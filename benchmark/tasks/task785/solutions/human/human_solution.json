[
  {
    "language": "Fortran",
    "code": "program a_sequence_of_permutations\n  implicit none\n  integer :: n, k, p(100000) = 0, q(100000) = 0, r(100000,2) = 0, i\n  read(*,*) n, k\n  read(*,*) p(1:n)\n  read(*,*) q(1:n)\n  if (k == 1) then\n    call output(p(1:n))\n    stop\n  end if\n  r(1:n,2) = q(1:n)\n  do i = 3, k\n    r(1:n,1) = p(1:n)\n    call quick_sort(r(1:n,:),1)\n    p(1:n) = q(1:n)\n    q(1:n) = r(1:n,2)\n  end do\n  call output(q(1:n))\ncontains\n  subroutine output(a)\n    integer, intent(in) :: a(:)\n    integer :: n, i\n    n = size(a)\n    write(*,'(i0)',advance='no') a(1)\n    do i = 2, n\n      write(*,'(x,i0)',advance='no') a(i)\n    end do\n    write(*,*)\n  end\n  recursive subroutine quick_sort(a,i)\n    integer, intent(inout) :: a(:,:)\n    integer, intent(in) :: i\n    integer :: n, l, r, m\n    integer :: p, b(size(a,2))\n    n = size(a,1)\n    l = 1\n    r = n\n    m = (l+r)/2\n    p = a(m,i)+a(l,i)+a(r,i)-max(a(m,i),a(l,i),a(r,i))-min(a(m,i),a(l,i),a(r,i))\n    do\n      do while (a(l,i) < p)\n        l = l+1\n      end do\n      do while (a(r,i) > p)\n        r = r-1\n      end do\n      if (l >= r) exit\n      b = a(l,:)\n      a(l,:) = a(r,:)\n      a(r,:) = b\n      l = l+1\n      r = r-1\n    end do\n    if (1 < l-1) call quick_sort(a(1:l-1,:),i)\n    if (r+1 < n) call quick_sort(a(r+1:n,:),i)\n  end\nend program a_sequence_of_permutations"
  },
  {
    "language": "Fortran",
    "code": "program a_sequence_of_permutations\n  implicit none\n  integer :: n, k, m, i\n  integer, allocatable :: p(:), q(:), a(:), b(:), c(:), d(:)\n  read(*,*) n, k\n  allocate(p(n),q(n),a(n),b(n),c(n),d(n))\n  read(*,*) p(1:n)\n  read(*,*) q(1:n)\n  select case (mod(k-1,6)+1)\n  case (1)\n    a = identity(n)\n    b = p\n  case (2)\n    a = identity(n)\n    b = q\n  case (3)\n    a = identity(n)\n    b = composite(q,inverse(p))\n  case (4)\n    a = q\n    b = inverse(p)\n  case (5)\n    a = composite(q,inverse(p))\n    b = inverse(q)\n  case (6)\n    a = composite(q,inverse(p))\n    b = composite(inverse(q),p)\n  end select\n  m = (k-1)/6\n  c = composite(composite(q,inverse(p)),composite(inverse(q),p))\n  d = identity(n)\n  do while (m > 0)\n    if (btest(m,0)) d = composite(c,d)\n    c = composite(c,c)\n    m = rshift(m,1)\n  end do\n  a = composite(a,d)\n  call output(composite(a,composite(b,inverse(a))))\ncontains\n  subroutine output(a)\n    integer, intent(in) :: a(:)\n    integer :: n, i\n    n = size(a)\n    write(*,'(i0)',advance='no') a(1)\n    do i = 2, n\n      write(*,'(x,i0)',advance='no') a(i)\n    end do\n    write(*,*)\n  end\n  function identity(n) result(ret)\n    integer, intent(in) :: n\n    integer :: ret(n), i\n    do i = 1, n\n      ret(i) = i\n    end do\n  end\n  function composite(a,b) result(ret)\n    integer, intent(in) :: a(:), b(:)\n    integer :: n, ret(size(a)), i\n    n = size(a)\n    do i = 1, n\n      ret(i) = a(b(i))\n    end do\n  end\n  function inverse(a) result(ret)\n    integer, intent(in) :: a(:)\n    integer :: n, ret(size(a)), i\n    n = size(a)\n    do i = 1, n\n      ret(a(i)) = i\n    end do\n  end\nend program a_sequence_of_permutations"
  },
  {
    "language": "Fortran",
    "code": "program a_sequence_of_permutations\n  implicit none\n  integer :: n, k, m, i\n  integer, allocatable, dimension(:) :: p, q, a, b, c, d\n  read(*,*) n, k\n  allocate(p(n),q(n),a(n),b(n),c(n),d(n))\n  read(*,*) p(1:n)\n  read(*,*) q(1:n)\n  select case (mod(k-1,6)+1)\n  case (1)\n    a = identity(n)\n    b = p\n  case (2)\n    a = identity(n)\n    b = q\n  case (3)\n    a = identity(n)\n    b = composite(q,inverse(p))\n  case (4)\n    a = q\n    b = inverse(p)\n  case (5)\n    a = composite(q,inverse(p))\n    b = inverse(q)\n  case (6)\n    a = composite(q,inverse(p))\n    b = composite(inverse(q),p)\n  end select\n  m = (k-1)/6\n  c = composite(composite(q,inverse(p)),composite(inverse(q),p))\n  d = identity(n)\n  do while (m > 0)\n    if (btest(m,0)) d = composite(c,d)\n    c = composite(c,c)\n    m = rshift(m,1)\n  end do\n  a = composite(d,a)\n  call output(composite(a,composite(b,inverse(a))))\ncontains\n  subroutine output(a)\n    integer, intent(in) :: a(:)\n    integer :: n, i\n    n = size(a)\n    write(*,'(i0)',advance='no') a(1)\n    do i = 2, n\n      write(*,'(x,i0)',advance='no') a(i)\n    end do\n    write(*,*)\n  end\n  function identity(n) result(ret)\n    integer, intent(in) :: n\n    integer :: ret(n), i\n    do i = 1, n\n      ret(i) = i\n    end do\n  end\n  function composite(a,b) result(ret)\n    integer, intent(in) :: a(:), b(:)\n    integer :: n, ret(size(a)), i\n    n = size(a)\n    do i = 1, n\n      ret(i) = a(b(i))\n    end do\n  end\n  function inverse(a) result(ret)\n    integer, intent(in) :: a(:)\n    integer :: n, ret(size(a)), i\n    n = size(a)\n    do i = 1, n\n      ret(a(i)) = i\n    end do\n  end\nend program a_sequence_of_permutations"
  },
  {
    "language": "Fortran",
    "code": "program a_sequence_of_permutations\n  implicit none\n  integer :: n, k, i, loop\n  integer :: p(100000), q(100000), p0(100000), q0(100000)\n  p = 0\n  q = 0\n  read(*,*) n, k\n  read(*,*) p(1:n)\n  read(*,*) q(1:n)\n  if (n.eq.1) then\n    write(*,'(i0)') 1\n    stop\n  end if\n  if (k.eq.1) then\n    write(*,'(i0)',advance='no') p(1)\n    do i = 2, n\n      write(*,'(x,i0)',advance='no') p(i)\n    end do\n    write(*,*)\n    stop\n  else if (k.eq.2) then\n    write(*,'(i0)',advance='no') q(1)\n    do i = 2, n\n      write(*,'(x,i0)',advance='no') q(i)\n    end do\n    write(*,*)\n    stop\n  end if\n  p0 = p\n  q0 = q\n  loop = -1\n  do i = 3, k\n    call swap(n,p(1:n),q(1:n))\n    if ((sum(abs(p(1:n)-p0(1:n))).eq.0).and.(sum(abs(q(1:n)-q0(1:n))).eq.0)) then\n      loop = i-2\n      exit\n    end if\n  end do\n  if (loop.gt.0) then\n    k = mod(k,loop) + 1\n    if (k.eq.1) then\n      write(*,'(i0)',advance='no') p(1)\n      do i = 2, n\n        write(*,'(x,i0)',advance='no') p(i)\n      end do\n      write(*,*)\n      stop\n    else if (k.eq.2) then\n      write(*,'(i0)',advance='no') q(1)\n      do i = 2, n\n        write(*,'(x,i0)',advance='no') q(i)\n      end do\n      write(*,*)\n      stop\n    end if\n    do i = 3, k\n      call swap(n,p(1:n),q(1:n))\n    end do\n  end if\n  write(*,'(i0)',advance='no') q(1)\n  do i = 2, n\n    write(*,'(x,i0)',advance='no') q(i)\n  end do\n  write(*,*)\n  stop\ncontains\n  subroutine swap(n,p,q)\n    implicit none\n    integer, intent(inout) :: n, p(n), q(n)\n    integer :: r(n), i\n    do i = 1, n\n      r(p(i)) = q(i)\n    end do\n    p = q\n    q = r\n    return\n  end subroutine swap\nend program a_sequence_of_permutations"
  },
  {
    "language": "Fortran",
    "code": "program a_sequence_of_permutations\n  implicit none\n  integer :: n, k, p(100000) = 0, q(100000) = 0, r(100000,2) = 0, i\n  read(*,*) n, k\n  read(*,*) p(1:n)\n  read(*,*) q(1:n)\n  if (k < 3) then\n    if (k == 1) then\n      call output(p(1:n))\n    else\n      call output(q(1:n))\n    end if\n    stop\n  end if\n  do i = 3, k\n    r(1:n,1) = p(1:n)\n    r(1:n,2) = q(1:n)\n    call quick_sort(r(1:n,:),1)\n    p(1:n) = q(1:n)\n    q(1:n) = r(1:n,2)\n  end do\n  call output(q(1:n))\ncontains\n  subroutine output(a)\n    integer, intent(in) :: a(:)\n    integer :: n, i\n    n = size(a)\n    write(*,'(i0)',advance='no') a(1)\n    do i = 2, n\n      write(*,'(x,i0)',advance='no') a(i)\n    end do\n    write(*,*)\n  end\n  recursive subroutine quick_sort(a,i)\n    integer, intent(inout) :: a(:,:)\n    integer, intent(in) :: i\n    integer :: n, l, r, m\n    integer :: p, b(size(a,2))\n    n = size(a,1)\n    l = 1\n    r = n\n    m = (l+r)/2\n    p = a(m,i)+a(l,i)+a(r,i)-max(a(m,i),a(l,i),a(r,i))-min(a(m,i),a(l,i),a(r,i))\n    do\n      do while (a(l,i) < p)\n        l = l+1\n      end do\n      do while (a(r,i) > p)\n        r = r-1\n      end do\n      if (l >= r) exit\n      b = a(l,:)\n      a(l,:) = a(r,:)\n      a(r,:) = b\n      l = l+1\n      r = r-1\n    end do\n    if (1 < l-1) call quick_sort(a(1:l-1,:),i)\n    if (r+1 < n) call quick_sort(a(r+1:n,:),i)\n  end\nend program a_sequence_of_permutations"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 100010\n#define maxm 100010\n#define inf 1000000007\n#define mod 1000000007\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int>pii;\ntypedef bitset<maxn> bit;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,K;\nint p[maxn],q[maxn],inv_p[maxn],inv_q[maxn];\nvoid inv(int *A,int *B)\n{\n    for(int i=1;i<=n;i++)  B[A[i]]=i;\n}\nvoid init(int *A)\n{\n    for(int i=1;i<=n;i++)  A[i]=i;\n}\nint tmp[maxn],tmpx[maxn];\nvoid mul(int *A,int *B,int *C)\n{\n    for(int i=1;i<=n;i++)  tmp[i]=A[B[i]];\n    for(int i=1;i<=n;i++)  C[i]=tmp[i];\n}\nint a[7][maxn];\nvoid quick_pow(int *A,int p,int *C)\n{\n    init(C);\n    while(p)\n    {\n        if(p&1)  mul(C,A,C);\n        mul(A,A,A);\n        p>>=1;\n    }\n}\nint res[maxn];\nint main()\n{\n    n=read();K=read();\n    for(int i=1;i<=n;i++)  p[i]=read();\n    for(int i=1;i<=n;i++)  q[i]=read();\n    inv(p,inv_p);inv(q,inv_q);\n    int A[maxn],B[maxn];\n    init(A);\n    mul(A,q,A);mul(A,inv_p,A);\n    mul(A,inv_q,A);mul(A,p,A);\n    for(int i=1;i<=n;i++)  a[1][i]=p[i],a[2][i]=q[i];\n    for(int i=3;i<=6;i++)\n    {\n        inv(a[i-2],tmpx);\n        mul(a[i-1],tmpx,a[i]);\n    }\n    int m=(K-1)/6;\n    quick_pow(A,m,B);\n    for(int i=1;i<=n;i++)  res[i]=B[i];\n    mul(res,a[K-6*m],res);\n    inv(B,A);\n    mul(res,A,res);\n    for(int i=1;i<=n;i++)  printf(\"%d \",res[i]);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<18;\nint n;\nvoid Inv(int a[],int b[])\n{\n    for(int i=1;i<=n;i++)\n        b[a[i]]=i;\n}\nint tmp[Q],cmp[Q];\nvoid Mul(int a[],int b[],int c[])\n{\n    for(int i=1;i<=n;i++)\n        tmp[i]=a[b[i]];\n    for(int i=1;i<=n;i++)\n        c[i]=tmp[i];\n}\nint p[Q],q[Q];\nvoid R(int a[])\n{\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n}\nint owo[10][Q],cc[Q];\nvoid F(int p[],int q[],int f[])\n{\n    Inv(p,cc);\n    Mul(q,cc,f);\n}\nvoid Ksm(int a[],int b)\n{\n    for(int i=1;i<=n;i++)cmp[i]=i,cc[i]=a[i];\n    for(;b;b>>=1,Mul(cc,cc,cc))\n        if(b&1)Mul(cmp,cc,cmp);\n    for(int i=1;i<=n;i++)\n        a[i]=cmp[i];\n}\nint A[Q],ip[Q],iq[Q],IA[Q];\nint main()\n{\n    int k;\n    scanf(\"%d%d\",&n,&k);\n    R(p),R(q);\n    for(int i=1;i<=n;i++)\n        owo[1][i]=p[i],owo[2][i]=q[i],owo[0][i]=i;\n    for(int i=3;i<6;i++)\n        F(owo[i-2],owo[i-1],owo[i]);\n    int rel=k%6;\n    for(int i=1;i<=n;i++)A[i]=q[i];\n    Inv(p,ip),Inv(q,iq);\n    Mul(A,ip,A);\n    Mul(A,iq,A);\n    Mul(A,p,A);\n    Inv(A,IA);\n    Ksm(A,k/6),Ksm(IA,k/6);\n    Mul(A,owo[rel],A);\n    Mul(A,IA,A);\n    for(int i=1;i<=n;i++)\n        printf(\"%d \",A[i]);\n    return 0;\n}\n/*\n10 6\n7 10 6 5 4 2 9 1 3 8\n4 1 9 2 3 7 8 10 6 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e5+20;\n\nint n,k;\nvector<int>p,q,invp,invq;\n\ninline vector<int> Get_Inversion(vector<int>p)\n{\n\tstatic vector<int>invp(n+1);\n\tREP(i,1,n)invp[p[i]]=i;\n\treturn invp;\n}\n\ninline vector<int> operator *(vector<int>p,vector<int>q)\n{\n\tREP(i,1,n)p[i]=q[p[i]];\n\treturn p;\n}\n\ninline void init()\n{\n\tn=read();k=read(); p.resize(n+1); q.resize(n+1);\n\tREP(i,1,n)p[i]=read();\n\tREP(i,1,n)q[i]=read();\n\tinvp=Get_Inversion(p); invq=Get_Inversion(q);\n}\n\ninline vector<int>power(vector<int>a,int b)\n{\n\tstatic int vis[maxn];\n\tmemset(vis,0,sizeof(int)*(n+1));\n\tREP(i,1,n)if(!vis[i])\n\t{\n\t\tstatic int st[maxn]; int top=0;\n\t\tfor(int j=i;!vis[j];j=a[j])vis[j]=1,st[top++]=j;\n\t\t//int turn=b%top;\n\t\tREP(j,0,top-1)a[st[j]]=st[(j+b)%top];\n\t}\n\treturn a;\n}\n\ninline void doing()\n{\n\tvector<int>A=invq*p*q*invp,invA=Get_Inversion(A);\n\tvector<int>f[8];\n\tf[1]=p; f[2]=q;\n\tREP(i,3,6)f[i]=Get_Inversion(f[i-2])*f[i-1];\n\tint tk=(k-1)/6,rest=k-tk*6;\n\tA=power(A,tk); invA=power(invA,tk);\n\tvector<int>debug=Get_Inversion(A);\n\tvector<int>ans=A*f[rest]*invA;\n\tREP(i,1,n)printf(\"%d \",ans[i]);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=1e5+100;\nstruct node{\n\tint a[N];\n};int n;\nnode cheng(node n1,node n2){\n\tnode no;\n\tfor(int i=1;i<=n;i++) no.a[i]=n2.a[n1.a[i]];\n\treturn no;\n}\nnode ni(node n1){\n\tnode no;\n\tfor(int i=1;i<=n;i++) no.a[n1.a[i]]=i;\n\treturn no;\n}\nnode mi(node x,int t){\n\tnode d;\n\tfor(int i=1;i<=n;i++) d.a[i]=i;\n\twhile(t){\n\t\tif(t%2) d=cheng(d,x);\n\t\tx=cheng(x,x);t/=2;\n\t}\n\treturn d;\n}\nint main()\n{\n\tint K;\n\tscanf(\"%d%d\",&n,&K);\n\tnode n1,n2;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&n1.a[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&n2.a[i]);\n\t/*if(K<=2){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(K==1) printf(\"%d\",n1.a[i]);\n\t\t\telse printf(\"%d\",n2.a[i]);\n\t\t\tif(i<n) printf(\" \");\n\t\t\telse printf(\"\\n\");\n\t\t}\n\t\treturn 0;\n\t}*/\n\tint t=(K-1)%6+1;\n\tif(t>=2){\n\t\tfor(int i=3;i<=t;i++){\n\t\t\tnode T=n2;\n\t\t\tn2=cheng(ni(n1),n2);\n\t\t\tn1=T;\n\t\t}\n\t\tn1=n2;\n\t}\n\tnode A=cheng(ni(n2),n1);\n\tA=cheng(A,n2);A=cheng(A,ni(n1));\n\tA=mi(A,(K-t)/6);\n\tnode ans=cheng(A,n1);ans=cheng(ans,ni(A));\n\tfor(int i=1;i<=n;i++){\n\t\tprintf(\"%d\",ans.a[i]);\n\t\tif(i<n) printf(\" \");\n\t\telse printf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define int long long\n#define vi vector<int>\nusing namespace std;\nint n, k;\nvi A, a[6];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nvi inv(vi x)\n{\n\tvi res(n);\n\tfor(int i = 0; i < n; i ++) res[x[i]] = i;\n\treturn res;\n}\nvi mul(vi p, vi q)\n{\n\tvi res(n);\n\tfor(int i = 0; i < n; i ++) res[i] = p[q[i]];\n\treturn res;\n}\nvi ksm(vi x, int y)\n{\n\tvi res(n);\n\tfor(int i = 0; i < n; i ++) res[i] = i;\n\tfor(; y; y >>= 1, x = mul(x, x))\n\t\tif(y & 1) res = mul(res, x);\n\treturn res;\n}\nsigned main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); k = read() - 1;\n\ta[0].resize(n); for(int i = 0; i < n; i ++) a[0][i] = read() - 1;\n\ta[1].resize(n); for(int i = 0; i < n; i ++) a[1][i] = read() - 1;\n\tfor(int i = 2; i < 6; i ++) a[i] = mul(a[i - 1], inv(a[i - 2]));\n\tif(k < 6)\n\t{\n\t\tfor(int i = 0; i < n; i ++) printf(\"%lld \", a[k][i] + 1);\n\t\treturn 0;\n\t}\n\tA = ksm(mul(mul(a[1], inv(a[0])), mul(inv(a[1]), a[0])), k / 6);\n\tA = mul(mul(A, a[k % 6]), inv(A));\n\tfor(int i = 0; i < n; i ++) printf(\"%lld \", A[i] + 1);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 100010\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint tmp[N],n,k;\nvoid per(int *a,int *p)\n{\n\tfor(int i=1;i<=n;i++)\ttmp[i]=a[p[i]];\n\tfor(int i=1;i<=n;i++)\ta[i]=tmp[i];\n}\nint p[N],q[N],bs[6][N],a[N],g[N],b[N],ip[N],iq[N],ig[N],ans[N];\nint main()\n{\n\tn=read(),k=read()-1;\n\tfor(int i=1;i<=n;i++)\tbs[0][i]=p[i]=read(),ip[p[i]]=i;\n\tfor(int i=1;i<=n;i++)\tbs[1][i]=q[i]=read(),iq[q[i]]=i;\n\tfor(int k=2;k<6;k++)\n\t\tfor(int i=1;i<=n;i++)\tbs[k][bs[k-2][i]]=bs[k-1][i];\n\tint mi=k/6;\n\tfor(int i=1;i<=n;i++)\tg[i]=i,b[i]=i;\n\tper(b,q); per(b,ip); per(b,iq); per(b,p);\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tper(g,b);\n\t\tper(b,b); mi>>=1;\n\t}\n\tfor(int i=1;i<=n;i++)\tig[g[i]]=i;\n\tfor(int i=1;i<=n;i++)\tans[i]=i;\n\tper(ans,g); per(ans,bs[k%6]); per(ans,ig);\n\tfor(int i=1;i<=n;i++)\tprintf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug_v(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\n//{{{ io\nFILE *file_in=stdin,*file_out=stdout;\n#define fin normal_in\n#define fout normal_out\n//const char fname[]=\"\";\n//FILE *fin=fopen(fname,\"r\"),*fout=fopen(fname,\"w\");\n#ifdef __MINGW32__\n#define LLD \"%I64d\"\n#define LLU \"%I64u\"\n#else\n#define LLD \"%lld\"\n#define LLU \"%llu\"\n#endif\nstruct NORMAL_IN{\n\tbool cnt;\n\tNORMAL_IN():cnt(true){}\n\toperator int() const {return cnt;}\n#define endl \"\\n\"\n\tNORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,\"%d\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,\"%u\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,\"%lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,\"%Lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,\"%s\",c)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(string &s){\n\t\ts.clear();\n\t\tfor(bool r=false;;){\n\t\t\tconst char c=getchar();\n\t\t\tif(c==EOF){ cnt=false; break;}\n\t\t\tconst int t=isspace(c);\n\t\t\tif(!r and !t)r=true;\n\t\t\tif(r){\n\t\t\t\tif(!t)s.push_back(c);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\t\tNORMAL_IN& operator>>(vector<T> &v){\n\t\t\tint v_size = v.size();\n\t\t\tREP(i,v_size){\n\t\t\t\t*this>>v[i];\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n} normal_in;\n\nstruct NORMAL_OUT{\n\tNORMAL_OUT& operator<<(const int &n){fprintf(file_out,\"%d\",n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,\"%u\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}\n\tNORMAL_OUT& operator<<(const double &n){fprintf(file_out,\"%lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long double &n){fprintf(file_out,\"%Lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const char c[]){fprintf(file_out,\"%s\",c);return *this;}\n\tNORMAL_OUT& operator<<(const string &s){fprintf(file_out,\"%s\",s.c_str());return *this;}\n} normal_out;\nstruct ERR_OUT{\n\ttemplate<class T>\n\t\tERR_OUT& operator<<(const T &a){\n\t\t\tcerr<<\"\\x1b[7m\"<<a<<\"\\x1b[m\";\n\t\t\treturn *this;\n\t\t}\n} ferr;\n//}}}\n\n\n\nInt N;\nInt K;\nvector<int> p;\nvector<int> q;\n\nvector<int> id(){\n\tvector<int> r(N);\n\tREP(i,N)r[i] = i;\n\treturn r;\n}\n\nvector<int> comp(const vector<int> &p, const vector<int> &q){\n\tvector<int> r(N);\n\tREP(i,N)r[i] = p[q[i]];\n\treturn r;\n}\nvector<int> inv(const vector<int> &p){\n\tvector<int> r(N);\n\tREP(i,N)r[p[i]] = i;\n\treturn r;\n}\nvector<int> pow(const vector<int> &p, int k){\n\tif(k==0)return id();\n\tauto r = pow(p,k/2);\n\tr = comp(r,r);\n\tif(k%2==1)r = comp(r,p);\n\treturn r;\n}\n\nvoid solve(){\n\tif(K==1){\n\t\tREP(i,N)fout<<p[i]+1<<\" \";\n\t\tfout<<endl;\n\t\treturn;\n\t}else if(K==2){\n\t\tREP(i,N)fout<<q[i]+1<<\" \";\n\t\tfout<<endl;\n\t\treturn;\n\t}\n\tvector<int> A, B;\n\tA.reserve(N);\n\tB.reserve(N);\n\tswitch(K%6){\n\tcase 0:\n\t\tA = comp(inv(q),p);\n\t\tbreak;\n\tcase 1:\n\t\tA = p;\n\t\tbreak;\n\tcase 2:\n\t\tA = q;\n\t\tbreak;\n\tcase 3:\n\t\tA = comp(q,inv(p));\n\t\tbreak;\n\tcase 4:\n\t\tA = inv(p);\n\t\tbreak;\n\tcase 5:\n\t\tA = inv(q);\n\t\tbreak;\n\tdefault:\n\t\tassert(false);\n\t}\n\tint K2 = K-2;\n\tB = comp(comp(q,inv(p)),comp(inv(q),p));\n\tB = pow(B,K2/6);\n\tint rem = K2%6;\n\tdo{\n\t\tif(rem<=1)break;\n\t\tB = comp(B,q);\n\t\tif(rem<=2)break;\n\t\tB = comp(B,inv(p));\n\t\tif(rem<=4)break;\n\t\tB = comp(B,inv(q));\n\t}while(0);\n\tauto r = comp(comp(B,A),inv(B));\n\tREP(i,N){\n\t\tfout<<r[i]+1;\n\t\tif(i<N-1){\n\t\t\tfout<<\" \";\n\t\t}\n\t}\n\tfout<<endl;\n}\n\n\n//{{{ main function\nint main(){\n\tfin >> N;\n\tfin >> K;\n\tp.assign(N,Int());\n\tfor(int i = 0 ; i < N ; i++){\n\t\tfin >> p[i];\n\t\tp[i]--;\n\t}\n\tq.assign(N,Int());\n\tfor(int i = 0 ; i < N ; i++){\n\t\tfin >> q[i];\n\t\tq[i]--;\n\t}\n\tsolve();\n\treturn 0;\n}\n\n//}}}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking\n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define inf 2147480000\nusing namespace std;\nint n,k;\nstruct perm{\n\tint a[100005];\n\tperm operator +(const perm &b)const{\n\t\tperm c;\n\t\tFor(i,1,n) c.a[i]=a[b.a[i]];\n\t\treturn c;\n\t}\n\tperm operator -(const perm &b)const{\n\t\tperm c,d;\n\t\tFor(i,1,n) d.a[b.a[i]]=i;\n\t\tFor(i,1,n) c.a[i]=a[d.a[i]];\n\t\treturn c;\n\t}\n\tvoid init(){\n\t\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\t}\n}a,b;\nvoid output(perm a){\n\tFor(i,1,n) printf(\"%d \",a.a[i]);\n\tputs(\"\");\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\ta.init();\n\tb.init();\n\tif (k==1) return output(a),0;\n\tif (k==2) return output(b),0;\n\tint T=(k-1)/6;\n\tperm tmp,S;\n\tFor(i,1,n) tmp.a[i]=i;\n\tS=b-a-b+a;\n\tfor (;T;T>>=1,S=S+S)\n\t\tif (T&1) tmp=tmp+S;\n\ta=tmp+a-tmp;\n\tb=tmp+b-tmp;\n\tk-=(k-1)/6*6;\n\tFor(i,3,k){\n\t\tperm c=b-a;\n\t\ta=b; b=c;\n\t}\n\toutput(b);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e5 + 5;\n\n/*vector<char> s[3];\n\nvoid output(int ind) {\n\tREP(i, 0, SZ(s[ind])) {\n\t\tputchar(s[ind][i]);\n\t}\n\tputchar('\\n');\n}*/\n\nint n;\nint A[MAXN], B[MAXN], a[MAXN], b[MAXN];\nint BabA[MAXN], aBAb[MAXN], _left[MAXN], _right[MAXN];\nint ans[MAXN];\n\nvoid output(int *per) {\n\tREP(i, 0, n) {\n\t\tprintf(\"%d \", per[i] + 1);\n\t}\n\tputchar('\\n');\n}\n\nvoid mul(int * per1, int * per2, int *res) {\n\tREP(i, 0, n) {\n\t\tres[i] = per2[per1[i]];\n\t}\n}\n\nint tmp_per[MAXN];\nvoid mul_by(int *per, int *per_by) {\n\tREP(i, 0, n) {\n\t\ttmp_per[i] = per[i];\n\t}\n\tmul(tmp_per, per_by, per);\n}\n\nint pow_per[MAXN];\nvoid pow_mod(int * per, int st, int *res) {\n\tREP(i, 0, n) {\n\t\tres[i] = i;\n\t\tpow_per[i] = per[i];\n\t}\n\tfor(; st; st /= 2) {\n\t\tif (st & 1) {\n\t\t\tmul_by(res, pow_per);\n\t\t}\n\t\tREP(i, 0, n) {\n\t\t\ttmp_per[i] = pow_per[i];\n\t\t}\n\t\tmul(tmp_per, tmp_per, pow_per);\n\t}\n}\n\nvoid solve(){\n\t/*s[1].pb('A');\n\ts[2].pb('B');\n\toutput(1);\n\toutput(2);\n\tREP(i, 3, 30) {\n\t\tint ind = i % 3, ind1 = (i + 1) % 3, ind2 = (i + 2) % 3;\n\t\ts[ind] = s[ind2];\n\t\tfor(int i = SZ(s[ind1]) - 1; i >= 0; i--) {\n\t\t\tchar cur = s[ind1][i];\n\t\t\tif (cur == s[ind].back()) {\n\t\t\t\ts[ind].pop_back();\n\t\t\t} else {\n\t\t\t\tif (cur <= 'B') {\n\t\t\t\t\tcur += 'b' - 'B';\n\t\t\t\t} else {\n\t\t\t\t\tcur -= 'b' - 'B';\n\t\t\t\t}\n\t\t\t\ts[ind].pb(cur);\n\t\t\t}\n\t\t}\n\t\toutput(ind);\n\t}*/\n\tint k;\n\tscanf(\"%d%d\", &n, &k);\n\tREP(i, 0, n) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tA[i]--;\n\t\ta[A[i]] = i;\n\t}\n\tREP(i, 0, n) {\n\t\tscanf(\"%d\", &B[i]);\n\t\tB[i]--;\n\t\tb[B[i]] = i;\n\t}\n\t\n\tif (k == 1) {\n\t\toutput(A);\n\t\treturn;\n\t}\n\tif (k == 2) {\n\t\toutput(B);\n\t\treturn;\n\t}\n\t\n\tint l1 = (k / 3 * 2 + k % 3);\n\tint l2 = ((k - 4) / 3 * 2 + (k - 4) % 3);\n\tif (k <= 4) {\n\t\tl2 = 0;\n\t}\n\t\n\tREP(i, 0, n) {\n\t\tBabA[i] = A[i];\n\t}\n\tmul_by(BabA, b);\n\tmul_by(BabA, a);\n\tmul_by(BabA, B);\n\t\n\tREP(i, 0, n) {\n\t\taBAb[i] = b[i];\n\t}\n\tmul_by(aBAb, A);\n\tmul_by(aBAb, B);\n\tmul_by(aBAb, a);\n\t\n\tpow_mod(BabA, l1 / 4, _left);\n\tpow_mod(aBAb, l2 / 4, _right);\n\t\n\tREP(i, 0, n) {\n\t\tans[i] = _right[i];\n\t}\n\tif (l2 % 4 >= 1) {\n\t\tmul_by(ans, b);\n\t}\n\tif (l2 % 4 >= 2) {\n\t\tmul_by(ans, A);\n\t}\n\tif (l2 % 4 >= 3) {\n\t\tmul_by(ans, B);\n\t}\n\tif (l1 % 4 >= 3) {\n\t\tmul_by(ans, b);\n\t}\n\tif (l1 % 4 >= 2) {\n\t\tmul_by(ans, a);\n\t}\n\tif (l1 % 4 >= 2) {\n\t\tmul_by(ans, B);\n\t}\n\tmul_by(ans, _left);\n\toutput(ans);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,k,p[100010],q[100010],A[100010],pv[100010],qv[100010],Av[100010],ans[100010],a[7][100010];\nvoid mul(int a[],int b[],int c[])\n{\n\tstatic int X[100010];\n\tfor(int i=1;i<=n;++i)X[i]=a[b[i]];\n\tmemcpy(c+1,X+1,n<<2);\n}\nvoid kpow(int a[],int b,int c[])\n{\n\tstatic bool vis[100010];\n\tstatic int st[100010],tp,X[100010];\n\tmemset(vis+1,0,n);\n\tfor(int i=1;i<=n;++i)\n\t\tif(!vis[i])\n\t\t{\n\t\t\tint x=i;tp=0;\n\t\t\twhile(!vis[x])st[++tp]=x,vis[x]=1,x=a[x];\n\t\t\tfor(int j=1;j<=tp;++j)X[st[j]]=st[(j+b-1)%tp+1];\n\t\t}\n\tmemcpy(c+1,X+1,n<<2);\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&k);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&p[i]),pv[p[i]]=i;\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&q[i]),qv[q[i]]=i;\n\tmemcpy(A+1,q+1,n<<2);\n\tmul(A,pv,A);\n\tmul(A,qv,A);\n\tmul(A,p,A);\n\tfor(int i=1;i<=n;++i)Av[A[i]]=i;\n//\tfor(int i=1;i<=n;++i)printf(\"%d \",A[i]);printf(\"\\n\");\n//\tfor(int i=1;i<=n;++i)printf(\"%d \",Av[i]);printf(\"\\n\");\t\t\n\tkpow(A,(k-1)/6,A);\n\tkpow(Av,(k-1)/6,Av);\n//\tfor(int i=1;i<=n;++i)printf(\"%d \",A[i]);printf(\"\\n\");\n//\tfor(int i=1;i<=n;++i)printf(\"%d \",Av[i]);printf(\"\\n\");\t\n\tmemcpy(ans+1,A+1,n<<2);\n\tmemcpy(a[1]+1,p+1,n<<2);memcpy(a[2]+1,q+1,n<<2);\n\tfor(int i=3;i<=(k-1)%6+1;++i)\n\t\tfor(int j=1;j<=n;++j)a[i][a[i-2][j]]=a[i-1][j];\n\tmul(ans,a[(k-1)%6+1],ans);\n\tmul(ans,Av,ans);\n\tfor(int i=1;i<=n;++i)printf(\"%d \",ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\ntypedef vector<int> vi;\n\nint norm(int x, int m) {\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nvi power(const vi& p, int k) {\n  int n = p.size();\n  vector<bool> vis(n);\n  vi ret(n);\n  for (int i = 0; i < n; ++i)\n    if (!vis[i]) {\n      vector<int> cycle;\n      int x = i;\n      while (!vis[x]) {\n        cycle.push_back(x);\n        vis[x] = true;\n        x = p[x];\n      }\n      for (int i = 0; i < cycle.size(); ++i)\n        ret[cycle[i]] = cycle[norm(i + k, cycle.size())];\n    }\n  return ret;\n}\n\nvi inverse(const vi& p) { return power(p, -1); }\n\nvi mult(const vi& p, const vi& q) {\n  int n = p.size();\n  vi ret(n);\n  for (int i = 0; i < n; ++i)\n    ret[i] = p[q[i]];\n  return ret;\n}\n\ntemplate <class T, class... Args>\nvi mult(const T& first, const Args&... args...) {\n  return mult(first, mult(args...));\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  \n  int n, k;\n  cin >> n >> k;\n  --k;\n  vi p(n), q(n);\n  cin >> p >> q;\n  for (int& v : p) --v;\n  for (int& v : q) --v;\n  vi ip = inverse(p), iq = inverse(q), w = mult(q, ip, iq, p);\n  int m = k / 6;\n  static vi little[6];\n  little[0] = mult(power(w, m), q, p, iq, power(w, 1 - m));\n  little[1] = mult(power(w, m), q, power(w, -m));\n  int r = k % 6;\n  for (int i = 2; i <= r; ++i)\n    little[i] = mult(little[i - 1], inverse(little[i - 2]));\n  vi ans = little[r];\n  for (int& v : ans) ++v;\n  cout << ans << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> inverse(vector<int> a) {\n  int n = (int) a.size();\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[a[i]] = i;\n  }\n  return ret;\n}\n\nvector<int> multiple(vector<int> a, vector<int> b) {\n  int n = (int) a.size();\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[i] = a[b[i]];\n  }\n  return ret;\n}\n\nvector<int> power(vector<int> a, int b) {\n  int n = (int) a.size();\n  vector<int> ret(n);\n  iota(ret.begin(), ret.end(), 0);\n  while (b) {\n    if (b & 1) {\n      ret = multiple(ret, a);\n    }\n    b >>= 1;\n    ret = multiple(ret, ret);\n  }\n  return ret;\n}\n\nvoid output(vector<int> a) {\n  for (int i = 0; i < (int) a.size(); i++) {\n    if (i) {\n      cout << \" \";\n    }\n    cout << a[i] + 1;\n  }\n  cout << '\\n';\n  exit(0);\n}\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> p(n), q(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    p[i]--;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> q[i];\n    q[i]--;\n  }\n  if (k == 1) {\n    output(p);\n  }\n  vector<vector<int>> l(6);\n  l[0] = q;\n  l[1] = multiple(l[0], inverse(p));\n  l[2] = multiple(l[1], inverse(q));\n  l[3] = multiple(l[2], multiple(p, inverse(q)));\n  l[4] = multiple(l[2], multiple(p, multiple(p, inverse(q))));\n  l[5] = multiple(l[2], multiple(p, multiple(q, multiple(p, inverse(q)))));\n  vector<int> bABa = multiple(q, multiple(inverse(p), multiple(inverse(q), p)));\n  vector<int> AbaB = multiple(inverse(p), multiple(q, multiple(p, inverse(q))));\n  vector<int> f = power(AbaB, (k - 2) / 6);\n  f = multiple(l[(k - 2) % 6], f);\n  f = multiple(power(bABa, (k - 2) / 6), f);\n  output(f);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nvector<int> inv(vector<int> vec) {\n    int N = vec.size();\n    vector<int> res(N);\n    for(int i=0; i<N; i++) {\n        res[ vec[i] ] = i;\n    }\n    return res;\n}\n\nvector<int> mul(vector<int> A, vector<int> B) {\n    int N = A.size();\n    vector<int> res(N);\n    for(int i=0; i<N; i++) {\n        res[i] = A[ B[i] ];\n    }\n    return res;\n}\n\nvector<int> mod_pow(vector<int> A, int k) {\n    int N = A.size();\n    vector<int> res(N);\n    iota(res.begin(), res.end(), 0);\n    for(; k>0; k>>=1) {\n        if(k & 1) res = mul(res, A);\n        A = mul(A, A);\n    }\n    return res;\n}\n\nsigned main() {\n    int N, K; cin >> N >> K;\n    vector<int> p(N), q(N);\n    for(int i=0; i<N; i++) cin >> p[i], p[i]--;\n    for(int i=0; i<N; i++) cin >> q[i], q[i]--;\n    vector<int> ip = inv(p), iq = inv(q);\n\n    // vector<int> prod = mul(mul(mul(q, ip), iq), p);\n    vector<int> prod = mul(q, mul(ip, mul(iq, p)));\n    vector<int> A = mod_pow(prod, (K - 1) / 6);\n\n    int mod = (K - 1) % 6;\n    vector<int> B;\n    if(mod == 0) B = p;\n    else if(mod == 1) B = q;\n    else {\n        vector<int> X = p, Y = q;\n        for(int i=0; i<mod-1; i++) {\n            vector<int> Z = mul(Y, inv(X));\n            X = Y, Y = Z;\n        }\n        B = Y;\n    }\n\n    vector<int> ans = mul(mul(A, B), inv(A));\n    for(int i=0; i<N; i++) {\n        printf(\"%lld%c\", ans[i] + 1, i+1 == N ? '\\n' : ' ');\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n#ifdef LOCAL\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else \n#define dump(x) true\n#endif\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nV<int> inv(const V<int>& a) {\n\tV<int> res(a.size());\n\trep(i, a.size()) {\n\t\tres[a[i]] = i;\n\t}\n\treturn res;\t\n}\n\nV<int> comp(const V<int>& a, const V<int>& b) { // a * b\n\tV<int> res(a.size());\n\trep(i, a.size()) {\n\t\tres[i] = a[b[i]];\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N, K; cin >> N >> K;\n\tV<int> p(N), q(N);\n\trep(i, N) {\n\t\tcin >> p[i], --p[i];\n\t}\n\trep(i, N) {\n\t\tcin >> q[i], --q[i];\n\t}\n\n\tV<int> id(N); //mod 6\n\tiota(ALL(id), 0);\n\n\t{\n\t\tint cyc = (K - 1) / 6;\n\t\tV<int> base = comp(inv(q), p);\n\t\tbase = comp(inv(p), base);\n\t\tbase = comp(q, base);\n\n\t\twhile (cyc > 0) {\n\t\t\tif (cyc & 1) {\n\t\t\t\tid = comp(base, id);\n\t\t\t}\n\t\t\tbase = comp(base, base);\n\t\t\tcyc /= 2;\n\t\t}\n\t}\n\n\tint rem = (K - 1) % 6;\n\tp = comp(id, p);\n\tp = comp(p, inv(id));\n\tq = comp(id, q);\n\tq = comp(q, inv(id));\n\n\trep(i, rem) {\n\t\tV<int> nx = comp(q, inv(p));\n\t\tp = q;\n\t\tq = nx;\n\t}\n\n\trep(i, N) {\n\t\tprintf(\"%d%c\", p[i], i == N-1 ? '\\n' : ' ');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define vi vector<int>\nint n,k;\nvi a[15];\nint read()\n{\n\tchar c=getchar();\n\tint res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nvi inv(vi a)\n{\n\tvi b;b.resize(n);\n\tfor(int i=0;i<n;i++) b[a[i]]=i;\n\treturn b;\n}\nvi mul(vi a,vi b)\n{\n\tvi c;c.resize(n);\n\tfor(int i=0;i<n;i++) c[i]=a[b[i]];\n\treturn c;\n}\nvi ksm(vi x,int n)\n{\n\tvi ans;ans.resize(n);\n\tfor(int i=0;i<n;i++) ans[i]=i;\n\twhile(n)\n\t{\n\t\tif(n&1) ans=mul(ans,x);\n\t\tx=mul(x,x);\n\t\tn>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\ta[1].resize(n);for(int i=0;i<n;i++) a[1][i]=read(),a[1][i]--;\n\ta[2].resize(n);for(int i=0;i<n;i++) a[2][i]=read(),a[2][i]--;\n\tfor(int i=3;i<=6;i++) a[i]=mul(a[i-1],inv(a[i-2]));\n\tif(k<=6)\n\t{\n\t\tfor(int i=0;i<n;i++) printf(\"%d \",a[k][i]+1);\n\t\treturn 0;\n\t}\n\tvi A=mul(mul(a[2],inv(a[1])),mul(inv(a[2]),a[1]));\n\tA=ksm(A,(k-1)/6);\n\tA=mul(mul(A,a[(k-1)%6+1]),inv(A));\n\tfor(int i=0;i<n;i++) printf(\"%d \",A[i]+1);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 102000;\nint n,k;\nvoid print(Vi a){\n\tassert(SZ(a)==n);\n\trep(i,0,n-1)printf(\"%d \",a[i]+1);puts(\"\");\n}\nVi inv(Vi a){\n//\tputs(\"QaQ\");print(a);\n\tVi b(n,0);//rep(i,0,n-1)assert(a[i]<n);\n\trep(i,0,n-1)b[a[i]]=i;\n\treturn b;\n}\nVi operator *(const Vi &p, const Vi &q){\n//\tputs(\"OwO\");print(q);print(q);\n\tVi a(n,0);\n\trep(i,0,n-1)a[i]=q[p[i]];\n\treturn a;\n}\nVi mul(Vi p, Vi q){return p*q;}\nVi power(Vi a, int t){\n\tassert(SZ(a)==n);//t & n!!\n\tVi res(n,0);rep(i,0,n-1)res[i]=i;\n\twhile(t){\n\t\tif(t&1)res=res*a;a=a*a;t>>=1;\n\t}\n\tassert(SZ(res)==n);\n\treturn res;\n}\nchar flip(char c){return c>='a'&&c<='z'?c+'A'-'a':c+'a'-'A';}\nint main() {\n\tread(n);read(k);Vi p(n,0),q(n,0);\n\trep(i,0,n-1)read(p[i]),p[i]--;\n\trep(i,0,n-1)read(q[i]),q[i]--;\n\t\n\t/*string a[N];\n\ta[1]=\"p\";a[2]=\"q\";\n\trep(i,3,k){\n\t\tper(j,SZ(a[i-2])-1,0)a[i]+=flip(a[i-2][j]);\n\t\trep(j,0,SZ(a[i-1])-1)\n\t\t\tif(!a[i].empty()&&a[i].back()==flip(a[i-1][j]))a[i].pop_back();\n\t\t\telse a[i]+=a[i-1][j];\n\t}\n\t\n\trep(i,1,k){\n\t\tprintf(\"%d(%d):\",i,SZ(a[i])-SZ(a[i-1]));cout<<a[i]<<endl;\n\t}*/\n\t\n\tif(k<=6){\n\t\tVi a[8];a[1]=p;a[2]=q;\n\t\trep(i,3,k)a[i]=mul(inv(a[i-2]),a[i-1]);\n\t\tprint(a[k]);return 0;\n\t}\n\tint c=k/6;//Q+(pqPQ)*(c-1)+???+(pQPq)*c\n\tVi P=inv(p),Q=inv(q);//,tt=p*q*P*Q;\n//\tprintf(\"done1 %d %d %d %d %d\\n\",SZ(p),SZ(q),SZ(P),SZ(Q),SZ(p*q*P*Q));\n\tVi q233=power(p*q*P*Q,c-1);\n\tVi res=mul(Q,q233);\n//\tputs(\"done1 yzr\");\n\tint tmp=k%6;\n\tif(tmp==0)res=mul(res,p);\n\tif(tmp==1)res=mul(res,mul(p,q));\n\tif(tmp==2)res=mul(res,mul(mul(mul(p,q),P),q));\n\tif(tmp==3)res=mul(res,mul(mul(mul(mul(p,q),P),P),q));\n\tif(tmp==4)res=res*p*q*P*Q*P*q;\n\tif(tmp==5)res=res*p*q*P*Q*p*Q*P*q;\n//\tputs(\"done2\");\n\tres=res*power(p*Q*P*q,c);\n\tprint(res);\n\t/*print(p);print(q);\n\trep(t,3,k){\n\t\tVi w=mul(inv(p),q);p=q;q=w;print(w);\n\t}*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint n,k;\nvoid mul(int A[],int B[],int C[]){\n\tstatic int tmp[MAXN];\n\tfor(int i=1;i<=n;i++)\t\n\t\ttmp[i]=B[C[i]];\n\tfor(int i=1;i<=n;i++)\n\t\tA[i]=tmp[i];\n}\nvoid inv(int A[],int B[]){\n\tfor(int i=1;i<=n;i++)\n\t\tA[B[i]]=i;\n}\nint p[MAXN],q[MAXN],p1[MAXN],q1[MAXN],e[MAXN],res[MAXN],res1[MAXN];\nint main(){\n\tSF(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t\tSF(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tSF(\"%d\",&q[i]);\n\tinv(p1,p);\n\tinv(q1,q);\n\tfor(int i=1;i<=n;i++){\n\t\te[i]=i;\n\t\tres[i]=i;\n\t}\n\tmul(e,e,q);mul(e,e,p1);mul(e,e,q1);mul(e,e,p);\n\tint x=(k-1)/6;\n\tint y=(k-1)%6+1;\n\twhile(x){\n\t\tif(x&1)\n\t\t\tmul(res,res,e);\n\t\tmul(e,e,e);\n\t\tx>>=1;\t\n\t}\n\tif(y>=4)\n\t\tmul(res,res,q);\n\tif(y>=5)\n\t\tmul(res,res,p1);\n\tinv(res1,res);\n\tif(y==1){\n\t\tmul(res,res,p);\n\t}\n\telse if(y==2){\n\t\tmul(res,res,q);\n\t}\n\telse if(y==3){\n\t\tmul(res,res,q);\n\t\tmul(res,res,p1);\n\t}\n\telse if(y==4){\n\t\tmul(res,res,p1);\n\t}\n\telse if(y==5){\n\t\tmul(res,res,q1);\n\t}\n\telse{\n\t\tmul(res,res,q1);\n\t\tmul(res,res,p);\n\t}\n\tmul(res,res,res1);\n\tfor(int i=1;i<=n;i++)\n\t\tPF(\"%d \",res[i]);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass DASequenceOfPermutations {\npublic:\n    vector<int> mul(const vector<int>&a, const vector<int>&b) {\n        int N = a.size();\n        vector<int> R(N);\n        for (int i = 0; i < N; ++i) {\n            R[i] = a[b[i]];\n        }\n        return R;\n    }\n\n    vector<int> prod(const vector<int>&w, int k) {\n        int N = w.size();\n        vector<int> R(N), P = w;\n        for (int i = 0; i < N; ++i) {\n            R[i] = i;\n        }\n\n        while (k) {\n            if (k%2) R = mul(R, P);\n            P = mul(P, P);\n            k >>= 1;\n        }\n        return R;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        int N, K; cin >> N >> K;\n        vector<int> P(N), Q(N); cin >> P >> Q;\n\n        for (int&p: P) --p;\n        for (int&q: Q) --q;\n\n        vector<int> PI(N), QI(N);\n        for (int i = 0; i < N; ++i) {\n            QI[Q[i]] = i;\n            PI[P[i]] = i;\n        }\n        vector<int> Per(N);\n        for (int i = 0; i < N; ++i) Per[i] = Q[PI[QI[P[i]]]];\n\n        int s = (K-1)/6;\n        K -= 6*s;\n\n        vector<int> pow = prod(Per, s);\n        vector<int> ipow(N);\n        for (int i = 0; i < N; ++i) {\n            ipow[pow[i]] = i;\n        }\n        P = mul(pow, mul(P, ipow));\n        Q = mul(pow, mul(Q, ipow));\n        vector<int> Ans;\n        if (K == 1) {\n            Ans = P;\n        } else {\n            for (int k = 3; k <= K; ++k) {\n                vector<int> Z(N);\n                for (int i = 0; i < N; ++i) {\n                    Z[P[i]] = Q[i];\n                }\n                swap(P, Q);\n                swap(Q, Z);\n            }\n            Ans = Q;\n        }\n\n        for (int&ans: Ans) ++ans;\n        cout << Ans;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDASequenceOfPermutations solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,k;\nint a[100001];\nint one[100001];\nint t[100001];\nvoid cpy(int* u,int* w){\n\tfor(int i=1; i<=n ;i++) w[i]=u[i];\n}\nint out(int* u){\n\tfor(int i=1; i<=n ;i++) cout << u[i] << ' ';\n\tcout << endl;\n\treturn 0;\n}\nvoid mul(int* u,int* v,int* w){\n\tfor(int i=1; i<=n ;i++) t[i]=v[u[i]];\n\tcpy(t,w);\n}\nvoid inv(int* u,int* w){\n\tfor(int i=1; i<=n ;i++) t[u[i]]=i;\n\tcpy(t,w);\n}\nvoid pw(int* u,int k,int* w){\n\tif(k==0){\n\t\tcpy(one,w);\n\t\treturn;\n\t}\n\tif(k%2==1){\n\t\tpw(u,k-1,w);mul(w,u,w);\n\t}\n\telse{\n\t\tpw(u,k/2,w);mul(w,w,w);\n\t}\n}\nint p[100001];\nint q[100001];\nint r[100001];\nint s[100001];\nint x[100001];\nint y[100001];\nint invp[100001];\nint invq[100001];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> k;\n\tfor(int i=1; i<=n ;i++) cin >> p[i];\n\tfor(int i=1; i<=n ;i++) cin >> q[i];\n\tfor(int i=1; i<=n ;i++) one[i]=i;\n\tif(k==1) return out(p);\n\tif(k==2) return out(q);\n\tinv(p,invp);\n\tinv(q,invq);\n\t//out(t);out(invq);\n\tif(k%6==1) cpy(p,r);\n\tif(k%6==2) cpy(q,r);\n\tif(k%6==3) mul(invp,q,r);\n\tif(k%6==4) cpy(invp,r);\n\tif(k%6==5) cpy(invq,r);\n\tif(k%6==0) mul(invq,p,r);\n\t//out(r);\n\tmul(invq,p,s);mul(s,q,s);mul(s,invp,s);\n\tint pl=(2*k-4)/3;\n\tpw(s,pl/4,x);\n\tif(pl%4>=1) mul(x,invq,x);\n\tif(pl%4>=2) mul(x,p,x);\n\tif(pl%4>=3) mul(x,q,x);\n\tmul(x,r,y);\n\tinv(x,x);\n\tmul(y,x,y);\n\tout(y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int>& operator *= (vector<int> &p, vector<int> q) {\n  vector<int> r = p;\n  for (int i = 0; i < (int) p.size(); ++i) {\n    p[i] = q[r[i]];\n  }\n  return p;\n}\n\nvector<int> operator * (vector<int> p, vector<int> q) {\n  return p *= q;\n}\n\nvector<int> inv(const vector<int> &p) {\n  int n = (int) p.size();\n  vector<int> res(n);\n  for (int i = 0; i < n; ++i) {\n    res[p[i]] = i;\n  }\n  return res;\n}\n\nvector<int> power(vector<int> x, int y) {\n  int n = (int) x.size();\n  vector<int> res(n);\n  for (int i = 0; i < n; ++i) {\n    res[i] = i;\n  }\n  while (y) {\n    if (y & 1) {\n      res *= x;\n    }\n    x *= x;\n    y >>= 1;\n  }\n  return res;\n}\n\nvoid output(vector<int> ans) {\n  for (int i = 0; i < (int) ans.size(); ++i) {\n    if (i) {\n      cout << \" \";\n    }\n    cout << ans[i] + 1;\n  }\n  cout << \"\\n\";\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> p(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i];\n    --p[i];\n  }\n  vector<int> q(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> q[i];\n    --q[i];\n  }\n  if (m == 1) {\n    output(p);\n  } else if (m == 2) {\n    output(q);\n  } else {\n    m -= 2;\n    vector<int> inv_p = inv(p);\n    vector<int> inv_q = inv(q);\n    vector<int> ans(n);\n    for (int i = 0; i < n; ++i) {\n      ans[i] = i;\n    }\n    ans *= power(inv_q * p * q * inv_p, m / 6);\n    switch (m % 6) {\n      case 0:\n        ans *= q;\n        break;\n      case 1:\n        ans *= inv_p * q;\n        break;\n      case 2:\n        ans *= inv_q * inv_p * q;\n        break;\n      case 3:\n        ans *= inv_q * p * inv_q * inv_p * q;\n        break;\n      case 4:\n        ans *= inv_q * p * p * inv_q * inv_p * q;\n        break;\n      case 5:\n        ans *= inv_q * p * q * p * inv_q * inv_p * q;\n        break;\n    }\n    ans *= power(p * inv_q * inv_p * q, m / 6);\n    output(ans);\n  }\n  return 0;\n}\n\n/*\n(-2 1 2 -1) * (i - 2) / 6 + f[(i - 2) % 6] + (1 -2 -1 2) * (i - 2) / 6 \nf[0] = {2}\nf[1] = {-1, 2}\nf[2] = {-2, -1, 2}\nf[3] = {-2, 1, -2, -1, 2}\nf[4] = {-2, 1, 1, -2, -1, 2}\nf[5] = {-2, 1, 2, 1, -2, -1, 2}\n */ \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct perm {\n\tvector <int> v;\n\tvoid input(int n) {\n\t\tv.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d\", &v[i]);\n\t\t\tv[i]--;\n\t\t}\n\t}\n\tvoid output() {\n\t\tfor (int i = 0; i < v.size(); i++)\n\t\t\tprintf(\"%d \", v[i] + 1);\n\t\tputs(\"\");\n\t}\n\tint& operator [](int id) {\n\t\treturn v[id];\n\t}\n};\n\nperm inv(perm a) {\n\tvector <int> res(a.v.size(), 0);\n\tfor (int i = 0; i < res.size(); i++)\n\t\tres[a[i]] = i;\n\treturn {res};\n}\n\nperm operator *(perm a, perm b) {\n\tvector <int> res(a.v.size(), 0);\n\tfor (int i = 0; i < a.v.size(); i++)\n\t\tres[i] = a[b[i]];\n\treturn {res};\n}\n\nperm operator ^(perm a, int n) {\n\tperm res;\n\tfor (int i = 0; i < a.v.size(); i++)\n\t\tres.v.push_back(i);\n\tfor (; n; n /= 2) {\n\t\tif (n % 2)\n\t\t\tres = res * a;\n\t\ta = a * a;\n\t}\n\treturn res;\n}\n\nint N, K;\nperm p, q;\n\nvoid load() {\n\tscanf(\"%d%d\", &N, &K);\n\tp.input(N);\n\tq.input(N);\n}\n\nperm solve() {\n\tfor (; K > 2 && K % 3 != 2; K--) {\n\t\tperm t = q;\n\t\tq = q * inv(p);\n\t\tp = t;\n\t}\n\t\n\tif (K == 1)\n\t\treturn p;\n\tif (K == 2)\n\t\treturn q;\n\t\n\tint diff = K / 3 + 1;\n\tint same = K / 3 - 1;\n\tperm pref = q * inv(p) * inv(q) * p;\n\tpref = pref ^ (diff / 2);\n\tif (diff % 2)\n\t\tpref = pref * q * inv(p);\n\tperm a = inv(q) * inv(p);\n\tperm b = q * p;\n\tif (same % 2) \n\t\tswap(a, b);\n\tperm suff = a * b;\n\tsuff = suff ^ (same / 2);\n\tif (same % 2)\n\t\tsuff = suff * a;\n\treturn pref * suff * inv(q);\n}\n\nint main() {\n\tload();\n\tsolve().output();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000000\n#define infll 1000000000000000000ll\n#define vi vector<int>\n#define vll vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define mpr make_pair\n#define fi first\n#define se second\n#define pq priority_queue<int>\n#define pqll priority_queue<ll>\n#define up(x,y) (x<(y)?x=(y):0)\n#define dn(x,y) (x>(y)?x=(y):0)\n#define ad(x,y) (x=(x+(y))%mod)\n#define mod 1000000007\n#define N 100009\nusing namespace std;\n\nint n,m; vi ans,f,a[9];\nvi inv(vi a){\n\tint i; vi f; f.resize(n+1);\n\tfor\t(i=1; i<=n; i++) f[a[i]]=i;\n\treturn f;\n}\nvi mrg(vi a,vi b){\n\tint i; vi c; c.resize(n+1);\n\tfor (i=1; i<=n; i++) c[i]=b[a[i]];\n\treturn c;\t\n}\nvoid opt(vi f){\n\tint i;\n\tfor (i=1; i<=n; i++) printf(\"%d%c\",f[i],i<n?' ':'\\n');\t\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint i;\n\ta[1].resize(n+1); a[2].resize(n+1);\n\tfor (i=1; i<=n; i++) scanf(\"%d\",&a[1][i]);\n\tfor (i=1; i<=n; i++) scanf(\"%d\",&a[2][i]);\n\tif (m==1){ opt(a[1]); return 0; }\n\tfor (i=3; i<=7; i++) a[i]=mrg(inv(a[i-2]),a[i-1]);\n\tf=mrg(mrg(inv(a[2]),a[1]),mrg(a[2],inv(a[1])));\n\tint tmp=(m-2)/6;\n\tm-=tmp*6;\n\tans.resize(n+1);\n\tfor (i=1; i<=n; i++) ans[i]=i;\n\tfor (; tmp; tmp>>=1,f=mrg(f,f)) if (tmp&1) ans=mrg(ans,f);\n\tans=mrg(mrg(ans,a[m]),inv(ans));\n\topt(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\nconst int N=1e5+5;\n\ntypedef vector<int> vec;\n\nint n,k,c[N];\nbool vis[N];\nvec a[7],A,p,q;\n\nvec inv(vec a) {\n\tvec b;b.resize(n);\n\tfo(i,0,n-1) b[a[i]]=i;\n\treturn b;\n}\n\nvec mult(vec a,vec b) {\n\tvec c;c.resize(n);\n\tfo(i,0,n-1) c[i]=a[b[i]];\n\treturn c;\n}\n\nvec pwr(vec a,int t) {\n\tvec b;b.resize(n);\n\tfo(i,0,n-1) vis[i]=0;\n\tfo(i,0,n-1)\n\t\tif (!vis[i]) {\n\t\t\tif (a[i]==i) {b[i]=i;continue;}\n\t\t\tint x=i,m=0;\n\t\t\tdo {vis[c[m++]=x]=1;x=a[x];} while (x!=i);\n\t\t\tfo(j,0,m-1) b[c[j]]=c[(j+t)%m];\n\t\t}\n\treturn b;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tp.resize(n);q.resize(n);\n\tfo(i,0,n-1) scanf(\"%d\",&p[i]),p[i]--;\n\tfo(i,0,n-1) scanf(\"%d\",&q[i]),q[i]--;\n\ta[1]=p;a[2]=q;\n\tif (n<=6) {\n\t\tfo(i,3,n) a[i]=mult(a[i-1],inv(a[i-2]));\n\t\tfo(i,0,n-1) printf(\"%d \",a[n][i]+1);\n\t\treturn 0;\n\t}\n\tfo(i,3,6) a[i]=mult(a[i-1],inv(a[i-2]));\n\tA.resize(n);fo(i,0,n-1) A[i]=i;\n\tA=mult(A,q);A=mult(A,inv(p));A=mult(A,inv(q));A=mult(A,p);\n\tA=pwr(A,(k-1)/6);\n\tvec an=a[k%6];\n\tan=mult(A,an);an=mult(an,inv(A));\n\tfo(i,0,n-1) printf(\"%d \",an[i]+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n//#define cerr if(false) cerr\n#define show(...) cerr << #__VA_ARGS__ << \" = \",debug(__VA_ARGS__);\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate<typename T, typename S>\nostream &operator<<(ostream &os,pair<T,S>a){\n    os << '(' << a.first << ',' << a.second << ')';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, vector<T> v){\n    for(auto x:v)os << x << ' ';\n    return os;\n}\nvoid debug(){cerr << '\\n';}\ntemplate<typename H, typename... T>\nvoid debug(H a, T... b){\n    cerr << a;\n    if(sizeof...(b))cerr << \", \";\n    debug(b...);\n}\n\n//char inv(char c){\n//    return c^32;\n//}\n//string inv(string &a){\n//    auto res = a;\n//    for(auto &x:res) x^=32;\n//    reverse(res.begin(),res.end());\n//    return res;\n//}\n//string product(const string &a,const string &b){\n//    auto res = a;\n//    for(auto x:b){\n//        if(res.size() and inv(x) == res.back())res.erase(res.begin()+res.size()-1);\n//        else res.push_back(x);\n//    }\n//    return res;\n//    \n//}\n\nvector<int> id(const int n){\n    vector<int> res(n);\n    rep(i,n)res[i] = i;\n    return res;\n}\nvector<int> inv(const vector<int> &a){\n    vector<int> res(a.size());\n    rep(i,a.size()){\n        res[a[i]] = i;\n    }\n    return res;\n}\nvector<int> product(const vector<int> &a, const vector<int> &b){\n    vector<int> res(a.size());\n    rep(i,a.size()){\n        res[i] = a[b[i]];\n    }\n    return res;\n}\nvector<int> power(const vector<int> &a, ll p){\n    if(p == 0)return id((int)a.size());\n    auto res = a;\n    auto temp = a;\n    p--;\n    for(int i = 0; i < 28; i++){\n        if(p >> i & 1){\n            res = product(res, temp);\n        }\n        temp = product(temp, temp);\n    }\n    return res;\n}\nint main(){\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n    vector<int>p(n),q(n);\n    rep(i,n)scanf(\"%d\",&p[i]),p[i]--;\n    rep(i,n)scanf(\"%d\",&q[i]),q[i]--;\n    auto g = product(q,product(inv(p),product(inv(q),p)));\n    g = power(g,(k-1)/6);\n    auto a = product(g,product(p,inv(g)));\n    auto b = product(g,product(q,inv(g)));\n    int now = 1 + (k-1)/6*6;\n    while(now != k){\n        auto c = product(b,inv(a));\n        a = b;\n        b = c;\n        now++;\n    }\n    rep(i,n)printf(\"%d \",a[i]+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define Fast_IO ios::sync_with_stdio(false);\n#define fir first\n#define sec second\n#define mod 998244353\n#define INF 0x3fffffff\n#define ll long long\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\ntypedef pair<int,int> pii;\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint sub(int x,int y){return x-y<0?x-y+mod:x-y;}\nint mul(int x,int y){return 1LL*x*y%mod;}\nvector<int> a[6];\nint n,k;\nvector<int> mul(vector<int> a,vector<int> b)\n{\n\tvector<int> ans(n);\n\tfor(int i=0;i<n;i++) ans[i]=a[b[i]];\n\treturn ans;\n}\nvector<int> inv(vector<int> a)\n{\n\tvector<int> ans(n);\n\tfor(int i=0;i<n;i++) ans[a[i]]=i;\n\treturn ans;\n}\nvector<int> qpow(vector<int> a,int y)\n{\n\tvector<int> ans(n);\n\tfor(int i=0;i<n;i++) ans[i]=i;\n\twhile(y)\n\t{\n\t\tif(y&1) ans=mul(ans,a);\n\t\ta=mul(a,a);\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\nsigned main()\n{\n\tn=read(),k=read()-1;\n\tfor(int i=0;i<n;i++) a[0].pb(read()-1);\n\tfor(int i=0;i<n;i++) a[1].pb(read()-1);\n\tfor(int i=2;i<6;i++) a[i]=mul(a[i-1],inv(a[i-2]));\n\tif(k<6)\n\t{\n\t\tfor(int i=0;i<n;i++) printf(\"%d \",a[k][i]+1);\n\t\treturn 0;\n\t}\n\tvector<int> ans=qpow(mul(mul(a[1],inv(a[0])),mul(inv(a[1]),a[0])),k/6);\n\tans=mul(mul(ans,a[k%6]),inv(ans));\n\tfor(int i=0;i<n;i++) printf(\"%d \",ans[i]+1);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nint n, k, p[100010], q[100010], fp[100010], fq[100010], A[100010], a[100010], b[100010], c[100010], ans[100010], tmp[100010];\n\ninline void ksm (int p) {\n\tif (!p) return;\n\tksm (p >> 1);\n\tfor (int i = 1; i <= n; ++i) tmp[i] = a[a[i]];\n\tfor (int i = 1; i <= n; ++i) a[i] = tmp[i];\n\tif (p & 1) {\n\t\tfor (int i = 1; i <= n; ++i) tmp[i] = A[a[i]];\n\t\tfor (int i = 1; i <= n; ++i) a[i] = tmp[i];\n\t}\n}\n\nint main () {\n\tscanf (\"%d%d\", &n, &k);\n\tfor (int i = 1; i <= n; ++i) scanf (\"%d\", &p[i]), fp[p[i]] = i;\n\tfor (int i = 1; i <= n; ++i) scanf (\"%d\", &q[i]), fq[q[i]] = i;\n\t\n\tfor (int i = 1; i <= n; ++i) A[i] = q[fp[fq[p[i]]]];\n\tfor (int i = 1; i <= n; ++i) a[i] = i;\n\t\n\tksm ((k - 1) / 6);\n\t\n\tif (k % 6 == 1) for (int i = 1; i <= n; ++i) c[i] = p[i];\n\tif (k % 6 == 2) for (int i = 1; i <= n; ++i) c[i] = q[i];\n\tif (k % 6 == 3) for (int i = 1; i <= n; ++i) c[i] = q[fp[i]];\n\tif (k % 6 == 4) {\n\t\tfor (int i = 1; i <= n; ++i) c[i] = fp[i];\n\t\tfor (int i = 1; i <= n; ++i) tmp[i] = a[q[i]];\n\t\tfor (int i = 1; i <= n; ++i) a[i] = tmp[i];\n\t}\n\tif (k % 6 == 5) {\n\t\tfor (int i = 1; i <= n; ++i) c[i] = fq[i];\n\t\tfor (int i = 1; i <= n; ++i) tmp[i] = a[q[fp[i]]];\n\t\tfor (int i = 1; i <= n; ++i) a[i] = tmp[i];\n\t}\n\tif (k % 6 == 0) {\n\t\tfor (int i = 1; i <= n; ++i) c[i] = fq[p[i]];\n\t\tfor (int i = 1; i <= n; ++i) tmp[i] = a[q[fp[i]]];\n\t\tfor (int i = 1; i <= n; ++i) a[i] = tmp[i];\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i) b[a[i]] = i;\n\t\n\tfor (int i = 1; i <= n; ++i) ans[i] = a[c[b[i]]];\n\t\n\tfor (int i = 1; i <= n; ++i) printf (\"%d%c\", ans[i], \" \\n\"[i == n]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\n\nV<int> operator*(V<int> a,V<int> b){\n\tint N = a.size();\n\tV<int> c(N);\n\trep(i,N) c[i] = a[b[i]];\n\treturn c;\n}\nV<int> inv(V<int> a){\n\tint N = a.size();\n\tV<int> c(N);\n\trep(i,N) c[a[i]] = i;\n\treturn c;\n}\nV<int> ex(V<int> x,int p){\n\tint N = x.size();\n\tV<int> a(N);iota(all(a),0);\n\twhile(p){\n\t\tif(p&1) a = a*x;\n\t\tx = x*x;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tint N,K; cin >> N >> K,K--;\n\tV<int> p(N),q(N);\n\trep(i,N) cin >> p[i],p[i]--;\n\trep(i,N) cin >> q[i],q[i]--;\n\n\tV<int> L = q*inv(p)*inv(q)*p;\n\n\tVV<int> pfx(6);\n\tpfx[0] = p, pfx[1] = q;\n\tfor(int i=2;i<6;i++) pfx[i] = pfx[i-1]*inv(pfx[i-2]);\n\tint e = K/6;\n\tL = ex(L,e);\n\tauto res = L * pfx[K%6] * inv(L);\n\trep(i,N) cout << res[i]+1 << \" \";\n\tcout << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\n\nvector<int> inv(vector<int> a) {\n  vector<int> b(n);\n  for (int i = 0; i < n; i++) {\n    b[a[i]] = i;\n  }\n  return b;\n}\n\nvector<int>& operator*=(vector<int>& a, vector<int> b) {\n  vector<int> c(n);\n  for (int i = 0; i < n; i++) {\n    c[i] = a[b[i]];\n  }\n  a = c;\n  return a;\n}\n\nvector<int> operator*(vector<int> a, vector<int> b) {\n  return a *= b;\n}\n\nvoid output(vector<int> a) {\n  for (int i = 0; i < n; i++) {\n    printf(\"%d%c\", a[i] + 1, \" \\n\"[i == n - 1]);\n  }\n}\n\nvector<int> power(vector<int> a, int k) {\n  vector<int> res(n);\n  for (int i = 0; i < n; i++) {\n    res[i] = i;\n  }\n  while (k > 0) {\n    if (k & 1) {\n      res *= a;\n    }\n    a *= a;\n    k >>= 1;\n  }\n  return res;\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    a[i]--;\n  }\n  vector<int> b(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &b[i]);\n    b[i]--;\n  }\n  if (m == 1) {\n    output(a);\n  } else if (m == 2) {\n    output(b);\n  } else {\n    m -= 2;\n    vector<int> A = inv(a);\n    vector<int> B = inv(b);\n    vector<int> res = power(b * A * B * a, m / 6);\n    int rm = m % 6;\n    if (rm == 0) res *= b;\n    if (rm == 1) res *= b * A;\n    if (rm == 2) res *= b * A * B;\n    if (rm == 3) res *= b * A * B * a * B;\n    if (rm == 4) res *= b * A * B * a * a * B;\n    if (rm == 5) res *= b * A * B * a * b * a * B;\n    res *= power(A * b * a * B, m / 6);\n    output(res);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005;\n\nint n, k;\nstruct perm {\n\tint p[N];\n\tint& operator [] (int index) { return p[index]; }\n\tint operator [] (int index) const { return p[index]; }\n\tperm inverse() const {\n\t\tstatic perm tmp;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\ttmp[p[i]] = i;\n\t\treturn tmp;\n\t}\n\tfriend perm operator * (const perm &a, const perm &b) {\n\t\tstatic perm tmp;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\ttmp[i] = a[b[i]];\n\t\treturn tmp;\n\t}\n\tperm pow(int k) const {\n\t\tstatic bool vis[N];\n\t\tstatic int cycle[N], id[N], tot;\n\t\tstatic perm tmp;\n\t\tfor (int i = 1; i <= n; ++i) if (!vis[i]) {\n\t\t\tint j = i;\n\t\t\ttot = 0;\n\t\t\tdo {\n\t\t\t\tid[j] = tot, cycle[tot++] = j, vis[j] = 1, j = p[j];\n\t\t\t} while (j != i);\n\t\t\tj = i;\n\t\t\tdo {\n\t\t\t\ttmp[j] = cycle[(id[j] + k) % tot], j = p[j];\n\t\t\t} while (j != i);\n\t\t}\n\t\treturn tmp;\n\t}\n} p, q, t, s;\n\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> k;\n\tfor (int i = 1; i <= n; ++i) std::cin >> p[i];\n\tfor (int i = 1; i <= n; ++i) std::cin >> q[i];\n\tt = q * p.inverse() * q.inverse() * p;\n\tswitch (k % 6) {\n\t\tcase 0: \n\t\t\ts = q.inverse() * p; break;\n\t\tcase 1:\n\t\t\ts = p; break;\n\t\tcase 2:\n\t\t\ts = q; break;\n\t\tcase 3:\n\t\t\ts = q * p.inverse(); break;\n\t\tcase 4:\n\t\t\ts = t * p.inverse(); break;\n\t\tcase 5:\n\t\t\ts = t * q.inverse(); break;\n\t}\n\tt = t.pow(k / 6), s = t * s * t.inverse();\n\tfor (int i = 1; i <= n; ++i) std::cout << s[i] << ' ';\n\tstd::cout << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nostream& operator << (ostream &os, const vector<int> &v) {\n    os << \"[\";\n    for (int i = 0; i < v.size(); ++i) {\n        os << 1 + v[i];\n        if (i + 1 < v.size()) {\n            os << \" \";\n        }\n    }\n    os << \"]\";\n    return os;\n}\n\nint n, k;\nvector<int> p, q;\n\nvector<int> inv(const vector<int> &p) {\n    vector<int> res(p.size());\n    for (int i = 0; i < res.size(); ++i) {\n        res[p[i]] = i;\n    }\n    return res;\n}\n\nvector<int> product(const vector<int> &p, const vector<int> &q) {\n    vector<int> res(p.size());\n    for (int i = 0; i < res.size(); ++i) {\n        res[i] = p[q[i]];\n    }\n    return res;\n}\n\nvector<int> power(const vector<int> &v, int k) {\n    vector<int> res(v.size());\n    for (int i = 0; i < res.size(); ++i) {\n        res[i] = i;\n    }\n    if (k == 0) {\n        return res;\n    }\n    --k;\n    vector<char> used(v.size());\n    for (int i = 0; i < v.size(); ++i) {\n        if (!used[i]) {\n            int pos = i;\n            vector<int> q;\n            while (!used[pos]) {\n                q.push_back(v[pos]);\n                used[pos] = 1;\n                pos = v[pos];\n            }\n            vector<int> w(q.size());\n            for (int i = 0; i < w.size(); ++i) {\n                w[i] = (q[(i + k) % w.size()]);\n            }\n            reverse(w.begin(), w.end());\n            while (!w.empty()) {\n                res[pos] = w.back();\n                w.pop_back();\n                pos = v[pos];\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d%d\", &n, &k);\n    p.resize(n);\n    q.resize(n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &p[i]);\n        --p[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &q[i]);\n        --q[i];\n    }\n    --k;\n    vector<int> v = product(q, product(inv(p), product(inv(q), p)));\n    vector<int> cur = power(v, k / 6);\n    k %= 6;\n    p = product(cur, product(p, inv(cur)));\n    q = product(cur, product(q, inv(cur)));\n    while (k--) {\n        vector<int> v = product(q, inv(p));\n        p = q;\n        q = v;\n    }\n    for (int x : p) {\n        printf(\"%d \", x + 1);\n    }\n    puts(\"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL>PL;\nconst LL INF=1e18;\nint N,K,i,j;\nint A[100010][1010];\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>N>>K;\n    for(i=0;i<N;i++)\n        cin>>A[1][i];\n    for(i=0;i<N;i++)\n        cin>>A[2][i];\n    for(i=3;i<=K;i++)\n    {\n        for(j=0;j<N;j++)\n            A[i][A[i-2][j]-1]=A[i-1][j];\n        for(j=0;j<N;j++)\n            if(A[i-1][j]!=A[1][j]||A[i][j]!=A[2][j])\n                break;\n        if(j>=N)\n            break;\n    }\n    if(i<=K)\n        K=(K-1)%(i-2)+1;\n    for(i=0;i<N;i++)\n        cout<<A[K][i]<<' ';\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\n\nstruct data {\n\tint a[100001];\n\n\tvoid init() {\n\t\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\t}\n}f[7], A, ans;\n\ndata operator + (const data &a, const data &b) {\n\tdata ans;\n\tfor (int i = 1; i <= n; ++i)\n\t\tans.a[i] = a.a[b.a[i]];\n\treturn ans;\n}\n\ndata inv(const data &a) {\n\tdata ans;\n\tfor (int i = 1; i <= n; ++i)\n\t\tans.a[a.a[i]] = i;\n\treturn ans;\n}\n\ndata fpow(data x, int y) {\n\tdata ans;\n\tfor (int i = 1; i <= n; ++i) ans.a[i] = i;\n\twhile (y) {\n\t\tif (y & 1) ans = ans + x;\n\t\ty >>= 1; x = x + x;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\t\t\n\tf[1].init(); f[2].init();\n\tfor (int i = 3; i <= 6; ++i)\n\t\tf[i] = f[i - 1] + inv(f[i - 2]);\n\tint mod = k % 6 ? k % 6 : 6;\n\tA = f[2] + inv(f[1]) + inv(f[2]) + f[1];\n\tans = fpow(A, (k - mod) / 6);\n\tans = ans + f[mod];\n\tans = ans + fpow(inv(A), (k - mod) / 6);\n\tfor (int i = 1; i <= n; ++i)\n\t\tprintf(\"%d \", ans.a[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint n,k;\nint p[100010],q[100010];\n\nstruct Array{\n\tint a[100010];\n\tvoid show(){\n\t\trep1(i,n){\n\t\t\tprintf(\"%d%c\",a[i],(i==n)?'\\n':' ');\n\t\t}\n\t}\n}I;\nvoid init(){\n\trep1(i,n)I.a[i] = i;\n}\n\nvoid inv(Array &a){\n\tint a_[100010];\n\trep1(i,n)a_[a.a[i]] = i;\n\trep1(i,n)a.a[i] = a_[i];\n}\nArray pro(Array &a,Array &b){\n\tArray ret;\n\trep1(i,n)ret.a[i] = a.a[b.a[i]];\n\treturn ret;\n}\nArray pow(Array &a, int e){\n\tif(e == 0)return I;\n\tArray ret = pow(a,e/2);\n\tret = pro(ret,ret);\n\tif(e%2 == 1){\n\t\tret = pro(ret,a);\n\t}\n\treturn ret;\n}\n\nArray f(Array &a,Array &b){\n\tinv(a);\n\tArray ret = pro(b,a);\n\tinv(a);\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\trep1(i,n)scanf(\"%d\",&p[i]);\n\trep1(i,n)scanf(\"%d\",&q[i]);\n\tinit();\n\t\n\tstatic Array P,Q;\n\trep1(i,n){\n\t\tP.a[i] = p[i];\n\t\tQ.a[i] = q[i];\n\t}\n\tstatic Array P_inv = P; inv(P_inv);\n\tstatic Array Q_inv = Q; inv(Q_inv);\n\tstatic Array F;\n\tF = pro(P_inv,Q);\n\tF = pro(F,P);\n\tF = pro(F,Q_inv);\n\tstatic Array R = pow(F,(k-1)/6);\n\tstatic Array L = R; inv(L);\n\t\n\t//P.show();\n\t//Q.show();\n\t//L.show();\n\t//R.show();\n\t\n\tint x = 6*((k-1)/6)+1;\n\tint y = x+1;\n\tstatic Array A = pro(P,R); A = pro(L,A);\n\tstatic Array B = pro(Q,R); B = pro(L,B);\n\t//cout << x << \" \" << y << endl;\n\t//A.show();\n\t//B.show();\n\t\n\tstatic Array C;\n\twhile(y < k){\n\t\tC = f(A,B);\n\t\tA = B;\n\t\tB = C;\n\t\tx ++;\n\t\ty ++;\n\t}\n\tif(x == k)A.show();\n\telse B.show();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf = 1.01e9;\nconst i64 inf64 = 4.01e18;\nconst double eps = 1e-9;\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// q(p(i))\nvector<i64> composite(const vector<i64> &p, const vector<i64> &q){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n) res[i]=q[p[i]];\n    return res;\n}\n\nvector<i64> inverse(const vector<i64> &p){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n) res[p[i]]=i;\n    return res;\n}\n\nvector<i64> pow(vector<i64> p,i64 k){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n){\n        res[i]=i;\n    }\n    while(k){\n        if(k&1){\n            res=composite(res,p);\n        }\n        p=composite(p,p);\n        k>>=1;\n    }\n    return res;\n}\n\nvector<i64> f(const vector<i64> &p,const vector<i64> &q){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n) res[p[i]]=q[i];\n    return res;\n}\n\nvoid solve() {\n    //const i64 mod = 1'000'000'007;\n\n    /*\n    vector<string> vs(30);\n    vs[1]=\"a\";\n    vs[2]=\"b\";\n    rep(i,3,vs.size()){\n        vs[i]=vs[i-1];\n        for(i64 j=vs[i-2].size()-1; j>=0; --j){\n            char c=vs[i-2][j];\n            if(c=='a'){\n                if(vs[i].back()=='a') vs[i].pop_back();\n                else vs[i]+='A';\n            }\n            if(c=='A'){\n                if(vs[i].back()=='A') vs[i].pop_back();\n                else vs[i]+='a';\n            }\n            if(c=='b'){\n                if(vs[i].back()=='b') vs[i].pop_back();\n                else vs[i]+='B';\n            }\n            if(c=='B'){\n                if(vs[i].back()=='B') vs[i].pop_back();\n                else vs[i]+='b';\n            }\n        }\n    }\n    rep(i,1,vs.size()){\n        cout << i << \": \" << vs[i] << endl;\n    }\n     */\n\n    i64 N,K;\n    cin >> N >> K;\n\n    vector<i64> p(N),q(N);\n    rep(i,0,N){\n        cin >> p[i];\n        --p[i];\n    }\n    rep(i,0,N){\n        cin >> q[i];\n        --q[i];\n    }\n\n    if(K<=20){\n        vector<vector<i64>> a(max(K+1,i64(3)));\n        a[1]=p;\n        a[2]=q;\n        rep(i,3,K+1){\n            a[i]=f(a[i-2],a[i-1]);\n        }\n        rep(i,0,N){\n            cout << a[K][i]+1;\n            if(i==N-1) cout << endl;\n            else cout << \" \";\n        }\n        return;\n    }\n\n    vector<i64> pi=inverse(p),qi=inverse(q);\n\n    auto x= composite(composite(composite(p, qi), pi), q);\n    auto y= composite(composite(composite(qi, p), q), pi);\n\n    i64 loop=(K-2)/6, rem=K-(2+loop*6);\n    auto prev=composite(composite(inverse(pow(x,loop)),p),pow(x,loop));\n    auto ans=composite(composite(pow(y,loop),q),pow(x,loop));\n    rep(i,0,rem){\n        auto tmp=ans;\n        ans=f(prev,ans);\n        prev=tmp;\n    }\n\n    rep(i,0,N){\n        cout << ans[i]+1;\n        if(i==N-1) cout << endl;\n        else cout << \" \";\n    }\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nint n,k;\nvector<int> p,q;\nvector<int> id()\n{\n    vector<int> ret;ret.resize(n);\n    for(int i=0;i<n;i++) ret[i]=i;\n    return ret;\n}\nvector<int> getinv(vector<int> &p)\n{\n    vector<int> ret;ret.resize(n);\n    for(int i=0;i<n;i++) ret[p[i]]=i;\n    return ret;\n}\nvector<int> mul(vector<int> p,vector<int> q)\n{\n    vector<int> ret;ret.resize(n);\n    for(int i=0;i<n;i++) ret[i]=p[q[i]];\n    return ret;\n}\nvector<int> pow_(vector<int> &a,int x)\n{\n    vector<int> ret;ret.resize(n);\n    for(int i=0;i<n;i++) ret[i]=i;\n    while(x)\n    {\n        if(x&1) ret=mul(ret,a);\n        a=mul(a,a);\n        x>>=1;\n    }\n    return ret;\n}\nvoid go()\n{\n    vector<int> r=getinv(p);\n    r=mul(q,r);\n    p=q;q=r;\n}\n//lhs=qp'q'p\n//rhs=p'qpq'\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    p.resize(n);q.resize(n);\n    for(int i=0;i<n;i++) {scanf(\"%d\",&p[i]); p[i]--;}\n    for(int i=0;i<n;i++) {scanf(\"%d\",&q[i]); q[i]--;}\n    if(k==1)\n    {\n        for(int i=0;i<n;i++) printf(\"%d \",p[i]+1);\n        return 0;\n    }\n    k-=2;\n    while(k%6) {go(); k--;}\n    vector<int> lhs=id(),rhs=id();\n    lhs=mul(lhs,q);lhs=mul(lhs,getinv(p));lhs=mul(lhs,getinv(q));lhs=mul(lhs,p);\n    rhs=mul(rhs,getinv(p));rhs=mul(rhs,q);rhs=mul(rhs,p);rhs=mul(rhs,getinv(q));\n    lhs=pow_(lhs,k/6);rhs=pow_(rhs,k/6);\n    lhs=mul(lhs,q);lhs=mul(lhs,rhs);\n    for(int i=0;i<n;i++) printf(\"%d \",lhs[i]+1);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\ntypedef vector<int> vi;\nconst int maxn=100111;\n\nint n,k;\nvi operator *(const vi&a,const vi&b)\n{\n\tvi ret(n);\n\tfor(int i=0;i<n;i++)ret[i]=a[b[i]];\n\treturn ret;\n}\nvi neg(const vi&a)\n{\n\tvi ret(n);\n\tfor(int i=0;i<n;i++)ret[a[i]]=i;\n\treturn ret;\n}\nbool vis[maxn];\nint seq[maxn];\nvi qpow(const vi&a,int k)\n{\n\tvi ret(n);\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=0;i<n;i++)if(!vis[i])\n\t{\n\t\tint tot=0,tmp=i;\n\t\twhile(!vis[tmp])\n\t\t{\n\t\t\tseq[tot++]=tmp;vis[tmp]=1;\n\t\t\ttmp=a[tmp];\n\t\t}\n\t\tfor(int j=0;j<tot;j++)ret[seq[j]]=seq[(j+k)%tot];\n\t}\n\treturn ret;\n}\nvi conj(const vi&a,const vi&b){return a*b*neg(a);}\n\n\nint main()\n{\n\tget2(n,k);\n\tvi p,q;\n\tfor(int i=0,x;i<n;i++)\n\t{\n\t\tget1(x);x--;\n\t\tp.pb(x);\n\t}\n\tfor(int i=0,x;i<n;i++)\n\t{\n\t\tget1(x);x--;\n\t\tq.pb(x);\n\t}\n\tvi comm=q*neg(p)*neg(q)*p;comm=qpow(comm,(k-1)/6);\n\tp=conj(comm,p);q=conj(comm,q);\n\tfor(int i=(k-1)/6*6+1;i<k;i++)\n\t{\n\t\tvi nv=q*neg(p);\n\t\tp=q;\n\t\tq=nv;\n\t}\n\tfor(int i=0;i<n;i++)printf(\"%d \",p[i]+1);puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<assert.h>\n#define fo(i,a,b) for(int i=(a);i<=(b);++i)\n#define fd(i,b,a) for(int i=(b);i>=(a);--i)\n#define mset(a,x) memset(a,x,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(b))\nusing namespace std;\nint read(){int n=0,p=1;char ch;for(ch=getchar();ch<'0' || ch>'9';ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\ntypedef vector<int> vi;\nconst int N=1e5+5;\nint n,k;\nvi a[7],ans;\nvi mrg(const vi &a,const vi &b)\n{\n\tstatic vi c; c.resize(n+1);\n\tfo(i,1,n) c[i]=a[b[i]];\n\treturn c;\n}\nvi inv(const vi &a)\n{\n\tstatic vi c; c.resize(n+1);\n\tfo(i,1,n) c[a[i]]=i;\n\treturn c;\n}\nvoid writeln(const vi &a)\n{\n\tfo(i,1,n) printf(\"%d \",a[i]);puts(\"\");\n}\nint main()\n{\n\tn=read(),k=read();\n\ta[1].resize(n+1),a[2].resize(n+1);\n\tfo(i,1,n) a[1][i]=read();\n\tfo(i,1,n) a[2][i]=read();\n\tfo(i,3,6) a[i]=mrg(a[i-1],inv(a[i-2]));\n\tans.resize(n+1);\n\tfo(i,1,n) ans[i]=i;\n\tvi f,g; f.resize(n+1),g.resize(n+1);\n\tf = mrg(a[2],mrg(inv(a[1]),mrg(inv(a[2]),a[1])));\n\tfo(i,1,n) g[i]=i;\n\t//a[i]=f*a[i-6]*inv(f);\n\tfor(int x=(k-1)/6;x;x>>=1)\n\t{\n\t\tif(x&1) g = mrg(g,f);\n\t\tf = mrg(f,f);\n\t}\n\tans = mrg(g,a[(k-1)%6+1]);\n\tans = mrg(ans,inv(g));\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=100005;\nint n,k;\nstruct permutation\n{\n\tint a[N];\n\tinline permutation(void) { memset(a,0,sizeof(a)); }\n\tinline int& operator [] (CI x) { return a[x]; }\n\tinline friend permutation operator ~ (permutation A)\n\t{\n\t\tpermutation tp; for (RI i=1;i<=n;++i) tp[A[i]]=i; return tp;\n\t}\n\tinline friend permutation operator * (permutation A,permutation B)\n\t{\n\t\tpermutation C; for (RI i=1;i<=n;++i) C[i]=A[B[i]]; return C;\n\t}\n\tinline friend permutation operator ^ (permutation A,int p)\n\t{\n\t\tpermutation t; for (RI i=1;i<=n;++i) t[i]=i;\n\t\tfor (;p;p>>=1,A=A*A) if (p&1) t=t*A; return t;\n\t}\n\tinline void print(void)\n\t{\n\t\tfor (RI i=1;i<=n;++i) printf(\"%d \",a[i]);\n\t}\n}a[10],T;\nint main()\n{\n\tRI i; for (scanf(\"%d%d\",&n,&k),i=1;i<=n;++i) scanf(\"%d\",&a[1][i]);\n\tfor (i=1;i<=n;++i) scanf(\"%d\",&a[2][i]);\n\tfor (i=3;i<=6;++i) a[i]=a[i-1]*(~a[i-2]);\n\tint d=k/6,r=k%6; if (!r) --d,r=6; T=a[2]*(~a[1])*(~a[2])*a[1];\n\treturn ((T^d)*a[r]*((~T)^d)).print(),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> inv(const vector<int>& p){\n    vector<int> res(p.size());\n    for(int i=0;i<p.size();i++) res[p[i]] = i;\n    return res;\n}\n\nvector<int> mul(const vector<int>& p, const vector<int>& q){\n    vector<int> res(p.size());\n    for(int i=0;i<p.size();i++) res[i] = p[q[i]];\n    return res;\n}\n\nvector<int> pow(const vector<int>& p, int K){\n    const int N = p.size();\n    if(K == 0){\n        vector<int> res(N);\n        for(int i=0;i<N;i++) res[i] = i;\n        return res;\n    }\n    auto res = pow(p, K/2);\n    res = mul(res, res);\n    if(K%2 == 1) res = mul(res, p);\n    return res;\n}\n\nint main(){\n    int N, K; cin >> N >> K;\n    vector<int> p(N), q(N);\n    for(auto& t : p){ cin >> t; --t; }\n    for(auto& t : q){ cin >> t; --t; }\n    auto pInv = inv(p);\n    auto qInv = inv(q);\n    auto r = mul(mul(mul(q, pInv), qInv), p);\n    r = pow(r, K/6);\n    auto rInv = inv(r);\n    auto cur = mul(mul(r, p), rInv);\n    auto next = mul(mul(r, q), rInv);\n    int k = K/6*6+1;\n    while(k < K){\n        auto tmp = next;\n        next = mul(next, inv(cur));\n        cur = tmp;\n        ++k;\n    }\n    for(auto& t : cur) cout << t+1 << \" \";\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct Perm {\n  VI data;\n\n  Perm(int sz) : data(sz) {}\n  Perm(VI x) : data(x) {}\n\n  Perm operator*(const Perm &rhs) const {\n    VI ans(SZ(data));\n    for (int i = 0; i < SZ(data); ++i) {\n      ans[i] = data[rhs.data[i]];\n    }\n    return ans;\n  }\n\n  Perm Inv() const {\n    VI ans(SZ(data));\n    for (int i = 0; i < SZ(data); ++i) {\n      ans[data[i]] = i;\n    }\n    return ans;\n  }\n\n  Perm Pow(int k) const {\n    Perm ans(SZ(data));\n    for (int i = 0; i < SZ(data); ++i) { ans.data[i] = i; }\n    Perm coef = *this;\n\n    while (k) {\n      if (k & 1) { ans = ans * coef; }\n      k >>= 1;\n      coef = coef * coef;\n    }\n    return ans;\n  }\n};\n\nvoid Out(const Perm &p) {\n  for (int v : p.data) { cout << v + 1 << \" \"; }\n  cout << \"\\n\";\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, K;\n  cin >> N >> K;\n\n  Perm p(N), q(N);\n  for (int i = 0; i < N; ++i) {\n    cin >> p.data[i]; --p.data[i];\n  }\n  for (int i = 0; i < N; ++i) {\n    cin >> q.data[i]; --q.data[i];\n  }\n\n  if (K == 1) { Out(p); return 0; }\n  if (K == 2) { Out(q); return 0; }\n\n  const int njumps = (K - 2) / 6;\n  Perm coef = (q * p.Inv() * q.Inv() * p).Pow(njumps);\n\n  Perm a = coef * p * coef.Inv();\n  Perm b = coef * q * coef.Inv();\n  int cur_b = 6 * njumps + 2;\n\n  while (cur_b < K) {\n    tie(a, b) = make_pair(b, b * a.Inv());\n    ++cur_b;\n  }\n\n  Out(b);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair < int , int > pii;\ntypedef long long LL;\n#define mpr make_pair\n#define FS first\n#define SC second\n#define PB push_back\ntemplate < typename T > T MAX(T a,T b){return (a>b)?a:b;}\ntemplate < typename T > T MIN(T a,T b){return (a<b)?a:b;}\ntemplate < typename T > void UMAX(T &a,T b){a=(a>b?a:b);}\ntemplate < typename T > void UMIN(T &a,T b){a=(a<b?a:b);}\nint readint(){\n\tchar c=getchar();\n\tint ret=0;\n\twhile(!(c>='0' && c<='9')) c=getchar();\n\twhile(c>='0' && c<='9'){\n\t\tret=ret*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn ret;\n}\nvoid putint(int v){\n\tif(!v){\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif(v>=10) putint(v/10);\n\tputchar('0'+(v%10));\n}\nconst int fhp[4]={-2,1,2,-1},fmd[6]={1,2,2,-1,-2,-2};\nint n,m;\nstruct permu{\n\tvector < int > p;\n\tvoid read(){\n\t\tp.resize(n);\n\t\tint i;\n\t\tfor(i=0;i<n;++i){\n\t\t\tscanf(\"%d\",&p[i]);\n\t\t\t--p[i];\n\t\t}\n\t}\n\tvoid print(){\n\t\tint i;\n\t\tfor(i=0;i<n;++i){\n\t\t\tprintf(\"%d \",p[i]+1);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tvoid init(){\n\t\tp.resize(n);\n\t\tint i;\n\t\tfor(i=0;i<n;++i) p[i]=i;\n\t}\n};\npermu M(permu A,permu B){\n\tpermu ret;\n\tret.init();\n\tint i;\n//\tprintf(\"%d %d\\n\",(int)A.p.size(),(int)B.p.size());\n\tfor(i=0;i<n;++i){\n\t\tret.p[i]=B.p[A.p[i]];\n\t}\n\treturn ret;\n}\npermu P(permu A,int T){\n\tpermu R;\n\tR.init();\n\twhile(T){\n\t\tif(T&1) R=M(R,A);\n\t\tT>>=1;\n\t\tA=M(A,A);\n\t}\n\treturn R;\n}\npermu inv(permu A){\n\tpermu ret;\n\tret.init();\n\tint i;\n\tfor(i=0;i<n;++i) ret.p[A.p[i]]=i;\n\treturn ret;\n}\npermu p,q,ip,iq;\npermu eval(int v){\n\tif(v==1)\n\t\treturn p;\n\telse if(v==-1)\n\t\treturn ip;\n\telse if(v==2)\n\t\treturn q;\n\telse\n\t\treturn iq;\n}\nint getsz(int m){\n\tif(m==1) return 1;\n\tint id=(m+1)/3;\n\treturn (id-1)*4+1+(m+1)%3;\n}\nint main(){\n\tint i,j,k;\n\tscanf(\"%d%d\",&n,&m);\n\tp.read();\n\tq.read();\n\tip=inv(p);\n\tiq=inv(q);\n\tint S=getsz(m);\n//\tprintf(\"S=%d\\n\",S);\n\tpermu ALLP=M(eval(fhp[0]),M(eval(fhp[1]),M(eval(fhp[2]),eval(fhp[3]))));\n\tpermu LLL=P(ALLP,((S&1)?(S/2):(S/2-1))/4),MMM=eval(fmd[(m-1)%6]),RRR;\n\tint t=(S/2)%4;\n\tfor(i=0;i<t;++i) LLL=M(LLL,eval(fhp[i]));\n\tRRR=inv(LLL);\n\tif(S&1)\n\t\tM(M(LLL,MMM),RRR).print();\n\telse if(m&1)\n\t\tM(LLL,M(M(eval(-1),eval(2)),RRR)).print();\n\telse\n\t\tM(LLL,M(M(eval(1),eval(-2)),RRR)).print();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\ntypedef long double ld;\ntypedef long long ll;\n\ntypedef vector<ll> vii;\n\nvii inv(const vii &A) {\n  vii B = A;\n  reverse(all(B));\n  for (auto &x : B)\n    x *= -1;\n  return B;\n}\n\nvii comb(const vii &A, const vii &B) {\n  vii C = A;\n  for (int x : B) {\n    if (!C.empty() && C.back() == -x) {\n      C.pop_back();\n    } else {\n      C.push_back(x);\n    }\n  }\n  return C;\n}\n\nvoid print(vii A) {\n  cerr << A.size() << \": \";\n  for (int x : A) {\n    cerr << x << \" \";\n  }\n  cerr << \"\\n\";\n}\n\nvoid rem_same(vii &A, vii &B) {\n  while (!A.empty() && !B.empty() && A.back() == B.back()) {\n    A.pop_back();\n    B.pop_back();\n  }\n}\n\nvoid diff(vii A, vii B) {\n  for (int i = 0; i < 2; ++i) {\n    rem_same(A, B);\n    reverse(all(A));\n    reverse(all(B));\n  }\n  assert(A.empty());\n  //print(A);\n  print(B);\n  //cerr << endl;\n}\n\n\ntypedef vector<int> Perm;\n\nvoid print(Perm A) {\n  for (int x : A) {\n    cerr << x + 1 << \" \";\n  }\n  cerr << \"\\n\";\n}\n\n\n\nint n;\n\nPerm inverse(const Perm &p) {\n  Perm q(n);\n  for (int i = 0; i < n; ++i) {\n    q[p[i]] = i;\n  }\n  return q;\n}\n\nPerm comb(const Perm &p, const Perm &q) {\n  Perm s(n);\n  for (int i = 0; i < n; ++i)\n    s[i] = p[q[i]];\n  return s;\n}\n\nPerm id() {\n  Perm p(n);\n  iota(all(p), 0);\n  return p;\n}\n\nPerm pow(Perm p, ll to) {\n  Perm q = id();\n  while (to) {\n    if (to & 1) {\n      q = comb(q, p);\n    }\n    p = comb(p, p);\n    to >>= 1;\n  }\n  return q;\n}\n\nvii my_prod(int n) {\n  if (n == 1) {\n    return {1};\n  } else if (n == 2) {\n    return {2};\n  }\n\n  vii L = {2}, R = {};\n  for (int i = 3; i <= n; ++i) {\n    if (i % 6 == 3) {\n      L.push_back(-1);\n    } else if (i % 6 == 4) {\n      R.push_back(-2);\n    } else if (i % 6 == 5) {\n      L.push_back(-2);\n      R.push_back(1);\n    } else if (i % 6 == 0) {\n      L.push_back(1);\n    } else if (i % 6 == 1) {\n      R.push_back(2);\n    } else if (i % 6 == 2) {\n      L.push_back(2);\n      R.push_back(-1);\n    }\n  }\n\n  vii ans = L;\n  reverse(all(R));\n  for (int x : R)\n    ans.push_back(x);\n\n  return ans;\n}\n\nPerm get_naive(Perm p, Perm q, int k) {\n  if (k == 1) {\n    return p;\n  } \n  for (int i = 3; i <= k; ++i) {\n    p = comb(q, inverse(p));\n    swap(p, q);\n  }\n  return q;\n}\n\nPerm get(Perm p, Perm q, ll k) {\n  if (k == 1) {\n    return p;\n  } else if (k == 2) {\n    return q;\n  }\n\n  Perm x = comb(inverse(p), comb(inverse(q), comb(p, q)));\n  Perm y = comb(inverse(p), comb(q, comb(p, inverse(q))));\n\n  Perm L = q;\n  Perm R = id();\n\n  ll times = (k - 2) / 6;\n  L = comb(L, pow(x, times));\n  R = pow(y, times);\n\n\n  for (int i = 6 * times + 3; i <= k; ++i) {\n    if (i % 6 == 3) {\n      //L.push_back(-1);\n      L = comb(L, inverse(p));\n    } else if (i % 6 == 4) {\n      //R.push_back(-2);\n      R = comb(inverse(q), R);\n    } else if (i % 6 == 5) {\n      //L.push_back(-2);\n      L = comb(L, inverse(q));\n      //R.push_back(1);\n      R = comb(p, R);\n    } else if (i % 6 == 0) {\n      //L.push_back(1);\n      L = comb(L, p);\n    } else if (i % 6 == 1) {\n      //R.push_back(2);\n      R = comb(q, R);\n    } else if (i % 6 == 2) {\n      //L.push_back(2);\n      L = comb(L, q);\n      //R.push_back(-1);\n      R = comb(inverse(p), R);\n    }\n  }\n\n  //print(L);\n  //print(R);\n\n  Perm ans = comb(L, R);\n  \n  return ans;\n}\n\nvoid experiment() {\n  vii A = {1};\n  vii B = {2};\n  for (int i = 3; i < 300; ++i) {\n    A = comb(B, inv(A));\n    swap(A, B);\n    print(B);\n    print(my_prod(i));\n    assert(B == my_prod(i));\n    //cerr << \"\\n\";\n    //diff(A, B);\n  }\n}\n\n\n\n  \n\nint main() {\n#ifdef LOCAL\n  assert(freopen(\"d.in\", \"r\", stdin));\n#endif\n\n  //experiment();\n\n  ios_base::sync_with_stdio(false);\n\n  cin >> n;\n  int k;\n  cin >> k;\n  Perm p(n), q(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i];\n    --p[i];\n  }\n\n  for (int i = 0; i < n; ++i) {\n    cin >> q[i];\n    --q[i];\n  }\n\n\n  //for (int i = 1; i <= 100; ++i) {\n    \n    //auto A = get(p, q, i);\n    //auto B = get_naive(p, q, i);\n    //if (A != B) {\n      //print(A);\n      //print(B);\n      //cerr << \"i = \" << i << \"\\n\";\n      //assert(!\"coinc\");\n    //}\n\n    //cerr << i << \" ok.\\n\";\n  //}\n\n  Perm ans = get(p, q, k);\n  for (int i = 0; i < n; ++i) {\n    cout << ans[i] + 1 << \" \";\n  }\n  cerr << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int MN = 100005;\n\nint N, K;\nstruct per {\n\tint a[MN];\n\tper() {}\n\tint & operator [] (const int &i) { return a[i]; }\n\tfriend per operator ~ (per A) {\n\t\tper C;\n\t\tfor (int i = 1; i <= N; ++i) C[A[i]] = i;\n\t\treturn C;\n\t}\n\tfriend per operator * (per A, per B) {\n\t\tper C;\n\t\tfor (int i = 1; i <= N; ++i) C[i] = A[B[i]];\n\t\treturn C;\n\t}\n\tfriend per operator ^ (per B, int E) {\n\t\tper A;\n\t\tfor (int i = 1; i <= N; ++i) A[i] = i;\n\t\tfor (; E; E >>= 1, B = B * B)\n\t\t\tif (E & 1) A = A * B;\n\t\treturn A;\n\t}\n} p, q, ip, iq, qip, iqp, qipiqp, ans;\n\nint main() {\n\tscanf(\"%d%d\", &N, &K);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%d\", &p[i]);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%d\", &q[i]);\n\tip = ~p, iq = ~q;\n\tqip = q * ip, iqp = iq * p;\n\tqipiqp = qip * iqp;\n\tans = qipiqp ^ (K / 6);\n\tif (K % 6 == 0) ans = ans * iqp * ~ans;\n\tif (K % 6 == 1) ans = ans * p * ~ans;\n\tif (K % 6 == 2) ans = ans * q * ~ans;\n\tif (K % 6 == 3) ans = ans * qip * ~ans;\n\tif (K % 6 == 4) ans = ans * qip * iq * ~ans;\n\tif (K % 6 == 5) ans = ans * qip * iqp * iq * ~ans;\n\tfor (int i = 1; i <= N; ++i) printf(\"%d%c\", ans[i], \" \\n\"[i == N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2019.5.20 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define eps 1e-10\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ninline int read() {\n    res s=0,ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return s;\n}\ninline LL Read() {\n    RG LL s=0;\n    res ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return s;\n}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=1e5+10;\nnamespace MAIN {\n    int n,k;\n    typedef vector<int> vec;\n    vec a[7];\n    inline vec Read(){\n        RG vec ret(n);\n        for(res i=0;i<n;i++)ret[i]=read()-1;\n        return ret;\n    }\n    inline void print(const RG vec &a){\n        for(res i=0;i<n;i++)printf(\"%d \",a[i]+1);\n        puts(\"\");\n    }\n    inline vec getinv(const RG vec &a){\n        RG vec ret(n);\n        for(res i=0;i<n;i++)ret[a[i]]=i;\n        return ret;\n    }\n    inline vec mul(const RG vec &a,const RG vec &b){\n        RG vec ret(n);\n        for(res i=0;i<n;i++)ret[i]=a[b[i]];\n        return ret;\n    }\n    inline vec qpow(RG vec x,res y){\n        RG vec ret(n);\n        for(res i=0;i<n;i++)ret[i]=i;\n        while(y){\n            if(y&1)ret=mul(ret,x);\n            x=mul(x,x),y>>=1;\n        }\n        return ret;\n    }\n    vec p,q;\n    inline void MAIN(){\n        n=read(),k=read(),p=Read(),q=Read();\n        a[1]=p,a[2]=q;\n        for(res i=3;i<=6;i++)a[i]=mul(a[i-1],getinv(a[i-2]));\n        RG vec A=mul(mul(q,getinv(p)),mul(getinv(q),p)),B=qpow(A,(k-1)/6);\n        print(mul(mul(B,a[(k-1)%6+1]),getinv(B)));\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n//    freopen(\"graph.in\",\"r\",stdin);\n//    freopen(\"graph.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\ntemplate<class A, class B> A operator+=(A& l, const B& r) { return l = l+r; }\ntemplate<class A, class B> A operator-=(A& l, const B& r) { return l = l-r; }\ntemplate<class A, class B> A operator*=(A& l, const B& r) { return l = l*r; }\ntemplate<class A, class B> A operator/=(A& l, const B& r) { return l = l/r; }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modInt {\n    T val;\n    T mod = 0;\n    // static const T mod = MOD;\n\n    void normalize() {\n        if (mod == 0) return;\n        val %= mod; if (val < 0) val += mod;\n    }\n    modInt(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }\n    // modInt(T v = 0, T m = 0) : val(v) { normalize(); }\n\n    explicit operator T() const { return val; }\n    friend ostream& operator<<(ostream& os, const modInt& a) { return os << a.val; }\n    friend bool operator==(const modInt& a, const modInt& b) { return a.val == b.val; }\n    friend bool operator!=(const modInt& a, const modInt& b) { return !(a == b); }\n\n    friend void check(modInt& a, modInt& b) { // make sure all operations are valid\n        // comment out if mod is static const\n        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }\n        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;\n        if (a.mod != mod) { a.mod = mod; a.normalize(); }\n        if (b.mod != mod) { b.mod = mod; b.normalize(); }\n    }\n    friend modInt operator+(modInt a, modInt b) {\n        check(a,b); a.val += (T)b;\n        if (a.val >= a.mod) a.val -= a.mod;\n        return a;\n    }\n    friend modInt operator-(modInt a, modInt b) {\n        check(a,b); a.val -= (T)b; \n        if (a.val < 0) a.val += a.mod; \n        return a;\n    }\n    friend modInt operator-(const modInt& a) { return modInt(0)-a; }\n\n    friend modInt operator*(modInt a, modInt b) {\n        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;\n    }\n    friend modInt exp(modInt a, ll p) {\n        modInt ans(1,a.mod);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modInt inv(const modInt& a) {\n        return {invGeneral(a.val,a.mod),a.mod};\n        // return exp(b,b.mod-2) if prime\n    }\n    friend modInt operator/(modInt a, modInt b) { \n        check(a,b); return a*inv(b); \n    }\n};\n\ntypedef modInt<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N,K;\n\nvi f(vi p, vi q) {\n    vi res(sz(p));\n    F0R(i,sz(p)) res[p[i]-1] = q[i];\n    return res;\n}\n\n\nvi inv(vi v) {\n    vi tmp(sz(v));\n    F0R(i,sz(v)) tmp[v[i]-1] = i+1;  \n    return tmp;\n}\n\nvi operator*(const vi& l, const vi& r) {\n    vi res(sz(l));\n    F0R(i,sz(l)) res[i] = r[l[i]-1];\n    return res;\n}\n\nvi po(vi x, int y) {\n    if (y == 0) {\n        vi v(N); F0R(i,N) v[i] = i+1;\n        return v;\n    }\n    auto a = po(x*x,y/2); if (y&1) a = a*x;\n    return a;\n}\n\nvoid fin(vi res){\n    trav(t,res) cout << t << \" \";\n    exit(0);\n}\n\nint main() {\n    setIO(); re(N,K);\n    vi p(N), q(N); re(p,q);\n    /*vector<vi> v;\n    v.pb(p), v.pb(q);\n    F0R(i,K-2) v.pb(f(v[sz(v)-2],v[sz(v)-1]));\n    // trav(a,v) ps(a);\n    ps(v.back());\n    ps(inv(p)*q);*/\n    if (K == 1) fin(p);\n    vi cool = po(inv(q)*p*q*inv(p),(K-2)/6);\n    vi res = cool;\n    if (K % 6 == 2) res = res*q;\n    if (K % 6 == 3) res = res*inv(p)*q;\n    if (K % 6 == 4) res = res*inv(q)*inv(p)*q;\n    if (K % 6 == 5) res = res*inv(q)*p*inv(q)*inv(p)*q;\n    if (K % 6 == 0) res = res*inv(q)*p*p*inv(q)*inv(p)*q;\n    if (K % 6 == 1) res = res*inv(q)*p*q*p*inv(q)*inv(p)*q;\n    res *= inv(cool);\n    fin(res);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <tuple>\ntemplate <typename T> constexpr T my_abs(const T &x) { return x < 0 ? -x : x; }\nusing ll = long long;\nstruct permutation : std::vector<int>\n{\n\tpermutation(int n = 0) { resize(n); for (int i = 0; i < n; i++) at(i) = i; }\n\tinline permutation operator *(const permutation &a) const\n\t{\n\t\tpermutation res(size());\n\t\tfor (int i = 0; i < size(); i++)\n\t\t\tres[i] = at(a[i]);\n\t\treturn res;\n\t}\n\tinline permutation inv() const\n\t{\n\t\tpermutation res(size());\n\t\tfor (int i = 0; i < size(); i++)\n\t\t\tres[at(i)] = i;\n\t\treturn res;\n\t}\n};\ninline permutation quick_pow(permutation a, int n)\n{\n\tpermutation res(a.size());\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a;\n\t\ta = a * a;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\ninline void output(permutation a)\n{\n\tfor (int i = 0; i < a.size(); i++)\n\t\tprintf(\"%d%c\", a[i] + 1, \" \\n\"[i + 1 == a.size()]);\n}\nint main()\n{\n\t// freopen(\"AGC031-D.in\", \"r\", stdin);\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tpermutation a(n), b(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &b[i]);\n\t\tb[i]--;\n\t}\n\tif (k == 1)\n\t{\n\t\toutput(a);\n\t\treturn 0;\n\t}\n\tif (k == 2)\n\t{\n\t\toutput(b);\n\t\treturn 0;\n\t}\n\tk -= 3;\n\tpermutation ra = a.inv(), rb = b.inv();\n\tpermutation pl = quick_pow(rb * a * b * ra, k / 8);\n\tpermutation pr = quick_pow(ra * b * a * rb, k / 8);\n\tk %= 8;\n\tstd::vector<permutation> vec = {rb, a, b, ra};\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (i * 2 < k)\n\t\t\tpl = pl * vec[i];\n\t\tif (i * 2 + 1 < k)\n\t\t\tpr = vec[i] * pr;\n\t}\n\toutput(b * ra * pl * pr);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int>& apply(vector<int> &a, vector<int> &b)\n{\n\tvector<int> r(a.size());\n\n\tfor (int i = 0; i < b.size(); i++) r[i] = a[b[i]];\n\n\treturn move(r);\n}\n\nvector<int>& pow(vector<int> &a, int k)\n{\n\tvector<int> r(a.size());\n\n\tif (k == 0){\n\t\tfor (int i = 0; i < a.size(); i++) r[i] = i;\n\t}\n\telse{\n\t\tauto h = pow(a, k / 2);\n\t\tr = apply(h, h);\n\t\tif (k % 2){\n\t\t\tfor (int i = 0; i < r.size(); i++) r[i] = a[r[i]];\n\t\t}\n\t}\n\n\treturn move(r);\n}\n\n\nint main()\n{\n\tint N, K; scanf (\"%d %d\", &N, &K);\n\tvector<int> p(N), q(N), P(N), Q(N);\n\tfor (int i = 0; i < N; i++){\n\t\tscanf (\"%d\", &p[i]); p[i]--;\n\t\tP[p[i]] = i;\n\t}\n\tfor (int i = 0; i < N; i++){\n\t\tscanf (\"%d\", &q[i]); q[i]--;\n\t\tQ[q[i]] = i;\n\t}\n\n\tvector<int> r;\n\tif (K == 1) r = p;\n\telse{\n\t\tint u = (K - 2) / 6;\n\t\tvector<int> X = pow(apply(P, apply(q, apply(p, Q))), u);\n\n\t\tvector<int> C;\n\n\t\tif (K % 6 == 0) C = apply(p, Q);\n\t\tif (K % 6 == 1) C = apply(q, apply(p, Q));\n\t\tif (K % 6 == 2) C = q;\n\t\tif (K % 6 == 3) C = apply(q, P);\n\t\tif (K % 6 == 4) C = apply(q, apply(P, Q));\n\t\tif (K % 6 == 5) C = Q;\n\n\t\tint v = (K + 1) / 6;\n\t\tvector<int> Y = pow(apply(q, apply(P, apply(Q, p))), v);\n\n\t\tr = apply(Y, apply(C, X));\n\t}\n\n\tfor (int i = 0; i < N; i++) printf (\"%d%c\", r[i] + 1, i + 1 < N ? ' ' : '\\n');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=100005;\nint n,k;\nclass Perm{\npublic:\n\tint to[maxn];\n\tvoid init(){\n\t\tREP(i,n){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tto[x]=i;\n\t\t}\n\t}\n\tPerm inv(){\n\t\tPerm res;\n\t\tREP(i,n)res.to[to[i]]=i;\n\t\treturn res;\n\t}\n\tPerm operator * (const Perm &o)const{\n\t\tPerm res;\n\t\tREP(i,n)res.to[i]=o.to[to[i]];\n\t\treturn res;\n\t}\n}id,p,q,cur,a[6],b[6];\nPerm quickpow(Perm x,int pow){\n\tPerm res=id;\n\tfor(;pow;pow>>=1){\n\t\tif(pow&1)res=res*x;\n\t\tx=x*x;\n\t}\n\treturn res;\n}\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d\",&n,&k);\n\tk--;\n\tp.init();\n\tq.init();\n\tREP(i,n)id.to[i]=i;\n\ta[0]=a[1]=a[2]=id;\n\ta[3]=b[1]=q;\n\ta[4]=a[5]=b[2]=q*p.inv();\t\n\tb[0]=p;\n\tb[3]=p.inv();\n    b[4]=q.inv();\n    b[5]=q.inv()*p;\n\tcur=q*p.inv()*q.inv()*p;\n\tcur=quickpow(cur,k/6)*a[k%6];\n\tcur=(cur*b[k%6]*cur.inv()).inv();\n\tREP(i,n)printf(\"%d \",cur.to[i]);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nint n,k,x;\nvec ans,a[4],L,R;\nvec rev(vec v){\n\tvec ans;\n\tans.resize(n+1);\n\tFOR(i,1,n) ans[v[i]]=i;\n\treturn ans;\n}\nvec mul(vec a,vec b){\n\tvec c;\n\tc.clear();\n\tc.pb(0);\n\tFOR(i,1,n) c.pb(b[a[i]]);\n\treturn c;\n}\nvec pw(vec x,int y){\n\tvec t;\n\tt.clear();\n\tt.pb(0);\n\tFOR(i,1,n) t.pb(i);\n\tfor (;y;y>>=1){\n\t\tif (y&1) t=mul(t,x);\n\t\tx=mul(x,x);\n\t}\n\treturn t;\n}\nint main(){\n\t//a1 0\n\t//rev a1 1\n\t//a2 2\n\t//rev a2 3\n\tcin>>n>>k;\n\ta[0].pb(0);\n\tFOR(i,1,n){\n\t\tgetint(x);\n\t\ta[0].pb(x);\n\t}\n\ta[2].pb(0);\n\tFOR(i,1,n){\n\t\tgetint(x);\n\t\ta[2].pb(x);\n\t}\n\ta[1]=rev(a[0]);\n\ta[3]=rev(a[2]);\n\tL=mul(mul(mul(a[3],a[0]),a[2]),a[1]);\n\tR=mul(mul(mul(a[0],a[3]),a[1]),a[2]);\n\tif (k==1){\n\t\tFOR(i,1,n) printf(\"%d \",a[1][i]);\n\t\treturn 0;\n\t}\n\tif (k%6==2){\n\t\tans=pw(L,k/6);\n\t\tans=mul(ans,a[2]);\n\t\tans=mul(ans,pw(R,k/6));\n\t}\n\tif (k%6==3){\n\t\tans=pw(L,k/6);\n\t\tans=mul(ans,a[1]);\n\t\tans=mul(ans,a[2]);\n\t\tans=mul(ans,pw(R,k/6));\n\t}\n\tif (k%6==4){\n\t\tans=pw(L,k/6);\n\t\tans=mul(ans,a[3]);\n\t\tans=mul(ans,a[1]);\n\t\tans=mul(ans,a[2]);\n\t\tans=mul(ans,pw(R,k/6));\n\t}\n\tif (k%6==5){\n\t\tans=pw(L,k/6);\n\t\tans=mul(ans,a[3]);\n\t\tans=mul(ans,pw(R,k/6+1));\n\t}\n\tif (k%6==0){\n\t\tans=pw(L,k/6-1);\n\t\tans=mul(ans,a[3]);\n\t\tans=mul(ans,a[0]);\n\t\tans=mul(ans,pw(R,k/6));\n\t}\n\tif (k%6==1){\n\t\tans=pw(L,k/6-1);\n\t\tans=mul(ans,a[3]);\n\t\tans=mul(ans,a[0]);\n\t\tans=mul(ans,a[2]);\n\t\tans=mul(ans,pw(R,k/6));\n\t}\n\tFOR(i,1,n) printf(\"%d \",ans[i]);\n\treturn 0;\n}\n/*\n0\n2\n12\n312\n30312\n300312\n3020312\n302120312\n3021120312\n30213120312\n3021303120312\n30213003120312\n302130203120312\n30213021203120312\n302130211203120312\n3021302131203120312\n302130213031203120312\n3021302130031203120312\n30213021302031203120312\n3021302130212031203120312\n30213021302112031203120312\n302130213021312031203120312\n30213021302130312031203120312\n302130213021300312031203120312\n3021302130213020312031203120312\n302130213021302120312031203120312\n3021302130213021120312031203120312\n30213021302130213120312031203120312\n3021302130213021303120312031203120312\n30213021302130213003120312031203120312\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\nusing namespace std;\nconst int N=1e5+5;\nint n,k;\nint p[N],q[N],ip[N],iq[N],f[N],_f[N],a[N],b[N];\nvoid get(int k){\n\tif(k==0)return;\n\tget(k>>1);\n\tfo(i,1,n)a[i]=f[f[i]];\n\tif(k&1)\n\t\tfo(i,1,n)f[i]=a[q[ip[iq[p[i]]]]];\n\telse fo(i,1,n)f[i]=a[i];\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>k;\n\tfo(i,1,n)cin>>p[i],ip[p[i]]=i;\n\tfo(i,1,n)cin>>q[i],iq[q[i]]=i;\n\tfo(i,1,n)f[i]=i;\n\tget((k-1)/6);\n\tif(k%6==4){\n\t\tfo(i,1,n)a[i]=f[q[i]];\n\t\tfo(i,1,n)f[i]=a[i];\n\t}\n\tif(k%6==0||k%6==5){\n\t\tfo(i,1,n)a[i]=f[q[ip[i]]];\n\t\tfo(i,1,n)f[i]=a[i];\n\t}\n\tfo(i,1,n)_f[f[i]]=i;\n\tif(k%6==1)fo(i,1,n)b[i]=f[p[i]];\n\tif(k%6==2)fo(i,1,n)b[i]=f[q[i]];\n\tif(k%6==3)fo(i,1,n)b[i]=f[q[ip[i]]];\n\tif(k%6==4)fo(i,1,n)b[i]=f[ip[i]];\n\tif(k%6==5)fo(i,1,n)b[i]=f[iq[i]];\n\tif(k%6==0)fo(i,1,n)b[i]=f[iq[p[i]]];\n\tfo(i,1,n)a[i]=b[_f[i]];\n\tfo(i,1,n)printf(\"%d \",a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nvector<int>p, q, A, ans;\n\nvector<int> operator * (const vector<int>&a,const vector<int>&b){\n    vector<int>c; c.resize(n+1);\n    for (int i=1;i<=n;++i) c[i]=a[b[i]];\n    return c;\n}\nvector<int> ni(const vector<int>&a){\n    vector<int>c; c.resize(n+1);\n    for (int i=1;i<=n;++i) c[a[i]]=i;\n    return c;\n}\n\nvector<int> K(vector<int>x,int y){\n    --y; vector<int>t=x;\n    for (;y;y>>=1,x=x*x)\n        if (y&1) t=t*x;\n    return t;\n}\n\nvector<int> gao(int m){\n    vector<int>f[100];\n    f[1]=p; f[2]=q;\n    for (int i=3;i<=m;++i) f[i]=f[i-1]*ni(f[i-2]);\n    return f[m];\n}\n\nint main(){\n    cin>>n>>k;\n    p.resize(n+1); q.resize(n+1);\n    for (int i=1;i<=n;++i) cin>>p[i];\n    for (int i=1;i<=n;++i) cin>>q[i];\n    A=q*ni(p)*ni(q)*p;\n    if (k<30) ans=gao(k);\n    else{\n        int t=k/6-3;\n        ans=K(A,t)*gao(k-t*6)*K(ni(A),t);\n    }\n    for (int i=1;i<=n;++i) cout<<ans[i]<<' ';\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\ntypedef vector<int> perm;\nperm operator + (const perm &a, const perm &b) {\n  perm c(n, 0);\n  for (int i = 0; i < n; i++) {\n    c[i] = b[a[i]];\n  }\n  return c;\n}\nperm operator ~ (const perm &a) {\n  perm c(n);\n  for (int i = 0; i < n; i++) {\n    c[a[i]] = i;\n  }\n  return c;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  perm a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    --a[i];\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &b[i]);\n    --b[i];\n  }\n  perm p = ~b + a + b + ~a, q(n);\n  vector<int> visit(n, 0), d;\n  for (int i = 0; i < n; i++) {\n    if (!visit[i]) {\n      d.clear();\n      int j = i;\n      do {\n        d.push_back(j);\n        visit[j] = 1;\n        j = p[j];\n      } while (j ^ i);\n      for (int j = 0; j < (int) d.size(); j++) {\n        q[d[j]] = d[(j + (k - 1) / 6) % d.size()];\n      }\n    }\n  }\n  a = q + a + ~q;\n  b = q + b + ~q;\n  for (int t = (k - 1) % 6; t; t--) {\n    perm c = ~a + b;\n    a = b, b = c;\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d%c\", a[i] + 1, i == n - 1 ? '\\n' : ' ');\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nstruct node\n{\n    int a[100005];\n}p,q,s[7];\nnode inv(node x)\n{\n    node s;\n    for(int i=1;i<=n;i++)\n        s.a[x.a[i]]=i;\n    return s;\n}\nnode mul(node x,node y)\n{\n    node z;\n    for(int i=1;i<=n;i++)\n        z.a[i]=y.a[x.a[i]];\n    return z;\n}\nnode qpow(node x,int y)\n{\n    node ans;\n    for(int i=1;i<=n;i++)\n        ans.a[i]=i;\n    while(y)\n    {\n        if(y&1) ans=mul(ans,x);\n        x=mul(x,x);\n        y>>=1;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&p.a[i]);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&q.a[i]);\n    s[1]=p;s[2]=q;\n    for(int i=3;i<=6;i++)\n        s[i]=mul(s[i-1],inv(s[i-2]));\n    if(k<=6)\n    {\n        for(int i=1;i<=n;i++)\n            printf(i==n?\"%d\\n\":\"%d\",s[k].a[i]);\n        return 0;\n    }\n    node A=mul(mul(mul(q,inv(p)),inv(q)),p);\n    A=qpow(A,(k-1)/6);\n    node ans=(mul(A,s[k%6+1]),inv(A));\n    for(int i=1;i<=n;i++)\n        printf(i==n?\"%d\\n\":\"%d \",ans.a[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\n\ntypedef long long i64;\nconst int inf = (int)1.05e9;\n\n// c = a . b\nvoid mult(vector<int>& c, const vector<int> &a, const vector<int>& b)\n{\n\tconst int n = a.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tc[i] = a[b[i]];\n\t}\n}\n\n// b = a\nvoid copy(vector<int> &b, const vector<int> &a)\n{\n\tconst int n = a.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tb[i] = a[i];\n\t}\n}\n\nvoid rev(vector<int> &b, const vector<int> &a)\n{\n\tconst int n = a.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tb[a[i]] = i;\n\t}\n}\n\nvoid unit(vector<int>& a)\n{\n\tconst int n = a.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\ta[i] = i;\n\t}\n}\n\n// b = a ^ k\nvoid power(vector<int>& b, const vector<int> &a, const int k)\n{\n\tstatic vector<int> temp, a2;\n\tconst int n = a.size();\n\n\ta2.resize(n);\n\ttemp.resize(n);\n\tcopy(a2, a);\n\tunit(b);\n\n\tfor(int x = 0; x < 31; ++x) {\n\n\t\tif((k >> x) & 1) {\n\t\t\tmult(temp, b, a2);\n\t\t\tcopy(b, temp);\n\t\t}\n\n\t\tmult(temp, a2, a2);\n\t\tcopy(a2, temp);\n\t}\n}\n\nvoid print_answer(const vector<int>& xs)\n{\n\tconst int n = xs.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tprintf(\"%d\\n\", xs[i] + 1);\n\t}\n}\n\nint main()\n{\n\tint n, k;\n\tvector<int> ps, qs;\n\n\tscanf(\"%d%d\", &n, &k);\n\tps.resize(n);\n\tqs.resize(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &ps[i]);\n\t\tps[i] -= 1;\n\t}\n\tfor(int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &qs[i]);\n\t\tqs[i] -= 1;\n\t}\n\n\tif(k == 1) {\n\t\tprint_answer(ps);\n\t\treturn 0;\n\t} else if(k == 2) {\n\t\tprint_answer(qs);\n\t\treturn 0;\n\t}\n\n\tint sec = k / 3;\n\tint rem = k % 3;\n\n\tint first = (sec - 1) * 2 + rem;\n\tint second = (rem == 0) ? 2 : 1;\n\n\t// fprintf(stderr, \"first = %d, second = %d\\n\", first, second);\n\n\tvector<int> f[4];\n\n\tfor(int i = 0; i < 4; ++i) {\n\t\tf[i].resize(n);\n\t}\n\n\tcopy(f[0], qs);\n\trev(f[1], ps);\n\trev(f[2], qs);\n\tcopy(f[3], ps);\n\n\tvector<int> g(n), temp(n);\n\n\tunit(g);\n\tfor(int i = 0; i < 4; ++i) {\n\t\tmult(temp, g, f[i]);\n\t\tcopy(g, temp);\n\t}\n\n\tpower(temp, g, first / 4);\n\n\tcopy(g, temp);\n\tfor(int i = 0; i < first % 4; ++i) {\n\t\tmult(temp, g, f[i]);\n\t\tcopy(g, temp);\n\t}\n\n\tvector<int> rg(n);\n\trev(rg, g);\n\n\tvector<int> h(n);\n\n\tunit(h);\n\tfor(int i = 0; i < second; ++i) {\n\t\tmult(temp, h, f[(first % 4 + i) % 4]);\n\t\tcopy(h, temp);\n\t}\n\n\tvector<int> ans(n);\n\n\tmult(temp, g, h);\n\tmult(ans, temp, rg);\n\n\tprint_answer(ans);\n\n\treturn 0;\n}\n\n/* waffle */\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000000;\nconstexpr ll INF = 1000000000000000000;\nconstexpr ld EPS = 1e-12;\nconstexpr ld PI = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\nvector<int> operator *(vector<int> a, vector<int> b) {\n\tint n = b.size();\n\tvector<int> res(n);\n\trep(i, n) res[i] = a[b[i]];\n\treturn res;\n}\n\nvoid operator *=(vector<int> &a, vector<int> b) {\n\ta = a * b;\n}\n\nvector<int> perm_pow(vector<int> base, ll k) {\n\tint n = base.size();\n\tvector<int> ans(n);\n\trep(i, n) ans[i] = i;\n\twhile (k) {\n\t\tif (k & 1) ans *= base;\n\t\tbase *= base;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> p(n), q(n), pinv(n), qinv(n);\n\trep(i, n) {\n\t\tcin >> p[i];\n\t\tp[i]--;\n\t\tpinv[p[i]] = i;\n\t}\n\trep(i, n) {\n\t\tcin >> q[i];\n\t\tq[i]--;\n\t\tqinv[q[i]] = i;\n\t}\n\tvector<int> ans = q;\n\tif (k == 3) ans *= pinv;\n\telse {\n\t\tvector<int> x = pinv * qinv * p * q;\n\t\tans *= perm_pow(x, (k - 1) / 6);\n\t\tif ((k - 1) % 6 >= 3) ans *= pinv * qinv;\n\t\tif (k % 6 == 0) ans *= p;\n\t\tif (k % 6 == 3) ans *= pinv;\n\t\tif ((k - 2) % 6 >= 3) ans *= p * qinv;\n\t\tvector<int> y = pinv * q * p * qinv;\n\t\tans *= perm_pow(y, (k - 2) / 6);\n\t}\n\trep(i, n) cout << ans[i] + 1 << ' ';\n\tcout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n\n#define boost ios::sync_with_stdio(0); cin.tie(0)\n\n#define fi first\n#define se second\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\n\nconst int N = 1e6 + 5;\n\n/***************************************************************************/\n\nvector<int> identity(int n) {\n\tvector<int> A(n);\n\tfor(int i=0; i<n; i++) {\n\t\tA[i] = i;\n\t}\n\treturn A;\n}\n\nvector<int> inverse(vector<int> A) {\n\tvector<int> B(A.size());\n\tfor(int i=0; i<(int)B.size(); i++) {\n\t\tB[A[i]] = i;\n\t}\n\treturn B;\n}\n\nvector<int> multiply(vector<int> A, vector<int> B) {\n\tvector<int> C(A.size());\n\tfor(int i=0; i<(int)C.size(); i++) {\n\t\tC[i] = A[B[i]];\n\t}\n\treturn C;\n}\n\nvector<int> power(vector<int> A, int n) {\n\tif(n == 0) return identity(A.size());\n\tvector<int> B = power(A, n >> 1);\n\tB = multiply(B, B);\n\tif(n & 1) B = multiply(B, A);\n\treturn B;\n}\n\nint main() {\n\n\tboost;\n\tint n, k; cin>>n>>k; k--;\n\tvector<int> P(n), Q(n);\n\tfor(int i=0; i<n; i++) {\n\t\tcin>>P[i]; P[i]--;\n\t}\n\tfor(int i=0; i<n; i++) {\n\t\tcin>>Q[i]; Q[i]--;\n\t}\n\n\tvector<int> A = multiply(multiply(Q, inverse(P)), multiply(inverse(Q), P));\n\tA = power(A, k/6);\n\tk %= 6;\n\tif(k >= 3) A = multiply(A, Q);\n\tif(k > 3) A = multiply(A, inverse(P));\n\n\tvector<int> B = P;\n\tif(k == 1) B = Q;\n\telse if(k == 2) B = multiply(Q, inverse(P));\n\telse if(k == 3) B = inverse(P);\n\telse if(k == 4) B = inverse(Q);\n\telse if(k == 5) B = multiply(inverse(Q), P);\n\n\tvector<int> AK = multiply(A, multiply(B, inverse(A)));\n\tfor(int i=0; i<n; i++) {\n\t\tcout<<AK[i]+1<<\" \";\n\t}\n\tcout<<\"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i) \n\ntypedef std::vector<int> P;\nconst int N=100005;\n\nint n,k;\nP a[6];\n\nvoid print(P a){\n\tfor(int i=0;i<a.size();++i)printf(\"%d \",a[i]+1);puts(\"\");\n}\n\nP mul(P a,P b){\n\tP c(n);\n\trep(i,0,n-1)c[i]=a[b[i]];\n\treturn c;\n}\n\nP inv(P a){\n\tP b(n);\n\trep(i,0,n-1)b[a[i]]=i;\n\treturn b;\n}\n\nP fpow(P a,int b){\n\tP c(n);rep(i,0,n-1)c[i]=i;\n\tfor(;b;b>>=1,a=mul(a,a))if(b&1)c=mul(c,a);\n\treturn c;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);a[0].resize(n),a[1].resize(n);\n\trep(i,0,n-1)scanf(\"%d\",&a[0][i]),--a[0][i];\n\trep(i,0,n-1)scanf(\"%d\",&a[1][i]),--a[1][i];\n\trep(i,2,5)a[i]=mul(a[i-1],inv(a[i-2]));\n\tP A=mul(mul(a[1],inv(a[0])),mul(inv(a[1]),a[0])),B=fpow(A,(k-1)/6);\n\tprint(mul(mul(B,a[(k-1)%6]),inv(B)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,K;\nstruct Perm{\n\tint d[100010];\n\tint& operator[](int x){return d[x];}\n\tPerm inv()\n\t{\n\t\tPerm tmp;\n\t\tfor(int i=1;i<=n;++i)tmp.d[d[i]]=i;\n\t\treturn tmp;\n\t}\n}e;\nPerm operator * (Perm a,Perm b)\n{\n\tfor(int i=1;i<=n;++i)b[i]=a[b[i]];\n\treturn b;\n}\nPerm Ppow(Perm x,int k)\n{\n\tPerm r=e;\n\twhile(k)\n\t{\n\t\tif(k&1)r=r*x;\n\t\tk>>=1;x=x*x;\n\t}\n\treturn r;\n}\nPerm A[11];\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tfor(int i=1;i<=n;++i)e[i]=A[0][i]=i;\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&A[1][i]);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&A[2][i]);\n\tPerm p=A[1],ip=p.inv(),q=A[2],iq=q.inv();\n\tPerm s=q*ip*iq*p,is=ip*q*p*iq;\n\tPerm ans=Ppow(s,K/6);\n\tfor(int i=3;i<=K%6;++i)A[i]=A[i-1]*A[i-2].inv();\n\tans=ans*A[K%6];\n\tans=ans*Ppow(is,K/6);\n\tfor(int i=1;i<=n;++i)printf(\"%d \",ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL>PL;\nconst LL INF=1e18;\nint N;\ninline vector<int>inv(const vector<int>&V)\n{\n    vector<int>ret;\n    ret.resize(N);\n    int i;\n    for(i=0;i<N;i++)\n        ret[V[i]]=i;\n    return ret;\n}\ninline vector<int>operator*(const vector<int>&V1,const vector<int>&V2)\n{\n    vector<int>ret;\n    ret.resize(N);\n    int i;\n    for(i=0;i<N;i++)\n        ret[i]=V1[V2[i]];\n    return ret;\n}\nvector<int>idn;\ninline vector<int>Pow(vector<int>V,int K)\n{\n    vector<int>ret=idn;\n    while(K>0)\n    {\n        if(K&1)\n            ret=ret*V;\n        V=V*V;\n        K>>=1;\n    }\n    return ret;\n}\nint K,i,j;\nvector<int>A[6],B[7];\nvector<int>pinv,qinv,ans,t;\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>N>>K;\n    A[0].resize(N);\n    A[1].resize(N);\n    idn.resize(N);\n    for(i=0;i<N;i++)\n        cin>>A[0][i];\n    for(i=0;i<N;i++)\n        cin>>A[1][i];\n    for(i=0;i<N;i++)\n        A[0][i]--,A[1][i]--,idn[i]=i;\n    pinv=inv(A[0]);\n    qinv=inv(A[1]);\n    A[2]=A[1]*pinv;\n    A[3]=pinv;\n    A[4]=qinv;\n    A[5]=qinv*A[0];\n    B[0]=B[1]=B[2]=idn;\n    B[3]=A[1];\n    B[4]=B[5]=A[1]*pinv;\n    B[6]=B[5]*qinv;\n    B[6]=B[6]*A[0];\n    t=Pow(B[6],--K/6);\n    ans=t=t*B[K%6];\n    ans=ans*A[K%6];\n    t=inv(t);\n    ans=ans*t;\n    for(i=0;i<N;i++)\n        cout<<ans[i]+1<<' ';\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;const int N=1e5+10;typedef long long ll;\nint S;\nstruct data\n{\n\tint a[N];\n\tdata()\n\t{\n\t//\tprintf(\"construct!\\n\");\n\t\tfor(int i=0;i<N;i++)a[i]=0;\n\t//\tprintf(\"fin cons\\n\");\n\t}\n\tinline int& operator [](const int& x){return a[x];}\n\tinline data ginv()\n\t{\n\t\tdata c;\n\t\tfor(int i=1;i<=S;i++)c[a[i]]=i;\n\t\treturn c;\n\t} \n\tfriend data operator *(data a,data b)\n\t{\n\t\tdata c;\n\t\tfor(int i=1;i<=S;i++)c[i]=a[b[i]];\n\t\treturn c;\n\t}\n\tvoid operator =(data b)\n\t{\n\t\tfor(int i=1;i<=S;i++)a[i]=b[i];\n\t}\n}a,p,q,st;\ninline data f(data p,data q)\n{\n\treturn q*p.ginv();\n}\ninline data po(data a,int pw)\n{\n\tdata r;\n\tfor(int i=1;i<=S;i++)r[i]=i;\n\tfor(;pw;pw>>=1,a=a*a)if(pw&1)r=r*a;\n\treturn r;\n}\nint main()\n{\n//\tprintf(\"main_start\\n\");\n\tscanf(\"%d\",&S);int k;scanf(\"%d\",&k);\n\tfor(int i=1;i<=S;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=S;i++)scanf(\"%d\",&q[i]);\n\tint pw;int bas;\n\tif(k%6)\n\t\tpw=k/6,bas=k%6;\n\telse \n\t\tpw=k/6-1,bas=6;\n\ta=q*p.ginv()*q.ginv()*p;\n\tswitch(bas)\n\t{\n\t\tcase 1:{st=p;}\n\t\tcase 2:{st=q;}\n\t\tdefault:\n\t\t{\n\t\t\tfor(int i=3;i<=bas;i++)\n\t\t\t\tst=f(p,q),p=q,q=st;\n\t\t}\n\t}\n\tst=po(a,pw)*st*po(a.ginv(),pw);\n\tfor(int i=1;i<=S;i++)\n\t\tprintf(\"%d \",st[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\n\nvector<int> inv(vector<int> a) {\n  vector<int> b(n);\n  for (int i = 0; i < n; i++) {\n    b[a[i]] = i;\n  }\n  return b;\n}\n\nvector<int>& operator*=(vector<int>& a, vector<int> b) {\n  vector<int> c(n);\n  for (int i = 0; i < n; i++) {\n    c[i] = a[b[i]];\n  }\n  a = c;\n  return a;\n}\n\nvector<int> operator*(vector<int> a, vector<int> b) {\n  return a *= b;\n}\n\nvoid output(vector<int> a) {\n  for (int i = 0; i < n; i++) {\n    printf(\"%d%c\", a[i] + 1, \" \\n\"[i == n - 1]);\n  }\n}\n\nvector<int> power(vector<int> a, int k) {\n  vector<int> res(n);\n  for (int i = 0; i < n; i++) {\n    res[i] = i;\n  }\n  while (k > 0) {\n    if (k & 1) {\n      res *= a;\n    }\n    a *= a;\n    k >>= 1;\n  }\n  return res;\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    a[i]--;\n  }\n  vector<int> b(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &b[i]);\n    b[i]--;\n  }\n  if (m == 1) {\n    output(a);\n  } else if (m == 2) {\n    output(b);\n  } else {\n    m -= 2;\n    vector<int> A = inv(a);\n    vector<int> B = inv(b);\n    vector<int> res = power(b * A * B * a, m / 6);\n    int rm = m % 6;\n    if (rm == 0) res *= b;\n    if (rm == 1) res *= b * A;\n    if (rm == 2) res *= b * A * B;\n    if (rm == 3) res *= b * A * B * a * B;\n    if (rm == 4) res *= b * A * B * a * a * b;\n    if (rm == 5) res *= b * A * B * a * b * a * B;\n    res *= power(A * b * a * B, m / 6);\n    output(res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Maxn 100007\nint n,k;\nint p[Maxn],q[Maxn];\nint a[Maxn],b[Maxn],tmp1[Maxn],tmp2[Maxn];\nint ans[Maxn],r[Maxn];\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&p[i]);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&q[i]);\n    if (k%6==1)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=p[i];\n    } else if (k%6==2)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=q[i];\n    } else if (k%6==3)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=q[i];\n    } else if (k%6==4)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=i;\n    } else if (k%6==5)\n    {\n        for (int i=1;i<=n;i++)\n            b[q[i]]=i;\n    } else\n    {\n        for (int i=1;i<=n;i++)\n            tmp2[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            b[i]=tmp2[p[i]];\n    }\n    for (int i=1;i<=n;i++)\n        ans[i]=i;\n    if (k>1)\n    {\n        --k;\n        int c=k/6;\n        k%=6;\n        for (int i=1;i<=n;i++)\n            tmp1[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            r[i]=p[tmp1[i]];\n        for (int i=1;i<=n;i++)\n            tmp1[i]=r[i];\n        for (int i=1;i<=n;i++)\n            r[i]=q[tmp1[i]];\n        for (int i=1;i<=n;i++)\n            tmp1[p[i]]=i;\n        for (int i=1;i<=n;i++)\n            tmp2[i]=r[i];\n        for (int i=1;i<=n;i++)\n            r[i]=tmp1[tmp2[i]];\n        while (c>0)\n        {\n            if (c%2==1)\n            {\n                for (int i=1;i<=n;i++)\n                    ans[i]=r[ans[i]];\n            }\n            c/=2;\n            for (int i=1;i<=n;i++)\n                tmp1[i]=r[i];\n            for (int i=1;i<=n;i++)\n                r[i]=tmp1[tmp1[i]];\n        }\n        if (k%6==3)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[ans[i]];\n        } else if (k%6==4||k%6==5)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[ans[i]];\n            for (int i=1;i<=n;i++)\n                ans[i]=p[ans[i]];\n        } else if (k%6==0)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[ans[i]];\n            for (int i=1;i<=n;i++)\n                ans[i]=q[p[ans[i]]];\n        }\n    }\n    for (int i=1;i<=n;i++)\n        a[ans[i]]=i;\n    for (int i=1;i<=n;i++)\n        ans[i]=b[ans[i]];\n    for (int i=1;i<=n;i++)\n        ans[i]=a[ans[i]];\n    for (int i=1;i<=n;i++)\n        printf(\"%d \",ans[i]);\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nstd::vector<int> a[100005];\nint n,k,cnt,used[100005];\nint ans[100005],p[100005],pp[100005],q[100005],qq[100005],g[100005],gg[100005],gk[100005],ggk[100005],f[10][100005],ff[10][10005];\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&q[i]);\n\tfor (int i=1;i<=n;i++) f[1][i]=p[i];\n\tfor (int i=1;i<=n;i++) f[2][i]=q[i];\n\tfor (int i=1;i<=n;i++) ff[1][f[1][i]]=i;\n\tfor (int i=1;i<=n;i++) ff[2][f[2][i]]=i;\n\tfor (int r=3;r<=6;r++)\n\t{\n\t\tfor (int i=1;i<=n;i++) f[r][i]=f[r-1][ff[r-2][i]];\n\t\tfor (int i=1;i<=n;i++) ff[r][f[r][i]]=i;\n\t}\n\tfor (int i=1;i<=n;i++) pp[p[i]]=i;\n\tfor (int i=1;i<=n;i++) qq[q[i]]=i;\n\tfor (int i=1;i<=n;i++) g[i]=q[pp[qq[p[i]]]];\n\tfor (int i=1;i<=n;i++) gg[g[i]]=i;\n\tfor (int i=1;i<=n;i++)\n\t    if (!used[i])\n\t    {\n\t\t\tint x=++cnt;\n\t\t\tused[i]=1;\n\t\t\ta[x].push_back(i);\n\t    \tfor (int j=g[i];!used[j];j=g[j])\n\t    \t{\n\t    \t\ta[x].push_back(j);\n\t    \t\tused[j]=1;\n\t\t\t}\n\t    }\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tint sz=a[i].size();\n\t\tfor (int j=0;j<a[i].size();j++)\n\t\t{\n\t\t\tint x=a[i][j],y=a[i][(j+k/6)%sz];\n\t\t\tgk[x]=y;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) used[i]=0;\n\tfor (int i=1;i<=cnt;i++) a[i].clear();cnt=0;\n\tfor (int i=1;i<=n;i++)\n\t    if (!used[i])\n\t    {\n\t\t\tint x=++cnt;\n\t\t\tused[i]=1;\n\t\t\ta[x].push_back(i);\n\t    \tfor (int j=gg[i];!used[j];j=gg[j])\n\t    \t{\n\t    \t\ta[x].push_back(j);\n\t    \t\tused[j]=1;\n\t\t\t}\n\t    }\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tint sz=a[i].size();\n\t\tfor (int j=0;j<a[i].size();j++)\n\t\t{\n\t\t\tint x=a[i][j],y=a[i][(j+k/6)%sz];\n\t\t\tggk[x]=y;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) used[i]=0;\n\tfor (int i=1;i<=cnt;i++) a[i].clear();cnt=0;\n\tfor (int i=1;i<=n;i++) ans[i]=gk[f[(k-1)%6+1][ggk[i]]];\n\tfor (int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,K;\nstruct Perm{\n\tint d[100100];\n\tint& operator[](int x){return d[x];}\n\tPerm inv()\n\t{\n\t\tPerm tmp;\n\t\tfor(int i=1;i<=n;++i)tmp.d[d[i]]=i;\n\t\treturn tmp;\n\t}\n}e;\nPerm operator * (Perm a,Perm b)\n{\n\tfor(int i=1;i<=n;++i)b[i]=a[b[i]];\n\treturn b;\n}\nPerm Ppow(Perm x,int k)\n{\n\tPerm r=e;\n\twhile(k)\n\t{\n\t\tif(k&1)r=r*x;\n\t\tk>>=1;x=x*x;\n\t}\n\treturn r;\n}\nPerm A[11];\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tfor(int i=1;i<=n;++i)e[i]=A[0][i]=i;\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&A[1][i]);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&A[2][i]);\n\tPerm p=A[1],ip=p.inv(),q=A[2],iq=q.inv();\n\tPerm s=q*ip*iq*p,is=ip*q*p*iq;\n\tint t=(K-1)/6;\n\tPerm ans=Ppow(s,t);\n\tfor(int i=3;i<=K-t*6;++i)A[i]=A[i-1]*A[i-2].inv();\n\tans=ans*A[K%6];\n\tans=ans*Ppow(is,t);\n\tfor(int i=1;i<=n;++i)printf(\"%d \",ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nvector<int> mul(vector<int> x, vector<int> y){\n    vector<int> z(x.size());\n    for (int i = 0; i < x.size(); ++i) {\n        z[i] = x[y[i]];\n    }\n    return z;\n}\n\n\nvector<int> pow_(vector<int> x, int n){\n    vector<int> ans(x.size()), xx = x;\n    iota(ans.begin(),ans.end(), 0);\n    while(n > 0){\n        if(n & 1) ans = mul(ans, xx);\n        xx = mul(xx, xx);\n        n >>= 1;\n    }\n    return ans;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n), b(n), A(n), B(n);\n    for (auto &&i : a) scanf(\"%d\", &i), i--;\n    for (auto &&i : b) scanf(\"%d\", &i), i--;\n    if(k == 1){\n        for (int i = 0; i < n; ++i) {\n            if(i) printf(\" \");\n            printf(\"%d\", a[i]+1);\n        }\n        puts(\"\");\n        return 0;\n    }\n    vector<string> v{\"b\", \"bA\", \"bAB\", \"bABaB\", \"bABaaB\", \"bABabaB\"};\n    for (int i = 0; i < n; ++i) {\n        A[a[i]] = i;\n        B[b[i]] = i;\n    }\n    auto f = [&](string s){\n        vector<int> ans(n);\n        iota(ans.begin(),ans.end(),0);\n        for (char i : s) {\n            if(i == 'a') ans = mul(ans, a);\n            else if(i == 'b') ans = mul(ans, b);\n            else if(i == 'A') ans = mul(ans, A);\n            else if(i == 'B') ans = mul(ans, B);\n        }\n        return ans;\n    };\n    vector<int> X = f(\"bABa\"), Y = f(\"AbaB\");\n    auto ans = mul(mul(pow_(X, (k-2)/6), f(v[(k-2)%6])), pow_(Y, (k-2)/6));\n    for (int i = 0; i < n; ++i) {\n        if(i) printf(\" \");\n        printf(\"%d\", ans[i]+1);\n    }\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\nvector<int> inv(vector<int> r){\n  vector<int> res(r.size(), 0);\n  rep(i, sz(r))res[r[i]] = i;\n  return res;\n}\n\nvector<int> comp(vector<int> a, vector<int> b){\n  vector<int> res(a.size(), 0);\n  rep(i, sz(a))res[i] = a[b[i]];\n  return res;\n}\n\nvector<int> db[34];\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  INT(n); LL(k);\n  vector<int> p(n), q(n); cin >> p >> q; rep(i, n)p[i]--, q[i]--;\n  vector<int> pi = inv(p), qi = inv(q);\n  if(k == 1){\n    cout << p << endl;\n    return 0;\n  }\n  db[0] = comp(q, comp(pi, comp(qi, p)));\n  FOR(i, 1, 33){\n    db[i] = comp(db[i-1], db[i-1]);\n  }\n  vector<int> A(n, 0); rep(i, n)A[i] = i;\n  ll tmp = (k - 1) / 6;\n  int ind = 0;\n  while(tmp){\n    if(tmp % 2 == 1){\n      A = comp(A, db[ind]);\n    }\n    ind++;\n    tmp /= 2;\n  }\n  int cnt = (k - 1) % 6;\n  if(cnt == 3)A = comp(A, q);\n  if(cnt == 4)A = comp(A, comp(q, pi));\n  if(cnt == 5)A = comp(A, comp(q, pi));\n  vector<int> B;\n  if(cnt == 0)B = p;\n  if(cnt == 1)B = q;\n  if(cnt == 2)B = comp(q, pi);\n  if(cnt == 3)B = pi;\n  if(cnt == 4)B = qi;\n  if(cnt == 5)B = comp(qi, p);\n  vector<int> res = comp(A, comp(B, inv(A)));\n  rep(i, n)res[i]++;\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint n,c[N],k;\nstruct zhihuan{\n\tint a[N];\n\tzhihuan operator *(const zhihuan &b)const {\n\t\tzhihuan x;\n\t\tfor (int i=1;i<=n;i++)x.a[i]=a[b.a[i]];\n\t\treturn x;\n\t}\n}I,p,q;\nzhihuan inv(zhihuan x){\n\tfor (int i=1;i<=n;i++)c[x.a[i]]=i;\n\tfor (int i=1;i<=n;i++)x.a[i]=c[i];\n\treturn x;\n}\nzhihuan ksm(zhihuan x,int y){\n\tif (!y)return I;\n\tzhihuan z=ksm(x,y);\n\tz=z*z;\n\tif (y&1)z=z*x;\n\treturn z;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i<=n;i++)I.a[i]=i;\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&p.a[i]);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&q.a[i]);\n\tzhihuan Ans=q*inv(p)*inv(q)*p;\n\tint t=k%6;if (t==0)t=6;\n\tAns=ksm(Ans,(k-t)/6);k=t;\n\tif (k==1)Ans=Ans*p;\n\tif (k==2)Ans=Ans*q;\n\tif (k==3)Ans=Ans*q*inv(p);\n\tif (k==4)Ans=Ans*q*inv(p)*inv(q);\n\tif (k==5)Ans=Ans*q*inv(p)*inv(q)*p*inv(q);\n\tif (k==6)Ans=Ans*q*inv(p)*inv(q)*p*p*inv(q);\n\tfor (int i=1;i<=n;i++)printf(\"%d \",Ans.a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n;\nvector<ll> ret;\n\n\n\nvoid cul(vector<ll> &ret,const vector<ll> &A,const vector<ll> &B){\n    for(int i=0;i<n;i++){ret[i]=B[A[i]];}\n}\n\nvoid rev(vector<ll> &ret,vector<ll> A){\n    for(int i=0;i<n;i++){ret[A[i]]=i;}\n}\n\nvoid Out(vector<ll> ans){\n    for(int i=0;i+1<n;i++){cout<<ans[i]+1<<\" \";}\n    cout<<ans.back()+1<<endl;\n}\n\nvector<ll> operator * (const vector<ll> &A,const vector<ll> &B){cul(ret,A,B); return ret;}\n\nvector<ll> & operator *= (vector<ll> &A,const vector<ll> &B){cul(ret,A,B); return A=ret;}\n\nvector<ll> & operator /= (vector<ll> &A,const vector<ll> &B){cul(ret,B,A); return A=ret;}\n\n\nint main(){\n    ll k;\n    cin>>n>>k;\n    vector<ll> P(n);\n    vector<ll> Q(n);\n    for(auto &I:P){cin>>I; I--;}\n    for(auto &I:Q){cin>>I; I--;}\n    \n    ret.resize(n);\n    vector<ll> PI(n);\n    vector<ll> QI(n);\n    rev(PI,P);\n    rev(QI,Q);\n    vector<ll> O=P*QI*PI*Q;\n    vector<ll> A(n);\n    for(int i=0;i<n;i++){A[i]=i;}\n    \n    if(k==1){\n        Out(P);\n        return 0;\n    }\n    else if(k==2){\n        Out(Q);\n        return 0;\n    }\n    else if(k==3){\n        Out(PI*Q);\n        return 0;\n    }\n    \n    k-=3;\n    ll Z=k/6;\n    while(Z>0){\n        if(Z&1){A*=O;}\n        Z>>=1;\n        O*=O;\n    }\n    if(k%6){A/=Q;}\n    if(k%6>1){A/=PI;}\n    if(k%6>3){A/=QI;}\n    if(k%6==5){A/=P;}\n    if(k%3==1){\n        QI=PI;\n    }\n    else if(k%3==2){\n        QI=QI;\n    }\n    else{\n        cul(QI,PI,Q);\n    }\n    if((k/3)&1){rev(QI,QI);}\n    O*=QI;\n    O*=A;\n    Out(O);\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Ido Kessler\n */\n\n#pragma GCC optimize(\"O3\")\n\n#include <iostream>\n#include <map>\n\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n\n\n\nnamespace io {\n\tclass input_reader {\n\t\tstd::istream &in;\n\n\t\ttemplate<typename T>\n\t\tinline void readIntegerValue(T &f) {\n\t\t\tbool positive = true;\n\t\t\tf = 0;\n\t\t\tchar c;\n\t\t\tif (!in.get(c)) throw std::runtime_error(\"No more inputs while reading number\");\n\t\t\twhile (c < '0' || c > '9') {\n\t\t\t\tif (c == '-') positive = false;\n\t\t\t\tif (!in.get(c)) throw std::runtime_error(\"No more inputs while reading number\");\n\t\t\t}\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tf = (f << 3) + (f << 1) + (c & 15);\n\t\t\t\tif (!in.get(c)) break;\n\t\t\t}\n\t\t\tif (!positive) f *= -1;\n\t\t}\n\n\tpublic:\n\t\tinput_reader(std::istream &in) : in(in) {}\n\n\t\tinline void read(int &f) { readIntegerValue(f); }\n\n\t\tinline void read(short &f) { readIntegerValue(f); }\n\n\t\tinline void read(long int &f) { readIntegerValue(f); }\n\n\t\tinline void read(long long int &f) { readIntegerValue(f); }\n\n\t\tinline void read(unsigned int &f) { readIntegerValue(f); }\n\n\t\tinline void read(unsigned short &f) { readIntegerValue(f); }\n\n\t\tinline void read(unsigned long int &f) { readIntegerValue(f); }\n\n\t\tinline void read(unsigned long long int &f) { readIntegerValue(f); }\n\n\t\ttemplate<typename T>\n\t\tinline void read(std::vector<T> &f) { for (auto &i : f) read(i); }\n\n\t\ttemplate<typename T, int N>\n\t\tinline void read(std::array<T, N> &res) { for (auto &i: res) read(i); }\n\n\t\ttemplate<typename T>\n\t\tinline void read(T &f) { in >> f; }\n\n\t\ttemplate<typename T1, typename T2>\n\t\tinline void read(T1 &t1, T2 &t2) { read(t1), read(t2); }\n\n\t\ttemplate<typename T1, typename T2, typename T3>\n\t\tinline void read(T1 &t1, T2 &t2, T3 &t3) { read(t1, t2), read(t3); }\n\n\t\ttemplate<typename T1, typename T2, typename T3, typename T4>\n\t\tinline void read(T1 &t1, T2 &t2, T3 &t3, T4 &t4) { read(t1, t2, t3), read(t4); }\n\n\t\ttemplate<typename T1, typename T2, typename T3, typename T4, typename T5>\n\t\tinline void read(T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5) { read(t1, t2, t3, t4), read(t5); }\n\n\t\ttemplate<typename T>\n\t\tinline void readArray(int n, T *res) { while (n--) read(*(res++)); }\n\n\t\ttemplate<typename T>\n\t\tinput_reader &operator>>(T &t) { return read(t), *this; }\n\t};\n}\n\n\n\n\nnamespace io {\n\tclass output_writer {\n\t\tstd::ostream &out;\n\n\t\ttemplate<typename T>\n\t\tinline void printIntegerHelper(T x) {\n\t\t\tif (x >= 10) printIntegerHelper(x / 10);\n\t\t\tout.put(x % 10 + 48);\n\t\t}\n\n\t\ttemplate<typename T>\n\t\tinline void printInteger(T x) {\n\t\t\tif (x < 0) out.put('-'), x = -x;\n\t\t\tprintIntegerHelper(x);\n\t\t}\n\n\t\ttemplate<typename T>\n\t\tinline void printArray(T &ar) {\n\t\t\tbool first = true;\n\t\t\tfor (auto &t : ar) print((first) ? first = false, \"\" : \" \", t);\n\t\t}\n\n\tpublic:\n\t\toutput_writer(std::ostream &out) : out(out) {}\n\n\t\tinline void flush() { out.flush(); }\n\n\t\tinline void print(char x) { out.put(x); }\n\n\t\tinline void print(short x) { printInteger(x); }\n\n\t\tinline void print(int x) { printInteger(x); }\n\n\t\tinline void print(long int x) { printInteger(x); }\n\n\t\tinline void print(long long int x) { printInteger(x); }\n\n\t\tinline void print(unsigned short x) { printInteger(x); }\n\n\t\tinline void print(unsigned int x) { printInteger(x); }\n\n\t\tinline void print(unsigned long int x) { printInteger(x); }\n\n\t\tinline void print(unsigned long long int x) { printInteger(x); }\n\n\t\ttemplate<typename T1>\n\t\tinline void print(const T1 &t1) { out << t1; }\n\n\t\ttemplate<typename T1>\n\t\tinline void print(const std::vector<T1> &t1) { printArray(t1); }\n\n\t\ttemplate<typename T1, int N>\n\t\tinline void print(const std::array<T1, N> &t1) { printArray(t1); }\n\n\t\ttemplate<typename T1, int N, int M>\n\t\tinline void print(const std::array<std::array<T1, M>, N> &t1) { for (auto &t : t1) println(t); }\n\n\t\ttemplate<typename T1>\n\t\tinline void print(const std::vector<std::vector<T1>> &t1) { for (auto &t : t1) println(t); }\n\n\t\ttemplate<typename T, typename... Args>\n\t\tinline void print(const T &t, Args... args) { print(t), print(args...); }\n\n\t\tinline void println() { out.put('\\n'); }\n\n\t\ttemplate<typename... Args>\n\t\tinline void println(Args... args) { print(args...), println(); }\n\n\t\ttemplate<typename T>\n\t\toutput_writer &operator<<(const T &t) { return print(t), *this; }\n\t};\n}\n\n\n#define all(x) (x).begin(), (x).end()\n#define fori(i,n) for(int i = 0; i < n; i++)\n#define rep(i,s,e) for(int i = (s); i <= (e); ++i)\n#define repr(i,s,e) for(int i = (s); i >= (e); --i)\n#define ll long long int\n\n\n\nusing namespace std;\n\nclass DASequenceOfPermutations {\n\tvector<int> random;\n\tint n;\n\tconst ll MOD = 1e9 + 7;\n\n\tint hash(const vector<int> &p) {\n\t\tll res = 0;\n\t\tfori(i, n) {\n\t\t\tres *= n;\n\t\t\tres += p[i];\n\t\t\tres %= MOD;\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid op(const vector<int> &p, const vector<int> &q, vector<int> &res) {\n\t\tfori(i, n) res[p[i]] = q[i];\n\t}\n\n\tvoid print(io::output_writer &out, vector<int> &v) {\n\t\tfori(i, n) v[i]++;\n\t\tout << v;\n\t}\n\n\tvoid solve(io::input_reader &in, io::output_writer &out) {\n\t\tint k;\n\t\tin.read(n, k);\n\t\tvector<int> a[2];\n\t\ta[0].resize(n), a[1].resize(n);\n\t\tin >> a[0] >> a[1];\n\t\tfori(i, n) a[0][i]--, a[1][i]--;\n\t\tsrand(0);\n\t\trandom.resize(n);\n\t\tfor (int &i:random) i = rand() % (2 * n);\n\t\tmap<pair<int, int>, int> memos;\n\t\tpair<int, int> h;\n\t\th.first = hash(a[0]);\n\t\th.second = hash(a[1]);\n\t\tmemos[h] = 1;\n\t\tint currentK = 1;\n\t\tvector<int> res(n);\n\t\tbool jump1 = false;\n\t\twhile (true) {\n\t\t\tif (currentK + 1 >= k) {\n\t\t\t\tprint(out, a[k - currentK]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\top(a[0], a[1], res);\n\t\t\tstd::swap(a[0], a[1]);\n\t\t\tstd::swap(a[1], res);\n\t\t\tcurrentK++;\n\t\t\tif (!jump1) {\n\t\t\t\th.first = h.second;\n\t\t\t\th.second = hash(a[1]);\n\t\t\t\tif (memos.find(h) != memos.end()) {\n\t\t\t\t\tint lastSeen = memos[h];\n\t\t\t\t\tint _k = k - lastSeen;\n\t\t\t\t\tint _cur = currentK - lastSeen;\n\t\t\t\t\tcurrentK = lastSeen + ((_k) / _cur) * _cur;\n\t\t\t\t}\n\t\t\t\tmemos[h] = currentK;\n\t\t\t}\n\t\t}\n\t}\n\npublic:\n\tvoid solve(std::istream &in, std::ostream &out) {\n\t\tio::input_reader input(in);\n\t\tio::output_writer output(out);\n\t\tsolve(input, output);\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false), cin.tie(0);\n\tDASequenceOfPermutations solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nusing vll=vector<ll>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\nusing vpii=vector<pii>;\n\nvi fastexp(const vi& perm, int x) {\n    if (x > 1) {\n        int n = perm.size();\n        vi halfexp = fastexp(perm, x/2);\n        vi res(n);\n        for (int i=0; i<n; ++i) {\n            if (x&1)\n                res[i] = perm[halfexp[halfexp[i]]];\n            else\n                res[i] = halfexp[halfexp[i]];\n        }\n        return res;\n    }\n    assert(x == 1);\n    return perm;\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, k;\n    cin >> n >> k;\n    vvi ais(6, vi(n));\n    for (int i=0; i<n; ++i) {\n        cin >> ais[0][i];\n        --ais[0][i];\n    }\n    for (int i=0; i<n; ++i) {\n        cin >> ais[1][i];\n        --ais[1][i];\n    }\n    for (int j=2; j<6; ++j) {\n        for (int i=0; i<n; ++i) {\n            ais[j][ais[j-2][i]] = ais[j-1][i];\n        }\n    }\n\n    int lowi = k%6;\n    if (lowi == 0)\n        lowi = 6;\n    int x = (k - lowi)/6;\n\n    vi per(n);\n    for (int i=0; i<n; ++i)\n        per[i] = ais[3][ais[0][i]];\n\n    vi res;\n    if (x == 0)\n        res = ais[lowi-1];\n    else {\n        vi perexp = fastexp(per, x);\n        res = vi(n);\n        for (int i=0; i<n; ++i) {\n            res[perexp[i]] = perexp[ais[lowi-1][i]];\n        }\n    }\n    for (int i=0; i<n; ++i)\n        cout << res[i]+1 << \" \";\n    cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n#define vel vector<int>\n#define vvel vector<vel>\n#define vvvel vector<vvel>\n#define veb vector<bool>\nvel func(vel p, vel q) {\n\tvel ans(p.size());\n\tfor (int i = 0; i < p.size(); i++) {\n\t\tans[p[i]] = q[i];\n\t}\n\treturn ans;\n}\npair<vel, vel> rui(int k, pair<vel,vel> x) {\n\tif (k == 0) { return x; }\n\tpair<vel,vel> ans = rui(k / 2, rui(k / 2, x));\n\tif (k % 2 == 1) {\n\t\tvel p = ans.first;\n\t\tvel q = ans.second;\n\t\tpair<vel, vel> qans = make_pair(q, func(p, q));\n\t\tans = qans;\n\t}\n\treturn ans;\n}\nsigned main() {\n\tint n, k; cin >> n >> k;\n\tvel p(n); vel q(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> p[i]; p[i]--;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> q[i]; q[i]--;\n\t}\n\tvel w;\n\tif (k == 0) {\n\t\tw = p;\n\t}\n\telse if (k == 1) { w = q; }\n\telse { w= rui(k-2, make_pair(p, q)).second; }\n\tfor (int i = 0; i < n-1; i++) {\n\t\tcout << w[i]+1 << \" \";\n\t}\n\tcout << w[n - 1]+1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\nusing namespace std;\nvi p,q,a[7];\nint n,k,x;\nvi mul(vi x,vi y)\n{\n    vi z;\n    for(int i=0;i<x.size();i++)\n        z.push_back(x[y[i]]);\n    return z;\n}\nvi inv(vi x)\n{\n    vi y(n);\n    for(int i=0;i<x.size();i++)\n        y[x[i]]=i;\n    return y;\n}\nvi qpow(vi x,int y)\n{\n    vi ans(n);\n    for(int i=0;i<n;i++) ans[i]=i;\n    while(y)\n    {\n        if(y&1) ans=mul(ans,x);\n        x=mul(x,x);\n        y>>=1;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&x);\n        p.push_back(x-1);\n    }\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&x);\n        q.push_back(x-1);\n    }\n    a[1]=p;a[2]=q;\n    for(int i=3;i<=n;i++)\n        a[i]=mul(a[i-1],inv(a[i-2]));\n    if(k<=6)\n    {\n        for(int i=0;i<n;i++)\n            printf(i==n-1?\"%d\\n\":\"%d \",a[k][i]+1);\n        return 0;\n    }\n    vi A=mul(mul(q,inv(p)),mul(inv(q),p));\n    A=qpow(A,(k-1)/6);\n    vi ans=mul(mul(A,a[(k-1)%6+1]),inv(A));\n    for(int i=0;i<n;i++)\n        printf(i==n-1?\"%d\\n\":\"%d \",ans[i]+1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, T, aux2[100009], aux[100009], a[100009], b[100009], invA[100009], invB[100009], period[100009], ans[100009], ap[100009], cyc[100009];\nvector < int > v[109];\n\nvoid compose (int a[], int b[])\n{\n    for (int i=1; i<=N; i++)\n        aux[i] = a[i];\n    for (int i=1; i<=N; i++)\n        a[i] = aux[b[i]];\n}\n\nvoid raiseTo (int p[], int E, int ans[])\n{\n//    printf (\"^ %d\\n\", E);\n    for (int i=1; i<=N; i++)\n        ap[i] = 0;\n    for (int i=1; i<=N; i++)\n        if (ap[i] == 0)\n        {\n            int sz = 1; cyc[sz] = i;\n            while (ap[cyc[sz]] == 0)\n                ap[cyc[sz]] = 1,\n                cyc[sz + 1] = p[cyc[sz]], sz ++;\n            sz --;\n            for (int j=1; j<=sz; j++)\n                ans[cyc[j]] = cyc[(j - 1 + E) % sz + 1];\n        }\n/*    printf (\"smart:\");\n    for (int i=1; i<=N; i++)\n        printf (\" %d\", ans[i]);\n    printf (\"\\n\");\n    for (int i=1; i<=N; i++)\n        ans[i] = i;\n    while (E --) compose (ans, p);\n    printf (\"brute:\");\n    for (int i=1; i<=N; i++)\n        printf (\" %d\", ans[i]);\n    printf (\"\\n\");*/\n}\n\nvoid getInverse (int source[], int dest[])\n{\n    for (int i=1; i<=N; i++)\n        dest[source[i]] = i;\n}\n\nvoid apply (int x[], int type)\n{\n//    printf (\"+ %d\\n\", type);\n    if (type == 1) compose (x, a);\n    else\n    if (type == 2) compose (x, b);\n    else\n    if (type == -1) compose (x, invA);\n    else compose (x, invB);\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nv[1].push_back (1);\nv[2].push_back (2);\nfor (int i=3; i<=28; i++)\n{\n    for (auto it : v[i - 1])\n        v[i].push_back (it);\n    for (auto it = v[i - 2].rbegin (); it != v[i - 2].rend (); it ++)\n        if (!v[i].empty () && - *it + v[i].back () == 0) v[i].pop_back ();\n        else v[i].push_back (- *it);\n}\n/*for (int i=1; i<=28; i++, printf (\"\\n\"))\n{\n    int sz = 0;\n    for (auto it : v[i])\n    {\n        printf (\"%d \", it);\n        sz = (sz + 1) & 3;\n        if (sz == 0)\n            printf (\" |  \");\n    }\n}\nexit (0);*/\nscanf (\"%d %d\", &N, &T);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &a[i]), period[i] = i;\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &b[i]), ans[i] = i;\ngetInverse (a, invA), getInverse (b, invB);\nif (T <= 4)\n{\n    for (auto it : v[T])\n        apply (ans, it);\n}\nelse\n{\n    int times = (T + 1) / 6, r = (T - 5) % 6;\n\n    apply (period, 2), apply (period, -1), apply (period, -2), apply (period, 1);\n    raiseTo (period, times, ans);\n/*    for (int i=1; i<=N; i++)\n        printf (\"%d%c\", ans[i], \" \\n\"[i == N]);*/\n\n    if (r >= 3)\n    {\n        for (int pos = 8; pos < 12; pos ++)\n            apply (ans, v[11 + r][pos]);\n        r -= 3;\n    }\n\n    for (int i=1; i<=N; i++)\n        period[i] = i;\n    for (int pos = 8; pos < 12; pos ++)\n        apply (period, v[11 + r][pos]);\n//    apply (period, -2), apply (period, -1), apply (period, 2), apply (period, 1);\n    raiseTo (period, times - 1, aux2);\n    compose (ans, aux2);\n/*    for (int i=1; i<=N; i++)\n        printf (\"%d%c\", aux2[i], \" \\n\"[i == N]);\n    for (int i=1; i<=N; i++)\n        printf (\"%d%c\", ans[i], \" \\n\"[i == N]);*/\n\n    for (int pos = 4; pos < v[5 + r].size (); pos ++)\n        apply (ans, v[5 + r][pos]);\n}\nfor (int i=1; i<=N; i++)\n    printf (\"%d%c\", ans[i], \" \\n\"[i == N]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5;\n\nint n, k;\n\nint p[MAXN + 5], q[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>(), k = read<int>();\n\tfor(int i = 1; i <= n; ++i) p[i] = read<int>();\n\tfor(int i = 1; i <= n; ++i) q[i] = read<int>();\n}\n\ninline void inv(int *f, int *s)\n{\n\tstatic int S[MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i) S[f[i]] = i;\n\tfor(int i = 1; i <= n; ++i) s[i] = S[i];\n}\n\ninline void mul(int *f, int *g, int *s)\n{\n\tstatic int S[MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i) S[i] = f[g[i]];\n\tfor(int i = 1; i <= n; ++i) s[i] = S[i];\n}\n\ninline void fpm(int *f, int y, int *s)\n{\n\tif(y == 0) { for(int i = 1; i <= n; ++i) s[i] = i; return; }\n\n\tstatic int S[MAXN + 5], vis[MAXN + 5];\n\tfor(int i = 1; i <= n; ++i) vis[i] = 0;\n\n\tfor(int i = 1; i <= n; ++i) if(!vis[i])\n\t{\n\t\tstatic int cir[MAXN + 5], len;\n\t\tlen = 0;\n\n\t\tfor(int j = i; !vis[j]; j = f[j]) vis[j] = 1, cir[len++] = j;\n\t\tfor(int j = 0; j < len; ++j) S[cir[j]] = cir[(j + y) % len];\n\t}\n\tfor(int i = 1; i <= n; ++i) s[i] = S[i];\n}\n\ninline void solve()\n{\n\tstatic int A[MAXN + 5], iA[MAXN + 5], ip[MAXN + 5], iq[MAXN + 5], M[7][MAXN + 5];\n\n\tinv(p, ip);\n\tinv(q, iq);\n\tmul(q, ip, A);\n\tmul(A, iq, A);\n\tmul(A, p, A);\n\tinv(A, iA);\n\n\tint m = k % 6 == 0 ? k / 6 - 1 : k / 6, t = k % 6 == 0 ? 6 : k % 6;\n\tfpm(A, m, A);\n\tfor(int i = 1; i <= n; ++i) M[1][i] = p[i];\n\tfor(int i = 1; i <= n; ++i) M[2][i] = q[i];\n\tfor(int i = 3; i <= 6; ++i)\n\t{\n\t\tstatic int f[MAXN + 5];\n\n\t\tinv(M[i - 2], f);\n\t\tmul(M[i - 1], f, M[i]);\n\t}\n\tfpm(iA, m, iA);\n\n\tmul(A, M[t], A);\n\tmul(A, iA, A);\n\n\tfor(int i = 1; i <= n; ++i) printf(\"%d \", A[i]);\n\tputs(\"\");\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"D.in\", \"r\", stdin);\n//\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nconst int maxn = 100005;\nint n, k;\n\nstruct perm\n{\n\tint data[maxn];\n\tint operator[](int x) const { return data[x]; }\n\tint &operator[](int x) { return data[x]; }\n} p, q, fold, ans;\nperm operator*(const perm &a, const perm &b)\n{\n\tperm c;\n\tfor (int i = 1; i <= n; ++i)\n\t\tc[i] = b[a[i]];\n\treturn c;\n}\nperm inv(const perm &x)\n{\n\tperm y;\n\tfor (int i = 1; i <= n; ++i)\n\t\ty[x[i]] = i;\n\treturn y;\n}\nperm power(const perm &a, int x)\n{\n\tstatic bool vis[maxn];\n\tperm ret;\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tstd::vector<int> now;\n\t\t\tnow.push_back(i);\n\t\t\tvis[i] = true;\n\t\t\tfor (int j = a[i]; j != i; j = a[j])\n\t\t\t\tnow.push_back(j), vis[j] = true;\n\t\t\tfor (int i = 0; i < (int)now.size(); ++i)\n\t\t\t\tret[now[i]] = now[(i + x) % now.size()];\n\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tvis[i] = false;\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &p[i]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &q[i]);\n\tfold = power(p * inv(q) * inv(p) * q, (k - 1) / 6);\n\tswitch (k % 6)\n\t{\n\t\tcase 0:\n\t\t\tans = inv(fold) * inv(q) * p * p * inv(q) * inv(p) * q * fold;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tans = inv(fold) * p * fold;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tans = inv(fold) * q * fold;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tans = inv(fold) * inv(p) * q * fold;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tans = inv(fold) * inv(q) * inv(p) * q * fold;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tans = inv(fold) * inv(q) * p * inv(q) * inv(p) * q * fold;\n\t\t\tbreak;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tprintf(\"%d%c\", ans[i], \" \\n\"[i == n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <unordered_map>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n \ntypedef long long ll;\ntypedef long double ld;\n \nconst ll MOD = 1e9 + 7, INF = 1e18 + 1;\n \nusing namespace std;\nint n, k;\n\nvector <int> d[1000000];\n\nvector <int> f (vector <int> a, vector <int> b)\n{\n\tvector<int> v (n);\n\n\tfor (int i = 0; i < n; i++)\n\t\tv[i] = a[b[i] - 1];\n\n\treturn v;\n}\n\nvector <int> inv (vector <int> a)\n{\n\tvector <int> s (n);\n\n\tfor (int i = 0; i < n; i++)\n\t\ts[a[i] - 1] = i + 1;\n\n\treturn s;\n}\n\nvector <int> qpow (vector <int> a, int b)\n{\n\tvector <int> s;\n\n\tfor (int i = 0; i < n; i++)\n\t\ts.push_back (i + 1);\n\n\twhile (b)\n\t{\n\t\tif (b & 1) s = f (s, a);\n\t\ta = f (a, a);\n\t\tb /= 2;\n\t}\n\n\treturn s;\n}\n\nint main ()\n{\n\tcin >> n >> k;\n\n\tvector <int> p (n), q (n);\n\n\tfor (int i = 0; i < n; i++)\n\t\tscanf (\"%d\", &p[i]);\n\n\tfor (int i = 0; i < n; i++)\n\t\tscanf (\"%d\", &q[i]);\n\n\tauto A = qpow (f (q, f (inv (p), f (inv (q), p))), (k - 1) / 6);\n\n\tif(k % 6 == 4) A = f (A, q);\n\tif(k % 6 == 5 || k % 6 == 0) A = f (A, f (q, inv (p)));\n\n\tvector <int> B[7];\n\n\tB[1] = p;\n\tB[2] = q;\n\tB[3] = f (q, inv (p));\n\tB[4] = inv (p);\n\tB[5] = inv (q);\n\tB[6] = f (inv (q), p);\n\n\tauto ans = f (A, f (B[(k - 1) % 6 + 1], inv (A)));\n\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e5 + 5;\n\n/*vector<char> s[3];\n\nvoid output(int ind) {\n\tREP(i, 0, SZ(s[ind])) {\n\t\tputchar(s[ind][i]);\n\t}\n\tputchar('\\n');\n}*/\n\nint n;\nint A[MAXN], B[MAXN], a[MAXN], b[MAXN];\nint BabA[MAXN], aBAb[MAXN], _left[MAXN], _right[MAXN];\nint ans[MAXN];\n\nvoid output(int *per) {\n\tREP(i, 0, n) {\n\t\tprintf(\"%d \", per[i] + 1);\n\t}\n\tputchar('\\n');\n}\n\nvoid mul(int * per1, int * per2, int *res) {\n\tREP(i, 0, n) {\n\t\tres[i] = per2[per1[i]];\n\t}\n}\n\nint tmp_per[MAXN];\nvoid mul_by(int *per, int *per_by) {\n\tREP(i, 0, n) {\n\t\ttmp_per[i] = per[i];\n\t}\n\tmul(tmp_per, per_by, per);\n}\n\nint pow_per[MAXN];\nvoid pow_mod(int * per, int st, int *res) {\n\tREP(i, 0, n) {\n\t\tres[i] = i;\n\t\tpow_per[i] = per[i];\n\t}\n\tfor(; st; st /= 2) {\n\t\tif (st & 1) {\n\t\t\tmul_by(res, pow_per);\n\t\t}\n\t\tREP(i, 0, n) {\n\t\t\ttmp_per[i] = pow_per[i];\n\t\t}\n\t\tmul(tmp_per, tmp_per, pow_per);\n\t}\n}\n\nvoid solve(){\n\t/*s[1].pb('A');\n\ts[2].pb('B');\n\toutput(1);\n\toutput(2);\n\tREP(i, 3, 30) {\n\t\tint ind = i % 3, ind1 = (i + 1) % 3, ind2 = (i + 2) % 3;\n\t\ts[ind] = s[ind2];\n\t\tfor(int i = SZ(s[ind1]) - 1; i >= 0; i--) {\n\t\t\tchar cur = s[ind1][i];\n\t\t\tif (cur == s[ind].back()) {\n\t\t\t\ts[ind].pop_back();\n\t\t\t} else {\n\t\t\t\tif (cur <= 'B') {\n\t\t\t\t\tcur += 'b' - 'B';\n\t\t\t\t} else {\n\t\t\t\t\tcur -= 'b' - 'B';\n\t\t\t\t}\n\t\t\t\ts[ind].pb(cur);\n\t\t\t}\n\t\t}\n\t\toutput(ind);\n\t}*/\n\tint k;\n\tscanf(\"%d%d\", &n, &k);\n\tREP(i, 0, n) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tA[i]--;\n\t\ta[A[i]] = i;\n\t}\n\tREP(i, 0, n) {\n\t\tscanf(\"%d\", &B[i]);\n\t\tB[i]--;\n\t\tb[B[i]] = i;\n\t}\n\t\n\tif (k == 1) {\n\t\toutput(A);\n\t\treturn;\n\t}\n\tif (k == 2) {\n\t\toutput(B);\n\t\treturn;\n\t}\n\t\n\tint l1 = (k / 3 * 2 + k % 3);\n\tint l2 = ((k - 4) / 3 * 2 + (k - 4) % 3);\n\tif (k <= 4) {\n\t\tl2 = 0;\n\t}\n\t\n\tREP(i, 0, n) {\n\t\tBabA[i] = A[i];\n\t}\n\tmul_by(BabA, b);\n\tmul_by(BabA, a);\n\tmul_by(BabA, B);\n\t\n\tREP(i, 0, n) {\n\t\taBAb[i] = b[i];\n\t}\n\tmul_by(aBAb, A);\n\tmul_by(aBAb, B);\n\tmul_by(aBAb, a);\n\t\n\tpow_mod(BabA, l1 / 4, _left);\n\tpow_mod(aBAb, l2 / 4, _right);\n\t\n\tREP(i, 0, n) {\n\t\tans[i] = _right[i];\n\t}\n\tif (l2 % 4 >= 1) {\n\t\tmul_by(ans, b);\n\t}\n\tif (l2 % 4 >= 2) {\n\t\tmul_by(ans, A);\n\t}\n\tif (l2 % 4 >= 3) {\n\t\tmul_by(ans, B);\n\t}\n\tif (l1 % 4 >= 3) {\n\t\tmul_by(ans, b);\n\t}\n\tif (l1 % 4 >= 2) {\n\t\tmul_by(ans, a);\n\t}\n\tif (l1 % 4 >= 2) {\n\t\tmul_by(ans, B);\n\t}\n\tmul_by(ans, _left);\n\toutput(ans);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define trav(a, x) for(auto& a : x)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long double ld;\n\nint n;\nll k;\n\nvi mult(const vi &a, const vi &b){\n    vi ans(n);\n    rep(i,0,n){\n        ans[i] = a[b[i]];\n    }\n    return ans;\n}\n\nvi inv(const vi &a){\n    vi ans(n);\n    rep(i,0,n){\n        ans[a[i]] = i;\n    }\n    return ans;\n}\n\nvi powr(vi a, ll m){\n    vi ans(n);\n    rep(i,0,n){\n        ans[i] = i;\n    }\n    while(m>0){\n        if(m%2){\n            ans = mult(ans, a);\n        }\n        a = mult(a,a);\n        m/=2;\n    }\n    return ans;\n}\n\nint main(){\n    cin.sync_with_stdio(0); cin.tie(0);\n    cin.exceptions(cin.failbit);\n\n    cin >> n >> k;\n    k--;\n    vi p(n);\n    vi q(n);\n    rep(i,0,n){\n        cin >> p[i];\n        p[i]--;\n    }\n    rep(i,0,n){\n        cin >> q[i];\n        q[i]--;\n    }\n    vi pinv = inv(p);\n    vi qinv = inv(q);\n    vi r = mult(q, mult(pinv, mult(qinv, p)));\n    ll kk = k/6;\n    vi rr = powr(r, kk);\n    k -= 6*kk;\n    while(k>0){\n        vi pp = q;\n        q = mult(q, inv(p));\n        p = pp;\n        k--;\n    }\n    vi ans = mult(rr, mult(p, inv(rr)));\n    trav(x, ans){\n        cout << x+1 << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,K;\nstruct Perm{\n\tint d[100100];\n\tint& operator[](int x){return d[x];}\n\tPerm inv()\n\t{\n\t\tPerm tmp;\n\t\tfor(int i=1;i<=n;++i)tmp.d[d[i]]=i;\n\t\treturn tmp;\n\t}\n}e;\nPerm operator * (Perm a,Perm b)\n{\n\tfor(int i=1;i<=n;++i)b[i]=a[b[i]];\n\treturn b;\n}\nPerm Ppow(Perm x,int k)\n{\n\tPerm r=e;\n\twhile(k)\n\t{\n\t\tif(k&1)r=r*x;\n\t\tk>>=1;x=x*x;\n\t}\n\treturn r;\n}\nPerm A[11];\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tfor(int i=1;i<=n;++i)e[i]=A[0][i]=i;\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&A[1][i]);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&A[2][i]);\n\tPerm p=A[1],ip=p.inv(),q=A[2],iq=q.inv();\n\tPerm s=(((q*ip)*iq)*p),is=s.inv();\n\tint t=(K-1)/6;\n\tPerm ans=Ppow(s,t);\n\tfor(int i=3;i<=K-6*t;++i)A[i]=A[i-1]*A[i-2].inv();\n//\tfor(int i=1;i<=n;++i)printf(\"%d \",ans[i]);puts(\"\");\n\tans=ans*A[K-6*t];\n//\tfor(int i=1;i<=n;++i)printf(\"%d \",ans[i]);puts(\"\");\n\tans=ans*Ppow(is,t);\n\tfor(int i=1;i<=n;++i)printf(\"%d \",ans[i]);puts(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// {{{ Definitions\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define FERR(s) freopen(s, \"w\", stderr)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define dputs(s) fprintf(stderr, s\"\\n\")\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n// }}}\n// {{{ Modular\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1)\n                ans = mul(ans, x);\n        return ans;\n    }\n}; // namespace modular\n// }}}\n// {{{ Base\n\nnamespace Base {\n    template <typename Tp> inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-')\n                y = -1;\n            c = getchar();\n        }\n        if (c == EOF)\n            return 0;\n        while ('0' <= c && c <= '9')\n            x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp> inline void read(Tp &x) { x = input<Tp>(); }\n    template <typename Tp> inline void chmax(Tp &x, Tp y) { x < y ? x = y : 0; }\n    template <typename Tp> inline void chmin(Tp &x, Tp y) { x > y ? x = y : 0; }\n}; // namespace Base\n\n// }}}\nusing namespace Base;\n\n#define MAX_N 200007\n\nint N, K;\nint p[MAX_N], q[MAX_N], tmp[MAX_N], inv[MAX_N], tmp2[MAX_N], tmp3[MAX_N], a[10][MAX_N], f[MAX_N], res[MAX_N];\n\nvoid getinv(int *p, int *f) {\n    Rep(i, N) f[p[i]] = i;\n}\n\nvoid mul(int *a, int *b, int *f) {\n    Rep(i, N) f[i] = a[b[i]];\n}\n\nint st[MAX_N], ans[MAX_N], pos[MAX_N], top;\nbool vis[MAX_N];\nvoid pow(int *a, int y) {\n    memset(vis, false, sizeof(vis));\n    Rep(i, N) if (!vis[i]) {\n        top = 0;\n        for (int j = i; !vis[j]; j = a[j]) {\n            vis[j] = true;\n            st[++top] = j;\n        }\n        Rep(i, top) pos[st[i]] = i;\n        int z = y % top;\n        for (int j = i; ; j = a[j]) {\n            ans[j] = st[(pos[a[j]] + z - 1) % top + 1];\n            if (j == st[top]) break;\n        }\n        // Rep(i, top) {\n            // ans[st[(i + z - 1) % top + 1]] = st[i];\n        // }\n    }\n    Rep(i, N) a[i] = ans[i];\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n    FIN(\"b.in\");\n    FOUT(\"b.out\");\n    FERR(\"b.log\");\n#endif\n    read(N), read(K);\n    Rep(i, N) read(p[i]), a[1][i] = p[i];\n    Rep(i, N) read(q[i]), a[2][i] = q[i];\n    rep(i, 3, 6) {\n        getinv(a[i - 2], inv);\n        mul(a[i - 1], inv, a[i]);\n    }\n    if (K <= 6) {\n        Rep(i, N) printf(\"%d \", a[K][i]); puts(\"\");\n        return 0;\n    }\n    getinv(p, inv);\n    mul(q, inv, tmp2);\n    getinv(q, inv);\n    mul(inv, p, tmp3);\n    mul(tmp2, tmp3, f);\n    getinv(f, tmp);\n    // Rep(i, N) debug(\"%d \", tmp[i]); dputs(\"\");\n    pow(f, (K - 1) / 6 - 1);\n    pow(tmp, (K - 1) / 6 - 1);\n    // Rep(i, N) debug(\"%d \", tmp[i]); dputs(\"\");\n    // debug(\"%d\\n\", K - (K - 1) / 6 * 6);\n    mul(f, a[K - (K - 1) / 6 * 6], tmp2);\n    mul(tmp2, tmp, res);\n    Rep(i, N) printf(\"%d \", res[i]); puts(\"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < '0' || c > '9') && c != '-');\n\tif (c == '-') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\nconst int N = 1e5 + 5;\n\nint n, K, p[N], q[N], l[N], r[N], ip[N], iq[N], resl[N], resr[N], tmp[N], mid[N];\n// f(n) = (2 -1 -2 1) + f(n - 6) + (-1 2 1 -2)\nint main()\n{\n\tread(n); read(K); int mt = K % 6; if (!mt) mt = 6;\n\tfor (int i = 1; i <= n; i++) read(p[i]), ip[p[i]] = i;\n\tfor (int i = 1; i <= n; i++) read(q[i]), iq[q[i]] = i;\n\tfor (int i = 1; i <= n; i++) l[i] = q[ip[iq[p[i]]]], r[i] = ip[q[p[iq[i]]]];\n\tK = (K - mt) / 6; for (int i = 1; i <= n; i++) resl[i] = resr[i] = i;\n\twhile (K)\n\t{\n\t\tif (K & 1)\n\t\t{\n\t\t\tfor (int i = 1; i <= n; i++) tmp[i] = l[resl[i]];\n\t\t\tfor (int i = 1; i <= n; i++) resl[i] = tmp[i];\n\t\t\tfor (int i = 1; i <= n; i++) tmp[i] = r[resr[i]];\n\t\t\tfor (int i = 1; i <= n; i++) resr[i] = tmp[i];\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) tmp[i] = l[l[i]];\n\t\tfor (int i = 1; i <= n; i++) l[i] = tmp[i];\n\t\tfor (int i = 1; i <= n; i++) tmp[i] = r[r[i]];\n\t\tfor (int i = 1; i <= n; i++) r[i] = tmp[i];\n\t\tK >>= 1;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (mt == 1) mid[i] = p[i];\n\t\telse if (mt == 2) mid[i] = q[i];\n\t\telse if (mt == 3) mid[i] = q[ip[i]];\n\t\telse if (mt == 4) mid[i] = q[ip[iq[i]]];\n\t\telse if (mt == 5) mid[i] = q[ip[iq[p[iq[i]]]]];\n\t\telse mid[i] = q[ip[iq[p[iq[q[p[iq[i]]]]]]]];\n\tfor (int i = 1; i <= n; i++) printf(\"%d \", resl[mid[resr[i]]]);\n\treturn puts(\"\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100010\n\nint n;\n\nstruct P{\n\tint *a;\n\n\tP(){\n\t\ta = new int[n+1];\n\t\tfor(int i=1;i<=n;i++) a[i]=i;\n\t}\n\n\tint & operator[](int i){\n\t\treturn a[i];\n\t}\n\n\tP operator*(P x){\n\t\tP t;\n\t\tfor(int i=1;i<=n;i++) t[i] = x[a[i]];\n\t\treturn t;\n\t}\n}p,q;\n\nP T(P p){\n\tP q;\n\tfor(int i=1;i<=n;i++) q[p[i]]=i;\n\treturn q;\n}\n\nP getPow(P x, int y){\n\tP res;\n\twhile(y){\n\t\tif(y&1) res=res*x;\n\t\tx=x*x;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\nP gao(int k){\n\tP t = p*T(q)*T(p)*q;\n\tt = getPow(t, k/6);\n\tp = T(t)*p*t;\n\tq = T(t)*q*t;\n\tk %= 6;\n\twhile(k--){\n\t\tt = T(p)*q;\n\t\tp=q; q=t;\n\t}\n\treturn p;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"in\",\"r\",stdin);\n#endif\n\tint K;\n\tscanf(\"%d%d\",&n,&K);\n\tp=P(); q=P();\n\tK--;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",p.a+i);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",q.a+i);\n\tP res = gao(K);\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%d \",res[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nvector<int> operator*(const vector<int>&x, const vector<int>&y) {\n\tvector<int>z(x.size());\n\trep(i, 0, z.size()) {\n\t\tz[i] = x[y[i]];\n\t}\n\treturn z;\n}\nvector<int>inv(vector<int>&x) {\n\tvector<int>z(x.size());\n\trep(i, 0, x.size()) {\n\t\tz[x[i]] = i;\n\t}\n\treturn z;\n}\nvector<int> pow(vector<int> base, long long exponent) {\n\tvector<int>res(base.size());\n\tiota(all(res), 0);\n\twhile (exponent > 0) {\n\t\tif (exponent & 1)\n\t\t\tres = res * base;\n\t\tbase = base * base;\n\t\texponent >>= 1;\n\t}\n\treturn res;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N; cin >> N;\n\tint K; cin >> K;\n\tvector<int>p(N); rep(i, 0, N) { cin >> p[i]; p[i]--; }\n\tvector<int>q(N); rep(i, 0, N) { cin >> q[i]; q[i]--; }\n\n\tauto base=q*inv(p)*inv(q)*p;\n\tauto x = pow(base, (K - 1) / 6);\n\n\tint r = (K - 1) % 6;\n\tvector<vector<int>>a;\n\ta.eb(x*p*inv(x));\n\ta.eb(x*q*inv(x));\n\n\trep(i, 2, 10)a.eb(a[i - 1] * inv(a[i - 2]));\n\n\trep(i, 0, N)cout << a[r][i]+1 << (i == N - 1 ? '\\n' : ' ');\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> inv(vector<int> A){\n    int N = A.size();\n    vector<int> ret(N);\n    for(int i=0; i<N; i++) ret[A[i]] = i;\n    return ret;\n}\n\nvector<int> mul(vector<int> A, vector<int> B){\n    int N = A.size();\n    vector<int> ret(N);\n    for(int i=0; i<N; i++) ret[i] = A[B[i]];\n    return ret;\n}\n\nint main(){\n    int N, K;\n    cin >> N >> K;\n    K--;\n    vector<int> P(N), Q(N);\n    for(int i=0; i<N; i++){\n        cin >> P[i];\n        P[i]--;\n    }\n    for(int i=0; i<N; i++){\n        cin >> Q[i];\n        Q[i]--;\n    }\n    auto PI = inv(P);\n    auto QI = inv(Q);\n\n    auto X = mul(Q, mul(PI, mul(QI, P)));\n    int q = K/6, r = K%6;\n    vector<int> A(N);\n    for(int i=0; i<N; i++) A[i] = i;\n    while(q > 0){\n        if(q%2){\n            A = mul(A, X);\n        }\n        q /= 2;\n        X = mul(X, X);\n    }\n    if(r >= 3) A = mul(A, Q);\n    if(r >= 4) A = mul(A, PI);\n\n    vector<int> B;\n    if(r == 0) B = P;\n    if(r == 1) B = Q;\n    if(r == 2) B = mul(Q, PI);\n    if(r == 3) B = PI;\n    if(r == 4) B = QI;\n    if(r == 5) B = mul(QI, P);\n\n    vector<int> ans = mul(A, mul(B, inv(A)));\n    for(int i=0; i<N; i++) cout << ans[i]+1 << \" \\n\"[i==N-1]; \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 100010;\nconst int INF = 2147483600;\n\nint N,K; int b[MAXN+1],c[MAXN+1]; bool vis[MAXN+1]; int sta[MAXN+1],top;\nstruct data{\n\tint a[MAXN+1];\n\tinline void Pow(LL k){\n\t\tfor(int i=1;i<=N;i++) vis[i]=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(vis[i]) continue;\n\t\t\tint nw=i; top=0; while(!vis[a[nw]]) sta[top++]=nw=a[nw],vis[nw]=1;\n\t\t\tnw=k%top; for(int j=0;j<top;j++){\n\t\t\t\tb[sta[j]]=sta[nw],++nw; if(nw>=top) nw-=top; }\n\t\t} for(int i=1;i<=N;i++) a[i]=b[i];\n\t\treturn ;\n\t}\n}An[9];\ndata operator * (const data p,const data q){\n\tdata nw; for(int i=1;i<=N;i++) nw.a[i]=p.a[q.a[i]]; return nw;\n}\ninline data Inv(data n){\n\tdata ret; for(int i=1;i<=N;i++) b[n.a[i]]=i;\n\tfor(int i=1;i<=N;i++) ret.a[i]=b[i]; return ret;\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(); K=read();\n\tfor(int i=1;i<=N;i++) An[1].a[i]=read();\n\tfor(int i=1;i<=N;i++) An[2].a[i]=read();\n\tfor(int i=3;i<=7;i++) An[i]=An[i-1]*Inv(An[i-2]);\n\tint m=(K-1)/6,n=(K-1)%6+1;\n\tdata p,q; p=An[1]; q=An[2];\n\tdata A; A=q; A=A*Inv(p); A=A*Inv(q); A=A*p;\n\tdata ivA; ivA=Inv(A);\n\tA.Pow(m); ivA.Pow(m);\n\tdata ret; ret=A; ret=ret*An[n]; ret=ret*ivA;\n\tfor(int i=1;i<=N;i++) printf(\"%d \",ret.a[i]);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Maxn 100007\nint n,k;\nint p[Maxn],q[Maxn];\nint a[Maxn],b[Maxn],tmp1[Maxn],tmp2[Maxn];\nint ans[Maxn],r[Maxn];\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&p[i]);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&q[i]);\n    if (k%6==1)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=p[i];\n    } else if (k%6==2)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=q[i];\n    } else if (k%6==3)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=q[i];\n    } else if (k%6==4)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=i;\n    } else if (k%6==5)\n    {\n        for (int i=1;i<=n;i++)\n            b[q[i]]=i;\n    } else\n    {\n        for (int i=1;i<=n;i++)\n            tmp2[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            b[i]=tmp2[p[i]];\n    }\n    for (int i=1;i<=n;i++)\n        ans[i]=i;\n    if (k>1)\n    {\n        --k;\n        int c=k/6;\n        k%=6;\n        for (int i=1;i<=n;i++)\n            tmp1[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            r[i]=p[tmp1[i]];\n        for (int i=1;i<=n;i++)\n            r[i]=q[r[i]];\n        for (int i=1;i<=n;i++)\n            tmp1[p[i]]=i;\n        for (int i=1;i<=n;i++)\n            r[i]=tmp1[r[i]];\n        while (c>0)\n        {\n            if (c%2==1)\n            {\n                for (int i=1;i<=n;i++)\n                    ans[i]=r[ans[i]];\n            }\n            c/=2;\n            for (int i=1;i<=n;i++)\n                tmp1[i]=r[i];\n            for (int i=1;i<=n;i++)\n                r[i]=tmp1[tmp1[i]];\n        }\n        if (k%6==3)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[ans[i]];\n        } else if (k%6==4||k%6==5)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[ans[i]];\n            for (int i=1;i<=n;i++)\n                ans[i]=p[ans[i]];\n        } else if (k%6==0)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[ans[i]];\n            for (int i=1;i<=n;i++)\n                ans[i]=q[p[ans[i]]];\n        }\n    }\n    for (int i=1;i<=n;i++)\n        a[ans[i]]=i;\n    for (int i=1;i<=n;i++)\n        ans[i]=b[ans[i]];\n    for (int i=1;i<=n;i++)\n        ans[i]=a[ans[i]];\n    for (int i=1;i<=n;i++)\n        printf(\"%d \",ans[i]);\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nvoid print(vector<int> a){\n    for (int i=0; i < a.size(); i++) cout << a[i]+1 << \" \";\n    exit(0);\n}\nvector<int> rev(vector<int> &a){\n    int n = a.size();\n    vector<int> res(n);\n    for (int i=0;i<n;i++) res[a[i]] = i;\n    return res;\n}\nvector<int> mult(vector<int> a, vector<int> b){\n    int n = a.size();\n    vector<int> res(n);\n    for (int i=0; i < n; i++) res[i] = b[a[i]];\n    return res;\n}\nvector<int> pw(vector<int> &a, int d){\n    if (d==0){\n        vector<int> K;\n        for (int i=0;i<a.size();i++) K.push_back(i);\n        return K;\n    }\n    if (d==1) return a;\n    if (d % 2 == 0){\n        vector<int> res = pw(a,d/2);\n        return mult(res, res);\n    }\n    return mult(a, pw(a,d-1));\n}\nvector<int> get(vector<vector<int> > kek, int d){\n    int n = kek[0].size();\n    vector<int> cp;\n    for (int i=0;i<n;i++) cp.push_back(i);\n    for (int i=0;i<4;i++) cp = mult(cp, kek[i]);\n    int N = d/4;\n    cp = pw(cp, N);\n    for (int i=0;i<(d%4);i++) cp = mult(cp, kek[i]);\n    return cp;\n}\nmain() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n), b(n);\n    for (int i=0; i < n; i++) cin >> a[i];\n    for (int i=0; i < n; i++) a[i]--;\n    for (int i=0; i < n; i++) cin >> b[i];\n    for (int i=0; i < n; i++) b[i]--;\n    if (k==1) print(a);\n    if (k==2) print(b);\n    int deg = ((k-3)/3) * 4 + 2;\n    if (k%3 == 1) deg++;\n    if (k%3==2) deg += 3;\n    vector<int> reva = rev(a), revb = rev(b);\n    vector<vector<int> > revlist = {revb, a, b, reva};\n    int need = (deg-1)/2;\n    vector<int> relax = get(revlist, need);\n    vector<int> R = rev(relax);\n    if (deg % 2 != 0){\n        if (deg % 8 == 7) relax = mult(relax, mult(a, R));\n        if (deg % 8 == 1) relax = mult(relax, mult(b, R));\n        if (deg % 8 == 3) relax = mult(relax, mult(reva, R));\n        if (deg % 8 == 5) relax = mult(relax, mult(revb, R));\n    }\n    else{\n        if (deg % 8 == 2) relax = mult(relax, mult(reva, mult(b, R)));\n        if (deg % 8 == 6) relax = mult(relax, mult(revb, mult(a, R)));\n    }\n    print(relax);\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// 代表的関数\nvector<int> idv, p, q, pi, qi; // pi, qi は p, q の逆写像, idv は恒等写像\n\n// 逆写像計算\nvector<int> inv(const vector<int> &v) {\n    int N = v.size();\n    vector<int> res(N);\n    for (int i = 0; i < N; ++i) res[v[i]] = i;\n    return res;\n}\n\n// 合成写像計算\ninline vector<int> operator +(const vector<int> &a, const vector<int> &b) {\n    int N = a.size();\n    vector<int> res(N);\n    for (int i = 0; i < N; ++i) res[i] = a[b[i]];\n    return res;\n}\n\n// r_k\nvector<vector<int> > beki; // beki[i] := r[4×2^i], 前計算しておく\nvector<int> calc(long long k) {\n    int num = k / 4;\n    int r = k % 4;\n    vector<int> amari = idv;\n    if (r == 0) amari = idv;\n    else if (r == 1) amari = pi;\n    else if (r == 2) amari = pi + qi;\n    else if (r == 3) amari = pi + qi + p;\n    auto syuki = idv;\n    for (int i = 0; i < 35; ++i) if (num & (1LL<<i)) syuki = syuki + beki[i];\n    return syuki + amari;\n}\n\n// 解く\nvector<int> solve(long long K) {\n    if (K == 1) return p;\n    if (K == 2) return q;\n    if (K == 3) return q + pi;\n    if (K == 4) return q + pi + qi;\n    if (K == 5) return q + pi + qi + p + qi;\n    if (K == 6) return q + pi + qi + p + p + qi;\n    long long a, b;\n    long long k = K / 3;\n    if (K % 3 == 0) a = k*2-1, b = k*2-3;\n    else if (K % 3 == 1) a = k*2, b = k*2-3;\n    else a = k*2, b = k*2-1;\n    auto res = q + calc(a) + inv(calc(b)) + qi;\n    return res;\n}\n\nint main() {\n    // 入力, 恒等写像, 逆写像\n    int N, K; cin >> N >> K;\n    idv.resize(N); p.resize(N); q.resize(N);\n    for (int i = 0; i < N; ++i) idv[i] = i;\n    for (int i = 0; i < N; ++i) cin >> p[i], --p[i];\n    for (int i = 0; i < N; ++i) cin >> q[i], --q[i];\n    pi = inv(p);\n    qi = inv(q);\n\n    // 繰り返し構造のダブリング前処理\n    auto pqpq = pi + qi + p + q;\n    beki.resize(35);\n    beki[0] = pqpq;\n    for (int i = 0; i+1 < 35; ++i) beki[i+1] = beki[i] + beki[i];\n\n    // 解く\n    auto res = solve(K);\n    for (auto v : res) cout << v + 1 << \" \";\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\ntemplate <typename T>\nvoid debug_out(T t) {\n  cerr << t;\n}\n\ntemplate <typename A, typename B>\nvoid debug_out(pair<A, B> u) {\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\n}\n\ntemplate <typename T>\nvoid debug_out(vector<T> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << \", \";\n  }\n}\n\ntemplate <typename T>\nvoid debug_out(vector<vector<T>> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << endl;\n  }\n}\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\" << endl, debug_out(__VA_ARGS__), cerr << endl;\n\n\nint n, k;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  k--;\n  vector<int> p(n);\n  range(i, 0, n) {\n    cin >> p[i];\n    p[i]--;\n  }\n  vector<int> q(n);\n  range(i, 0, n) {\n    cin >> q[i];\n    q[i]--;\n  }\n  auto f = [&] (vector<int> x, vector<int> y) {\n    vector<int> a(n);\n    range(i, 0, n) a[x[i]] = y[i];\n    return a;\n  };\n  vector<vector<int>> a(3);\n  a[0] = p;\n  a[1] = q;\n  a[2] = f(p, q);\n  while(a.back() != a[1] || a[a.size() - 2] != a[0]) {\n    assert(a.size() < 1000);\n    a.push_back(f(a[a.size() - 2], a.back()));\n  }\n  a.pop_back();\n  a.pop_back();\n  k %= a.size();\n  for(int i : a[k]) cout << i + 1 << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5;\nint n, k;\nvector<int> p, q;\nvector<int> pt = {0, 7, 9, 4, 8, 2, 5, 1, 6, 10, 3};\nmap<pair<vector<int>, vector<int> >, int> mp;\nvoid go(int h, vector<int> p, vector<int> q) {\n    if (h == k) {\n        for (int i = 1; i <= n; i++) {\n            cout << p[i];\n            if (i != n) cout << \" \";\n            else cout << \"\\n\";\n        }\n        exit(0);\n    }\n    if (mp.find({p, q}) != mp.end()) {\n        int start = mp[{p, q}];\n        int last = h - 1;\n        int len = last - start + 1;\n        k = k - start + 1;\n        k = k % len;\n        if (k == 0) {\n            k = len;\n        }\n        mp.clear();\n        go(1, p, q);\n    }\n    mp[{p, q}] = h;\n    vector<int> m(n + 1);\n    for (int i = 1; i <= n; i++) m[p[i]] = q[i];\n    go(h + 1, q, m);\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n >> k;\n    p.resize(n + 1);\n    q.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> p[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        cin >> q[i];\n    }\n    go(1, p, q);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 5;\nint n, k;\nvector<int> p, q;\n\nbool read() {\n  if (scanf(\"%d%d\", &n, &k) < 2) {\n    return false;\n  }\n  k--;\n  p.resize(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &p[i]);\n    p[i]--;\n  }\n  q.resize(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &q[i]);\n    q[i]--;\n  }\n  return true;\n}\n\nvector<int> inv(const vector<int> &p) {\n  vector<int> q(n);\n  for (int i = 0; i < n; i++) {\n    q[p[i]] = i;\n  }\n  return q;\n}\n\nvector<int> mul(const vector<int> &a, const vector<int> &b) {\n  vector<int> c(n);\n  for (int i = 0; i < n; i++) {\n    c[i] = a[b[i]];\n  }\n  return c;\n}\n\nvector<int> powPerm(vector<int> p, int k) {\n  vector<int> res(n);\n  for (int i = 0; i < n; i++) {\n    res[i] = i;\n  }\n  while (k) {\n    if (k & 1) {\n      res = mul(res, p);\n    }\n    k >>= 1;\n    p = mul(p, p);\n  }\n  return res;\n}\n\nvoid printAns(const vector<int> &p) {\n  for (int i = 0; i < n; i++) {\n    printf(\"%d \", p[i] + 1);\n  }\n  printf(\"\\n\");\n}\n\nvoid solve() {\n  if (k == 0) {\n    printAns(p);\n    return;\n  }\n  if (k == 1) {\n    printAns(q);\n    return;\n  }\n  if (k == 2) {\n    printAns(mul(q, inv(p)));\n    return;\n  }\n  vector<int> a;\n  {\n    int x = k / 3;\n    a = powPerm(mul(mul(q, inv(p)), mul(inv(q), p)), x / 2);\n    if (x & 1) {\n      a = mul(a, mul(mul(q, inv(p)), inv(q)));\n    } else {\n      a = mul(a, q);\n    }\n  }\n  vector<int> b;\n  {\n    int x = (k - 3) / 6;\n    b = powPerm(mul(mul(inv(p), q), mul(p, inv(q))), x);\n    int y = (k - 3) % 6;\n    if (y == 1) {\n      b = mul(mul(p, inv(q)), b);\n    } else if (y == 2) {\n      b = mul(mul(mul(p, p), inv(q)), b);\n    } else if (y == 3) {\n      b = mul(mul(p, inv(q)), b);\n    } else if (y == 4) {\n      b = mul(mul(mul(inv(p), q), mul(p, inv(q))), b);\n    } else if (y == 5) {\n      b = mul(mul(mul(mul(inv(p), inv(p)), q), mul(p, inv(q))), b);\n    }\n  }\n  printAns(mul(a, b));\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,tune=native\")\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(),(x).end()\n#define I(x, a) for(auto x : (a))\n#define ins insert\n#define F(i, l, r) for(auto i = (l); i < (r); i++)\n#define DF(i, l, r) for(auto i = (l); i >= (r); i--)\n#define E(i, l, r) for(auto i = (l); i <= (r); i++)\n#define pb push_back\n#define X first\n#define Y second\n#define mp make_pair\n#define ret return\n#define brk break\n#define cont continue\n#define move fjgjgjgjghd\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double dbl;\ntypedef pair<int, int> pii;\n\ntypedef vector<int> perm;\n\nconst int mod = (int)1e9 + 7;\nconst int N = (int)2e5 + 5;\n\nint n, k;\n\nperm mul(const perm & a, const perm & b){\n\tperm q(a.size());\n\tF(i, 0, n)\n\t\tq[i] = a[b[i]];\n\treturn q;\n}\n\nperm inv(const perm & a){\n\tperm b(a.size());\n\tF(i, 0, n)\n\t\tb[a[i]] = i;\n\tret b;\n}\n\nvoid finish(const perm & p){\n\tI(x, p)cout << x + 1 << ' ';\n\texit(0);\n}\n\nint wc[N];\nint nxt[N];\nint cycle[N];\n\nperm pw(const perm & a, int w){\n\tif(w == 0){\n\t\tvector<int>res(a.size());\n\t\tiota(all(res), 0);\n\t\tret res;\n\t}\n//\tF(i, 0, n)cerr << a[i] << ' ';\n//\tcerr << endl;\n\tvector<int> res(a.size());\n\tfill(wc, wc + n, 0);\n\tF(i, 0, n){\n\t\tnxt[i] = a[i];\n\t\tcycle[i] = 0;\n\t}\n\tF(i, 0, n){\n\t\tif(wc[i])cont;\n\t\tint j = i;\n\t\twc[i] = 1;\n\t\tcycle[i] = 1;\n\t\tj = nxt[i];\n\t\twhile(j != i){\n\t\t\t++cycle[i];\n\t\t\twc[j] = 1;\n\t\t\tj = nxt[j];\n\t\t}\n\t}\n\tF(i, 0, n){\n\t\tif(wc[i] == 2)cont;\n\t\tint len = w%cycle[i];\n\t\tint j = i;\n\t\tF(t, 0, len)j = nxt[j];\n\t\tres[i] = j;\n\t\tint t = nxt[i];\n\t\twc[i] = 2;\n\t\twhile(t != i){\n\t\t\twc[t] = 2;\n\t\t\tj = nxt[j];\n\t\t\tres[t] = j;\n\t\t\tt = nxt[t];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tvector<int> p, q;\n\tcin >> n >> k;\n\tp.resize(n); q.resize(n);\n\tF(i, 0, n){\n\t\tcin >> p[i];\n\t\t--p[i];\n\t}\n\tF(i, 0, n){\n\t\tcin >> q[i];\n\t\t--q[i];\n\t}\n\tauto ip = inv(p);\n\tauto iq = inv(q);\n\tif(k == 1)finish(p);\n\tif(k == 2)finish(q);\n\tint r = k%6;\n\tauto L = mul(q, ip);\n\tL = mul(L, iq);\n\tL = mul(L, p);\n\tif(r == 0){\n\t\tL = pw(L, k/6);\n\t\tL = mul(L, p);\n\t\tL = mul(L, iq);\n\t\tauto R = mul(ip, q);\n\t\tR = mul(R, p);\n\t\tR = mul(R, iq);\n\t\tR = pw(R, k/6 - 1);\n\t\tL = mul(L, R);\n\t\tfinish(L);\n\t}\n\tif(r == 1){\n\t\tL = pw(L, k/6);\n\t    auto R = mul(q, p);\n\t\tR = mul(R, iq);\n\t\tR = mul(R, ip);\n\t\tR = pw(R, k/6);\n\t\tR = mul(R, p);\n\t\tfinish(mul(L, R));\n\t}\n\tif(r == 2){\n\t\tL = pw(L, k/6);\n\t\tauto R = mul(q, p);\n\t\tR = mul(R, iq);\n\t\tR = mul(R, ip);\n\t\tR = pw(R, k/6);\n\t\tR = mul(R, p);\n\t\tR = mul(ip, R);\n\t\tR = mul(q, R);\n\t\tfinish(mul(L, R));\n\t}\n\tif(r == 3){\n\t\tL = pw(L, k/6);\n\t\tL = mul(L, q);\n\t\tL = mul(L, ip);\n\t\tauto R = mul(ip, q);\n\t\tR = mul(R, p);\n\t\tR = mul(R, iq);\n\t\tR = pw(R, k/6);\n\t\tfinish(mul(L, R));\n\t}\n\tif(r == 4){\n\t\tL = pw(L, k/6 + 1);\n\t\tL = mul(L, ip);\n\t\tauto R = mul(ip, q);\n\t\tR = mul(R, p);\n\t\tR = mul(R, iq);\n\t\tR = pw(R, k/6);\n\t\tfinish(mul(L, R));\n\t}\n\tif(r == 5){\n\t\tL = pw(L, k/6 + 1);\n\t\tL = mul(L, iq);\n\t\tauto R = mul(ip, q);\n\t\tR = mul(R, p);\n\t\tR = mul(R, iq);\n\t\tR = pw(R, k/6);\n\t\tfinish(mul(L, R));\n\t}\n\tassert(0);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 100010;\nconst int INF = 2147483600;\n\nint N,K; int b[MAXN+1],c[MAXN+1]; bool vis[MAXN+1]; int sta[MAXN+1],top;\nstruct data{\n\tint a[MAXN+1];\n\tinline void Pow(LL k){\n\t\tfor(int i=1;i<=N;i++) vis[i]=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(vis[i]) continue;\n\t\t\tint nw=i; top=0; while(!vis[a[nw]]) sta[top++]=nw=a[nw],vis[nw]=1;\n\t\t\tnw=k%top; for(int j=0;j<top;j++){\n\t\t\t\tb[sta[j]]=sta[nw],++nw; if(nw>=top) nw-=top; }\n\t\t} for(int i=1;i<=N;i++) a[i]=b[i];\n\t\treturn ;\n\t}\n}An[9];\ndata operator * (const data p,const data q){\n\tdata nw; for(int i=1;i<=N;i++) nw.a[i]=p.a[q.a[i]]; return nw;\n}\ninline data Inv(data n){\n\tdata ret; for(int i=1;i<=N;i++) b[n.a[i]]=i;\n\tfor(int i=1;i<=N;i++) ret.a[i]=b[i]; return ret;\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(); K=read();\n\tfor(int i=1;i<=N;i++) An[1].a[i]=read();\n\tfor(int i=1;i<=N;i++) An[2].a[i]=read();\n\tfor(int i=3;i<=7;i++) An[i]=An[i-1]*Inv(An[i-2]);\n\tint m=(K-1)/6,n=(K-1)%6+1;\n\tdata p,q; p=An[1]; q=An[2];\n\tdata A; A=q; A=A*Inv(p); A=A*Inv(q); A=A*p;\n\tdata ivA; ivA=Inv(A);\n\tA.Pow(m); ivA.Pow(m);\n\tdata ret; ret=A; ret=ret*An[n]; ret=ret*ivA;\n\tfor(int i=1;i<=N;i++) printf(\"%d \",ret.a[i]);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fi first\n#define se second\n#define sz(a) int(a.size())\n#define clr(a) memset(a,0,sizeof(a))\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int mod=1;\ntemplate<typename T=int>\nT gi() {\n\tT x=0,o=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\ntemplate<typename T> bool chkmax(T &a,T b) { return a<b?a=b,1:0; };\ntemplate<typename T> bool chkmin(T &a,T b) { return a>b?a=b,1:0; };\nint add(int a,int b) { return a+b>=mod?a+b-mod:a+b; }\nint sub(int a,int b) { return a-b<0?a-b+mod:a-b; }\nvoid inc(int &a,int b) { a=(a+b>=mod?a+b-mod:a+b); }\nvoid dec(int &a,int b) { a=(a-b<0?a-b+mod:a-b); }\nstring to_string(string s) { return '\"'+s+'\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(bool b) { return (b?\"true\":\"false\"); }\ntemplate<typename A,typename B> string to_string(pair<A,B> p) {\n\treturn \"(\"+to_string(p.fi)+\",\"+to_string(p.se)+\")\";\n}\ntemplate<typename T> string to_string(T v) {\n\tint fst=1;string ret=\"{\";\n\tfor(auto x:v) {\n\t\tif(!fst) ret+=\",\";\n\t\tfst=0,ret+=to_string(x);\n\t}\n\tret+=\"}\";return ret;\n}\nvoid dbg_out() { cerr<<endl; }\ntemplate<typename Head,typename... Tail> void dbg_out(Head H,Tail... T) {\n\tcerr<<\" \"<<to_string(H);\n\tdbg_out(T...);\n}\n#define dbg(...) cerr<<\"{\"<<#__VA_ARGS__<<\"}:\",dbg_out(__VA_ARGS__)\n\ntemplate<typename T>\nint qpow(int a,T b) {\n\tint ret=1;\n\twhile(b) {\n\t\tif(b&1) ret=1ll*ret*a%mod;\n\t\ta=1ll*a*a%mod,b>>=1;\n\t}\n\treturn ret;\n}\n\nconst int N=1e5+10;\nvector<int> unit;\n\nvector<int> pinv(vector<int> a) {\n\tint n=sz(a);\n\tvector<int> ret(n);\n\tfor(int i=0;i<n;i++) ret[a[i]]=i;\n\treturn ret;\n}\n\nvector<int> pmul(vector<int> a,vector<int> b) {\n\tint n=sz(a);\n\tvector<int> ret(n);\n\tfor(int i=0;i<n;i++) ret[i]=b[a[i]];\n\treturn ret;\n}\n\nvector<int> ppow(vector<int> a,int b) {\n\tvector<int> ret=unit;\n\twhile(b) {\n\t\tif(b&1) ret=pmul(ret,a);\n\t\ta=pmul(a,a),b>>=1;\n\t}\n\treturn ret;\n}\n\nint n,k;\n\nint main() {\n\tn=gi(),k=gi()-1;\n\tfor(int i=0;i<n;i++) unit.pb(i);\n\tvector<vector<int>> a(6,vector<int>(n));\n\tfor(int i=0;i<n;i++) a[0][i]=gi()-1;\n\tfor(int i=0;i<n;i++) a[1][i]=gi()-1;\n\tfor(int i=2;i<6;i++) a[i]=pmul(pinv(a[i-2]),a[i-1]);\n\tvector<int> A=a[0];\n\tA=pmul(A,pinv(a[1]));\n\tA=pmul(A,pinv(a[0]));\n\tA=pmul(A,a[1]);\n\tvector<int> ans=ppow(pinv(A),k/6);\n\tans=pmul(ans,a[k%6]);\n\tans=pmul(ans,ppow(A,k/6));\n\tfor(auto x:ans) printf(\"%d \",x+1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 1000700\nint n,k,ct,p[N],q[N],rp[N],rq[N],s[N],rs[N],vis[N],st[N],as[N],s1[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&q[i]);\n\tif(k==1){for(int i=1;i<=n;i++)printf(\"%d \",p[i]);return 0;}\n\tif(k<=6)\n\t{\n\t\tfor(int i=3;i<=k;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)s[p[j]]=q[j],p[j]=q[j];\n\t\t\tfor(int j=1;j<=n;j++)q[j]=s[j];\n\t\t}\n\t\tfor(int i=1;i<=n;i++)printf(\"%d \",q[i]);return 0;\n\t}\n\tfor(int i=1;i<=n;i++)rp[p[i]]=i,rq[q[i]]=i;\n\tfor(int i=1;i<=n;i++)s1[i]=rp[q[p[rq[i]]]];\n\tfor(int i=3;i<=(k-1)%6+7;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)s[p[j]]=q[j],p[j]=q[j];\n\t\tfor(int j=1;j<=n;j++)q[j]=s[j];\n\t}\n\tfor(int i=1;i<=n;i++)if(!vis[i])\n\t{\n\t\tct=0;st[ct=1]=i;vis[i]=1;\n\t\tfor(int j=s1[i];j!=i;j=s1[j])st[++ct]=j,vis[j]=1;\n\t\tfor(int j=1;j<=ct;j++)as[st[j]]=st[(j-2+(k-1)/6)%ct+1];\n\t}\n\tfor(int i=1;i<=n;i++)rs[as[i]]=i;\n\tfor(int i=1;i<=n;i++)printf(\"%d \",rs[q[as[i]]]);\n}//"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iterator>\n\nusing namespace std;\n\nint main(){\n\n\tint n, k;\n\tvector<int> p, q, r;\n\n\tcin>> n >> k;\n\tp.resize(n);\n\tq.resize(n);\n\tr.resize(n);\n\n\tfor(int i=0;i<n;i++) cin>> p[i];\n\tfor(int i=0;i<n;i++) cin>> q[i];\n\n\tfor(int i=2;i<k;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tr[p[j]-1]=q[j];\n\t\t}\n\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcout<< r[j] << q[j] << p[j] << endl;\n\t\t\tp[j]=q[j];\n\t\t\tq[j]=r[j];\n\t\t}\n\n\t\tcout<< endl;\n\t}\n\n\tfor(int i=0;i<n;i++) cout<< r[i] << \" \";\n\tcout<< endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long double ldb ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 2e5 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int mod = 1e9 + 7 ;\nconst db eps = 1e-10 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nint n, k;\n\nstruct permutations\n{\n\tint pos[maxn];\n\tpermutations(){rep(i, 1, n) pos[i] = i;}\n\tfriend permutations operator * (permutations p, permutations q)\n\t{\n\t\tpermutations ret;\n\t\trep(i, 1, n) ret.pos[i] = p.pos[q.pos[i]];\n\t\treturn ret;\n\t}\n\tpermutations operator *= (permutations b)\n\t{\n\t\treturn *this = *this * b;\n\t}\n};\n\npermutations a, b, mul, ans;\n\npermutations inv(permutations a)\n{\n\tpermutations ret;\n\trep(i, 1, n) ret.pos[a.pos[i]] = i;\n\treturn ret;\n}\n\npermutations power(permutations a, ll b)\n{\n\tpermutations ret;\n\tfor (; b; b >>= 1, a *= a) if(b & 1) ret *= a;\n\treturn ret;\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &k);\n\trep(i, 1, n) scanf(\"%d\", &a.pos[i]);\n\trep(i, 1, n) scanf(\"%d\", &b.pos[i]);\n\tmul = power(b * inv(a) * inv(b) * a, (k - 1) / 6);\n\tk = (k - 1) % 6 + 1;\n\tif(k == 1) ans = mul * a * inv(mul);\n\telse if(k == 2) ans = mul * b * inv(mul);\n\telse if(k == 3) ans = mul * b * inv(a) * inv(mul);\n\telse if(k == 4) ans = mul * b * inv(a) * inv(b) * inv(mul);\n\telse if(k == 5) ans = mul * b * inv(a) * inv(b) * a * inv(b) * inv(mul);\n\telse ans = mul * b * inv(a) * inv(b) * a * a * inv(b) * inv(mul);\n\trep(i, 1, n) printf(\"%d%c\", ans.pos[i], \" \\n\"[i == n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Perm : vector<int> {\n    using vector<int>::vector;\n    Perm() {}\n    Perm(initializer_list<int> list) : vector<int>(list) {}\n\n};\n\nPerm& operator*=(Perm& a, const Perm& b) {\n    assert(a.size() == b.size());\n    int n = a.size();\n    Perm _a(a);\n    for (int i = 0; i < n; i++) {\n        a[i] = _a[b[i]];\n    }\n    return a;\n}\nPerm operator*(const Perm& a, const Perm& b) {\n    assert(a.size() == b.size());\n    int n = a.size();\n    Perm c(n);\n    for (int i = 0; i < n; i++) {\n        c[i] = a[b[i]];\n    }\n    return c;\n}\nPerm pinv(const Perm& a) {\n    int n = a.size();\n    Perm c(n);\n    for (int i = 0; i < n; i++) {\n        c[a[i]] = i;\n    }\n    return c;\n}\nPerm& operator/=(Perm& a, const Perm& b) {\n    return a *= pinv(b);\n}\nPerm operator/(const Perm& a, const Perm& b) {\n    return a * pinv(b);\n}\nPerm ppow(Perm a, int64_t e) {\n    if (e < 0) {\n        a = pinv(a);\n        e *= -1;\n    }\n    int n = a.size();\n    Perm c(n);\n    iota(c.begin(), c.end(), 0);\n    for (; e; e>>=1) {\n        if (e&1) c *= a;\n        a *= a;\n    }\n    return c;\n}\nint cycles_cnt(Perm a) {\n    int cnt = 0, n = a.size();\n    for (int i = 0; i < n; i++) {\n        if (~a[i]) {\n            cnt++;\n            for (int j = i; ~a[j];) {\n                int nxt = a[j];\n                a[j] = -1;\n                j = nxt;\n            }\n        }\n    }\n    return cnt;\n}\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    Perm p(n), q(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i];\n        p[i]--;\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> q[i];\n        q[i]--;\n    }\n    Perm ip = pinv(p);\n    Perm iq = pinv(q);\n    int exp = (k-1) / 6;\n    int rem = (k-1) % 6;\n    Perm base = q*ip*iq*p;\n    Perm lhs = ppow(base, exp);\n    Perm rhs = pinv(lhs);\n    Perm mid;\n    if      (rem == 0) mid = p;\n    else if (rem == 1) mid = q;\n    else if (rem == 2) mid = q*ip;\n    else if (rem == 3) mid = q*ip*iq;\n    else if (rem == 4) mid = q*ip*iq*p*iq;\n    else if (rem == 5) mid = q*ip*iq*p*p*iq;\n    Perm res = lhs * mid * rhs;\n    for (int i = 0; i < n; i++) {\n        cout << res[i]+1 << ' ';\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define ph push\n#define ptc putchar\n#define enter putchar('\\n')\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long double ldb;\ntypedef long long ll;\ntypedef long long lnt;\ninline int read(){\n\tint x = 0;char c = getchar();\n\twhile (!isdigit(c)) c = getchar();\n\twhile (isdigit(c)) x = (x << 1) + (x << 3) + c - '0' , c = getchar();\n\treturn x;\n}\ninline void write(int x){\n\tif (!x){\n       ptc('0');\n       return;\n\t}\n\tint dg[20] , len = 0;\n\twhile (x) dg[len++] = x % 10 , x /= 10;\n\twhile (len--) ptc(dg[len]+'0');\n}\ninline void writeln(int x){\n\twrite(x);\n\tptc('\\n');\n}\n\nconst int N = 2e5 + 10;\nint n , k ;\n\nstruct permutation{\n\tint a[N];\n\tinline int& operator [] (int x){return a[x];}\n};\n\ninline permutation operator * (permutation A,permutation B) {\n\tpermutation C;\n\tfor (int i = 1;i <= n;i++){\n\t\tC[i] = A[B[i]];\n\t}\n\treturn C;\n}\n\ninline permutation operator ^ (permutation A,int y) {\n\tpermutation C;\n\tfor (int i = 1;i <= n;i++) C[i] = i;\n\twhile (y){\n\t\tif (y & 1) C = C * A;\n\t\tA = A * A;y >>= 1;\n\t}\n\treturn C;\n}\n\ninline permutation inv(permutation A){\n\tpermutation B;\n\tfor (int i = 1;i <= n;i++){\n\t\tB[A[i]] = i;\n\t}\n\treturn B;\n}\n\nvoid Print(permutation x){\n    for(int i=1;i<=n;i++)\n        printf(\"%d \",x.a[i]);\n    puts(\"\");\n}\n\npermutation p , q , ip , iq , A , B , ans;\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i = 1;i <= n;i++){\n\t\tscanf(\"%d\",&p[i]);\n\t}\n\tfor (int i = 1;i <= n;i++){\n\t\tscanf(\"%d\",&q[i]);\n\t}\n\t\n\tip = inv(p) , iq = inv(q);\n\t\n\t\n    int f = (k - 1) / 6 , g = k - f * 6;\n    permutation h = q * ip * iq * p;\n    A = h ^ f;\n    \n\tif(g == 1){\n        B = p;\n    }else \n\tif(g == 2){\n        B = q;\n    }else \n\tif(g == 3){\n        B = q * ip;\n    }else \n\tif(g == 4){\n        A = A * q;\n        B = ip;\n    }else \n\tif(g == 5){\n        A = A * q * ip;\n        B = iq;\n    }else{\n        A = A * q * ip;\n        B = iq * p;\n    }\n    \n    ans = A * B * inv(A);\n    Print(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//problem:agc031_d\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=1e5+5;\nint n,k,p[MAXN],q[MAXN],t[MAXN],tt[MAXN],ttt[MAXN],a[MAXN],b[MAXN];\nvoid rev(int *p,int *res){\n\tfor(int i=1;i<=n;++i)res[p[i]]=i;\n}\nvoid mul(int *p,int *q,int *res){\n\tfor(int i=1;i<=n;++i)res[i]=p[q[i]];\n}\nvoid cp(int *p,int *res){\n\tfor(int i=1;i<=n;++i)res[i]=p[i];\n}\nvoid get_a(){\n\tfor(int i=1;i<=n;++i)a[i]=i;\n\tint e=(k-1)/6;\n\tif(!e){\n\t\tif(k%6==1);\n\t\telse if(k%6==2);\n\t\telse if(k%6==3);\n\t\telse if(k%6==4)cp(q,a);\n\t\telse if(k%6==5)rev(p,t),mul(q,t,a);\n\t\telse if(k%6==0)rev(p,t),mul(q,t,a);\n\t\telse assert(0);\n\t}\n\t//a=tt^e\n\trev(p,t),rev(q,tt),mul(q,t,ttt),mul(ttt,tt,t),mul(t,p,tt);\n\twhile(e){\n\t\tif(e&1)mul(a,tt,t),cp(t,a);\n\t\tcp(tt,ttt),mul(tt,ttt,t),cp(t,tt);//tt=tt*tt\n\t\te>>=1;\n\t}\n}\nvoid get_b(){\n\tif(k%6==1)cp(p,b);\n\telse if(k%6==2)cp(q,b);\n\telse if(k%6==3)rev(p,t),mul(q,t,b);\n\telse if(k%6==4)rev(p,b);\n\telse if(k%6==5)rev(q,b);\n\telse if(k%6==0)rev(q,t),mul(t,p,b);\n\telse assert(0);\n}\nint main() {\n\tn=read();k=read();\n\tfor(int i=1;i<=n;++i)p[i]=read();\n\tfor(int i=1;i<=n;++i)q[i]=read();\n\tget_a();\n\tget_b();\n\trev(a,t),mul(a,b,tt),mul(tt,t,ttt);\n\tfor(int i=1;i<=n;++i)printf(\"%d \",ttt[i]);puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nstd::vector<int> a[100005];\nint n,k,cnt,used[100005];\nint ans[100005],p[100005],pp[100005],q[100005],qq[100005],g[100005],gg[100005],gk[100005],ggk[100005],f[10][100005],ff[10][100005];\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&q[i]);\n\tfor (int i=1;i<=n;i++) f[0][i]=i;\n\tfor (int i=1;i<=n;i++) ff[0][i]=i;\n\tfor (int i=1;i<=n;i++) f[1][i]=p[i];\n\tfor (int i=1;i<=n;i++) f[2][i]=q[i];\n\tfor (int i=1;i<=n;i++) ff[1][f[1][i]]=i;\n\tfor (int i=1;i<=n;i++) ff[2][f[2][i]]=i;\n\tfor (int r=3;r<=6;r++)\n\t{\n\t\tfor (int i=1;i<=n;i++) f[r][i]=f[r-1][ff[r-2][i]];\n\t\tfor (int i=1;i<=n;i++) ff[r][f[r][i]]=i;\n\t}\n\tfor (int i=1;i<=n;i++) pp[p[i]]=i;\n\tfor (int i=1;i<=n;i++) qq[q[i]]=i;\n\tfor (int i=1;i<=n;i++) g[i]=q[pp[qq[p[i]]]];\n\tfor (int i=1;i<=n;i++) gg[g[i]]=i;\n\tfor (int i=1;i<=n;i++)\n\t    if (!used[i])\n\t    {\n\t\t\tint x=++cnt;\n\t\t\tused[i]=1;\n\t\t\ta[x].push_back(i);\n\t    \tfor (int j=g[i];!used[j];j=g[j])\n\t    \t{\n\t    \t\ta[x].push_back(j);\n\t    \t\tused[j]=1;\n\t\t\t}\n\t    }\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tint sz=a[i].size();\n\t\tfor (int j=0;j<a[i].size();j++)\n\t\t{\n\t\t\tint x=a[i][j],y=a[i][(j+(k-1)/6)%sz];\n\t\t\tgk[x]=y;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) used[i]=0;\n\tfor (int i=1;i<=cnt;i++) a[i].clear();cnt=0;\n\tfor (int i=1;i<=n;i++)\n\t    if (!used[i])\n\t    {\n\t\t\tint x=++cnt;\n\t\t\tused[i]=1;\n\t\t\ta[x].push_back(i);\n\t    \tfor (int j=gg[i];!used[j];j=gg[j])\n\t    \t{\n\t    \t\ta[x].push_back(j);\n\t    \t\tused[j]=1;\n\t\t\t}\n\t    }\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tint sz=a[i].size();\n\t\tfor (int j=0;j<a[i].size();j++)\n\t\t{\n\t\t\tint x=a[i][j],y=a[i][(j+(k-1)/6)%sz];\n\t\t\tggk[x]=y;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) used[i]=0;\n\tfor (int i=1;i<=cnt;i++) a[i].clear();cnt=0;\n\tfor (int i=1;i<=n;i++) ans[i]=gk[f[(k-1)%6+1][ggk[i]]];\n\tfor (int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define mp make_pair\n\nvoid print(auto &a)\n{\n    for (auto s: a) cout<<s<<' ';\n    cout<<endl;\n}\n\nvoid get(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cin>>a[i];\n}\n\nconst int p =  1e9 + 7;\n\n\nint mul(int a, int b) {\n    return (1LL * a%p * b%p) % p;\n}\n\nint add(int a, int b) {\n    ll s = (a+b);\n    s = s%p;\n    if (s<0) s+=p; \n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}\n\n\n\nvector<int> Z(string s)\n{\nint n = s.length();\nvector<int> z(n);\nint L = 0, R = 0;\nfor (int i = 1; i < n; i++) {\n  if (i > R) {\n    L = R = i;\n    while (R < n && s[R-L] == s[R]) R++;\n    z[i] = R-L; R--;\n  } else {\n    int k = i-L;\n    if (z[k] < R-i+1) z[i] = z[k];\n    else {\n      L = i;\n      while (R < n && s[R-L] == s[R]) R++;\n      z[i] = R-L; R--;\n    }\n  }\n}\nreturn z;\n}\n\nvector<int> opvec(vector<int> a, vector<int> b)\n{\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i<n; i++) res[a[i]] = b[i];\n    return res;\n}\n\nvector<int> invvec(vector<int> a)\n{\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i<n; i++) res[a[i]] = i;\n    return res;\n}\n\nvector<int> mulvec(vector<int> a, vector<int> b)\n{\n    a = invvec(a);\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i<n; i++) res[a[i]] = b[i];\n    return res;\n}\n\nvector<int> id(int n)\n{\n    vector<int> res(n);\n    for (int i = 0; i<n; i++) res[i] = i;\n    return res;\n}\n\nvector<int> power(vector<int> a, int deg)\n{\n    if (deg==0) return id(a.size());\n    if (deg%2==1) return mulvec(power(a, deg-1), a);\n    auto kek = power(a, deg/2);\n    return mulvec(kek, kek);\n}\n\n\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    int n, k;\n    cin>>n>>k;\n    vector<int> a(n), b(n);\n    get(a);\n    get(b);\n    for (int i = 0; i<n; i++) {a[i]--; b[i]--;}\n    vector<int> keks(n);\n    \n    int m = 0;\n    if (k>21) m = (k-20)/6;\n    keks = mulvec(opvec(b, a), b);\n    keks = mulvec(keks, invvec(a));\n    keks = power(keks, m);\n    k -= 6*m;\n    vector<vector<int>> operations(k);\n    operations[0] = a;\n    operations[1] = b;\n    for (int i = 2; i<k; i++) operations[i] = opvec(operations[i-2], operations[i-1]);\n    vector<int> answer = mulvec(keks, operations[k-1]);\n    answer = mulvec(answer, invvec(keks));\n    for (int i = 0; i<n; i++) answer[i]++;\n    print(answer);\n    \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nint n,k;\nstruct per{\n  vector<int> x;\n  void pob(){\n    x.resize(n);\n    R(i,n){\n      cin >> x[i];\n      x[i]--;\n    }\n  }\n  void wys(){\n    R(i,n){\n      cout << x[i] + 1 << \" \";\n    }\n    cout << \"\\n\";\n  }\n  void odw(per a){\n    x.resize(n);\n    R(i,n){\n      x[a.x[i]] = i;\n    }\n  }\n  per(){};\n  per(per a,per b):x(n){\n    R(i,n){\n      x[i] = a.x[b.x[i]];\n    }\n  };\n  void id(){\n    x.resize(n);\n    R(i,n)x[i] = i;\n  }\n}a,b,a2,b2,res;\n\nvector<vector<int>> xxx = \n{\n  {1,-2},\n  {2,1,-2},\n  {2},\n  {2,-1},\n  {2,-1,-2},\n  {-2}\n};\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> k;\n  a.pob();\n  if(k == 1){\n    a.wys();\n    return 0;\n  }\n  b.pob();\n  a2.odw(a);\n  b2.odw(b);\n  per spec(per(b,a2),per(b2,a));\n  res.id();\n  int w = (k + 1) / 6;\n  while(w){\n    if(w & 1){\n      res = per(res,spec);\n    }\n    w/=2;\n    spec = per(spec,spec);\n  }\n  for(int el:xxx[k%6]){\n    if(el == 2){\n      res = per(res,b);\n    }else if(el == 1){\n      res = per(res,a);\n    }else if(el == -1){\n      res = per(res,a2);\n    }else {\n      res = per(res,b2);\n    }\n  }\n  \n  spec = per(per(a2,b),per(a,b2));\n  w = (k - 2) / 6;\n  while(w){\n    if(w & 1){\n      res = per(res,spec);\n    }\n    w/=2;\n    spec = per(spec,spec);\n  }\n  res.wys();\n  \n//   vector<vector<int>> f;\n//   f.PB({1});\n//   f.PB({2});\n//   for(int i = 0; i < 20; i++){\n//     vector<int> pom = f[i + 1];\n//     reverse(ALL(f[i]));\n//     for(int el:f[i]){\n//       if(el == pom.back()){\n//         pom.pop_back();\n//       }else\n//         pom.PB(-el);\n//     }\n//     reverse(ALL(f[i]));\n//     f.PB(pom);\n//     debug(pom);\n//   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll n, k;\nvector<int> p, q, ip, iq, tot1, tot2, id;\n\nvector<int> mul(vector<int> a, vector<int> b) {\n\tvector<int> ans;\n\tans.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tans[i] = a[b[i]];\n\treturn ans;\n}\n\nvector<int> inv(vector<int> a) {\n\tvector<int> ans;\n\tans.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tans[a[i]] = i;\n\treturn ans;\n}\n\nvector<int> exp(vector<int> a, int j) {\n\tif (j == 0)\n\t\treturn id;\n\tif (j%2 == 1)\n\t\treturn mul(a, exp(a, j-1));\n\tauto b = exp(a, j/2);\n\treturn mul(b, b);\n}\n\nvector<int> get1(ll j) {\n\tll l = 2*(j-1)/3;\n\tif (j%3 != 1)\n\t\tl += 2;\n\tauto ans = exp(tot1, l/4);\n\tif (l%4 == 0)\n\t\treturn ans;\n\tif (l%4 == 1)\n\t\treturn mul(ans, q);\n\tif (l%4 == 2)\n\t\treturn mul(ans, mul(q, ip));\n\tif (l%4 == 3)\n\t\treturn mul(ans, mul(q, mul(ip, iq)));\n}\n\nvector<int> get2(ll j) {\n\tll l = 2*(j-1)/3;\n\tif (j%3 != 0)\n\t\tl--;\n\tauto ans = exp(tot2, l/4);\n\tif (l%4 == 0)\n\t\treturn ans;\n\tif (l%4 == 1)\n\t\treturn mul(iq, ans);\n\tif (l%4 == 2)\n\t\treturn mul(p, mul(iq, ans));\n\tif (l%4 == 3)\n\t\treturn mul(q, mul(p, mul(iq, ans)));\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n >> k;\n\tp.resize(n);\n\tq.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> p[i]; p[i]--;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> q[i]; q[i]--;\n\t}\n\tid.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tid[i] = i;\n\n\tip = inv(p);\n\tiq = inv(q);\n\ttot1 = mul(q, mul(ip, mul(iq, p)));\n\ttot2 = mul(ip, mul(q, mul(p, iq)));\n\n\tvector<int> ans;\n\tif (k == 1)\n\t\tans = p;\n\telse if (k == 2)\n\t\tans = q;\n\telse if (k == 3)\n\t\tans = mul(q, ip);\n\telse\n\t\tans = mul(get1(k), get2(k));\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << ans[i]+1 << ' ';\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n    // return getchar();\n    static char buf[100000],*l=buf,*r=buf;\n    return l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x)\n{\n    x=0; int f=1,ch=nc();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n    while(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n    x*=f;\n}\nconst int maxn=1e5+50;\nint n,k;\nvector<int> id;\nvoid init()\n{\n    id.resize(n);\n    for(int i=0;i<n;++i) id[i]=i;\n}\nvector<int> mul(vector<int> a,vector<int> b)\n{\n    vector<int> re(n);\n    for(int i=0;i<n;++i) re[i]=a[b[i]];\n    return re;\n}\nvector<int> inver(vector<int> a)\n{\n    vector<int> re(n);\n    for(int i=0;i<n;++i) re[a[i]]=i;\n    return re;\n}\nvector<int> power(vector<int> x,int y)\n{\n    vector<int> re=id;\n    while(y)\n    {\n        if(y&1) re=mul(re,x);\n        x=mul(x,x);\n        y>>=1;\n    }\n    return re;\n}\nint main()\n{\n    read(n),read(k);\n    vector<int> p(n),q(n);\n    for(int i=0;i<n;++i) read(p[i]),--p[i];\n    for(int i=0;i<n;++i) read(q[i]),--q[i];\n    init();\n    int d=(k-1)/6; k-=d*6;\n    vector<int> A=id,B;\n    A=mul(A,q);\n    A=mul(A,inver(p));\n    A=mul(A,inver(q));\n    A=mul(A,p);\n    A=power(A,d);\n    if(k==1) B=p;\n    else if(k==2) B=q;\n    else if(k==3) B=mul(q,inver(p));\n    else if(k==4) A=mul(A,q),B=inver(p);\n    else if(k==5) A=mul(mul(A,q),inver(p)),B=inver(q);\n    else A=mul(mul(A,q),inver(p)),B=mul(inver(q),p);\n    vector<int> an=mul(mul(A,B),inver(A));\n    for(int i=0;i<n;++i)\n    {\n        if(i) printf(\" \");\n        printf(\"%d\",an[i]+1);\n    }\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int N=100005;\nvi A,B[10],p,q,res;\nint n,K;\n\nvi rev(vi a){\n\tvi b(n+1,0);\n\trep(i,1,n)b[a[i]]=i;\n\treturn b;\n}\n\nvi mul(vi a,vi b){\n\tvi c(n+1,0);\n\trep(i,1,n)c[i]=a[b[i]];\n\treturn c;\n}\n\nvi power(vi a,int p){\n\tvi res(n+1,0);\n\trep(i,1,n)res[i]=i;\n\tfor(;p;p>>=1,a=mul(a,a))\n\t\tif(p&1)res=mul(res,a);\n\treturn res;\n}\n\nint main(){\n\tcin>>n>>K;\n\tp.resize(n+1,0);\n\trep(i,1,n)cin>>p[i];\n\tq.resize(n+1,0);\n\trep(i,1,n)cin>>q[i];\n\tA=power(mul(q,mul(rev(p),mul(rev(q),p))),(K-1)/6);\n\tif(K%6==4)A=mul(A,q);\n\tif(K%6==5||K%6==0)A=mul(A,mul(q,rev(p)));\n\tB[1]=p;\n\tB[2]=q;\n\tB[3]=mul(q,rev(p));\n\tB[4]=rev(p);\n\tB[5]=rev(q);\n\tB[6]=mul(rev(q),p);\n\tres=mul(A,mul(B[(K-1)%6+1],rev(A)));\n\trep(i,1,n)printf(\"%d \",res[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\n\nInt n, k;\nvector<int> p, q;\nvector<int> P, Q;\n\nvector<int> permutate(vector<int> a, vector<int> b){\n    int n = a.size();\n    vector<int> res(n);\n    for(int i = 0;i < n;i++){\n        res[i] = b[a[i]];\n    }\n    return res;\n}\n\nvector<int> inverse(vector<int> a){\n    int n = a.size();\n    vector<int> res(n);\n    for(int i = 0;i < n;i++){\n        res[a[i]] = i;\n    }\n    return res;\n}\n\nvector<int> f(vector<int> a, vector<int> b){\n    return permutate(inverse(a), b);\n}\n\nvector<int> id;\n\nvector<int> power(vector<int> f, int x){\n    vector<int> res = id;\n    vector<int> tmp = f;\n    for(int i = 0;i <= 30;i++){\n        if((x >> i) % 2 == 1){\n            res = permutate(res, tmp);\n        }\n        tmp = permutate(tmp, tmp);\n    }\n    return res;\n}\n\nvoid show(vector<int> a){\n\n        for(int i = 0;i < n;i++){\n            cout << a[i] + 1 << \" \";\n        }cout << endl;\n}\n\nint main(){\n    cin >> n >> k;\n    P.resize(n);\n    Q.resize(n);\n    for(int i = 0;i < n;i++)id.push_back(i);\n    for(int i = 0;i < n;i++){cin >> P[i];P[i]--;}\n    for(int i = 0;i < n;i++){cin >> Q[i];Q[i]--;}\n    p = inverse(P);\n    q = inverse(Q);\n\n    vector<int> l = permutate(permutate(q, P), permutate(Q, p));\n    vector<int> r = permutate(permutate(P, q), permutate(p, Q));\n\n    vector<int> a = P;\n    vector<int> b = Q;\n\n    int ind = 1;\n    while(ind < k && ind < 7){\n        a = f(a, b);\n        swap(a, b);\n        ind++;\n    }\n    while((k - ind) % 6 != 0){\n        a = f(a, b);\n        swap(a, b);\n        ind++;\n    }\n    if(k == ind){\n        show(a);\n        return 0;\n    }\n    a = permutate(power(l, (k-ind) / 6), a);\n    a = permutate(a, power(r, (k-ind) / 6));\n    show(a);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int N = (int) 1e5 + 100;\nint n;\n\nstruct Perm\n{\n    int p[N];\n\n    Perm() : p() \n    {\n        for (int i = 0; i < N; i++)\n            p[i] = i;\n    }\n\n    void read()\n    {\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%d\", &p[i]);\n            p[i]--;\n        }\n    }\n\n    Perm inv() const\n    {\n        Perm ans = Perm();\n        for (int i = 0; i < n; i++)\n            ans.p[p[i]] = i;\n        return ans;\n    }\n\n    Perm operator * (const Perm &A) const\n    {\n        Perm ans = Perm();\n        for (int i = 0; i < n; i++)\n            ans.p[i] = A.p[p[i]];\n        return ans;\n    }\n\n    Perm fpow(int d)\n    {\n        if (d == 0)\n            return Perm();\n        Perm A = fpow(d / 2);\n        A = A * A;\n        if (d & 1)\n            A = A * *this;\n        return A;\n    }\n\n    void print() const\n    {\n        for (int i = 0; i < n; i++)\n            printf(\"%d \", p[i] + 1);\n        printf(\"\\n\");\n    }\n\n};\n\nPerm A, B, a, b, bABa;\n\nPerm getPref(int pref)\n{\n    Perm ans = bABa.fpow(pref / 4);\n    if (pref % 4 >= 1)\n        ans = ans * b;\n    if (pref % 4 >= 2)\n        ans = ans * A;\n    if (pref % 4 >= 3)\n        ans = ans * B;\n    return ans;\n}\n\nint getSufLen(int x)\n{\n    int ans = x - (x + 2) / 3;\n    return ans;\n}\n\nint getPrefLen(int x)\n{\n    int ans = x - x / 3 - 2;\n    return ans;\n}\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    for (int k = 3; k <= 10; k++)\n    {\n        eprintf(\"%d : %d %d\\n\", k, getPrefLen(k), getSufLen(k));\n    }\n\n\n    int k;\n    scanf(\"%d%d\", &n, &k);\n    A.read();\n    B.read();\n\n    if (n == 1)\n    {\n        A.print();\n        return 0;\n    }\n    if (n == 2)\n    {\n        B.print();\n        return 0;\n    }\n    int suff = getSufLen(k);\n    int pref = getPrefLen(k);\n    eprintf(\"%d : %d %d\\n\", k, pref, suff);\n\n    a = A.inv();\n    b = B.inv();\n\n    bABa = b * A * B * a;\n   \n    Perm X = getPref(pref), y = getPref(suff);\n    Perm Y = y.inv();\n\n    Perm ans = X * Y;\n    ans.print();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n\n#ifdef DEBUG\n#include <misc/C++/Debug.cpp>\n#else\n#define dump(x)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\nvector<int> compose(const vector<int> &p, const vector<int> &q){\n  int n = p.size();\n  vector<int> ret(n);\n  REP(i,n) ret[i] = p[q[i]];\n  return ret;\n}\n\nvector<int> inverse(const vector<int> &p){\n  int n = p.size();\n  vector<int> ret(n);\n  REP(i,n) ret[p[i]] = i;\n  return ret;\n}\n\ntemplate <typename T> T power(T n, LLI p, const T &e, const function<T(T,T)> &f){\n  T ret = e;\n  while(p>0){\n    if(p&1) ret = f(ret, n);\n    n = f(n, n);\n    p /= 2;\n  }\n  return ret;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,K;\n  while(cin >> N >> K){\n    vector<int> p(N), q(N); cin >> p >> q;\n    for(auto &x : p) --x;\n    for(auto &x : q) --x;\n    \n    auto ip = inverse(p);\n    auto iq = inverse(q);\n    auto x = compose(q, compose(ip, compose(iq, p)));;\n    auto id = vector<int>(N);\n    REP(i,N) id[i] = i;\n    \n    vector<int> as[6] = {id, id, id, q, compose(q,ip), compose(q,ip)};\n    vector<int> a = compose(power<vector<int>>(x, (K-1)/6, id, compose), as[(K+5)%6]);\n    \n    vector<int> bs[6] = {p,q,compose(q,ip),ip,iq,compose(iq,p)};\n    auto b = bs[(K+5)%6];\n    \n    auto ans = compose(a, compose(b, inverse(a)));\n\n    for(auto &x : ans) ++x;\n    join(cout, ALL(ans));\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nll nums[2000][100010];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, K;\n    cin >> N >> K;\n    ll p[N], q[N];\n    ll base[N], next[N];\n    REP(i, 0, N) {\n        cin >> p[i];\n        base[i] = p[i];\n    }\n    REP(i, 0, N) {\n        cin >> q[i];\n        next[i] = q[i];\n    }\n    ll ind = 0;\n    while(1) {\n        ind++;\n        ll tmp[N];\n        REP(i, 0, N) {\n            tmp[base[i] - 1] = next[i];\n        }\n        REP(i, 0, N) {\n            base[i] = next[i];\n            next[i] = tmp[i];\n        }\n        bool ok = true;\n        REP(i, 0, N) {\n            if (p[i] != base[i] || q[i] != next[i]) {\n                ok = false;\n            }\n        }\n        if (ok) {\n            break;\n        }\n    }\n    //ll nums[ind][N];\n    REP(i, 0, N) {\n        nums[0][i] = p[i];\n        nums[1][i] = q[i];\n    }\n    REP(i, 2, ind + 2) {\n        REP(j, 0, N) {\n            nums[i][nums[i - 2][j] - 1] = nums[i - 1][j];\n        }\n    }\n    // cout << ind << endl;\n    // REP(i, 0, ind + 2) {\n    //     REP(j, 0, N) {\n    //         cout << nums[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    ll rem = (K - 1) % ind;\n    REP(i, 0, N) {\n        cout << nums[rem][i];\n        if (i != N - 1) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <complex>\n#define pb push_back\n#define pll pair <ll, ll>\n#define MOMI using namespace std;\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#pragma optimize(\"TKACHENKO-GORYACHENKO\")\n#pragma GCC optimize(\"O3\")\n\n//#pragma GCC optimize(\"unroll-loops\")\n//#define double long double\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e5;\n\nll n, m, k;\n\nvector <ll> ID;\n\nvoid vivod(vector <ll> V){\n    ll q;\n    for (q = 0; q < V.size(); q++){\n        cout << V[q] << \" \";\n    }\n    cout << endl << endl;\n}\n\nvector <ll> mul(vector <ll> A, vector <ll> B){\n    vector <ll> ANS;\n    ANS.resize(A.size());\n    ll q;\n    for (q = 0; q < A.size(); q++){\n        ANS[q] = A[B[q]];\n    }\n    return ANS;\n}\n\nvector <ll> rev(vector <ll> A){\n    vector <ll> ANS;\n    ANS.resize(A.size());\n    ll q;\n    for (q = 0; q < A.size(); q++){\n        ANS[A[q]] = q;\n    }\n    return ANS;\n}\n\nvector <ll> step(vector <ll> A, ll x){\n    if (x == 0){\n        return ID;\n    }\n    if (x % 2 == 1){\n        return mul(step(A, x - 1), A);\n    }\n    vector <ll> T = step(A, x / 2);\n    return mul(T, T);\n}\n\nint main(){\n    ll q, w, e, t, a, b, c;\n    cin >> n >> k;\n    vector <ll> P, Q;\n    ID.resize(n);\n    for (q = 0; q < n; q++){\n        ID[q] = q;\n    }\n    P.resize(n); Q.resize(n);\n    for (q = 0; q < n; q++){\n        cin >> P[q];\n        P[q]--;\n    }\n    for (q = 0; q < n; q++){\n        cin >> Q[q];\n        Q[q]--;\n    }\n    k--;\n//    vivod(P);vivod(Q);\n    vector <ll> W = mul(mul(Q, rev(P)), mul(rev(Q), P));\n//    vivod(W);\n//    vector <ll> A = mul(mul(P, step(W, (k) / 6)), rev(P)); /// 0, 6, 12, 18, 24\n//    vector <ll> B = mul(mul(Q, step(W, (k) / 6)), rev(Q)); /// 1, 7, 13, 19, 25;\n    vector <ll> A = mul(step(W, (k) / 6), mul(P, rev(step(W, k / 6))));\n    vector <ll> B = mul(step(W, (k) / 6), mul(Q, rev(step(W, k / 6))));\n//    cout << \"A \" << endl; vivod(A);\n//    cout << \"B \" << endl; vivod(B);\n    if (k % 6 == 0){\n        for (q = 0; q < n; q++){\n            cout << A[q] << \" \";\n        }\n        return 0;\n    }\n    ll i = (k / 6) * 6 + 1;\n    for (;i < k; i++){\n        vector <ll> C;\n        C.resize(n);\n        for (q = 0; q < n; q++){\n            C[A[q]] = B[q];\n        }\n//        vivod(C);\n        A = B;\n        B = C;\n    }\n    for (q = 0; q < n; q++){\n        cout << B[q] + 1 << \" \";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nnamespace ProjectPermy\n{\n\tstruct perm\n\t{\n\t\tvector<int>v;\n\t\tint &operator[](int x){return v[x];}\n\t\tconst int &operator[](int x)const{return v[x];}\n\t\tint size()const{return v.size()-1;}\n\t\tvoid resize(int n){v.resize(n+1);}\n\t\tvoid read(int n){v.resize(n+1);for(int i=1;i<=size();i++)scanf(\"%d\",&v[i]);}\n\t\tvoid out()\n\t\t{\n\t\t\tfor(int i=1;i<=size();i++)\n\t\t\t\tprintf(\"%d \",v[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t};\n\tperm e(int n)\n\t{\n\t\tperm ans;\n\t\tans.resize(n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans[i]=i;\n\t\treturn ans;\n\t}\n\tperm operator*(perm a,perm b)\n\t{\n\t\tperm ans=e(a.size());\n\t\tperm rev=e(a.size());\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t\tans[i]=a[b[i]];\n\t\treturn ans;\n\t}\n\tperm operator~(perm a)\n\t{\n\t\tperm ans=e(a.size());\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t\tans[a[i]]=i;\n\t\treturn ans;\n\t}\n\tint vis[1000001];\n\tvoid find_cycle(perm a,int x,vector<int>&rem)\n\t{\n\t\tif(vis[x]) return;\n\t\tvis[x]=1;\n\t\trem.push_back(x);\n\t\tfind_cycle(a,a[x],rem);\n\t}\n\tperm Pow(perm a,int x)\n\t{\n\t\tperm ans=e(a.size());\n\t\tvector<vector<int> >cycle;\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t{\n\t\t\tif(!vis[i])\n\t\t\t{\n\t\t\t\tvector<int> rem;\n\t\t\t\tfind_cycle(a,i,rem);\n\t\t\t\tcycle.push_back(rem);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<cycle.size();i++)\n\t\t{\n\t\t\tfor(int j=0;j<cycle[i].size();j++)\n\t\t\t\tans[cycle[i][j]]=cycle[i][(j+x)%cycle[i].size()];\n\t\t}\n\t\treturn ans;\n\t}\n}\nusing namespace ProjectPermy;\nsigned main()\n{\n//\tfreopen(\"data_generator.txt\",\"r\",stdin);\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tperm p,q;\n\tp.read(n);\n\tq.read(n);\n\tperm a[7];\n\ta[1]=p;\n\ta[2]=q;\n\tfor(int i=3;i<=6;i++)\n\t\ta[i]=a[i-1]*(~a[i-2]);\n\tif(m<=6)\n\t{\n\t\ta[m].out();\n\t\treturn 0;\n\t}\n\tperm g=q*(~p)*(~q)*p;\n\t(Pow(g,(m-1)/6)*a[(m-1)%6+1]*Pow(~g,(m-1)/6)).out();\n\treturn 0;\n}\n/*\n10 156046\n2 4 3 1 5 8 9 10 7 6\n5 6 1 4 3 2 8 9 10 7\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> per;\n\nint n, k;\nper a[7], A, p, q; // A = qp^{-1}q^{-1}\n\nper mul(per a, per b) {\n\tper c;\n\tc.resize(n);\n\tfor (int i = 0; i < n; ++i) c[i] = a[b[i]];\n\treturn c;\n}\n\nper inv(per a) {\n\tper b;\n\tb.resize(n);\n\tfor (int i = 0; i < n; ++i) b[a[i]] = i;\n\treturn b;\n}\n\nint cir[100005];\nbool is[100005];\n\nper power(per a, int t) { // return a^t\n\tper b;\n\tb.resize(n);\n\tfor (int i = 0; i < n; ++i) is[i] = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (!is[i]) {\n\t\t\tif (a[i] == i) {\n\t\t\t\tb[i] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint p = i, l = 0;\n\t\t\tdo {\n\t\t\t\tcir[l++] = p;\n\t\t\t\tis[p] = 1;\n\t\t\t\tp = a[p];\n\t\t\t} while (p != i);\n\t\t\tfor (int j = 0; j < l; ++j)\n\t\t\t\tb[cir[j]] = cir[(j + t) % l];\n\t\t}\n\treturn b;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tp.resize(n);\n\tq.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &p[i]);\n\t\t--p[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &q[i]);\n\t\t--q[i];\n\t}\n\ta[1] = p;\n\ta[2] = q;\n\tif (k <= 6) {\n\t\tfor (int i = 3; i <= k; ++i) a[i] = mul(a[i - 1], inv(a[i - 2]));\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tprintf(\"%d \", a[k][i] + 1);\n\t\treturn 0;\n\t}\n\tfor (int i = 3; i <= 6; ++i) a[i] = mul(a[i - 1], inv(a[i - 2]));\n\tA.resize(n);\n\tfor (int i = 0; i < n; ++i) A[i] = i;\n\tA = mul(A, q);\n\tA = mul(A, inv(p));\n\tA = mul(A, inv(q));\n\tA = mul(A, p);\n\tA = power(A, (k - 1) / 6);\n\tper ans = mul(mul(A, a[(k - 1) % 6 + 1]), inv(A));\n\tfor (int i = 0; i < n; ++i) {\n\t\tprintf(\"%d \", ans[i] + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Maxn 100007\nint n,k;\nint p[Maxn],q[Maxn];\nint a[Maxn],b[Maxn],tmp1[Maxn],tmp2[Maxn];\nint ans[Maxn],r[Maxn];\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&p[i]);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&q[i]);\n    if (k%6==1)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=p[i];\n    } else if (k%6==2)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=q[i];\n    } else if (k%6==3)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=q[i];\n    } else if (k%6==4)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=i;\n    } else if (k%6==5)\n    {\n        for (int i=1;i<=n;i++)\n            b[q[i]]=i;\n    } else\n    {\n        for (int i=1;i<=n;i++)\n            tmp2[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            b[i]=tmp2[p[i]];\n    }\n    for (int i=1;i<=n;i++)\n        ans[i]=i;\n    if (k>1)\n    {\n        --k;\n        int c=k/6;\n        k%=6;\n        for (int i=1;i<=n;i++)\n            tmp1[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            r[i]=p[tmp1[i]];\n        for (int i=1;i<=n;i++)\n            tmp1[i]=r[i];\n        for (int i=1;i<=n;i++)\n            r[i]=q[tmp1[i]];\n        for (int i=1;i<=n;i++)\n            tmp1[p[i]]=i;\n        for (int i=1;i<=n;i++)\n            tmp2[i]=r[i];\n        for (int i=1;i<=n;i++)\n            r[i]=tmp1[tmp2[i]];\n        while (c>0)\n        {\n            if (c%2==1)\n            {\n                for (int i=1;i<=n;i++)\n                    tmp2[i]=ans[i];\n                for (int i=1;i<=n;i++)\n                    ans[i]=r[tmp2[i]];\n            }\n            c/=2;\n            for (int i=1;i<=n;i++)\n                tmp1[i]=r[i];\n            for (int i=1;i<=n;i++)\n                r[i]=tmp1[tmp1[i]];\n        }\n        if (k%6==3)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                tmp2[i]=ans[i];\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[tmp2[i]];\n        } else if (k%6==4||k%6==5)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                tmp2[i]=ans[i];\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[tmp2[i]];\n            for (int i=1;i<=n;i++)\n                tmp2[i]=ans[i];\n            for (int i=1;i<=n;i++)\n                ans[i]=p[tmp2[i]];\n        } else if (k%6==0)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                tmp2[i]=ans[i];\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[tmp2[i]];\n            for (int i=1;i<=n;i++)\n                tmp2[i]=ans[i];\n            for (int i=1;i<=n;i++)\n                ans[i]=q[p[tmp2[i]]];\n        }\n    }\n    for (int i=1;i<=n;i++)\n        a[ans[i]]=i;\n    for (int i=1;i<=n;i++)\n        tmp2[i]=ans[i];\n    for (int i=1;i<=n;i++)\n        ans[i]=b[tmp2[i]];\n    for (int i=1;i<=n;i++)\n        tmp2[i]=ans[i];\n    for (int i=1;i<=n;i++)\n        ans[i]=a[tmp2[i]];\n    for (int i=1;i<=n;i++)\n        printf(\"%d \",ans[i]);\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n//#define cerr if(false) cerr\n#define show(...) cerr << #__VA_ARGS__ << \" = \",debug(__VA_ARGS__);\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate<typename T, typename S>\nostream &operator<<(ostream &os,pair<T,S>a){\n    os << '(' << a.first << ',' << a.second << ')';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, vector<T> v){\n    for(auto x:v)os << x << ' ';\n    return os;\n}\nvoid debug(){cerr << '\\n';}\ntemplate<typename H, typename... T>\nvoid debug(H a, T... b){\n    cerr << a;\n    if(sizeof...(b))cerr << \", \";\n    debug(b...);\n}\n\n//char inv(char c){\n//    return c^32;\n//}\n//string inv(string &a){\n//    auto res = a;\n//    for(auto &x:res) x^=32;\n//    reverse(res.begin(),res.end());\n//    return res;\n//}\n//string product(const string &a,const string &b){\n//    auto res = a;\n//    for(auto x:b){\n//        if(res.size() and inv(x) == res.back())res.erase(res.begin()+res.size()-1);\n//        else res.push_back(x);\n//    }\n//    return res;\n//    \n//}\n\nvector<int> id(const int n){\n    vector<int> res(n);\n    rep(i,n)res[i] = i;\n    return res;\n}\nvector<int> inv(const vector<int> &a){\n    vector<int> res(a.size());\n    rep(i,a.size()){\n        res[a[i]] = i;\n    }\n    return res;\n}\nvector<int> product(const vector<int> &a, const vector<int> &b){\n    vector<int> res(a.size());\n    rep(i,a.size()){\n        res[i] = a[b[i]];\n    }\n    return res;\n}\nvector<int> power(const vector<int> &a, ll p){\n    if(p == 0)return id((int)a.size());\n    auto res = a;\n    auto temp = a;\n    p--;\n    for(int i = 0; i < 28; i++){\n        if(p >> i & 1){\n            res = product(res, temp);\n        }\n        temp = product(temp, temp);\n    }\n    return res;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    int k;\n    cin >> k;\n    vector<int>p(n),q(n);\n    rep(i,n)cin >> p[i],p[i]--;\n    rep(i,n)cin >> q[i],q[i]--;\n    auto g = product(q,product(inv(p),product(inv(q),p)));\n    g = power(g,(k-1)/6);\n    auto a = product(g,product(p,inv(g)));\n    auto b = product(g,product(q,inv(g)));\n    int now = 1 + (k-1)/6*6;\n    while(now != k){\n        auto c = product(b, inv(a));\n        a = b;\n        b = c;\n        now++;\n    }\n    rep(i,n)cout << a[i] + 1 << \" \\n\"[i==n-1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int N=100005;\nvi A,B[10],p,q,res;\nint n,K;\n\nvi rev(vi a){\n\tvi b(n+1,0);\n\trep(i,1,n)b[a[i]]=i;\n\treturn b;\n}\n\nvi mul(vi a,vi b){\n\tvi c(n+1,0);\n\trep(i,1,n)c[i]=a[b[i]];\n\treturn c;\n}\n\nvi power(vi a,int p){\n\tvi res(n+1,0);\n\trep(i,1,n)res[i]=i;\n\tfor(;p;p>>=1,a=mul(a,a))\n\t\tif(p&1)res=mul(res,a);\n\treturn res;\n}\n\nint main(){\n\tcin>>n>>K;\n\tp.resize(n+1,0);\n\trep(i,1,n)cin>>p[i];\n\tq.resize(n+1,0);\n\trep(i,1,n)cin>>q[i];\n\tA=power(mul(q,mul(rev(p),mul(rev(q),p))),(K-1)/6);\n\tif(K%6==4)A=mul(A,q);\n\tif(K%6==5||K%6==0)A=mul(A,mul(q,rev(p)));\n\tB[1]=p;\n\tB[2]=q;\n\tB[3]=mul(q,rev(p));\n\tB[4]=rev(p);\n\tB[5]=rev(q);\n\tB[6]=mul(rev(q),p);\n\tres=mul(A,mul(B[(K-1)%6+1],rev(A)));\n\trep(i,1,n)printf(\"%d \",res[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct permutation {\n  vector<int> p;\n  int n;\n  \n  void init(int _n) {\n    n = _n;\n    p.reserve(n + 1);\n    for(int i = 1; i <= n; i++) {\n      p[i] = i;\n    }\n  }\n\n  void read(int _n) {\n    init(_n);\n    for(int i = 1; i <= n; i++) {\n      scanf(\"%d\", &p[i]);\n    }\n  }\n\n  void print(void) {\n    for(int i = 1; i <= n; i++) {\n      printf(\"%d%c\", p[i], i == n ? '\\n' : ' ');\n    }\n  }\n\n  permutation inverse(void) {\n    permutation q;\n    q.init(n);\n    for(int i = 1; i <= n; i++) {\n      q.p[p[i]] = i;\n    }\n    return q;\n  }\n\n  permutation operator * (const permutation &rhs) const {\n    permutation q;\n    q.init(n);\n    for(int i = 1; i <= n; i++) {\n      q.p[i] = p[rhs.p[i]];\n    }\n    return q;\n  }\n}a[6], t;\n\npermutation operator ^ (permutation p, int y) {\n  permutation q;\n  q.init(p.n);\n  for(; y; y >>= 1, p = p * p) {\n    if(y & 1) {\n      q = q * p;\n    }\n  }\n  return q;\n}\n\nint n, m;\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  m--;\n  a[0].read(n); a[1].read(n);\n  for(int i = 2; i < 6; i++) {\n    a[i] = a[i - 1] * a[i - 2].inverse();\n  }\n  t = (a[3] * a[0]) ^ (m / 6);\n  (t * a[m % 6] * t.inverse()).print();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\ntemplate <typename T>\nvoid debug_out(T t) {\n  cerr << t;\n}\n\ntemplate <typename A, typename B>\nvoid debug_out(pair<A, B> u) {\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\n}\n\ntemplate <typename T>\nvoid debug_out(vector<T> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << \", \";\n  }\n}\n\ntemplate <typename T>\nvoid debug_out(vector<vector<T>> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << endl;\n  }\n}\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\" << endl, debug_out(__VA_ARGS__), cerr << endl;\n\n\nint n, k;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  k--;\n  vector<int> p(n);\n  range(i, 0, n) {\n    cin >> p[i];\n    p[i]--;\n  }\n  vector<int> q(n);\n  range(i, 0, n) {\n    cin >> q[i];\n    q[i]--;\n  }\n  auto f = [&] (vector<int> x, vector<int> y) {\n    vector<int> a(n);\n    range(i, 0, n) a[x[i]] = y[i];\n    return a;\n  };\n  vector<vector<int>> a(3);\n  a[0] = p;\n  a[1] = q;\n  a[2] = f(p, q);\n  while(a.back() != a[1] || a[a.size() - 2] != a[0]) a.push_back(f(a[a.size() - 2], a.back()));\n  a.pop_back();\n  a.pop_back();\n  k %= a.size();\n  for(int i : a[k]) cout << i + 1 << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\n\n\nvector<int> p1(100020,0);\n\nvector<int> p2(100020,0);\n\nvector<int> m1(100020,0);\nvector<int> m2(100020,0);\n\nvector<int>Z1,Z2;\nint n;\nvector<int> ff(vector<int>v1,vector<int> v2){\n\tvector<int> ans(n+1,0);\n\t\n\tfor(int i=0;i<=n;i++){\n\t\tans[v1[i]]=v2[i];\n\t}\n\treturn ans;\n}\n\n\nvector<int> BB(vector<int> ve,int kai){\n\tif(kai==1) return ve;\n\tif(kai%2){\n\t\treturn ff(BB(ve,kai-1),ve);\n\t}\n\tvector<int> D=BB(ve,kai/2);\n\treturn ff(D,D);\n}\n\nvector<int> migi(int r, vector<int> ve){\n\t\n\tint t=r/4;\n\tif(t){\n\tvector<int> be=BB(Z2,t);\n\t\t\n\t\tve=ff(be,ve);\n\t}\n\tr%=4;\n\t\n\tif(r>=1) ve=ff(m2,ve);\n\tif(r>=2) ve=ff(p1,ve);\n\tif(r>=3) ve=ff(p2,ve);\n\treturn ve;\n}\n\nvector<int> hidari(int r,vector<int> ve){\n\t\n\tint t=r/4;\n\tint tt=r%4;\n\n\t\n\tif(tt>=3) ve=ff(m2,ve);\n\tif(tt>=2) ve=ff(m1,ve);\n\tif(tt>=1) ve=ff(p2,ve);\n\t\n\tif(t){\n\tvector<int> be=BB(Z1,t);\n\t\t\n\t\tve=ff(be,ve);\n\t}\n\t\n\treturn ve;\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nvector<int> moto;\n \t\n \tint k;\n \tcin>>n>>k;\n \t\n \tfor(int i=0;i<=n;i++)moto.pb(i);\n \t\n \tfor(int i=1;i<=n;i++){\n \t\tcin>>p1[i];\n \t\tm1[p1[i]]=i;\n \t}\n \t\n \tfor(int i=1;i<=n;i++){\n \t\tcin>>p2[i];\n \t\tm2[p2[i]]=i;\n \t}\n \tif(k==1){\n \t\tfor(int i=1;i<=n;i++)cout<<p1[i]<<\" \";\n \t\tcout<<endl;\n \t\treturn 0;\n \t}\n\n \t\n \tif(k==2){\n \t\tfor(int i=1;i<=n;i++)cout<<p2[i]<<\" \";\n \t\tcout<<endl;\n \t\treturn 0;\n \t}\n \t Z1=moto;\n \tZ1=ff(p1,Z1);\n \tZ1=ff(m2,Z1);\n \tZ1=ff(m1,Z1);\n \tZ1=ff(p2,Z1);\n \t\n \t\n \t Z2=moto;\n \tZ2=ff(m2,Z2);\n \tZ2=ff(p1,Z2);\n \tZ2=ff(p2,Z2);\n \tZ2=ff(m1,Z2);\n \t\n \t\n \t\n \tvector<int> ans=moto;\n \t\n \tint k1=(k+1)/3;\n \tk1=k1*2-2;\n \tif(k%3==2)k1--;\n \t\n \tans=migi(k1,ans);\n \t\n \tint k2=k1+3;\n \tif(k%3==0) k2--;\n \tans=hidari(k2,ans);\n \t\n \tfor(int i=1;i<=n;i++)cout<<ans[i]<<\" \";\n \tcout<<endl;\n \treturn 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1e5+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,k;\nstruct Node{\n\tint a[MAXN];\n\tint&operator[](int x){return a[x];}\n\tinline Node Inv(){Node b;Rep(i,1,n)b[a[i]]=i;return b;}\n\tinline friend Node operator*(Node a,Node b){Node c;Rep(i,1,n)c[i]=a[b[i]];return c;}\n\tinline friend Node operator^(Node a,int k){\n\t\tstatic int vis[MAXN],p[MAXN];memset(vis,0,sizeof(vis));Node b;\n\t\tRep(i,1,n)if(!vis[i]){\n\t\t\tint cnt=0;p[cnt=1]=i,vis[i]=1;\n\t\t\tfor(int t=a[i];t!=i;t=a[t])vis[t]=1,p[++cnt]=t;\n\t\t\tRep(j,1,cnt)b[p[j]]=p[(j+k-1)%cnt+1];\n\t\t}return b;\n\t}\n}a[7],A,ans;\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),k=read();\n\tRep(i,1,n)a[1][i]=read();Rep(i,1,n)a[2][i]=read();\n\tRep(i,3,6)a[i]=a[i-1]*(a[i-2].Inv());\n\tA=a[2]*(a[1].Inv())*(a[2].Inv())*a[1];\n\tans=(A^((k-1)/6))*a[(k-1)%6+1]*(A.Inv()^((k-1)/6));\n\tRep(i,1,n)cout<<ans[i]<<\" \";cout<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main () {\n  int N, K;\n  cin >> N >> K;\n  vector<vector<int>>per(6,vector<int>(N + 1));\n  for (int i = 1; i <= N; i ++) {\n    cin >> per[1][i];\n    per[4][per[1][i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    cin >> per[2][i];\n    per[5][per[2][i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    per[3][per[1][i]] = per[2][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    per[0][per[3][i]] = i;\n  }\n  int ans = K % 6;\n  for (int i = 1; i < N; i ++) {\n    cout << per[ans][i] << ' ';\n  }\n  cout << per[ans][N] << endl;\n}\n  \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\ntypedef vector<int> vec;\n//a*b\nvec multi(vec a, vec b) {\n\tint n = a.size();\n\tvec ret(n);\n\trep(i, n) {\n\t\tret[i] = a[b[i] - 1];\n\t}\n\treturn ret;\n}\nvec inv(vec a) {\n\tint n = a.size();\n\tvec ret(n);\n\trep(i, n) {\n\t\tret[a[i] - 1] = i + 1;\n\t}\n\treturn ret;\n}\nint n, k; vec p, q;\nint main() {\n\tcin >> n >> k;\n\tp.resize(n), q.resize(n);\n\trep(i, n)cin >> p[i];\n\trep(i, n)cin >> q[i];\n\tint r = k % 6, d = k / 6;\n\tif (r == 0) {\n\t\tr=6; d--;\n\t}\n\tvec b(n);\n\tif (r == 1) {\n\t\tb = p;\n\t}\n\telse{\n\t\tvec c = p, d = q;\n\t\trep(i, r - 2) {\n\t\t\tvec mem = inv(c); c = d; d = multi(d, mem);\n\t\t}\n\t\tb = d;\n\t}\n\tvec u = multi(multi(q, inv(p)), multi(inv(q), p));\n\tvec v = inv(u);\n\tvec u2[30], v2[30];\n\tu2[0] = u, v2[0] = v;\n\trep1(i, 29) {\n\t\tu2[i] = multi(u2[i - 1], u2[i - 1]);\n\t\tv2[i] = multi(v2[i - 1], v2[i - 1]);\n\t}\n\trep(i, 30) {\n\t\tif (d&(1 << i)) {\n\t\t\tb = multi(multi(u2[i], b), v2[i]);\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << b[i];\n\t}\n\tcout << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\ntypedef vector <int> vi;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nint n, k;\nvi A, a[6];\nvi inv(vi x) {\n\tvi res(n);\n\tfor(int i = 0; i < n; ++ i) res[x[i]] = i;\n\treturn res;\n}\nvi mul(vi p, vi q) {\n\tvi res(n);\n\tfor(int i = 0; i < n; ++ i) res[i] = p[q[i]];\n\treturn res;\n}\nvi ksm(vi x, int y) {\n\tvi res(n);\n\tfor(int i = 0; i < n; ++ i) res[i] = i;\n\tfor( ; y; x = mul(x, x), y >>= 1) {\n\t\tif(y & 1) res = mul(res, x);\n\t}\n\treturn res;\n}\nsigned main() {\n\tn = read(); k = read() - 1;\n\ta[0].resize(n); for(int i = 0; i < n; ++ i) a[0][i] = read() - 1;\n\ta[1].resize(n); for(int i = 0; i < n; ++ i) a[1][i] = read() - 1;\n\tfor(int i = 2; i < 6; ++ i) a[i] = mul(a[i - 1], inv(a[i - 2]));\n\tif(k < 6) {for(int i = 0; i < n; ++ i) printf(\"%d \", a[k][i] + 1); return 0;}\n\tA = ksm(mul(mul(a[1], inv(a[0])), mul(inv(a[1]), a[0])), k / 6);\n\tA = mul(mul(A, a[k % 6]), inv(A));\n\tfor(int i = 0; i < n; ++ i) printf(\"%d \", A[i] + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\nconst int N=1e5+5;\n\ntypedef vector<int> vec;\n\nint n,k,c[N];\nbool vis[N];\nvec a[7],A,p,q;\n\nvec inv(vec a) {\n\tvec b;b.resize(n);\n\tfo(i,0,n-1) b[a[i]]=i;\n\treturn b;\n}\n\nvec mult(vec a,vec b) {\n\tvec c;c.resize(n);\n\tfo(i,0,n-1) c[i]=a[b[i]];\n\treturn c;\n}\n\nvec pwr(vec a,int t) {\n\tvec b;b.resize(n);\n\tfo(i,0,n-1) vis[i]=0;\n\tfo(i,0,n-1)\n\t\tif (!vis[i]) {\n\t\t\tif (a[i]==i) {b[i]=i;continue;}\n\t\t\tint x=i,m=0;\n\t\t\tdo {vis[c[m++]=x]=1;x=a[x];} while (x!=i);\n\t\t\tfo(j,0,m-1) b[c[j]]=c[(j+t)%m];\n\t\t}\n\treturn b;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tp.resize(n);q.resize(n);\n\tfo(i,0,n-1) scanf(\"%d\",&p[i]),p[i]--;\n\tfo(i,0,n-1) scanf(\"%d\",&q[i]),q[i]--;\n\ta[1]=p;a[2]=q;\n\tif (n<=6) {\n\t\tfo(i,3,n) a[i]=mult(a[i-1],inv(a[i-2]));\n\t\tfo(i,0,n-1) printf(\"%d \",a[n][i]+1);\n\t\treturn 0;\n\t}\n\tfo(i,3,6) a[i]=mult(a[i-1],inv(a[i-2]));\n\tA.resize(n);fo(i,0,n-1) A[i]=i;\n\tA=mult(A,q);A=mult(A,inv(p));A=mult(A,inv(q));A=mult(A,p);\n\tA=pwr(A,(k-1)/6);\n\tvec an=a[(k-1)%6+1];\n\tan=mult(A,an);an=mult(an,inv(A));\n\tfo(i,0,n-1) printf(\"%d \",an[i]+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\nconst int N = 100010;\n\nvi operator*(const vi& a, const vi& b)\n{\n\tvi res(a.size());\n\tfor (int i = 1; i < a.size(); ++i) res[i] = a[b[i]];\n\treturn res;\n}\n\nvi inv(const vi& a)\n{\n\tvi res(a.size());\n\tfor (int i = 1; i < a.size(); ++i) res[a[i]] = i;\n\treturn res;\n}\n\nvi qpow(const vi& a, int y)\n{\n\tvi res(a.size());\n\tvector<bool> vis(a.size(), false);\n\tfor (int i = 1; i < a.size(); ++i)\n\t{\n\t\tif (vis[i]) continue;\n\t\tvi cycle(1, i);\n\t\tfor (int u = a[i]; u != i; u = a[u])\n\t\t{\n\t\t\tcycle.push_back(u);\n\t\t\tvis[u] = true;\n\t\t}\n\t\tfor (int j = 0; j < cycle.size(); ++j) res[cycle[j]] = cycle[(j + y) % cycle.size()];\n\t}\n\treturn res;\n}\n\n/*vi qpow(vi x, int y)\n{\n\tvi out(x.size());\n\tfor (int i = 1; i < x.size(); ++i) out[i] = i;\n\twhile (y)\n\t{\n\t\tif (y & 1) out = out * x;\n\t\tx = x * x;\n\t\ty >>= 1;\n\t}\n\treturn out;\n}*/\n\nint n, k;\nvi f[10], g, ans;\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\t\n\tf[1].resize(n + 1);\n\tf[2].resize(n + 1);\n\t\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &f[1][i]);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &f[2][i]);\n\tfor (int i = 3; i <= 5; ++i) f[i] = f[i - 1] * inv(f[i - 2]);\n\tf[0] = inv(f[2]) * f[1];\n\tg = f[1] * inv(f[0]) * inv(f[1]) * f[0];\n\t\n\tans = qpow(g, k / 6) * f[k % 6] * qpow(inv(g), k / 6);\n\t\n\tfor (int i = 1; i <= n; ++i) printf(\"%d%c\", ans[i], \" \\n\"[i == n]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n#define F first\n#define pb push_back\n#define sz(x) ((int)(x).size())\n\ninline int in(){ int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = 1000*100 + 100;\n\nint a[N], b[N], c[N], d[N], e[N], f[N], g[N], h[N], A[N], B[N], C[N], D[N]; \n\nint n;\n\nvoid rev(int* a, int* b) { \n    fill(b, b + n, 0);\n    for(int i = 0; i < n; i++) \n        b[a[i]] = i; \n}\n\nvoid mul(int* a, int* b, int* c) {\n    fill(c, c + n, 0); \n    for(int i = 0; i < n; i++) \n        c[i] = a[b[i]]; \n}\n\n\nvoid pr(int *a) { \n    for(int i = 0; i < n; i++)\n        cout << a[i]+1 << ' ';\n    cout << endl;\n}\nvoid bpow(int* a, int b, int* c) {\n    int* tmp = new int[n]; \n    int* tmp2 = new int[n]; \n    int* corig = c; \n\n    for(int i = 0; i < n; i++) \n        c[i] = i;\n\n    copy(a, a + n, tmp); \n\n    for(; b ; b/= 2) { \n        if( b % 2 == 1 ) { \n            mul( c , tmp , tmp2 ); \n            swap( c , tmp2 ); \n        }\n        mul( tmp , tmp , tmp2 ); \n        swap( tmp , tmp2 ); \n    }\n\n    copy( c , c + n , tmp ); \n    copy( tmp, tmp + n, corig ); \n}\n\n\nint main(){\n    int k;\n    cin >> n >> k; \n\n    for(int i = 0; i < n; i++) {\n        cin >> a[i]; \n        a[i]--;\n    }\n\n    for(int j = 0; j < n; j++) {\n        cin >> b[j];\n        b[j]--; \n    }\n\n    if( k < 6 ) { \n        for(int t = 3; t <= k; t++) { \n            rev(a, d); \n            mul(b, d, c); \n            swap(a, b); \n            swap(b, c); \n        }\n        if( k == 1 ) \n            swap(a, b);\n        for(int i = 0; i < n; i++)\n            cout << 1+b[i] << ' '; \n        cout << endl;\n        return 0;\n    } else { \n        rev(a, c);\n        rev(b, d); \n\n        mul(b, c, e);\n        mul(e, d, f); \n        mul(f, a, A);\n\n        mul(a, d, e);\n        mul(e, c, f);\n        mul(f, b, B); \n\n        int st = k/6;\n\n\n        bpow(A, st, e); \n        bpow(B, st-1, f); \n\n        mul(e, f, g); \n        mul(g, a, h); \n        mul(h, d, C);\n\n        mul(e, b, g);\n        mul(g, f, h);\n        mul(h, a, g);\n        mul(g, d, D);\n\n        for(int x = 0; x < k%6; x++) { \n            rev( C , e ); \n            mul( D , e , f ); \n            swap( C , D );\n            swap( D , f ); \n        }\n\n        for(int i = 0; i < n; i++)\n            cout << C[i]+1 << ' ';\n        cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nint p[2][100001],q[2][100001],n,k;\nint tem[100001],A[100001],ans[100001],con[100001],top,f[7][100001];\nbool vis[100001];\nvoid mul(int *a,int *b,int *c){\n\tfor(int i=1;i<=n;i++)tem[i]=a[b[i]];\n\tfor(int i=1;i<=n;i++)c[i]=tem[i];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[0][i]),p[1][p[0][i]]=i;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&q[0][i]),q[1][q[0][i]]=i;\n\tfor(int i=1;i<=n;i++)A[i]=ans[i]=i;\n\tmul(A,q[0],A);\n\tmul(A,p[1],A);\n\tmul(A,q[1],A);\n\tmul(A,p[0],A);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]){\n\t\t\tcon[(top=0)++]=i;\n\t\t\tint Tem=A[i];\n\t\t\tvis[i]=1;\n\t\t\twhile(Tem!=i){\n\t\t\t\tvis[Tem]=1;\n\t\t\t\tcon[top++]=Tem;\n\t\t\t\tTem=A[Tem];\n\t\t\t}\n\t\t\tfor(int i=0;i<top;i++)\n\t\t\t\ttem[con[i]]=con[(i+((k-1)/6))%top];\n\t\t}\n\tfor(int i=1;i<=n;i++)A[i]=tem[i];\n\tmul(ans,A,ans);\n\tmemcpy(f[1],p[0],sizeof p[0]);\n\tmemcpy(f[2],q[0],sizeof q[0]);\n\tfor(int i=3;i<=(k-1)%6+1;i++){\n\t\tfor(int j=1;j<=n;j++)tem[f[i-2][j]]=j;\n\t\tfor(int j=1;j<=n;j++)f[i-2][j]=tem[j];\n\t\tmul(f[i-1],f[i-2],f[i]);\n\t}\n\tmul(ans,f[(k-1)%6+1],ans);\n\tfor(int i=1;i<=n;i++)tem[A[i]]=i;\n\tfor(int i=1;i<=n;i++)A[i]=tem[i];\n\tmul(ans,A,ans);\n\tfor(int i=1;i<=n;i++)printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\nnamespace PermutationSpace{\n\tconst int PermutationLen=100000;\n\tstruct Permutation{\n\t\tint P[PermutationLen+1];\n\t\tPermutation(){for (int i=0;i<=PermutationLen;i++) P[i]=i;}\n\t\tinline int & operator [] (const int &index){return P[index];}\n\t};\n\tPermutation operator * (Permutation A,Permutation B){\n\t\tPermutation C;\n\t\tfor (int i=1;i<=PermutationLen;i++) C[i]=A[B[i]];\n\t\treturn C;\n\t}\n\n\tPermutation Inv(Permutation C){\n\t\tPermutation D;\n\t\tfor (int i=1;i<=PermutationLen;i++) D[C[i]]=i;\n\t\treturn D;\n\t}\n\tPermutation Pow(Permutation D,int p){\n\t\tbool vis[PermutationLen+1];\n\t\tint stk[PermutationLen],top;\n\t\tPermutation E;\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor (int i=1;i<=PermutationLen;i++){\n\t\t\tif (vis[i]) continue;\n\t\t\ttop=0;\n\t\t\tfor (int now=i;!vis[now];now=D[now])\n\t\t\t\tstk[top++]=now,vis[now]=true;\n\t\t\tfor (int j=0;j<top;j++) E[stk[j]]=stk[(j+p)%top];\n\t\t}\n\t\treturn E;\n\t}\n}\n\nusing namespace PermutationSpace;\n\nPermutation A[6],G;\n\nint n,m;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&A[1][i]);\n\tfor (int j=1;j<=n;j++) scanf(\"%d\",&A[2][j]);\n\tA[0]=A[1]*A[2];\n\tA[3]=A[2]*Inv(A[1]);\n\tA[4]=A[3]*Inv(A[2]);\n\tA[5]=A[4]*Inv(A[3]);\n\tG=A[2]*Inv(A[1])*Inv(A[2])*A[1];\n\tG=Pow(G,m/6)*A[m%6]*Pow(Inv(G),m/6);\n\tfor (int i=1;i<=n;i++) printf(\"%d \",G[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\nint n, a, b;\nint popcnt(int x) {\n\tint r = 0;\n\tfor (int i = 0; i < 17; i++)\n\t\tr += (x >> i) & 1;\n\treturn r;\n}\nbool recv(int x) {\n\tif (x == 1)\n\t\treturn true;\n\treturn recv(x / 2) & (x & 1);\n}\nvector<int> r;\nvoid rec(int d, int f) {\n\tif (f == 0)\n\t\treturn;\n\tint x = d & -d;\n\td ^= x, f ^= x;\n\n\tif (!d) {\n\t\trec(f & -f, f);\n\t\tr.emplace_back(x);\n\t\trec(f & -f, f);\n\t}\n\telse {\n\t\tint cnt = popcnt(d);\n\t\tint y = 0;\n\t\tfor (int i = 0; i < cnt / 2; i++) {\n\t\t\ty |= d & -d;\n\t\t\td ^= d & -d;\n\t\t}\n\t\tint z = d;\n\n\t\trec(y, f);\n\t\tr.emplace_back(x);\n\t\trec(z, f);\n\t}\n}\nint main() {\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\tbool valid = popcnt(a ^ b) & 1;\n\tprintf(valid ? \"YES\\n\" : \"NO\\n\");\n\tif (!valid)\n\t\treturn 0;\n\trec(a ^ b, (1 << n) - 1);\n\n\tprintf(\"%d\", a);\n\tfor (int i = 0; i < r.size(); i++)\n\t\tprintf(\" %d\", a ^= r[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\ntemplate <typename T>\nvoid debug_out(T t) {\n  cerr << t;\n}\n\ntemplate <typename A, typename B>\nvoid debug_out(pair<A, B> u) {\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\n}\n\ntemplate <typename T>\nvoid debug_out(vector<T> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << \", \";\n  }\n}\n\ntemplate <typename T>\nvoid debug_out(vector<vector<T>> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << endl;\n  }\n}\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\" << endl, debug_out(__VA_ARGS__), cerr << endl;\n\n\nint n, k;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  k--;\n  vector<int> p(n);\n  range(i, 0, n) {\n    cin >> p[i];\n    p[i]--;\n  }\n  vector<int> q(n);\n  range(i, 0, n) {\n    cin >> q[i];\n    q[i]--;\n  }\n  auto f = [&] (vector<int> x, vector<int> y) {\n    vector<int> a(n);\n    range(i, 0, n) a[x[i]] = y[i];\n    return a;\n  };\n  vector<vector<int>> a(3);\n  a[0] = p;\n  a[1] = q;\n  a[2] = f(p, q);\n  while(a.back() != a[1] || a[a.size() - 2] != a[0]) {\n    assert(a.size() < 100);\n    a.push_back(f(a[a.size() - 2], a.back()));\n  }\n  a.pop_back();\n  a.pop_back();\n  k %= a.size();\n  for(int i : a[k]) cout << i + 1 << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nstruct pos {\n    vector <int> seq;\n    pos(int n = 0) {\n        seq.resize(n + 1);\n        for (int i = 1; i <= n; i++)\n            seq[i] = i;\n    }\n};\n\npos Inverse(const pos &a)\n{\n    pos res(a.seq.size() - 1);\n    for (int i = 1; i < a.seq.size(); i++)\n        res.seq[a.seq[i]] = i;\n    return res;\n}\n\npos Multiply(const pos &a, const pos &b)\n{\n    pos c(b.seq.size() - 1);\n    for (int i = 1; i < b.seq.size(); i++)\n        c.seq[i] = a.seq[b.seq[i]];\n    return c;\n}\n\nint main()\n{\n    int n, k; scanf(\"%d %d\", &n, &k);\n    pos p(n), q(n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &p.seq[i]);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &q.seq[i]);\n    pos res;\n    if (k == 1) res = p;\n    else if (k == 2) res = q;\n    else if (k == 3) res = Multiply(q, Inverse(p));\n    else {\n        pos beg(n), mid(n);\n        if (k % 3 == 2) {\n            pos A = Multiply(q, Inverse(p));\n            pos B = Multiply(Inverse(q), p);\n            pos C = Multiply(A, B);\n            int tims = (k - 2) / 6;\n            while (tims) {\n                if (tims & 1) beg = Multiply(beg, C);\n                tims >>= 1; C = Multiply(C, C);\n            }\n            if (k % 6 == 5) beg = Multiply(beg, A);\n        } else {\n            pos A = Multiply(Inverse(p), Inverse(q));\n            pos B = Multiply(p, q);\n            pos C = Multiply(A, B);\n            beg = q;\n            int tims = (k - 4) / 6;\n            while (tims) {\n                if (tims & 1) beg = Multiply(beg, C);\n                tims >>= 1; C = Multiply(C, C);\n            }\n            if (k % 6 == 3 || k % 6 == 1) beg = Multiply(beg, A);\n        }\n        if (k % 6 == 0)\n            mid = Multiply(Multiply(Inverse(p), Inverse(q)), Multiply(p, p));\n        else if (k % 6 == 1)\n            mid = p;\n        else if (k % 6 == 2)\n            mid = q;\n        else if (k % 6 == 3)\n            mid = Multiply(Multiply(p, q), Multiply(Inverse(p), Inverse(p)));\n        else if (k % 6 == 4)\n            mid = Inverse(p);\n        else if (k % 6 == 5)\n            mid = Inverse(q);\n        res = Multiply(Multiply(beg, mid), Inverse(beg));\n    }\n    for (int i = 1; i < res.seq.size(); i++)\n        printf(\"%d%c\", res.seq[i], i + 1 < res.seq.size()? ' ': '\\n');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> apply(vector<int> &a, vector<int> &b)\n{\n\tvector<int> r(a.size());\n\n\tfor (int i = 0; i < b.size(); i++) r[i] = a[b[i]];\n\n\treturn move(r);\n}\n\nvector<int> pow(vector<int> &a, int k)\n{\n\tvector<int> r(a.size());\n\n\tif (k == 0){\n\t\tfor (int i = 0; i < a.size(); i++) r[i] = i;\n\t}\n\telse{\n\t\tauto h = pow(a, k / 2);\n\t\tr = apply(h, h);\n\t\tif (k % 2){\n\t\t\tfor (int i = 0; i < r.size(); i++) r[i] = a[r[i]];\n\t\t}\n\t}\n\n\treturn move(r);\n}\n\n\nint main()\n{\n\tint N, K; scanf (\"%d %d\", &N, &K);\n\tvector<int> p(N), q(N), P(N), Q(N);\n\tfor (int i = 0; i < N; i++){\n\t\tscanf (\"%d\", &p[i]); p[i]--;\n\t\tP[p[i]] = i;\n\t}\n\tfor (int i = 0; i < N; i++){\n\t\tscanf (\"%d\", &q[i]); q[i]--;\n\t\tQ[q[i]] = i;\n\t}\n\n\tvector<int> r;\n\tif (K == 1) r = p;\n\telse{\n\t\tint u = (K - 2) / 6;\n\t\tvector<int> X = pow(apply(P, apply(q, apply(p, Q))), u);\n\n\t\tvector<int> C;\n\n\t\tif (K % 6 == 0) C = apply(p, Q);\n\t\tif (K % 6 == 1) C = apply(q, apply(p, Q));\n\t\tif (K % 6 == 2) C = q;\n\t\tif (K % 6 == 3) C = apply(q, P);\n\t\tif (K % 6 == 4) C = apply(q, apply(P, Q));\n\t\tif (K % 6 == 5) C = Q;\n\n\t\tint v = (K + 1) / 6;\n\t\tvector<int> Y = pow(apply(q, apply(P, apply(Q, p))), v);\n\n\t\tr = apply(Y, apply(C, X));\n\t}\n\n\tfor (int i = 0; i < N; i++) printf (\"%d%c\", r[i] + 1, i + 1 < N ? ' ' : '\\n');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nint n,k;\npoly a[7];\npoly inv(poly a){\n\tpoly b(n);\n\tFor(i,0,n-1)b[a[i]]=i;\n\treturn b;\n}\npoly operator *(poly a,poly b){\n\tpoly c(n);\n\tFor(i,0,n-1)c[i]=a[b[i]];\n\treturn c;\n}\npoly ksm(poly a,int b){\n\tpoly ans(n); For(i,0,n-1)ans[i]=i;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a;\n\t\ta=a*a;\n\t}\n\treturn ans;\n}\nint main(){\n\tn=read(),k=read();\n\tFor(i,1,n)a[1].pb(read()-1);\n\tFor(i,1,n)a[2].pb(read()-1);\n\tint t=k%6; if(!t)t=6;\n\tFor(i,3,t)a[i]=a[i-1]*inv(a[i-2]);\n\tpoly A=a[2]*inv(a[1])*inv(a[2])*a[1];\n\ta[t]=ksm(A,(k-t)/6)*a[t]*ksm(inv(A),(k-t)/6);\n\tfor(auto i:a[t])wri(i+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define C(a, b) memcpy((a) + 1, (b) + 1, n << 2)\n#define U(x) using permutation::x\n\nconst int N = 100054;\ntypedef int perm[N], *pperm;\ntypedef std::initializer_list <pperm> il;\n\nint n, K;\n\nnamespace permutation {\n\tperm buf[2], I, U, F;\n\tpperm cur = *buf, nxt = buf[1];\n\tint stamp = 0;\n\n\tvoid init() {std::iota(I + 1, I + (n + 1), 1);}\n\tvoid read(pperm a) {for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);}\n\tvoid print(pperm a) {for (int i = 1; i <= n; ++i) printf(\"%d%c\", a[i], i == n ? 10 : 32);}\n\tvoid mul(pperm a, pperm b, pperm c) {for (int i = 1; i <= n; ++i) a[i] = b[c[i]];}\n\tvoid inv(pperm a, pperm b) {for (int i = 1; i <= n; ++i) a[b[i]] = i;}\n\tvoid multiply(pperm a, const il &fs) {C(nxt, I); for (pperm g : fs) std::swap(cur, nxt), mul(nxt, cur, g); C(a, nxt);}\n\tvoid pow(pperm a, pperm b, int K) {\n\t\tint i, j, c; ++stamp;\n\t\tfor (i = 1; i <= n; ++i) if (U[i] != stamp) {\n\t\t\tfor (c = 0, j = i; U[j] != stamp; j = b[j], ++c) U[j] = stamp, F[c] = j;\n\t\t\tfor (j = 0; j < c; ++j) a[F[j]] = F[(j + K) % c];\n\t\t}\n\t}\n}\n\nU(init); U(read); U(print); U(mul); U(inv); U(multiply); U(pow);\n\nperm g[3], A, B, BabA, AbaB, L, M, R, ans;\n\nint main() {\n\tperm &a = *g, &b = g[1], &c = g[2];\n\tscanf(\"%d%d\", &n, &K), init();\n\tread(a), read(b), inv(A, a), inv(B, b), mul(c, b, A);\n\tif (--K < 2) return print(g[K]), 0;\n\tmultiply(BabA, {B, a, b, A}), multiply(AbaB, {A, b, a, B});\n\tpow(L, BabA, (K - 2) / 6), pow(R, AbaB, (K - 2) / 6);\n\tswitch ((K - 2) % 6) {\n\t\tcase 0: multiply(M, {}); break;\n\t\tcase 1: multiply(M, {B}); break;\n\t\tcase 2: multiply(M, {B, a, B}); break;\n\t\tcase 3: multiply(M, {B, a, a, B}); break;\n\t\tcase 4: multiply(M, {B, a, b, a, B}); break;\n\t\tcase 5: multiply(M, {B, a, b, A, b, a, B}); break;\n\t}\n\tmultiply(ans, {c, L, M, R}), print(ans);\n\treturn 0;\n}\n/*\na = 4 5 1 2 3\tA = 3 4 5 1 2\nb = 3 2 1 5 4\tB = 3 2 1 5 4\nc = 1 5 4 3 2\tC = 1 5 4 3 2\nd = 4 5 1 2 3\tD = 3 4 5 1 2\ne = 4 3 2 1 5\tE = 4 3 2 1 5\n\n 2 c = b A = b A|\n 3 d = c B = b A|B\n 4 e = d C = b A|B|a B\n 5 f = e D = b A|B a|a B\n 6 g = f E = b A|B a|b|a B\n 7 h = g F = b A|B a b|A|b a B\n 8 i = h G = b A|B a b A|A b a B\n 9 j = i H = b A|B a b A|B|A b a B\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define ll long long\n//#define file\nusing namespace std;\n\nstruct type{\n\tint a[100001];\n} a,b,A,B,c,I;\nint n,m,i,j,k,l;\n\ntype turn(type a,type b)\n{\n\tstatic type c;\n\tint i;\n\tfo(i,1,n) c.a[i]=b.a[a.a[i]];\n\treturn c;\n}\ntype ny(type a)\n{\n\tstatic type c;\n\tint i;\n\tfo(i,1,n) c.a[a.a[i]]=i;\n\treturn c;\n}\ntype qpower(type a,int b)\n{\n\tstatic type ans;\n\tans=I;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=turn(ans,a);\n\t\ta=turn(a,a),b>>=1;\n\t}\n\treturn ans;\n}\ntype js1(int t)\n{\n\ttype ans=qpower(turn(turn(turn(B,a),b),A),t/4);\n\tif (t%4>=1) ans=turn(ans,B);\n\tif (t%4>=2) ans=turn(ans,a);\n\tif (t%4>=3) ans=turn(ans,b);\n\treturn ans;\n}\ntype js2(int t)\n{\n\ttype ans=I;;\n\tif (t%4>=3) ans=turn(ans,B);\n\tif (t%4>=2) ans=turn(ans,A);\n\tif (t%4>=1) ans=turn(ans,b);\n\treturn turn(ans,qpower(turn(turn(turn(a,B),A),b),t/4));\n}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"agc031d.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n) scanf(\"%d\",&a.a[i]),I.a[i]=i;\n\tfo(i,1,n) scanf(\"%d\",&b.a[i]);\n\t\n\tif (m<=6)\n\t{\n\t\tfo(i,1,m-1)\n\t\t{\n\t\t\tA=ny(a);\n\t\t\tc=turn(A,b);\n\t\t\ta=b,b=c;\n\t\t}\n\t\tfo(i,1,n) printf(\"%d \",a.a[i]);\n\t}\n\telse\n\t{\n\t\tA=ny(a),B=ny(b),l=(m-1)/6;\n\t\tswitch (m%6)\n\t\t{\n\t\t\tcase 1:{j=l*4-1;k=l*4;break;}\n\t\t\tcase 2:{j=l*4;k=l*4+1;break;}\n\t\t\tcase 3:{j=l*4;k=l*4+2;break;}\n\t\t\tcase 4:{j=l*4+1;k=l*4+2;break;}\n\t\t\tcase 5:{j=l*4+2;k=l*4+3;break;}\n\t\t\tcase 0:{j=l*4+2;k=l*4+4;break;}\n\t\t}\n\t\tc=turn(js1(j),js2(k));\n\t\tfo(i,1,n) printf(\"%d \",c.a[i]);\n\t}\n\tprintf(\"\\n\");\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <tuple>\ntemplate <typename T> constexpr T my_abs(const T &x) { return x < 0 ? -x : x; }\nusing ll = long long;\nstruct permutation : std::vector<int>\n{\n\tpermutation(int n = 0) { resize(n); for (int i = 0; i < n; i++) at(i) = i; }\n\tinline permutation operator *(const permutation &a) const\n\t{\n\t\tpermutation res(size());\n\t\tfor (int i = 0; i < size(); i++)\n\t\t\tres[i] = at(a[i]);\n\t\treturn res;\n\t}\n\tinline permutation inv() const\n\t{\n\t\tpermutation res(size());\n\t\tfor (int i = 0; i < size(); i++)\n\t\t\tres[at(i)] = i;\n\t\treturn res;\n\t}\n};\ninline permutation quick_pow(permutation a, int n)\n{\n\tpermutation res(a.size());\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a;\n\t\ta = a * a;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\ninline void output(permutation a)\n{\n\tfor (int i = 0; i < a.size(); i++)\n\t\tprintf(\"%d%c\", a[i] + 1, \" \\n\"[i + 1 == a.size()]);\n}\nint main()\n{\n\t// freopen(\"AGC031-D.in\", \"r\", stdin);\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tpermutation a(n), b(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &b[i]);\n\t\tb[i]--;\n\t}\n\tif (k == 1)\n\t{\n\t\toutput(a);\n\t\treturn 0;\n\t}\n\tif (k == 2)\n\t{\n\t\toutput(b);\n\t\treturn 0;\n\t}\n\tk -= 3;\n\tpermutation ra = a.inv(), rb = b.inv();\n\tpermutation pl = quick_pow(rb * a * b * ra, k / 7);\n\tpermutation pr = quick_pow(ra * b * a * rb, k / 7);\n\tk %= 7;\n\tstd::vector<permutation> vec = {rb, a, b, ra};\n\tstd::vector<int> len = {0, 1, 3, 4, 5, 7, 8};\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (i * 2 < len[k])\n\t\t\tpl = pl * vec[i];\n\t\tif (i * 2 + 1 < len[k])\n\t\t\tpr = vec[i] * pr;\n\t}\n\toutput(b * ra * pl * pr);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define mp make_pair\n\nvoid print(auto &a)\n{\n    for (auto s: a) cout<<s<<' ';\n    cout<<endl;\n}\n\nvoid get(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cin>>a[i];\n}\n\nconst int p =  1e9 + 7;\n\n\nint mul(int a, int b) {\n    return (1LL * a%p * b%p) % p;\n}\n\nint add(int a, int b) {\n    ll s = (a+b);\n    s = s%p;\n    if (s<0) s+=p; \n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}\n\n\n\nvector<int> Z(string s)\n{\nint n = s.length();\nvector<int> z(n);\nint L = 0, R = 0;\nfor (int i = 1; i < n; i++) {\n  if (i > R) {\n    L = R = i;\n    while (R < n && s[R-L] == s[R]) R++;\n    z[i] = R-L; R--;\n  } else {\n    int k = i-L;\n    if (z[k] < R-i+1) z[i] = z[k];\n    else {\n      L = i;\n      while (R < n && s[R-L] == s[R]) R++;\n      z[i] = R-L; R--;\n    }\n  }\n}\nreturn z;\n}\n\nvector<int> opvec(vector<int> a, vector<int> b)\n{\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i<n; i++) res[a[i]] = b[i];\n    return res;\n}\n\nvector<int> invvec(vector<int> a)\n{\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i<n; i++) res[a[i]] = i;\n    return res;\n}\n\nvector<int> mulvec(vector<int> a, vector<int> b)\n{\n    a = invvec(a);\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i<n; i++) res[a[i]] = b[i];\n    return res;\n}\n\nvector<int> id(int n)\n{\n    vector<int> res(n);\n    for (int i = 0; i<n; i++) res[i] = i;\n    return res;\n}\n\nvector<int> power(vector<int> a, int deg)\n{\n    if (deg==0) return id(a.size());\n    if (deg%2==1) return mulvec(power(a, deg-1), a);\n    auto kek = power(a, deg/2);\n    return mulvec(kek, kek);\n}\n\n\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    int n, k;\n    cin>>n>>k;\n    vector<int> a(n), b(n);\n    get(a);\n    get(b);\n    if (k==1) {print(a); return 0;}\n    for (int i = 0; i<n; i++) {a[i]--; b[i]--;}\n    vector<int> keks(n);\n    \n    int m = 0;\n    if (k>21) m = (k-20)/6;\n    keks = mulvec(opvec(b, a), b);\n    keks = mulvec(keks, invvec(a));\n    keks = power(keks, m);\n    k -= 6*m;\n    vector<vector<int>> operations(k);\n    operations[0] = a;\n    operations[1] = b;\n    for (int i = 2; i<k; i++) operations[i] = opvec(operations[i-2], operations[i-1]);\n    vector<int> answer = mulvec(keks, operations[k-1]);\n    answer = mulvec(answer, invvec(keks));\n    for (int i = 0; i<n; i++) answer[i]++;\n    print(answer);\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define gc getchar\n#define pc putchar\ninline ll read(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void wri(ll x){write(x);pc(' ');}\ninline void writeln(ll x){write(x);pc('\\n');}\ntypedef vector<int> ve;\nve vec[233];\nint n,k;\nve mul(ve a,ve b){\n\tve c(n);\n\trep(i,0,n) c[i]=a[b[i]];\n\treturn c;\n}\nve inv(ve a){\n\tve b(n);\n\trep(i,0,n) b[a[i]] = i;\n\treturn b;\n}\nve qpow(ve a,int b){\n\tve ans(n);rep(i,0,n)ans[i]=i;\n\tfor(;b;b>>=1,a=mul(a,a))\n\t\tif(b&1) ans=mul(ans,a);\n\treturn ans;\n}\nvoid print(ve x){\n\trep(i,0,n) wri(x[i]+1);puts(\"\");\n}\nint main(){\n\tn = read(),k = read();\n\tRep(t,1,2) Rep(i,1,n) vec[t] . push_back(read()-1);\n\tRep(i,3,6) vec[i] = mul(vec[i-1],inv(vec[i-2]));\n\tve A=mul(mul(vec[2],inv(vec[1])),mul(inv(vec[2]),vec[1]));\n\tA  = qpow(A,(k-1)/6);\n\tprint(mul(mul(A,vec[(k-1)%6+1]),inv(A)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\nint N;\nlong long K;\n\nvector<int> idv;\nvector<int> p, q, pi, qi;\nvector<int> pqpq;\n\nvector<vector<int> > beki;\n\nvector<int> inv(const vector<int> &v) {\n    vector<int> res(N);\n    for (int i = 0; i < N; ++i) res[v[i]] = i;\n    return res;\n}\n\n// a b (b が先)\ninline vector<int> operator +(const vector<int> &a, const vector<int> &b) {\n    vector<int> res(N);\n    for (int i = 0; i < N; ++i) res[i] = a[b[i]];\n    return res;\n}\n\ninline vector<int> pl(const vector<int> &a, const vector<int> &b) {\n    vector<int> res(N);\n    for (int i = 0; i < N; ++i) res[i] = a[b[i]];\n    return res;\n}\n\n// r_k\nvector<int> calc(long long k) {\n    if (k == 0) return idv;\n    if (k == 1) return q;\n    --k;\n\n    int num = k / 4;\n    int r = k % 4;\n    vector<int> res = idv;\n    if (r == 0) res = idv;\n    else if (r == 1) res = pi;\n    else if (r == 2) res = pi + qi;\n    else if (r == 3) res = pi + qi + p;\n    \n    auto totyu = idv;\n    for (int i = 0; i < 35; ++i) {\n        if (num & (1LL<<i)) {\n            totyu = totyu + beki[i];\n        }\n    }\n    res = totyu + res;\n    res = q + res;\n    return res;\n}\n\nvector<int> solve(long long k) {\n    if (k == 1) return p;\n    if (k == 2) return q;\n    if (k == 3) return q + pi;\n    long long a, b;\n    long long d = k / 3;\n    if (k % 3 == 0) a = d*2, b = d*2-2;\n    else if (k % 3 == 1) a = d*2+1, b = d*2-2;\n    else a = d*2+2, b = d*2-1;\n\n    /*\n    COUT(\"---------\");\n    COUT(k);\n    COUT(a);\n    COUT(b);\n    COUT(calc(a));\n    COUT(calc(b));\n    */\n    \n    auto res = calc(a) + inv(calc(b));\n    return res;\n}\n\nint main() {\n    while (cin >> N >> K) {\n        idv.resize(N); p.resize(N); q.resize(N);\n        for (int i = 0; i < N; ++i) idv[i] = i;\n        for (int i = 0; i < N; ++i) cin >> p[i], --p[i];\n        for (int i = 0; i < N; ++i) cin >> q[i], --q[i];\n        pi = inv(p);\n        qi = inv(q);\n        pqpq = pi + qi + p + q;\n        beki.assign(35, vector<int>());\n        beki[0] = pqpq;\n        for (int i = 0; i+1 < 35; ++i) {\n            beki[i+1] = pl(beki[i], beki[i]);\n        }\n        auto res = solve(K);\n        for (int i = 1; i < 10; ++i) {\n            //cout << i << \": \" << solve(i) << endl;\n        }\n\n        for (auto v : res) {\n            cout << v + 1 << \" \";\n        }\n        cout << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<random>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\nmt19937 engine;\n\nint N, K;\nint P[100011], Q[100011];\n\nint buf[100011];\nint idx[100011];\nint cur[100011];\nvoid go(int *a, char c) {\n    if (c == 'p') {\n\tREP (i, N) buf[i] = a[P[i]];\n    } else if (c == 'q') {\n\tREP (i, N) buf[i] = a[Q[i]];\n    } else if (c == 'P') {\n\tREP (i, N) buf[P[i]] = a[i];\n    } else {\n\tREP (i, N) buf[Q[i]] = a[i];\n    }\n    REP (i, N) a[i] = buf[i];\n}\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &K);\n    REP (i, N) scanf(\"%d\", P+i), P[i]--;\n    REP (i, N) scanf(\"%d\", Q+i), Q[i]--;\n\n    if (K == 1) {\n\tREP (i, N) idx[i] = P[i];\n    } else if (K == 2) {\n\tREP (i, N) idx[i] = Q[i];\n    } else {\n\tint len = K - 3 + (K-2) / 3;\n\tint m = len % 8;\n\tint r = len / 8;\n\tREP (i, N) idx[i] = i;\n\tgo(idx, 'q');\n\tgo(idx, 'P');\n\n\tREP (i, N) cur[i] = i;\n\tgo(cur, 'Q');\n\tgo(cur, 'p');\n\tgo(cur, 'q');\n\tgo(cur, 'P');\n\n\tfor (int k=r; k; k>>=1) {\n\t    if (k & 1) {\n\t\tREP (i, N) buf[i] = idx[cur[i]];\n\t\tREP (i, N) idx[i] = buf[i];\n\t    }\n\t    REP (i, N) buf[i] = cur[cur[i]];\n\t    REP (i, N) cur[i] = buf[i];\n\t}\n\n\tstring z;\n\t// PqpQPqpQ\n\tREP (i, m/2) {\n\t    z.push_back(\"QpqP\"[i]);\n\t    go(idx, \"QpqP\"[i]);\n\t}\n\tif (m % 2) {\n\t    go(idx, \"QpqP\"[m/2]);\n\t}\n\treverse(z.begin(), z.end());\n\tREP (i, m/2) {\n\t    go(idx, z[i]);\n\t}\n\t\n\tgo(cur, 'P');\n\tgo(cur, 'q');\n\tgo(cur, 'p');\n\tgo(cur, 'Q');\n\n\tfor (int k=r; k; k>>=1) {\n\t    if (k & 1) {\n\t\tREP (i, N) buf[i] = idx[cur[i]];\n\t\tREP (i, N) idx[i] = buf[i];\n\t    }\n\t    REP (i, N) buf[i] = cur[cur[i]];\n\t    REP (i, N) cur[i] = buf[i];\n\t}\n    }\n\n    REP (i, N) idx[i]++;\n    rprintf(\"%d\", idx, idx+N);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<iostream>\nusing namespace std;\n\ninline int read()\n{\n    int x=0; bool f=1; char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=0;\n    for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^'0');\n    if(f) return x;\n    return -x;\n}\n\nconst int N = 1e5;\nconst int lgM = 30;\nint p[N+3],q[N+3],pp[N+3],qq[N+3];\nint g[N+3],f[N+3],ff[N+3];\nint tmp[N+3];\nint aux[N+3];\nint ans[N+3];\nint a[7][N+3];\nint n,m;\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1; i<=n; i++) scanf(\"%d\",&p[i]),pp[p[i]] = i;\n    for(int i=1; i<=n; i++) scanf(\"%d\",&q[i]),qq[q[i]] = i;\n    for(int i=1; i<=n; i++) a[1][i] = p[i],a[2][i] = q[i];\n    for(int k=3; k<=6; k++)\n    {\n        for(int i=1; i<=n; i++) a[k][a[k-2][i]] = a[k-1][i];\n    }\n    for(int i=1; i<=n; i++) g[i] = q[pp[qq[p[i]]]],f[i] = i,tmp[i] = g[i];\n    int nn = m%6==0?6:m%6; m = (m-1)/6;\n    for(int i=0; m; i++)\n    {\n        if(m&(1<<i))\n        {\n            m-=(1<<i);\n            for(int j=1; j<=n; j++) aux[j] = f[tmp[j]];\n            for(int j=1; j<=n; j++) f[j] = aux[j];\n        }\n        for(int j=1; j<=n; j++) aux[j] = tmp[tmp[j]];\n        for(int j=1; j<=n; j++) tmp[j] = aux[j];\n    }\n    for(int i=1; i<=n; i++) ff[f[i]] = i;\n    for(int i=1; i<=n; i++) ans[i] = f[a[nn][ff[i]]];\n    for(int i=1; i<=n; i++) printf(\"%d \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint q[N],p[N],ans[N],invq[N],invp[N],ansinv[N],s[N],b[N];\nint n,k;\nvoid la(int *a,int *b)\n{\n\tfor (int i=1;i<=n;i++) a[i]=b[a[i]];\n}\nvoid mul(int *a)\n{\n\tfor (int i=1;i<=n;i++) b[i]=a[i];\n\tfor (int i=1;i<=n;i++) a[i]=b[a[i]];\n}\nvoid ksm(int y)\n{\n\tif (y==0) return;\n\tfor (int i=1;i<=n;i++) s[i]=i;\n\tla(s,invq); la(s,p); la(s,q); la(s,invp);\n\tfor (;y;y>>=1,mul(s)) if (y&1) la(ans,s);\t\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&q[i]);\n\tfor (int i=1;i<=n;i++) invp[p[i]]=i;\n\tfor (int i=1;i<=n;i++) invq[q[i]]=i;\n    for (int i=1;i<=n;i++) ans[i]=i;\t\n    ksm((k-1)/6);\n    if (k%6==4) la(ans,invq);\n    else if (k%6==5||k%6==0) la(ans,invq),la(ans,p);\n    for (int i=1;i<=n;i++) ansinv[ans[i]]=i;\n    if (k%6==1) la(ans,p);\n    else if (k%6==2) la(ans,q);\n    else if (k%6==3) la(ans,invp),la(ans,q);\n    else if (k%6==4) la(ans,invp);\n    else if (k%6==5) la(ans,invq);\n    else la(ans,p),la(ans,invq);\n    la(ans,ansinv);\n\tfor (int i=1;i<=n;i++) printf(\"%d \",ans[i]);\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iosteam>\n#include<vector>\nusing namespace std;\nint main () {\n  int N, K;\n  cin >> N >> K;\n  vector<vector<int>>per(6,vector<int>(N + 1));\n  for (int i = 1; i <= N; i ++) {\n    cin >> per[1][i];\n    per[4][per[1][i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    cin >> per[2][i];\n    per[5][per[2][i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    per[3][per[1][i]] = per[2][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    per[0][per[3][i]] = i;\n  }\n  int ans = K % 6;\n  for (int i = 1; i < N; i ++) {\n    cout << per[ans][i] << ' ';\n  }\n  cout << per[ans][N] << endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nvoid print(vector<int> a){\n    for (int i=0; i < a.size(); i++) cout << a[i]+1 << \" \";\n    exit(0);\n}\nvector<int> rev(vector<int> &a){\n    int n = a.size();\n    vector<int> res(n);\n    for (int i=0;i<n;i++) res[a[i]] = i;\n    return res;\n}\nvector<int> mult(vector<int> a, vector<int> b){\n    int n = a.size();\n    vector<int> res(n);\n    for (int i=0; i < n; i++) res[i] = b[a[i]];\n    return res;\n}\nvector<int> pw(vector<int> &a, int d){\n    if (d==0){\n        vector<int> K;\n        for (int i=0;i<a.size();i++) K.push_back(i);\n        return K;\n    }\n    if (d==1) return a;\n    if (d % 2 == 0){\n        vector<int> res = pw(a,d/2);\n        return mult(res, res);\n    }\n    return mult(a, pw(a,d-1));\n}\nvector<int> get(vector<vector<int> > kek, int d){\n    int n = kek[0].size();\n    vector<int> cp;\n    for (int i=0;i<n;i++) cp.push_back(i);\n    for (int i=0;i<4;i++) cp = mult(cp, kek[i]);\n    int N = d/4;\n    cp = pw(cp, N);\n    for (int i=0;i<(d%4);i++) cp = mult(cp, kek[i]);\n    return cp;\n}\nmain() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n), b(n);\n    for (int i=0; i < n; i++) cin >> a[i];\n    for (int i=0; i < n; i++) a[i]--;\n    for (int i=0; i < n; i++) cin >> b[i];\n    for (int i=0; i < n; i++) b[i]--;\n    if (k==1) print(a);\n    if (k==2) print(b);\n    int deg = ((k-3)/3) * 4 + 2;\n    if (k%3 == 1) deg++;\n    if (k%3==2) deg += 3;\n    vector<int> reva = rev(a), revb = rev(b);\n    vector<vector<int> > revlist = {revb, a, b, reva};\n    int need = (deg-1)/2;\n    vector<int> relax = get(revlist, need);\n    vector<int> R = rev(relax);\n    if (deg % 2 != 0){\n        if (deg % 8 == 7) relax = mult(relax, mult(a, R));\n        if (deg % 8 == 1) relax = mult(relax, mult(b, R));\n        if (deg % 8 == 3) relax = mult(relax, mult(reva, R));\n        if (deg % 8 == 5) relax = mult(relax, mult(revb, R));\n    }\n    else{\n        if (deg % 8 == 2) relax = mult(relax, mult(reva, mult(b, R)));\n        if (deg % 8 == 6) relax = mult(relax, mult(a, mult(revb, R)));\n    }\n    print(relax);\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool vis[100005];\nint now[100005];\n\nstruct Per {\n  int *num,n;\n  Per() {}\n  Per(int a):n(a) {num=new int[n+1];}\n  Per inv() {\n  \tPer b(n);\n  \tfor(int i=1;i<=n;i++) b.num[num[i]]=i;\n  \treturn b;\n  }\n  Per operator * (Per b) {\n  \tPer c(n);\n  \tfor(int i=1;i<=n;i++) c.num[i]=num[b.num[i]];\n  \treturn c;\n  }\n  Per operator ^ (int k) {\n  \tPer b(n);\n  \tfor(int i=1;i<=n;i++) vis[i]=0;\n  \tfor(int i=1;i<=n;i++)\n  \t  if (!vis[i]) {\n  \t  \t  int x=i,cnt=0;\n  \t  \t  do {\n  \t  \t  \tnow[++cnt]=x;\n  \t  \t  \tvis[x]=1;\n  \t  \t  \tx=num[x];\n\t\t  } while (x!=i);\n\t\t  for(int j=1;j<=cnt;j++) b.num[now[j]]=now[(j+k-1)%cnt+1];\n\t\t}\n\treturn b;\n  }\n};\n\nPer fir[7];\n\nint main() {\n  int n,k;\n  scanf(\"%d%d\",&n,&k);\n  fir[1]=Per(n);\n  fir[2]=Per(n);\n  for(int i=1;i<=n;i++) scanf(\"%d\",&fir[1].num[i]);\n  for(int i=1;i<=n;i++) scanf(\"%d\",&fir[2].num[i]);\n  for(int i=3;i<=6;i++) fir[i]=fir[i-1]*fir[i-2].inv();\n  Per a=fir[2]*fir[1].inv()*fir[2].inv()*fir[1];\n  Per ans=(a^((k-1)/6))*fir[(k-1)%6+1]*(a.inv()^((k-1)/6));\n  for(int i=1;i<=n;i++) printf(\"%d \",ans.num[i]);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> operator * (const vector<int> &a, const vector<int> &b){\n\tvector<int> c(a.size());\n\tfor(int i = 0; i < a.size(); i++) c[i] = b[a[i]];\n\treturn c;\n}\nvector<int> inv(const vector<int> &a){\n\tvector<int> b(a.size());\n\tfor(int i = 0; i < a.size(); i++) b[a[i]] = i;\n\treturn b;\n}\n\nchar neg(char x){\n\tif(x == 'A') x = 'a';\n\telse if(x == 'a') x = 'A';\n\telse if(x == 'B') x = 'b';\n\telse if(x == 'b') x = 'B';\n\telse assert(false);\n\treturn x;\t\n}\n\nstring inverse(string s){\n\treverse(s.begin(), s.end());\n\tfor (char& x : s){\n\t\tx = neg(x);\n\t}\n\treturn s;\n}\n\nstring process(string s){\n\tstring z;\n\tfor(char x : s){\n\t\tif(!z.empty() && z.back() == neg(x)){\n\t\t\tz.pop_back();\n\t\t} else {\n\t\t\tz += x;\n\t\t}\n\t}\n\treturn z;\n}\n\nvoid test(){\n\tstring x = \"A\";\n\tstring y = \"B\";\n\tfor(int j = 3; j < 100; j++){\n\t\tstring z = process(inverse(x) + y);\n\t\tcout << j << \" \" << z << endl;\n\t\tx = y; y = z;\n\t}\n\texit(0);\n}\n\nvector<int> bf(vector<int> p, vector<int> q, int k){\n\tif(k == 1) return p;\n\tfor(int b = 2; b < k; b++){\n\t\tp = inv(p) * q;\n\t\tswap(p, q);\n\t}\n\treturn q;\n}\n\nvector<int> expo(vector<int> p, int n){\n\tif(n == 0) return p * inv(p);\n\tif(n & 1) return p * expo(p, n-1);\n\treturn expo(p*p, n/2);\n}\n\nvector<int> solve(vector<int> p, vector<int> q, int k){\n\tif(k <= 10) return bf(p, q, k);\n\tint c = (k - 4) / 6;\n\tvector<int> lhs = inv(q) * p * q * inv(p);\n\tvector<int> rhs = inv(lhs);\n\treturn expo(lhs, c) * solve(p, q, k - c * 6) * expo(rhs, c);\n}\n\n\nint main(){\n\tcin.sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> p(n), q(n);\n\tfor(int i = 0; i < n; i++) cin >> p[i];\n\tfor(int i = 0; i < n; i++) cin >> q[i];\n\tfor(int i = 0; i < n; i++) p[i]--, q[i]--;\n\tvector<int> ans;\n\tans = solve(p, q, k);\n\t//assert(ans == bf(p, q, k));\n\tfor(int r = 0; r < n; r++){\n\t\tcout << ans[r] + 1 << ' ';\n\t}\n\tcout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint p[MAX_N], q[MAX_N], tmp[MAX_N], block[MAX_N], ad[MAX_N];\nint pinv[MAX_N], qinv[MAX_N];\nint x[MAX_N], y[MAX_N], z[MAX_N];\nint xinv[MAX_N], yinv[MAX_N], zinv[MAX_N];\nint res[MAX_N], resinv[MAX_N];\nint n, K;\n\nvoid unite(int *a, int *b, int *c){\n\trep(i,n){\n\t\tc[i] = a[b[i]];\n\t}\n}\n\nvoid pow(int *a, int cnt, int *b){\n\trep(i,n) b[i] = i;\n\twhile(cnt){\n\t\tif(cnt % 2){\n\t\t\tunite(b, a, tmp);\n\t\t\trep(i,n) b[i] = tmp[i];\n\t\t}\n\t\tunite(a, a, tmp);\n\t\trep(i,n) a[i] = tmp[i];\n\t\tcnt >>= 1;\n\t}\n}\n\nvoid print(int *a){\n\trep(i,n){\n\t\tcout << a[i]+1 << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> K;\n\trep(i,n){\n\t\tcin >> p[i];\n\t\t--p[i];\n\t}\n\trep(i,n){\n\t\tcin >> q[i];\n\t\t--q[i];\n\t}\n\trep(i,n){\n\t\tpinv[p[i]] = i;\n\t\tqinv[q[i]] = i;\n\t}\n\tunite(qinv, p, block);\n\trep(i,n) ad[i] = tmp[i] = block[i];\n\tunite(pinv, tmp, block);\n\trep(i,n) tmp[i] = block[i];\n\tunite(q, tmp, block);\n\trep(i,n){\n\t\tx[i] = q[i], xinv[i] = qinv[i];\n\t}\n\tunite(q, pinv, y), unite(qinv, p, yinv);\n\tunite(y, qinv, z), unite(yinv, q, zinv);\n\tif(K == 1){\n\t\tprint(p);\n\t}else{\n\t\tpow(block, (K-2)/6, res);\n\t\tif((K-2) % 6 >= 3){\n\t\t\tunite(res, y, tmp);\n\t\t\trep(i,n) res[i] = tmp[i];\n\t\t\trep(i,n) resinv[res[i]] = i;\n\t\t\tif((K-2) % 6 == 3){\n\t\t\t\tunite(res, xinv, tmp);\n\t\t\t\trep(i,n) res[i] = tmp[i];\n\t\t\t\tunite(res, resinv, tmp);\n\t\t\t}else if((K-2) % 6 == 4){\n\t\t\t\tunite(res, yinv, tmp);\n\t\t\t\trep(i,n) res[i] = tmp[i];\n\t\t\t\tunite(res, resinv, tmp);\n\t\t\t}else{\n\t\t\t\tunite(res, zinv, tmp);\n\t\t\t\trep(i,n) res[i] = tmp[i];\n\t\t\t\tunite(res, resinv, tmp);\n\t\t\t}\n\t\t}else{\n\t\t\trep(i,n) resinv[res[i]] = i;\n\t\t\tif((K-2) % 6 == 0){\n\t\t\t\tunite(res, x, tmp);\n\t\t\t\trep(i,n) res[i] = tmp[i];\n\t\t\t\tunite(res, resinv, tmp);\n\t\t\t}else if((K-2) % 6 == 1){\n\t\t\t\tunite(res, y, tmp);\n\t\t\t\trep(i,n) res[i] = tmp[i];\n\t\t\t\tunite(res, resinv, tmp);\n\t\t\t}else{\n\t\t\t\tunite(res, z, tmp);\n\t\t\t\trep(i,n) res[i] = tmp[i];\n\t\t\t\tunite(res, resinv, tmp);\n\t\t\t}\n\t\t}\n\t\tprint(tmp);\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+50;\nint n,K;\nint p[N],q[N],py[N],qy[N],a[10][N];\nint A[N],Ay[N];\nvoid Inv(int a[N],int R[N])\n{\n\tint i;\n\tstatic int b[N];\n\tfor(i=1;i<=n;i++) b[a[i]]=i;\n\t//printf(\"S%d %d %d\\n\",a[1],b[2],b[3]);\n\tfor(i=1;i<=n;i++) R[i]=b[i];\n}\nvoid trans(int a[N],int b[N])\n{\n\tint i;\n\tfor(i=1;i<=n;i++) a[i]=b[a[i]];\n}\nvoid gnew(int a[N],int R[N],int cs)\n{\n\tint i,x,top,rcs,now;\n\tstatic int nxt[N],vis[N],val[N],stk[N];\n\tmemset(vis,0,sizeof(vis));\n\tfor(i=1;i<=n;i++) nxt[i]=a[i];\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(vis[i]) continue;\n\t\ttop=0;\n\t\tx=i;\n\t\twhile(vis[x]==0) stk[top++]=x,vis[x]=1,x=nxt[x];\n\t\trcs=cs%top;\n\t\tx=i;now=rcs;\n\t\twhile(1)\n\t\t{\n\t\t\tval[x]=stk[now];\n\t\t\tif(nxt[x]==i) break;\n\t\t\tx=nxt[x];\n\t\t\tnow++;if(now==top) now=0;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++) R[i]=val[i];\n}\nint main()\n{\n\tint i;\n\tscanf(\"%d%d\",&n,&K);K--;\n\tfor(i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tfor(i=1;i<=n;i++) scanf(\"%d\",&q[i]);\n\t\n\tInv(p,py);Inv(q,qy);\n\tmemcpy(a[0],p,sizeof(p));\n\tmemcpy(a[1],q,sizeof(q));\n\tfor(i=2;i<6;i++)\n\t{\n\t\tmemcpy(a[i],a[i-2],sizeof(a[i-2]));\n\t\tInv(a[i],a[i]);\n\t\ttrans(a[i],a[i-1]);\n\t}\n\tfor(i=1;i<=n;i++) A[i]=i;\n\ttrans(A,p);trans(A,qy);trans(A,py);trans(A,q);\n\tInv(A,Ay);\n\tgnew(A,A,K/6);gnew(Ay,Ay,K/6);\n\ttrans(Ay,a[K%6]);\n\ttrans(Ay,A);\n\tfor(i=1;i<=n;i++) printf(\"%d \",Ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,k;\nint p[100005],q[100005],ip[100005],iq[100005],A[100005],iA[100005],T[100005];\nint rtem[100005];\ninline void mul(int *a,int *b,int *c){\n\tfor(int i=1;i<=n;i++)rtem[i]=a[b[i]];\n\tfor(int i=1;i<=n;i++)c[i]=rtem[i];\n}\ninline void inv(int *a,int *b){\n\tfor(int i=1;i<=n;i++)b[a[i]]=i;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&q[i]);\n\tfor(int i=1;i<=n;i++)A[i]=T[i]=i;\n\tinv(p,ip); inv(q,iq);\n\tmul(T,q,T); mul(T,ip,T); mul(T,iq,T); mul(T,p,T);\n\tfor(int i=1;i<=(k-1)/6;i<<=1,mul(T,T,T))if(((k-1)/6)&i)mul(A,T,A);\n\tinv(A,iA);\n\tmul(A,p,T); mul(T,iA,p);\n\tmul(A,q,T); mul(T,iA,q);\n\tk=(k-1)%6+1;\n\tif(k==1){for(int i=1;i<=n;i++)printf(\"%d \",p[i]); return 0;}\n\tfor(int i=3;i<=k;i++){\n\t\tinv(p,ip);\n\t\tmul(q,ip,T);\n\t\tswap(p,q);\n\t\tswap(q,T);\n\t}\n\tfor(int i=1;i<=n;i++)printf(\"%d \",q[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-19 18:52:05\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=100010;\nint n;\n#define arr std::vector<int>\narr inv(arr a)\n{\n\tarr b(n+1);\n\tfr(i,1,n) b[a[i]]=i;\n\treturn b;\n}\narr operator*(arr a,arr b)\n{\n\tarr c(n+1);\n\tfr(i,1,n) c[i]=a[b[i]];\n\treturn c;\n}\narr &operator*=(arr &a,arr b){ return a=a*b; }\nint k;\narr a,b,c;\narr power(arr a,int b)\n{\n\tarr r(n+1);\n\tfr(i,1,n) r[i]=i;\n\tfor(;b;b>>=1,a*=a) if(b&1) r*=a;\n\treturn r;\n}\nint main()\n{\n\tn=read(); k=read(); a=arr(n+1); b=arr(n+1);\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n) b[i]=read();\n\tc=b*inv(a)*inv(b)*a; k--;\n\twhile(k%6){ arr d=a; a=b; b*=inv(d); k--; }\n\ta=power(c,k/6)*a*power(inv(c),k/6);\n\tfr(i,1,n) printf(\"%d%c\",a[i],i==n?'\\n':' ');\n\treturn 0;\n}\n/*\na\nb\nbA\nbAB\nbABaB\nbABaaB\nbABabaB\nbABabAbaB\n*/"
  },
  {
    "language": "C++",
    "code": "Permutation operator * (Permutation p1,Permutation p2){\n\tPermutation res;\n\tfor(int i=1;i<=n;i++) res[i]=p1[p2[i]];\n\treturn res;\n}\nPermutation fp(Permutation a,int k){\n\tPermutation res;\n\tfor(int i=1;i<=n;i++) res[i]=i;\n\tfor(;k;k>>=1,a=a*a)\n\t\tif(k&1) res=a*res;\n\treturn res;\n}\nint main(){\n\tread(n);read(k);\n\tP.init();\n\tQ.init();\n\tPermutation ans,res,f[10];\n\tres=Q*inv(P)*inv(Q)*P;\n\tf[1]=P;f[2]=Q;\n\tfor(int i=3;i<=6;i++) f[i]=f[i-1]*inv(f[i-2]);\n\tans=fp(res,(k-1)/6)*f[(k-1)%6+1]*fp(inv(res),(k-1)/6);\n\tfor(int i=1;i<=n;i++)\n\t\tcout<<ans[i]<<' ';\n\tcout<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nstruct node\n{\n    int a[100005];\n}p,q,s[7];\nnode inv(node x)\n{\n    node s;\n    for(int i=1;i<=n;i++)\n        s.a[x.a[i]]=i;\n    return s;\n}\nnode mul(node x,node y)\n{\n    node z;\n    for(int i=1;i<=n;i++)\n        z.a[x.a[i]]=y.a[i];\n    return z;\n}\nnode qpow(node x,int y)\n{\n    node ans;\n    for(int i=1;i<=n;i++)\n        ans.a[i]=i;\n    while(y)\n    {\n        if(y&1) ans=mul(ans,x);\n        x=mul(x,x);\n        y>>=1;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&p.a[i]);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&q.a[i]);\n    s[1]=p;s[2]=q;\n    for(int i=3;i<=6;i++)\n        s[i]=mul(s[i-1],inv(s[i-2]));\n    if(k<=6)\n    {\n        for(int i=1;i<=n;i++)\n            printf(i==n?\"%d\\n\":\"%d\",s[k].a[i]);\n        return 0;\n    }\n    node A=mul(mul(mul(q,inv(p)),inv(q)),p);\n    A=qpow(A,k/6);\n    node ans=(mul(A,s[k%6+1]),inv(A));\n    for(int i=1;i<=n;i++)\n        printf(i==n?\"%d\\n\":\"%d \",ans.a[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\n\nconst int N=1e5+1;\nint p[N], q[N], t[N], tmp[N];\nbool vis[N];\nint main() {\n\tint n=rd(), k=rd();\n\tfor(int i=1; i<=n; ++i) p[i]=rd();\n\tfor(int i=1; i<=n; ++i) q[i]=rd();\n\tfor(int i=1; i<=n; ++i) t[p[i]]=q[i];\n\tfor(int i=1; i<=n; ++i) tmp[q[i]]=t[i];\n\tfor(int i=1; i<=n; ++i) t[i]=tmp[p[i]];\n\tfor(int i=1; i<=(k-1)%6; ++i) {\n\t\tfor(int j=1; j<=n; ++j) tmp[p[j]]=q[j];\n\t\tfor(int j=1; j<=n; ++j) p[j]=q[j], q[j]=tmp[j];\n\t}\n\tk=(k-1)/6;\n\tfor(int i=1; i<=n; ++i) if(!vis[i]) {\n\t\tint cnt=0;\n\t\tvis[tmp[cnt++]=i]=true;\n\t\tfor(int j=i; (j=t[j])!=i; ) vis[tmp[cnt++]=j]=true;\n\t\tfor(int j=0; j<cnt; ++j) t[tmp[j]]=tmp[(j+k)%cnt];\n\t}\n\tfor(int i=1; i<=n; ++i) tmp[i]=t[p[i]];\n\tfor(int i=1; i<=n; ++i) p[t[i]]=tmp[i];\n\tfor(int i=1; i<=n; ++i) printf(\"%d%c\", p[i], \" \\n\"[i==n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iterator>\n\nusing namespace std;\n\nint main(){\n\n\tint n, k;\n\tvector<int> p, q, r;\n\n\tcin>> n >> k;\n\tp.resize(n);\n\tq.resize(n);\n\tr.resize(n);\n\n\tfor(int i=0;i<n;i++) cin>> p[i];\n\tfor(int i=0;i<n;i++) cin>> q[i];\n\n\tfor(int i=2;i<k;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tr[p[j]-1]=q[j];\n\t\t}\n\n\t\tfor(int j=0;j<n;j++){\n\t\t\t//cout<< r[j] << q[j] << p[j] << endl;\n\t\t\tp[j]=q[j];\n\t\t\tq[j]=r[j];\n\t\t}\n\n\t\t//cout<< endl;\n\t}\n\n\tfor(int i=0;i<n;i++) cout<< r[i] << \" \";\n\tcout<< endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nint N;\nint P[100000];\nint PT[100000];\nint Q[100000];\nint QT[100000];\nint answer[100000];\nint buffer[100000];\nint buffer2[100000];\nint buffer3[100000];\nint buffer4[100000];\nvoid Rev(int* A,int* B){\n\tfor(int i=0;i<N;i++){\n\t\tA[B[i]] = i;\n\t}\n}\nvoid Mul(int* A,int* B,int* C){\n\tfor(int i=0;i<N;i++){\n\t\tA[i] = B[C[i]];\n\t}\n}\nvoid Pow(int* A,int* B,long K){\n\tvector<int> ans(N);\n\tvector<int> ans2(N);\n\tfor(int i=0;i<N;i++){\n\t\tans[i] = i;\n\t}\n\tvector<int> T(N);\n\tvector<int> T2(N);\n\tfor(int i=0;i<N;i++){\n\t\tT[i] = B[i];\n\t}\n\twhile(K){\n\t\tif(K & 1){\n\t\t\tswap(ans,ans2);\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tans[i] = ans2[T[i]];\n\t\t\t}\n\t\t}\n\t\tswap(T,T2);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tT[i] = T2[T2[i]];\n\t\t}\n\t\tK /= 2;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tA[i] = ans[i];\n\t}\n}\nvoid Calc(){\n\tN = rei();\n\tlong K = rel()-1;\n\tfor(int i=0;i<N;i++){\n\t\tP[i] = rei()-1;\n\t\tPT[P[i]] = i;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tQ[i] = rei()-1;\n\t\tQT[Q[i]] = i;\n\t}\n\tif(K % 6 == 0){\n\t\tMul(buffer,Q,PT);\n\t\tMul(buffer2,buffer,QT);\n\t\tMul(buffer,buffer2,P);\n\t\tPow(buffer,buffer,K/6);\n\t\tRev(buffer4,buffer);\n\t\tMul(buffer2,buffer,P);\n\t\tMul(answer,buffer2,buffer4);\n\t}\n\telse if(K % 6 == 1){\n\t\tMul(buffer,Q,PT);\n\t\tMul(buffer2,buffer,QT);\n\t\tMul(buffer,buffer2,P);\n\t\tPow(buffer,buffer,K/6);\n\t\tRev(buffer4,buffer);\n\t\tMul(buffer2,buffer,Q);\n\t\tMul(answer,buffer2,buffer4);\n\t}\n\telse if(K % 6 == 2){\n\t\tMul(buffer,Q,PT);\n\t\tMul(buffer2,buffer,QT);\n\t\tMul(buffer,buffer2,P);\n\t\tPow(buffer,buffer,K/6);\n\t\tRev(buffer4,buffer);\n\t\tMul(buffer2,buffer,Q);\n\t\tMul(buffer,buffer2,PT);\n\t\tMul(answer,buffer,buffer4);\n\t}\n\telse if(K % 6 == 3){\n\t\tMul(buffer,Q,PT);\n\t\tMul(buffer2,buffer,QT);\n\t\tMul(buffer,buffer2,P);\n\t\tPow(buffer,buffer,K/6);\n\t\tRev(buffer4,buffer);\n\t\tMul(buffer2,buffer,Q);\n\t\tMul(buffer,buffer2,PT);\n\t\tMul(buffer2,buffer,QT);\n\t\tMul(answer,buffer2,buffer4);\n\t}\n\telse if(K % 6 == 4){\n\t\tMul(buffer,Q,PT);\n\t\tMul(buffer2,buffer,QT);\n\t\tMul(buffer,buffer2,P);\n\t\tPow(buffer,buffer,K/6);\n\t\tRev(buffer4,buffer);\n\t\tMul(buffer2,buffer,Q);\n\t\tMul(buffer,buffer2,PT);\n\t\tMul(buffer2,buffer,QT);\n\t\tMul(buffer,buffer2,P);\n\t\tMul(buffer2,buffer,QT);\n\t\tMul(answer,buffer2,buffer4);\n\t}\n\telse{\n\t\tMul(buffer,Q,PT);\n\t\tMul(buffer2,buffer,QT);\n\t\tMul(buffer,buffer2,P);\n\t\tPow(buffer,buffer,K/6);\n\t\tRev(buffer4,buffer);\n\t\tMul(buffer2,buffer,Q);\n\t\tMul(buffer,buffer2,PT);\n\t\tMul(buffer2,buffer,QT);\n\t\tMul(buffer,buffer2,P);\n\t\tMul(buffer2,buffer,P);\n\t\tMul(buffer,buffer2,QT);\n\t\tMul(answer,buffer,buffer4);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tcout << answer[i]+1;\n\t\tif(i == N-1){\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \" \";\n\t\t}\n\t}\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t// no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n} \nusing io :: gi;\nusing io :: putc;\nusing io :: print;\nconst int N=1e5+5;\nint n,p[N],q[N];\nstruct node{\n\tint a[N];\n\tinline node operator *(const node &rhs)const{\n\t\tnode ans;\n\t\tfor(ri i=1;i<=n;++i) ans.a[i]=a[rhs.a[i]];\n\t\treturn ans;\n\t}\n};\ninline node inv(node p){\n\tnode ans;\n\tfor(ri i=1;i<=n;++i)\n\t\tans.a[p.a[i]]=i;\n\treturn ans;\n}\ninline node fpow(node a,ri b){\n\tnode ans;\n\tfor(ri i=1;i<=n;++i) ans.a[i]=i;\n\tfor(;b;b>>=1,a=a*a)\n\t\tif(b&1)\n\t\t\tans=ans*a;\n\treturn ans;\n}\nint main(){\n\tri k,i,f,g;\n\tnode p,q,invp,invq,A,B,invA,ans; \n\tgi(n);gi(k);\n\tfor(i=1;i<=n;++i) gi(p.a[i]);\n\tfor(i=1;i<=n;++i) gi(q.a[i]);\n\tinvp=inv(p);\n\tinvq=inv(q);\n\tf=(k-1)/6;\n\tg=k-f*6;\n\tA=q*invp*invq*p;\n\tif(g==1){\n\t\tB=p;\n\t}\n\telse if(g==2){\n\t\tB=q;\n\t}\n\telse if(g==3){\n\t\tB=q*invp;\n\t}\n\telse if(g==4){\n\t\tB=q*invp*invq;\n\t}\n\telse if(g==5){\n\t\tB=A*invq;\n\t}\n\telse if(g==6){\n\t\tB=A*p*invq;\n\t}\n\tinvA=inv(A);\n\tans=fpow(A,f)*B*fpow(invA,f); \n\tfor(i=1;i<=n;++i) print(ans.a[i]),putc(' ');\n\tputc('\\n');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100005\nusing namespace std;\nint a[maxn],n,b[maxn],K,t;\nint ans[maxn],tmp[maxn];\nint c[maxn][30],d[maxn][30];\nint A[maxn],B[maxn];\n\nint main(){\n    cin >> n >> K;\n    for (int i=1;i<=n;i++) cin >> a[i];\n    for (int i=1;i<=n;i++) A[a[i]]=i;\n    for (int i=1;i<=n;i++) cin >> b[i];\n    for (int i=1;i<=n;i++) B[b[i]]=i;\n    if (K==1){\n        for (int i=1;i<=n;i++) printf(\"%d \",a[i]);puts(\"\");\n        return 0;\n    }\n\n    K-=2; t=K/6;\n    for (int i=1;i<=n;i++) ans[i]=i;\n    for (int i=1;i<=n;i++) c[i][0]=A[b[a[B[i]]]];\n    for (int i=1;i<=n;i++) d[i][0]=b[A[B[a[i]]]];\n    for (int i=1;i<30;i++)\n        for (int j=1;j<=n;j++)\n            c[j][i]=c[c[j][i-1]][i-1],\n            d[j][i]=d[d[j][i-1]][i-1];\n    for (int i=0;i<30;i++) if (t&(1<<i)) {\n        for (int j=1;j<=n;j++) tmp[j]=ans[j];\n        for (int j=1;j<=n;j++) ans[j]=c[tmp[j]][i];\n    }\n    for (int i=1;i<=n;i++) tmp[i]=ans[i];\n    for (int i=1;i<=n;i++){\n        if (K%6==0) ans[i]=b[tmp[i]];\n        if (K%6==1) ans[i]=b[A[tmp[i]]];\n        if (K%6==2) ans[i]=b[A[B[tmp[i]]]];\n        if (K%6==3) ans[i]=b[A[B[a[B[tmp[i]]]]]];\n        if (K%6==4) ans[i]=b[A[B[a[a[B[tmp[i]]]]]]];\n        if (K%6==5) ans[i]=b[A[B[a[b[a[B[tmp[i]]]]]]]];\n    }\n    for (int i=0;i<30;i++) if (t&(1<<i)) {\n        for (int j=1;j<=n;j++) tmp[j]=ans[j];\n        for (int j=1;j<=n;j++) ans[j]=d[tmp[j]][i];\n    }\n    for (int i=1;i<=n;i++) cout << ans[i] << ' '; cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\nstruct node{int n,a[110000];}p,q,A,r,ss;\nnode operator*(node x,node y)\n{\n\tnode z;z.n=x.n;\n\tfor(int i=1;i<=z.n;i++)z.a[i]=y.a[x.a[i]];\n\treturn z;\n}\nnode operator-(node x)\n{\n\tnode y;y.n=x.n;\n\tfor(int i=1;i<=y.n;i++)y.a[x.a[i]]=i;\n\treturn y;\n}\nnode operator^(node x,int k)\n{\n\tnode y;y.n=x.n;\n\tmemset(y.a,-1,sizeof(y.a));\n\tfor(int i=1;i<=y.n;i++)\n\t{\n\t\tif(y.a[i]==-1)\n\t\t{\n\t\t\tint j=x.a[i],ring=1;\n\t\t\twhile(j!=i)j=x.a[j],ring++;\n\t\t\tint t=k%ring;\n\t\t\ty.a[i]=i;\n\t\t\twhile(t--)y.a[i]=x.a[y.a[i]];\n\t\t\twhile(x.a[j]!=i)y.a[x.a[j]]=x.a[y.a[j]],j=x.a[j];\n\t\t}\n\t}\n\treturn y;\n}\nint main()\n{\n\tint n,k;scanf(\"%d%d\",&n,&k);\n\tp.n=q.n=n;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p.a[i]);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&q.a[i]);\n\tA=-q*p*q*-p;\n\tA=A^k/6;\n\tif(k%6==0)r=p*-q;\n\telse if(k%6==1)r=p;\n\telse if(k%6==2)r=q;\n\telse if(k%6==3)r=-p*q;\n\telse if(k%6==4)r=-q*-p*q;\n\telse if(k%6==5)r=-q*p*-q*-p*q;\n\tss=A*r*-A;\n\tfor(int i=1;i<n;i++)printf(\"%d \",ss.a[i]);\n\tprintf(\"%d\\n\",ss.a[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 100007;\n\nint n,tim,ps[_],qs[_],pr[_],qr[_];\nint bas[7][_],tran[_],gg[_],ggr[_];\n\nint main()\n{\n\tn=ty(),tim=ty();\n\tfor(int i=1;i<=n;i++)ps[i]=ty(),pr[ps[i]]=i;\n\tfor(int i=1;i<=n;i++)qs[i]=ty(),qr[qs[i]]=i;\n\n\tfor(int i=1;i<=n;i++)bas[1][i]=ps[i],bas[2][i]=qs[i];\n\tfor(int i=3;i<=6;i++)for(int j=1;j<=n;j++)bas[i][bas[i-2][j]]=bas[i-1][j];\n\t\n\tfor(int i=1;i<=n;i++)tran[i]=qs[pr[qr[ps[i]]]],gg[i]=i;\n\n\tint xtim=(tim-1)/6,rtim=tim-xtim*6;\n\twhile(xtim)\n\t{\n\t\tstatic int temp[_];\n\t\tif(xtim&1)\n\t\t{\n\t\t\tfor(int i=1;i<=n;i++)temp[i]=gg[tran[i]];\n\t\t\tfor(int i=1;i<=n;i++)gg[i]=temp[i];\n\t\t}\n\t\tfor(int i=1;i<=n;i++)temp[i]=tran[tran[i]];\n\t\tfor(int i=1;i<=n;i++)tran[i]=temp[i];\n\t\txtim>>=1;\n\t}\n\tfor(int i=1;i<=n;i++)ggr[gg[i]]=i;\n\tfor(int i=1;i<=n;i++)printf(\"%d%c\",gg[bas[rtim][ggr[i]]],\" \\n\"[i==n]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint n,k;\nstruct permutation{\n\tint a[100100];\n}p,q,_p,_q,g,_g,g_,_g_,ans,a[10],_a[10],E;\nvoid times(permutation &ans,permutation x,permutation y){\n\tfor(int i=1;i<=n;i++)\n\t\tans.a[i]=x.a[y.a[i]];\t\n}\nvoid inv(permutation &x,permutation y){\n\tfor(int i=1;i<=n;i++)\n\t\tx.a[y.a[i]]=i;\n}\nvoid quickpow(permutation &ans,permutation x,int y){\n\tpermutation res=x;\n\tans=E;\n\twhile(y){\n\t\tif(y&1) times(ans,ans,res);\n\t\ttimes(res,res,res);\n\t\ty>>=1;\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t\tE.a[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&p.a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&q.a[i]);\n\tinv(_p,p);\n\tinv(_q,q);\n\ttimes(g,q,_p);\n\ttimes(g,g,_q);\n\ttimes(g,g,p);\n\tinv(_g,g);\n\tint R=(k-1)%6+1,Q=(k-R)/6;\n\ta[1]=p,a[2]=q,_a[1]=_p,_a[2]=_q;\n\tfor(int i=3;i<=6;i++)\n\t\ttimes(a[i],a[i-1],_a[i-2]),inv(_a[i],a[i]);\n\tquickpow(g_,g,Q);\n\tquickpow(_g_,_g,Q);\n\ttimes(ans,g_,a[R]);\n\ttimes(ans,ans,_g_);\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%d \",ans.a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> p, q;\nvector<int> inv (vector<int>a) {\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[a[i]] = i;\n  }\n  return ret;\n}\nvector<int> cmp (vector<int>a, vector<int> b) {\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[i] = a[b[i]];\n  }\n  return ret;\n}\nvector<int> make (string s) {\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[i] = i;\n  }\n  for (char c : s) {\n    if (c == 'p') ret = cmp(ret, p);\n    else if (c == 'q') ret = cmp(ret, q);\n    else if (c == 'P') ret = cmp(ret, inv(p));\n    else if (c == 'Q') ret = cmp(ret, inv(q));\n  }\n  return ret;\n}\nvector<int> pow (vector<int>a, int k) {\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[i] = i;\n  }\n  while (k) {\n    if (k & 1) {\n      ret = cmp(ret, a);\n    }\n    a = cmp(a, a);\n    k >>= 1;\n  }\n  return ret;\n}\nint main() {\n  int k;\n  cin >> n >> k;\n  p.resize(n);\n  q.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    p[i]--;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> q[i];\n    q[i]--;\n  }\n  vector<int> ret(n);\n  if (k == 1) {\n    ret = p;\n  } else if (k == 2) {\n    ret = q;\n  } else {\n    k -= 2;\n    for (int i = 0; i < n; i++) {\n      ret[i] = i;\n    }\n    string rsd[6] = {\"q\", \"qP\", \"qPQ\", \"Q\", \"pQ\", \"qpQ\"};\n    int q = k / 6;\n    int r = k % 6;\n    ret = cmp(ret, pow(make(\"qPQp\"), q + r / 3));\n    ret = cmp(ret, make(rsd[r]));\n    ret = cmp(ret, pow(make(\"PqpQ\"), q));\n  }\n  for (int i = 0; i < n; i++) {\n    ret[i]++;\n  }\n  for (int i = 0; i < n; i++) {\n    cout << ret[i];\n    if (i < n - 1) {\n      cout << ' ';\n    } else {\n      cout << '\\n';\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\nbool is_equal(int loop[], int q[], int n);\n\nint main()\n{\n    int n, cnt = 0;\n    long k;\n    cin >> n >> k;\n\n    int p[n], q[n], tmp[n], loop[n];\n    for (int i = 0; i < n; i++) cin >> p[i];\n    for (int i = 0; i < n; i++) cin >> q[i];\n    if (k == 1) {\n        for (int i = 0; i < n - 1; i++) cout << p[i] << \" \";\n        cout << p[n - 1] << endl;\n    } \n    else if (k == 2) {\n        for (int i = 0; i < n - 1; i++) cout << q[i] << \" \";\n        cout << q[n - 1] << endl;\n    } \n    else {\n        for (int i = 2; i < k; i++)\n        {\n            if (i == 3)\n                for (int i = 0; i < n; i++) loop[i] = q[i];\n            cnt++;\n            for (int j = 0; j < n; j++)\n                tmp[(p[j] - 1)] = q[j];\n            for (int j = 0; j < n; j++) {\n                p[j] = q[j];\n                q[j] = tmp[j];\n            }\n            /*\n            if (is_equal(loop, q, n))\n            {\n                cout << cnt << endl;\n                for (int i = 0; i < ((k - 2) % cnt); i++) {\n                    for (int j = 0; j < n; j++)\n                        tmp[(p[j] - 1)] = q[j];\n                    for (int j = 0; j < n; j++) {\n                        p[j] = q[j];\n                        q[j] = tmp[j];\n                    }\n                }\n                break;\n            }\n            */\n        }\n        for (int i = 0; i < n - 1; i++)\n            cout << q[i] << \" \";\n        cout << q[n - 1] << endl;\n    }\n}\n\nbool is_equal(int loop[], int q[], int n)\n{\n    for (int i = 0; i < n; i++) {\n        if (loop[i] != q[i]) return false;\n    }\n    return true;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nint n, k;\nvector<int> p, q, rp, rq;\n\ntemplate<typename T, typename U>\nvector<int> mult(T&& a, U&& b) {\n    vector<int> c(n);\n    for (int i = 0; i < n; ++i) {\n        c[i] = b[a[i]];\n    }\n    return c;\n}\n\ntemplate<typename T>\nvector<int> rev(T&& a) {\n    vector<int> c(n);\n    for (int i = 0; i < n; ++i) {\n        c[a[i]] = i;\n    }\n    return c;\n}\n\ntemplate<typename T>\nvector<int> binpow(T&& p, int k) {\n    vector<int> ans(n);\n    for (int i = 0; i < n; ++i) {\n        ans[i] = i;\n    }\n    while (k) {\n        if (k & 1) {\n            ans = mult(p, ans);\n        }\n        p = mult(p, p);\n        k >>= 1;\n    }\n    return ans;\n}\n\ntemplate<typename T>\nvoid out(T&& q) {\n    for (int i = 0; i < n; ++i) {\n        if (i) {\n            cout << \" \";\n        }\n        cout << q[i] + 1;\n    }\n    cout << endl;\n    exit(0);\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> k;\n//   n = 5;\n//   out(mult(vector<int>({1, 3, 2, 0, 4}), vector<int>({0, 1, 2, 3, 4})));\n    p.resize(n);\n    q.resize(n);\n    rq.resize(n);\n    rp.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        --p[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> q[i];\n        --q[i];\n    }\n    rp = rev(p);\n    rq = rev(q);\n    vector<vector<int>> v = {{}, p, q};\n    for (int i = 3; i <= 6; ++i) {\n        v.push_back(mult(rev(v[i - 2]), v[i - 1]));\n    }\n    auto a = mult(mult(rq, p), mult(q, rp));\n    auto beginning = binpow(a, (k - 1) / 6);\n    vector<int> b;\n    b = mult(mult(p, rq), mult(rp, q));\n    auto ending = binpow(b, (k - 1) / 6);\n    vector<int> mid = v[(k - 1) % 6 + 1];\n    auto ans = mult(mult(beginning, mid), ending);\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint n,m,k;\nstruct Perm\n{\n\tint p[100005];\n\tPerm(){memset(p,0,sizeof(p));}\n\tint&operator[](int i){return p[i];}\n\tPerm operator*(Perm q)\n\t{\n\t\tPerm a;\n\t\tfor(int i=1;i<=n;i++)a[i]=p[q[i]];\n\t\treturn a;\n\t}\n\tPerm Inv()\n\t{\n\t\tPerm a;\n\t\tfor(int i=1;i<=n;i++)a[p[i]]=i;\n\t\treturn a;\n\t}\n}p,q,ip,iq,t,it,ans,a[10];\nPerm quick_pow(Perm x,int a)\n{\n\tPerm ans;\n\tfor(int i=1;i<=n;i++)ans[i]=i;\n\twhile(a)\n\t{\n\t\tif(a&1)ans=ans*x;\n\t\tx=x*x;\n\t\ta>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&q[i]);\n\tip=p.Inv();\n\tiq=q.Inv();\n\tt=q*ip*iq*p;\n\tit=t.Inv();\n\tk=(m-1)/6;\n\tm-=6*k;\n\ta[1]=p;\n\ta[2]=q;\n\tfor(int i=3;i<=6;i++)a[i]=a[i-1]*a[i-2].Inv();\n\tPerm ans=quick_pow(t,k)*a[m]*quick_pow(it,k);\n\tfor(int i=1;i<=n;i++)printf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nVI f(VI p, VI q){\n    int n = p.size();\n    VI ret(n);\n    REP(i,n) ret[p[i]] = q[i];\n    return ret;\n}\n\nVI inv(VI p){\n    int n = p.size();\n    VI ret(n);\n    REP(i,n) ret[p[i]] = i;\n    return ret;\n}\n\nVI mul(VI p, VI q){\n    int n = p.size();\n    VI ret(n);\n    REP(i,n) ret[i] = p[q[i]];\n    return ret;\n}\n\nvoid out(VI p){\n    for (int x : p) cout << x + 1 << \" \";\n    cout << endl;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    k--;\n    VI p(n), q(n);\n    REP(i,n) p[i] = in() - 1;\n    REP(i,n) q[i] = in() - 1;\n\n    VI a(n);\n    REP(i,n) a[i] = i;\n    VI x = mul(q, mul(inv(p), mul(inv(q), p)));\n    int t = k / 6;\n    while (t) {\n        if (t % 2) a = mul(x, a);\n        x = mul(x, x);\n        t /= 2;\n    }\n\n    p = mul(a, mul(p, inv(a)));\n    q = mul(a, mul(q, inv(a)));\n\n    VI ans;\n    if (k % 6 == 0) ans = p;\n    else if (k % 6 == 1) ans = q;\n    else{\n        REP(i,(k%6)-1){\n            VI r = f(p, q);\n            p = q;\n            q = r;\n        }\n        ans = q;\n    }\n    out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvector<int> inv(vector<int>&a){\n    vector<int>b(a.size());\n    rep(i,a.size()){\n        b[a[i]] = i;\n    }\n    return b;\n}\n\nvector<int> mul(vector<int>&a,vector<int>&b){\n    int n = a.size();\n    vector<int> res(n);\n    vector<int> ib = inv(b);\n    rep(i,n){\n        res[ib[i]] = a[i];\n    }\n    return res;\n}\nvector<int> calc(vector<int>a,int k){\n\n    if(k==0){\n        int n = a.size();\n        vector<int> res(n);\n        rep(i,n){\n            res[i] = i;\n        }\n        return res;\n    }\n    if(k==1){\n        return a;\n    }\n    if(k%2==0){\n        vector<int> tmp = calc(a,k/2);\n        return mul(tmp,tmp);\n    }else{\n        vector<int> tmp = calc(a,k/2);\n        tmp = mul(tmp,tmp);\n        return mul(a,tmp);\n    }\n}\nint main(){\n    int n,k;\n    cin >> n >> k;\n    vector<int>p(n),q(n);\n    rep(i,n){\n        cin >> p[i];\n        p[i]--;\n    }\n    rep(i,n){\n        cin >> q[i];\n        q[i]--;\n    }\n    k--;\n    int c = k/6;\n    int d = k%6;\n    vector<int> a,b;\n    if(d==0){\n        b = p;\n    }else if(d==1){\n        b = q;\n    }else if(d==2){\n        vector<int> tmp = inv(p);\n        b = mul(q,tmp);\n    }else if(d==3){ \n        b = inv(p);\n    }else if(d==4){\n        b = inv(q);\n    }else if(d==5){\n        vector<int> tmp = inv(q);\n        b = mul(tmp,p);\n    }\n    vector<int> ip,iq;\n    ip = inv(p);\n    iq = inv(q);\n    a = mul(q,ip);\n    a = mul(a,iq);\n    a = mul(a,p);\n    a = calc(a,c);\n    if(d >= 3){\n        a = mul(a,q);\n        a = mul(a,ip);\n    }\n    vector<int> ia = inv(a);\n    vector<int> T = mul(a,b);\n    vector<int>res = mul(T,ia);\n    rep(i,n){\n        cout << res[i]+1 << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define each(a,x) for(auto a : (x))\n#define all(a) (a).begin(),(a).end()\n#define chmin(a,b) ((a) = min((a),(b)))\n#define chmax(a,b) ((a) = max((a),(b)))\n#define in_range(x,l,r) ((l)<=(x) && (x)<(r))\n#define printvec(a) rep(i,a) cout << a[i] << \" \\n\"[i+1==(a).size()];\n#define fs first\n#define sc second\n#define em emplace\n#define eb emplace_back\n#define sz size()\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\n\nconst ll INF = 1e8;\nconst D EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\ninline vi inverse(const vi& perm) {\n  vi inv(perm.size());\n  rep(i, perm.size()) {\n    inv[perm[i]] = i;\n  }\n  return inv;\n}\n\nvi multiply(const vi& a, const vi& b) {\n  vi ans(a.size());\n  rep(i, a.size()){\n    ans[i] = b[a[i]];\n  }\n  return ans;\n}\n\nvi pow(const vi& a, ll k) {\n  if (k == 0) {\n    vi ans(a.size());\n    rep(i, a.size()) ans[i] = i;\n    return ans;\n  }\n\n  vi ans = pow(a, k / 2);\n  ans = multiply(ans, ans);\n  if (k & 1LL) {\n    ans = multiply(ans, a);\n  }\n  return ans;\n}\n\nint main(){\n  ll n, k;\n  cin >> n >> k;\n  vi p(n), q(n);\n  rep(i,n) {\n    cin >> p[i]; p[i]--;\n  }\n  rep(i,n) {\n    cin >> q[i]; q[i]--;\n  }\n\n  vi ans(n);\n  if (k < 30) {\n    vi a1 = p, a2 = q;\n    for(int i = 3; i <= k; ++i) {\n      vi a3 = multiply(inverse(a1), a2);\n      swap(a1, a2);\n      swap(a2, a3);\n    }\n    ans = a2;\n  } else {\n    vi prefix_base = multiply(inverse(q), multiply(p, multiply(q, inverse(p))));\n    vi prefix = pow(prefix_base, (k-2) / 6);\n    vi suffix_base = multiply(inverse(p), multiply(q, multiply(p, inverse(q))));\n    vi suffix = pow(suffix_base, (k-2) / 6);\n    vi very_suffix = multiply(inverse(p), q);\n\n    vi core = multiply(inverse(q), multiply(p, multiply(q, multiply(p, inverse(q)))));\n    if (k % 6 == 2LL) {\n      core = p;\n    } else if (k % 6 == 3LL) {\n      core.resize(n);\n      rep(i, n) core[i] = i;\n    } else if (k % 6 == 4LL) {\n      core = inverse(q);\n    } else if (k % 6 == 5LL) {\n      core = multiply(inverse(q), multiply(p, inverse(q)));\n    } else if (k % 6 == 0LL) {\n      core = multiply(inverse(q), multiply(p, multiply(p, inverse(q))));\n    }\n\n    ans = multiply(prefix, multiply(core, multiply(suffix, very_suffix)));\n  }\n\n  rep(i, n) {\n    cout << ans[i] + 1 << \" \\n\"[i == n-1];\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <utility>\n#define maxn 100005\nusing namespace std;\ntypedef long long ll;\ninline int getint(){\n  char c; int res = 0;\n  for(c = getchar();c < '0' || c > '9';c = getchar());\n  for(;c >= '0' && c <= '9';c = getchar()) res = res * 10 + (c - '0');\n  return res;\n}\nint n,k;\nstruct Permu{\n  int p[maxn];\n  Permu(){\n    memset(p,0,sizeof(p));\n  }\n  void read(){\n    for(int i = 1;i <= n;i++) p[i] = getint();\n  }\n  void print(){\n    for(int i = 1;i <= n;i++) printf(\"%d%c\",p[i],i == n ? '\\n' : ' ');\n  }\n  Permu operator * (Permu q){\n    Permu res = Permu();\n    for(int i = 1;i <= n;i++) res.p[p[i]] = q.p[i];\n    return res;\n  }\n  bool operator == (Permu q){\n    for(int i = 1;i <= n;i++) if(p[i] ^ q.p[i]) return false;\n    return true;\n  }\n}a,b;\nPermu e;\nvector <Permu> lis;\nint main(){\n  n = getint(), k = getint();\n  for(int i = 1;i <= n;i++) e.p[i] = i;\n  a.read();\n  b.read();\n  if(k == 1) a.print();\n  else if(k == 2) b.print();\n  else{\n    for(int i = 3;i <= k;i++){\n      lis.push_back(a);\n      Permu c = b;\n      b = a * b;\n      a = c;\n      if(a == lis[0] && b == lis[1]){\n        int len = i - 2;\n        lis[k % len == 0 ? len - 1 : k % len - 1].print();\n        return 0;\n      }\n    }\n    b.print();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\n\n\nvector<int> p1(100020,0);\n\nvector<int> p2(100020,0);\n\nvector<int> m1(100020,0);\nvector<int> m2(100020,0);\n\nvector<int>Z1,Z2;\nint n;\nvector<int> ff(vector<int>v1,vector<int> v2){\n\tvector<int> ans(n+1,0);\n\t\n\tfor(int i=0;i<=n;i++){\n\t\tans[i]=v1[v2[i]];\n\t}\n\treturn ans;\n}\n\n\nvector<int> BB(vector<int> ve,int kai){\n\tif(kai==1) return ve;\n\tif(kai%2){\n\t\treturn ff(BB(ve,kai-1),ve);\n\t}\n\tvector<int> D=BB(ve,kai/2);\n\treturn ff(D,D);\n}\n\nvector<int> migi(int r, vector<int> ve){\n\t\n\tint t=r/4;\n\tif(t){\n\tvector<int> be=BB(Z2,t);\n\t\t\n\t\tve=ff(be,ve);\n\t}\n\tr%=4;\n\t\n\tif(r>=1) ve=ff(m2,ve);\n\tif(r>=2) ve=ff(p1,ve);\n\tif(r>=3) ve=ff(p2,ve);\n\treturn ve;\n}\n\nvector<int> hidari(int r,vector<int> ve){\n\t\n\tint t=r/4;\n\tint tt=r%4;\n\n\t\n\tif(tt>=3) ve=ff(m2,ve);\n\tif(tt>=2) ve=ff(m1,ve);\n\tif(tt>=1) ve=ff(p2,ve);\n\t\n\tif(t){\n\tvector<int> be=BB(Z1,t);\n\t\t\n\t\tve=ff(be,ve);\n\t}\n\t\n\treturn ve;\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nvector<int> moto;\n \t\n \tint k;\n \tcin>>n>>k;\n \t\n \tfor(int i=0;i<=n;i++)moto.pb(i);\n \t\n \tfor(int i=1;i<=n;i++){\n \t\tcin>>p1[i];\n \t\tm1[p1[i]]=i;\n \t}\n \t\n \tfor(int i=1;i<=n;i++){\n \t\tcin>>p2[i];\n \t\tm2[p2[i]]=i;\n \t}\n \tif(k==1){\n \t\tfor(int i=1;i<=n;i++)cout<<p1[i]<<\" \";\n \t\tcout<<endl;\n \t\treturn 0;\n \t}\n\n \t\n \tif(k==2){\n \t\tfor(int i=1;i<=n;i++)cout<<p2[i]<<\" \";\n \t\tcout<<endl;\n \t\treturn 0;\n \t}\n \t/*\n \tfor(int i=1;i<=n;i++)cout<<p1[i]<<\" \";\n \tcout<<endl;\n \tfor(int i=1;i<=n;i++)cout<<m1[i]<<\" \";\n \tcout<<endl;\n \tfor(int i=1;i<=n;i++)cout<<p2[i]<<\" \";\n \tcout<<endl;\n \tfor(int i=1;i<=n;i++)cout<<m2[i]<<\" \";\n \tcout<<endl;\n \t*/\n \t Z1=moto;\n \tZ1=ff(p1,Z1);\n \t\n \tZ1=ff(m2,Z1);\n \tZ1=ff(m1,Z1);\n \tZ1=ff(p2,Z1);\n \t\n \t\n \t Z2=moto;\n \tZ2=ff(m2,Z2);\n \tZ2=ff(p1,Z2);\n \tZ2=ff(p2,Z2);\n \tZ2=ff(m1,Z2);\n \t\n \t\n \tvector<int> ans=moto;\n \t\n \tint k1=(k+1)/3;\n \tk1=k1*2-2;\n \tif(k%3==2)k1--;\n \t\n \tans=migi(k1,ans);\n \t\n \tint k2=k1+3;\n \tif(k%3==0) k2--;\n \tans=hidari(k2,ans);\n \t//cout<<k1<<\" \"<<k2<<endl;\n \tfor(int i=1;i<=n;i++)cout<<ans[i]<<\" \";\n \tcout<<endl;\n \treturn 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-9;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\nbool nearlyeq(double x, double y) { return abs(x - y) < eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vi xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\nvi rev_map(const vi &f) {\n\tint n = f.size();\n\tvi ret(n);\n\tLoop(i, n) {\n\t\tret[f[i]] = i;\n\t}\n\treturn ret;\n}\n\n// g, then, f\nvi seq_map(const vi &f, const vi &g) {\n\tint n = f.size();\n\tvi ret(n);\n\tLoop(i, n) {\n\t\tret[i] = f[g[i]];\n\t}\n\treturn ret;\n}\n\nvi pow_map(const vi &f, int p) {\n\tvi ret;\n\tif (p == 0) {\n\t\tret.resize(f.size());\n\t\tLoop(i, f.size()) ret[i] = i;\n\t}\n\telse if (p == 1) ret = f;\n\telse {\n\t\tret = pow_map(f, p / 2);\n\t\tret = seq_map(ret, ret);\n\t\tif (p % 2 == 1) ret = seq_map(f, ret);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n, k; cin >> n >> k; k--;\n\tvi p(n);\n\tLoop(i, n) {\n\t\tcin >> p[i]; p[i]--;\n\t}\n\tvi q(n);\n\tLoop(i, n) {\n\t\tcin >> q[i]; q[i]--;\n\t}\n\tvi P = rev_map(p);\n\tvi Q = rev_map(q);\n\tvi qPQp = seq_map(q, seq_map(P, seq_map(Q, p)));\n\tvi PqpQ = rev_map(qPQp);\n\tvi qP = seq_map(q, P);\n\tvi qPQ = seq_map(qP, Q);\n\tvi qPQpQ = seq_map(qPQ, seq_map(p, Q));\n\tvi qPQppQ = seq_map(qPQ, seq_map(p, seq_map(p, Q)));\n\tvi qPQpqpQ = seq_map(qPQ, seq_map(p, seq_map(q, seq_map(p, Q))));\n\tvi ans;\n\tif (k == 0) {\n\t\tans = p;\n\t}\n\telse {\n\t\tk--;\n\t\tint m = k / 6;\n\t\tif (k % 6 == 0) {\n\t\t\tans = seq_map(pow_map(qPQp, m), seq_map(q, pow_map(PqpQ, m)));\n\t\t}\n\t\telse if (k % 6 == 1) {\n\t\t\tans = seq_map(pow_map(qPQp, m), seq_map(qP, pow_map(PqpQ, m)));\n\t\t}\n\t\telse if (k % 6 == 2) {\n\t\t\tans = seq_map(pow_map(qPQp, m), seq_map(qPQ, pow_map(PqpQ, m)));\n\t\t}\n\t\telse if (k % 6 == 3) {\n\t\t\tans = seq_map(pow_map(qPQp, m), seq_map(qPQpQ, pow_map(PqpQ, m)));\n\t\t}\n\t\telse if (k % 6 == 4) {\n\t\t\tans = seq_map(pow_map(qPQp, m), seq_map(qPQppQ, pow_map(PqpQ, m)));\n\t\t}\n\t\telse if (k % 6 == 5) {\n\t\t\tans = seq_map(pow_map(qPQp, m), seq_map(qPQpqpQ, pow_map(PqpQ, m)));\n\t\t}\n\t}\n\tLoop(i, n) ans[i]++;\n\tprintv(ans);\n}\n\n/*\n\np\nq\nqP\nqPQ\nqPQpQ\nqPQppQ\nqPQpqpQ\nqPQp q PqpQ\nqPQp qP PqpQ\nqPQp qPQ PqpQ\nqPQp qPQpQ PqpQ\nqPQp qPQppQ PqpQ\nqPQp qPQpqpQ PqpQ\nqPQpqPQp q PqpQPqpQ\nqPQpqPQp qP PqpQPqpQ\nqPQpqPQp qPQ PqpQPqpQ\nqPQpqPQp qPQpQ PqpQPqpQ\nqPQpqPQp qPQppQ PqpQPqpQ\nqPQpqPQp qPQpqpQ PqpQPqpQ\nqPQpqPQpqPQp q PqpQPqpQPqpQ\nqPQpqPQpqPQp qP PqpQPqpQPqpQ\nqPQpqPQpqPQp qPQ PqpQPqpQPqpQ\nqPQpqPQpqPQp qPQpQ PqpQPqpQPqpQ\nqPQpqPQpqPQp qPQppQ PqpQPqpQPqpQ\nqPQpqPQpqPQp qPQpqpQ PqpQPqpQPqpQ\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, m;\n\nvector <int> A, B, IA, IB, fil[10];\n\nvector <int> Inv(vector <int> cxt) {\n\tvector <int> tmp = cxt;\n\tfor(int i = 0; i < (int) cxt.size(); ++ i)\n\ttmp[cxt[i]] = i;\n\treturn tmp;\n}\n\nvector <int> operator * (vector <int> a, vector <int> b) {\n\tvector <int> ans; ans.resize(a.size());\n\tfor(int i = 0; i < n; ++ i) {\n\t\tans[i] = a[i];\n\t}\n\tfor(int i = 0; i < n; ++ i)\n\tans[i] = b[ans[i]];\n\treturn ans;\n} \n\nvector <int> Pow(vector <int> x, int y) {\n\tvector <int> res; res.clear();\n\tfor(int i = 0; i < n; ++ i) res.push_back(i);\n\tfor(; y; y >>= 1, x = x * x) {\n\t\tif(y & 1)\n\t\tres = res * x;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> n >> m;\n\tA.resize(n);  B.resize(n);\n\tfor(int i = 0; i < n; ++ i) scanf(\"%d\", &A[i]), -- A[i];\n\tfor(int i = 0; i < n; ++ i) scanf(\"%d\", &B[i]), -- B[i];\n\tint now = (m - 1) / 6; m -= now * 6;\n\tIA = Inv(A), IB = Inv(B);\n\tvector <int> k1 = A * IB * IA * B, k2 = Inv(k1);\n\tswap(k1, k2);\n\tk1 = Pow(k1, now); k2 = Pow(k2, now);\n\tfil[1] = k1 * A * k2;\n\tfil[2] = k1 * B * k2;\n\tfor(int i = 3; i <= m; ++ i) {\n\t\tfil[i].resize(n);\n\t\tfor(int j = 0; j < n; ++ j)\n\t\tfil[i][fil[i - 2][j]] = fil[i - 1][j];\n\t}\n\tfor(int j = 0; j < n; ++ j) {\n\t\tprintf(\"%d \", fil[m][j] + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf = 1.01e9;\nconst i64 inf64 = 4.01e18;\nconst double eps = 1e-9;\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// q(p(i))\nvector<i64> composite(const vector<i64> &p, const vector<i64> &q){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n) res[i]=q[p[i]];\n    return res;\n}\n\nvector<i64> inverse(const vector<i64> &p){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n) res[p[i]]=i;\n    return res;\n}\n\nvector<i64> pow(vector<i64> p,i64 k){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n){\n        res[i]=i;\n    }\n    while(k){\n        if(k&1){\n            res=composite(res,p);\n        }\n        p=composite(p,p);\n        k>>=1;\n    }\n    return res;\n}\n\nvector<i64> f(const vector<i64> &p,const vector<i64> &q){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n) res[p[i]]=q[i];\n    return res;\n}\n\nvoid solve() {\n    //const i64 mod = 1'000'000'007;\n\n    /*\n    vector<string> vs(30);\n    vs[1]=\"a\";\n    vs[2]=\"b\";\n    rep(i,3,vs.size()){\n        vs[i]=vs[i-1];\n        for(i64 j=vs[i-2].size()-1; j>=0; --j){\n            char c=vs[i-2][j];\n            if(c=='a'){\n                if(vs[i].back()=='a') vs[i].pop_back();\n                else vs[i]+='A';\n            }\n            if(c=='A'){\n                if(vs[i].back()=='A') vs[i].pop_back();\n                else vs[i]+='a';\n            }\n            if(c=='b'){\n                if(vs[i].back()=='b') vs[i].pop_back();\n                else vs[i]+='B';\n            }\n            if(c=='B'){\n                if(vs[i].back()=='B') vs[i].pop_back();\n                else vs[i]+='b';\n            }\n        }\n    }\n    rep(i,1,vs.size()){\n        cout << i << \": \" << vs[i] << endl;\n    }\n     */\n\n    i64 N,K;\n    cin >> N >> K;\n\n    vector<i64> p(N),q(N);\n    rep(i,0,N){\n        cin >> p[i];\n        --p[i];\n    }\n    rep(i,0,N){\n        cin >> q[i];\n        --q[i];\n    }\n\n    if(K<=20){\n        vector<vector<i64>> a(K+1);\n        a[1]=p;\n        a[2]=q;\n        rep(i,3,K+1){\n            a[i]=f(a[i-2],a[i-1]);\n        }\n        rep(i,0,N){\n            cout << a[K][i]+1;\n            if(i==N-1) cout << endl;\n            else cout << \" \";\n        }\n        return;\n    }\n\n    vector<i64> pi=inverse(p),qi=inverse(q);\n\n    auto x= composite(composite(composite(p, qi), pi), q);\n    auto y= composite(composite(composite(qi, p), q), pi);\n\n    i64 loop=(K-2)/6, rem=K-(2+loop*6);\n    print(loop);\n    print(rem);\n    auto prev=composite(composite(inverse(pow(x,loop)),p),pow(x,loop));\n    auto ans=composite(composite(pow(y,loop),q),pow(x,loop));\n    rep(i,0,rem){\n        auto tmp=ans;\n        ans=f(prev,ans);\n        prev=tmp;\n    }\n\n    rep(i,0,N){\n        cout << ans[i]+1;\n        if(i==N-1) cout << endl;\n        else cout << \" \";\n    }\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//problem:agc031_d\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=1e5+5;\nint n,k,p[MAXN],q[MAXN],t[MAXN],tt[MAXN],ttt[MAXN],a[MAXN],b[MAXN];\nvoid rev(int *p,int *res){\n\tfor(int i=1;i<=n;++i)res[p[i]]=i;\n}\nvoid mul(int *p,int *q,int *res){\n\tfor(int i=1;i<=n;++i)res[i]=p[q[i]];\n}\nvoid cp(int *p,int *res){\n\tfor(int i=1;i<=n;++i)res[i]=p[i];\n}\nvoid get_a(){\n\tfor(int i=1;i<=n;++i)a[i]=i;\n\tint e=(k-1)/6;\n//\tif(k%6==1);\n//\telse if(k%6==2);\n//\telse if(k%6==3);\n//\telse if(k%6==4)cp(q,a);\n//\telse if(k%6==5)rev(p,t),mul(q,t,a);\n//\telse if(k%6==0)rev(p,t),mul(q,t,a);\n//\telse assert(0);\n\t//a=tt^e\n\trev(p,t),rev(q,tt),mul(q,t,ttt),mul(ttt,tt,t),mul(t,p,tt);\n\twhile(e){\n\t\tif(e&1)mul(a,tt,t),cp(t,a);\n\t\tcp(tt,ttt),mul(tt,ttt,t),cp(t,tt);//tt=tt*tt\n\t\te>>=1;\n\t}\n\tif(k%6==1);\n\telse if(k%6==2);\n\telse if(k%6==3);\n\telse if(k%6==4)mul(a,q,t),cp(t,a);\n\telse if(k%6==5)mul(a,q,tt),rev(p,t),mul(tt,t,a);\n\telse if(k%6==0)mul(a,q,tt),rev(p,t),mul(tt,t,a);\n\telse assert(0);\n}\nvoid get_b(){\n\tif(k%6==1)cp(p,b);\n\telse if(k%6==2)cp(q,b);\n\telse if(k%6==3)rev(p,t),mul(q,t,b);\n\telse if(k%6==4)rev(p,b);\n\telse if(k%6==5)rev(q,b);\n\telse if(k%6==0)rev(q,t),mul(t,p,b);\n\telse assert(0);\n}\nint main() {\n\tn=read();k=read();\n\tfor(int i=1;i<=n;++i)p[i]=read();\n\tfor(int i=1;i<=n;++i)q[i]=read();\n\tget_a();\n\tget_b();\n\trev(a,t),mul(a,b,tt),mul(tt,t,ttt);\n\tfor(int i=1;i<=n;++i)printf(\"%d \",ttt[i]);puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 100005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N,K;\nstruct pl {\n    int f[100005];\n    friend pl operator * (const pl &a,const pl &b) {\n\tpl c;\n\tfor(int i = 1 ; i <= N ; ++i) c.f[i] = a.f[b.f[i]];\n\treturn c;\n    }\n    pl inv() {\n\tpl c;\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    c.f[f[i]] = i;\n\t}\n\treturn c;\n    }\n}p,q,iq,ip,s,res,t,ans;\nvoid fpow(int c) {\n    for(int i = 1 ; i <= N ; ++i) res.f[i] = i;\n    t = s;\n    while(c) {\n\tif(c & 1) res = res * t;\n\tt = t * t;\n\tc >>= 1;\n    }\n}\nvoid Solve() {\n    read(N);read(K);\n    for(int i = 1 ; i <= N ; ++i) read(p.f[i]);\n    for(int i = 1 ; i <= N ; ++i) read(q.f[i]);\n    ip = p.inv();iq = q.inv();\n    s = q * ip * iq * p;\n    fpow((K - 1) / 6);\n    int x = (K - 1) % 6;\n    if(x == 0) {\n\tans = res * p * res.inv();\n    }\n    else if(x == 1) {\n\tans = res * q * res.inv();\n    }\n    else if(x == 2) {\n\tans = res * q * ip * res.inv();\n    }\n    else if(x == 3) {\n\tres = res * q;\n\tans = res * ip * res.inv();\n    }\n    else if(x == 4) {\n\tres = res * q * ip;\n\tans = res * iq * res.inv();\n    }\n    else if(x == 3) {\n\tres = res * q * ip;\n\tans = res * iq * p * res.inv();\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n\tout(ans.f[i]);space;\n    }\n    enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define _ << \" _ \" <<\n#define TRACE(x) cout << #x << \" = \" << x << endl\n\ntypedef long long ll;\n\nconst int MaxN = 1e5;\n\nint n, k;\nvector<int> id, p, q, P, Q, PQ, pq, Pq, pQ;\nvector<int> PQpq[31], PqpQ[31], pQPq[31];\n\nvector<int> mult(vector<int>& a, vector<int>& b) {\n    vector<int> c(n);\n    for (int i = 0; i < n; i++) c[i] = a[b[i]];\n    return c;\n}\n\nvoid powers(vector<int> a[]) {\n    for (int i = 1; i < 31; i++) a[i] = mult(a[i-1], a[i-1]);\n}\n\nvector<int> get_pow(vector<int> a[], int e) {\n    vector<int> b = id;\n    for (int i = 0; i < 31; i++)\n        if (e & (1 << i)) b = mult(b, a[i]);\n    return b;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> k;\n    p.resize(n);\n    q.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i];\n        p[i]--;\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> q[i];\n        q[i]--;\n    }\n\n    if (k == 1) {\n        for (int i = 0; i < n; i++) cout << p[i] + 1 << \" \";\n        return 0;\n    }\n\n    id.resize(n);\n    P.resize(n);\n    Q.resize(n);\n    for (int i = 0; i < n; i++) {\n        id[i] = i;\n        P[p[i]] = i;\n        Q[q[i]] = i;\n    }\n\n    PQ = mult(P, Q);\n    pq = mult(p, q);\n    PQpq[0] = mult(PQ, pq);\n    powers(PQpq);\n    pQ = mult(p, Q);\n    Pq = mult(P, q);\n    PqpQ[0] = mult(Pq, pQ);\n    powers(PqpQ);\n    pQPq[0] = mult(pQ, Pq);\n    powers(pQPq);\n\n    k = ((k - 2) / 3) * 4 + (k - 2) % 3 + 1;\n\n    vector<int> sol = q;\n\n    int a = k / 4; if (k % 4 == 3) a++;\n    vector<int> x = get_pow(PQpq, a / 2); sol = mult(sol, x);\n    if (a % 2) sol = mult(sol, PQ);\n\n    int b = k / 4;\n    if (k % 8 < 4) {\n        if (k % 8 == 2) sol = mult(sol, P);\n        vector<int> y = get_pow(PqpQ, b / 2); sol = mult(sol, y);\n        if (b % 2) sol = mult(sol, Pq);\n    } else {\n        if (k % 8 == 6) sol = mult(sol, p);\n        vector<int> y = get_pow(pQPq, b / 2); sol = mult(sol, y);\n        if (b % 2) sol = mult(sol, pQ);\n    }\n\n    for (int i = 0; i < n; i++) cout << sol[i] + 1 << \" \";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std; \ntypedef vector<int> ve;\nint n,k;\nve p,q,A,B,ip,iq;\nvoid re(ve &x) {\n\tx.resize(n+1);\n\tfill(x.begin(),x.begin()+1+n,0);\n}\nve inv(ve a) {\n\tve orz;\n\tre(orz);\n\tfor(int i=1;i<=n;i++) {\n\t\torz[a[i]] = i;\n\t}\n\treturn orz;\n}\nve operator*(ve aa,ve bb) {\n\tve orz; re(orz);\n\tfor(int i=1;i<=n;i++) {\n\t\torz[i] = aa[bb[i]];\n\t}\n\treturn orz;\n}\nve ksm(ve aa,int b) {\n\tve orz; re(orz);\n\tfor(int i=1;i<=n;i++) orz[i] = i;\n\tfor(;b;b>>=1,aa = aa*aa) {\n\t\tif(b&1) {\n\t\t\torz = orz*aa;\n\t\t}\n\t}\n\treturn orz;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tre(p); re(q);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&q[i]);\n\tip = inv(p); iq = inv(q);\n\tve yooo = q*ip*iq*p;\n\tA = ksm(yooo,(k-1)/6);\n\tint yo = k - (k-1)/6*6;\n\tswitch(yo) {\n\t\tcase 1:{\n\t\t\tB = p;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:{\n\t\t\tB = q;\n\t\t\tbreak;\n\t\t}\n\t\tcase 3:{\n\t\t\tB = q * ip;\n\t\t\tbreak;\n\t\t}\n\t\tcase 4:{\n\t\t\tB = ip;\n\t\t\tA = A*q;\n\t\t\tbreak;\n\t\t}\n\t\tcase 5:{\n\t\t\tB = iq;\n\t\t\tA = A*q*ip;\n\t\t\tbreak;\n\t\t}\n\t\tcase 6:{\n\t\t\tB = iq*p;\n\t\t\tA = A*q*ip;\n\t\t\tbreak;\n\t\t}\n\t}\n\tve ans = A * B * inv(A);\n\tfor(int i=1;i<=n;i++) {\n\t\tprintf(\"%d \",ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstring inv(string x) {\n  reverse(begin(x), end(x));\n  for (auto&& e : x) e ^= 32;\n  return x;\n}\nstring cp(string x, string y) {\n  reverse(begin(y), end(y));\n  while (!x.empty() and !y.empty() and (x.back() ^ y.back()) == 32) {\n    x.pop_back();\n    y.pop_back();\n  }\n  reverse(begin(y), end(y));\n  return x + y;\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, k; cin >> n >> k, --k;\n  V<> p(n); for (auto&& e : p) cin >> e, --e;\n  V<> q(n); for (auto&& e : q) cin >> e, --e;\n  auto cp = [&](const V<>& p, const V<>& q) -> V<> {\n    V<> res(n);\n    for (int i = 0; i < n; ++i) {\n      res[i] = p[q[i]];\n    }\n    return res;\n  };\n  auto inv = [&](const V<>& p) -> V<> {\n    V<> res(n);\n    for (int i = 0; i < n; ++i) {\n      res[p[i]] = i;\n    }\n    return res;\n  };\n  auto pow = [&](V<> p, int k) -> V<> {\n    V<> res(n);\n    iota(begin(res), end(res), 0);\n    while (k) {\n      if (k & 1) res = cp(res, p);\n      p = cp(p, p);\n      k >>= 1;\n    }\n    return res;\n  };\n  auto f = [&](const V<>& p, const V<>& q) -> V<> {\n    return cp(q, inv(p));\n  };\n  auto solve = [&]() -> V<> {\n    if (!k) return p;\n    VV<> a(7);\n    a[0] = p, a[1] = q;\n    for (int i = 2; i <= 6; ++i) {\n      a[i] = f(a[i - 2], a[i - 1]);\n    }\n    int r = (k - 1) % 6 + 1;\n    auto x = cp(a[3], p);\n    x = pow(x, (k - r) / 6);\n    auto res = a[r];\n    res = cp(x, res);\n    res = cp(res, inv(x));\n    return res;\n  };\n  auto res = solve();\n  for (int i = 0; i < n; ++i) {\n    cout << res[i] + 1 << \" \\n\"[i == n - 1];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nint n,k;\nstruct Permutation{\n\tint a[101000];\n\tint& operator [] (int x){return a[x];}\n\tvoid init(){\n\t\tfor(int i=1;i<=n;i++) read(a[i]);\n\t}\n}P,Q;\nPermutation inv(Permutation p){\n\tPermutation res;\n\tfor(int i=1;i<=n;i++) res[p[i]]=i;\n\treturn res;\n}\nPermutation operator * (Permutation p1,Permutation p2){\n\tPermutation res;\n\tfor(int i=1;i<=n;i++) res[i]=p1[p2[i]];\n\treturn res;\n}\nPermutation fp(Permutation a,int k){\n\tPermutation res;\n\tfor(int i=1;i<=n;i++) res[i]=i;\n\tfor(;k;k>>=1,a=a*a)\n\t\tif(k&1) res=a*res;\n\treturn res;\n}\nint main(){\n\tread(n);read(k);\n\tP.init();\n\tQ.init();\n\tPermutation ans,res,f[10];\n\tres=Q*inv(P)*inv(Q)*P;\n\tf[1]=P;f[2]=Q;\n\tfor(int i=3;i<=6;i++) f[i]=f[i-1]*inv(f[i-2]);\n\tans=fp(res,(k-1)/6)*f[(k-1)%6+1]*fp(inv(res),(k-1)/6);\n\tfor(int i=1;i<=n;i++)\n\t\tcout<<ans[i]<<' ';\n\tcout<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register int i=(a);i<=(b);i++)\n#define For(i,a,b) for (register int i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\nusing namespace std;\nconst int N=1e5+5;\nint n,k,tmp;\nstruct P\n{\n\tint a[N];\n\tP(){mem(a,0);}\n}p,q,pi,qi,f[10],A,ans;\nP operator *(P x,P y)\n{\n\tP ret;\n\tFOR(i,1,n) ret.a[i]=x.a[y.a[i]];\n\treturn ret;\n}\nP operator ^(P x,int y)\n{\n\tP ret;\n\tFOR(i,1,n) ret.a[i]=i;\n\tfor (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;\n\treturn ret;\n}\ninline P Inv(P x)\n{\n\tP ret;\n\tFOR(i,1,n) ret.a[x.a[i]]=i;\n\treturn ret;\n}\ninline P F(P x,P y)\n{\n\tP ret;\n\tret=y*Inv(x);\n\treturn ret;\n}\ninline void Write(P x)\n{\n\tFOR(i,1,n) printf(\"%d \",x.a[i]);\n\tputs(\"\");\n\treturn;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tFOR(i,1,n) scanf(\"%d\",&p.a[i]);\n\tFOR(i,1,n) scanf(\"%d\",&q.a[i]);\n\tf[1]=p,f[2]=q;\n\tpi=Inv(p),qi=Inv(q);\n\ttmp=(k-1)/6;\n\tk-=6*tmp;\n\tA=q*pi*qi*p;\n\tA=A^tmp;\n\tFOR(i,3,6) f[i]=F(f[i-2],f[i-1]);\n\tans=A*f[k]*Inv(A);\n\tWrite(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define INF  (1<<30)\n#define INFL (1LL<<60)\n#define MOD 1000000007\n#define EPS ((ld)(1e-9))\n\n#define sz(x) ((int)(x).size())\n#define setz(x) memset(x, 0, sizeof(x))\n#define rep(i, x)  for (int i = 0, _##i = (x); i < _##i; i++)\n#define repp(i, x) for (int i = 1, _##i = (x); i <= _##i; i++)\n#define repr(i, s, e) for (int i = (s), _##i = (e); i < _##i; i++)\n\n#define L(x) ((x)*2)\n#define R(x) ((x)*2+1)\n\n#ifndef __SOULTCH\n#define endl '\\n'\n#define debug(x) \n#else\n#define debug(x) cout << \" [+] \" << #x << \" = \" << x << endl\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ld, ld> pdd;\ntypedef pair<ll, ll> pll;\n\ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const pair<T, V> pai) { \n    return os << pai.first << ' ' << pai.second;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> v) {\n    rep(i, sz(v)) cout << v[i] << ' ';\n    return os;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const set<T> s) {\n    for (T p : s) cout << p << ' ';\n    return os;\n}\n\ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const map<T, V> s) {\n    for (auto p : s) cout << '(' << p << \") \";\n    return os;\n}\n\ntemplate<typename T, typename V>\nistream &operator>>(istream &is, pair<T, V> &pai) {\n\tis >> pai.first >> pai.second;\n\treturn is;\n}\n\nint N, K;\nint arr[100001][1000];\n\nint main(void) {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n\n    cin >> N >> K;\n    repp(i, N) cin >> arr[0][i];\n    repp(i, N) cin >> arr[1][i];\n\n    int pr = -1;\n    repr(i, 2, 1000) {\n        repp(j, N) arr[i][arr[i-2][j]] = arr[i-1][j];\n\n        bool f = true;\n        repp(j, N) if (arr[0][j] != arr[i-1][j] or arr[1][j] != arr[i][j]) {f = false; break;}\n        if (f) {\n            pr = i;\n            break;\n        }\n    }\n\n    K %= (pr-1);\n    repp(i, N) cout << arr[K-1][i] << ' ';\n    cout << endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<iostream>\nusing namespace std;\n\ninline int read()\n{\n\tint x=0; bool f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=0;\n\tfor(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^'0');\n\tif(f) return x;\n\treturn -x;\n}\n\nconst int N = 1e5;\nconst int lgM = 30;\nint p[N+3],q[N+3],pp[N+3],qq[N+3];\nint g[N+3],f[N+3],ff[N+3];\nint tmp[N+3];\nint aux[N+3];\nint ans[N+3];\nint a[7][N+3];\nint n,m;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&p[i]),pp[p[i]] = i;\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&q[i]),qq[q[i]] = i;\n\tfor(int i=1; i<=n; i++) a[1][i] = p[i],a[2][i] = q[i];\n\tfor(int k=3; k<=6; k++)\n\t{\n\t\tfor(int i=1; i<=n; i++) a[k][a[k-2][i]] = a[k-1][i];\n\t}\n\tfor(int i=1; i<=n; i++) g[i] = q[pp[qq[p[i]]]],f[i] = i,tmp[i] = g[i];\n\tint nn = m%6==0?6:m%6; m = (m-1)/6;\n\tfor(int i=0; m; i++)\n\t{\n\t\tif(m&(1<<i))\n\t\t{\n\t\t\tm-=(1<<i);\n\t\t\tfor(int j=1; j<=n; j++) aux[j] = f[tmp[j]];\n\t\t\tfor(int j=1; j<=n; j++) f[j] = aux[j];\n\t\t}\n\t\tfor(int j=1; j<=n; j++) aux[j] = tmp[tmp[j]];\n\t\tfor(int j=1; j<=n; j++) tmp[j] = aux[j];\n\t}\n\tfor(int i=1; i<=n; i++) ff[f[i]] = i;\n\tfor(int i=1; i<=n; i++) ans[i] = f[a[nn][ff[i]]];\n\tfor(int i=1; i<=n; i++) printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#define int long long\nusing namespace std;\n\nint MOD = 1000000007;\nint N;\n\nvector<int> rev(vector<int> &X) {\n\tvector<int> res(N);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tres[X[i]] = i;\n\t}\n\treturn res;\n}\n\nvector<int> mul(vector<int> &X, vector<int> &Y) {\n\tvector<int> res(N);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tres[i] = Y[X[i]];\n\t}\n\treturn res;\n}\n\nvector<int> ID;\n\nvector<int> po(vector<int> &X, int k) {\n\tif (k == 0) {\n\t\treturn ID;\n\t}\n\tvector<int> res = po(X, k / 2);\n\tres = mul(res, res);\n\tif (k % 2 == 1) {\n\t\tres = mul(res, X);\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint K;\n\tcin >> N >> K;\n\tID.resize(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tID[i] = i;\n\t}\n\tvector<int> revA(N);\n\tvector<int> revB(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> revA[i];\n\t\trevA[i]--;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> revB[i];\n\t\trevB[i]--;\n\t}\n\tvector<int> A = rev(revA);\n\tvector<int> B = rev(revB);\n\tint X[4] = { 2,-1,-2,1 };\n\tvector<vector<int> > XX(4);\n\tXX[0] = B;\n\tXX[1] = revA;\n\tXX[2] = revB;\n\tXX[3] = A;\n\tvector<int> ALL = ID;\n\tfor (int i = 0; i < 4; i++) {\n\t\tALL = mul(ALL, XX[i]);\n\t}\n\tvector<int> Z;\n\tif (K % 3 == 0) {\n\t\tint num = 2 * (K / 3) - 2;\n\t\tZ = po(ALL, num / 4);\n\t\tfor (int i = 0; i < num % 4; i++) {\n\t\t\tZ = mul(Z, XX[i]);\n\t\t}\n\t\tvector<int> revZ = rev(Z);\n\n\t\tif (K % 2 == 0) {\n\t\t\tZ = mul(Z, revB);\n\t\t\tZ = mul(Z, A);\n\n\t\t} else {\n\t\t\tZ = mul(Z, B);\n\t\t\tZ = mul(Z, revA);\n\t\t}\n\t\tZ = mul(Z, revZ);\n\t} else if (K % 3 == 1) {\n\t\tint num = 2 * (K / 3) - 1;\n\t\tZ = po(ALL, num / 4);\n\t\tfor (int i = 0; i < num % 4; i++) {\n\t\t\tZ = mul(Z, XX[i]);\n\t\t}\n\t\tvector<int> revZ = rev(Z);\n\t\tif (K % 2 == 0) {\n\t\t\tZ = mul(Z, revA);\n\t\t} else {\n\t\t\tZ = mul(Z, A);\n\t\t}\n\t\tZ = mul(Z, revZ);\n\t} else {\n\t\tint num = 2 * (K / 3);\n\t\tZ = po(ALL, num / 4);\n\t\tfor (int i = 0; i < num % 4; i++) {\n\t\t\tZ = mul(Z, XX[i]);\n\t\t}\n\t\tvector<int> revZ = rev(Z);\n\t\tif (K % 2 == 0) {\n\t\t\tZ = mul(Z, B);\n\t\t} else {\n\t\t\tZ = mul(Z, revB);\n\t\t}\n\t\tZ = mul(Z, revZ);\n\t}\n\tZ = rev(Z);\n\tif (K == 1) Z = revA;\n\tif (K == 2) Z = revB;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << Z[i] + 1;\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <boost/container/static_vector.hpp>\n//#include <boost/unordered_set.hpp>\n//#include <boost/unordered_map.hpp>\n//#include <unistd.h>\n\n//#include <cv.h>\n//#include <highgui.h>\n#include <stdlib.h>\n#include <string>\n\n// 置換行列P,Qの積。ただし、p,qは対応する順列で、P[i][j] == 1 <==> p[i] = j となっている。\n// N次元行列の表現に、先頭が0のN+1要素ベクトルを利用している。\nstd::vector<int> perm_product(std::vector<int> p, std::vector<int> q) {\n    assert(p.size() == q.size());\n    std::vector<int> r;\n    r.resize(p.size());\n    int N = p.size() - 1;\n    for (int i = 1; i <= N; i++) {\n        r[i] = q[p[i]];\n    }\n    return r;\n}\n\n// 置換行列Pの転置。pは対応する順列。\nstd::vector<int> perm_trans(std::vector<int> p) {\n    std::vector<int> r;\n    r.resize(p.size());\n    int N = p.size() - 1;\n    for (int i = 1; i <= N; i++) {\n        r[p[i]] = i;\n    }\n    return r;\n}\n\n// 置換行列Pの累乗。ただしpは対応する順列。\nstd::vector<int> perm_pow(std::vector<int> p, long long K) {\n    std::vector<int> r;\n    r.resize(p.size());\n    int N = p.size() - 1;\n    for (int i = 1; i <= N; i++) {\n        r[i] = i;\n    }\n\n    while (K > 0) {\n        if (K & 1) {\n            r = perm_product(r, p);\n        }\n        p = perm_product(p, p);\n        K = (K >> 1);\n    }\n\n    return r;\n}\n\nconst int MAX_N = 100050;\nint N;\nint K;\n\nstd::vector<int> func(const std::vector<int>& p, const std::vector<int>& q) {\n    assert(p.size() == q.size());\n    std::vector<int> ret;\n    ret.resize(p.size());\n\n    for (int i = 1; i <= N; i++) {\n        ret[p[i]] = q[i];\n    }\n\n    return ret;\n}\n\nstd::vector<int> ret[7];\n\nint main(int argc, char **argv) {\n    std::cin >> N >> K;\n\n    std::vector<int> p, q;\n    p.resize(N+1);\n    q.resize(N+1);\n\n    for (int i = 1; i <= N; i++) {\n        std::cin >> p[i];\n    }\n\n    for (int i = 1; i <= N; i++) {\n        std::cin >> q[i];\n    }\n\n    int pow_num = (K - 1) / 6;\n    std::vector<int> A = perm_product(perm_product(perm_trans(q), p), perm_product(q, perm_trans(p)));\n    std::vector<int> A_pow = perm_pow(A, pow_num);\n\n    ret[1] = perm_product(perm_product(A_pow, p), perm_trans(A_pow));\n    ret[2] = perm_product(perm_product(A_pow, q), perm_trans(A_pow));\n\n    for (int i = 3; i <= 6; i++) {\n        ret[i] = perm_product(perm_trans(ret[i-2]), ret[i-1]);\n    }\n\n    int id = (K % 6 == 0) ? 6 : K % 6;\n\n    for (int i = 1; i <= N; i++) {\n        std::cout << ret[id][i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstdlib>\n#include <utility>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstring>\n\nusing namespace std;\n\n#define ll long long\n\n#ifndef ONLINE_JUDGE\n#define debug(format, ...) fprintf(stderr, \\\n    \"%s:%d: \" format \"\\n\", __func__, __LINE__,##__VA_ARGS__)\n#else\n#define debug(format, ...)\n#define NDEBUG\n#endif\n\nint n, k;\n\nstruct Perm {\n    int* vals;\n};\n\nPerm operator*(Perm a, Perm b)\n{\n    Perm ans;\n    ans.vals = new int[n + 5];\n    for (int i = 1; i <= n; i++) {\n        ans.vals[i] = b.vals[a.vals[i]];\n    }\n    return ans;\n}\n\nPerm operator^(Perm a, int pwr)\n{\n    Perm ans;\n    ans.vals = new int[n + 5];\n    bool* vis = new bool[n + 5];\n    for (int i = 1; i <= n; i++) vis[i] = false;\n    for (int i = 1; i <= n; i++) {\n        if (vis[i]) continue;\n        vector<int> cycle;\n        int cur = i;\n        do {\n            vis[cur] = true; cycle.push_back(cur); cur = a.vals[cur];\n        } while (cur != i);\n        for (int x = 0; x < cycle.size(); x++) {\n            ans.vals[cycle[x]] = cycle[(x + pwr) % cycle.size()];\n        }\n    }\n    delete[] vis;\n    return ans;\n}\n\nPerm inv(Perm a)\n{\n    Perm ans;\n    ans.vals = new int[n + 5];\n    for (int i = 1; i <= n; i++) {\n        ans.vals[a.vals[i]] = i;\n    }\n    return ans;\n}\n\nPerm a[15];\n\nint main()\n{\n    scanf(\"%d%d\", &n, &k);\n    Perm p, q;\n    p.vals = new int[n + 5];\n    q.vals = new int[n + 5];\n    for (int i = 1; i <= n; i++) scanf(\"%d\", p.vals + i);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", q.vals + i);\n    Perm ans;\n    if (k < 6) {\n        a[1] = p; a[2] = q;\n        for (int i = 3; i <= k; i++) {\n            a[i] = inv(a[i-2]) * a[i-1];\n        }\n        ans = a[k];\n    } else {\n        Perm perm_x = p * q * inv(p) * inv(q);\n        Perm perm_y = q * p * inv(q) * inv(p);\n        int cnt = (k % 6 >= 4 ? k / 6 : (k / 6) - 1);\n        Perm middle;\n        if (k % 6 == 0) {\n            middle = p * p * inv(q) * inv(p);\n        } else if (k % 6 == 1) {\n            middle = p * q * p * inv(q) * inv(p);\n        } else if (k % 6 == 2) {\n            middle = p * q * inv(p) * q * p * inv(q) * inv(p);\n        } else if (k % 6 == 3) {\n            middle = p * q * inv(p) * inv(p) * q * p * inv(q) * inv(p);\n        } else if (k % 6 == 4) {\n            middle = inv(p);\n        } else {\n            middle = p * inv(q) * inv(p);\n        }\n        ans = inv(q) * (perm_x ^ cnt) * middle * (perm_y ^ cnt) * q;\n    }\n    for (int i = 1; i <= n; i++) {\n        printf(\"%d \", ans.vals[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nvector<int> bABa;\nvector<int> AbaB;\nvector<int> a;\nvector<int> b;\nvector<int> A;\nvector<int> B;\nll n;\n\nchar chenge(char c){\n\tif(isupper(c))return tolower(c);\n\telse return toupper(c);\n}\n\nstring rev(string str){\n\tstring ret = \"\";\n\tREP(i, str.size()){\n\t\tret += chenge(str[str.size() - i - 1]);\n\t}\n\treturn ret;\n}\n\nvoid test() {\n\tint n;cin >> n;\n\tstring a = \"a\";\n\tstring b = \"b\";\n\tcout << a << endl << b << endl;\n\tREP(i, n){\n\t\tstring A = rev(a);\t\n\t\tstring B = b;\n\t\twhile(A.size() > 0 && B.size() > 0 && chenge(A.front()) == B.back()){\n\t\t\tA.erase(A.begin());\n\t\t\tB.pop_back();\n\t\t}\n\t\ta = b;\n\t\tb = B + A;\n\t\tint pla = 0;\n\t\twhile(pla < b.size()-1-pla && b[pla] == chenge(b[b.size()-1-pla]))pla++;\n\t\tREP(j, b.size()){\n\t\t\tif(j == pla || j == b.size() - pla)cout << \" \";\n\t\t\tcout << b[j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvector<int> func(vector<int> p, vector<int> q){\n\tvector<int> ret(p.size());\n\tREP(i, p.size()){\n\t\tret[i] = p[q[i]];\n\t}\n\treturn ret;\n}\n\nvector<int> inverse(vector<int> v){\n\tvector<int> ret(v.size());\n\tREP(i, v.size()){\n\t\tret[v[i]] = i;\n\t}\n\treturn ret;\n}\n\nvoid out(vector<int> v){\n\tREP(i, v.size())cout << v[i] + 1 << \" \";cout << endl;\n}\n\nvector<int> make_x(ll n, ll k){\n\tll cou = k / 6;\n\tvector<int> ret(n);\n\tauto kake = bABa;\n\tREP(i, n)ret[i] = i;\n\tREP(i, 30){\n\t\tif(cou & (1 << i)){\n\t\t\tret = func(ret, kake);\n\t\t}\n\t\tkake = func(kake, kake);\n\t}\n\t\n\tint tmp = k % 6;\n\tif(tmp <= 0)return ret;\n\tret = func(ret, b);\n\tif(tmp <= 1)return ret;\n\tret = func(ret, A);\n\tif(tmp <= 3)return ret;\n\tret = func(ret, B);\n\tif(tmp <= 4)return ret;\n\tret = func(ret, a);\n\treturn ret;\n}\n\nvector<int> make_y(int k){\n\tint tmp = k % 6;\n\tswitch(tmp){\n\t\tcase 0:return func(b, A);\n\t\tcase 1:return A;\n\t\tcase 2:return B;\n\t\tcase 3:return func(B, a);\n\t\tcase 4:return a;\n\t\tcase 5:return b;\n\t}\n}\n\nint main(){\n\tll n, k;cin >> n >> k;\n\ta.resize(n);REP(i, n)cin >> a[i],a[i]--;\n\tb.resize(n);REP(i, n)cin >> b[i],b[i]--;\n\t\n\tif(k == 1){\n\t\tout(a);\n\t\treturn 0;\n\t}\n\tif(k == 2){\n\t\tout(b);\n\t\treturn 0;\n\t}\n\tk -= 3;\n\n\tA = inverse(a);\n\tB = inverse(b);\n\tbABa = func(func(func(b, A), B), a);\t\n\t\n\tauto x = make_x(n, k);\n\tauto y = make_y(k);\n\t\n\tout(func(func(x, y), inverse(x)));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\nvector<int> inv(const vector<int> &r){\n  vector<int> res(r.size(), 0);\n  rep(i, sz(r))res[r[i]] = i;\n  return res;\n}\n\nvector<int> comp(const vector<int> &a, const vector<int> &b){\n  vector<int> res(a.size(), 0);\n  rep(i, sz(a))res[i] = a[b[i]];\n  return res;\n}\n\nvector<int> db[34];\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  INT(n); LL(k);\n  vector<int> p(n), q(n); cin >> p >> q; rep(i, n)p[i]--, q[i]--;\n  vector<int> pi = inv(p), qi = inv(q);\n  if(k == 1){\n    rep(i, n)p[i]++;\n    cout << p << endl;\n    return 0;\n  }\n  db[0] = comp(q, comp(pi, comp(qi, p)));\n  FOR(i, 1, 33){\n    db[i] = comp(db[i-1], db[i-1]);\n  }\n  vector<int> A(n, 0); rep(i, n)A[i] = i;\n  ll tmp = (k - 1) / 6;\n  int ind = 0;\n  while(tmp){\n    if(tmp % 2 == 1){\n      A = comp(A, db[ind]);\n    }\n    ind++;\n    tmp /= 2;\n  }\n  int cnt = (k - 1) % 6;\n  if(cnt == 3)A = comp(A, q);\n  if(cnt == 4)A = comp(A, comp(q, pi));\n  if(cnt == 5)A = comp(A, comp(q, pi));\n  vector<int> B;\n  if(cnt == 0)B = p;\n  if(cnt == 1)B = q;\n  if(cnt == 2)B = comp(q, pi);\n  if(cnt == 3)B = pi;\n  if(cnt == 4)B = qi;\n  if(cnt == 5)B = comp(qi, p);\n  vector<int> res = comp(A, comp(B, inv(A)));\n  rep(i, n)res[i]++;\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Maxn 100007\nint n,k;\nint p[Maxn],q[Maxn];\nint a[Maxn],b[Maxn],tmp1[Maxn],tmp2[Maxn];\nint ans[Maxn],r[Maxn];\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&p[i]);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&q[i]);\n    if (k%6==1)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=p[i];\n    } else if (k%6==2)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=q[i];\n    } else if (k%6==3)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=q[i];\n    } else if (k%6==4)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=i;\n    } else if (k%6==5)\n    {\n        for (int i=1;i<=n;i++)\n            b[q[i]]=i;\n    } else\n    {\n        for (int i=1;i<=n;i++)\n            tmp2[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            b[i]=tmp2[p[i]];\n    }\n    for (int i=1;i<=n;i++)\n        ans[i]=i;\n    if (k>1)\n    {\n        --k;\n        int c=(k-1)/6;\n        k%=6;\n        for (int i=1;i<=n;i++)\n            tmp1[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            r[i]=p[tmp1[i]];\n        for (int i=1;i<=n;i++)\n            tmp1[i]=r[i];\n        for (int i=1;i<=n;i++)\n            r[i]=q[tmp1[i]];\n        for (int i=1;i<=n;i++)\n            tmp1[p[i]]=i;\n        for (int i=1;i<=n;i++)\n            tmp2[i]=r[i];\n        for (int i=1;i<=n;i++)\n            r[i]=tmp1[tmp2[i]];\n        while (c>0)\n        {\n            if (c%2==1)\n            {\n                for (int i=1;i<=n;i++)\n                    tmp2[i]=ans[i];\n                for (int i=1;i<=n;i++)\n                    ans[i]=r[tmp2[i]];\n            }\n            c/=2;\n            for (int i=1;i<=n;i++)\n                tmp1[i]=r[i];\n            for (int i=1;i<=n;i++)\n                r[i]=tmp1[tmp1[i]];\n        }\n        if (k%6==3)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                tmp2[i]=ans[i];\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[tmp2[i]];\n        } else if (k%6==4||k%6==5)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                tmp2[i]=ans[i];\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[tmp2[i]];\n            for (int i=1;i<=n;i++)\n                tmp2[i]=ans[i];\n            for (int i=1;i<=n;i++)\n                ans[i]=p[tmp2[i]];\n        } else if (k%6==0)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                tmp2[i]=ans[i];\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[tmp2[i]];\n            for (int i=1;i<=n;i++)\n                tmp2[i]=ans[i];\n            for (int i=1;i<=n;i++)\n                ans[i]=q[p[tmp2[i]]];\n        }\n    }\n    for (int i=1;i<=n;i++)\n        a[ans[i]]=i;\n    for (int i=1;i<=n;i++)\n        tmp2[i]=ans[i];\n    for (int i=1;i<=n;i++)\n        ans[i]=b[tmp2[i]];\n    for (int i=1;i<=n;i++)\n        tmp2[i]=ans[i];\n    for (int i=1;i<=n;i++)\n        ans[i]=a[tmp2[i]];\n    for (int i=1;i<=n;i++)\n        printf(\"%d \",ans[i]);\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Maxn 100007\nint n,k;\nint p[Maxn],q[Maxn];\nint a[Maxn],b[Maxn],tmp1[Maxn],tmp2[Maxn];\nint ans[Maxn],r[Maxn];\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&p[i]);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&q[i]);\n    if (k%6==1)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=p[i];\n    } else if (k%6==2)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=q[i];\n    } else if (k%6==3)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=q[i];\n    } else if (k%6==4)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=i;\n    } else if (k%6==5)\n    {\n        for (int i=1;i<=n;i++)\n            b[q[i]]=i;\n    } else\n    {\n        for (int i=1;i<=n;i++)\n            tmp2[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            b[i]=tmp2[p[i]];\n    }\n    for (int i=1;i<=n;i++)\n        ans[i]=i;\n    if (k>1)\n    {\n        --k;\n        int c=k/6;\n        k%=6;\n        for (int i=1;i<=n;i++)\n            tmp1[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            r[i]=p[tmp1[i]];\n        for (int i=1;i<=n;i++)\n            tmp1[i]=r[i];\n        for (int i=1;i<=n;i++)\n            r[i]=q[tmp1[i]];\n        for (int i=1;i<=n;i++)\n            tmp1[p[i]]=i;\n        for (int i=1;i<=n;i++)\n            tmp2[i]=r[i];\n        for (int i=1;i<=n;i++)\n            r[i]=tmp1[tmp2[i]];\n        while (c>0)\n        {\n            if (c%2==1)\n            {\n                for (int i=1;i<=n;i++)\n                    tmp2[i]=ans[i];\n                for (int i=1;i<=n;i++)\n                    ans[i]=r[tmp2[i]];\n            }\n            c/=2;\n            for (int i=1;i<=n;i++)\n                tmp1[i]=r[i];\n            for (int i=1;i<=n;i++)\n                r[i]=tmp1[tmp1[i]];\n        }\n        if (k%6==3)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[ans[i]];\n        } else if (k%6==4||k%6==5)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[ans[i]];\n            for (int i=1;i<=n;i++)\n                ans[i]=p[ans[i]];\n        } else if (k%6==0)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[ans[i]];\n            for (int i=1;i<=n;i++)\n                ans[i]=q[p[ans[i]]];\n        }\n    }\n    for (int i=1;i<=n;i++)\n        a[ans[i]]=i;\n    for (int i=1;i<=n;i++)\n        ans[i]=b[ans[i]];\n    for (int i=1;i<=n;i++)\n        ans[i]=a[ans[i]];\n    for (int i=1;i<=n;i++)\n        printf(\"%d \",ans[i]);\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <set>\n#include <utility>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cmath>\n#include <deque>\n#include <bitset>\n#define ll long long\n#define PI 3.1415926535897932384626433832795\n#define read(x) scanf(\"%d\",&x);\n#define readll(x) cin>>x;\n#define FOR(x,a,b) for(int x=a;x<b;x++)\n#define MP make_pair\n#define PB push_back\n#define pii pair<int,int>\n#define readN(N,X) for(int i=0;i<N;i++) cin>>X[i];\n#define pff pair<double,double>\n#define MOD 1000000007\n\nusing namespace std;\nint N, A, B;\nbool vis[300000];\nint cnt;\nvector<int> res;\nint offset = 0;\n\nvoid dfs(int pos){\n  //if (vis[pos]) return;\n  res.PB(pos);\n  vis[pos] = 1;\n  cnt++;\n  for (int i=1;i < N; i++) {\n    int mask = (1<<( (i + offset) % N) );\n    int u = pos ^ mask;\n    if (vis[u] == false) {\n      dfs(u);\n      break;\n    }\n  }\n}\n\nint main(){\n  std::ios::sync_with_stdio(false); \n  cin>>N>>A>>B;\n  vis[B] = 1;\n\n  int diff = 0;\n  for (int i=0;i < N; i++) {\n    if ((A & (1<<i)) != (B & (1<<i)) ) {\n      diff++;\n      offset = i;\n    }\n  }\n\n  if (diff != 1) {\n   cout<<\"NO\"<<endl;\n  }\n\n\n  dfs(A);\n  \n   cout<<\"YES\"<<endl;\n   for (int x:res) cout<<x<<\" \";\n   reverse(res.begin(), res.end());\n   for (int x:res) {\n      if (x != A)\n        cout<<(x ^ (1<<offset))<<\" \";\n   }\n\n      cout<<B<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nnamespace ProjectPermy\n{\n\tstruct perm\n\t{\n\t\tvector<int>v;\n\t\tint &operator[](int x){return v[x];}\n\t\tconst int &operator[](int x)const{return v[x];}\n\t\tint size()const{return v.size()-1;}\n\t\tvoid resize(int n){v.resize(n+1);}\n\t\tvoid read(int n){v.resize(n+1);for(int i=1;i<=size();i++)scanf(\"%d\",&v[i]);}\n\t\tvoid out()\n\t\t{\n\t\t\tfor(int i=1;i<=size();i++)\n\t\t\t\tprintf(\"%d \",v[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t};\n\tperm e(int n)\n\t{\n\t\tperm ans;\n\t\tans.resize(n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans[i]=i;\n\t\treturn ans;\n\t}\n\tperm operator*(perm a,perm b)\n\t{\n\t\tperm ans=e(a.size());\n\t\tperm rev=e(a.size());\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t\tans[i]=a[b[i]];\n\t\treturn ans;\n\t}\n\tperm operator~(perm a)\n\t{\n\t\tperm ans=e(a.size());\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t\tans[a[i]]=i;\n\t\treturn ans;\n\t}\n\tvector<int>vis,rem;\n\tperm operate;\n\tvoid find_cycle(int x)\n\t{\n\t\tif(vis[x]) return;\n\t\tvis[x]=1;\n\t\trem.push_back(x);\n\t\tfind_cycle(operate[x]);\n\t}\n\tperm Pow(perm a,int x)\n\t{\n\t\tperm ans=e(a.size());\n\t\tvector<vector<int> >cycle;\n\t\tvis.clear();\n\t\tvis.resize(a.size()+1);\n\t\toperate=a;\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t{\n\t\t\tif(!vis[i])\n\t\t\t{\n\t\t\t\trem.clear();\n\t\t\t\tfind_cycle(i);\n\t\t\t\tcycle.push_back(rem);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<cycle.size();i++)\n\t\t{\n\t\t\tfor(int j=0;j<cycle[i].size();j++)\n\t\t\t\tans[cycle[i][j]]=cycle[i][(j+x)%cycle[i].size()];\n\t\t}\n\t\treturn ans;\n\t}\n}\nusing namespace ProjectPermy;\nsigned main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tperm p,q;\n\tp.read(n);\n\tq.read(n);\n\tperm a[7];\n\ta[1]=p;\n\ta[2]=q;\n\tfor(int i=3;i<=6;i++)\n\t\ta[i]=a[i-1]*(~a[i-2]);\n\tif(m<=6)\n\t{\n\t\ta[m].out();\n\t\treturn 0;\n\t}\n\tperm g=q*(~p)*(~q)*p;\n\t(Pow(g,(m-1)/6)*a[(m-1)%6+1]*Pow(~g,(m-1)/6)).out();\n\treturn 0;\n}\n/*\n5\n2 4 3 1 5\n2 4 3 1 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint gi(){\n\tint x=0,w=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')w=0,ch=getchar();\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\n#define vi vector<int>\nint n,k;vi a[7];\nvi readin(){\n\tvi res(n);\n\tfor(int i=0;i<n;++i)res[i]=gi()-1;\n\treturn res;\n}\nvoid print(vi a){\n\tfor(int i=0;i<n;++i)printf(\"%d \",a[i]+1);\n\tputs(\"\");\n}\nvi inv(vi a){\n\tvi res(n);\n\tfor(int i=0;i<n;++i)res[a[i]]=i;\n\treturn res;\n}\nvi mul(vi a,vi b){\n\tvi res(n);\n\tfor(int i=0;i<n;++i)res[i]=a[b[i]];\n\treturn res;\n}\nvi fastpow(vi a,int b){\n\tvi res(n);\n\tfor(int i=0;i<n;++i)res[i]=i;\n\twhile(b){if(b&1)res=mul(res,a);a=mul(a,a);b>>=1;}\n\treturn res;\n}\nint main(){\n\tn=gi();k=gi();\n\tvi p=readin(),q=readin();\n\ta[1]=p;a[2]=q;\n\tfor(int i=3;i<=6;++i)a[i]=mul(a[i-1],inv(a[i-2]));\n\tvi A=mul(mul(q,inv(p)),mul(inv(q),p)),B=fastpow(A,(k-1)/6);\n\tprint(mul(mul(B,a[(k-1)%6+1]),inv(B)));return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, K;\n    cin >> N >> K;\n    ll p[N], q[N];\n    ll base[N], next[N];\n    REP(i, 0, N) {\n        cin >> p[i];\n        base[i] = p[i];\n    }\n    REP(i, 0, N) {\n        cin >> q[i];\n        next[i] = q[i];\n    }\n    ll ind = 0;\n    while(1) {\n        ind++;\n        ll tmp[N];\n        REP(i, 0, N) {\n            tmp[base[i] - 1] = next[i];\n        }\n        REP(i, 0, N) {\n            base[i] = next[i];\n            next[i] = tmp[i];\n        }\n        bool ok = true;\n        REP(i, 0, N) {\n            if (p[i] != base[i] || q[i] != next[i]) {\n                ok = false;\n            }\n        }\n        if (ok) {\n            break;\n        }\n    }\n    ll nums[ind][N];\n    REP(i, 0, N) {\n        nums[0][i] = p[i];\n        nums[1][i] = q[i];\n    }\n    REP(i, 2, ind + 2) {\n        REP(j, 0, N) {\n            nums[i][nums[i - 2][j] - 1] = nums[i - 1][j];\n        }\n    }\n    // cout << ind << endl;\n    // REP(i, 0, ind + 2) {\n    //     REP(j, 0, N) {\n    //         cout << nums[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    ll rem = (K - 1) % ind;\n    REP(i, 0, N) {\n        cout << nums[rem][i];\n        if (i != N - 1) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n;\nvector<ll> ret;\n\n\n\nvoid cul(vector<ll> &ret,const vector<ll> &A,const vector<ll> &B){\n    for(int i=0;i<n;i++){ret[i]=B[A[i]];}\n}\n\nvoid rev(vector<ll> &ret,vector<ll> A){\n    for(int i=0;i<n;i++){ret[A[i]]=i;}\n}\n\nvoid Out(vector<ll> ans){\n    for(int i=0;i+1<n;i++){cout<<ans[i]+1<<\" \";}\n    cout<<ans.back()+1<<endl;\n}\n\nvector<ll> operator * (const vector<ll> &A,const vector<ll> &B){cul(ret,A,B); return ret;}\n\nvector<ll> & operator *= (vector<ll> &A,const vector<ll> &B){cul(ret,A,B); return A=ret;}\n\nvector<ll> & operator /= (vector<ll> &A,const vector<ll> &B){cul(ret,B,A); return A=ret;}\n\n\nint main(){\n    ll k;\n    cin>>n>>k;\n    vector<ll> P(n);\n    vector<ll> Q(n);\n    for(auto &I:P){cin>>I; I--;}\n    for(auto &I:Q){cin>>I; I--;}\n    \n    ret.resize(n);\n    vector<ll> PI(n);\n    vector<ll> QI(n);\n    rev(PI,P);\n    rev(QI,Q);\n    vector<ll> O=P*QI*PI*Q;\n    vector<ll> A(n);\n    for(int i=0;i<n;i++){A[i]=i;}\n    \n    if(k==1){\n        Out(P);\n        return 0;\n    }\n    else if(k==2){\n        Out(Q);\n        return 0;\n    }\n    else if(k==3){\n        Out(PI*Q);\n        return 0;\n    }\n    \n    if(k<=100){\n        for(int i=3;i<=k;i++){\n            rev(P,P);\n            P*=Q;\n            swap(P,Q);\n        }\n        Out(Q);\n    }\n    \n    k-=3;\n    ll Z=k/6;\n    while(Z>0){\n        if(Z&1){A*=O;}\n        Z>>=1;\n        O*=O;\n    }\n    \n    if(k%6){A/=Q;}\n    if(k%6>1){A/=PI;}\n    if(k%6>3){A/=QI;}\n    if(k%6==5){A/=P;}\n    \n    rev(O,A);\n    \n    if(k%3==1){\n        QI=PI;\n    }\n    else if(k%3==2){\n        QI=QI;\n    }\n    else{\n        cul(QI,PI,Q);\n    }\n    if((k/3)&1){rev(QI,QI);}\n    O*=QI;\n    O*=A;\n    Out(O);\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint read();\n\nint n, k;\nint p[200005], q[200005];\nint bs[200005], rt[200005];\nvoid init(int *a) {\n    for (int i = 1; i <= n; ++i) a[i] = i;\n}\n\nint tmp[200005];\nvoid pm(int *s, int *p) {\n    for (int i = 1; i <= n; ++i) tmp[i] = s[p[i]];\n    memcpy(s + 1, tmp + 1, n << 2);\n}\nvoid ip(int *s, int *p) {\n    for (int i = 1; i <= n; ++i) tmp[p[i]] = s[i];\n    memcpy(s + 1, tmp + 1, n << 2);\n}\n\nint f[10][200005];\nvoid fsp(int p) {\n    while (p) (p & 1) ? pm(rt, bs) : void(), pm(bs, bs), p >>= 1;\n}\n\nvoid prt(int *p) {\n    for (int i = 1; i <= n; ++i) printf(\"%d \", p[i]);\n    puts(\"\");\n}\nint main() {\n    n = read(), k = read(), init(bs), init(rt);\n    for (int i = 1; i <= n; ++i) p[i] = read();\n    for (int i = 1; i <= n; ++i) q[i] = read();\n    pm(bs, q), ip(bs, p), ip(bs, q), pm(bs, p), fsp((k - 1) / 6);\n\n    memcpy(f[1] + 1, rt + 1, n << 2), memcpy(f[2] + 1, rt + 1, n << 2);\n    int tk = (k - 1) % 6 + 1;\n    pm(f[1], p), ip(f[1], rt), pm(f[2], q), ip(f[2], rt);\n\n    if (tk <= 2) return prt(f[tk]), 0;\n    for (int i = 3; i <= tk; ++i)\n        memcpy(f[i] + 1, f[i - 1] + 1, n << 2), ip(f[i], f[i - 2]);\n    return prt(f[tk]), 0;\n}\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();\n    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') { if (ch == '-') bo = -1; ch = getchar(); }\n\twhile(ch >= '0' && ch <= '9') { res = (res << 1) + (res << 3) + ch - '0'; ch = getchar(); }\n\treturn bo * res;\n}\n\ntemplate<typename T> void read(T &x) { x = read(); }\ntemplate<typename T, typename ...Argv> void read(T &a, Argv &...argv) { read(a); read(argv...); }\n\nstd::vector<int> a[6], A;\nint n, k;\n\nstd::vector<int> operator * (const std::vector<int> &a, const std::vector<int> &b) {\n\tstd::vector<int> res(n);\n\tfor (int i = 0; i < n; ++ i) res[i] = a[b[i]];\n\treturn res;\n}\n\nstd::vector<int> inv(const std::vector<int> &a) {\n\tstd::vector<int> res(n);\n\tfor (int i = 0; i < n; ++ i) res[a[i]] = i;\n\treturn res;\n}\n\nstd::vector<int> ksm(std::vector<int> x, int y) {\n\tstd::vector<int> res(n);\n\tfor (int i = 0; i < n; ++ i) res[i] = i;\n\tfor (; y; y >>= 1, x = x * x) if (y & 1) res = res * x;\n\treturn res;\n}\n\nint main() {\n\t// freopen(\"a.in\", \"r\", stdin);\n\tn = read(), k = read() - 1; a[1].resize(n); a[0].resize(n);\n\tfor (int i = 0; i < n; ++ i) a[0][i] = read() - 1;\n\tfor (int i = 0; i < n; ++ i) a[1][i] = read() - 1;\n\tfor (int i = 2; i < 6; ++ i) a[i] = a[i - 1] * inv(a[i - 2]);\n\tif (k < 6) { for (int i = 0; i < n; ++ i) printf(\"%d \", a[k][i] + 1); puts(\"\"); return 0; }\n\tA = ksm((a[1] * inv(a[0])) * (inv(a[1]) * a[0]), k / 6);\n\tA = A * a[k % 6] * inv(A);;\n\tfor (int i = 0; i < n; ++ i) printf(\"%d \", A[i] + 1); puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\nusing namespace std;\ninline int read(){int w=1,s=0;char ch=getchar();while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}return w*s;}\nint n,K;\nvector<int> A[7];\nvector<int> tmp;\ninline vector<int> getInv(vector<int> x)\n{\n\tvector<int> res;\n\tfor(rint i=1;i<=n;++i) res.pb(0);\n\tfor(rint i=0;i<n;++i) res[x[i]]=i;\n\treturn res;\n}\ninline vector<int> Mul(vector<int> p,vector<int> q)\n{\n\tvector<int> res;\n\tfor(rint i=0;i<n;++i) res.pb(p[q[i]]);\n\treturn res;\n}\ninline vector<int> ksm(vector<int> x,int y)\n{\n\tvector<int> res;\n\tfor(rint i=0;i<n;++i) res.pb(i);\n\twhile(y)\n\t{\n \t\tif(y&1)res=Mul(res,x);\n \t\tx=Mul(x,x);y>>=1;\n\t}return res;\n}\nint main()\n{\t\n\tn=read();K=read();\n\tfor(rint i=1;i<=n;++i) {int x=read()-1;A[1].pb(x);}\n\tfor(rint i=1;i<=n;++i) {int x=read()-1;A[2].pb(x);}\n\tfor(rint i=3;i<=6;++i)\n\t\tA[i]=Mul(A[i-1],getInv(A[i-2]));\n\ttmp=Mul(Mul(A[2],getInv(A[1])),Mul(getInv(A[2]),A[1]));\n\tvector<int> res=ksm(tmp,(K-1)/6);\n\tres=Mul(Mul(res,A[(K-1)%6+1]),getInv(res));\n\tfor(rint i=0;i<n;++i) cout<<res[i]+1<<\" \";\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <chrono>\n#include <ctime>\n#include <bitset>\n#include <iterator>\n#include <cmath>\n#include <stack>\n#include <random>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nvector<ll> mat_mul2(int n, vector<ll>& a, vector<ll>& b) {\n  vector<ll> ret(n+1);\n  for(int i=1; i<=n; i++) {\n    ret[i] = a[b[i]];\n  }\n  return ret;\n}\n\nvector<ll> mat_pow2(vector<ll> mat, int n, int size) {\n  vector<ll> res(size+1);\n  vector<ll> a = mat;\n  for(int i=1; i<=size; i++) {\n    res[i] = i;\n  }\n  while(n > 0) {\n    if (n&1) {\n      res = mat_mul2(size, res, a);\n    }\n    a = mat_mul2(size, a, a); n >>= 1;\n  }\n  return res;\n}\n\nvector<ll> mat_inv(vector<ll>& a, int n) {\n  vector<ll> ret(n+1);\n  for(int i=1; i<=n; i++) {\n    ret[a[i]] = i;\n  }\n  return ret;\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, k; cin >> n >> k;\n  vector<ll> p(n+1);\n  vector<ll> q(n+1);\n  vector<ll> ip(n+1);\n  vector<ll> iq(n+1);\n\n  for(int i=1; i<=n; i++) {\n    cin >> p[i];\n    ip[p[i]] = i;\n  }\n  for(int i=1; i<=n; i++) {\n    cin >> q[i];\n    iq[q[i]] = i;\n  }\n\n  k--;\n  vector<ll> A;\n  A = mat_mul2(n, q, ip);\n  A = mat_mul2(n, A, iq);\n  A = mat_mul2(n, A, p);\n\n  A = mat_pow2(A, k/6, n);\n  k = k%6;\n\n  vector<ll> IA(n+1);\n  for(int i=1; i<=n; i++) {\n    IA[A[i]] = i;\n  }\n\n  vector<ll> ans;\n  if (k==0) {\n    ans = p;\n  } else if (k==1) {\n    ans = q;\n  } else {\n    k--;\n    while(k--) {\n      p = mat_inv(p, n);\n      ans = mat_mul2(n, q, p);\n      p = q;\n      q = ans;\n    }\n  }\n\n  ans = mat_mul2(n, A, ans);\n  ans = mat_mul2(n, ans, IA);\n\n  for(int i=1; i<=n; i++) {\n    cout << ans[i] << ' ';\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<random>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, K;\nint P[100011], Q[100011];\n\nint buf[100011];\nint idx[100011];\nint cur[100011];\nvoid go(int *a, char c) {\n    if (c == 'p') {\n\tREP (i, N) buf[i] = a[P[i]];\n    } else if (c == 'q') {\n\tREP (i, N) buf[i] = a[Q[i]];\n    } else if (c == 'P') {\n\tREP (i, N) buf[P[i]] = a[i];\n    } else {\n\tREP (i, N) buf[Q[i]] = a[i];\n    }\n    REP (i, N) a[i] = buf[i];\n}\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &K);\n    REP (i, N) scanf(\"%d\", P+i), P[i]--;\n    REP (i, N) scanf(\"%d\", Q+i), Q[i]--;\n\n    if (K == 1) {\n\tREP (i, N) idx[i] = P[i];\n    } else if (K == 2) {\n\tREP (i, N) idx[i] = Q[i];\n    } else {\n\tint len = K - 3 + (K-2) / 3;\n\tint m = len % 8;\n\tint r = len / 8;\n\tREP (i, N) idx[i] = i;\n\tgo(idx, 'q');\n\tgo(idx, 'P');\n\n\tREP (i, N) cur[i] = i;\n\tgo(cur, 'Q');\n\tgo(cur, 'p');\n\tgo(cur, 'q');\n\tgo(cur, 'P');\n\n\tfor (int k=r; k; k>>=1) {\n\t    if (k & 1) {\n\t\tREP (i, N) buf[i] = idx[cur[i]];\n\t\tREP (i, N) idx[i] = buf[i];\n\t    }\n\t    REP (i, N) buf[i] = cur[cur[i]];\n\t    REP (i, N) cur[i] = buf[i];\n\t}\n\n\tstring z;\n\t// PqpQPqpQ\n\tREP (i, m/2) {\n\t    z.push_back(\"QpqP\"[i]);\n\t    go(idx, \"QpqP\"[i]);\n\t}\n\tif (m % 2) {\n\t    go(idx, \"QpqP\"[m/2]);\n\t}\n\treverse(z.begin(), z.end());\n\tREP (i, m/2) {\n\t    go(idx, z[i]);\n\t}\n\t\n\tREP (i, N) cur[i] = i;\n\tgo(cur, 'P');\n\tgo(cur, 'q');\n\tgo(cur, 'p');\n\tgo(cur, 'Q');\n\n\tfor (int k=r; k; k>>=1) {\n\t    if (k & 1) {\n\t\tREP (i, N) buf[i] = idx[cur[i]];\n\t\tREP (i, N) idx[i] = buf[i];\n\t    }\n\t    REP (i, N) buf[i] = cur[cur[i]];\n\t    REP (i, N) cur[i] = buf[i];\n\t}\n    }\n\n    REP (i, N) idx[i]++;\n    rprintf(\"%d\", idx, idx+N);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long LL;\nconst int N = 6e3+10;\ninline int read()\n{\n\tregister int x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n;\nint pa[N] , pb[N] , id[N] , nx[N];\nstring s , f[N];\nint main()\n{\n\tcin >> n; cin >> s; s = \" \" + s;\n\tint cnta = 0 , cntb = 0;\n\tfor(int i = 1 ; i <= n * 2 ; ++i)\n\t\tif(s[i] == 'a') pa[id[i] = ++cnta] = i; else pb[id[i] = ++cntb] = i;\n\tpa[n + 1] = pb[n + 1] = 2 * n + 1; id[n * 2 + 1] = n + 1;\n\tfor(int i = 1 , j = 0 ; i <= n + 1 ; ++i)\n\t\twhile(j < min(pa[i] , pb[i])) nx[++j] = i;\n\tfor(int i = n ; i >= 1 ; --i)\n\t{\n\t\tif(pb[i] < pa[i])\n\t\t{\n\t\t\tint j = pb[i];\n\t\t\tfor( ; pb[id[j]] < pa[id[j]] && (id[j] <= i || pa[id[j] - 1] > pb[id[j]]) ; ++j)\n\t\t\t\tif(id[j] >= i) f[i] += s[j];\n\t\t\tf[i] += f[id[j]];\n\t\t}\n\t\telse\n\t\tf[i] = \"ab\" + f[nx[pb[i] + 1]];\n\t\tf[i] = max(f[i] , f[i + 1]);\n\t}\n\tcout << f[1] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <complex>\n#define pb push_back\n#define pll pair <ll, ll>\n#define MOMI using namespace std;\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#pragma optimize(\"TKACHENKO-GORYACHENKO\")\n#pragma GCC optimize(\"O3\")\n\n//#pragma GCC optimize(\"unroll-loops\")\n//#define double long double\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e5;\n\nll n, m, k;\n\nvector <ll> ID;\n\nvoid vivod(vector <ll> V){\n    ll q;\n    for (q = 0; q < V.size(); q++){\n        cout << V[q] << \" \";\n    }\n    cout << endl << endl;\n}\n\nvector <ll> mul(vector <ll> A, vector <ll> B){\n    vector <ll> ANS;\n    ANS.resize(A.size());\n    ll q;\n    for (q = 0; q < A.size(); q++){\n        ANS[q] = A[B[q]];\n    }\n    return ANS;\n}\n\nvector <ll> rev(vector <ll> A){\n    vector <ll> ANS;\n    ANS.resize(A.size());\n    ll q;\n    for (q = 0; q < A.size(); q++){\n        ANS[A[q]] = q;\n    }\n    return ANS;\n}\n\nvector <ll> step(vector <ll> A, ll x){\n    if (x == 0){\n        return ID;\n    }\n    if (x % 2 == 1){\n        return mul(step(A, x - 1), A);\n    }\n    vector <ll> T = step(A, x / 2);\n    return mul(T, T);\n}\n\nint main(){\n    ll q, w, e, t, a, b, c;\n    cin >> n >> k;\n    vector <ll> P, Q;\n    ID.resize(n);\n    for (q = 0; q < n; q++){\n        ID[q] = q;\n    }\n    P.resize(n); Q.resize(n);\n    for (q = 0; q < n; q++){\n        cin >> P[q];\n        P[q]--;\n    }\n    for (q = 0; q < n; q++){\n        cin >> Q[q];\n        Q[q]--;\n    }\n    k--;\n//    vivod(P);vivod(Q);\n    vector <ll> W = mul(mul(Q, rev(P)), mul(rev(Q), P));\n//    vivod(W);\n//    vector <ll> A = mul(mul(P, step(W, (k) / 6)), rev(P)); /// 0, 6, 12, 18, 24\n//    vector <ll> B = mul(mul(Q, step(W, (k) / 6)), rev(Q)); /// 1, 7, 13, 19, 25;\n    vector <ll> A = mul(step(W, (k) / 6), mul(P, rev(step(W, k / 6))));\n    vector <ll> B = mul(step(W, (k) / 6), mul(Q, rev(step(W, k / 6))));\n//    cout << \"A \" << endl; vivod(A);\n//    cout << \"B \" << endl; vivod(B);\n    if (k % 6 == 0){\n        for (q = 0; q < n; q++){\n            cout << A[q] + 1 << \" \";\n        }\n        return 0;\n    }\n    ll i = (k / 6) * 6 + 1;\n    for (;i < k; i++){\n        vector <ll> C;\n        C.resize(n);\n        for (q = 0; q < n; q++){\n            C[A[q]] = B[q];\n        }\n//        vivod(C);\n        A = B;\n        B = C;\n    }\n    for (q = 0; q < n; q++){\n        cout << B[q] + 1 << \" \";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a != 0 ? gcd (b % a, a) : b; }\n\nconst int N = 100000;\n\nint n;\nint m;\nint p[N];\nint q[N];\nint pp[N];\nint qq[N];\nint e[N];\nint h[N];\nint g[N];\n\nint main () {\n\tscanf (\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf (\"%d\", &p[i]);\n\t\tp[i]--; \n\t\tpp[p[i]] = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf (\"%d\", &q[i]);\n\t\tq[i]--; \n\t\tqq[q[i]] = i;\n\t}\n\tif (m == 1) {\n\t\tfor (int i = 0; i < n; i++) e[i] = p[i];\n\t} else {\n\t\tfor (int i = 0; i < n; i++) e[i] = i;\n\n\t\tfor (int i = 0; i < n; i++) g[i] = q[pp[qq[p[i]]]];\n\t\tint k = (m + 1) / 6;\n\t\twhile (k) {\n\t\t\tif (k & 1) {\n\t\t\t\tfor (int i = 0; i < n; i++) h[i] = e[g[i]];\n\t\t\t\tfor (int i = 0; i < n; i++) e[i] = h[i];\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) h[i] = g[g[i]];\n\t\t\tfor (int i = 0; i < n; i++) g[i] = h[i];\n\t\t\tk /= 2;\n\t\t}\n//\t\tfor (int i = 0; i < n; i++) printf (\"%d \", e[i] + 1);\n//\t\tprintf (\"\\n\");\n/*  2: (-2, 1, 2, -1) x   0 |  2 | (1, -2, -1, 2) x   0\n  3: (-2, 1, 2, -1) x   0 | -1  2 | (1, -2, -1, 2) x   0\n  4: (-2, 1, 2, -1) x   0 | -2 -1  2 | (1, -2, -1, 2) x   0\n  5: (-2, 1, 2, -1) x   0 | -2 | (1, -2, -1, 2) x   1\n  6: (-2, 1, 2, -1) x   0 | -2  1 | (1, -2, -1, 2) x   1\n  7: (-2, 1, 2, -1) x   0 | -2  1  2 | (1, -2, -1, 2) x   1*/\n\n\t\tif (m % 6 == 2) {\n\t\t\tfor (int i = 0; i < n; i++) g[i] = q[i];\n\t\t} else\n\t\tif (m % 6 == 3) {\n\t\t\tfor (int i = 0; i < n; i++) g[i] = q[pp[i]];\n\t\t} else\n\t\tif (m % 6 == 4) {\n\t\t\tfor (int i = 0; i < n; i++) g[i] = q[pp[qq[i]]];\n\t\t} else\n\t\tif (m % 6 == 5) {\n\t\t\tfor (int i = 0; i < n; i++) g[i] = qq[i];\n\t\t} else\n\t\tif (m % 6 == 0) {\n\t\t\tfor (int i = 0; i < n; i++) g[i] = p[qq[i]];\n\t\t} else\n\t\tif (m % 6 == 1) {\n\t\t\tfor (int i = 0; i < n; i++) g[i] = q[p[qq[i]]];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) h[i] = e[g[i]];\n\t\tfor (int i = 0; i < n; i++) e[i] = h[i];\n//\t\tfor (int i = 0; i < n; i++) printf (\"%d \", e[i] + 1);\n//\t\tprintf (\"\\n\");\n//\t\tfor (int i = 0; i < n; i++) printf (\"%d %d\\n\", e[i] + 1, g[i] + 1);\n\n\t\tfor (int i = 0; i < n; i++) g[i] = pp[q[p[qq[i]]]];\n\t\tk = (m - 2) / 6;\n\t\twhile (k) {\n\t\t\tif (k & 1) {\n\t\t\t\tfor (int i = 0; i < n; i++) h[i] = e[g[i]];\n\t\t\t\tfor (int i = 0; i < n; i++) e[i] = h[i];\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) h[i] = g[g[i]];\n\t\t\tfor (int i = 0; i < n; i++) g[i] = h[i];\n\t\t\tk /= 2;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) printf (\"%d \", e[i] + 1);\n\tprintf (\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> p, q;\nvector<int> inv (vector<int>a) {\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[a[i]] = i;\n  }\n  return ret;\n}\nvector<int> cmp (vector<int>a, vector<int> b) {\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[i] = a[b[i]];\n  }\n  return ret;\n}\nvector<int> make (string s) {\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[i] = i;\n  }\n  for (char c : s) {\n    if (c == 'p') ret = cmp(ret, p);\n    else if (c == 'q') ret = cmp(ret, q);\n    else if (c == 'P') ret = cmp(ret, inv(p));\n    else if (c == 'Q') ret = cmp(ret, inv(q));\n  }\n  return ret;\n}\nvector<int> pow (vector<int>a, int k) {\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[i] = i;\n  }\n  while (k) {\n    if (k & 1) {\n      ret = cmp(ret, a);\n    }\n    a = cmp(a, a);\n    k >>= 1;\n  }\n  return ret;\n}\nint main() {\n  int k;\n  cin >> n >> k;\n  p.resize(n);\n  q.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    p[i]--;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> q[i];\n    q[i]--;\n  }\n  k -= 2;\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[i] = i;\n  }\n  string rsd[6] = {\"q\", \"qP\", \"qPQ\", \"Q\", \"pQ\", \"qpQ\"};\n  int q = k / 6;\n  int r = k % 6;\n  ret = cmp(ret, pow(make(\"qPQp\"), q + r / 3));\n  ret = cmp(ret, make(rsd[r]));\n  ret = cmp(ret, pow(make(\"PqpQ\"), q));\n  for (int i = 0; i < n; i++) {\n    ret[i]++;\n  }\n  for (int i = 0; i < n; i++) {\n    cout << ret[i];\n    if (i < n - 1) {\n      cout << ' ';\n    } else {\n      cout << '\\n';\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=100005;\nint p[N],q[N],P[N],Q[N];\nint a[N],A[N],n,k;\nint b[N],c[N],d[N];\nvoid power(int *a,int y){\n\tFor(i,1,n) b[i]=i;\n\tfor (;y;){\n\t\tif (y&1){\n\t\t\tFor(i,1,n) c[i]=b[a[i]];\n\t\t\tFor(i,1,n) b[i]=c[i];\n\t\t}\n\t\tif (y/=2){\n\t\t\tFor(i,1,n) c[i]=a[a[i]];\n\t\t\tFor(i,1,n) a[i]=c[i];\n\t\t}\n\t}\n\tFor(i,1,n) a[i]=b[i];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tFor(i,1,n) scanf(\"%d\",&p[i]),P[p[i]]=i;\n\tFor(i,1,n) scanf(\"%d\",&q[i]),Q[q[i]]=i;\n\tFor(i,1,n) a[i]=q[P[Q[p[i]]]],A[a[i]]=i;\n\tint T=(k-1)/6; k-=T*6;\n\tpower(a,T); power(A,T);\n\tFor(i,1,n) b[i]=a[p[A[i]]];\n\tFor(i,1,n) c[i]=a[q[A[i]]];\n\tfor (;k>=2;k--){\n\t\tFor(i,1,n) d[b[i]]=c[i];\n\t\tFor(i,1,n) b[i]=c[i],c[i]=d[i];\n\t}\n\tif (k==2) For(i,1,n) b[i]=c[i];\n\tFor(i,1,n) printf(\"%d \",b[i]);\n}\n/*\np\nq\nqP\nqPQ\nqPQpQ\nqPQpQqpQ\nqPQppPqpQ\nqPQpqPqpQ\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint n,K;\nstruct pe{\n\tint A[100001];\n\tint&operator[](int x){return A[x];}\n}p,q,mid,g;\npe operator*(pe A,pe B){\n\tpe c;for(int i=1;i<=n;++i)c[i]=A[B[i]];\n\treturn c;\n}\npe operator~(pe A){\n\tpe c;for(int i=1;i<=n;++i)c[A[i]]=i;\n\treturn c;\n}\npe operator^(pe A,int b){\n\tpe c;for(int i=1;i<=n;++i)c[i]=i;\n\twhile(b){\n\t\tif(b&1)c=c*A;\n\t\tA=A*A;b>>=1;\n\t}\n\treturn c;\n}\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tn=gi(),K=gi();\n\tfor(int i=1;i<=n;++i)p[i]=gi();\n\tfor(int i=1;i<=n;++i)q[i]=gi();\n\tif(K==-1){for(int i=1;i<=n;++i)printf(\"%d \",p[i]);puts(\"\");return 0;}\n\tif(K==0){for(int i=1;i<=n;++i)printf(\"%d \",q[i]);puts(\"\");return 0;}\n\tint N=(K-1)/6;\n\tint _=(K-1)%6+1;\n\tif(_==1)mid=p;\n\telse if(_==2)mid=q;\n\telse if(_==3)mid=q*~p;\n\telse if(_==4)mid=q*~p*~q;\n\telse if(_==5)mid=q*~p*~q*p*~q;\n\telse if(_==6)mid=q*~p*~q*p*p*~q;\n\tg=q*~p*~q*p;g=g^N;\n\tmid=g*mid*~g;\n\tfor(int i=1;i<=n;++i)printf(\"%d \",mid[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nint n,k;\nint p[125252];\nint q[125252];\n\nint I[125252];\n\nint pinv[125252];\nint qinv[125252];\n\nint p1[125252], p2[125252];\n\nint f[125252];\nint ans[125252];\n\nint tmp[125252];\nvoid mult(int ans[125252], int a[125252], int b[125252]){\n  REP(i,n)tmp[i] = a[b[i]];\n  REP(i,n)ans[i] = tmp[i];\n}\n\nint main(){\n  scanf(\"%d%d\",&n,&k);\n  REP(i,n)scanf(\"%d\",p+i),p[i]--;\n  REP(i,n)scanf(\"%d\",q+i),q[i]--;\n\n  if(k==1){\n    REP(i,n)printf(\"%d%c\",p[i]+1,i==n-1?'\\n':' ');\n    return 0;\n  }else if(k==2){\n    REP(i,n)printf(\"%d%c\",q[i]+1,i==n-1?'\\n':' ');\n    return 0;\n  }\n  \n  REP(i,n)I[i]=i;\n  REP(i,n)pinv[p[i]]=i;\n  REP(i,n)qinv[q[i]]=i;\n  // P1: -2 1 2 -1\n  REP(i,n)p1[i] = i;\n  mult(p1, p1, pinv);\n  mult(p1, p1, q);\n  mult(p1, p1, p);\n  mult(p1, p1, qinv);\n  // P2: 1 -2 -1 2 (= P1 inv)\n  REP(i,n)p2[i] = i;\n  mult(p2, p2, q);\n  mult(p2, p2, pinv);\n  mult(p2, p2, qinv);\n  mult(p2, p2, p);\n  // REP(i,n)p2[p1[i]] = i;\n\n  REP(i,n)f[i]=i;\n\n  int p2cnt = (k-2)/6;\n  while(p2cnt){\n    if(p2cnt&1)mult(f,f,p2);\n    mult(p2,p2,p2);\n    p2cnt >>= 1;\n  }\n  if(k%6==3){\n    mult(f,f,p); mult(f,f,qinv);\n  }else if(k%6==4){\n    mult(f,f,q); mult(f,f,p); mult(f,f,qinv);\n  }else if(k%6==5){\n    mult(f,f,q);\n  }else if(k%6==0){\n    mult(f,f,q); mult(f,f,pinv);\n  }else if(k%6==1){\n    mult(f,f,q); mult(f,f,pinv); mult(f,f,qinv);\n  }else if(k%6==2){\n    mult(f,f,qinv);\n  }\n  int p1cnt = (k+1)/6;\n  while(p1cnt){\n    if(p1cnt&1)mult(f,f,p1);\n    mult(p1,p1,p1);\n    p1cnt >>= 1;\n  }\n  // if(k%6==3){\n  //   mult(f,f,qinv); mult(f,f,p);\n  // }else if(k%6==4){\n  //   mult(f,f,qinv); mult(f,f,p); mult(f,f,q);\n  // }else if(k%6==5){\n  //   mult(f,f,q);\n  // }else if(k%6==0){\n  //   mult(f,f,pinv); mult(f,f,q);\n  // }else if(k%6==1){\n  //   mult(f,f,qinv); mult(f,f,pinv); mult(f,f,q);\n  // }else if(k%6==2){\n  //   mult(f,f,qinv);\n  // }\n\n\n  REP(i,n)ans[f[i]] = i;\n  REP(i,n)printf(\"%d%c\",ans[i]+1,i==n-1 ? '\\n' : ' ');\n  // REP(i,n)printf(\"%d%c\",f[i]+1,i==n-1 ? '\\n' : ' ');\n\n  return 0;\n\n  // jikken\n  vi a, b;\n  a.push_back(-1);\n  b.push_back(-2);\n  while(k-- >= 3){\n    vi c = b;\n    while(a.size()){\n      int x = -a.back();\n      a.pop_back();\n      if(c.size() && c.back() == -x){\n        c.pop_back();\n      }else{\n        c.push_back(x);\n      }\n    }\n    // printf(\"%2d: \", k+3);\n    // REP(i,c.size())printf(\"%d \",c[i]);puts(\"\");\n    a = b; b = c;\n  }\n\n  REP(i,n)f[i] = i;\n  reverse(ALL(b));\n  REP(i,b.size()){\n    int v = b[i];\n    if(v==1)mult(f,f,p);\n    if(v==2)mult(f,f,q);\n    if(v==-1)mult(f,f,pinv);\n    if(v==-2)mult(f,f,qinv);\n  }\n  REP(i,n)ans[f[i]] = i;\n  REP(i,n)printf(\"%d%c\",ans[i]+1,i==n-1 ? '\\n' : ' ');\n  REP(i,n)printf(\"%d%c\",f[i]+1,i==n-1 ? '\\n' : ' ');\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main () {\n  int N;\n  long long K;\n  cin >> N >> K;\n  vector<vector<int>>B(6,vector<int>(N + 1));\n  vector<vector<int>>A(6,vector<int>(N + 1));\n  vector<int>key(N + 1);\n  int an[100002];\n  vector<int>an_(N + 1);\n  vector<int>ans(N + 1);\n  for (int i = 1; i <= N; i ++) {\n    cin >> B[1][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    cin >> B[2][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    B[3][B[1][i]] = B[2][i];\n    B[4][B[1][i]] = i;\n    B[5][B[2][i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    B[0][B[4][i]] = B[5][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    A[1][i] = i;\n    A[2][i] = i;\n    A[3][i] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    A[4][i] = B[2][i];\n    A[5][i] = B[3][i];\n    A[0][i] = B[3][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    key[i] = B[2][B[4][B[5][B[1][i]]]];\n  }\n  int jun = (int)K % 6;\n  int ju = (int)K / 6;\n  for (int i = 1; i <= N; i ++) {\n    an[i] = A[jun][i];\n  }\n  for (int i = 0; i < ju; i ++) {\n    for (int j = 1; j <= N; j ++) {\n      an[j] = key[an[j]];\n    }\n  }\n  for (int i = 1; i <= N; i ++) {\n    an_[an[i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    ans[i] = an[B[jun][an_[i]]];\n  }\n  for (int i = 1; i < N; i ++) {\n    cout << ans[i] << ' ';\n  }\n  cout << ans[N] << endl;\n}\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <utility>\n#include <functional>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint n;\nvoid pow(int p[100001], int k, int ret[100001]){\n    int pp[31][100001];\n    for(int i=1; i<=n; i++){\n        pp[0][i]=p[i];\n    }\n    for(int j=1; (1<<j)<=k; j++){\n        for(int i=1; i<=n; i++){\n            pp[j][i]=pp[j-1][pp[j-1][i]];\n        }\n    }\n    for(int i=1; i<=n; i++) ret[i]=i;\n    for(int j=0; (1<<j)<=k; j++){\n        if(k&(1<<j)){\n            int ret2[100001];\n            for(int i=1; i<=n; i++){\n                ret2[i]=ret[pp[j][i]];\n            }\n            for(int i=1; i<=n; i++) ret[i]=ret2[i];\n        }\n    }\n}\nvoid mul(int p[100001], int q[100001], int ret[100001]){\n    for(int i=1; i<=n; i++){\n        ret[i]=p[q[i]];\n    }\n}\nint main()\n{\n    int k; cin>>n>>k;\n    int p[100001], q[100001], pi[100001], qi[100001];\n    for(int i=1; i<=n; i++){\n        cin>>p[i]; pi[p[i]]=i;\n    }\n    for(int i=1; i<=n; i++){\n        cin>>q[i]; qi[q[i]]=i;\n    }\n    int r[100001], rp[100001], r1[100001], r2[100001];\n    mul(q, pi, r1);\n    mul(qi, p, r2);\n    mul(r1, r2, r);\n    pow(r, (k-1)/6, rp);\n    if((k-1)%6>=3){\n        int rp2[100001];\n        mul(rp, r1, rp2);\n        for(int i=1; i<=n; i++) rp[i]=rp2[i];\n    }\n    int rpi[100001];\n    for(int i=1; i<=n; i++){\n        rpi[rp[i]]=i;\n    }\n    int s[100001];\n    if((k-1)%6==0){\n        for(int i=1; i<=n; i++) s[i]=p[i];\n    }else if((k-1)%6==1){\n        for(int i=1; i<=n; i++) s[i]=q[i];\n    }else if((k-1)%6==2){\n        for(int i=1; i<=n; i++) s[i]=r1[i];\n    }else if((k-1)%6==3){\n        for(int i=1; i<=n; i++) s[i]=pi[i];\n    }else if((k-1)%6==4){\n        for(int i=1; i<=n; i++) s[i]=qi[i];\n    }else{\n        for(int i=1; i<=n; i++) s[i]=r2[i];\n    }\n    int ans2[100001];\n    mul(rp, s, ans2);\n    int ans[100001];\n    mul(ans2, rpi, ans);\n    for(int i=1; i<=n; i++){\n        if(i<n) cout<<ans[i]<<\" \";\n        else cout<<ans[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define trav(a,x) for(auto &a:x)\n#define all(x) x.begin(),x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nvi mul(const vi &a,const vi &b) {\n    int n = a.size();\n    vi c(n);\n    rep(i,0,n) c[i] = a[b[i]];\n    return c;\n}\nvi inv(const vi &a) {\n    int n = a.size();\n    vi b(n);\n    rep(i,0,n) b[a[i]] = i;\n    return b;\n}\nvi ident(int n) {\n    vi a(n);\n    rep(i,0,n) a[i] = i;\n    return a;\n}\nvi pow(const vi &a, int k) {\n    int n = a.size();\n    if(k==0) return ident(n);\n    vi half = pow(a,k/2);\n    vi result = mul(half,half);\n    if(k%2==1) result = mul(result,a);\n    return result;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    vi p(n), q(n);\n    rep(i,0,n) {\n        cin >> p[i];\n        --p[i];\n    }\n    rep(i,0,n) {\n        cin >> q[i];\n        --q[i];\n    }\n    int sides = (k-1)/6;\n    int kk = k-sides*6;\n    vector<vi> seq(max(3,kk+1));\n    seq[1] = p;\n    seq[2] = q;\n    rep(i,3,kk+1) seq[i]=mul(seq[i-1],inv(seq[i-2]));\n    auto a=p, b=q,c=inv(a),d=inv(q);\n    auto left = pow(mul(b,mul(c,mul(d,a))),sides);\n    auto right = pow(mul(c,mul(b,mul(a,d))),sides);\n    auto result = mul(left,mul(seq[kk],right));\n    rep(i,0,n) cout << (result[i]+1) << \" \";\n    cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int N = 1e5 + 7;\nint n, k, p[N], q[N], vp[N], vq[N], t[N], vt[N], ans[N];\n\ninline void init(int *a) {\n\tfor (int i = 1; i <= n; i++) a[i] = i;\n}\n\ninline void inv(int *a, int *b) {\n\tfor (int i = 1; i <= n; i++) b[a[i]] = i;\n}\n\ninline void mul(int *a, int *b) {\n\tstatic int c[N];\n\tfor (int i = 1; i <= n; i++) c[i] = a[b[i]];\n\tfor (int i = 1; i <= n; i++) a[i] = c[i];\n}\n\ninline void ksm(int *a, int b) {\n\tstatic int d[N];\n\tinit(d);\n\twhile (b) {\n\t\tif (b & 1) mul(d, a);\n\t\tmul(a, a), b >>= 1;\n\t}\n\tfor (int i = 1; i <= n; i++) a[i] = d[i];\n}\n\nint main() {\n\trd(n, k), rda(p, n), rda(q, n), inv(p, vp), inv(q, vq);\n\tinit(t), mul(t, q), mul(t, vp), mul(t, vq), mul(t, p), inv(t, vt);\n\tint r = k % 6 ? k % 6 : 6, w = (k - r) / 6;\n\tksm(t, w), ksm(vt, w);\n\tinit(ans), mul(ans, t);\n\tswitch (r) {\n\t\tcase 1 : mul(ans, p); break;\n\t\tcase 2 : mul(ans, q); break;\n\t\tcase 3 : mul(ans, q), mul(ans, vp); break;\n\t\tcase 4 : mul(ans, q), mul(ans, vp), mul(ans, vq); break;\n\t\tcase 5 : mul(ans, q), mul(ans, vp), mul(ans, vq), mul(ans, p), mul(ans, vq); break;\n\t\tcase 6 : mul(ans, q), mul(ans, vp), mul(ans, vq), mul(ans, p), mul(ans, p), mul(ans, vq); break;\n\t}\n\tmul(ans, vt);\n\tprinta(ans, n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\nusing namespace std;\nvi p,q,a[7];\nint n,k,x;\nvi mul(vi x,vi y)\n{\n    vi z;\n    for(int i=0;i<x.size();i++)\n        z.push_back(x[y[i]]);\n    return z;\n}\nvi inv(vi x)\n{\n    vi y(n);\n    for(int i=0;i<x.size();i++)\n        y[x[i]]=i;\n    return y;\n}\nvi qpow(vi x,int y)\n{\n    vi ans(n);\n    for(int i=0;i<n;i++) ans[i]=i;\n    while(y)\n    {\n        if(y&1) ans=mul(ans,x);\n        x=mul(x,x);\n        y>>=1;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&x);\n        p.push_back(x-1);\n    }\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&x);\n        q.push_back(x-1);\n    }\n    a[1]=p;a[2]=q;\n    for(int i=3;i<=6;i++)\n        a[i]=mul(a[i-1],inv(a[i-2]));\n    if(k<=6)\n    {\n        for(int i=0;i<n;i++)\n            printf(i==n-1?\"%d\\n\":\"%d \",a[k][i]+1);\n        return 0;\n    }\n    vi A=mul(mul(q,inv(p)),mul(inv(q),p));\n    A=qpow(A,(k-1)/6);\n    vi ans=mul(mul(A,a[(k-1)%6+1]),inv(A));\n    for(int i=0;i<n;i++)\n        printf(i==n-1?\"%d\\n\":\"%d \",ans[i]+1);\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\nint n,k;\nint p[N],q[N],p_[N],q_[N],A[N];\nvoid inv(int p_[],int p[]){\n\tstatic int r[N];\n\tfor (int i=1;i<=n;++i)\n\t\tr[p[i]]=i;\n\tmemcpy(p_,r,sizeof(int)*(n+1));\n}\nvoid multi(int f[],int p[],int q[]){\n\tstatic int r[N];\n\tfor (int i=1;i<=n;++i)\n\t\tr[i]=p[q[i]];\n\tmemcpy(f,r,sizeof(int)*(n+1));\n}\nvoid getpow(int p[],int k){\n\tstatic int vis[N],r[N],q[N];\n\tmemset(vis,0,sizeof(int)*(n+1));\n\tfor (int i=1;i<=n;++i)\n\t\tif (!vis[i]){\n\t\t\tint cnt=0;\n\t\t\tfor (int x=i;!vis[x];x=p[x])\n\t\t\t\tvis[x]=1,q[cnt++]=x;\n\t\t\tfor (int j=0;j<cnt;++j)\n\t\t\t\tr[q[j]]=q[(j+k)%cnt];\n\t\t}\n\tmemcpy(p,r,sizeof(int)*(n+1));\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i<=n;++i)\n\t\tscanf(\"%d\",&p[i]);\n\tfor (int i=1;i<=n;++i)\n\t\tscanf(\"%d\",&q[i]);\n\tinv(p_,p),inv(q_,q);\n\tmemcpy(A,q,sizeof(int)*(n+1));\t\n\tmulti(A,A,p_),multi(A,A,q_),multi(A,A,p);\n\tint r=(k-1)%6;\n\tfor (int i=0;i<r;++i){\n\t\tinv(p,p);\n\t\tmulti(p,q,p);\n\t\tswap(p,q);\n\t}\n\tgetpow(A,(k-1)/6);\n\tmulti(p,A,p);\n\tinv(A,A);\n\tmulti(p,p,A);\n\tfor (int i=1;i<=n;++i)\n\t\tprintf(\"%d \",p[i]);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nvector<int> getInv(vector<int>& v) {\n    vector<int> res(v.size());\n    for (int i = 0; i < v.size(); i++) {\n        res[v[i]] = i;\n    }\n    return res;\n}\n\nvector<int> getMul(vector<int> p, vector<int> q) {\n    vector<int> res(p.size());\n    for (int i = 0; i < p.size(); i++) {\n        res[i] = q[p[i]];\n    }\n    return res;\n}\n\nvector<int> getNext(vector<int>& p, vector<int>& q) {\n    vector<int> res(p.size());\n    for (int i = 0; i < p.size(); i++) {\n        res[p[i]] = q[i];\n    }\n    return res;\n}\n\nvector<int> getPow(vector<int> v, int n) {\n    vector<int> res(v.size());\n    for (int i = 0; i < v.size(); i++) res[i] = i;\n    while (n > 0) {\n        if (n & 1) res = getMul(res, v);\n        v = getMul(v, v);\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, K;\n    cin >> n >> K;\n    vector<int> p(n), q(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i];\n        p[i]--;\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> q[i];\n        q[i]--;\n    }\n\n    vector<int> pinv = getInv(p), qinv = getInv(q);\n    vector<int> v1 = getPow(getMul(getMul(getMul(p, qinv), pinv), q), (K - 1) / 6);\n    vector<int> v2 = getPow(getMul(getMul(getMul(qinv, p), q), pinv), (K - 1) / 6);\n    vector<int> v3;\n    if ((K - 1) % 6 == 0) v3 = p;\n    else if ((K - 1) % 6 == 1) v3 = q;\n    else {\n        for (int i = 2; i <= (K - 1) % 6; i++) {\n            v3 = getNext(p, q);\n            p = q;\n            q = v3;\n        }\n    }\n    vector<int> ans = getMul(getMul(v2, v3), v1);\n\n    for (int i = 0; i < n; i++) {\n        cout << ans[i] + 1 << \" \\n\"[i + 1 == n];\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n\n#define boost ios::sync_with_stdio(0); cin.tie(0)\n\n#define fi first\n#define se second\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\n\nconst int N = 1e6 + 5;\n\n/***************************************************************************/\n\nvector<int> identity(int n) {\n\tvector<int> A(n);\n\tfor(int i=0; i<n; i++) {\n\t\tA[i] = i;\n\t}\n\treturn A;\n}\n\nvector<int> inverse(vector<int> A) {\n\tvector<int> B(A.size());\n\tfor(int i=0; i<(int)B.size(); i++) {\n\t\tB[A[i]] = i;\n\t}\n\treturn B;\n}\n\nvector<int> multiply(vector<int> A, vector<int> B) {\n\tvector<int> C(A.size());\n\tfor(int i=0; i<(int)C.size(); i++) {\n\t\tC[i] = A[B[i]];\n\t}\n\treturn C;\n}\n\nvector<int> power(vector<int> A, int n) {\n\tif(n == 0) return identity(A.size());\n\tvector<int> B = power(A, n >> 1);\n\tB = multiply(B, B);\n\tif(n & 1) B = multiply(B, A);\n\treturn B;\n}\n\nvector<int> ans[10];\n\nint main() {\n\n\tboost;\n\tint n, k; cin>>n>>k; k--;\n\tvector<int> P(n), Q(n);\n\tfor(int i=0; i<n; i++) {\n\t\tcin>>P[i]; P[i]--;\n\t}\n\tfor(int i=0; i<n; i++) {\n\t\tcin>>Q[i]; Q[i]--;\n\t}\n\n\tvector<int> A = multiply(multiply(Q, inverse(P)), multiply(inverse(Q), P));\n\tA = power(A, k/6);\n\tk %= 6;\n\tif(k >= 3) A = multiply(A, Q);\n\tif(k > 3) A = multiply(A, inverse(P));\n\n\tvector<int> B = P;\n\tif(k == 1) B = Q;\n\telse if(k == 2) B = multiply(Q, inverse(P));\n\telse if(k == 3) B = inverse(P);\n\telse if(k == 4) B = inverse(Q);\n\telse B = multiply(inverse(Q), P);\n\n\tvector<int> AK = multiply(A, multiply(B, inverse(A)));\n\tfor(int i=0; i<n; i++) {\n\t\tcout<<AK[i]+1<<\" \";\n\t}\n\tcout<<\"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nvector<int> inv(vector<int> a) {\n\tint n = a.size();\n\tvector<int> b(n);\n\tfor (int i = 0; i < n; ++i) b[a[i]] = i;\n\treturn b;\n}\n// c = a o b\nvector<int> compose(vector<int> a, vector<int> b) {\n\tint n = a.size();\n\tvector<int> c(n);\n\tfor (int i = 0; i < n; ++i) c[i] = a[b[i]];\n\treturn c;\n}\nvector<int> power(vector<int> a, int b) {\n  int n = a.size();\n  vector<int> x(n);\n  iota(x.begin(), x.end(), 0);\n  while (b) {\n    if (b & 1) x = compose(x, a);\n    a = compose(a, a);\n    b >>= 1;\n  }\n  return x;\n}\nint main() {\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tvector<int> p(n), q(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &p[i]);\n\t\t--p[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &q[i]);\n\t\t--q[i];\n\t}\n\tvector<vector<int>> mid(6);\n\tmid[0] = p;\n\tmid[1] = q;\n\tfor (int i = 2; i < 6; ++i) {\n\t\tmid[i] = compose(mid[i - 1], inv(mid[i - 2]));\n\t}\n\tauto rep = compose(q, compose(inv(p), compose(inv(q), p)));\n\tauto v = power(rep, (k - 1) / 6);\n\tauto ans = compose(v, compose(mid[(k - 1) % 6], inv(v)));\n\tfor (int i = 0; i < n; ++i) printf(\"%d \", ans[i] + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 100000\nusing namespace std;\nint n,k;struct P\n{\n\tint a[N+5];I P(CI x=0) {for(RI i=1;i<=x;++i) a[i]=i;}\n\tI int& operator [] (CI x) {return a[x];}I int operator [] (CI x) Con {return a[x];}\n \tI friend P operator ~ (Con P& A) {P B;for(RI i=1;i<=n;++i) B[A[i]]=i;return B;}\n\tI friend P operator * (Con P& A,Con P& B) {P C;for(RI i=1;i<=n;++i) C[i]=A[B[i]];return C;}\n}p,q,s,a[10],ans;\nI P QP(P x,RI y) {P t=P(n);W(y) y&1&&(t=t*x,0),x=x*x,y>>=1;return t;}\nint main()\n{\n\tRI i;for(scanf(\"%d%d\",&n,&k),i=1;i<=n;++i) scanf(\"%d\",&p[i]);for(i=1;i<=n;++i) scanf(\"%d\",&q[i]);\n\ta[1]=p,a[2]=q,a[3]=a[2]*(~a[1]),a[4]=a[3]*(~a[2]),a[5]=a[4]*(~a[3]),a[6]=a[5]*(~a[4]);\n\ts=q*(~p)*(~q)*p,ans=QP(s,(k-1)/6)*a[(k-1)%6+1]*QP(~s,(k-1)/6);\n\tfor(i=1;i<=n;++i) printf(\"%d%c\",ans[i],\" \\n\"[i==n]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\n\n\nvector<int> p1(100020);\n\nvector<int> p2(100020);\n\nvector<int> m1(100020);\nvector<int> m2(100020);\n\nvector<int>Z1,Z2;\nint n;\nvector<int> ff(vector<int>v1,vector<int> v2){\n\tvector<int> ans(n+1,0);\n\t\n\tfor(int i=0;i<=n;i++){\n\t\tans[v1[i]]=v2[i];\n\t}\n\treturn ans;\n}\n\n\nvector<int> BB(vector<int> ve,int kai){\n\tif(kai==1) return ve;\n\tif(kai%2){\n\t\treturn ff(BB(ve,kai-1),ve);\n\t}\n\tvector<int> D=BB(ve,kai/2);\n\treturn ff(D,D);\n}\n\nvector<int> migi(int r, vector<int> ve){\n\t\n\tint t=r/4;\n\tif(t){\n\tvector<int> be=BB(Z2,t);\n\t\t\n\t\tve=ff(be,ve);\n\t}\n\tr%=4;\n\t\n\tif(r>=1) ve=ff(m2,ve);\n\tif(r>=2) ve=ff(p1,ve);\n\tif(r>=3) ve=ff(p2,ve);\n\treturn ve;\n}\n\nvector<int> hidari(int r,vector<int> ve){\n\t\n\tint t=r/4;\n\tint tt=r%4;\n\n\t\n\tif(tt>=3) ve=ff(m2,ve);\n\tif(tt>=2) ve=ff(m1,ve);\n\tif(tt>=1) ve=ff(p2,ve);\n\t\n\tif(t){\n\tvector<int> be=BB(Z1,t);\n\t\t\n\t\tve=ff(be,ve);\n\t}\n\t\n\treturn ve;\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nvector<int> moto;\n \t\n \tint k;\n \tcin>>n>>k;\n \t\n \tfor(int i=0;i<=n;i++)moto.pb(i);\n \t\n \tfor(int i=1;i<=n;i++){\n \t\tcin>>p1[i];\n \t\tm1[p1[i]]=i;\n \t}\n \t\n \tfor(int i=1;i<=n;i++){\n \t\tcin>>p2[i];\n \t\tm2[p2[i]]=i;\n \t}\n \t\n \n \t Z1=moto;\n \tZ1=ff(p1,Z1);\n \tZ1=ff(m2,Z1);\n \tZ1=ff(m1,Z1);\n \tZ1=ff(p2,Z1);\n \t\n \t\n \t Z2=moto;\n \tZ2=ff(m2,Z1);\n \tZ2=ff(p1,Z1);\n \tZ2=ff(p2,Z1);\n \tZ2=ff(m1,Z1);\n \t\n \t\n \t\n \tvector<int> ans=moto;\n \t\n \tint k1=(k+1)/3;\n \tk1=k1*2-2;\n \tif(k%3==2)k1--;\n \t\n \tans=migi(k1,ans);\n \t\n \tint k2=k1+3;\n \tif(k%3==0) k2--;\n \tans=hidari(k2,ans);\n \t\n \tfor(int i=1;i<=n;i++)cout<<ans[i]<<\" \";\n \tcout<<endl;\n \treturn 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define INF  (1<<30)\n#define INFL (1LL<<60)\n#define MOD 1000000007\n#define EPS ((ld)(1e-9))\n\n#define sz(x) ((int)(x).size())\n#define setz(x) memset(x, 0, sizeof(x))\n#define rep(i, x)  for (int i = 0, _##i = (x); i < _##i; i++)\n#define repp(i, x) for (int i = 1, _##i = (x); i <= _##i; i++)\n#define repr(i, s, e) for (int i = (s), _##i = (e); i < _##i; i++)\n\n#define L(x) ((x)*2)\n#define R(x) ((x)*2+1)\n\n#ifndef __SOULTCH\n#define endl '\\n'\n#define debug(x) \n#else\n#define debug(x) cout << \" [+] \" << #x << \" = \" << x << endl\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ld, ld> pdd;\ntypedef pair<ll, ll> pll;\n\ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const pair<T, V> pai) { \n    return os << pai.first << ' ' << pai.second;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> v) {\n    rep(i, sz(v)) cout << v[i] << ' ';\n    return os;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const set<T> s) {\n    for (T p : s) cout << p << ' ';\n    return os;\n}\n\ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const map<T, V> s) {\n    for (auto p : s) cout << '(' << p << \") \";\n    return os;\n}\n\ntemplate<typename T, typename V>\nistream &operator>>(istream &is, pair<T, V> &pai) {\n\tis >> pai.first >> pai.second;\n\treturn is;\n}\n\nint N, K;\nint arr[100001][100];\n\nint main(void) {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n\n    cin >> N >> K;\n    repp(i, N) cin >> arr[0][i];\n    repp(i, N) cin >> arr[1][i];\n\n    int pr = -1;\n    repr(i, 2, 100) {\n        repp(j, N) arr[i][arr[i-2][j]] = arr[i-1][j];\n\n        bool f = true;\n        repp(j, N) if (arr[0][j] != arr[i-1][j] or arr[1][j] != arr[i][j]) {f = false; break;}\n        if (f) {\n            pr = i;\n            break;\n        }\n    }\n\n    K %= (pr-1);\n    repp(i, N) cout << arr[K-1][i] << ' ';\n    cout << endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int N = (int) 1e5 + 100;\nint n;\n\nstruct Perm\n{\n    int p[N];\n\n    Perm() : p() \n    {\n        for (int i = 0; i < N; i++)\n            p[i] = i;\n    }\n\n    void read()\n    {\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%d\", &p[i]);\n            p[i]--;\n        }\n    }\n\n    Perm inv() const\n    {\n        Perm ans = Perm();\n        for (int i = 0; i < n; i++)\n            ans.p[p[i]] = i;\n        return ans;\n    }\n\n    Perm operator * (const Perm &A) const\n    {\n        Perm ans = Perm();\n        for (int i = 0; i < n; i++)\n            ans.p[i] = A.p[p[i]];\n        return ans;\n    }\n\n    Perm fpow(int d)\n    {\n        if (d == 0)\n            return Perm();\n        Perm A = fpow(d / 2);\n        A = A * A;\n        if (d & 1)\n            A = A * *this;\n        return A;\n    }\n\n    void print() const\n    {\n        for (int i = 0; i < n; i++)\n            printf(\"%d \", p[i] + 1);\n        printf(\"\\n\");\n    }\n\n};\n\nPerm A, B, a, b, bABa;\n\nPerm getPref(int pref)\n{\n    Perm ans = bABa.fpow(pref / 4);\n    if (pref % 4 >= 1)\n        ans = ans * b;\n    if (pref % 4 >= 2)\n        ans = ans * A;\n    if (pref % 4 >= 3)\n        ans = ans * B;\n    return ans;\n}\n\nint getSufLen(int x)\n{\n    int ans = x - (x + 2) / 3;\n    return ans;\n}\n\nint getPrefLen(int x)\n{\n    int ans = x - x / 3 - 2;\n    return ans;\n}\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    int k;\n    scanf(\"%d%d\", &n, &k);\n    A.read();\n    B.read();\n\n    if (k == 1)\n    {\n        A.print();\n        return 0;\n    }\n    if (k == 2)\n    {\n        B.print();\n        return 0;\n    }\n    int suff = getSufLen(k);\n    int pref = getPrefLen(k);\n    eprintf(\"%d : %d %d\\n\", k, pref, suff);\n\n    a = A.inv();\n    b = B.inv();\n\n    bABa = b * A * B * a;\n   \n    Perm X = getPref(pref), y = getPref(suff);\n    Perm Y = y.inv();\n\n    Perm ans = X * Y;\n    ans.print();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef long double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 100010;\nint a[8][N], n, b[8][N], t1[N], t2[N], k, ans[N], rec[N];\n// b * c -> c_{b_i}\nvoid mul(int *a,int *b,int *c) {\n  static int tb[N], tc[N];\n  rep (i, 1, n) tb[i] = b[i], tc[i] = c[i];\n  rep (i, 1, n) a[i] = tc[tb[i]];\n}\nvoid getinv(int *a,int *b) {\n  rep (i, 1, n) a[b[i]] = i;\n}\nvoid getpower(int* ret,int *a,int b) {\n  rep (i, 1, n) ret[i] = i;\n  while (b) {\n    if (b&1) mul(ret, ret, a);\n    mul(a, a, a);\n    b >>= 1;\n  }\n}\nint main() {\n  read(n), read(k);\n  rep (i, 1, 2) rep (j, 1, n)\n    read(a[i][j]);\n  getinv(b[1], a[1]), getinv(b[2], a[2]);\n  rep (i, 3, 6) {\n    mul(a[i], b[i-2], a[i-1]);\n    mul(b[i], b[i-1], a[i-2]);\n  }\n  // A = Q^{-1} P Q P^{-1}\n  mul(t1, b[2], a[1]), mul(t1, t1, a[2]), mul(t1, t1, b[1]);\n  getinv(t2, t1);\n  int tmp = (k - 1) / 6;\n  getpower(ans, t1, tmp);\n  mul(ans, ans, a[(k-1) % 6 + 1]);\n  getpower(rec, t2, tmp);\n  mul(ans, ans, rec);\n  rep (i, 1, n) printf(\"%d \", ans[i]);\n  puts(\"\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * bABa bABa           b                  AbaB AbaB  14\n * bABa bABa           bA                 AbaB AbaB  15\n * bABa bABa           bAB                AbaB AbaB  16\n * bABa bABa           bABa B             AbaB AbaB  17\n * bABa bABa           bABa aB            AbaB AbaB  18\n * bABa bABa           bABa baB           AbaB AbaB  19\n * bABa bABa bABa      b             AbaB AbaB AbaB  20\n * bABa bABa bABa      bA            AbaB AbaB AbaB  21\n * bABa bABa bABa      bAB           AbaB AbaB AbaB  22\n * bABa bABa bABa      bABa B        AbaB AbaB AbaB  23\n * bABa bABa bABa      bABa aB       AbaB AbaB AbaB  24\n * bABa bABa bABa      bABa baB      AbaB AbaB AbaB  25\n * bABa bABa bABa bABa b        AbaB AbaB AbaB AbaB  26\n * bABa bABa bABa bABa bA       AbaB AbaB AbaB AbaB  27\n * bABa bABa bABa bABa bAB      AbaB AbaB AbaB AbaB  28\n * bABa bABa bABa bABa bABa B   AbaB AbaB AbaB AbaB  29\n * bABa bABa bABa bABa bABa aB  AbaB AbaB AbaB AbaB  30\n */\n\nvector<int> inv(vector<int> a) {\n  int n = (int) a.size();\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[a[i]] = i;\n  }\n  return ret;\n}\n\nvector<int> mul(vector<int> a, vector<int> b) {\n  int n = (int) a.size();\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[i] = a[b[i]];\n  }\n  return ret;\n}\n\nvector<int> power(vector<int> a, int b) {\n  int n = (int) a.size();\n  vector<int> ret(n);\n  iota(ret.begin(), ret.end(), 0);\n  while (b) {\n    if (b & 1) {\n      ret = mul(ret, a);\n    }\n    b >>= 1;\n    a = mul(a, a);\n  }\n  return ret;\n}\n\nvoid output(vector<int> a) {\n  for (int i = 0; i < (int) a.size(); i++) {\n    if (i) {\n      cout << \" \";\n    }\n    cout << a[i] + 1;\n  }\n  cout << '\\n';\n  exit(0);\n}\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i]--;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> b[i];\n    b[i]--;\n  }\n  if (k == 1) {\n    output(a);\n  }\n  vector<int> A = inv(a);\n  vector<int> B = inv(b);\n  vector<int> bABa = mul(b, mul(A, mul(B, a)));\n  vector<int> AbaB = mul(A, mul(b, mul(a, B)));\n\n  vector<int> l[6];\n  l[0] = b;\n  l[1] = mul(b, A);\n  l[2] = mul(b, mul(A, B));\n  l[3] = mul(bABa, B);\n  l[4] = mul(bABa, mul(a, B));\n  l[5] = mul(bABa, mul(b, mul(a, B)));\n\n  vector<int> f = power(AbaB, (k - 2) / 6);\n  f = mul(l[(k - 2) % 6], f);\n  f = mul(power(bABa, (k - 2) / 6), f);\n  output(f);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Dmitry _kun_ Sayutin (2019)\n\n#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n\nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\nvector<int> perm_mult(const vector<int>& a, const vector<int>& b) {\n    vector<int> res(SZ(a), -1);\n\n    for (int i = 0; i != SZ(a); ++i)\n        res[i] = a[b[i]];\n\n    return res;\n}\n\nvector<int> perm_inv(const vector<int>& a) {\n    vector<int> res(SZ(a), -1);\n\n    for (int i = 0; i != SZ(a); ++i)\n        res[a[i]] = i;\n\n    return res;\n}\n\nvector<int> perm_pow(vector<int> a, int k) {\n    vector<int> res(SZ(a));\n    std::iota(ALL(res), 0);\n\n    while (k) {\n        if (k % 2) {\n            vector<int> resc = perm_mult(res, a);\n            res = resc;\n        }\n\n        vector<int> a_c = perm_mult(a, a);\n        a = a_c;\n        k /= 2;\n    }\n\n    return res;\n}\n\n#define mult perm_mult\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    // code here\n\n#if 1\n    int n = input<int>();\n    int k = input<int>() - 1;\n    \n    vector<int> p(n), q(n);\n    for (int& el: p)\n        el = input<int>() - 1;\n\n    for (int& el: q)\n        el = input<int>() - 1;\n\n    vector<int> p_inv = perm_inv(p);\n    vector<int> q_inv = perm_inv(q);\n    \n    vector<int> res;\n\n    // vector<int> aaa = mult(q, mult(p_inv, mult(q_inv, mult(p, q_inv))));\n    // for (int elem: aaa)\n    //     cout << 1 + elem << \" \";\n    // cout << \"\\n\";\n    \n    if (k == 0) {\n        res = p;\n    } else if (k == 1) {\n        res = q;\n    } else {\n        k -= 2;\n\n        int LEN = 4 * (k / 6);\n        k %= 6;\n\n        int fuck[6] = {0, 1, 2, 2, 3, 4};\n        LEN += fuck[k];\n\n        vector<int> center;\n        if (k == 0)\n            center = mult(q, p_inv);\n        else if (k == 1)\n            center = p_inv;\n        else if (k == 2)\n            center = q_inv;\n        else if (k == 3)\n            center = mult(q_inv, p);\n        else if (k == 4)\n            center = p;\n        else if (k == 5)\n            center = q;\n\n        res = perm_pow(mult(mult(q, p_inv), mult(q_inv, p)), LEN / 4);\n\n        if (LEN % 4 >= 1)\n            res = perm_mult(res, q);\n        if (LEN % 4 >= 2)\n            res = perm_mult(res, p_inv);\n        if (LEN % 4 >= 3)\n            res = perm_mult(res, q_inv);\n\n        res = perm_mult(res, center);\n\n        if (LEN % 4 >= 3)\n            res = perm_mult(res, q);\n        if (LEN % 4 >= 2)\n            res = perm_mult(res, p);\n        if (LEN % 4 >= 1)\n            res = perm_mult(res, q_inv);\n\n        vector<int> right = perm_pow(mult(mult(p_inv, q), mult(p, q_inv)), LEN / 4);\n        res = perm_mult(res, right);\n    }\n\n    for (int elem: res)\n        cout << 1 + elem << \" \";\n    cout << \"\\n\";\n\n#endif\n    \n#if 0\n    vector<vector<pair<char, int>>> seq(100);\n\n    seq[0] = {{'p', 1}};\n    seq[1] = {{'q', 1}};\n    \n    for (int i = 2; i < 100; ++i) {\n        auto a = seq[i - 2];\n        auto b = seq[i - 1];\n\n        for (auto& elem: a) {\n            elem.second = -elem.second;\n        }\n        reverse(ALL(a));\n        \n        vector<pair<char, int>> res;\n\n        for (auto elem: b)\n            res.emplace_back(elem);\n\n        for (auto p: a) {\n            if (not res.empty() and res.back().first == p.first)\n                res.back().second += p.second;\n            else\n                res.push_back(p);\n\n            if (res.back().second == 0)\n                res.pop_back();\n        }\n\n        seq[i] = res;\n    }\n\n    for (int i = 0; i != 20; ++i) {\n        cout << i << \" \";\n        for (auto elem: seq[i]) {\n            for (int iter = 0; iter != abs(elem.second); ++iter)\n                cout << elem.first << (elem.second > 0 ? \"+\" : \"-\") << \" \";\n        }\n\n        cout << \"\\n\";\n    }\n\n#endif\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main () {\n  int N;\n  long K;\n  cin >> N >> K;\n  int B[6][100001];\n  int A[6][100001];\n  int key[100001];\n  int an[100001];\n  int an_[100001];\n  int ans[100001];\n  for (int i = 1; i <= N; i ++) {\n    cin >> B[1][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    cin >> B[2][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    B[3][B[1][i]] = B[2][i];\n    B[4][B[1][i]] = i;\n    B[5][B[2][i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    B[0][B[4][i]] = B[5][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    A[1][i] = i;\n    A[2][i] = i;\n    A[3][i] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    A[4][i] = B[2][i];\n    A[5][i] = B[3][i];\n    A[0][i] = B[3][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    key[i] = B[2][B[4][B[5][B[1][i]]]];\n  }\n  int jun = (int)K % 6;\n  int ju = (int)K / 6;\n  for (int i = 1; i <= N; i ++) {\n    an[i] = A[jun][i];\n  }\n  for (int i = 0; i < ju; i ++) {\n    for (int j = 1; j <= N; j ++) {\n      an[j] = key[an[j]];\n    }\n  }\n  for (int i = 1; i <= N; i ++) {\n    an_[an[i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    ans[i] = an[B[jun][an_[i]]];\n  }\n  for (int i = 1; i < N; i ++) {\n    cout << ans[i] << ' ';\n  }\n  cout << ans[N] << endl;\n}\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nvector<int> mul(vector<int> x, vector<int> y){\n    vector<int> z(x.size());\n    for (int i = 0; i < x.size(); ++i) {\n        z[i] = x[y[i]];\n    }\n    return z;\n}\n\n\nvector<int> pow_(vector<int> x, int n){\n    vector<int> ans(x.size()), xx = x;\n    iota(ans.begin(),ans.end(), 0);\n    while(n > 0){\n        if(n & 1) ans = mul(ans, xx);\n        xx = mul(xx, xx);\n        n >>= 1;\n    }\n    return ans;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n), b(n), A(n), B(n);\n    for (auto &&i : a) scanf(\"%d\", &i), i--;\n    for (auto &&i : b) scanf(\"%d\", &i), i--;\n    if(k == 1){\n        for (int i = 0; i < n; ++i) {\n            if(i) printf(\" \");\n            printf(\"%d\", a[i]+1);\n        }\n        puts(\"\");\n        return 0;\n    }\n    vector<string> v{\"b\", \"bA\", \"bAB\", \"bABaB\", \"bABaaB\", \"bABabaB\"};\n    for (int i = 0; i < n; ++i) {\n        A[a[i]] = i;\n        B[b[i]] = i;\n    }\n    auto f = [&](string s){\n        vector<int> ans(n);\n        iota(ans.begin(),ans.end(),0);\n        for (char i : s) {\n            if(i == 'a') ans = mul(ans, a);\n            else if(i == 'b') ans = mul(ans, b);\n            else if(i == 'A') ans = mul(ans, A);\n            else if(i == 'B') ans = mul(ans, B);\n        }\n        return ans;\n    };\n    vector<int> X = f(\"bABa\"), Y = f(\"AbaB\");\n    cout << v[(k-2)%6] << \"\\n\";\n    auto ans = mul(mul(pow_(X, (k-2)/6), f(v[(k-2)%6])), pow_(Y, (k-2)/6));\n    for (int i = 0; i < n; ++i) {\n        if(i) printf(\" \");\n        printf(\"%d\", ans[i]+1);\n    }\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nV<int> inv(V<int> a) {\n\tV<int> res(a.size());\n\tREP(i, a.size()) res[a[i]] = i;\n\treturn res;\n}\n\nV<int> merge(V<int> a, V<int> b) {\n\tV<int> res(a.size());\n\tREP(i, a.size()) res[i] = a[b[i]];\n\treturn res;\n}\n\nV<int> id(int n) {\n\tV<int> res(n);\n\tstd::iota(ALL(res), 0);\n\treturn res;\n}\n\nV<int> repeating(V<int> a, int p) {\n\tV<int> res = id(a.size());\n\twhile (p) {\n\t\tif (p & 1) res = merge(res, a);\n\t\ta = merge(a, a);\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, k);\n\tVEC(int, p, n);\n\tVEC(int, q, n);\n\tREP(i, n) --p[i], --q[i];\n\n\tV<int> ans = [&] {\n\t\tif (k == 1) return p;\n\t\tif (k == 2) return q;\n\n\t\tauto P = inv(p);\n\t\tauto Q = inv(q);\n\n\t\tV<std::string> X = { \"Qp\", \"Qpq\", \"q\", \"Pq\", \"QPq\", \"Q\" };\n\n\t\tauto res(id(n));\n\t\tauto PqpQ = merge(P, merge(q, merge(p, Q)));\n\t\tres = merge(repeating(PqpQ, (k - 2) / 6), res);\n\t\tfor (auto& c : X[k % 6]) {\n\t\t\t/* */if (c == 'p') res = merge(p, res);\n\t\t\telse if (c == 'q') res = merge(q, res);\n\t\t\telse if (c == 'P') res = merge(P, res);\n\t\t\telse if (c == 'Q') res = merge(Q, res);\n\t\t}\n\t\tauto qPQp = merge(q, merge(P, merge(Q, p)));\n\t\tres = merge(repeating(qPQp, (k + 1) / 6), res);\n\t\treturn res;\n\t}();\n\tREP(i, n) {\n\t\tOUT(ans[i] + 1)SPBR(i, n);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nvector<int> mult(vector<int> a, vector<int> b) {\n\t// permutation a * b\n\tint N = a.size();\n\tvector<int> ret(N);\n\tfor(int i = 0; i < N; i++) ret[i] = a[b[i]];\n\treturn ret;\n}\n\nvector<int> inv(vector<int> a) {\n\t// permutation a^-1\n\tint N = a.size();\n\tvector<int> ret(N);\n\tfor(int i = 0; i < N; i++) ret[a[i]] = i;\n\treturn ret;\n}\n\nvector<int> pw(vector<int> & a, int e) {\n\tint N = a.size();\n\tif(e <= 0) {\n\t\tvector<int> id(N);\n\t\tfor(int i = 0; i < N; i++) id[i] = i;\n\t\treturn id;\n\t}\n\tvector<int> x = pw(a, e/2);\n\tx = mult(x, x);\n\tif(e&1) x = mult(x, a);\n\treturn x;\n}\n\nvector<int> lift(vector<int> p, vector<int> q, int K) {\n\tif(K == 0) return mult(inv(q), p);\n\tvector<int> b = mult(q, mult(inv(p), mult(inv(q), p)));\n\tvector<int> b_pw = pw(b, K);\n\treturn mult(b_pw, mult(lift(p, q, 0), inv(b_pw)));\n}\n\nvoid print(vector<int> p) {\n\tint N = p.size();\n\tfor(int i = 0; i < N; i++) cout << p[i]+1 << ((i+1 == N) ? \"\\n\" : \" \");\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, K;\n\tcin >> N >> K;\n\tvector< vector<int> > P(6, vector<int>(N));\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> P[1][i];\n\t\tP[1][i]--;\n\t}\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> P[2][i];\n\t\tP[2][i]--;\n\t}\n\tP[0] = mult(inv(P[2]), P[1]);\n\tfor(int i = 3; i < 6; i++) P[i] = mult(P[i-1], inv(P[i-2]));\n\tvector<int> b = mult(P[2], mult(inv(P[1]), mult(inv(P[2]), P[1])));\n\tvector<int> b_pw = pw(b, K/6);\n\tprint(mult(b_pw, mult(P[K%6], inv(b_pw))));\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100010\nint n,k;\nvector<int> Inv(vector<int> A)\n{\n\tvector<int> ret(n);\n\tfor(int i=0;i<n;i++)\n\t\tret[A[i]]=i;\n\treturn ret;\n}\nvector<int> Mul(vector<int> a,vector<int> b)\n{\n\tvector<int>ret(n);\n\tfor(int i=0;i<n;i++)\n\t\tret[i]=a[b[i]];\n\treturn ret;\n}\nvector<int> Pow(vector<int> a,int b)\n{\n\tvector<int>ret(n);\n\tfor(int i=0;i<n;i++) ret[i]=i;\n\twhile(b)\n\t{\n\t\tif(b&1) ret=Mul(ret,a);\n\t\ta=Mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nvector<int>a[6],p,q;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\ta[0].resize(n),a[1].resize(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[0][i]);\n\t\ta[0][i]--;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[1][i]);\n\t\ta[1][i]--;\n\t}\n\tfor(int i=2;i<6;i++)\n\t\ta[i]=Mul(a[i-1],Inv(a[i-2]));\n\tp=Pow(Mul(Mul(a[1],Inv(a[0])),Mul(Inv(a[1]),a[0])),(k-1)/6);\n\tk=(k-1)%6;\n\tq=Mul(p,Mul(a[k],Inv(p)));\n\tfor(int i=0;i<n;i++)\n\t\tprintf(\"%d \",q[i]+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct yu\n{\n\tint a[100001];\n}a,b,c,p,q,ip,iq,id,aa,bb,cc;\nint n,k,f,g;\nyu getinv(yu a)\n{\n\tyu b;\n\tfor (int i=1;i<=n;i++)b.a[a.a[i]]=i;\n\treturn b;\n}\nyu cheng(yu a,yu b)\n{\n\tyu c;\n\tfor (int i=1;i<=n;i++)c.a[i]=a.a[b.a[i]];\n\treturn c;\n} \nyu mi(yu a,int y)\n{\n\tyu c=id;\n\twhile (y)\n\t{\n\t\tif (y%2==1)c=cheng(c,a);\n\t\ta=cheng(a,a);\n\t\ty/=2;\n\t}\n\treturn c;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&k);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&p.a[i]);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&q.a[i]);\n\tfor (int i=1;i<=n;i++)id.a[i]=i;\n\tip=getinv(p);\n\tiq=getinv(q);\n\tf=(k-1)/6;\n\tg=k-f*6;\n\tcc=cheng(cheng(cheng(q,ip),iq),p);\n\taa=mi(cc,f);\n\tif (g==1)bb=p;\n\tif (g==2)bb=q;\n\tif (g==3)bb=cheng(q,ip);\n\tif (g==4)bb=ip,aa=cheng(aa,q);\n\tif (g==5)bb=iq,aa=cheng(cheng(aa,q),ip);\n\tif (g==6)bb=cheng(iq,p),aa=cheng(cheng(aa,q),ip);\n\tp=cheng(cheng(aa,bb),getinv(aa));\n\tfor (int i=1;i<=n;i++)printf(\"%d \",p.a[i]);\n} \n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\n\n// char tog(char c) {\n//   if (isupper(c)) return c-'A'+'a';\n//   return c-'a'+'A';\n// }\n// string rev(string s) {\n//   reverse(rng(s));\n//   for (char& c : s) c = tog(c);\n//   return s;\n// }\n\n// int main() {\n//   int n;\n//   scanf(\"%d\",&n);\n//   string a = \"A\";\n//   string b = \"B\";\n//   rep(i,n) {\n//     string c = b;\n//     while (sz(a) && sz(c)) {\n//       if (a.back() != c.back()) break;\n//       a.pop_back();\n//       c.pop_back();\n//     }\n//     c += rev(a);\n//     cerr<<c<<endl;\n//     a = b; b = c;\n//   }\n//   return 0;\n// }\n\nvi input(int n) {\n  vi a(n);\n  cin>>a;\n  rep(i,n) a[i]--;\n  return a;\n}\nvi inv(vi a) {\n  vi res(sz(a));\n  rep(i,sz(a)) {\n    res[a[i]] = i;\n  }\n  return res;\n}\nvi f(vi a, vi b) {\n  int n = sz(a);\n  vi res(n);\n  rep(i,n) res[i] = b[a[i]];\n  return res;\n}\nvoid out(vi a) {\n  rep(i,sz(a)) a[i]++;\n  cout<<a<<endl;\n}\n\nvi I;\nvi ex(vi a, int t) {\n  if (!t) return I;\n  vi res = ex(a,t>>1);\n  res = f(res,res);\n  if (t&1) res = f(res,a);\n  return res;\n}\n\nint main () {\n  int n,t;\n  scanf(\"%d%d\",&n,&t);\n  vi a = input(n);\n  vi b = input(n);\n  vi A = inv(a);\n  vi B = inv(b);\n  I = vi(n);\n  rep(i,n) I[i] = i;\n\n  if (t == 1) {\n    out(a);\n    return 0;\n  }\n  // if (t == 2) {\n  //   out(b);\n  //   return 0;\n  // }\n  // if (t == 3) {\n  //   out(f(A,b));\n  //   return 0;\n  // }\n\n  vi BabA = f(f(f(B,a),b),A);\n  vi aBAb = inv(BabA);\n\n  t -= 2;\n  int c = t/6;\n  t %= 6;\n\n  vi l = ex(BabA,c+t/3);\n  vi r = ex(aBAb,c);\n\n  vi ans = I;\n  ans = f(ans,l);\n  if (t < 3) {\n    ans = f(ans,B);\n    if (t >= 1) ans = f(ans,a);\n    if (t >= 2) ans = f(ans,b);\n  } else {\n    if (t >= 5) ans = f(ans,B);\n    if (t >= 4) ans = f(ans,A);\n    ans = f(ans,b);\n  }\n  ans = f(ans,r);\n\n  out(inv(ans));\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N, K;\n\nvector<int> cross(vector<int> a, vector<int> b) {\n    vector<int> ret(N+1);\n    ret[0] = -1;\n    for(int i = 1; i <= N; i++) {\n        ret[i] = a[b[i]];\n    }\n    return ret;\n}\n\nvector<int> inverse(vector<int> a) {\n    vector<int> ret(N+1);\n    ret[0] = -1;\n    for(int i = 1; i <= N; i++) {\n        ret[a[i]] = i;\n    }\n    return ret;\n}\n\nvector<int> beki(vector<int> a, int b) {\n    vector<int> ret(N+1);\n    ret[0] = -1;\n    if(b == 0) {\n        for(int i = 1; i <= N; i++) ret[i] = i;\n        return ret;\n    }\n    ret = beki(a, b / 2);\n    ret = cross(ret, ret);\n    if(b % 2 == 1) ret = cross(ret, a);\n    return ret;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> K;\n    vector<int> p(N+1);\n    vector<int> q(N+1);\n    for(int i = 1; i <= N; i++) cin >> p[i];\n    for(int i = 1; i <= N; i++) cin >> q[i];\n    vector<int> pInv = inverse(p);\n    vector<int> qInv = inverse(q);\n    vector<int> initial[7];\n    initial[1] = p;\n    initial[2] = q;\n    initial[3] = cross(q, pInv);\n    initial[4] = cross(q, cross(pInv, qInv));\n    initial[5] = cross(q, cross(pInv, cross(qInv, cross(p, qInv))));\n    initial[6] = cross(q, cross(pInv, cross(qInv, cross(p, cross(p, qInv)))));\n    vector<int> S = cross(q, cross(pInv, cross(qInv, p)));\n    int ans_index = (K - 1) % 6 + 1;\n    int ans_times = (K - ans_index) / 6;\n    S = beki(S, ans_times);\n    vector<int> ans = cross(S, cross(initial[ans_index], inverse(S)));\n    for(int i = 1; i <= N; i++) cout << ans[i] << \" \";\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// {{{ Definitions\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define FERR(s) freopen(s, \"w\", stderr)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define dputs(s) fprintf(stderr, s\"\\n\")\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n// }}}\n// {{{ Modular\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1)\n                ans = mul(ans, x);\n        return ans;\n    }\n}; // namespace modular\n// }}}\n// {{{ Base\n\nnamespace Base {\n    template <typename Tp> inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-')\n                y = -1;\n            c = getchar();\n        }\n        if (c == EOF)\n            return 0;\n        while ('0' <= c && c <= '9')\n            x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp> inline void read(Tp &x) { x = input<Tp>(); }\n    template <typename Tp> inline void chmax(Tp &x, Tp y) { x < y ? x = y : 0; }\n    template <typename Tp> inline void chmin(Tp &x, Tp y) { x > y ? x = y : 0; }\n}; // namespace Base\n\n// }}}\nusing namespace Base;\n\n#define MAX_N 200007\n\nint N, K;\nint p[MAX_N], q[MAX_N], tmp[MAX_N], inv[MAX_N], tmp2[MAX_N], tmp3[MAX_N], a[10][MAX_N], f[MAX_N], res[MAX_N];\n\nvoid getinv(int *p, int *f) {\n    Rep(i, N) f[p[i]] = i;\n}\n\nvoid mul(int *a, int *b, int *f) {\n    Rep(i, N) f[i] = a[b[i]];\n}\n\nint st[MAX_N], ans[MAX_N], pos[MAX_N], top;\nbool vis[MAX_N];\nvoid pow(int *a, int y) {\n    memset(vis, false, sizeof(vis));\n    Rep(i, N) if (!vis[i]) {\n        top = 0;\n        for (int j = i; !vis[j]; j = a[j]) {\n            vis[j] = true;\n            st[++top] = j;\n        }\n        Rep(i, top) pos[st[i]] = i;\n        int z = y % top;\n        for (int j = i; ; j = a[j]) {\n            ans[j] = st[(pos[a[j]] + z - 1) % top + 1];\n            if (j == st[top]) break;\n        }\n        // Rep(i, top) {\n            // ans[st[(i + z - 1) % top + 1]] = st[i];\n        // }\n    }\n    Rep(i, N) a[i] = ans[i];\n}\n\nint main() {\n    read(N), read(K);\n    Rep(i, N) read(p[i]), a[1][i] = p[i];\n    Rep(i, N) read(q[i]), a[2][i] = q[i];\n    rep(i, 3, 6) {\n        getinv(a[i - 2], inv);\n        mul(a[i - 1], inv, a[i]);\n    }\n    if (K <= 6) {\n        Rep(i, N) printf(\"%d \", a[K][i]); puts(\"\");\n        return 0;\n    }\n    getinv(p, inv);\n    mul(q, inv, tmp2);\n    getinv(q, inv);\n    mul(inv, p, tmp3);\n    mul(tmp2, tmp3, f);\n    getinv(f, tmp);\n    // Rep(i, N) debug(\"%d \", tmp[i]); dputs(\"\");\n    pow(f, (K - 1) / 6 - 1);\n    pow(tmp, (K - 1) / 6 - 1);\n    // Rep(i, N) debug(\"%d \", tmp[i]); dputs(\"\");\n    // debug(\"%d\\n\", K - (K - 1) / 6 * 6);\n    mul(f, a[K - (K - 1) / 6 * 6], tmp2);\n    mul(tmp2, tmp, res);\n    Rep(i, N) printf(\"%d \", res[i]); puts(\"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nchar opp(char x) {\n  return (tolower(x) == x) ? toupper(x) : tolower(x);\n}\n\nvi mul(const vi& a, const vi& b) {\n  vi c(a.size());\n  for (int i = 0; i < a.size(); ++i) c[i] = b[a[i]];\n  return c;\n}\n\nvi id(int n) {\n  vi v(n);\n  for (int i = 0; i < n; ++i) v[i] = i;\n  return v;\n}\n\nvi inv(const vi& v) {\n  vi a(v.size());\n  for (int i = 0; i < v.size(); ++i) {\n    a[v[i]] = i;\n  }\n  return a;\n}\n\nvi mpow(vi x, ll n) {\n  vi res = id(x.size());\n  while (n) {\n    if (n & 1) res = mul(res, x);\n    x = mul(x, x);\n    n /= 2;\n  } \n  return res;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  --k;\n  vi p(n), q(n), P(n), Q(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i]; --p[i];\n    P[p[i]] = i;\n  }\n  for (int i = 0; i < n; ++i) {\n    cin >> q[i]; --q[i];\n    Q[q[i]] = i;\n  }\n  vvi mid(6);\n  mid[0] = p;\n  mid[1] = q;\n  mid[2] = mul(P, q);\n  mid[3] = P;\n  mid[4] = Q;\n  mid[5] = mul(p, Q);\n  vvi per(5, id(n));\n  per[1] = Q;\n  per[2] = mul(per[1], p);\n  per[3] = mul(per[2], q);\n  per[4] = mul(per[3], P);\n  int l = (k < 3) ? 0 : (k - 1) / 3 * 2 + (k % 3 == 0);\n  vi pref = mul(mpow(per[4], l / 4), per[l % 4]);\n  vi res = mul(mul(pref, mid[k % 6]), inv(pref));\n  for (int i = 0; i < res.size(); ++i) cout << res[i] + 1 << ' ';\n  cout << endl;\n/*  vs s(40);\n  s[0] = \"p\", s[1] = \"q\";\n  string pat = \"QpqP\";\n  for (int i = 2; i < s.size(); ++i) {\n    string& a = s[i];\n    a = s[i - 2];\n    reverse(a.begin(), a.end());\n    for (char& x : a) {\n      x = opp(x);\n    }\n    for (char x : s[i - 1]) {\n      if (a.empty() || tolower(a.back()) != tolower(x) || islower(a.back()) == islower(x)) {\n        a += x;\n      } else {\n        a.pop_back();\n      }\n    }\n    for (int j = 0; j < (int)s[i].size() / 2 - 1; ++j) assert(s[i][j] == pat[j % 4] && s[i][s[i].size() - 1 - j] == opp(pat[j % 4]));\n    cerr << s[i] << endl;\n  }*/\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long \nconst ll mod=1e9+7;\n\nbool ismatch(vector<ll> a,vector<ll> b){\n    for(ll i=0;i<a.size();i++){\n        if(a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n\n    ll n,k;\n    cin>>n>>k;\n    vector<ll> p;\n    for(ll i=0;i<n;i++){\n        ll x;\n        cin>>x;\n        p.push_back(x);\n    }\n\n    vector<ll> q;\n    for(ll i=0;i<n;i++){\n        ll x;\n        cin>>x;\n        q.push_back(x);\n    }\n\n    vector<ll> v[100];\n    v[0]=p;\n    v[1]=q;\n    ll j=2;\n    ll cnt=0;\n    while(1){\n        vector<ll> v1(n);\n        for(ll i=0;i<n;i++){\n            v1[v[j-2][i]-1]=v[j-1][i];\n        }\n        vector<ll> v2=v1;\n        v[j++]=v2;\n        cnt++;\n        if(ismatch(v[j-2],p) && ismatch(v[j-1],q)){\n            break;\n        }\n\n    }\n\n    ll ind=k%cnt;\n    if(ind==0){\n        ind=2;\n    }\n    for(ll i=0;i<n;i++){\n        cout<<v[ind-1][i]<<\" \";\n    }\n    cout<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+6;\nstruct permutain\n{\n    int a[N];\n    permutain(){memset(a,0,sizeof a);}\n    int& operator [](int x){return a[x];}\n}p,q,ip,iq,A,B,ans;\nint n,k;\npermutain operator *(permutain a,permutain b){\n    permutain c;\n    for(int i=1;i<=n;i++)\n        c[i]=a[b[i]];\n    return c;\n}\npermutain inv(permutain a)\n{\n    permutain b;\n    for(int i=1;i<=n;i++)\n        b[a[i]]=i;\n    return b;\n}\npermutain operator ^(permutain a,int b)\n{\n    permutain c;\n    for(int i=1;i<=n;i++)\n        c[i]=i;\n    while(b){\n        if(b&1)\n            c=c*a;\n        a=a*a;\n        b>>=1;\n    }\n    return c;\n}\nvoid Print(permutain x)\n{\n    for(int i=1;i<=n;i++)\n        printf(\"%d \",x.a[i]);\n    puts(\"\");\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&p[i]);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&q[i]);\n    ip=inv(p);\n    iq=inv(q);\n    int f=(k-1)/6,g=k-f*6;\n    permutain h=q*ip*iq*p;\n    A=h^f;\n    if(g==1)\n        B=p;\n    else if(g==2)\n        B=q;\n    else if(g==3)\n        B=q*ip;\n    else if(g==4)\n    {\n        A=A*q;\n        B=ip;\n    }\n    else if(g==5)\n    {\n        A=A*q*ip;\n        B=iq;\n    }\n    else\n    {\n        A=A*q*ip;\n        B=iq*p;\n    }\n    ans=A*B*inv(A);\n    Print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define fi first\n#define se second\n#define ll long long\n#define dbg(v) cerr<<#v<<\" = \"<<v<<'\\n'\n#define vi vector<int>\n#define vl vector <ll>\n#define pii pair<int,int>\n#define vii vector < pii >\n#define mp make_pair\n#define db long double\n#define pb push_back\n#define all(s) s.begin(),s.end()\ntemplate < class P , class Q > ostream& operator<<(ostream& stream, pair < P , Q > v){ stream << \"(\" << v.fi << ',' << v.se << \")\"; return stream;}\ntemplate < class T > ostream& operator<<(ostream& stream, const vector<T> v){ stream << \"[ \"; for (int i=0; i<(int)v.size(); i++) stream << v[i] << \" \"; stream << \"]\"; return stream;}\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nconst int N = 1e5 + 5;\nint p[N];\nint q[N];\nint ip[N];\nint iq[N];\nint w[30][N];\nint A[N];\nint B[N];\nint E[N];\nint iv[N];\nint main(void) {\n    int n,k;\n    cin>>n>>k;\n    --k;\n    for (int i = 1;i <= n;++i)\n        cin>>p[i],ip[p[i]] = i;\n    for (int i = 1;i <= n;++i)\n        cin>>q[i],iq[q[i]] = i;\n    for (int i = 1;i <= n;++i)\n        w[0][i] = q[ip[iq[p[i]]]];\n    for (int t = 1;t < 30;++t)\n        for (int i = 1;i <= n;++i)\n            w[t][i] = w[t - 1][w[t - 1][i]];\n    for (int i = 1;i <= n;++i) {\n        A[i] = i;\n        const int val[] = {p[i],q[i],q[ip[i]],ip[i],iq[i],iq[p[i]]};\n        B[i] = val[k % 6];\n    }\n    for (int t = 0;t < 30;++t)\n        if (((k / 6) >> t) & 1)\n            for (int i = 1;i <= n;++i)\n                A[i] = w[t][A[i]];\n    for (int i = 1;i <= n;++i) {\n        if (k % 6 == 3)\n            E[i] = A[q[i]];\n        else\n        if (k % 6 == 4)\n            E[i] = A[q[ip[i]]];\n        else\n        if (k % 6 == 5)\n            E[i] = A[q[ip[i]]];\n        else\n            E[i] = A[i];\n    }\n    for (int i = 1;i <= n;++i)\n        A[i] = E[i];\n    for (int i = 1;i <= n;++i)\n        iv[A[i]] = i;\n    for (int i = 1;i <= n;++i)\n        cout << A[B[iv[i]]] << \" \\n\"[i == n];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nusing namespace std;\ntypedef vector<int> vec;\nint N,K;\nvec p,q;\nvec mul(const vec &a,const vec &b){\n\tvec ret(N);\n\tREP(i,N){\n\t\tret[i]=a[b[i]];\n\t}\n\treturn ret;\n}\nvec inv(const vec &v){\n\tvec ret(N);\n\tREP(i,N){\n\t\tret[v[i]]=i;\n\t}\n\treturn ret;\n}\nvec pwr(vec n,int m){\n\tvec ret(N);\n\tREP(i,N)ret[i]=i;\n\twhile(m){\n\t\tif(m&1){\n\t\t\tret=mul(ret,n);\n\t\t}\n\t\tn=mul(n,n);\n\t\tm>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d %d\",&N,&K);\n\tK--;\n\tREP(i,N){\n\t\tint pi;\n\t\tscanf(\"%d\",&pi);\n\t\tpi--;\n\t\tp.push_back(pi);\n\t}\n\tREP(i,N){\n\t\tint qi;\n\t\tscanf(\"%d\",&qi);\n\t\tqi--;\n\t\tq.push_back(qi);\n\t}\n\tvec a,b;\n\ta=pwr(mul(mul(mul(q,inv(p)),inv(q)),p),K/6);\n\tK%=6;\n\tif(K==0){\n\t\tb=p;\n\t}else if(K==1){\n\t\tb=q;\n\t}else{\n\t\tvec b0=p,b1=q;\n\t\tREP(i,K-1){\n\t\t\tb=mul(b1,inv(b0));\n\t\t\tb0=b1;\n\t\t\tb1=b;\n\t\t}\n\t}\n\tvec ans=mul(mul(a,b),inv(a));\n\tREP(i,N){\n\t\tif(i)putchar(' ');\n\t\tprintf(\"%d\",ans[i]+1);\n\t}\n\tputchar('\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n#define rep(i, n) for (int i = 0; i < (int) n; i++)\n#define reps(i, n) for (int i = 1; i <= (int) n; i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) x.erase(unique(all(x)), x.end());\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << x << endl\nusing vint=vector<int>;\nusing vvint=vector<vint>;\nusing pint=pair<int, int>;\nusing vpint=vector<pint>;\nconstexpr double pi = 3.1415926535897932384626433832795028;\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\ninline int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ninline int lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> using priority_queue_rev=priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, const T2 &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, const T2 &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct Setup {\n    static constexpr int PREC = 20;\n    Setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nstruct Permutation {\n    const int n;\n    std::vector<int> data;\n    Permutation(int n) : n(n), data(n) { for (int i = 0; i < n; i++) { data[i] = i; }}\n    Permutation(std::vector<int> &src) : n(src.size()), data(src) {}\n    bool next() { return std::next_permutation(data.begin(), data.end()); }\n    bool prev() { return std::prev_permutation(data.begin(), data.end()); }\n    bool operator==(const Permutation &rhs) const { return data == rhs.data; }\n    bool operator!=(const Permutation &rhs) const { return data != rhs.data; }\n    int operator[](int i) const { return data[i]; }\n    Permutation &operator*=(const Permutation &rhs) {\n        std::vector<int> tmp(data);\n        for (int i = 0; i < n; i++) { data[i] = tmp[rhs[i]]; }\n        return *this;\n    }\n    Permutation &operator/=(const Permutation &rhs) { return *this *= rhs.inv(); }\n    Permutation operator*(const Permutation &rhs) const { return Permutation(*this) *= rhs; }\n    Permutation operator/(const Permutation &rhs) const { return Permutation(*this) /= rhs; }\n    Permutation inv() const {\n        std::vector<int> ret(n);\n        for (int i = 0; i < n; i++) { ret[data[i]] = i; }\n        return ret;\n    }\n    Permutation pow(long long m) const {\n        std::vector<int> ret(n);\n        std::vector<bool> used(n);\n        for (int i = 0; i < n; i++) {\n            if (used[i]) { continue; }\n            used[i] = true;\n            std::vector<int> cyc;\n            int cur = i;\n            do {\n                cyc.push_back(cur);\n                cur = data[cur];\n            } while (cur != i);\n            for (int j = 0; j < cyc.size(); j++) { ret[cyc[j]] = cyc[(j + m) % cyc.size()]; }\n        }\n        return ret;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Permutation &rhs) {\n        os << \"{\";\n        for (int i = 0; i < rhs.n; i++) { os << rhs[i] << (i + 1 != rhs.n ? \", \" : \"\"); }\n        os << \"}\";\n        return os;\n    }\n};\n\nint N, K;\nsigned main() {\n    cin >> N >> K;\n    vint p(N), q(N);\n    rep(i, N) { cin >> p[i], p[i]--; }\n    rep(i, N) { cin >> q[i], q[i]--; }\n    Permutation P(p), Q(q);\n    Permutation O(N);\n    int k = (K - 1) % 6;\n    if (k == 0) { O *= P; }\n    else if (k == 1) { O *= Q; }\n    else if (k == 2) { O *= Q / P; }\n    else if (k == 3) { O *= Q / P / Q; }\n    else if (k == 4) { O *= Q / P / Q * P / Q; }\n    else if (k == 5) { O *= Q / P / Q * P * P / Q; }\n    Permutation S = (Q / P / Q * P).pow((K - 1) / 6);\n    Permutation A = S * O / S;\n    rep(i, N) { cout << A[i] + 1 << endl; }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<18;\nint n;\nvoid Inv(int a[],int b[])\n{\n    for(int i=1;i<=n;i++)\n        b[a[i]]=i;\n}\nint tmp[Q],cmp[Q];\nvoid Mul(int a[],int b[],int c[])\n{\n    for(int i=1;i<=n;i++)\n        tmp[i]=a[b[i]];\n    for(int i=1;i<=n;i++)\n        c[i]=tmp[i];\n}\nint p[Q],q[Q];\nvoid R(int a[])\n{\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n}\nint owo[10][Q],cc[Q];\nvoid F(int p[],int q[],int f[])\n{\n    Inv(p,cc);\n    Mul(q,cc,f);\n}\nvoid Ksm(int a[],int b)\n{\n    for(int i=1;i<=n;i++)cmp[i]=i,cc[i]=a[i];\n    for(;b;b>>=1,Mul(cc,cc,cc))\n        if(b&1)Mul(cmp,cc,cmp);\n    for(int i=1;i<=n;i++)\n        a[i]=cmp[i];\n}\nint A[Q],ip[Q],iq[Q],IA[Q];\nint main()\n{\n    int k;\n    scanf(\"%d%d\",&n,&k);\n    R(p),R(q);\n    for(int i=1;i<=n;i++)\n        owo[1][i]=p[i],owo[2][i]=q[i],owo[0][i]=i;\n    for(int i=3;i<=6;i++)\n        F(owo[i-2],owo[i-1],owo[i]);\n    int rel=(k-1)%6+1;\n    for(int i=1;i<=n;i++)A[i]=q[i];\n    Inv(p,ip),Inv(q,iq);\n    Mul(A,ip,A);\n    Mul(A,iq,A);\n    Mul(A,p,A);\n    Inv(A,IA);\n    Ksm(A,(k-1)/6),Ksm(IA,(k-1)/6);\n    Mul(A,owo[rel],A);\n    Mul(A,IA,A);\n    for(int i=1;i<=n;i++)\n        printf(\"%d \",A[i]);\n    return 0;\n}\n/*\n10 6\n7 10 6 5 4 2 9 1 3 8\n4 1 9 2 3 7 8 10 6 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing perm = vector<int>;\nint N;\nperm inv(const perm& a) {\n\tperm r(N);\n\tfor (int i = 0; i < N; i++) r[a[i]] = i;\n\treturn r;\n}\nperm operator * (const perm& a, const perm& b) {\n\tperm r(N);\n\tfor (int i = 0; i < N; i++) r[i] = a[b[i]];\n\treturn r;\n}\n\nperm pow(perm a, int b) {\n\tperm r(N);\n\tiota(r.begin(),r.end(),0);\n\twhile (b) {\n\t\tif (b&1) r = r * a;\n\t\ta = a * a;\n\t\tb >>= 1;\n\t}\n\treturn r;\n}\n\nint K;\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N >> K; K--;\n\tperm P(N), Q(N);\n\tfor (int i = 0; i < N; i++) cin >> P[i], P[i]--;\n\tfor (int i = 0; i < N; i++) cin >> Q[i], Q[i]--;\n\tperm pref = Q * inv(P) * inv(Q) * P;\n\tpref = pow(pref, K / 6);\n\tperm mid;\n\tswitch(K % 6) {\n\t\tcase 0:\n\t\t\tmid = P;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmid = Q;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmid = Q * inv(P);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmid = Q * inv(P) * inv(Q);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmid = Q * inv(P) * inv(Q) * P * inv(Q);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmid = Q * inv(P) * inv(Q) * P * P * inv(Q);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t}\n\tperm res = pref * mid * inv(pref);\n\n\tfor (int i = 0; i < N; i++) cout << res[i]+1 << \" \\n\"[i+1==N];\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nvoid print(vector<int> a){\n    for (int i=0; i < a.size(); i++) cout << a[i]+1 << \" \";\n    exit(0);\n}\nvector<int> rev(vector<int> &a){\n    int n = a.size();\n    vector<int> res(n);\n    for (int i=0;i<n;i++) res[a[i]] = i;\n    return res;\n}\nvector<int> mult(vector<int> a, vector<int> b){\n    int n = a.size();\n    vector<int> res(n);\n    for (int i=0; i < n; i++) res[i] = b[a[i]];\n    return res;\n}\nvector<int> pw(vector<int> &a, int d){\n    if (d==0){\n        vector<int> K;\n        for (int i=0;i<a.size();i++) K.push_back(i);\n        return K;\n    }\n    if (d==1) return a;\n    if (d % 2 == 0){\n        vector<int> res = pw(a,d/2);\n        return mult(res, res);\n    }\n    return mult(a, pw(a,d-1));\n}\nvector<int> get(vector<vector<int> > kek, int d){\n    int n = kek[0].size();\n    vector<int> cp;\n    for (int i=0;i<n;i++) cp.push_back(i);\n    for (int i=0;i<4;i++) cp = mult(cp, kek[i]);\n    int N = d/4;\n    cp = pw(cp, N);\n    for (int i=0;i<(d%4);i++) cp = mult(cp, kek[i]);\n    return cp;\n}\nmain() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n), b(n);\n    for (int i=0; i < n; i++) cin >> a[i];\n    for (int i=0; i < n; i++) a[i]--;\n    for (int i=0; i < n; i++) cin >> b[i];\n    for (int i=0; i < n; i++) b[i]--;\n    if (k==1) print(a);\n    if (k==2) print(b);\n    int deg = ((k-3)/3) * 4 + 2;\n    if (k%3 == 1) deg++;\n    if (k%3==2) deg += 3;\n    vector<int> reva = rev(a), revb = rev(b);\n    vector<vector<int> > revlist = {revb, a, b, reva};\n    int need = (deg-1)/2;\n    vector<int> relax = get(revlist, need);\n    vector<int> R = rev(relax);\n    if (deg % 2 != 0){\n        if (deg % 8 == 7) relax = mult(relax, mult(a, R));\n        if (deg % 8 == 1) relax = mult(relax, mult(b, R));\n        if (deg % 8 == 3) relax = mult(relax, mult(reva, R));\n        if (deg % 8 == 5) relax = mult(relax, mult(revb, R));\n    }\n    else{\n        if (deg % 8 == 2) relax = mult(relax, mult(reva, mult(b, R)));\n        if (deg % 8 == 6) relax = mult(relax, mult(revb, mult(a, R)));\n    }\n    print(relax);\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define each(a,x) for(auto a : (x))\n#define all(a) (a).begin(),(a).end()\n#define chmin(a,b) ((a) = min((a),(b)))\n#define chmax(a,b) ((a) = max((a),(b)))\n#define in_range(x,l,r) ((l)<=(x) && (x)<(r))\n#define printvec(a) rep(i,a) cout << a[i] << \" \\n\"[i+1==(a).size()];\n#define fs first\n#define sc second\n#define em emplace\n#define eb emplace_back\n#define sz size()\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\n\nconst ll INF = 1e8;\nconst D EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\ninline vi inverse(const vi& perm) {\n  vi inv(perm.size());\n  rep(i, perm.size()) {\n    inv[perm[i]] = i;\n  }\n  return inv;\n}\n\nvi multiply(const vi& a, const vi& b) {\n  vi ans(a.size());\n  rep(i, a.size()){\n    ans[i] = b[a[i]];\n  }\n  return ans;\n}\n\nvi pow(const vi& a, ll k) {\n  if (k == 0) {\n    vi ans(a.size());\n    rep(i, a.size()) ans[i] = i;\n    return ans;\n  }\n\n  vi ans = pow(a, k / 2);\n  ans = multiply(ans, ans);\n  if (k & 1LL) {\n    ans = multiply(ans, a);\n  }\n  return ans;\n}\n\nint main(){\n  ll n, k;\n  cin >> n >> k;\n  vi p(n), q(n);\n  rep(i,n) {\n    cin >> p[i]; p[i]--;\n  }\n  rep(i,n) {\n    cin >> q[i]; q[i]--;\n  }\n\n  vi ans(n);\n  if (k < 7) {\n    vi a1 = p, a2 = q;\n    for(int i = 3; i <= k; ++i) {\n      vi a3 = multiply(inverse(a1), a2);\n      swap(a1, a2);\n      swap(a2, a3);\n    }\n    ans = a2;\n  } else {\n    vi prefix_base = multiply(inverse(q), multiply(p, multiply(q, inverse(p))));\n    vi prefix = pow(prefix_base, (k-2) / 6);\n    vi suffix_base = multiply(inverse(p), multiply(q, multiply(p, inverse(q))));\n    vi suffix = pow(suffix_base, (k-2) / 6);\n    vi very_suffix = multiply(inverse(p), q);\n\n    /*\n    vi core = multiply(inverse(q), multiply(p, multiply(q, multiply(p, inverse(q)))));\n    if (k % 6 == 2LL) {\n      core.resize(n);\n      rep(i, n) core[i] = i;\n    } else if (k % 6 == 3LL) {\n      core = p;\n    } else if (k % 6 == 4LL) {\n      core = inverse(q);\n    } else if (k % 6 == 5LL) {\n      core = multiply(inverse(q), multiply(p, inverse(q)));\n    } else if (k % 6 == 0LL) {\n      core = multiply(inverse(q), multiply(p, multiply(p, inverse(q))));\n    }\n    */\n    vi core = multiply(inverse(q), multiply(p, multiply(q, multiply(p, inverse(q)))));\n    if (k % 6 == 2LL) {\n      core = p;\n    } else if (k % 6 == 3LL) {\n      core.resize(n);\n      rep(i, n) core[i] = i;\n    } else if (k % 6 == 4LL) {\n      core = inverse(q);\n    } else if (k % 6 == 5LL) {\n      core = multiply(inverse(q), multiply(p, inverse(q)));\n    } else if (k % 6 == 0LL) {\n      core = multiply(inverse(q), multiply(p, multiply(p, inverse(q))));\n    }\n\n    ans = multiply(prefix, multiply(core, multiply(suffix, very_suffix)));\n    /*\n    vi a1 = p, a2 = q;\n    for(int i = 3; i <= k; ++i) {\n      vi a3 = multiply(inverse(a1), a2);\n      swap(a1, a2);\n      swap(a2, a3);\n    }\n\n    rep(i, n) {\n      cerr << ans[i] + 1 << \" \\n\"[i == n-1];\n    }\n    rep(i, n) {\n      cerr << a2[i] + 1 << \" \\n\"[i == n-1];\n    }\n    assert(ans == a2);\n    */\n  }\n\n  rep(i, n) {\n    cout << ans[i] + 1 << \" \\n\"[i == n-1];\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nstd::vector<int> a[100005];\nint n,k,cnt,used[100005];\nint ans[100005],p[100005],pp[100005],q[100005],qq[100005],g[100005],gg[100005],gk[100005],ggk[100005],f[10][100005],ff[10][100005];\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&q[i]);\n\tfor (int i=1;i<=n;i++) f[0][i]=i;\n\tfor (int i=1;i<=n;i++) ff[0][i]=i;\n\tfor (int i=1;i<=n;i++) f[1][i]=p[i];\n\tfor (int i=1;i<=n;i++) f[2][i]=q[i];\n\tfor (int i=1;i<=n;i++) ff[1][f[1][i]]=i;\n\tfor (int i=1;i<=n;i++) ff[2][f[2][i]]=i;\n\tfor (int r=3;r<=6;r++)\n\t{\n\t\tfor (int i=1;i<=n;i++) f[r][i]=f[r-1][ff[r-2][i]];\n\t\tfor (int i=1;i<=n;i++) ff[r][f[r][i]]=i;\n\t}\n\tfor (int i=1;i<=n;i++) pp[p[i]]=i;\n\tfor (int i=1;i<=n;i++) qq[q[i]]=i;\n\tfor (int i=1;i<=n;i++) g[i]=q[pp[qq[p[i]]]];\n\tfor (int i=1;i<=n;i++) gg[g[i]]=i;\n//\tfor (int i=1;i<=n;i++) printf(\"%d \",g[i]);puts(\"\");\n\tfor (int i=1;i<=n;i++)\n\t    if (!used[i])\n\t    {\n\t\t\tint x=++cnt;\n\t\t\tused[i]=1;\n\t\t\ta[x].push_back(i);\n\t    \tfor (int j=g[i];!used[j];j=g[j])\n\t    \t{\n\t    \t\ta[x].push_back(j);\n\t    \t\tused[j]=1;\n\t\t\t}\n\t    }\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tint sz=a[i].size();\n\t\tfor (int j=0;j<a[i].size();j++)\n\t\t{\n\t\t\tint x=a[i][j],y=a[i][(j+(k-1)/6)%sz];\n\t\t\tgk[x]=y;\n\t\t}\n\t}\n//\tfor (int i=1;i<=n;i++) printf(\"%d \",gk[i]);puts(\"\");\n\tfor (int i=1;i<=n;i++) used[i]=0;\n\tfor (int i=1;i<=cnt;i++) a[i].clear();cnt=0;\n\tfor (int i=1;i<=n;i++)\n\t    if (!used[i])\n\t    {\n\t\t\tint x=++cnt;\n\t\t\tused[i]=1;\n\t\t\ta[x].push_back(i);\n\t    \tfor (int j=gg[i];!used[j];j=gg[j])\n\t    \t{\n\t    \t\ta[x].push_back(j);\n\t    \t\tused[j]=1;\n\t\t\t}\n\t    }\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tint sz=a[i].size();\n\t\tfor (int j=0;j<a[i].size();j++)\n\t\t{\n\t\t\tint x=a[i][j],y=a[i][(j+(k-1)/6)%sz];\n\t\t\tggk[x]=y;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) used[i]=0;\n\tfor (int i=1;i<=cnt;i++) a[i].clear();cnt=0;\n\tfor (int i=1;i<=n;i++) ans[i]=gk[f[(k-1)%6+1][ggk[i]]];\n\t\n\tfor (int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main () {\n  int N;\n  long long K;\n  cin >> N >> K;\n  vector<vector<int>>B(6,vector<int>(N + 1));\n  vector<vector<int>>A(6,vector<int>(N + 1));\n  vector<int>key(N + 1);\n  int an[100002];\n  vector<int>an_(N + 1);\n  vector<int>ans(N + 1);\n  for (int i = 1; i <= N; i ++) {\n    cin >> B[1][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    cin >> B[2][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    B[3][B[1][i]] = B[2][i];\n    B[4][B[1][i]] = i;\n    B[5][B[2][i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    B[0][B[4][i]] = B[5][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    A[1][i] = i;\n    A[2][i] = i;\n    A[3][i] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    A[4][i] = B[2][i];\n    A[5][i] = B[3][i];\n    A[0][i] = B[3][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    key[i] = B[2][B[4][B[5][B[1][i]]]];\n  }\n  int jun = (int)K % 6;\n  int ju = (int)(K - 1) / 6;\n  for (int i = 1; i <= N; i ++) {\n    an[i] = A[jun][i];\n  }\n  for (int i = 0; i < ju; i ++) {\n    for (int j = 1; j <= N; j ++) {\n      an[j] = key[an[j]];\n    }\n  }\n  for (int i = 1; i <= N; i ++) {\n    an_[an[i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    ans[i] = an[B[jun][an_[i]]];\n  }\n  for (int i = 1; i < N; i ++) {\n    cout << ans[i] << ' ';\n  }\n  cout << ans[N] << endl;\n}\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=100005;\nint n,K,i,p[N],q[N],invp[N],invq[N],a[N],b[N],c[N],x[10][N],ans[N],m;\nvoid Mult(int a[N],int b[N],int rtn[N])\n{\n\tfor(int i=1;i<=n;++i)\n\t\trtn[i]=a[b[i]];\n}\nvoid Inv(int a[N],int rtn[N])\n{\n\tfor(int i=1;i<=n;++i)\n\t\trtn[a[i]]=i;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",p+i);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",q+i);\n\tInv(p,invp);\n\tInv(q,invq);\n\tfor(i=1;i<=n;++i)\n\t\tx[1][i]=p[i],x[2][i]=q[i];\n\tMult(q,invp,x[3]);\n\tMult(x[3],invq,x[4]);\n\tMult(x[4],p,a);\n\tMult(a,invq,x[5]);\n\tMult(a,p,b);\n\tMult(b,invq,x[0]);\n\tInv(a,b);\n\tm=(K-1)/6;\n\tfor(i=1;i<=n;++i)\n\t\tans[i]=i;\n\twhile(m)\n\t{\n\t\tif(m&1)\n\t\t{\n\t\t\tMult(ans,a,c);\n\t\t\tfor(i=1;i<=n;++i)\n\t\t\t\tans[i]=c[i];\n\t\t}\n\t\tMult(a,a,c);\n\t\tfor(i=1;i<=n;++i)\n\t\t\ta[i]=c[i];\n\t\tm>>=1;\n\t}\n\tMult(ans,x[K%6],c);\n\tfor(i=1;i<=n;++i)\n\t\tans[i]=c[i];\n\tm=(K-1)/6;\n\twhile(m)\n\t{\n\t\tif(m&1)\n\t\t{\n\t\t\tMult(ans,b,c);\n\t\t\tfor(i=1;i<=n;++i)\n\t\t\t\tans[i]=c[i];\n\t\t}\n\t\tMult(b,b,c);\n\t\tfor(i=1;i<=n;++i)\n\t\t\tb[i]=c[i];\n\t\tm>>=1;\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tprintf(\"%d \", ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long LL;\ntemplate<typename T>\ninline void read(T &x){\n\tint ch = getchar(); x = 0;\n\tbool f = false;\n\twhile((ch < '0' || ch > '9') && ch != '-') ch = getchar();\n\tif(ch == '-'){f = true; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9'){x = x * 10 + ch - '0'; ch = getchar();}\n\tif(f) x = -x;\t\n}\nint n, k;\nvi a[6], A;\ninline vi inv(const vi &p){\n\tvi q(n);\n\tfor(Rint i = 0;i < n;++ i) q[p[i]] = i;\n\treturn q;\n}\ninline vi mul(const vi &p, const vi &q){\n\tvi r(n);\n\tfor(Rint i = 0;i < n;++ i) r[i] = p[q[i]];\n\treturn r;\n}\ninline vi ksm(vi a, int b){\n\tvi res(n);\n\tfor(Rint i = 0;i < n;++ i) res[i] = i;\n\twhile(b){\n\t\tif(b & 1) res = mul(res, a);\n\t\ta = mul(a, a); b >>= 1;\n\t}\n\treturn res;\n}\nint main(){\n\tread(n); read(k); -- k;\n\ta[0].resize(n); for(Rint i = 0;i < n;++ i) read(a[0][i]), -- a[0][i];\n\ta[1].resize(n); for(Rint i = 0;i < n;++ i) read(a[1][i]), -- a[1][i];\n\tfor(Rint i = 2;i < 6;++ i) a[i] = mul(a[i - 1], inv(a[i - 2]));\n\tif(k < 6){for(Rint i = 0;i < n;++ i) printf(\"%d \", a[k][i] + 1); return 0;}\n\tA = ksm(mul(mul(a[1], inv(a[0])), mul(inv(a[1]), a[0])), k / 6);\n\tA = mul(mul(A, a[k % 6]), inv(A));\n\tfor(Rint i = 0;i < n;++ i) printf(\"%d \", A[i] + 1); \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\ntemplate <typename T>\nvoid debug_out(T t) {\n  cerr << t;\n}\n\ntemplate <typename A, typename B>\nvoid debug_out(pair<A, B> u) {\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\n}\n\ntemplate <typename T>\nvoid debug_out(vector<T> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << \", \";\n  }\n}\n\ntemplate <typename T>\nvoid debug_out(vector<vector<T>> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << endl;\n  }\n}\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\" << endl, debug_out(__VA_ARGS__), cerr << endl;\n\n\nint n, k;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  k--;\n  vector<int> p(n);\n  range(i, 0, n) {\n    cin >> p[i];\n    p[i]--;\n  }\n  vector<int> q(n);\n  range(i, 0, n) {\n    cin >> q[i];\n    q[i]--;\n  }\n  auto f = [&] (vector<int> x, vector<int> y) {\n    vector<int> a(n);\n    range(i, 0, n) a[x[i]] = y[i];\n    return a;\n  };\n  vector<int> a = q;\n  vector<int> b = f(p, q);\n  int cnt = 1;\n  while(a != p || b != q) {\n    vector<int> _b = b;\n    b = f(a, b);\n    a = _b;\n    cnt++;\n  }\n  k %= cnt;\n  a = p;\n  b = q;\n  while(k--) {\n    vector<int> _b = b;\n    b = f(a, b);\n    a = _b;\n  }\n  for(int i : a) cout << i + 1 << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define vec vector<int>\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\nint read(){\n    R int res,f=1;R char ch;\n    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);\n    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');\n    return res*f;\n}\nchar sr[1<<21],z[20];int C=-1,Z=0;\ninline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\nvoid print(R int x){\n    if(C>1<<20)Ot();if(x<0)sr[++C]='-',x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]=' ';\n}\nconst int N=1e5+5;\nvec p,q,ip,iq,a[9];int n,k;\nvec Inv(const vec &A){\n\tvec B(n);\n\tfp(i,0,n-1)B[A[i]]=i;\n\treturn B;\n}\nvec Mul(const vec &A,const vec &B){\n\tvec C(n);\n\tfp(i,0,n-1)C[i]=A[B[i]];\n\treturn C;\n}\nvec ksm(vec x,int y){\n\tvec res(n);fp(i,0,n-1)res[i]=i;\n\tfor(;y;y>>=1,x=Mul(x,x))if(y&1)res=Mul(res,x);\n\treturn res;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tn=read(),k=read(),p.resize(n),q.resize(n);\n\tfp(i,0,n-1)p[i]=read()-1;\n\tfp(i,0,n-1)q[i]=read()-1;\n\tip=Inv(p),iq=Inv(q),a[1]=p,a[2]=q;\n\tfp(i,3,6)a[i]=Mul(a[i-1],Inv(a[i-2]));\n\tint len=(k-1)/6;\n\tvec cir=ksm(Mul(q,Mul(ip,Mul(iq,p))),len);\n\tvec res=Mul(cir,Mul(a[k-len*6],Inv(cir)));\n\tfp(i,0,n-1)print(res[i]+1);\n\treturn Ot(),0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-19 18:52:05\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\nconst int N=100010;\nint n;\nstruct arr\n{\n\tint a[N];\n\tarr(){ memset(a,0,sizeof(a)); }\n\tint &operator[](int p){ return a[p]; }\n};\narr inv(arr a)\n{\n\tarr b;\n\tfr(i,1,n) b[a[i]]=i;\n\treturn b;\n}\narr operator*(arr a,arr b)\n{\n\tarr c;\n\tfr(i,1,n) c[i]=a[b[i]];\n\treturn c;\n}\narr &operator*=(arr &a,arr b){ return a=a*b; }\nint k;\narr a,b,c;\narr power(arr a,int b)\n{\n\tarr r;\n\tfr(i,1,n) r[i]=i;\n\tfor(;b;b>>=1,a*=a) if(b&1) r*=a;\n\treturn r;\n}\nint main()\n{\n\tn=read(); k=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n) b[i]=read();\n\tc=b*inv(a)*inv(b)*a; k--;\n\twhile(k%6)\n\t{\n\t\tarr d=a; a=b; b*=inv(d); k--;\n\t}\n\ta=power(c,k/6)*a*power(inv(c),k/6);\n\tfr(i,1,n) printf(\"%d%c\",a[i],i==n?'\\n':' ');\n\treturn 0;\n}\n/*\na\nb\nbA\nbAB\nbABaB\nbABaaB\nbABabaB\nbABabAbaB\n*/"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <list>\n#include <ostream>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\nusing X = vector<int>;\n\nX inverse(X x) {\n  X r(x.size());\n  for(int i = 0; i < x.size(); i++) r[x[i]] = i;\n  return r;\n}\n\nX op(X a, X b) {\n  X r(a.size());\n  for(int i = 0; i < a.size(); i++) r[i] = a[b[i]];\n  return r;\n}\n\nX f(X a, X b) {\n  X r(a.size());\n  for(int i = 0; i < a.size(); i++) r[a[i]] = b[i];\n  return r;\n}\n\nint n, k;\n\nX getE() {\n  X r(n);\n  iota(begin(r), end(r), 0);\n  return r;\n}\n\nX x[4];\nint cycle[] = {1, 3, 2, 0};\n\n// 実験しただけ…\n\nX get(int start, int t) {\n  int t4 = t / 4;\n  auto a = getE();\n  for(int i = 0; i < 4; i++) a = op(a, x[cycle[(start + i) % 4]]);\n  auto r = getE();\n  while(t4) {\n    if(t4 & 1) r = op(r, a);\n    a = op(a, a);\n    t4 >>= 1;\n  }\n  t %= 4;\n  for(int i = 0; i < t; i++) r = op(r, x[cycle[(start + i) % 4]]);\n  return r;\n}\n\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n\n  cin >> n >> k;\n  k--;\n  X p(n), q(n);\n  for(auto & e: p) cin >> e, e--;\n  for(auto & e: q) cin >> e, e--;\n  x[0] = p;\n  x[1] = q;\n  x[2] = inverse(q);\n  x[3] = inverse(p);\n\n  // assert(p == inverse(x[3]));\n  // assert(q == inverse(x[2]));\n\n  vector<vector<int>> v;\n  v.push_back({0});\n  v.push_back({1});\n  for(int i = 0; i < 15; i++) {\n    auto u = v[i];\n    auto w = v[i+1];\n    for(auto &e : u) e = 3 - e;\n    while(u.size() && w.size() && u.back() + w.back() == 3) w.pop_back(), u.pop_back();\n    reverse(u.begin(), u.end());\n    w.insert(w.end(), u.begin(), u.end());\n    v.push_back(w);\n    // dump(i, v[i].size());\n    // dump(v[i]);\n  }\n\n  auto r = getE();\n  if(k <= 10) {\n    for(int i = 0; i < v[k].size(); i++) r = op(r, x[v[k][i]]);\n  } else {\n    int c = 5 + 2 * ((k - 6) / 3);\n    int len = 6 + 4 * ((k - 5) / 3);\n    switch(k % 3) {\n      case 0:\n        len += 1;\n        break;\n      case 1:\n        len += 3;\n        break;\n      case 2:\n        c++;\n        break;\n    }\n    assert(len >= c);\n    auto a = get(0, c);\n    auto b = inverse(get(0, len - c));\n    r = op(a, b);\n  }\n\n  for(int i = 0; i < n; i++) cout << r[i] + 1 << \" \\n\"[i == n - 1];\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 16.03.2019 15:14:06       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> inv(vector<int> a) {\n  int n = (int) a.size();\n  vector<int> b(n);\n  for (int i = 0; i < n; i++) b[a[i]] = i;\n  return b;\n}\n\nvoid output(vector<int> a) {\n  int n = (int) a.size();\n  for (int i = 0; i < n; i++) {\n    if (i > 0) cout << \" \";\n    cout << a[i] + 1;\n  }\n  cout << '\\n';\n  exit(0);\n}\n\nvector<int> apply(vector<int> a, vector<int> b) {\n  int n = (int) a.size();\n  vector<int> c(n);\n  for (int i = 0; i < n; i++) {\n    c[i] = a[b[i]];\n  }\n  return c;\n}\n\nvector<int> power(vector<int> a, int b) {\n  int n = (int) a.size();\n  vector<int> x(n);\n  iota(x.begin(), x.end(), 0);\n  while (b > 0) {\n    if (b & 1) {\n      x = apply(x, a);\n    }\n    a = apply(a, a);\n    b >>= 1;\n  }\n  return x;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i]--;\n  }\n  vector<int> b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> b[i];\n    b[i]--;\n  }\n  vector<int> A = inv(a);\n  vector<int> B = inv(b);\n  if (k == 1) {\n    output(a);\n  }\n  if (k == 2) {\n    output(b);\n  }\n  int pref = (k * 2 - 4) / 3;\n  vector<int> p = power(apply(b, apply(A, apply(B, a))), pref / 4);\n  if (pref % 4 == 3) p = apply(p, apply(b, apply(A, B)));\n  if (pref % 4 == 2) p = apply(p, apply(b, A));\n  if (pref % 4 == 1) p = apply(p, b);\n  vector<int> P = inv(p);\n  vector<int> res = P;\n  if (k % 6 == 1) res = apply(a, res);\n  if (k % 6 == 2) res = apply(b, res);\n  if (k % 6 == 3) res = apply(b, apply(A, res));\n  if (k % 6 == 4) res = apply(A, res);\n  if (k % 6 == 5) res = apply(B, res);\n  if (k % 6 == 0) res = apply(B, apply(a, res));\n  res = apply(p, res);\n  output(res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 100005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N,K;\nstruct pl {\n    int f[100005];\n    friend pl operator * (const pl &a,const pl &b) {\n\tpl c;\n\tfor(int i = 1 ; i <= N ; ++i) c.f[i] = a.f[b.f[i]];\n\treturn c;\n    }\n    pl inv() {\n\tpl c;\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    c.f[f[i]] = i;\n\t}\n\treturn c;\n    }\n}p,q,iq,ip,s,res,t,ans;\nvoid fpow(int c) {\n    for(int i = 1 ; i <= N ; ++i) res.f[i] = i;\n    t = s;\n    while(c) {\n\tif(c & 1) res = res * t;\n\tt = t * t;\n\tc >>= 1;\n    }\n}\nvoid Solve() {\n    read(N);read(K);\n    for(int i = 1 ; i <= N ; ++i) read(p.f[i]);\n    for(int i = 1 ; i <= N ; ++i) read(q.f[i]);\n    ip = p.inv();iq = q.inv();\n    s = q * ip * iq * p;\n    fpow((K - 1) / 6);\n    int x = (K - 1) % 6;\n    if(x == 0) {\n\tans = res * p * res.inv();\n    }\n    else if(x == 1) {\n\tans = res * q * res.inv();\n    }\n    else if(x == 2) {\n\tans = res * q * ip * res.inv();\n    }\n    else if(x == 3) {\n\tres = res * q;\n\tans = res * ip * res.inv();\n    }\n    else if(x == 4) {\n\tres = res * q * ip;\n\tans = res * iq * res.inv();\n    }\n    else if(x == 5) {\n\tres = res * q * ip;\n\tans = res * iq * p * res.inv();\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n\tout(ans.f[i]);space;\n    }\n    enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int _ = 1e5 + 7;\nstruct permutation{\n\tint arr[_];\n\tvoid input(int len){arr[0] = len; for(int i = 1 ; i <= len ; ++i) cin >> arr[i];}\n\tint& operator [](int x){return arr[x];}\n\tpermutation reverse(){\n\t\tpermutation temp; temp[0] = arr[0];\n\t\tfor(int i = 1 ; i <= arr[0] ; ++i) temp[arr[i]] = i;\n\t\treturn temp;\n\t}\n\tfriend permutation operator *(permutation p , permutation q){\n\t\tpermutation temp; for(int i = 1 ; i <= p[0] ; ++i) temp[i] = p[q[i]];\n\t\ttemp[0] = p[0]; return temp;\n\t}\n\tpermutation pow(int x){\n\t\tbool vis[_] = {}; permutation now; now[0] = arr[0];\n\t\tif(x == 0) for(int i = 1 ; i <= arr[0] ; ++i) now[i] = i;\n\t\telse\n\t\t\tfor(int i = 1 ; i <= arr[0] ; ++i)\n\t\t\t\tif(!vis[i]){\n\t\t\t\t\tint dis = 0 , tmp = i; vector < int > pot;\n\t\t\t\t\tdo{++dis; vis[tmp] = 1; pot.push_back(tmp); tmp = arr[tmp];}while(tmp != i);\n\t\t\t\t\tfor(int i = 0 ; i < pot.size() ; ++i) now[pot[i]] = pot[(i + x % pot.size()) % pot.size()];\n\t\t\t\t}\n\t\treturn now;\n\t}\n\tvoid output(){for(int i = 1 ; i <= arr[0] ; ++i) cout << arr[i] << ' ';}\n}arr[6] , tmp; int N , K;\n\nint main(){\n\tint N; cin >> N >> K; arr[0].input(N); arr[1].input(N); --K;\n\tfor(int i = 2 ; i < 6 ; ++i) arr[i] = arr[i - 1] * arr[i - 2].reverse();\n\ttmp = (arr[1] * arr[0].reverse() * arr[1].reverse() * arr[0]).pow(K / 6);\n\t(tmp * arr[K % 6] * tmp.reverse()).output();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nvector<int> operator * (const vector<int> & a, const vector<int> & b)\n{\n\tvector<int> ret(n + 1);\n\tfor(int i = 1; i <= n; ++i) ret[i] = a[b[i]];\n\treturn ret;\n}\nvector<int> inv(const vector<int> & a)\n{\n\tvector<int> ret(n + 1);\n\tfor(int i = 1; i <= n; ++i) ret[a[i]] = i;\n\treturn ret;\n}\nvector<int> Pow(const vector<int> & a, int k)\n{\n\tvector<bool> vis(n + 1, 0);\n\tvector<int> ret(n + 1);\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!vis[i])\n\t\t{\n\t\t\tvector<int> cycle;\n\t\t\tint cur = i;\n\t\t\twhile(!vis[cur])\n\t\t\t{\n\t\t\t\tvis[cur] = 1;\n\t\t\t\tcycle.push_back(cur);\n\t\t\t\tcur = a[cur];\n\t\t\t}\n\t\t\tfor(int j = 0; j < cycle.size(); ++j)\n\t\t\t\tret[cycle[j]] = cycle[(j + k) % cycle.size()];\n\t\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tvector<int> a[6]; for(int i = 0; i < 6; ++i) a[i] = vector<int>(n + 1);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &a[0][i]);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &a[1][i]);\n\tfor(int i = 2; i < 6; ++i) a[i] = a[i - 1] * inv(a[i - 2]);\n\tauto A = a[1] * inv(a[0]) * inv(a[1]) * a[0], P = Pow(A, (k - 1) / 6);\n\tauto ans = P * a[(k - 1) % 6] * inv(P);\n\tfor(int i = 1; i <= n; ++i) printf(\"%d \", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long LL;\ntemplate<typename T>\ninline void read(T &x){\n\tint ch = getchar(); x = 0;\n\tbool f = false;\n\twhile((ch < '0' || ch > '9') && ch != '-') ch = getchar();\n\tif(ch == '-'){f = true; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9'){x = x * 10 + ch - '0'; ch = getchar();}\n\tif(f) x = -x;\t\n}\nint n, k;\nvi a[6], A;\ninline vi inv(const vi &p){\n\tvi q(n);\n\tfor(Rint i = 0;i < n;++ i) q[p[i]] = i;\n\treturn q;\n}\ninline vi mul(const vi &p, const vi &q){\n\tvi r(n);\n\tfor(Rint i = 0;i < n;++ i) r[i] = p[q[i]];\n\treturn r;\n}\ninline vi ksm(vi a, int b){\n\tvi res(n);\n\tfor(Rint i = 0;i < n;++ i) res[i] = i;\n\twhile(b){\n\t\tif(b & 1) res = mul(res, a);\n\t\ta = mul(a, a); b >>= 1;\n\t}\n\treturn res;\n}\nint main(){\n\tread(n); read(k); -- k;\n\ta[0].resize(n); for(Rint i = 0;i < n;++ i) read(a[0][i]), -- a[0][i];\n\ta[1].resize(n); for(Rint i = 0;i < n;++ i) read(a[1][i]), -- a[1][i];\n\tfor(Rint i = 2;i < 6;++ i) a[i] = mul(a[i - 1], inv(a[i - 2]));\n\tif(k < 6){for(Rint i = 0;i < n;++ i) printf(\"%d \", a[k][i] + 1); return 0;}\n\tA = ksm(mul(mul(a[1], inv(a[0])), mul(inv(a[1]), a[0])), k / 6);\n\tA = mul(mul(A, a[k % 6]), inv(A));\n\tfor(Rint i = 0;i < n;++ i) printf(\"%d \", A[i] + 1); \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nint N;\nint K;\nusing P = vector<int>;\nP e;\n\nP Rev(P p) {\n  P rev(p.size());\n  rep(i, N) {\n    rev[p[i]] = i;\n  }\n  return rev;\n}\n\nP Conv(P p, P q) {\n  P ret(N);\n  rep(i, N) {\n    ret[i] = p[q[i]];\n  }\n  return ret;\n}\n\nvoid Out(P p) {\n  rep(i, N) {\n    printf(\"%d%c\", p[i]+1, \" \\n\"[i == N-1]);\n  }\n}\n\nint main() {\n  scanf(\"%d%d\", &N, &K);\n  rep(i, N) e.eb(i);\n  \n  vector<int> p(N);\n  vector<int> q(N);\n  rep(i, N) {\n    scanf(\"%d\", &p[i]);\n    --p[i];\n  }\n  rep(i, N) {\n    scanf(\"%d\", &q[i]);\n    --q[i];\n  }\n\n  if (K == 1) {\n    Out(p);\n    return 0;\n  }\n\n  if (K == 2) {\n    Out(q);\n    return 0;\n  }\n\n  int L = K-4;\n  P rp = Rev(p);\n  P rq = Rev(q);\n  P g = Conv(Conv(rp, rq), Conv(p, q));\n  int t = L/6;\n\n  if (K == 3) {\n    Out(Conv(q, rp));\n    return 0;\n  }\n  \n  P h(q);\n  rep(i, 30) {\n    if (t >> i & 1) {\n      h = Conv(h, g);\n    }\n    g = Conv(g, g);\n  }\n\n  P ans(e);\n  switch(L%6) {\n  case 0:\n    ans = Conv(Conv(h, rp), Rev(h));\n    break;\n  case 1:\n    h = Conv(h, rp);\n    ans = Conv(Conv(h, rq), Rev(h));\n    break;\n  case 2:\n    h = Conv(h, rp);\n    ans = Conv(Conv(h, Conv(rq, p)), Rev(h));\n    break;\n  case 3:\n    h = Conv(h, Conv(rp, rq));\n    ans = Conv(Conv(h, p), Rev(h));\n    break;\n  case 4:\n    h = Conv(h, Conv(Conv(rp, rq), p));\n    ans = Conv(Conv(h, q), Rev(h));\n    break;\n  case 5:\n    h = Conv(h, Conv(Conv(rp, rq), p));\n    ans = Conv(Conv(h, Conv(q, rp)), Rev(h));\n    break;\n  default:\n    assert(0);\n  }\n  Out(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint n;\nstruct P{\n\tint p[100010];\n\tvoid init()\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tp[i]=i;\n\t}\n};\nP res;\nP operator *(const P& a,const P& b)\n{\n\tfor(int i=1;i<=n;i++)\n\t\tres.p[i]=a.p[b.p[i]];\n\treturn res;\n}\nP ans,t;\nP fpow(const P& a,int b)\n{\n\tans.init();t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=ans*t;\n\t\tt=t*t;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nP tmp;\nP getinv(const P& a)\n{\n\tfor(int i=1;i<=n;i++)\n\t\ttmp.p[a.p[i]]=i;\n\treturn tmp;\n}\nP A,Ainv,p,pinv,q,qinv,fans;\nP a[7];\nvoid input(P& a)\n{\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a.p[i]);\n\treturn ;\n}\nint main()\n{\n\tint k;\n\tscanf(\"%d %d\",&n,&k);\n\tinput(p);input(q);\n\tpinv=getinv(p);\n\tqinv=getinv(q);\n\tA=q*pinv*qinv*p;\n\tAinv=getinv(A);\n\ta[1]=p;\n\ta[2]=q;\n\tfor(int i=3;i<=6;i++)\n\t\ta[i]=a[i-1]*getinv(a[i-2]);\n\tfans=fpow(A,(k-1)/6)*a[(k-1)%6+1]*fpow(Ainv,(k-1)/6);\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%d \",fans.p[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll n, k;\nvector<ll> p, q, ip, iq, tot1, tot2, id;\n\nvector<ll> mul(vector<ll> a, vector<ll> b) {\n\tvector<ll> ans;\n\tans.resize(n);\n\tfor (ll i = 0; i < n; ++i)\n\t\tans[i] = a[b[i]];\n\treturn ans;\n}\n\nvector<ll> inv(vector<ll> a) {\n\tvector<ll> ans;\n\tans.resize(n);\n\tfor (ll i = 0; i < n; ++i)\n\t\tans[a[i]] = i;\n\treturn ans;\n}\n\nvector<ll> exp(vector<ll> a, ll j) {\n\tif (j == 0)\n\t\treturn id;\n\tif (j%2 == 1)\n\t\treturn mul(a, exp(a, j-1));\n\tauto b = exp(a, j/2);\n\treturn mul(b, b);\n}\n\nvector<ll> get1(ll j) {\n\tll l = 2*((j-1)/3);\n\tif (j%3 != 1)\n\t\tl += 2;\n\tauto ans = exp(tot1, l/4);\n\tif (l%4 == 0)\n\t\treturn ans;\n\tif (l%4 == 1)\n\t\treturn mul(ans, q);\n\tif (l%4 == 2)\n\t\treturn mul(ans, mul(q, ip));\n\tif (l%4 == 3)\n\t\treturn mul(ans, mul(q, mul(ip, iq)));\n}\n\nvector<ll> get2(ll j) {\n\tll l = 2*((j-1)/3);\n\tif (j%3 != 0)\n\t\tl--;\n\tauto ans = exp(tot2, l/4);\n\tif (l%4 == 0)\n\t\treturn ans;\n\tif (l%4 == 1)\n\t\treturn mul(iq, ans);\n\tif (l%4 == 2)\n\t\treturn mul(p, mul(iq, ans));\n\tif (l%4 == 3)\n\t\treturn mul(q, mul(p, mul(iq, ans)));\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n >> k;\n\tp.resize(n);\n\tq.resize(n);\n\tfor (ll i = 0; i < n; ++i) {\n\t\tcin >> p[i]; p[i]--;\n\t}\n\tfor (ll i = 0; i < n; ++i) {\n\t\tcin >> q[i]; q[i]--;\n\t}\n\tid.resize(n);\n\tfor (ll i = 0; i < n; ++i)\n\t\tid[i] = i;\n\n\tip = inv(p);\n\tiq = inv(q);\n\ttot1 = mul(q, mul(ip, mul(iq, p)));\n\ttot2 = mul(ip, mul(q, mul(p, iq)));\n\n\tvector<ll> ans;\n\tif (k == 1)\n\t\tans = p;\n\telse if (k == 2)\n\t\tans = q;\n\telse if (k == 3)\n\t\tans = mul(q, ip);\n\telse\n\t\tans = mul(get1(k), get2(k));\n\tfor (ll i = 0; i < n; ++i)\n\t\tcout << ans[i]+1 << ' ';\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <utility>\n#define maxn 100005\nusing namespace std;\ntypedef long long ll;\ninline int getint(){\n  char c; int res = 0;\n  for(c = getchar();c < '0' || c > '9';c = getchar());\n  for(;c >= '0' && c <= '9';c = getchar()) res = res * 10 + (c - '0');\n  return res;\n}\nint n,k;\nstruct Permu{\n  int a[maxn];\n  Permu(){\n    memset(a,0,sizeof(a));\n  }\n  void read(){\n    for(int i = 1;i <= n;i++) a[i] = getint();\n  }\n  void print(){\n    for(int i = 1;i <= n;i++) printf(\"%d%c\",a[i],i == n ? '\\n' : ' ');\n  }\n  bool operator == (const Permu &p){\n    for(int i = 1;i <= n;i++) if(a[i] ^ p.a[i]) return false;\n    return true;\n  }\n  Permu operator * (Permu p){\n    Permu res = Permu();\n    for(int i = 1;i <= n;i++) res.a[i] = a[p.a[i]];\n    return res;\n  }\n  Permu inv(){\n    Permu res = Permu();\n    for(int i = 1;i <= n;i++) res.a[a[i]] = i;\n    return res;\n  }\n};\nPermu f(Permu p,Permu q){ return q * p.inv(); }\nPermu p,q,e,fir[7];\nPermu fpow(Permu p,int x){\n  Permu res = e;\n  while(x){\n    if(x & 1) res = res * p;\n    x >>= 1;\n    p = p * p;\n  }\n  return res;\n}\nint main(){\n  n = getint(), k = getint();\n  for(int i = 1;i <= n;i++) e.a[i] = i;\n  p.read(), q.read();\n  fir[1] = p, fir[2] = q;\n  for(int i = 3;i <= 6;i++) fir[i] = f(fir[i - 2],fir[i - 1]);\n  if(k <= 6) fir[k].print();\n  else{\n    Permu A = q * p.inv();\n    Permu r = q.inv() * p * q * p.inv();\n    int num = k % 6;\n    A = A * fpow(r,k / 6 - 1);\n    fir[0] = A * q.inv() * p * A.inv();\n    fir[1] = f(A * q.inv() * A.inv(),fir[0]);\n    for(int i = 2;i <= num;i++) fir[i] = f(fir[i - 2],fir[i - 1]);\n    fir[num].print();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t// no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n} \nusing io :: gi;\nusing io :: putc;\nusing io :: print;\nconst int N=1e5+5;\nint n,p[N],q[N];\nstruct node{\n\tint a[N];\n\tinline node operator *(const node &rhs)const{\n\t\tnode ans;\n\t\tfor(ri i=1;i<=n;++i) ans.a[i]=a[rhs.a[i]];\n\t\treturn ans;\n\t}\n};\ninline node inv(node p){\n\tnode ans;\n\tfor(ri i=1;i<=n;++i)\n\t\tans.a[p.a[i]]=i;\n\treturn ans;\n}\ninline node fpow(node a,ri b){\n\tnode ans;\n\tfor(ri i=1;i<=n;++i) ans.a[i]=i;\n\tfor(;b;b>>=1,a=a*a)\n\t\tif(b&1)\n\t\t\tans=ans*a;\n\treturn ans;\n}\nint main(){\n\tri k,i,f,g;\n\tnode p,q,invp,invq,A,B,invA,ans; \n\tgi(n);gi(k);\n\tfor(i=1;i<=n;++i) gi(p.a[i]);\n\tfor(i=1;i<=n;++i) gi(q.a[i]);\n\tinvp=inv(p);\n\tinvq=inv(q);\n\tf=(k-1)/6;\n\tg=k-f*6;\n\tA=q*invp*invq*p;\n\tif(g==1){\n\t\tB=p;\n\t}\n\telse if(g==2){\n\t\tB=q;\n\t}\n\telse if(g==3){\n\t\tB=q*invp;\n\t}\n\telse if(g==4){\n\t\tB=q*invp*invq;\n\t}\n\telse if(g==5){\n\t\tB=A*invq;\n\t}\n\telse if(g==6){\n\t\tB=A*p*invq;\n\t}\n\tA=fpow(A,f);\n\tinvA=inv(A);\n\tans=A*B*invA; \n\tfor(i=1;i<=n;++i) print(ans.a[i]),putc(' ');\n\tputc('\\n');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\ntypedef vector<int> vec;\nconst int N=1e5+10;\nint n,k,k1;\nvec p,q,t,a,b,c,s,t1,s1;\nvec inv(vec a){\n\tvec b;\n\tb.resize(n);\n\tfor (int i=0;i<n;i++)\n\t\tb[a[i]]=i;\n\treturn b;\n}\nvec divi(vec a,vec b){\n\tvec c;\n\tc.resize(n);\n\tfor (int i=0;i<n;i++)\n\t\tc[a[i]]=b[i];\n\treturn c;\n}\nvec mult(vec a,vec b){\n\treturn divi(inv(b),a);\n}\nvoid write(vec a){\n\tfor (int i=0;i<n;i++)printf(\"%d \",a[i]+1);\n\tcout<<endl;\n}\nint main(){\n\tcin>>n>>k;\n\tp.resize(n),q.resize(n);\n\tfor (int i=0;i<n;i++)scanf(\"%d\",&p[i]),p[i]--;\n\tfor (int i=0;i<n;i++)scanf(\"%d\",&q[i]),q[i]--;\n\ts.resize(n);\n\tfor (int i=0;i<n;i++)s[i]=i;\n\ts1=s;\n\tt=mult(mult(mult(q,inv(p)),inv(q)),p);\n\tt1=inv(t);\n\tk1=(k-1)/6;\n\tk=k-k1*6;\n\twhile (k1){\n\t\tif (k1&1)s=mult(s,t),s1=mult(s1,t1);\n\t\tt=mult(t,t);\n\t\tt1=mult(t1,t1);\n\t\tk1>>=1;\n\t}\n\ta=mult(mult(s,p),s1);\n\tb=mult(mult(s,q),s1);\n\tif (k==1){\n\t\twrite(a);\n\t\treturn 0;\n\t}\n\twhile (k>2){\n\t\tc=divi(a,b);\n\t\ta=b,b=c;k--;\n\t}\n\twrite(b);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nvector<int> bABa;\nvector<int> a;\nvector<int> b;\nvector<int> A;\nvector<int> B;\nll n;\n\nvector<int> func(vector<int> p, vector<int> q){\n\tvector<int> ret(p.size());\n\tREP(i, p.size()){\n\t\tret[i] = p[q[i]];\n\t}\n\treturn ret;\n}\n\nvector<int> inverse(vector<int> v){\n\tvector<int> ret(v.size());\n\tREP(i, v.size()){\n\t\tret[v[i]] = i;\n\t}\n\treturn ret;\n}\n\nvoid out(vector<int> v){\n\tREP(i, v.size())cout << v[i] + 1 << \" \";cout << endl;\n}\n\nvector<int> make_x(ll n, ll k){\n\tll cou = k / 6;\n\tvector<int> ret(n);\n\tauto kake = bABa;\n\tREP(i, n)ret[i] = i;\n\tREP(i, 30){\n\t\tif(cou & (1 << i)){\n\t\t\tret = func(ret, kake);\n\t\t}\n\t\tkake = func(kake, kake);\n\t}\n\t\n\tint tmp = k % 6;\n\tif(tmp <= 0)return ret;\n\tret = func(ret, b);\n\tif(tmp <= 1)return ret;\n\tret = func(ret, A);\n\tif(tmp <= 3)return ret;\n\tret = func(ret, B);\n\tif(tmp <= 4)return ret;\n\tret = func(ret, a);\n\treturn ret;\n}\n\nvector<int> make_y(int k){\n\tint tmp = k % 6;\n\tswitch(tmp){\n\t\tcase 0:return func(b, A);\n\t\tcase 1:return A;\n\t\tcase 2:return B;\n\t\tcase 3:return func(B, a);\n\t\tcase 4:return a;\n\t\tcase 5:return b;\n\t}\n}\n\nint main(){\n\tll n, k;cin >> n >> k;\n\ta.resize(n);REP(i, n)cin >> a[i],a[i]--;\n\tb.resize(n);REP(i, n)cin >> b[i],b[i]--;\n\t\n\tif(k == 1){\n\t\tout(a);\n\t\treturn 0;\n\t}\n\tif(k == 2){\n\t\tout(b);\n\t\treturn 0;\n\t}\n\tk -= 3;\n\n\tA = inverse(a);\n\tB = inverse(b);\n\tbABa = func(func(func(b, A), B), a);\t\n\t\n\tauto x = make_x(n, k);\n\tauto y = make_y(k);\n\t\n\tout(func(func(x, y), inverse(x)));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 1\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n\nint p[100000],q[100000],P[100000],Q[100000];\nint R[100000],r[100000];\nint n[31][100000];\nint ans[100000];\nint apply(int *ans,int *perm,int N) {\n    int i;\n    for (i = 0; i < N; i++) ans[i] = perm[ans[i]];\n    return 0;\n}\nint a[10][100000];\nint main() {\n    int i,j;\n    int N,K;\n    scanf(\"%d %d\",&N,&K),K--;\n    for (i = 0; i < N; i++) scanf(\"%d\",&p[i]),p[i]--,P[p[i]] = i;\n    for (i = 0; i < N; i++) scanf(\"%d\",&q[i]),q[i]--,Q[q[i]] = i;\n    if (K < 10) {\n        for (i = 0; i < N; i++) a[0][i] = p[i],a[1][i] = q[i];\n        for (i = 2; i <= K; i++) {\n            for (j = 0; j < N; j++) a[i][a[i-2][j]] = a[i-1][j];\n        }\n        for (i = 0; i < N; i++) printf(\"%d \",a[K][i]+1);\n        printf(\"\\n\");\n        return 0;\n    }\n\n    for (i = 0; i < N; i++) ans[i] = i,R[i] = i,r[i] = i;\n    apply(ans,Q,N);\n    apply(R,p,N),apply(R,q,N),apply(R,P,N),apply(R,Q,N);\n    int c = (K-3)/6;\n    for (i = 0; i < N; i++) n[0][i] = R[i];\n    for (i = 1; i <= 30; i++) {\n        for (j = 0; j < N; j++) n[i][j] = n[i-1][n[i-1][j]];\n    }\n    for (i = 0; i < N; i++) {\n        for (j = 30; j >= 0; j--) {\n            if (c & (1 << j)) ans[i] = n[j][ans[i]];\n        }\n    }\n    c = K % 6;\n    if (c == 0) apply(ans,p,N);\n    else if (c == 1) apply(ans,p,N),apply(ans,q,N),apply(ans,P,N);\n    else if (c == 2) apply(ans,p,N),apply(ans,q,N),apply(ans,P,N),apply(ans,P,N);\n    else if (c == 3) apply(ans,P,N);\n    else if (c == 4) apply(ans,p,N),apply(ans,Q,N),apply(ans,P,N);\n    else if (c == 5) apply(ans,p,N),apply(ans,p,N),apply(ans,Q,N),apply(ans,P,N);\n    c = K/6;\n    apply(r,q,N),apply(r,p,N),apply(r,Q,N),apply(r,P,N);\n    for (i = 0; i < N; i++) n[0][i] = r[i];\n    for (i = 1; i <= 30; i++) {\n        for (j = 0; j < N; j++) n[i][j] = n[i-1][n[i-1][j]];\n    }\n    for (i = 0; i < N; i++) {\n        for (j = 30; j >= 0; j--) {\n            if (c & (1 << j)) ans[i] = n[j][ans[i]];\n        }\n    }\n    apply(ans,q,N);\n    for (i = 0; i < N; i++) printf(\"%d \",ans[i]+1);\n    printf(\"\\n\");\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int M = 12;\n\nstruct Perm {\n\tvector<int> a;\n\n\tPerm() : a() {}\n\tPerm(int z) {\n\t\ta.resize(z);\n\t\tfor (int i = 0; i < z; i++)\n\t\t\ta[i] = i;\n\t}\n\tPerm(vector<int> _a) : a(_a) {}\n\n\tPerm getRev() {\n\t\tvector<int> b;\n\t\tb.resize(a.size());\n\t\tfor (int i = 0; i < (int)a.size(); i++)\n\t\t\tb[a[i]] = i;\n\t\treturn Perm(b);\n\t}\n\tPerm operator * (const Perm &P) {\n\t\tvector<int> b;\n\t\tb.resize(a.size());\n\t\tfor (int i = 0; i < (int)a.size(); i++)\n\t\t\tb[i] = P.a[a[i]];\n\t\treturn Perm(b);\n\t}\n\tPerm getPow(int k) {\n\t\tvector<int> b;\n\t\tvector<bool> used;\n\t\tint n = (int)a.size();\n\t\tb.resize(n);\n\t\tused.resize(n, false);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i]) continue;\n\t\t\tvector<int> cur;\n\t\t\tint v = i;\n\t\t\twhile(!used[v]) {\n\t\t\t\tcur.push_back(v);\n\t\t\t\tused[v] = 1;\n\t\t\t\tv = a[v];\n\t\t\t}\n\t\t\tint L = (int)cur.size();\n\t\t\tfor (int j = 0; j < L; j++)\n\t\t\t\tb[cur[j]] = cur[(j + k) % L];\n\t\t}\n\t\treturn Perm(b);\n\t}\n\n\tvoid print() {\n\t\tfor (int x : a)\n\t\t\tprintf(\"%d \", x + 1);\n\t\tprintf(\"\\n\");\n\t}\n};\n\nPerm z[M];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tk--;\n\tvector<int> a;\n\ta.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\tz[0] = Perm(a);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\tz[1] = Perm(a);\n\tfor (int i = 2; i < M; i++)\n\t\tz[i] = z[i - 2].getRev() * z[i - 1];\n\n\tif (k < M) {\n\t\tz[k].print();\n\t} else {\n\t\tint p = k % 6;\n\t\tif (p < 3) p += 6;\n\t\tk = (k - p) / 6;\n\t\tPerm P = z[1].getRev() * z[0] * z[1] * z[0].getRev();\n\t\tP = P.getPow(k);\n\t\tP = P * z[p] * P.getRev();\n\t\tP.print();\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n//#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\nvoid out_ans(vec ans){\n    for(int x: ans) cout << x + 1 << \" \";\n    cout << endl;\n}\n\nvec func(vec p, vec q){\n    int N = SZ(p);\n    vec r(N);\n    REP(i, N) r[p[i]] = q[i];\n    return r;\n}\n\nvec mul(vec p, vec q){\n    int N = SZ(p);\n    vec r(N);\n    REP(i, N) r[i] = p[q[i]];\n    return r;\n}\n\nvec pow(vec a, int n){\n    vec p(SZ(a)); REP(i, SZ(a)) p[i] = i;\n    IREP(i, 31){\n        p = mul(p, p);\n        if((n >> i) & 1) p = mul(p, a);\n    }\n    return p;\n}\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    vec p(N); cin >> p;\n    vec q(N); cin >> q;\n    REP(i, N){\n        p[i]--; q[i]--;\n    }\n\n    if(K <= 6){\n        mat a(6);\n        a[0] = p; a[1] = q;\n        FOR(i, 2, 6) a[i] = func(a[i - 2], a[i - 1]);\n        out_ans(a[K - 1]);\n        return 0;\n    }\n\n    vec P(N), Q(N);\n    REP(i, N){\n        P[p[i]] = i;\n        Q[q[i]] = i;\n    }\n\n    vec PQpq = mul(P, mul(Q, mul(p, q)));\n    vec QPqp = mul(Q, mul(P, mul(q, p)));\n    vec mid;\n    if(K % 6 == 1) mid = p;\n    else if(K % 6 == 2) mid = mul(P, mul(q, p));\n    else if(K % 6 == 3) mid = mul(P, mul(P, mul(q, p)));\n    else if(K % 6 == 4) mid = mul(P, QPqp);\n    else if(K % 6 == 5) mid = mul(P, mul(Q, mul(p, QPqp)));\n    else if(K % 6 == 0) mid = mul(P, mul(Q, mul(p, mul(p, QPqp))));\n\n    int n = (K - 1) / 6;\n    vec ans = mul(q, mul(pow(PQpq, n), mul(mid, mul(pow(QPqp, n - 1), Q))));\n    out_ans(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,l,r) for(int i=l;i<=r;i++)\n#define of(i,l,r) for(int i=l;i>=r;i--)\n#define fe(i,u) for(int i=head[u];i;i=e[i].next)\n#define el putchar('\\n')\n#define ta putchar('\t')\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ninline void open(const char *s)\n{\n\t#ifndef ONLINE_JUDGE\n\tchar str[20];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n//\tsprintf(str,\"%s.out\",s);\n//\tfreopen(str,\"w\",stdout);\n\t#endif\n}\ninline int rd()\n{\n\tstatic int x,f;\n\tx=0;f=1;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';\n\treturn f>0?x:-x;\n}\nconst int N=100010;\nint n,K;\nvi a[7],p,q,A,ans;\n\ninline vi inv(vi a)\n{static vi res(n+1);\n\tfo(i,1,n)res[a[i]]=i;\n\treturn res;\n}\ninline vi mul(vi a,vi b)\n{static vi res(n+1);\n\tfo(i,1,n)res[i]=a[b[i]];\n\treturn res;\n}\ninline vi pwr(vi x,int k)\n{static vi res(n+1);\n\tfo(i,1,n)res[i]=i;\n\tfor(;k;k>>=1,x=mul(x,x))if(k&1)res=mul(res,x);\n\treturn res;\n}\n\nint main()\n{\n\tn=rd();K=rd();\n\tp.resize(n+1);q.resize(n+1);\n\tfo(i,1,n)p[i]=rd();\n\tfo(i,1,n)q[i]=rd();\n\ta[1]=p;a[2]=q;a[0].resize(n+1);fo(i,1,n)a[0][i]=i;\n\tA=mul(mul(mul(q,inv(p)),inv(q)),p);\n\tfo(i,3,6)a[i]=mul(a[i-1],inv(a[i-2]));\n\tif(K<=6){\n\t\tfo(i,1,n)printf(\"%d \",a[K][i]);\n\t\treturn 0;\n\t}\n\tans.resize(n+1);A=pwr(A,(K-1)/6);\n\tans=mul(mul(A,a[(K-1)%6+1]),inv(A));\n\tfo(i,1,n)printf(\"%d \",ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int>\nusing namespace std;\ninline int read(){\n\tint v=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0' || c>'9'){\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9'){\n\t\tv=v*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn v*f;\n}\nconst int Maxn=100005;\nint n,k;\nstruct P{\n\tint a[Maxn];\n\tP(){\n\t\tmemset(a,0,sizeof(a));\n\t}\n\tvoid Out(){\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tprintf(\"%d \",a[i]);\n\t\t}\n\t}\n}p,q;\nP inv(P x){\n\tP ret;\n\tfor (int i=1;i<=n;i++){\n\t\tret.a[x.a[i]]=i;\n\t}\n\treturn ret;\n}\nP mul(P x,P y){\n\tP ret;\n\tfor (int i=1;i<=n;i++){\n\t\tret.a[i]=y.a[x.a[i]];\n\t}\n\treturn ret;\n}\nP qp(P x,int pw){\n\tP ret;\n\tfor (int i=1;i<=n;i++){\n\t\tret.a[i]=i;\n\t}\n\twhile (pw){\n\t\tif (pw&1) ret=mul(ret,x);\n\t\tx=mul(x,x);\n\t\tpw>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d %d\",&n,&k);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&p.a[i]);\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&q.a[i]);\n\t}\n\tP pr=inv(p),qr=inv(q);\n\tif (k==1){\n\t\tp.Out();\n\t\treturn 0;\n\t}\n\tif (k==2){\n\t\tq.Out();\n\t\treturn 0;\n\t}\n\tif (k==3){\n\t\tP ret=mul(pr,q);\n\t\tret.Out();\n\t\treturn 0;\n\t}\n\tk-=4;\n\tP tmp=mul(qr,mul(p,mul(q,pr)));\n\tint W=k/6;\n\tk%=6;\n\ttmp=qp(tmp,W);\n\tif (k==0){\n\t\ttmp=mul(tmp,qr);\n\t\tP ans=mul(tmp,mul(pr,inv(tmp)));\n\t\tans.Out();\n\t}\n\telse if (k==1){\n\t\ttmp=mul(tmp,mul(qr,p));\n\t\tP ans=mul(tmp,mul(qr,inv(tmp)));\n\t\tans.Out();\n\t}\n\telse if (k==2){\n\t\ttmp=mul(tmp,mul(qr,p));\n\t\tP ans=mul(tmp,mul(mul(p,qr),inv(tmp)));\n\t\tans.Out();\n\t}\n\telse if (k==3){\n\t\ttmp=mul(tmp,mul(qr,mul(p,q)));\n\t\tP ans=mul(tmp,mul(p,inv(tmp)));\n\t\tans.Out();\n\t}\n\telse if (k==4){\n\t\ttmp=mul(tmp,mul(qr,mul(p,mul(q,pr))));\n\t\tP ans=mul(tmp,mul(q,inv(tmp)));\n\t\tans.Out();\n\t}\n\telse if (k==5){\n\t\ttmp=mul(tmp,mul(qr,mul(p,mul(q,pr))));\n\t\tP ans=mul(tmp,mul(mul(pr,q),inv(tmp)));\n\t\tans.Out();\n\t}\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=1e5+5;\nint n,k,a[N],b[N],c[N],d[N],e[N],f[N],g[N],i;\ninline void in(int*a){for(int i=1;i<=n;++i)scanf(\"%d\",a+i);}\ninline void out(int*a){for(int i=1;i<=n;++i)printf(\"%d%c\",a[i],i==n?'\\n':' ');}\ninline void I(int*a){for(int i=1;i<=n;++i)a[i]=i;}\ninline void getinv(int*a){\n\tstatic int b[N];\n\tfor(int i=1;i<=n;++i)b[a[i]]=i;\n\tmemcpy(a+1,b+1,n<<2);\n}\ninline void mul(int*a,int*b,int*c){\n\tstatic int ans[N];\n\tfor(int i=1;i<=n;++i)ans[i]=b[a[i]];\n\tmemcpy(c+1,ans+1,n<<2);\n}\ninline void poww(int*a,int K,int*b){\n\tstatic int c[N];memcpy(c+1,a+1,n<<2);I(b);\n\tfor(;K;K>>=1,mul(c,c,c))if(K&1)mul(c,b,b);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tin(a);in(b);if(k==1){out(a);return 0;}\n\tmemcpy(c+1,a+1,n<<2);\n\tmemcpy(d+1,b+1,n<<2);\n\tgetinv(c);getinv(d);\n\tif(k>7)mul(d,a,e),mul(e,b,e),mul(e,c,e),poww(e,(k-2)/6,e);else I(e);\n\tif(1<k%6 && k%6<5){memcpy(f+1,b+1,n<<2);if(k%3!=2)mul(c,f,f);if(k%3==1)mul(d,f,f);}\n\t\telse{memcpy(f+1,d+1,n<<2);if(k%3!=2)mul(f,a,f);if(k%3==1)mul(f,b,f);}\n\tif(k>4)mul(a,d,g),mul(g,c,g),mul(g,b,g),poww(g,(k+1)/6,g);else I(g);\n\tmul(e,f,f);mul(f,g,g);out(g);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nvector<int> inv(vector<int> vec) {\n    int N = vec.size();\n    vector<int> res(N);\n    for(int i=0; i<N; i++) {\n        res[ vec[i] ] = i;\n    }\n    return res;\n}\n\nvector<int> mul(vector<int> A, vector<int> B) {\n    int N = A.size();\n    vector<int> res(N);\n    for(int i=0; i<N; i++) {\n        res[i] = A[ B[i] ];\n    }\n    return res;\n}\n\nvector<int> mod_pow(vector<int> A, int k) {\n    int N = A.size();\n    vector<int> res(N);\n    iota(res.begin(), res.end(), 0);\n    for(; k>0; k>>=1) {\n        if(k & 1) res = mul(res, A);\n        A = mul(A, A);\n    }\n    return res;\n}\n\nsigned main() {\n    int N, K; cin >> N >> K;\n    vector<int> p(N), q(N);\n    for(int i=0; i<N; i++) cin >> p[i], p[i]--;\n    for(int i=0; i<N; i++) cin >> q[i], q[i]--;\n    vector<int> ip = inv(p), iq = inv(q);\n\n    vector<int> prod = mul(mul(mul(q, ip), iq), p);\n    vector<int> A = mod_pow(prod, (K - 1) / 6);\n\n    int mod = (K - 1) % 6;\n    vector<int> B;\n    if(mod == 0) B = p;\n    else if(mod == 1) B = q;\n    else {\n        vector<int> X = p, Y = q;\n        for(int i=0; i<mod-1; i++) {\n            vector<int> Z = mul(Y, inv(X));\n            X = Y, Y = Z;\n        }\n        B = Y;\n    }\n\n    vector<int> ans = mul(mul(A, B), inv(A));\n    for(int i=0; i<N; i++) {\n        printf(\"%lld%c\", ans[i] + 1, i+1 == N ? '\\n' : ' ');\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\")\n#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=a;i<=b;i++)\n#define Fod(i,b,a) for (int i=b;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define _SEED_ ('C'+'L'+'Y'+'A'+'K'+'I'+'O'+'I')\n#define outval(x) printf(#x\" = %d\\n\",x)\n#define outvec(x) printf(\"vec \"#x\" = \");for (auto _v : x)printf(\"%d \",_v);puts(\"\")\n#define outtag(x) puts(\"----------\"#x\"----------\")\n#define outarr(a,L,R) printf(#a\"[%d...%d] = \",L,R);\\\n\t\t\t\t\t\tFor(_v2,L,R)printf(\"%d \",a[_v2]);puts(\"\");\nusing namespace std;\ntypedef long long LL;\ntypedef vector <int> vi;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=100005;\nint n,k;\nvi p,q,ip,iq,a[10];\nvi Inv(vi A){\n\tvi B(n);\n\tFor(i,0,n-1)\n\t\tB[A[i]]=i;\n\treturn B;\n}\nvi Mul(vi A,vi B){\n\tvi C(n);\n\tFor(i,0,n-1)\n\t\tC[i]=A[B[i]];\n\treturn C;\n}\nvi Pow(vi x,int y){\n\tvi ans;\n\tFor(i,0,n-1)\n\t\tans.pb(i);\n\tfor (;y;y>>=1,x=Mul(x,x))\n\t\tif (y&1)\n\t\t\tans=Mul(ans,x);\n\treturn ans;\n}\nint main(){\n\tn=read(),k=read();\n\tFor(i,1,n)\n\t\tp.pb(read()-1);\n\tFor(i,1,n)\n\t\tq.pb(read()-1);\n\tip=Inv(p),iq=Inv(q);\n\ta[1]=p,a[2]=q;\n\tFor(i,3,6)\n\t\ta[i]=Mul(a[i-1],Inv(a[i-2]));\n\tint len=(k-1)/6;\n\tvi cir=Pow(Mul(q,Mul(ip,Mul(iq,p))),len);\n\tvi rem=a[k-len*6];\n\tvi res=Mul(cir,Mul(rem,Inv(cir)));\n\tFor(i,0,n-1)\n\t\tprintf(\"%d \",res[i]+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define maxn 100005\nusing namespace std;\n\nint n,m,p[maxn],q[maxn],i,j,k;\n\nstruct per{int a[maxn];} a,b,A,B,C,D,F,G[7];\nper operator*(per a,per b){\n\tper c;\n\tfor(int i=1;i<=n;i++) c.a[i]=b.a[a.a[i]];\n\treturn c;\n}\nper inv(per a){\n\tper b;\n\tfor(int i=1;i<=n;i++) b.a[a.a[i]]=i;\n\treturn b;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tfor(i=1;i<=n;i++) scanf(\"%d\",&q[i]);\n\tfor(i=1;i<=n;i++) a.a[i]=p[i],b.a[i]=q[i];\n\tA=inv(a),B=inv(b),C=B*a*b*A;\n\tG[1]=a,G[2]=b;\n\tfor(i=3;i<=6;i++) G[i]=inv(G[i-2])*G[i-1];\n\tfor(i=1;i<=n;i++) D.a[i]=i;\n\tfor(k=(m-1)/6;k;k/=2,C=C*C) if (k&1) D=D*C;\n\tF=D*G[(m-1)%6+1]*inv(D);\n\tfor(i=1;i<=n;i++) printf(\"%d \",F.a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define each(a,x) for(auto a : (x))\n#define all(a) (a).begin(),(a).end()\n#define chmin(a,b) ((a) = min((a),(b)))\n#define chmax(a,b) ((a) = max((a),(b)))\n#define in_range(x,l,r) ((l)<=(x) && (x)<(r))\n#define printvec(a) rep(i,a) cout << a[i] << \" \\n\"[i+1==(a).size()];\n#define fs first\n#define sc second\n#define em emplace\n#define eb emplace_back\n#define sz size()\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\n\nconst ll INF = 1e8;\nconst D EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\ninline vi inverse(const vi& perm) {\n  vi inv(perm.size());\n  rep(i, perm.size()) {\n    inv[perm[i]] = i;\n  }\n  return inv;\n}\n\nvi multiply(const vi& a, const vi& b) {\n  vi ans(a.size());\n  rep(i, a.size()){\n    ans[i] = b[a[i]];\n  }\n  return ans;\n}\n\nvi pow(const vi& a, ll k) {\n  if (k == 0) {\n    vi ans(a.size());\n    rep(i, a.size()) ans[i] = i;\n    return ans;\n  }\n\n  vi ans = pow(a, k / 2);\n  ans = multiply(ans, ans);\n  if (k & 1LL) {\n    ans = multiply(ans, a);\n  }\n  return ans;\n}\n\nint main(){\n  ll n, k;\n  cin >> n >> k;\n  vi p(n), q(n);\n  rep(i,n) {\n    cin >> p[i]; p[i]--;\n  }\n  rep(i,n) {\n    cin >> q[i]; q[i]--;\n  }\n\n  vi ans(n);\n  if (k == 1) {\n    ans = p;\n  } else if (k == 2) {\n    ans = q;\n  } else if (k < 30) {\n    vi a1 = p, a2 = q;\n    for(int i = 3; i <= k; ++i) {\n      vi a3 = multiply(inverse(a1), a2);\n      swap(a1, a2);\n      swap(a2, a3);\n    }\n    ans = a2;\n  } else {\n    vi prefix_base = multiply(inverse(q), multiply(p, multiply(q, inverse(p))));\n    vi prefix = pow(prefix_base, (k-2) / 6);\n    vi suffix_base = multiply(inverse(p), multiply(q, multiply(p, inverse(q))));\n    vi suffix = pow(suffix_base, (k-2) / 6);\n    vi very_suffix = multiply(inverse(p), q);\n\n    vi core = multiply(inverse(q), multiply(p, multiply(q, multiply(p, inverse(q)))));\n    if (k % 6 == 2LL) {\n      core = p;\n    } else if (k % 6 == 3LL) {\n      core.resize(n);\n      rep(i, n) core[i] = i;\n    } else if (k % 6 == 4LL) {\n      core = inverse(q);\n    } else if (k % 6 == 5LL) {\n      core = multiply(inverse(q), multiply(p, inverse(q)));\n    } else if (k % 6 == 0LL) {\n      core = multiply(inverse(q), multiply(p, multiply(p, inverse(q))));\n    }\n\n    ans = multiply(prefix, multiply(core, multiply(suffix, very_suffix)));\n  }\n\n  rep(i, n) {\n    cout << ans[i] + 1 << \" \\n\"[i == n-1];\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MN 100000\ninline int read()\n{\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n    return x*f;\n}\nint p[MN+5],n,k,q[MN+5],pi[MN+5],qi[MN+5],s[MN+5],a[MN+5],si[MN+5],tmp[MN+5];\nvoid Mul(int*A,int*B)\n{\n    for(int i=1;i<=n;++i) tmp[i]=A[B[i]];\n    for(int i=1;i<=n;++i) A[i]=tmp[i];\n}\nint main()\n{\n    n=read();k=read();\n    for(int i=1;i<=n;++i) p[i]=read(),pi[p[i]]=i,s[i]=i;\n    for(int i=1;i<=n;++i) q[i]=read(),qi[q[i]]=i,a[i]=i;\n    if(k>6)\n    {\n        Mul(s,q);Mul(s,pi);Mul(s,qi);Mul(s,p);\n        for(int t=(k-1)/6;t;t>>=1,Mul(s,s)) if(t&1) Mul(a,s);\n    }\n    int r=(k-1)%6+1;\n    if(r>3) Mul(a,q); if(r>4) Mul(a,pi);\n    for(int i=1;i<=n;++i) si[a[i]]=i;\n    if(r==1) Mul(a,p); if(r==2) Mul(a,q); if(r==3) Mul(a,q),Mul(a,pi);\n    if(r==4) Mul(a,pi);if(r==5) Mul(a,qi);if(r==6) Mul(a,qi),Mul(a,p);\n    Mul(a,si);\n    for(int i=1;i<=n;++i) printf(\"%d \",a[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> operator*(const vector<int> &lhs, vector<int> rhs) {\n    for (int &i : rhs)\n        i = lhs[i];\n    return rhs;\n}\nvector<int> inverse(const vector<int> &a) {\n    vector<int> b(a.size());\n    for (int i = 0; i < a.size(); ++i)\n        b[a[i]] = i;\n    return b;\n}\nvector<int> power(vector<int> a, int k) {\n    vector<bool> visited(a.size());\n    for (int i = 0; i < a.size(); ++i) {\n        if (visited[i])\n            continue;\n        vector<int> b;\n        for (int j = i; !visited[j]; visited[j] = true, j = a[j])\n            b.push_back(j);\n        for (int j = 0; j < b.size(); ++j)\n            a[b[j]] = b[(j + k) % b.size()];\n    }\n    return a;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    --k;\n    vector<int> p(n), q(n);\n    for (int &i : p) {\n        cin >> i;\n        --i;\n    }\n    for (int &i : q) {\n        cin >> i;\n        --i;\n    }\n    vector<int> a, b;\n    a = power(q * inverse(p) * inverse(q) * p, k / 6);\n    vector<vector<int>> c(6);\n    c[0] = a * p * inverse(a);\n    c[1] = a * q * inverse(a);\n    for (int i = 2; i < 6; ++i)\n        c[i] = c[i - 1] * inverse(c[i - 2]);\n    for (int i : c[k % 6])\n        cout << i + 1 << \" \\n\"[i == c[k % 6].back()];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <ctime>\n#include <cassert>\n#include <unordered_map>\n#include <fstream>\n#include <random>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <tuple>\n#include <complex>\n#include <chrono>\n#include <climits>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef unsigned int uint;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n// default_random_engine generator;\n// mt19937 rnd(1);\n\nvector<int> operator*(const vector<int> &a, const vector<int> &b) {\n    int n = sz(a);\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[i] = a[b[i]];\n    }\n    return res;\n}\n\nvector<int> id(int n) {\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[i] = i;\n    }\n    return res;\n}\n\nvector<int> binPow(vector<int> a, int m) {\n    int n = sz(a);\n    vector<int> res = id(n);\n    for (; m > 0; m >>= 1) {\n        if (m & 1) {\n            res = res * a;\n        }\n        a = a * a;\n    }\n    return res;\n}\n\nvector<int> rev(const vector<int> &a) {\n    int n = sz(a);\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[a[i]] = i;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n\n    vector<int> u = {2, 1, 3, 0};\n    // vector<int> v = {3, 0, 2, 1};\n    vector<int> v = {2, 1, 3, 0};\n\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> p(n), q(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        --p[i];\n    }\n    for (int j = 0; j < n; ++j) {\n        cin >> q[j];\n        --q[j];\n    }\n\n    --k;\n    if (k == 0) {\n        for (int el : p) {\n            cout << el << \" \";\n        }\n        cout << endl;\n        return 0;\n    } \n    if (k == 1) {\n        for (int el : q) {\n            cout << el << \" \";\n        }\n        cout << endl;\n        return 0;\n    }\n\n    int s = k + (k - 1) / 3;\n    int a = (s + 1) / 2 + 1;\n    int b = (s + 1) / 2 - 1;\n    if (a + b > s) {\n        --a;\n    }\n\n    vector<vector<int>> perm(4);\n    perm[0] = p;\n    perm[1] = rev(p);\n    perm[2] = q;\n    perm[3] = rev(q);\n\n    vector<int> f = id(n); \n    vector<int> g = id(n);\n    for (int i = 0; i < 4; ++i) {\n        f = f * perm[u[i]];\n        g = g * perm[v[i]];\n    }\n\n    f = binPow(f, a / 4);\n    g = binPow(g, b / 4);\n\n    for (int i = 0; i < a % 4; ++i) {\n        f = f * perm[u[i]];\n    }\n    for (int i = 0; i < b % 4; ++i) {\n        g = g * perm[v[i]];\n    }\n\n    vector<int> res = f * rev(g);\n\n    for (int i = 0; i < n; ++i) {\n        cout << res[i] + 1 << \" \";\n    }\n    cout << endl;\n\n\n\n\n\n    // int k;\n    // cin >> k;\n\n    // vector<vector<int>> w;\n    // w.push_back({0});\n    // w.push_back({2});\n\n    // for (int i = 2; i < k; ++i) {\n    //     vector<int> nxt = w.back();\n    //     vector<int> arr = w[sz(w) - 2];\n    //     for (int i = 0; i < sz(arr); ++i) {\n    //         arr[i] ^= 1;\n    //     }\n    //     reverse(all(arr));\n\n    //     for (int i = 0; i < sz(arr); ++i) {\n    //         if ((arr[i] ^ nxt.back()) == 1) {\n    //             nxt.pop_back();\n    //         } else {\n    //             nxt.push_back(arr[i]);\n    //         }\n    //     }\n\n    //     w.push_back(nxt);\n    // }\n\n\n    // vector<int> u = {2, 1, 3, 0};\n    // vector<int> v = {3, 0, 2, 1};\n\n    // for (int i = 0; i < k; ++i) {\n    //     int a = 0, b = 0;\n    //     for (int j = 0; j < sz(w[i]); ++j) {\n    //         if (w[i][j] != u[j % 4]) {\n    //             break;\n    //         }\n    //         ++a;\n    //     }\n    //     reverse(all(w[i]));\n    //     for (int j = 0; j < sz(w[i]); ++j) {\n    //         if (w[i][j] != v[j % 4]) {\n    //             break;\n    //         }\n    //         ++b;\n    //     }\n    //     reverse(all(w[i]));\n\n    //     // cout << i << \" \" << sz(w[i]) << \" \" << a << \" \" << b << endl;\n\n    //     int s = i + (i - 1) / 3;\n    //     int aa = (s + 1) / 2 + 1;\n    //     int bb = (s + 1) / 2 - 1;\n\n    //     if (i >= 2) {\n    //         assert(s == sz(w[i]));\n    //         assert(a == aa);\n    //         assert(b == bb);\n\n    //     }\n        \n\n    //     // cout << i << \" \" << s << \" \" << aa << \" \" << bb << endl;\n    // } \n\n    // for (int i = 0; i < k; ++i) {\n    //     // if (i % 3 != 1) {\n    //     //     continue;\n    //     // }\n    //     for (int el : w[i]) {\n    //         cout << el << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    // int n, k;\n    // cin >> n >> k;\n\n    // vector<vector<int>> a(2, vector<int>(n));\n\n    // for (int i = 0; i < 2; ++i) {\n    //     for (int j = 0; j < n; ++j) {\n    //         cin >> a[i][j];\n    //         --a[i][j];\n    //     }\n    // } \n\n    // while (sz(a) < k) {\n    //     int m = sz(a);\n    //     a.push_back(vector<int>(n));\n\n    //     vector<int> r(n);\n    //     for (int i = 0; i < n; ++i) {\n    //         r[a[m - 2][i]] = i;\n    //     }\n\n    //     for (int i = 0; i < n; ++i) {\n    //         a[m][i] = a[m - 1][r[i]];\n    //     }\n    // }\n\n    // for (int i = 0; i < n; ++i) {\n    //     cout << a[k - 1][i] + 1 << \" \";\n    // }\n    // cout << endl;\n\n\n        \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <random>\n#include <cstdint>\n#include <bitset>\n#include <iomanip>\n#include <utility>\n#include<map>\n#include<functional>\n#include<climits>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 1000000007;\nint p[100000], q[100000];\nll n, k,cou=3;\n\nll asd();\nll syuuki;\nint test[100000][2];\n\nint main() {\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> p[i];\n\t\ttest[i][0] = p[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> q[i];\n\t\ttest[i][1] = q[i];\n\t}\n\tfor (int i = 0;; i++) {\n\t\tll a=asd();\n\t\tif(a==-1||i==0)cou++;\n\t\telse {\n\t\t\tsyuuki = a;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tp[i] = test[i][0];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tq[i]=test[i][1];\n\t}\n\tfor (int i = 0; i < ((k-2)%syuuki); i++) {\n\t\tasd();\n\t}\n\n\tif (k == 1) {\n\t\tcout << p[0];\n\t\tfor (int i = 1; i < n; i++)cout << ' ' << p[i];\n\t}\n\telse {\n\t\tcout << q[0];\n\t\tfor (int i = 1; i < n; i++)cout << ' ' << q[i];\n\t}\n\tcout << endl;\n}\n\nll asd() {\n\tint memo[100000];\n\tfor (int i = 0; i < n; i++) {\n\t\tmemo[p[i]-1] = q[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tp[i] = q[i];\n\t\tq[i] = memo[i];\n\t}\n\tbool flg = true;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (q[i] != test[i][1]) {\n\t\t\tflg = false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (flg)return cou - 2;\n\telse return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<iostream>\nusing namespace std;\n\ninline int read()\n{\n\tint x=0; bool f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=0;\n\tfor(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^'0');\n\tif(f) return x;\n\treturn -x;\n}\n\nconst int N = 1e5;\nconst int lgM = 30;\nint p[N+3],q[N+3],pp[N+3],qq[N+3];\nint g[N+3],f[N+3],ff[N+3];\nint tmp[N+3];\nint aux[N+3];\nint ans[N+3];\nint a[7][N+3];\nint n,m;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&p[i]),pp[p[i]] = i;\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&q[i]),qq[q[i]] = i;\n\tfor(int i=1; i<=n; i++) a[1][i] = p[i],a[2][i] = q[i];\n\tfor(int k=3; k<=6; k++)\n\t{\n\t\tfor(int i=1; i<=n; i++) a[k][a[k-2][i]] = a[k-1][i];\n\t}\n\tfor(int i=1; i<=n; i++) g[i] = q[pp[qq[p[i]]]],f[i] = i,tmp[i] = g[i];\n\tm = (m-1)/6;\n\tfor(int i=0; m; i++)\n\t{\n\t\tif(m&(1<<i))\n\t\t{\n\t\t\tm-=(1<<i);\n\t\t\tfor(int j=1; j<=n; j++) aux[j] = f[tmp[j]];\n\t\t\tfor(int j=1; j<=n; j++) f[j] = aux[j];\n\t\t}\n\t\tfor(int j=1; j<=n; j++) aux[j] = tmp[tmp[j]];\n\t\tfor(int j=1; j<=n; j++) tmp[j] = aux[j];\n\t}\n\tfor(int i=1; i<=n; i++) ff[f[i]] = i;\n\tint nn = n%6==0?6:n%6;\n\tfor(int i=1; i<=n; i++) ans[i] = f[a[nn][ff[i]]];\n\tfor(int i=1; i<=n; i++) printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define mp make_pair\n\nvoid print(auto &a)\n{\n    for (auto s: a) cout<<s<<' ';\n    cout<<endl;\n}\n\nvoid get(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cin>>a[i];\n}\n\nconst int p =  1e9 + 7;\n\n\nint mul(int a, int b) {\n    return (1LL * a%p * b%p) % p;\n}\n\nint add(int a, int b) {\n    ll s = (a+b);\n    s = s%p;\n    if (s<0) s+=p; \n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}\n\n\n\nvector<int> Z(string s)\n{\nint n = s.length();\nvector<int> z(n);\nint L = 0, R = 0;\nfor (int i = 1; i < n; i++) {\n  if (i > R) {\n    L = R = i;\n    while (R < n && s[R-L] == s[R]) R++;\n    z[i] = R-L; R--;\n  } else {\n    int k = i-L;\n    if (z[k] < R-i+1) z[i] = z[k];\n    else {\n      L = i;\n      while (R < n && s[R-L] == s[R]) R++;\n      z[i] = R-L; R--;\n    }\n  }\n}\nreturn z;\n}\n\nvector<int> opvec(vector<int> a, vector<int> b)\n{\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i<n; i++) res[a[i]] = b[i];\n    return res;\n}\n\nvector<int> invvec(vector<int> a)\n{\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i<n; i++) res[a[i]] = i;\n    return res;\n}\n\nvector<int> mulvec(vector<int> a, vector<int> b)\n{\n    a = invvec(a);\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i<n; i++) res[a[i]] = b[i];\n    return res;\n}\n\nvector<int> id(int n)\n{\n    vector<int> res(n);\n    for (int i = 0; i<n; i++) res[i] = i;\n    return res;\n}\n\nvector<int> power(vector<int> a, int deg)\n{\n    if (deg==0) return id(a.size());\n    if (deg%2==1) return mulvec(power(a, deg-1), a);\n    auto kek = power(a, deg/2);\n    return mulvec(kek, kek);\n}\n\n\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    int n, k;\n    cin>>n>>k;\n    vector<int> a(n), b(n);\n    get(a);\n    get(b);\n    for (int i = 0; i<n; i++) {a[i]--; b[i]--;}\n    vector<int> keks(n);\n    \n    int m = 0;\n    if (k>11) m = (k-5)/6;\n    keks = mulvec(opvec(b, a), b);\n    keks = mulvec(keks, invvec(a));\n    keks = power(keks, m);\n    k -= 6*m;\n    vector<vector<int>> operations(k);\n    operations[0] = a;\n    operations[1] = b;\n    for (int i = 2; i<k; i++) operations[i] = opvec(operations[i-2], operations[i-1]);\n    vector<int> answer = mulvec(keks, operations[k-1]);\n    answer = mulvec(answer, invvec(keks));\n    for (int i = 0; i<n; i++) answer[i]++;\n    print(answer);\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define MN 101000\n\nint n, k;\n\nstruct xxx{\n\tint a[MN];\n}g, G, p, q, f[7];\n\nxxx inv(xxx a)\n{\n\txxx c;\n\tfor(int i = 1; i <= n; i++) c.a[a.a[i]] = i;\n\treturn c;\n}\n\nxxx mul(xxx a, xxx b)\n{\n\txxx c;\n\tfor(int i = 1; i <= n; i++) c.a[i] = b.a[a.a[i]];\n\treturn c;\n}\n\nxxx init()\n{\n\txxx a;\n\tfor(int i = 1; i <= n; i++) a.a[i] = i;\n\treturn a;\n}\n\nxxx qpow(xxx x, int p)\n{\n\txxx ans; ans = init();\n\tfor(; p; p >>= 1, x = mul(x, x)) if(p & 1) ans = mul(ans, x);\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d\", &p.a[i]);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d\", &q.a[i]);\n\tg = mul(mul(mul(inv(q), p), q), inv(p)); G = inv(g);\n\tf[0] = init(); f[1] = p; f[2] = q;\n\tfor(int i = 3; i <= 6; i++) \n\t\tf[i] = mul(inv(f[i - 2]), f[i - 1]);\n\txxx ans = mul(mul(qpow(g, k / 6), f[k % 6]), qpow(G, k / 6));\n\tfor(int i = 1; i <= n; i++) printf(\"%d \", ans.a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>U[10100];\nint w[1010000], st[1010000];\nvector<int> Make(vector<int>A, vector<int>B) {\n\tint i, cnt = 0;\n\tfor (i = 0; i < A.size(); i++)w[cnt++] = A[i];\n\tfor (i = B.size() - 1; i >= 0; i--)w[cnt++] = B[i] ^ 1;\n\tint top = 0;\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (top && (st[top] ^ 1) == w[i]) top--;\n\t\telse st[++top] = w[i];\n\t}\n\tvector<int>r;\n\tfor (i = 1; i <= top; i++)r.push_back(st[i]);\n\treturn r;\n}\nint p[101000], q[101000], pr[101000], qr[100100], n, K, T[101000], Res[101000];\n\nint AA[101000], BB[101000];\nint AU[101000][30], BU[101000][30];\n\nint GoA(int a, int k) {\n\tint i = 0;\n\twhile (k) {\n\t\tif (k & 1)a = AU[a][i];\n\t\ti++, k >>= 1;\n\t}\n\treturn a;\n}\nint GoB(int a, int k) {\n\tint i = 0;\n\twhile (k) {\n\t\tif (k & 1)a = BU[a][i];\n\t\ti++, k >>= 1;\n\t}\n\treturn a;\n}\n\nvoid Solve() {\n\tint i, j;\n\tscanf(\"%d%d\", &n, &K);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &p[i]);\n\t\tpr[p[i]] = i;\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &q[i]);\n\t\tqr[q[i]] = i;\n\t}\n\n\tif (K == 1) {\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tprintf(\"%d \", p[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 1; i <= n; i++) {\n\t\tAA[i] = q[pr[qr[p[i]]]];\n\t\tBB[i] = pr[q[p[qr[i]]]];\n\t\tAU[i][0] = AA[i], BU[i][0] = BB[i];\n\t}\n\tfor (i = 0; i < 29; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tAU[j][i + 1] = AU[AU[j][i]][i];\n\t\t\tBU[j][i + 1] = BU[BU[j][i]][i];\n\t\t}\n\t}\n\n\tif (K % 3 == 2) {\n\t\tint t = K / 3;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tT[i] = GoB(i,t/2);\n\t\t}\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tif (t % 2 == 0) {\n\t\t\t\tRes[i] = GoA(q[T[i]], (t + 1) / 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRes[i] = GoA(qr[T[i]], (t + 1) / 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (K % 3 == 0) {\n\t\tint t = K / 3 - 1;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tT[i] = GoB(i, t / 2);\n\t\t}\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tif (t % 2 == 0) {\n\t\t\t\tRes[i] = GoA(q[pr[T[i]]], (t + 1) / 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRes[i] = GoA(p[qr[T[i]]], (t + 1) / 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (K % 3 == 1) {\n\t\tint t = K / 3 - 1;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tT[i] = GoB(i, t / 2);\n\t\t}\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tif (t % 2 == 0) {\n\t\t\t\tRes[i] = GoA(q[pr[qr[T[i]]]], (t + 1) / 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRes[i] = GoA(q[p[qr[T[i]]]], (t + 1) / 2);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)printf(\"%d \", Res[i]);\n}\nint main() {\n\tU[1].push_back(0);\n\tU[2].push_back(2);\n\tint i;\n\tfor (i = 3; i <= 30; i++) {\n\t\tU[i] = Make(U[i - 1], U[i - 2]);\n\t}\n/*\tfor (int j = 1; j <= 3; j++) {\n\t\tfor (i = j; i <= 30; i += 3) {\n\t\t\tfor (auto &t : U[i])printf(\"%d \", t);\n\t\t\tputs(\"\");\n\t\t}\n\t}*/\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 100000\nusing namespace std;\nint n,k;struct P\n{\n\tint a[N+5];I P(CI x=0) {for(RI i=1;i<=x;++i) a[i]=i;}\n\tI int& operator [] (CI x) {return a[x];}I int operator [] (CI x) Con {return a[x];}\n \tI friend P operator ~ (Con P& A) {P B;for(RI i=1;i<=n;++i) B[A[i]]=i;return B;}\n\tI friend P operator * (Con P& A,Con P& B) {P C;for(RI i=1;i<=n;++i) C[i]=A[B[i]];return C;}\n}p,q,s,a[6],ans;\nI P QP(P x,RI y) {P t=P(n);W(y) y&1&&(t=t*x,0),x=x*x,y>>=1;return t;}\nint main()\n{\n\tRI i;for(scanf(\"%d%d\",&n,&k),i=1;i<=n;++i) scanf(\"%d\",&p[i]);for(i=1;i<=n;++i) scanf(\"%d\",&q[i]);\n\ta[1]=p,a[2]=q,a[3]=a[2]*(~a[1]),a[4]=a[3]*(~a[2]),a[5]=a[4]*(~a[3]),a[6]=a[5]*(~a[4]);\n\ts=q*(~p)*(~q)*p,ans=QP(s,(k-1)/6)*a[(k-1)%6+1]*QP(~s,(k-1)/6);\n\tfor(i=1;i<=n;++i) printf(\"%d%c\",ans[i],\" \\n\"[i==n]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n\nusing namespace std; \ntypedef vector<int> ve;\nint n,k;\nve p,q,A,B,ip,iq;\nvoid re(ve &x) {\n\tx.resize(n+1);\n\tfill(x.begin(),x.begin()+1+n,0);\n}\nve inv(ve a) {\n\tve orz;\n\tre(orz);\n\tfor(int i=1;i<=n;i++) {\n\t\torz[a[i]] = i;\n\t}\n\treturn orz;\n}\nve operator*(ve aa,ve bb) {\n\tve orz; re(orz);\n\tfor(int i=1;i<=n;i++) {\n\t\torz[i] = aa[bb[i]];\n\t}\n\treturn orz;\n}\nve ksm(ve aa,int b) {\n\tve orz; re(orz);\n\tfor(int i=1;i<=n;i++) orz[i] = i;\n\tfor(;b;b>>=1,aa = aa*aa) {\n\t\tif(b&1) {\n\t\t\torz = orz*aa;\n\t\t}\n\t}\n\treturn orz;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tre(p); re(q);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&q[i]);\n\tip = inv(p); iq = inv(q);\n\tve yooo = q*ip*iq*p;\n\tA = ksm(yooo,(k-1)/6);\n\tint yo = k - (k-1)/6*6;\n\tswitch(yo) {\n\t\tcase 1:{\n\t\t\tB = p;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:{\n\t\t\tB = q;\n\t\t\tbreak;\n\t\t}\n\t\tcase 3:{\n\t\t\tB = q * ip;\n\t\t\tbreak;\n\t\t}\n\t\tcase 4:{\n\t\t\tB = ip;\n\t\t\tA = A*q;\n\t\t\tbreak;\n\t\t}\n\t\tcase 5:{\n\t\t\tB = iq;\n\t\t\tA = A*q*ip;\n\t\t\tbreak;\n\t\t}\n\t\tcase 6:{\n\t\t\tB = iq*p;\n\t\t\tA = q*ip;\n\t\t\tbreak;\n\t\t}\n\t}\n\tve ans = A * B * inv(A);\n\tfor(int i=1;i<=n;i++) {\n\t\tprintf(\"%d \",ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <ctime>\n#include <cassert>\n#include <unordered_map>\n#include <fstream>\n#include <random>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <tuple>\n#include <complex>\n#include <chrono>\n#include <climits>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef unsigned int uint;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n// default_random_engine generator;\n// mt19937 rnd(1);\n\nvector<int> operator*(const vector<int> &a, const vector<int> &b) {\n    int n = sz(a);\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[i] = a[b[i]];\n    }\n    return res;\n}\n\nvector<int> id(int n) {\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[i] = i;\n    }\n    return res;\n}\n\nvector<int> binPow(vector<int> a, int m) {\n    int n = sz(a);\n    vector<int> res = id(n);\n    for (; m > 0; m >>= 1) {\n        if (m & 1) {\n            res = res * a;\n        }\n        a = a * a;\n    }\n    return res;\n}\n\nvector<int> rev(const vector<int> &a) {\n    int n = sz(a);\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[a[i]] = i;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n\n    vector<int> u = {2, 1, 3, 0};\n    // vector<int> v = {3, 0, 2, 1};\n    vector<int> v = {2, 1, 3, 0};\n\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> p(n), q(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        --p[i];\n    }\n    for (int j = 0; j < n; ++j) {\n        cin >> q[j];\n        --q[j];\n    }\n\n    --k;\n    if (k == 0) {\n        for (int el : p) {\n            cout << el + 1 << \" \";\n        }\n        cout << endl;\n        return 0;\n    } \n    if (k == 1) {\n        for (int el : q) {\n            cout << el + 1 << \" \";\n        }\n        cout << endl;\n        return 0;\n    }\n\n    int s = k + (k - 1) / 3;\n    int a = (s + 1) / 2 + 1;\n    int b = (s + 1) / 2 - 1;\n    if (a + b > s) {\n        --a;\n    }\n\n    vector<vector<int>> perm(4);\n    perm[0] = p;\n    perm[1] = rev(p);\n    perm[2] = q;\n    perm[3] = rev(q);\n\n    vector<int> f = id(n); \n    vector<int> g = id(n);\n    for (int i = 0; i < 4; ++i) {\n        f = f * perm[u[i]];\n        g = g * perm[v[i]];\n    }\n\n    f = binPow(f, a / 4);\n    g = binPow(g, b / 4);\n\n    for (int i = 0; i < a % 4; ++i) {\n        f = f * perm[u[i]];\n    }\n    for (int i = 0; i < b % 4; ++i) {\n        g = g * perm[v[i]];\n    }\n\n    vector<int> res = f * rev(g);\n\n    for (int i = 0; i < n; ++i) {\n        cout << res[i] + 1 << \" \";\n    }\n    cout << endl;\n\n    // int k;\n    // cin >> k;\n\n    // vector<vector<int>> w;\n    // w.push_back({0});\n    // w.push_back({2});\n\n    // for (int i = 2; i < k; ++i) {\n    //     vector<int> nxt = w.back();\n    //     vector<int> arr = w[sz(w) - 2];\n    //     for (int i = 0; i < sz(arr); ++i) {\n    //         arr[i] ^= 1;\n    //     }\n    //     reverse(all(arr));\n\n    //     for (int i = 0; i < sz(arr); ++i) {\n    //         if ((arr[i] ^ nxt.back()) == 1) {\n    //             nxt.pop_back();\n    //         } else {\n    //             nxt.push_back(arr[i]);\n    //         }\n    //     }\n\n    //     w.push_back(nxt);\n    // }\n\n\n    // vector<int> u = {2, 1, 3, 0};\n    // vector<int> v = {3, 0, 2, 1};\n\n    // for (int i = 0; i < k; ++i) {\n    //     int a = 0, b = 0;\n    //     for (int j = 0; j < sz(w[i]); ++j) {\n    //         if (w[i][j] != u[j % 4]) {\n    //             break;\n    //         }\n    //         ++a;\n    //     }\n    //     reverse(all(w[i]));\n    //     for (int j = 0; j < sz(w[i]); ++j) {\n    //         if (w[i][j] != v[j % 4]) {\n    //             break;\n    //         }\n    //         ++b;\n    //     }\n    //     reverse(all(w[i]));\n\n    //     // cout << i << \" \" << sz(w[i]) << \" \" << a << \" \" << b << endl;\n\n    //     int s = i + (i - 1) / 3;\n    //     int aa = (s + 1) / 2 + 1;\n    //     int bb = (s + 1) / 2 - 1;\n\n    //     if (i >= 2) {\n    //         assert(s == sz(w[i]));\n    //         assert(a == aa);\n    //         assert(b == bb);\n\n    //     }\n        \n\n    //     // cout << i << \" \" << s << \" \" << aa << \" \" << bb << endl;\n    // } \n\n    // for (int i = 0; i < k; ++i) {\n    //     // if (i % 3 != 1) {\n    //     //     continue;\n    //     // }\n    //     for (int el : w[i]) {\n    //         cout << el << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    // int n, k;\n    // cin >> n >> k;\n\n    // vector<vector<int>> a(2, vector<int>(n));\n\n    // for (int i = 0; i < 2; ++i) {\n    //     for (int j = 0; j < n; ++j) {\n    //         cin >> a[i][j];\n    //         --a[i][j];\n    //     }\n    // } \n\n    // while (sz(a) < k) {\n    //     int m = sz(a);\n    //     a.push_back(vector<int>(n));\n\n    //     vector<int> r(n);\n    //     for (int i = 0; i < n; ++i) {\n    //         r[a[m - 2][i]] = i;\n    //     }\n\n    //     for (int i = 0; i < n; ++i) {\n    //         a[m][i] = a[m - 1][r[i]];\n    //     }\n    // }\n\n    // for (int i = 0; i < n; ++i) {\n    //     cout << a[k - 1][i] + 1 << \" \";\n    // }\n    // cout << endl;\n\n\n        \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint n,c[N],k;\nstruct zhihuan{\n\tint a[N];\n\tzhihuan operator *(const zhihuan &b)const {\n\t\tzhihuan x;\n\t\tfor (int i=1;i<=n;i++)x.a[i]=a[b.a[i]];\n\t\treturn x;\n\t}\n}I,p,q;\nzhihuan inv(zhihuan x){\n\tfor (int i=1;i<=n;i++)c[x.a[i]]=i;\n\tfor (int i=1;i<=n;i++)x.a[i]=c[i];\n\treturn x;\n}\nzhihuan ksm(zhihuan x,int y){\n\tzhihuan z=I;\n\tfor (;y;y>>=1,x=x*x)\n\t\tif (y&1)z=z*x;\n\treturn z;\t\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i<=n;i++)I.a[i]=i;\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&p.a[i]);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&q.a[i]);\n\tzhihuan Ans=q*inv(p)*inv(q)*p;\n\tint t=k%6;if (t==0)t=6;\n\tint ttt=(k-t)/6;zhihuan A=ksm(Ans,(k-t)/6);k=t;\n\tAns=I;\n\tif (k==1)Ans=A*p*inv(A);\n\tif (k==2)Ans=A*q*inv(A);\n\tif (k==3)Ans=A*q*inv(p)*inv(A);\n\tif (k==4)A=A*q,Ans=A*inv(p)*inv(A);\n\tif (k==5)A=A*q*inv(p),Ans=A*inv(q)*inv(A);\n\tif (k==6)A=A*q*inv(p),Ans=A*inv(q)*p*inv(A);\n\tfor (int i=1;i<=n;i++)printf(\"%d \",Ans.a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef complex<long double> cd;\n\nconst int maxn = 2e5 + 5;\n\nint p[maxn], q[maxn], rp[maxn], rq[maxn];\nint n;\nint rA[maxn], A[maxn], B[maxn];\n\nvoid power(int b){\n\tif (b == 0)\n\t\treturn;\n\tpower(b / 2);\n\tfor (int i = 1; i <= n; i++)\n\t\tB[i] = A[A[i]];\n\tfor (int i = 1; i <= n; i++)\n\t\tA[i] = B[i];\n\tif (b & 1){\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = A[q[rp[rq[p[i]]]]];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = B[i];\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint k;\n\tcin >> n >> k;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> p[i];\n\t\trp[p[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> q[i];\n\t\trq[q[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tA[i] = i;\n\tpower((k - 1) / 6);\n\tif (k % 6 == 4){\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = A[q[i]];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = B[i];\n\t}\n\tif (k % 6 == 5 or k % 6 == 0){\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = A[q[rp[i]]];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = B[i];\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\trA[A[i]] = i;\n\tk %= 6;\n\tif (k == 1)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = p[i];\n\telse if (k == 2)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = q[i];\n\telse if (k == 3)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = q[rp[i]];\n\telse if (k == 4)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = rp[i];\n\telse if (k == 5)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = rq[i];\n\telse\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = rq[p[i]];\n\tfor (int i = 1; i <= n; i++)\n\t\tcout << A[B[rA[i]]] << \" \";\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 100010\n#define ll long long\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mod 998244353\n#define fi first\n#define pi pair<int, int>\n#define se second\n#define mp make_pair\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\n// head\nvi p[maxn];\t\nint n, k;\nbool check(int a, int b) {\n\tfor (int i = 1; i <= n; i++)\n\t\tif (p[a][i] != p[b][i]) return 0;\n\treturn 1;\n}\nint main() {\n\tcin >> n >> k;\n\tp[1].resize(n + 1), p[2].resize(n + 1);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &p[1][i]);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &p[2][i]);\n\tint md = 0;\n\tfor (int i = 3; i < 1000; i++) {\n\t\tp[i].resize(n + 1);\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tp[i][p[i - 2][j]] = p[i - 1][j];\n\t\tif (check(1, i - 1) && check(2, i)) {\n\t\t\tmd = i - 2;\n\t\t\tbreak;\n\t\t}\n\t}\n//\tcout << \"!! \" << md << endl;\n\tk %= md;\n\tif (!k) k += md;\n\tfor (int i = 1; i <= n; i++)\n\t\tprintf(\"%d \", p[k][i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 100000;\n\nvoid ans(int* p, int n) {\n\tfor (int i = 0; i < n; i++) printf(\"%d \", p[i]);\n\tprintf(\"\\n\");\n\t\n\texit(0);\n}\n\nint n;\n\nvoid mult(int* p, int* q, int* r) {\n\tfor (int i = 0; i < n; i++) {\n\t\tr[i] = p[q[i] - 1];\n\t}\n}\n\nint p[55][MX];\n\nvoid binpow(int* a, int k) {\n\tiota(p[44], p[44] + n, 1);\n\twhile (k > 0) {\n\t\tif (k % 2 == 1) {\n\t\t\tmult(p[44], a, p[45]);\n\t\t\tmemmove(p[44], p[45], 4 * n);\n\t\t}\n\t\t\n\t\tmult(a, a, p[45]);\n\t\tmemmove(a, p[45], 4 * n);\n\t\t\n\t\tk /= 2;\n\t}\n\t\n\tmemmove(a, p[44], 4 * n);\n}\n\nvoid getInv(int* p, int* r) {\n\tfor (int i = 0; i < n; i++) r[p[i] - 1] = i + 1;\n}\n\nint main() {\n\tint k;\n\tignore = scanf(\"%d %d\", &n, &k);\n\tfor (int i = 0; i < n; i++) ignore = scanf(\"%d\", p[0] + i);\n\tfor (int i = 0; i < n; i++) ignore = scanf(\"%d\", p[1] + i);\n\t\n\tfor (int i = 2; i < 10; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tp[i][p[i - 2][j] - 1] = p[i - 1][j];\n\t\t}\n\t}\n\t\n\tif (k < 10) ans(p[k - 1], n);\n\t\n\tgetInv(p[0], p[11]);\n\tgetInv(p[1], p[12]);\n\t\n\tmult(p[1], p[11], p[13]);\n\tmult(p[13], p[12], p[14]);\n\tmult(p[14], p[0], p[15]);\n\t\n\tbinpow(p[15], (k - 1) / 6);\n\t\n\tmult(p[11], p[1], p[21]);\n\tmult(p[21], p[0], p[22]);\n\tmult(p[22], p[12], p[23]);\n\t\n\tbinpow(p[23], (k - 1) / 6);\n\t\n\tmult(p[15], p[(k - 1) % 6], p[33]);\n\tmult(p[33], p[23], p[34]);\n\t\n\tans(p[34], n);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100005,inf=0x3f3f3f3f;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,K;\nstruct perm{\n\tint a[N];\n\tint &operator[](int k){return a[k];}\n}p,q,A,ans;\nperm inv(perm a){\n\tstatic perm b;\n\tfor (int i=1;i<=n;i++) b[a[i]]=i;\n\treturn b;\n}\nperm operator*(perm a,perm b){\n\tstatic perm c;\n\tfor (int i=1;i<=n;i++) c[i]=a[b[i]];\n\treturn c;\n}\nperm operator^(perm a,int k){\n\tstatic perm c;\n\tstatic int b[N],h[N],cnt;\n\tfor (int i=1;i<=n;i++) h[i]=0;\n\tfor (int i=1;i<=n;i++)\n\tif (!h[i]){\n\t\tint x=i;cnt=0;\n\t\twhile (!h[x]){h[x]=1;x=a[x];b[cnt++]=x;}\n\t\tfor (int j=0;j<cnt;j++) c[b[j]]=b[(j+k)%cnt];\n\t}\n\treturn c;\n}\nint main(){\n\tn=read();K=read()-1;\n\tfor (int i=1;i<=n;i++) p[i]=read();\n\tfor (int i=1;i<=n;i++) q[i]=read();\n\tA=q*inv(p)*inv(q)*p;\n\tA=A^(K/6);\n\tint r=K%6;\n\tfor (int i=1;i<=r;i++){\n\t\tans=q*inv(p);\n\t\tp=q;q=ans;\n\t}\n\tans=A*p*inv(A);\n\tfor (int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool vis[100005];\nint now[100005];\n\nstruct Per {\n  int *num,n;\n  Per() {}\n  Per(int a):n(a) {num=new int[n+1];}\n  Per inv() {\n  \tPer b(n);\n  \tfor(int i=1;i<=n;i++) b.num[num[i]]=i;\n  \treturn b;\n  }\n  Per operator * (Per b) {\n  \tPer c(n);\n  \tfor(int i=1;i<=n;i++) c.num[i]=num[b.num[i]];\n  \treturn c;\n  }\n  Per operator ^ (int k) {\n  \tPer b(n);\n  \tfor(int i=1;i<=n;i++) vis[i]=0;\n  \tfor(int i=1;i<=n;i++)\n  \t  if (!vis[i]) {\n  \t  \t  int x=i,cnt=0;\n  \t  \t  do {\n  \t  \t  \tnow[++cnt]=x;\n  \t  \t  \tvis[x]=1;\n  \t  \t  \tx=num[x];\n\t\t  } while (x!=i);\n\t\t  for(int j=1;j<=cnt;j++) b.num[now[j]]=now[(j+k-1)%cnt+1];\n\t\t}\n\treturn b;\n  }\n};\n\nPer fir[7];\n\nint main() {\n  int n,k;\n  scanf(\"%d%d\",&n,&k);\n  fir[1]=Per(n);\n  fir[2]=Per(n);\n  for(int i=1;i<=n;i++) scanf(\"%d\",&fir[1].num[i]);\n  for(int i=1;i<=n;i++) scanf(\"%d\",&fir[2].num[i]);\n  for(int i=3;i<=6;i++) fir[i]=fir[i-1]*fir[i-2].inv();\n  Per a=fir[2]*fir[1].inv()*fir[2].inv()*fir[1];\n  Per ans=(a^((k-1)/6))*fir[(k-1)%6+1]*(a.inv()^((k-1)/6));\n  for(int i=1;i<=n;i++) printf(\"%d \",ans.num[i]);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing vi = vector<int>;\n\nvi mul(vi a, vi b) {\n\tint n = a.size();\n\tvi c(n);\n\tfor(int i = 0; i < n; i++) c[a[i]] = b[i];\n\treturn c;\n}\nvi normul(vi a, vi b) {\n\tint n = a.size();\n\tvi c(n);\n\tfor(int i = 0; i < n; i++) c[i] = b[a[i]];\n\treturn c;\n}\nvi inv(vi a) {\n\tint n = a.size();\n\tvi c(n);\n\tfor(int i = 0; i < n; i++) c[a[i]] = i;\n\treturn c;\n}\nvi pow(vi a, int n) {//slow, can be done in O(n) by shifting cycles\n\tvi r(a.size()); iota(all(r), 0);\n\twhile(n) {\n\t\tif(n&1) r = normul(r, a);\n\t\tn>>=1, a = normul(a, a);\n\t}\n\treturn r;\n}\n\nint x = 100;\nvi f[1010];\nint n, k;\nvoid read() {\n\tcin >> n >> k;--k;\n\tfor(int x = 0; x < 2; x++) {\n\t\tf[x].resize(n);\n\t\tfor(auto &i : f[x]) cin >> i, i--;\n\t}\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid stress() {\n\tn = 100, k = 0;\n\tfor(int x = 0; x < 2; x++) {\n\t\tf[x].resize(n);\n\t\tiota(all(f[x]), 0);\n\t\tshuffle(all(f[x]), rng);\n\t}\n}\nvoid gen() {\n\tfor(int i = 2; i < x; i++) f[i] = mul(f[i-2], f[i-1]);\n}\nvi lst;\nvoid print(vi a, int DEBUG = 1) {\n\tfor(auto i : a) cout << i+1 << \" \";\n\tif(DEBUG) {\n\tcout << \" : \";\n\tint n = a.size();\n\tvi c(n);\n\tfor(int t = 0, i = 0; i < n; i++) {\n\t\tif(c[i]) continue;\n\t\t++t;\n\t\tint u = i;\n\t\tvi v;\n\t\twhile(!c[u]) {\n\t\t\tc[u] = t;\n\t\t\tu = a[u];\n\t\t\tv.push_back(u);\n\t\t}\n\t\tcout << \"( \";\n\t\tfor(auto &i : v) cout << i+1 << \" \";cout << \") ,\";\n\t}\n\tcout << \" : \";\n\tif(lst.size()) {\n\t\tvi t = mul(inv(lst), a);\n\t\tfor(auto i : t) cout << i+1 << \" \";\n\t}\n\tlst = a;\n\tcout << '\\n';\n\t}\n}\nvoid print() {\n\t//int c = 1;\n\t//while(mul(inv(f[k%c]), f[c + (k%c)]) != mul(inv(f[c + (k%c)]), f[2*c + (k%c)])) c++;\n\tfor(int i = 0; i < x; i++) cout << i << \" :\", print(f[i]);\n\t\n}\nvoid solve() {\n\tint c = 1;\n\twhile(mul(inv(f[k%c]), f[c + (k%c)]) != mul(inv(f[c + (k%c)]), f[2*c + (k%c)])) c++;\n\tif(k < 48) print(f[k], 0);\n\telse {\n\t\tvi t;\n\t\tvi s = mul(inv(f[k%3]), f[3 + (k%3)]);\n\t\tvi a = f[k%3];\n\t\tk = (k/3)+1;\n\t\tif(k&1) {\n\t\t\tt = normul(pow(inv(s), k/2), a);\n\t\t\tt = normul(t, pow(s, k/2));\n\t\t} else {\n\t\t\tt = normul(pow(inv(s), k/2 - 1), inv(a));\n\t\t\tt = normul(t, pow(s, k/2));\n\t\t}\n\t\tprint(t, 0);\n\t}\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tread();\n\t//stress();\n\tgen();\n\t//print();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std; \ntypedef vector<int> ve;\nint n,k;\nve p,q,A,B,ip,iq;\nvoid re(ve &x) {\n\tx.resize(n+1);\n\tfill(x.begin(),x.begin()+1+n,0);\n}\nve inv(ve a) {\n\tve orz;\n\tre(orz);\n\tfor(int i=1;i<=n;i++) {\n\t\torz[a[i]] = i;\n\t}\n\treturn orz;\n}\nve operator*(ve aa,ve bb) {\n\tve orz; re(orz);\n\tfor(int i=1;i<=n;i++) {\n\t\torz[i] = aa[bb[i]];\n\t}\n\treturn orz;\n}\nve ksm(ve aa,int b) {\n\tve orz; re(orz);\n\tfor(int i=1;i<=n;i++) orz[i] = i;\n\tfor(;b;b>>=1,aa = aa*aa) {\n\t\tif(b&1) {\n\t\t\torz = orz*aa;\n\t\t}\n\t}\n\treturn orz;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tre(p); re(q);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&q[i]);\n\tip = inv(p); iq = inv(q);\n\tve yooo = q*ip*iq*p;\n\tA = ksm(yooo,(k-1)/6);\n\tint yo = k - (k-1)/6*6;\n\tswitch(yo) {\n\t\tcase 1:{\n\t\t\tB = p;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:{\n\t\t\tB = q;\n\t\t\tbreak;\n\t\t}\n\t\tcase 3:{\n\t\t\tB = q * ip;\n\t\t\tbreak;\n\t\t}\n\t\tcase 4:{\n\t\t\tB = ip;\n\t\t\tA = A*q;\n\t\t\tbreak;\n\t\t}\n\t\tcase 5:{\n\t\t\tB = iq;\n\t\t\tA = A*q*ip;\n\t\t\tbreak;\n\t\t}\n\t\tcase 6:{\n\t\t\tB = iq*p;\n\t\t\tA = q*ip;\n\t\t\tbreak;\n\t\t}\n\t}\n\tve ans = A * B * inv(A);\n\tfor(int i=1;i<=n;i++) {\n\t\tprintf(\"%d \",ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--) \n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) { \n\tscanf(\"%c\", &x); \n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\tsystem_clock::now().time_since_epoch()\n\t).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, k;\n\nvector<int> combine(vector<int> a, vector<int> b) {\n\tvector<int> c(len(a));\n\tf(i, len(a)) {\n\t\tc[a[i]] = b[i];\n\t}\n\treturn c;\n}\n\nvector<int> xpow(vector<int> x, int p) {\n\tif (p == 1) return x;\n\tif (p & 1) {\n\t\treturn combine(xpow(x, p - 1), x);\n\t} else {\n\t\tvector<int> t = xpow(x, p / 2);\n\t\treturn combine(t, t);\n\t}\n}\n\nvector<int> a0, a1;\n\nmap<int, vector<int>> mem;\nvector<int> calc(int i) {\n\tif (i == 0) return a0;\n\tif (i == 1) return a1;\n\tif (i == 2) return combine(a0, a1);\n\tif (mem.count(i)) return mem[i];\n\treturn mem[i] = combine(calc(i - 2), calc(i - 1));\n\tif (i & 1) {\n\t\tvector<int> A = calc(i / 2 + 1);\n\t\tvector<int> B = calc(i / 2);\n\t\treturn mem[i] = combine(combine(B, A), combine(B, A));\n\t} else {\n\t\tvector<int> A = calc(i / 2);\n\t\tvector<int> B = calc(i / 2 - 1);\n\t\tvector<int> C = calc(i / 2 + 1);\n\t\treturn mem[i] = combine(combine(B, C), A);\n\t}\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, k;\n\tvector<int> a(n);\n\tvector<int> b(n);\n\tscan a, b;\n\tapply(a, x--);\n\tapply(b, x--);\n\ta0 = a;\n\ta1 = b;\n\t// vector<int> t = calc(k - 1);\n\t// apply(t, x++);\n\t// print t;\n\tvector<int> C = a0;\n\tvector<int> D = a1;\n\tint id = 0;\n\tmap<pair<vector<int>, vector<int>>, int> last;\n\tint cycle = 0;\n\tint pre = 0;\n\twhile (true) {\n\t\tif (last.count(mp(C, D))) {\n\t\t\tcycle = id - last[mp(C, D)];\n\t\t\tpre = id;\n\t\t\tbreak;\n\t\t}\n\t\tlast[mp(C, D)] = id++;\n\t\ttie(C, D) = mt(D, combine(C, D));\n\t}\n\tvector<int> final;\n\tif (k < pre + 10) {\n\t\tfinal = calc(k - 1);\n\t} else {\n\t\t// for (int j = -4; j < 5; j++) {\n\t\t\t// print calc(pre + (k + j - pre) % cycle);\n\t\t// }\n\n\t\tfinal = calc(pre + (k - 1 - pre) % cycle);\n\t}\n\tapply(final, x++);\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<ll,pll> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\n\nvi inv(vi a){\n\tvi b(n);\n\tfor(int i=0;i<n;i++) b[a[i]]=i;\n\treturn b;\n}\n\nvi mul(vi a,vi b){\n\tvi c(n);\n\tfor(int i=0;i<n;i++) c[i]=b[a[i]];\n\treturn c;\n}\n\nvi pow(vi a,int p){\n\tvi b(n);\n\tfor(int i=0;i<n;i++) b[i]=i;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) b=mul(b,a);\n\t\ta=mul(a,a);\n\t}\n\treturn b;\n}\n\nint k;\nvi a,b,A,B,d;\n\nvi f(int p){\n\tvi c(n);\n\tfor(int i=0;i<n;i++) c[i]=i;\n\tif(p<0) return c;\n\tc=pow(d,p/6);\n\tc=mul(c,B);\n\tif(p%6>=1) c=mul(c,a);\n\tif(p%6>=3) c=mul(c,b);\n\tif(p%6>=4) c=mul(c,A);\n\treturn c;\n}\n\nint main(){\n\tcin>>n>>k;\n\ta=b=vi(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\ta[i]--;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin>>b[i];\n\t\tb[i]--;\n\t}\n\tA=inv(a),B=inv(b);\n\td=mul(B,mul(a,mul(b,A)));\n\tvi c;\n\tif(k==1) c=a;\n\telse c=mul(f(k-4),inv(f(k-2)));\n\tfor(int i=0;i<n;i++) cout<<c[i]+1<<\" \\n\"[i==n-1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 100005\nint n,m;\nstruct per { int a[maxn]; per(){ memset(a,0,sizeof(a)); } }p,q;\nper operator * (per a,per b) { per c; for(int i=1;i<=n;i++) c.a[i]=a.a[b.a[i]]; return c; }\nper operator ^ (per a,int k) { per res; for(int i=1;i<=n;i++) res.a[i]=i; while(k) { if(k&1) res=res*a; a=a*a; k>>=1; } return res; }\nper inv(per a) { per b; for(int i=1;i<=n;i++) b.a[a.a[i]]=i; return b; }\nint main() {\n\tscanf(\"%d%d\",&n,&m); for(int i=1;i<=n;i++) scanf(\"%d\",&p.a[i]); for(int i=1;i<=n;i++) scanf(\"%d\",&q.a[i]);\n\tint x=(m-1)/6,y=m%6; per ip=inv(p),iq=inv(q),h=q*ip*iq*p,A=h^x,B;\n\tif(y==1) B=p; else if(y==2) B=q; else if(y==3) B=q*ip; else if(y==4) A=A*q,B=ip; else if(y==5) A=A*q*ip,B=iq; else A=A*q*ip,B=iq*p;\n\tper ans=A*B*inv(A); for(int i=1;i<=n;i++) printf(\"%d \",ans.a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#define rep(i,n) for(int (i) = 0;(i) < (n);(i)++)\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\n\nstruct Permutation{\n    vector<int> x;\n    int sz;\n    \n    Permutation(){\n        ;\n    }\n    \n    Permutation(int a):sz(a){\n        x.resize(sz);\n        for(int i = 0;i < sz;i++){\n            x[i]=i;\n        }\n    }\n    \n    int &operator[](int a){\n        return x[a];\n    }\n    \n    Permutation &operator=(const Permutation &a){\n        sz = a.sz;\n        x.resize(sz);\n        for(int i = 0;i < sz;i++){\n            x[i]=a.x[i];\n        }\n        return (*this);\n    }\n    \n    void show(){\n        for(int i =0 ;i<sz-1;i++){\n            cout<<x[i]+1<<\" \";\n        }\n        cout<<x[sz-1]+1<<endl;\n    }\n    \n\n\n    Permutation operator *(const Permutation &B){\n        Permutation ret(sz);\n        for(int i = 0;i < sz;i++){\n            ret.x[i]=x[B.x[i]];\n        }\n        return ret;\n    }\n\n    \n    Permutation operator *(ll X){\n        Permutation ret(sz);\n        Permutation A = *this;\n        while(X>0){\n            if(X%2==1)ret = ret*A;\n            A=A*A;\n            X>>=1;\n        }\n        return ret;\n    }\n};\n\nPermutation inv(const Permutation &A){\n    Permutation ret(A.sz);\n    for(int i = 0;i < A.sz;i++){\n        ret[A.x[i]]=i;\n    }\n    return ret;\n}\n\nPermutation id;\n\nvoid init(){\n    id.sz=N;\n    id.x.reserve(N);\n    for(int i = 0;i < N;i++){\n        id.x.push_back(i);\n    }\n}\n\nint main(){\n    ll K;\n    cin>>N>>K;\n    K--;\n    init();\n    Permutation P(N),Q(N),Pi,Qi;\n    vector<Permutation> A(6);\n    vector<Permutation> B(6);\n    Permutation T;\n    for(int i = 0;i< N;i++){\n        cin>>P[i];\n        P[i]--;\n    }\n    for(int i = 0;i< N;i++){\n        cin>>Q[i];\n        Q[i]--;\n    }\n    Pi=inv(P);\n    Qi=inv(Q);\n    B[0]=P;\n    B[1]=Q;\n    B[2]=Q*Pi;\n    B[3]=Pi;\n    B[4]=Qi;\n    B[5]=Qi*P;\n    A[0]=id;\n    A[1]=id;\n    A[2]=id;\n    A[3]=Q;\n    A[4]=Q*Pi;\n    A[5]=Q*Pi;\n//    cout<<\"B:\"<<endl;\n//    for(int i = 0;i < 6;i++){B[i].show();};\n//    cout<<\"A:\"<<endl;\n//    for(int i = 0;i < 6;i++){A[i].show();};\n    T= Q*Pi*Qi*P;\n    T = (T*(K/6));\n    T = (T*A[K%6]);\n    Permutation ans = T*B[K%6]*inv(T);\n    ans.show();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n;\nvector<ll> ret;\n\n\n\nvoid cul(vector<ll> &ret,const vector<ll> &A,const vector<ll> &B){\n    for(int i=0;i<n;i++){ret[i]=B[A[i]];}\n}\n\nvoid rev(vector<ll> &ret,vector<ll> A){\n    for(int i=0;i<n;i++){ret[A[i]]=i;}\n}\n\nvoid Out(vector<ll> ans){\n    for(int i=0;i+1<n;i++){cout<<ans[i]+1<<\" \";}\n    cout<<ans.back()+1<<endl;\n}\n\nvector<ll> operator * (const vector<ll> &A,const vector<ll> &B){cul(ret,A,B); return ret;}\n\nvector<ll> & operator *= (vector<ll> &A,const vector<ll> &B){cul(ret,A,B); return A=ret;}\n\nvector<ll> & operator /= (vector<ll> &A,const vector<ll> &B){cul(ret,B,A); return A=ret;}\n\n\nint main(){\n    ll k;\n    cin>>n>>k;\n    vector<ll> P(n);\n    vector<ll> Q(n);\n    for(auto &I:P){cin>>I; I--;}\n    for(auto &I:Q){cin>>I; I--;}\n    \n    ret.resize(n);\n    vector<ll> PI(n);\n    vector<ll> QI(n);\n    rev(PI,P);\n    rev(QI,Q);\n    vector<ll> O=P*QI*PI*Q;\n    vector<ll> A(n);\n    for(int i=0;i<n;i++){A[i]=i;}\n    \n    if(k==1){\n        Out(P);\n        return 0;\n    }\n    else if(k==2){\n        Out(Q);\n        return 0;\n    }\n    else if(k==3){\n        Out(PI*Q);\n        return 0;\n    }\n    \n    k-=3;\n    ll Z=k/6;\n    while(Z>0){\n        if(Z&1){A*=O;}\n        Z>>=1;\n        O*=O;\n    }\n    \n    if(k%6){A/=Q;}\n    if(k%6>1){A/=PI;}\n    if(k%6>3){A/=QI;}\n    if(k%6==5){A/=P;}\n    \n    rev(O,A);\n    \n    if(k%3==1){\n        QI=PI;\n    }\n    else if(k%3==2){\n        QI=QI;\n    }\n    else{\n        cul(QI,PI,Q);\n    }\n    if((k/3)&1){rev(QI,QI);}\n    O*=QI;\n    O*=A;\n    Out(O);\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N, K;\nint P[1 << 18];\nint Q[1 << 18];\nbool used[1 << 18];\n\nvector<int> Connect(vector<vector<int>> V) {\n\tvector<int> R(V[0].size(), 0);\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tint cx = i;\n\t\tfor (int j = 0; j < V.size(); j++) cx = V[j][cx];\n\t\tR[i] = cx;\n\t}\n\treturn R;\n}\n\nvector<int> Multiply(vector<int> V, int S) {\n\tvector<int> R(V.size(), 0);\n\tfor (int i = 0; i < V.size(); i++) used[i] = false;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (used[i] == true) continue;\n\t\tvector<int> vec; int cx = i;\n\t\twhile (used[cx] == false) {\n\t\t\tused[cx] = true;\n\t\t\tvec.push_back(cx);\n\t\t\tcx = V[cx];\n\t\t}\n\t\tfor (int j = 0; j < vec.size(); j++) R[vec[j]] = vec[(j + S) % vec.size()];\n\t}\n\treturn R;\n}\n\nvector<int> simulator(vector<int> P, vector<int> Q, int K) {\n\tif (K == 1) return P;\n\tif (K == 2) return Q;\n\tfor (int i = 3; i <= K; i++) {\n\t\tvector<int> R(N, 0);\n\t\tfor (int j = 0; j < N; j++) R[P[j]] = Q[j];\n\t\tP = Q; Q = R;\n\t}\n\treturn Q;\n}\n\nint main() {\n\t// Step #1. 入力\n\tcin >> N >> K;\n\tfor (int i = 0; i < N; i++) { cin >> P[i]; P[i]--; }\n\tfor (int i = 0; i < N; i++) { cin >> Q[i]; Q[i]--; }\n\n\t// Step #2. Vector に落とし込む\n\tvector<int> realP(N, 0);\n\tvector<int> realQ(N, 0);\n\tvector<int> subP(N, 0);\n\tvector<int> subQ(N, 0);\n\tfor (int i = 0; i < N; i++) realP[i] = P[i];\n\tfor (int i = 0; i < N; i++) realQ[i] = Q[i];\n\tfor (int i = 0; i < N; i++) subP[P[i]] = i;\n\tfor (int i = 0; i < N; i++) subQ[Q[i]] = i;\n\n\t// Step #3. 場合分け\n\tint M = (K - 1) / 6;\n\tvector<int> Answer;\n\tif (K <= 6) {\n\t\tAnswer = simulator(realP, realQ, K);\n\t}\n\telse if (K % 6 == 1) {\n\t\tvector<int> V1 = Connect({ realP, realQ, subP, subQ });\n\t\tvector<int> V2 = Multiply(V1, M - 1);\n\t\tvector<int> V3 = Connect({ subQ, subP, realQ, realP });\n\t\tvector<int> V4 = Multiply(V3, M - 1);\n\t\tAnswer = Connect({ subQ, V2, realP, realQ, realP, V4, subQ, subP, realQ });\n\t}\n\telse if (K % 6 == 2) {\n\t\tvector<int> V1 = Connect({ realP, realQ, subP, subQ });\n\t\tvector<int> V2 = Multiply(V1, M - 1);\n\t\tvector<int> V3 = Connect({ realQ, realP, subQ, subP });\n\t\tvector<int> V4 = Multiply(V3, M);\n\t\tAnswer = Connect({ subQ, V2, realP, realQ, subP, V4, realQ });\n\t}\n\telse if (K % 6 == 3) {\n\t\tvector<int> V1 = Connect({ realP, realQ, subP, subQ });\n\t\tvector<int> V2 = Multiply(V1, M - 1);\n\t\tvector<int> V3 = Connect({ realQ, realP, subQ, subP });\n\t\tvector<int> V4 = Multiply(V3, M);\n\t\tAnswer = Connect({ subQ, V2, realP, realQ, subP, subP, V4, realQ });\n\t}\n\telse if (K % 6 == 4) {\n\t\tvector<int> V1 = Connect({ realP, realQ, subP, subQ });\n\t\tvector<int> V2 = Multiply(V1, M - 1);\n\t\tvector<int> V3 = Connect({ realQ, realP, subQ, subP });\n\t\tvector<int> V4 = Multiply(V3, M);\n\t\tAnswer = Connect({ subQ, V2, realP, realQ, subP, subQ, subP, V4, realQ });\n\t}\n\telse if (K % 6 == 5) {\n\t\tvector<int> V1 = Connect({ realP, realQ, subP, subQ });\n\t\tvector<int> V2 = Multiply(V1, M);\n\t\tvector<int> V3 = Connect({ subQ, subP, realQ, realP });\n\t\tvector<int> V4 = Multiply(V3, M);\n\t\tAnswer = Connect({ subQ, V2, realP, V4, subQ, subP, realQ });\n\t}\n\telse if (K % 6 == 0) {\n\t\tvector<int> V1 = Connect({ realP, realQ, subP, subQ });\n\t\tvector<int> V2 = Multiply(V1, M);\n\t\tvector<int> V3 = Connect({ subQ, subP, realQ, realP });\n\t\tvector<int> V4 = Multiply(V3, M);\n\t\tAnswer = Connect({ subQ, V2, realP, realP, V4, subQ, subP, realQ });\n\t}\n\n\t// Step #4. 出力\n\tfor (int i = 0; i < Answer.size(); i++) {\n\t\tif (i >= 1) cout << \" \";\n\t\tcout << Answer[i] + 1;\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define maxn 100005\nusing namespace std;\n\nint n,m,p[maxn],q[maxn],i,j,k;\n\nstruct per{int a[maxn];} a,b,A,B,C,D,F;\nper operator*(per a,per b){\n\tper c;\n\tfor(int i=1;i<=n;i++) c.a[i]=b.a[a.a[i]];\n\treturn c;\n}\nper inv(per a){\n\tper b;\n\tfor(int i=1;i<=n;i++) b.a[a.a[i]]=i;\n\treturn b;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tfor(i=1;i<=n;i++) scanf(\"%d\",&q[i]);\n\tfor(i=1;i<=n;i++) a.a[i]=p[i],b.a[i]=q[i];\n\tA=inv(a),B=inv(b),C=B*a*b*A;\n\tfor(i=1;i<=n;i++) D.a[i]=i;\n\tfor(k=(m-1)/6;k;k/=2,C=C*C) if (k&1) D=D*C;\n\tm=(m-1)%6+1;\n\tif (m==1) F=D*a*inv(D);\n\tif (m==2) F=D*b*inv(D);\n\tif (m==3) F=D*A*b*inv(D);\n\tif (m==4) F=D*B*A*b*inv(D);\n\tif (m==5) F=D*B*a*B*A*b*inv(D);\n\tif (m==6) F=D*B*a*a*B*A*B*inv(D);\n\tfor(i=1;i<=n;i++) printf(\"%d \",F.a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <list>\n#include <ostream>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\nusing X = vector<int>;\n\nX inverse(X x) {\n  X r(x.size());\n  for(int i = 0; i < x.size(); i++) r[x[i]] = i;\n  return r;\n}\n\nX op(X a, X b) {\n  X r(a.size());\n  for(int i = 0; i < a.size(); i++) r[i] = b[a[i]];\n  return r;\n}\n\nX f(X a, X b) {\n  X r(a.size());\n  for(int i = 0; i < a.size(); i++) r[a[i]] = b[i];\n  return r;\n}\n\nint n, k;\n\nX getE() {\n  X r(n);\n  iota(begin(r), end(r), 0);\n  return r;\n}\n\nX x[4];\nint cycle[] = {2, 0, 1, 3};\n\n// 実験しただけ…\n\nX get(int start, int t) {\n  int t4 = t / 4;\n  auto a = getE();\n  for(int i = 0; i < 4; i++) a = op(a, x[cycle[(start + i) % 4]]);\n  auto r = getE();\n  while(t4) {\n    if(t4 & 1) r = op(r, a);\n    a = op(a, a);\n    t4 >>= 1;\n  }\n  t %= 4;\n  for(int i = 0; i < t; i++) r = op(r, x[cycle[(start + i) % 4]]);\n  return r;\n}\n\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n\n  cin >> n >> k;\n  k--;\n  X p(n), q(n);\n  for(auto & e: p) cin >> e, e--;\n  for(auto & e: q) cin >> e, e--;\n  x[0] = p;\n  x[1] = q;\n  x[2] = inverse(q);\n  x[3] = inverse(p);\n\n  // assert(p == inverse(x[3]));\n  // assert(q == inverse(x[2]));\n\n  vector<vector<int>> v;\n  v.push_back({0});\n  v.push_back({1});\n  for(int i = 0; i < 20; i++) {\n    auto u = v[i];\n    auto w = v[i+1];\n    for(auto &e : u) e = 3 - e;\n    reverse(u.begin(), u.end());\n    reverse(w.begin(), w.end());\n    while(u.size() && w.size() && u.back() + w.back() == 3) w.pop_back(), u.pop_back();\n    reverse(w.begin(), w.end());\n    u.insert(u.end(), w.begin(), w.end());\n    v.push_back(u);\n    // dump(i, v[i]);\n  }\n\n  auto r = getE();\n  if(k <= 10) {\n    for(int i = 0; i < v[k].size(); i++) r = op(r, x[v[k][i]]);\n  } else {\n    int c = 2 + 2 * ((k - 6) / 3);\n    int len = 6 + 4 * ((k - 5) / 3);\n    switch(k % 3) {\n      case 0:\n        len += 1;\n        break;\n      case 1:\n        len += 2;\n        break;\n      case 2:\n        c++;\n        break;\n    }\n    assert(len >= c);\n    dump(len, c);\n    auto a = get(0, c);\n    auto b = inverse(get(0, len - c));\n    r = op(a, b);\n  }\n\n  for(int i = 0; i < n; i++) cout << r[i] + 1 << \" \\n\"[i == n - 1];\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end());\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint=vector<int>;\nusing vvint=vector<vint>;\nusing pint=pair<int, int>;\nusing vpint=vector<pint>;\nconstexpr double pi = 3.1415926535897932384626433832795028;\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\ninline int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ninline int lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> using priority_queue_rev=priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, const T2 &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, const T2 &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct Setup {\n    static constexpr int PREC = 20;\n    Setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nstruct Permutation {\n    const int n;\n    std::vector<int> data;\n    Permutation(int n) : n(n), data(n) { for (int i = 0; i < n; i++) { data[i] = i; }}\n    Permutation(std::vector<int> &src) : n(src.size()), data(src) {}\n    bool next() { return std::next_permutation(data.begin(), data.end()); }\n    bool prev() { return std::prev_permutation(data.begin(), data.end()); }\n    bool operator==(const Permutation &rhs) const { return data == rhs.data; }\n    bool operator!=(const Permutation &rhs) const { return data != rhs.data; }\n    int operator[](int i) const { return data[i]; }\n    Permutation &operator*=(const Permutation &rhs) {\n        std::vector<int> tmp(data);\n        for (int i = 0; i < n; i++) { data[i] = tmp[rhs[i]]; }\n        return *this;\n    }\n    Permutation &operator/=(const Permutation &rhs) { return *this *= rhs.inv(); }\n    Permutation operator*(const Permutation &rhs) const { return Permutation(*this) *= rhs; }\n    Permutation operator/(const Permutation &rhs) const { return Permutation(*this) /= rhs; }\n    Permutation inv() const {\n        std::vector<int> ret(n);\n        for (int i = 0; i < n; i++) { ret[data[i]] = i; }\n        return ret;\n    }\n    Permutation pow(long long m) const {\n        std::vector<int> ret(n);\n        std::vector<bool> used(n);\n        for (int i = 0; i < n; i++) {\n            if (used[i]) { continue; }\n            std::vector<int> cyc;\n            int cur = i;\n            do {\n                used[cur] = true;\n                cyc.push_back(cur);\n                cur = data[cur];\n            } while (cur != i);\n            for (int j = 0; j < cyc.size(); j++) { ret[cyc[j]] = cyc[(j + m) % cyc.size()]; }\n        }\n        return ret;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Permutation &rhs) {\n        os << \"{\";\n        for (int i = 0; i < rhs.n; i++) { os << rhs[i] << (i + 1 != rhs.n ? \", \" : \"\"); }\n        os << \"}\";\n        return os;\n    }\n};\n\nint N, K;\nsigned main() {\n    cin >> N >> K;\n    vint p(N), q(N);\n    rep(i, N) { cin >> p[i], p[i]--; }\n    rep(i, N) { cin >> q[i], q[i]--; }\n    Permutation P(p), Q(q);\n    Permutation O(N);\n    int k = (K - 1) % 6;\n    if (k == 0) { O *= P; }\n    else if (k == 1) { O *= Q; }\n    else if (k == 2) { O *= Q / P; }\n    else if (k == 3) { O *= Q / P / Q; }\n    else if (k == 4) { O *= Q / P / Q * P / Q; }\n    else if (k == 5) { O *= Q / P / Q * P * P / Q; }\n    Permutation S = (Q / P / Q * P).pow((K - 1) / 6);\n    Permutation A = S * O / S;\n    rep(i, N) { cout << A[i] + 1 << endl; }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct permutation {\n\tint n;\n\tvector<int> p;\n\n\tpermutation () {\n\t\tn = 0;\n\t}\n\tpermutation (int n) {\n\t\tthis -> n = n;\n\t\tfor (int i = 0; i < n; i++) p.push_back(i);\n\t}\n\n\tpermutation& operator = (permutation rhs) {\n\t\tn = rhs.n;\n\t\tp = rhs.p;\n\t\treturn *this;\n\t}\n\n\tpermutation operator * (permutation rhs) const {\n\t\tpermutation res(n);\n\t\tfor (int i = 0; i < n; i++) res.p[i] = p[rhs.p[i]];\n\t\treturn res;\n\t}\n\n\tpermutation inv () const {\n\t\tpermutation res(n);\n\t\tfor (int i = 0; i < n; i++) res.p[p[i]] = i;\n\t\treturn res;\n\t}\n\n\tvoid output () {\n\t\tfor (int i = 0; i < n; i++) write(p[i] + 1), putchar(' ');\n\t\tputchar('\\n');\n\t}\n\n} id, p, q;\n\nint n, k;\n\npermutation qpow (permutation p, int k) {\n\tpermutation res(p.n);\n\twhile (k) {\n\t\tif (k & 1) res = res * p;\n\t\tp = p * p, k >>= 1;\n\t}\n\treturn res;\n}\n\nvector<int> seq[N];\nint main () {\n\tread(n), read(k);\n\tid = p = q = permutation(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tread(p.p[i]), p.p[i]--;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tread(q.p[i]), q.p[i]--;\n\t}\n\n\tif (k == 1) p.output();\n\telse {\n\t\tpermutation a = qpow(q * p.inv() * q.inv() * p, (k - 2) / 6), b;\n\t\tif (k % 6 == 1) a = a * q * p.inv() * q.inv(), b = p;\n\t\tif (k % 6 == 2) b = q;\n\t\tif (k % 6 == 3) b = q * p.inv();\n\t\tif (k % 6 == 4) a = a * q, b = p.inv();\n\t\tif (k % 6 == 5) a = a * q * p.inv(), b = q.inv();\n\t\tif (k % 6 == 0) a = a * q * p.inv(), b = q.inv() * p;\n\t\t(a * b * a.inv()).output();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nint p[2][100001],q[2][100001],n,k;\nint tem[100001],A[100001],ans[100001],con[100001],top,f[6][100001];\nbool vis[100001];\nvoid mul(int *a,int *b,int *c){\n\tfor(int i=1;i<=n;i++)tem[i]=a[b[i]];\n\tfor(int i=1;i<=n;i++)c[i]=tem[i];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[0][i]),p[1][p[0][i]]=i;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&q[0][i]),q[1][q[0][i]]=i;\n\tfor(int i=1;i<=n;i++)A[i]=ans[i]=i;\n\tmul(A,q[0],A);\n\tmul(A,p[1],A);\n\tmul(A,q[1],A);\n\tmul(A,p[0],A);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]){\n\t\t\tcon[(top=0)++]=i;\n\t\t\tint Tem=A[i];\n\t\t\tvis[i]=1;\n\t\t\twhile(Tem!=i){\n\t\t\t\tvis[Tem]=1;\n\t\t\t\tcon[top++]=Tem;\n\t\t\t\tTem=A[Tem];\n\t\t\t}\n\t\t\tfor(int i=0;i<top;i++)\n\t\t\t\ttem[con[i]]=con[(i+k/6)%top];\n\t\t}\n\tfor(int i=1;i<=n;i++)A[i]=tem[i];\n\tmul(ans,A,ans);\n\tmemcpy(f[1],p[0],sizeof p[0]);\n\tmemcpy(f[2],q[0],sizeof q[0]);\n\tfor(int i=3;i<=(k-1)%6+1;i++){\n\t\tfor(int j=1;j<=n;j++)tem[f[i-2][j]]=j;\n\t\tfor(int j=1;j<=n;j++)f[i-2][j]=tem[j];\n\t\tmul(f[i-1],f[i-2],f[i]);\n\t}\n\tmul(ans,f[(k-1)%6+1],ans);\n\tfor(int i=1;i<=n;i++)tem[A[i]]=i;\n\tfor(int i=1;i<=n;i++)A[i]=tem[i];\n\tmul(ans,A,ans);\n\tfor(int i=1;i<=n;i++)printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 1e5+1;\nint a[N];int b[N];int c[N];\nint a2[N];int b2[N];\nint main() {\n\tint n,k;\n\tcin >> n >> k;\n\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\tfor(int i = 1; i <= n; i++) cin >> b[i];\n\tfor(int i = 1; i <= n; i++){\n\t\ta2[i]=a[i];\n\t\tb2[i]=b[i];\n\t}\n\tif(k==1){\n\t\tfor(int i = 1; i <= n; i++) cout << a[i] << \" \";\n\t\treturn 0;\n\t}\n\tif(k==2){\n\t\tfor(int i = 1; i <= n; i++) cout << b[i] << \" \";\n\t\treturn 0;\n\t}\n\tint prd=1000000000;\n\tfor(int i = 1; i <= k-2; i++){\n\t\tfor(int j = 1; j <= n; j++) c[a[j]]=b[j];\n\t\tfor(int j = 1; j <= n; j++) a[j]=b[j];\n\t\tfor(int j = 1; j <= n; j++) b[j]=c[j];\n\t\tbool check=true;\n\t\tfor(int j = 1; j <= n; j++) if((a2[j]!=a[j])||(b2[j]!=b[j])) check=false;\n\t\tif(check){\n\t\t\tprd=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(prd!=1000000000){\n\t\tk%=prd;\n\t\tif(k==0) k=prd;\n\t\tif(k==1){\n\t\t\tfor(int i = 1; i <= n; i++) cout << a[i] << \" \";\n\t\t\treturn 0;\n\t\t}\n\t\telse if(k==2){\n\t\t\tfor(int i = 1; i <= n; i++) cout << b[i] << \" \";\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\tfor(int i = 1; i <= k-2; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++) c[a[j]]=b[j];\n\t\t\t\tfor(int j = 1; j <= n; j++) a[j]=b[j];\n\t\t\t\tfor(int j = 1; j <= n; j++) b[j]=c[j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++) cout << b[i] << \" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nconst int N = 100000 + 7;\n\nint n, k;\nstruct permutation {\n\tint p[N];\n} a[7], g;\n\nvoid init(permutation& a) {\n\tfor (int i = 1; i <= n; ++i) a.p[i] = i;\n}\npermutation mul(const permutation& a, const permutation& b) {\n\tpermutation c;\n\tfor (int i = 1; i <= n; ++i) c.p[i] = a.p[b.p[i]];\n\treturn c;\n}\npermutation mul(const permutation a, const permutation b, const permutation c) {\n\treturn mul(mul(a, b), c);\n}\npermutation inv(const permutation& a) {\n\tpermutation c;\n\tfor (int i = 1; i <= n; ++i) c.p[a.p[i]] = i;\n\treturn c;\n}\npermutation pow(permutation a, int k) {\n\tpermutation c;\n\tinit(c);\n\tfor (; k; a = mul(a, a), k >>= 1) if (k & 1) c = mul(c, a);\n\treturn c;\n}\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d \", &a[1].p[i]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d \", &a[2].p[i]);\n\ta[3] = mul(a[2], inv(a[1]));\n\ta[4] = mul(a[3], inv(a[2]));\n\tg = mul(a[4], a[1]);\n\n\tif (k <= 4)\n\t\tg = a[k];\n\telse {\n\t\tint t = (k - 4 - 1) / 3 + 1;\n\t\tif (t & 1)\n\t\t\tg = mul(pow(g, t / 2 + 1), inv(a[k - 3 * t]), pow(inv(g), t / 2));\n\t\telse\n\t\t\tg = mul(pow(g, t / 2), a[k - 3 * t], pow(inv(g), t / 2));\n\t}\n\tfor (int i = 1; i <= n; ++i) printf(\"%d \", g.p[i]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<deque>\nusing namespace std;\nnamespace mine\n{\n\ttypedef long long ll;\n\t#define double long double\n\tconst int INF=0x3f3f3f3f;\n\tll qread()\n\t{\n\t\tll ans=0;char c=getchar();int f=1;\n\t\twhile(c<'0' or c>'9') {if(c=='-') f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num)\n\t{\n\t\tif(num<0) {num=-num;putchar('-');}\n\t\tif(num>9) write(num/10);\n\t\tputchar('0'+num%10);\n\t}\n\tvoid writeln(int num){write(num);puts(\"\");}\n\t#define FR first\n\t#define SE second\n\t#define MP make_pair\n\t#define pr pair<int,int>\n\t#define PB push_back\n\tinline void chmax(ll &x,ll y) {x=x>y?x:y;}\n\tinline void chmin(ll &x,ll y) {x=x<y?x:y;}\n\n\tconst int MAX_N=1e5+10;\n\tstruct PP\n\t{\n\t\tint m[MAX_N];PP(){memset(m,0,sizeof m);}\n\t\tint& operator [] (int i) {return m[i];}\n\t\tPP inv()\n\t\t{\n\t\t\tPP b;for(int i=1;i<MAX_N;i++) b[m[i]]=i;\n\t\t\treturn b;\n\t\t}\n\n\t\tfriend PP operator * (PP a,PP b)\n\t\t{\n\t\t\tPP c;for(int i=1;i<MAX_N;i++) c[i]=a[b[i]];\n\t\t\treturn c;\n\t\t}\n\t\tfriend PP operator / (PP a,PP b)\n\t\t{\n\t\t\treturn a*b.inv();\n\t\t}\n\t};\n\tPP qpower(PP x,int e)\n\t{\n\t\tPP ans;for(int i=1;i<MAX_N;i++) ans[i]=i;\n\t\twhile(e)\n\t\t{\n\t\t\tif(e&1) ans=ans*x;\n\t\t\tx=x*x;e>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tPP a[10],A,ans;\n\tvoid main()\n\t{\n\t\tint n,k;scanf(\"%d%d\",&n,&k);\n\t\tfor(int i=1;i<=n;i++) a[1][i]=qread();\n\t\tfor(int i=1;i<=n;i++) a[2][i]=qread();\n\t\ta[0]=a[2].inv()*a[1];for(int i=3;i<=5;i++) a[i]=a[i-1]/a[i-2];\n\t\tA=a[2]/a[1]/a[2]*a[1];ans=qpower(A,k/6)*a[k%6]/qpower(A,k/6);\n\t\tfor(int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n \t}\n};\nint main()\n{\n\tsrand(time(0));\n\tmine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nstruct node\n{\n    int a[100005];\n}p,q,s[7];\nnode inv(node x)\n{\n    node s;\n    for(int i=1;i<=n;i++)\n        s.a[x.a[i]]=i;\n    return s;\n}\nnode mul(node x,node y)\n{\n    node z;\n    for(int i=1;i<=n;i++)\n        z.a[i]=x.a[y.a[i]];\n    return z;\n}\nnode qpow(node x,int y)\n{\n    node ans;\n    for(int i=1;i<=n;i++)\n        ans.a[i]=i;\n    while(y)\n    {\n        if(y&1) ans=mul(ans,x);\n        x=mul(x,x);\n        y>>=1;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&p.a[i]);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&q.a[i]);\n    s[1]=p;s[2]=q;\n    for(int i=3;i<=6;i++)\n        s[i]=mul(s[i-1],inv(s[i-2]));\n    if(k<=6)\n    {\n        for(int i=1;i<=n;i++)\n            printf(i==n?\"%d\\n\":\"%d\",s[k].a[i]);\n        return 0;\n    }\n    node A=mul(mul(mul(q,inv(p)),inv(q)),p);\n    A=qpow(A,(k-1)/6);\n    node ans=(mul(A,s[k%6+1]),inv(A));\n    for(int i=1;i<=n;i++)\n        printf(i==n?\"%d\\n\":\"%d \",ans.a[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100100;\nvector<int> compose(const vector<int> &a, const vector<int> &b){\n\tint len = a.size();\n\tvector<int> r(len);\n\tfor(int i = 0; i < len; i++)\n\t\tr[i] = a[b[i]];\n\treturn r;\n}\nvector<int> inverse(const vector<int> &a){\n\tint len = a.size();\n\tvector<int> r(len);\n\tfor(int i = 0; i < len; i++)\n\t\tr[a[i]] = i;\n\treturn r;\n}\nvoid show(const vector<int> &a){\n\tint len = a.size();\n\tfor(int i = 0; i < len; i++)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n}\nvector<int> pwr(vector<int> a, int k){\n\tint len = a.size();\n\tvector<int> r(len);\n\tfor(int i = 0; i < len; i++)\n\t\tr[i] = i;\n\tfor(; k; k >>= 1, a = compose(a, a))\n\t\tif(k&1)\n\t\t\tr = compose(r, a);\n\treturn r;\n}\n/**\n0 = p\n1 = q\n2 = qp-1\n3 = qp-1q-1\n4 = qp-1q-1pq-1\n5 = qp-1q-1pq-1qpq-1 = qp-1q-1ppq-1\n6 = qp-1q-1ppq-1qp-1qpq-1 = qp-1q-1p qpq-1\n\n0 = (I, p)\n1 = (I, q)\n2 = (I, qp-1)\n3 = (q, p-1)\n4 = (qp-1, q-1)\n5 = (qp-1, q-1p)\n**/\nint main(){\n\tint n, k; cin >> n >> k;\n\tvector<int> p(n), q(n);\n\tfor(int i = 0; i < n; i++) cin >> p[i], p[i]--;\n\tfor(int i = 0; i < n; i++) cin >> q[i], q[i]--;\n\tvector<int> fold = compose(q, compose(inverse(p), compose(inverse(q), p)));\n\tk--;\n\tfold = pwr(fold, k / 6); k %= 6;\n\tif(k == 0){\n\t\tfold = compose(fold, compose(p, inverse(fold)));\n\t} else if(k == 1){\n\t\tfold = compose(fold, compose(q, inverse(fold)));\n\t} else if(k == 2){\n\t\tfold = compose(fold, compose(compose(q, inverse(p)), inverse(fold)));\n\t} else if(k == 3){\n\t\tfold = compose(compose(fold, q), compose(inverse(p), inverse(compose(fold, q))));\n\t} else if(k == 4){\n\t\tvector<int> a = compose(q, inverse(p));\n\t\tfold = compose(fold, a);\n\t\tfold = compose(fold, compose(inverse(q), inverse(fold)));\n\t} else {\n\t\tvector<int> a = compose(q, inverse(p));\n\t\tfold = compose(fold, a);\n\t\tfold = compose(fold, compose(compose(inverse(q), p), inverse(fold)));\n\t}\n\tfor(int i = 0; i < n; i++) cout << fold[i] + 1 << \" \";\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (ll)x.size()\n#define f first\n#define s second\nconst ll MOD = 1e9+7;\nconst ll INF = 1e9;\nconst ll MAXN = 200100;\n\nint N,a,b;\n\nvector<int> ask(int len, int fst, int lst, int off){\n  \n  vi ans;\n\n  if (len == 1){\n    ans.pb(fst+off);\n    ans.pb(lst+off);\n    return ans;\n  }\n  int H = (1<<(len-1));\n  int fb=(H&fst)>0;\n  int lb=(H&lst)>0;\n\n  // cout<<fst<<' '<<lst<<'\\n';\n\n  if (fb == lb && fb==1){\n    vi A = ask(len-1, fst-H,lst-H,H);\n    int j=A.back();A.pop_back();\n    int k=A.back();\n    vi B=ask(len-1,k-H,j-H,0);\n    for (auto i:A)ans.pb(i);\n    for (auto i:B)ans.pb(i);\n    ans.pb(j);\n  }\n  else if (fb == lb && fb == 0){\n    vi A = ask(len-1,fst,lst,0);\n    int j=A.back();A.pop_back();\n    int k=A.back();\n    vi B=ask(len-1,k,j,H);\n    for (auto i:A)ans.pb(i);\n    for (auto i:B)ans.pb(i);\n    ans.pb(j);\n    // for (auto i :ans)cout<<i<<' ';\n  }else{\n    int nst = fst%H;\n    int nen = lst%H;\n    int tar=0;\n    while (tar==nst||tar==nen)++tar;\n    if (fst>H){\n      vi A = ask(len-1,nst,tar,H);\n      vi B = ask(len-1,tar,nst,0);\n      for (auto i:A)ans.pb(i);\n      for (auto i:B)ans.pb(i);\n    }else{\n      vi A = ask(len-1,nst,tar,0);\n      vi B = ask(len-1,tar,nst,H);\n      for (auto i:A)ans.pb(i);\n      for (auto i:B)ans.pb(i);\n    }\n  }\n  for (auto &i:ans)i+=off;\n  // for (auto i:ans)cout<<i<<' ';cout<<'\\n';\n  return ans;\n}\n\nint main(){\n  cin>>N>>a>>b;\n  if ((__builtin_popcount(a)^__builtin_popcount(b))%2==0){\n    cout<<\"NO\\n\";\n    return 0;\n  }\n  cout<<\"YES\\n\";\n  for (auto x:ask(N,a,b,0))cout<<x<<' ';\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\n\nint P[110000];\nint Q[110000];\nvector<int>mul(vector<int>a,vector<int>b){\n\tint n=a.size();\n\tvector<int>ret(n);\n\tfor(int i=0;i<n;i++){\n\t\tret[i]=a[b[i]];\n\t}\n\treturn ret;\n}\nvector<int>pw(vector<int>a,int b){\n\tint n=a.size();\n\tvector<int>ret(n);\n\tfor(int i=0;i<n;i++)ret[i]=i;\n\twhile(b){\n\t\tif(b%2){\n\t\t\tvector<int>tmp(n);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ttmp[i]=ret[a[i]];\n\t\t\t}\n\t\t\tret=tmp;\n\t\t}\n\t\tb/=2;\n\t\tvector<int>tmp(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=a[a[i]];\n\t\t}\n\t\ta=tmp;\n\t}\n\treturn ret;\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",P+i);P[i]--;\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",Q+i);Q[i]--;\n\t}\n\tvector<int>p(a);\n\tvector<int>q(a);\n\tvector<int>pi(a);\n\tvector<int>qi(a);\n\tfor(int i=0;i<a;i++){\n\t\tp[i]=P[i];\n\t\tq[i]=Q[i];\n\t\tpi[P[i]]=i;\n\t\tqi[Q[i]]=i;\n\t}\n\tif(b==1){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tprintf(\"%d \",P[i]+1);\n\t\t}printf(\"\\n\");\n\t\treturn 0;\n\t}else if(b==2){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tprintf(\"%d \",Q[i]+1);\n\t\t}printf(\"\\n\");\n\t\treturn 0;\n\t}\n\tint Llen=b/3*2;\n\tif(b%3==2)Llen++;\n\tint Rlen=b/3*2-2;\n\tRlen+=b%3;\n\tvector<int>L(a);\n\tvector<int>R(a);\n\tfor(int i=0;i<a;i++){\n\t\tL[i]=R[i]=i;\n\t}\n\tvector<int>cycle=mul(mul(pi,q),mul(p,qi));\n\tvector<int>Lcycle=mul(mul(q,pi),mul(qi,p));\n\t\n\tR=pw(cycle,Rlen/4);\n\tif(Rlen%4>0)R=mul(qi,R);\n\tif(Rlen%4>1)R=mul(p,R);\n\tif(Rlen%4>2)R=mul(q,R);\n\tL=pw(Lcycle,Llen/4);\n\tif(Llen%4>0)L=mul(L,q);\n\tif(Llen%4>1)L=mul(L,pi);\n\tif(Llen%4>2)L=mul(L,qi);\n\t\n\tvector<int>ret=mul(L,R);\n\tfor(int i=0;i<a;i++)printf(\"%d \",ret[i]+1);printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\n\nvi rev(vi p)\n{\n    vi q(p.size());\n    for (int i = 0; i < p.size(); i++) q[p[i]] = i;\n    return q;\n}\n\nvi apply(vi p, vi q)\n{\n    vi r(p.size());\n    for (int i = 0; i < p.size(); i++) r[i] = p[q[i]];\n    return r;\n}\n\nvi inq(vi A, int k)\n{\n    if (k == 0)\n    {\n        vi a(A.size());\n        iota(all(a), 0);\n        return a;\n    }\n    vi B = inq(A, k / 2);\n    if (k % 2) return apply(B, apply(B, A));\n    return apply(B, B);\n}\n\nvoid solve(int n, int k, vi p, vi q)\n{\n    k--;\n    vi A = apply(q, apply(rev(p), apply(rev(q), p)));\n    A = inq(A, k / 6);\n    vector<vi> a(6);\n    a[0] = apply(A, apply(p, rev(A)));\n    a[1] = apply(A, apply(q, rev(A)));\n    for (int i = 2; i < 6; i++)\n    {\n        a[i] = apply(a[i - 1], rev(a[i - 2]));\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cout << a[k % 6][i] + 1 << \" \";\n    }\n    cout << \"\\n\";\n}\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n    vi p(n), q(n);\n    for (int i = 0; i < n; i++) cin >> p[i], p[i]--;\n    for (int i = 0; i < n; i++) cin >> q[i], q[i]--;\n    solve(n, k, p, q);\n}\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define ALL(a)  (a).begin(),(a).end()\n#define LL long long\n\nint n;\nLL k;\nvector<int> p,q;\nvector<int> mods[6];\n\nvector<int> compose(const vector<int> &v1,const vector<int> &v2){\n  vector<int> v;\n  REP(i,v1.size())v.push_back(v1[v2[i]]);\n  return v;\n}\n\nvector<int> inverse(const vector<int> &v){\n  vector<int> retv(v.size());\n  REP(i,v.size())retv[v[i]]=i;\n  return retv;\n}\n\nint main(){\n  cin>>n>>k;\n  int tmp;\n  REP(i,n){\n    cin>>tmp;tmp--;\n    p.push_back(tmp);\n  }\n  REP(i,n){\n    cin>>tmp;tmp--;\n    q.push_back(tmp);\n  }\n  mods[0]=p;mods[1]=q;\n  REP(i,4){\n    mods[2+i]=compose(mods[1+i],inverse(mods[i]));\n  }\n  LL iter = (k-1)/6;\n  vector<int> pow,b;\n  REP(i,n)pow.push_back(i);\n  b=compose(q,compose(inverse(p),compose(inverse(q),p)));\n  while(iter>0){\n    if(iter%2){\n      pow = compose(pow,b);\n    }\n    b=compose(b,b);\n    iter/=2;\n  }\n  vector<int> v = compose(compose(pow,mods[(k-1)%6]),inverse(pow));\n  REP(i,n){\n    if(i==0)cout<<v[i]+1;\n    else cout<<\" \"<<v[i]+1;\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nint N;\nvector<int> rev(vector<int> &X) {\n\tvector<int> res(N);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tres[X[i]] = i;\n\t}\n\treturn res;\n}\nvector<int> mul(vector<int> &X, vector<int> &Y) {\n\tvector<int> res(N);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tres[i] = Y[X[i]];\n\t}\n\treturn res;\n}\n\nvector<int> ID;\nvector<int> po(vector<int> &X, int k) {\n\tif (k == 0) {\n\t\treturn ID;\n\t}\n\tvector<int> res = po(X, k / 2);\n\tres = mul(res, res);\n\tif (k % 2 == 1) {\n\t\tres = mul(res, X);\n\t}\n\n\treturn res;\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint K;\n\tcin >> N >> K;\n\tID.resize(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tID[i] = i;\n\t}\n\tvector<int> revA(N);\n\tvector<int> revB(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> revA[i]; revA[i]--;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> revB[i]; revB[i]--;\n\t}\n\n\tvector<int> A = rev(revA);\n\tvector<int> B = rev(revB);\n\n\n\t/*vector<int> A;\n\tvector<int> B;\n\tvector<int> C;\n\tA.push_back(1);\n\tB.push_back(2);\n\n\n\tfor (int i = 0; i < K - 2; i++) {\n\t\treverse(A.begin(), A.end());\n\t\tC = B;\n\t\tfor (int j = 0; j < A.size(); j++) {\n\t\t\tA[j] *= -1;\n\t\t\tif (C.size() == 0) {\n\t\t\t\tC.push_back(A[j]);\n\t\t\t}\n\t\t\telse if (C.back() + A[j] == 0) {\n\t\t\t\tC.pop_back();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tC.push_back(A[j]);\n\t\t\t}\n\n\t\t}\n\t\tfor (int j = 0; j < C.size(); j++) {\n\t\t\tif (C[j] > 0)cerr << \" \";\n\t\t\tcerr << C[j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\n\t\tA = B;\n\t\tB = C;\n\t}*/\n\n\n\n\tint X[4] = { 2,-1,-2,1 };\n\t\n\n\tvector<vector<int> > XX(4);\n\tXX[0] = B;\n\tXX[1] = revA;\n\tXX[2] = revB;\n\tXX[3] = A;\n\n\n\tvector<int> ALL = ID;\n\tfor (int i = 0; i < 4; i++) {\n\t\tALL = mul(ALL, XX[i]);\n\t}\n\n\n\n\tvector<int> Z;\n\tif (K % 3 == 0) {\n\t\tint num = 2 * (K / 3) - 2;\n\t\tZ = po(ALL, num / 4);\n\t\tfor (int i = 0; i < num % 4; i++) {\n\t\t\tZ = mul(Z, XX[i]);\n\t\t}\n\t\tvector<int> revZ = rev(Z);\n\n\t\tif (K % 2 == 0) {\n\t\t\tZ = mul(Z, revB);\n\t\t\tZ = mul(Z, A);\n\n\t\t}\n\t\telse {\n\t\t\tZ = mul(Z, B);\n\t\t\tZ = mul(Z, revA);\n\t\t}\n\t\tZ = mul(Z, revZ);\n\t}\n\telse if (K % 3 == 1) {\n\t\tint num = 2 * (K / 3) - 1;\n\t\tZ = po(ALL, num / 4);\n\t\tfor (int i = 0; i < num % 4; i++) {\n\t\t\tZ = mul(Z, XX[i]);\n\t\t}\n\t\tvector<int> revZ = rev(Z);\n\n\t\tif (K % 2 == 0) {\n\t\t\t//cerr << \"hi\" << endl;\n\t\t\tZ = mul(Z, revA);\n\t\t}\n\t\telse {\n\t\t\tZ = mul(Z, A);\n\t\t}\n\n\t\tZ = mul(Z, revZ);\n\t}\n\telse {\n\t\tint num = 2 * (K / 3);\n\t\tZ = po(ALL, num / 4);\n\t\tfor (int i = 0; i < num % 4; i++) {\n\t\t\tZ = mul(Z, XX[i]);\n\t\t}\n\t\tvector<int> revZ = rev(Z);\n\t\tif (K % 2 == 0) {\n\t\t\tZ = mul(Z, B);\n\t\t}\n\t\telse {\n\t\t\tZ = mul(Z, revB);\n\t\t}\n\t\tZ = mul(Z, revZ);\n\t}\n\n\tZ = rev(Z);\n\tif (K == 1) Z = revA;\n\tif (K == 2) Z = revB;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << Z[i] + 1;\n\t}\n\tcout << endl;\n\n\n\n\t//cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int>\nusing namespace std;\ninline int read(){\n\tint v=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0' || c>'9'){\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9'){\n\t\tv=v*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn v*f;\n}\nconst int Maxn=100005;\nint n,k;\nstruct P{\n\tint a[Maxn];\n\tP(){\n\t\tmemset(a,0,sizeof(a));\n\t}\n\tvoid Out(){\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tprintf(\"%d \",a[i]);\n\t\t}\n\t}\n}p,q;\nP inv(P x){\n\tP ret;\n\tfor (int i=1;i<=n;i++){\n\t\tret.a[x.a[i]]=i;\n\t}\n\treturn ret;\n}\nP mul(P x,P y){\n\tP ret;\n\tfor (int i=1;i<=n;i++){\n\t\tret.a[i]=y.a[x.a[i]];\n\t}\n\treturn ret;\n}\nP qp(P x,int pw){\n\tP ret;\n\tfor (int i=1;i<=n;i++){\n\t\tret.a[i]=i;\n\t}\n\twhile (pw){\n\t\tif (pw&1) ret=mul(ret,x);\n\t\tx=mul(x,x);\n\t\tpw>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d %d\",&n,&k);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&p.a[i]);\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&q.a[i]);\n\t}\n\tP pr=inv(p),qr=inv(q);\n\tif (k==1){\n\t\tp.Out();\n\t\treturn 0;\n\t}\n\tif (k==2){\n\t\tq.Out();\n\t\treturn 0;\n\t}\n\tif (k==3){\n\t\tP ret=mul(qr,p);\n\t\tret.Out();\n\t\treturn 0;\n\t}\n\tk-=4;\n\tP tmp=mul(qr,mul(p,mul(q,pr)));\n\tint W=k/6;\n\tk%=6;\n\ttmp=qp(tmp,W);\n\tif (k==0){\n\t\ttmp=mul(tmp,qr);\n\t\tP ans=mul(tmp,mul(pr,inv(tmp)));\n\t\tans.Out();\n\t}\n\telse if (k==1){\n\t\ttmp=mul(tmp,mul(qr,p));\n\t\tP ans=mul(tmp,mul(qr,inv(tmp)));\n\t\tans.Out();\n\t}\n\telse if (k==2){\n\t\ttmp=mul(tmp,mul(qr,p));\n\t\tP ans=mul(tmp,mul(mul(p,qr),inv(tmp)));\n\t\tans.Out();\n\t}\n\telse if (k==3){\n\t\ttmp=mul(tmp,mul(qr,mul(p,q)));\n\t\tP ans=mul(tmp,mul(p,inv(tmp)));\n\t\tans.Out();\n\t}\n\telse if (k==4){\n\t\ttmp=mul(tmp,mul(qr,mul(p,mul(q,pr))));\n\t\tP ans=mul(tmp,mul(q,inv(tmp)));\n\t\tans.Out();\n\t}\n\telse if (k==5){\n\t\ttmp=mul(tmp,mul(qr,mul(p,mul(q,pr))));\n\t\tP ans=mul(tmp,mul(mul(pr,q),inv(tmp)));\n\t\tans.Out();\n\t}\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n//#define cerr if(false) cerr\n#define show(...) cerr << #__VA_ARGS__ << \" = \",debug(__VA_ARGS__);\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate<typename T, typename S>\nostream &operator<<(ostream &os,pair<T,S>a){\n    os << '(' << a.first << ',' << a.second << ')';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, vector<T> v){\n    for(auto x:v)os << x << ' ';\n    return os;\n}\nvoid debug(){cerr << '\\n';}\ntemplate<typename H, typename... T>\nvoid debug(H a, T... b){\n    cerr << a;\n    if(sizeof...(b))cerr << \", \";\n    debug(b...);\n}\n\n//char inv(char c){\n//    return c^32;\n//}\n//string inv(string &a){\n//    auto res = a;\n//    for(auto &x:res) x^=32;\n//    reverse(res.begin(),res.end());\n//    return res;\n//}\n//string product(const string &a,const string &b){\n//    auto res = a;\n//    for(auto x:b){\n//        if(res.size() and inv(x) == res.back())res.erase(res.begin()+res.size()-1);\n//        else res.push_back(x);\n//    }\n//    return res;\n//    \n//}\n\nvector<int> id(const int n){\n    vector<int> res(n);\n    rep(i,n)res[i] = i;\n    return res;\n}\nvector<int> inv(const vector<int> &a){\n    vector<int> res(a.size());\n    rep(i,a.size()){\n        res[a[i]] = i;\n    }\n    return res;\n}\nvector<int> product(const vector<int> &a, const vector<int> &b){\n    vector<int> res(a.size());\n    rep(i,a.size()){\n        res[i] = a[b[i]];\n    }\n    return res;\n}\nvector<int> power(const vector<int> &a, ll p){\n    if(p == 0)return id((int)a.size());\n    auto res = a;\n    auto temp = a;\n    p--;\n    for(int i = 0; i < 60; i++){\n        if(p >> i & 1){\n            res = product(res, temp);\n        }\n        temp = product(temp, temp);\n    }\n    return res;\n}\nint main(){\n    int n;\n    cin >> n;\n    int k;\n    cin >> k;\n    vector<int>p(n),q(n);\n    rep(i,n)cin >> p[i],p[i]--;\n    rep(i,n)cin >> q[i],q[i]--;\n    auto g = product(q,product(inv(p),product(inv(q),p)));\n    g = power(g,(k-1)/6);\n    auto a = product(g,product(p,inv(g)));\n    auto b = product(g,product(q,inv(g)));\n    int now = 2 + (k-1)/6*6;\n    while(now != k){\n        auto c = product(b,inv(a));\n        a = b;\n        b = c;\n        now++;\n    }\n    rep(i,n)cout << b[i] + 1 << \" \\n\"[i==n-1];\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nint p[SIZE],q[SIZE],invp[SIZE],invq[SIZE],d[SIZE],e[SIZE],inve[SIZE];\nint a[6][SIZE];\nbool u[SIZE];\nint main(){\n    int N,K; R(N,K);\n    FOR(i,1,N)R(p[i]);\n    FOR(i,1,N)R(q[i]);\n    FOR(i,1,N){\n        invp[p[i]]=i;\n        invq[q[i]]=i;\n    }\n    memcpy(a[0],p,sizeof(p));\n    memcpy(a[1],q,sizeof(q));\n    FOR(i,2,5){\n        FOR(j,1,N){\n            a[i][a[i-2][j]]=a[i-1][j];\n        }\n    }\n    FOR(i,1,N){\n        d[i]=invp[q[p[invq[i]]]];\n    }\n    K--;\n    int tt=K/6;\n    FOR(i,1,N){\n        if(!u[i]){\n            VI gg;\n            int now=i;\n            while(!u[now]){\n                gg.PB(now);\n                u[now]=1;\n                now=d[now];\n            }\n            REP(j,SZ(gg)) e[gg[j]]=gg[(j+tt)%SZ(gg)];\n        }\n    }\n    FOR(i,1,N)inve[e[i]]=i;\n    VI an;\n    FOR(i,1,N)an.PB(inve[a[K%6][e[i]]]);\n    W(an);\n    return 0;\n}\n/*\n * p\n * q\n * p'q\n * q'p'q\n * q'pq'p'q\n * q'ppq'p'q\n * q'pqp' p pq'p'q\n * q'pqp' q pq'p'q\n * q'pqp' p'q pq'p'q\n * q'pqp'q'p'qpq'p'q\n * q'pqp'q'pq'p'qpq'p'q\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = (int)1e9 + 7;\nconst int maxN = 2 * (int)1e5 + 100;\nint n;\nvector < int > poly_mult(vector < int > a, vector < int > b) {\n    vector < int > c(n);\n    for (int i = 0; i < n; i++) {\n        c[i] = a[b[i]];\n    }\n    return c;\n}\nvector < int > inv(vector < int > a) {\n    vector < int > c(n);\n    for (int i = 0; i < n; i++) {\n        c[a[i]] = i;\n    }\n    return c;\n}\nvector < int > pw(vector < int > a, int k) {\n    vector < int > ans(n);\n    if (k == 0) {\n        for (int i = 0; i < n; i++) ans[i] = i;\n        return ans;\n    }\n    if (k == 1) return a;\n    if (k & 1) return poly_mult(a, pw(a, k - 1));\n    auto t = pw(a, k / 2);\n    return poly_mult(t, t);\n}\nint k;\nvoid print(vector < int > p) {\n    for (int v : p) cout << v + 1 << \" \";\n    exit(0);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> k;\n    vector < int > p(n), q(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i];\n        p[i]--;\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> q[i];\n        q[i]--;\n    }\n    while (k % 6 != 1) {\n        auto t1 = poly_mult(q, inv(p));\n        auto t2 = q;\n        q = t1;\n        p = t2;\n        k--;\n    }\n    if (k == 1) {\n        print(p);\n    }\n    auto pp = p;\n    auto qq = q;\n    for (int i = 0; i < 2; i++) {\n        auto t = poly_mult(qq, inv(pp));\n        pp = qq;\n        qq = t;\n    }\n    // a[4] = qq;\n    auto T = poly_mult(qq, p);\n    auto T1 = pw(T, k / 6);\n    auto T2 = pw(inv(T), k / 6);\n    print(poly_mult(T1, poly_mult(p, T2)));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nvector<int> merge(vector<int> a, const vector<int>& b) {\n\tfor (int x : b) {\n\t\tif (!a.empty() && a.back() == (x ^ 1)) {\n\t\t\ta.pop_back();\n\t\t} else {\n\t\t\ta.push_back(x);\n\t\t}\n\t}\n\treturn a;\n}\n\nvoid inv(vector<int>& a) {\n\treverse(all(a));\n\tfor (int& x : a) {\n\t\tx ^= 1;\n\t}\n}\n\nvoid output(const vector<int>& a) {\n\tint cur = (int)a.size() / 2;\n\tcout << (int)a.size() << \" \";\n\tfor (int x : a) {\n\t\t// cout << (char)('p' + x / 2);\n\t\t// if (x & 1) {\n\t\t// \tcout << \"^{-1}\";\n\t\t// }\n\t\tcout << \"pPqQ\"[x];\n\t\tif (cur-- == 0) {\n\t\t\tcout << \" \";\n\t\t}\n\t}\n\tcout << \"\\n\";\n}\n\nvector<int> mult(const vector<itn>& a, const vector<itn>& b) {\n\tint n = a.size();\n\tvector<int> c(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tc[i] = a[b[i]];\n\t}\n\treturn c;\n}\n\nvector<int> pw(vector<int> a, int b) {\n\tvector<int> res(a.size());\n\tiota(all(res), 0);\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = mult(res, a);\n\t\t}\n\t\tb >>= 1;\n\t\ta = mult(a, a);\n\t}\n\treturn res;\n}\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\t// vector<int> a = {0};\n\t// vector<int> b = {2};\n\t// for (int i = 0; i < 20; ++i) {\n\t// \toutput(a);\n\t// \tinv(a);\n\t// \ta = merge(b, a);\n\t// \ta.swap(b);\n\t// }\n\n\tint n = nxt(), k = nxt();\n\tvector<int> p(n), q(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tp[i] = nxt() - 1;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tq[i] = nxt() - 1;\n\t}\n\tvector<itn> P(n), Q(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tP[p[i]] = Q[q[i]] = i;\n\t}\n\n\tauto qPQp = mult(mult(q, P), mult(Q, p));\n\tauto PqpQ = mult(mult(P, q), mult(p, Q));\n\n\tif (k == 1) {\n\t\tfor (int x : p) {\n\t\t\tprintf(\"%d \", x + 1);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\n\tint len = (k - 2) / 3 * 4 + 1 + (k - 2) % 3;\n\tint lhs = (len + 2) / 2;\n\tint rhs = len - lhs;\n\n\tauto res = pw(PqpQ, rhs / 4);\n\tif (rhs % 4 >= 1) {\n\t\tres = mult(Q, res);\n\t}\n\tif (rhs % 4 >= 2) {\n\t\tres = mult(p, res);\n\t}\n\tif (rhs % 4 >= 3) {\n\t\tres = mult(q, res);\n\t}\n\tif (lhs % 4 >= 3) {\n\t\tres = mult(Q, res);\n\t}\n\tif (lhs % 4 >= 2) {\n\t\tres = mult(P, res);\n\t}\n\tif (lhs % 4 >= 1) {\n\t\tres = mult(q, res);\n\t}\n\tres = mult(pw(qPQp, lhs / 4), res);\n\n\tfor (int x : res) {\n\t\tprintf(\"%d \", x + 1);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\ntypedef vector<int> perm;\nperm operator + (const perm &a, const perm &b) {\n  perm c(n, 0);\n  for (int i = 0; i < n; i++) {\n    c[i] = b[a[i]];\n  }\n  return c;\n}\nperm operator ~ (const perm &a) {\n  perm c(n);\n  for (int i = 0; i < n; i++) {\n    c[a[i]] = i;\n  }\n  return c;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  perm a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    --a[i];\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &b[i]);\n    --b[i];\n  }\n  perm p = ~b + a + b + ~a, q(n);\n  vector<int> visit(n, 0), d;\n  for (int i = 0; i < n; i++) {\n    if (!visit[i]) {\n      d.clear();\n      int j = i;\n      do {\n        d.push_back(j);\n        visit[j] = 1;\n        j = p[j];\n      } while (j ^ i);\n      for (int j = 0; j < (int) d.size(); j++) {\n        q[d[j]] = d[(j + (k - 1) / 6) % d.size()];\n      }\n    }\n  }\n  a = q + a + ~q;\n  b = q + b + ~q;\n  for (int t = (k - 1) % 6; t; t--) {\n    perm c = ~a + b;\n    a = b, b = c;\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d%c\", a[i] + 1, i == n - 1 ? '\\n' : ' ');\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e5+5;\n\nint n,k,p[N],q[N],ip[N],iq[N],tr[N];\nint tmp[N];\n\nvoid multi(int *a,int *b,int *c){\n\tfo(i,1,n)tmp[i]=a[b[i]];\n\tfo(i,1,n)c[i]=tmp[i];\n}\n\nvoid inverse(int *a,int *b){\n\tfo(i,1,n)tmp[a[i]]=i;\n\tfo(i,1,n)b[i]=tmp[i];\n}\n\nbool pd[N];\nint cir[N],u;\nint ans[N];\n\nint main(){\n\tn=get();k=get();\n\tfo(i,1,n)p[i]=get();\n\tfo(i,1,n)q[i]=get();\n\tif (k==1){\n\t\tfo(i,1,n)printf(\"%d \",p[i]);putchar('\\n');\n\t\treturn 0;\n\t}\n\tif (k==2){\n\t\tfo(i,1,n)printf(\"%d \",q[i]);putchar('\\n');\n\t\treturn 0;\n\t}\n\tfo(i,1,n)ip[p[i]]=i,iq[q[i]]=i;\n\tfo(i,1,n)tr[i]=i;\n\tmulti(q,ip,tr);\n\tmulti(tr,iq,tr);\n\tmulti(tr,p,tr);\n\tint tim=(k-1)/6,pos=(k-1)%6+1;\n\tfo(i,1,n)\n\tif (!pd[i]){\n\t\tu=0;\n\t\tfor(int x=i;!pd[x];x=tr[x])pd[cir[++u]=x]=1;\n\t\tfo(j,1,u)ans[cir[j]]=cir[(j+tim-1)%u+1];\n\t}\n\tfo(i,1,n)tr[i]=ans[i];\n\tif (pos==1)fo(i,1,n)ans[i]=p[i];\n\tif (pos==2)fo(i,1,n)ans[i]=q[i];\n\tif (pos==3)multi(q,ip,ans);\n\tif (pos==4){multi(tr,q,tr);fo(i,1,n)ans[i]=ip[i];}\n\tif (pos==5){multi(tr,q,tr);multi(tr,ip,tr);fo(i,1,n)ans[i]=iq[i];}\n\tif (pos==6){multi(iq,p,ans);multi(tr,q,tr);multi(tr,ip,tr);}\n\tmulti(tr,ans,ans);\n\tinverse(tr,tr);\n\tmulti(ans,tr,ans);\n\tfo(i,1,n)printf(\"%d \",ans[i]);putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nll N, K;\nvll p, q;\n\n\nvll op(vll x, vll y) {\n\tvll ret(N + 1);\n\trepn(i, N) { ret[x[i]] = y[i]; }\n\treturn ret;\n}\n\nvll con(vll y,vll x) {\n\tvll ret(N + 1);\n\trepn(i, N)ret[i] = y[x[i]];\n\treturn ret;\n}\n\nvll inv(vll x) {\n\tvll ret(N + 1);\n\trepn(i, N)ret[x[i]] = i;\n\treturn ret;\n}\n\nvll ini;\n\nvll db(vll x, ll K) {\n\tif (K == 0) {\n\t\treturn ini;\n\t}\n\n\t\n\tvll c = db(x, K / 2);\n\tvll ret = con(c, con(c, ini));\n\tif (K % 2 == 1) { ret = con(x, ret); }\n\treturn ret;\n}\n\n\nint main() {\n\tcin >> N >> K;\n\tp.resize(N + 1);\n\tq.resize(N + 1);\n\n\trepn(i, N)cin >> p[i];\n\trepn(i, N) cin >> q[i];\n\n\tini.assign(N + 1, 0);\n\trepn(i, N) ini[i] = i;\n\n\tif (K == 1) {\n\t\trepn(i, N)cout << p[i] << \" \";\n\t\tcout << endl;\n\t\treturn 0;\n\t}\n\n\tvll pqpq = con(inv(p), con(q, con(p, inv(q))));\n\n\tvll ans(N + 1);\n\trepn(i, N) ans[i] = i;\n\n\tvvll a(12);\n\ta[1] = p;\n\ta[2] = q;\n\trepn(i, 9)a[i + 2] = op(a[i], a[i + 1]);\n\n\t//repn(i, 9) {\n\t//\trepn(j, N)cout << a[i][j] << \" \";\n\t//\tcout << endl;\n\t//}\n\n\tll x = (K - 2) % 6 + 2;\n\tll L = (K + 4) / 6 - 1;\n\n\t//repn(i, N)cout << db(pqpq,1)[i] << \" \";\n\t//cout << endl;\n\n\tans = con(db(pqpq, L), ans);\n\t//ans = con(pqpq, ans);\n\tans = con(a[x], ans);\n\t//ans = con(inv(pqpq), ans);\n\tans = con(db(inv(pqpq), L), ans);\n\n\trepn(i, N)cout << ans[i] << \" \";\n\tcout << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define N 100001\nint a[N],b[N],c[N],d[N],i,j,m,n,s[N];\ninline void one(int*x){for(i=1;i<=n;i++)x[i]=i;}\ninline void inv(int*x,int*y)\n{\n    for(i=1;i<=n;i++)s[y[i]]=i;\n    memcpy(x+1,s+1,n<<2);\n}\ninline void mul(int*x,int*y,int*z)\n{\n    for(i=1;i<=n;i++)s[i]=y[z[i]];\n    memcpy(x+1,s+1,n<<2);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(i=1;i<=n;i++)scanf(\"%d\",a+i),c[a[i]]=i;\n    for(i=1;i<=n;i++)scanf(\"%d\",b+i),d[b[i]]=i;\n    for(mul(c,c,b),mul(c,c,a),mul(c,c,d),one(d),j=--m/6,m%=6;j;j>>=1,mul(c,c,c))if(j&1)mul(d,d,c);\n    for(inv(c,d),mul(a,a,d),mul(a,c,a),mul(b,b,d),mul(b,c,b);m;m--)inv(c,a),memcpy(a+1,b+1,n<<2),mul(b,b,c);\n    for(int i=1;i<=n;i++)printf(\"%d%c\",a[i],i==n?'\\n':' ');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvi inv(vi p){\n\tint n=p.size();\n\tvi res(n);\n\trep(i,n)res[p[i]]=i;\n\treturn res;\n}\n\nvi mult(vi p,vi q){\n\tint n=p.size();\n\tvi res(n);\n\trep(i,n)\n\t\tres[i]=q[p[i]];\n\treturn res;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,k;cin>>n>>k;\n\tk--;\n\t\n\tvi p=readvi(n,-1);\n\tvi q=readvi(n,-1);\n\t\n\tvi pinv=inv(p);\n\tvi qinv=inv(q);\n\t\n\tvi r=mult(mult(qinv,p),mult(q,pinv));\n\t\n\tint m=k/6;\n\tvi h(n);\n\tiota(all(h),0);\n\t\n\twhile(m){\n\t\tif(m%2)h=mult(h,r);\n\t\tr=mult(r,r);\n\t\tm>>=1;\n\t}\n\t\n\tk%=6;\n\trep(_,k){\n\t\ttie(p,q)=make_pair(q,mult(inv(p),q));\n\t}\n\t\n\tvi ans=mult(mult(h,p),inv(h));\n\t\n\tfor(auto&v:ans)v++;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\n\n\nvector<int> p1(100020);\n\nvector<int> p2(100020);\n\nvector<int> m1(100020);\nvector<int> m2(100020);\n\nvector<int>Z1,Z2;\nint n;\nvector<int> ff(vector<int>v1,vector<int> v2){\n\tvector<int> ans(n+1,0);\n\t\n\tfor(int i=0;i<=n;i++){\n\t\tans[v1[i]]=v2[i];\n\t}\n\treturn ans;\n}\n\n\nvector<int> BB(vector<int> ve,int kai){\n\tif(kai==1) return ve;\n\tif(kai%2){\n\t\treturn ff(BB(ve,kai-1),ve);\n\t}\n\tvector<int> D=BB(ve,kai/2);\n\treturn ff(D,D);\n}\n\nvector<int> migi(int r, vector<int> ve){\n\t\n\tint t=r/4;\n\tif(t){\n\tvector<int> be=BB(Z2,t);\n\t\t\n\t\tve=ff(be,ve);\n\t}\n\tr%=4;\n\t\n\tif(r>=1) ve=ff(m2,ve);\n\tif(r>=2) ve=ff(p1,ve);\n\tif(r>=3) ve=ff(p2,ve);\n\treturn ve;\n}\n\nvector<int> hidari(int r,vector<int> ve){\n\t\n\tint t=r/4;\n\tint tt=r%4;\n\n\t\n\tif(tt>=3) ve=ff(m2,ve);\n\tif(tt>=2) ve=ff(m1,ve);\n\tif(tt>=1) ve=ff(p2,ve);\n\t\n\tif(t){\n\tvector<int> be=BB(Z1,t);\n\t\t\n\t\tve=ff(be,ve);\n\t}\n\t\n\treturn ve;\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nvector<int> moto;\n \t\n \tint k;\n \tcin>>n>>k;\n \t\n \tfor(int i=0;i<=n;i++)moto.pb(i);\n \t\n \tfor(int i=1;i<=n;i++){\n \t\tcin>>p1[i];\n \t\tm1[p1[i]]=i;\n \t}\n \t\n \tfor(int i=1;i<=n;i++){\n \t\tcin>>p2[i];\n \t\tm2[p2[i]]=i;\n \t}\n \tif(k==1){\n \t\tfor(int i=1;i<=n;i++)cout<<p1[i]<<\" \";\n \t\tcout<<endl;\n \t\treturn 0;\n \t}\n\n \t\n \tif(k==2){\n \t\tfor(int i=1;i<=n;i++)cout<<p2[i]<<\" \";\n \t\tcout<<endl;\n \t\treturn 0;\n \t}\n \t Z1=moto;\n \tZ1=ff(p1,Z1);\n \tZ1=ff(m2,Z1);\n \tZ1=ff(m1,Z1);\n \tZ1=ff(p2,Z1);\n \t\n \t\n \t Z2=moto;\n \tZ2=ff(m2,Z1);\n \tZ2=ff(p1,Z1);\n \tZ2=ff(p2,Z1);\n \tZ2=ff(m1,Z1);\n \t\n \t\n \t\n \tvector<int> ans=moto;\n \t\n \tint k1=(k+1)/3;\n \tk1=k1*2-2;\n \tif(k%3==2)k1--;\n \t\n \tans=migi(k1,ans);\n \t\n \tint k2=k1+3;\n \tif(k%3==0) k2--;\n \tans=hidari(k2,ans);\n \t\n \tfor(int i=1;i<=n;i++)cout<<ans[i]<<\" \";\n \tcout<<endl;\n \treturn 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n//#define cerr if(false) cerr\n#define show(...) cerr << #__VA_ARGS__ << \" = \",debug(__VA_ARGS__);\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate<typename T, typename S>\nostream &operator<<(ostream &os,pair<T,S>a){\n    os << '(' << a.first << ',' << a.second << ')';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, vector<T> v){\n    for(auto x:v)os << x << ' ';\n    return os;\n}\nvoid debug(){cerr << '\\n';}\ntemplate<typename H, typename... T>\nvoid debug(H a, T... b){\n    cerr << a;\n    if(sizeof...(b))cerr << \", \";\n    debug(b...);\n}\n\n//char inv(char c){\n//    return c^32;\n//}\n//string inv(string &a){\n//    auto res = a;\n//    for(auto &x:res) x^=32;\n//    reverse(res.begin(),res.end());\n//    return res;\n//}\n//string product(const string &a,const string &b){\n//    auto res = a;\n//    for(auto x:b){\n//        if(res.size() and inv(x) == res.back())res.erase(res.begin()+res.size()-1);\n//        else res.push_back(x);\n//    }\n//    return res;\n//    \n//}\n\nvector<int> id(const int n){\n    vector<int> res(n);\n    rep(i,n)res[i] = i;\n    return res;\n}\nvector<int> inv(const vector<int> &a){\n    vector<int> res(a.size());\n    rep(i,a.size()){\n        res[a[i]] = i;\n    }\n    return res;\n}\nvector<int> product(const vector<int> &a, const vector<int> &b){\n    vector<int> res(a.size());\n    rep(i,a.size()){\n        res[i] = a[b[i]];\n    }\n    return res;\n}\nvector<int> power(const vector<int> &a, ll p){\n    if(p == 0)return id((int)a.size());\n    auto res = a;\n    auto temp = a;\n    p--;\n    for(int i = 0; i < 30; i++){\n        if(p >> i & 1){\n            res = product(res, temp);\n        }\n        temp = product(temp, temp);\n    }\n    return res;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    int k;\n    cin >> k;\n    vector<int>p(n),q(n);\n    rep(i,n)cin >> p[i],p[i]--;\n    rep(i,n)cin >> q[i],q[i]--;\n    auto g = product(q,product(inv(p),product(inv(q),p)));\n    g = power(g,(k-1)/6);\n    auto a = product(g,product(p,inv(g)));\n    auto b = product(g,product(q,inv(g)));\n    int now = 1 + (k-1)/6*6;\n    while(now != k){\n        auto c = product(b, inv(a));\n        a = b;\n        b = c;\n        now++;\n    }\n    rep(i,n)cout << a[i] + 1 << \" \\n\"[i==n-1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nvector<int> bABa;\nvector<int> AbaB;\nvector<int> a;\nvector<int> b;\nvector<int> A;\nvector<int> B;\nll n;\n\nchar chenge(char c){\n\tif(isupper(c))return tolower(c);\n\telse return toupper(c);\n}\n\nstring rev(string str){\n\tstring ret = \"\";\n\tREP(i, str.size()){\n\t\tret += chenge(str[str.size() - i - 1]);\n\t}\n\treturn ret;\n}\n\nvoid test() {\n\tint n;cin >> n;\n\tstring a = \"a\";\n\tstring b = \"b\";\n\tcout << a << endl << b << endl;\n\tREP(i, n){\n\t\tstring A = rev(a);\t\n\t\tstring B = b;\n\t\twhile(A.size() > 0 && B.size() > 0 && chenge(A.front()) == B.back()){\n\t\t\tA.erase(A.begin());\n\t\t\tB.pop_back();\n\t\t}\n\t\ta = b;\n\t\tb = B + A;\n\t\tint pla = 0;\n\t\twhile(pla < b.size()-1-pla && b[pla] == chenge(b[b.size()-1-pla]))pla++;\n\t\tREP(j, b.size()){\n\t\t\tif(j == pla || j == b.size() - pla)cout << \" \";\n\t\t\tcout << b[j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvector<int> func(vector<int> p, vector<int> q){\n\tvector<int> ret(p.size());\n\tREP(i, p.size()){\n\t\tret[p[i]] = q[i];\n\t}\n\treturn ret;\n}\n\nvector<int> inverse(vector<int> v){\n\tvector<int> ret(v.size());\n\tREP(i, v.size()){\n\t\tret[v[i]] = i;\n\t}\n\treturn ret;\n}\n\nvoid out(vector<int> v){\n\tREP(i, v.size())cout << v[i] + 1 << \" \";cout << endl;\n}\n\nvector<int> make_x(ll n, ll k){\n\tll cou = k / 6;\n\tvector<int> ret(n);\n\tauto kake = bABa;\n\tREP(i, n)ret[i] = i;\n\tREP(i, 30){\n\t\tif(cou & (1 << i)){\n\t\t\tret = func(ret, kake);\n\t\t}\n\t\tkake = func(kake, kake);\n\t}\n\t\n\tint tmp = k % 6;\n\tif(tmp <= 0)return ret;\n\tret = func(ret, b);\n\tif(tmp <= 1)return ret;\n\tret = func(ret, A);\n\tif(tmp <= 3)return ret;\n\tret = func(ret, B);\n\tif(tmp <= 4)return ret;\n\tret = func(ret, a);\n\treturn ret;\n}\n\nvector<int> make_invx(ll n, ll k){\n\tll cou = k / 6;\n\tvector<int> ret(n);\n\tauto kake = AbaB;\n\tREP(i, n)ret[i] = i;\n\tREP(i, 30){\n\t\tif(cou & (1 << i)){\n\t\t\tret = func(ret, kake);\n\t\t}\n\t\tkake = func(kake, kake);\n\t}\n\t\n\tint tmp = k % 6;\n\tif(tmp <= 0)return ret;\n\tret = func(B, ret);\n\tif(tmp <= 1)return ret;\n\tret = func(a, ret);\n\tif(tmp <= 3)return ret;\n\tret = func(b, ret);\n\tif(tmp <= 4)return ret;\n\tret = func(A, ret);\n\treturn ret;\n}\n\nvector<int> make_y(int k){\n\tint tmp = k % 6;\n\tswitch(tmp){\n\t\tcase 0:return func(b, A);\n\t\tcase 1:return A;\n\t\tcase 2:return B;\n\t\tcase 3:return func(B, a);\n\t\tcase 4:return a;\n\t\tcase 5:return b;\n\t}\n}\n\nint main(){\n\tll n, k;cin >> n >> k;\n\ta.resize(n);REP(i, n)cin >> a[i],a[i]--;\n\tb.resize(n);REP(i, n)cin >> b[i],b[i]--;\n\t\n\tif(k == 1){\n\t\tout(a);\n\t\treturn 0;\n\t}\n\tif(k == 2){\n\t\tout(b);\n\t\treturn 0;\n\t}\n\tk -= 3;\n\n\tA = inverse(a);\n\tB = inverse(b);\n\tbABa = func(func(func(b, A), B), a);\t\n\tAbaB = func(func(func(A, b), a), B);\t\n\n\tauto x = make_x(n, k);\n\tauto invx = make_invx(n, k);\n\tauto y = make_y(k);\n\t\n\tout(func(func(x, y), invx));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvector<int> inv(vector<int>&a){\n    vector<int>b(a.size());\n    rep(i,a.size()){\n        b[a[i]] = i;\n    }\n    return b;\n}\n\nvector<int> mul(vector<int>&a,vector<int>&b){\n    int n = a.size();\n    vector<int> res(n);\n    vector<int> ib = inv(b);\n    rep(i,n){\n        res[ib[i]] = a[i];\n    }\n    return res;\n}\nvector<int> calc(vector<int>a,int k){\n\n    if(k==0){\n        int n = a.size();\n        vector<int> res(n);\n        rep(i,n){\n            res[i] = i;\n        }\n        return res;\n    }\n    if(k==1){\n        return a;\n    }\n    if(k%2==0){\n        vector<int> tmp = calc(a,k/2);\n        return mul(tmp,tmp);\n    }else{\n        vector<int> tmp = calc(a,k/2);\n        tmp = mul(tmp,tmp);\n        return mul(a,tmp);\n    }\n}\nint main(){\n    int n,k;\n    cin >> n >> k;\n    vector<int>p(n),q(n);\n    rep(i,n){\n        cin >> p[i];\n        p[i]--;\n    }\n    rep(i,n){\n        cin >> q[i];\n        q[i]--;\n    }\n    k--;\n    int c = k/6;\n    int d = k%6;\n    vector<int> a,b;\n    if(d==0){\n        b = p;\n    }else if(d==1){\n        b = q;\n    }else if(d==2){\n        vector<int> tmp = inv(p);\n        b = mul(q,tmp);\n    }else if(d==3){ \n        b = inv(p);\n    }else if(d==4){\n        b = inv(q);\n    }else if(d==5){\n        vector<int> tmp = inv(q);\n        b = mul(tmp,p);\n    }\n    vector<int> ip,iq;\n    ip = inv(p);\n    iq = inv(q);\n    a = mul(q,ip);\n    a = mul(a,iq);\n    a = mul(a,p);\n    a = calc(a,c);\n    if(d >= 3){\n        a = mul(a,q);\n        a = mul(a,ip);\n    }\n    vector<int> ia = inv(a);\n    vector<int> T = mul(a,b);\n    vector<int>res = mul(T,ia);\n    srep(i,n){\n        cout << res[i]+1 << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\nconst int N = 100010;\n\nvi operator*(const vi& a, const vi& b)\n{\n\tvi res(a.size());\n\tfor (int i = 1; i < a.size(); ++i) res[i] = a[b[i]];\n\treturn res;\n}\n\nvi inv(const vi& a)\n{\n\tvi res(a.size());\n\tfor (int i = 1; i < a.size(); ++i) res[a[i]] = i;\n\treturn res;\n}\n\n/*vi qpow(const vi& a, int y)\n{\n\tvi res(a.size());\n\tstatic vector<bool> vis(a.size(), false);\n\tfor (int i = 1; i < a.size(); ++i)\n\t{\n\t\tif (vis[i]) continue;\n\t\tvi cycle(1, a[i]);\n\t\tfor (int u = a[i]; u != i; u = a[u])\n\t\t{\n\t\t\tcycle.push_back(u);\n\t\t\tvis[u] = true;\n\t\t}\n\t\tfor (int j = 0; j < cycle.size(); ++j) res[cycle[j]] = cycle[(j + y) % cycle.size()];\n\t}\n\treturn res;\n}*/\n\nvi qpow(vi x, int y)\n{\n\tvi out(x.size());\n\tfor (int i = 1; i < x.size(); ++i) out[i] = i;\n\twhile (y)\n\t{\n\t\tif (y & 1) out = out * x;\n\t\tx = x * x;\n\t\ty >>= 1;\n\t}\n\treturn out;\n}\n\nint n, k;\nvi f[10], g, ans;\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\t\n\tf[1].resize(n + 1);\n\tf[2].resize(n + 1);\n\t\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &f[1][i]);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &f[2][i]);\n\tfor (int i = 3; i <= 5; ++i) f[i] = f[i - 1] * inv(f[i - 2]);\n\tf[0] = inv(f[2]) * f[1];\n\tg = f[1] * inv(f[0]) * inv(f[1]) * f[0];\n\t\n\tans = qpow(g, k / 6) * f[k % 6] * qpow(inv(g), k / 6);\n\t\n\tfor (int i = 1; i <= n; ++i) printf(\"%d%c\", ans[i], \" \\n\"[i == n]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=100000 +117;\nconst int MM= +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nint a[NN]={};\nint b[NN]={};\nint ra[NN]={};\nint rb[NN]={};\nint f[NN]={};\nint rf[NN]={};\nint cent[7][NN]={};\nint rev[NN]={};\nint tp[NN]={};\nvoid cp(int tar[],int src[]){\n\tfor(int i=1;i<=n;++i)tar[i]=src[i];\n}\nvoid mul(int a[],int b[]){\n\tfor(int i=1;i<=n;++i){\n\t\ttp[i]=a[b[i]];\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ta[i]=tp[i];\n\t}\n}\nvoid getrev(int a[],int x[]){\n\tfor(int i=1;i<=n;++i){\n\t\ta[x[i]]=i;\n\t}\n}\nint s[NN]={};\nbool vis[NN]={};\nvoid getmi(int a[],int k){\n\tfor(int i=1;i<=n;++i)vis[i]=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(!vis[i]){\n\t\t\tint pos=i;\n\t\t\tint cnt=0;\n\t\t\twhile(!vis[pos]){\n\t\t\t\tvis[pos]=1;\n\t\t\t\ts[cnt++]=pos;\n\t\t\t\tpos=a[pos];\n\t\t\t}\n\t\t\tfor(int j=0;j<cnt;++j){\n\t\t\t\ttp[s[j]]=s[(j+k)%cnt];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)a[i]=tp[i];\n}\nint main(){\n\t//open();\n\tn=read();\n\tint k=read();\n\tfor(int i=1;i<=n;++i){\n\t\ta[i]=read();\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tb[i]=read();\n\t}\n\tgetrev(ra,a);\n\tgetrev(rb,b);\n\tcp(f,b);\n\tmul(f,ra);\n\tmul(f,rb);\n\tmul(f,a);\n\tgetrev(rf,f);\n\tcp(cent[1],a);\n\tcp(cent[2],b);\n\tfor(int i=3;i<=6;++i){\n\t\tcp(cent[i],cent[i-1]);\n\t\tgetrev(rev,cent[i-2]);\n\t\tmul(cent[i],rev);\n\t}\n\tint now=(k-1)%6+1;\n\tgetmi(f,(k-now)/6);\n\tgetmi(rf,(k-now)/6);\n\tmul(f,cent[now]);\n\tmul(f,rf);\n\tfor(int i=1;i<=n;++i){\n\t\tprintf(\"%d \",f[i]);\n\t}\n\tputchar('\\n');\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000000;\nconstexpr ll INF = 1000000000000000000;\nconstexpr ld EPS = 1e-12;\nconstexpr ld PI = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\nvector<int> operator *(vector<int> a, vector<int> b) {\n\tint n = b.size();\n\tvector<int> res(n);\n\trep(i, n) res[i] = a[b[i]];\n\treturn res;\n}\n\nvoid operator *=(vector<int> &a, vector<int> b) {\n\ta = a * b;\n}\n\nvector<int> perm_pow(vector<int> base, ll k) {\n\tint n = base.size();\n\tvector<int> ans(n);\n\trep(i, n) ans[i] = i;\n\twhile (k) {\n\t\tif (k & 1) ans *= base;\n\t\tbase *= base;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> p(n), q(n), pinv(n), qinv(n);\n\trep(i, n) {\n\t\tcin >> p[i];\n\t\tp[i]--;\n\t\tpinv[p[i]] = i;\n\t}\n\trep(i, n) {\n\t\tcin >> q[i];\n\t\tq[i]--;\n\t\tqinv[q[i]] = i;\n\t}\n\tvector<int> ans = q;\n\tif (k == 1) ans = p;\n\tif (k == 3) ans *= pinv;\n\telse {\n\t\tvector<int> x = pinv * qinv * p * q;\n\t\tans *= perm_pow(x, (k - 1) / 6);\n\t\tif ((k - 1) % 6 >= 3) ans *= pinv * qinv;\n\t\tif (k % 6 == 0) ans *= p;\n\t\tif (k % 6 == 3) ans *= pinv;\n\t\tif ((k - 2) % 6 >= 3) ans *= p * qinv;\n\t\tvector<int> y = pinv * q * p * qinv;\n\t\tans *= perm_pow(y, (k - 2) / 6);\n\t}\n\trep(i, n) cout << ans[i] + 1 << ' ';\n\tcout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#define fs first\n#define se second\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\ntypedef pair<ld, ld> pdd;\n\nint n;\nint P[100001];\nint Q[100001];\nint L[100001];\nint R[100001];\nint A[100001];\nint B[100001];\nint T[100001];\nint X[100001];\n\nvoid init(int v[]) {\n    for (int i = 1; i <= n; ++i) v[i] = i;\n}\n\nvoid add(int v[], int s[]) {\n    for (int i = 1; i <= n; ++i) {\n        T[i] = s[v[i]];\n    }\n    for (int i = 1; i <= n; ++i) {\n        v[i] = T[i];\n    }\n}\n\nvoid move(int v[], int s[]) {\n    for (int i = 1; i <= n; ++i) {\n        v[i] = s[i];\n    }\n}\n\nvoid print(int v[]) {\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d \", v[i]);\n    }\n    exit(0);\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; ++i) {\n        cin >> P[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        cin >> Q[i];\n    }\n    if (k == 1) print(P);\n    if (k <= 100) {\n        for (int i = 3; i <= k; ++i) {\n            init(X);\n            for (int j = 1; j <= n; ++j) L[P[j]] = j;\n            add(X, L);\n            add(X, Q);\n            move(P, Q);\n            move(Q, X);\n        }\n        print(Q);\n    }\n    for (int i = 1; i <= n; ++i) {\n        L[P[i]] = i;\n        R[Q[i]] = i;\n    }\n    init(X);\n    add(X, R);\n    add(X, P);\n    add(X, Q);\n    add(X, L);\n    move(A, X);\n    init(X);\n    int pw = (k - 2) / 6;\n    while (pw) {\n        if (pw & 1) {\n            add(X, A);\n        }\n        init(B);\n        add(B, A);\n        add(B, A);\n        move(A, B);\n        pw >>= 1;\n    }\n    move(A, X);\n    for (int i = 1; i <= n; ++i) B[A[i]] = i;\n    init(X);\n    switch(k % 6) {\n    case 0:\n        add(X, A);\n        add(X, R);\n        add(X, P);\n        add(X, P);\n        add(X, R);\n        add(X, L);\n        add(X, Q);\n        add(X, B);\n        break;\n    case 1:\n        add(X, A);\n        add(X, R);\n        add(X, P);\n        add(X, Q);\n        add(X, P);\n        add(X, R);\n        add(X, L);\n        add(X, Q);\n        add(X, B);\n        break;\n    case 2:\n        add(X, A);\n        add(X, Q);\n        add(X, B);\n        break;\n    case 3:\n        add(X, A);\n        add(X, L);\n        add(X, Q);\n        add(X, B);\n        break;\n    case 4:\n        add(X, A);\n        add(X, R);\n        add(X, L);\n        add(X, Q);\n        add(X, B);\n        break;\n    case 5:\n        add(X, A);\n        add(X, R);\n        add(X, P);\n        add(X, R);\n        add(X, L);\n        add(X, Q);\n        add(X, B);\n        break;\n    }\n    print(X);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<ld, ld>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=n;i--;)\n#define rrep2(i,n) for(ll i=n;i--;)\n#define rrep3(i,a,b) for(ll i=b;i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=(a)+((b)-(a)-1)/(c)*(c);i>=(a);i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each1(i,a) for(auto&&i:a)\n#define each2(x,y,a) for(auto&&[x,y]:a)\n#define each3(x,y,z,a) for(auto&&[x,y,z]:a)\n#define each(...) overload4(__VA_ARGS__,each3,each2,each1)(__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define Msum(...) accumulate(all(__VA_ARGS__),0_M)\n#define elif else if\n#define unless(a) if(!(a))\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type>name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type>name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T> bool chmin(T& a, const T& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmax(T& a, const T& b){ if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > T(b)){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < T(b)){ a = b; return 1; } return 0; }\nvector<ll> iota(ll n){ vector<ll> a(n); iota(a.begin(), a.end(), 0); return a; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ull i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T> a){ Uniq(a); unordered_map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T> a){ Uniq(a); map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const complex<T>& a){ if(a.real() >= 0) print('+'); print(a.real()); if(a.imag() >= 0) print('+'); print(a.imag()); print('i'); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline ll __lg(ull __n){ return sizeof(ull) * __CHAR_BIT__  - 1 - __builtin_clzll(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\nint First(bool i = true){ return out(i?\"First\":\"Second\"); }\nint Second(bool i = true){ return out(\"Second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\nstruct Permutation {\n    vector<ll> perm;\n    Permutation(initializer_list<ll> perm): perm(perm) {}\n    Permutation(vector<ll> perm): perm(perm) {}\n    template<class T> Permutation(const initializer_list<T>& perm): perm(perm.begin(), perm.end()) {}\n    template<class T> Permutation(const vector<T>& perm): perm(perm.begin(), perm.end()) {}\n    static Permutation identity(ll n) { vector<ll> ans(n); iota(ans.begin(), ans.end(), 0); return ans; }\n    Permutation inv() const { vector<ll> ans(perm.size()); rep(perm.size()) ans[perm[i]] = i; return ans; }\n    Permutation operator* (const Permutation& x) const { Permutation ans = *this; return ans *= x; }\n    Permutation& operator*=(const Permutation& x) { vector<ll> ans(perm.size()); rep(perm.size()) ans[i] = x.perm[perm[i]]; perm.swap(ans); return *this; }\n    Permutation pow(ll x) const {\n        Permutation ans = identity(perm.size()), cnt = *this;\n        while(x){\n            if(x & 1) ans *= cnt;\n            x /= 2;\n            cnt *= cnt;\n        }\n        return ans;\n    }\n};\nsigned main(){\n    LL(n,k);\n    VEC(ll,a,n);\n    if(k==1)return out(a);\n    VEC(ll,b,n);\n    each(i,a)i--;\n    each(i,b)i--;\n    Permutation p(a),q(b);\n    Permutation l=q.inv()*p*q*p.inv();\n    l=l.pow((k-2)/6);\n    if((k-2)%6>=2)l*=q.inv();\n    if((k-2)%6>=3)l*=p;\n    if((k-2)%6>=5)l*=q;\n    Permutation r=p*q.inv()*p.inv()*q;\n    r=r.pow(k/6);\n    if(k%6>=2)r=q*r;\n    if(k%6>=3)r=p.inv()*r;\n    if(k%6>=5)r=q.inv()*r;\n    l*=r;\n    each(i,l.perm)i++;\n    out(l.perm);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n/**\n * File    : D2.cpp\n * Author  : Kazune Takahashi\n * Created : 2019-5-29 20:27:35\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\n/*\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\n\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n*/\n\n/*\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n*/\n\n// const ll MOD = 1000000007;\n\nint N, K;\nvector<int> a, b, A, B, x, y, I;\n\nvector<int> inv(vector<int> V)\n{\n  vector<int> W(N);\n  for (auto i = 0; i < N; i++)\n  {\n    W[V[i]] = i;\n  }\n  return W;\n}\n\nvector<int> mult(vector<int> V, vector<int> W)\n{\n  vector<int> U(N);\n  for (auto i = 0; i < N; i++)\n  {\n    U[i] = V[W[i]];\n  }\n  return U;\n}\n\nvector<int> power(vector<int> V, int n)\n{\n  if (n == 0)\n  {\n    return I;\n  }\n  else if (n % 2 == 0)\n  {\n    vector<int> W = power(V, n / 2);\n    return mult(W, W);\n  }\n  else\n  {\n    return mult(V, power(V, n - 1));\n  }\n}\n\nvector<int> f(vector<int> V, vector<int> W)\n{\n  return mult(W, inv(V));\n}\n\nvoid flush(vector<int> V)\n{\n  for (auto i = 0; i < N; i++)\n  {\n    cout << V[i] + 1;\n    if (i < N - 1)\n    {\n      cout << \" \";\n    }\n    else\n    {\n      cout << endl;\n    }\n  }\n}\n\nint main()\n{\n  cin >> N >> K;\n  K--;\n  a = vector<int>(N);\n  b = vector<int>(N);\n  I = vector<int>(N);\n  for (auto i = 0; i < N; i++)\n  {\n    I[i] = i;\n  }\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> a[i];\n    a[i]--;\n  }\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> b[i];\n    b[i]--;\n  }\n  A = inv(a);\n  B = inv(b);\n  // $x = bABa$, $y = AbaB$\n  x = mult(mult(b, A), mult(B, a));\n  y = mult(mult(A, b), mult(a, B));\n  if (K == 0)\n  {\n    flush(a);\n    return 0;\n  }\n  int n = (K - 1) / 6;\n  vector<int> p = mult(mult(power(x, n), b), power(y, n));\n  vector<int> q = mult(mult(power(x, n), mult(b, A)), power(y, n));\n  for (auto i = 6 * n + 1; i < K; i++)\n  {\n    vector<int> r = f(p, q);\n    p = q;\n    q = r;\n  }\n  flush(p);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nvector<LL> func(vector<LL> a, vector<LL> b) {\n  vector<LL> ret(a.size());\n  for (int i = 0; i < a.size(); i++) ret[a[i]] = b[i];\n  return ret;\n}\n\nvector<LL> inv(vector<LL> a) {\n  vector<LL> ret(a.size());\n  for (int i = 0; i < a.size(); i++) ret[a[i]] = i;\n  return ret;\n}\n\nvector<LL> mult(vector<LL> a, vector<LL> b) {\n  vector<LL> ret(a.size());\n  for (int i = 0; i < a.size(); i++) ret[i] = a[b[i]];\n  return ret;\n}\n\nvector<LL> pow(vector<LL> a, int k) {\n  if (k == 0) {\n    vector<LL> ret(a.size());\n    for (int i = 0; i < a.size(); i++) ret[i] = i;\n    return ret;\n  }\n  if (k == 1) return a;\n  vector<LL> ret = pow(a, k / 2);\n  ret = mult(ret, ret);\n  if (k % 2 == 1) {\n    ret = mult(ret, a);\n  }\n  return ret;\n}\n\nvoid check(vector<LL> p, vector<LL> q, int K) {\n  K--;\n  vector<vector<LL>> data;\n  data.push_back(p);\n  data.push_back(q);\n  for (int i = 2; i <= 20; i++) {\n    data.push_back(func(data[i - 2], data[i - 1]));\n  }\n\n  auto tmp = mult(data[9], data[6]);\n  auto tmpinv = inv(tmp);\n  auto base = data[K % 6];\n  base = mult(base, pow(tmpinv, K / 6));\n  base = mult(pow(tmp, K / 6), base);\n  for (int i = 0; i < base.size(); i++) {\n    cout << base[i] + 1;\n    if (i < base.size() - 1)\n      cout << \" \";\n    else\n      cout << endl;\n  }\n}\n\nvoid solve(long long N, long long K, std::vector<long long> p,\n           std::vector<long long> q) {\n  for (auto&& i : p) i--;\n  for (auto&& i : q) i--;\n\n  check(p, q, K);\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long K;\n  scanf(\"%lld\", &K);\n  std::vector<long long> p(N);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%lld\", &p[i]);\n  }\n  std::vector<long long> q(N);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%lld\", &q[i]);\n  }\n  solve(N, K, std::move(p), std::move(q));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n;\nvector<ll> ret;\n\n\n\nvoid cul(vector<ll> &ret,const vector<ll> &A,const vector<ll> &B){\n    for(int i=0;i<n;i++){ret[i]=B[A[i]];}\n}\n\nvoid rev(vector<ll> &ret,vector<ll> A){\n    for(int i=0;i<n;i++){ret[A[i]]=i;}\n}\n\nvoid Out(vector<ll> ans){\n    for(int i=0;i+1<n;i++){cout<<ans[i]+1<<\" \";}\n    cout<<ans.back()+1<<endl;\n}\n\nvector<ll> operator * (const vector<ll> &A,const vector<ll> &B){cul(ret,A,B); return ret;}\n\nvector<ll> & operator *= (vector<ll> &A,const vector<ll> &B){cul(ret,A,B); return A=ret;}\n\nvector<ll> & operator /= (vector<ll> &A,const vector<ll> &B){cul(ret,B,A); return A=ret;}\n\n\nint main(){\n    ll k;\n    cin>>n>>k;\n    vector<ll> P(n);\n    vector<ll> Q(n);\n    for(auto &I:P){cin>>I; I--;}\n    for(auto &I:Q){cin>>I; I--;}\n    \n    ret.resize(n);\n    vector<ll> PI(n);\n    vector<ll> QI(n);\n    rev(PI,P);\n    rev(QI,Q);\n    vector<ll> O=P*QI*PI*Q;\n    vector<ll> A(n);\n    for(int i=0;i<n;i++){A[i]=i;}\n    \n    if(k==1){\n        Out(P);\n        return 0;\n    }\n    else if(k==2){\n        Out(Q);\n        return 0;\n    }\n    else if(k==3){\n        Out(PI*Q);\n        return 0;\n    }\n    \n    k-=3;\n    ll Z=k/6;\n    while(Z>0){\n        if(Z&1){A*=O;}\n        Z>>=1;\n        O*=O;\n    }\n    \n    if(k%6){A/=Q;}\n    if(k%6>1){A/=PI;}\n    if(k%6>3){A/=QI;}\n    if(k%6==5){A/=P;}\n    \n    rev(O,A);\n    \n    if(k%3==1){\n        QI=PI;\n    }\n    else if(k%3==2){\n        QI=QI;\n    }\n    else{\n        cul(QI,PI,Q);\n    }\n    if((k/3)&1){rev(QI,QI);}\n    if(k%6==3){rev(QI,Q); QI=P*QI;}\n    O*=QI;\n    O*=A;\n    Out(O);\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace io{\n    const int l=1<<20;\n    char buf[l],*s,*t,c;\n    inline void gc(){\n        if(s==t){\n            t=(s=buf)+fread(buf,1,l,stdin);\n            c=s==t?EOF:*s++;\n        }else c=*s++;\n    }\n    template<class IT>inline void gi(IT &x){\n        x=0;gc();while(c<'0'||c>'9')gc();\n        while('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^48);gc();}\n    }\n    char buf0[20];int a;\n    template<class IT>inline void pi(IT x){\n        if(x<0){putchar('-');x=-x;}\n        do buf0[++a]=x%10+48;while(x/=10);\n        while(a)putchar(buf0[a--]);\n        putchar('\\n');\n    }\n};\nusing io::gi;\nusing io::pi;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\ntypedef vector<int> vi;\ntypedef vector<ll > vl;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=100005;\nint st[N],vis[N],n;\ninline void in(vi &a){\n\tint i,j;\n\ta.resize(n+1);\n\trep(i,1,n)scanf(\"%d\",&a[i]);\n}\ninline void out(const vi &a){\n\tint i;\n\trep(i,1,n)printf(\"%d \",a[i]);\n}\ninline vi inv(const vi &a){\n\tvi b(n+1,0);\n\tint i;\n\trep(i,1,n)b[a[i]]=i;\n\treturn b;\n}\ninline vi mul(const vi &a,const vi &b){\n\tvi c(n+1,0);\n\tint i;\n\trep(i,1,n)c[i]=b[a[i]];\n\treturn c;\n}\ninline vi pow(vi a,int k){\n\tvi b(n+1,0);\n\tint i,j,t;\n\trep(i,1,n)vis[i]=1;\n\trep(i,1,n)if(vis[i]){\n\t\tst[t=0]=i;\n\t\tfor(j=a[i];j!=i;j=a[j])vis[st[++t]=j]=0;\n\t\t++t;\n\t\tREP(j,0,t)b[st[j]]=st[(j+k)%t];\n\t}\n\treturn b;\n}\nvi a,b,c,d;\nint main(){\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int k;\n    scanf(\"%d%d\",&n,&k);--k;\n    in(a);\n\tin(b);\n\td=pow(mul(mul(inv(b),a),mul(b,inv(a))),k/6);\n\tif(k%=6){\n\t\tif(k==1)c=b;\n\t\telse for(;k!=1;--k){c=mul(inv(a),b);a=b;b=c;}\n\t}else c=a;\n\tout(mul(mul(d,c),inv(d)));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\n#define ve vector<int> \nconst int N=100005;\nint n,k; \nve vec[N];\nve mul (ve a,ve b)\n{\n\tve f(n);\n\tfor (int u=0;u<n;u++)\tf[u]=a[b[u]];\n\treturn f;\n}\nve inv (vector<int> a)\n{\n\tve f(n);\n\tfor (int u=0;u<n;u++)\tf[a[u]]=u;\n\treturn f;\n}\nve Pow(ve x,int y)\n{\n\tve f(n);\n\tfor (int u=0;u<n;u++) f[u]=u;\n\twhile (y>0)\n\t{\n\t\tif (y&1) f=mul(f,x);\n\t\tx=mul(x,x);y>>=1;\n\t}\n\treturn f;\n}\nvoid print (ve x)\n{\n\tfor (int u=0;u<n;u++) printf(\"%d \",x[u]+1);\n\tprintf(\"\\n\");\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int u=1;u<=n;u++)\t{int x;scanf(\"%d\",&x);vec[1].push_back(x-1);}\n\tfor (int u=1;u<=n;u++)\t{int x;scanf(\"%d\",&x);vec[2].push_back(x-1);}\n\tfor (int u=3;u<=6;u++) vec[u]=mul(vec[u-1],inv(vec[u-2]));\n\tve A=mul(mul(vec[2],inv(vec[1])),mul(inv(vec[2]),vec[1]));\n\tA=Pow(A,(k-1)/6);\n\tprint(mul(mul(A,vec[(k-1)%6+1]),inv(A)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> inv(const vector<int>& p){\n    vector<int> res(p.size());\n    for(int i=0;i<p.size();i++) res[p[i]] = i;\n    return res;\n}\n\nvector<int> mul(const vector<int>& p, const vector<int>& q){\n    vector<int> res(p.size());\n    for(int i=0;i<p.size();i++) res[i] = p[q[i]];\n    return res;\n}\n\nvector<int> pow(const vector<int>& p, int K){\n    const int N = p.size();\n    if(K == 0){\n        vector<int> res(N);\n        for(int i=0;i<N;i++) res[i] = i;\n        return res;\n    }\n    auto res = pow(p, K/2);\n    res = mul(res, res);\n    if(K%2 == 1) res = mul(res, p);\n    return res;\n}\n\nint main(){\n    int N, K; cin >> N >> K;\n    vector<int> p(N), q(N);\n    for(auto& t : p){ cin >> t; --t; }\n    for(auto& t : q){ cin >> t; --t; }\n    auto pInv = inv(p);\n    auto qInv = inv(q);\n    auto r = mul(mul(mul(q, pInv), qInv), p);\n    r = pow(r, (K-1)/6);\n    auto rInv = inv(r);\n    auto cur = mul(mul(r, p), rInv);\n    auto next = mul(mul(r, q), rInv);\n    int k = (K-1)/6*6+1;\n    while(k < K){\n        auto tmp = next;\n        next = mul(next, inv(cur));\n        cur = tmp;\n        ++k;\n    }\n    for(auto& t : cur) cout << t+1 << \" \";\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 1000000\n#define T 6\nint n,k;\nstruct Permutation\n{\n\tint seq[MAXN+5];\n\tPermutation operator * (Permutation B)\n\t{\n\t\tstatic Permutation ret;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tret.seq[i]=seq[B.seq[i]];\n\t\treturn ret;\n\t}\n\tPermutation Inv()\n\t{\n\t\tstatic Permutation ret;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tret.seq[seq[i]]=i;\n\t\treturn ret;\n\t}\n\tvoid Init()\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tseq[i]=i;\n\t}\n\tvoid Print()\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i==1)\n\t\t\t\tprintf(\"%d\",seq[i]);\n\t\t\telse\n\t\t\t\tprintf(\" %d\",seq[i]);\n\t}\n};\nPermutation PowMod(Permutation a,int b)\n{\n\tstatic Permutation ret;\n\tret.Init();\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tret=ret*a;\n\t\ta=a*a;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nPermutation p,q,ans,ans2,pre,tmp,unit;\nint main()\n{\n\tscanf(\"%d %d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&p.seq[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&q.seq[i]);\n\t\n\tunit=q*p.Inv()*q.Inv()*p;\n\tans=PowMod(unit,(k-1)/T);\n\t\n\tk=k-(k-1)/T*T;\n\tans2.Init();\n\tif(k==1)\t\tans2=p;\n\telse if(k==2)\tans2=q;\n\telse\n\t{\n\t\tans2=q,pre=p;\n\t\tfor(int i=3;i<=k;i++)\n\t\t{\n\t\t\ttmp=ans2;\n\t\t\tans2=ans2*pre.Inv();\n\t\t\tpre=tmp;\n\t\t}\n\t}\n\tans=ans*ans2*ans.Inv();\n\tans.Print();\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n       \ntypedef long long lo;\n\ntemplate <class T> inline void read(T &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = x * 10 + c - '0', c = getchar());\n    if (f) x = -x;\n}  \ntypedef unsigned long long ul;\nconst int N = 1e5 + 233;\nint n, K;\nstruct perm_t {\n    int a[N];\n    perm_t() {\n\tfill(a, a + n + 1, 0);\n    }\n    int& operator [] (int x) {return a[x];}\n    friend perm_t operator * (perm_t x, perm_t y) {\n\tperm_t ans;\n\trep (i, n) ans[i] = x[y[i]];\n\treturn ans;\n    }\n    perm_t inv() {\n\tperm_t p = *this, ans;\n\trep (i, n) ans[p[i]] = i;\n\treturn ans;\n    }\n    inline void read() {\n\trep (i, n) cin >> a[i];\n    }\n    inline void write() {\n\trep (i, n) cout << a[i] << \" \\n\"[i == n];\n    }\n};\nperm_t p, q, t, a[7];\n\nperm_t power(perm_t a, int k) {\n    perm_t ans;\n    rep (i, n) ans[i] = i;\n    for (; k; k >>= 1, a = a * a)\n\tif (k & 1) ans = ans * a;\n    return ans;\n}\n\nint main(void) {\n    read(n); read(K);\n    p.read(); q.read(); t = q * p.inv() * q.inv() * p;\n    t = power(t, (K - 1) / 6);\n    a[1] = t * p * t.inv(); a[2] = t * q * t.inv();\n    for (int i = 3; i <= 6; i++)\n\ta[i] = a[i - 1] * a[i - 2].inv();\n    int ret = K - ((K - 1) / 6) * 6;\n    a[ret].write();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Maxn 100007\nint n,k;\nint p[Maxn],q[Maxn];\nint a[Maxn],b[Maxn],tmp1[Maxn],tmp2[Maxn];\nint ans[Maxn],r[Maxn];\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&p[i]);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&q[i]);\n    if (k%6==1)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=p[i];\n    } else if (k%6==2)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=q[i];\n    } else if (k%6==3)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=q[i];\n    } else if (k%6==4)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=i;\n    } else if (k%6==5)\n    {\n        for (int i=1;i<=n;i++)\n            b[q[i]]=i;\n    } else\n    {\n        for (int i=1;i<=n;i++)\n            tmp1[p[i]]=i,tmp2[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            b[tmp1[i]]=tmp2[i];\n    }\n    for (int i=1;i<=n;i++)\n        ans[i]=i;\n    if (k>1)\n    {\n        --k;\n        int c=k/6;\n        k%=6;\n        for (int i=1;i<=n;i++)\n            tmp1[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            r[i]=p[tmp1[i]];\n        for (int i=1;i<=n;i++)\n            r[i]=q[r[i]];\n        for (int i=1;i<=n;i++)\n            tmp1[p[i]]=i;\n        for (int i=1;i<=n;i++)\n            r[i]=tmp1[r[i]];\n        while (c>0)\n        {\n            if (c%2==1)\n            {\n                for (int i=1;i<=n;i++)\n                    ans[i]=r[ans[i]];\n            }\n            c/=2;\n            for (int i=1;i<=n;i++)\n                tmp1[i]=r[i];\n            for (int i=1;i<=n;i++)\n                r[i]=tmp1[tmp1[i]];\n        }\n        if (k%6==3)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[ans[i]];\n        } else if (k%6==4||k%6==5)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[ans[i]];\n            for (int i=1;i<=n;i++)\n                ans[i]=p[ans[i]];\n        } else if (k%6==0)\n        {\n            for (int i=1;i<=n;i++)\n                tmp1[q[i]]=i;\n            for (int i=1;i<=n;i++)\n                ans[i]=tmp1[ans[i]];\n            for (int i=1;i<=n;i++)\n                ans[i]=q[p[ans[i]]];\n        }\n    }\n    for (int i=1;i<=n;i++)\n        a[ans[i]]=i;\n    for (int i=1;i<=n;i++)\n        ans[i]=b[ans[i]];\n    for (int i=1;i<=n;i++)\n        ans[i]=a[ans[i]];\n    for (int i=1;i<=n;i++)\n        printf(\"%d \",ans[i]);\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 1000000001\nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,k,m,i,j;\nvector<int> a[9],p1,p2,ans;\nvector<int> inv(vector<int> A){\n\tvector<int> B(n);\n\tfor(i=0;i<n;i++)\n\t\tB[A[i]]=i;\n\treturn B;\n}\nvector<int> mul(vector<int> A,vector<int> B){\n\tvector<int> C(n);\n\tfor(i=0;i<n;i++)\n\t\tC[i]=A[B[i]];\n\treturn C;\n}\nvector<int> ksm(vector<int> A,int v){\n\tvector<int> B;\n\tfor(i=0;i<n;i++)\n\t\tB.push_back(i);\n\twhile(v){\n\t\tif(v&1)\n\t\t\tB=mul(B,A);\n\t\tA=mul(A,A);\n\t\tv>>=1;\n\t}\n\treturn B;\n}\nint main(){\n    n=read();k=read();\n    for(i=1;i<=n;i++)\n    \ta[1].push_back(read()-1);\n    for(i=1;i<=n;i++)\n    \ta[2].push_back(read()-1);\n    for(j=3;j<=6;j++)\n    \ta[j]=mul(a[j-1],inv(a[j-2]));\n    p1=mul(a[4],a[1]);\n    p2=inv(p1);\n    m=(k-1)/6;\n    ans=mul(mul(ksm(p1,m),a[(k-1)%6+1]),ksm(p2,m));\n    for(i=0;i<n;i++)\n    \tpus(ans[i]+1,1);\n    cout<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n\nusing namespace std;\nconst int Max_N(100050);\n\nint N;\n\nstruct Perm\n{\n\tint P[Max_N];\n\tinline Perm Inv() const\n\t{\n\t\tPerm c;\n\t\tfor (int i = 1;i <= N;++i)\n\t\t\tc.P[P[i]] = i;\n\t\treturn c;\n\t}\n};\n\ninline Perm operator*(const Perm &a, const Perm &b)\n{\n\tPerm c;\n\tfor (int i = 1;i <= N;++i)\n\t\tc.P[i] = b.P[a.P[i]];\n\treturn c;\n}\n\nPerm operator^(Perm a, int n)\n{\n\tPerm Ret;\n\tfor (int i = 1;i <= N;++i)\n\t\tRet.P[i] = i;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tRet = Ret * a;\n\t\ta = a * a, n >>= 1;\n\t}\n\treturn Ret;\n}\n\n/*\n设F(P, Q) = X，有X[P[i]] = Q[i]。那么X[i] = Q[P^(-1)[i]]，故X = P^(-1) * Q\n然后找规律：\nA[1] = P\nA[2] = Q\nA[3] = P^(-1) * Q\nA[4] = Q^(-1) * P^(-1) * Q\nA[5] = Q^(-1) * P * Q^(-1) * P^(-1) * Q\nA[6] = Q^(-1) * P * Q * Q^(-1) * P * Q^(-1) * P^(-1) * Q = Q^(-1) * P * P * Q^(-1) * P^(-1) * Q\nA[7] = Q^(-1) * P * Q * P^(-1) * Q * Q^(-1) * P * P * Q^(-1) * P^(-1) * Q = Q^(-1) * P * Q * P * Q^(-1) * P^(-1) * Q\nA[8] = Q^(-1) * P * Q * P^(-1) * P^(-1) * Q * Q^(-1) * P * Q * P * Q^(-1) * P^(-1) * Q = Q^(-1) * P * Q * P^(-1) * Q * P * Q^(-1) * P^(-1) * Q\n设B = P * Q^(-1) * P^(-1) * Q，B^(-1) = Q^(-1) * P * Q * P^(-1)，观察可得A[i > 6] = B^(-1) * A[i - 6] * B。然后直接做即可\n*/\n\nint K;\nPerm A[6], P, Q, B, IP, IQ, IB, Ans;\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &K), --K;\n\tfor (int i = 1;i <= N;++i)\n\t\tscanf(\"%d\", &P.P[i]);\n\tfor (int i = 1;i <= N;++i)\n\t\tscanf(\"%d\", &Q.P[i]);\n\tIP = P.Inv(), IQ = Q.Inv();\n\tA[0] = P, A[1] = Q;\n\tfor (int i = 2;i < 6;++i)\n\t\tA[i] = A[i - 2].Inv() * A[i - 1];\n\tIB = (B = P * IQ * IP * Q).Inv();\n\tIB = (IB ^ (K / 6)), B = (B ^ (K / 6));\n\tAns = IB * A[K % 6] * B;\n\tfor (int i = 1;i <= N;++i)\n\t\tprintf(\"%d \", Ans.P[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nint N;\nvector<int> rev(vector<int> &X) {\n\tvector<int> res(N);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tres[X[i]] = i;\n\t}\n\treturn res;\n}\nvector<int> mul(vector<int> &X, vector<int> &Y) {\n\tvector<int> res(N);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tres[i] = Y[X[i]];\n\t}\n\treturn res;\n}\n\nvector<int> ID;\nvector<int> po(vector<int> &X, int k) {\n\tif (k == 0) {\n\t\treturn ID;\n\t}\n\tvector<int> res = po(X, k / 2);\n\tres = mul(res, res);\n\tif (k % 2 == 1) {\n\t\tres = mul(res, X);\n\t}\n\n\treturn res;\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint K;\n\tcin >> N >> K;\n\tID.resize(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tID[i] = i;\n\t}\n\tvector<int> revA(N);\n\tvector<int> revB(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> revA[i]; revA[i]--;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> revB[i]; revB[i]--;\n\t}\n\n\tvector<int> A = rev(revA);\n\tvector<int> B = rev(revB);\n\n\n\t/*vector<int> A;\n\tvector<int> B;\n\tvector<int> C;\n\tA.push_back(1);\n\tB.push_back(2);\n\n\n\tfor (int i = 0; i < K - 2; i++) {\n\t\treverse(A.begin(), A.end());\n\t\tC = B;\n\t\tfor (int j = 0; j < A.size(); j++) {\n\t\t\tA[j] *= -1;\n\t\t\tif (C.size() == 0) {\n\t\t\t\tC.push_back(A[j]);\n\t\t\t}\n\t\t\telse if (C.back() + A[j] == 0) {\n\t\t\t\tC.pop_back();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tC.push_back(A[j]);\n\t\t\t}\n\n\t\t}\n\t\tfor (int j = 0; j < C.size(); j++) {\n\t\t\tif (C[j] > 0)cerr << \" \";\n\t\t\tcerr << C[j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\n\t\tA = B;\n\t\tB = C;\n\t}*/\n\n\n\n\tint X[4] = { 2,-1,-2,1 };\n\t\n\n\tvector<vector<int> > XX(4);\n\tXX[0] = B;\n\tXX[1] = revA;\n\tXX[2] = revB;\n\tXX[3] = A;\n\n\n\tvector<int> ALL = ID;\n\tfor (int i = 0; i < 4; i++) {\n\t\tALL = mul(ALL, XX[i]);\n\t}\n\n\n\n\tvector<int> Z;\n\tif (K % 3 == 0) {\n\t\tint num = 2 * (K / 3) - 2;\n\t\tZ = po(ALL, num / 4);\n\t\tfor (int i = 0; i < num % 4; i++) {\n\t\t\tZ = mul(Z, XX[i]);\n\t\t}\n\t\tvector<int> revZ = rev(Z);\n\n\t\tif (K % 2 == 0) {\n\t\t\tZ = mul(Z, revB);\n\t\t\tZ = mul(Z, A);\n\n\t\t}\n\t\telse {\n\t\t\tZ = mul(Z, B);\n\t\t\tZ = mul(Z, revA);\n\t\t}\n\t\tZ = mul(Z, revZ);\n\t}\n\telse if (K % 3 == 1) {\n\t\tint num = 2 * (K / 3) - 1;\n\t\tZ = po(ALL, num / 4);\n\t\tfor (int i = 0; i < num % 4; i++) {\n\t\t\tZ = mul(Z, XX[i]);\n\t\t}\n\t\tvector<int> revZ = rev(Z);\n\n\t\tif (K % 2 == 0) {\n\t\t\tZ = mul(Z, A);\n\t\t}\n\t\telse {\n\t\t\tZ = mul(Z, revA);\n\t\t}\n\n\t\tZ = mul(Z, revZ);\n\t}\n\telse {\n\t\tint num = 2 * (K / 3);\n\t\tZ = po(ALL, num / 4);\n\t\tfor (int i = 0; i < num % 4; i++) {\n\t\t\tZ = mul(Z, XX[i]);\n\t\t}\n\t\tvector<int> revZ = rev(Z);\n\t\tif (K % 2 == 0) {\n\t\t\tZ = mul(Z, B);\n\t\t}\n\t\telse {\n\t\t\tZ = mul(Z, revB);\n\t\t}\n\t\tZ = mul(Z, revZ);\n\t}\n\tif (K == 1) Z = revA;\n\tif (K == 2) Z = revB;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << Z[i] + 1;\n\t}\n\tcout << endl;\n\n\n\n\t//cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 10;\n\nbool seen[N];\n\nvector<int> inverse(vector<int> p);\nvector<int> compose(vector<int> p, vector<int> q);\nvector<int> power(vector<int> p, int x);\n\nint main() {\n\tfast_cin();\n\tint n, k;\n\tcin >> n >> k;\n\tint t = k;\n\twhile (t > 1 and t % 6 != 2) {\n\t\t--t;\n\t}\n\tint x = (t - 2) / 6;\n\tvector<int> p(n + 1), q(n + 1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> q[i];\n\t}\n\tif (t == 1) {\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tcout << p[i] << ' ';\n\t\t}\n\t\tcout << endl;\n\t\treturn 0;\n\t}\n\tvector<int> p_inv = inverse(p);\n\tvector<int> q_inv = inverse(q);\n\tvector<int> u = q;\n\tu = compose(u, p_inv);\n\tu = compose(u, q_inv);\n\tu = compose(u, p);\n\tvector<int> v = inverse(u);\n\tvector<int> p_t1 = compose(compose(power(u, x), q), power(v, x));\n\tvector<int> p_t2 = compose(compose(power(u, x), compose(q, p_inv)), power(v, x));\n\twhile (t + 1 < k) {\n\t\tvector<int> temp = compose(p_t2, inverse(p_t1));\n\t\tp_t1 = p_t2;\n\t\tp_t2 = temp;\n\t\t++t;\n\t}\n\tvector<int> ans;\n\tif (t == k) {\n\t\tans = p_t1;\n\t} else {\n\t\tans = p_t2;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcout << ans[i] << ' ';\n\t}\n\tcout << endl;\n}\n\nvector<int> inverse(vector<int> p) {\n\tint n = p.size() - 1;\n\tvector<int> ans(n + 1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tans[p[i]] = i;\n\t}\n\treturn ans;\n}\n\nvector<int> compose(vector<int> p, vector<int> q) {\n\tint n = p.size() - 1;\n\tvector<int> ans(n + 1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tans[i] = p[q[i]];\n\t}\n\treturn ans;\n}\n\nvector<int> power(vector<int> p, int x) {\n\tmemset(seen, 0, sizeof(seen));\n\tint n = p.size() - 1;\n\tvector<int> ans(n + 1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (seen[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> cycle;\n\t\tint u = p[i];\n\t\twhile (!seen[u]) {\n\t\t\tseen[u] = true;\n\t\t\tcycle.pb(u);\n\t\t\tu = p[u];\n\t\t}\n\t\tint k = cycle.size();\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tans[cycle[j]] = cycle[(j + x) % k];\n\t\t}\n\t}\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 10;\n\nint N, K;\n\nstruct Perm {\n    int p[MAX_N];\n    int &operator[](int x) { return p[x]; }\n    const int &operator[](int x) const { return p[x]; }\n\n    Perm() { iota(p + 1, p + N + 1, 1); }\n\n    Perm kth_power(int k) {\n        Perm res;\n        static bool vis[MAX_N];\n        fill_n(vis + 1, N, false);\n        for (int i = 1; i <= N; i++) {\n            if (!vis[i]) {\n                vector<int> cycle;\n                for (int j = i; !vis[j]; vis[j] = true, j = p[j]) cycle.push_back(j);\n                int n = cycle.size();\n                for (int j = 0; j < n; j++)\n                    res[cycle[j]] = cycle[(j + n + k) % n];\n            }\n        }\n        return res;\n    }\n};\n\nPerm mult(const Perm &A, const Perm &B) {\n    Perm C;\n    for (int i = 1; i <= N; i++) C[i] = B[A[i]];\n    return C;\n}\n\nPerm small_cases[7];\nPerm P, Q;\n\nint main() {\n    scanf(\"%d%d\", &N, &K);\n    for (int i = 1; i <= N; i++) scanf(\"%d\", &P[i]);\n    for (int i = 1; i <= N; i++) scanf(\"%d\", &Q[i]);\n    small_cases[1] = P;\n    small_cases[2] = Q;\n    for (int i = 3; i <= 6; i++) {\n        small_cases[i] = mult(small_cases[i - 2].kth_power(-1), small_cases[i - 1]);\n    }\n    int m = (K - 1) / 6;\n    Perm res = small_cases[K - 6 * m], head = Q.kth_power(-1);\n    head = mult(head, P);\n    head = mult(head, Q);\n    head = mult(head, P.kth_power(-1));\n    head = head.kth_power(m);\n    res = mult(head, res);\n    res = mult(res, head.kth_power(-1));\n    for (int i = 1; i <= N; i++) printf(\"%d \", res[i]);\n    printf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair < int , int > pii;\ntypedef long long LL;\n#define mpr make_pair\n#define FS first\n#define SC second\n#define PB push_back\ntemplate < typename T > T MAX(T a,T b){return (a>b)?a:b;}\ntemplate < typename T > T MIN(T a,T b){return (a<b)?a:b;}\ntemplate < typename T > void UMAX(T &a,T b){a=(a>b?a:b);}\ntemplate < typename T > void UMIN(T &a,T b){a=(a<b?a:b);}\nint readint(){\n\tchar c=getchar();\n\tint ret=0;\n\twhile(!(c>='0' && c<='9')) c=getchar();\n\twhile(c>='0' && c<='9'){\n\t\tret=ret*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn ret;\n}\nvoid putint(int v){\n\tif(!v){\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif(v>=10) putint(v/10);\n\tputchar('0'+(v%10));\n}\nconst int fhp[4]={-2,1,2,-1},fmd[6]={1,2,2,-1,-2,-2};\nint n,m;\nstruct permu{\n\tvector < int > p;\n\tvoid read(){\n\t\tp.resize(n);\n\t\tint i;\n\t\tfor(i=0;i<n;++i){\n\t\t\tscanf(\"%d\",&p[i]);\n\t\t\t--p[i];\n\t\t}\n\t}\n\tvoid print(){\n\t\tint i;\n\t\tfor(i=0;i<n;++i){\n\t\t\tprintf(\"%d \",p[i]+1);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tvoid init(){\n\t\tp.resize(n);\n\t\tint i;\n\t\tfor(i=0;i<n;++i) p[i]=i;\n\t}\n};\npermu M(permu A,permu B){\n\tpermu ret;\n\tret.init();\n\tint i;\n//\tprintf(\"%d %d\\n\",(int)A.p.size(),(int)B.p.size());\n\tfor(i=0;i<n;++i){\n\t\tret.p[i]=B.p[A.p[i]];\n\t}\n\treturn ret;\n}\npermu P(permu A,int T){\n\tpermu R;\n\tR.init();\n\twhile(T){\n\t\tif(T&1) R=M(R,A);\n\t\tT>>=1;\n\t\tA=M(A,A);\n\t}\n\treturn R;\n}\npermu inv(permu A){\n\tpermu ret;\n\tret.init();\n\tint i;\n\tfor(i=0;i<n;++i) ret.p[A.p[i]]=i;\n\treturn ret;\n}\npermu p,q,ip,iq;\npermu eval(int v){\n\tif(v==1)\n\t\treturn p;\n\telse if(v==-1)\n\t\treturn ip;\n\telse if(v==2)\n\t\treturn q;\n\telse\n\t\treturn iq;\n}\nint getsz(int m){\n\tif(m==1) return 1;\n\tint id=(m+1)/3;\n\treturn (id-1)*4+1+(m+1)%3;\n}\nint main(){\n\tint i,j,k;\n\tscanf(\"%d%d\",&n,&m);\n\tp.read();\n\tq.read();\n\tip=inv(p);\n\tiq=inv(q);\n\tint S=getsz(m);\n//\tprintf(\"S=%d\\n\",S);\n\tpermu ALLP=M(eval(fhp[0]),M(eval(fhp[1]),M(eval(fhp[2]),eval(fhp[3]))));\n\tpermu LLL=P(ALLP,((S&1)?(S/2):(S/2-1))/4),MMM=eval(fmd[(m-1)%6]),RRR;\n\tint t=((S&1)?(S/2):(S/2-1))%4;\n\tfor(i=0;i<t;++i) LLL=M(LLL,eval(fhp[i]));\n\tRRR=inv(LLL);\n\tif(S&1)\n\t\tM(M(LLL,MMM),RRR).print();\n\telse if(m&1)\n\t\tM(LLL,M(M(eval(-1),eval(2)),RRR)).print();\n\telse\n\t\tM(LLL,M(M(eval(1),eval(-2)),RRR)).print();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> operator*(const vector<int>& a, const vector<int>& b) {\n    int sz = a.size();\n    vector<int> c(sz);\n    for (int i = 0; i < sz; i++) {\n        c[i] = a[b[i]];\n    }\n    return c;\n}\nvector<int> inv(const vector<int>& a) {\n    int sz = a.size();\n    vector<int> c(sz);\n    for (int i = 0; i < sz; i++) {\n        c[a[i]] = i;\n    }\n    return c;\n}\nvector<int> vpow(vector<int>& a, int exp) {\n    int sz = a.size();\n    vector<int> c(sz);\n    iota(c.begin(), c.end(), 0);\n    for (; exp; exp>>=1) {\n        if (exp&1)\n            c = c * a;\n        a = a * a;\n    }\n    return c;\n}\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> p(n+1);\n    vector<int> q(n+1);\n    p[0] = q[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        cin >> p[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        cin >> q[i];\n    }\n    vector<int> ip = inv(p);\n    vector<int> iq = inv(q);\n    int exp = (k-1) / 6;\n    int rem = (k-1) % 6;\n    vector<int> base = q*ip*iq*p;\n    vector<int> lhs = vpow(base, exp);\n    vector<int> rhs = inv(lhs);\n    vector<int> mid;\n    if      (rem == 0) mid = p;\n    else if (rem == 1) mid = q;\n    else if (rem == 2) mid = q*ip;\n    else if (rem == 3) mid = q*ip*iq;\n    else if (rem == 4) mid = q*ip*iq*p*iq;\n    else if (rem == 5) mid = q*ip*iq*p*p*iq;\n    vector<int> res = lhs * mid * rhs;\n    for (int i = 1; i <= n; i++) {\n        cout << res[i] << ' ';\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nint n,k,x;\nvec ans,a[4],L,R;\nvec rev(vec v){\n\tvec ans;\n\tans.resize(n+1);\n\tFOR(i,1,n) ans[v[i]]=i;\n\treturn ans;\n}\nvec mul(vec a,vec b){\n\tvec c;\n\tc.clear();\n\tc.pb(0);\n\tFOR(i,1,n) c.pb(b[a[i]]);\n\treturn c;\n}\nvec pw(vec x,int y){\n\tvec t;\n\tt.clear();\n\tt.pb(0);\n\tFOR(i,1,n) t.pb(i);\n\tfor (;y;y>>=1){\n\t\tif (y&1) t=mul(t,x);\n\t\tx=mul(x,x);\n\t}\n\treturn t;\n}\nint main(){\n\t//a1 0\n\t//rev a1 1\n\t//a2 2\n\t//rev a2 3\n\tcin>>n>>k;\n\ta[0].pb(0);\n\tFOR(i,1,n){\n\t\tgetint(x);\n\t\ta[0].pb(x);\n\t}\n\ta[2].pb(0);\n\tFOR(i,1,n){\n\t\tgetint(x);\n\t\ta[2].pb(x);\n\t}\n\ta[1]=rev(a[0]);\n\ta[3]=rev(a[2]);\n\tL=mul(mul(mul(a[3],a[0]),a[2]),a[1]);\n\tR=mul(mul(mul(a[0],a[3]),a[1]),a[2]);\n\tif (k==1){\n\t\tFOR(i,1,n) printf(\"%d \",a[0][i]);\n\t\treturn 0;\n\t}\n\tif (k%6==2){\n\t\tans=pw(L,k/6);\n\t\tans=mul(ans,a[2]);\n\t\tans=mul(ans,pw(R,k/6));\n\t}\n\tif (k%6==3){\n\t\tans=pw(L,k/6);\n\t\tans=mul(ans,a[1]);\n\t\tans=mul(ans,a[2]);\n\t\tans=mul(ans,pw(R,k/6));\n\t}\n\tif (k%6==4){\n\t\tans=pw(L,k/6);\n\t\tans=mul(ans,a[3]);\n\t\tans=mul(ans,a[1]);\n\t\tans=mul(ans,a[2]);\n\t\tans=mul(ans,pw(R,k/6));\n\t}\n\tif (k%6==5){\n\t\tans=pw(L,k/6);\n\t\tans=mul(ans,a[3]);\n\t\tans=mul(ans,pw(R,k/6+1));\n\t}\n\tif (k%6==0){\n\t\tans=pw(L,k/6-1);\n\t\tans=mul(ans,a[3]);\n\t\tans=mul(ans,a[0]);\n\t\tans=mul(ans,pw(R,k/6));\n\t}\n\tif (k%6==1){\n\t\tans=pw(L,k/6-1);\n\t\tans=mul(ans,a[3]);\n\t\tans=mul(ans,a[0]);\n\t\tans=mul(ans,a[2]);\n\t\tans=mul(ans,pw(R,k/6));\n\t}\n\tFOR(i,1,n) printf(\"%d \",ans[i]);\n\treturn 0;\n}\n/*\n0\n2\n12\n312\n30312\n300312\n3020312\n302120312\n3021120312\n30213120312\n3021303120312\n30213003120312\n302130203120312\n30213021203120312\n302130211203120312\n3021302131203120312\n302130213031203120312\n3021302130031203120312\n30213021302031203120312\n3021302130212031203120312\n30213021302112031203120312\n302130213021312031203120312\n30213021302130312031203120312\n302130213021300312031203120312\n3021302130213020312031203120312\n302130213021302120312031203120312\n3021302130213021120312031203120312\n30213021302130213120312031203120312\n3021302130213021303120312031203120312\n30213021302130213003120312031203120312\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\ntypedef vector<int> vi;\n\nint norm(int x, int m) {\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nvi power(const vi& p, int k) {\n  int n = p.size();\n  vector<bool> vis(n);\n  vi ret(n);\n  for (int i = 0; i < n; ++i)\n    if (!vis[i]) {\n      vector<int> cycle;\n      int x = i;\n      while (!vis[x]) {\n        cycle.push_back(x);\n        vis[x] = true;\n        x = p[x];\n      }\n      for (int i = 0; i < cycle.size(); ++i)\n        ret[cycle[i]] = cycle[norm(i + k, cycle.size())];\n    }\n  return ret;\n}\n\nvi inverse(const vi& p) { return power(p, -1); }\n\nvi mult(const vi& p, const vi& q) {\n  int n = p.size();\n  vi ret(n);\n  for (int i = 0; i < n; ++i)\n    ret[i] = p[q[i]];\n  return ret;\n}\n\ntemplate <class T, class... Args>\nvi mult(const T& first, const Args&... args...) {\n  return mult(first, mult(args...));\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  \n  int n, k;\n  cin >> n >> k;\n  --k;\n  vi p(n), q(n);\n  cin >> p >> q;\n  for (int& v : p) --v;\n  for (int& v : q) --v;\n  vi ip = inverse(p), iq = inverse(q), w = mult(q, ip, iq, p);\n  int m = k / 6;\n  static vi little[6];\n  little[0] = mult(power(w, m), q, p, iq, power(w, 1 - m));\n  little[1] = mult(power(w, m), q, power(w, -m));\n  int r = k % 6;\n  for (int i = 2; i <= r; ++i)\n    little[i] = mult(little[i - 1], inverse(little[i - 2]));\n  for (int i = 0; i <= r; ++i)\n    cout << little[i] << '\\n';\n  vi ans = little[r];\n  for (int& v : ans) ++v;\n  cout << ans << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=305,INF=1<<30;\n\nvector<int> rev(vector<int> &A){\n    vector<int> res(si(A));\n    \n    for(int i=0;i<si(A);i++){\n        res[A[i]]=i;\n    }\n    \n    return res;\n}\n\nvector<int> mul(vector<int> &A,vector<int> &B){\n    vector<int> res=A;\n    \n    for(int i=0;i<si(A);i++){\n        res[i]=B[res[i]];\n    }\n    \n    return res;\n}//A→Bの順\n\nvector<int> pow(vector<int> &A,ll n){\n    vector<int> res(si(A));\n    iota(all(res),0);\n    \n    while(n>0){\n        if(n&1) res=mul(res,A);\n        A=mul(A,A);\n        n/=2;\n    }\n    \n    return res;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    random_device seed_gen;\n    mt19937_64 rng(seed_gen());\n    \n    int N,K;cin>>N>>K;\n    K--;\n    vector<int> p(N),q(N);\n    for(int i=0;i<N;i++){\n        cin>>p[i];\n        p[i]--;\n    }\n    for(int i=0;i<N;i++){\n        cin>>q[i];\n        q[i]--;\n    }\n    \n    vector<int> pp=rev(p),qq=rev(q),r=mul(pp,q);\n    \n    if(K==0){\n        for(int a:p) cout<<a+1<<\" \";\n        cout<<endl;\n        return 0;\n    }\n    \n    if(K==1){\n        for(int a:q) cout<<a+1<<\" \";\n        cout<<endl;\n        return 0;\n    }\n    \n    if(K==2){\n        for(int a:r) cout<<a+1<<\" \";\n        cout<<endl;\n        return 0;\n    }\n    \n    vector<int> A(N),B(N),res(N);\n    iota(all(A),0);\n    iota(all(B),0);\n    iota(all(res),0);\n    A=mul(A,p);\n    A=mul(A,qq);\n    A=mul(A,pp);\n    A=mul(A,q);\n    \n    B=mul(B,qq);\n    B=mul(B,p);\n    B=mul(B,q);\n    B=mul(B,pp);\n    \n    int x=(K-3)%6,y=(K-3)/6;\n    \n    A=pow(A,y);\n    B=pow(B,y);\n    \n    p=q;\n    q=r;\n    \n    for(int i=0;i<=x;i++){\n        pp=rev(p);\n        r=mul(pp,q);\n        \n        p=q;\n        q=r;\n    }\n    \n    res=mul(res,B);\n    res=mul(res,q);\n    res=mul(res,A);\n    \n    for(int a:res) cout<<a+1<<\" \";\n    cout<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (100010)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\ntypedef vector<int> vc;\nint n,m;\nvc a,b,inva,invb,t[N],tmp,tmp2,ans;\nvc getinv(vc a){\n\tvc t; t.resize(n+1);\n\tfor(int i=1;i<=n;i++)\n\tt[a[i]]=i;\n\treturn t;\n}\nvc mul(vc a,vc b){\n\tvc c; c.resize(n+1);\n\tfor(int i=1;i<=n;i++)\n\tc[i]=a[b[i]];\n\treturn c;\n}\nvc ksm(vc a,int p){\n\tvc res; res.resize(n+1);\n\tfor(int i=1;i<=n;i++)res[i]=i;\n\twhile(p){\n\t\tif(p&1)res=mul(res,a);\n\t\ta=mul(a,a),p>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tread(n),read(m),a.resize(n+1),b.resize(n+1); \n\tfor(int i=1;i<=n;i++)read(a[i]);\n\tfor(int i=1;i<=n;i++)read(b[i]);\n\tinva=getinv(a),invb=getinv(b);\n\tt[1]=a,t[2]=b;\n\tfor(int i=3;i<=6;i++)t[i]=mul(t[i-1],getinv(t[i-2]));\n\ttmp=mul(mul(mul(b,inva),invb),a); tmp2=getinv(tmp); int K=(m-1)/6;\n\tans=mul(mul(ksm(tmp,K),t[(m-1)%6+1]),ksm(tmp2,K));\n\tfor(int i=1;i<=n;i++)printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking\n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define inf 2147480000\nusing namespace std;\nint n,k;\nstruct perm{\n\tint a[100005];\n\tperm operator +(const perm &b)const{\n\t\tperm c;\n\t\tFor(i,1,n) c.a[i]=a[b.a[i]];\n\t\treturn c;\n\t}\n\tperm operator -(const perm &b)const{\n\t\tperm c,d;\n\t\tFor(i,1,n) d.a[b.a[i]]=i;\n\t\tFor(i,1,n) c.a[i]=a[d.a[i]];\n\t\treturn c;\n\t}\n\tvoid init(){\n\t\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\t}\n}a,b;\nvoid output(perm a){\n\tFor(i,1,n) printf(\"%d \",a.a[i]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\ta.init();\n\tb.init();\n\tif (k==1) return output(a),0;\n\tif (k==2) return output(b),0;\n\tint T=(k-2)/6;\n\tperm tmp,S;\n\tFor(i,1,n) tmp.a[i]=i;\n\tS=b-a-b+a;\n\tfor (;T;T>>=1,S=S+S)\n\t\tif (T&1) tmp=tmp+S;\n\ta=tmp+a-tmp;\n\tb=tmp+b-tmp;\n\tk-=(k-2)/6*6;\n\tFor(i,3,k){\n\t\tperm c=b-a;\n\t\ta=b; b=c;\n\t}\n\toutput(b);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\nbool is_equal(int loop[], int q[], int n);\n\nint main()\n{\n    int n, cnt = 0;\n    long k;\n    cin >> n >> k;\n\n    int p[n], q[n], tmp[n], loop_p[n], loop_q[n];\n    for (int i = 0; i < n; i++) cin >> p[i];\n    for (int i = 0; i < n; i++) cin >> q[i];\n    if (k == 1) {\n        for (int i = 0; i < n - 1; i++) cout << p[i] << \" \";\n        cout << p[n - 1] << endl;\n    } \n    else if (k == 2) {\n        for (int i = 0; i < n - 1; i++) cout << q[i] << \" \";\n        cout << q[n - 1] << endl;\n    } \n    else {\n        for (int i = 2; i < k; i++)\n        {\n            if (i == 3)\n                for (int i = 0; i < n; i++) loop_p[i] = p[i];\n            if (i == 4)\n                for (int i = 0; i < n; i++) loop_q[i] = q[i];\n            cnt++;\n            for (int j = 0; j < n; j++)\n                tmp[(p[j] - 1)] = q[j];\n            for (int j = 0; j < n; j++) {\n                p[j] = q[j];\n                q[j] = tmp[j];\n            }\n            \n            if (is_equal(loop_p, p, n) && is_equal(loop_q, q, n))\n            {\n                for (int i = 0; i < ((k - 2) % cnt); i++) {\n                    for (int j = 0; j < n; j++)\n                        tmp[(p[j] - 1)] = q[j];\n                    for (int j = 0; j < n; j++) {\n                        p[j] = q[j];\n                        q[j] = tmp[j];\n                    }\n                }\n                break;\n            }\n        }\n        for (int i = 0; i < n - 1; i++)\n            cout << q[i] << \" \";\n        cout << q[n - 1] << endl;\n    }\n}\n\nbool is_equal(int loop[], int q[], int n)\n{\n    for (int i = 0; i < n; i++) {\n        if (loop[i] != q[i]) return false;\n    }\n    return true;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, k;\nint p[100005], q[100005];\nint P[100005], Q[100005];\nint QpqP[100005], PqpQ[100005];\nint beki1[100005], beki2[100005];\nint ans[100005];\n\nint tmp[100005], tmp2[100005];\nvoid print(int p[])\n{\n\tfor(int i = 1; i <= n; i++) cout << p[i] << \" \"; cout << endl;\n}\nvoid inv(int p[], int dest[])\n{\n\tfor(int i = 1; i <= n; i++) dest[p[i]] = i;\n}\nvoid mul(int p[], int q[], int dest[])\n{\n\tfor(int i = 1; i <= n; i++) tmp[i] = q[p[i]];\n\tfor(int i = 1; i <= n; i++) dest[i] = tmp[i];\n}\nvoid ident(int p[])\n{\n\tfor(int i = 1; i <= n; i++) p[i] = i;\n}\nvoid power(int p[], int k, int dest[])\n{\n\tfor(int i = 1; i <= n; i++) tmp2[i] = p[i];\n\tident(dest);\n\tfor(;k;k/=2){\n\t\tif(k%2) mul(dest, tmp2, dest);\n\t\tmul(tmp2, tmp2, tmp2);\n\t}\n}\n\n\nint main(void)\n{\n\tcin >> n >> k;\n\tfor(int i = 1; i <= n; i++) cin >> p[i];\n\tfor(int i = 1; i <= n; i++) cin >> q[i];\n\tinv(p, P), inv(q, Q);\n\t\n\tif(k == 1){\n\t\tprint(p);\n\t\treturn 0;\n\t}\n\tif(k == 2){\n\t\tprint(q);\n\t\treturn 0;\n\t}\n\tk -= 3;\n\t\n\tident(QpqP);\n\tmul(QpqP, Q, QpqP);\n\tmul(QpqP, p, QpqP);\n\tmul(QpqP, q, QpqP);\n\tmul(QpqP, P, QpqP);\n\t\n\tident(PqpQ);\n\tmul(PqpQ, P, PqpQ);\n\tmul(PqpQ, q, PqpQ);\n\tmul(PqpQ, p, PqpQ);\n\tmul(PqpQ, Q, PqpQ);\n\t\n\tpower(QpqP, k/6, QpqP);\n\tpower(PqpQ, k/6, PqpQ);\n\t\n\tident(ans);\n\tmul(ans, QpqP, ans);\n\t\n\tif(k%6 == 1) mul(ans, Q, ans);\n\tif(k%6 == 2){\n\t\tmul(ans, Q, ans);\n\t\tmul(ans, p, ans);\n\t\tmul(ans, Q, ans);\n\t}\n\tif(k%6 == 3){\n\t\tmul(ans, Q, ans);\n\t\tmul(ans, p, ans);\n\t\tmul(ans, p, ans);\n\t\tmul(ans, Q, ans);\n\t}\n\tif(k%6 == 4){\n\t\tmul(ans, Q, ans);\n\t\tmul(ans, p, ans);\n\t\tmul(ans, q, ans);\n\t\tmul(ans, p, ans);\n\t\tmul(ans, Q, ans);\n\t}\n\tif(k%6 == 5){\n\t\tmul(ans, Q, ans);\n\t\tmul(ans, p, ans);\n\t\tmul(ans, q, ans);\n\t\tmul(ans, P, ans);\n\t\tmul(ans, q, ans);\n\t\tmul(ans, p, ans);\n\t\tmul(ans, Q, ans);\n\t}\n\t\n\tmul(ans, PqpQ, ans);\n\tmul(ans, P, ans);\n\tmul(ans, q, ans);\n\tprint(ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <list>\n#include <ostream>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\nusing X = vector<int>;\n\nX inverse(X x) {\n  X r(x.size());\n  for(int i = 0; i < x.size(); i++) r[x[i]] = i;\n  return r;\n}\n\nX op(X a, X b) {\n  X r(a.size());\n  for(int i = 0; i < a.size(); i++) r[i] = b[a[i]];\n  return r;\n}\n\nX f(X a, X b) {\n  X r(a.size());\n  for(int i = 0; i < a.size(); i++) r[a[i]] = b[i];\n  return r;\n}\n\nint n, k;\n\nX getE() {\n  X r(n);\n  iota(begin(r), end(r), 0);\n  return r;\n}\n\nX x[4];\nint cycle[] = {2, 0, 1, 3};\n\n// 実験しただけ…\n\nX get(int start, int t) {\n  int t4 = t / 4;\n  auto a = getE();\n  for(int i = 0; i < 4; i++) a = op(a, x[cycle[(start + i) % 4]]);\n  auto r = getE();\n  while(t4) {\n    if(t4 & 1) r = op(r, a);\n    a = op(a, a);\n    t4 >>= 1;\n  }\n  t %= 4;\n  for(int i = 0; i < t; i++) r = op(r, x[cycle[(start + i) % 4]]);\n  return r;\n}\n\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n\n  cin >> n >> k;\n  k--;\n  X p(n), q(n);\n  for(auto & e: p) cin >> e, e--;\n  for(auto & e: q) cin >> e, e--;\n  x[0] = p;\n  x[1] = q;\n  x[2] = inverse(q);\n  x[3] = inverse(p);\n\n  // assert(p == inverse(x[3]));\n  // assert(q == inverse(x[2]));\n\n  vector<vector<int>> v;\n  v.push_back({0});\n  v.push_back({1});\n  for(int i = 0; i < 20; i++) {\n    auto u = v[i];\n    auto w = v[i+1];\n    for(auto &e : u) e = 3 - e;\n    reverse(u.begin(), u.end());\n    reverse(w.begin(), w.end());\n    while(u.size() && w.size() && u.back() + w.back() == 3) w.pop_back(), u.pop_back();\n    reverse(w.begin(), w.end());\n    u.insert(u.end(), w.begin(), w.end());\n    v.push_back(u);\n    // dump(i, v[i]);\n  }\n\n  auto r = getE();\n  if(k <= 10) {\n    for(int i = 0; i < v[k].size(); i++) r = op(r, x[v[k][i]]);\n  } else {\n    int c = 2 + 2 * ((k - 6) / 3);\n    int len = 6 + 4 * ((k - 5) / 3);\n    switch(k % 3) {\n      case 0:\n        len += 1;\n        break;\n      case 1:\n        len += 3;\n        break;\n      case 2:\n        c++;\n        break;\n    }\n    assert(len >= c);\n    dump(len, c);\n    auto a = get(0, c);\n    auto b = inverse(get(0, len - c));\n    r = op(a, b);\n  }\n\n  for(int i = 0; i < n; i++) cout << r[i] + 1 << \" \\n\"[i == n - 1];\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 100010;\nint tmp[MAXN];\nint n, K;\nstruct pr {\n\tint A[MAXN];\n\tpr() {}\n\tpr(int * B) { memcpy(A, B, n + 1 << 2); }\n\tpr inv() {\n\t\tfor (int i = 1; i <= n; ++i) tmp[A[i]] = i;\n\t\treturn tmp;\n\t}\n\tpr operator () (pr b) {\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\ttmp[i] = A[b.A[i]];\n\t\treturn tmp;\n\t}\n\tpr pow(int x) {\n\t\tstatic bool vis[MAXN];\n\t\tstatic int li[MAXN], bak;\n\t\tmemset(vis, 0, n + 1);\n\t\tfor (int i = 1; i <= n; ++i) if (!vis[i]) {\n\t\t\tbak = 0;\n\t\t\tint now = i;\n\t\t\twhile (!vis[now]) {\n\t\t\t\tvis[now] = true;\n\t\t\t\tli[bak++] = now;\n\t\t\t\tnow = A[now];\n\t\t\t}\n\t\t\tint sx = x % bak;\n\t\t\tfor (int j = 0; j < bak; ++j)\n\t\t\t\ttmp[li[j]] = li[(j + sx) % bak];\n\t\t}\n\t\treturn tmp;\n\t}\n} f[7];\nint main() {\n\tstd::cin >> n >> K;\n\tfor (int i = 1; i <= n; ++i) std::cin >> f[1].A[i];\n\tfor (int i = 1; i <= n; ++i) std::cin >> f[2].A[i];\n\tpr x = f[2](f[1].inv()(f[2].inv()(f[1])));\n\tfor (int i = 3; i <= 6; ++i)\n\t\tf[i] = f[i - 1](f[i - 2].inv());\n\tint tar = K % 6 + (K % 6 == 0) * 6;\n\tpr ans = x.pow((K - tar) / 6)(f[tar](x.inv().pow((K - tar) / 6)));\n\tfor (int i = 1; i <= n; ++i) std::cout << ans.A[i] << ' ';\n\tstd::cout << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 1, i##_end_ = (n); i <= i##_end_; ++i)\nusing namespace std;\ntypedef long long ll;\n\n\nstruct permutation {\n    int sz;\n    vector<int> a;\n    permutation(int N = 0): sz(N), a(N + 10) { }\n    inline void identity() {\n        for(int i = 1; i <= sz; ++i)  a[i] = i;\n    }\n    inline void show(const char * msg) {\n        printf(\"%s\", msg);\n        for(int i = 1; i <= sz; ++i) {\n            printf(\"%d\", a[i]);\n            if(i < sz) putchar(' ');\n        }\n    }\n    int& operator [] (int idx) { return a[idx]; }\n    permutation operator * (permutation rhs) {\n        permutation res(sz);\n        for(int i = 1; i <= sz; ++i)\n            res[i] = a[rhs[i]];\n        return res;\n    }\n    bool check() {\n        vector<int> _vis(sz + 3, 0);\n        rep(i, sz) _vis[a[i]] = true;\n        rep(i, sz) if(!_vis[i]) { puts(\"NO!NOT A PERMUTATION!\"); return false; }\n        return true;\n    }\n    ll decomp() {\n        vector<int> _vis(sz + 3, 0);\n        ll ans = -1;\n        for(int i = 1; i <= sz; ++i) if(!_vis[i]) {\n            ll len = 0, c = i;\n            while(!_vis[c]) {\n                _vis[c] = true;\n                len++;\n                c = a[c];\n            }\n            if(ans == -1) ans = len;\n            else ans = ans * (len / __gcd(ans, len));\n        }\n        return ans;\n    }\n    permutation inverse() {\n        permutation rev(sz);\n        rep(i, sz) rev[a[i]] = i;\n        return rev;\n    }\n};\n\npermutation qpow(permutation p, int y) {\n    permutation t(p.sz);\n    t.identity();\n    for(; y; y >>= 1, p = p * p)\n        if(y & 1) t = t * p;\n    return t;\n}\n\nint n, k;\nint main() {\n    scanf(\"%d%d\", &n, &k);\n    int period = (k - 1) / 6, left = k - 6 * period;\n    permutation p(n), q(n), pi(n), qi(n), res(n), A(n), B(n), qpqp(n);\n    rep(i, n) scanf(\"%d\", &p[i]);\n    rep(i, n) scanf(\"%d\", &q[i]);\n    pi = p.inverse();\n    qi = q.inverse();\n    qpqp = q * pi * qi * p;\n    res.identity();\n\n    A = qpow(qpqp, period);\n    switch(left) {\n        case 1: B = p; break;\n        case 2: B = q; break;\n        case 3: B = q * pi; break;\n        case 4: B = q * pi * qi; break;\n        case 5: B = q * pi * qi * p * qi; break;\n        case 6: B = q * pi * qi * p * p * qi; break;\n    }\n    \n    res = A * B * A.inverse();\n    res.show(\"\");\n    putchar('\\n');\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\nnamespace PermutationSpace{\n\tconst int PermutationLen=100000;\n\tstruct Permutation{\n\t\tint P[PermutationLen+1];\n\t\tPermutation(){for (int i=0;i<=PermutationLen;i++) P[i]=i;}\n\t\tinline int & operator [] (const int &index){return P[index];}\n\t};\n\tPermutation operator * (Permutation A,Permutation B){\n\t\tPermutation C;\n\t\tfor (int i=1;i<=PermutationLen;i++) C[i]=A[B[i]];\n\t\treturn C;\n\t}\n\n\tPermutation Inv(Permutation C){\n\t\tPermutation D;\n\t\tfor (int i=1;i<=PermutationLen;i++) D[C[i]]=i;\n\t\treturn D;\n\t}\n\tPermutation Pow(Permutation D,int p){\n\t\tbool vis[PermutationLen+1];\n\t\tint stk[PermutationLen],top;\n\t\tPermutation E;\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor (int i=1;i<=PermutationLen;i++){\n\t\t\tif (vis[i]) continue;\n\t\t\ttop=0;\n\t\t\tfor (int now=i;!vis[now];now=D[now])\n\t\t\t\tstk[top++]=now,vis[now]=true;\n\t\t\tfor (int j=0;j<top;j++) E[stk[j]]=stk[(j+p)%top];\n\t\t}\n\t\treturn E;\n\t}\n}\n\nusing namespace PermutationSpace;\n\nPermutation A[6],G;\n\nint n,m;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&A[1][i]);\n\tfor (int j=1;j<=n;j++) scanf(\"%d\",&A[2][j]);\n\tA[0]=Inv(A[2])*A[1];\n\tA[3]=A[2]*Inv(A[1]);\n\tA[4]=A[3]*Inv(A[2]);\n\tA[5]=A[4]*Inv(A[3]);\n\tG=A[2]*Inv(A[1])*Inv(A[2])*A[1];\n\tG=Pow(G,m/6)*A[m%6]*Pow(Inv(G),m/6);\n\tfor (int i=1;i<=n;i++) printf(\"%d \",G[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nvector<int> P,Q,PR,QR;\n\nvector<int> rev(vector<int> A) {\n\tvector<int> R(N);\n\tint i;\n\tFOR(i,N) R[A[i]]=i;\n\treturn R;\n}\nvector<int> conv(vector<int> A,vector<int> B) { \n\tvector<int> R(N);\n\tint i;\n\tFOR(i,N) R[i]=A[B[i]];\n\treturn R;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K;\n\tP.resize(N);\n\tQ.resize(N);\n\tFOR(i,N) cin>>P[i];\n\tFOR(i,N) cin>>Q[i];\n\tFOR(i,N) P[i]--,Q[i]--;\n\t\n\tPR=rev(P);\n\tQR=rev(Q);\n\tK--;\n\tauto A=conv(conv(conv(Q,PR),QR),P);\n\tvector<int> E,B;\n\tFOR(i,N) E.push_back(i);\n\tB=E;\n\tFOR(i,30) {\n\t\tif((K/6)&(1<<i)) E=conv(E,A);\n\t\tA=conv(A,A);\n\t}\n\t\n\tK%=6;\n\tA=E;\n\tif(K>=3) {\n\t\tA=conv(A,Q);\n\t\tif(K>=4) A=conv(A,PR);\n\t}\n\t\n\tauto AR=rev(A);\n\t\n\tif(K==0) B=P;\n\tif(K==1) B=Q;\n\tif(K==2) B=conv(Q,PR);\n\tif(K==3) B=PR;\n\tif(K==4) B=QR;\n\tif(K==5) B=conv(QR,P);\n\t\n\tauto C=conv(conv(A,B),AR);\n\tFORR(c,C) cout<<c+1<<\" \";\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/STACK:256000000\")\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<queue>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<ctime>\n#include<cstdio>\n#include<cassert>\n#include<functional>\n\n\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<char, char> pcc;\ntypedef pair<double, double> pdd;\n\n#define show(x) cerr << x\n#define debug(x) show(#x << \": \" << (x) << endl)\n\nconst long double PI = 3.14159265358979323846;\nconst long double eps = 1e-5;\nconst int INF = numeric_limits<int>::max();\nconst ll LINF = numeric_limits<ll>::max();\nconst ll mod = 1000 * 1000 * 1000 + 7;\n\n\nvector<int> inv(const vector<int>& a) {\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i)\n        res[a[i]] = i;\n    return res;\n}\n\n\nvector<int> mult(const vector<int>& a, const vector<int>& b) {\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[i] = a[b[i]];\n    }\n    return res;\n}\n\nvector<int> power(vector<int> a, int n) {\n    int sz = a.size();\n    vector<int> res(sz);\n    for (int i = 0; i < sz; ++i)\n        res[i] = i;\n    while (n) {\n        if (n & 1)\n            res = mult(res, a);\n        a = mult(a, a);\n        n /= 2;\n    }\n    return res;\n}\n\n\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> p(n), q(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        --p[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> q[i];\n        --q[i];\n    }\n    int tr = 20;\n    if (k < tr) {\n        vector<vector<int> > res(k + 5);\n        res[0] = p;\n        res[1] = q;\n        for (int i = 2; i < k; ++i)\n            res[i] = mult(res[i - 1], inv(res[i - 2]));\n        for (int i = 0; i < n; ++i) {\n            cout << res[k - 1][i] + 1 << \" \";\n        }\n        cout << endl;\n        return;\n    }\n    int x = (k + 1) / 6;\n    int r = (k + 1) % 6;\n    vector<int> p1 = mult(mult(q, inv(p)), mult(inv(q), p));\n    vector<int> p2 = mult(mult(inv(p), q), mult(p, inv(q)));\n    p1 = power(p1, x);\n    int y = x - 1;\n    if (r >= 3)\n        ++y;\n    p2 = power(p2, y);\n    vector<int> p3;\n    if (r == 0) {\n        p3 = inv(q);\n    }\n    if (r == 1) {\n        p3 = mult(p, inv(q));\n    }\n    if (r == 2) {\n        p3 = mult(q, mult(p, inv(q)));\n    }\n    if (r == 3) {\n        p3 = q;\n    }\n    if (r == 4) {\n        p3 = mult(q, inv(p));\n    }\n    if (r == 5) {\n        p3 = mult(mult(q, inv(p)), inv(q));\n    }\n    vector<int> res = mult(p1, mult(p3, p2));\n    for (int i = 0; i < res.size(); ++i)\n        cout << res[i] + 1 << \" \";\n    cout << endl;\n\n    \n    \n\n\n\n\n}\n\n//#define LOCAL\n\nint main() {\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);cout.tie(nullptr);\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    solve();\n\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nconst int MAXN = -1;\nint N;\n\nvector<int> mul(const vector<int>& A, const vector<int>& B) {\n    vector<int> C(N+1);\n    for (int i = 1; i <= N; i++) C[i] = A[B[i]];\n    return C;\n}\n\nvector<int> fast_pow(const vector<int>& A, int e) {\n    if (e == 0) {\n        vector<int> res(N+1);\n        for (int i = 1; i <= N; i++) res[i] = i;\n        return res;\n    }\n    if (e%2 == 0) return fast_pow(mul(A, A), e/2);\n    return mul(A, fast_pow(mul(A, A), e/2));\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    // vector<string> vec = {\"A\", \"X\"};\n    // for (int i = 0; i < 50; i++) {\n    //     string s = vec[i+1];\n    //     string t = vec[i];\n    //     reverse(t.begin(), t.end());\n    //     int it = 0;\n    //     for (char c : t) {\n    //         if (c != s.back()) break;\n    //         it++;\n    //         s.pop_back();\n    //     }\n    //     for (int j = it; j < SZ(t); j++) {\n    //         if (t[j] == 'A') s += 'B';\n    //         if (t[j] == 'B') s += 'A';\n    //         if (t[j] == 'X') s += 'Y';\n    //         if (t[j] == 'Y') s += 'X';\n    //     }\n    //     vec.push_back(s);\n    //     cout << i << \": \" << SZ(s) << \" \" << s << endl;\n    // }\n\n    cin >> N;\n    int K;\n    cin >> K;\n    vector<int> A(N+1), X(N+1), B(N+1), Y(N+1);\n    for (int i = 1; i <= N; i++) {\n        cin >> A[i];\n        B[A[i]] = i;\n    }\n    for (int i = 1; i <= N; i++) {\n        cin >> X[i];\n        Y[X[i]] = i;\n    }\n    if (K == 1) {\n        for (int i = 1; i <= N; i++) cout << A[i] << \" \";\n        return 0;\n    }\n    if (K == 2) {\n        for (int i = 1; i <= N; i++) cout << X[i] << \" \";\n        return 0;\n    }\n    vector<int> bef = mul(mul(X, B), mul(Y, A));\n    vector<int> aft = mul(mul(B, X), mul(A, Y));\n\n    K -= 3;\n    int c = K % 6;\n    K /= 6;\n    int kb = K, ka = K;\n    vector<int> mid;\n    if (c == 0) mid = mul(X, B);\n    if (c == 1) mid = mul(mul(X, B), Y);\n    if (c == 2) mid = Y;\n    if (c == 3) mid = mul(A, Y);\n    if (c == 4) mid = mul(mul(X, A), Y);\n    if (c == 5) mid = X;\n\n    if (c >= 2) kb++;\n    if (c >= 5) ka++;\n\n    // dbg(bef, kb, aft, ka);\n    bef = fast_pow(bef, kb);\n    aft = fast_pow(aft, ka);\n\n    // return 0;\n    vector<int> res = mul(mul(bef, mid), aft);\n    for (int i = 1; i <= N; i++) cout << res[i] << \" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "読んだ"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nnamespace ProjectPermy\n{\n\tstruct perm\n\t{\n\t\tvector<int>v;\n\t\tint &operator[](int x){return v[x];}\n\t\tconst int &operator[](int x)const{return v[x];}\n\t\tint size()const{return v.size()-1;}\n\t\tvoid resize(int n){v.resize(n+1);}\n\t\tvoid read(int n){v.resize(n+1);for(int i=1;i<=size();i++)scanf(\"%d\",&v[i]);}\n\t\tvoid out()\n\t\t{\n\t\t\tfor(int i=1;i<=size();i++)\n\t\t\t\tprintf(\"%d \",v[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t};\n\tperm e(int n)\n\t{\n\t\tperm ans;\n\t\tans.resize(n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans[i]=i;\n\t\treturn ans;\n\t}\n\tperm operator*(perm a,perm b)\n\t{\n\t\tperm ans=e(a.size());\n\t\tperm rev=e(a.size());\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t\tans[i]=a[b[i]];\n\t\treturn ans;\n\t}\n\tperm operator~(perm a)\n\t{\n\t\tperm ans=e(a.size());\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t\tans[a[i]]=i;\n\t\treturn ans;\n\t}\n\tvoid find_cycle(perm a,int x,vector<int>vis,vector<int>&rem)\n\t{\n\t\tif(vis[x]) return;\n\t\tvis[x]=1;\n\t\trem.push_back(x);\n\t\tfind_cycle(a,a[x],vis,rem);\n\t}\n\tperm Pow(perm a,int x)\n\t{\n\t\tperm ans=e(a.size());\n\t\tvector<vector<int> >cycle;\n\t\tvector<int>vis;\n\t\tvis.resize(a.size()+1);\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t{\n\t\t\tif(!vis[i])\n\t\t\t{\n\t\t\t\tvector<int> rem;\n\t\t\t\tfind_cycle(a,i,vis,rem);\n\t\t\t\tcycle.push_back(rem);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<cycle.size();i++)\n\t\t{\n\t\t\tfor(int j=0;j<cycle[i].size();j++)\n\t\t\t\tans[cycle[i][j]]=cycle[i][(j+x)%cycle[i].size()];\n\t\t}\n\t\treturn ans;\n\t}\n}\nusing namespace ProjectPermy;\nsigned main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tperm p,q;\n\tp.read(n);\n\tq.read(n);\n\tperm a[7];\n\ta[1]=p;\n\ta[2]=q;\n\tfor(int i=3;i<=6;i++)\n\t\ta[i]=a[i-1]*(~a[i-2]);\n\tif(m<=6)\n\t{\n\t\ta[m].out();\n\t\treturn 0;\n\t}\n\tperm g=q*(~p)*(~q)*p;\n\t(Pow(g,(m-1)/6)*a[(m-1)%6+1]*Pow(~g,(m-1)/6)).out();\n\treturn 0;\n}\n/*\n5\n2 4 3 1 5\n2 4 3 1 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvi inverse(vi p)\n{\n\tint n=p.size();\n\tvi q(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tq[p[i]]=i;\n\t}\n\treturn q;\n}\n\nvi f(vi a, vi b)\n{\n\tint n=a.size();\n\tvi p(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tp[i]=a[b[i]];\n\t}\n\treturn p;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tint k; cin>>k;\n\tvi p,q;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x; cin>>x; x--; p.pb(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x; cin>>x; x--; q.pb(x);\n\t}\n\tvi ip = inverse(p);\n\tvi iq = inverse(q);\n\tvi A = f(q, f(ip, f(iq, p)));\n\tvi iA = inverse(A);\n\tll pp = (k-1)/6;\n\tvi r;\n\tvi ir;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tr.pb(i); ir.pb(i);\n\t}\n\twhile(pp)\n\t{\n\t\tif(pp&1) r=f(r,A);\n\t\tA=f(A,A);\n\t\tpp>>=1;\n\t}\n\tpp=(k-1)/6;\n\twhile(pp)\n\t{\n\t\tif(pp&1) ir=f(ir,iA);\n\t\tiA=f(iA,iA);\n\t\tpp>>=1;\n\t}\n\tvi C[6];\n\tC[0]=p;\n\tC[1]=q;\n\tfor(int i=2;i<6;i++)\n\t{\n\t\tC[i]=f(C[i-1],inverse(C[i-2]));\n\t}\n\tr=f(r,C[(k-1)%6]);\n\tr=f(r,ir);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcout<<r[i]+1;\n\t\tif(i+1<n) cout<<' ';\n\t}\n\tcout<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 1000700\nint n,k,ct,p[N],q[N],rp[N],rq[N],s[N],rs[N],vis[N],st[N],as[N],s1[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&q[i]);\n\tif(k==1){for(int i=1;i<=n;i++)printf(\"%d \",p[i]);return 0;}\n\tif(k<=6)\n\t{\n\t\tfor(int i=3;i<=k;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)s[p[j]]=q[j],p[j]=q[j];\n\t\t\tfor(int j=1;j<=n;j++)q[j]=s[j];\n\t\t}\n\t\tfor(int i=1;i<=n;i++)printf(\"%d \",q[i]);return 0;\n\t}\n\tfor(int i=1;i<=n;i++)rp[p[i]]=i,rq[q[i]]=i;\n\tfor(int i=1;i<=n;i++)s1[i]=rp[q[p[rq[i]]]];\n\tfor(int i=3;i<=(k-1)%6+7;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)s[p[j]]=q[j],p[j]=q[j];\n\t\tfor(int j=1;j<=n;j++)q[j]=s[j];\n\t}\n\tfor(int i=1;i<=n;i++)if(!vis[i])\n\t{\n\t\tct=0;st[ct=1]=i;vis[i]=1;\n\t\tfor(int j=s1[i];j!=i;j=s1[j])st[++ct]=j,vis[j]=1;\n\t\tfor(int j=1;j<=ct;j++)as[st[j]]=st[(j-2+(k-1)/6)%ct+1];\n\t}\n\tfor(int i=1;i<=n;i++)rs[as[i]]=i;\n\tfor(int i=1;i<=n;i++)printf(\"%d \",rs[q[as[i]]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define vi vector<int>\nint n,k;\nvi a[7];\nint read()\n{\n\tchar c=getchar();\n\tint res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nvi inv(vi a)\n{\n\tvi b;b.resize(n);\n\tfor(int i=0;i<n;i++) b[a[i]]=i;\n\treturn b;\n}\nvi mul(vi a,vi b)\n{\n\tvi c;c.resize(n);\n\tfor(int i=0;i<n;i++) c[i]=a[b[i]];\n\treturn c;\n}\nvi ksm(vi x,int mi)\n{\n\tvi ans;ans.resize(n);\n\tfor(int i=0;i<n;i++) ans[i]=i;\n\twhile(mi)\n\t{\n\t\tif(mi&1) ans=mul(ans,x);\n\t\tx=mul(x,x);\n\t\tmi>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\ta[1].resize(n);for(int i=0;i<n;i++) a[1][i]=read(),a[1][i]--;\n\ta[2].resize(n);for(int i=0;i<n;i++) a[2][i]=read(),a[2][i]--;\n\tfor(int i=3;i<=6;i++) a[i]=mul(a[i-1],inv(a[i-2]));\n\tif(k<=6)\n\t{\n\t\tfor(int i=0;i<n;i++) printf(\"%d \",a[k][i]+1);\n\t\treturn 0;\n\t}\n\tvi A=mul(mul(a[2],inv(a[1])),mul(inv(a[2]),a[1]));\n\tA=ksm(A,(k-1)/6);\n\tA=mul(mul(A,a[(k-1)%6+1]),inv(A));\n\tfor(int i=0;i<n;i++) printf(\"%d \",A[i]+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long double ldb ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 3e3 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int mod = 1e9 + 7 ;\nconst db eps = 1e-10 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nint n, k;\n\nstruct permutations\n{\n\tint pos[maxn];\n\tpermutations(){rep(i, 1, n) pos[i] = i;}\n\tfriend permutations operator * (permutations p, permutations q)\n\t{\n\t\tpermutations ret;\n\t\trep(i, 1, n) ret.pos[i] = p.pos[q.pos[i]];\n\t\treturn ret;\n\t}\n\tpermutations operator *= (permutations b)\n\t{\n\t\treturn *this = *this * b;\n\t}\n};\n\npermutations a, b, mul, ans;\n\npermutations inv(permutations a)\n{\n\tpermutations ret;\n\trep(i, 1, n) ret.pos[a.pos[i]] = i;\n\treturn ret;\n}\n\npermutations power(permutations a, ll b)\n{\n\tpermutations ret;\n\tfor (; b; b >>= 1, a *= a) if(b & 1) ret *= a;\n\treturn ret;\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &k);\n\trep(i, 1, n) scanf(\"%d\", &a.pos[i]);\n\trep(i, 1, n) scanf(\"%d\", &b.pos[i]);\n\tmul = power(b * inv(a) * inv(b) * a, (k - 1) / 6);\n\tk = (k - 1) % 6 + 1;\n\tif(k == 1) ans = mul * a * inv(mul);\n\telse if(k == 2) ans = mul * b * inv(mul);\n\telse if(k == 3) ans = mul * b * inv(a) * inv(mul);\n\telse if(k == 4) ans = mul * b * inv(a) * inv(b) * inv(mul);\n\telse if(k == 5) ans = mul * b * inv(a) * inv(b) * a * inv(b);\n\telse ans = mul * b * inv(a) * inv(b) * a * a * inv(b) * inv(mul);\n\trep(i, 1, n) printf(\"%d%c\", ans.pos[i], \" \\n\"[i == n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * There is a start and there is no end in the space. ---Infinity.\n * It ruins and goes though there is also a start in stars. ---Finite.\n * Only the man who has wisdom can read the most foolish one from the history.\n * Fishes living in the sea doesn't know the life in the land.\n * It also ruins and goes if they have wisdom.\n * It funnier that man exceeds the speed of light than fish start living in the land.\n * It can be said that this is an final ultimatum from the god to the people who can fight.\n *\n * Steins;Gate\n */\n\n#include <bits/stdc++.h>\n\nconst int N = 100010;\n\nint a[N], b[N], c[N], d[N], A[N], n, k, vis[N], B[N], dis[N], C[N], D[N];\nint t1[2][N], t2[2][N], t3[2][N], ans[7][N];\nstd::vector<int> v[N];\n\ninline int Find(int x, int t) {\n    int loop = v[vis[x]].size() - 1;\n    t = (t + dis[x]) % loop;\n    return v[vis[x]][t];\n}\n\nint main() {\n\n    scanf(\"%d%d\", &n, &k);\n    k--;\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &b[i]);\n\n    /// get A  c = b-1  d = a-1\n    for(int i = 1; i <= n; i++) {\n        c[b[i]] = i;\n        d[a[i]] = i;\n    }\n    /*for(int i = 1; i <= n; i++) {\n        printf(\"%d \", c[i]);\n    }\n    puts(\"\");\n    for(int i = 1; i <= n; i++) {\n        printf(\"%d \", d[i]);\n    }\n    puts(\"\");*/\n    for(int i = 1; i <= n; i++) {\n        A[i] = b[d[c[ a[i] ]]];\n    }\n    int t = k / 6;\n    //printf(\"t = %d \\n\", t);\n    /// get B = A^t\n    for(int i = 1; i <= n; i++) {\n        if(vis[i]) continue;\n        /// !vis[i]\n        int j = i;\n        v[i].push_back(i);\n        do {\n            j = A[j];\n            dis[j] = v[i].size();\n            vis[j] = i;\n            v[i].push_back(j);\n        } while(j != i);\n        dis[i] = 0;\n    }\n    for(int i = 1; i <= n; i++) {\n        B[i] = t ? Find(i, t) : i;\n    }\n\n    /*printf(\"vis : \\n\");\n    for(int i = 1; i <= n; i++) {\n        printf(\"%d \", vis[i]);\n    }\n    puts(\"\");\n\n    printf(\"A : \\n\");\n    for(int i = 1; i <= n; i++) {\n        printf(\"%d \", A[i]);\n    }\n    puts(\"\");*/\n\n    memcpy(t1[0] + 1, B + 1, n * sizeof(int));\n    memcpy(t1[1] + 1, B + 1, n * sizeof(int));\n    memcpy(t2[0] + 1, a + 1, n * sizeof(int));\n    memcpy(t2[1] + 1, b + 1, n * sizeof(int));\n    for(int i = 1; i <= n; i++) {\n        t3[0][t1[0][i]] = i;\n        t3[1][t1[1][i]] = i;\n    }\n\n    for(int i = 1; i <= n; i++) {\n        ans[0][i] = t1[0][t2[0][t3[0][i]]];\n        ans[1][i] = t1[1][t2[1][t3[1][i]]];\n    }\n    t = k % 6;\n    //printf(\"t = %d \\n\", t);\n    for(int i = 2; i <= t; i++) {\n        for(int j = 1; j <= n; j++) {\n            ans[i][ans[i - 2][j]] = ans[i - 1][j];\n        }\n    }\n\n    /*puts(\"\");\n    for(int i = 0; i <= 1; i++) {\n        for(int j = 1; j <= n; j++) {\n            printf(\"%d \", ans[i][j]);\n        }\n        puts(\"\");\n    }\n    puts(\"\");*/\n\n    for(int i = 1; i <= n; i++) {\n        printf(\"%d \", ans[t][i]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n//#define cerr if(false) cerr\n#define show(...) cerr << #__VA_ARGS__ << \" = \",debug(__VA_ARGS__);\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate<typename T, typename S>\nostream &operator<<(ostream &os,pair<T,S>a){\n    os << '(' << a.first << ',' << a.second << ')';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, vector<T> v){\n    for(auto x:v)os << x << ' ';\n    return os;\n}\nvoid debug(){cerr << '\\n';}\ntemplate<typename H, typename... T>\nvoid debug(H a, T... b){\n    cerr << a;\n    if(sizeof...(b))cerr << \", \";\n    debug(b...);\n}\n\n//char inv(char c){\n//    return c^32;\n//}\n//string inv(string &a){\n//    auto res = a;\n//    for(auto &x:res) x^=32;\n//    reverse(res.begin(),res.end());\n//    return res;\n//}\n//string product(const string &a,const string &b){\n//    auto res = a;\n//    for(auto x:b){\n//        if(res.size() and inv(x) == res.back())res.erase(res.begin()+res.size()-1);\n//        else res.push_back(x);\n//    }\n//    return res;\n//    \n//}\n\nvector<int> id(const int n){\n    vector<int> res(n);\n    rep(i,n)res[i] = i;\n    return res;\n}\nvector<int> inv(const vector<int> &a){\n    vector<int> res(a.size());\n    rep(i,a.size()){\n        res[a[i]] = i;\n    }\n    return res;\n}\nvector<int> product(const vector<int> &a, const vector<int> &b){\n    vector<int> res(a.size());\n    rep(i,a.size()){\n        res[i] = a[b[i]];\n    }\n    return res;\n}\nvector<int> power(const vector<int> &a, ll p){\n    if(p == 0)return id((int)a.size());\n    auto res = a;\n    auto temp = a;\n    p--;\n    for(int i = 0; i < 60; i++){\n        if(p >> i & 1){\n            res = product(res, temp);\n        }\n        temp = product(temp, temp);\n    }\n    return res;\n}\nint main(){\n    int n;\n    cin >> n;\n    int k;\n    cin >> k;\n    vector<int>p(n),q(n);\n    rep(i,n)cin >> p[i],p[i]--;\n    rep(i,n)cin >> q[i],q[i]--;\n    auto g = product(q,product(inv(p),product(inv(q),p)));\n    g = power(g,(k-1)/6);\n    auto a = product(g,product(p,inv(g)));\n    auto b = product(g,product(q,inv(g)));\n    int now = 1 + (k-1)/6*6;\n    while(now != k){\n        auto c = product(b,inv(a));\n        a = b;\n        b = c;\n        now++;\n    }\n    rep(i,n)cout << a[i] + 1 << \" \\n\"[i==n-1];\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nstd::vector<int> a[100005];\nint n,k,cnt,used[100005];\nint ans[100005],p[100005],pp[100005],q[100005],qq[100005],g[100005],gg[100005],gk[100005],ggk[100005],f[10][100005],ff[10][10005];\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&q[i]);\n\tfor (int i=1;i<=n;i++) f[0][i]=i;\n\tfor (int i=1;i<=n;i++) ff[0][i]=i;\n\tfor (int i=1;i<=n;i++) f[1][i]=p[i];\n\tfor (int i=1;i<=n;i++) f[2][i]=q[i];\n\tfor (int i=1;i<=n;i++) ff[1][f[1][i]]=i;\n\tfor (int i=1;i<=n;i++) ff[2][f[2][i]]=i;\n\tfor (int r=3;r<=5;r++)\n\t{\n\t\tfor (int i=1;i<=n;i++) f[r][i]=f[r-1][ff[r-2][i]];\n\t\tfor (int i=1;i<=n;i++) ff[r][f[r][i]]=i;\n\t}\n\tfor (int i=1;i<=n;i++) pp[p[i]]=i;\n\tfor (int i=1;i<=n;i++) qq[q[i]]=i;\n\tfor (int i=1;i<=n;i++) g[i]=q[pp[qq[p[i]]]];\n\tfor (int i=1;i<=n;i++) gg[g[i]]=i;\n\tfor (int i=1;i<=n;i++)\n\t    if (!used[i])\n\t    {\n\t\t\tint x=++cnt;\n\t\t\tused[i]=1;\n\t\t\ta[x].push_back(i);\n\t    \tfor (int j=g[i];!used[j];j=g[j])\n\t    \t{\n\t    \t\ta[x].push_back(j);\n\t    \t\tused[j]=1;\n\t\t\t}\n\t    }\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tint sz=a[i].size();\n\t\tfor (int j=0;j<a[i].size();j++)\n\t\t{\n\t\t\tint x=a[i][j],y=a[i][(j+k/6)%sz];\n\t\t\tgk[x]=y;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) used[i]=0;\n\tfor (int i=1;i<=cnt;i++) a[i].clear();cnt=0;\n\tfor (int i=1;i<=n;i++)\n\t    if (!used[i])\n\t    {\n\t\t\tint x=++cnt;\n\t\t\tused[i]=1;\n\t\t\ta[x].push_back(i);\n\t    \tfor (int j=gg[i];!used[j];j=gg[j])\n\t    \t{\n\t    \t\ta[x].push_back(j);\n\t    \t\tused[j]=1;\n\t\t\t}\n\t    }\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tint sz=a[i].size();\n\t\tfor (int j=0;j<a[i].size();j++)\n\t\t{\n\t\t\tint x=a[i][j],y=a[i][(j+k/6)%sz];\n\t\t\tggk[x]=y;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) used[i]=0;\n\tfor (int i=1;i<=cnt;i++) a[i].clear();cnt=0;\n\tfor (int i=1;i<=n;i++) ans[i]=gk[f[k%6][ggk[i]]];\n\tfor (int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define maxn 100005\nint n,m;\nstruct per\n{\n\tint a[maxn];\n\tper(){ memset(a,0,sizeof(a)); }\n}p,q;\nper operator * (per a,per b)\n{\n\tper c;\n\tfor(int i=1;i<=n;i++) c.a[i]=a.a[b.a[i]];\n\treturn c;\n}\nper operator ^ (per a,int k)\n{\n\tper res;\n\tfor(int i=1;i<=n;i++) res.a[i]=i;\n\twhile(k)\n\t{\n\t\tif(k&1) res=res*a;\n\t\ta=a*a;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\nper inv(per a)\n{\n\tper b;\n\tfor(int i=1;i<=n;i++) b.a[a.a[i]]=i;\n\treturn b;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&p.a[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&q.a[i]);\n\tint x=(m-1)/6,y=m%6;\n\tper ip=inv(p),iq=inv(q),h=q*ip*iq*p,A=h^x,B;\n\tif(y==1) B=p;\n\telse if(y==2) B=q;\n\telse if(y==3) B=q*ip;\n\telse if(y==4) A=A*q,B=ip;\n\telse if(y==5) A=A*q*ip,B=iq;\n\telse A=A*q*ip,B=iq*p;\n\tper ans=A*B*inv(A);\n\tfor(int i=1;i<=n;i++) printf(\"%d \",ans.a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x = 0 , f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nint n , k;\ntypedef vector<int> vi;\nvi a[6];\nvi A;\ninline vi inv(const vi &p)\n{\n\tvi q(n);\n\tfor(int i = 0;i < n;i ++) q[p[i]] = i;\n\treturn q;\n}\ninline vi mul(const vi &p,const vi &q)\n{\n\tvi r(n);\n\tfor(int i = 0;i < n;i ++) r[i] = p[q[i]];\n\treturn r;\n}\ninline vi ksm(vi a,ll b)\n{\n\tvi res(n);\n\tfor(int i = 0;i < n;i ++) res[i] = i;\n\twhile(b)\n\t{\n\t\tif(b & 1) res = mul(res,a);\n\t\ta = mul(a,a); b >>= 1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tn = read(); k = read() - 1;\n\ta[0].resize(n); for(int i = 0;i < n;i ++) a[0][i] = read() - 1;\n\ta[1].resize(n); for(int i = 0;i < n;i ++) a[1][i] = read() - 1;\n\tfor(int i = 2;i < 6;i ++) a[i] = mul(a[i - 1],inv(a[i - 2]));\n\tif(k < 6)\n\t{\n\t\tfor(int i = 0;i < n;i ++) printf(\"%d \",a[k][i] + 1); \n\t\treturn puts(\"\") , 0;\n\t}\n\tA = ksm(mul(mul(a[1],inv(a[0])),mul(inv(a[1]),a[0])),k / 6);\n\tA = mul(mul(A,a[k % 6]),inv(A));\n\tfor(int i = 0;i < n;i ++) printf(\"%d \",A[i] + 1);\n\treturn puts(\"\") , 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int a[N];}a[2],p,q,an;\nint n,k;\nInfo ni(Info x){\n\tInfo y;\n\tfor (int i=1;i<=n;i++) y.a[x.a[i]]=i;\n\treturn y;\n}\nInfo work(Info x,Info y){\n\tInfo z;\n\tfor (int i=1;i<=n;i++) z.a[i]=x.a[y.a[i]];\n\treturn z;\n}\nInfo get(Info x,int y){\n\tInfo z;\n\tbool vi[N];int a[N],na;\n\tfor (int i=1;i<=n;i++) vi[i]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tif (vi[i]){\n\t\t\tna=0;\n\t\t\tfor (int j=i;vi[j];j=x.a[j]){a[na++]=j;vi[j]=0;}\n\t\t\tfor (int i=0;i<na;i++)z.a[a[i]]=a[(i+y)%na];\n\t\t}\n\t}\n\treturn z;\n}\nint main(){\n\tread(n);read(k);\n\tfor (int i=1;i<=n;i++) read(a[0].a[i]);\n\tfor (int i=1;i<=n;i++) read(a[1].a[i]);\n\tif (k%6==1)q=a[0];\n\tif (k%6==2)q=a[1];\n\tif (k%6==3)q=work(a[1],ni(a[0]));\n\tif (k%6==4)q=ni(a[0]);\n\tif (k%6==5)q=ni(a[1]);\n\tif (k%6==0)q=work(ni(a[1]),a[0]);\n\tp=a[1];p=work(p,ni(a[0]));\n\tp=work(p,ni(a[1]));p=work(p,a[0]);\n\tp=get(p,(k-1)/6);\n\tif (k%6>=4||k%6==0)p=work(p,a[1]);\n\tif (k%6==5||k%6==0)p=work(p,ni(a[0]));\n\tan=work(p,q);an=work(an,ni(p));\n\tfor (int i=1;i<=n;i++) cout<<an.a[i]<<' ';cout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100100;\nint a[N],b[N],c[N],d[N],e[N],f[N],g[N],n,K;\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>K;\n\tfor(int i=1;i<=n;++i)cin>>a[i],c[a[i]]=i;\n\tfor(int i=1;i<=n;++i)cin>>b[i],d[b[i]]=i;\n\tfor(int i=1;i<=n;++i)e[i]=b[c[d[a[i]]]];\n\tint u=(K-1)%6,v=(K-1)/6;\n\twhile(u--){\n\t\tfor(int i=1;i<=n;++i)a[i]=b[c[i]];\n\t\tfor(int i=1;i<=n;++i)swap(a[i],b[i]),c[a[i]]=d[b[i]]=i;\n\t}\n\tfor(int i=1;i<=n;++i)if(!f[i]){\n\t\tint cnt=1;g[0]=i;\n\t\tfor(int j=e[i];j!=i;j=e[j])g[cnt++]=j;\n\t\tfor(int j=0;j<cnt;++j)f[g[j]]=g[(j+v)%cnt];\n\t}\n\tfor(int i=1;i<=n;++i)e[f[i]]=i;\n\tfor(int i=1;i<=n;++i)cout<<f[a[e[i]]]<<(i==n?'\\n':' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, K, P[101010], Q[101010];\nvector<string> A;\n\nstring inv(string a)\n{\n\tstring ret;\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\tret.push_back((char)(a[a.size() - 1 - i] ^ 32));\n\t}\n\treturn ret;\n}\nstring concat(string a, string b)\n{\n\treverse(b.begin(), b.end());\n\twhile (a.size() > 0 && b.size() > 0 && (a.back() ^ b.back()) == 32) {\n\t\ta.pop_back();\n\t\tb.pop_back();\n\t}\n\treverse(b.begin(), b.end());\n\treturn a + b;\n}\n\nvector<int> inv(const vector<int> &perm)\n{\n\tvector<int> ret(N, -1);\n\tfor (int i = 0; i < N; ++i) ret[perm[i]] = i;\n\treturn ret;\n}\nvector<int> app(const vector<int> &a, const vector<int> &b)\n{\n\tvector<int> ret(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tret[i] = a[b[i]];\n\t}\n\treturn ret;\n}\nvector<int> power(const vector<int> &a, int p)\n{\n\tvector<int> ret = a, pp = a;\n\t--p;\n\tfor (int i = 0; i < 30; ++i) {\n\t\tif ((p >> i) & 1) {\n\t\t\tret = app(ret, pp);\n\t\t}\n\t\tpp = app(pp, pp);\n\t}\n\treturn ret;\n}\n\nvector<vector<int>> sols;\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &K); --K;\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d\", P + i); --P[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d\", Q + i); --Q[i];\n\t}\n\n\t{\n\t\tvector<int> tmp;\n\t\tfor (int i = 0; i < N; ++i) tmp.push_back(P[i]);\n\t\tsols.push_back(tmp);\n\t}\n\t{\n\t\tvector<int> tmp;\n\t\tfor (int i = 0; i < N; ++i) tmp.push_back(Q[i]);\n\t\tsols.push_back(tmp);\n\t}\n\tfor (int i = 2; i < 12; ++i) {\n\t\tsols.push_back(app(sols[i - 1], inv(sols[i - 2])));\n\t\t//for (int j = 0; j < N; ++j) printf(\"%d \", sols[i][j]);\n\t\t//puts(\"\");\n\t}\n\t\n\tvector<int> res;\n\tif (K < 10) {\n\t\tres = sols[K];\n\t} else {\n\t\tint dec = (K - 3) / 6;\n\t\tK -= dec * 6;\n\t\tvector<int> hoge = app(app(inv(sols[0]), sols[1]), app(sols[0], inv(sols[1])));\n\t\thoge = power(hoge, dec);\n\t\tres = app(inv(hoge), app(sols[K], hoge));\n\t}\n\tfor (int i = 0; i < N; ++i) printf(\"%d%c\", res[i] + 1, i == N - 1 ? '\\n' : ' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for((i)=1;(i)<=(n);(i)++) \nusing namespace std;\nint n,m,i;\nvector<int> f[7],t;\nvector<int> mul(vector<int> a,vector<int> b){\n\tvector<int> ans;ans.resize(n+1);\n\tint i;rep(i,n) ans[i]=a[b[i]];\n\treturn ans;\n}\nvector<int> inv(vector<int> a){\n\tvector<int> ans;ans.resize(n+1);\n\tint i;rep(i,n) ans[a[i]]=i;\n\treturn ans;\n}\nvector<int> pw(vector<int> x,int y)\n{\n\tvector<int> ans;\n\tint i;rep(i,n+1) ans.push_back(i-1);\n//\treturn ans;\n\twhile(y){\n\t\tif(y&1)ans=mul(ans,x);\n\t\tx=mul(x,x);\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\nint main(){\n\tcin>>n>>m;\n\tf[1].resize(n+1);\n\tf[2].resize(n+1);\n\trep(i,n)cin>>f[1][i];\n\trep(i,n)cin>>f[2][i];\n\tfor(i=3;i<=6;i++){\n\t\tf[i]=mul(f[i-1],inv(f[i-2]));\n\t}\n\tt=mul(mul(f[2],inv(f[1])),mul(inv(f[2]),f[1]));\n//\trep(i,n)cout<<t[i]<<' ';cout<<endl;\n\tt=pw(t,(m-1)/6);\n//\trep(i,n)cout<<t[i]<<' ';cout<<endl;\n//\trep(i,n)cout<<f[(m-1)%6+1][i]<<' ';cout<<endl;\n\tt=mul(mul(t,f[(m-1)%6+1]),inv(t));\n\trep(i,n)cout<<t[i]<<' ';cout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 120000;\n\nint n;\n\nint tmp[MAXN];\n\nvoid merge(int *a, int *b, int *c) {\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = a[b[i]];\n}\n\nvoid rev(int *a, int *b) {\n\tfor (int i = 0; i < n; ++i)\n\t\tb[a[i]] = i;\n}\n\nvoid revin(int *a) {\n\trev(a, tmp);\n\tfor (int i = 0; i < n; ++i)\n\t\ta[i] = tmp[i];\n}\n\nvoid mergein(int *a, int *b) {\n\tmerge(a, b, tmp);\n\tfor (int i = 0; i < n; ++i)\n\t\ta[i] = tmp[i];\n}\n\n\nvoid init(int *a) {\n\tfor (int i = 0; i < n; ++i)\n\t\ta[i] = i;\n}\n\nint tmp2[MAXN];\n\nvoid pw(int *a, int b) {\n\tinit(tmp2);\n\twhile (b) {\n\t\twhile (!(b & 1))\n\t\t\tmergein(a, a), b >>= 1;\n\t\t--b;\n\t\tmergein(tmp2, a);\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\ta[i] = tmp2[i];\n}\n\nint a[MAXN];\nint b[MAXN];\n\nint go[MAXN];\nint ar[MAXN];\nint br[MAXN];\n\nint go2[MAXN];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tint k;\n\tcin >> n >> k;\n\t--k;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i], --a[i];\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> b[i], --b[i];\n\trev(a, ar);\n\trev(b, br);\n\tif (k == 0) {\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcout << a[i] + 1 << \" \";\n\t\tcout << \"\\n\";\n\t\treturn 0;\n\t}\n\tint c = (k - 1) / 3;\n\tinit(go);\n\tint c2 = c / 2;\n\tmergein(go, b);\n\tmergein(go, ar);\n\tmergein(go, br);\n\tmergein(go, a);\n\tpw(go, c2);\n\tif (c % 2 == 1) {\n\t\tmergein(go, b);\n\t\tmergein(go, ar);\n\t}\n\trev(go, go2);\n\tint lf = (k - 1) % 3;\n\tif (c % 2 == 0) {\n\t\tmergein(go, b);\n\t\tif (lf >= 1)\n\t\t\tmergein(go, ar);\n\t\tif (lf >= 2)\n\t\t\tmergein(go, br);\n\t}\n\telse {\n\t\tmergein(go, br);\n\t\tif (lf >= 1)\n\t\t\tmergein(go, a);\n\t\tif (lf >= 2)\n\t\t\tmergein(go, b);\n\t}\n\tmergein(go, go2);\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << go[i] + 1 << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint h[7][100010],ans[100010];\nint p[100010],q[100010],p1[100010],q1[100010],a[100010],b[100010],c[100010],d[100010],n,k;\nbool vis[100010];\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline void print(int x)\n{\n\tstatic char s[233];\n\tif (!x) { putchar('0');putchar(' ');return; }\n\tint tot=0;\n\tfor (;x;x/=10) s[++tot]=x%10+'0';\n\tfor (;tot;tot--) putchar(s[tot]);\n\tputchar(' ');\n}\n\nint main()\n{\n\tn=rd();k=rd();\n\tfor (int i=1;i<=n;i++) p[i]=rd();\n\tfor (int i=1;i<=n;i++) q[i]=rd();\n\tfor (int i=1;i<=n;i++) p1[p[i]]=i,q1[q[i]]=i;\n\tfor (int i=1;i<=n;i++) a[i]=p[i];\n\tfor (int i=1;i<=n;i++) b[i]=q1[a[i]];\n\tfor (int i=1;i<=n;i++) a[i]=b[i];\n\tfor (int i=1;i<=n;i++) b[i]=p1[a[i]];\n\tfor (int i=1;i<=n;i++) a[i]=b[i];\n\tfor (int i=1;i<=n;i++) b[i]=q[a[i]];\n\tfor (int i=1;i<=n;i++) a[i]=b[i];\n\tint hh=(k-1)/6;\n\tfor (int i=1;i<=n;i++) if (!vis[i])\n\t{\n\t\tint tt=0;\n\t\tfor (int j=i;!vis[j];j=a[j]) d[tt++]=j,vis[j]=true;\n\t\tfor (int j=0;j<tt;j++) b[d[j]]=d[(j+hh)%tt];\n\t}\n\tfor (int i=1;i<=n;i++) c[b[i]]=i;\n\tfor (int i=1;i<=n;i++) h[1][i]=p[i],h[2][i]=q[i];\n\tfor (int i=1;i<=4;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++) a[h[i][j]]=j;\n\t\tfor (int j=1;j<=n;j++) h[i+2][j]=h[i+1][a[j]];\n\t}\n\tint now=k-hh*6;\n\tfor (int i=1;i<=n;i++) ans[i]=c[i];\n\tfor (int i=1;i<=n;i++) a[i]=h[now][ans[i]];\n\tfor (int i=1;i<=n;i++) ans[i]=a[i];\n\tfor (int i=1;i<=n;i++) a[i]=b[ans[i]];\n\tfor (int i=1;i<=n;i++) ans[i]=a[i];\n\tfor (int i=1;i<=n;i++) print(ans[i]);\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-19 18:52:05\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=100010;\nint n;\nstruct arr\n{\n\tstd::vector<int> a;\n\tarr(){ a.resize(n+10); }\n\tint &operator[](int p){ return a[p]; }\n\tarr &operator=(arr b)\n\t{\n\t\tfr(i,1,n) a[i]=b[i];\n\t\treturn *this;\n\t}\n};\narr inv(arr a)\n{\n\tarr b;\n\tfr(i,1,n) b[a[i]]=i;\n\treturn b;\n}\narr operator*(arr a,arr b)\n{\n\tarr c;\n\tfr(i,1,n) c[i]=a[b[i]];\n\treturn c;\n}\narr &operator*=(arr &a,arr b){ return a=a*b; }\nint k;\narr a,b,c;\narr power(arr a,int b)\n{\n\tarr r;\n\tfr(i,1,n) r[i]=i;\n\tfor(;b;b>>=1,a*=a) if(b&1) r*=a;\n\treturn r;\n}\nint main()\n{\n\tn=read(); k=read(); a=arr(); b=arr();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n) b[i]=read();\n\tc=b*inv(a)*inv(b)*a; k--;\n\twhile(k%6){ arr d=a; a=b; b*=inv(d); k--; }\n\ta=power(c,k/6)*a*power(inv(c),k/6);\n\tfr(i,1,n) printf(\"%d%c\",a[i],i==n?'\\n':' ');\n\treturn 0;\n}\n/*\na\nb\nbA\nbAB\nbABaB\nbABaaB\nbABabaB\nbABabAbaB\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000000\n#define infll 1000000000000000000ll\n#define vi vector<int>\n#define vll vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define mpr make_pair\n#define fi first\n#define se second\n#define pq priority_queue<int>\n#define pqll priority_queue<ll>\n#define up(x,y) (x<(y)?x=(y):0)\n#define dn(x,y) (x>(y)?x=(y):0)\n#define ad(x,y) (x=(x+(y))%mod)\n#define mod 1000000007\n#define N 100009\nusing namespace std;\n\nint n,m; vi ans,f,a[9];\nvi inv(vi a){\n\tint i; vi f; f.resize(n+1);\n\tfor\t(i=1; i<=n; i++) f[a[i]]=i;\n\treturn f;\n}\nvi mrg(vi a,vi b){\n\tint i; vi c; c.resize(n+1);\n\tfor (i=1; i<=n; i++) c[i]=b[a[i]];\n\treturn c;\t\n}\nvoid opt(vi f){\n\tint i;\n\tfor (i=1; i<=n; i++) printf(\"%d%c\",f[i],i<n?' ':'\\n');\t\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint i;\n\ta[1].resize(n+1); a[2].resize(n+1);\n\tfor (i=1; i<=n; i++) scanf(\"%d\",&a[1][i]);\n\tfor (i=1; i<=n; i++) scanf(\"%d\",&a[2][i]);\n\tif (m==1) opt(a[1]);\n\tfor (i=3; i<=7; i++) a[i]=mrg(inv(a[i-2]),a[i-1]);\n\tf=mrg(mrg(inv(a[2]),a[1]),mrg(a[2],inv(a[1])));\n\tint tmp=(m-2)/6;\n\tm-=tmp*6;\n\tans.resize(n+1);\n\tfor (i=1; i<=n; i++) ans[i]=i;\n\tfor (; tmp; tmp>>=1,f=mrg(f,f)) if (tmp&1) ans=mrg(ans,f);\n\tans=mrg(mrg(ans,a[m]),inv(ans));\n\topt(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int N=1e5+10;\nint n,k,tmp[N];\nstruct Poly\n{\n\tint a[N];\n\tPoly inv()\n\t\t{\n\t\t\tPoly C;\n\t\t\tfor(int i=1;i<=n;i++) tmp[a[i]]=i;\n\t\t\tfor(int i=1;i<=n;i++) C.a[i]=tmp[i];\n\t\t\treturn C;\n\t\t}\n\tPoly operator * (Poly A)\n\t\t{\n\t\t\tPoly C;\n\t\t\tfor(int i=1;i<=n;i++) C.a[i]=a[A.a[i]];\n\t\t\treturn C;\n\t\t}\n}A,P,Q,bs[9];\nPoly ksm(Poly A,int k)\n{\n\tPoly s=bs[0];for(;k;k>>=1,A=A*A)\n\t\t\t\t\t if(k&1) s=s*A;return s;\n}\nint main()\n{\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) cin>>P.a[i];\n\tfor(int i=1;i<=n;i++) cin>>Q.a[i];\n\tA=Q*P.inv()*Q.inv()*P;\n\tfor(int i=1;i<=n;i++) bs[0].a[i]=i;\n\tbs[1]=P;bs[2]=Q;\n\tfor(int i=3;i<=6;i++) bs[i]=bs[i-1]*bs[i-2].inv();\n\n\tint u=k/6,p=k%6;if(!p) u--,p=6;\n\tPoly Ans1=ksm(A,u),Ans2=ksm(A.inv(),u);\n\tPoly Ans=Ans1*bs[p]*Ans2;\n\tfor(int i=1;i<=n;i++) cout<<Ans.a[i]<<\" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long \nconst ll mod=1e9+7;\n\nbool ismatch(vector<ll> a,vector<ll> b){\n    for(ll i=0;i<a.size();i++){\n        if(a[i]!=b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n\n    ll n,k;\n    cin>>n>>k;\n    vector<ll> p;\n    for(ll i=0;i<n;i++){\n        ll x;\n        cin>>x;\n        p.push_back(x);\n    }\n\n    vector<ll> q;\n    for(ll i=0;i<n;i++){\n        ll x;\n        cin>>x;\n        q.push_back(x);\n    }\n\n    vector<ll> v[1000];\n    v[0]=p;\n    v[1]=q;\n    ll j=2;\n    ll cnt=0;\n    while(1){\n        vector<ll> v1(n);\n        for(ll i=0;i<n;i++){\n            v1[v[j-2][i]-1]=v[j-1][i];\n        }\n        vector<ll> v2=v1;\n        v[j++]=v2;\n        cnt++;\n        if(ismatch(v[j-2],p) && ismatch(v[j-1],q)){\n            break;\n        }\n\n    }\n\n    ll ind=k%cnt;\n    if(ind==0){\n        ind=2;\n    }\n    for(ll i=0;i<n;i++){\n        cout<<v[ind-1][i]<<\" \";\n    }\n    cout<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n//#define cerr if(false) cerr\n#define show(...) cerr << #__VA_ARGS__ << \" = \",debug(__VA_ARGS__);\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate<typename T, typename S>\nostream &operator<<(ostream &os,pair<T,S>a){\n    os << '(' << a.first << ',' << a.second << ')';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, vector<T> v){\n    for(auto x:v)os << x << ' ';\n    return os;\n}\nvoid debug(){cerr << '\\n';}\ntemplate<typename H, typename... T>\nvoid debug(H a, T... b){\n    cerr << a;\n    if(sizeof...(b))cerr << \", \";\n    debug(b...);\n}\n\n//char inv(char c){\n//    return c^32;\n//}\n//string inv(string &a){\n//    auto res = a;\n//    for(auto &x:res) x^=32;\n//    reverse(res.begin(),res.end());\n//    return res;\n//}\n//string product(const string &a,const string &b){\n//    auto res = a;\n//    for(auto x:b){\n//        if(res.size() and inv(x) == res.back())res.erase(res.begin()+res.size()-1);\n//        else res.push_back(x);\n//    }\n//    return res;\n//    \n//}\n\nvector<int> id(const int n){\n    vector<int> res(n);\n    rep(i,n)res[i] = i;\n    return res;\n}\nvector<int> inv(const vector<int> &a){\n    vector<int> res(a.size());\n    rep(i,a.size()){\n        res[a[i]] = i;\n    }\n    return res;\n}\nvector<int> product(const vector<int> &a, const vector<int> &b){\n    vector<int> res(a.size());\n    rep(i,a.size()){\n        res[i] = a[b[i]];\n    }\n    return res;\n}\nvector<int> power(const vector<int> &a, ll p){\n    if(p == 0)return id((int)a.size());\n    auto res = a;\n    auto temp = a;\n    p--;\n    for(int i = 0; i < 30; i++){\n        if(p >> i & 1){\n            res = product(res, temp);\n        }\n        temp = product(temp, temp);\n    }\n    return res;\n}\nint main(){\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n    vector<int>p(n),q(n);\n    rep(i,n)scanf(\"%d\",&p[i]),p[i]--;\n    rep(i,n)scanf(\"%d\",&q[i]),q[i]--;\n    auto g = product(q,product(inv(p),product(inv(q),p)));\n    g = power(g,(k-1)/6);\n    auto a = product(g,product(p,inv(g)));\n    auto b = product(g,product(q,inv(g)));\n    int now = 1 + (k-1)/6*6;\n    while(now != k){\n        auto c = product(b,inv(a));\n        a = b;\n        b = c;\n        now++;\n    }\n    rep(i,n)printf(\"%d \",a[i]+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200010\n\nset<pair<int, int> >s;\nmap<pair<int, int>, vector<int> >m;\nint bb;\nvector<int> solve(vector<int>pp, vector<int>qq, int k, int b) {\n\tvector<int>ppp;\n\tvector<int>qqq;\n\tvector<int>re;\n\tint r[N];\n\tint cb;\n\tif (k == 1)return pp;\n\tif (k == 2)return qq;\n\tif (k == 3) {\n\t\tf(i, pp.size())r[pp[i]] = qq[i];\n\t\tf(i, pp.size())re.push_back(r[i + 1]);\n\t\treturn re;\n\t}\n\tif (s.count(make_pair(k, b)) == 1)return m[make_pair(k, b)];\n\tif (k % 2 == 1) {\n\t\tppp = solve(pp, qq, (k + 1) / 2, b);\n\t\tqqq = solve(pp, qq, (k + 3) / 2, b);\n\t\tbb++;\n\t\tcb = b;\n\t\tb = bb;\n\t\tre = solve(ppp, qqq, (k + 1) / 2, b);\n\t\ts.insert(make_pair(k, cb));\n\t\tm[make_pair(k, cb)] = re;\n\t\treturn re;\n\t}\n\telse {\n\t\tppp = solve(pp, qq, k / 2, b);\n\t\tqqq = solve(pp, qq, (k + 2) / 2, b);\n\t\tbb++;\n\t\tcb = b;\n\t\tb = bb;\n\t\tre = solve(ppp, qqq, (k + 2) / 2, b);\n\t\ts.insert(make_pair(k, cb));\n\t\tm[make_pair(k, cb)] = re;\n\t\treturn re;\n\t}\n}\n\nint main() {\n\tint n, k, x;\n\tvector<int>p;\n\tvector<int>q;\n\tscanf(\"%d %d\", &n, &k);\n  k%=n;\n\tvector<int>ans;\n\tf(i, n) {\n\t\tscanf(\"%d\", &x);\n\t\tp.push_back(x);\n\t}\n\tf(i, n) {\n\t\tscanf(\"%d\", &x);\n\t\tq.push_back(x);\n\t}\n\tbb = 0;\n\tans = solve(p, q, k, 0);\n\tf(i, n) {\n\t\tprintf(\"%d\", ans[i]);\n\t\tif (i < n - 1)printf(\" \");\n\t\telse printf(\"\\n\");\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;const int N=1e5+10;typedef long long ll;\nint S;\nstruct data\n{\n\tint a[N];\n\tdata()\n\t{\n\t//\tprintf(\"construct!\\n\");\n\t\tfor(int i=0;i<N;i++)a[i]=0;\n\t//\tprintf(\"fin cons\\n\");\n\t}\n\tinline int& operator [](const int& x){return a[x];}\n\tinline data ginv()\n\t{\n\t\tdata c;\n\t\tfor(int i=1;i<=S;i++)c[a[i]]=i;\n\t\treturn c;\n\t} \n\tfriend data operator *(data a,data b)\n\t{\n\t\tdata c;\n\t\tfor(int i=1;i<=S;i++)c[i]=a[b[i]];\n\t\treturn c;\n\t}\n\tvoid operator =(data b)\n\t{\n\t\tfor(int i=1;i<=S;i++)a[i]=b[i];\n\t}\n}a,p,q,st;\ninline data f(data p,data q)\n{\n\treturn q*p.ginv();\n}\ninline data po(data a,int pw)\n{\n\tdata r;\n\tfor(int i=1;i<=S;i++)r[i]=i;\n\tfor(;pw;pw>>=1,a=a*a)if(pw&1)r=r*a;\n\treturn r;\n}\nint main()\n{\n//\tprintf(\"main_start\\n\");\n\tscanf(\"%d\",&S);int k;scanf(\"%d\",&k);\n\tfor(int i=1;i<=S;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=S;i++)scanf(\"%d\",&q[i]);\n\tint pw=(k-1)/6;int bas=(k-1)%6+1;\n\ta=q*p.ginv()*q.ginv()*p;\n\tswitch(bas)\n\t{\n\t\tcase 1:{st=p;}\n\t\tcase 2:{st=q;}\n\t\tdefault:\n\t\t{\n\t\t\tfor(int i=3;i<=bas;i++)\n\t\t\t\tst=f(p,q),p=q,q=st;\n\t\t}\n\t}\n\tst=po(a,pw)*st*po(a.ginv(),pw);\n\tfor(int i=1;i<=S;i++)\n\t\tprintf(\"%d \",st[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int N=1e5+10;\nint n,k,tmp[N];\nstruct Poly\n{\n\tint a[N];\n\tPoly inv()\n\t\t{\n\t\t\tPoly C;\n\t\t\tfor(int i=1;i<=n;i++) tmp[a[i]]=i;\n\t\t\tfor(int i=1;i<=n;i++) C.a[i]=tmp[i];\n\t\t\treturn C;\n\t\t}\n\tPoly operator * (Poly A)\n\t\t{\n\t\t\tPoly C;\n\t\t\tfor(int i=1;i<=n;i++) C.a[i]=a[A.a[i]];\n\t\t\treturn C;\n\t\t}\n}A,P,Q,bs[9];\nPoly ksm(Poly A,int k)\n{\n\tPoly s=bs[0];for(;k;k>>=1,A=A*A)\n\t\t\t\t\t if(k&1) s=s*A;return s;\n}\nint main()\n{\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) cin>>P.a[i];\n\tfor(int i=1;i<=n;i++) cin>>Q.a[i];\n\tA=Q*P.inv()*Q.inv()*P;\n\tfor(int i=1;i<=n;i++) bs[0].a[i]=i;\n\tbs[1]=P;bs[2]=Q;\n\tfor(int i=3;i<=5;i++) bs[i]=bs[i-1]*bs[i-2].inv();\n\n\tPoly Ans1=ksm(A,k/6),Ans2=ksm(A.inv(),k/6);\n\tPoly Ans=Ans1*bs[k%6]*Ans2;\n\tfor(int i=1;i<=n;i++) cout<<Ans.a[i]<<\" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nnamespace ProjectPermy\n{\n\tstruct perm\n\t{\n\t\tvector<int>v;\n\t\tint &operator[](int x){return v[x];}\n\t\tconst int &operator[](int x)const{return v[x];}\n\t\tint size()const{return v.size()-1;}\n\t\tvoid resize(int n){v.resize(100001);}\n\t\tvoid read(int n){v.resize(100001);for(int i=1;i<=size();i++)scanf(\"%d\",&v[i]);}\n\t\tvoid out()\n\t\t{\n\t\t\tfor(int i=1;i<=size();i++)\n\t\t\t\tprintf(\"%d \",v[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t};\n\tperm e(int n)\n\t{\n\t\tperm ans;\n\t\tans.resize(n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans[i]=i;\n\t\treturn ans;\n\t}\n\tperm operator*(perm a,perm b)\n\t{\n\t\tperm ans=e(a.size());\n\t\tperm rev=e(a.size());\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t\tans[i]=a[b[i]];\n\t\treturn ans;\n\t}\n\tperm operator~(perm a)\n\t{\n\t\tperm ans=e(a.size());\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t\tans[a[i]]=i;\n\t\treturn ans;\n\t}\n\tvoid find_cycle(perm a,int x,vector<int>vis,vector<int>&rem)\n\t{\n\t\tif(vis[x]) return;\n\t\tvis[x]=1;\n\t\trem.push_back(x);\n\t\tfind_cycle(a,a[x],vis,rem);\n\t}\n\tperm Pow(perm a,int x)\n\t{\n\t\tperm ans=e(a.size());\n\t\tvector<vector<int> >cycle;\n\t\tvector<int>vis;\n\t\tvis.resize(a.size()+2);\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t{\n\t\t\tif(!vis[i])\n\t\t\t{\n\t\t\t\tvector<int> rem;\n\t\t\t\tfind_cycle(a,i,vis,rem);\n\t\t\t\tcycle.push_back(rem);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<cycle.size();i++)\n\t\t{\n\t\t\tfor(int j=0;j<cycle[i].size();j++)\n\t\t\t\tans[cycle[i][j]]=cycle[i][(j+x)%cycle[i].size()];\n\t\t}\n\t\treturn ans;\n\t}\n}\nusing namespace ProjectPermy;\nsigned main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tperm p,q;\n\tp.read(n);\n\tq.read(n);\n\tperm a[7];\n\ta[1]=p;\n\ta[2]=q;\n\tfor(int i=3;i<=6;i++)\n\t\ta[i]=a[i-1]*(~a[i-2]);\n\tif(m<=6)\n\t{\n\t\ta[m].out();\n\t\treturn 0;\n\t}\n\tperm g=q*(~p)*(~q)*p;\n\t(Pow(g,(m-1)/6)*a[(m-1)%6+1]*Pow(~g,(m-1)/6)).out();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <chrono>\n#include <ctime>\n#include <bitset>\n#include <iterator>\n#include <cmath>\n#include <stack>\n#include <random>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nvector<int> mat_mul(const vector<int>& a, const vector<int>& b, int& n) {\n  vector<int> ret(n+1);\n  for(int i=1; i<=n; i++) {\n    ret[i] = a[b[i]];\n  }\n  return ret;\n}\n\nvector<int> mat_pow(vector<int>& mat, int n, int& size) {\n  vector<int> res(size+1);\n  vector<int> a = mat;\n  for(int i=1; i<=size; i++) {\n    res[i] = i;\n  }\n  while(n > 0) {\n    if (n&1) {\n      res = mat_mul(res, a, size);\n    }\n    a = mat_mul(a, a, size); n >>= 1;\n  }\n  return res;\n}\n\nvector<int> mat_inv(const vector<int>& a, const int& n) {\n  vector<int> ret(n+1);\n  for(int i=1; i<=n; i++) {\n    ret[a[i]] = i;\n  }\n  return ret;\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, k; cin >> n >> k;\n  vector<int> p(n+1);\n  vector<int> q(n+1);\n  for(int i=1; i<=n; i++) {\n    cin >> p[i];\n  }\n  for(int i=1; i<=n; i++) {\n    cin >> q[i];\n  }\n  vector<int> ip = mat_inv(p, n);\n  vector<int> iq = mat_inv(q, n);\n\n  k--;\n  vector<int> A = mat_mul(q, ip, n);\n  A = mat_mul(A, iq, n);\n  A = mat_mul(A, p, n);\n  A = mat_pow(A, k/6, n);\n  vector<int> IA = mat_inv(A, n);\n\n  k = k%6;\n  vector<int> ans;\n  if (k==0) {\n    ans = p;\n  } else if (k==1) {\n    ans = q;\n  } else {\n    k--;\n    while(k--) {\n      ans = mat_mul(q, mat_inv(p, n), n);\n      p = q;\n      q = ans;\n    }\n  }\n\n  ans = mat_mul(A, ans, n);\n  ans = mat_mul(ans, IA, n);\n\n  for(int i=1; i<=n; i++) {\n    cout << ans[i] << ' ';\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <tuple>\ntemplate <typename T> constexpr T my_abs(const T &x) { return x < 0 ? -x : x; }\nusing ll = long long;\nstruct permutation : std::vector<int>\n{\n\tpermutation(int n = 0) { resize(n); for (int i = 0; i < n; i++) at(i) = i; }\n\tinline permutation operator *(const permutation &a) const\n\t{\n\t\tpermutation res(size());\n\t\tfor (int i = 0; i < size(); i++)\n\t\t\tres[i] = at(a[i]);\n\t\treturn res;\n\t}\n\tinline permutation inv() const\n\t{\n\t\tpermutation res(size());\n\t\tfor (int i = 0; i < size(); i++)\n\t\t\tres[at(i)] = i;\n\t\treturn res;\n\t}\n};\ninline permutation quick_pow(permutation a, int n)\n{\n\tpermutation res(a.size());\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a;\n\t\ta = a * a;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\ninline void output(permutation a)\n{\n\tfor (int i = 0; i < a.size(); i++)\n\t\tprintf(\"%d%c\", a[i] + 1, \" \\n\"[i + 1 == a.size()]);\n}\nint main()\n{\n\t// freopen(\"AGC031-D.in\", \"r\", stdin);\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tpermutation a(n), b(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &b[i]);\n\t\tb[i]--;\n\t}\n\tif (k == 1)\n\t{\n\t\toutput(a);\n\t\treturn 0;\n\t}\n\tif (k == 2)\n\t{\n\t\toutput(b);\n\t\treturn 0;\n\t}\n\tpermutation ra = a.inv(), rb = b.inv();\n\tif (k == 3)\n\t{\n\t\toutput(b * ra);\n\t\treturn 0;\n\t}\n\tk -= 4;\n\tpermutation pl = quick_pow(rb * a * b * ra, k / 6);\n\tpermutation pr = quick_pow(ra * b * a * rb, k / 6);\n\tk %= 6;\n\tstd::vector<permutation> vec = {rb, a, b, ra};\n\tstd::vector<int> len = {1, 3, 4, 5, 7, 8};\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (i * 2 < len[k])\n\t\t\tpl = pl * vec[i];\n\t\tif (i * 2 + 1 < len[k])\n\t\t\tpr = vec[i] * pr;\n\t}\n\toutput(b * ra * pl * pr);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define FIR first\n#define SEC second\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10;\nint n;\nvoid mul(int *a,int *p) {\n    static int b[N];\n    for(int i=1;i<=n;++i) b[i]=a[p[i]];\n    for(int i=1;i<=n;++i) a[i]=b[i];\n}\nint vis[N];\nvoid Pow(int *a,int k) {\n    static int b[N],c[N],m;\n    for(int i=1;i<=n;++i) vis[i]=0;\n    for(int i=1;i<=n;++i) if(!vis[i]) {\n        m=0; int cur=i;\n        while(!vis[cur]) vis[b[m++]=cur]=1,cur=a[cur];\n        for(int i=0;i<m;++i) c[b[i]]=b[(i+k)%m];\n    }\n    for(int i=1;i<=n;++i) a[i]=c[i];\n}\nint p[N],q[N],rp[N],rq[N];\nint a[N],ra[N],b[N],c[N];\nint main() {\n    int L; rd(n),rd(L),L--;\n    for(int i=1;i<=n;++i) rd(p[i]),rp[p[i]]=i;\n    for(int i=1;i<=n;++i) rd(q[i]),rq[q[i]]=i;\n    for(int i=1;i<=n;++i) a[i]=i;\n    mul(a,q),mul(a,rp),mul(a,rq),mul(a,p);\n    Pow(a,L/6); L%=6;\n    for(int i=1;i<=n;++i) ra[a[i]]=i;\n    for(int i=1;i<=n;++i) b[i]=a[i];\n    mul(b,q),mul(b,ra);\n    mul(a,p),mul(a,ra);\n    while(L--) {\n        for(int i=1;i<=n;++i) ra[a[i]]=i,c[i]=b[i];\n        mul(c,ra);\n        for(int i=1;i<=n;++i) a[i]=b[i],b[i]=c[i];\n    }\n    for(int i=1;i<=n;++i) printf(\"%d \",a[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nstruct Permutation{\n  std::vector<int> ps;\n  Permutation(){\n  }\n  Permutation(int N):ps(N){\n    for(int i=0;i<N;i++){\n      ps[i]=i;\n    }\n  }\n  void read(int N){\n    ps.resize(N);\n    for(int i=0;i<N;i++){\n      scanf(\"%d\",&ps[i]);\n      ps[i]--;\n    }\n  }\n  int operator[](int index)const{\n    return ps[index];\n  }\n  int& operator[](int index){\n    return ps[index];\n  }\n  struct Permutation inv()const{\n    struct Permutation res(ps.size());\n    for(int i=0;i<ps.size();i++){\n      res[ps[i]]=i;\n    }\n    return res;\n  }\n};\nstruct Permutation operator*(struct Permutation p,struct Permutation q){\n  int N=p.ps.size();\n  struct Permutation res(N);\n  for(int i=0;i<N;i++){\n    res[i]=p[q[i]];\n  }\n  return res;\n}\n\nstruct Permutation exp[30];\n\nstruct Permutation seq[10];\n\nint main(){\n  int N,K;\n  scanf(\"%d %d\",&N,&K);\n  K--;\n  seq[0].read(N);\n  seq[1].read(N);\n  for(int i=2;i<10;i++){\n    seq[i]=seq[i-1]*seq[i-2].inv();\n  }\n  exp[0]=seq[1]*seq[0].inv()*seq[1].inv()*seq[0];\n  for(int k=1;k<30;k++){\n    exp[k]=exp[k-1]*exp[k-1];\n  }\n  int full=(K-4)/6;\n  struct Permutation pre(N);\n  for(int k=0;k<30;k++){\n    if(full&(1<<k)){\n      pre=pre*exp[k];\n    }\n  }\n  struct Permutation res=pre*seq[K-full*6]*pre.inv();\n  for(int i=0;i<N;i++){\n    if(i) printf(\" \");\n    printf(\"%d\",res.ps[i]+1);\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long LL;\ntemplate<typename T>\ninline void read(T &x){\n\tint ch = getchar(); x = 0;\n\tbool f = false;\n\twhile((ch < '0' || ch > '9') && ch != '-') ch = getchar();\n\tif(ch == '-'){f = true; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9'){x = x * 10 + ch - '0'; ch = getchar();}\n\tif(f) x = -x;\t\n}\nint n, k;\nvi a[6], A;\ninline vi inv(const vi &p){\n\tvi q(n);\n\tfor(Rint i = 0;i < n;++ i) q[p[i]] = i;\n\treturn q;\n}\ninline vi mul(const vi &p, const vi &q){\n\tvi r(n);\n\tfor(Rint i = 0;i < n;++ i) r[i] = p[q[i]];\n\treturn r;\n}\ninline vi ksm(vi a, int b){\n\tvi res(n);\n\tfor(Rint i = 0;i < n;++ i) res[i] = i;\n\twhile(b){\n\t\tif(b & 1) res = mul(res, a);\n\t\ta = mul(a, a); b >>= 1;\n\t}\n\treturn res;\n}\nint main(){\n\tread(n); read(k); -- k;\n\ta[0].resize(n); for(Rint i = 0;i < n;++ i) read(a[0][i]), -- a[0][i];\n\ta[1].resize(n); for(Rint i = 0;i < n;++ i) read(a[1][i]), -- a[1][i];\n\tfor(Rint i = 2;i < 6;++ i) a[i] = mul(a[i - 1], inv(a[i - 2]));\n\tif(k < 6){for(Rint i = 0;i < n;++ i) printf(\"%d \", a[k][i] + 1); return 0;}\n\tA = ksm(mul(mul(a[1], inv(a[0])), mul(inv(a[1]), a[0])), k / 6);\n\tA = mul(mul(A, a[k % 6]), inv(A));\n\tfor(Rint i = 0;i < n;++ i) printf(\"%d \", A[i] + 1); \n}"
  },
  {
    "language": "C++",
    "code": "//第8回シンデレラガール総選挙は是非本田未央ちゃんに投票をお願いします！\n//ファンのことも他のアイドルの子たちのことも本当に大事にしてて、今まで周りに色んなものを与えてくれました。\n//今度は私たちが未央ちゃんにお返しをする番です。みんなでガラスの靴を履かせてあげましょう！\n// #本田未央を一番星に #本田未央を令和のシンデレラガールに #第8回シンデレラガール総選挙\n#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nostream &operator<<(ostream &os, const vector<int> &a) {\n\tos<<\"[\";\n\trep(i,a.size()){\n\t\tos<<a[i];\n\t\tif(i<a.size()-1) os<<\",\";\n\t}\n\tos<<\"]\";\n\treturn os; \n}\nint n;\nvector<int> inv(vector<int> a){\n\tvector<int> ret(n);\n\trep(i,n) ret[a[i]]=i;\n\treturn ret;\n}\nvector<int> mul(vector<int> a,vector<int> b){\n\tvector<int> ret(n);\n\trep(i,n) ret[i]=b[a[i]];\n\treturn ret;\n}\nmap<int,vector<int> > me;\nvector<int> rec(int a){\n\tif(me[a].size()>0) return me[a];\n\treturn me[a]=mul(rec(a/2),rec(a-a/2));\n}\nvector<int> ama[10];\nint main()\n{\n\tvector<int> a,b,id;\n\tint m,c;\n\tcin>>n>>m;m--;\n\trep(i,n) id.pb(i);\n\trep(i,n){\n\t\tcin>>c;c--;a.pb(c);\n\t}\n\trep(i,n){\n\t\tcin>>c;c--;b.pb(c);\n\t}\n\tama[0]=a;ama[1]=b;\n\trep(i,6) ama[i+2]=mul(inv(ama[i]),ama[i+1]);\n\tvector<int> A=inv(a),B=inv(b);\n\t//cout<<ama[2]<<endl;\n\tvector<int> x=mul(B,mul(a,mul(b,A)));\n\tme[0]=id;me[1]=x;\n\tvector<int> y=rec(m/6);\n\t//cout<<y<<endl;\n\tvector<int> out=mul(y,mul(ama[m%6],inv(y)));\n\trep(i,n){\n\t\tcout<<out[i]+1;\n\t\tif(i<n-1) cout<<' ';else cout<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fm, to)    for (int i = fm; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e5;\nint n, k, cnt;\nvector<int> a, b, f[nsz + 5];\n\nvector<int> inline operator * (const vector<int> &a, const vector<int> &b) {\n    vector<int> res(n);\n    loop (i, n) {\n        res[a[i] - 1] = b[i];\n    }\n    return res;\n}\n\nbool inline chk(const vector<int> &a, const vector<int>&b) {\n    return a == ::a && b == ::b;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n >> k;\n    a.resize(n), b.resize(n);\n    loop (i, n) {\n        cin >> a[i];\n    }\n    loop (i, n) {\n        cin >> b[i];\n    }\n    f[0] = a, f[1] = b;\n    for (cnt = 2;; ++cnt) {\n        f[cnt] = f[cnt - 2] * f[cnt - 1];\n        if (chk(f[cnt - 1], f[cnt])) {\n            cnt -= 2;\n            break;\n        }\n    }\n    k = (k - 1) % (cnt + 1);\n    loop (i, n) {\n        cout << f[k][i] << ' ';\n    }\n    cout << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 100010;\nconst int INF = 2147483600;\n\nint N,K; int b[MAXN+1],c[MAXN+1]; bool vis[MAXN+1]; int sta[MAXN+1],top;\nstruct dat{\n\tint a[MAXN+1];\n\tinline void Pow(LL k){\n\t\tfor(int i=1;i<=N;i++) vis[i]=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(vis[i]) continue;\n\t\t\tint nw=i; top=0; while(!vis[a[nw]]) sta[top++]=nw=a[nw],vis[nw]=1;\n\t\t\tnw=k%top; for(int j=0;j<top;j++){\n\t\t\t\tb[sta[j]]=sta[nw],++nw; if(nw>=top) nw-=top; }\n\t\t} for(int i=1;i<=N;i++) a[i]=b[i];\n\t\treturn ;\n\t}\n}An[9];\ndat operator * (const dat p,const dat q){\n\tdat nw; for(int i=1;i<=N;i++) nw.a[i]=p.a[q.a[i]]; return nw;\n}\ninline dat Inv(dat n){\n\tdat ret; for(int i=1;i<=N;i++) b[n.a[i]]=i;\n\tfor(int i=1;i<=N;i++) ret.a[i]=b[i]; return ret;\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(); K=read();\n\tfor(int i=1;i<=N;i++) An[1].a[i]=read();\n\tfor(int i=1;i<=N;i++) An[2].a[i]=read();\n\tfor(int i=3;i<=7;i++) An[i]=An[i-1]*Inv(An[i-2]);\n\tint m=(K-1)/6,n=(K-1)%6+1;\n\tdat p,q; p=An[1]; q=An[2];\n\tdat A; A=q; A=A*Inv(p); A=A*Inv(q); A=A*p;\n\tdat ivA; ivA=Inv(A);\n\tA.Pow(m); ivA.Pow(m);\n\tdat ret; ret=A; ret=ret*An[n]; ret=ret*ivA;\n\tfor(int i=1;i<=N;i++) printf(\"%d \",ret.a[i]);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=1e5+5;\n\nstruct P{\n    int n;\n    int a[N];\n    P(int _n){ n=_n; FOR(i,1,n)a[i]=i; }\n    P(){}\n    void read(){\n        FOR(i,1,n)scanf(\"%d\",&a[i]);\n    }\n    int & operator[](int x){return a[x];}\n    P operator*(P b){\n        P res;\n        res.n=n;\n        FOR(i,1,n)res[i]=a[b[i]];\n        return res;\n    }\n    P operator*=(P b){\n        *this = *this * b;\n        return *this;\n    }\n    void print(){\n        FOR(i,1,n)printf(\"%d%c\",a[i],\" \\n\"[i==n]);\n    }\n};\n\nP inv(P& a){\n    P res;\n    res.n=a.n;\n    FOR(i,1,a.n)res[a[i]]=i;\n    return res;\n}\nP pw(P a,int m){\n    P res(a.n);\n    while(m)m&1?res=res*a:0,a=a*a,m>>=1;\n    return res;\n}\n\nint n,k;\n\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    P p(n),q(n);\n    p.read();\n    q.read();\n    P ip=inv(p),iq=inv(q);\n\n    P A=q*ip*iq*p;\n    A=pw(A,(k-1)/6);\n    if(k%6==4)A*=q;\n    else if(k%6==5)A*=q*ip;\n    else if(k%6==0)A*=q*ip;\n\n    P B=\n        k%6==0?iq*p:\n        k%6==1?p:\n        k%6==2?q:\n        k%6==3?q*ip:\n        k%6==4?ip:\n        iq;\n\n    P ans=A*B*inv(A);\n    ans.print();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nconst int maxn = 100005;\nint n, k;\n\nstruct perm\n{\n\tint data[maxn];\n\tint operator[](int x) const { return data[x]; }\n\tint &operator[](int x) { return data[x]; }\n} p, q, fold, ans;\nperm operator*(const perm &a, const perm &b)\n{\n\tperm c;\n\tfor (int i = 1; i <= n; ++i)\n\t\tc[i] = b[a[i]];\n\treturn c;\n}\nperm inv(const perm &x)\n{\n\tperm y;\n\tfor (int i = 1; i <= n; ++i)\n\t\ty[x[i]] = i;\n\treturn y;\n}\nperm power(const perm &a, int x)\n{\n\tstatic bool vis[maxn];\n\tperm ret;\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tstd::vector<int> now;\n\t\t\tnow.push_back(i);\n\t\t\tvis[i] = true;\n\t\t\tfor (int j = a[i]; j != i; j = a[j])\n\t\t\t\tnow.push_back(j), vis[j] = true;\n\t\t\tfor (int i = 0; i < (int)now.size(); ++i)\n\t\t\t\tret[now[i]] = now[(i + x) % now.size()];\n\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tvis[i] = false;\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &p[i]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &q[i]);\n\tfold = power(p * inv(q) * inv(p) * q, k / 6);\n\tswitch (k % 6)\n\t{\n\t\tcase 0:\n\t\t\tans = inv(fold) * inv(q) * p * p * inv(q) * inv(p) * q * fold;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tans = inv(fold) * p * fold;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tans = inv(fold) * q * fold;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tans = inv(fold) * inv(p) * q * fold;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tans = inv(fold) * inv(q) * inv(p) * q * fold;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tans = inv(fold) * inv(q) * p * inv(q) * inv(p) * q * fold;\n\t\t\tbreak;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tprintf(\"%d%c\", ans[i], \" \\n\"[i == n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n;\nvector<ll> ret;\n\n\n\nvoid cul(vector<ll> &ret,const vector<ll> &A,const vector<ll> &B){\n    for(int i=0;i<n;i++){ret[i]=B[A[i]];}\n}\n\nvoid rev(vector<ll> &ret,vector<ll> A){\n    for(int i=0;i<n;i++){ret[A[i]]=i;}\n}\n\nvoid Out(vector<ll> ans){\n    for(int i=0;i+1<n;i++){cout<<ans[i]+1<<\" \";}\n    cout<<ans.back()+1<<endl;\n}\n\nvector<ll> operator * (const vector<ll> &A,const vector<ll> &B){cul(ret,A,B); return ret;}\n\nvector<ll> & operator *= (vector<ll> &A,const vector<ll> &B){cul(ret,A,B); return A=ret;}\n\nvector<ll> & operator /= (vector<ll> &A,const vector<ll> &B){cul(ret,B,A); return A=ret;}\n\n\nint main(){\n    ll k;\n    cin>>n>>k;\n    vector<ll> P(n);\n    vector<ll> Q(n);\n    for(auto &I:P){cin>>I; I--;}\n    for(auto &I:Q){cin>>I; I--;}\n    \n    ret.resize(n);\n    vector<ll> PI(n);\n    vector<ll> QI(n);\n    rev(PI,P);\n    rev(QI,Q);\n    vector<ll> O=P*QI*PI*Q;\n    vector<ll> A(n);\n    for(int i=0;i<n;i++){A[i]=i;}\n    \n    if(k==1){\n        Out(P);\n        return 0;\n    }\n    else if(k==2){\n        Out(Q);\n        return 0;\n    }\n    else if(k==3){\n        Out(PI*Q);\n        return 0;\n    }\n    if(k<=100){\n        for(int i=3;i<=k;i++){\n            rev(P,P);\n            P*=Q;\n            swap(P,Q);\n        }\n        Out(Q);\n        return 0;\n    }\n    \n    k-=3;\n    ll Z=k/6;\n    while(Z>0){\n        if(Z&1){A*=O;}\n        Z>>=1;\n        O*=O;\n    }\n    \n    if(k%6){A/=Q;}\n    if(k%6>1){A/=PI;}\n    if(k%6>3){A/=QI;}\n    if(k%6==5){A/=P;}\n    \n    rev(O,A);\n    \n    if(k%3==1){\n        QI=PI;\n    }\n    else if(k%3==2){\n        QI=QI;\n    }\n    else{\n        cul(QI,PI,Q);\n    }\n    if((k/3)&1){rev(QI,QI);}\n    O*=QI;\n    O*=A;\n    Out(O);\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=305,INF=1<<30;\n\nvector<int> rev(vector<int> &A){\n    vector<int> res(si(A));\n    \n    for(int i=0;i<si(A);i++){\n        res[A[i]]=i;\n    }\n    \n    return res;\n}\n\nvector<int> mul(vector<int> &A,vector<int> &B){\n    vector<int> res=A;\n    \n    for(int i=0;i<si(A);i++){\n        res[i]=B[res[i]];\n    }\n    \n    return res;\n}//A→Bの順で写像を適用\n\nvector<int> pow(vector<int> &A,ll n){\n    vector<int> res(si(A));\n    iota(all(res),0);\n    \n    while(n>0){\n        if(n&1) res=mul(res,A);\n        A=mul(A,A);\n        n/=2;\n    }\n    \n    return res;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,K;cin>>N>>K;\n    K--;\n    vector<int> p(N),q(N);\n    for(int i=0;i<N;i++){\n        cin>>p[i];\n        p[i]--;\n    }\n    for(int i=0;i<N;i++){\n        cin>>q[i];\n        q[i]--;\n    }\n    \n    vector<int> pp=rev(p),qq=rev(q),r=mul(pp,q);\n    \n    if(K==0){\n        for(int a:p) cout<<a+1<<\" \";\n        cout<<endl;\n        return 0;\n    }\n    \n    if(K==1){\n        for(int a:q) cout<<a+1<<\" \";\n        cout<<endl;\n        return 0;\n    }\n    \n    if(K==2){\n        for(int a:r) cout<<a+1<<\" \";\n        cout<<endl;\n        return 0;\n    }\n    \n    vector<int> A(N),B(N),res(N);\n    iota(all(A),0);\n    iota(all(res),0);\n    A=mul(A,p);\n    A=mul(A,qq);\n    A=mul(A,pp);\n    A=mul(A,q);\n    \n    int x=(K-3)%6,y=(K-3)/6;\n    \n    A=pow(A,y);\n    B=rev(A);\n    \n    p=q;\n    q=r;\n    \n    for(int i=0;i<=x;i++){\n        pp=rev(p);\n        r=mul(pp,q);\n        \n        p=q;\n        q=r;\n    }\n    \n    res=mul(res,B);\n    res=mul(res,q);\n    res=mul(res,A);\n    \n    for(int a:res) cout<<a+1<<\" \";\n    cout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=100005;\nint n,k;\nstruct permutation\n{\n\tint a[N];\n\tinline permutation(void) { memset(a,0,sizeof(a)); }\n\tinline int& operator [] (CI x) { return a[x]; }\n\tinline friend permutation operator ~ (permutation A)\n\t{\n\t\tpermutation tp; for (RI i=1;i<=n;++i) tp[A[i]]=i; return tp;\n\t}\n\tinline friend permutation operator * (permutation A,permutation B)\n\t{\n\t\tpermutation C; for (RI i=1;i<=n;++i) C[i]=A[B[i]]; return C;\n\t}\n\tinline friend permutation operator ^ (permutation A,int p)\n\t{\n\t\tpermutation t; for (RI i=1;i<=n;++i) t[i]=i;\n\t\tfor (;p;p>>=1,A=A*A) if (p&1) t=t*A; return t;\n\t}\n\tinline void print(void)\n\t{\n\t\tfor (RI i=1;i<=n;++i) printf(\"%d \",a[i]);\n\t}\n}a[10],T;\nint main()\n{\n\tRI i; for (scanf(\"%d%d\",&n,&k),i=1;i<=n;++i) scanf(\"%d\",&a[1][i]);\n\tfor (i=1;i<=n;++i) scanf(\"%d\",&a[2][i]);\n\tfor (i=3;i<=6;++i) a[i]=a[i-1]*(~a[i-2]);\n\tint d=k/6,r=k%6; if (!r) --d,++r; T=a[2]*(~a[1])*(~a[2])*a[1];\n\treturn ((T^d)*a[r]*((~T)^d)).print(),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stack>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nvector<int> pmul(const vector<int> &p, const vector<int> &q) {\n    int n = p.size()-1;\n    vector<int> ans(n+1);\n    for (int i = 1; i <= n; i++) ans[i] = p[q[i]];\n    return ans;\n}\n\nvector<int> ppow(vector<int> &p, int k) {\n    int n = p.size()-1;\n    vector<int> ans(n+1), pw = p;\n    for (int i = 1; i <= n; i++) ans[i] = i;\n    while (k > 0) {\n        if (k % 2 != 0) ans = pmul(ans, pw);\n        pw = pmul(pw, pw);\n        k >>= 1;\n    }\n    return ans;\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n    vector<int> p(n+1), q(n+1), P(n+1), Q(n+1);\n    for (int i = 1; i <= n; i++) {\n        int x; cin >> x; p[i] = x; P[x] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        int x; cin >> x; q[i] = x; Q[x] = i;\n    }\n    vector<int> ans;\n    if (k == 1) ans = p;\n    else if (k == 2) ans = q;\n    else if (k == 3) ans = pmul(q, P);\n    else if (k == 4) ans = pmul(q, pmul(P, Q));\n    else {\n        vector<int> r(n+1), R(n+1);\n        for (int i = 1; i <= n; i++) {\n            r[i] = q[P[Q[p[i]]]];\n            R[i] = P[q[p[Q[i]]]];\n        }\n        int t = (k+1)/6;\n        vector<int> s = ppow(r, t), S = ppow(R, t-1);\n        vector<int> u = Q;\n        int res = (k + 1) % 6;\n        if (res > 0) u = pmul(p, u);\n        if (res > 1) u = pmul(q, u);\n        if (res > 2) {\n            u = pmul(P, u);\n            if (res == 4) u = pmul(P, u);\n            if (res == 5) u = pmul(P, pmul(Q, u));\n            u = pmul(q, u);\n        }\n        ans = pmul(s, pmul(u, S));\n    }\n    for (int i = 1; i <= n; i++) cout << ans[i] << ' ';\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate<typename T> void read(T &x)\n{\n\tx = 0;\n\tchar c = getchar();\n\tbool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n, k;\nvector<int> p, q;\n\nvector<int> operator + (vector<int> a, vector<int> b)\n{\n\tvector<int> c(n+1);\n\tfor(int i=1; i<=n; i++) c[i] = a[b[i]];\n\treturn c;\n}\n\nvector<int> operator * (vector<int> a, int num)\n{\n\tvector<int> c(n+1), vis(n+1);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tif(vis[i]) continue;\n\t\tint x = i;\n\t\tvector<int> loop;\n\t\twhile(!vis[x])\n\t\t{\n\t\t\tloop.push_back(x);\n\t\t\tvis[x] = 1;\n\t\t\tx = a[x];\n\t\t}\n\t\tfor(int j=0; j<loop.size(); j++) c[loop[j]] = a[loop[(j+num-1+loop.size())%loop.size()]];\n\t}\n\treturn c;\n}\n\nvector<int> rev(vector<int> a)\n{\n\tvector<int> c(n+1);\n\tfor(int i=1; i<=n; i++) c[a[i]] = i;\n\treturn c;\n}\n\nvoid print(vector<int> a)\n{\n\tfor(int i=1; i<=n; i++) printf(\"%d \", a[i]);\n\tputchar('\\n');\n}\n\nint main()\n{\n\tread(n), read(k), k--;\n\tp.resize(n+1), q.resize(n+1);\n\tfor(int i=1; i<=n; i++) read(p[i]);\n\tfor(int i=1; i<=n; i++) read(q[i]);\n\tint pre = k/6;\n\tvector<int> id(n+1);\n\tfor(int i=1; i<=n; i++) id[i] = i;\n\tauto l = (q+rev(p)+rev(q)+p)*pre;\n\tswitch (k % 6)\n\t{\n\tcase 0:\n\t\tprint(l+p+rev(l));\n\t\tbreak;\n\tcase 1:\n\t\tprint(l+q+rev(l));\n\t\tbreak;\n\tcase 2:\n\t\tprint(l+q+rev(p)+rev(l));\n\t\tbreak;\n\tcase 3:\n\t\tprint(l+q+rev(p)+rev(q)+rev(l));\n\t\tbreak;\n\tcase 4:\n\t\tprint(l+q+rev(p)+rev(q)+p+rev(q)+rev(l));\n\t\tbreak;\n\tcase 5:\n\t\tprint(l+q+rev(p)+rev(q)+p+p+rev(q)+rev(l));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint n,c[N],k;\nstruct zhihuan{\n\tint a[N];\n\tzhihuan operator *(const zhihuan &b)const {\n\t\tzhihuan x;\n\t\tfor (int i=1;i<=n;i++)x.a[i]=a[b.a[i]];\n\t\treturn x;\n\t}\n}I,p,q;\nzhihuan inv(zhihuan x){\n\tfor (int i=1;i<=n;i++)c[x.a[i]]=i;\n\tfor (int i=1;i<=n;i++)x.a[i]=c[i];\n\treturn x;\n}\nzhihuan ksm(zhihuan x,int y){\n\tif (!y)return I;\n\tzhihuan z=ksm(x,y/2);\n\tz=z*z;\n\tif (y&1)z=z*x;\n\treturn z;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i<=n;i++)I.a[i]=i;\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&p.a[i]);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&q.a[i]);\n\tzhihuan Ans=q*inv(p)*inv(q)*p;\n\tint t=k%6;if (t==0)t=6;\n\tAns=ksm(Ans,(k-t)/6);k=t;\n\tif (k==1)Ans=Ans*p;\n\tif (k==2)Ans=Ans*q;\n\tif (k==3)Ans=Ans*q*inv(p);\n\tif (k==4)Ans=Ans*q*inv(p)*inv(q);\n\tif (k==5)Ans=Ans*q*inv(p)*inv(q)*p*inv(q);\n\tif (k==6)Ans=Ans*q*inv(p)*inv(q)*p*p*inv(q);\n\tfor (int i=1;i<=n;i++)printf(\"%d \",Ans.a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\nvector<int> inv(vector<int> r){\n  vector<int> res(r.size(), 0);\n  rep(i, sz(r))res[r[i]] = i;\n  return res;\n}\n\nvector<int> comp(vector<int> a, vector<int> b){\n  vector<int> res(a.size(), 0);\n  rep(i, sz(a))res[i] = a[b[i]];\n  return res;\n}\n\nvector<int> db[34];\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  INT(n); LL(k);\n  vector<int> p(n), q(n); cin >> p >> q; rep(i, n)p[i]--, q[i]--;\n  vector<int> pi = inv(p), qi = inv(q);\n  if(k == 1){\n    rep(i, n)p[i]++;\n    cout << p << endl;\n    return 0;\n  }\n  db[0] = comp(q, comp(pi, comp(qi, p)));\n  FOR(i, 1, 33){\n    db[i] = comp(db[i-1], db[i-1]);\n  }\n  vector<int> A(n, 0); rep(i, n)A[i] = i;\n  ll tmp = (k - 1) / 6;\n  int ind = 0;\n  while(tmp){\n    if(tmp % 2 == 1){\n      A = comp(A, db[ind]);\n    }\n    ind++;\n    tmp /= 2;\n  }\n  int cnt = (k - 1) % 6;\n  if(cnt == 3)A = comp(A, q);\n  if(cnt == 4)A = comp(A, comp(q, pi));\n  if(cnt == 5)A = comp(A, comp(q, pi));\n  vector<int> B;\n  if(cnt == 0)B = p;\n  if(cnt == 1)B = q;\n  if(cnt == 2)B = comp(q, pi);\n  if(cnt == 3)B = pi;\n  if(cnt == 4)B = qi;\n  if(cnt == 5)B = comp(qi, p);\n  vector<int> res = comp(A, comp(B, inv(A)));\n  rep(i, n)res[i]++;\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nint n,want;\nvector<int> a;\nvector<int> b;\nvector<int> ans;\n\nvector<int> inv(const vector<int> &a) { vector<int> ret(n); REP(i,n) ret[a[i]]=i; return ret; }\nvector<int> combine(const vector<int> &a,const vector<int> &b) { vector<int> ret(n); REP(i,n) ret[i]=a[b[i]]; return ret; }\nvector<int> pw(vector<int> x,int k) { vector<int> ret(n); REP(i,n) ret[i]=i; while(true) { if(k&1) ret=combine(ret,x); if((k>>=1)==0) return ret; x=combine(x,x); } }\n\nvoid solve() {\n\tif(want==1) { ans=a; return; }\n\tvector<int> ainv=inv(a),binv=inv(b);\n\tint nfull=(want-2)/6,nrem=(want-2)%6;\n\tvector<int> leftperiod=combine(b,combine(ainv,combine(binv,a)));\n\tvector<vector<int>> mid(6);\n\tmid[0]=b;\n\tmid[1]=combine(b,ainv);\n\tmid[2]=combine(b,combine(ainv,binv));\n\tmid[3]=combine(b,combine(ainv,combine(binv,combine(a,binv))));\n\tmid[4]=combine(b,combine(ainv,combine(binv,combine(a,combine(a,binv)))));\n\tmid[5]=combine(b,combine(ainv,combine(binv,combine(a,combine(b,combine(a,binv))))));\n\tvector<int> leftfull=pw(leftperiod,nfull);\n\tans=combine(leftfull,combine(mid[nrem],inv(leftfull)));\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&want);\n\ta=vector<int>(n); REP(i,n) scanf(\"%d\",&a[i]),--a[i];\n\tb=vector<int>(n); REP(i,n) scanf(\"%d\",&b[i]),--b[i];\n\tsolve();\n\tREPSZ(i,ans) { if(i!=0) printf(\" \"); printf(\"%d\",ans[i]+1); } puts(\"\");\n}\n\nbool isopp(char a,char b) { return a!=b&&tolower(a)==tolower(b); }\nvoid research() {\n\tvector<string> ops(101);\n\tops[1]=string(\"a\");\n\tops[2]=string(\"b\");\n\tFORE(i,3,100) {\n\t\tops[i]=ops[i-1]; for(int j=SZ(ops[i-2])-1;j>=0;--j) ops[i]+=islower(ops[i-2][j])?toupper(ops[i-2][j]):tolower(ops[i-2][j]);\n\t\tint cnt=0; REPSZ(j,ops[i]) if(cnt!=0&&isopp(ops[i][cnt-1],ops[i][j])) --cnt; else ops[i][cnt++]=ops[i][j]; ops[i].resize(cnt);\n\t}\n\tFORE(i,1,100) {\n\t\tint nsym=0; while(2*(nsym+1)<=SZ(ops[i])&&isopp(ops[i][nsym],ops[i][SZ(ops[i])-1-nsym])) ++nsym;\n\t\tint nrep=0; while(4*(nrep+1)<=nsym&&ops[i][4*nrep]=='b'&&ops[i][4*nrep+1]=='A'&&ops[i][4*nrep+2]=='B'&&ops[i][4*nrep+3]=='a') ++nrep; nsym=4*nrep;\n\t\tint nmid=SZ(ops[i])-2*nsym;\n\t\tprintf(\"%3d (%2d,%d,%d): \",i,nrep,nsym-4*nrep,nmid); REP(j,nmid) printf(\"%c\",ops[i][nsym+j]); REP(j,7-nmid) printf(\" \"); printf(\" | \"); REP(j,nsym-4*nrep) printf(\"%c\",ops[i][4*nrep+j]); puts(\"\");\n\t}\n}\n\nint main() {\n\t//research();\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint a[9][21],n,k,an[9],A[21],An;\n\nstruct Pm\n{\n\tint p[100010],c[100010],cn;\n\tbool bo[100010];\n\tvoid operator ^=(int b)\n\t{\n\t\tmemset(bo,0,sizeof(bo));\n\t\tfor (int x,i=1; i<=n; i++) if (!bo[i])\n\t\t{\n\t\t\tbo[x=i]=1,c[0]=i,cn=1;\n\t\t\tfor (x=p[x]; x!=i; x=p[x]) c[cn++]=x,bo[x]=1;\n\t\t\tfor (int j=0; j<cn; j++) p[c[j]]=c[(j+b+cn)%cn];\n\t\t}\n\t}\n\tvoid operator *=(Pm A) {for (int i=1; i<=n; i++) p[i]=A.p[p[i]];}\n\tvoid in() {for (int i=1; i<=n; i++) scanf(\"%d\",&p[i]);}\n\tvoid out() {for (int i=1; i<=n; i++) printf(\"%d \",p[i]);puts(\"\");}\n}p,q,P,Q,t,T,ans;\n\nPm calc(int x)\n{\n\tif (x==1) return p;\n\tif (x==-1) return P;\n\tif (x==2) return q;\n\tif (x==-2) return Q;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k),a[1][1]=1,a[2][1]=2,an[1]=an[2]=1;\n\tfor (int i=3; i<=7; i++)\n\t{\n\t\tAn=an[i-2]+an[i-1],an[i]=0;\n\t\tfor (int j=1; j<=an[i-1]; j++) A[an[i-2]+j]=a[i-1][j];\n\t\tfor (int j=1; j<=an[i-2]; j++) A[j]=-a[i-2][an[i-2]-j+1];\n\t\tfor (int j=1; j<An; j++) if (A[j]==-A[j+1]) A[j]=A[j+1]=0,j++;\n\t\tfor (int j=1; j<=An; j++) if (A[j]) a[i][++an[i]]=A[j];\n\t}\n\tp.in(),q.in(),P=p,P^=(-1),Q=q,Q^=(-1),t=calc(a[7][1]);\n\tfor (int i=2; i<=(an[7]>>1); i++) t*=calc(a[7][i]);\n\tt^=((k-1)/6),T=t,T^=(-1),ans=t;\n\tfor (int i=1; i<=an[(k-1)%6+1]; i++) ans*=calc(a[(k-1)%6+1][i]);\n\tans*=T,ans.out();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\ntypedef long long int ll;\nusing namespace std;\n\n#define DEBUG 0\n\n#if DEBUG\n  #define DLOG(...) fprintf(stderr, __VA_ARGS__)\n#else\n  #define DLOG(...)\n#endif\n\nvoid debug(auto f) {\n#if DEBUG\n  f();\n#endif\n}\n\nll N, K;\nvector<ll> p, q;\nvector<vector<ll>> init(7);\n\nvector<ll> comp(vector<ll> s, vector<ll> t) {\n  vector<ll> result(N+1);\n  for (ll i = 1; i <= N; i++)  result.at(i) = s.at(t.at(i));\n  return result;\n}\n\nvector<ll> inv(vector<ll> s) {\n  vector<ll> result(N+1);\n  for (ll i = 1; i <= N; i++)  result.at(s.at(i)) = i;\n  return result;\n}\n\nvector<ll> unit() {\n  vector<ll> result(N+1);\n  for (ll i = 1; i <= N; i++)  result.at(i) = i;\n  return result;\n}\n\nvector<ll> funcf(vector<ll> s, vector<ll> t) {\n  return comp(t, inv(s));\n}\n\nint main() {\n#if !DEBUG\n  ios_base::sync_with_stdio(false);\n#endif\n\n  cin >> N >> K;\n  p.resize(N+1);\n  q.resize(N+1);\n  for (ll i = 1; i <= N; i++)  cin >> p.at(i);\n  for (ll i = 1; i <= N; i++)  cin >> q.at(i);\n  init.at(1) = vector<ll>(p);\n  init.at(2) = vector<ll>(q);\n  for (ll i = 3; i <= 6; i++)  init.at(i) = funcf(init.at(i-2), init.at(i-1));\n  ll n = (K-1) / 6;\n  ll k = (K-1) % 6;\n  vector<ll> alpha = comp(q, comp(inv(p), comp(inv(q), p)));\n  ll pwlen = 32;\n  vector<vector<ll>> powA(pwlen);\n  powA.at(0) = unit();\n  powA.at(1) = vector<ll>(alpha);\n  for (ll j = 1; j < pwlen - 1; j++)  {\n    powA.at(j+1) = comp(powA.at(j), powA.at(j));\n  }\n  vector<ll> beta = unit();\n  for (ll j = 1, x = n; x > 0; j++, x /= 2) {\n    if (x % 2 == 1)  beta = comp(beta, powA.at(j));\n  }\n  vector<ll> answer = comp(beta, comp(init.at(k+1), inv(beta)));\n  for (ll i = 1; i <= N - 1; i++)  cout << answer.at(i) << \" \";\n  cout << answer.at(N) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn = 200111;\nvector<int> tablen = {-1, 1, 2, 3, 5, 6};\nint n, K, a[2][maxn], ia[2][maxn], c[maxn], ic[maxn], d[maxn], c0[4][maxn], cp[maxn], ans[maxn];\nvoid getinv(int a[], int b[])\n{\n\tstatic int tmp[maxn];\n\tfor (int i=1; i<=n; i++) tmp[a[i]] = i;\n\tfor (int i=1; i<=n; i++) b[i] = tmp[i];\n}\nvoid apply(int a[], int b[], int c[])\n{\n\tstatic int tmp[maxn];\n\tfor (int i=1; i<=n; i++) tmp[i] = b[a[i]];\n\tfor (int i=1; i<=n; i++) c[i] = tmp[i];\n}\nvoid apply(int a[], int b[])\n{\n\tstatic int tmp[maxn];\n\tfor (int i=1; i<=n; i++) tmp[i] = b[a[i]];\n\tfor (int i=1; i<=n; i++) a[i] = tmp[i];\n}\nvoid applyk(int a[], int b[], int K, int c[])\n{\n\tstatic int tab[33][maxn], tmp[maxn];\n\tfor (int i=1; i<=n; i++) tab[0][i] = b[i];\n\tfor (int i=1; i<=30; i++) apply(tab[i-1], tab[i-1], tab[i]);\n\tfor (int i=1; i<=n; i++) tmp[i] = a[i];\n\tfor (int i=0; i<=30; i++)\n\t{\n\t\tif ((K>>i)&1)\n\t\t{\n\t\t\tapply(tmp, tab[i], tmp);\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++) c[i] = tmp[i];\n}\nint main()\n{\n\tgetii(n, K); K--;\n\tfor (int i=1; i<=n; i++) geti(a[0][i]);\n\tfor (int i=1; i<=n; i++) geti(a[1][i]);\n\tgetinv(a[0], ia[0]);\n\tgetinv(a[1], ia[1]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tcp[i] = c[i] = d[i] = ans[i] = i;\n\t\tc0[0][i] = ia[1][i];\n\t\tc0[1][i] = a[0][i];\n\t\tc0[2][i] = a[1][i];\n\t\tc0[3][i] = ia[0][i];\n\t}\n\tapply(cp, c0[0]);\n\tapply(cp, c0[1]);\n\tapply(cp, c0[2]);\n\tapply(cp, c0[3]);\n\t\n\t\n\tif (K<2)\n\t{\n\t\tfor (int i=1; i<=n; i++) puti(a[K][i]);\n\t}\n\telse\n\t{\n\t\tint t = K%6;\n\t\tint sz = (K/6)*8+tablen[t];\n\t\tint l = (sz-1)/2;\n\t\tapplyk(c, cp, l/4, c);\n\t\tfor (int i=0; i<l%4; i++) apply(c, c0[i]);\n\t\tif (t==0) apply(d, a[0]);\n\t\telse if (t==1) apply(d, a[1]);\n\t\telse if (t==2) apply(d, ia[0]), apply(d, a[1]);\n\t\telse if (t==3) apply(d, ia[0]);\n\t\telse if (t==4) apply(d, ia[1]);\n\t\telse if (t==5) apply(d, a[0]), apply(d, ia[1]);\n//\t\tfor (int i=1; i<=n; i++) cout<<c[i]<<\" \"; cout<<endl;\n//\t\tfor (int i=1; i<=n; i++) cout<<d[i]<<\" \"; cout<<endl;\n\t\t\n\t\tapply(ans, c);\n\t\tapply(ans, d);\n\t\tgetinv(c, ic);\n\t\tapply(ans, ic);\n\t\tfor (int i=1; i<=n; i++) puti(ans[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long li;\ntypedef unsigned long long lu;\nconst int inf = ~0U >> 2;\nconst li infl = ~0LLU >> 2;\n\ntemplate <class T> inline void Min(T &x, T y) { if (y < x) x = y; }\ntemplate <class T> inline void Max(T &x, T y) { if (y > x) x = y; }\n\n// ----------------------------------------\n\nconst int maxn = 1e5;\n\nint n;\n\nstruct Perm {\n  int p[maxn];\n\n  int & operator [] (int i) {\n    return p[i];\n  }\n\n  int operator [] (int i) const {\n    return p[i];\n  }\n\n  Perm operator * (const Perm &q) const {\n    static Perm z;\n    for (int i = 0; i < n; ++i) {\n      z[i] = p[q[i]];\n    }\n    return z;\n  }\n\n  Perm Inv(void) const {\n    static Perm z;\n    for (int i = 0; i < n; ++i) {\n      z[p[i]] = i;\n    }\n    return z;\n  }\n\n  void Read(void) {\n    for (int i = 0; i < n; ++i) {\n      scanf(\"%d\", p + i);\n      --p[i];\n    }\n  }\n\n  void Print(void) {\n    for (int i = 0; i < n; ++i) {\n      printf(\"%d%c\", p[i] + 1, \" \\n\"[i == n - 1]);\n    }\n  }\n} p, q, inv_p, inv_q, A, inv_A;\n\nPerm Iden(void) {\n  static Perm p;\n  for (int i = 0; i < n; ++i) {\n    p[i] = i;\n  }\n  return p;\n}\n\nPerm Pow(const Perm &p0, int x) {\n  static Perm p;\n  static Perm q;\n  p = p0;\n  q = Iden();\n  for (; x; x >>= 1) {\n    if (x & 1) q = q * p;\n    p = p * p;\n  }\n  return q;\n}\n\nint main(void) {\n  int k;\n  scanf(\"%d%d\", &n, &k);\n  p.Read();\n  q.Read();\n  inv_p = p.Inv();\n  inv_q = q.Inv();\n  A = q * inv_p * inv_q * p;\n  int rep = (k - 1) / 6;\n  int now = 1;\n\n  A = Pow(A, rep);\n  inv_A = A.Inv();\n  p = A * p * inv_A;\n  q = A * q * inv_A;\n  now += rep * 6;\n\n  while (now < k) {\n    A = q * p.Inv();\n    p = q;\n    q = A;\n    ++now;\n  }\n  p.Print();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\nnamespace PermutationSpace{\n\tconst int PermutationLen=100000;\n\tstruct Permutation{\n\t\tint P[PermutationLen+1];\n\t\tPermutation(){for (int i=0;i<=PermutationLen;i++) P[i]=i;}\n\t\tinline int & operator [] (const int &index){return P[index];}\n\t};\n\tPermutation operator * (Permutation A,Permutation B){\n\t\tPermutation C;\n\t\tfor (int i=1;i<=PermutationLen;i++) C[i]=A[B[i]];\n\t\treturn C;\n\t}\n\n\tPermutation Inv(Permutation C){\n\t\tPermutation D;\n\t\tfor (int i=1;i<=PermutationLen;i++) D[C[i]]=i;\n\t\treturn D;\n\t}\n\tPermutation Pow(Permutation D,int p){\n\t\tbool vis[PermutationLen+1];\n\t\tint stk[PermutationLen],top;\n\t\tPermutation E;\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor (int i=1;i<=PermutationLen;i++){\n\t\t\tif (vis[i]) continue;\n\t\t\ttop=0;\n\t\t\tfor (int now=i;!vis[now];now=D[now])\n\t\t\t\tstk[top++]=now,vis[now]=true;\n\t\t\tfor (int j=0;j<top;j++) E[stk[j]]=stk[(j+p)%top];\n\t\t}\n\t\treturn E;\n\t}\n}\n\nusing namespace PermutationSpace;\n\nPermutation A[6],G;\n\nint n,m;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&A[1][i]);\n\tfor (int j=1;j<=n;j++) scanf(\"%d\",&A[2][j]);\n\tA[0]=A[1]*Inv(A[2]);\n\tA[3]=A[2]*Inv(A[1]);\n\tA[4]=A[3]*Inv(A[2]);\n\tA[5]=A[4]*Inv(A[3]);\n\tG=A[2]*Inv(A[1])*Inv(A[2])*A[1];\n\tG=Pow(G,m/6)*A[m%6]*Pow(Inv(G),m/6);\n\tfor (int i=1;i<=n;i++) printf(\"%d \",G[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Maxn 100007\nint n,k;\nint p[Maxn],q[Maxn];\nint a[Maxn],b[Maxn],tmp1[Maxn],tmp2[Maxn];\nint ans[Maxn],r[Maxn];\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&p[i]);\n    for (int i=1;i<=n;i++)\n        scanf(\"%d\",&q[i]);\n    if (k%6==1)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=p[i];\n    } else if (k%6==2)\n    {\n        for (int i=1;i<=n;i++)\n            b[i]=q[i];\n    } else if (k%6==3)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=q[i];\n    } else if (k%6==4)\n    {\n        for (int i=1;i<=n;i++)\n            b[p[i]]=i;\n    } else if (k%6==5)\n    {\n        for (int i=1;i<=n;i++)\n            b[q[i]]=i;\n    } else\n    {\n        for (int i=1;i<=n;i++)\n            tmp1[p[i]]=i,tmp2[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            b[tmp1[i]]=tmp2[i];\n    }\n    for (int i=1;i<=n;i++)\n        ans[i]=i;\n    if (k>1)\n    {\n        --k;\n        int c=k/6;\n        k%=6;\n        for (int i=1;i<=n;i++)\n            tmp1[q[i]]=i;\n        for (int i=1;i<=n;i++)\n            r[i]=p[tmp1[i]];\n        for (int i=1;i<=n;i++)\n            r[i]=q[r[i]];\n        for (int i=1;i<=n;i++)\n            tmp1[p[i]]=i;\n        for (int i=1;i<=n;i++)\n            r[i]=tmp1[r[i]];\n        while (c>0)\n        {\n            if (c%2==1)\n            {\n                for (int i=1;i<=n;i++)\n                    ans[i]=r[ans[i]];\n            }\n            c/=2;\n            for (int i=1;i<=n;i++)\n                tmp1[i]=r[i];\n            for (int i=1;i<=n;i++)\n                r[i]=tmp1[tmp1[i]];\n        }\n    }\n    for (int i=1;i<=n;i++)\n        a[ans[i]]=i;\n    for (int i=1;i<=n;i++)\n        ans[i]=b[ans[i]];\n    for (int i=1;i<=n;i++)\n        ans[i]=a[ans[i]];\n    for (int i=1;i<=n;i++)\n        printf(\"%d \",ans[i]);\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, k, ia[100005], ib[100005];\n\nvector<int> x[4], def;\n\nvector<int> operator + (vector<int> A, vector<int> B) {\n    vector<int> R;\n    for(int i=0;i<n;i++) {\n        R.push_back(A[B[i]]);\n    }\n    return R;\n}\n\nvector<int> calc (vector<int> V, int C) {\n    if(!C) return def;\n    vector<int> R = calc(V, C/2);\n    R = R + R;\n    if(C % 2) R = R + V;\n    return R;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=0;i<n;i++) {\n        int T;\n        scanf(\"%d\",&T);\n        T--;\n        x[0].push_back(T);\n        ia[T] = i;\n    }\n    for(int i=0;i<n;i++) {\n        int T;\n        scanf(\"%d\",&T);\n        T--;\n        x[1].push_back(T);\n        ib[T] = i;\n    }\n    for(int i=0;i<n;i++) {\n        x[2].push_back(ia[i]);\n        x[3].push_back(ib[i]);\n        def.push_back(i);\n    }\n    vector<int> C;\n    if(k == 1) C = x[0];\n    else if(k == 2) C = (x[1]);\n    else if(k == 3) C = (x[1] + x[2]);\n    else if(k == 4) C = (x[1] + x[2] + x[3]);\n    else {\n        int A = (k-5)/6, B = (k-5)%6;\n        C = calc(x[3]+x[2]+x[1]+x[0], A) + x[3];\n        if(B == 1) C = x[0] + C;\n        else if(B == 2) C = x[1] + x[0] + C;\n        else if(B == 3) C = x[1] + x[2] + x[1] + x[0] + C;\n        else if(B == 4) C = x[1] + x[2] + x[2] + x[1] + x[0] + C;\n        else if(B == 5) C = x[1] + x[2] + x[3] + x[2] + x[1] + x[0] + C;\n        C = calc(x[1] + x[2] + x[3] + x[0], A+1) + C;\n    }\n    for(int i=0;i<n;i++) {\n        printf(\"%d \", C[i]+1);\n    }\n    puts(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nstruct info {int a[MAXN]; };\nint n; ll m;\ninfo inv(info a) {\n\tinfo res;\n\tfor (int i = 1; i <= n; i++)\n\t\tres.a[a.a[i]] = i;\n\treturn res;\n}\ninfo unit() {\n\tinfo res;\n\tfor (int i = 1; i <= n; i++)\n\t\tres.a[i] = i;\n\treturn res;\n}\ninfo operator * (info a, info b) {\n\tinfo res;\n\tfor (int i = 1; i <= n; i++)\n\t\tres.a[i] = b.a[a.a[i]];\n\treturn res;\n}\ninfo p, q, r;\ninfo power(info a, ll x) {\n\tif (x == 0) return unit();\n\tif (x < 0) return power(inv(a), -x);\n\tinfo tmp = power(a, x / 2);\n\tif (x % 2 == 0) return tmp * tmp;\n\telse return tmp * tmp * a;\n}\nint main() {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(p.a[i]);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(q.a[i]);\n\twhile (m % 6 != 1) {\n\t\tinfo r = inv(p) * q;\n\t\tp = q, q = r, m--;\n\t}\n\tr = power(inv(q) * p * q * inv(p), m / 6) * power(p, m / 6 + 1);\n\tinfo res = r * p * inv(r);\n\tfor (int i = 1; i <= n; i++)\n\t\tprintf(\"%d \", res.a[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> operator*(const vector<int> &lhs, vector<int> rhs) {\n    for (int &i : rhs)\n        i = lhs[i];\n    return rhs;\n}\nvector<int> inverse(const vector<int> &a) {\n    vector<int> b(a.size());\n    for (int i = 0; i < a.size(); ++i)\n        b[a[i]] = i;\n    return b;\n}\nvector<int> power(vector<int> a, int k) {\n    vector<bool> visited(a.size());\n    for (int i = 0; i < a.size(); ++i) {\n        if (visited[i])\n            continue;\n        vector<int> b;\n        for (int j = i; !visited[j]; visited[j] = true, j = a[j])\n            b.push_back(j);\n        for (int j = 0; j < b.size(); ++j)\n            a[b[j]] = b[(j + k) % b.size()];\n    }\n    return a;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    --k;\n    vector<int> p(n), q(n);\n    for (int &i : p) {\n        cin >> i;\n        --i;\n    }\n    for (int &i : q) {\n        cin >> i;\n        --i;\n    }\n    vector<int> a, b;\n    a = power(q * inverse(p) * inverse(q) * p, k / 6);\n    vector<vector<int>> c(6);\n    c[0] = a * p * inverse(a);\n    c[1] = a * q * inverse(a);\n    for (int i = 2; i < 6; ++i)\n        c[i] = c[i - 1] * inverse(c[i - 2]);\n    for (int i : c[k % 6])\n        cout << i + 1 << \" \\n\"[i == c[k % 6].back()];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &x) {\n\tstatic char ch; \n\twhile (!isdigit(ch = getchar())); \n\tx = ch - '0'; \n\twhile (isdigit(ch = getchar()))\n\t\tx = x * 10 + ch - '0'; \n}\n\nconst int MaxN = 1e5 + 5; \n\nint n, K; \nstruct per {\n\tint a[MaxN];\n\n\tinline void scan() {\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tread(a[i]); \n\t\t}\n\t}\n\tinline void print() {\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tprintf(\"%d%c\", a[i], \" \\n\"[i == n]); \n\t\t}\n\t}\n\n\tinline per inv() {\n\t\tper res; \n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tres.a[a[i]] = i; \n\t\t}\n\t\treturn res; \n\t}\n\tinline per operator * (const per &rhs) const {\n\t\tper res; \n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tres.a[i] = a[rhs.a[i]]; \n\t\t}\n\t\treturn res; \n\t}\n\tinline per operator ^ (int p) const {\n\t\tper res; \n\n\t\tstatic bool vis[MaxN]; \n\t\tfor (int i = 1; i <= n; ++i) vis[i] = false; \n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (!vis[i]) {\n\t\t\t\tint x = i, len = 0; \n\t\t\t\tstd::vector<int> cur; \n\n\t\t\t\twhile (!vis[x]) {\n\t\t\t\t\tcur.push_back(x); \n\t\t\t\t\tvis[x] = true, x = a[x], ++len; \n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j < len; ++j) {\n\t\t\t\t\tres.a[cur[j]] = cur[(j + p) % len]; \n\t\t\t\t}\n\t\t\t}\n\t\treturn res; \n\t}\n}a[10], A, B; \n\nint main() {\n#ifdef orzczk\n\tfreopen(\"permutation.in\", \"r\", stdin); \n#endif\n\t\n\tread(n), read(K); \n\n\ta[1].scan(), a[2].scan(); \n\tfor (int i = 3; i <= 6; ++i) {\n\t\ta[i] = a[i - 1] * a[i - 2].inv(); \n\t}\n\t\n\tA = a[2] * a[1].inv() * a[2].inv() * a[1]; \n\tB = A.inv(); \n\n\tint t = (K - 1) / 6; \n\t((A ^ t) * a[K - 6 * t] * (B ^ t)).print(); \n\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// 代表的関数\nvector<int> idv, p, q, pi, qi; // pi, qi は p, q の逆写像, idv は恒等写像\n\n// 逆写像計算\nvector<int> inv(const vector<int> &v) {\n    int N = v.size();\n    vector<int> res(N);\n    for (int i = 0; i < N; ++i) res[v[i]] = i;\n    return res;\n}\n\n// 合成写像計算\ninline vector<int> operator +(const vector<int> &a, const vector<int> &b) {\n    int N = a.size();\n    vector<int> res(N);\n    for (int i = 0; i < N; ++i) res[i] = a[b[i]];\n    return res;\n}\n\n// r_k\nvector<vector<int> > beki; // beki[i] := r[4×2^i], 前計算しておく\nvector<int> calc(long long k) {\n    int num = k / 4;\n    int r = k % 4;\n    vector<int> amari = idv;\n    if (r == 0) amari = idv;\n    else if (r == 1) amari = pi;\n    else if (r == 2) amari = pi + qi;\n    else if (r == 3) amari = pi + qi + p;\n    auto syuki = idv;\n    for (int i = 0; i < 35; ++i) if (num & (1LL<<i)) syuki = syuki + beki[i];\n    return syuki + amari;\n}\n\n// 解く\nvector<int> solve(long long K) {\n    if (K == 1) return p;\n    if (K == 2) return q;\n    if (K == 3) return q + pi;\n    long long a, b;\n    long long k = K / 3;\n    if (K % 3 == 0) a = k*2-1, b = k*2-3;\n    else if (K % 3 == 1) a = k*2, b = k*2-3;\n    else a = k*2, b = k*2-1;\n    auto res = q + calc(a) + inv(calc(b)) + qi;\n    return res;\n}\n\nint main() {\n    // 入力, 恒等写像, 逆写像\n    int N, K; cin >> N >> K;\n    idv.resize(N); p.resize(N); q.resize(N);\n    for (int i = 0; i < N; ++i) idv[i] = i;\n    for (int i = 0; i < N; ++i) cin >> p[i], --p[i];\n    for (int i = 0; i < N; ++i) cin >> q[i], --q[i];\n    pi = inv(p);\n    qi = inv(q);\n\n    // 繰り返し構造のダブリング前処理\n    auto pqpq = pi + qi + p + q;\n    beki.resize(35);\n    beki[0] = pqpq;\n    for (int i = 0; i+1 < 35; ++i) beki[i+1] = beki[i] + beki[i];\n\n    // 解く\n    auto res = solve(K);\n    for (auto v : res) cout << v + 1 << \" \";\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef complex<long double> cd;\n\nconst int maxn = 2e5 + 5;\n\nint p[maxn], q[maxn], rp[maxn], rq[maxn];\nint n;\nint rA[maxn], A[maxn], B[maxn];\n\nvoid power(int b){\n\tif (b == 0)\n\t\treturn;\n\tpower(b / 2);\n\tfor (int i = 1; i <= n; i++)\n\t\tB[i] = A[A[i]];\n\tfor (int i = 1; i <= n; i++)\n\t\tA[i] = B[i];\n\tif (b & 1){\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = A[q[rp[rq[p[i]]]]];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = B[i];\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint k;\n\tcin >> n >> k;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> p[i];\n\t\trp[p[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> q[i];\n\t\trq[q[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tA[i] = i;\n\tpower((k - 1) / 6);\n\tif (k % 6 == 4){\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = A[q[i]];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = B[i];\n\t}\n\tif (k % 6 == 5 or k % 6 == 0){\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = A[q[rp[i]]];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = B[i];\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\trA[A[i]] = i;\n\tk %= 6;\n\tif (k == 1)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = p[i];\n\telse if (k == 2)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = q[i];\n\telse if (k == 3)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = q[rp[i]];\n\telse if (k == 4)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = rp[i];\n\telse if (k == 5)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = rq[i];\n\telse\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = rq[p[i]];\n\tfor (int i = 1; i <= n; i++)\n\t\tcout << A[B[rA[i]]] << \" \";\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cassert>\n#include<cmath>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<bitset>\n#include<vector>\n#include<time.h>\n#include<algorithm>\nusing namespace std;\n#define REP(i,x,y) for(int i=x;i<=y;i++)\n#define rep(i,n) REP(i,1,n)\n#define rep0(i,n) REP(i,0,n-1)\n#define repG(i,x) for(int i=pos[x];~i;i=e[i].next)\n#define ll long long\n#define db double\nconst int N=100007;\nconst int INF=1e9+7;\nint n,k;\nint p[5][N],v1[N][40],v2[N][40];\nint calc1(int x,int s){\n\tint nw=0;\n\twhile(s){\n\t\tif(s&1)x=v1[x][nw];\n\t\ts>>=1;\n\t\tnw++;\n\t}\n\treturn x;\n}\nint calc2(int x,int s){\n\tint nw=0;\n\twhile(s){\n\t\tif(s&1)x=v2[x][nw];\n\t\ts>>=1;\n\t\tnw++;\n\t}\n\treturn x;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\trep(o,2)rep(i,n)scanf(\"%d\",&p[o][i]);\n\trep(i,n){\n\t\tp[3][p[2][i]]=i;\n\t\tp[4][p[1][i]]=i;\n\t}\n\tif(k<3){\n\t\trep(i,n)printf(\"%d \",p[k][i]);\n\t\tputs(\"\");\n\t\treturn 0;\n\t}\n\trep(i,n)v1[i][0]=p[4][p[2][p[1][p[3][i]]]];\n\trep(i,35)rep(j,n)v1[j][i]=v1[v1[j][i-1]][i-1];\n\trep(i,n)v2[i][0]=p[2][p[4][p[3][p[1][i]]]];\n\trep(i,35)rep(j,n)v2[j][i]=v2[v2[j][i-1]][i-1];\n\tint hh=(k-2)/3*4+(k-2)%3+1;\n\tint o1=(hh-1)/2;\n\tint o2=hh-o1;\n\trep(i,n){\n\t\tint t=calc1(i,o1/4);\n\t\tif(o1%4>0){\n\t\t\tt=p[3][t];\n\t\t\tif(o1%4>1){\n\t\t\t\tt=p[1][t];\n\t\t\t\tif(o1%4>2)t=p[2][t];\n\t\t\t}\n\t\t}\n\t\tif(o2%4>0){\n\t\t\tif(o2%4>1){\n\t\t\t\tif(o2%4>2)t=p[3][t];\n\t\t\t\tt=p[4][t];\n\t\t\t}\n\t\t\tt=p[2][t];\n\t\t}\n\t\tprintf(\"%d \",calc2(t,o2/4));\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nint p[2][100001],q[2][100001],n,k;\nint tem[100001],A[100001],ans[100001],con[100001],top,f[6][100001];\nbool vis[100001];\nvoid mul(int *a,int *b,int *c){\n\tfor(int i=1;i<=n;i++)tem[i]=a[b[i]];\n\tfor(int i=1;i<=n;i++)c[i]=tem[i];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[0][i]),p[1][p[0][i]]=i;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&q[0][i]),q[1][q[0][i]]=i;\n\tfor(int i=1;i<=n;i++)A[i]=ans[i]=i;\n\tmul(A,q[0],A);\n\tmul(A,p[1],A);\n\tmul(A,q[1],A);\n\tmul(A,p[0],A);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]){\n\t\t\tcon[(top=0)++]=i;\n\t\t\tint Tem=A[i];\n\t\t\tvis[i]=1;\n\t\t\twhile(Tem!=i){\n\t\t\t\tvis[Tem]=1;\n\t\t\t\tcon[top++]=Tem;\n\t\t\t\tTem=A[Tem];\n\t\t\t}\n\t\t\tfor(int i=0;i<top;i++)\n\t\t\t\ttem[con[i]]=con[(i+k/6)%top];\n\t\t}\n\tfor(int i=1;i<=n;i++)A[i]=tem[i];\n\tmul(ans,A,ans);\n\tmemcpy(f[1],p[0],sizeof p[0]);\n\tmemcpy(f[2],q[0],sizeof q[0]);\n\tfor(int i=3;i<=(k-1)%6+1;i++){\n\t\tfor(int j=1;j<=n;j++)tem[f[i-2][j]]=j;\n\t\tfor(int j=1;j<=n;j++)f[i-2][j]=tem[j];\n\t\tmul(f[i-1],f[i-2],f[i]);\n\t}\n\tmul(ans,f[(k-1)%6+1],ans);\n\tfor(int i=1;i<=n;i++)tem[A[i]]=i;\n\tfor(int i=1;i<=n;i++)A[i]=tem[i];\n\tmul(ans,A,ans);\n\tfor(int i=1;i<=n;i++)printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nInt n;\nvector<Int> mg(vector<Int> a,vector<Int> b){\n  vector<Int> c(n);\n  for(Int i=0;i<n;i++) c[i]=a[b[i]];\n  return c;\n}\n\nvector<Int> vpow(vector<Int> a,Int k){\n  vector<Int> c(n);\n  iota(c.begin(),c.end(),0);\n  while(k){\n    if(k&1) c=mg(c,a);\n    a=mg(a,a);\n    k>>=1;\n  }\n  return c;\n}\n\nvoid print(vector<Int> v){\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<v[i]+1;\n  }\n  cout<<endl;\n}\n\nsigned main(){\n  Int k;\n  cin>>n>>k;\n  vector<Int> p(n),q(n),x(n),y(n);\n  for(Int i=0;i<n;i++) cin>>p[i];\n  for(Int i=0;i<n;i++) cin>>q[i];\n  for(Int i=0;i<n;i++){\n    p[i]--;q[i]--;\n    x[p[i]]=i;\n    y[q[i]]=i;\n  }\n  k--;\n  if(k==0){\n    print(p);\n    return 0;\n  }\n  if(k==1){\n    print(q);\n    return 0;\n  }  \n  auto qxyp=mg(q,mg(x,mg(y,p)));\n  auto xqpy=mg(x,mg(q,mg(p,y)));\n\n  vector<vector<Int> > vs;\n  vs.emplace_back(mg(q,mg(p,y)));\n  vs.emplace_back(q);\n  vs.emplace_back(mg(q,x));\n  vs.emplace_back(mg(q,mg(x,y)));\n  vs.emplace_back(y);\n  vs.emplace_back(mg(p,y));\n\n  Int a=(k+2)/6,b=(k-1)/6,c=k%6;\n  auto ans=mg(vpow(qxyp,a),mg(vs[c],vpow(xqpy,b)));\n\n  print(ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 2e5 + 5;\n\n/*vector<char> s[3];\n\nvoid output(int ind) {\n\tREP(i, 0, SZ(s[ind])) {\n\t\tputchar(s[ind][i]);\n\t}\n\tputchar('\\n');\n}*/\n\nint n;\nint A[MAXN], B[MAXN], a[MAXN], b[MAXN];\nint BabA[MAXN], aBAb[MAXN], _left[MAXN], _right[MAXN];\nint ans[MAXN];\n\nvoid output(int *per) {\n\tREP(i, 0, n) {\n\t\tprintf(\"%d \", per[i] + 1);\n\t}\n\tputchar('\\n');\n}\n\nvoid mul(int * per1, int * per2, int *res) {\n\tREP(i, 0, n) {\n\t\tres[i] = per2[per1[i]];\n\t}\n}\n\nint tmp_per[MAXN];\nvoid mul_by(int *per, int *per_by) {\n\tREP(i, 0, n) {\n\t\ttmp_per[i] = per[i];\n\t}\n\tmul(tmp_per, per_by, per);\n}\n\nint pow_per[MAXN];\nvoid pow_mod(int * per, int st, int *res) {\n\tREP(i, 0, n) {\n\t\tres[i] = i;\n\t\tpow_per[i] = per[i];\n\t}\n\tfor(; st; st /= 2) {\n\t\tif (st & 1) {\n\t\t\tmul_by(res, pow_per);\n\t\t}\n\t\tREP(i, 0, n) {\n\t\t\ttmp_per[i] = pow_per[i];\n\t\t}\n\t\tmul(tmp_per, tmp_per, pow_per);\n\t}\n}\n\nvoid solve(){\n\t/*s[1].pb('A');\n\ts[2].pb('B');\n\toutput(1);\n\toutput(2);\n\tREP(i, 3, 30) {\n\t\tint ind = i % 3, ind1 = (i + 1) % 3, ind2 = (i + 2) % 3;\n\t\ts[ind] = s[ind2];\n\t\tfor(int i = SZ(s[ind1]) - 1; i >= 0; i--) {\n\t\t\tchar cur = s[ind1][i];\n\t\t\tif (cur == s[ind].back()) {\n\t\t\t\ts[ind].pop_back();\n\t\t\t} else {\n\t\t\t\tif (cur <= 'B') {\n\t\t\t\t\tcur += 'b' - 'B';\n\t\t\t\t} else {\n\t\t\t\t\tcur -= 'b' - 'B';\n\t\t\t\t}\n\t\t\t\ts[ind].pb(cur);\n\t\t\t}\n\t\t}\n\t\toutput(ind);\n\t}*/\n\tint k;\n\tscanf(\"%d%d\", &n, &k);\n\tREP(i, 0, n) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tA[i]--;\n\t\ta[A[i]] = i;\n\t}\n\tREP(i, 0, n) {\n\t\tscanf(\"%d\", &B[i]);\n\t\tB[i]--;\n\t\tb[B[i]] = i;\n\t}\n\t\n\tif (k == 1) {\n\t\toutput(A);\n\t\treturn;\n\t}\n\tif (k == 2) {\n\t\toutput(B);\n\t\treturn;\n\t}\n\t\n\tint l1 = (k / 3 * 2 + k % 3);\n\tint l2 = ((k - 4) / 3 * 2 + (k - 4) % 3);\n\tif (k <= 4) {\n\t\tl2 = 0;\n\t}\n\t\n\tREP(i, 0, n) {\n\t\tBabA[i] = A[i];\n\t}\n\tmul_by(BabA, b);\n\tmul_by(BabA, a);\n\tmul_by(BabA, B);\n\t\n\tREP(i, 0, n) {\n\t\taBAb[i] = b[i];\n\t}\n\tmul_by(aBAb, A);\n\tmul_by(aBAb, B);\n\tmul_by(aBAb, a);\n\t\n\tpow_mod(BabA, l1 / 4, _left);\n\tpow_mod(aBAb, l2 / 4, _right);\n\t\n\tREP(i, 0, n) {\n\t\tans[i] = _right[i];\n\t}\n\tif (l2 % 4 >= 1) {\n\t\tmul_by(ans, b);\n\t}\n\tif (l2 % 4 >= 2) {\n\t\tmul_by(ans, A);\n\t}\n\tif (l2 % 4 >= 3) {\n\t\tmul_by(ans, B);\n\t}\n\tif (l1 % 4 >= 3) {\n\t\tmul_by(ans, b);\n\t}\n\tif (l1 % 4 >= 2) {\n\t\tmul_by(ans, a);\n\t}\n\tif (l1 % 4 >= 1) {\n\t\tmul_by(ans, B);\n\t}\n\tmul_by(ans, _left);\n\toutput(ans);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nvi mul(vi p, vi q){\n\tvi res(sz(p));\n\trep(i,0,sz(p)) res[i] = p[q[i]];\n\treturn res;\n}\n\nvi inv(vi p){\n\tvi res(sz(p));\n\trep(i,0,sz(p)) res[p[i]] = i;\n\treturn res;\n}\n\nvi pow(vi p, int e){\n\tvi res(sz(p));\n\trep(i,0,sz(p)) res[i] = i;\n\twhile(e){\n\t\tif(e%2) res = mul(res, p);\n\t\tp = mul(p,p);\n\t\te /= 2;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n, k;\n\tcin >> n >> k;\n\t--k;\n\n\tvi ps(n), qs(n);\n\ttrav(x, ps) cin >> x, --x;\n\ttrav(x, qs) cin >> x, --x;\n\n\tvi com = mul(qs, inv(ps));\n\tcom = mul(com, inv(qs));\n\tcom = mul(com, ps);\n\tcom = pow(com, k/6);\n\tk %= 6;\n\trep(_,0,k){\n\t\tps = mul(qs, inv(ps));\n\t\tswap(ps,qs);\n\t}\n\tvi ans = mul(com, mul(ps, inv(com)));\n\ttrav(x, ans) cout << x+1 << ' ';\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+6;//!\nstruct permutain{\n    int a[N];\n    permutain(){memset(a,0,sizeof a);}\n    int& operator [](int x){return a[x];}\n}p,q,ip,iq,A,B,ans;\nint n,k;\npermutain operator *(permutain a,permutain b){\n    permutain c;\n    for(int i=1;i<=n;i++)\n        c[i]=a[b[i]];\n    return c;\n}\npermutain inv(permutain a){\n    permutain b;\n    for(int i=1;i<=n;i++)\n        b[a[i]]=i;\n    return b;\n}\npermutain operator ^(permutain a,int b){\n    permutain c;\n    for(int i=1;i<=n;i++)\n        c[i]=i;\n    while(b){\n        if(b&1)\n            c=c*a;\n        a=a*a;\n        b>>=1;\n    }\n    return c;\n}\nvoid Print(permutain x){\n    for(int i=1;i<=n;i++)\n        printf(\"%d \",x.a[i]);\n    puts(\"\");\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&p[i]);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&q[i]);\n    ip=inv(p);\n    iq=inv(q);\n    int f=(k-1)/6,g=k-f*6;\n    permutain h=q*ip*iq*p;\n    A=h^f;\n    if(g==1){\n        B=p;\n    }\n    else if(g==2){\n        B=q;\n    }\n    else if(g==3){\n        B=q*ip;\n    }\n    else if(g==4){\n        A=A*q;\n        B=ip;\n    }\n    else if(g==5){\n        A=A*q*ip;\n        B=iq;\n    }\n    else{\n        A=A*q*ip;\n        B=iq*p;\n    }\n    ans=A*B*inv(A);\n    Print(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main () {\n  int N;\n  long long K;\n  cin >> N >> K;\n  vector<vector<int>>B(6,vector<int>(N + 1));\n  vector<vector<int>>A(6,vector<int>(N + 1));\n  vector<int>key(N + 1);\n  vector<int>an(N + 1);\n  vector<int>an_(N + 1);\n  vector<int>ans(N + 1);\n  for (int i = 1; i <= N; i ++) {\n    cin >> B[1][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    cin >> B[2][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    B[3][B[1][i]] = B[2][i];\n    B[4][B[1][i]] = i;\n    B[5][B[2][i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    B[0][B[4][i]] = B[5][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    A[1][i] = i;\n    A[2][i] = i;\n    A[3][i] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    A[4][i] = B[2][i];\n    A[5][i] = B[3][i];\n    A[0][i] = B[3][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    key[i] = B[2][B[4][B[5][B[1][i]]]];\n  }\n  int jun = (int)K % 6;\n  int ju = (int)K / 6;\n  for (int i = 1; i <= N; i ++) {\n    an[i] = A[jun][i];\n  }\n  for (int i = 0; i < ju; i ++) {\n    an[i] = key[an[i]];\n  }\n  for (int i = 1; i <= N; i ++) {\n    an_[an[i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    ans[i] = an[B[jun][an_[i]]];\n  }\n  for (int i = 1; i < N; i ++) {\n    cout << ans[i] << ' ';\n  }\n  cout << ans[N] << endl;\n}\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(c)      int(c.size())\n#define rep(i,a,b) for (int i=a; i<(b); ++i)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); --i)\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\n\nint const MAXN=110000;\n\nvi pneg(const vi &p) {\n\tvi P(sz(p));\n\trep(i,0,sz(p)) P[p[i]]=i;\n\treturn P;\n}\n\nvoid pmul(const vi &p,const vi &q,vi &r) {\n\tstatic int tmp[MAXN];\n\trep(i,0,sz(p)) tmp[i]=p[q[i]];\n\trep(i,0,sz(p)) r[i]=tmp[i];\n}\n\nvi ppow(vi p, int n) {\n\tvi r(sz(p));\n\trep(i,0,sz(p)) r[i]=i;\n\twhile (n>0) {\n\t\tif (n%2) pmul(r,p,r);\n\t\tpmul(p,p,p);\n\t\tn/=2;\n\t}\n\treturn r;\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(10);\n\n\tint N,K;\n\tcin>>N>>K;\n\tK--;\n\t\n\tvi p(N),q(N);\n\trep(i,0,N) {\n\t\tcin>>p[i];\n\t\tp[i]--;\n\t}\n\trep(i,0,N) {\n\t\tcin>>q[i];\n\t\tq[i]--;\n\t}\n\t\n\tvi P=pneg(p);\n\tvi Q=pneg(q);\n\t\n\t// a=qPQp\n\tvi a(N);\n\tpmul(q,P,a);\n\tpmul(a,Q,a);\n\tpmul(a,p,a);\n\t\n\t// a=a^(K/6)\n\ta=ppow(a,K/6);\n\t\n\tvi b(N);\n\tswitch (K%6) {\n\t\tcase 0:\n\t\t\tb=p;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tb=q;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t// b=qP\n\t\t\tpmul(q,P,b);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t// b=qPQ\n\t\t\tpmul(q,P,b);\n\t\t\tpmul(b,Q,b);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t// b=qPQpQ\n\t\t\tpmul(q,P,b);\n\t\t\tpmul(b,Q,b);\n\t\t\tpmul(b,p,b);\n\t\t\tpmul(b,Q,b);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t// b=qPQppQ\n\t\t\tpmul(q,P,b);\n\t\t\tpmul(b,Q,b);\n\t\t\tpmul(b,p,b);\n\t\t\tpmul(b,p,b);\n\t\t\tpmul(b,Q,b);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t}\n\t\n\tvi res(N);\n\tpmul(a,b,res);\n\tpmul(res,pneg(a),res);\n\t\n\trep(i,0,N) cout<<res[i]+1<<\" \\n\"[i+1==N];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nauto dot(const std::vector<int> &p, const std::vector<int> &q) {\n    std::vector<int> ret(p.size());\n    for (int i = 0; i < p.size(); i++) ret[i] = p[q[i]];\n    return ret;\n}\n\nauto inv(const std::vector<int> &p) {\n    std::vector<int> ret(p.size());\n    for (int i = 0; i < p.size(); i++) ret[p[i]] = i;\n    return ret;\n}\n\nauto f(const std::vector<int> &p, const std::vector<int> &q) {\n    return dot(q, inv(p));\n}\n\nstd::vector<int> operator*(const std::vector<int> &lhs, const std::vector<int> &rhs) {\n    return dot(lhs, rhs);\n}\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n    std::vector<int> p(n), q(n);\n    for (int i = 0; i < n; i++) { std::cin >> p[i]; p[i]--; }\n    for (int i = 0; i < n; i++) { std::cin >> q[i]; q[i]--; }\n\n    std::vector<int> ret(n);\n    for (int i = 0; i < n; i++) ret[i] = i;\n    auto m = q * inv(p) * inv(q) * p;\n    for (int i = 0, t = (k - 1) / 6; (1 << i) <= t; i++) {\n        if (t & (1 << i)) {\n            ret = ret * m;\n        }\n        m = m * m;\n    }\n    int r = (k - 1) % 6;\n    if (r >= 3) ret = ret * q;\n    if (r >= 4) ret = ret * inv(p);\n\n    std::vector<int> b;\n    if (r == 0) b = p;\n    else if (r == 1) b = q;\n    else if (r == 2) b = q * inv(p);\n    else if (r == 3) b = inv(p);\n    else if (r == 4) b = inv(q);\n    else b = inv(q) * p;\n\n    ret = ret * b * inv(ret);\n    for (int i = 0; i < n; i++) std::cout << ret[i] + 1 << \" \";\n    std::cout << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define FIO \"agc31D\"\nusing namespace std;\n\nconst int N=1e5+5;\n\nint n,k;\n\nstruct per{\n  int a[N];\n  inline void rd(){\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n  }\n\n  inline int& operator [](int x){return a[x];}\n  inline const int& operator [](const int &x)const {return a[x];}\n\n  inline per inv(){\n    static per ret;\n    for(int i=1;i<=n;i++)ret[a[i]]=i;\n    return ret;\n  }\n\n  inline per operator *(const per &b)const{\n    static per ret;\n    for(int i=1;i<=n;i++)ret[i]=a[b[i]];\n    return ret;\n  }\n  inline per& operator *=(const per &b){return *this=*this*b;}\n  inline void set(){\n    for(int i=1;i<=n;i++)a[i]=i;\n  }\n  inline void out(){\n    for(int i=1;i<=n;i++)printf(\"%d%c\",a[i],i^n?' ':'\\n');\n    cout.flush();\n  }\n  inline per operator ^(int b)const{\n    static per a=*this,ret;\n    ret.set();\n    for(;b;b>>=1,a*=a)\n      if(b&1)ret*=a;\n    return ret;\n  }\n}p,q,ip,iq,a[7],cur;\n\nint main(){\n  scanf(\"%d%d\",&n,&k);\n  p.rd();\n  q.rd();\n  ip=p.inv();\n  iq=q.inv();\n  a[1]=p;a[2]=q;\n  for(int i=3;i<=6;i++)a[i]=a[i-1]*(a[i-2].inv());\n  cur=(q*ip*iq*p)^((k-1)/6);\n  (cur*a[(k-1)%6+1]*(cur.inv())).out();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define FOF(i,a,b) for(int i=a;i< b;i++)\nusing namespace std;\nconst int N=100100;\nint n,K;\nstruct subs{\n\tint v[N];\n\tsubs iv(){\n\t\tsubs x;\n\t\tFOR(i,1,n) x.v[v[i]]=i;\n\t\treturn x;\n\t}\n\tsubs operator * (const subs&x)const{\n\t\tsubs y;\n\t\tFOR(i,1,n) y.v[i]=v[x.v[i]];\n\t\treturn y;\n\t}\n\tsubs pw(int K){\n\t\tsubs x;\n\t\tstatic int vi[N],s[N];\n\t\tFOR(i,1,n)if(!vi[i]){\n\t\t\tint m=0;\n\t\t\tfor(int u=i;!vi[u];u=v[u]) vi[u]=1,s[m++]=u;\n\t\t\tFOF(j,0,m) x.v[s[j]]=s[(j+K)%m];\n\t\t}\n\t\treturn x;\n\t}\n}p,q,r,w,a[7];\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&K);K--;\n\tFOR(i,1,n) scanf(\"%d\",&p.v[i]);\n\tFOR(i,1,n) scanf(\"%d\",&q.v[i]);\n\tr=q*p.iv()*q.iv()*p;\n\ta[0]=p;a[1]=q;\n\tFOR(i,2,5) a[i]=a[i-1]*a[i-2].iv();\n\tr=r.pw(K/6);\n\tw=r*a[K%6]*r.iv();\n\tFOR(i,1,n) cout<<w.v[i]<<' ';cout<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\nconst int N = 1e5 + 5;\nstruct ZHI {\n\tint n, per[N];\n\tZHI() {}\n\tZHI operator * (const ZHI &d) {\n\t\tZHI ret;\n\t\tret.n = n;\n\t\tfor (int i = 1; i <= n; ++i) ret.per[i] = per[d.per[i]];\n\t\treturn ret;\n\t}\n\tZHI inv() {\n\t\tZHI ret;\n\t\tret.n = n;\n\t\tfor (int i = 1; i <= n; ++i) ret.per[per[i]] = i;\n\t\treturn ret;\n\t}\n\tvoid print() {\n\t    for (int i = 1; i <= n; ++i) printf(\"%d \", per[i]);\n\t    printf(\"\\n\");\n\t}\n} p, q, base[2], ho[6];\nZHI ksm(ZHI x, int y) {\n\tZHI ret;\n\tret.n = x.n;\n\tfor (int i = 1; i <= x.n; ++i) ret.per[i] = i;\n\tfor (; y; y >>= 1, x = x * x)\n\t\tif (y & 1) ret = ret * x;\n\treturn ret;\n}\nint n, k;\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tp.n = n, q.n = n;\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &p.per[i]);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &q.per[i]);\n\tho[0] = q.inv() * p;\n\tho[1] = p;\n\tfor (int i = 2; i <= 5; ++i) ho[i] = ho[i - 1] * ho[i - 2].inv();\n\tbase[0] = q * p.inv() * q.inv() * p;\n\tbase[1] = base[0].inv();\n\tZHI ans = ksm(base[0], k / 6) * ho[k % 6] * ksm(base[1], k / 6);\n\tans.print();\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end());\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint=vector<int>;\nusing vvint=vector<vint>;\nusing pint=pair<int, int>;\nusing vpint=vector<pint>;\nconstexpr double pi = 3.1415926535897932384626433832795028;\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\ninline int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ninline int lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> using priority_queue_rev=priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, const T2 &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, const T2 &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct Setup {\n    static constexpr int PREC = 20;\n    Setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nstruct Permutation {\n    const int n;\n    std::vector<int> data;\n    Permutation(int n) : n(n), data(n) { for (int i = 0; i < n; i++) { data[i] = i; }}\n    Permutation(std::vector<int> &src) : n(src.size()), data(src) {}\n    bool next() { return std::next_permutation(data.begin(), data.end()); }\n    bool prev() { return std::prev_permutation(data.begin(), data.end()); }\n    bool operator==(const Permutation &rhs) const { return data == rhs.data; }\n    bool operator!=(const Permutation &rhs) const { return data != rhs.data; }\n    int operator[](int i) const { return data[i]; }\n    Permutation &operator*=(const Permutation &rhs) {\n        std::vector<int> tmp(data);\n        for (int i = 0; i < n; i++) { data[i] = tmp[rhs[i]]; }\n        return *this;\n    }\n    Permutation &operator/=(const Permutation &rhs) { return *this *= rhs.inv(); }\n    Permutation operator*(const Permutation &rhs) const { return Permutation(*this) *= rhs; }\n    Permutation operator/(const Permutation &rhs) const { return Permutation(*this) /= rhs; }\n    Permutation inv() const {\n        std::vector<int> ret(n);\n        for (int i = 0; i < n; i++) { ret[data[i]] = i; }\n        return ret;\n    }\n    Permutation pow(long long m) const {\n        std::vector<int> ret(n);\n        std::vector<bool> used(n);\n        for (int i = 0; i < n; i++) {\n            if (used[i]) { continue; }\n            std::vector<int> cyc;\n            int cur = i;\n            do {\n                used[cur] = true;\n                cyc.push_back(cur);\n                cur = data[cur];\n            } while (cur != i);\n            for (int j = 0; j < cyc.size(); j++) { ret[cyc[j]] = cyc[(j + m) % cyc.size()]; }\n        }\n        return ret;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Permutation &rhs) {\n        os << \"{\";\n        for (int i = 0; i < rhs.n; i++) { os << rhs[i] << (i + 1 != rhs.n ? \", \" : \"\"); }\n        os << \"}\";\n        return os;\n    }\n};\n\nint N, K;\nsigned main() {\n    cin >> N >> K;\n    vint p(N), q(N);\n    rep(i, N) { cin >> p[i], q[i]--; }\n    rep(i, N) { cin >> q[i], q[i]--; }\n    Permutation P(p), Q(q);\n    Permutation O(N);\n    int k = (K - 1) % 6;\n    if (k == 0) { O *= P; }\n    else if (k == 1) { O *= Q; }\n    else if (k == 2) { O *= Q / P; }\n    else if (k == 3) { O *= Q / P / Q; }\n    else if (k == 4) { O *= Q / P / Q * P / Q; }\n    else if (k == 5) { O *= Q / P / Q * P * P / Q; }\n    Permutation S = (Q / P / Q * P).pow((K - 1) / 6);\n    Permutation A = S * O / S;\n    rep(i, N) { cout << A[i] + 1 << endl; }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define MN 101000\n\nint n, k;\n\nstruct xxx{\n\tint a[MN];\n}g, G, p, q, f[7];\n\nxxx inv(xxx a)\n{\n\txxx c;\n\tfor(int i = 1; i <= n; i++) c.a[a.a[i]] = i;\n\treturn c;\n}\n\nxxx mul(xxx a, xxx b)\n{\n\txxx c;\n\tfor(int i = 1; i <= n; i++) c.a[i] = b.a[a.a[i]];\n\treturn c;\n}\n\nxxx init()\n{\n\txxx a;\n\tfor(int i = 1; i <= n; i++) a.a[i] = i;\n\treturn a;\n}\n\nxxx qpow(xxx x, int p)\n{\n\txxx ans; ans = init();\n\tfor(; p; p >>= 1, x = mul(x, x)) if(p & 1) ans = mul(ans, x);\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d\", &p.a[i]);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d\", &q.a[i]);\n\tg = mul(mul(mul(inv(q), p), q), inv(p)); G = inv(g);\n\tf[0] = init(); f[1] = p; f[2] = q;\n\tfor(int i = 3; i <= 6; i++) \n\t\tf[i] = mul(inv(f[i - 2]), f[i - 1]);\n\txxx ans = mul(mul(qpow(g, k / 6 - (k % 6 == 0)), f[k % 6 == 0 ? 6 : k % 6]), qpow(G, k / 6 - (k % 6 == 0)));\n\tfor(int i = 1; i <= n; i++) printf(\"%d \", ans.a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n#ifdef LOCAL\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else \n#define dump(x) true\n#endif\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nV<int> inv(const V<int>& a) {\n\tV<int> res(a.size());\n\trep(i, a.size()) {\n\t\tres[a[i]] = i;\n\t}\n\treturn res;\t\n}\n\nV<int> comp(const V<int>& a, const V<int>& b) { // a * b\n\tV<int> res(a.size());\n\trep(i, a.size()) {\n\t\tres[i] = a[b[i]];\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N, K; cin >> N >> K;\n\tV<int> p(N), q(N);\n\trep(i, N) {\n\t\tcin >> p[i], --p[i];\n\t}\n\trep(i, N) {\n\t\tcin >> q[i], --q[i];\n\t}\n\n\tV<int> id(N); //mod 6\n\tiota(ALL(id), 0);\n\n\t{\n\t\tint cyc = (K - 1) / 6;\n\t\tV<int> base = comp(inv(q), p);\n\t\tbase = comp(inv(p), base);\n\t\tbase = comp(q, base);\n\n\t\twhile (cyc > 0) {\n\t\t\tif (cyc & 1) {\n\t\t\t\tid = comp(base, id);\n\t\t\t}\n\t\t\tbase = comp(base, base);\n\t\t\tcyc /= 2;\n\t\t}\n\t}\n\n\tint rem = (K - 1) % 6;\n\tp = comp(id, p);\n\tp = comp(p, inv(id));\n\tq = comp(id, q);\n\tq = comp(q, inv(id));\n\n\trep(i, rem) {\n\t\tV<int> nx = comp(q, inv(p));\n\t\tp = q;\n\t\tq = nx;\n\t}\n\n\trep(i, N) {\n\t\tprintf(\"%d%c\", p[i] + 1, i == N-1 ? '\\n' : ' ');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=1e5+100;\nstruct node{\n\tint a[N];\n};int n;\nnode cheng(node n1,node n2){\n\tnode no;\n\tfor(int i=1;i<=n;i++) no.a[i]=n2.a[n1.a[i]];\n\treturn no;\n}\nnode ni(node n1){\n\tnode no;\n\tfor(int i=1;i<=n;i++) no.a[n1.a[i]]=i;\n\treturn no;\n}\nnode mi(node x,int t){\n\tnode d;\n\tfor(int i=1;i<=n;i++) d.a[i]=i;\n\twhile(t){\n\t\tif(t%2) d=cheng(d,x);\n\t\tx=cheng(x,x);t/=2;\n\t}\n\treturn d;\n}\nint main()\n{\n\tint K;\n\tscanf(\"%d%d\",&n,&K);\n\tnode n1,n2;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&n1.a[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&n2.a[i]);\n\t/*if(K<=2){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(K==1) printf(\"%d\",n1.a[i]);\n\t\t\telse printf(\"%d\",n2.a[i]);\n\t\t\tif(i<n) printf(\" \");\n\t\t\telse printf(\"\\n\");\n\t\t}\n\t\treturn 0;\n\t}*/\n\tnode A=cheng(ni(n2),n1);\n\tA=cheng(A,n2);A=cheng(A,ni(n1));\n\tint t=(K-1)%6+1;\n\tif(t>=2){\n\t\tfor(int i=3;i<=t;i++){\n\t\t\tnode T=n2;\n\t\t\tn2=cheng(ni(n1),n2);\n\t\t\tn1=T;\n\t\t}\n\t\tn1=n2;\n\t}\n\tA=mi(A,(K-t)/6);\n\tnode ans=cheng(A,n1);ans=cheng(ans,ni(A));\n\tfor(int i=1;i<=n;i++){\n\t\tprintf(\"%d\",ans.a[i]);\n\t\tif(i<n) printf(\" \");\n\t\telse printf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long double ldb ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 2e5 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int mod = 1e9 + 7 ;\nconst db eps = 1e-10 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nint n, k;\n\nstruct permutations\n{\n\tint pos[maxn];\n\tpermutations(){rep(i, 1, n) pos[i] = i;}\n\tfriend permutations operator * (permutations p, permutations q)\n\t{\n\t\tpermutations ret;\n\t\trep(i, 1, n) ret.pos[i] = p.pos[q.pos[i]];\n\t\treturn ret;\n\t}\n\tpermutations operator *= (permutations b)\n\t{\n\t\treturn *this = *this * b;\n\t}\n};\n\npermutations a, b, mul, ans;\n\npermutations inv(permutations a)\n{\n\tpermutations ret;\n\trep(i, 1, n) ret.pos[a.pos[i]] = i;\n\treturn ret;\n}\n\npermutations power(permutations a, ll b)\n{\n\tpermutations ret;\n\tfor (; b; b >>= 1, a *= a) if(b & 1) ret *= a;\n\treturn ret;\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &k);\n\trep(i, 1, n) scanf(\"%d\", &a.pos[i]);\n\trep(i, 1, n) scanf(\"%d\", &b.pos[i]);\n\tmul = power(b * inv(a) * inv(b) * a, (k - 1) / 6);\n\tk = (k - 1) % 6 + 1;\n\tif(k == 1) ans = mul * a * inv(mul);\n\telse if(k == 2) ans = mul * b * inv(mul);\n\telse if(k == 3) ans = mul * b * inv(a) * inv(mul);\n\telse if(k == 4) ans = mul * b * inv(a) * inv(b) * inv(mul);\n\telse if(k == 5) ans = mul * b * inv(a) * inv(b) * a * inv(b);\n\telse ans = mul * b * inv(a) * inv(b) * a * a * inv(b) * inv(mul);\n\trep(i, 1, n) printf(\"%d%c\", ans.pos[i], \" \\n\"[i == n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nInt n;\nvector<Int> mg(vector<Int> a,vector<Int> b){\n  vector<Int> c(n);\n  for(Int i=0;i<n;i++) c[i]=a[b[i]];\n  return c;\n}\n\nvector<Int> vpow(vector<Int> a,Int k){\n  vector<Int> c(n);\n  iota(c.begin(),c.end(),0);\n  while(k){\n    if(k&1) c=mg(c,a);\n    a=mg(a,a);\n    k>>=1;\n  }\n  return c;\n}\n\nvoid print(vector<Int> v){\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<v[i]+1;\n  }\n  cout<<endl;\n}\n\nsigned main(){\n  Int k;\n  cin>>n>>k;\n  vector<Int> p(n),q(n),x(n),y(n);\n  for(Int i=0;i<n;i++) cin>>p[i];\n  for(Int i=0;i<n;i++) cin>>q[i];\n  for(Int i=0;i<n;i++){\n    p[i]--;q[i]--;\n    x[p[i]]=i;\n    y[q[i]]=i;\n  }\n  k--;\n  if(k==0){\n    print(p);\n    return 0;\n  }\n  if(k==1){\n    print(q);\n    return 0;\n  }  \n  auto qxyp=mg(q,mg(x,mg(y,p)));\n  auto xqpy=mg(x,mg(q,mg(p,y)));\n\n  vector<vector<Int> > vs;\n  vs.emplace_back(mg(q,x));\n  vs.emplace_back(mg(q,mg(x,y)));\n  vs.emplace_back(y);\n  vs.emplace_back(mg(p,y));\n  vs.emplace_back(mg(q,mg(p,y)));\n  vs.emplace_back(q);\n\n  Int a=(k+4)/6,b=(k+1)/6,c=k%6;\n  auto ans=mg(vpow(qxyp,a),mg(vs[c],vpow(xqpy,b)));\n\n  print(ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:134217728\")\n\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <memory>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\ntypedef long long Int;\ntypedef pair<int,int> PII;\ntypedef vector<int> VInt;\n\n#define FOR(i, a, b) for(i = (a); i < (b); ++i)\n#define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i)\n#define CLEAR(a, b) memset(a, b, sizeof(a))\n#define SIZE(a) int((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define PB push_back\n#define MP make_pair\n\nVInt inv(VInt& v)\n{\n\tVInt r(SIZE(v));\n\tint i;\n\tFOR(i, 0, SIZE(v))\n\t\tr[v[i]] = i;\n\n\treturn r;\n}\n\nVInt mul(VInt& v, VInt& w)\n{\n\tVInt r(SIZE(v));\n\tint i;\n\tFOR(i, 0, SIZE(v))\n\t\tr[i] = w[v[i]];\n\n\treturn r;\n}\n\nvoid gen()\n{\n\tVInt v(1, 1);\n\tVInt w(1, 2);\n\n\tint i, j, k;\n\tFOR(i, 0, 32)\n\t{\n\t\tFOR(j, 0, SIZE(v)) printf(\"%2d\", v[j]);\n\t\tFOR(j, 0, SIZE(v)) if (v[j] != -v[SIZE(v) - 1 - j]) break;\n\t\tprintf(\": \");\n\t\tFOR(k, j, SIZE(v) - j) printf(\"%d|\", v[k]);\n\t\tprintf(\" %d-%d\\n\", SIZE(v), j);\n\n\t\tVInt v2 = v;\n\t\treverse(ALL(v2));\n\t\tFOR(j, 0, SIZE(v2)) v2[j] = -v2[j];\n\t\tFOR(j, 0, SIZE(w))\n\t\t{\n\t\t\tif (!v2.empty() && v2.back() == -w[j])\n\t\t\t\tv2.pop_back();\n\t\t\telse\n\t\t\t\tv2.push_back(w[j]);\n\t\t}\n\n\t\tv = w;\n\t\tw = v2;\n\t}\n}\n\nint main()\n{\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\n\tVInt p(n), q(n);\n\tint i;\n\tFOR(i, 0, n) scanf(\"%d\", &p[i]);\n\tFOR(i, 0, n) scanf(\"%d\", &q[i]);\n\tFOR(i, 0, n) --p[i];\n\tFOR(i, 0, n) --q[i];\n\n\tVInt pp = inv(p);\n\tVInt qq = inv(q);\n\n\tVInt r = p;\n\tif(k > 1)\n\t{\n\t\tVInt common = mul(qq, p);\n\t\tcommon = mul(common, q);\n\t\tcommon = mul(common, pp);\n\n\t\tk -= 2;\n\t\tint cnt = k / 6;\n\t\tint rem = k % 6;\n\t\tint off[] = { 0, 0, 1, 2, 2, 3 };\n\t\tswitch(rem)\n\t\t{\n\t\tcase 0:\n\t\t\tr = q;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tr = mul(pp, q);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tr = pp;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tr = qq;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tr = mul(p, qq);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tr = p;\n\t\t\tbreak;\n\t\t}\n\n\t\tVInt t(n);\n\t\tFOR(i, 0, n) t[i] = i;\n\t\tfor (i = 1; i <= cnt; i <<= 1)\n\t\t{\n\t\t\tif ((cnt & i) != 0) t = mul(t, common);\n\t\t\tcommon = mul(common, common);\n\t\t}\n\n\t\tVInt z[] = {qq, p, q, pp};\n\t\tFOR(i, 0, off[rem])\tt = mul(t, z[i]);\n\n\t\tr = mul(t, r);\n\t\tt = inv(t);\n\t\tr = mul(r, t);\n\t}\n\n\tFOR(i, 0, n) printf(\"%d \", r[i] + 1);\n\treturn 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> apply(vector<int> &a, vector<int> &b)\n{\n\tvector<int> r(a.size());\n\n\tfor (int i = 0; i < b.size(); i++) r[i] = a[b[i]];\n\n\treturn r;\n}\n\nvector<int> pow(vector<int> &a, int k)\n{\n\tvector<int> r(a.size());\n\n\tif (k == 0){\n\t\tfor (int i = 0; i < a.size(); i++) r[i] = i;\n\t}\n\telse{\n\t\tauto h = pow(a, k / 2);\n\t\tr = apply(h, h);\n\t\tif (k % 2){\n\t\t\tfor (int i = 0; i < r.size(); i++) r[i] = a[r[i]];\n\t\t}\n\t}\n\n\treturn r;\n}\n\n\nint main()\n{\n\tint N, K; scanf (\"%d %d\", &N, &K);\n\tvector<int> p(N), q(N), P(N), Q(N);\n\tfor (int i = 0; i < N; i++){\n\t\tscanf (\"%d\", &p[i]); p[i]--;\n\t\tP[p[i]] = i;\n\t}\n\tfor (int i = 0; i < N; i++){\n\t\tscanf (\"%d\", &q[i]); q[i]--;\n\t\tQ[q[i]] = i;\n\t}\n\n\tvector<int> r;\n\tif (K == 1) r = p;\n\telse{\n\t\tint u = (K - 2) / 6;\n\t\tvector<int> X = pow(apply(P, apply(q, apply(p, Q))), u);\n\n\t\tvector<int> C;\n\n\t\tif (K % 6 == 0) C = apply(p, Q);\n\t\tif (K % 6 == 1) C = apply(q, apply(p, Q));\n\t\tif (K % 6 == 2) C = q;\n\t\tif (K % 6 == 3) C = apply(q, P);\n\t\tif (K % 6 == 4) C = apply(q, apply(P, Q));\n\t\tif (K % 6 == 5) C = Q;\n\n\t\tint v = (K + 1) / 6;\n\t\tvector<int> Y = pow(apply(q, apply(P, apply(Q, p))), v);\n\n\t\tr = apply(Y, apply(C, X));\n\t}\n\n\tfor (int i = 0; i < N; i++) printf (\"%d%c\", r[i] + 1, i + 1 < N ? ' ' : '\\n');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass DASequenceOfPermutations {\npublic:\n    vector<int> mul(const vector<int>&a, const vector<int>&b) {\n        int N = a.size();\n        vector<int> R(N);\n        for (int i = 0; i < N; ++i) {\n            R[i] = a[b[i]];\n        }\n        return R;\n    }\n\n    vector<int> prod(const vector<int>&w, int k) {\n        int N = w.size();\n        vector<int> R(N), P = w;\n        for (int i = 0; i < N; ++i) {\n            R[i] = i;\n        }\n\n        while (k) {\n            if (k%2) R = mul(R, P);\n            P = mul(P, P);\n            k >>= 1;\n        }\n        return R;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        int N, K; cin >> N >> K;\n        vector<int> P(N), Q(N); cin >> P >> Q;\n\n        for (int&p: P) --p;\n        for (int&q: Q) --q;\n\n        vector<int> PI(N), QI(N);\n        for (int i = 0; i < N; ++i) {\n            QI[Q[i]] = i;\n            PI[P[i]] = i;\n        }\n        vector<int> Per(N);\n        for (int i = 0; i < N; ++i) Per[i] = Q[PI[QI[P[i]]]];\n\n        int s = (K-1)/6;\n        K -= 6*s;\n\n        vector<int> pow = prod(Per, s);\n        vector<int> ipow(N);\n        for (int i = 0; i < N; ++i) {\n            ipow[pow[i]] = i;\n        }\n        P = mul(pow, mul(P, ipow));\n        Q = mul(pow, mul(Q, ipow));\n        vector<int> ans;\n        if (K == 1) {\n            ans = P;\n        } else {\n\n            for (int k = 3; k <= K; ++k) {\n                vector<int> Z(N);\n                for (int i = 0; i < N; ++i) {\n                    Z[P[i]] = Q[i];\n                }\n                swap(P, Q);\n                swap(Q, Z);\n            }\n            ans = Q;\n        }\n\n        for (int&q: Q) ++q;\n        cout << Q;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDASequenceOfPermutations solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n\nstruct perm {\n  vector<int> a;\n  perm(int n) : a(n) {}\n  int size() { return a.size(); }\n  int &operator[](int k) { return a[k]; }\n};\n\nperm operator*(perm a, perm b) {\n  const int n = a.size();\n  perm ans(n);\n  REP(i, n) ans[i] = a[b[i]];\n  return ans;\n}\n\nperm inv(perm a) {\n  const int n = a.size();\n  perm ans(n);\n  REP(i, n) ans[a[i]] = i;\n  return ans;\n}\n\nperm pow(perm a, int b) {\n  const int n = a.size();\n  perm ans(n);\n  REP(i, n) ans[i] = i;\n  while (b > 0) {\n    if (b & 1) ans = ans * a;\n    a = a * a;\n    b >>= 1;\n  }\n  return ans;\n}\n\nvoid print(perm a) {\n  for (int i = 0; i < a.size(); i++) {\n    if (i > 0) cout << ' ';\n    cout << a[i] + 1;\n  }\n  cout << '\\n';\n}\n\nint main() {\n  int N, K;\n  cin >> N >> K;\n  perm P(N), Q(N);\n  REP(i, N) cin >> P[i], P[i]--;\n  REP(i, N) cin >> Q[i], Q[i]--;\n  auto X = Q * inv(P) * inv(Q) * P;\n  auto Y = inv(P) * Q * P * inv(Q);\n  vector<perm> A;\n  A.push_back(P);\n  A.push_back(Q);\n  for (int i = 0; i < 5; i++) {\n    A.push_back(A[i + 1] * inv(A[i]));\n  }\n  A.erase(A.begin());\n  if (K == 1) {\n    print(P);\n    return 0;\n  }\n  K -= 2;\n  perm ans = pow(X, K / 6) * A[K % 6] * pow(Y, K / 6);\n  print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nvector<int> invert(vector<int> const & p) {\n    vector<int> q(p.size());\n    REP (i, p.size()) {\n        q[p[i]] = i;\n    }\n    return q;\n}\n\nvector<int> multiply(vector<int> const & p, vector<int> const & q) {\n    assert (p.size() == q.size());\n    vector<int> r(p.size());\n    REP (i, p.size()) {\n        r[i] = p[q[i]];\n    }\n    return r;\n}\n\nvector<int> power(vector<int> p, ll k) {\n    vector<int> q(p.size());\n    iota(ALL(q), 0);\n    for (ll i = 1; i <= k; i <<= 1) {\n        if (k & i) q = multiply(q, p);\n        p = multiply(p, p);\n    }\n    return q;\n}\n\nvector<int> solve(int n, ll k, vector<int> const & p, vector<int> const & q) {\n    int kq = (k - 1) / 6;\n    int kr = (k - 1) % 6;\n    vector<int> a = power(multiply(q, multiply(invert(p), multiply(invert(q), p))), kq);\n    switch (kr) {\n        case 3:\n            a = multiply(a, q);\n            break;\n        case 4:\n        case 5:\n            a = multiply(a, multiply(q, invert(p)));\n            break;\n    }\n    vector<int> b =\n        kr == 0 ? p :\n        kr == 1 ? q :\n        kr == 2 ? multiply(q, invert(p)) :\n        kr == 3 ? invert(p) :\n        kr == 4 ? invert(q) :\n                  multiply(invert(q), p);\n    return multiply(a, multiply(b, invert(a)));\n}\n\nint main() {\n    // input\n    int n; ll k; cin >> n >> k;\n    vector<int> p(n);\n    REP (i, n) {\n        cin >> p[i];\n        -- p[i];\n    }\n    vector<int> q(n);\n    REP (i, n) {\n        cin >> q[i];\n        -- q[i];\n    }\n\n    // solve\n    vector<int> r = solve(n, k, p, q);\n\n    // output\n    REP (i, n) {\n        cout << r[i] + 1 << ' ';\n    }\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> inv(vector<int> a) {\n  int n = (int) a.size();\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[a[i]] = i;\n  }\n  return ret;\n}\n\nvector<int> mul(vector<int> a, vector<int> b) {\n  int n = (int) a.size();\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[i] = a[b[i]];\n  }\n  return ret;\n}\n\nvector<int> power(vector<int> a, int b) {\n  int n = (int) a.size();\n  vector<int> ret(n);\n  iota(ret.begin(), ret.end(), 0);\n  while (b) {\n    if (b & 1) {\n      ret = mul(ret, a);\n    }\n    b >>= 1;\n    a = mul(a, a);\n  }\n  return ret;\n}\n\nvoid output(vector<int> a) {\n  for (int i = 0; i < (int) a.size(); i++) {\n    if (i) {\n      cout << \" \";\n    }\n    cout << a[i] + 1;\n  }\n  cout << '\\n';\n  \n  exit(0);\n}\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i]--;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> b[i];\n    b[i]--;\n  }\n  if (k == 1) {\n    output(a);\n  }\n  vector<int> A = inv(a);\n  vector<int> B = inv(b);\n  vector<int> bABa = mul(b, mul(A, mul(B, a)));\n  vector<int> AbaB = mul(A, mul(b, mul(a, B)));\n\n  vector<int> l[6];\n  l[0] = b;\n  l[1] = mul(b, A);\n  l[2] = mul(b, mul(A, B));\n  l[3] = mul(bABa, B);\n  l[4] = mul(bABa, mul(a, B));\n  l[5] = mul(bABa, mul(b, mul(a, B)));\n\n  vector<int> f = power(AbaB, (k - 2) / 6);\n  f = mul(l[(k - 2) % 6], f);\n  f = mul(power(bABa, (k - 2) / 6), f);\n  output(f);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf = 1.01e9;\nconst i64 inf64 = 4.01e18;\nconst double eps = 1e-9;\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// q(p(i))\nvector<i64> composite(const vector<i64> &p, const vector<i64> &q){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n) res[i]=q[p[i]];\n    return res;\n}\n\nvector<i64> inverse(const vector<i64> &p){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n) res[p[i]]=i;\n    return res;\n}\n\nvector<i64> pow(vector<i64> p,i64 k){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n){\n        res[i]=i;\n    }\n    while(k){\n        if(k&1){\n            res=composite(res,p);\n        }\n        p=composite(p,p);\n        k>>=1;\n    }\n    return res;\n}\n\nvector<i64> f(const vector<i64> &p,const vector<i64> &q){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n) res[p[i]]=q[i];\n    return res;\n}\n\nvoid solve() {\n    //const i64 mod = 1'000'000'007;\n\n    /*\n    vector<string> vs(30);\n    vs[1]=\"a\";\n    vs[2]=\"b\";\n    rep(i,3,vs.size()){\n        vs[i]=vs[i-1];\n        for(i64 j=vs[i-2].size()-1; j>=0; --j){\n            char c=vs[i-2][j];\n            if(c=='a'){\n                if(vs[i].back()=='a') vs[i].pop_back();\n                else vs[i]+='A';\n            }\n            if(c=='A'){\n                if(vs[i].back()=='A') vs[i].pop_back();\n                else vs[i]+='a';\n            }\n            if(c=='b'){\n                if(vs[i].back()=='b') vs[i].pop_back();\n                else vs[i]+='B';\n            }\n            if(c=='B'){\n                if(vs[i].back()=='B') vs[i].pop_back();\n                else vs[i]+='b';\n            }\n        }\n    }\n    rep(i,1,vs.size()){\n        cout << i << \": \" << vs[i] << endl;\n    }\n     */\n\n    i64 N,K;\n    cin >> N >> K;\n\n    vector<i64> p(N),q(N);\n    rep(i,0,N){\n        cin >> p[i];\n        --p[i];\n    }\n    rep(i,0,N){\n        cin >> q[i];\n        --q[i];\n    }\n\n    if(K<=15){\n        vector<vector<i64>> a(K+1);\n        a[1]=p;\n        a[2]=q;\n        rep(i,3,K+1){\n            a[i]=f(a[i-2],a[i-1]);\n        }\n        rep(i,0,N){\n            cout << a[K][i]+1;\n            if(i==N-1) cout << endl;\n            else cout << \" \";\n        }\n        return;\n    }\n\n    vector<i64> pi=inverse(p),qi=inverse(q);\n\n    auto x= composite(composite(composite(p, qi), pi), q);\n    auto y= composite(composite(composite(qi, p), q), pi);\n\n    i64 loop=(K-2)/6, rem=K-(2+loop*6);\n    auto prev=composite(composite(inverse(pow(x,loop)),p),pow(x,loop));\n    auto ans=composite(composite(pow(y,loop),q),pow(x,loop));\n    rep(i,0,rem){\n        auto tmp=ans;\n        ans=f(prev,ans);\n        prev=tmp;\n    }\n\n    rep(i,0,N){\n        cout << ans[i]+1;\n        if(i==N-1) cout << endl;\n        else cout << \" \";\n    }\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nstd::vector<int> a[100005];\nint n,k,cnt,used[100005];\nint ans[100005],p[100005],pp[100005],q[100005],qq[100005],g[100005],gg[100005],gk[100005],ggk[100005],f[10][100005],ff[10][10005];\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&q[i]);\n\tfor (int i=1;i<=n;i++) f[0][i]=i;\n\tfor (int i=1;i<=n;i++) ff[0][i]=i;\n\tfor (int i=1;i<=n;i++) f[1][i]=p[i];\n\tfor (int i=1;i<=n;i++) f[2][i]=q[i];\n\tfor (int i=1;i<=n;i++) ff[1][f[1][i]]=i;\n\tfor (int i=1;i<=n;i++) ff[2][f[2][i]]=i;\n\tfor (int r=3;r<=6;r++)\n\t{\n\t\tfor (int i=1;i<=n;i++) f[r][i]=f[r-1][ff[r-2][i]];\n\t\tfor (int i=1;i<=n;i++) ff[r][f[r][i]]=i;\n\t}\n\tfor (int i=1;i<=n;i++) pp[p[i]]=i;\n\tfor (int i=1;i<=n;i++) qq[q[i]]=i;\n\tfor (int i=1;i<=n;i++) g[i]=q[pp[qq[p[i]]]];\n\tfor (int i=1;i<=n;i++) gg[g[i]]=i;\n//\tfor (int i=1;i<=n;i++) printf(\"%d \",g[i]);puts(\"\");\n\tfor (int i=1;i<=n;i++)\n\t    if (!used[i])\n\t    {\n\t\t\tint x=++cnt;\n\t\t\tused[i]=1;\n\t\t\ta[x].push_back(i);\n\t    \tfor (int j=g[i];!used[j];j=g[j])\n\t    \t{\n\t    \t\ta[x].push_back(j);\n\t    \t\tused[j]=1;\n\t\t\t}\n\t    }\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tint sz=a[i].size();\n\t\tfor (int j=0;j<a[i].size();j++)\n\t\t{\n\t\t\tint x=a[i][j],y=a[i][(j+(k-1)/6)%sz];\n\t\t\tgk[x]=y;\n\t\t}\n\t}\n//\tfor (int i=1;i<=n;i++) printf(\"%d \",gk[i]);puts(\"\");\n\tfor (int i=1;i<=n;i++) used[i]=0;\n\tfor (int i=1;i<=cnt;i++) a[i].clear();cnt=0;\n\tfor (int i=1;i<=n;i++)\n\t    if (!used[i])\n\t    {\n\t\t\tint x=++cnt;\n\t\t\tused[i]=1;\n\t\t\ta[x].push_back(i);\n\t    \tfor (int j=gg[i];!used[j];j=gg[j])\n\t    \t{\n\t    \t\ta[x].push_back(j);\n\t    \t\tused[j]=1;\n\t\t\t}\n\t    }\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tint sz=a[i].size();\n\t\tfor (int j=0;j<a[i].size();j++)\n\t\t{\n\t\t\tint x=a[i][j],y=a[i][(j+(k-1)/6)%sz];\n\t\t\tggk[x]=y;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) used[i]=0;\n\tfor (int i=1;i<=cnt;i++) a[i].clear();cnt=0;\n\tfor (int i=1;i<=n;i++) ans[i]=gk[f[(k-1)%6+1][ggk[i]]];\n\t\n\tfor (int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nusing vll=vector<ll>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\nusing vpii=vector<pii>;\n\nvi fastexp(const vi& perm, int x) {\n    if (x > 1) {\n        int n = perm.size();\n        vi halfexp = fastexp(perm, x/2);\n        vi res(n);\n        for (int i=0; i<n; ++i) {\n            if (x&1)\n                res[i] = perm[halfexp[halfexp[i]]];\n            else\n                res[i] = halfexp[halfexp[i]];\n        }\n        return res;\n    }\n    assert(x == 1);\n    return perm;\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, k;\n    cin >> n >> k;\n    vvi ais(6, vi(n));\n    for (int i=0; i<n; ++i) {\n        cin >> ais[0][i];\n        --ais[0][i];\n    }\n    for (int i=0; i<n; ++i) {\n        cin >> ais[1][i];\n        --ais[1][i];\n    }\n    for (int j=2; j<6; ++j) {\n        for (int i=0; i<n; ++i) {\n            ais[j][ais[j-2][i]] = ais[j-1][i];\n        }\n    }\n\n    int lowi = n%6;\n    if (lowi == 0)\n        lowi = 6;\n    int x = (k - lowi)/6;\n\n    vi per(n);\n    for (int i=0; i<n; ++i)\n        per[i] = ais[3][ais[0][i]];\n\n    vi res;\n    if (x == 0)\n        res = ais[lowi-1];\n    else {\n        vi perexp = fastexp(per, x);\n        res = vi(n);\n        for (int i=0; i<n; ++i) {\n            res[perexp[i]] = perexp[ais[lowi-1][i]];\n        }\n    }\n    for (int i=0; i<n; ++i)\n        cout << res[i]+1 << \" \";\n    cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main () {\n  int N;\n  long long K;\n  cin >> N >> K;\n  vector<vector<int>>B(6,vector<int>(N + 1));\n  vector<vector<int>>A(6,vector<int>(N + 1));\n  vector<int>key(N + 1);\n  int an[100002];\n  vector<int>an_(N + 1);\n  vector<int>ans(N + 1);\n  for (int i = 1; i <= N; i ++) {\n    cin >> B[1][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    cin >> B[2][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    B[3][B[1][i]] = B[2][i];\n    B[4][B[1][i]] = i;\n    B[5][B[2][i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    B[0][B[4][i]] = B[5][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    A[1][i] = i;\n    A[2][i] = i;\n    A[3][i] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    A[4][i] = B[2][i];\n    A[5][i] = B[3][i];\n    A[0][i] = B[3][i];\n  }\n  for (int i = 1; i <= N; i ++) {\n    key[i] = B[2][B[4][B[5][B[1][i]]]];\n  }\n  int jun = (int)K % 6;\n  int ju = (int)K / 6;\n  for (int i = 1; i <= N; i ++) {\n    an[i] = A[jun][i];\n  }\n  for (int i = 0; i < ju; i ++) {\n    int* a = an;\n    for (int j = 1; j <= N; j ++) {\n      an[j] = key[a[j]];\n    }\n  }\n  for (int i = 1; i <= N; i ++) {\n    an_[an[i]] = i;\n  }\n  for (int i = 1; i <= N; i ++) {\n    ans[i] = an[B[jun][an_[i]]];\n  }\n  for (int i = 1; i < N; i ++) {\n    cout << ans[i] << ' ';\n  }\n  cout << ans[N] << endl;\n}\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/STACK:256000000\")\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<queue>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<ctime>\n#include<cstdio>\n#include<cassert>\n#include<functional>\n\n\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<char, char> pcc;\ntypedef pair<double, double> pdd;\n\n#define show(x) cerr << x\n#define debug(x) show(#x << \": \" << (x) << endl)\n\nconst long double PI = 3.14159265358979323846;\nconst long double eps = 1e-5;\nconst int INF = numeric_limits<int>::max();\nconst ll LINF = numeric_limits<ll>::max();\nconst ll mod = 1000 * 1000 * 1000 + 7;\n\n\nvector<int> inv(const vector<int>& a) {\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i)\n        res[a[i]] = i;\n    return res;\n}\n\n\nvector<int> mult(const vector<int>& a, const vector<int>& b) {\n    int n = a.size();\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[i] = a[b[i]];\n    }\n    return res;\n}\n\nvector<int> power(vector<int> a, int n) {\n    int sz = a.size();\n    vector<int> res(sz);\n    for (int i = 0; i < sz; ++i)\n        res[i] = i;\n    while (n) {\n        if (n & 1)\n            res = mult(res, a);\n        a = mult(a, a);\n        n /= 2;\n    }\n    return res;\n}\n\n\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> p(n), q(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        --p[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> q[i];\n        --q[i];\n    }\n    int tr = 20;\n    if (k < tr) {\n        vector<vector<int> > res(k);\n        res[0] = p;\n        res[1] = q;\n        for (int i = 2; i < k; ++i)\n            res[i] = mult(res[i - 1], inv(res[i - 2]));\n        for (int i = 0; i < n; ++i) {\n            cout << res[k - 1][i] + 1 << \" \";\n        }\n        cout << endl;\n        return;\n    }\n    int x = (k + 1) / 6;\n    int r = (k + 1) % 6;\n    vector<int> p1 = mult(mult(q, inv(p)), mult(inv(q), p));\n    vector<int> p2 = mult(mult(inv(p), q), mult(p, inv(q)));\n    p1 = power(p1, x);\n    int y = x - 1;\n    if (r >= 3)\n        ++y;\n    p2 = power(p2, y);\n    vector<int> p3;\n    if (r == 0) {\n        p3 = inv(q);\n    }\n    if (r == 1) {\n        p3 = mult(p, inv(q));\n    }\n    if (r == 2) {\n        p3 = mult(q, mult(p, inv(q)));\n    }\n    if (r == 3) {\n        p3 = q;\n    }\n    if (r == 4) {\n        p3 = mult(q, inv(p));\n    }\n    if (r == 5) {\n        p3 = mult(mult(q, inv(p)), inv(q));\n    }\n    vector<int> res = mult(p1, mult(p3, p2));\n    for (int i = 0; i < res.size(); ++i)\n        cout << res[i] + 1 << \" \";\n    cout << endl;\n\n    \n    \n\n\n\n\n}\n\n//#define LOCAL\n\nint main() {\n    ios_base::sync_with_stdio(0);cin.tie(nullptr);cout.tie(nullptr);\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    solve();\n\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n;\nvector<ll> ret;\n\n\n\nvoid cul(vector<ll> &ret,const vector<ll> &A,const vector<ll> &B){\n    for(int i=0;i<n;i++){ret[i]=B[A[i]];}\n}\n\nvoid rev(vector<ll> &ret,vector<ll> A){\n    for(int i=0;i<n;i++){ret[A[i]]=i;}\n}\n\nvoid Out(vector<ll> ans){\n    for(int i=0;i+1<n;i++){cout<<ans[i]+1<<\" \";}\n    cout<<ans.back()+1<<endl;\n}\n\nvector<ll> operator * (const vector<ll> &A,const vector<ll> &B){cul(ret,A,B); return ret;}\n\nvector<ll> & operator *= (vector<ll> &A,const vector<ll> &B){cul(ret,A,B); return A=ret;}\n\nvector<ll> & operator /= (vector<ll> &A,const vector<ll> &B){cul(ret,B,A); return A=ret;}\n\n\nint main(){\n    ll k;\n    cin>>n>>k;\n    vector<ll> P(n);\n    vector<ll> Q(n);\n    for(auto &I:P){cin>>I; I--;}\n    for(auto &I:Q){cin>>I; I--;}\n    \n    ret.resize(n);\n    vector<ll> PI(n);\n    vector<ll> QI(n);\n    rev(PI,P);\n    rev(QI,Q);\n    vector<ll> O=P*QI*PI*Q;\n    vector<ll> A(n);\n    for(int i=0;i<n;i++){A[i]=i;}\n    \n    if(k==1){\n        Out(P);\n        return 0;\n    }\n    else if(k==2){\n        Out(Q);\n        return 0;\n    }\n    else if(k==3){\n        Out(PI*Q);\n        return 0;\n    }\n    \n    if(k<100){assert(false);}\n    \n    k-=3;\n    ll Z=k/6;\n    while(Z>0){\n        if(Z&1){A*=O;}\n        Z>>=1;\n        O*=O;\n    }\n    \n    if(k%6){A/=Q;}\n    if(k%6>1){A/=PI;}\n    if(k%6>3){A/=QI;}\n    if(k%6==5){A/=P;}\n    \n    rev(O,A);\n    \n    if(k%3==1){\n        QI=PI;\n    }\n    else if(k%3==2){\n        QI=QI;\n    }\n    else{\n        cul(QI,PI,Q);\n    }\n    if((k/3)&1){rev(QI,QI);}\n    O*=QI;\n    O*=A;\n    Out(O);\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5;\nint n, k;\n\nstruct perm {\n\tint n, a[maxn + 3];\n\n\tperm(int m) {\n\t\tn = m;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[i] = i;\n\t\t}\n\t}\n\n\tfriend perm operator * (perm p, perm q) {\n\t\tperm r(p.n);\n\t\tfor (int i = 1; i <= p.n; i++) {\n\t\t\tr.a[i] = p.a[q.a[i]];\n\t\t}\n\t\treturn r;\n\t}\n\n\tperm inv() {\n\t\tperm r(n);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tr.a[a[i]] = i;\n\t\t}\n\t\treturn r;\n\t}\n\n\tvoid print() {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tprintf(\"%d%c\", a[i], \" \\n\"[i == n]);\n\t\t}\n\t}\n};\n\nperm g(perm p, perm q) {\n\treturn p * q * p.inv();\n}\n\nperm qpow(perm p, int k) {\n\tperm q(n);\n\tfor (; k; k >>= 1, p = p * p) {\n\t\tif (k & 1) q = p * q;\n\t}\n\treturn q;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\tperm p(n), q(n), r(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &p.a[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &q.a[i]);\n\t}\n\tint x = (k - 1) / 6;\n\tr = q * p.inv() * q.inv() * p;\n\tr = qpow(r, x);\n\tk -= x * 6;\n\tif (k == 1) {\n\t\tg(r, p).print();\n\t} else if (k == 2) {\n\t\tg(r, q).print();\n\t} else if (k == 3) {\n\t\tg(r, q * p.inv()).print();\n\t} else if (k == 4) {\n\t\tg(r, q * p.inv() * q.inv()).print();\n\t} else if (k == 5) {\n\t\tg(r, q * p.inv() * q.inv() * p * q.inv()).print();\n\t} else {\n\t\tg(r, q * p.inv() * q.inv() * p * p * q.inv()).print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(c)      int(c.size())\n#define rep(i,a,b) for (int i=a; i<(b); ++i)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); --i)\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\n\nvi pinv(const vi &p) {\n\tvi res(sz(p));\n\trep(i,0,sz(p)) res[p[i]]=i;\n\treturn res;\n}\n\nvi pcompose(const vi &p,const vi &q) {\n\tvi res(sz(p));\n\trep(i,0,sz(p)) res[i]=p[q[i]];\n\treturn res;\n}\n\nvi ppow(vi p,int n) {\n\tvi res(sz(p));\n\trep(i,0,sz(p)) res[i]=i;\n\twhile (n>0) {\n\t\tif (n%2) res=pcompose(res,p);\n\t\tp=pcompose(p,p);\n\t\tn/=2;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(10);\n\n\tint N,K;\n\tcin>>N>>K;\n\tK--;\n\t\n\tvi p(N),q(N);\n\trep(i,0,N) {\n\t\tcin>>p[i];\n\t\tp[i]--;\n\t}\n\trep(i,0,N) {\n\t\tcin>>q[i];\n\t\tq[i]--;\n\t}\n\t\n\tvi P=pinv(p);\n\tvi Q=pinv(q);\n\t\n\tvi a=ppow(pcompose(q,pcompose(P,pcompose(Q,p))),K/6);\n\tvi b;\n\tswitch (K%6) {\n\t\tcase 0:\n\t\t\tb=p;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tb=q;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tb=pcompose(q,P);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tb=pcompose(q,pcompose(P,Q));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tb=pcompose(q,pcompose(P,pcompose(Q,pcompose(p,Q))));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tb=pcompose(q,pcompose(P,pcompose(Q,pcompose(p,pcompose(p,Q)))));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t}\n\t\n\tvi res=pcompose(a,pcompose(b,pinv(a)));\n\trep(i,0,N) cout<<res[i]+1<<\" \\n\"[i+1==N];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (int NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (int NAME = (NUM)-1; NAME >= 0; --NAME)\n#define ALL(NAME) (NAME).begin(), (NAME).end()\n#define VEC(TYPE, A, NAME, INIT) vector<TYPE> NAME(A, INIT)\n#define VEC2(TYPE, A, B, NAME, INIT) vector<vector<TYPE>> NAME(A, vector<TYPE>(B, (INIT)))\n\ntemplate< class T >\nconst vector<T> operator*( const vector<T>& a, const vector<T>& b )\n{\n\tT size = a.size();\n\tvector<T> ret( size );\n\tREP( i , size ) ret[i] = a[b[i]];\n\treturn ret;\n}\n\ntemplate< class T >\nconst vector<T> operator~( const vector<T>& a )\n{\n\tT size = a.size();\n\tvector<T> ret( size );\n\tREP( i , size ) ret[a[i]] = i;\n\treturn ret;\n}\n\ntemplate< class T >\nvoid makeUnitPermutation( vector<T>& a )\n{\n\tT size = a.size();\n\tREP( i , size ) a[i] = i;\n}\n\nvoid print( const vector<ll>& v )\n{\n\tfor( ll i = 0, end = v.size() - 1; i < end; ++i )\n\t\tcout << v[i] + 1 << \" \";\n\tcout << v[v.size()-1] + 1 << endl;\n}\n\nint main()\n{\n\tll n, k;\n\tcin >> n >> k;\n\tvector<ll> p( n );\n\tvector<ll> q( n );\n\tREP(i,n) {cin>>p[i]; --p[i];}\n\tREP(i,n) {cin>>q[i]; --q[i];}\n\n\tauto pInv = ~p;\n\tauto qInv = ~q;\n\tauto cycle = q * pInv * qInv * p;\n\n\tauto kk = ( k - 1 ) / 6;\n\tauto cycleK = cycle; makeUnitPermutation( cycleK );\n\t{\n\t\tauto x = cycle;\n\t\twhile (kk > 0)\n\t\t{\n\t\t\tif (kk & 1) cycleK = cycleK * x;\n\t\t\tx = x * x;\n\t\t\tkk >>= 1;\n\t\t}\n\t}\n\n\tauto center = cycleK; makeUnitPermutation( center );\n\tREP(i,( k - 1 ) % 6 + 1)\n\t{\n\t\tif( i == 0 ) center = p;\n\t\telse if( i == 1 ) center = q;\n\t\telse if( i == 2 ) center = center * pInv;\n\t\telse if( i == 3 ) center = cycle * pInv;\n\t\telse if( i == 4 ) center = cycle * qInv;\n\t\telse if( i == 5 ) center = cycle * p * qInv;\n\t}\n\n\tauto ans =cycleK * center * ( ~cycleK );\n\n\tprint( ans );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\nusing std::cin; using std::cout;\nusing std::endl;\nusing std::bitset; using std::map;\nusing std::queue; using std::priority_queue;\nusing std::set; using std::string;\nusing std::stringstream; using std::vector;\nusing std::pair; using std::make_pair;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<ULL, ULL> puu;\n#ifdef DEBUG\nusing std::cerr;\n#define pass cerr << \"[\" << __FUNCTION__ << \"] : line = \" << __LINE__ << endl;\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)                      \\\n\t{                                           \\\n\t\tcerr << #a << \" = {\";                   \\\n\t\tfor (int qwq = (st); qwq <= (n); ++qwq) \\\n\t\t\tif (qwq == (st))                    \\\n\t\t\t\tcerr << a[qwq];                 \\\n\t\t\telse                                \\\n\t\t\t\tcerr << \", \" << a[qwq];         \\\n\t\tcerr << \"}\" << endl;                    \\\n\t}\n#define displayv(a) displaya(a, 0, (int)(a.size() - 1))\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#include <ctime>\nclass MyTimer {\n\tclock_t st;\npublic:\n\tMyTimer() { cerr << std::fixed << std::setprecision(0); reset(); }\n\t~MyTimer() { report(); }\n\tvoid reset() { st = clock_t(); }\n\tvoid report() {  cerr << \"Time consumed: \" << (clock() - st) * \\\n\t\t1e3 / CLOCKS_PER_SEC << \"ms\" << endl; }\n} myTimer;\n#else\n#define cerr if(false) std::cout\n#define pass ;\n#define display(x) ;\n#define displaya(a, st, n) ;\n#define displayv(a) ;\n#define eprintf(...) if(0) fprintf(stderr, __VA_ARGS__)\nclass MyTimer {\npublic: void reset() {} void report() {}\n} myTimer;\n#endif\n\ntemplate<typename A, typename B>\nstd::ostream& operator << (std::ostream &cout, const pair<A, B> &x) {\n\treturn cout << \"(\" << x.first << \", \" << x.second << \")\";\n}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) { return a > b ? a = b, true : false; }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) { return a < b ? a = b, true : false; }\n\nconst int maxN = 100000 + 233;\nconst int maxK = 1000000000 + 233;\nint n, k;\nvector<int> p, q;\n\nvector<int> inv(const vector<int> &x) {\n\tvector<int> a(x.size());\n\tfor(int i = 0; i < n; ++i) a[x[i]] = i;\n\treturn a;\n}\nvector<int> comp(const vector<int> &x, const vector<int> &y) {\n\tvector<int> a(x.size());\n\tfor(int i = 0; i < n; ++i) a[i] = y[x[i]];\n\treturn a;\n}\nvoid print(const vector<int> &a) {\n\tfor(int i = 0; i < n; ++i) cout << (a[i] + 1) << ' '; cout << endl;\n}\n\nvector<int> qpow(vector<int> a, int k) {\n\tvector<int> r(a.size());\n\tfor(int i = 0; i < n; ++i) r[i] = i;\n\twhile(k) {\n\t\tif(k & 1) r = comp(r, a);\n\t\ta = comp(a, a); k >>= 1;\n\t}\n\treturn r;\n}\nvector<int> pre() {\n\tint cnt = (k - 1) / 3 * 2 - 1;\n\teprintf(\"k = %d, pre = %d\\n\", k, cnt);\n\tauto r = qpow(comp(comp(comp(inv(q), p),q),inv(p)), cnt / 4);\n\tcnt -= cnt / 4 * 4;\n\tif(cnt) cnt--, r = comp(r, inv(q));\n\tif(cnt) cnt--, r = comp(r, p);\n\tif(cnt) cnt--, r = comp(r, q);\n\treturn r;\n}\n\nvector<int> post() {\n\tvector< vector<int> > off;\n\tif((k + 1) / 3 % 2 == 1)\n\t\toff = {q, p, inv(q), inv(p)};\n\telse\n\t\toff = {inv(q), inv(p), q, p};\n\tint cnt = (k + 1) / 3 * 2 - 1;\n\teprintf(\"k = %d, post = %d\\n\", k, cnt);\n\tauto r = qpow(comp(comp(comp(off[0], off[1]), off[2]), off[3]), cnt / 4);\n\tcnt -= cnt / 4 * 4;\n\tif(cnt) cnt--, r = comp(r, off[0]);\n\tif(cnt) cnt--, r = comp(r, off[1]);\n\tif(cnt) cnt--, r = comp(r, off[2]);\n\treturn r;\n}\n\nvoid bf() {\n\tif(k == 1) print(p);\n\telse if(k == 2) print(q);\n\telse {\n\t\tk -= 2;\n\t\twhile(k--) {\n\t\t\tauto x = comp(inv(p), q);\n\t\t\tp = q; q = x;\n\t\t}\n\t\tprint(q);\n\t}\n}\n\n/*\n10 25\n7 10 6 5 4 2 9 1 3 8\n4 1 9 2 3 7 8 10 6 5\n*/\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n >> k;\n\tp.resize(n); q.resize(n);\n\tfor(int i = 0; i < n; ++i) cin >> p[i], p[i]--;\n\tfor(int i = 0; i < n; ++i) cin >> q[i], q[i]--;\n\tif(k <= 6) {\n\t\tbf();\n\t} else {\n\t\tvector<int> mid;\n\t\tif(k % 6 == 5 || k % 6 == 1) mid = p;\n\t\telse if(k % 6 == 0) mid = comp(p, p);\n\t\telse if(k % 6 == 2 || k % 6 == 4) mid = inv(p);\n\t\telse mid = inv(comp(p, p));\n\t\tauto res = comp(comp(pre(), mid), post());\n\t\tprint(res);\n\t\t// bf();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define vi vector<int>\nusing namespace std;\nvi p,q,a[7];\nint n,k,x;\nvi mul(vi x,vi y)\n{\n    vi z;\n    for(int i=0;i<x.size();i++)\n        z.push_back(x[y[i]]);\n    return z;\n}\nvi inv(vi x)\n{\n    vi y(n);\n    for(int i=0;i<x.size();i++)\n        y[x[i]]=i;\n    return y;\n}\nvi ppow(vi x,int y)\n{\n    vi ans(n);\n    for(int i=0;i<n;i++) ans[i]=i;\n    while(y)\n    {\n        if(y&1) ans=mul(ans,x);\n        x=mul(x,x);\n        y>>=1;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&x);\n        p.push_back(x-1);\n    }\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&x);\n        q.push_back(x-1);\n    }\n    a[1]=p;a[2]=q;\n    for(int i=3;i<=n;i++)\n        a[i]=mul(a[i-1],inv(a[i-2]));\n    if(k<=6)\n    {\n        for(int i=0;i<n;i++)\n            printf(i==n-1?\"%d\\n\":\"%d \",a[k][i]+1);\n        return 0;\n    }\n    vi A=mul(mul(q,inv(p)),mul(inv(q),p)),B=ppow(A,(k-1)/6);\n    vi ans=mul(mul(B,a[(k-1)%6+1]),inv(B));\n    for(int i=0;i<n;i++)\n        printf(i==n-1?\"%d\\n\":\"%d \",ans[i]+1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\nvint inv(vint P){\n\tvint Q(P.size());\n\trep(i,P.size())Q[P[i]]=i;\n\treturn Q;\n}\n\nvint mul(vint P,vint Q){\n\tvint R(P.size());\n\trep(i,P.size())R[i]=Q[P[i]];\n\treturn R;\n}\n\nvint po(vint X,int K){\n\tvint ret(X.size());rep(i,X.size())ret[i]=i;\n\twhile(K){\n\t\tif(K&1)ret=mul(ret,X);\n\t\tX=mul(X,X);\n\t\tK>>=1;\n\t}\n\treturn ret;\n}\n\nvoid test(vint P,vint Q,int K){\n\twhile(K){\n\t\tK--;\n\t\tvint R=mul(inv(P),Q);\n\t\tP=Q;Q=R;\n\t}\n\trep(i,P.size())cout<<P[i]+1<<\" \";cout<<endl;\n\n}\n\nsigned main(){\n\tint N,K;\n\tcin>>N>>K;K--;\n\n\tvector<int>P(N),Q(N);\n\n\n\trep(i,N)cin>>P[i],P[i]--;\n\trep(i,N)cin>>Q[i],Q[i]--;\n\twhile(K%6){\n\t\tK--;\n\t\tvint R=mul(inv(P),Q);\n\t\tP=Q;Q=R;\n\t}\n\n\tvint X=P;\n\tX=mul(X,inv(Q));\n\tX=mul(X,inv(P));\n\tX=mul(X,Q);\n\n\tvint Z=po(X,K/6);\n\tvint ans=mul(inv(Z),P);\n\tans=mul(ans,Z);\n\trep(i,N){\n\t\tif(i)cout<<\" \";\n\t\tcout<<ans[i]+1;\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Since g++10 is released, some characters is not valid inside #if 0 :(\n * So, why not using clang++? :D\n\n * Date:\n  2020.07.15\n\n * Solution:\n  To be updated.\n\n * Digression:\n\n * CopyRight:\n          ▁▃▄▄▄▃▃▃▃▄▶\n        ▗▇▀▔    ▔▔▔▔\n       ▄▛   ▃▅━━■▄▂\n      ▟▊   ▐▘     ▀▙\n     ▟▜▌   ▐▖   ▋  ▐▍\n    ▟▘ ▜   ▝▀▇▆●▘  ▐▌\n  ▗▟▘   ▜▃       ▁▅▛\n  ▔▀▼▅▄▃▃██▅▄▄▄▅■▀▔\n        ▔▔▔▔▔▔\n */\n\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct _{\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 100000;\nstruct P {\n\tint x[maxn + 5];\n};\n\nint N;\nP operator * (const P &a, const P &b) {\n\tP c;\n\tfor (int i = 1; i <= N; i ++)\n\t\tc.x[i] = b.x[a.x[i]];\n\treturn c;\n}\n\nP inv (const P &a) {\n\tP b;\n\tfor (int i = 1; i <= N; i ++)\n\t\tb.x[a.x[i]] = i;\n\treturn b;\n}\n\nP a[10], r, tmp;\n\nint main () {\n\tN = read;\n\tint M = read;\n\tfor (int i = 1; i <= N; i ++)\n\t\ta[1].x[i] = read;\n\tfor (int i = 1; i <= N; i ++)\n\t\ta[2].x[i] = read;\n\tfor (int i = 1; i <= N; i ++)\n\t\tr.x[i] = i;\n\n\tfor (int i = 3; i <= 7; i ++)\n\t\ta[i] = inv(a[i - 2]) * a[i - 1];\n\n\tint Mx = (M - 2) / 6, My = M - Mx * 6;\n\ttmp = a[1] * a[4];\n\n\tfor (int k = Mx; k; k >>= 1) {\n\t\tif (k & 1) r = r * tmp;\n\t\ttmp = tmp * tmp;\n\t}\n\n\ttmp = inv(r) * a[My] * r;\n\n\tfor (int i = 1; i <= N; i ++)\n\t\tprintf(\"%d \", tmp.x[i]);\n\tputs(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> apply(const vector<int> &a, const vector<int> &b)\n{\n\tvector<int> r(a.size());\n\n\tfor (int i = 0; i < b.size(); i++) r[i] = a[b[i]];\n\n\treturn move(r);\n}\n\nvector<int> pow(const vector<int> &a, int k)\n{\n\tvector<int> r(a.size());\n\n\tif (k == 0){\n\t\tfor (int i = 0; i < a.size(); i++) r[i] = i;\n\t}\n\telse{\n\t\tauto h = pow(a, k / 2);\n\t\tr = apply(h, h);\n\t\tif (k % 2){\n\t\t\tfor (int i = 0; i < r.size(); i++) r[i] = a[r[i]];\n\t\t}\n\t}\n\n\treturn move(r);\n}\n\n\nint main()\n{\n\tint N, K; scanf (\"%d %d\", &N, &K);\n\tvector<int> p(N), q(N), P(N), Q(N);\n\tfor (int i = 0; i < N; i++){\n\t\tscanf (\"%d\", &p[i]); p[i]--;\n\t\tP[p[i]] = i;\n\t}\n\tfor (int i = 0; i < N; i++){\n\t\tscanf (\"%d\", &q[i]); q[i]--;\n\t\tQ[q[i]] = i;\n\t}\n\n\tvector<int> r;\n\tif (K == 1) r = p;\n\telse{\n\t\tint u = (K - 2) / 6;\n\t\tvector<int> X = pow(apply(P, apply(q, apply(p, Q))), u);\n\n\t\tvector<int> C;\n\n\t\tif (K % 6 == 0) C = apply(p, Q);\n\t\tif (K % 6 == 1) C = apply(q, apply(p, Q));\n\t\tif (K % 6 == 2) C = q;\n\t\tif (K % 6 == 3) C = apply(q, P);\n\t\tif (K % 6 == 4) C = apply(q, apply(P, Q));\n\t\tif (K % 6 == 5) C = Q;\n\n\t\tint v = (K + 1) / 6;\n\t\tvector<int> Y = pow(apply(q, apply(P, apply(Q, p))), v);\n\n\t\tr = apply(Y, apply(C, X));\n\t}\n\n\tfor (int i = 0; i < N; i++) printf (\"%d%c\", r[i] + 1, i + 1 < N ? ' ' : '\\n');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint p[131072],invp[131072],q[131072],invq[131072];\nint f[131072],g[131072],invf[131072];\nint tmp[131072];\nint main()\n{\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&p[i]);\n\t\tinvp[p[i]]=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&q[i]);\n\t\tinvq[q[i]]=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tg[i]=q[invp[invq[p[i]]]];\n\t\tf[i]=i;\n\t}\n\tint kk=(k-1)/6;\n\twhile(kk)\n\t{\n\t\tif(kk&1)\n\t\t{\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\ttmp[i]=f[g[i]];\n\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tf[i]=tmp[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\ttmp[i]=g[g[i]];\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tg[i]=tmp[i];\n\t\t}\n\t\tkk>>=1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tinvf[f[i]]=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(k%6==1)\n\t\t{\n\t\t\tprintf(\"%d\",f[p[invf[i]]]);\n\t\t}\n\t\telse if(k%6==2)\n\t\t{\n\t\t\tprintf(\"%d\",f[q[invf[i]]]);\n\t\t}\n\t\telse if(k%6==3)\n\t\t{\n\t\t\tprintf(\"%d\",f[q[invp[invf[i]]]]);\n\t\t}\n\t\telse if(k%6==4)\n\t\t{\n\t\t\tprintf(\"%d\",f[q[invp[invq[invf[i]]]]]);\n\t\t}\n\t\telse if(k%6==5)\n\t\t{\n\t\t\tprintf(\"%d\",f[q[invp[invq[p[invq[invf[i]]]]]]]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\",f[q[invp[invq[p[p[invq[invf[i]]]]]]]]);\n\t\t}\n\t\tif(i==n)\n\t\t{\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputchar(' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int kMaxn = 1e5 + 10;\n\ntypedef int IAr[kMaxn];\n\nint n, k;\nIAr p, q, a[7], ip, iq, B, IB, buf;\n\nvoid SetId(int ar[]) {\n\tfor (int i = 1; i <= n; i++) ar[i] = i;\n}\nvoid Inv(int ar[], int rs[]) {\n\tfor (int i = 1; i <= n; i++) rs[ar[i]] = i;\n}\nvoid Mul(int ar[], int m[]) {\n\tfor (int i = 1; i <= n; i++) buf[i] = ar[m[i]];\n\tmemcpy(ar, buf, sizeof(int) * (n + 1));\n}\nvoid Mul(int ar[], int m[], int ret[]) {\n\tfor (int i = 1; i <= n; i++) buf[i] = ar[m[i]];\t\n\tmemcpy(ret, buf, sizeof(int) * (n + 1));\n}\nvoid FPow(int ar[], int ex);\nvoid Print(int ar[]);\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", p + i);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", q + i);\n\n\tmemcpy(a[1], p, sizeof(int) * (n + 1));\n\tmemcpy(a[2], q, sizeof(int) * (n + 1));\n\tfor (int i = 3; i <= 6; i++) {\n\t\tInv(a[i - 2], buf);\n\t\tMul(a[i - 1], buf, a[i]);\n\t}\n\n\tif (k <= 6) {\n\t\tPrint(a[k]);\n\t\treturn 0;\n\t}\n\tSetId(B);\n\tInv(q, iq), Inv(p, ip);\n\tMul(B, q), Mul(B, ip), Mul(B, iq), Mul(B, p);\n\tInv(B, IB);\n\n\tint ex = (k - 1) / 6;\n\tFPow(B, ex), FPow(IB, ex);\n\tMul(B, a[(k - 1) % 6 + 1]), Mul(B, IB);\n\n\tPrint(B);\n\treturn 0;\n}\n\nvoid FPow(int ar[], int ex) {\n\tstatic IAr bs, ret;\n\tmemcpy(bs, ar, sizeof(int) * (n + 1));\n\tSetId(ret);\n\tfor (; ex; Mul(bs, bs), ex >>= 1)\n\t\tif (ex & 1) Mul(ret, bs);\n\tmemcpy(ar, ret, sizeof(int) * (n + 1));\n}\n\nvoid Print(int ar[]) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%d \", ar[i]);\n\t}\n\tputchar('\\n');\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> inv (vector<int> v) {\n  int n = (int) v.size();\n  vector<int> ans (n);\n  for (int i = 0; i < n; i++) {\n    ans[v[i]] = i;\n  }\n  return ans;\n}\n\nvector<int> operator* (vector<int> p, vector<int> q) {\n  int n = (int) p.size();\n  vector<int> ans (n);\n  for (int i = 0; i < n; i++) {\n    ans[i] = p[q[i]];\n  }\n  return ans;\n}\n\nostream& operator<< (ostream &out, vector<int> p) {\n  for (int i = 0; i < (int) p.size(); i++) {\n    cout << p[i] + 1 << \" \";\n  }\n  return out;\n}\n\nvector<int> id (int n) {\n  vector<int> ans;\n  for (int i = 0; i < n; i++) {\n    ans.push_back(i);\n  }\n  return ans;\n}\n\nvector<int> exp (vector<int> p, int k) {\n  if (k == 0) return id(p.size());\n  if (k % 2 == 0) {\n    auto half = exp(p, k / 2);\n    return half * half;\n  }\n  return p * exp(p, k - 1);\n}\n\nint main () {\n  int n, k;\n  cin >> n >> k;\n\n  vector<int> p (n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    p[i]--;\n  }\n\n  vector<int> q (n);\n  for (int i = 0; i < n; i++) {\n    cin >> q[i];\n    q[i]--;\n  }\n\n  vector<int> ip = inv(p);\n  vector<int> iq = inv(q);\n  \n  k--;\n  if (k < 6) {\n    if (k == 0) cout << p << endl;\n    if (k == 1) cout << q << endl;\n    if (k == 2) cout << q * ip << endl;\n    if (k == 3) cout << q * ip * iq << endl;\n    if (k == 4) cout << q * ip * iq * p * iq << endl;\n    if (k == 5) cout << q * ip * iq * p * p * iq << endl;\n    return 0;\n  }\n\n  int pc = k / 6;\n  vector<int> pref = q * ip * iq;\n  pref = pref * exp(p * q * ip * iq, pc - 1);\n  k %= 6;\n\n  if (k >= 1) pref = pref * p;\n  if (k >= 3) pref = pref * q;\n  if (k >= 4) pref = pref * ip;\n  \n  vector<int> ipref = inv(pref);\n  if (k == 0) cout << pref * p * ipref << endl;\n  if (k == 1) cout << pref * q * ipref << endl;\n  if (k == 2) cout << pref * q * ip * ipref << endl;\n  if (k == 3) cout << pref * ip * ipref << endl;\n  if (k == 4) cout << pref * iq * ipref << endl;\n  if (k == 5) cout << pref * iq * p * ipref << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,k;\nint a[100001];\nint one[100001];\nint t[100001];\nvoid cpy(int* u,int* w){\n\tfor(int i=1; i<=n ;i++) w[i]=u[i];\n}\nint out(int* u){\n\tfor(int i=1; i<=n ;i++) cout << u[i] << ' ';\n\tcout << endl;\n\treturn 0;\n}\nvoid mul(int* u,int* v,int* w){\n\tfor(int i=1; i<=n ;i++) t[i]=v[u[i]];\n\tcpy(t,w);\n}\nvoid inv(int* u,int* w){\n\tfor(int i=1; i<=n ;i++) t[u[i]]=i;\n\tcpy(t,w);\n}\nvoid pw(int* u,int k,int* w){\n\tif(k==0){\n\t\tcpy(one,w);\n\t\treturn;\n\t}\n\tif(k%2==1){\n\t\tpw(u,k-1,w);mul(w,u,w);\n\t}\n\telse{\n\t\tpw(u,k/2,w);mul(w,w,w);\n\t}\n}\nint p[100001];\nint q[100001];\nint r[100001];\nint s[100001];\nint x[100001];\nint y[100001];\nint invp[100001];\nint invq[100001];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> k;\n\tfor(int i=1; i<=n ;i++) cin >> p[i];\n\tfor(int i=1; i<=n ;i++) cin >> q[i];\n\tfor(int i=1; i<=n ;i++) one[i]=i;\n\tif(k==1) return out(p);\n\tif(k==2) return out(q);\n\tinv(p,invp);\n\tinv(q,invq);\n\t//out(t);out(invq);\n\tif(k%6==1) cpy(p,r);\n\tif(k%6==2) cpy(q,r);\n\tif(k%6==3) mul(invp,q,r);\n\tif(k%6==4) cpy(invp,r);\n\tif(k%6==5) cpy(invq,r);\n\tif(k%6==0) mul(p,invq,r);\n\t//out(r);\n\tmul(invq,p,s);mul(s,q,s);mul(s,invp,s);\n\tint pl=(2*k-4)/3;\n\tpw(s,pl/4,x);\n\tif(pl%4>=1) mul(x,invq,x);\n\tif(pl%4>=2) mul(x,p,x);\n\tif(pl%4>=3) mul(x,q,x);\n\tmul(x,r,y);\n\tinv(x,x);\n\tmul(y,x,y);\n\tout(y);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nnamespace ProjectPermy\n{\n\tstruct perm\n\t{\n\t\tvector<int>v;\n\t\tint &operator[](int x){return v[x];}\n\t\tconst int &operator[](int x)const{return v[x];}\n\t\tint size()const{return v.size()-1;}\n\t\tvoid resize(int n){v.resize(n+1);}\n\t\tvoid read(int n){v.resize(n+1);for(int i=1;i<=size();i++)scanf(\"%d\",&v[i]);}\n\t\tvoid out()\n\t\t{\n\t\t\tfor(int i=1;i<=size();i++)\n\t\t\t\tprintf(\"%d \",v[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t};\n\tperm e(int n)\n\t{\n\t\tperm ans;\n\t\tans.resize(n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans[i]=i;\n\t\treturn ans;\n\t}\n\tperm operator*(perm a,perm b)\n\t{\n\t\tperm ans=e(a.size());\n\t\tperm rev=e(a.size());\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t\tans[i]=a[b[i]];\n\t\treturn ans;\n\t}\n\tperm operator~(perm a)\n\t{\n\t\tperm ans=e(a.size());\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t\tans[a[i]]=i;\n\t\treturn ans;\n\t}\n\tvoid find_cycle(perm a,int x,vector<int>vis,vector<int>&rem)\n\t{\n\t\tif(vis[x]) return;\n\t\tvis[x]=1;\n\t\trem.push_back(x);\n\t\tfind_cycle(a,a[x],vis,rem);\n\t}\n\tperm Pow(perm a,int x)\n\t{\n\t\tperm ans=e(a.size());\n\t\tvector<vector<int> >cycle;\n\t\tvector<int>vis;\n\t\tvis.resize(a.size()+2);\n\t\tfor(int i=1;i<=a.size();i++)\n\t\t{\n\t\t\tif(!vis[i])\n\t\t\t{\n\t\t\t\tvector<int> rem;\n\t\t\t\tfind_cycle(a,i,vis,rem);\n\t\t\t\tcycle.push_back(rem);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<cycle.size();i++)\n\t\t{\n\t\t\tfor(int j=0;j<cycle[i].size();j++)\n\t\t\t\tans[cycle[i][j]]=cycle[i][(j+x)%cycle[i].size()];\n\t\t}\n\t\treturn ans;\n\t}\n}\nusing namespace ProjectPermy;\nsigned main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tperm p,q;\n\tp.read(n);\n\tq.read(n);\n\tperm a[7];\n\ta[1]=p;\n\ta[2]=q;\n\tfor(int i=3;i<=6;i++)\n\t\ta[i]=a[i-1]*(~a[i-2]);\n\tif(m<=6)\n\t{\n\t\ta[m].out();\n\t\treturn 0;\n\t}\n\tperm g=q*(~p)*(~q)*p;\n\t(Pow(g,(m-1)/6)*a[(m-1)%6+1]*Pow(~g,(m-1)/6)).out();\n\treturn 0;\n}\n/*\n10 156046\n2 4 3 1 5 8 9 10 7 6\n2 4 3 1 5 8 9 10 7 6\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nvector<int> E;\nint n;\n\nvector<int> mul(vector<int> a, vector<int> b) {\n    vector<int> res(n);\n    for (int i = 0; i < n; i++) {\n        res[i] = a[b[i]];\n    }\n    return res;\n}\n\nvector<int> pow(vector<int> a, int k) {\n    vector<int> res = E;\n    while (k > 0) {\n        if (k % 2 == 1) {\n            res = mul(res, a);\n        }\n        a = mul(a, a);\n        k /= 2;\n    }\n    return res;\n}\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i]; a[i]--;\n    }\n    vector<int> b(n);\n    for (int i = 0; i < n; i++) {\n        cin >> b[i]; b[i]--;\n    }\n\n    vector<int> A(n);\n    vector<int> B(n);\n    for (int i = 0; i < n; i++) {\n        A[a[i]] = i;\n        B[b[i]] = i;\n    }\n\n    E.resize(n);\n    for (int i = 0; i < n; i++) E[i] = i;\n\n    vector<int> res;\n    if (k < 10) {\n        for (int i = 1; i < k; i++) {\n            vector<int> c = mul(b, A);\n            vector<int> C = mul(a, B);\n            a = b; A = B;\n            b = c; B = C;\n        }\n        res = a;\n    } else {\n        vector<int> left, right, mid;\n        left = mul(b, mul(A, mul(B, a)));\n        right = mul(A, mul(b, mul(a, B)));\n\n        left = pow(left, (k + 1) / 6);\n        right = pow(right, (k - 2) / 6);\n\n        if (k % 6 == 2) {\n            mid = b;\n        } else if (k % 6 == 3) {\n            mid = mul(b, A);\n        } else if (k % 6 == 4) {\n            mid = mul(b, mul(A, B));\n        } else if (k % 6 == 5) {\n            mid = B;\n        } else if (k % 6 == 0) {\n            mid = mul(a, B);\n        } else if (k % 6 == 1) {\n            mid = mul(b, mul(a, B));\n        }\n        res = mul(left, mul(mid, right));\n    }\n    \n    for (int i = 0; i < n; i++) {\n        cout << res[i] + 1 << \" \";\n    }\n    cout << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing perm = vector<int>;\nperm operator*(perm a, perm b){\n    perm *r = new perm();\n    r->resize(a.size());\n    for(size_t i=0;i<a.size();i++) (*r)[i] = a[b[i]-1];\n    return *r;\n}\nperm inv(perm a){\n    perm *r = new perm();\n    r->resize(a.size());\n    for(size_t i=0;i<a.size();i++) (*r)[a[i]-1] = i+1;\n    return *r;\n}\nperm pow(perm a, int n){\n    perm *r = new perm();\n    r->resize(a.size());\n    for(size_t i=0;i<a.size();i++) (*r)[i] = i+1;\n    if(n==0) return *r;\n    if(n==1) return *r*a;\n    delete r;\n    if(n%2) return pow(a*a, n/2)*a;\n    return pow(a*a, n/2);\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout.precision(12);\n    cout.setf(ios_base::fixed, ios_base::floatfield);\n    \n    int n, k;\n    vector<int> p, q, r, s;    \n    cin >> n >> k;\n    p.resize(n);\n    q.resize(n);\n    r.resize(n);\n    s.resize(n);\n    for(int i=0;i<n;i++) cin >> p[i];\n    for(int i=0;i<n;i++) cin >> q[i];\n    \n    s = q*inv(p)*inv(q)*p;\n    s = pow(s, (k-1)/6);\n    if(k%6==1) copy(p.begin(), p.end(), r.begin());\n    else if(k%6==2) copy(q.begin(), q.end(), r.begin());\n    else{\n        for(int i=3;i<=(k-1)%6+1;i++){\n            r = q*inv(p);\n            copy(q.begin(), q.end(), p.begin());\n            copy(r.begin(), r.end(), q.begin());\n        }\n    }    \n\n    r = s*r*inv(s);\n    for(int i=0;i<n;i++) cout << r[i] << \" \\n\"[i==n-1];\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\nusing ld = long double;\nusing ll = long long;\nusing ull = unsigned long long;\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename T>\nconstexpr T MOD = static_cast<T>(1000000007);\ntemplate <typename F>\nconstexpr F PI() { return 3.1415926535897932385; }\n#define SHOW(...) (std::cerr << \"(\" << #__VA_ARGS__ << \") = (\"), HogeHogeSansuu(__VA_ARGS__), std::cerr << \")\" << std::endl;\nstruct has_debugPrint_impl\n{\n    template <class T>\n    static auto check(T&& x) -> decltype(x.debugPrint(), std::true_type{});\n    template <class T>\n    static auto check(...) -> std::false_type;\n};\ntemplate <class T>\nclass has_debugPrint : public decltype(has_debugPrint_impl::check<T>(std::declval<T>()))\n{\n};\ntemplate <bool>\nstruct HogeHogeDump\n{\n    template <typename T>\n    static void dump(const T& x) { x.debugPrint(); }\n};\ntemplate <>\nstruct HogeHogeDump<false>\n{\n    template <typename T>\n    static void dump(const T& x) { std::cerr << x; }\n};\nvoid HogeHogeSansuu() { ; }\ntemplate <typename T>\nvoid HogeHogeSansuu(const T& x) { HogeHogeDump<has_debugPrint<T>::value>::dump(x); }\ntemplate <typename T, typename... Args>\nvoid HogeHogeSansuu(const T& x, Args... args) { HogeHogeDump<has_debugPrint<T>::value>::dump(x), std::cerr << \",\", HogeHogeSansuu(args...); }\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return a = std::min(a, b), a == b; }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return a = std::max(a, b), a == b; }\ntemplate <typename T, typename F>\nvoid For(const T s, const T t, const F f)\n{\n    for (T i = s; i != t; i += T(s < t ? 1 : -1)) { f(i); }\n}\ntemplate <typename T, typename F>\nvoid Rep(const T N, const F f) { For<T, F>(0, N, f); }\ntemplate <typename T, typename F>\nvoid RRep(const T N, const F f) { For<T, F>(N - 1, -1, f); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T PopCount(const T u)\n{\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), PopCount(v);\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return (v << 1) == (T(1) << (log2p1(v))); }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return ispow2(v) ? v : T(1) << log2p1(v); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : ispow2(v) ? v : T(1) << (log2p1(v) - 1); }\ntemplate <typename T>\nstruct Accum\n{\n    template <typename InIt>\n    Accum(const InIt first, const InIt last) : accum(std::size_t(std::distance(first, last))) { std::partial_sum(first, last, accum.begin()); }\n    T sum(const std::size_t i) const { return i == 0 ? T(0) : accum[i - 1]; }\n    T sum(const std::size_t l, const std::size_t r) const { return sum(r) - sum(l); }\n    std::vector<T> accum;\n};\ntemplate <typename T>\nstruct Accum2D\n{\n    Accum2D(const std::vector<std::vector<T>>& t) : accum{t}\n    {\n        for (std::size_t i = 0; i < accum.size(); i++) {\n            for (std::size_t j = 1; j < accum[i].size(); j++) { accum[i][j] += accum[i][j - 1]; }\n        }\n        for (std::size_t i = 1; i < accum.size(); i++) {\n            for (std::size_t j = 0; j < accum[i].size(); j++) { accum[i][j] += accum[i - 1][j]; }\n        }\n    }\n    T sum(const std::size_t y, const std::size_t x) const { return y == 0 or x == 0 ? T(0) : accum[y - 1][x - 1]; }\n    T sum(const std::size_t ymin, const std::size_t ysup, const std::size_t xmin, const std::size_t xsup) const { return sum(ysup, xsup) - sum(ymin, xmin); }\n    std::vector<std::vector<T>> accum;\n};\ntemplate <typename T>\nstruct Zip\n{\n    template <typename InIt>\n    Zip(const InIt first, const InIt last) : unzip(std::size_t(std::distance(first, last)))\n    {\n        std::copy(first, last, unzip), std::sort(unzip.begin(), unzip.end()), unzip.erase(std::unique(unzip.begin(), unzip.end()), unzip.end());\n        for (std::size_t i = 0; i < unzip.size(); i++) { zip[unzip[i]] = i; }\n    }\n    std::vector<T> unzip;\n    std::map<T, std::size_t> zip;\n};\ntemplate <typename T, std::size_t N>\nstd::ostream& operator<<(std::ostream& os, const std::array<T, N>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::deque<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::multimap<K, T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::multiset<T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::map<K, T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::pair<T1, T2>& v) { return (os << \"<\" << v.first << \",\" << v.second << \">\"); }\ntemplate <typename T1, typename T2, typename T3>\nstd::ostream& operator<<(std::ostream& os, const std::priority_queue<T1, T2, T3>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.top() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::queue<T1>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.front() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::set<T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::stack<T1>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.top() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename K, typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_multimap<K, T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_multiset<T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_map<K, T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_set<T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    int N, K;\n    std::cin >> N >> K, K--;\n    std::vector<int> p(N), q(N), rp(N), rq(N);\n    for (int i = 0; i < N; i++) { std::cin >> p[i], p[i]--, rp[p[i]] = i; }\n    for (int i = 0; i < N; i++) { std::cin >> q[i], q[i]--, rq[q[i]] = i; }\n    auto hoge = [&](const std::vector<int>& p, const std::vector<int>& q) -> std::vector<int> {\n        std::vector<int> ans(N);\n        for (int i = 0; i < N; i++) { ans[i] = p[q[i]]; }\n        return ans;\n    };\n    auto id = [&]() {\n        std::vector<int> ans(N);\n        std::iota(ans.begin(), ans.end(), 0);\n        return ans;\n    };\n    const std::vector<int> P = hoge(hoge(q, rp), hoge(rq, p));\n    const auto C = K % 6 == 0 ? p : K % 6 == 1 ? q : K % 6 == 2 ? hoge(q, rp) : K % 6 == 3 ? rp : K % 6 == 4 ? rq : hoge(rq, p);\n    const auto R = K % 6 <= 2 ? id() : K % 6 == 3 ? q : hoge(q, rp);\n    auto power = [&](auto&& self, const std::vector<int>& p, const int K) -> std::vector<int> {\n        if (K == 0) {\n            return id();\n        } else if (K % 2 == 1) {\n            return hoge(self(self, p, K - 1), p);\n        } else {\n            const auto pp = self(self, p, K / 2);\n            return hoge(pp, pp);\n        }\n    };\n    const auto Q = hoge(power(power, P, K / 6), R);\n    std::vector<int> RQ(N);\n    for (int i = 0; i < N; i++) { RQ[Q[i]] = i; }\n    const auto ans = hoge(Q, hoge(C, RQ));\n    for (int i = 0; i < N; i++) { std::cout << ans[i] + 1 << \" \"; }\n    std::cout << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long LL;\nconst int N = 6e3+10;\ninline int read()\n{\n\tregister int x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n , len , anslen;\nint sum[N];\nchar s[N] , ans[N];\n\nbool check(int i , int j)\n{\n\tif(i > j) return false;\n\tif(sum[j - 1] - sum[i] > 0 && sum[j] - sum[i] == j - i - 1) return false;\n\treturn true;\n}\n\nvoid updatechar()\n{\n\tint posa = 0 , posb = 0;\n\tfor(int i = 1 ; i <= len ; ++i) sum[i] = sum[i-1] + (s[i] == 'a');\n\tfor(int i = 1 , j = 1 ; i <= len ; ++i) if(s[i] == 'a')\n\t{\n\t\twhile(s[j] != 'b') j++;\n\t\tif(check(i , j)) { posa = i , posb = j; break; }\n\t\tj++;\n\t}\n\tif(!posa && !posb) return;\n\tint tot = 0;\n\tfor(int i = 1 ; i <= len ; ++i) if(i != posa && i != posb) s[++tot] = s[i];\n\ts[tot+1] = s[tot+2] = '\\0';\n\tlen = tot;\n}\n\nvoid updateans()\n{\n\tif(!anslen)\n\t{\n\t\tfor(int i = 1 ; i <= len ; ++i) ans[i] = s[i];\n\t\tanslen = len; return ;\n\t}\n\tint tmp = min(anslen , len) , flag = 2;\n\tfor(int i = 1 ; i <= tmp ; ++i) \n\t\tif(s[i] > ans[i]) { flag = 1; break; }\n\t\telse\n\t\tif(s[i] < ans[i]) { flag = 0; break; }\n\tif(flag == 1)\n\t{\n\t\tfor(int i = 1 ; i <= len ; ++i) ans[i] = s[i];\n\t\tanslen = len;\n\t}\n\telse\n\tif(flag == 0) return ;\n\telse\n\t{\n\t\tif(anslen < len)\n\t\t{\n\t\t\tfor(int i = 1 ; i <= len ; ++i) ans[i] = s[i];\n\t\t\tanslen = len;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tn = read(); scanf(\"%s\" , s+1); len = n * 2;\n\tfor(int i = 1 ; i <= n ; ++i)\n\t\tupdatechar() , updateans();\n\tcout << (ans + 1) << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(c)      int(c.size())\n#define rep(i,a,b) for (int i=a; i<(b); ++i)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); --i)\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\n\nint const MAXN=110000;\n\nvi pneg(const vi &p) {\n\tvi P(sz(p));\n\trep(i,0,sz(p)) P[p[i]]=i;\n\treturn P;\n}\n\nvoid pmul(const vi &p,const vi &q,vi &res) {\n\tstatic int tmp[MAXN];\n\trep(i,0,sz(p)) tmp[i]=p[q[i]];\n\trep(i,0,sz(p)) res[i]=tmp[i];\n}\n\nvi ppow(vi p,int n) {\n\tvi res(sz(p));\n\trep(i,0,sz(p)) res[i]=i;\n\twhile (n>0) {\n\t\tif (n%2) pmul(res,p,res);\n\t\tpmul(p,p,p);\n\t\tn/=2;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(10);\n\n\tint N,K;\n\tcin>>N>>K;\n\tK--;\n\t\n\tvi p(N),q(N);\n\trep(i,0,N) {\n\t\tcin>>p[i];\n\t\tp[i]--;\n\t}\n\trep(i,0,N) {\n\t\tcin>>q[i];\n\t\tq[i]--;\n\t}\n\t\n\tvi P=pneg(p);\n\tvi Q=pneg(q);\n\t\n\t// a=qPQp\n\tvi a(N);\n\tpmul(q,P,a);\n\tpmul(a,Q,a);\n\tpmul(a,p,a);\n\t\n\t// a=a^(K/6)\n\ta=ppow(a,K/6);\n\t\n\tvi b(N);\n\tswitch (K%6) {\n\t\tcase 0:\n\t\t\tb=p;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tb=q;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t// b=qP\n\t\t\tpmul(q,P,b);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t// b=qPQ\n\t\t\tpmul(q,P,b);\n\t\t\tpmul(b,Q,b);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t// b=qPQpQ\n\t\t\tpmul(q,P,b);\n\t\t\tpmul(b,Q,b);\n\t\t\tpmul(b,p,b);\n\t\t\tpmul(b,Q,b);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t// b=qPQppQ\n\t\t\tpmul(q,P,b);\n\t\t\tpmul(b,Q,b);\n\t\t\tpmul(b,p,b);\n\t\t\tpmul(b,p,b);\n\t\t\tpmul(b,Q,b);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t}\n\t\n\tvi res(N);\n\tpmul(a,b,res);\n\tpmul(res,pneg(a),res);\n\t\n\trep(i,0,N) cout<<res[i]+1<<\" \\n\"[i+1==N];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nvector <int> inv(const vector <int> &v) {\n    int i;\n    vector <int> iv(v.size());\n    \n    for (i = 0; i < v.size(); i++) iv[v[i]] = i;\n    \n    return iv;\n}\n\nvector <int> mul(const vector <int> &v, const vector <int> &w) {\n    int i;\n    vector <int> z;\n    \n    for (i = 0; i < v.size(); i++) z.push_back(v[w[i]]);\n    \n    return z;\n}\n\nvector <int> pow(const vector <int> &v, int n) {\n    int i;\n    vector <int> w = v, z;\n    \n    for (i = 0; i < v.size(); i++) z.push_back(i);\n    \n    while (n > 0) {\n        if (n & 1) z = mul(z, w);\n        w = mul(w, w);\n        n >>= 1;\n    }\n    \n    return z;\n}\n\nint main() {\n    int n, k, i;\n    vector <int> p, q, ip, iq, v, a, b, ans;\n    \n    scanf(\"%d %d\", &n, &k);\n    \n    for (i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        p.push_back(x - 1);\n    }\n    \n    for (i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        q.push_back(x - 1);\n    }\n    \n    ip = inv(p);\n    iq = inv(q);\n    \n    v = pow(mul(q, mul(ip, mul(iq, p))), (k - 1) / 6);\n    \n    if (k % 6 == 1) {\n        a = v;\n        b = p;\n    } else if (k % 6 == 2) {\n        a = v;\n        b = q;\n    } else if (k % 6 == 3) {\n        a = v;\n        b = mul(q, ip);\n    } else if (k % 6 == 4) {\n        a = mul(v, q);\n        b = ip;\n    } else if (k % 6 == 5) {\n        a = mul(v, mul(q, ip));\n        b = iq;\n    } else {\n        a = mul(v, mul(q, ip));\n        b = mul(iq, p);\n    }\n    \n    ans = mul(a, mul(b, inv(a)));\n    \n    for (i = 0; i < v.size(); i++) {\n        if (i > 0) putchar(' ');\n        printf(\"%d\", ans[i] + 1);\n    }\n    puts(\"\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n#include <numeric>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\\n\";\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\\n\"\n#define dbv(a) cerr << #a << \" = \"; for (auto xxxx: a) cerr << xxxx << \" \"; cerr << endl\n\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing perm = vector<int>;\n\nperm one(int n) {\n  perm p = perm(n);\n  for (int i = 0; i < n; i++) {\n    p[i] = i;\n  }\n  return p;\n}\n\nperm operator*(const perm& a, const perm& b) {\n  perm res(a.size());\n  for (int i = 0; i < (int)a.size(); i++) {\n    res[i] = b[a[i]];\n  }\n  return res;\n}\n\nperm operator^(perm a, int k) {\n  perm res = one(a.size());\n  while (k) {\n    if (k & 1) res = res * a;\n    a = a * a;\n    k /= 2;\n  }\n  return res;\n}\n\nperm operator~(const perm& a) {\n  perm res(a.size());\n  for (int i = 0; i < (int)a.size(); i++) {\n    assert(0 <= a[i] && a[i] < (int)a.size());\n    res[a[i]] = i;\n  }\n  return res;\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"d.in\", \"r\", stdin);\n  freopen(\"d.out\", \"w\", stdout);\n#endif\n\n  int n, k;\n  while (scanf(\"%d%d\", &n, &k) == 2) {\n    perm p(n), q(n);\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d\", &p[i]);\n      --p[i];\n    }\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d\", &q[i]);\n      --q[i];\n    }\n\n    perm lm, rm;\n\n    int deg = (k - 12) / 6;\n    if (deg > 0) {\n      perm ip = ~p;\n      perm iq = ~q;\n      lm = (iq * p * q * ip);\n      rm = (p * iq * ip * q);\n      lm = lm ^ deg;\n      rm = rm ^ deg;\n      k -= deg * 6;\n    } else {\n      lm = rm = one(n);\n    }\n\n    for (int i = 2; i < k; i++) {\n      perm t = (~p) * q;\n      p = q;\n      q = t;\n    }\n\n    perm ans;\n    if (k == 1) {\n      ans = p;\n    } else {\n      ans = q;\n    }\n\n    ans = lm * ans * rm;\n\n    for (int i : ans) {\n      printf(\"%d \", i + 1);\n    }\n    printf(\"\\n\");\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long double ldb ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 2e6 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int mod = 1e9 + 7 ;\nconst db eps = 1e-10 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nint n, k;\n\nstruct permutations\n{\n\tint pos[maxn];\n\tpermutations(){rep(i, 1, n) pos[i] = i;}\n\tfriend permutations operator * (permutations p, permutations q)\n\t{\n\t\tpermutations ret;\n\t\trep(i, 1, n) ret.pos[i] = p.pos[q.pos[i]];\n\t\treturn ret;\n\t}\n\tpermutations operator *= (permutations b)\n\t{\n\t\treturn *this = *this * b;\n\t}\n};\n\npermutations a, b, mul, ans;\n\npermutations inv(permutations a)\n{\n\tpermutations ret;\n\trep(i, 1, n) ret.pos[a.pos[i]] = i;\n\treturn ret;\n}\n\npermutations power(permutations a, ll b)\n{\n\tpermutations ret;\n\tfor (; b; b >>= 1, a *= a) if(b & 1) ret *= a;\n\treturn ret;\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &k);\n\trep(i, 1, n) scanf(\"%d\", &a.pos[i]);\n\trep(i, 1, n) scanf(\"%d\", &b.pos[i]);\n\tmul = power(b * inv(a) * inv(b) * a, (k - 1) / 6);\n\tk = (k - 1) % 6 + 1;\n\tif(k == 1) ans = mul * a * inv(mul);\n\telse if(k == 2) ans = mul * b * inv(mul);\n\telse if(k == 3) ans = mul * b * inv(a) * inv(mul);\n\telse if(k == 4) ans = mul * b * inv(a) * inv(b) * inv(mul);\n\telse if(k == 5) ans = mul * b * inv(a) * inv(b) * a * inv(b);\n\telse ans = mul * b * inv(a) * inv(b) * a * a * inv(b) * inv(mul);\n\trep(i, 1, n) printf(\"%d%c\", ans.pos[i], \" \\n\"[i == n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf = 1.01e9;\nconst i64 inf64 = 4.01e18;\nconst double eps = 1e-9;\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// q(p(i))\nvector<i64> composite(const vector<i64> &p, const vector<i64> &q){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n) res[i]=q[p[i]];\n    return res;\n}\n\nvector<i64> inverse(const vector<i64> &p){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n) res[p[i]]=i;\n    return res;\n}\n\nvector<i64> pow(vector<i64> p,i64 k){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n){\n        res[i]=i;\n    }\n    while(k){\n        if(k&1){\n            res=composite(res,p);\n        }\n        p=composite(p,p);\n        k>>=1;\n    }\n    return res;\n}\n\nvector<i64> f(const vector<i64> &p,const vector<i64> &q){\n    const i64 n=p.size();\n    vector<i64> res(n);\n    rep(i,0,n) res[p[i]]=q[i];\n    return res;\n}\n\nvoid solve() {\n    //const i64 mod = 1'000'000'007;\n\n    /*\n    vector<string> vs(30);\n    vs[1]=\"a\";\n    vs[2]=\"b\";\n    rep(i,3,vs.size()){\n        vs[i]=vs[i-1];\n        for(i64 j=vs[i-2].size()-1; j>=0; --j){\n            char c=vs[i-2][j];\n            if(c=='a'){\n                if(vs[i].back()=='a') vs[i].pop_back();\n                else vs[i]+='A';\n            }\n            if(c=='A'){\n                if(vs[i].back()=='A') vs[i].pop_back();\n                else vs[i]+='a';\n            }\n            if(c=='b'){\n                if(vs[i].back()=='b') vs[i].pop_back();\n                else vs[i]+='B';\n            }\n            if(c=='B'){\n                if(vs[i].back()=='B') vs[i].pop_back();\n                else vs[i]+='b';\n            }\n        }\n    }\n    rep(i,1,vs.size()){\n        cout << i << \": \" << vs[i] << endl;\n    }\n     */\n\n    i64 N,K;\n    cin >> N >> K;\n\n    vector<i64> p(N),q(N);\n    rep(i,0,N){\n        cin >> p[i];\n        --p[i];\n    }\n    rep(i,0,N){\n        cin >> q[i];\n        --q[i];\n    }\n\n    if(K<=15){\n        vector<vector<i64>> a(K+1);\n        a[1]=p;\n        a[2]=q;\n        rep(i,3,K+1){\n            a[i]=f(a[i-2],a[i-1]);\n        }\n        rep(i,0,N){\n            cout << a[K][i]+1;\n            if(i==N-1) cout << endl;\n            else cout << \" \";\n        }\n        return;\n    }\n    \n    return;\n\n    vector<i64> pi=inverse(p),qi=inverse(q);\n\n    auto x= composite(composite(composite(p, qi), pi), q);\n    auto y= composite(composite(composite(qi, p), q), pi);\n\n    i64 loop=(K-2)/6, rem=K-(2+loop*6);\n    auto prev=composite(composite(inverse(pow(x,loop)),p),pow(x,loop));\n    auto ans=composite(composite(pow(y,loop),q),pow(x,loop));\n    rep(i,0,rem){\n        auto tmp=ans;\n        ans=f(prev,ans);\n        prev=tmp;\n    }\n\n    rep(i,0,N){\n        cout << ans[i]+1;\n        if(i==N-1) cout << endl;\n        else cout << \" \";\n    }\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport GHC.Exts (build)\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  p <- VU.map (subtract 1) . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  q <- VU.map (subtract 1) . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) $ query p q k) mempty\n\n\nquery :: (?n :: Int) => Perm -> Perm -> Int -> Perm\nquery !p_immut !q_immut !k = VU.create $ do\n  p <- VU.unsafeThaw p_immut\n  q <- VU.unsafeThaw q_immut\n  tmp_reg <- VUM.new (?n * 2)\n  let (!tmp0,!tmp1) = VUM.splitAt ?n tmp_reg\n      (!kd6, !km6) = (k-1) `divMod` 6\n      loop p q next 0  = return (p,q,next)\n      loop p q next !k = do\n        forM_ [0 .. ?n-1] $ \\ !i -> do\n          pi <- VUM.read p i\n          VUM.write next pi =<< VUM.read q i\n        loop q next p (k-1)\n  (pp, qq, tmp2) <- loop p q tmp0 km6 -- (pp,qq) = F^km6(p,q)\n      -- now tmp0,p,q are unusable\n      -- Meaningful values are in pp and qq; tmp1 and tmp2 are free.\n  forM_ [0 .. ?n-1] $ \\ !i -> do -- tmp1 = qq*(qq*pp)^{-1}\n    qpi <- VUM.read qq =<< VUM.read pp i\n    VUM.write tmp1 qpi =<< VUM.read qq i\n  forM_ [0 .. ?n-1] $ \\ !i -> do -- tmp2 = tmp1*pp\n    VUM.write tmp2 i =<< VUM.read tmp1 =<< VUM.read pp i\n      -- Values for later use are in tmp2 and pp\n      -- tmp1 and qq have meaningful values, but will not be used later,\n      -- and thus are free\n  let pow b tmp res !e = do\n        forM_ [0 .. ?n-1] $ \\ !i -> VUM.write res i i\n        when (e > 0) $ powloop b tmp res e\n      powloop b tmp res !e = do\n        when (odd e) $ forM_ [0 .. ?n-1] $ \\ !i ->\n          VUM.write res i =<< VUM.read b =<< VUM.read res i\n        let !e1 = e `shiftR` 1\n        when (e1 > 0) $ do\n          forM_ [0 .. ?n-1] $ \\ !i ->\n            VUM.write tmp i =<< VUM.read b =<< VUM.read b i\n          powloop tmp b res e1\n  pow tmp2 qq tmp1 kd6 -- tmp1 = (tmp2)^kd6\n    -- Now tmp2 and qq are freed and hold meaningless values\n  forM_ [0 .. ?n - 1] $ \\ !i -> do -- tmp2 = tmp1*pp*(tmp1)^{-1}\n    tmp1i <- VUM.read tmp1 i\n    VUM.write tmp2 tmp1i =<< VUM.read tmp1 =<< VUM.read pp i\n  return tmp2\n  \n  \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n-- The following code is copy-paste from the Data.List\n-- in the package base-4.12.0.0.\n-- For the license text, see http://hackage.haskell.org/package/base-4.12.0.0.\n\n\n-- | 'iterate\\'' is the strict version of 'iterate'.\n--\n-- It ensures that the result of each application of force to weak head normal\n-- form before proceeding.\n{-# NOINLINE [1] iterate' #-}\niterate' :: (a -> a) -> a -> [a]\niterate' f x =\n    let x' = f x\n    in x' `seq` (x : iterate' f x')\n\n{-# INLINE [0] iterate'FB #-} -- See Note [Inline FB functions]\niterate'FB :: (a -> b -> b) -> (a -> a) -> a -> b\niterate'FB c f x0 = go x0\n  where go x =\n            let x' = f x\n            in x' `seq` (x `c` go x')\n\n{-# RULES\n\"iterate'\"    [~1] forall f x.   iterate' f x = build (\\c _n -> iterate'FB c f x)\n\"iterate'FB\"  [1]                iterate'FB (:) = iterate'\n #-}\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport qualified Data.Foldable as F\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor_main = sympow (conjinv q p `comp` p) kd6\n      ans = (!! km6)\n        [conj actor_main p,\n         conj actor_main q,\n         conj actor_main (f p q),\n         conjinv (actor_main `comp` q) p,\n         conjinv (comp actor_main q `g` p) q,\n         conj (comp actor_main q `g` comp q p) (g p q)]\n  BSB.hPutBuilder stdout\n    $ F.fold\n    $ V.imap (\\i -> if i > 0 then (BSB.char7 ' ' <>) else id)\n    $ V.map BSB.intDec $ V.convert $ VU.map (+1) ans\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport GHC.Exts (build)\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  p <- VU.map (subtract 1) . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  q <- VU.map (subtract 1) . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) $ query p q k) mempty\n\n\nquery :: (?n :: Int) => Perm -> Perm -> Int -> Perm\nquery !p_immut !q_immut !k = VU.create $ do\n  p <- VU.unsafeThaw p_immut\n  q <- VU.unsafeThaw q_immut\n  tmp_reg <- VUM.new (?n * 2)\n  let (!tmp0,!tmp1) = VUM.splitAt ?n tmp_reg\n      (!kd6, !km6) = (k-1) `divMod` 6\n      loop !p !q !next 0  = return (p,q,next)\n      loop !p !q !next !k = do\n        forM_ [0 .. ?n-1] $ \\ !i -> do\n          !pi <- VUM.unsafeRead p i\n          (VUM.write next pi $!) =<< VUM.unsafeRead q i\n        loop q next p (k-1)\n  (!pp, !qq, !tmp2) <- loop p q tmp0 km6 -- (pp,qq) = F^km6(p,q)\n      -- now tmp0,p,q are unusable\n      -- Meaningful values are in pp and qq; tmp1 and tmp2 are free.\n  forM_ [0 .. ?n-1] $ \\ !i -> do -- tmp1 = qq*(qq*pp)^{-1}\n    !qpi <- (VUM.unsafeRead qq $!) =<< VUM.unsafeRead pp i\n    (VUM.unsafeWrite tmp1 qpi $!) =<< VUM.unsafeRead qq i\n  forM_ [0 .. ?n-1] $ \\ !i -> do -- tmp2 = tmp1*pp\n    (VUM.unsafeWrite tmp2 i $!)\n      =<< (VUM.unsafeRead tmp1 $!) =<< VUM.unsafeRead pp i\n      -- Values for later use are in tmp2 and pp\n      -- tmp1 and qq have meaningful values, but will not be used later,\n      -- and thus are free\n  let pow !b !tmp !res !e = do\n        forM_ [0 .. ?n-1] $ \\ !i -> VUM.unsafeWrite res i i\n        when (e > 0) $ powloop b tmp res e\n      powloop !b !tmp !res !e = do\n        when (odd e) $ forM_ [0 .. ?n-1] $ \\ !i ->\n          (VUM.unsafeWrite res i $!)\n          =<< (VUM.unsafeRead b $!) =<< VUM.unsafeRead res i\n        let !e1 = e `shiftR` 1\n        when (e1 > 0) $ do\n          forM_ [0 .. ?n-1] $ \\ !i ->\n            (VUM.unsafeWrite tmp i $!)\n            =<< (VUM.unsafeRead b $!) =<< VUM.unsafeRead b i\n          powloop tmp b res e1\n  pow tmp2 qq tmp1 kd6 -- tmp1 = (tmp2)^kd6\n    -- Now tmp2 and qq are freed and hold meaningless values\n  forM_ [0 .. ?n - 1] $ \\ !i -> do -- tmp2 = tmp1*pp*(tmp1)^{-1}\n    !tmp1i <- VUM.unsafeRead tmp1 i\n    (VUM.unsafeWrite tmp2 tmp1i $!)\n      =<< (VUM.unsafeRead tmp1 $!) =<< VUM.unsafeRead pp i\n  return tmp2\n  \n  \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor_main = sympow (conjinv q p `comp` p) kd6\n      ans = (!! km6)\n        [conj actor_main p,\n         conj actor_main q,\n         conj actor_main (f p q),\n         conjinv (actor_main `comp` q) p,\n         conjinv (comp actor_main q `g` p) q,\n         conj (comp actor_main q `g` comp q p) (g p q)]\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) mempty\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport qualified Data.Foldable as F\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor_main = sympow (conjinv q p `comp` p) kd6\n      ans = (!! km6)\n        [conj actor_main p,\n         conj actor_main q,\n         conj actor_main (f p q),\n         conjinv (actor_main `comp` q) p,\n         conjinv (comp actor_main q `g` p) q,\n         conj (comp actor_main q `g` comp q p) (g p q)]\n  putStrLn $ unwords $ V.toList $ V.map show $ V.convert $ VU.map (+1) ans\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor = sympow (conjinv q p `comp` p) kd6\n      p1 = conj actor p\n      q1 = conj actor q\n      ans = fst $ (!! km6) $ iterate' (\\(!x,!y) -> (y,f x y)) (p1,q1)\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) (BSB.byteString BS.empty)\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n-- The following code is copy-paste from the Data.List\n-- in the package base-4.12.0.0.\n-- For the license text, see http://hackage.haskell.org/package/base-4.12.0.0.\n\n#if !MIN_VERSION_base(4,11,0)\n-- | 'iterate\\'' is the strict version of 'iterate'.\n--\n-- It ensures that the result of each application of force to weak head normal\n-- form before proceeding.\n{-# NOINLINE [1] iterate' #-}\niterate' :: (a -> a) -> a -> [a]\niterate' f x =\n    let x' = f x\n    in x' `seq` (x : iterate' f x')\n\n{-# INLINE [0] iterate'FB #-} -- See Note [Inline FB functions]\niterate'FB :: (a -> b -> b) -> (a -> a) -> a -> b\niterate'FB c f x0 = go x0\n  where go x =\n            let x' = f x\n            in x' `seq` (x `c` go x')\n\n{-# RULES\n\"iterate'\"    [~1] forall f x.   iterate' f x = build (\\c _n -> iterate'FB c f x)\n\"iterate'FB\"  [1]                iterate'FB (:) = iterate'\n #-}\n#endif\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport GHC.Exts (build)\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  p <- VU.map (subtract 1) . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  q <- VU.map (subtract 1) . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) $ query p q k) mempty\n\n\nquery :: (?n :: Int) => Perm -> Perm -> Int -> Perm\nquery !p_immut !q_immut !k = VU.create $ do\n  p <- VU.unsafeThaw p_immut\n  q <- VU.unsafeThaw q_immut\n  tmp_reg <- VUM.new (?n * 2)\n  let (!tmp0,!tmp1) = VUM.splitAt ?n tmp_reg\n      (!kd6, !km6) = (k-1) `divMod` 6\n      loop !p !q !next 0  = return (p,q,next)\n      loop !p !q !next !k = do\n        forM_ [0 .. ?n-1] $ \\ !i -> do\n          pi <- VUM.unsafeRead p i\n          VUM.write next pi =<< VUM.unsafeRead q i\n        loop q next p (k-1)\n  (!pp, !qq, !tmp2) <- loop p q tmp0 km6 -- (pp,qq) = F^km6(p,q)\n      -- now tmp0,p,q are unusable\n      -- Meaningful values are in pp and qq; tmp1 and tmp2 are free.\n  forM_ [0 .. ?n-1] $ \\ !i -> do -- tmp1 = qq*(qq*pp)^{-1}\n    qpi <- VUM.unsafeRead qq =<< VUM.unsafeRead pp i\n    VUM.unsafeWrite tmp1 qpi =<< VUM.unsafeRead qq i\n  forM_ [0 .. ?n-1] $ \\ !i -> do -- tmp2 = tmp1*pp\n    VUM.unsafeWrite tmp2 i\n      =<< VUM.unsafeRead tmp1 =<< VUM.unsafeRead pp i\n      -- Values for later use are in tmp2 and pp\n      -- tmp1 and qq have meaningful values, but will not be used later,\n      -- and thus are free\n  let pow !b !tmp !res !e = do\n        forM_ [0 .. ?n-1] $ \\ !i -> VUM.unsafeWrite res i i\n        when (e > 0) $ powloop b tmp res e\n      powloop !b !tmp !res !e = do\n        when (odd e) $ forM_ [0 .. ?n-1] $ \\ !i ->\n          VUM.unsafeWrite res i\n          =<< VUM.unsafeRead b =<< VUM.unsafeRead res i\n        let !e1 = e `shiftR` 1\n        when (e1 > 0) $ do\n          forM_ [0 .. ?n-1] $ \\ !i ->\n            VUM.unsafeWrite tmp i\n            =<< VUM.unsafeRead b =<< VUM.unsafeRead b i\n          powloop tmp b res e1\n  pow tmp2 qq tmp1 kd6 -- tmp1 = (tmp2)^kd6\n    -- Now tmp2 and qq are freed and hold meaningless values\n  forM_ [0 .. ?n - 1] $ \\ !i -> do -- tmp2 = tmp1*pp*(tmp1)^{-1}\n    tmp1i <- VUM.unsafeRead tmp1 i\n    VUM.unsafeWrite tmp2 tmp1i\n      =<< VUM.unsafeRead tmp1 =<< VUM.unsafeRead pp i\n  return tmp2\n  \n  \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport qualified Data.Foldable as F\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor_main = sympow (conjinv q p `comp` p) kd6\n      ans = (!! km6)\n        [conj actor_main p,\n         conj actor_main q,\n         conj actor_main (f p q),\n         conjinv (actor_main `comp` q) p,\n         conjinv (comp actor_main q `g` p) q,\n         conj (comp actor_main q `g` comp q p) (g p q)]\n  BSB.hPutBuilder stdout\n    $ F.fold\n    $ V.imap (\\i -> if i > 0 then (BSB.char7 ' ' <>) else id)\n    $ V.map BSB.intDec $ V.convert ans\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\nimport Control.Monad\nimport Data.List\nimport Data.Int\nimport qualified Data.Vector.Unboxed as V\nimport qualified Data.Vector.Unboxed.Mutable as VM\n\ninfixl 7 <.>\n\nnewtype Perm = Perm (V.Vector Int16) deriving Eq\n\npermFromIntList :: Int -> [Int] -> Perm\npermFromIntList n xs = Perm $ V.fromListN n $ map (subtract 1 . fromIntegral) xs\n\nidentPerm :: Int -> Perm\nidentPerm n = Perm $ V.fromListN n [0..fromIntegral (n-1)]\n\ncompPerm :: Perm -> Perm -> Perm\ncompPerm (Perm f) (Perm g)\n  = let n = V.length f -- = V.length g\n    in Perm $ V.generate n $ \\i -> f V.! (fromIntegral $ g V.! i)\n\n(<.>) :: Perm -> Perm -> Perm\n(<.>) = compPerm\n\ninvPerm :: Perm -> Perm\ninvPerm (Perm p) = Perm $ V.create $ do\n  let n = V.length p\n  q <- VM.new n\n  forM_ [0..n-1] $ \\i -> do\n    VM.write q (fromIntegral $ p V.! i) (fromIntegral i)\n  return q\n\npowPerm :: Int -> Perm -> Int -> Perm\npowPerm n _ 0 = identPerm n\npowPerm _ p i = loop (i-1) p p\n  where loop 0 !p !acc = acc\n        loop 1 p acc = p `compPerm` acc\n        loop i p acc = case quotRem i 2 of\n                         (j,0) -> loop j (p `compPerm` p) acc\n                         (j,_) -> loop j (p `compPerm` p) (acc `compPerm` p)\n\nshowPerm :: Perm -> String\nshowPerm (Perm p) = intercalate \" \" $ map (show . (+ 1)) $ V.toList p\n\nparseInts :: String -> [Int]\nparseInts s = case reads s of\n                [(x,t)] -> x : parseInts t\n                _ -> []\n\nmain = do\n  [n,k] <- parseInts <$> getLine\n  ps <- parseInts <$> getLine\n  qs <- parseInts <$> getLine\n  let p = permFromIntList n ps\n      q = permFromIntList n qs\n      f p q = q `compPerm` invPerm p\n\n  {-\n  let as = p : q : zipWith f as (tail as)\n      a_k = as !! (k - 1)\n  putStrLn $ showPerm a_k\n  -}\n  {-\n  let loop i p q | i == 0 = p\n                 | otherwise = loop (i - 1) q (f p q)\n  putStrLn $ showPerm $ loop (k - 1) p q\n  -}\n\n  let m = (k + 1) `quot` 2\n      r = (q <.> invPerm p) <.> (invPerm q <.> p)\n      b = case m `quotRem` 3 of\n            (l,0) -> powPerm n r (l-1) <.> q <.> invPerm p\n            (l,1) -> powPerm n r l\n            (l,_) -> powPerm n r l <.> q\n      c = case k `rem` 6 of\n            0 -> invPerm q <.> p\n            1 -> p\n            2 -> q\n            3 -> invPerm p <.> q\n            4 -> invPerm p\n            _ -> invPerm q\n      a_k' = b <.> c <.> invPerm b\n  putStrLn $ showPerm a_k'\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport GHC.Exts (build)\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor = sympow (conjinv q p `comp` p) kd6\n      p1 = conj actor p\n      q1 = conj actor q\n      ans = fst $ (!! km6) $ iterate' (\\(!x,!y) -> (y,f x y)) (p1,q1)\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) (BSB.byteString BS.empty)\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\n{-# INLINE sympow #-}\nsympow p 0 = idperm\nsympow p k_ = VU.create $ do\n  vec <- VU.thaw idperm\n  pcopy <- if k_ > 0 then VU.thaw p else VU.thaw $ inv p\n  let k = abs k_\n  tmp <- VUM.replicate ?n 0\n  let loop !p !tmp !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ \\i ->\n          VUM.write vec i =<< VUM.read p =<< VUM.read vec i\n        let k1 = shiftR k 1\n        when (k1 > 0) $ do\n          forM_ [0 .. ?n-1] $ \\i ->\n            VUM.write tmp i =<< VUM.read p =<< VUM.read p i\n          loop tmp p k1\n  loop pcopy tmp k\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n-- The following code is copy-paste from the Data.List\n-- in the package base-4.12.0.0.\n-- For the license text, see http://hackage.haskell.org/package/base-4.12.0.0.\n\n-- | 'iterate\\'' is the strict version of 'iterate'.\n--\n-- It ensures that the result of each application of force to weak head normal\n-- form before proceeding.\n{-# NOINLINE [1] iterate' #-}\niterate' :: (a -> a) -> a -> [a]\niterate' f x =\n    let x' = f x\n    in x' `seq` (x : iterate' f x')\n\n{-# INLINE [0] iterate'FB #-} -- See Note [Inline FB functions]\niterate'FB :: (a -> b -> b) -> (a -> a) -> a -> b\niterate'FB c f x0 = go x0\n  where go x =\n            let x' = f x\n            in x' `seq` (x `c` go x')\n\n{-# RULES\n\"iterate'\"    [~1] forall f x.   iterate' f x = build (\\c _n -> iterate'FB c f x)\n\"iterate'FB\"  [1]                iterate'FB (:) = iterate'\n #-}\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor = sympow (conjinv q p `comp` p) kd6\n      p1 = conj actor p\n      q1 = conj actor q\n      ans = fst $ (!! km6) $ iterate' (\\(!x,!y) -> (y,f x y)) (p1,q1)\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) (BSB.byteString BS.empty)\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List (sort, intersperse)\n\nmain :: IO ()\nmain = do\n  [n, k] <- map read . words <$> getLine\n  ps <- map read . words <$> getLine\n  qs <- map read . words <$> getLine\n  let\n    as = map show $ g k ps qs\n    a : as' = as\n  putStr a\n  mapM_ putStr . map (' ' :) $ as'\n  putStrLn \"\"\n\nf :: [Int] -> [Int] -> [Int]\nf ps qs = map snd . sort $ zip ps qs\n\ng k ps qs = if k == 1 then ps else g (k - 1) qs (f ps qs)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport GHC.Exts (build)\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor = sympow (conjinv q p `comp` p) kd6\n      p1 = conj actor p\n      q1 = conj actor q\n      ans = fst $ (!! km6) $ iterate' (\\(!x,!y) -> (y,f x y)) (p1,q1)\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) (BSB.byteString BS.empty)\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\n{-# INLINE sympow #-}\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  pcopy <- VU.thaw p\n  tmp <- VUM.replicate ?n 0\n  let loop !p !tmp !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ \\i ->\n          VUM.write vec i =<< VUM.read p =<< VUM.read vec i\n        let k1 = shiftR k 1\n        when (k1 > 0) $ do\n          forM_ [0 .. ?n-1] $ \\i ->\n            VUM.write tmp i =<< VUM.read p =<< VUM.read p i\n          loop tmp p k1\n  loop pcopy tmp k\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n-- The following code is copy-paste from the Data.List\n-- in the package base-4.12.0.0.\n-- For the license text, see http://hackage.haskell.org/package/base-4.12.0.0.\n\n-- | 'iterate\\'' is the strict version of 'iterate'.\n--\n-- It ensures that the result of each application of force to weak head normal\n-- form before proceeding.\n{-# NOINLINE [1] iterate' #-}\niterate' :: (a -> a) -> a -> [a]\niterate' f x =\n    let x' = f x\n    in x' `seq` (x : iterate' f x')\n\n{-# INLINE [0] iterate'FB #-} -- See Note [Inline FB functions]\niterate'FB :: (a -> b -> b) -> (a -> a) -> a -> b\niterate'FB c f x0 = go x0\n  where go x =\n            let x' = f x\n            in x' `seq` (x `c` go x')\n\n{-# RULES\n\"iterate'\"    [~1] forall f x.   iterate' f x = build (\\c _n -> iterate'FB c f x)\n\"iterate'FB\"  [1]                iterate'FB (:) = iterate'\n #-}\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor_main = sympow (conjinv q p `comp` p) kd6\n      ans = (!! km6)\n        [conj actor_main p,\n         conj actor_main q,\n         conj actor_main (f p q),\n         conjinv (actor_main `comp` q) p,\n         conjinv (comp actor_main q `g` p) q,\n         conj (comp actor_main q `g` comp q p) (g p q)]\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) (BSB.byteString BS.empty)\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List (sort, intersperse)\n\nmain :: IO ()\nmain = do\n  [n, k] <- map read . words <$> getLine\n  ps <- map read . words <$> getLine\n  qs <- map read . words <$> getLine\n  let\n    as = g k ps qs\n  putStrLn . intersperse ' ' . map show $ as\n\nf :: [Int] -> [Int] -> [Int]\nf ps qs = map snd . sort $ zip ps qs\n\ng k ps qs = if k == 1 then ps else g (k - 1) qs (f ps qs)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor_main = sympow (conjinv q p `comp` p) kd6\n      ans = (!! km6)\n        [conj actor_main p,\n         conj actor_main q,\n         conj actor_main (f p q),\n         conjinv (actor_main `comp` q) p,\n         conjinv (comp actor_main q `g` p) q,\n         conjinv (comp actor_main q `g` comp q p) (g p q)]\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) (BSB.byteString BS.empty)\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\nimport Control.Monad\nimport Data.List\nimport qualified Data.Vector.Unboxed as V\nimport qualified Data.Vector.Unboxed.Mutable as VM\n\ninfixl 7 <.>\n\nnewtype Perm = Perm (V.Vector Int) deriving Eq\n\npermFromIntList :: Int -> [Int] -> Perm\npermFromIntList n xs = Perm $ V.fromListN n $ map (subtract 1) xs\n\nidentPerm :: Int -> Perm\nidentPerm n = Perm $ V.fromListN n [0..n-1]\n\ncompPerm :: Perm -> Perm -> Perm\ncompPerm (Perm f) (Perm g)\n  = let n = V.length f -- = V.length g\n    in Perm $ V.generate n $ \\i -> f V.! (g V.! i)\n\n(<.>) :: Perm -> Perm -> Perm\n(<.>) = compPerm\n\ninvPerm :: Perm -> Perm\ninvPerm (Perm p) = Perm $ V.create $ do\n  let n = V.length p\n  q <- VM.new n\n  forM_ [0..n-1] $ \\i -> do\n    VM.write q (p V.! i) i\n  return q\n\npowPerm :: Int -> Perm -> Int -> Perm\npowPerm n _ 0 = identPerm n\npowPerm _ p i = loop (i-1) p p\n  where loop 0 !p !acc = acc\n        loop 1 p acc = p `compPerm` acc\n        loop i p acc = case quotRem i 2 of\n                         (j,0) -> loop j (p `compPerm` p) acc\n                         (j,_) -> loop j (p `compPerm` p) (acc `compPerm` p)\n\nshowPerm :: Perm -> String\nshowPerm (Perm p) = intercalate \" \" $ map (show . (+ 1)) $ V.toList p\n\nparseInts :: String -> [Int]\nparseInts s = case reads s of\n                [(x,t)] -> x : parseInts t\n                _ -> []\n\nmain = do\n  [n,k] <- parseInts <$> getLine\n  ps <- parseInts <$> getLine\n  qs <- parseInts <$> getLine\n  let p = permFromIntList n ps\n      q = permFromIntList n qs\n      f p q = q `compPerm` invPerm p\n\n  {-\n  let as = p : q : zipWith f as (tail as)\n      a_k = as !! (k - 1)\n  putStrLn $ showPerm a_k\n  -}\n  {-\n  let loop i p q | i == 0 = p\n                 | otherwise = loop (i - 1) q (f p q)\n  putStrLn $ showPerm $ loop (k - 1) p q\n  -}\n\n  let m = (k + 1) `quot` 2\n      r = (q <.> invPerm p) <.> (invPerm q <.> p)\n      b = case m `quotRem` 3 of\n            (l,0) -> powPerm n r (l-1) <.> q <.> invPerm p\n            (l,1) -> powPerm n r l\n            (l,_) -> powPerm n r l <.> q\n      c = case k `rem` 6 of\n            0 -> invPerm q <.> p\n            1 -> p\n            2 -> q\n            3 -> invPerm p <.> q\n            4 -> invPerm p\n            _ -> invPerm q\n      a_k' = b <.> c <.> invPerm b\n  putStrLn $ showPerm a_k'\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport GHC.Exts (build)\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor = sympow (conjinv q p `comp` p) kd6\n      p1 = conj actor p\n      q1 = conj actor q\n      ans = fst $ (!! km6) $ iterate' (\\(!x,!y) -> (y,f x y)) (p1,q1)\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) (BSB.byteString BS.empty)\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n-- The following code is copy-paste from the Data.List\n-- in the package base-4.12.0.0.\n-- For the license text, see http://hackage.haskell.org/package/base-4.12.0.0.\n\n-- | 'iterate\\'' is the strict version of 'iterate'.\n--\n-- It ensures that the result of each application of force to weak head normal\n-- form before proceeding.\n{-# NOINLINE [1] iterate' #-}\niterate' :: (a -> a) -> a -> [a]\niterate' f x =\n    let x' = f x\n    in x' `seq` (x : iterate' f x')\n\n{-# INLINE [0] iterate'FB #-} -- See Note [Inline FB functions]\niterate'FB :: (a -> b -> b) -> (a -> a) -> a -> b\niterate'FB c f x0 = go x0\n  where go x =\n            let x' = f x\n            in x' `seq` (x `c` go x')\n\n{-# RULES\n\"iterate'\"    [~1] forall f x.   iterate' f x = build (\\c _n -> iterate'FB c f x)\n\"iterate'FB\"  [1]                iterate'FB (:) = iterate'\n #-}\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor = sympow (conjinv q p `comp` p) kd6\n      p1 = conj actor p\n      q1 = conj actor q\n      ans = fst $ (!! km6) $ iterate' (\\(!x,!y) -> (y,f x y)) (p1,q1)\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) (BSB.byteString BS.empty)\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n-- The following code is copy-paste from the Data.List\n-- in the package base-4.12.0.0.\n-- For the license text, see http://hackage.haskell.org/package/base-4.12.0.0.\n\n-- | 'iterate\\'' is the strict version of 'iterate'.\n--\n-- It ensures that the result of each application of force to weak head normal\n-- form before proceeding.\n{-# NOINLINE [1] iterate' #-}\niterate' :: (a -> a) -> a -> [a]\niterate' f x =\n    let x' = f x\n    in x' `seq` (x : iterate' f x')\n\n{-# INLINE [0] iterate'FB #-} -- See Note [Inline FB functions]\niterate'FB :: (a -> b -> b) -> (a -> a) -> a -> b\niterate'FB c f x0 = go x0\n  where go x =\n            let x' = f x\n            in x' `seq` (x `c` go x')\n\n{-# RULES\n\"iterate'\"    [~1] forall f x.   iterate' f x = build (\\c _n -> iterate'FB c f x)\n\"iterate'FB\"  [1]                iterate'FB (:) = iterate'\n #-}\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List (sort, intersperse)\n\nmain :: IO ()\nmain = do\n  [n, k] <- map read . words <$> getLine\n  ps <- map read . words <$> getLine\n  qs <- map read . words <$> getLine\n  let\n    as = g k ps qs\n  putStrLn . intersperse \" \" . map show $ as\n\nf ps qs = map snd . sort $ zip ps qs\n\ng k ps qs = if k == 1 then ps else g (k - 1) qs (f ps qs)"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor = sympow (conjinv q p `comp` p) kd6\n      p1 = conj actor p\n      q1 = conj actor q\n      ans = fst $ iterate (\\(x,!y) -> (y,f x y)) (p1,q1) !! km6\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) (BSB.byteString BS.empty)\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List (sort, intersperse)\n\nmain :: IO ()\nmain = do\n  [n, k] <- map read . words <$> getLine\n  ps <- map read . words <$> getLine\n  qs <- map read . words <$> getLine\n  let\n    as = g k ps qs\n  putStrLn . intersperse \" \" . map show $ as\n\nf :: [Int] -> [Int] -> [Int]\nf ps qs = map snd . sort $ zip ps qs\n\ng k ps qs = if k == 1 then ps else g (k - 1) qs (f ps qs)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport GHC.Exts (build)\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  p <- VU.map (subtract 1) . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  q <- VU.map (subtract 1) . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) $ query p q k) mempty\n\n\nquery :: (?n :: Int) => Perm -> Perm -> Int -> Perm\nquery !p_immut !q_immut !k = VU.create $ do\n  p <- VU.unsafeThaw p_immut\n  q <- VU.unsafeThaw q_immut\n  tmp_reg <- VUM.new (?n * 2)\n  let (!tmp0,!tmp1) = VUM.splitAt ?n tmp_reg\n      (!kd6, !km6) = (k-1) `divMod` 6\n      loop !p !q !next 0  = return (p,q,next)\n      loop !p !q !next !k = do\n        forM_ [0 .. ?n-1] $ \\ !i -> do\n          pi <- VUM.read p i\n          VUM.write next pi =<< VUM.read q i\n        loop q next p (k-1)\n  (!pp, !qq, !tmp2) <- loop p q tmp0 km6 -- (pp,qq) = F^km6(p,q)\n      -- now tmp0,p,q are unusable\n      -- Meaningful values are in pp and qq; tmp1 and tmp2 are free.\n  forM_ [0 .. ?n-1] $ \\ !i -> do -- tmp1 = qq*(qq*pp)^{-1}\n    qpi <- VUM.read qq =<< VUM.read pp i\n    VUM.write tmp1 qpi =<< VUM.read qq i\n  forM_ [0 .. ?n-1] $ \\ !i -> do -- tmp2 = tmp1*pp\n    VUM.write tmp2 i =<< VUM.read tmp1 =<< VUM.read pp i\n      -- Values for later use are in tmp2 and pp\n      -- tmp1 and qq have meaningful values, but will not be used later,\n      -- and thus are free\n  let pow !b !tmp !res !e = do\n        forM_ [0 .. ?n-1] $ \\ !i -> VUM.write res i i\n        when (e > 0) $ powloop b tmp res e\n      powloop !b !tmp !res !e = do\n        when (odd e) $ forM_ [0 .. ?n-1] $ \\ !i ->\n          VUM.write res i =<< VUM.read b =<< VUM.read res i\n        let !e1 = e `shiftR` 1\n        when (e1 > 0) $ do\n          forM_ [0 .. ?n-1] $ \\ !i ->\n            VUM.write tmp i =<< VUM.read b =<< VUM.read b i\n          powloop tmp b res e1\n  pow tmp2 qq tmp1 kd6 -- tmp1 = (tmp2)^kd6\n    -- Now tmp2 and qq are freed and hold meaningless values\n  forM_ [0 .. ?n - 1] $ \\ !i -> do -- tmp2 = tmp1*pp*(tmp1)^{-1}\n    tmp1i <- VUM.read tmp1 i\n    VUM.write tmp2 tmp1i =<< VUM.read tmp1 =<< VUM.read pp i\n  return tmp2\n  \n  \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport GHC.Exts (build)\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor = sympow (conjinv q p `comp` p) kd6\n      p1 = conj actor p\n      q1 = conj actor q\n      ans = fst $ (!! km6) $ iterate' (\\(!x,!y) -> y `seq` (y,f x y)) (p1,q1)\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) (BSB.byteString BS.empty)\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\n-- PREREQUISTE : k >= 0\nsympow :: (?n :: Int) => Perm -> Int -> Perm\n{-# INLINE sympow #-}\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  pcopy <- VU.thaw p\n  tmp <- VUM.replicate ?n 0\n  let loop !p !tmp !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ \\i ->\n          VUM.write vec i =<< VUM.read p =<< VUM.read vec i\n        let k1 = shiftR k 1\n        when (k1 > 0) $ do\n          forM_ [0 .. ?n-1] $ \\i ->\n            VUM.write tmp i =<< VUM.read p =<< VUM.read p i\n          loop tmp p k1\n  loop pcopy tmp k\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n-- The following code is copy-paste from the Data.List\n-- in the package base-4.12.0.0.\n-- For the license text, see http://hackage.haskell.org/package/base-4.12.0.0.\n\n-- | 'iterate\\'' is the strict version of 'iterate'.\n--\n-- It ensures that the result of each application of force to weak head normal\n-- form before proceeding.\n{-# NOINLINE [1] iterate' #-}\niterate' :: (a -> a) -> a -> [a]\niterate' f x =\n    let x' = f x\n    in x' `seq` (x : iterate' f x')\n\n{-# INLINE [0] iterate'FB #-} -- See Note [Inline FB functions]\niterate'FB :: (a -> b -> b) -> (a -> a) -> a -> b\niterate'FB c f x0 = go x0\n  where go x =\n            let x' = f x\n            in x' `seq` (x `c` go x')\n\n{-# RULES\n\"iterate'\"    [~1] forall f x.   iterate' f x = build (\\c _n -> iterate'FB c f x)\n\"iterate'FB\"  [1]                iterate'FB (:) = iterate'\n #-}\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor = sympow (conjinv q p `comp` p) kd6\n      p1 = conj actor p\n      q1 = conj actor q\n      ans = fst $ iterate (\\(x,!y) -> (y,f x y)) (p1,q1) !! km6\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) (BSB.byteString BS.empty)\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, ImplicitParams,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\n-- import Control.Monad.ST.Unsafe\n\nmain :: IO ()\nmain = do\n  [n,k] <- map readInt . words <$> getLine\n  [p,q] <- replicateM 2 $ VU.map (subtract 1)\n    . VU.unfoldrN n (runStateT $ rIntS) <$> BS.getLine\n  let ?n = n\n  let (kd6, km6) = (k-1) `divMod` 6\n      actor = sympow (conjinv q p `comp` p) kd6\n      p1 = conj actor p\n      q1 = conj actor q\n      ans = fst $ (!! km6) $ iterate' (\\(!x,!y) -> (y,f x y)) (p1,q1)\n  BSB.hPutBuilder stdout\n    $ VU.foldr (\\ !j r !sp -> sp <> BSB.intDec j <> r (BSB.char7 ' '))\n       (\\ !sp -> BSB.char7 '\\n') (VU.map (+1) ans) (BSB.byteString BS.empty)\n   \n\n-- Aut_Set({0,..,n-1})\n-- To be used under the constraint (?n :: Int)\n-- INVARIANT : VU.length x == ?n for x :: Perm\n-- INVARIANT : VU.all (uncurry (==)) $ VU.indexed $ sort x for x :: Perm\ntype Perm = VU.Vector Int\n\nidperm :: (?n :: Int) => Perm\n{-# INLINE idperm #-}\nidperm = VU.generate ?n id\n\ninv :: (?n :: Int) => Perm -> Perm\n{-# INLINE inv #-}\ninv = g idperm\n\ncomp :: Perm -> Perm -> Perm\n{-# INLINE comp #-}\ncomp = VU.map . (VU.!)\n\n-- f p q = qp^{-1}\nf :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE f #-}\nf = VU.update_ (VU.replicate ?n (-1))\n\n-- g p q = pq^{-1}\ng :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE g #-}\ng = flip f\n\n-- conj p x = pxp^{-1}\nconj :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conj #-}\nconj p x = g (comp p x) p\n\n-- conjinv p x = px^{-1}p^{-1}\nconjinv :: (?n :: Int) => Perm -> Perm -> Perm\n{-# INLINE conjinv #-}\nconjinv p x = g p (comp p x)\n\nsympow :: (?n :: Int) => Perm -> Int -> Perm\nsympow p 0 = idperm\nsympow p k = VU.create $ do\n  vec <- VU.thaw idperm\n  let loop !p !k = do\n        when (testBit k 0) $ forM_ [0 .. ?n-1] $ VUM.modify vec (p VU.!)\n        let k1 = shiftR k 1\n        when (k1 > 0) $ loop (comp p p) k1\n  if k >= 0 then loop p k else loop (inv p) (-k)\n  return vec\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n-- The following code is copy-paste from the Data.List\n-- in the package base-4.12.0.0.\n-- For the license text, see http://hackage.haskell.org/package/base-4.12.0.0.\n\n#if !(MIN_VERSION_base(4,11,0))\n-- | 'iterate\\'' is the strict version of 'iterate'.\n--\n-- It ensures that the result of each application of force to weak head normal\n-- form before proceeding.\n{-# NOINLINE [1] iterate' #-}\niterate' :: (a -> a) -> a -> [a]\niterate' f x =\n    let x' = f x\n    in x' `seq` (x : iterate' f x')\n\n{-# INLINE [0] iterate'FB #-} -- See Note [Inline FB functions]\niterate'FB :: (a -> b -> b) -> (a -> a) -> a -> b\niterate'FB c f x0 = go x0\n  where go x =\n            let x' = f x\n            in x' `seq` (x `c` go x')\n\n{-# RULES\n\"iterate'\"    [~1] forall f x.   iterate' f x = build (\\c _n -> iterate'FB c f x)\n\"iterate'FB\"  [1]                iterate'FB (:) = iterate'\n #-}\n#endif\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint *f(int *p, int *q, int N){\n\tint i;\n\tint *ans = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tans[p[i]] = q[i];\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint N, K, i;\n\tscanf(\"%d%d\", &N, &K);\n\tint *p = (int *)malloc(sizeof(int) * N);\n\tint *q = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &p[i]);\n\t\tp[i]--;\n\t}\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &q[i]);\n\t\tq[i]--;\n\t}\n\tif(K == 1){\n\t\tfor(i = 0; i < N; i++){\n\t\t\tprintf(\"%d \", p[i] + 1);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\tif(K == 2){\n\t\tfor(i = 0; i < N; i++){\n\t\t\tprintf(\"%d \", q[i] + 1);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\tint **a = (int **)malloc(sizeof(int *) * (K + 1));\n\ta[1] = p;\n\ta[2] = q;\n\tfor(i = 3; i <= K; i++){\n\t\ta[i] = f(a[i - 2], a[i - 1], N);\n\t}\n\tfor(i = 0; i < N; i++){\n\t\tprintf(\"%d \", a[K][i] + 1);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint N;\n\nint *inverse(int *a){\n\tint i;\n\tint *a_inv = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\ta_inv[a[i]] = i;\n\t}\n\treturn a_inv;\n}\n\nint *mul(int *a, int *b){\n\tint i;\n\tint *c = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tc[i] = a[b[i]];\n\t}\n\treturn c;\n}\n\nint *power(int *a, int n){\n\tif(n == 0){\n\t\tint i;\n\t\tint *ans = (int *)malloc(sizeof(int) * N);\n\t\tfor(i = 0; i < N; i++){\n\t\t\tans[i] = i;\n\t\t}\n\t\treturn ans;\n\t}\n\telse if(n % 2 == 0){\n\t\treturn power(mul(a, a), n / 2);\n\t}\n\telse{\n\t\treturn mul(a, power(a, n - 1));\n\t}\n}\n\nint main(){\n\tint K, i;\n\tscanf(\"%d%d\", &N, &K);\n\tK--;\n\tint *p = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &p[i]);\n\t\tp[i]--;\n\t}\n\tint *q = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &q[i]);\n\t\tq[i]--;\n\t}\n\tint **ans_small = (int **)malloc(sizeof(int *) * 6);\n\tans_small[0] = p;\n\tans_small[1] = q;\n\tfor(i = 2; i < 6; i++){\n\t\tans_small[i] = mul(ans_small[i - 1], inverse(ans_small[i - 2]));\n\t}\n/*\tfor(i = 0; i < 6; i++){\n\t\tprintf(\"ans_small[%d]\\n\", i);\n\t\tint j;\n\t\tfor(j = 0; j < N; j++){\n\t\t\tprintf(\"%d \", ans_small[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\tint *qPQp = mul(mul(q, inverse(p)), mul(inverse(q), p));\n\tint *ans = mul(mul(power(qPQp, K / 6), ans_small[K % 6]), power(inverse(qPQp), K / 6));\n\tfor(i = 0; i < N; i++){\n\t\tprintf(\"%d \", ans[i] + 1);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>//random,NULL\n#include <string.h>\n#include <time.h>\n#include <unistd.h>//sleep()\n#include <math.h>\n#include <stdbool.h>\n\n#define rep(i,n) for(int i=0; i<((int)n); i++)\n#define REP(i,n) for(int i=0; i<=((int)n); i++)\n#define srep(i,a,n) for(int i=a; i<((int)n); i++)\n#define SREP(i,a,n) for(int i=a; i<=((int)n); i++)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define RREP(i,n) for(int i=n; i>=0; i--)\n#define INF 1000000000\n\n//具体的に考えることも重要だが、抽象的に数学で考えてみることも重要。\n//置換群の問題\n\nvoid merge_sort(int *t1, int *s1, int left, int right){\n    if(left==right){\n        ;\n    }\n    else{\n        int n2=(right-left+1)/2;\n        int n3=right-left+1-n2;\n        int i=0,j=0,k=0;\n\n        merge_sort(t1, s1, left, left+n2-1);\n        merge_sort(t1, s1, left+n2, right);\n\n        int *t2=(int *)malloc(sizeof(int)*n2);\n        int *t3=(int *)malloc(sizeof(int)*n3);\n        int *s2=(int *)malloc(sizeof(int)*n2);\n        int *s3=(int *)malloc(sizeof(int)*n3);\n\n        for(i=0;i<n2;i++){\n          t2[i]=t1[left+i];\n          s2[i]=s1[left+i];\n        }\n        for(i=0;i<n3;i++){\n          t3[i]=t1[left+n2+i];\n          s3[i]=s1[left+n2+i];\n        }\n\n        //ここの実装にn時間かかった。定義されていない領域にアクセスしないの重要。\n        for(i=0;i<n2+n3;i++){\n            if(k==n3 || (j<n2 && t2[j]<t3[k])){\n                t1[left+i]=t2[j];\n                s1[left+i]=s2[j];\n                j++;\n            }\n            else{\n                t1[left+i]=t3[k];\n                s1[left+i]=s3[k];\n                k++;\n            }\n        }\n    }\n}\n\n\n//置換の積 (p^a)(q^b) を計算する\n//置換は(0~N-1)で構成されているとする。\nvoid replace(int N, int *p, int a, int *q, int b, int *pro2){\n  int *temp=(int *)malloc(sizeof(int)*N);\n  int *p1=(int *)malloc(sizeof(int)*N);\n  int *q1=(int *)malloc(sizeof(int)*N);\n  int *p2=(int *)malloc(sizeof(int)*N);\n  int *q2=(int *)malloc(sizeof(int)*N);\n  rep(i,N){\n    p1[i]=i;\n    q1[i]=i;\n    p2[i]=p[i];\n    q2[i]=q[i];\n  }\n\n\n  if(a==-1 && b==-1){\n    merge_sort(p2, p1, 0, N-1);\n    merge_sort(q2, q1, 0, N-1);\n    rep(i,N){\n      temp[i]=p1[q1[i]];\n    }\n    rep(i,N){\n      pro2[i]=temp[i];\n    }\n  }\n  else if(a==1 && b==-1){\n    merge_sort(p1, p2, 0, N-1);\n    merge_sort(q2, q1, 0, N-1);\n    rep(i,N){\n      temp[i]=p2[q1[i]];\n    }\n    rep(i,N){\n      pro2[i]=temp[i];\n    }\n  }\n  else if(a==-1 && b==1){\n    merge_sort(p2, p1, 0, N-1);\n    merge_sort(q1, q2, 0, N-1);\n    rep(i,N){\n      temp[i]=p1[q2[i]];\n    }\n    rep(i,N){\n      pro2[i]=temp[i];\n    }\n  }\n  else{\n    // printf(\"p2 = \");\n    // rep(i,N){\n    //   printf(\"%d \", p2[i]);\n    // }\n    // printf(\"\\n\");\n    // printf(\"q2 = \");\n    // rep(i,N){\n    //   printf(\"%d \", q2[i]);\n    // }\n    // printf(\"\\n\");\n    merge_sort(p1, p2, 0, N-1);\n    merge_sort(q1, q2, 0, N-1);\n\n    rep(i,N){\n      temp[i]=p2[q2[i]];\n    }\n    rep(i,N){\n      pro2[i]=temp[i];\n    }\n  }\n}\n\n//AとBを求める\nvoid make(int N, int *p2, int *q2, int *A2, int *B2, int eqo, int rest, int *pro2){\n  if(eqo==0){\n    rep(i,N){\n      A2[i]=i;\n    }\n  }\n  else if(eqo==1){\n    rep(i,N){\n      A2[i]=pro2[i];\n    }\n  }\n  else{\n    rep(i,N){\n      A2[i]=pro2[i];\n    }\n    rep(i,eqo-1){\n      replace(N, A2, 1, pro2, 1, A2);\n    }\n  }\n\n\n  if(rest==1){\n    rep(i,N){\n      B2[i]=p2[i];\n    }\n  }\n  else if(rest==2){\n    rep(i,N){\n      B2[i]=q2[i];\n    }\n  }\n  else if(rest==3){\n    replace(N, q2, 1, p2, -1, B2);\n  }\n  else if(rest==4){\n    replace(N, A2, 1, q2, 1, A2);\n    int *p1=(int *)malloc(sizeof(int)*N);\n    rep(i,N){\n      p1[i]=i;\n    }\n    replace(N, p1, 1, p2, -1, B2);\n  }\n  else if(rest==5){\n    replace(N, A2, 1, q2, 1, A2);\n    // printf(\"A2 = \");\n    // rep(i,N){\n    //   printf(\"%d \", A2[i]);\n    // }\n    // printf(\"\\n\");\n    replace(N, A2, 1, p2, -1, A2);\n    int *q1=(int *)malloc(sizeof(int)*N);\n    rep(i,N){\n      q1[i]=i;\n    }\n    replace(N, q1, 1, q2, -1, B2);\n  }\n  else{\n    replace(N, A2, 1, q2, 1, A2);\n    replace(N, A2, 1, p2, -1, A2);\n    replace(N, q2, -1, p2, 1, B2);\n  }\n}\n\n\n\nint main(){\n  char buf[1024];\n  int N,K;\n\n  fgets(buf,sizeof(buf),stdin);\n  sscanf(buf, \"%d %d\", &N, &K);\n\n  int *p2=(int *)malloc(sizeof(int)*N);\n  rep(i,N){\n    scanf(\"%d\",&p2[i]);\n    p2[i]--;\n  }\n\n  int *q2=(int *)malloc(sizeof(int)*N);\n  rep(i,N){\n    scanf(\"%d\",&q2[i]);\n    q2[i]--;\n  }\n\n  int *pro1=(int *)malloc(sizeof(int)*N);\n  rep(i,N){\n    pro1[i]=i;\n  }\n  int *pro2=(int *)malloc(sizeof(int)*N);\n\n  replace(N, q2, -1, p2, 1, pro2);\n  replace(N, p2, -1, pro2, 1, pro2);\n  replace(N, q2, 1, pro2, 1, pro2);\n\n  // rep(i,N){\n  //   printf(\"%d \", pro2[i]+1);\n  // }\n  // printf(\"\\n\");\n\n  int eqo=(K-1)/6;\n  int rest=K%6;\n\n\n  int *A2=(int *)malloc(sizeof(int)*N);\n  int *B2=(int *)malloc(sizeof(int)*N);\n\n  make(N, p2, q2, A2, B2, eqo, rest, pro2);\n\n  // printf(\"A2 = \");\n  // rep(i,N){\n  //   printf(\"%d \", A2[i]);\n  // }\n  // printf(\"\\n\");\n  // printf(\"B2 = \");\n  // rep(i,N){\n  //   printf(\"%d \", B2[i]);\n  // }\n  // printf(\"\\n\");\n\n\n  int *a=(int *)malloc(sizeof(int)*N);\n  replace(N, A2, 1, B2, 1, a);\n  replace(N, a, 1, A2, -1, a);\n\n  rep(i,N){\n    a[i]++;\n    printf(\"%d \", a[i]);\n  }\n  printf(\"\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define size 524288\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nvoid arrcpy(int a[],int b[],int n){\n  int i;\n  for(i=1;i<=n;i++){\n    a[i]=b[i];\n  }\n}\n\n//map inverse\n//A^(-1)\nvoid map_inv(int r[],int a[],int n){\n  int i;\n  for(i=1;i<=n;i++){\n    r[a[i]]=i;\n  }\n}\n\n//map product\n//R=AB\nvoid map_prod(int r[],int a[],int b[],int n){\n  int i;\n  for(i=1;i<=n;i++){\n    r[i]=b[a[i]];\n  }\n}\n\n//map merge\n//A=AB\nvoid map_merge(int a[],int b[],int n){\n  int i;\n  for(i=1;i<=n;i++){\n    a[i]=b[a[i]];\n  }\n}\n\n//map power\n//A^k\nvoid map_pow(int r[],int a[],int k,int n){\n  int i;\n  int mem[size];\n  for(i=1;i<=n;i++){r[i]=i;}\n  while(k>0){\n    if(k%2){\n      map_merge(r,a,n);\n    }\n    map_prod(mem,a,a,n);\n    arrcpy(a,mem,n);\n    k/=2;\n  }\n}\n\nint main(void){\n  int i,j,n,m,k,c,h,w,r=0,l,t;\n  int p[size],q[size];\n  int invp[size],invq[size];\n  int a[size],b[size],inva[size];\n  int mem[size],res[size];\n  scanf(\"%d%d\",&n,&k);\n  for(i=1;i<=n;i++){scanf(\"%d\",&p[i]);}\n  map_inv(invp,p,n);\n  for(i=1;i<=n;i++){scanf(\"%d\",&q[i]);}\n  map_inv(invq,q,n);\n  for(i=1;i<=n;i++){\n    a[i]=i;\n    b[i]=i;\n    res[i]=i;\n  }\n  map_merge(a,invq,n);\n  map_merge(a,p,n);\n  map_merge(a,q,n);\n  map_merge(a,invp,n);\n  map_pow(mem,a,(k-1)/6,n);\n  arrcpy(a,mem,n);\n  map_inv(inva,a,n);\n  if(k%6==1){\n    map_merge(b,p,n);\n  }\n  if(k%6==2){\n    map_merge(b,q,n);\n  }\n  if(k%6==3){\n    map_merge(b,invp,n);\n    map_merge(b,q,n);\n  }\n  if(k%6==4){\n    map_merge(b,invq,n);\n    map_merge(b,invp,n);\n    map_merge(b,q,n);\n  }\n  if(k%6==5){\n    map_merge(b,invq,n);\n    map_merge(b,p,n);\n    map_merge(b,invq,n);\n    map_merge(b,invp,n);\n    map_merge(b,q,n);\n  }\n  if(k%6==0){\n    map_merge(b,invq,n);\n    map_merge(b,p,n);\n    map_merge(b,p,n);\n    map_merge(b,invq,n);\n    map_merge(b,invp,n);\n    map_merge(b,q,n);\n  }\n  map_merge(res,a,n);\n  map_merge(res,b,n);\n  map_merge(res,inva,n);\n  //prarr(&a[1],n);\n  //prarr(&b[1],n);\n  //prarr(&inva[1],n);\n  prarr(&res[1],n);\n  return 0;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n  val (N, K) = readInts()\n  val A = readInts()\n\n  fun solve(n: Int): Boolean {\n    var current = 0\n    for (i in 0 until N) {\n      val d = A[i] % n\n      val a = (current + d + n) % n\n      val b = (current - d + n) % n\n      val da = Math.abs(a - n)\n      val db = Math.abs(b - n)\n      if (da < db) {\n        current = a\n      } else {\n        current = b\n      }\n    }\n    return current == 0\n  }\n\n  val pf = primeFactorization(A.sum()).toList()\n\n  var result = 0\n  var prods = Array(pf.size) { 0 }\n  fun f(i: Int) {\n    var p = 1\n    for (n in 0..pf[i].second) {\n      prods[i] = p\n      p *= pf[i].first\n      if (i + 1 < pf.size) {\n        f(i + 1)\n      } else {\n        var num = 1\n        prods.forEach { num *= it }\n        if (solve(num)) result = Math.max(result, num)\n      }\n    }\n  }\n  f(0)\n\n  println(result)\n}\n\nfun primeFactorization(n: Int): Map<Int, Int> {\n  val isPrime = Array(n + 1) { true }\n  isPrime[0] = false\n  isPrime[1] = false\n  var i = 2\n  while (i <= n) {\n    if (isPrime[i]) {\n      var j = i * 2\n      while (j <= n) {\n        isPrime[j] = false\n        j += i\n      }\n    }\n    i++\n  }\n\n  var num = n\n  val factors = mutableMapOf<Int, Int>()\n  for (i in 2..n) {\n    if (!isPrime[i]) continue\n    var cnt = 0\n    while (num % i == 0) {\n      cnt++\n      num /= i\n    }\n    if (cnt > 0) factors[i] = cnt\n  }\n  return factors\n}\n\nfun readString() = readLine()!!\nfun readStrings() = readString().split(\" \")\nfun readInt() = readString().toInt()\nfun readInts() = readStrings().map { it.toInt() }\nfun readLong() = readString().toLong()\nfun readLongs() = readStrings().map { it.toLong() }\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\nimport static java.util.Arrays.fill;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic int[] compose(int p[], int q[]) {\n\t\tint n = p.length;\n\t\tint r[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tr[i] = p[q[i]];\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int[] inv(int p[]) {\n\t\tint n = p.length;\n\t\tint r[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tr[p[i]] = i;\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int[] pow(int p[], int m) {\n\t\tint n = p.length;\n\t\tint r[] = new int[n];\n\t\tfill(r, -1);\n\t\tint c[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (r[i] >= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint clen = 0;\n\t\t\tfor (int j = i;;) {\n\t\t\t\tc[clen++] = j;\n\t\t\t\tj = p[j];\n\t\t\t\tif (j == i) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < clen; j++) {\n\t\t\t\tr[c[j]] = c[(j + m) % clen];\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tint k = scanInt() - 1;\n\t\tint p[] = new int[n], pi[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[i] = scanInt() - 1;\n\t\t\tpi[p[i]] = i;\n\t\t}\n\t\tint q[] = new int[n], qi[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tq[i] = scanInt() - 1;\n\t\t\tqi[q[i]] = i;\n\t\t}\n\t\tint pr[] = pow(compose(compose(compose(q, pi), qi), p), k / 6);\n\t\tint su[] = pow(compose(compose(compose(pi, q), p), qi), k / 6);\n\t\tint p1[] = compose(compose(pr, p), su);\n\t\tint p2[] = compose(compose(pr, q), su);\n\t\tint res[];\n\t\tif (k % 6 == 0) {\n\t\t\tres = p1;\n\t\t} else {\n\t\t\tfor (int i = 1; i != k % 6; i++) {\n\t\t\t\tint p3[] = compose(p2, inv(p1));\n\t\t\t\tp1 = p2;\n\t\t\t\tp2 = p3;\n\t\t\t}\n\t\t\tres = p2;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tout.print((res[i] + 1) + \" \");\n\t\t}\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        boolean local = false;\n        boolean async = false;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"dalt\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        int mod = (int) 1e9 + 7;\n\n        public int mod(int val) {\n            val %= mod;\n            if (val < 0) {\n                val += mod;\n            }\n            return val;\n        }\n\n        public int mod(long val) {\n            val %= mod;\n            if (val < 0) {\n                val += mod;\n            }\n            return (int) val;\n        }\n\n        int bitAt(int x, int i) {\n            return (x >> i) & 1;\n        }\n\n        int bitAt(long x, int i) {\n            return (int) ((x >> i) & 1);\n        }\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n        public void solve() {\n            int n = io.readInt();\n            int k = io.readInt() - 1;\n            int[] pArray = new int[n];\n            int[] qArray = new int[n];\n            for (int i = 0; i < n; i++) {\n                pArray[i] = io.readInt() - 1;\n            }\n            for (int i = 0; i < n; i++) {\n                qArray[i] = io.readInt() - 1;\n            }\n\n            Permutation p = new Permutation(pArray);\n            Permutation q = new Permutation(qArray);\n\n            Permutation A = q;\n            A = Permutation.mul(A, 1, p, -1);\n            A = Permutation.mul(A, 1, q, -1);\n            A = Permutation.mul(A, 1, p, 1);\n\n            Permutation[] remainder = new Permutation[6];\n            remainder[0] = p;\n            remainder[1] = q;\n            for (int i = 2; i < 6; i++) {\n                remainder[i] = Permutation.mul(remainder[i - 1], 1, remainder[i - 2], -1);\n            }\n\n            Permutation res = Permutation.mul(A, k / 6, remainder[k % 6], 1);\n            res = Permutation.mul(res, 1, A, -(k / 6));\n\n            for (int i = 0; i < n; i++) {\n                io.cache.append(res.apply(i, 1) + 1).append(' ');\n            }\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder();\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n\n    /**\n     * Represent permutation 0~(n-1)\n     */\n    public static class Permutation {\n        int[] g;\n        int[] idx;\n        int[] l;\n        int[] r;\n        int n;\n\n        public Permutation(int[] p) {\n            this(p, p.length);\n        }\n\n        public Permutation(int[] p, int len) {\n            n = len;\n            boolean[] visit = new boolean[n];\n            g = new int[n];\n            l = new int[n];\n            r = new int[n];\n            idx = new int[n];\n            int wpos = 0;\n            for (int i = 0; i < n; i++) {\n                int val = p[i];\n                if (visit[val]) {\n                    continue;\n                }\n                visit[val] = true;\n                g[wpos] = val;\n                l[wpos] = wpos;\n                idx[val] = wpos;\n                wpos++;\n                while (true) {\n                    int x = p[g[wpos - 1]];\n                    if (visit[x]) {\n                        break;\n                    }\n                    visit[x] = true;\n                    g[wpos] = x;\n                    l[wpos] = l[wpos - 1];\n                    idx[x] = wpos;\n                    wpos++;\n                }\n                for (int j = l[wpos - 1]; j < wpos; j++) {\n                    r[j] = wpos - 1;\n                }\n            }\n        }\n\n        public static Permutation mul(Permutation a, int ap, Permutation b, int bp) {\n            int n = a.n;\n            int[] p = new int[n];\n            for (int i = 0; i < n; i++) {\n                p[i] = a.apply(b.apply(i, bp), ap);\n            }\n            return new Permutation(p, n);\n        }\n\n        public int apply(int x, int p) {\n            int i = idx[x];\n            int dist = (i - l[i]) + p;\n            int len = r[i] - l[i] + 1;\n            dist %= len;\n            if (dist < 0) {\n                dist += len;\n            }\n            return g[dist + l[i]];\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < n; i++) {\n                builder.append(apply(i, 1)).append(' ');\n            }\n            return builder.toString();\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), K = ni();\n\t\tint[] P = na(n);\n\t\tfor(int i = 0;i < n;i++)P[i]--;\n\t\tint[] Q = na(n);\n\t\tfor(int i = 0;i < n;i++)Q[i]--;\n\t\t\n\t\t// -p, q, p, -q\n\t\t// q -p -q p\n\t\t\n\t\t/*\n[5, [-q]]\n[6, [p, -q]]\n[7, [q, p, -q]]\n[8, [q]]\n[9, [q, -p]]\n[10, [q, -p, -q]]\n\t\t * \n\t\t */\n\t\tif(K == 1){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tout.print(P[i]+1 + \" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint[] A = mul(inv(P), Q, P, inv(Q)); \n\t\tint[] B = mul(Q, inv(P), inv(Q), P);\n\t\t\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0;i < n;i++)f[i] = i;\n\t\tf = pow(A, (K-2)/6, f);\n\t\tif(K % 6 == 2){\n\t\t\tf = mul(Q, f);\n\t\t}else if(K % 6 == 3){\n\t\t\tf = mul(Q, inv(P), f);\n\t\t}else if(K % 6 == 4){\n\t\t\tf = mul(Q, inv(P), inv(Q), f);\n\t\t}else if(K % 6 == 5){\n\t\t\tf = mul(inv(Q), f);\n\t\t}else if(K % 6 == 0){\n\t\t\tf = mul(P, inv(Q), f);\n\t\t}else if(K % 6 == 1){\n\t\t\tf = mul(Q, P, inv(Q), f);\n\t\t}\n\t\tf = pow(B, (K+1)/6, f);\n\t\t\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tout.print(f[i]+1 + \" \");\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tstatic int[] pow(int[] f, int e, int[] a)\n\t{\n\t\twhile(e > 0){\n\t\t\tif((e&1) == 1){\n\t\t\t\ta = mul(f, a);\n\t\t\t}\n\t\t\tf = mul(f, f);\n\t\t\te>>>=1;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tstatic int[] mul(int[]... x)\n\t{\n\t\tint[] f = mul(x[x.length-2], x[x.length-1]);\n\t\tfor(int i = x.length-3;i >= 0;i--){\n\t\t\tf = mul(x[i], f);\n\t\t}\n\t\treturn f;\n\t}\n\t\n\tstatic int[] mul(int[] f, int[] g)\n\t{\n\t\tint[] ret = new int[f.length];\n\t\tfor(int i = 0;i < g.length;i++){\n\t\t\tret[i] = f[g[i]];\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic int[] inv(int[] f)\n\t{\n\t\tint[] ret = new int[f.length];\n\t\tfor(int i = 0;i < f.length;i++)ret[f[i]] = i;\n\t\treturn ret;\n\t}\n\t\n\tstatic List<String> clean(List<String> x)\n\t{\n\t\touter:\n\t\twhile(true){\n\t\t\tfor(int i = 0;i < x.size()-1;i++){\n\t\t\t\tString l = x.get(i);\n\t\t\t\tString r = x.get(i+1);\n\t\t\t\tif(l.length() == 1 && r.length() == 2 && l.charAt(0) == r.charAt(1)){\n\t\t\t\t\tx.remove(i);\n\t\t\t\t\tx.remove(i);\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\tif(r.length() == 1 && l.length() == 2 && r.charAt(0) == l.charAt(1)){\n\t\t\t\t\tx.remove(i);\n\t\t\t\t\tx.remove(i);\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\t}\n\t\n\tstatic List<String> rev(List<String> x)\n\t{\n\t\tList<String> y = new ArrayList<>();\n\t\tfor(int i = x.size()-1;i >= 0;i--){\n\t\t\tString t = x.get(i);\n\t\t\tif(t.length() == 2){\n\t\t\t\ty.add(t.substring(1));\n\t\t\t}else{\n\t\t\t\ty.add(\"-\" + t);\n\t\t\t}\n\t\t}\n\t\treturn y;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\n\tint[] solve() {\n\t\tint n = nextInt();\n\t\tint b = nextInt() - 1;\n\t\tint[] p = new int[n];\n\t\tint[] q = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[i] = nextInt() - 1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tq[i] = nextInt() - 1;\n\t\t}\n\n\t\tif (b == 0) {\n\t\t\treturn p;\n\t\t}\n\n\t\tint k = (b - 1) / 6;\n\n\t\tint head, tail;\n\t\tint[] mid;\n\n\t\tif (b == 6 * k + 1) {\n\t\t\thead = tail = k;\n\t\t\tmid = q;\n\t\t} else if (b == 6 * k + 2) {\n\t\t\thead = tail = k;\n\t\t\tmid = mult(inv(p), q);\n\t\t} else if (b == 6 * k + 3) {\n\t\t\thead = tail = k;\n\t\t\tmid = mult(inv(q), mult(inv(p), q));\n\t\t} else if (b == 6 * k + 4) {\n\t\t\thead = k;\n\t\t\ttail = k + 1;\n\t\t\tmid = inv(q);\n\t\t} else if (b == 6 * k + 5) {\n\t\t\thead = k;\n\t\t\ttail = k + 1;\n\t\t\tmid = mult(inv(q), p);\n\t\t} else if (b == 6 * k + 6) {\n\t\t\thead = k;\n\t\t\ttail = k + 1;\n\t\t\tmid = mult(mult(inv(q), p), q);\n\t\t} else {\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\t// QpqP\n\t\tint[] headBlock = mult(mult(mult(inv(q), p), q), inv(p));\n\n\t\tint[] tailBlock = inv(headBlock);\n\n\t\tint[] ret = mult(mult(pow(headBlock, head), mid), pow(tailBlock, tail));\n\n\t\treturn ret;\n\t}\n\n\tchar flip(char c) {\n\t\tif (Character.isLowerCase(c)) {\n\t\t\treturn Character.toUpperCase(c);\n\t\t} else {\n\t\t\treturn Character.toLowerCase(c);\n\t\t}\n\t}\n\n\tString inverse(String a) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = a.length() - 1; i >= 0; i--) {\n\t\t\tsb.append(flip(a.charAt(i)));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString simplify(String a) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < a.length(); i++) {\n\t\t\t// sb.append(flip(a.charAt(i)));\n\t\t\tif (sb.length() > 0\n\t\t\t\t\t&& flip(a.charAt(i)) == sb.charAt(sb.length() - 1)) {\n\t\t\t\tsb.deleteCharAt(sb.length() - 1);\n\t\t\t} else {\n\t\t\t\tsb.append(a.charAt(i));\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString f(String a, String b) {\n\t\treturn simplify(inverse(a) + b);\n\t}\n\n\tint[] inv(int[] p) {\n\t\tint[] q = new int[p.length];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tq[p[i]] = i;\n\t\t}\n\t\treturn q;\n\t}\n\n\tint[] mult(int[] a, int[] b) {\n\t\tint[] c = new int[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tc[i] = b[a[i]];\n\t\t}\n\t\treturn c;\n\t}\n\n\tint[] pow(int[] a, int b) {\n\t\tint[] ret = IntStream.range(0, a.length).toArray();\n\t\tfor (; b > 0; b >>= 1) {\n\t\t\tif ((b & 1) == 1) {\n\t\t\t\tret = mult(ret, a);\n\t\t\t}\n\t\t\ta = mult(a, a);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid test() {\n\t\tString[] a = new String[250];\n\t\ta[0] = \"p\";\n\t\ta[1] = \"q\";\n\t\tfor (int i = 2; i < a.length; i++) {\n\t\t\ta[i] = f(a[i - 2], a[i - 1]);\n\t\t}\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t// System.err.println(i + \" \" + a[i].length());\n\t\t\t// if (a[i].length() != i) {\n\t\t\t// System.err.println(i);\n\t\t\t// }\n\t\t\t// System.err.println(i + \" \" + a[i]);\n\t\t\tString s = a[i];\n\t\t\tint beg = 0;\n\t\t\twhile (beg + 4 <= s.length()\n\t\t\t\t\t&& s.substring(beg, beg + 4).equals(\"QpqP\")) {\n\t\t\t\tbeg += 4;\n\t\t\t}\n\t\t\t// System.err.println(i + \" \" + s.substring(beg));\n\n\t\t\tint end = s.length();\n\t\t\twhile (end - 4 >= 0 && s.substring(end - 4, end).equals(\"pQPq\")) {\n\t\t\t\tend -= 4;\n\t\t\t}\n\n\t\t\tSystem.err.println(i + \" \" + beg / 4 + \" \" + (s.length() - end) / 4\n\t\t\t\t\t+ \" \" + s.substring(beg, end));\n\t\t}\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\t\n\tvoid submit() {\n\t\tint[] ans = solve();\n\t\tfor (int x : ans) {\n\t\t\tout.print(x + 1 + \" \");\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\tstatic final int C = 5;\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static int[] f(int[] p, int[] q){\n        int[] a = new int[p.length];\n        for(int i=0; i<a.length; i++) a[p[i]-1] = q[i];\n        return a;\n    }\n\n    static void printArray(int[] array){\n        for(int n=0; n<array.length; n++){\n            System.out.print(array[n]);\n            if(n==array.length-1) System.out.println();\n            else System.out.print(\" \");\n        }\n    }\n\n    static int[] fPow(int[] p, int[] q, int K){\n        int[] cur = Arrays.copyOf(p, p.length);\n        int[] next = Arrays.copyOf(q, q.length);\n        for(int k=0; k<K; k++){\n            if(k>0 && Arrays.equals(p,cur) && Arrays.equals(q,next)){\n                //System.err.printf(\"period: %d\",k);\n                return fPow(p, q, K%k);\n            }\n            int[] a = f(cur,next);\n            if(Arrays.equals(cur,a)&&Arrays.equals(next,a))return a;\n            cur = next;\n            next = a;\n            if(k==K-1) return cur;\n        }\n        return cur;\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt()-1;\n        int[] p = new int[N], q = new int[N];\n        for(int n=0; n<N; n++) p[n]=sc.nextInt();\n        for(int n=0; n<N; n++) q[n]=sc.nextInt();\n\n        printArray(fPow(p,q,K));\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        int n;\n        TaskD.Perm f;\n        TaskD.Perm g;\n        TaskD.Perm F;\n        TaskD.Perm G;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.nextInt();\n            int k = in.nextInt() - 1;\n            f = new TaskD.Perm(n);\n            g = new TaskD.Perm(n);\n            for (int i = 0; i < n; ++i)\n                f.a[i] = in.nextInt() - 1;\n            for (int i = 0; i < n; ++i)\n                g.a[i] = in.nextInt() - 1;\n            F = f.inv();\n            G = g.inv();\n\n            int[][] d = new int[60][];\n            d[0] = new int[]{1};\n            d[1] = new int[]{2};\n            for (int i = 2; i < d.length; ++i)\n                d[i] = mult(d[i - 1], inv(d[i - 2]));\n\n            TaskD.Perm base = g.mult(F).mult(G).mult(f);\n            int cnt = k / 6;\n            base = pow(base, cnt);\n            TaskD.Perm ibase = base.inv();\n\n            TaskD.Perm res = base.mult(toPerm(d[k % 6])).mult(ibase);\n            for (int i = 0; i < n; ++i)\n                out.print((res.a[i] + 1) + \" \");\n            out.printLine();\n//        for (int i = 0; i < d.length; ++i)\n//            System.err.println(tostr(d[i]));\n        }\n\n        private TaskD.Perm pow(TaskD.Perm x, int y) {\n            TaskD.Perm res = new TaskD.Perm(n);\n            while (y > 0) {\n                if (y % 2 == 0) {\n                    y /= 2;\n                    x = x.mult(x);\n                } else {\n                    --y;\n                    res = res.mult(x);\n                }\n            }\n            return res;\n        }\n\n        TaskD.Perm toPerm(int[] a) {\n            TaskD.Perm res = new TaskD.Perm(n);\n            for (int x : a) {\n                if (x == 1) res = res.mult(f);\n                if (x == 2) res = res.mult(g);\n                if (x == -1) res = res.mult(F);\n                if (x == -2) res = res.mult(G);\n            }\n            return res;\n        }\n\n        private int[] mult(int[] a, int[] b) {\n            int l = a.length - 1, r = 0;\n            while (l >= 0 && r < b.length && a[l] + b[r] == 0) {\n                --l;\n                ++r;\n            }\n            int[] res = new int[l + 1 + b.length - r];\n            for (int i = 0; i <= l; ++i)\n                res[i] = a[i];\n            for (int i = r; i < b.length; ++i)\n                res[l + 1 + i - r] = b[i];\n            return res;\n        }\n\n        private int[] inv(int[] a) {\n            int[] res = new int[a.length];\n            for (int i = 0; i < a.length; ++i)\n                res[i] = -a[a.length - i - 1];\n            return res;\n        }\n\n        static class Perm {\n            int[] a;\n\n            public Perm(int n) {\n                a = new int[n];\n                for (int i = 0; i < n; ++i)\n                    a[i] = i;\n            }\n\n            TaskD.Perm mult(TaskD.Perm other) {\n                TaskD.Perm res = new TaskD.Perm(a.length);\n                for (int i = 0; i < a.length; ++i)\n                    res.a[i] = a[other.a[i]];\n                return res;\n            }\n\n            TaskD.Perm inv() {\n                TaskD.Perm res = new TaskD.Perm(a.length);\n                for (int i = 0; i < a.length; ++i)\n                    res.a[a[i]] = i;\n                return res;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buffer = new byte[10000];\n        private int cur;\n        private int count;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isSpace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (count == -1) {\n                throw new InputMismatchException();\n            }\n            try {\n                if (cur >= count) {\n                    cur = 0;\n                    count = stream.read(buffer);\n                    if (count <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            return buffer[cur++];\n        }\n\n        public int readSkipSpace() {\n            int c;\n            do {\n                c = read();\n            } while (isSpace(c));\n            return c;\n        }\n\n        public int nextInt() {\n            int sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10 + c - '0';\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt() - 1;\n\t\tint[] a = new int[N];\n\t\tint[] b = new int[N];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = sc.nextInt() - 1;\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tb[i] = sc.nextInt() - 1;\n\t\t}\n\t\tint mod = K % 6;\n\t\tint[] mid = null;\n\t\tswitch (mod) {\n\t\t\tcase 0:\n\t\t\t\tmid = a;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tmid = b;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tmid = compose(b, inv(a));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tmid = inv(a);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tmid = inv(b);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tmid = compose(inv(b), a);\n\t\t\t\tbreak;\n\t\t}\n\t\tint[] left;\n\t\tif (K < 3) {\n\t\t\tleft = id(N);\n\t\t} else {\n\t\t\tint total = 1 + ((K - 3) / 3) * 2;\n\t\t\tif (K % 3 != 0) total++;\n\t\t\tint[] base = compose(b, compose(inv(a), compose(inv(b), a)));\n\t\t\tleft = eleva(base, total / 4);\n\t\t\tif (total % 4 >= 1) {\n\t\t\t\tleft = compose(left, b);\n\t\t\t}\n\t\t\tif (total % 4 >= 2) {\n\t\t\t\tleft = compose(left, inv(a));\n\t\t\t}\n\t\t\tif (total % 4 >= 3) {\n\t\t\t\tleft = compose(left, inv(b));\n\t\t\t}\n\t\t}\n\t\tint[] ret = compose(left, compose(mid, inv(left)));\n\t\tfor (int i = 0; i < ret.length; i++) {\n\t\t\tif (i > 0) out.print(\" \");\n\t\t\tout.print(ret[i] + 1);\n\t\t}\n\t\tout.println();\n\t\tout.flush();\n\t}\n\t\n\tstatic int[] inv(int[] a) {\n\t\tint[] ret = new int[a.length];\n\t\tfor (int i = 0; i < ret.length; i++) {\n\t\t\tret[a[i]] = i;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic int[] compose(int[] a, int[] b) {\n\t\tint[] ret = new int[a.length];\n\t\tfor (int i = 0; i < ret.length; i++) {\n\t\t\tret[i] = a[b[i]];\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic int[] id(int n) {\n\t\tint[] ret = new int[n];\n\t\tfor (int i = 0; i < ret.length; i++) {\n\t\t\tret[i] = i;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic int[] eleva(int[] a, int e) {\n\t\tif (e == 0) return id(a.length);\n\t\tint[] tmp = eleva(a, e / 2);\n\t\ttmp = compose(tmp, tmp);\n\t\tif (e % 2 == 1) {\n\t\t\ttmp = compose(tmp, a);\n\t\t}\n\t\treturn tmp;\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        DASequenceOfPermutations solver = new DASequenceOfPermutations();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DASequenceOfPermutations {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            int[] p = in.readIntArray(n);\n            int[] q = in.readIntArray(n);\n            MiscUtils.decreaseByOne(p, q);\n            if (k >= 4) {\n                int[] qRev = ArrayUtils.reversePermutation(q);\n                int[] pRev = ArrayUtils.reversePermutation(p);\n                int[] qRevP = multiplyPermutations(qRev, p);\n                int[] pref = multiplyPermutations(qRevP, multiplyPermutations(q, pRev));\n                int[] prefPower = new int[n];\n                int[] temp = new int[n];\n                int pow = (k - 4) / 6;\n                power(pref, pow, prefPower, temp);\n                int[] post = ArrayUtils.reversePermutation(prefPower);\n                int[] nP = multiplyPermutations(prefPower, multiplyPermutations(multiplyPermutations(qRev,\n                        multiplyPermutations(pRev, q)), post));\n                int[] nQ = multiplyPermutations(prefPower, multiplyPermutations(multiplyPermutations(qRevP,\n                        multiplyPermutations(qRev, multiplyPermutations(pRev, q))), post));\n                p = nP;\n                q = nQ;\n                k -= 6 * pow + 3;\n            }\n            for (int i = 0; i < k - 1; i++) {\n                int[] next = multiplyPermutations(ArrayUtils.reversePermutation(p), q);\n                p = q;\n                q = next;\n            }\n            for (int i = 0; i < n; i++) {\n                p[i]++;\n            }\n            out.printLine(p);\n        }\n\n        private void power(int[] p, int n, int[] res, int[] temp) {\n            if (n == 0) {\n                for (int i = 0; i < res.length; i++) {\n                    res[i] = i;\n                }\n                return;\n            }\n            if ((n & 1) == 1) {\n                power(p, n - 1, temp, res);\n                inlineMultiplyPermutations(res, temp, p);\n            } else {\n                power(p, n >> 1, temp, res);\n                inlineMultiplyPermutations(res, temp, temp);\n            }\n        }\n\n        public static void inlineMultiplyPermutations(int[] result, int[] first, int[] second) {\n            int count = first.length;\n            for (int i = 0; i < count; i++) {\n                result[i] = second[first[i]];\n            }\n        }\n\n        public static int[] multiplyPermutations(int[] first, int[] second) {\n            int count = first.length;\n            int[] result = new int[count];\n            for (int i = 0; i < count; i++) {\n                result[i] = second[first[i]];\n            }\n            return result;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static int[] reversePermutation(int[] permutation) {\n            int[] result = new int[permutation.length];\n            for (int i = 0; i < permutation.length; i++) {\n                result[permutation[i]] = i;\n            }\n            return result;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void printLine(int[] array) {\n            print(array);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class MiscUtils {\n        public static void decreaseByOne(int[]... arrays) {\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i]--;\n                }\n            }\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nclass K\n{\n\tint[] G => ReadLine().Split().Select(i => int.Parse(i) - 1).ToArray();\n\tint N;\n\tstatic void Main() => new K().Z();\n\tvoid Z()\n\t{\n\t\tvar I = G;\n\t\tN = I[0] + 1;\n\t\tWriteLine(string.Join(\" \", C(G, G, I[1]).Select(i => i + 1)));\n\t}\n\tint[] C(int[] p, int[] q, int K)\n\t{\n\t\tint[] P = I(p), Q = I(q), x = E(M(q, P, Q, p), K / 6), y = I(x);\n\t\tswitch (K % 6)\n\t\t{\n\t\t\tcase 0: return M(x, p, y);\n\t\t\tcase 1: return M(x, q, y);\n\t\t\tcase 2: return M(x, q, P, y);\n\t\t\tcase 3: return M(x, q, P, Q, y);\n\t\t\tcase 4: return M(x, q, P, Q, p, Q, y);\n\t\t\tdefault: return M(x, q, P, Q, p, p, Q, y);\n\t\t}\n\t}\n\tint[] I(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tint[] M(int[] a, int[] b) { var p = new int[N]; for (var i = 0; i < N; i++) p[i] = a[b[i]]; return p; }\n\tint[] M(params int[][] a) => a.Aggregate(M);\n\tint[] E(int[] a, int b)\n\t{\n\t\tif (b < 0) return I(E(a, -b));\n\t\tvar p = new int[N];\n\t\tvar f = new bool[N];\n\t\tfor (var i = 0; i < N; i++)\n\t\t\tif (!f[i])\n\t\t\t{\n\t\t\t\tvar l = new List<int>();\n\t\t\t\tvar x = i;\n\t\t\t\twhile (!f[x]) { l.Add(x); f[x] = true; x = a[x]; }\n\t\t\t\tvar C = l.Count;\n\t\t\t\tfor (var j = 0; j < C; j++) p[l[j]] = l[(j + b) % C];\n\t\t\t}\n\t\treturn p;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main(string[] args)\n    {\n        int n, k;\n        sc.Multi(out n, out k);\n        var p = sc.IntArr.Select(x => x - 1).ToArray();\n        var q = sc.IntArr.Select(x => x - 1).ToArray();\n        if (k == 1) {\n            DBG(p.Select(x => x + 1));\n            return;\n        }\n        if (k == 2) {\n            DBG(q.Select(x => x + 1));\n            return;\n        }\n        var a = new int[6][];\n        a[0] = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[0][i] = i;\n        }\n        a[1] = inv(q);\n        a[2] = mul(a[1], p);\n        a[3] = mul(a[2], q);\n        a[4] = mul(a[3], inv(p));\n        a[5] = mul(a[4], q);\n        int c = k - 2 - k / 3;\n        var b = pow(a[4], c / 4);\n        var ib = inv(b);\n        b = mul(b, a[c % 4]);\n        if (k % 3 == 0) {\n            ib = mul(inv(a[c % 4 + 2]), ib);\n        }\n        else\n            ib = mul(inv(a[c % 4 + 1]), ib);\n\n        var ans = mul(b, ib);\n        Prt(ans.Select(x => x + 1));\n\n        if (false) {\n            var A = new int[2][];\n            A[0] = new int[] { 0, 1 };\n            A[1] = new int[] { -1, 1 };\n            var r = new int[][] { p, q };\n            for (int i = 0; i < k - 2; i++)\n            {\n                r = mul1(A, r);\n            }\n            // var r = mul1(pow(A, k - 2), p);\n            Prt(r[1]);\n        }\n        sw.Flush();\n    }\n    // 0: e, 1: x, -1: inv\n    static int[] mul(int A, int[] x) {\n        var ret = x.copy();\n        for (int i = 0; i < ret.Length; i++)\n        {\n            if (A == 0) {\n                ret[i] = i;\n            }\n            else if (A == 1) {\n                ret[i] = x[i];\n            }\n            else if (A == -1) {\n                ret[x[i]] = i;\n            }\n            else throw new Exception();\n        }\n        return ret;\n    }\n    static int[] inv(int[] x) {\n        var ret = new int[x.Length];\n        for (int i = 0; i < ret.Length; i++)\n        {\n            ret[x[i]] = i;\n        }\n        return ret;\n    }\n    static int[] mul(int[] x, int[] y) {\n        var ret = x.copy();\n        for (int i = 0; i < ret.Length; i++)\n        {\n            ret[i] = y[ret[i]];\n        }\n        return ret;\n    }\n    static int[][] mul1(int[][] A, int[][] x) {\n        var ret = new int[2][];\n        for (int i = 0; i < 2; i++)\n        {\n            ret[i] = mul(mul(A[i][0], x[0]), mul(A[i][1], x[1]));\n        }\n        return ret;\n    }\n    static int[][] mul2(int[][] A, int[][] B) {\n        var ret = new int[2][];\n        for (int i = 0; i < 2; i++)\n        {\n            ret[i] = new int[2];\n            for (int j = 0; j < 2; j++)\n            {\n                ret[i][j] = A[i][0] * B[0][j] + A[i][1] * B[1][j];\n            }\n        }\n        return ret;\n    }\n    static int[][] pow(int[][] A, long k) {\n        if (k == 1) {\n            return A;\n        }\n        var t = pow(A, k / 2);\n        t = mul2(t, t);\n        if (k % 2 == 1) t = mul2(t, A);\n        return t;\n    }\n    static int[] pow(int[] p, long k) {\n        if (k == 0) {\n            var ret = new int[p.Length];\n            for (int i = 0; i < ret.Length; i++)\n            {\n                ret[i] = i;\n            }\n            return ret;\n        }\n        var t = pow(p, k / 2);\n        t = mul(t, t);\n        if (k % 2 == 1) t = mul(t, p);\n        return t;\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nclass K\n{\n\tstatic int[] G => ReadLine().Split().Select(i => int.Parse(i) - 1).ToArray();\n\tstatic int N;\n\tstatic void Main()\n\t{\n\t\tvar I = G;\n\t\tN = I[0] + 1;\n\t\tWriteLine(string.Join(\" \", C(G, G, I[1]).Select(i => i + 1)));\n\t}\n\tstatic int[] C(int[] p, int[] q, int K)\n\t{\n\t\tint[] P = I(p), Q = I(q), x = E(M(q, P, Q, p), K / 6), y = I(x);\n\t\tswitch (K % 6)\n\t\t{\n\t\t\tcase 0: return M(x, p, y);\n\t\t\tcase 1: return M(x, q, y);\n\t\t\tcase 2: return M(x, q, P, y);\n\t\t\tcase 3: return M(x, q, P, Q, y);\n\t\t\tcase 4: return M(x, q, P, Q, p, Q, y);\n\t\t\tdefault: return M(x, q, P, Q, p, p, Q, y);\n\t\t}\n\t}\n\tstatic int[] I(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tstatic int[] M(int[] a, int[] b) { var p = new int[N]; for (var i = 0; i < N; i++) p[i] = a[b[i]]; return p; }\n\tstatic int[] M(params int[][] a) => a.Aggregate(M);\n\tstatic int[] E(int[] a, int b)\n\t{\n\t\tif (b < 0) return I(E(a, -b));\n\t\tvar p = new int[N];\n\t\tvar f = new bool[N];\n\t\tfor (var i = 0; i < N; i++)\n\t\t\tif (!f[i])\n\t\t\t{\n\t\t\t\tvar l = new List<int>();\n\t\t\t\tvar x = i;\n\t\t\t\twhile (!f[x]) { l.Add(x); f[x] = true; x = a[x]; }\n\t\t\t\tvar C = l.Count;\n\t\t\t\tfor (var j = 0; j < C; j++) p[l[j]] = l[(j + b) % C];\n\t\t\t}\n\t\treturn p;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n\tstatic int[] G => ReadLine().Split().Select(int.Parse).ToArray();\n\tstatic T[] MakeArray<T>(int n, Func<int, T> f) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = f(i); return a; }\n\tstatic int N;\n\tpublic K()\n\t{\n\t\tvar I = G;\n\t\tN = I[0];\n\t\tWriteLine(ToString(Calc(Get(), Get(), I[1] - 1)));\n\t}\n\tstatic int[] Get() => G.Select(i => i - 1).ToArray();\n\tstatic string ToString(int[] p) => string.Join(\" \", p.Select(i => i + 1));\n\tstatic int[] Calc(int[] p, int[] q, int K)\n\t{\n\t\tint[] P = Inv(p), Q = Inv(q), x = Mult(q, P, Q, p), y = Mult(P, q, p, Q);\n\t\tswitch (K % 6)\n\t\t{\n\t\t\tcase 0: return Mult(Pow(x, K / 6), q, p, Q, Pow(y, K / 6 - 1));\n\t\t\tcase 1: return Mult(Pow(x, K / 6), q, Pow(y, K / 6));\n\t\t\tcase 2: return Mult(Pow(x, K / 6), q, P, Pow(y, K / 6));\n\t\t\tcase 3: return Mult(Pow(x, K / 6), q, P, Q, Pow(y, K / 6));\n\t\t\tcase 4: return Mult(Pow(x, K / 6), q, P, Q, p, Q, Pow(y, K / 6));\n\t\t\tdefault: return Mult(Pow(x, K / 6), q, P, Q, p, p, Q, Pow(y, K / 6));\n\t\t}\n\t}\n\tstatic int[] Inv(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tstatic int[] Mult(int[] a, int[] b) => MakeArray(N, i => a[b[i]]);\n\tstatic int[] Mult(params int[][] a) => a.Aggregate(Mult);\n\tstatic int[] Pow(int[] a, int b)\n\t{\n\t\tif (b < 0) return Inv(Pow(a, -b));\n\t\tvar p = new int[N];\n\t\tvar f = new bool[N];\n\t\tfor (var i = 0; i < N; i++)\n\t\t\tif (!f[i])\n\t\t\t{\n\t\t\t\tvar l = new List<int>();\n\t\t\t\tvar x = i;\n\t\t\t\twhile (!f[x]) { l.Add(x); f[x] = true; x = a[x]; }\n\t\t\t\tvar C = l.Count;\n\t\t\t\tfor (var j = 0; j < C; j++) p[l[j]] = l[(j + b) % C];\n\t\t\t}\n\t\treturn p;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n\tstatic int F => int.Parse(Str);\n\tstatic long FL => long.Parse(Str);\n\tstatic int[] G => Strs.Select(int.Parse).ToArray();\n\tstatic decimal[] GD => Strs.Select(decimal.Parse).ToArray();\n\tstatic long[] GL => Strs.Select(long.Parse).ToArray();\n\tstatic string Str => ReadLine();\n\tstatic string[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n\tstatic T[] ConstantArray<T>(int n, T val) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = val; return a; }\n\tstatic T[] MakeArray<T>(int n, Func<int, T> f) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = f(i); return a; }\n\tconst int MOD = 1000000007;\n\tpublic K()\n\t{\n\t\tSetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n\t\tSolve();\n\t\tOut.Flush();\n\t}\n\tstatic int N;\n\tvoid Solve()\n\t{\n\t\tvar I = G;\n\t\tN = I[0];\n\t\tWriteLine(ToString(Calc(Get(), Get(), I[1] - 1)));\n\t}\n\tstatic int[] Get() => G.Select(i => i - 1).ToArray();\n\tstatic string ToString(int[] p) => string.Join(\" \", p.Select(i => i + 1));\n\tstatic int[] Calc(int[] p, int[] q, int K)\n\t{\n\t\t// if (K == 0) return p;\n\t\t// if (K == 1) return q;\n\t\t// if (K < 6) return Calc(q, Mult(q, Inv(p)), K - 1);\n\t\tint[] ip = Inv(p), iq = Inv(q), x = Mult(q, ip, iq, p), y = Mult(ip, q, p, iq);\n\t\tswitch (K % 6)\n\t\t{\n\t\t\tcase 0: return Mult(Pow(x, K / 6), q, p, iq, Pow(y, K / 6 - 1));\n\t\t\tcase 1: return Mult(Pow(x, K / 6), q, Pow(y, K / 6));\n\t\t\tcase 2: return Mult(Pow(x, K / 6), q, ip, Pow(y, K / 6));\n\t\t\tcase 3: return Mult(Pow(x, K / 6), q, ip, iq, Pow(y, K / 6));\n\t\t\tcase 4: return Mult(Pow(x, K / 6 + 1), iq, Pow(y, K / 6));\n\t\t\tdefault: return Mult(Pow(x, K / 6 + 1), p, iq, Pow(y, K / 6));\n\t\t}\n\t}\n\tstatic int[] Inv(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tstatic int[] Mult(int[] a, int[] b)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[i] = a[b[i]];\n\t\treturn c;\n\t}\n\tstatic int[] Mult(params int[][] a)\n\t{\n\t\tif (a.Length == 0) return MakeArray(N, i => i);\n\t\tvar x = a[0];\n\t\tfor (var i = 1; i < a.Length; i++) x = Mult(x, a[i]);\n\t\treturn x;\n\t}\n\tstatic int[] Pow(int[] a, int b)\n\t{\n\t\tvar p = new int[N];\n\t\tvar done = new bool[N];\n\t\tfor (var i = 0; i < N; i++)\n\t\t\tif (!done[i])\n\t\t\t{\n\t\t\t\tdone[i] = true;\n\t\t\t\tvar cycle = new List<int> { i };\n\t\t\t\tvar x = a[i];\n\t\t\t\twhile (x != i) { cycle.Add(x); done[x] = true; x = a[x]; }\n\t\t\t\tvar L = cycle.Count;\n\t\t\t\tvar c = (b + L) % L;\n\t\t\t\tfor (var j = 0; j < L; j++) p[cycle[j]] = cycle[(j + c) % L];\n\t\t\t}\n\t\treturn p;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;using static System.Console;class K{int[]G=>ReadLine().Split().Select(i=>int.Parse(i)-1).ToArray();int N;static void Main()=>new K().Z();void Z(){var I=G;N=I[0]+1;WriteLine(string.Join(\" \",C(G,G,I[1]).Select(i=>i+1)));}int[]C(int[]p,int[]q,int K){int[]P=I(p),Q=I(q),x=E(M(q,P,Q,p),K/6),y=I(x);switch(K%6){case 0:return M(x,p,y);case 1:return M(x,q,y);case 2:return M(x,q,P,y);case 3:return M(x,q,P,Q,y);case 4:return M(x,q,P,Q,p,Q,y);default:return M(x,q,P,Q,p,p,Q,y);}}int[]I(int[]a){var c=new int[N];for(var i=0;i<N;i++)c[a[i]]=i;return c;}int[]M(int[]a,int[]b){var p=new int[N];for(var i=0;i<N;i++)p[i]=a[b[i]];return p;}int[]M(params int[][]a)=>a.Aggregate(M);int[]E(int[]a,int b){int[]p=new int[N],f=new int[N],l=new int[N];for(var i=0;i<N;i++)if(f[i]<1){int x=i,C=0;while(f[x]<1){l[C++]=x;f[x]=1;x=a[x];}for(var j=0;j<C;j++)p[l[j]]=l[(j+b)%C];}return p;}}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;using static System.Console;class K{int[]G=>ReadLine().Split().Select(i=>int.Parse(i)-1).ToArray();int N;int[]X=>new int[N];static void Main()=>new K().Z();void Z(){var I=G;N=I[0]+1;WriteLine(string.Join(\" \",C(G,G,I[1]).Select(i=>i+1)));}int[]C(int[]p,int[]q,int K){int[]P=I(p),Q=I(q),x=E(M(q,P,Q,p),K/6),y=I(x);switch(K%6){case 0:return M(x,p,y);case 1:return M(x,q,y);case 2:return M(x,q,P,y);case 3:return M(x,q,P,Q,y);case 4:return M(x,q,P,Q,p,Q,y);default:return M(x,q,P,Q,p,p,Q,y);}}int[]I(int[]a){var c=X;for(var i=0;i<N;i++)c[a[i]]=i;return c;}int[]M(params int[][]l)=>l.Aggregate((a,b)=>{var p=X;for(var i=0;i<N;i++)p[i]=a[b[i]];return p;});int[]E(int[]a,int b){int[]p=X,f=X,l=X;for(var i=0;i<N;i++)if(f[i]<1){int x=i,C=0;while(f[x]<1){l[C++]=x;f[x]=1;x=a[x];}for(var j=0;j<C;j++)p[l[j]]=l[(j+b)%C];}return p;}}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n\tint F => int.Parse(Str);\n\tlong FL => long.Parse(Str);\n\tint[] G => Strs.Select(int.Parse).ToArray();\n\tdecimal[] GD => Strs.Select(decimal.Parse).ToArray();\n\tlong[] GL => Strs.Select(long.Parse).ToArray();\n\tstring Str => ReadLine();\n\tstring[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n\tstatic T[] ConstantArray<T>(int n, T val) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = val; return a; }\n\tstatic T[] MakeArray<T>(int n, Func<int, T> f) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = f(i); return a; }\n\tconst int MOD = 1000000007;\n\tpublic K()\n\t{\n\t\tSetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n\t\tSolve();\n\t\tOut.Flush();\n\t}\n\tint N;\n\tvoid Solve()\n\t{\n\t\tvar I = G;\n\t\tN = I[0];\n\t\tWriteLine(ToString(Calc(Get(), Get(), I[1] - 1)));\n\t}\n\tint[] Get() => G.Select(i => i - 1).ToArray();\n\tstring ToString(int[] p) => string.Join(\" \", p.Select(i => i + 1));\n\tint[] Calc(int[] p, int[] q, int K)\n\t{\n\t\tif (K == 0) return p;\n\t\tif (K == 1) return q;\n\t\tif (K < 6) return Calc(q, Mult(q, Inv(p)), K - 1);\n\t\tint[] ip = Inv(p), iq = Inv(q), x = Mult(q, ip, iq, p), y = Mult(ip, q, p, iq);\n\t\tswitch (K % 6)\n\t\t{\n\t\t\tcase 0: return Mult(Pow(x, K / 6), q, p, iq, Pow(y, K / 6 - 1));\n\t\t\tcase 1: return Mult(Pow(x, K / 6), q, Pow(y, K / 6));\n\t\t\tcase 2: return Mult(Pow(x, K / 6), q, ip, Pow(y, K / 6));\n\t\t\tcase 3: return Mult(Pow(x, K / 6), q, ip, iq, Pow(y, K / 6));\n\t\t\tcase 4: return Mult(Pow(x, K / 6 + 1), iq, Pow(y, K / 6));\n\t\t\tdefault: return Mult(Pow(x, K / 6 + 1), p, iq, Pow(y, K / 6));\n\t\t}\n\t}\n\tint[] Pow(int[] a, int b)\n\t{\n\t\tvar p = MakeArray(N, i => i);\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = Mult(p, x);\n\t\t\tb >>= 1;\n\t\t\tx = Mult(x, x);\n\t\t}\n\t\treturn p;\n\t}\n\tint[] Inv(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tint[] Mult(params int[][] a)\n\t{\n\t\tif (a.Length == 0) return MakeArray(N, i => i);\n\t\tvar x = a[0];\n\t\tfor (var i = 1; i < a.Length; i++) x = Mult(x, a[i]);\n\t\treturn x;\n\t}\n\tint[] Mult(int[] a, int[] b)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[i] = a[b[i]];\n\t\treturn c;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;  \nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Gtand031_D\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var first = Console.ReadLine().Split(' ');\n            var N = int.Parse(first[0]);\n            var K = int.Parse(first[1]);\n            var p = Console.ReadLine().Split(' ').Select(c => int.Parse(c)).ToArray();\n            var q = Console.ReadLine().Split(' ').Select(c => int.Parse(c)).ToArray();\n            var ret = new int[N];\n            for(int i = 0; i<K-2;i++)\n            {\n                for(int j=0;j<N;j++)\n                {\n                    ret[p[j]-1] = q[j]; \n                }\n                p = q;\n                q = ret;\n            }\n            Console.WriteLine(String.Join(\" \", ret));\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n\tstatic int F => int.Parse(Str);\n\tstatic long FL => long.Parse(Str);\n\tstatic int[] G => Strs.Select(int.Parse).ToArray();\n\tstatic decimal[] GD => Strs.Select(decimal.Parse).ToArray();\n\tstatic long[] GL => Strs.Select(long.Parse).ToArray();\n\tstatic string Str => ReadLine();\n\tstatic string[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n\tstatic T[] ConstantArray<T>(int n, T val) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = val; return a; }\n\tstatic T[] MakeArray<T>(int n, Func<int, T> f) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = f(i); return a; }\n\tconst int MOD = 1000000007;\n\tpublic K()\n\t{\n\t\tSetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n\t\tSolve();\n\t\tOut.Flush();\n\t}\n\tstatic int N;\n\tvoid Solve()\n\t{\n\t\tvar I = G;\n\t\tN = I[0];\n\t\tWriteLine(ToString(Calc(Get(), Get(), I[1] - 1)));\n\t}\n\tstatic int[] Get() => G.Select(i => i - 1).ToArray();\n\tstatic string ToString(int[] p) => string.Join(\" \", p.Select(i => i + 1));\n\tstatic int[] Calc(int[] p, int[] q, int K)\n\t{\n\t\tif (K == 0) return p;\n\t\tif (K == 1) return q;\n\t\tif (K < 6) return Calc(q, Mult(q, Inv(p)), K - 1);\n\t\tint[] ip = Inv(p), iq = Inv(q), x = Mult(q, ip, iq, p), y = Mult(ip, q, p, iq);\n\t\tswitch (K % 6)\n\t\t{\n\t\t\tcase 0: return Mult(Pow(x, K / 6), q, p, iq, Pow(y, K / 6 - 1));\n\t\t\tcase 1: return Mult(Pow(x, K / 6), q, Pow(y, K / 6));\n\t\t\tcase 2: return Mult(Pow(x, K / 6), q, ip, Pow(y, K / 6));\n\t\t\tcase 3: return Mult(Pow(x, K / 6), q, ip, iq, Pow(y, K / 6));\n\t\t\tcase 4: return Mult(Pow(x, K / 6 + 1), iq, Pow(y, K / 6));\n\t\t\tdefault: return Mult(Pow(x, K / 6 + 1), p, iq, Pow(y, K / 6));\n\t\t}\n\t}\n\tstatic int[] Inv(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tstatic int[] Mult(int[] a, int[] b)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[i] = a[b[i]];\n\t\treturn c;\n\t}\n\tstatic int[] Mult(params int[][] a)\n\t{\n\t\tif (a.Length == 0) return MakeArray(N, i => i);\n\t\tvar x = a[0];\n\t\tfor (var i = 1; i < a.Length; i++) x = Mult(x, a[i]);\n\t\treturn x;\n\t}\n\tstatic int[] Pow(int[] a, int b)\n\t{\n\t\tvar p = new int[N];\n\t\tvar done = new bool[N];\n\t\tfor (var i = 0; i < N; i++)\n\t\t\tif (!done[i])\n\t\t\t{\n\t\t\t\tdone[i] = true;\n\t\t\t\tvar cycle = new List<int> { i };\n\t\t\t\tvar x = a[i];\n\t\t\t\twhile (x != i) { cycle.Add(x); done[x] = true; x = a[x]; }\n\t\t\t\tvar L = cycle.Count;\n\t\t\t\tvar c = b % L;\n\t\t\t\tfor (var j = 0; j < L; j++) p[cycle[j]] = cycle[(j + c) % L];\n\t\t\t}\n\t\treturn p;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nclass K\n{\nint[]G=>ReadLine().Split().Select(i=>int.Parse(i)-1).ToArray();\nint N;\nstatic void Main()=>new K().Z();\nvoid Z()\n{\nvar I=G;\nN=I[0]+1;\nWriteLine(string.Join(\" \",C(G,G,I[1]).Select(i=>i+1)));\n}\nint[]C(int[]p,int[]q,int K)\n{\nint[]P=I(p),Q=I(q),x=E(M(q,P,Q,p),K/6),y=I(x);\nswitch(K%6)\n{\ncase 0:return M(x,p,y);\ncase 1:return M(x,q,y);\ncase 2:return M(x,q,P,y);\ncase 3:return M(x,q,P,Q,y);\ncase 4:return M(x,q,P,Q,p,Q,y);\ndefault:return M(x,q,P,Q,p,p,Q,y);\n}\n}\nint[]I(int[]a)\n{\nvar c=new int[N];\nfor(var i=0;i<N;i++)c[a[i]]=i;\nreturn c;\n}\nint[]M(int[]a,int[]b){var p=new int[N];for(var i=0;i<N;i++)p[i]=a[b[i]];return p;}\nint[]M(params int[][]a)=>a.Aggregate(M);\nint[]E(int[]a,int b)\n{\nvar p=new int[N];\nvar f=new bool[N];\nfor(var i=0;i<N;i++)\nif(!f[i])\n{\nvar l=new List<int>();\nvar x=i;\nwhile(!f[x]){l.Add(x);f[x]=true;x=a[x];}\nvar C=l.Count;\nfor(var j=0;j<C;j++)p[l[j]]=l[(j+b)%C];\n}\nreturn p;\n}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main(string[] args)\n    {\n        int n, k;\n        sc.Multi(out n, out k);\n        var p = sc.IntArr.Select(x => x - 1).ToArray();\n        var q = sc.IntArr.Select(x => x - 1).ToArray();\n        var a = new int[6][];\n        a[0] = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[0][i] = i;\n        }\n        a[1] = inv(q);\n        a[2] = mul(a[1], p);\n        a[3] = mul(a[2], q);\n        a[4] = mul(a[3], inv(p));\n        a[5] = mul(a[4], q);\n        int c = k - 2 - k / 3;\n        var b = pow(a[4], c / 4);\n        var ib = inv(b);\n        b = mul(b, a[c % 4]);\n        if (k % 3 == 0) {\n            ib = mul(inv(a[c % 4 + 2]), ib);\n        }\n        else\n            ib = mul(inv(a[c % 4 + 1]), ib);\n\n        var ans = mul(b, ib);\n        Prt(ans.Select(x => x + 1));\n\n        if (false) {\n            var A = new int[2][];\n            A[0] = new int[] { 0, 1 };\n            A[1] = new int[] { -1, 1 };\n            var r = new int[][] { p, q };\n            for (int i = 0; i < k - 2; i++)\n            {\n                r = mul1(A, r);\n            }\n            // var r = mul1(pow(A, k - 2), p);\n            Prt(r[1]);\n        }\n        sw.Flush();\n    }\n    // 0: e, 1: x, -1: inv\n    static int[] mul(int A, int[] x) {\n        var ret = x.copy();\n        for (int i = 0; i < ret.Length; i++)\n        {\n            if (A == 0) {\n                ret[i] = i;\n            }\n            else if (A == 1) {\n                ret[i] = x[i];\n            }\n            else if (A == -1) {\n                ret[x[i]] = i;\n            }\n            else throw new Exception();\n        }\n        return ret;\n    }\n    static int[] inv(int[] x) {\n        var ret = new int[x.Length];\n        for (int i = 0; i < ret.Length; i++)\n        {\n            ret[x[i]] = i;\n        }\n        return ret;\n    }\n    static int[] mul(int[] x, int[] y) {\n        var ret = x.copy();\n        for (int i = 0; i < ret.Length; i++)\n        {\n            ret[i] = y[ret[i]];\n        }\n        return ret;\n    }\n    static int[][] mul1(int[][] A, int[][] x) {\n        var ret = new int[2][];\n        for (int i = 0; i < 2; i++)\n        {\n            ret[i] = mul(mul(A[i][0], x[0]), mul(A[i][1], x[1]));\n        }\n        return ret;\n    }\n    static int[][] mul2(int[][] A, int[][] B) {\n        var ret = new int[2][];\n        for (int i = 0; i < 2; i++)\n        {\n            ret[i] = new int[2];\n            for (int j = 0; j < 2; j++)\n            {\n                ret[i][j] = A[i][0] * B[0][j] + A[i][1] * B[1][j];\n            }\n        }\n        return ret;\n    }\n    static int[][] pow(int[][] A, long k) {\n        if (k == 1) {\n            return A;\n        }\n        var t = pow(A, k / 2);\n        t = mul2(t, t);\n        if (k % 2 == 1) t = mul2(t, A);\n        return t;\n    }\n    static int[] pow(int[] p, long k) {\n        if (k == 0) {\n            var ret = new int[p.Length];\n            for (int i = 0; i < ret.Length; i++)\n            {\n                ret[i] = i;\n            }\n            return ret;\n        }\n        var t = pow(p, k / 2);\n        t = mul(t, t);\n        if (k % 2 == 1) t = mul(t, p);\n        return t;\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing static System.Console;\nclass K\n{\nint[]G=>ReadLine().Split().Select(i=>int.Parse(i)-1).ToArray();\nint N;\nstatic void Main()=>new K().Z();\nvoid Z()\n{\nvar I=G;\nN=I[0]+1;\nWriteLine(string.Join(\" \",C(G,G,I[1]).Select(i=>i+1)));\n}\nint[]C(int[]p,int[]q,int K)\n{\nint[]P=I(p),Q=I(q),x=E(M(q,P,Q,p),K/6),y=I(x);\nswitch(K%6)\n{\ncase 0:return M(x,p,y);\ncase 1:return M(x,q,y);\ncase 2:return M(x,q,P,y);\ncase 3:return M(x,q,P,Q,y);\ncase 4:return M(x,q,P,Q,p,Q,y);\ndefault:return M(x,q,P,Q,p,p,Q,y);\n}\n}\nint[]I(int[]a)\n{\nvar c=new int[N];\nfor(var i=0;i<N;i++)c[a[i]]=i;\nreturn c;\n}\nint[]M(int[]a,int[]b){var p=new int[N];for(var i=0;i<N;i++)p[i]=a[b[i]];return p;}\nint[]M(params int[][]a)=>a.Aggregate(M);\nint[]E(int[]a,int b)\n{\nvar p=new int[N];\nvar f=new int[N];\nvar l=new int[N];\nfor(var i=0;i<N;i++)\nif(f[i]<1)\n{\nint x=i,C=0;\nwhile(f[x]<1){l[C++]=(x);f[x]=1;x=a[x];}\nfor(var j=0;j<C;j++)p[l[j]]=l[(j+b)%C];\n}\nreturn p;\n}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n\tstatic int F => int.Parse(Str);\n\tstatic long FL => long.Parse(Str);\n\tstatic int[] G => Strs.Select(int.Parse).ToArray();\n\tstatic decimal[] GD => Strs.Select(decimal.Parse).ToArray();\n\tstatic long[] GL => Strs.Select(long.Parse).ToArray();\n\tstatic string Str => ReadLine();\n\tstatic string[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n\tstatic T[] ConstantArray<T>(int n, T val) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = val; return a; }\n\tstatic T[] MakeArray<T>(int n, Func<int, T> f) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = f(i); return a; }\n\tconst int MOD = 1000000007;\n\tpublic K()\n\t{\n\t\tSetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n\t\tSolve();\n\t\tOut.Flush();\n\t}\n\tstatic int N;\n\tvoid Solve()\n\t{\n\t\tvar I = G;\n\t\tN = I[0];\n\t\tWriteLine(ToString(Calc(Get(), Get(), I[1] - 1)));\n\t}\n\tstatic int[] Get() => G.Select(i => i - 1).ToArray();\n\tstatic string ToString(int[] p) => string.Join(\" \", p.Select(i => i + 1));\n\tstatic int[] Calc(int[] p, int[] q, int K)\n\t{\n\t\tif (K == 0) return p;\n\t\tif (K == 1) return q;\n\t\tif (K < 6) return Calc(q, Mult(q, Inv(p)), K - 1);\n\t\tint[] ip = Inv(p), iq = Inv(q), x = Mult(q, ip, iq, p), y = Mult(ip, q, p, iq);\n\t\tswitch (K % 6)\n\t\t{\n\t\t\tcase 0: return Mult(Pow(x, K / 6), q, p, iq, Pow(y, K / 6 - 1));\n\t\t\tcase 1: return Mult(Pow(x, K / 6), q, Pow(y, K / 6));\n\t\t\tcase 2: return Mult(Pow(x, K / 6), q, ip, Pow(y, K / 6));\n\t\t\tcase 3: return Mult(Pow(x, K / 6), q, ip, iq, Pow(y, K / 6));\n\t\t\tcase 4: return Mult(Pow(x, K / 6 + 1), iq, Pow(y, K / 6));\n\t\t\tdefault: return Mult(Pow(x, K / 6 + 1), p, iq, Pow(y, K / 6));\n\t\t}\n\t}\n\tstatic int[] Inv(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tstatic int[] Mult(int[] a, int[] b)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[i] = a[b[i]];\n\t\treturn c;\n\t}\n\tstatic int[] Mult(params int[][] a)\n\t{\n\t\tif (a.Length == 0) return MakeArray(N, i => i);\n\t\tvar x = a[0];\n\t\tfor (var i = 1; i < a.Length; i++) x = Mult(x, a[i]);\n\t\treturn x;\n\t}\n\tstatic int[] Pow(int[] a, int b)\n\t{\n\t\tvar p = MakeArray(N, i => i);\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = Mult(p, x);\n\t\t\tb >>= 1;\n\t\t\tx = Mult(x, x);\n\t\t}\n\t\treturn p;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;using System.Linq;using static System.Console;class K{int[]G=>ReadLine().Split().Select(i=>int.Parse(i)-1).ToArray();int N;static void Main()=>new K().Z();void Z(){var I=G;N=I[0]+1;WriteLine(string.Join(\" \",C(G,G,I[1]).Select(i=>i+1)));}int[]C(int[]p,int[]q,int K){int[]P=I(p),Q=I(q),x=E(M(q,P,Q,p),K/6),y=I(x);switch(K%6){case 0:return M(x,p,y);case 1:return M(x,q,y);case 2:return M(x,q,P,y);case 3:return M(x,q,P,Q,y);case 4:return M(x,q,P,Q,p,Q,y);default:return M(x,q,P,Q,p,p,Q,y);}}int[]I(int[]a){var c=new int[N];for(var i=0;i<N;i++)c[a[i]]=i;return c;}int[]M(int[]a,int[]b){var p=new int[N];for(var i=0;i<N;i++)p[i]=a[b[i]];return p;}int[]M(params int[][]a)=>a.Aggregate(M);int[]E(int[]a,int b){var p=new int[N];var f=new bool[N];for(var i=0;i<N;i++)if(!f[i]){var l=new List<int>();var x=i;while(!f[x]){l.Add(x);f[x]=true;x=a[x];}var C=l.Count;for(var j=0;j<C;j++)p[l[j]]=l[(j+b)%C];}return p;}}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\nclass AtCoder\n{\n    static int[] f(int[] p, int[] q)\n    {\n        int[] ret = new int[p.Length];\n        foreach(int i in Enumerable.Range(0, ret.Length))\n        {\n            ret[p[i]] = q[i];\n        }\n        return ret;\n    }\n    const int MOD = 1000000007;\n    public void Slove()\n    {\n        var inputs = Console.ReadLine().Split();\n        var n = int.Parse(inputs[0]);\n        var k = int.Parse(inputs[1]) - 2;\n        var p = Console.ReadLine().Split().Select(x => int.Parse(x) - 1).ToArray();\n        var q = Console.ReadLine().Split().Select(x => int.Parse(x) - 1).ToArray();\n\n        int count = 0;\n        var a1 = new int[n];\n        var a2 = new int[n];\n        p.CopyTo(a1, 0);\n        q.CopyTo(a2, 0);\n        foreach(int i in Enumerable.Range(1, k))\n        {\n            //System.Console.WriteLine(string.Join(\" \",a2.Select(x => x + 1)));\n            int[] temp = new int[n];\n            a2.CopyTo(temp, 0);    \n            a2 = f(a1, a2);\n            a1 = temp;\n            if(a1.SequenceEqual(p) && a2.SequenceEqual(q))\n            {\n                count = i;\n                //System.Console.WriteLine($\"end {count}\");\n                break;\n            }\n        }\n        if(count == 0)\n            System.Console.WriteLine(string.Join(\" \",a2.Select(x => x + 1)));\n        else\n        { \n            foreach(int i in Enumerable.Range(0, k % count))\n            {\n                int[] temp = new int[n];\n                a2.CopyTo(temp, 0);\n                a2 = f(a1, a2);\n                a1 = temp;\n            }\n            System.Console.WriteLine(string.Join(\" \",a2.Select(x => x + 1)));            \n        }\n    }\n    static void Main()\n    {\n        var ac = new AtCoder();\n        ac.Slove();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n\tstatic int F => int.Parse(Str);\n\tstatic long FL => long.Parse(Str);\n\tstatic int[] G => Strs.Select(int.Parse).ToArray();\n\tstatic decimal[] GD => Strs.Select(decimal.Parse).ToArray();\n\tstatic long[] GL => Strs.Select(long.Parse).ToArray();\n\tstatic string Str => ReadLine();\n\tstatic string[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n\tstatic T[] ConstantArray<T>(int n, T val) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = val; return a; }\n\tstatic T[] MakeArray<T>(int n, Func<int, T> f) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = f(i); return a; }\n\tconst int MOD = 1000000007;\n\tpublic K()\n\t{\n\t\tSetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n\t\tSolve();\n\t\tOut.Flush();\n\t}\n\tstatic int N;\n\tvoid Solve()\n\t{\n\t\tvar I = G;\n\t\tN = I[0];\n\t\tWriteLine(ToString(Calc(Get(), Get(), I[1] - 1)));\n\t}\n\tstatic int[] Get() => G.Select(i => i - 1).ToArray();\n\tstatic string ToString(int[] p) => string.Join(\" \", p.Select(i => i + 1));\n\tstatic int[] Calc(int[] p, int[] q, int K)\n\t{\n\t\tint[] ip = Inv(p), iq = Inv(q), x = Mult(q, ip, iq, p), y = Mult(ip, q, p, iq);\n\t\tswitch (K % 6)\n\t\t{\n\t\t\tcase 0: return Mult(Pow(x, K / 6), q, p, iq, Pow(y, K / 6 - 1));\n\t\t\tcase 1: return Mult(Pow(x, K / 6), q, Pow(y, K / 6));\n\t\t\tcase 2: return Mult(Pow(x, K / 6), q, ip, Pow(y, K / 6));\n\t\t\tcase 3: return Mult(Pow(x, K / 6), q, ip, iq, Pow(y, K / 6));\n\t\t\tcase 4: return Mult(Pow(x, K / 6 + 1), iq, Pow(y, K / 6));\n\t\t\tdefault: return Mult(Pow(x, K / 6 + 1), p, iq, Pow(y, K / 6));\n\t\t}\n\t}\n\tstatic int[] Inv(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tstatic int[] Mult(int[] a, int[] b) => MakeArray(N, i => a[b[i]]);\n\tstatic int[] Mult(params int[][] a)\n\t{\n\t\tif (a.Length == 0) return MakeArray(N, i => i);\n\t\tvar x = a[0];\n\t\tfor (var i = 1; i < a.Length; i++) x = Mult(x, a[i]);\n\t\treturn x;\n\t}\n\tstatic int[] Pow(int[] a, int b)\n\t{\n\t\tif (b < 0) return Inv(Pow(a, -b));\n\t\tvar p = new int[N];\n\t\tvar done = new bool[N];\n\t\tfor (var i = 0; i < N; i++)\n\t\t\tif (!done[i])\n\t\t\t{\n\t\t\t\tdone[i] = true;\n\t\t\t\tvar cycle = new List<int> { i };\n\t\t\t\tvar x = a[i];\n\t\t\t\twhile (x != i) { cycle.Add(x); done[x] = true; x = a[x]; }\n\t\t\t\tvar L = cycle.Count;\n\t\t\t\tvar c = b % L;\n\t\t\t\tfor (var j = 0; j < L; j++) p[cycle[j]] = cycle[(j + c) % L];\n\t\t\t}\n\t\treturn p;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "a"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nclass K\n{\n\tstatic int[] G => ReadLine().Split().Select(i => int.Parse(i) - 1).ToArray();\n\tstatic int N;\n\tstatic void Main()\n\t{\n\t\tvar I = G;\n\t\tN = I[0] + 1;\n\t\tWriteLine(ToString(Calc(G, G, I[1])));\n\t}\n\tstatic string ToString(int[] p) => string.Join(\" \", p.Select(i => i + 1));\n\tstatic int[] Calc(int[] p, int[] q, int K)\n\t{\n\t\tint[] P = Inv(p), Q = Inv(q), x = Pow(Mult(q, P, Q, p), K / 6), y = Inv(x);\n\t\tswitch (K % 6)\n\t\t{\n\t\t\tcase 0: return Mult(x, p, y);\n\t\t\tcase 1: return Mult(x, q, y);\n\t\t\tcase 2: return Mult(x, q, P, y);\n\t\t\tcase 3: return Mult(x, q, P, Q, y);\n\t\t\tcase 4: return Mult(x, q, P, Q, p, Q, y);\n\t\t\tdefault: return Mult(x, q, P, Q, p, p, Q, y);\n\t\t}\n\t}\n\tstatic int[] Inv(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tstatic int[] Mult(int[] a, int[] b) { var p = new int[N]; for (var i = 0; i < N; i++) p[i] = a[b[i]]; return p; }\n\tstatic int[] Mult(params int[][] a) => a.Aggregate(Mult);\n\tstatic int[] Pow(int[] a, int b)\n\t{\n\t\tif (b < 0) return Inv(Pow(a, -b));\n\t\tvar p = new int[N];\n\t\tvar f = new bool[N];\n\t\tfor (var i = 0; i < N; i++)\n\t\t\tif (!f[i])\n\t\t\t{\n\t\t\t\tvar l = new List<int>();\n\t\t\t\tvar x = i;\n\t\t\t\twhile (!f[x]) { l.Add(x); f[x] = true; x = a[x]; }\n\t\t\t\tvar C = l.Count;\n\t\t\t\tfor (var j = 0; j < C; j++) p[l[j]] = l[(j + b) % C];\n\t\t\t}\n\t\treturn p;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n\tint F => int.Parse(Str);\n\tlong FL => long.Parse(Str);\n\tint[] G => Strs.Select(int.Parse).ToArray();\n\tdecimal[] GD => Strs.Select(decimal.Parse).ToArray();\n\tlong[] GL => Strs.Select(long.Parse).ToArray();\n\tstring Str => ReadLine();\n\tstring[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n\tstatic T[] ConstantArray<T>(int n, T val) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = val; return a; }\n\tstatic T[] MakeArray<T>(int n, Func<int, T> f) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = f(i); return a; }\n\tconst int MOD = 1000000007;\n\tpublic K()\n\t{\n\t\tSetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n\t\tSolve();\n\t\tOut.Flush();\n\t}\n\tint N;\n\tvoid Solve()\n\t{\n\t\tvar I = G;\n\t\tN = I[0];\n\t\tvar K = I[1];\n\t\tvar p = G;\n\t\tvar q = G;\n\t\tfor (var i = 0; i < N; i++) { p[i]--; q[i]--; }\n\t\tWriteLine(string.Join(\" \", Calc(p, q, K).Select(i => i + 1)));\n\t}\n\tint[] Calc(int[] p, int[] q, int K)\n\t{\n\t\tif (K == 1) return p;\n\t\tif (K == 2) return q;\n\t\tif (K < 10) return Calc(q, Mult(q, Inv(p)), K - 1);\n\t\tK--;\n\t\tvar ip = Inv(p);\n\t\tvar iq = Inv(q);\n\t\tvar x = Mult(q, ip, iq, p);\n\t\tvar y = Mult(ip, q, p, iq);\n\t\tif (K % 6 == 0)\n\t\t{\n\t\t\t// 12\n\t\t\t// q.ip.iq.p.q.ip.iq.p.q.p.iq.ip.q.p.iq\n\t\t\t// x        .x        .q.p.iq.y\n\t\t\t// 18\n\t\t\t// q.ip.iq.p.q.ip.iq.p.q.ip.iq.p.q.p.iq.ip.q.p.iq.ip.q.p.iq\n\t\t\t// x      .x          .x        .q.p.iq.y        .y\n\t\t\treturn Mult(Pow(x, K / 6), q, p, iq, Pow(y, K / 6 - 1));\n\t\t}\n\t\tif (K % 6 == 1)\n\t\t{\n\t\t\t// q.ip.iq.p.q.ip.iq.p.q.ip.q.p.iq.ip.q.p.iq\n\t\t\t// x        .x        .q.y        .y\n\t\t\treturn Mult(Pow(x, K / 6), q, Pow(y, K / 6));\n\t\t}\n\t\tif (K % 6 == 2)\n\t\t{\n\t\t\t// q.ip\n\t\t\t// q.ip\n\t\t\treturn Mult(Pow(x, K / 6), q, ip, Pow(y, K / 6));\n\t\t}\n\t\tif (K % 6 == 3)\n\t\t{\n\t\t\t// q.ip.iq\n\t\t\t// q.ip.iq\n\t\t\treturn Mult(Pow(x, K / 6), q, ip, iq, Pow(y, K / 6));\n\t\t}\n\t\tif (K % 6 == 4)\n\t\t{\n\t\t\t// iq\n\t\t\t// iq\n\t\t\treturn Mult(Pow(x, K / 6 + 1), iq, Pow(y, K / 6));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// p.iq\n\t\t\t// p.iq\n\t\t\treturn Mult(Pow(x, K / 6 + 1), p, iq, Pow(y, K / 6));\n\t\t}\n\t}\n\tint[] Pow(int[] a, int b)\n\t{\n\t\tvar p = MakeArray(N, i => i);\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = Mult(p, x);\n\t\t\tb >>= 1;\n\t\t\tx = Mult(x, x);\n\t\t}\n\t\treturn p;\n\t}\n\tint[] Inv(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tint[] Mult(params int[][] a)\n\t{\n\t\tif (a.Length == 0) return MakeArray(N, i => i);\n\t\tvar x = a[0];\n\t\tfor (var i = 1; i < a.Length; i++) x = Mult(x, a[i]);\n\t\treturn x;\n\t}\n\tint[] Mult(int[] a, int[] b)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[i] = a[b[i]];\n\t\treturn c;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n\tint F => int.Parse(Str);\n\tlong FL => long.Parse(Str);\n\tint[] G => Strs.Select(int.Parse).ToArray();\n\tdecimal[] GD => Strs.Select(decimal.Parse).ToArray();\n\tlong[] GL => Strs.Select(long.Parse).ToArray();\n\tstring Str => ReadLine();\n\tstring[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n\tstatic T[] ConstantArray<T>(int n, T val) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = val; return a; }\n\tstatic T[] MakeArray<T>(int n, Func<int, T> f) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = f(i); return a; }\n\tconst int MOD = 1000000007;\n\tpublic K()\n\t{\n\t\tSetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n\t\tSolve();\n\t\tOut.Flush();\n\t}\n\tint N;\n\tvoid Solve()\n\t{\n\t\tvar I = G;\n\t\tN = I[0];\n\t\tvar K = I[1] - 1;\n\t\tvar p = G;\n\t\tvar q = G;\n\t\tfor (var i = 0; i < N; i++) { p[i]--; q[i]--; }\n\t\tWriteLine(string.Join(\" \", Calc(p, q, K).Select(i => i + 1)));\n\t}\n\tint[] Calc(int[] p, int[] q, int K)\n\t{\n\t\t// if (K == 0) return p;\n\t\t// if (K == 1) return q;\n\t\t// if (K < 10) return Calc(q, Mult(q, Inv(p)), K - 1);\n\t\tvar ip = Inv(p);\n\t\tvar iq = Inv(q);\n\t\tvar x = Mult(q, ip, iq, p);\n\t\tvar y = Mult(ip, q, p, iq);\n\t\tif (K % 6 == 0) return Mult(Pow(x, K / 6), q, p, iq, Pow(y, K / 6 - 1));\n\t\tif (K % 6 == 1) return Mult(Pow(x, K / 6), q, Pow(y, K / 6));\n\t\tif (K % 6 == 2) return Mult(Pow(x, K / 6), q, ip, Pow(y, K / 6));\n\t\tif (K % 6 == 3) return Mult(Pow(x, K / 6), q, ip, iq, Pow(y, K / 6));\n\t\tif (K % 6 == 4) return Mult(Pow(x, K / 6 + 1), iq, Pow(y, K / 6));\n\t\telse return Mult(Pow(x, K / 6 + 1), p, iq, Pow(y, K / 6));\n\t}\n\tint[] Pow(int[] a, int b)\n\t{\n\t\tvar p = MakeArray(N, i => i);\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = Mult(p, x);\n\t\t\tb >>= 1;\n\t\t\tx = Mult(x, x);\n\t\t}\n\t\treturn p;\n\t}\n\tint[] Inv(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tint[] Mult(params int[][] a)\n\t{\n\t\tif (a.Length == 0) return MakeArray(N, i => i);\n\t\tvar x = a[0];\n\t\tfor (var i = 1; i < a.Length; i++) x = Mult(x, a[i]);\n\t\treturn x;\n\t}\n\tint[] Mult(int[] a, int[] b)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[i] = a[b[i]];\n\t\treturn c;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n\tstatic int F => int.Parse(Str);\n\tstatic long FL => long.Parse(Str);\n\tstatic int[] G => Strs.Select(int.Parse).ToArray();\n\tstatic decimal[] GD => Strs.Select(decimal.Parse).ToArray();\n\tstatic long[] GL => Strs.Select(long.Parse).ToArray();\n\tstatic string Str => ReadLine();\n\tstatic string[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n\tstatic T[] ConstantArray<T>(int n, T val) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = val; return a; }\n\tstatic T[] MakeArray<T>(int n, Func<int, T> f) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = f(i); return a; }\n\tconst int MOD = 1000000007;\n\tpublic K()\n\t{\n\t\tSetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n\t\tSolve();\n\t\tOut.Flush();\n\t}\n\tstatic int N;\n\tvoid Solve()\n\t{\n\t\tvar I = G;\n\t\tN = I[0];\n\t\tWriteLine(ToString(Calc(Get(), Get(), I[1] - 1)));\n\t}\n\tstatic int[] Get() => G.Select(i => i - 1).ToArray();\n\tstatic string ToString(int[] p) => string.Join(\" \", p.Select(i => i + 1));\n\tstatic int[] Calc(int[] p, int[] q, int K)\n\t{\n\t\t// if (K == 0) return p;\n\t\t// if (K == 1) return q;\n\t\t// if (K < 6) return Calc(q, Mult(q, Inv(p)), K - 1);\n\t\tint[] ip = Inv(p), iq = Inv(q), x = Mult(q, ip, iq, p), y = Mult(ip, q, p, iq);\n\t\tswitch (K % 6)\n\t\t{\n\t\t\tcase 0: return Mult(Pow(x, K / 6), q, p, iq, Pow(y, K / 6 - 1));\n\t\t\tcase 1: return Mult(Pow(x, K / 6), q, Pow(y, K / 6));\n\t\t\tcase 2: return Mult(Pow(x, K / 6), q, ip, Pow(y, K / 6));\n\t\t\tcase 3: return Mult(Pow(x, K / 6), q, ip, iq, Pow(y, K / 6));\n\t\t\tcase 4: return Mult(Pow(x, K / 6 + 1), iq, Pow(y, K / 6));\n\t\t\tdefault: return Mult(Pow(x, K / 6 + 1), p, iq, Pow(y, K / 6));\n\t\t}\n\t}\n\tstatic int[] Inv(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tstatic int[] Mult(int[] a, int[] b)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[i] = a[b[i]];\n\t\treturn c;\n\t}\n\tstatic int[] Mult(params int[][] a)\n\t{\n\t\tif (a.Length == 0) return MakeArray(N, i => i);\n\t\tvar x = a[0];\n\t\tfor (var i = 1; i < a.Length; i++) x = Mult(x, a[i]);\n\t\treturn x;\n\t}\n\tstatic int[] Pow(int[] a, int b)\n\t{\n\t\tvar p = new int[N];\n\t\tvar done = new bool[N];\n\t\tfor (var i = 0; i < N; i++)\n\t\t\tif (!done[i])\n\t\t\t{\n\t\t\t\tdone[i] = true;\n\t\t\t\tvar cycle = new List<int> { i };\n\t\t\t\tvar x = a[i];\n\t\t\t\twhile (x != i) { cycle.Add(x); done[x] = true; x = a[x]; }\n\t\t\t\tvar L = cycle.Count;\n\t\t\t\tvar c = b % L;\n\t\t\t\tfor (var j = 0; j < L; j++) p[cycle[j]] = cycle[(j + c) % L];\n\t\t\t}\n\t\treturn p;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n\tstatic int[] G => ReadLine().Split().Select(i => int.Parse(i) - 1).ToArray();\n\tstatic T[] MakeArray<T>(int n, Func<int, T> f) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = f(i); return a; }\n\tstatic int N;\n\tpublic K()\n\t{\n\t\tvar I = G;\n\t\tN = I[0] + 1;\n\t\tWriteLine(ToString(Calc(G, G, I[1])));\n\t}\n\tstatic string ToString(int[] p) => string.Join(\" \", p.Select(i => i + 1));\n\tstatic int[] Calc(int[] p, int[] q, int K)\n\t{\n\t\tint[] P = Inv(p), Q = Inv(q), x = Pow(Mult(q, P, Q, p), K / 6), y = Inv(x);\n\t\tswitch (K % 6)\n\t\t{\n\t\t\tcase 0: return Mult(x, p, y);\n\t\t\tcase 1: return Mult(x, q, y);\n\t\t\tcase 2: return Mult(x, q, P, y);\n\t\t\tcase 3: return Mult(x, q, P, Q, y);\n\t\t\tcase 4: return Mult(x, q, P, Q, p, Q, y);\n\t\t\tdefault: return Mult(x, q, P, Q, p, p, Q, y);\n\t\t}\n\t}\n\tstatic int[] Inv(int[] a)\n\t{\n\t\tvar c = new int[N];\n\t\tfor (var i = 0; i < N; i++) c[a[i]] = i;\n\t\treturn c;\n\t}\n\tstatic int[] Mult(int[] a, int[] b) => MakeArray(N, i => a[b[i]]);\n\tstatic int[] Mult(params int[][] a) => a.Aggregate(Mult);\n\tstatic int[] Pow(int[] a, int b)\n\t{\n\t\tif (b < 0) return Inv(Pow(a, -b));\n\t\tvar p = new int[N];\n\t\tvar f = new bool[N];\n\t\tfor (var i = 0; i < N; i++)\n\t\t\tif (!f[i])\n\t\t\t{\n\t\t\t\tvar l = new List<int>();\n\t\t\t\tvar x = i;\n\t\t\t\twhile (!f[x]) { l.Add(x); f[x] = true; x = a[x]; }\n\t\t\t\tvar C = l.Count;\n\t\t\t\tfor (var j = 0; j < C; j++) p[l[j]] = l[(j + b) % C];\n\t\t\t}\n\t\treturn p;\n\t}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "#coding: euc-jp\nclass Main\n  def self.main\n    n, k = read\n    p = read\n    q = read\n    r = [p, q]\n    (k-2).times do |i1|\n      p1 = i1 % 2; p2 = 1 - p1\n      #p r\n      nextp = n.times.map{|i2| r[p2][ r[p1].index(i2 + 1) ]}\n      r[p1] = Marshal.load(Marshal.dump(nextp))\n      if p == r[p2] && q == r[p1] then\n        i = ((k / (i1+1)).floor * (i1+1))\n        if i % 2 == 1 then\n          p1, p2 = p2, p1\n        end\n        i1 = i - 1\n      end\n    end\n    n.times do |i|\n      print r[(k-1) % 2][i].to_s + ((i != n-1) ? ' ' : '')\n    end\n  end\n\n  def self.read\n    gets.chomp.split.map(&:to_i)\n  end\nend\n\nMain.main\n"
  },
  {
    "language": "Ruby",
    "code": "n,k = gets.split.map(&:to_i)\np = [nil] + gets.split.map(&:to_i)\nq = [nil] + gets.split.map(&:to_i)\ndef f(p, q)\n  a = []\n  1.upto(p.size-1) do |i|\n    a[p[i]] = q[i]\n  end\n  a\nend\na = []\nh = {}\nrh = {}\ncount = 0\n(k-2).times do\n  a = f(p, q)\n  count += 1\n  break if h[a]\n  p = q\n  q = a\n  h[a] = count\n  rh[count-1] = a\nend\nif count == (k-2)\n  puts a[1..-1].join(' ')\nelse\n  puts rh[(k % [(count-1), 1].max) - 3][1..-1].join(' ')\nend\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nint N, K;\nint[] P, Q;\n\nint[] inv(in int[] a) {\n  int[] b = new int[N];\n  foreach (i; 0 .. N) {\n    b[a[i]] = i;\n  }\n  return b;\n}\n\nint[] mul(in int[] a, in int[] b) {\n  int[] c = new int[N];\n  foreach (i; 0 .. N) {\n    c[i] = a[b[i]];\n  }\n  return c;\n}\n\nint[] power(in int[] a, int e) {\n  int[] b = a.dup;\n  int[] c = new int[N];\n  foreach (i; 0 .. N) {\n    c[i] = i;\n  }\n  for (; e; e >>= 1) {\n    if (e & 1) {\n      c = c.mul(b);\n    }\n    b = b.mul(b);\n  }\n  return c;\n}\n\nvoid main() {\n  try {\n    for (; ; ) {\n      N = readInt();\n      K = readInt();\n      P = new int[N];\n      foreach (i; 0 .. N) {\n        P[i] = readInt() - 1;\n      }\n      Q = new int[N];\n      foreach (i; 0 .. N) {\n        Q[i] = readInt() - 1;\n      }\n      \n      int[] ans;\n      if (K == 1) {\n        ans = P;\n      } else if (K == 2) {\n        ans = Q;\n      } else {\n        const x = (K + 1) * 2 / 3;\n        const y = (K - 3) * 2 / 3;\n        debug {\n          writefln(\"x = %s, y = %s\", x, y);\n        }\n        int[] invP = P.inv;\n        int[] invQ = Q.inv;\n        int[] R = Q.mul(invP).mul(invQ).mul(P);\n        int[] a = R.power(x / 4);\n        foreach (i; 0 .. x % 4) {\n          a = a.mul([Q, invP, invQ, P][i]);\n        }\n        int[] b = R.power(y / 4);\n        foreach (i; 0 .. y % 4) {\n          b = b.mul([Q, invP, invQ, P][i]);\n        }\n        ans = a.mul(b.inv);\n      }\n      foreach (i; 0 .. N) {\n        if (i > 0) {\n          write(\" \");\n        }\n        write(ans[i] + 1);\n      }\n      writeln();\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef complex<long double> cd;\n\nconst int maxn = 2e5 + 5;\n\nint p[maxn], q[maxn], rp[maxn], rq[maxn];\nint n;\nint rA[maxn], A[maxn], B[maxn];\n\nvoid power(int b){\n\tif (b == 0)\n\t\treturn;\n\tpower(b / 2);\n\tfor (int i = 1; i <= n; i++)\n\t\tB[i] = A[A[i]];\n\tfor (int i = 1; i <= n; i++)\n\t\tA[i] = B[i];\n\tif (b & 1){\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = A[q[rp[rq[p[i]]]]];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = B[i];\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint k;\n\tcin >> n >> k;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> p[i];\n\t\trp[p[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> q[i];\n\t\trq[q[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tA[i] = i;\n\tpower((k - 1) / 6);\n\tif (k % 6 == 4){\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = A[q[i]];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = B[i];\n\t}\n\tif (k % 6 == 5 or k % 6 == 0){\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = A[q[rp[i]]];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = B[i];\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\trA[A[i]] = i;\n\tk %= 6;\n\tif (k == 1)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = p[i];\n\telse if (k == 2)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = q[i];\n\telse if (k == 3)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = q[rp[i]];\n\telse if (k == 4)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = rp[i];\n\telse if (k == 5)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = rq[i];\n\telse\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tB[i] = rq[p[i]];\n\tfor (int i = 1; i <= n; i++)\n\t\tcout << A[B[rA[i]]] << \" \";\n\tcout << endl;\n}\n"
  },
  {
    "language": "Nim",
    "code": "import lists, sequtils, strutils, algorithm, math, future\n\nlet unko = stdin.readLine.split.map(parseInt)\nlet N = unko[0]\nlet K = unko[1]\n\nvar p = stdin.readLine.split.map(parseInt).map(proc (x:int): int = x-1)\nvar q = stdin.readLine.split.map(parseInt).map(proc (x:int): int = x-1)\n#echo \"p: \", p\n#echo \"q: \", q\n\nproc gousei_chikan(g: seq[int], f: seq[int]):seq[int] =\n  var h = newSeq[int](N)\n  for i in 0..<N:\n    h[i] = g[f[i]]\n  return h\n\nproc gyaku_chikan(f: seq[int]):seq[int] =\n  var g = newSeq[int](N)\n  for i in 0..<N:\n    g[f[i]] = i\n  return g\n\nproc id_chikan():seq[int] =\n  var f = newSeq[int](N)\n  for i in 0..<N:\n    f[i] = i\n  return f\n\nproc beki_chikan(f:seq[int], n:int):seq[int] =\n  if n == 0:\n    return id_chikan()\n\n  var kl = int(log2(float(n)))+1\n  var g_k = newSeqWith(kl, newSeq[int](N)) # g_k[k] = f^(2^k)\n  for k in 0..<kl:\n    if k==0:\n      g_k[k] = f\n    else:\n      g_k[k] = gousei_chikan(g_k[k-1], g_k[k-1])\n\n  var re = id_chikan()\n  var funi = 0\n  for k in 0..<kl:\n    if ((n shr k) and 1) == 1:\n      re = gousei_chikan(re,g_k[k])\n      funi += 1 shl k\n  #echo \"funi: \", funi\n  return re\n\n\nvar d = (K-1) div 6\nvar e = (K-1) mod 6 + 1 #K=6*d+e\n#echo \"d: \", d\n#echo \"e: \", e\n\nvar invP = gyaku_chikan(p)\nvar invQ = gyaku_chikan(q)\n#echo \"invP: \", invP\n#echo \"invQ: \", invQ\n\nvar temp = gousei_chikan(gousei_chikan(gousei_chikan(q,invP),invQ),p)\nvar A = beki_chikan(temp, d)\nvar invA = gyaku_chikan(A)\n#echo \"A: \", A\n\nvar B: seq[int]\nif e==1:\n  B = p\nelif e==2:\n  B = q\nelif e==3:\n  B = gousei_chikan(q, invP)\nelif e==4:\n  B = gousei_chikan(gousei_chikan(q,invP),invQ)\nelif e==5:\n  B = gousei_chikan(gousei_chikan(gousei_chikan(gousei_chikan(q,invP),invQ),p),invQ)\nelif e==6:\n  B = gousei_chikan(gousei_chikan(gousei_chikan(gousei_chikan(gousei_chikan(q,invP),invQ),p),p),invQ)\n#echo \"B: \", B\n\nvar re = gousei_chikan(gousei_chikan(A,B),invA)\n\n#echo \"re: \", re\nfor x in re.map(proc (x:int): int = x+1):\n  stdout.write x, \" \""
  },
  {
    "language": "Python",
    "code": "n,k = map(int,input().split())\np,q = list(map(int,input().split()))\n\ndef prog(k):\n    if(k==1):\n        return p\n    elif(k==2):\n        return q\n    else:\n        r=[0]*n\n        for i in range(1,n+1)\n            r[prog(k-2)[i]]=prog(k-1)[i]\n        return r\n\n''.join(prog(k))    \n"
  },
  {
    "language": "Python",
    "code": "N,K=map(int,input().split());p=[int(i)-1for i in input().split()];q=[int(i)-1for i in input().split()];T=lambda s,t:[s[t[i]]for i in range(N)];m=[[0for i in[0]*N]for i in[0]*6];m[0]=p;m[1]=q\ndef I(s):\n r=[0]*N\n for i in range(N):r[s[i]]=i\n return r\nfor i in range(4):m[i+2]=T(m[i+1],I(m[i]))\nE=lambda s,k:T(E(T(s,s),k//2),s)if k%2 else (E(T(s,s),k//2)if k else list(range(N)));t=E(T(T(T(q,I(p)),I(q)),p),~-K//6);print(*[str(i+1)for i in T(T(t,m[~-K%6]),I(t))])"
  },
  {
    "language": "Python",
    "code": "def f(p, q):\n    list1 = [0 for k in range(len(p))]\n    for i in range(len(p)):\n        list1[p[i]-1] = q[i]\n    return list1\n\nn, k = map(int, input().split())\n\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\na = p\nb = q\nfor i in range(k-2):\n    temp = b\n    b = f(a,b)\n    a = temp\n\nprint(b)\n"
  },
  {
    "language": "Python",
    "code": "n,k = map(int,input().split())\np,q = list(map(int,input().split()))\n\ndef prog(k):\n    if(k==1):\n        return p\n    elif(k==2):\n        return q\n    else:\n        r=[0]*n\n        for i in range(3,n+1)\n            r[prog(k-2)[i]]=prog(k-1)[i]\n        return r\n\n''.join(prog(k))    \n"
  },
  {
    "language": "Python",
    "code": "N, K = list(map(int,input().split()))\np = input().split()\nq = input().split()\n\na=[p,q]\n\nmemo = {}\n\ndef perm(p,q):\n    pq = ','.join(p) + ',' + ','.join(q)\n    if pq in memo:\n        return memo[pq]\n    else:\n        ans = [0] * len(p)\n        for i in range(len(p)):\n            ans[int(p[i])-1] = q[i]\n        memo[pq] = ans\n        return ans\n\nif K>=3:\n    for k in range(2,K):\n        a.append(perm(a[k-2],a[k-1]))\n\nprint(a[-1])\n"
  },
  {
    "language": "Python",
    "code": "#D\nn, k = map(int, input().split())\nbefore = input().split()\nafter = input().split()\nif k == 1:\n    result = before\nelif k == 2:\n    result = after\nelse:\n    for x in range(k - 2):\n        sort_dict = {k: v for k, v in zip(before, after)}\n        sorted_items = sorted(sort_dict.items())\n        next_seq = [v[1] for v in sorted_items]\n        before = after\n        after = next_seq\n    result = next_seq\n\nprint(' '.join(result))"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nn, k = (int(i) for i in input().split())\np = np.array([int(i) for i in input().split()])\nq = np.array([int(i) for i in input().split()])\n\ndef f(p, q):\n    return q[np.argsort(p)]\n\na_kk = q\na_k = f(p, q)\nfor i in range(4, k+1):\n    a_kkk = a_kk\n    a_kk = a_k\n    a_k = f(a_kkk, a_kk)\n\nprint(' '.join(a_k.astype(str)))"
  },
  {
    "language": "Python",
    "code": "from operator import itemgetter\n\n\ndef get_identity():\n    return list(range(1, n + 1))\n\n\ndef composition(ppp, qqq):\n    return [ppp[q - 1] for q in qqq]\n\n\ndef reverse_composition(ppp, qqq):\n    return [ppp[i] for i, q in sorted(enumerate(qqq), key=itemgetter(1))]\n\n\ndef solve(k, ppp, qqq):\n    qp = reverse_composition(qqq, ppp)\n    qpq = reverse_composition(qp, qqq)\n    qpqp = composition(qpq, ppp)\n   \n    l, m = divmod(k - 1, 6)\n    res = get_identity()\n    tmp = qpqp\n    while l:\n        if l % 2 == 1:\n            res = composition(res, tmp)\n        tmp = composition(tmp, tmp)\n        l >>= 1\n\n    m = (k - 1) % 6\n    if m == 0:\n        base = ppp\n    elif m == 1:\n        base = qqq\n    elif m == 2:\n        base = reverse_composition(qqq, ppp)\n    elif m == 3:\n        res = composition(res, qqq)\n        base = reverse_composition(get_identity(), ppp)\n    elif m == 4:\n        res = composition(res, qqq)\n        res = reverse_composition(res, ppp)\n        base = reverse_composition(get_identity(), qqq)\n    elif m == 5:\n        res = composition(res, qqq)\n        res = reverse_composition(res, ppp)\n        base = reverse_composition(get_identity(), qqq)\n        base = composition(base, ppp)\n    else:\n        raise NotImplementedError\n\n    ans = composition(res, base)\n    ans = reverse_composition(ans, res)\n    return ans\n\n\nn, k = map(int, input().split())\nppp = list(map(int, input().split()))\nqqq = list(map(int, input().split()))\nprint(*solve(k, ppp, qqq))\n"
  },
  {
    "language": "Python",
    "code": "N,K=map(int,input().split());p=[int(i)-1 for i in input().split()];q=[int(i)-1 for i in input().split()]\ndef I(s):\n r=[0]*N\n for i in range(N):r[s[i]]=i\n return r\ndef T(s,t):return [s[t[i]] for i in range(N)]\nm=[[0 for i in [0]*N] for i in [0]*6]\nfor i in range(N):m[0][i]=p[i];m[1][i]=q[i]\nfor i in range(4):m[i+2]=T(m[i+1],I(m[i]))\ndef E(s,k):\n if k%2==0:\n  return E(T(s,s),k//2) if k!=0 else list(range(N))\n else:\n  return T(E(T(s,s),k//2),s)\nt=E(T(T(T(q,I(p)),I(q)),p),~-K//6);print(\" \".join([str(i+1) for i in T(T(t,m[~-K%6]),I(t))]))"
  },
  {
    "language": "Python",
    "code": "n,k = map(int,input().split())\n\np = list(map(int,input().split()))\nq = list(map(int,input().split()))\n\ndef perprod(x,y): #xy\n    nn = len(x)\n    ret = [0 for i in range(nn)]\n\n    for i in range(nn):\n        ret[i] = x[y[i]-1]\n\n    return ret\n\ndef perinv(x): #inverse\n    nn = len(x)\n    ret = [0 for i in range(nn)]\n    for i in range(nn):\n        ret[x[i]-1] =i+1\n\n    return ret \n\namari = (k-1) % 6\ne = (k-1) //6\n\na =[[] for i in range(6)]\n\na[0] = p\na[1] = q\na[2] = perprod(a[1],perinv(a[0]))\na[3] = perprod(a[2],perinv(a[1]))\na[4] = perprod(a[3],perinv(a[2]))\na[5] = perprod(a[4],perinv(a[3]))\n\npp = perprod(perprod(a[1],perinv(a[0])),perprod(perinv(a[1]),a[0]))\n\n\nans1 = [i+1 for i in range(n)]\n\nwhile e>0:\n    if(e & 1): ans1 = perprod(ans1,pp)\n    pp = perprod(pp,pp)\n    e >>= 1\n\nans2 = perinv(ans1)\n\nans = perprod(ans1,a[amari])\nans = perprod(ans,ans2)\n\nprint(*ans)"
  },
  {
    "language": "Python",
    "code": "N,K=map(int,input().split())\np=[int(i)-1 for i in input().split()]\nq=[int(i)-1 for i in input().split()]\ndef inv(seq):\n    res=[0 for i in range(N)]\n    for i in range(N):\n        res[seq[i]]=i\n    return res\ndef times(seq1,seq2):\n    res=[0 for i in range(N)]\n    for i in range(N):\n        res[i]=seq1[seq2[i]]\n    return res\nmd=[[0 for i in range(N)] for i in range(6)]\nfor i in range(N):\n    md[0][i]=p[i]\n    md[1][i]=q[i]\nfor i in range(2,6):\n    md[i]=times(md[i-1],inv(md[i-2]))\nA=times(times(q,inv(p)),times(inv(q),p))\nT=(K-1)//6\ndef expseq(seq,k):\n    if k==0:\n        return [i for i in range(N)]\n    elif k==1:\n        return seq\n    elif k%2==0:\n        return expseq(times(seq,seq),k//2)\n    else:\n        return times(expseq(times(seq,seq),k//2),seq)\ntmp=expseq(A,T)\nans=times(times(tmp,md[(K-1)%6]),inv(tmp))\nprint(\" \".join([str(i+1) for i in ans]))\n"
  },
  {
    "language": "Python",
    "code": "N,K=map(int,input().split())\np=[int(i)-1 for i in input().split()]\nq=[int(i)-1 for i in input().split()]\ne=[i for i in range(N)]\ndef cir(x,y):\n    z=[0]*N\n    for i in range(N):\n        z[i]=x[y[i]]\n    return z\ndef inv(x):\n    z=[0]*N\n    for i in range(N):\n        z[x[i]]=i\n    return z\ndef f(x,y):\n    return cir(y,inv(x))\n\ndef double(x,k):\n    a=k\n    t=x\n    num=e\n    while a!=0:\n        if a%2==1:\n            num=cir(num,t)\n        a=a//2\n        t=cir(t,t)\n    return num\nP=inv(p)\nQ=inv(q)\n#print(p,q,P,Q)\nquo=(K-1)//6\nr=K-quo*6-1\nX=cir(q,cir(P,cir(Q,p)))\n#Y=cir(P,cir(q,cir(p,Q)))\n#Z=cir(q,double(Y,quo))\nZ=double(X,quo)\nA=cir(Z,cir(p,inv(Z)))\nB=cir(Z,cir(q,inv(Z)))\n#print(A,B,quo,r)\ndef g(n):\n    if n==0:\n        return A\n    if n==1:\n        return B\n    return f(g(n-2),g(n-1))\nL=g(r)\nfor i in range(N):\n    L[i]+=1\nprint(' '.join(map(str,L)))\n"
  },
  {
    "language": "Python",
    "code": "#D問題\nN,K=map(int,input().split())\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\np=[0]*N\nfor i in range(N):\n    r[p[i]]=q[i]\nif N%2==0:\n    if N%4==0:\n        for i in range(N):\n            print(p[i],end=\"\")\n    else:\n        for i in range(N):\n            print(r[i],end=\"\")\nelse:\n    if N%4==1:\n        for i in range(N):\n            print(r[i],end=\"\")\n    else:\n        for i in range(N):\n            print(q[i],end=\"\")\n"
  },
  {
    "language": "Python",
    "code": "N,K=map(int,input().split());p=[int(i)-1 for i in input().split()];q=[int(i)-1 for i in input().split()]\ndef I(s):\n r=[0 for i in range(N)]\n for i in range(N):r[s[i]]=i\n return r\ndef T(s,t):\n r=[0 for i in range(N)]\n for i in range(N):r[i]=s[t[i]]\n return r\nm=[[0 for i in range(N)] for i in range(6)];A=T(T(T(q,I(p)),I(q)),p);X=(K-1)//6\nfor i in range(N):m[0][i]=p[i];m[1][i]=q[i]\nfor i in range(2,6):m[i]=T(m[i-1],I(m[i-2]))\ndef E(s,k):\n if k==0:\n  return [i for i in range(N)]\n elif k==1:\n  return s\n elif k%2==0:\n  return E(T(s,s),k//2)\n else:\n  return T(E(T(s,s),k//2),s)\nt=E(A,X);a=T(T(t,m[(K-1)%6]),I(t));print(\" \".join([str(i+1) for i in a]))"
  },
  {
    "language": "Python",
    "code": "l = raw_input().split()\nN = int(l[0])\nK = int(l[1])\nP = [int(p) for p in raw_input().split()]\nQ = [int(q) for q in raw_input().split()]\n\n# print(N, K, P, Q)\n\ndef compose(P, Q):\n    ret = [0]*len(P)\n    for i in range(len(P)):\n        ret[P[i] - 1] = Q[i]\n    return ret\n\na = P\nb = Q\norder = 0\n\nwhile True:\n    # print(a, b)\n    c = compose(a, b)\n    a,b = b,c\n    order += 1\n    if a == P and b == Q:\n #       print(a, b)\n        break\n\n# print(order)\n#print(P, Q)\nremains = K % order\n\nfor i in range(remains - 2):\n    # print(i, a, b)\n    c = compose(a, b)\n    a,b = b,c\n\nans = \"\"\nfor i in range(len(b)):\n    ans += str(b[i])\n    if i < len(b):\n        ans += \" \"\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N,K=map(int,input().split());p=[int(i)-1for i in input().split()];q=[int(i)-1for i in input().split()];T=lambda s,t:[s[t[i]]for i in range(N)];m=[[0for i in[0]*N]for i in[0]*6];m[0]=p;m[1]=q\ndef I(s):\n r=[0]*N\n for i in range(N):r[s[i]]=i\n return r\nfor i in range(4):m[i+2]=T(m[i+1],I(m[i]))\nE=lambda s,k:T(E(T(s,s),k//2),s)if k%2 else (E(T(s,s),k//2)if k else list(range(N)));t=E(T(T(T(q,I(p)),I(q)),p),~-K//6);print(\" \".join([str(i+1)for i in T(T(t,m[~-K%6]),I(t))]))"
  },
  {
    "language": "Python",
    "code": "N, K = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\ndef f(p, q):\n    a = [None for _ in range(len(p))]\n    for idx, e_p in enumerate(p):\n        a[e_p-1] = q[idx]\n    return a\n\nclass A():\n    def __init__(self, K, p, q):\n        self.a = [None for _ in range(K)]\n        self.a[0] = p\n        self.a[1] = q\n\n    def get_an(self, n):\n        if self.a[n] is None:\n            self.a[n] = f(self.get_an(n-2), self.get_an(n-1))\n        return self.a[n]\n\na = A(K, p, q)\nans = a.get_an(K-1)\nprint(\" \".join(map(str, ans)))\n"
  },
  {
    "language": "Python",
    "code": "n, k = map(int, input().split())\nppp = list(map(int, input().split()))\nqqq = list(map(int, input().split()))\nini_p = ppp.copy()\nini_q = qqq.copy()\ni = 0\nfor i in range(k - 2):\n    rrr = [q for p, q in sorted(zip(ppp, qqq))]\n    if rrr == ini_p:\n        break\n    ppp = qqq\n    qqq = rrr\nelse:\n    print(*qqq)\n    exit()\n\nk = k % (i + 2)\nppp = ini_p\nqqq = ini_q\nfor i in range(k - 2):\n    rrr = [q for p, q in sorted(zip(ppp, qqq))]\n    ppp = qqq\n    qqq = rrr\nprint(*qqq)\n"
  },
  {
    "language": "Python",
    "code": "import copy\nimport sys\nN,K=[int(i) for i in input().split(\" \")]\np=[int(i) for i in input().split(\" \")]\nq=[int(i) for i in input().split(\" \")]\n\np_origin=copy.copy(p)\nq_origin=copy.copy(q)\n\ndef f(p,q):\n    retval=[0 for i in range(N)]\n    for _p,_q in zip(p,q):\n        retval[_p-1]=_q\n    return retval\n\nif K==1:\n    print(\" \".join([str(i) for i in p]))\n    sys.exit()\nif K==2:\n    print(\" \".join([str(i) for i in q]))\n    sys.exit()\n\nloop=0\n\nfor i in range(K-2):\n    tmp=f(p,q)\n    p=q\n    q=tmp\n    if p==p_origin and q==q_origin:\n        loop=i+1\n        break\n\nif loop==0:\n    print(\" \".join([str(i) for i in q]))\n\nelse:\n    p=p_origin\n    q=q_origin\n\n\n    for i in range(K%loop-2+loop):\n        tmp=f(p,q)\n        p=q\n        q=tmp\n    print(\" \".join([str(i) for i in q]))\n"
  },
  {
    "language": "Python",
    "code": "#D問題\nN,K=map(int,input().split())\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\nr=[0 for i in range(N)]\nfor i in range(N):\n    r[p[i]-1]=q[i]\nif K%2==0:\n    if K%4==0:\n        for i in range(N):\n            print(p[i],end=\" \")\n    else:\n        for i in range(N):\n            print(r[i],end=\" \")\nelse:\n    if K%4==1:\n        for i in range(N):\n            print(r[i],end=\" \")\n    else:\n        for i in range(N):\n            print(q[i],end=\" \")\n"
  },
  {
    "language": "Python",
    "code": "def func(p, q):\n    c = [0] * len(p)\n    for i, pi in enumerate(p):\n        c[pi - 1] = q[i]\n    return(c)\n\nN, K = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\n#print(\"N={},K={},p={},q={}\".format(N, K, p, q))\n\na = [[0]]\na.append(p)\na.append(q)\nperiod = K + 1\nfor i in range(3, K + 1):\n    a.append(func(a[i - 2], a[i - 1]))\n#    print(\"a[{}] = {}\".format(i, a[i]))\n    if((p == a[i - 1]) & (q == a[i])):\n        period = i - 2\n        break\n\nK = K % period\nif(0 == K):\n    K += period\n\n#print(\"perid = {}, new K = {}\".format(period, K))\n\nprint(\" \".join(map(str, a[K])))\n"
  },
  {
    "language": "Python",
    "code": "def func(p, q):\n    c = [0] * len(p)\n    for i, pi in enumerate(p):\n        c[pi - 1] = q[i]\n    return(c)\n\nN, K = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\n#print(\"N={},K={},p={},q={}\".format(N, K, p, q))\n\na = [[0]]\na.append(p)\na.append(q)\nperiod = K + 1\nfor i in range(3,K + 1):\n    a.append(func(a[i - 2], a[i - 1]))\n#    print(\"a[{}] = {}\".format(i, a[i]))\n    if((p == a[i - 1]) & (q == a[i])):\n        period = i - 2\n        break\n\nK = K % period\n\n#print(\"perid = {}, new K = {}\".format(period, K))\n\nprint(\" \".join(map(str, a[K])))\n"
  },
  {
    "language": "Python",
    "code": "N,K=map(int,input().split())\np=[int(i)-1 for i in input().split()]\nq=[int(i)-1 for i in input().split()]\ndef inv(seq):\n    res=[0 for i in range(N)]\n    for i in range(N):\n        res[seq[i]]=i\n    return seq\ndef times(seq1,seq2):\n    res=[0 for i in range(N)]\n    for i in range(N):\n        res[i]=seq1[seq2[i]]\n    return res\nmd=[[0 for i in range(N)] for i in range(6)]\nfor i in range(N):\n    md[0][i]=p[i]\n    md[1][i]=q[i]\nfor i in range(2,6):\n    md[i]=times(md[i-1],inv(md[i-2]))\nA=times(times(q,inv(p)),times(inv(q),p))\nT=(K-1)//6\ndef expseq(seq,k):\n    if k==0:\n        return [i for i in range(N)]\n    elif k==1:\n        return seq\n    elif k%2==0:\n        return expseq(times(seq,seq),k//2)\n    else:\n        return times(expseq(times(seq,seq),k//2),seq)\ntmp=expseq(A,T)\nans=times(times(tmp,md[(K-1)%6]),inv(tmp))\nprint(\" \".join([str(i+1) for i in ans]))\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\n# 可換なら6回周期。6個計算すると、交換子で共役とったものだとわかる。\n\nN,K = map(int,input().split())\n\nP,Q = [np.array(input().split(), dtype=np.int32) for _ in range(2)]\n\nP -= 1\nQ -= 1\n\ndef inv(a):\n    x = np.empty_like(a)\n    x[a] = np.arange(len(x))\n    return x\n\ndef mult_inv(a,b):\n    # ab^{-1}\n    c = np.empty_like(a)\n    c[b] = a\n    return c\n\ndef mult(a,b):\n    return mult_inv(a,inv(b))\n\ndef power(a,n):\n    if n == 0:\n        return np.arange(len(a))\n    x = power(a,n//2)\n    x = mult(x,x)\n    return mult(a,x) if n&1 else x\n\nA = [P,Q]\nfor _ in range(4):\n    A.append(mult_inv(A[-1],A[-2]))\n\nq,r = divmod(K-1,6)\nQP_Q_P = mult(mult_inv(mult_inv(Q,P),Q),P)\nleft = power(QP_Q_P,q)\nright = inv(left)\nanswer = mult(mult(left, A[r]), right) + 1\n\nprint(' '.join(answer.astype(str)))"
  },
  {
    "language": "Python",
    "code": "N,K=map(int,input().split())\np=[int(i)-1for i in input().split()]\nq=[int(i)-1for i in input().split()]\nT=lambda s,t:[s[t[i]]for i in range(N)]\nm=[[0for i in[0]*N]for i in[0]*6];m[0]=p;m[1]=q\ndef I(s):\n r=[0]*N\n for i in range(N):r[s[i]]=i\n return r\nfor i in range(4):m[i+2]=T(m[i+1],I(m[i]))\nE=lambda s,k:T(E(T(s,s),k//2),s)if k%2 else (E(T(s,s),k//2)if k else list(range(N)))\nt=E(T(T(T(q,I(p)),I(q)),p),~-K//6);print(\" \".join([str(i+1)for i in T(T(t,m[~-K%6]),I(t))]))"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nN, K = map(int, input().split())\np = np.array([int(_) for _ in input().split()])\nq = np.array([int(_) for _ in input().split()])\n\ndef a(k, p, q, N):\n  if k == 1:\n    return p\n  elif k == 2:\n    return q\n  for _ in range(k - 2):\n    p, q = q, q[(p - 2) % N]\n  return q\nprint(' '.join(map(str, a(K, p, q, N))))\n\n"
  },
  {
    "language": "Python",
    "code": "N,K=map(int,input().split());p=[int(i)-1 for i in input().split()];q=[int(i)-1 for i in input().split()];T=lambda s,t:[s[t[i]] for i in range(N)];m=[[0 for i in [0]*N] for i in [0]*6];m[0]=p;m[1]=q\ndef I(s):\n r=[0]*N\n for i in range(N):r[s[i]]=i\n return r\nfor i in range(4):m[i+2]=T(m[i+1],I(m[i]))\nE=lambda s,k:(E(T(s,s),k//2) if k!=0 else list(range(N)))if k%2==0 else T(E(T(s,s),k//2),s);t=E(T(T(T(q,I(p)),I(q)),p),~-K//6);print(\" \".join([str(i+1) for i in T(T(t,m[~-K%6]),I(t))]))"
  },
  {
    "language": "Python",
    "code": "def perpro(q,p):\n    res=[-1]*len(p)\n    for i in range(len(p)):\n        res[i]=q[p[i]]\n    return res\n\ndef inverse(p):\n    res=[-1]*len(p)\n    for i in range(len(p)):\n        res[p[i]]=i\n    return res\n\nN,K=map(int,input().split())\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\n\nide_ele=[i for i in range(N)]\n\nfor i in range(N):\n    p[i]-=1\n    q[i]-=1\n\ninvp=[-1]*N\nfor i in range(N):\n    invp[p[i]]=i\n\ninvq=[-1]*N\nfor i in range(N):\n    invq[q[i]]=i\n\nA=perpro(q,perpro(invp,perpro(invq,p)))\n\nkthA=[A]\nfor i in range(30):\n    kthA.append(perpro(kthA[-1],kthA[-1]))\n\ndef _nthA(n):\n    res=ide_ele\n    for i in range(30):\n        if n>>i&1==1:\n            res=perpro(res,kthA[i])\n    return res\n\ndef ntha(n):\n    qqq=n//4\n    r=n%4\n    if r==0:\n        return _nthA(qqq)\n    elif r==1:\n        return perpro(_nthA(qqq),q)\n    elif r==2:\n        return perpro(_nthA(qqq),perpro(q,invp))\n    else:\n        return perpro(_nthA(qqq),perpro(q,perpro(invp,invq)))\n\nQ=(K-1)//3\nr=(K-1)%3\nans=[]\nif Q==0:\n    if K==1:\n        ans=p\n    elif K==2:\n        ans=q\n    else:\n        ans=perpro(q,invp)\nelse:\n    if Q%2==0:\n        if r==0:\n            mid=p\n            a=ntha(2*Q-1)\n            ans=perpro(a,perpro(mid,inverse(a)))\n        elif r==1:\n            mid=q\n            a=ntha(2*Q)\n            ans=perpro(a,perpro(mid,inverse(a)))\n        else:\n            mid=perpro(q,invp)\n            a=ntha(2*Q)\n            ans=perpro(a,perpro(mid,inverse(a)))\n    else:\n        if r==0:\n            mid=invp\n            a=ntha(2*Q-1)\n            ans=perpro(a,perpro(mid,inverse(a)))\n        elif r==1:\n            mid=invq\n            a=ntha(2*Q)\n            ans=perpro(a,perpro(mid,inverse(a)))\n        else:\n            mid=perpro(invq,p)\n            a=ntha(2*Q)\n            ans=perpro(a,perpro(mid,inverse(a)))\n\nfor i in range(N):\n    ans[i]+=1\n\nprint(*ans)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nl = raw_input().split()\nN = int(l[0])\nK = int(l[1])\nP = [int(p) for p in raw_input().split()]\nQ = [int(q) for q in raw_input().split()]\n\n# print(N, K, P, Q)\n\ndef compose(P, Q):\n    ret = [0]*len(P)\n    for i in range(len(P)):\n        ret[P[i] - 1] = Q[i]\n    return ret\n\na = P\nb = Q\norder = 0\n\nwhile True:\n    # print(a, b)\n    c = compose(a, b)\n    a,b = b,c\n    order += 1\n    if a == P and b == Q:\n #       print(a, b)\n        break\n\nprint(order)\n#print(P, Q)\nremains = K % order\n\nfor i in range(remains - 2):\n    # print(i, a, b)\n    c = compose(a, b)\n    a,b = b,c\n\nans = \"\"\nfor i in range(len(b)):\n    ans += str(b[i])\n    if i < len(b):\n        ans += \" \"\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#D\nimport numpy as np\nn, k = map(int, input().split())\np = input().split()\nq = input().split()\n\ndef permutate(seq, perm):\n    perm_dic = {k:v for k, v in zip(perm, seq)}\n    perm_items = sorted(perm_dic.items())\n    return [v[1] for v in perm_items]\n\ndef fibonacci(k):\n    # k >= 3\n    if k == 1:\n        return 1\n    if k == 2:\n        return 1\n    a = 1\n    b = 1\n    for x in range(k-2):\n        c = a + b\n        a = b\n        b = c\n    return c\n\nif k == 1:\n    result = p\nelif k == 2:\n    result = q\nelse:\n    p_count = fibonacci(k-2)\n    q_count = fibonacci(k-1)\n    p_count = p_count % n\n    q_count = q_count % n\n    temp = q\n    for x in range (p_count):\n        temp = permutate(temp, p)\n    for x in range(q_count):\n        temp = permutate(temp, q)\n    result = temp\n        \n\nprint(' '.join(result))"
  },
  {
    "language": "Python",
    "code": "import sys\nstdin = sys.stdin\n\nsys.setrecursionlimit(10**9)\n\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnn = lambda: list(stdin.readline().split())\nns = lambda: stdin.readline().rstrip()\n\nn,k = na()\npp = na()\nqq = na()\n\ndef f(p,q,h):\n\tif h and p == pp and q == qq:\n\t\treturn [p,q]\n\tpq = [list(e) for e in zip(p, q)]\n\tpq.sort()\n\treturn [p]+f(q,[i[1] for i in pq],True)\n\nppqq = f(pp,qq,False)\nprint(' '.join(map(str,ppqq[k%(len(ppqq)-2)-1])))"
  },
  {
    "language": "Python",
    "code": "N,K=map(int,input().split())\np=[int(i)-1 for i in input().split()]\nq=[int(i)-1 for i in input().split()]\ndef inv(seq):\n    res=[0 for i in range(N)]\n    for i in range(N):\n        res[seq[i]]=i\n    return res\ndef times(seq1,seq2):\n    res=[0 for i in range(N)]\n    for i in range(N):\n        res[i]=seq1[seq2[i]]\n    return res\nmd=[[0 for i in range(N)] for i in range(6)]\nfor i in range(N):\n    md[0][i]=p[i]\n    md[1][i]=q[i]\nfor i in range(2,6):\n    md[i]=times(md[i-1],inv(md[i-2]))\nA=times(times(times(q,inv(p)),inv(q)),p)\nT=(K-1)//6\ndef expseq(seq,k):\n    if k==0:\n        return [i for i in range(N)]\n    elif k==1:\n        return seq\n    elif k%2==0:\n        return expseq(times(seq,seq),k//2)\n    else:\n        return times(expseq(times(seq,seq),k//2),seq)\ntmp=expseq(A,T)\nans=times(times(tmp,md[(K-1)%6]),inv(tmp))\nprint(\" \".join([str(i+1) for i in ans]))\n"
  },
  {
    "language": "Python",
    "code": "#get f\ndef make_f(p,q):\n\tN=len(p)\n\tf=[0 for i in range(N)]\n\tfor i in range(N):\n\t\tf[p[i]-1]=q[i]\n\treturn f\n\n\n\n#input\n\nN,K=input().split(\" \")\nN=int(N)\nK=int(K)\n\np=input().split(\" \")\np=[int(pi)for pi in p]\n\nq=input().split(\" \")\nq=[int(qi)for qi in q]\n\n\nA=[[],p,q]\n\nfor i in range(3,K+1):\n\tA.append(make_f(A[-2],A[-1]))\n\nprint(A[-1])\n\n"
  },
  {
    "language": "Python",
    "code": "#D問題\nN,K=map(int,input().split())\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\np=[0]*N\nfor i in range(N):\n    r[p[i]]=q[i]\nif N%2==0:\n    if N%4==0:\n        for i in range(N):\n          print(p[i],end=\"\")\n    else:\n        for i in range(N):\n          print(r[i],end=\"\")\nelse:\n    if N%4==1:\n        for i in range(N):\n          print(r[i],end=\"\")\n    else:\n        for i in range(N):\n          print(q[i],end=\"\")"
  },
  {
    "language": "Python",
    "code": "n, k = map(int, input().split())\nppp = list(map(int, input().split()))\nqqq = list(map(int, input().split()))\nini_p = ppp[:]\nini_q = qqq[:]\ni = 0\nfor i in range(k - 2):\n    rrr = [q for p, q in sorted(zip(ppp, qqq))]\n    if rrr == ini_p:\n        break\n    ppp = qqq\n    qqq = rrr\nelse:\n    print(*qqq)\n    exit()\n\nk = k % (i + 2)\nppp = ini_p\nqqq = ini_q\nfor i in range(k - 2):\n    rrr = [q for p, q in sorted(zip(ppp, qqq))]\n    ppp = qqq\n    qqq = rrr\nprint(*qqq)\n"
  },
  {
    "language": "Python",
    "code": "from operator import itemgetter\n\n\ndef get_identity():\n    return list(range(1, n + 1))\n\n\ndef composition(ppp, qqq):\n    return [ppp[q - 1] for q in qqq]\n\n\ndef reverse_composition(ppp, qqq):\n    return [ppp[i] for i, q in sorted(enumerate(qqq), key=itemgetter(1))]\n\n\ndef solve(k, ppp, qqq):\n    qp = reverse_composition(qqq, ppp)\n    qpq = reverse_composition(qp, qqq)\n    qpqp = composition(qpq, ppp)\n\n    l, m = divmod(k - 1, 6)\n    res = get_identity()\n    tmp = qpqp\n    while l:\n        if l % 2 == 1:\n            res = composition(res, tmp)\n        tmp = composition(tmp, tmp)\n        l >>= 1\n\n    m = (k - 1) % 6\n    if m == 0:\n        base = ppp\n    elif m == 1:\n        base = qqq\n    elif m == 2:\n        base = reverse_composition(qqq, ppp)\n    elif m == 3:\n        res = composition(res, qqq)\n        base = reverse_composition(get_identity(), ppp)\n    elif m == 4:\n        res = composition(res, qqq)\n        res = reverse_composition(res, ppp)\n        base = reverse_composition(get_identity(), qqq)\n    elif m == 5:\n        res = composition(res, qqq)\n        res = reverse_composition(res, ppp)\n        base = reverse_composition(get_identity(), qqq)\n        base = composition(base, ppp)\n    else:\n        raise NotImplementedError\n\n    ans = composition(res, base)\n    ans = reverse_composition(ans, res)\n    return ans\n\n\nn, k = map(int, input().split())\nppp = list(map(int, input().split()))\nqqq = list(map(int, input().split()))\nprint(*solve(k, ppp, qqq))\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin, stdout\nfrom itertools import repeat\ndef pr(a):\n    a = [x + 1 for x in a]\n    stdout.write(' '.join(map(str, a)))\ndef main():\n    n, k = map(int, stdin.readline().split())\n    p = map(int, stdin.readline().split(), repeat(10, n))\n    q = map(int, stdin.readline().split(), repeat(10, n))\n    p = [x - 1 for x in p]\n    q = [x - 1 for x in q]\n    if k == 1:\n        pr(p)\n        return\n    if k == 2:\n        pr(q)\n        return\n    def inv(a):\n        r = a[:]\n        for i, x in enumerate(a):\n            r[x] = i\n        return r\n    def comp(a, b):\n        return [a[x] for x in b]\n    pinv = inv(p)\n    qinv = inv(q)\n    b = q\n    a = comp(q, pinv)\n    if k == 3:\n        pr(a)\n        return\n    w = [b, a]\n    for i in xrange(4, 8):\n        a, b = comp(a, inv(b)), a\n        if k == i:\n            pr(a)\n            return\n        w.append(a)\n    y = range(n)\n    x = comp(q, comp(pinv, comp(qinv, p)))\n    r = (k - 8) / 6 + 1\n    while r:\n        if r & 1:\n            y = comp(x, y)\n        x = comp(x, x)\n        r >>= 1\n    t = comp(y, comp(w[(k - 8) % 6], inv(y)))\n    pr(t)\nmain()\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn main() {\n    input!{\n        n: usize,\n        k: usize1,\n        p: [usize1; n],\n        q: [usize1; n]\n    }\n    let mut tab: Vec<Vec<usize>> = vec![Vec::new(); 6];\n    tab[0] = p.clone();\n    tab[1] = q.clone();\n    for i in 2..6 {\n        tab[i] = perm_prod(&perm_inv(&tab[i - 2]), &tab[i - 1]);\n    }\n    let a = perm_pow(&perm_prod(&p, &tab[3]), k / 6);\n    let ans = perm_prod(&perm_prod(&perm_inv(&a), &tab[k % 6]), &a);\n    print!(\"{}\", ans[0] + 1);\n    for i in 1..n {\n        print!(\" {}\", ans[i] + 1);\n    }\n    println!(\"\");\n}\n\nfn perm_prod(p: &Vec<usize>, q: &Vec<usize>) -> Vec<usize> {\n    let n = p.len();\n    (0..n).map(|i| q[p[i]]).collect()\n}\n\nfn perm_pow(a: &Vec<usize>, mut p: usize) -> Vec<usize> {\n    let n = a.len();\n    let mut ret: Vec<usize> = (0..n).collect();\n    let mut r = a.clone();\n    while p > 0 {\n        if p % 2 == 0 {\n            r = perm_prod(&r, &r);\n            p /= 2;\n        } else {\n            ret = perm_prod(&ret, &r);\n            p -= 1;\n        }\n    }\n    ret\n}\n\nfn perm_inv(p: &Vec<usize>) -> Vec<usize> {\n    let n = p.len();\n    let mut ret: Vec<usize> = vec![0; n];\n    for i in 0..n {\n        ret[p[i]] = i;\n    }\n    ret\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn main() {\n    // let mut a = vec![0];\n    // let mut b = vec![1];\n\n    // for i in 0..100 {\n    //     println!(\"{}: {:?}\", i, a);\n\n    //     let mut c = b.clone();\n    //     for &x in a.iter().rev() {\n    //         if c.last().cloned() == Some(x) {\n    //             c.pop();\n    //         } else {\n    //             c.push(x ^ 2);\n    //         }\n    //     }\n\n    //     a = b;\n    //     b = c;\n    // }\n    // return;\n\n    input! {\n        n: usize,\n        k: usize1,\n        p: [usize1; n],\n        q: [usize1; n],\n    }\n\n    // 6:  [1, 2, 3, 0, 1, 0, 3]\n    // 7:  [1, 2, 3, 0, 1, 2, 1, 0, 3]\n    // 8:  [1, 2, 3, 0, 1, 2, 2, 1, 0, 3]\n    // 9:  [1, 2, 3, 0, 1, 2, 3, 2, 1, 0, 3]\n    // 10: [1, 2, 3, 0, 1, 2, 3, 0, 3, 2, 1, 0, 3]\n    // 11: [1, 2, 3, 0, 1, 2, 3, 0, 0, 3, 2, 1, 0, 3]\n\n    // 12: [1, 2, 3, 0, 1, 2, 3, 0, 1, 0, 3, 2, 1, 0, 3]\n    // 13: [1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 1, 0, 3, 2, 1, 0, 3]\n    // 14: [1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 2, 1, 0, 3, 2, 1, 0, 3]\n    // 15: [1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 2, 1, 0, 3, 2, 1, 0, 3]\n    // 16: [1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 3, 2, 1, 0, 3, 2, 1, 0, 3]\n    // 17: [1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 0, 3, 2, 1, 0, 3, 2, 1, 0, 3]\n\n    let mut a = vec![vec![0; n]; 4];\n    for i in 0..n {\n        a[0][i] = p[i];\n    }\n    for i in 0..n {\n        a[1][i] = q[i];\n    }\n    a[2] = inv(&a[0]);\n    a[3] = inv(&a[1]);\n\n    let m = if k < 6 {\n        let tbl: &[&[usize]] = &[\n            &[0],\n            &[1],\n            &[1, 2],\n            &[1, 2, 3],\n            &[1, 2, 3, 0, 3],\n            &[1, 2, 3, 0, 0, 3],\n        ];\n\n        let mut m = id(n);\n        for &aix in tbl[k].iter() {\n            m = mulv(&m, &a[aix]);\n        }\n        m\n    } else {\n        let tbl: &[&[usize]] = &[\n            &[1, 0, 3],\n            &[1, 2, 1, 0, 3],\n            &[1, 2, 2, 1, 0, 3],\n            &[1, 2, 3, 2, 1, 0, 3],\n            &[1, 2, 3, 0, 3, 2, 1, 0, 3],\n            &[1, 2, 3, 0, 0, 3, 2, 1, 0, 3],\n        ];\n\n        let t = mulv(&a[1], &mulv(&a[2], &mulv(&a[3], &a[0])));\n        let u = mulv(&a[2], &mulv(&a[1], &mulv(&a[0], &a[3])));\n\n        let mut m = powv(&t, k / 6);\n        for &aix in tbl[k % 6].iter() {\n            m = mulv(&m, &a[aix]);\n        }\n        m = mulv(&m, &powv(&u, k / 6 - 1));\n        m\n    };\n\n    // dbg!(&m);\n\n    for (i, x) in m.into_iter().enumerate() {\n        if i > 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", x + 1);\n    }\n    println!();\n}\n\nfn id(n: usize) -> Vec<usize> {\n    (0..n).collect()\n}\n\nfn mulv(p: &Vec<usize>, q: &Vec<usize>) -> Vec<usize> {\n    let mut v = vec![0; p.len()];\n    for i in 0..p.len() {\n        v[i] = p[q[i]];\n    }\n    v\n}\n\nfn inv(v: &Vec<usize>) -> Vec<usize> {\n    let mut w = vec![0; v.len()];\n    for i in 0..v.len() {\n        w[v[i]] = i;\n    }\n    w\n}\n\nfn powv(v: &Vec<usize>, n: usize) -> Vec<usize> {\n    if n == 0 {\n        return id(v.len());\n    } else if n == 1 {\n        return v.clone();\n    }\n\n    let m = n / 2;\n    let mut w = powv(&mulv(v, v), m);\n    if n % 2 == 1 {\n        w = mulv(&w, v);\n    }\n    w\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ${url}\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nfn next(a: &Vec<usize>, b: &Vec<usize>) -> Vec<usize> {\n    let mut c = a.clone();\n    c.reverse();\n    let al = a.len();\n    for i in 0..al {\n        c[i] ^= 1;\n    }\n\n    let bn = b.len();\n    for i in 0..bn {\n        let n = c.len();\n        if c[n-1] ^ 1 == b[i] {\n            c.pop();\n        } else {\n            c.push(b[i]);\n        }\n    }\n    c\n}\n\nfn combine(a: &Vec<usize>, b: &Vec<usize>) -> Vec<usize> {\n    let n = a.len();\n    let mut c = vec![0; n];\n    for i in 0..n {\n        c[i] = b[a[i]];\n    }\n    c\n}\n\nfn pow(a: &Vec<usize>, mut p: i64) -> Vec<usize> {\n    let n = a.len();\n    let mut aa = a.clone();\n    let mut ret = vec![0; n];\n    for i in 0..n {\n        ret[i] = i;\n    }\n    while p >= 1 {\n        if p & 1 == 1 {\n            ret = combine(&ret, &aa);\n        }\n        aa = combine(&aa, &aa);\n        p >>= 1;\n    }\n    ret\n}\n\nfn inv(a: &Vec<usize>) -> Vec<usize> {\n    let n = a.len();\n    let mut ret = vec![0; n];\n    for i in 0..n {\n        ret[a[i]] = i;\n    }\n    ret\n}\n\nfn wl(a: &Vec<usize>, elements: &Vec<Vec<usize>>) -> Vec<usize> {\n    let n = elements[0].len();\n    let mut ret = vec![0; n];\n    for i in 0..n {\n        ret[i] = i;\n    }\n    for ai in a {\n        ret = combine(&ret, &elements[*ai]);\n    }\n    ret\n}\n\nfn main() {\n    input! {\n        n: usize, k: usize,\n        p: [usize1; n],\n        q: [usize1; n]\n    };\n\n    let ip = inv(&p);\n    let iq = inv(&q);\n\n    let elements = vec![\n        p.clone(),\n        ip.clone(),\n        q.clone(),\n        iq.clone()\n    ];\n\n    let mut w = vec![];\n    w.push(vec![]);\n    w.push(vec![0]);\n    w.push(vec![2]);\n    for i in 3..20 {\n        let z = next(&w[i-2], &w[i-1]);\n        w.push(z.clone());\n    }\n\n    // a: [3, 0, 2, 1] i=8,14..\n    // b: [0, 3, 1, 2] i=5,11,17\n\n    let pa = wl(&vec![3, 0, 2, 1], &elements);\n    let pb = wl(&vec![0, 3, 1, 2], &elements);\n\n    let tbl = vec![\n        vec![3, 0],\n        vec![3, 0, 2],\n        vec![2],\n        vec![1, 2],\n        vec![3, 1, 2],\n        vec![3],\n    ];\n\n    let mut ans = vec![0; n];\n    for i in 0..n {\n        ans[i] = i;\n    }\n    if k <= 10 {\n        let ln = w[k].len();\n        for i in 0..ln {\n            ans = combine(&ans, &elements[w[k][i]]);\n        }\n    } else {\n        let cnt_a = (k-8)/6+1;\n        ans = combine(&ans, &pow(&pa, cnt_a as i64));\n        let md = k % 6;\n        let p = wl(&tbl[md], &elements);\n        ans = combine(&ans, &p);\n        let cnt_b = (k-5)/6+1;\n        ans = combine(&ans, &pow(&pb, cnt_b as i64));\n    }\n    for i in 0..n {\n        ans[i] += 1;\n    }\n    println!(\"{}\", join!(ans, \" \"));\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc031/tasks/agc031_d\n//\n#![allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::fmt::*;\nuse std::io::*;\nuse std::str::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nfn inv(p: &Vec<usize>) -> Vec<usize> {\n    let n = p.len();\n    let mut q = vec![0; n];\n    for i in 0..n {\n        q[p[i]] = i;\n    }\n    return q;\n}\n\nfn mul(p: &Vec<usize>, q: &Vec<usize>) -> Vec<usize> {\n    let n = p.len();\n    let mut r = vec![0; n];\n    for i in 0..n {\n        r[i] = q[p[i]];\n    }\n    return r;\n}\n\nfn pow(p: &Vec<usize>, k: u64) -> Vec<usize> {\n    let n = p.len();\n    let mut r = vec![0; n];\n    for i in 0..n {\n        r[i] = i;\n    }\n    let mut pp = p.clone();\n    let mut k = k;\n    while k >= 1 {\n        if k & 1 == 1 {\n            r = mul(&r, &pp);\n        }\n        pp = mul(&pp, &pp);\n        k >>= 1;\n    }\n    r\n}\n\nfn solve_small(p0: Vec<usize>, q0: Vec<usize>, k: u64) -> Vec<usize> {\n    if k == 1 {\n        return p0;\n    }\n    if k == 2 {\n        return q0;\n    }\n    let mut p = p0;\n    let mut q = q0;\n    for _i in 3..k + 1 {\n        let rev = inv(&p);\n        let neq = mul(&rev, &q);\n        p = q.clone();\n        q = neq;\n    }\n    q\n}\n\nfn solve(p0: Vec<usize>, q0: Vec<usize>, k: u64) -> Vec<usize> {\n    if k <= 20 {\n        return solve_small(p0, q0, k);\n    }\n    let p1 = inv(&p0);\n    let q1 = inv(&q0);\n\n    let prefix = mul(&mul(&mul(&q1, &p0), &q0), &p1);\n    let suffix = mul(&mul(&mul(&p0, &q1), &p1), &q0);\n\n    let prcount = (k - 2) / 6;\n    let sucount = (k + 1) / 6;\n    let center = (k - 2) % 6;\n\n    let p = pow(&prefix, prcount);\n    let s = pow(&suffix, sucount);\n    let c = match center {\n        0 => q0.clone(),\n        1 => mul(&p1, &q0),\n        2 => mul(&mul(&q1, &p1), &q0),\n        3 => q1.clone(),\n        4 => mul(&q1, &p0),\n        5 => mul(&mul(&q1, &p0), &q0),\n        _ => panic!(\"no\"),\n    };\n    mul(&mul(&p, &c), &s)\n}\n\nfn main() {\n    input! {\n        n: usize, k: u64,\n        p: [usize1; n],\n        q: [usize1; n]\n    };\n\n    let ans = solve(p, q, k);\n\n    for i in 0..n {\n        if i >= 1 {\n            print!(\" \");\n        }\n        print!(\"{}\", ans[i] + 1);\n    }\n    println!();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn comp(a: &[usize], b: &[usize]) -> Vec<usize> {\n    let n = a.len();\n    let mut ret = vec![0; n];\n    for i in 0..n {\n        ret[i] = b[a[i]];\n    }\n    ret\n}\n\nfn inv(a: &[usize]) -> Vec<usize> {\n    let n = a.len();\n    let mut ret = vec![0; n];\n    for i in 0..n {\n        ret[a[i]] = i;\n    }\n    ret\n}\n\nfn pow(a: &[usize], mut k: i64) -> Vec<usize> {\n    let mut cur = a.to_vec();\n    let mut sum: Vec<_> = (0..a.len()).collect();\n    while k > 0 {\n        if k % 2 == 1 {\n            sum = comp(&sum, &cur);\n        }\n        cur = comp(&cur, &cur);\n        k /= 2;\n    }\n    sum\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        k: i64,\n        p: [usize1; n],\n        q: [usize1; n],\n    }\n    let k = k - 1;\n    let mut tbl = vec![p, q];\n    for i in 2..6 {\n        let tmp = comp(&inv(&tbl[i - 2]), &tbl[i - 1]);\n        tbl.push(tmp);\n    }\n    let hop = pow(&comp(&tbl[0], &tbl[3]), k / 6);\n    let ans = comp(&comp(&inv(&hop), &tbl[(k % 6) as usize]), &hop);\n    for i in 0..n {\n        puts!(\"{}{}\", ans[i] + 1, if i == n - 1 { \"\\n\" } else { \" \" });\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]