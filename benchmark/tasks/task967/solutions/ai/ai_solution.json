[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nint main() {\n    int N, i, j;\n    scanf(\"%d\", &N);\n    \n    int A[N+1], B[N+1];\n    for (i = 1; i <= N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    for (i = 1; i <= N; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n    \n    if (A[1] != 0 || B[2] != 0) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    \n    int edges = 0;\n    int used[N+1];\n    memset(used, 0, sizeof(used));\n    used[1] = used[2] = 1;\n    \n    for (i = 1; i <= N; i++) {\n        for (j = 1; j <= N; j++) {\n            if (used[j]) continue;\n            \n            if ((A[j] == A[i] + 1) || (B[j] == B[i] + 1)) {\n                used[j] = 1;\n                edges++;\n            }\n        }\n    }\n    \n    for (i = 1; i <= N; i++) {\n        if (!used[i]) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n    }\n    \n    printf(\"%d\\n\", edges);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:30:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100000\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int *A = (int *)malloc((N + 1) * sizeof(int));\n    int *B = (int *)malloc((N + 1) * sizeof(int));\n    \n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n    \n    if (A[1] != 0 || B[2] != 0 || A[2] != B[1]) {\n        printf(\"-1\\n\");\n        free(A);\n        free(B);\n        return 0;\n    }\n    \n    int D = A[2]; // Distance between vertex 1 and 2\n    \n    for (int i = 1; i <= N; i++) {\n        if (abs(A[i] - B[i]) != D) {\n            printf(\"-1\\n\");\n            free(A);\n            free(B);\n            return 0;\n        }\n    }\n    \n    int max_A = 0;\n    for (int i = 1; i <= N; i++) {\n        if (A[i] > max_A) {\n            max_A = A[i];\n        }\n    }\n    \n    int *cnt_A = (int *)calloc((max_A + 1), sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        cnt_A[A[i]]++;\n    }\n    \n    long long edges = 0;\n    for (int d = 1; d <= max_A; d++) {\n        if (cnt_A[d] == 0) {\n            printf(\"-1\\n\");\n            free(A);\n            free(B);\n            free(cnt_A);\n            return 0;\n        }\n        edges += cnt_A[d];\n    }\n    \n    int max_B = 0;\n    for (int i = 1; i <= N; i++) {\n        if (B[i] > max_B) {\n            max_B = B[i];\n        }\n    }\n    \n    int *cnt_B = (int *)calloc((max_B + 1), sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        cnt_B[B[i]]++;\n    }\n    \n    for (int d = 1; d <= max_B; d++) {\n        if (cnt_B[d] == 0) {\n            printf(\"-1\\n\");\n            free(A);\n            free(B);\n            free(cnt_A);\n            free(cnt_B);\n            return 0;\n        }\n    }\n    \n    edges += cnt_B[1] - 1;\n    \n    printf(\"%lld\\n\", edges);\n    \n    free(A);\n    free(B);\n    free(cnt_A);\n    free(cnt_B);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:31:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> A(N), B(N);\n    for (int i = 0; i < N; ++i) cin >> A[i];\n    for (int i = 0; i < N; ++i) cin >> B[i];\n\n    if (A[0] != 0 || B[1] != 0 || A[1] != B[0]) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    int D = A[1];\n    for (int i = 2; i < N; ++i) {\n        if ((A[i] + B[i] < D) || ((A[i] + B[i] - D) % 2 != 0) || (abs(A[i] - B[i]) > D)) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    vector<pair<int, int>> edges;\n    for (int i = 1; i < N; ++i) {\n        if (A[i] == 1) edges.emplace_back(0, i);\n        if (B[i] == 1) edges.emplace_back(1, i);\n    }\n\n    for (int i = 2; i < N; ++i) {\n        if (A[i] + B[i] == D) continue;\n        int k = (A[i] + B[i] - D) / 2;\n        int dist_from_1 = A[i] - k;\n        bool found = false;\n        for (int j = 0; j < N; ++j) {\n            if (A[j] == dist_from_1 && B[j] == (D - dist_from_1)) {\n                edges.emplace_back(j, i);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    cout << edges.size() << endl;\n    for (auto &e : edges) {\n        cout << e.first + 1 << \" \" << e.second + 1 << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:31:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] A = new int[N + 1];\n        int[] B = new int[N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            A[i] = scanner.nextInt();\n        }\n        for (int i = 1; i <= N; i++) {\n            B[i] = scanner.nextInt();\n        }\n        \n        if (A[1] != 0 || B[2] != 0 || A[2] != B[1]) {\n            System.out.println(-1);\n            return;\n        }\n        \n        int D = A[2];\n        for (int i = 3; i <= N; i++) {\n            if ((A[i] + B[i] < D) || (A[i] + B[i] - D) % 2 != 0 || Math.abs(A[i] - B[i]) > D) {\n                System.out.println(-1);\n                return;\n            }\n        }\n        \n        List<String> edges = new ArrayList<>();\n        int maxA = 0;\n        int maxB = 0;\n        int vertexA = 1;\n        int vertexB = 2;\n        \n        for (int i = 3; i <= N; i++) {\n            if (A[i] + B[i] == D) {\n                if (A[i] == 1) {\n                    edges.add(\"1 \" + i);\n                } else if (B[i] == 1) {\n                    edges.add(\"2 \" + i);\n                } else {\n                    System.out.println(-1);\n                    return;\n                }\n            }\n        }\n        \n        for (int i = 3; i <= N; i++) {\n            if (A[i] + B[i] > D) {\n                int x = (A[i] + B[i] - D) / 2;\n                if (x < 0 || A[i] - x < 0 || B[i] - x < 0) {\n                    System.out.println(-1);\n                    return;\n                }\n                boolean found = false;\n                for (int j = 1; j <= N; j++) {\n                    if (i == j) continue;\n                    if (A[j] == A[i] - x && B[j] == B[i] - x) {\n                        edges.add(j + \" \" + i);\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    System.out.println(-1);\n                    return;\n                }\n            }\n        }\n        \n        edges.add(\"1 2\");\n        \n        for (int i = 1; i <= N; i++) {\n            if (A[i] == 1) {\n                edges.add(\"1 \" + i);\n            }\n            if (B[i] == 1) {\n                edges.add(\"2 \" + i);\n            }\n        }\n        \n        Set<String> edgeSet = new HashSet<>(edges);\n        System.out.println(edgeSet.size());\n        for (String edge : edgeSet) {\n            System.out.println(edge);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:31:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GraphDistances {\n    public static int findMinEdges(int N, int[] A, int[] B) {\n        // Check if direct paths are possible\n        for (int i = 1; i <= N; i++) {\n            if (Math.abs(A[i] - B[i]) > 1 || \n                Math.abs(A[i] - B[i]) < 0) {\n                return -1;\n            }\n        }\n\n        // Check distance consistency\n        if (A[1] != 0 || B[2] != 0) {\n            return -1;\n        }\n\n        // Count additional edges needed\n        int additionalEdges = 0;\n        for (int i = 1; i <= N; i++) {\n            if (Math.abs(A[i] - B[i]) == 1) {\n                additionalEdges++;\n            }\n        }\n\n        return additionalEdges;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        int N = 5;\n        int[] A = {0, 0, 1, 2, 3};  // 0-indexed, first element is dummy\n        int[] B = {0, 1, 0, 1, 2};\n        System.out.println(findMinEdges(N, A, B));\n    }\n}",
    "timestamp": "2025-08-05 23:31:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumEdges(int N, vector<int>& A, vector<int>& B) {\n        // Check basic validity conditions\n        if (A[0] != 0 || B[1] != 0) return -1;\n        \n        // Check triangle inequality and consistency\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                // Check triangle inequality for vertex 1\n                if (abs(A[i] - A[j]) > 1 || A[i] + A[j] < abs(A[i] - A[j])) return -1;\n                \n                // Check triangle inequality for vertex 2 \n                if (abs(B[i] - B[j]) > 1 || B[i] + B[j] < abs(B[i] - B[j])) return -1;\n            }\n        }\n        \n        // Find max distances from vertices 1 and 2\n        int max_dist_1 = *max_element(A.begin(), A.end());\n        int max_dist_2 = *max_element(B.begin(), B.end());\n        \n        // Minimum number of edges is the max distance\n        return max(max_dist_1, max_dist_2);\n    }\n};",
    "timestamp": "2025-08-05 23:32:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def graph_existence_and_min_edges(N, A, B):\n    # If distance from vertex 1 to 2 (A[1]) is odd, return -1, because distances will not match \n    if (A[1] % 2) != (B[0] % 2): \n        return -1\n    \n    # Verify the triangle inequality holds and calculate the edges\n    total_edges = 0\n    for i in range(N):\n        if abs(A[i] - B[i]) > A[1]:\n            return -1\n        total_edges += (A[i] + B[i] - A[1]) // 2\n\n    return total_edges - (N - 1)\n\n# Example usage\nN = 4\nA = [0, 1, 1, 2]\nB = [1, 0, 1, 2]\nprint(graph_existence_and_min_edges(N, A, B))",
    "timestamp": "2025-08-13 15:39:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GraphExistence {\n    public static int minEdges(int N, int[] A, int[] B) {\n        if (A[0] != 0 || B[1] != 0)\n            return -1;\n        \n        int minEdges = 0;\n        // Check existence conditions\n        for (int i = 0; i < N; i++) {\n            if (A[i] + B[i] < A[1] || A[i] + B[i] < B[0])\n                return -1;\n            minEdges = Math.max(minEdges, A[i] + B[i]);\n        }\n        // Return the minimum number of edges\n        return minEdges;\n    }\n\n    public static void main(String[] args) {\n        int N = 5;\n        int[] A = {0, 1, 2, 3, 4};\n        int[] B = {1, 0, 1, 2, 3};\n        System.out.println(minEdges(N, A, B));\n    }\n}",
    "timestamp": "2025-08-13 15:39:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXN 1005\n\nint main() {\n    int N;\n    int A[MAXN], B[MAXN];\n    int d[MAXN];\n\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n\n    if (A[1] != 0 || B[2] != 0 || A[2] != B[1]) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    for (int i = 1; i <= N; i++) {\n        int da = A[i];\n        int db = B[i];\n        int dab = abs(A[i] - B[i]);\n        if ((da + db - dab) % 2 != 0) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        d[i] = (da + db - dab) / 2;\n        if (d[i] < 0 || d[i] > A[i] || d[i] > B[i]) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n    }\n\n    int totalEdges = A[2];\n    for (int i = 3; i <= N; i++) {\n        totalEdges += d[i];\n    }\n\n    printf(\"%d\\n\", totalEdges);\n    return 0;\n}",
    "timestamp": "2025-08-13 15:40:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> A(N + 1), B(N + 1);\n    for (int i = 1; i <= N; ++i) cin >> A[i];\n    for (int i = 1; i <= N; ++i) cin >> B[i];\n    \n    if (A[1] != 0 || B[2] != 0) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        if (A[i] + B[i] < A[2] || (A[i] + B[i]) % 2 != A[2] % 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    vector<vector<int>> graph(N + 1, vector<int>());\n    queue<int> q;\n    vector<int> dist1(N + 1, INT_MAX), dist2(N + 1, INT_MAX);\n\n    q.push(1);\n    dist1[1] = 0;\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        for (int i = 1; i <= N; ++i) {\n            if (abs(A[i] - A[curr]) == 1 && dist1[i] == INT_MAX) {\n                dist1[i] = dist1[curr] + 1;\n                q.push(i);\n                graph[curr].push_back(i);\n                graph[i].push_back(curr);\n            }\n        }\n    }\n    \n    q.push(2);\n    dist2[2] = 0;\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        for (int i = 1; i <= N; ++i) {\n            if (abs(B[i] - B[curr]) == 1 && dist2[i] == INT_MAX) {\n                dist2[i] = dist2[curr] + 1;\n                q.push(i);\n            }\n        }\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        if (dist1[i] != A[i] || dist2[i] != B[i]) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    int edgeCount = 0;\n    for (int i = 1; i <= N; ++i) {\n        edgeCount += graph[i].size();\n    }\n\n    cout << edgeCount / 2 << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 15:40:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_graph_problem(N, A, B):\n    # Check if distances to vertex 1 and 2 satisfy triangle inequality\n    for i in range(1, N + 1):\n        if abs(A[i] - B[i]) > 1:\n            return -1\n    \n    # Count the number of vertices with different distances from 1 and 2\n    diff_count = sum(1 for i in range(1, N + 1) if A[i] != B[i])\n    \n    # Minimum number of edges needed to create the graph\n    if diff_count > 2:\n        return -1\n    \n    return N - 1\n\n# Example usage:\n# N = number of vertices\n# A = distances from vertex 1 \n# B = distances from vertex 2\n# A and B are 1-indexed arrays with indices from 1 to N",
    "timestamp": "2025-08-13 15:40:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    B = list(map(int, sys.stdin.readline().split()))\n    \n    # Check for basic conditions\n    if A[0] != 0 or B[1] != 0 or A[1] != B[0]:\n        print(-1)\n        return\n    \n    d = A[1]\n    for i in range(N):\n        if (A[i] + B[i] < d) or (abs(A[i] - B[i]) > d) or ((A[i] + B[i] - d) % 2 != 0):\n            print(-1)\n            return\n    \n    # Check if the graph can exist\n    edges = []\n    # We need to construct the graph with the minimal edges\n    # The minimal edges is N-1 if it's a tree, but we need to verify the distances\n    \n    # The minimal edges is sum_{i} (max_connections) but it's complex, so we proceed differently\n    # We can model the graph as a tree where nodes are arranged in layers based on A and B\n    \n    # The minimal edges is sum_{i} (number of parents for each node)\n    # The parent of node i is a node j with A[j] = A[i] - 1 and B[j] = B[i] - 1 or similar\n    \n    # We will proceed by constructing a tree where for each node, we connect it to a parent in the previous layer\n    \n    # First, collect nodes grouped by (a, b)\n    groups = {}\n    for i in range(N):\n        a = A[i]\n        b = B[i]\n        if (a, b) not in groups:\n            groups[(a, b)] = []\n        groups[(a, b)].append(i)\n    \n    # The root is node 0 (A=0, B=d)\n    # The node 1 is (A=d, B=0)\n    \n    # Check if (0, d) exists (node 0)\n    if (0, d) not in groups:\n        print(-1)\n        return\n    \n    # Check if (d, 0) exists (node 1)\n    if (d, 0) not in groups:\n        print(-1)\n        return\n    \n    # Now, for each (a, b), we need to find possible parents (a-1, b-1), (a-1, b+1), (a+1, b-1)\n    # But since a + b >= d and |a - b| <= d, the valid parents are (a-1, b-1) if a > 0 and b > 0\n    # Or (a-1, b+1) if a > 0 and b + 1 <= (d + a -1) (since b = B[i] must satisfy B[i] <= d + a)\n    # Or (a+1, b-1) if b > 0 and a + 1 <= (d + b -1)\n    \n    # We can model the tree by connecting each node to a parent in the previous layer\n    \n    # We will process nodes in order of a + b (since the minimal a + b is d)\n    \n    sorted_groups = sorted(groups.keys(), key=lambda x: (x[0] + x[1], x[0]))\n    \n    parent_map = {}\n    edge_count = 0\n    \n    # The root is (0, d)\n    root = groups[(0, d)][0]\n    parent_map[root] = -1\n    \n    # The node (d, 0) is node 1\n    node1 = groups[(d, 0)][0]\n    parent_map[node1] = root\n    edge_count += 1\n    \n    # Process other groups\n    for (a, b) in sorted_groups:\n        if a == 0 and b == d:\n            continue\n        if a == d and b == 0:\n            continue\n        \n        # Find possible parents\n        possible_parents = []\n        if (a - 1, b - 1) in groups:\n            possible_parents.append((a - 1, b - 1))\n        if (a - 1, b + 1) in groups:\n            possible_parents.append((a - 1, b + 1))\n        if (a + 1, b - 1) in groups:\n            possible_parents.append((a + 1, b - 1))\n        \n        if not possible_parents:\n            print(-1)\n            return\n        \n        # Choose the first possible parent (for minimal edges, we can choose any)\n        parent_group = possible_parents[0]\n        parent_node = groups[parent_group][0]\n        \n        for node in groups[(a, b)]:\n            if node not in parent_map:\n                parent_map[node] = parent_node\n                edge_count += 1\n    \n    # Verify distances\n    # We can perform BFS from node 0 and node 1 to verify A and B\n    \n    from collections import deque\n    adj = [[] for _ in range(N)]\n    for node in range(N):\n        if parent_map.get(node, -1) != -1:\n            p = parent_map[node]\n            adj[p].append(node)\n            adj[node].append(p)\n    \n    # BFS from node 0 to check A\n    dist_A = [-1] * N\n    q = deque()\n    dist_A[0] = 0\n    q.append(0)\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if dist_A[v] == -1:\n                dist_A[v] = dist_A[u] + 1\n                q.append(v)\n    \n    # BFS from node 1 to check B\n    dist_B = [-1] * N\n    q = deque()\n    dist_B[1] = 0\n    q.append(1)\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if dist_B[v] == -1:\n                dist_B[v] = dist_B[u] + 1\n                q.append(v)\n    \n    for i in range(N):\n        if dist_A[i] != A[i] or dist_B[i] != B[i]:\n            print(-1)\n            return\n    \n    print(edge_count)\n    # Output the edges\n    for node in range(N):\n        if parent_map.get(node, -1) != -1:\n            p = parent_map[node]\n            if p < node:  # To avoid duplicate edges\n                print(p + 1, node + 1)\n\nsolve()",
    "timestamp": "2025-08-13 15:41:01"
  }
]