[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nint a[100001];\nint b[100001];\nvi adj[100001];\nbool par[100001];\nvi aaa[100001];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\taaa[a[i]].pb(i);\n\t\tadj[b[i]].pb(i);\n\t}\n\tif(a[0]!=0||b[1]!=0)\n\t{\n\t\tcout<<-1<<'\\n';\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\tpar[0] = 1;\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\t//must come from last vec\n\t\tmap<int,vi> ma;\n\t\tmap<int,vi> unused;\n\t\tfor(int j = 0; j < adj[i-1].size(); j++)\n\t\t{\n\t\t\t//cerr<<adj[i-1][j]<<'\\n';\n\t\t\tma[a[adj[i-1][j]]].pb(adj[i-1][j]);\n\t\t}\n\t\tfor(int j = 0; j < adj[i-1].size(); j++)\n\t\t{\n\t\t\tif(!par[adj[i-1][j]]) unused[a[adj[i-1][j]]].pb(adj[i-1][j]);\n\t\t}\n\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t{\n\t\t\tint v = adj[i][j];\n\t\t\tint d = a[v];\n\t\t\t//cerr<<v<<' '<<d<<' '<<unused[d+1].size()<<'\\n';\n\t\t\tif(!aaa[d-1].empty())\n\t\t\t{\n\t\t\t\tif(!unused[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tint u = unused[d+1].back();\n\t\t\t\t\tunused[d+1].pop_back();\n\t\t\t\t\tpar[u] = true;\n\t\t\t\t}\n\t\t\t\telse if(!par[v]&&!ma[d-1].empty())\n\t\t\t\t{\n\t\t\t\t\tpar[v] = true;\n\t\t\t\t}\n\t\t\t\telse if(ma[d-1].empty()&&ma[d].empty()&&ma[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tcout<<-1<<'\\n';\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(!par[v]&&!ma[d-1].empty())\n\t\t\t\t{\n\t\t\t\t\tpar[v] = true;\n\t\t\t\t}\n\t\t\t\telse if(!unused[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tint u = unused[d+1].back();\n\t\t\t\t\tunused[d+1].pop_back();\n\t\t\t\t\tpar[u] = true;\n\t\t\t\t}\n\t\t\t\telse if(ma[d-1].empty()&&ma[d].empty()&&ma[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tcout<<-1<<'\\n';\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(!par[i])\n\t\t{\n\t\t\t//cerr<<i<<'\\n';\n\t\t\tif(!aaa[a[i]-1].empty())\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout<<-1<<'\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tassert(ans>=n-1);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\nbool comp (pair<int,int> a, pair<int,int>b){\n    return a.FI+a.SE<b.FI+b.SE or (a.FI+a.SE==b.FI+b.SE and a.FI<b.FI);\n}\nint cnt(multiset<pair<int,int>> &s, int a, int b){\n    return s.count(make_pair(a,b));\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,dmax=0;\n    cin >> n;\n    vector<pair<int,int>> d;\n    multiset<pair<int,int>> s;\n    REP(i,n){\n        int a,b;\n        cin >> a>>b;\n        //dmax=max(dmax,a+b);\n        s.insert(make_pair(a,b));\n        d.push_back(make_pair(a,b));\n    }\n    if(d[0].FI!=0 or d[1].SE!=0 or d[1].FI!=d[0].SE or d[0].SE==0){\n        cout << -1 << endl; return 0;\n    }\n    FOR(i,2,n){\n        if(d[i].FI==0 or d[i].SE==0){\n            cout << -1 << endl; return 0;\n        }\n    }\n    FOR(i,1,d[0].SE){\n        if(cnt(s,i,d[0].SE-i)==0){\n            cout << -1 << endl; return 0;\n        }\n    }\n    //0~1\n    int ans=cnt(s,1,d[0].SE-1)/*+cnt(s,d[0].SE-1,1)*/;\n\n    FOR(i,1,d[0].SE){\n        ans+=max(cnt(s,i,d[0].SE-i),cnt(s,i+1,d[0].SE-i-1));\n    }\n    sort(d.begin(),d.end());\n    d.erase(unique(ALL(d)),d.end());\n    sort(d.begin(),d.end(),comp);\n\n    bool succ=false;\n    for(auto it=lower_bound(ALL(d),make_pair(1,d[0].SE),comp); it<d.end();it++){\n        int d0=it->FI,d1=it->SE;\n        if(succ){\n            ans+=max(cnt(s,d0-1,d1+1),cnt(s,d0,d1));\n            if(cnt(s,d0+1,d1-1)) continue;\n            else if(cnt(s,d0-1,d1-1)or cnt(s,d0,d1-1)){\n                ans+=cnt(s,d0,d1);\n                succ =false;\n            }else {\n                cout << -1 << endl; return 0;\n            }\n        }else if(cnt(s,d0-1,d1-1)){\n            ans+=cnt(s,d0,d1);\n        }else if(cnt(s,d0-1,d1)){\n            ans+=cnt(s,d0,d1);\n            if(cnt(s,d0+1,d1-1)){\n                succ=true;\n                continue;\n            }else if(cnt(s,d0,d1-1)){\n                ans+= cnt(s,d0,d1);\n            }else{\n                cout << -1 << endl; return 0;\n            }\n        }else{\n            cout << -1 << endl; return 0;\n        }\n    }\n\n    cout << ans <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\nbool comp (pair<int,int> a, pair<int,int>b){\n    return a.FI+a.SE<b.FI+b.SE or (a.FI+a.SE==b.FI+b.SE and a.FI<b.FI);\n}\nint cnt(multiset<pair<int,int>> &s, int a, int b){\n    return s.count(make_pair(a,b));\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,dmax=0;\n    cin >> n;\n    vector<pair<int,int>> d;\n    multiset<pair<int,int>> s;\n    REP(i,n){\n        int a,b;\n        cin >> a>>b;\n        //dmax=max(dmax,a+b);\n        s.insert(make_pair(a,b));\n        d.push_back(make_pair(a,b));\n    }\n    if(d[0].FI!=0 or d[1].SE!=0 or d[1].FI!=d[0].SE or d[0].SE==0){\n        cout << -1 << endl; return 0;\n    }\n    FOR(i,2,n){\n        if(d[i].FI==0 or d[i].SE==0){\n            cout << -1 << endl; return 0;\n        }\n    }\n    FOR(i,1,d[0].SE){\n        if(cnt(s,i,d[0].SE-i)==0){\n            cout << -1 << endl; return 0;\n        }\n    }\n    //0~1\n    int ans=cnt(s,1,d[0].SE-1);//+cnt(s,d[0].SE-1,1)\n\n    FOR(i,1,d[0].SE){\n        ans+=max(cnt(s,i,d[0].SE-i),cnt(s,i+1,d[0].SE-i-1));\n    }\n    sort(d.begin(),d.end());\n    d.erase(unique(ALL(d)),d.end());\n    sort(d.begin(),d.end(),comp);\n    bool succ=false;\n    for(auto it=lower_bound(ALL(d),make_pair(1,d[0].SE),comp); it<d.end();it++){\n        int d0=it->FI,d1=it->SE;\n        //DBG(ans)\n        //cout << d0 << ' ' <<d1  <<' '<<succ<<endl;\n        if(succ){\n            ans+=max(cnt(s,d0-1,d1+1),cnt(s,d0,d1));\n            if(cnt(s,d0+1,d1-1)) continue;\n            else if(cnt(s,d0-1,d1-1)or cnt(s,d0,d1-1)){\n                ans+=cnt(s,d0,d1);\n                succ =false;\n            }else {\n                cout << -1 << endl; return 0;\n            }\n        }else if(cnt(s,d0-1,d1-1)){\n            ans+=cnt(s,d0,d1);\n        }else if(cnt(s,d0-1,d1)or cnt(s,d0-1,d1+1)){\n            ans+=cnt(s,d0,d1);\n            if(cnt(s,d0+1,d1-1)){\n                succ=true;\n                continue;\n            }else if(cnt(s,d0,d1-1)){\n                ans+= cnt(s,d0,d1);\n            }else{\n                cout << -1 << endl; return 0;\n            }\n        //}else if(cnt(s,d0-1,d1+1)){\n            //ans+=cnt(s,d0,d1);\n        }else{\n            cout << -1 << endl; return 0;\n        }\n    }\n\n    cout << ans <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nint n;\npair<int,int> a[maxn];\n\nbool check_1(){\n  if(a[1].first!=0||a[2].second!=0||a[2].first!=a[1].second||a[1].second==0)return false;\n  for(int i=3;i<=n;i++)\n    if(a[i].first==0||a[i].second==0||a[i].first+a[i].second<a[1].first+a[1].second)return false;\n  set<pair<int,int>>st;\n  for(int i=1;i<=n;i++)st.insert(a[i]);\n  for(int i=3;i<=n;i++){\n    int cnt=0;\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first-1,a[i].second+j))!=st.end()){\n        cnt++;\n        break;\n      }\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first+j,a[i].second-1))!=st.end()){\n        cnt++;\n        break;\n      }\n      if(cnt<2)return false;\n  }\n  return true;\n}\n\nbool cmp(pair<int,int> a,pair<int,int> b){\n  int ta = a.first + a.second;\n  int tb = b.first + b.second;\n  return ta == tb ? a.first < b.first: ta < tb;\n}\n\nint cal(){\n  int ret=0;\n  sort(a+1,a+n+1,cmp);\n  map<pair<int,int>,int>mp;\n  for(int i=1;i<=n;i++){\n    int pos = i;\n    vector<pair<int,int>>v;\n    v.push_back(a[i]);\n    for(int j = i;j<=n;j++){\n      if(a[j].first + a[j].second!=a[i].first + a[i].second)break;\n      pos = j;\n      if(mp.find(a[j])==mp.end())mp[a[j]]=1;\n      else mp[a[j]]+=1;\n      if(j>i&&a[j]!=a[j-1])v.push_back(a[j]);\n    }\n    int l = 0;\n    for(int j=0;j<v.size();j++){\n      int nl = mp[v[j]];\n      int nr = nl;\n      if(v[j].second==0)nr=0;\n      ret+=min(l,nl);\n      nl-=l;\n      if(nl<0)nl=0;\n      if(mp.find(make_pair(v[j].first-1,v[j].second-1))!=mp.end()){\n        ret+=min(nl,nr);\n        nr -= min(nl,nr);\n      }\n      l = nr;\n      if(l<0)l=0;\n      if(j+1<v.size()&&v[j].first+1<v[j+1].first)l=0;\n      //cout<<j<<\" : \"<<ret<<endl;\n      //cout<<v[j].first<<\",\"<<v[j].second<<endl;\n    }\n    i =pos;\n  }\n  //cout<<ret<<endl;\n  return ret;\n}\n\nint main() {\n   // freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    if(!check_1()){\n      cout<<-1<<endl;\n      return 0;\n    }\n    cout<<2*n-2-cal()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\nconst int inf = 1000000007;\n\nint n;\nstruct P {\n    int x,y,id;\n    P() {}\n    P(int x,int y, int id):x(x),y(y),id(id) {}\n    bool operator<(const P&a)const {\n        return x==a.x?y<a.y:x<a.x;\n    }\n} p[maxn];\n\nint main() {\n   // freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        p[i]=P(x,y,i);\n    }\n    if(p[1].y!=p[2].x||p[1].y>n-1||p[1].x!=0||p[2].y!=0)cout<<-1<<endl;\n    else {\n        if(n==2) {\n            cout<<1<<endl;\n        } else {\n            sort(p+3,p+n);\n            unordered_map<int,int>umap;\n            bool fail = false;\n            for(int i=3; i<=n; i++) {\n                if(p[i].x+p[i].y==p[1].y&&p[i].x&&p[i].y) {\n                    umap[p[i].x] = 1;\n                }\n                if((!p[i].x)||(!p[i].y))fail=true;\n                if(p[i].x>p[i].y+p[1].y||p[i].y>p[i].x+p[1].y)fail=true;\n                if(p[i].x+p[i].y<p[1].y)fail=true;\n            }\n            for(int i=1; i<p[1].y; i++)if(umap.find(i)==umap.end()) {\n                    fail = true;\n                    break;\n                }\n            int ret=0;\n            umap.clear();\n            umap[0]=1;\n            for(int i=3; i<=n; i++) {\n                if(p[i].y==p[i].x+p[1].y) {\n                    if(umap.find(p[i].x-1)==umap.end()) {\n                        fail=true;\n                        break;\n                    } else {\n                        umap[p[i].x]=1;\n                        ret++;\n                    }\n                }\n            }\n            umap.clear();\n            umap[0]=1;\n            for(int i=3; i<=n; i++) {\n                if(p[i].x==p[i].y+p[1].y) {\n                    if(umap.find(p[i].y-1)==umap.end()) {\n                        fail=true;\n                        break;\n                    } else {\n                        umap[p[i].y]=1;\n                        ret++;\n                    }\n                }\n            }\n            umap.clear();\n            for(int i=3; i<=n; i++) {\n                if(p[i].x+p[i].y==p[1].y) {\n                    if(umap.find(p[i].x)==umap.end()) {\n                        umap[p[i].x]=1;\n                    } else umap[p[i].x]++;\n                }\n            }\n            umap[0] = 1;\n            umap[p[1].y]=1;\n            for(int i=0; i<p[1].y; i++) {\n                if(umap.find(i)==umap.end()||umap.find(i+1)==umap.end()) {\n                    fail = true;\n                    break;\n                }\n                ret+=max(umap[i],umap[i+1]);\n            }\n            map<pair<int,int>,int>mp;\n            for(int i=1; i<p[1].y; i++)mp[make_pair(i,p[1].y-i)] = 1;\n            for(int i=3; i<=n; i++) {\n                if(p[i].x+p[i].y==p[1].y)continue;\n                if(p[i].x==p[i].y+p[1].y)continue;\n                if(p[i].y==p[i].x+p[1].y)continue;\n                if(mp[make_pair(p[i].x -1,p[i].y-1)]) {\n                    ret++;\n                    mp[make_pair(p[i].x,p[i].y)]=1;\n                } else {\n                    if(p[i].x+p[i].y==p[1].y+1) {\n                        ret+=2;\n                        mp[make_pair(p[i].x,p[i].y)]=1;\n                    } else {\n                        fail=true;\n                        break;\n                    }\n                }\n            }\n            if(fail)cout<<-1<<endl;\n            else cout<<ret<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 10;\nint ds[2][maxn];\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &ds[0][i], &ds[1][i]);\n  }\n  return 1;\n}\n\nint res;\n\nvoid solve() {\n  if (ds[0][0] || ds[1][1]) {\n    printf(\"-1\\n\");\n    return;\n  }\n  int d = ds[0][1];\n  if (ds[1][0] != d) {\n    printf(\"-1\\n\");\n    return;\n  }\n  vector<int> big(d + 1, 0);\n\n  vector<int> vs[2][d + 1];\n  for (int v = 0; v < n; ++v) {\n    int left = ds[0][v] + ds[1][v] - d;\n    if (left < 0 || abs(ds[0][v] - ds[1][v]) > d) {\n      printf(\"-1\\n\");\n      return;\n    }\n    if (left > 0) {\n      vs[left & 1][(ds[0][v] - ds[1][v] + d) / 2].pb((left + 1) / 2);\n    } else {\n      big[ds[0][v]] += 1;\n    }\n  }\n  res = 0;\n  for (int odd = 0; odd < 2; ++odd) {\n    vector<int> cool;\n    for (int i = 0; i <= d - odd; ++i) {\n      auto &cur = vs[odd][i];\n      sort(cur.begin(), cur.end());\n      int last = 0;\n      for (int i = 0; i < sz(cur);) {\n        int i0 = i;\n        while (i < sz(cur) && cur[i] == cur[i0]) {\n          ++i;\n        }\n        //eprintf(\"%dx  %d\\n\", i - i0, cur[i0]);\n        if (cur[i0] != last + 1) {\n          printf(\"-1\\n\");\n          return;\n        }\n        res += i - i0;\n        if (odd && cur[i0] == 1) {\n          res += i - i0;\n          cool.pb(i - i0);\n        }\n        ++last;\n      }\n      if (sz(cool) == i) {\n        cool.pb(0);\n      }\n    }\n    if (odd) {\n      for (int i = 0; i < sz(cool) - 1; ++i) {\n        int cur = min(cool[i], cool[i + 1]);\n        cool[i + 1] -= cur;\n        res -= cur;\n      }\n    }\n  }\n  if (big[0] != 1 || big[d] != 1) {\n    printf(\"-1\\n\");\n    return;\n  }\n  for (int i = 1; i < d; ++i) {\n    if (big[i] == 0) {\n      printf(\"-1\\n\");\n      return;\n    }\n  }\n  for (int i = 0; i < d; ++i) {\n    res += max(big[i], big[i + 1]);\n  }\n  printf(\"%d\\n\", res);\n}\n\nvoid gen() {\n  int m;\n  while (1) {\n    beg:;\n  n = rnd(5) + 2;\n  m = 0;\n  vector<vector<int> > es(n);\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      if (rnd(4) == 0) {\n        es[i].pb(j), es[j].pb(i);\n        eprintf(\"%d %d\\n\", i, j);\n        ++m;\n      }\n    }\n  }\n\n  for (int i = 0; i < 2; ++i) {\n    auto &dist = ds[i];\n    for (int v = 0; v < n; ++v) {\n      dist[v] = inf;\n    }\n    vector<int> st;\n    st.pb(i);\n    dist[i] = 0;\n    for (int l = 0; l < sz(st); ++l) {\n      int v = st[l];\n      for (int u : es[v]) {\n        if (dist[u] > dist[v] + 1) {\n          st.pb(u);\n          dist[u] = dist[v] + 1;\n        }\n      }\n    }\n    if (sz(st) < n) {\n      goto beg;\n    }\n  }\n  break;\n  }\n  eprintf(\"n = %d\\n\", n);\n  solve();\n  if (res == -1 || res > m) {\n    assert(0);\n  }\n}\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  if (0) {\n  while (1) {\n    gen();\n  }\n  }\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010],C[101010],D[101010];\nmap<pair<int,int>,vector<int>> M;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tM[{A[i],B[i]}].push_back(i);\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(i==0) {\n\t\t\tif(A[i]) return _P(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tC[i]=1;\n\t\t\tif(M.count({A[i]-1,B[i]-1})+M.count({A[i]-1,B[i]})+M.count({A[i]-1,B[i]+1})==0) return _P(\"-1\\n\");\n\t\t}\n\t\tif(i==1) {\n\t\t\tif(B[i]) return _P(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tD[i]=1;\n\t\t\tif(M.count({A[i]-1,B[i]-1})+M.count({A[i],B[i]-1})+M.count({A[i]+1,B[i]-1})==0) return _P(\"-1\\n\");\n\t\t}\n\t}\n\t\n\tint ret=0;\n\tFORR(m,M) {\n\t\tauto a=m.first;\n\t\ta.first--;\n\t\ta.second++;\n\t\tif(M.count(a)) {\n\t\t\tx=min(m.second.size(),M[a].size());\n\t\t\tFOR(i,x) {\n\t\t\t\tret++;\n\t\t\t\tC[m.second[i]]=0;\n\t\t\t\tD[M[a][i]]=0;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,N) {\n\t\tif(C[i]+D[i]==2) {\n\t\t\tif(M.count({A[i]-1,B[i]-1})) ret++;\n\t\t\telse ret+=2;\n\t\t\t\n\t\t}\n\t\telse ret+=C[i]+D[i];\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n;\nint da[125252], db[125252];\nmap<pii,vi> M;\nint st[125252];\n// befa, befb, afta, aftb\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n)scanf(\"%d%d\",da+i,db+i);\n  REP(i,n){\n    int xa = da[i], xb = db[i];\n    M[pii(xa,xb)].push_back(i);\n  }\n  st[0] |= 1;\n  st[1] |= 2;\n  ll ans = 0;\n  for(auto P:M){\n    pii pos = P.first;\n    int xa = pos.first;\n    int xb = pos.second;\n    int pp = P.second.front();\n    if((st[pp]&1)==0){\n      if(M.count(pii(xa-1,xb-1))){\n        ans += P.second.size();\n        for(auto x:P.second){\n          st[x] |= 3;\n        }\n        continue;\n      }else if(M.count(pii(xa-1,xb+1))){\n        pii to = pii(xa-1,xb+1);\n        auto Q = M[to];\n        ans += max(P.second.size(),Q.size());\n        for(auto x:P.second){\n          st[x] |= 1;\n        }\n        for(auto x:Q){\n          st[x] |= 2;\n        }\n      }else if(M.count(pii(xa-1,xb))){\n        ans += P.second.size();\n        for(auto x:P.second){\n          st[x] |= 1;\n        }\n      }\n    }\n    if((st[pp]&2)==0){\n      if(M.count(pii(xa-1,xb-1))){\n        ans += P.second.size();\n        for(auto x:P.second){\n          st[x] |= 3;\n        }\n        continue;\n      }else if(M.count(pii(xa+1,xb-1))){\n        pii to = pii(xa+1,xb-1);\n        auto Q = M[to];\n        ans += max(P.second.size(),Q.size());\n        for(auto x:P.second){\n          st[x] |= 2;\n        }\n        for(auto x:Q){\n          st[x] |= 1;\n        }\n      }else if(M.count(pii(xa,xb-1))){\n        ans += P.second.size();\n        for(auto x:P.second){\n          st[x] |= 2;\n        }\n      }\n    }\n  }\n  REP(i,n){\n    // DEBUG(st[i]);\n    if(st[i]!=3){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010];\nint L;\nint did[101010];\nint ok[101010];\n\nset<pair<int,int>> S;\nvector<pair<int,int>> V[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i]>>B[i];\n\t\n\tif(A[0]!=0) return _P(\"-1\\n\");\n\tif(B[1]!=0) return _P(\"-1\\n\");\n\tif(A[1]!=B[0]) return _P(\"-1\\n\");\n\tL=A[1];\n\tok[0]=ok[L]=1;\n\tdid[0]=did[1]=1;\n\t\n\tS.insert({0,L});\n\tS.insert({L,0});\n\tint ret=1;\n\tfor(i=2;i<N;i++) {\n\t\tif(A[i]==0 || B[i]==0) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<L) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]==L) {\n\t\t\tdid[i]=1;\n\t\t\tif(ok[A[i]]==1) ret++;\n\t\t\tok[A[i]]=1;\n\t\t\tret++;\n\t\t\tS.insert({A[i],B[i]});\n\t\t}\n\t\telse {\n\t\t\tV[A[i]+B[i]].push_back({A[i],i});\n\t\t}\n\t}\n\tFOR(i,L+1) if(ok[i]==0) return _P(\"-1\\n\");\n\tfor(i=L+1;i<=200000;i++) if(V[i].size()) {\n\t\tsort(ALL(V[i]));\n\t\tFOR(j,2) {\n\t\t\tFORR(r,V[i]) {\n\t\t\t\tx = r.second;\n\t\t\t\tif(did[x]) continue;\n\t\t\t\tif(S.count({A[x]-1,B[x]-1})) ret++;\n\t\t\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdid[x]=1;\n\t\t\t\tS.insert({A[x],B[x]});\n\t\t\t}\n\t\t\treverse(ALL(V[i]));\n\t\t}\n\t\t\n\t}\n\t\n\tFOR(i,N) if(did[i]==0) return _P(\"-1\\n\");\n\tassert(0);\n\t_P(\"%d\\n\",ret);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define N 100005\n#define fr first\n#define se second\n#define check(x,y) (mp.find(make_pair(x,y))!=mp.end())\nusing namespace std;\nstruct msg{\n\tint x,y,num;\n};\npii v[N];\nvector<msg> b[N*2];\nmap<pii,int > mp;\nmap<pii,int >::iterator itr;\nint dp[N][2];\nint n,ans,d;\nvoid end(){\n\tputs(\"-1\");\n\texit(0);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&v[i].first,&v[i].se),mp[v[i]]++;\n\td=v[1].se;\n\tfor(itr=mp.begin();itr!=mp.end();itr++){\n\t\tb[(itr->fr).fr+(itr->fr).se].push_back((msg){(itr->fr).fr,(itr->fr).se,itr->se});\n\t}\n\tfor(int i=0;i<d;i++) if(b[i].size()>0) end();\n\tif(mp[v[1]]!=1||mp[v[2]]!=1||v[1].fr!=0||v[2].se!=0||v[1].se!=v[2].fr) end();\n\t\n\tfor(int i=d;i<=n*2;i++){\n\t\tfor(int j=0;j<b[i].size();j++){\n\t\t\tdp[j][0]=dp[j][1]=0x3f3f3f3f;\n\t\t\tif(j==0){\n\t\t\t\tif(i==d) {dp[j][0]=0;continue;}\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)){\n\t\t\t\t\tdp[j][0]=dp[j][1]=b[i][j].num;\n\t\t\t\t}else if(check(b[i][j].x-1,b[i][j].y)){\n\t\t\t\t\tdp[j][0]=b[i][j].num;\n\t\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\t\tdp[j][1]=b[i][j].num*2;\n\t\t\t\t}else end();\n\t\t\t}else{\n\t\t\t\tint temp=0x3f3f3f3f;\n\t\t\t\tif(b[i][j-1].x+1==b[i][j].x)\n\t\t\t\t\ttemp=dp[j-1][0]+max(b[i][j].num,b[i][j-1].num);\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y))\n\t\t\t\t\ttemp=max(temp,dp[j-1][1]+b[i][j].num);\n\t\t\t\tdp[j][0]=temp;\n\t\t\t\t\n\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\ttemp+=b[i][j].num;\n\t\t\t\telse temp=0x3f3f3f3f;\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)) temp=min(temp,min(dp[j-1][1],dp[j][0])+b[i][j].num);\n\t\t\t\tdp[j][0]=min(dp[j][0],dp[j][1]=temp);\n\t\t\t}\n\t\t}\n\t\tif(i==d) ans+=dp[b[i].size()-1][0];\n\t\telse ans+=dp[b[i].size()-1][1];\n\t\tif(ans>1e9) end();\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define N 100005\n#define fr first\n#define se second\n#define check(x,y) (mp.find(make_pair(x,y))!=mp.end())\nusing namespace std;\nstruct msg{\n\tint x,y,num;\n};\npii v[N];\nvector<msg> b[N*2];\nmap<pii,int > mp;\nmap<pii,int >::iterator itr;\nint dp[N][2];\nint n,ans,d;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&v[i].first,&v[i].se),mp[v[i]]++;\n\td=v[1].se;\n\tfor(itr=mp.begin();itr!=mp.end();itr++){\n\t\tb[(itr->fr).fr+(itr->fr).se].push_back((msg){(itr->fr).fr,(itr->fr).se,itr->se});\n\t}\n\tfor(int i=0;i<d;i++) if(b[i].size()>0) return puts(\"-1\"),0;\n\tif(mp[v[1]]!=1||mp[v[2]]!=1||v[1].fr!=0||v[2].se!=0||v[1].se!=v[2].fr) return puts(\"-1\"),0;\n\t\n\tfor(int i=d;i<=n*2;i++){\n\t\tmemset(dp,0,sizeof(dp[0])*(b[i].size()+2));\n\t\tfor(int j=0;j<b[i].size();j++){\n\t\t\tdp[j][0]=dp[j][1]=0x3f3f3f3f;\n\t\t\tif(j==0){\n\t\t\t\tif(i==d) {dp[j][0]=0;continue;}\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)){\n\t\t\t\t\tdp[j][0]=dp[j][1]=b[i][j].num;\n\t\t\t\t}else if(check(b[i][j].x-1,b[i][j].y)){\n\t\t\t\t\tdp[j][0]=b[i][j].num;\n\t\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\t\tdp[j][1]=b[i][j].num*2;\n\t\t\t\t}else return puts(\"-1\"),0;\n\t\t\t}else{\n\t\t\t\tint temp=0x3f3f3f3f;\n\t\t\t\tif(b[i][j-1].x+1==b[i][j].x)\n\t\t\t\t\ttemp=dp[j-1][0]+max(b[i][j].num,b[i][j-1].num);\n\t\t\t\telse if(check(b[i][j].x-1,b[i][j].y))\n\t\t\t\t\ttemp=dp[j-1][1]+b[i][j].num;\n\t\t\t\tdp[j][0]=temp;\n\t\t\t\t\n\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\ttemp+=b[i][j].num;\n\t\t\t\telse temp=0x3f3f3f3f;\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)) temp=min(temp,dp[j-1][1]+b[i][j].num);\n\t\t\t\tdp[j][0]=min(dp[j][0],dp[j][1]=temp);\n\t\t\t}\n\t\t}\n\t\tif(i==d) ans+=dp[b[i].size()-1][0];\n\t\telse ans+=dp[b[i].size()-1][1];\n\t\tif(ans>1e9) return puts(\"-1\"),0;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\nlong long A[100005];\nlong long B[100005];\nint main(){\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i] >> B[i];\n\t}\n\tcout << 4 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nconst int MAXN = 100001;\nint ans, a[MAXN], b[MAXN], u[MAXN];\n\nvoid no() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nset<pii> S;\n\nvoid ch(bool x) {\n\tif (!x) no();\n}\n\nvoid solve() {\n\tch(a[1] == 0);\n\tch(b[2] == 0);\n\tch(a[2] == b[1]);\n\n\tint d = a[2];\n\tch(d > 0);\n\n\tvector<pii> v;\n\n\tans = n - 1;\n\n\tCL(0, u);\n\tm = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i > 2) ch(a[i] > 0 && b[i] > 0);\n\t\tch(a[i] + b[i] >= d);\n\t\tif (a[i] + b[i] == d) {\n\t\t\tif (!u[a[i]]) {\n\t\t\t\tS.insert(pii(a[i], b[i]));\n\t\t\t\tu[a[i]] = 1; m++;\n\t\t\t}\n\t\t\telse ans++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(pii(a[i], b[i]));\n\t\t}\n\t}\n\tch(m == d + 1);\n\tsort(v.begin(), v.end());\n\n\tfor (pii p : v) {\n\t\tif (S.count(pii(p.first - 1, p.second - 1))) { S.insert(p); continue; }\n\t\tif (S.count(pii(p.first, p.second))) { S.insert(p);  ans++; continue; }\n\t\tif (S.count(pii(p.first, p.second - 1))) { ans++; S.insert(p); continue; }\n\t\tif (S.count(pii(p.first - 1, p.second))) { ans++; S.insert(p); continue; }\n\t\t//if (S.count(pii(p.first, p.second - 1)) && S.count(pii(p.first - 1, p.second))) { ans++; S.insert(p); continue; }\n\t\tno();\n\t}\n}\n\nvoid read() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\tcin >> n;\n\tF1(i, n) cin >> a[i] >> b[i];\n}\n\nint main() {\n\tread();\n\tsolve();\n\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\tvector<pair<int, int> > A;\n\tfor(int i=0; i<N; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tA.emplace_back(a, b);\n\t}\n\tif(A[0].first!=0 || A[1].second!=0 || A[1].first!=A[0].second) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint ab = A[0].second;\n\tint sum = ab;\n\t{\n\t\tvector<int> vec(ab+1);\n\t\tfor(auto & p : A) {\n\t\t\tif(p.first+p.second==ab) {\n\t\t\t\t++vec[p.first];\n\t\t\t}\n\t\t\tif(p.first+p.second<ab) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(vec[0]!=1 || vec[ab]!=1) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i : vec) {\n\t\t\tif(i==0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(2<=i) {\n\t\t\t\tsum += (i-1)*2;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tvector<pair<int, int> > vec;\n\t\tfor(auto & p : A) {\n\t\t\tif(ab<p.first+p.second) {\n\t\t\t\tint aa = p.first+p.second - ab;\n\t\t\t\tint aaHalf = (aa+1)>>1;\n\t\t\t\tint aaa = p.first-aaHalf;\n\t\t\t\tif(aa&1) {\n\t\t\t\t\tvec.emplace_back(ab + ab + p.first-aaHalf, aaHalf);\n\t\t\t\t\t++sum;\n\t\t\t\t\t++sum;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvec.emplace_back(p.first-aaHalf, aaHalf);\n\t\t\t\t\t++sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\tint beforeF = -1;\n\t\tint beforeS = 0;\n\t\tfor(auto & p : vec) {\n\t\t\tif(p.first!=beforeF) {\n\t\t\t\tbeforeF = p.first;\n\t\t\t\tbeforeS = 0;\n\t\t\t}\n\t\t\tif(p.second!=beforeS && p.second!=beforeS+1) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbeforeS = p.second;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010];\nint L;\nint did[101010];\nint ok[101010];\n\nset<pair<int,int>> S;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i]>>B[i];\n\t\n\tif(A[0]!=0) return _P(\"-1\\n\");\n\tif(B[1]!=0) return _P(\"-1\\n\");\n\tif(A[1]!=B[0]) return _P(\"-1\\n\");\n\tL=A[1];\n\tok[0]=ok[L]=1;\n\tdid[0]=did[1]=1;\n\t\n\tS.insert({0,L});\n\tS.insert({L,0});\n\tvector<pair<int,int>> V;\n\tint ret=1;\n\tfor(i=2;i<N;i++) {\n\t\tif(A[i]==0 || B[i]==0) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<L) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]==L) {\n\t\t\tdid[i]=1;\n\t\t\tif(ok[A[i]]==1) ret++;\n\t\t\tok[A[i]]=1;\n\t\t\tret++;\n\t\t\tS.insert({A[i],B[i]});\n\t\t}\n\t\telse {\n\t\t\tV.push_back({A[i]+B[i],i});\n\t\t}\n\t}\n\tFOR(i,L+1) if(ok[i]==0) return _P(\"-1\\n\");\n\tsort(ALL(V));\n\tFORR(r,V) {\n\t\tx = r.second;\n\t\tif(S.count({A[x]-1,B[x]-1})) {\n\t\t\tret++;\n\t\t}\n\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x],B[x]-1})) {\n\t\t\tret+=2;\n\t\t}\n\t\telse {\n\t\t\treturn _P(\"-1\\n\");\n\t\t}\n\t\tS.insert({A[x],B[x]});\n\t}\n\tassert(0);\n\t_P(\"%d\\n\",ret);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\nbool comp (pair<int,int> a, pair<int,int>b){\n    return a.FI+a.SE<b.FI+b.SE or (a.FI+a.SE==b.FI+b.SE and a.FI<b.FI);\n}\nint cnt(multiset<pair<int,int>> &s, int a, int b){\n    return s.count(make_pair(a,b));\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<pair<int,int>> d;\n    multiset<pair<int,int>> s;\n    REP(i,n){\n        int a,b;\n        cin >> a>>b;\n        s.insert(make_pair(a,b));\n        d.push_back(make_pair(a,b));\n    }\n    if(d[0].FI!=0 or d[1].SE!=0 or d[1].FI!=d[0].SE or d[0].SE==0){\n        cout << -1 << endl; return 0;\n    }\n    FOR(i,2,n){\n        if(d[i].FI==0 or d[i].SE==0){\n            cout << -1 << endl; return 0;\n        }\n    }\n    FOR(i,1,d[0].SE){\n        if(cnt(s,i,d[0].SE-i)==0){\n            cout << -1 << endl; return 0;\n        }\n    }\n    //0~1\n    int ans=cnt(s,1,d[0].SE-1);\n\n    FOR(i,1,d[0].SE){\n        ans+=max(cnt(s,i,d[0].SE-i),cnt(s,i+1,d[0].SE-i-1));\n    }\n    sort(d.begin(),d.end());\n    d.erase(unique(ALL(d)),d.end());\n    sort(d.begin(),d.end(),comp);\n    int v=0;\n    for(auto it=lower_bound(ALL(d),make_pair(1,d[0].SE),comp); it<d.end();it++){\n        int d0=it->FI,d1=it->SE,add=0,now=cnt(s,d0,d1);\n        //DBG(ans)\n        //cout << d0 << ' ' <<d1  <<' '<<v<<endl;\n        if(v){\n            if(cnt(s,d0-1,d1-1)){\n                add=max(v,now);\n                v=min(v,now);\n            }else if(cnt(s,d0+1,d1-1)){\n                add=max(v,now);\n                v=now;\n            }else if(cnt(s,d0,d1-1)){\n                add=max(v,now)+now;\n                v=0;\n            }else {\n                cout << -1 << endl; return 0;\n            }\n        }else if(cnt(s,d0-1,d1-1)){\n            add=now;\n        }else if(cnt(s,d0-1,d1)or cnt(s,d0-1,d1+1)){\n            add=now;\n            if(cnt(s,d0+1,d1-1)){\n                v=add;\n            }else if(cnt(s,d0,d1-1)){\n                add*=2;\n            }else{\n                cout << -1 << endl; return 0;\n            }\n        }else{\n            cout << -1 << endl; return 0;\n        }\n        ans+=add;\n    }\n\n    cout << ans <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nconst int MAXN = 100001;\nint ans, a[MAXN], b[MAXN], u[MAXN];\n\nvoid no() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nset<pii> S;\n\nvoid ch(bool x) {\n\tif (!x) no();\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\tcin >> n;\n\tF1(i, n) cin >> a[i] >> b[i];\n\n\tch(a[1] == 0);\n\tch(b[2] == 0);\n\tch(a[2] == b[1]);\n\t\n\tint d = a[2];\n\tch(d > 0);\n\n\tvector<pii> v;\n\n\tans = n - 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i > 2) ch(a[i] > 0 && b[i] > 0);\n\t\tch(a[i] + b[i] >= d);\n\t\tif (a[i] + b[i] == d) {\n\t\t\tif (!u[a[i]]) {\n\t\t\t\tS.insert(pii(a[i], b[i]));\n\t\t\t\tu[a[i]] = 1; m++;\n\t\t\t}\n\t\t\telse ans++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(pii(a[i], b[i]));\n\t\t}\n\t}\n\tch(m == d + 1);\n\tsort(v.begin(), v.end());\n\n\tfor (pii p : v) {\n\t\tif (S.count(pii(p.first - 1, p.second - 1))) continue;\n\t\tif (S.count(pii(p.first, p.second))) { ans++; continue; }\n\t\tif (S.count(pii(p.first, p.second - 1))) { ans++; S.insert(p); continue; }\n\t\tif (S.count(pii(p.first - 1, p.second))) { ans++; S.insert(p); continue; }\n\t\tno();\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010],C[101010],D[101010];\nmap<pair<int,int>,vector<int>> M;\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tM[{A[i],B[i]}].push_back(i);\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(i==0) {\n\t\t\tif(A[i]) return _P(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tC[i]=1;\n\t\t\tif(M.count({A[i]-1,B[i]-1})+M.count({A[i]-1,B[i]})+M.count({A[i]-1,B[i]+1})==0) return _P(\"-1\\n\");\n\t\t}\n\t\tif(i==1) {\n\t\t\tif(B[i]) return _P(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tD[i]=1;\n\t\t\tif(M.count({A[i]-1,B[i]-1})+M.count({A[i],B[i]-1})+M.count({A[i]+1,B[i]-1})==0) return _P(\"-1\\n\");\n\t\t}\n\t}\n\t\n\tint ret=2*N-2;\n\tFORR(m,M) {\n\t\tauto a=m.first;\n\t\ta.first--;\n\t\ta.second++;\n\t\ty=0;\n\t\tFORR(x,m.second) {\n\t\t\tif(C[x]&&D[x]&&M.count({A[x]-1,B[x]-1})) {\n\t\t\t\tret--;\n\t\t\t\tC[x]=D[x]=0;\n\t\t\t}\n\t\t\tif(C[x]&&M.count(a)&&y<M[a].size()) {\n\t\t\t\tD[M[a][y]]=0;\n\t\t\t\tret--;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nconst int MAXN = 100001;\nint ans, a[MAXN], b[MAXN], u[MAXN];\n\nvoid no() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nset<pii> S;\n\nvoid ch(bool x) {\n\tif (!x) no();\n}\n\nint cc(pii p1, pii p2) {\n\tif (p1.first + p1.second != p2.first + p2.second) return p1.first + p1.second < p2.first + p2.second;\n\treturn p1 < p2;\n}\n\nvoid solve() {\n\tch(a[1] == 0);\n\tch(b[2] == 0);\n\tch(a[2] == b[1]);\n\n\tint d = a[2];\n\tch(d > 0);\n\n\tvector<pii> v;\n\n\tans = n - 1;\n\n\tCL(0, u);\n\tm = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i > 2) ch(a[i] > 0 && b[i] > 0);\n\t\tch(a[i] + b[i] >= d);\n\t\tif (a[i] + b[i] == d && !u[a[i]]) {\n\t\t\tS.insert(pii(a[i], b[i]));\n\t\t\tu[a[i]] = 1; m++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(pii(a[i], b[i]));\n\t\t}\n\t}\n\tch(m == d + 1);\n\tsort(v.begin(), v.end(), cc);\n\n\tset<pii> S2;\n\n\tfor (pii p : v) {\n\t\tif (S.count(pii(p.first - 1, p.second - 1))) { S.insert(p); continue; }\n\t\tif (S.count(pii(p.first, p.second))) { \n\t\t\tif (S.count(p) && S2.count(pii(p.first - 1, p.second + 1))) continue;\n\t\t\tS2.insert(p);  S.insert(p);  ans++; continue;\n\t\t}\n\t\tif (S.count(pii(p.first, p.second - 1))) { ans++; S.insert(p); S2.insert(p);  continue; }\n\t\tif (S.count(pii(p.first - 1, p.second))) { ans++; S.insert(p); S2.insert(p);  continue; }\n\t\t//if (S.count(pii(p.first, p.second - 1)) && S.count(pii(p.first - 1, p.second))) { ans++; S2.insert(p);  S.insert(p); continue; }\n\t\tno();\n\t}\n}\n\nvoid read() {\n\tfreopen(\"x.in\", \"r\", stdin);\n\tcin >> n;\n\tF1(i, n) cin >> a[i] >> b[i];\n}\n\nint main() {\n\tif (1) {\n\t\tread();\n\t\tsolve();\n\t\tcout << ans << endl;\n\t\texit(0);\n\t}\n\n\tF0(it, 10000000) {\n\t\tint edges = 0;\n\t\tn = 5 + rand()%10;\n\t\tvector<int> p(n + 1);\n\t\tvector< vector<int> > d(n + 1, vector<int>(n + 1, inf));\n\t\tF1(i, n) d[i][i] = 0;\n\t\tF1(i, n) p[i] = i;\n\t\tint cnt = n - 1;\n\t\twhile (cnt > 0) {\n\t\t\tint i = rand() % n + 1;\n\t\t\tint j = rand() % n + 1;\n\t\t\tif (i == j) continue;\n\t\t\td[i][j] = d[j][i] = 1;\n\t\t\tedges++;\n\t\t\twhile (i != p[i]) i = p[i];\n\t\t\twhile (j != p[j]) j = p[j];\n\t\t\tif (i != j) {\n\t\t\t\tp[i] = j;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t\tF1(k, n)F1(i, n) F1(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\tF1(i, n) {\n\t\t\tif (d[1][i] >= inf || d[2][i] >= inf) throw 12;\n\t\t\ta[i] = d[1][i];\n\t\t\tb[i] = d[2][i];\n\t\t}\n\n\t\tsolve();\n\t\tif (edges < ans) {\n\t\t\tcout << endl;\n\t\t\tcout << edges << \" \" << ans << endl;\n\t\t\tF1(i, n) cout << a[i] << \" \" << b[i] << endl;\n\t\t\tthrow 12;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 100010;\n\nint N;\nint A[MN], B[MN];\nvector<int> Va[MN], Vb[MN];\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n\n        Va[ A[i] ].push_back(i);\n        Vb[ B[i] ].push_back(i);\n    }\n\n    if(A[0] || B[1]) {\n        printf(\"-1\");\n        return 0;\n    }\n    if(A[1] != B[0]) {\n        printf(\"-1\");\n        return 0;\n    }\n    if(Va[0].size() > 1 || Vb[0].size() > 1) {\n        printf(\"-1\");\n        return 0;\n    }\n\n    multiset<int> pre;\n    pre.insert(B[0]);\n\n    for(int i = 1; i < N; i++) {\n        multiset<int> cur;\n\n        for(int j = 0; j < Va[i].size(); j++) {\n            int x = Va[i][j];\n\n            auto it = pre.lower_bound(B[x] - 1);\n            if(it == pre.end() || B[x] + 1 < *it) {\n                printf(\"-1\");\n                return 0;\n            }\n\n            cur.insert(B[x]);\n        }\n        pre = cur;\n    }\n\n    int ans = N - 1;\n\n    pre.clear();\n    pre.insert(A[1]);\n\n    multiset<int> alive = pre;\n    for(int i = 1; i < N; i++) {\n        multiset<int> cur;\n        multiset<int> tmp;\n\n        for(int j = 0; j < Vb[i].size(); j++) {\n            int x = Vb[i][j];\n\n            auto it = pre.lower_bound(A[x] - 1);\n            if(it == pre.end() || A[x] + 1 < *it) {\n                printf(\"-1\");\n                return 0;\n            }\n            cur.insert(A[x]);\n        }\n\n        vector<int> chk(Vb[i].size(), 0);\n        for(int j = 0; j < Vb[i].size(); j++) {\n            int x = Vb[i][j];\n\n            if(pre.find(A[x] - 1) != pre.end()) {\n                chk[j] = 1;\n            }\n        }\n        for(int j = 0; j < Vb[i].size(); j++) if(!chk[j]) {\n            int x = Vb[i][j];\n\n            tmp.insert(A[x]);\n            if(alive.find(A[x] + 1) != alive.end()) {\n                alive.erase(alive.find(A[x] + 1));\n            }\n            else ans++;\n        }\n\n        pre = cur;\n        alive = tmp;\n    }\n\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nint n;\npair<int,int> a[maxn];\n\nbool check_1(){\n  if(a[1].first!=0||a[2].second!=0||a[2].first!=a[1].second)return false;\n  for(int i=3;i<=n;i++)\n    if(a[i].first==0||a[i].second==0)return false;\n  set<pair<int,int>>st;\n  for(int i=1;i<=n;i++)st.insert(a[i]);\n  for(int i=3;i<=n;i++){\n    int cnt=0;\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first-1,a[i].second+j))!=st.end()){\n        cnt++;\n        break;\n      }\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first+j,a[i].second-1))!=st.end()){\n        cnt++;\n        break;\n      }\n      if(cnt<2)return false;\n  }\n  return true;\n}\n\nbool cmp(pair<int,int> a,pair<int,int> b){\n  int ta = a.first + a.second;\n  int tb = b.first + b.second;\n  return ta == tb ? a.first < b.first: ta < tb;\n}\n\nint cal(){\n  int ret=0;\n  sort(a+1,a+n+1,cmp);\n  map<pair<int,int>,int>mp;\n  map<pair<int,int>,int>f[2];\n  for(int i=1;i<=n;i++){\n    int pos = i;\n    vector<pair<int,int>>v;\n    v.push_back(a[i]);\n    for(int j = i;j<=n;j++){\n      if(a[j].first + a[j].second!=a[i].first + a[i].second)break;\n      pos = j;\n      if(mp.find(a[j])==mp.end())mp[a[j]]=1;\n      else mp[a[j]]+=1;\n      f[0][a[j]] = f[1][a[j]] = -1;\n      if(j>i&&a[j]!=a[i])v.push_back(a[j]);\n    }\n    f[0][v[0]]=0;\n    if(mp.find(make_pair(v[0].first-1,v[0].second-1))!=mp.end()){\n      f[1][v[0]] = mp[v[0]];\n    }\n    for(int j=0;j+1<v.size();j++){\n      if(f[0][v[j]]!=-1){\n        if(v[j].first == v[j+1].first - 1){\n          f[0][v[j+1]] = max(f[0][v[j+1]],f[0][v[j]] + min(mp[v[j]],mp[v[j+1]]));\n        } else {\n          f[0][v[j+1]] = max(f[0][v[j+1]],f[0][v[j]]);\n        }\n        if(mp.find(make_pair(v[j+1].first-1,v[j+1].second-1))!=mp.end()){\n          f[1][v[j+1]] = max(f[1][v[j+1]],f[0][v[j]]+mp[v[j+1]]);\n        }\n      }\n      if(f[1][v[j]]!=-1){\n        f[0][v[j+1]] = max(f[0][v[j+1]],f[1][v[j]]);\n        if(mp.find(make_pair(v[j+1].first-1,v[j+1].second-1))!=mp.end()){\n          f[1][v[j+1]] = max(f[1][v[j+1]],f[1][v[j]]+mp[v[j+1]]);\n        }\n      }\n    }\n    ret += max(0, max(f[0][v[v.size()-1]],f[1][v[v.size()-1]]));\n    i =pos;\n  }\n  return ret;\n}\n\nint main() {\n//    freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    if(!check_1()){\n      cout<<-1<<endl;\n      return 0;\n    }\n    cout<<2*n-2-cal()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 100010;\n\nint N;\nint A[MN], B[MN];\nvector<int> Va[MN], Vb[MN];\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n\n        Va[ A[i] ].push_back(i);\n        Vb[ B[i] ].push_back(i);\n    }\n\n    if(A[0] || B[1]) {\n        printf(\"-1\");\n        return 0;\n    }\n    if(Va[0].size() > 1 || Vb[0].size() > 1) {\n        printf(\"-1\");\n        return 0;\n    }\n\n    multiset<int> pre;\n    pre.insert(B[0]);\n\n    for(int i = 1; i < N; i++) {\n        multiset<int> cur;\n\n        for(int j = 0; j < Va[i].size(); j++) {\n            int x = Va[i][j];\n\n            auto it = pre.lower_bound(B[x] - 1);\n            if(it == pre.end() || B[x] + 1 < *it) {\n                printf(\"-1\");\n                return 0;\n            }\n\n            cur.insert(B[x]);\n        }\n        pre = cur;\n    }\n\n    int ans = N - 1;\n\n    pre.clear();\n    pre.insert(A[1]);\n\n    multiset<int> alive = pre;\n    for(int i = 1; i < N; i++) {\n        multiset<int> cur;\n        multiset<int> tmp;\n\n        for(int j = 0; j < Vb[i].size(); j++) {\n            int x = Vb[i][j];\n\n            auto it = pre.lower_bound(A[x] - 1);\n            if(it == pre.end() || A[x] + 1 < *it) {\n                printf(\"-1\");\n                return 0;\n            }\n            cur.insert(A[x]);\n        }\n\n        vector<int> chk(Vb[i].size(), 0);\n        for(int j = 0; j < Vb[i].size(); j++) {\n            int x = Vb[i][j];\n\n            if(pre.find(A[x] - 1) != pre.end()) {\n                chk[j] = 1;\n                continue;\n            }\n        }\n        for(int j = 0; j < Vb[i].size(); j++) if(!chk[j]) {\n            int x = Vb[i][j];\n\n            tmp.insert(A[x]);\n            if(alive.find(A[x] + 1) != alive.end()) {\n                alive.erase(alive.find(A[x] + 1));\n                continue;\n            }\n            else ans++;\n        }\n\n        pre = cur;\n        alive = tmp;\n    }\n\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\ntypedef pair<int, int> pii;\n\nmap<pii, int> a;\n\nvoid ass(bool ex) {\n    if (!ex) {\n        cout << -1 << '\\n';\n        exit(0);\n    }\n}\n\npii operator+(pii a, pii b) {\n    return pii{a.first + b.first, a.second + b.second};\n}\n\npii operator-(pii a, pii b) {\n    return pii{a.first - b.first, a.second - b.second};\n}\n\npii nx(pii a) {\n    return a + pii{1, -1};\n}\n\nint main() {\n    #ifdef LOCAL\n    assert(freopen(\"a.in\", \"r\", stdin));\n    #else\n    #endif\n    int n;\n    cin >> n;\n    int d;\n    forn (i, n) {\n        int x, y;\n        cin >> x >> y;\n        if (i == 0) {\n            ass(x == 0);\n            d = y;\n        }\n        if (i == 1)\n            ass(y == 0 && d == x);\n        ass(x + y >= d);\n        ass(x >= 0 && y >= 0);\n        if (i != 0)\n            ass(x != 0);\n        if (i != 1)\n            ass(y != 0);\n        a[pii(x, y)]++;\n    }\n    for (auto p: a) {\n        auto c = p.first;\n        if (c.second != 0)\n            ass(a.count(c + pii(0, -1)) || a.count(c + pii(-1, -1)) || a.count(c + pii(1, -1)));\n        if (c.first != 0)\n            ass(a.count(c + pii(-1, 0)) || a.count(c + pii(-1, -1)) || a.count(c + pii(-1, 1)));\n    }\n    //cerr << \"YES\\n\";\n    vector<pair<pii, int>> v;\n    for (auto A: a)\n        v.push_back(A);\n    sort(v.begin(), v.end(), [](pair<pii, int> a, pair<pii, int> b) {\n                int sa = a.first.first + a.first.second;\n                int sb = b.first.first + b.first.second;\n                if (sa != sb)\n                    return sa < sb;\n                return a.first < b.first;\n            });\n    int res = 2 * n - 2;\n\n    int carry = 0;\n    forn (ii, sz(v)) {\n        auto c = v[ii].first;\n        int cnt = v[ii].second;\n        if (a.count(c + pii{-1, -1})) {\n            res -= cnt;\n            res += carry;\n            cnt = 0;\n        }\n        int ncarry = 0;\n        if (ii + 1 < sz(v) && v[ii + 1].first == nx(c)) {\n            ncarry = min(v[ii + 1].second, cnt);\n            res -= ncarry;\n        }\n        carry = ncarry;\n    }\n    cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve();\nvoid precalc();\nclock_t start;\n//int timer = 1;\n\nint testNumber = 1;\n\nbool todo = true;\n\nint main() {\n#ifdef AIM\n    freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n#else\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    start = clock();\n    int t = 1;\n    cout.sync_with_stdio(0);\n    cin.tie(0);\n    precalc();\n    cout.precision(10);\n    cout << fixed;\n    //cin >> t;\n    int testNum = 1;\n    while (t--) {\n        //cerr << testNum << endl;\n        //cout << \"Case #\" << testNum++ << \": \";\n        solve();\n        ++testNumber;\n        //++timer;\n    }\n\n#ifdef AIM\n    cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n    return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n    if (!w)\n        return 1 % mod;\n    if (w & 1)\n        return q * 1LL * binpow(q, w - 1, mod) % mod;\n    return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n    while (w) {\n        q %= w;\n        swap(q, w);\n    }\n    return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n    return q / gcd(q, w) * w;\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n\n//const int mod = 1000000007;\n\n\nvoid solve() {\n    int n;\n    cin >> n;\n    multiset<pair<int, int>> a;\n    int b, c, d, e;\n    cin >> b >> c >> d >> e;\n    if (b != 0 || e != 0 || c != d) {\n        cout << \"-1\\n\";\n        return;\n    }\n    int dist = c;\n    a.insert({dist, 0});\n    a.insert({0, dist});\n\n    for (int i = 2; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        a.insert({x, y});\n        if (x == 0 || y == 0) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n\n    map<int, int> cnt;\n    int ans = n - 1;\n\n    for (auto item : a) {\n        if (abs(item.first - item.second) > dist) {\n            cout << \"-1\\n\";\n            return;\n        }\n        int diff =  item.first + item.second - dist;\n        if (diff < 0) {\n            cout << \"-1\\n\";\n            return;\n        }\n        if (diff == 0) {\n            cnt[item.first]++;\n            continue;\n        }\n        if (diff == 1) {\n            ++ans;\n            continue;\n        }\n        if (a.find(make_pair(item.first  - 1, item.second - 1)) == a.end()) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n    int sum = 0;\n    for (auto item : cnt) {\n        sum += item.second - 1;\n    }\n\n    for (int i = 1; i<=dist; ++i) {\n        sum -= max(min(cnt[i], cnt[i - 1]) - 1, 0);\n    }\n\n    ans += sum;\n\n    if (cnt.size() != dist + 1) {\n        cout << \"-1\\n\";\n        return;\n    }\n\n    cout << ans << \"\\n\";\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nint A[SIZE],B[SIZE],cnt[2][SIZE];\nVI d[SIZE];\nvoid NO(){puts(\"-1\");exit(0);}\nint main(){\n    DRI(N);\n    REP(i,N)RII(A[i+1],B[i+1]);\n    if(A[1]||B[2]||B[1]!=A[2]||A[2]==0)NO();\n    int dd=A[2];\n    int an=dd;\n    int one=0;\n    REPP(i,3,N+1){\n        if(!A[i]||!B[i])NO();\n        if(A[i]+B[i]==dd){\n            cnt[0][A[i]]++;\n            if(cnt[0][A[i]]>1)an+=2;\n        }\n        else if(A[i]+B[i]==dd+1){\n            cnt[1][A[i]]++;\n            if(cnt[1][A[i]]>1)an+=2;\n            one=1;\n        }\n        else{\n            an++;\n            int p=A[i]+dd-B[i];\n            if(p%2)NO();\n            if(p/2<0||p/2>dd)NO();\n            d[p/2].PB(A[i]-p/2);\n        }\n    }\n    REPP(i,1,dd){\n        if(!cnt[0][i])NO();\n    }\n    if(one){\n        an+=dd+1;\n        REPP(i,1,dd+1){\n            if(!cnt[1][i])NO();\n        }\n    }\n    REP(i,dd+1){\n        int lt=0;\n        sort(ALL(d[i]));\n        REP(j,SZ(d[i])){\n            if(d[i][j]!=lt&&d[i][j]!=lt+1)NO();\n            lt=d[i][j];\n        }\n    }\n    printf(\"%d\\n\",an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nint N;\nint A[101010],B[101010];\nmap<pair<int,int>,int> S;\nUF<500000> uf;\nmap<int,int> V[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tif(i!=0 && A[i]==0) return _P(\"-1\\n\");\n\t\tif(i==0 && A[i]) return _P(\"-1\\n\");\n\t\tif(i!=1 && B[i]==0) return _P(\"-1\\n\");\n\t\tif(i==1 && B[i]) return _P(\"-1\\n\");\n\t\tS[{A[i],B[i]}]=i;\n\t\tV[A[i]+B[i]][A[i]]++;\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(i!=0) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i]-1,B[i]})) uf(i,S[{A[i]-1,B[i]}]);\n\t\t\tif(S.count({A[i]-1,B[i]+1})) uf(i,S[{A[i]-1,B[i]+1}]);\n\t\t}\n\t\tif(i!=1) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i],B[i]-1})) uf(i,S[{A[i],B[i]-1}]);\n\t\t\tif(S.count({A[i]+1,B[i]-1})) uf(i,S[{A[i]+1,B[i]-1}]);\n\t\t}\n\t}\n\t\n\tif(uf.count(0)!=N) return _P(\"-1\\n\");\n\tint ret=2*N-2;\n\tFOR(i,2*N) if(V[i].size()) {\n\t\tint pre=-2,left=0;\n\t\tFORR(r,V[i]) {\n\t\t\tx = r.second;\n\t\t\tif(r.first==pre+1) {\n\t\t\t\tret -= min(left,x);\n\t\t\t\tx-=min(left,x);\n\t\t\t}\n\t\t\tif(S.count({r.first-1,(i-r.first)-1})) {\n\t\t\t\tret-=x;\n\t\t\t\tx=0;\n\t\t\t}\n\t\t\tpre=r.first;\n\t\t\tleft=x;\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MX = 120000;\n\nint n;\nint a[MX];\nint b[MX];\nvector<int> go[MX];\n\nset<pair<int, int> > ss;\nset<pair<int, int> > sst;\nset<pair<int, int> > ss2;\nset<pair<int, int> > ss2t;\n\nvector<pair<int, int> > ed;\nvector<int> vv;\nmap<pair<int, int>, int> mm;\n\nvoid ex() {\n\t//if (n != 3)\n\t//\tassert(false);\n\tcout << -1 << \"\\n\";\n\texit(0);\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i] >> b[i];\n\tif (a[0] != 0 || b[1] != 0)\n\t\tex();\n\tfor (int i = 0; i < n; ++i) {\n\t\tgo[a[i]].push_back(i);\n\t}\n\tif ((int)go[0].size() != 1)\n\t\tex();\n\tss.insert(make_pair(b[0], 0));\n\tss2.insert(make_pair(b[0], 0));\n\tfor (int i = 0; i < n; ++i)\n\t\tmm[make_pair(a[i], b[i])] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tsst.clear();\n\t\tss2t.clear();\n\t\tfor (int j: go[i]) {\n\t\t\tauto it = ss.lower_bound(make_pair(b[j] + 1, 0));\n\t\t\tss2t.insert(make_pair(b[j], j));\n\t\t\tif (it != ss.end() && it->first == b[j] + 1) {\n\t\t\t\ted.push_back(make_pair(j, it->second));\n\t\t\t\tss.erase(it);\n\t\t\t\tsst.insert(make_pair(b[j], j));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tauto it = ss2.lower_bound(make_pair(b[j] - 1, 0));\n\t\t\t\tif (it != ss2.end() && it->first <= b[j] + 1) {\n\t\t\t\t\tif (it->first != b[j] - 1)\n\t\t\t\t\t\tsst.insert(make_pair(b[j], j));\n\t\t\t\t\ted.push_back(make_pair(j, it->second));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tex();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto j: ss)\n\t\t\tvv.push_back(j.second);\n\t\tswap(ss, sst);\n\t\tswap(ss2, ss2t);\n\t}\n\tfor (int j: vv) {\n\t\tif (j == 1)\n\t\t\tcontinue;\n\t\tint fl = 0;\n\t\tfor (int d = -1; d <= 1; ++d) {\n\t\t\tif (mm.count(make_pair(a[j] + d, b[j] - 1))) {\n\t\t\t\tfl = 1;\n\t\t\t\ted.push_back(make_pair(mm[make_pair(a[j] + d, b[j] - 1)], j));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!fl) {\n\t\t\tex();\n\t\t}\n\t}\n\tcout << ed.size() << \"\\n\";\n\t/*for (auto j: ed) {\n\t\tcout << j.first + 1 << \" \" << j.second + 1 << \"\\n\";\n\t}*/\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n\nusing namespace std;\n\nmap <pair<int, int>, int> mp[200000];\n\nbool check(pair<int, int> p, int da, int db) {\n    int a = p.first + da;\n    int b = p.second + db;\n    \n    return mp[a + b].count(make_pair(a, b));\n}\n\npair<int, int> before(pair<int, int> p, int c) {\n    int m1, m2;\n    \n    if (check(p, -1, -1)) {\n        m1 = c;\n    } else if (check(p, -1, 0) && check(p, 0, -1)) {\n        m1 = c * 2;\n    } else {\n        m1 = 1e9;\n    }\n    \n    if (check(p, -1, 0)) {\n        m2 = c;\n    } else {\n        m2 = 1e9;\n    }\n    \n    return make_pair(m1, m2);\n}\n\nint solve() {\n    int n, d, ans = 0, i;\n    map <pair<int, int>, int>::iterator it, it2;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) {\n        int a, b;\n        \n        scanf(\"%d %d\", &a, &b);\n        \n        if (i == 0) {\n            if (a != 0 || b == 0) return -1;\n            \n            d = b;\n        } else if (i == 1) {\n            if (a != d || b != 0) return -1;\n        } else {\n            if (a == 0 || b == 0 || a + b < d) return -1;\n        }\n        \n        mp[a + b][make_pair(a, b)]++;\n    }\n    \n    for (it = mp[d].begin(); it != mp[d].end(); it++) {\n        if (it == mp[d].begin()) continue;\n        \n        it2 = it;\n        it2--;\n        \n        if (it2->first.first + 1 != it->first.first) return -1;\n        \n        ans += max(it->second, it2->second);\n    }\n    \n    for (i = d + 1; i < n * 2; i++) {\n        pair <int, int> p;\n        \n        if (mp[i].size() == 0) continue;\n        \n        for (it = mp[i].begin(); it != mp[i].end(); it++) {\n            if (it == mp[i].begin()) {\n                p = before(it->first, it->second);\n            } else {\n                it2 = it;\n                it2--;\n                \n                if (it2->first.first + 1 != it->first.first) {\n                    if (p.first >= 1e9) return -1;\n                    \n                    ans += p.first;\n                    p = before(it->first, it->second);\n                } else {\n                    int m1 = 1e9, m2 = 1e9, c = max(it->second, it2->second);\n                    \n                    if (check(it->first, -1, -1)) m1 = min(m1, min(p.first + it->second, p.second + c + it->second));\n                    if (check(it->first, 0, -1)) m1 = min(m1, min(p.first + c + it->second, p.second + c + it->second));\n                    if (check(it->first, -1, 0) && check(it->first, 0, -1)) m1 = min(m1, p.first + it->second * 2);\n                    \n                    m2 = min(m2, min(p.first + c, p.second + c));\n                    if (check(it->first, -1, 0)) m2 = min(m2, p.first + it->second);\n                    \n                    p = make_pair(m1, m2);\n                }\n            }\n        }\n        \n        if (p.first >= 1e9) return -1;\n        ans += p.first;\n    }\n    \n    return ans;\n}\n\nint main() {\n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\tvector<pair<int, int> > A;\n\tfor(int i=0; i<N; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tA.emplace_back(a, b);\n\t}\n\tif(A[0].first!=0 || A[1].second!=0 || A[1].first!=A[0].second) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint ab = A[0].second;\n\tint sum = ab;\n\t{\n\t\tvector<int> vec(ab+1);\n\t\tfor(auto & p : A) {\n\t\t\tif(p.first+p.second==ab) {\n\t\t\t\t++vec[p.first];\n\t\t\t}\n\t\t}\n\t\tif(vec[0]!=1 || vec[ab]!=1) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i : vec) {\n\t\t\tif(i==0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(2<=i) {\n\t\t\t\tsum += (i-1)*2;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tvector<pair<int, int> > vec;\n\t\tfor(auto & p : A) {\n\t\t\tif(p.first+p.second!=ab) {\n\t\t\t\tint aa = p.first+p.second - ab;\n\t\t\t\tint aaHalf = (aa+1)>>1;\n\t\t\t\tint aaa = p.first-aaHalf;\n\t\t\t\tif(aa<=0) {\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(aa&1) {\n\t\t\t\t\tvec.emplace_back(p.first-aaHalf+1, aaHalf);\n\t\t\t\t\t++sum;\n\t\t\t\t}\n\t\t\t\tvec.emplace_back(p.first-aaHalf, aaHalf);\n\t\t\t\t++sum;\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\tint beforeF = -1;\n\t\tint beforeS = 0;\n\t\tfor(auto & p : vec) {\n\t\t\tif(p.first!=beforeF) {\n\t\t\t\tbeforeF = p.first;\n\t\t\t\tbeforeS = 0;\n\t\t\t}\n\t\t\tif(p.second!=beforeS && p.second!=beforeS+1) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbeforeS = p.second;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 100005\n#define M 200005\n#define seed 23333\n\nusing namespace std;\nconst int inf=(int)1e9;\nint i,j,m,n,p,k,A[N],B[N],l;\nmap<pair<int,int>,int>mp;\nvector<int>v[M];\nint f[2][N],ans,sum[N],size[2],now,last;\nint RE()\n{\n\t\tputs(\"-1\");\n\t\texit(0);\n}\nint main()\n{\n\t\tscanf(\"%d\",&n); ans=2*n-2;\n\t\tfor (i=1;i<=n;++i) \n\t\t{\n\t\t\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\t\t\tmp[mk(A[i],B[i])]=1;\n\t\t\t\tif (i!=1&&!A[i]) RE();\n\t\t\t\tif (i!=2&&!B[i]) RE();\n\t\t}\n\t\tfor (i=1;i<=n;++i)\n\t\t{\n\t\t\t\tif (i!=1&&mp.find(mk(A[i]-1,B[i]))==mp.end()&&\n\t\t\t\t\t\tmp.find(mk(A[i]-1,B[i]-1))==mp.end()&&\n\t\t\t\t\t\tmp.find(mk(A[i]-1,B[i]+1))==mp.end()) RE();\n\t\t\t\tif (i!=2&&mp.find(mk(A[i],B[i]-1))==mp.end()&&\n\t\t\t\t\t\tmp.find(mk(A[i]-1,B[i]-1))==mp.end()&&\n\t\t\t\t\t\tmp.find(mk(A[i]+1,B[i]-1))==mp.end()) RE();\n\t\t\t\tv[A[i]+B[i]].pb(A[i]);\n\t\t}\n\t\tfor (i=1;i<=2*n;++i)\n\t\t\t\tif (v[i].size())\n\t\t\t\t{\n\t\t\t\t\t\tA[0]=B[0]=0;\n\t\t\t\t\t\tfor (j=0;j<(int)v[i].size();++j) A[++A[0]]=v[i][j],B[++B[0]]=v[i][j]; \n\t\t\t\t\t\tsort(B+1,B+B[0]+1); B[0]=unique(B+1,B+B[0]+1)-(B+1);\n\t\t\t\t\t\tfor (j=1;j<=B[0];++j) sum[j]=0;\n\t\t\t\t\t\tfor (j=1;j<=A[0];++j) sum[lower_bound(B+1,B+B[0]+1,A[j])-B]++;\n\t\t\t\t\t\tsize[0]=size[1]=now=last=0; now=1;\n\t\t\t\t\t\tsize[1]=sum[1];\n\t\t\t\t\t\tif (mp.find(mk(B[1]-1,i-B[1]-1))!=mp.end())\n\t\t\t\t\t\tfor (j=0;j<=size[now];++j) f[now][j]=size[now]-j;\n\t\t\t\t\t\telse for (j=0;j<=size[now];++j) f[now][j]=0;\n\t\t\t\t\t\tfor (j=2;j<=B[0];++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnow^=1; last=now^1;\n\t\t\t\t\t\t\t\tsize[now]=sum[j];\n\t\t\t\t\t\t\t\tfor (l=0;l<=size[now];++l) f[now][l]=0;\n\t\t\t\t\t\t\t\tif (mp.find(mk(B[j]-1,i-B[j]-1))==mp.end())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t  for (l=0;l<=size[last];++l)\n\t\t\t\t\t\t\t\t\t  \t f[now][sum[j]]=max(f[now][sum[j]],f[last][l]+(B[j]-B[j-1]==1)*min(sum[j],l));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t int Max=-inf;\n\t\t\t\t\t\t\t\t\t for (l=0;l<=size[now];++l)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (l<=size[last]) Max=max(Max,f[last][l]+(B[j]-B[j-1]==1)*l);\n\t\t\t\t\t\t\t\t\t\t\tf[now][l]=Max;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t Max=-inf;\n\t\t\t\t\t\t\t\t\t for (l=max(size[last],size[now]);l>=0;--l)\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t \t\tif (l<=size[last]) Max=max(Max,f[last][l]);\n\t\t\t\t\t\t\t\t\t \t\tif (l<=size[now])\n\t\t\t\t\t\t\t\t\t \t\tf[now][l]=max(f[now][l],Max+(B[j]-B[j-1]==1)*l);\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t for (l=0;l<=size[now];++l)\n\t\t\t\t\t\t\t\t\t \tf[now][l]+=(size[now]-l);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint Max=0;\n\t\t\t\t\t\tfor (j=0;j<=size[now];++j) Max=max(Max,f[now][j]);\n\t\t\t\t\t\tans-=Max;\n\t\t\t\t}\n\t\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\nlong long A[100005];\nlong long B[100005];\nint main(){\n\tcin >> N;\n\tlong long ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i] >> B[i];\n\t}\n\n\tif(A[0] == 0 && B[0] == 1){\n\t\treturn 1;\n\t}else{\n\t\tans += N - 1;\n\t\tfor(int i = 2; i < N; i++){\n\t\t\tif(A[i] == 1 && B[i] == 1){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nint n;\npair<int,int> a[maxn];\n\nbool check_1(){\n  if(a[1].first!=0||a[2].second!=0||a[2].first!=a[1].second)return false;\n  for(int i=3;i<=n;i++)\n    if(a[i].first==0||a[i].second==0)return false;\n  set<pair<int,int>>st;\n  for(int i=1;i<=n;i++)st.insert(a[i]);\n  for(int i=3;i<=n;i++){\n    int cnt=0;\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first-1,a[i].second+j))!=st.end()){\n        cnt++;\n        break;\n      }\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first+j,a[i].second-1))!=st.end()){\n        cnt++;\n        break;\n      }\n      if(cnt<2)return false;\n  }\n  return true;\n}\n\nbool cmp(pair<int,int> a,pair<int,int> b){\n  int ta = a.first + a.second;\n  int tb = b.first + b.second;\n  return ta == tb ? a.first < b.first: ta < tb;\n}\n\nint cal(){\n  int ret=0;\n  sort(a+1,a+n+1,cmp);\n  map<pair<int,int>,int>mp,f;\n  //map<pair<int,int>,int>f[2];\n  for(int i=1;i<=n;i++){\n    int pos = i;\n    vector<pair<int,int>>v;\n    v.push_back(a[i]);\n    for(int j = i;j<=n;j++){\n      if(a[j].first + a[j].second!=a[i].first + a[i].second)break;\n      pos = j;\n      if(mp.find(a[j])==mp.end())mp[a[j]]=1;\n      else mp[a[j]]+=1;\n      f[a[j]]=mp[a[j]];\n      //f[0][a[j]] = f[1][a[j]] = -1;\n      if(j>i&&a[j]!=a[i])v.push_back(a[j]);\n    }/*\n    f[0][v[0]]=0;\n    if(mp.find(make_pair(v[0].first-1,v[0].second-1))!=mp.end()){\n      f[1][v[0]] = mp[v[0]];\n    }\n    for(int j=0;j+1<v.size();j++){\n      if(f[0][v[j]]!=-1){\n        if(v[j].first == v[j+1].first - 1){\n          f[0][v[j+1]] = max(f[0][v[j+1]],f[0][v[j]] + min(mp[v[j]],mp[v[j+1]]));\n        } else {\n          f[0][v[j+1]] = max(f[0][v[j+1]],f[0][v[j]]);\n        }\n        if(mp.find(make_pair(v[j+1].first-1,v[j+1].second-1))!=mp.end()){\n          f[1][v[j+1]] = max(f[1][v[j+1]],f[0][v[j]]+mp[v[j+1]]);\n        }\n      }\n      if(f[1][v[j]]!=-1){\n        f[0][v[j+1]] = max(f[0][v[j+1]],f[1][v[j]]);\n        if(mp.find(make_pair(v[j+1].first-1,v[j+1].second-1))!=mp.end()){\n          f[1][v[j+1]] = max(f[1][v[j+1]],f[1][v[j]]+mp[v[j+1]]);\n        }\n      }\n    }\n    ret += max(0, max(f[0][v[v.size()-1]],f[1][v[v.size()-1]]));\n    */\n    for(int j=1;j<v.size();j++){\n      if(v[j-1].first+1==v[j].first){\n        int tt =min(mp[v[j-1]],mp[v[j]]);\n        ret+=tt;\n        f[v[j-1]] = min(f[v[j-1]],mp[v[j-1]]-tt);\n        f[v[j]] = min(f[v[j]],mp[v[j]]-tt);\n      }\n    }\n    for(int i=0;i<v.size();i++){\n      if(mp.find(make_pair(v[i].first-1,v[i].second-1))!=mp.end()){\n        ret+=f[v[i]];\n      }\n    }\n    i =pos;\n  }\n  return ret;\n}\n\nint main() {\n   // freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    if(!check_1()){\n      cout<<-1<<endl;\n      return 0;\n    }\n    cout<<2*n-2-cal()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010],C[101010],D[101010];\nmap<pair<int,int>,vector<int>> M;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tM[{A[i],B[i]}].push_back(i);\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(i==0) {\n\t\t\tif(A[i]) return _P(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tC[i]=1;\n\t\t\tif(M.count({A[i]-1,B[i]-1})+M.count({A[i]-1,B[i]})+M.count({A[i]-1,B[i]+1})==0) return _P(\"-1\\n\");\n\t\t}\n\t\tif(i==1) {\n\t\t\tif(B[i]) return _P(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tD[i]=1;\n\t\t\tif(M.count({A[i]-1,B[i]-1})+M.count({A[i],B[i]-1})+M.count({A[i]+1,B[i]-1})==0) return _P(\"-1\\n\");\n\t\t}\n\t}\n\tassert(0);\n\tint ret=0;\n\tFORR(m,M) {\n\t\tauto a=m.first;\n\t\ta.first--;\n\t\ta.second++;\n\t\tif(M.count(a)) {\n\t\t\tx=min(m.second.size(),M[a].size());\n\t\t\tFOR(i,x) {\n\t\t\t\tret++;\n\t\t\t\tC[m.second[i]]=0;\n\t\t\t\tD[M[a][i]]=0;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,N) {\n\t\tif(C[i]+D[i]==2) {\n\t\t\tif(M.count({A[i]-1,B[i]-1})) ret++;\n\t\t\telse ret+=2;\n\t\t\t\n\t\t}\n\t\telse ret+=C[i]+D[i];\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nint N;\nint A[101010],B[101010];\nmap<pair<int,int>,int> S;\nUF<500000> uf;\nmap<int,int> V[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\treturn _P(\"-1\\n\");\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tif(i!=0 && A[i]==0) return _P(\"-1\\n\");\n\t\tif(i==0 && A[i]) return _P(\"-1\\n\");\n\t\tif(i!=1 && B[i]==0) return _P(\"-1\\n\");\n\t\tif(i==1 && B[i]) return _P(\"-1\\n\");\n\t\tS[{A[i],B[i]}]=i;\n\t\tV[A[i]+B[i]][A[i]]++;\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(i!=0) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i]-1,B[i]})) uf(i,S[{A[i]-1,B[i]}]);\n\t\t\tif(S.count({A[i]-1,B[i]+1})) uf(i,S[{A[i]-1,B[i]+1}]);\n\t\t}\n\t\tif(i!=1) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i],B[i]-1})) uf(i,S[{A[i],B[i]-1}]);\n\t\t\tif(S.count({A[i]+1,B[i]-1})) uf(i,S[{A[i]+1,B[i]-1}]);\n\t\t}\n\t}\n\t\n\tif(uf.count(0)!=N) return _P(\"-1\\n\");\n\tint ret=2*N-2;\n\tFOR(i,2*N) if(V[i].size()) {\n\t\tint pre=-2,left=0;\n\t\tFORR(r,V[i]) {\n\t\t\tx = r.second;\n\t\t\tif(r.first==pre+1) {\n\t\t\t\tret -= min(left,x);\n\t\t\t\tx-=min(left,x);\n\t\t\t}\n\t\t\tif(S.count({r.first-1,(i-r.first)-1})) {\n\t\t\t\tret-=x;\n\t\t\t\tx=0;\n\t\t\t}\n\t\t\tpre=r.first;\n\t\t\tleft=x;\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nconst int MAXN = 100001;\nint ans, a[MAXN], b[MAXN], u[MAXN];\n\nvoid no() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nset<pii> S;\n\nvoid ch(bool x) {\n\tif (!x) no();\n}\n\nint cc(pii p1, pii p2) {\n\tif (p1.first + p1.second != p2.first + p2.second) return p1.first + p1.second < p2.first + p2.second;\n\treturn p1 < p2;\n}\n\n\nvoid solve() {\n\tch(a[1] == 0);\n\tch(b[2] == 0);\n\tch(a[2] == b[1]);\n\n\tint d = a[2];\n\tch(d > 0);\n\n\tvector<pii> v;\n\n\tans = n - 1;\n\n\tS.clear();\n\n\tCL(0, u);\n\tm = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i > 2) ch(a[i] > 0 && b[i] > 0);\n\t\tch(a[i] + b[i] >= d);\n\t\tif (a[i] + b[i] == d && !u[a[i]]) {\n\t\t\tS.insert(pii(a[i], b[i]));\n\t\t\tu[a[i]] = 1; m++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(pii(a[i], b[i]));\n\t\t}\n\t}\n\tch(m == d + 1);\n\tsort(v.begin(), v.end(), cc);\n\n\tset<pii> S2;\n\n\tfor (pii p : v) {\n\t\tif (S.count(pii(p.first - 1, p.second - 1))) { S.insert(p); continue; }\n\t\tif (S.count(pii(p.first, p.second))) { \n\t\t\tif (S2.count(pii(p.first - 1, p.second + 1))) continue;\n\t\t\tS2.insert(p);  ans++; continue;\n\t\t}\n\t\t//if (S.count(pii(p.first, p.second - 1))) { ans++; S.insert(p); S2.insert(p);  continue; }\n\t\t//if (S.count(pii(p.first - 1, p.second))) { ans++; S.insert(p); S2.insert(p);  continue; }\n\t\tif (S.count(pii(p.first, p.second - 1)) && S.count(pii(p.first - 1, p.second))) { \n\t\t\tS2.insert(p);  S.insert(p); \n\t\t\tif (!S2.count(pii(p.first - 1, p.second + 1))) ans++;\n\t\t\tcontinue; \n\t\t}\n\t\tno();\n\t}\n}\n\nvoid read() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\tcin >> n;\n\tF1(i, n) cin >> a[i] >> b[i];\n}\n\nint main() {\n\tif (1) {\n\t\tread();\n\t\tsolve();\n\t\tcout << ans << endl;\n\t\texit(0);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 1e5 + 10;\nint n , x[N] , y[N];\n\nvoid check(bool ok) {\n  if(!ok) {\n    puts(\"-1\");\n    exit(0);\n  }\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  rep(i,0,n) scanf(\"%d%d\",x+i,y+i);\n  check(x[0] == 0 && y[1] == 0 && x[1] > 0 && x[1] == y[0]);\n  rep(i,2,n) check(x[i] > 0 && y[i] > 0);\n  map<pii,int> S;\n  rep(i,0,n) S[mp(x[i],y[i])]++;\n  rep(i,0,n) {\n    if(x[i]) check(S.count(mp(x[i]-1,y[i]-1))||S.count(mp(x[i]-1,y[i]))||S.count(mp(x[i]-1,y[i]+1)));\n    if(y[i]) check(S.count(mp(x[i]-1,y[i]-1))||S.count(mp(x[i],y[i]-1))||S.count(mp(x[i]+1,y[i]-1)));\n  }\n  int res = 2 * n - 2;\n  vector<pair<pii,int> > pts;\n  for(auto e : S) pts.pb(e);\n  sort(all(pts),[&](pair<pii,int> a,pair<pii,int> b){\n      int sa=a.fi.fi+a.fi.se;\n      int sb=b.fi.fi+b.fi.se;\n      if(sa!=sb) return sa < sb;\n      return a.fi.fi < b.fi.fi;\n      });\n  int remain = 0;\n  rep(i,0,n) {\n    int x , y , cnt;\n    tie(x , y) = pts[i].fi;\n    cnt = pts[i].se;\n    int match = min(remain , cnt);\n    res -= match;\n    if(S.count(mp(x - 1 , y - 1))) {\n      int link = cnt - match;\n      res -= link;\n      cnt -= link;\n    }\n    if(i + 1 < n && x + 1 == pts[i+1].fi.fi && y - 1 == pts[i+1].fi.se)\n      remain = cnt;\n    else\n      remain = 0;\n  }\n  printf(\"%d\\n\",res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef long long LL;\nmap<int, map<int,int> > d; //exists\nmap<int, int> l[210000]; // freq[sum][xval]\nvector<int> xval;// \nvector<int> freq; // \nint n;\nint a[210000], b[210000];\nint main(){\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) cin >> a[i] >> b[i];\n\tif(a[0] != 0 || b[1] != 0 || a[1] != b[0] || a[1] == 0 || b[0] == 0){\n\t\tcout << -1 << endl; return 0;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tif(a[i] + b[i] < a[0] + b[0]){\n\t\t\tcout << -1 << endl; return 0;\n\t\t}\n\t\tif(i >= 2 && (a[i] == 0 || b[i] == 0) ){\n\t\t\tcout << -1 << endl; return 0;\n\t\t}\n\t\td[a[i]][b[i]] = 1;\n\t\tl[a[i]+b[i]][a[i]]++;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tif(a[i] > 0){\n\t\t\tif(!d[a[i]-1][b[i]-1] && !d[a[i]-1][b[i]] && !d[a[i]-1][b[i]+1]){\n\t\t\t\tcout << -1 << endl; return 0;\n\t\t\t}\n\t\t}\n\t\tif(b[i] > 0){\n\t\t\tif(!d[a[i]-1][b[i]-1] && !d[a[i]][b[i]-1] && !d[a[i]+1][b[i]-1]){\n\t\t\t\tcout << -1 << endl; return 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tLL ans = 0;\n\tfor(int i = 0; i < 210000; i++){\n\t\txval.clear();\n\t\tfreq.clear();\n\t\tfor(map<int, int>::iterator it = l[i].begin(); it != l[i].end(); it++){\n\t\t\txval.push_back(it->first);\n\t\t\tfreq.push_back(it->second);\n\t\t}\n\t\tint l = 0;\n\t\tfor(int j = 0; j < xval.size(); j++){\n\t\t\tint numl = freq[j];\n\t\t\tint numd = freq[j];\n\t\t\tnuml -= l;\n\t\t\tint xc = xval[j];\n\t\t\tint yc = i-xval[j];\n\t\t\tif(xc == 0) numl = 0;\n\t\t\tif(yc == 0) numd = 0;\n\t\t\tif(d[xc-1][yc-1]){\n\t\t\t\tint r = min(numl,numd);\n\t\t\t\tnuml -= r;\n\t\t\t\tnumd -= r;\n\t\t\t\tans += r;\n\t\t\t}\n\t\t\tans += numl;\n\t\t\tl = numd;\n\t\t\tans += numd;\n\t\t\tif(j + 1 == xval.size() || xval[j+1] != xval[j] + 1) l = 0;\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nconst int MAXN = 100001;\nint ans, a[MAXN], b[MAXN], u[MAXN];\n\nvoid no() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nset<pii> S;\n\nvoid ch(bool x) {\n\tif (!x) no();\n}\n\nint cc(pii p1, pii p2) {\n\tif (p1.first + p1.second != p2.first + p2.second) return p1.first + p1.second < p2.first + p2.second;\n\treturn p1 < p2;\n}\n\nvoid solve() {\n\tch(a[1] == 0);\n\tch(b[2] == 0);\n\tch(a[2] == b[1]);\n\n\tint d = a[2];\n\tch(d > 0);\n\n\tvector<pii> v;\n\n\tans = n - 1;\n\n\tCL(0, u);\n\tm = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i > 2) ch(a[i] > 0 && b[i] > 0);\n\t\tch(a[i] + b[i] >= d);\n\t\tif (a[i] + b[i] == d && !u[a[i]]) {\n\t\t\tS.insert(pii(a[i], b[i]));\n\t\t\tu[a[i]] = 1; m++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(pii(a[i], b[i]));\n\t\t}\n\t}\n\tch(m == d + 1);\n\tsort(v.begin(), v.end(), cc);\n\n\tset<pii> S2;\n\n\tfor (pii p : v) {\n\t\tif (S.count(pii(p.first - 1, p.second - 1))) { S.insert(p); continue; }\n\t\tif (S.count(pii(p.first, p.second))) { \n\t\t\tif (S.count(p) && S2.count(pii(p.first - 1, p.second + 1))) continue;\n\t\t\tS2.insert(p);  S.insert(p);  ans++; continue;\n\t\t}\n\t\tif (S.count(pii(p.first, p.second - 1))) { ans++; S.insert(p); S2.insert(p);  continue; }\n\t\tif (S.count(pii(p.first - 1, p.second))) { ans++; S.insert(p); S2.insert(p);  continue; }\n\t\t//if (S.count(pii(p.first, p.second - 1)) && S.count(pii(p.first - 1, p.second))) { ans++; S2.insert(p);  S.insert(p); continue; }\n\t\tno();\n\t}\n}\n\nvoid read() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\tcin >> n;\n\tF1(i, n) cin >> a[i] >> b[i];\n}\n\nint main() {\n\tif (1) {\n\t\tread();\n\t\tsolve();\n\t\tcout << ans << endl;\n\t\texit(0);\n\t}\n\n\tF0(it, 10000000) {\n\t\tint edges = 0;\n\t\tn = 5 + rand()%10;\n\t\tvector<int> p(n + 1);\n\t\tvector< vector<int> > d(n + 1, vector<int>(n + 1, inf));\n\t\tF1(i, n) d[i][i] = 0;\n\t\tF1(i, n) p[i] = i;\n\t\tint cnt = n - 1;\n\t\twhile (cnt > 0) {\n\t\t\tint i = rand() % n + 1;\n\t\t\tint j = rand() % n + 1;\n\t\t\tif (i == j) continue;\n\t\t\td[i][j] = d[j][i] = 1;\n\t\t\tedges++;\n\t\t\twhile (i != p[i]) i = p[i];\n\t\t\twhile (j != p[j]) j = p[j];\n\t\t\tif (i != j) {\n\t\t\t\tp[i] = j;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t\tF1(k, n)F1(i, n) F1(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\tF1(i, n) {\n\t\t\tif (d[1][i] >= inf || d[2][i] >= inf) throw 12;\n\t\t\ta[i] = d[1][i];\n\t\t\tb[i] = d[2][i];\n\t\t}\n\n\t\tsolve();\n\t\tif (edges < ans) {\n\t\t\tcout << endl;\n\t\t\tcout << edges << \" \" << ans << endl;\n\t\t\tF1(i, n) cout << a[i] << \" \" << b[i] << endl;\n\t\t\tthrow 12;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve();\nvoid precalc();\nclock_t start;\n//int timer = 1;\n\nint testNumber = 1;\n\nbool todo = true;\n\nint main() {\n#ifdef AIM\n    freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n#else\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    start = clock();\n    int t = 1;\n    cout.sync_with_stdio(0);\n    cin.tie(0);\n    precalc();\n    cout.precision(10);\n    cout << fixed;\n    //cin >> t;\n    int testNum = 1;\n    while (t--) {\n        //cerr << testNum << endl;\n        //cout << \"Case #\" << testNum++ << \": \";\n        solve();\n        ++testNumber;\n        //++timer;\n    }\n\n#ifdef AIM\n    cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n    return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n    if (!w)\n        return 1 % mod;\n    if (w & 1)\n        return q * 1LL * binpow(q, w - 1, mod) % mod;\n    return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n    while (w) {\n        q %= w;\n        swap(q, w);\n    }\n    return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n    return q / gcd(q, w) * w;\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n\n//const int mod = 1000000007;\n\n\nvoid solve() {\n    int n;\n    cin >> n;\n    multiset<pair<int, int>> a;\n    int b, c, d, e;\n    cin >> b >> c >> d >> e;\n    if (b != 0 || e != 0 || c != d) {\n        cout << \"-1\\n\";\n        return;\n    }\n    int dist = c;\n    a.insert({dist, 0});\n    a.insert({0, dist});\n\n    for (int i = 2; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        a.insert({x, y});\n    }\n\n    map<int, int> cnt;\n    int ans = n - 1;\n\n    for (auto item : a) {\n        int diff =  item.first + item.second - dist;\n        if (diff < 0) {\n            cout << \"-1\\n\";\n            return;\n        }\n        if (diff == 0) {\n            cnt[item.first]++;\n            continue;\n        }\n        if (diff == 1) {\n            ++ans;\n            continue;\n        }\n        if (a.find(make_pair(item.first  -1, item.second - 1)) == a.end()) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n\n    for (auto item : cnt) {\n        if (item.first == 0 || item.first == d) {\n            if (item.second != 1) {\n                cout << \"-1\\n\";\n                return;\n            }\n        }\n        ans += item.second - 1;\n    }\n\n    if (cnt.size() != dist + 1) {\n        cout << \"-1\\n\";\n        return;\n    }\n\n    cout << ans << \"\\n\";\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nint n;\npair<int,int> a[maxn];\n\nbool check_1(){\n  if(a[1].first!=0||a[2].second!=0||a[2].first!=a[1].second||a[1].second==0)return false;\n  for(int i=3;i<=n;i++)\n    if(a[i].first==0||a[i].second==0)return false;\n  set<pair<int,int>>st;\n  for(int i=1;i<=n;i++)st.insert(a[i]);\n  for(int i=3;i<=n;i++){\n    int cnt=0;\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first-1,a[i].second+j))!=st.end()){\n        cnt++;\n        break;\n      }\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first+j,a[i].second-1))!=st.end()){\n        cnt++;\n        break;\n      }\n      if(cnt<2)return false;\n  }\n  return true;\n}\n\nbool cmp(pair<int,int> a,pair<int,int> b){\n  int ta = a.first + a.second;\n  int tb = b.first + b.second;\n  return ta == tb ? a.first < b.first: ta < tb;\n}\n\nint cal(){\n  int ret=0;\n  sort(a+1,a+n+1,cmp);\n  map<pair<int,int>,int>mp,f;\n  //map<pair<int,int>,int>f[2];\n  for(int i=1;i<=n;i++){\n    int pos = i;\n    vector<pair<int,int>>v;\n    v.push_back(a[i]);\n    for(int j = i;j<=n;j++){\n      if(a[j].first + a[j].second!=a[i].first + a[i].second)break;\n      pos = j;\n      if(mp.find(a[j])==mp.end())mp[a[j]]=1;\n      else mp[a[j]]+=1;\n      f[a[j]]=mp[a[j]];\n      //f[0][a[j]] = f[1][a[j]] = -1;\n      if(j>i&&a[j]!=a[i])v.push_back(a[j]);\n    }/*\n    f[0][v[0]]=0;\n    if(mp.find(make_pair(v[0].first-1,v[0].second-1))!=mp.end()){\n      f[1][v[0]] = mp[v[0]];\n    }\n    for(int j=0;j+1<v.size();j++){\n      if(f[0][v[j]]!=-1){\n        if(v[j].first == v[j+1].first - 1){\n          f[0][v[j+1]] = max(f[0][v[j+1]],f[0][v[j]] + min(mp[v[j]],mp[v[j+1]]));\n        } else {\n          f[0][v[j+1]] = max(f[0][v[j+1]],f[0][v[j]]);\n        }\n        if(mp.find(make_pair(v[j+1].first-1,v[j+1].second-1))!=mp.end()){\n          f[1][v[j+1]] = max(f[1][v[j+1]],f[0][v[j]]+mp[v[j+1]]);\n        }\n      }\n      if(f[1][v[j]]!=-1){\n        f[0][v[j+1]] = max(f[0][v[j+1]],f[1][v[j]]);\n        if(mp.find(make_pair(v[j+1].first-1,v[j+1].second-1))!=mp.end()){\n          f[1][v[j+1]] = max(f[1][v[j+1]],f[1][v[j]]+mp[v[j+1]]);\n        }\n      }\n    }\n    ret += max(0, max(f[0][v[v.size()-1]],f[1][v[v.size()-1]]));\n    */\n    for(int j=1;j<v.size();j++){\n      if(v[j-1].first+1==v[j].first){\n        int tt =min(mp[v[j-1]],mp[v[j]]);\n        ret+=tt;\n        f[v[j-1]] = min(f[v[j-1]],mp[v[j-1]]-tt);\n        f[v[j]] = min(f[v[j]],mp[v[j]]-tt);\n      }\n    }\n    for(int i=0;i<v.size();i++){\n      if(mp.find(make_pair(v[i].first-1,v[i].second-1))!=mp.end()){\n        ret+=f[v[i]];\n      }\n    }\n    i =pos;\n  }\n  return ret;\n}\n\nint main() {\n  //  freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    if(!check_1()){\n      cout<<-1<<endl;\n      return 0;\n    }\n    cout<<2*n-2-cal()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\nlong long A[100005];\nlong long B[100005];\nint main(){\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i] >> B[i];\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n\nusing namespace std;\n\nmap <pair<int, int>, int> mp[200000];\n\nbool check(pair<int, int> p, int da, int db) {\n    int a = p.first + da;\n    int b = p.second + db;\n    \n    return mp[a + b].count(make_pair(a, b));\n}\n\npair<int, int> before(pair<int, int> p, int c) {\n    int m1, m2;\n    \n    if (check(p, -1, -1)) {\n        m1 = c;\n    } else if (check(p, -1, 0) && check(p, 0, -1)) {\n        m1 = c * 2;\n    } else {\n        m1 = 1e9;\n    }\n    \n    if (check(p, -1, 0)) {\n        m2 = c;\n    } else {\n        m2 = 1e9;\n    }\n    \n    return make_pair(m1, m2);\n}\n\nint solve() {\n    int n, d, m = 0, ans = 0, i;\n    map <pair<int, int>, int>::iterator it, it2;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) {\n        int a, b;\n        \n        scanf(\"%d %d\", &a, &b);\n        \n        if (i == 0) {\n            if (a != 0 || b == 0) return -1;\n            \n            d = b;\n        } else if (i == 1) {\n            if (a != d || b != 0) return -1;\n        } else {\n            if (a == 0 || b == 0 || a + b < d) return -1;\n            \n            m = max(m, a + b);\n        }\n        \n        mp[a + b][make_pair(a, b)]++;\n    }\n    \n    for (it = mp[d].begin(); it != mp[d].end(); it++) {\n        if (it == mp[d].begin()) continue;\n        \n        it2 = it;\n        it2--;\n        \n        if (it2->first.first + 1 != it->first.first) return -1;\n        \n        ans += max(it->second, it2->second);\n    }\n    \n    for (i = d + 1; i <= m; i++) {\n        pair <int, int> p;\n        \n        if (mp[i].size() == 0) return -1;\n        \n        for (it = mp[i].begin(); it != mp[i].end(); it++) {\n            if (it == mp[i].begin()) {\n                p = before(it->first, it->second);\n            } else {\n                it2 = it;\n                it2--;\n                \n                if (it2->first.first + 1 != it->first.first) {\n                    if (p.first >= 1e9) return -1;\n                    \n                    ans += p.first;\n                    p = before(it->first, it->second);\n                } else {\n                    int m1 = 1e9, m2 = 1e9, c = max(it->second, it2->second);\n                    \n                    if (check(it->first, -1, -1)) m1 = min(m1, min(p.first + it->second, p.second + c + it->second));\n                    if (check(it->first, 0, -1)) m1 = min(m1, min(p.first + c + it->second, p.second + c + it->second));\n                    if (check(it->first, -1, 0) && check(it->first, 0, -1)) m1 = min(m1, p.first + it->second * 2);\n                    \n                    m2 = min(m2, min(p.first + c, p.second + c));\n                    if (check(it->first, -1, 0)) m2 = min(m2, p.second + it->second);\n                    \n                    p = make_pair(m1, m2);\n                }\n            }\n        }\n        \n        if (p.first >= 1e9) return -1;\n        ans += p.first;\n    }\n    \n    return ans;\n}\n\nint main() {\n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define N 100005\n#define fr first\n#define se second\n#define check(x,y) (mp.find(make_pair(x,y))!=mp.end())\nusing namespace std;\nstruct msg{\n\tint x,y,num;\n};\npii v[N];\nvector<msg> b[N*2];\nmap<pii,int > mp;\nmap<pii,int >::iterator itr;\nint dp[N][2];\nint n,ans,d;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&v[i].first,&v[i].se),mp[v[i]]++;\n\td=v[1].se;\n\tfor(itr=mp.begin();itr!=mp.end();itr++){\n\t\tb[(itr->fr).fr+(itr->fr).se].push_back((msg){(itr->fr).fr,(itr->fr).se,itr->se});\n\t}\n\tfor(int i=0;i<d;i++) if(b[i].size()>0) return puts(\"-1\"),0;\n\tif(mp[v[1]]!=1||mp[v[2]]!=1||v[1].fr!=0||v[2].se!=0||v[1].se!=v[2].fr) return puts(\"-1\"),0;\n\t\n\tfor(int i=d;i<=n*2;i++){\n\t\tfor(int j=0;j<b[i].size();j++){\n\t\t\tdp[j][0]=dp[j][1]=0x3f3f3f3f;\n\t\t\tif(j==0){\n\t\t\t\tif(i==d) {dp[j][0]=0;continue;}\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)){\n\t\t\t\t\tdp[j][0]=dp[j][1]=b[i][j].num;\n\t\t\t\t}else if(check(b[i][j].x-1,b[i][j].y)){\n\t\t\t\t\tdp[j][0]=b[i][j].num;\n\t\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\t\tdp[j][1]=b[i][j].num*2;\n\t\t\t\t}else return puts(\"-1\"),0;\n\t\t\t}else{\n\t\t\t\tint temp=0x3f3f3f3f;\n\t\t\t\tif(b[i][j-1].x+1==b[i][j].x)\n\t\t\t\t\ttemp=dp[j-1][0]+max(b[i][j].num,b[i][j-1].num);\n\t\t\t\telse if(check(b[i][j].x-1,b[i][j].y))\n\t\t\t\t\ttemp=dp[j-1][1]+b[i][j].num;\n\t\t\t\tdp[j][0]=temp;\n\t\t\t\t\n\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\ttemp+=b[i][j].num;\n\t\t\t\telse temp=0x3f3f3f3f;\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)) temp=min(temp,min(dp[j-1][1],dp[j][0])+b[i][j].num);\n\t\t\t\tdp[j][0]=min(dp[j][0],dp[j][1]=temp);\n\t\t\t}\n\t\t}\n\t\tif(i==d) ans+=dp[b[i].size()-1][0];\n\t\telse ans+=dp[b[i].size()-1][1];\n\t\tif(ans>1e9) return puts(\"-1\"),0;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n\nusing namespace std;\n\nmap <pair<int, int>, int> mp[200000];\n\nbool check(pair<int, int> p, int da, int db) {\n    int a = p.first + da;\n    int b = p.second + db;\n    \n    if (a + b < 0) return false;\n    \n    return mp[a + b].count(make_pair(a, b));\n}\n\nbool before(pair<int, int> p) {\n    return check(p, -1, -1) || check(p, -1, 0) || check(p, -1, 1);\n}\n\nbool after(pair<int, int> p) {\n    return check(p, -1, -1) || check(p, 0, -1) || check(p, 1, -1);\n}\n\nint solve() {\n    int n, d, ans, i;\n    map <pair<int, int>, int>::iterator it, it2;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) {\n        int a, b;\n        \n        scanf(\"%d %d\", &a, &b);\n        \n        if (i == 0) {\n            if (a != 0 || b == 0) return -1;\n            \n            d = b;\n        } else if (i == 1) {\n            if (a != d || b != 0) return -1;\n        } else {\n            if (a == 0 || b == 0 || a + b < d) return -1;\n        }\n        \n        mp[a + b][make_pair(a, b)]++;\n    }\n    \n    ans = n * 2 - 2;\n    \n    for (i = d; i < n * 2; i++) {\n        int c;\n        \n        if (mp[i].size() == 0) continue;\n        \n        for (it = mp[i].begin(); it != mp[i].end(); it++) {\n            int c2 = it->second;\n            \n            if (!before(it->first) && it->first.first > 0) return -1;\n            if (!after(it->first) && it->first.second > 0) return -1;\n            \n            if (it != mp[i].begin()) {\n                it2 = it;\n                it2--;\n                \n                if (it2->first.first + 1 == it->first.first) {\n                    ans -= min(it->second, c);\n                    c2 -= min(it->second, c);\n                }\n            }\n            \n            if (check(it->first, -1, -1)) {\n                ans -= c2;\n                c = it->second - c2;\n            } else {\n                c = it->second;\n            }\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010];\nint L;\nint did[101010],elim[101010];\nint ok[101010];\n\nset<pair<int,int>> S;\nset<pair<int,int>> dup;\nvector<pair<int,int>> V[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tif(i>1) {\n\t\t\tif(dup.count({A[i],B[i]})) {\n\t\t\t\tdid[i]=elim[i]=1;\n\t\t\t}\n\t\t\tdup.insert({A[i],B[i]});\n\t\t}\n\t}\n\t\n\tif(A[0]!=0) return _P(\"-1\\n\");\n\tif(B[1]!=0) return _P(\"-1\\n\");\n\tif(A[1]!=B[0]) return _P(\"-1\\n\");\n\tL=A[1];\n\tok[0]=ok[L]=1;\n\tdid[0]=did[1]=1;\n\t\n\tS.insert({0,L});\n\tS.insert({L,0});\n\tint ret=L;\n\tfor(i=2;i<N;i++) {\n\t\tif(did[i]) continue;\n\t\tif(A[i]==0 || B[i]==0) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<L) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]==L && ok[A[i]]==0) {\n\t\t\tdid[i]=1;\n\t\t\tok[A[i]]=1;\n\t\t\tS.insert({A[i],B[i]});\n\t\t}\n\t\telse {\n\t\t\tV[A[i]+B[i]].push_back({A[i],i});\n\t\t}\n\t}\n\tFOR(i,L+1) if(ok[i]==0) return _P(\"-1\\n\");\n\tfor(i=L;i<=200000;i++) if(V[i].size()) {\n\t\tsort(ALL(V[i]));\n\t\tFOR(j,4) {\n\t\t\tFORR(r,V[i]) {\n\t\t\t\tx = r.second;\n\t\t\t\tif(did[x]) continue;\n\t\t\t\tif(S.count({A[x]-1,B[x]-1})) ret++;\n\t\t\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdid[x]=1;\n\t\t\t\tS.insert({A[x],B[x]});\n\t\t\t}\n\t\t\t\n\t\t\ty=-1;\n\t\t\t\n\t\t\tFOR(x,V[i].size()) {\n\t\t\t\tif(x>0 && abs(V[i][x].first-V[i][x-1].first)>1) y=-1;\n\t\t\t\t\n\t\t\t\tif(did[V[i][x].second]) {\n\t\t\t\t\tif(y>=0 && y-x>1) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t\twhile(y<x) {\n\t\t\t\t\t\t\tdid[V[i][y].second]=1;\n\t\t\t\t\t\t\tS.insert({A[V[i][y].second],B[V[i][y].second]});\n\t\t\t\t\t\t\tret++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ty=x;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treverse(ALL(V[i]));\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tFOR(x,N) if(elim[x]==1) {\n\t\tif(S.count({A[x]-1,B[x]-1})) ret++;\n\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\telse return _P(\"-1\\n\");\n\t}\n\tFOR(i,N) if(did[i]==0) return _P(\"-1\\n\");\n\t_P(\"%d\\n\",ret);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 10;\nint ds[2][maxn];\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &ds[0][i], &ds[1][i]);\n  }\n  return 1;\n}\n\nvoid solve() {\n  if (ds[0][0] || ds[1][1]) {\n    printf(\"-1\\n\");\n    return;\n  }\n  int d = ds[0][1];\n  if (ds[1][0] != d) {\n    printf(\"-1\\n\");\n    return;\n  }\n  vector<int> big(d + 1, 0);\n\n  vector<int> vs[2][d + 1];\n  for (int v = 0; v < n; ++v) {\n    int left = ds[0][v] + ds[1][v] - d;\n    if (left < 0 || abs(ds[0][v] - ds[1][v]) > d) {\n      printf(\"-1\\n\");\n      return;\n    }\n    if (left > 0) {\n      vs[left & 1][(ds[0][v] - ds[1][v] + d) / 2].pb((left + 1) / 2);\n    } else {\n      big[ds[0][v]] += 1;\n    }\n  }\n  int res = 0;\n  for (int odd = 0; odd < 2; ++odd) {\n    for (int i = 0; i <= d - odd; ++i) {\n      auto &cur = vs[odd][i];\n      sort(cur.begin(), cur.end());\n      int last = 0;\n      for (int i = 0; i < sz(cur);) {\n        int i0 = i;\n        while (i < sz(cur) && cur[i] == cur[i0]) {\n          ++i;\n        }\n        //eprintf(\"%dx  %d\\n\", i - i0, cur[i0]);\n        if (cur[i0] != last + 1) {\n          printf(\"-1\\n\");\n          return;\n        }\n        res += i - i0;\n        if (odd && cur[i0] == 1) {\n          res += i - i0;\n        }\n        ++last;\n      }\n    }\n  }\n  if (big[0] != 1 || big[d] != 1) {\n    printf(\"-1\\n\");\n    return;\n  }\n  for (int i = 1; i < d; ++i) {\n    if (big[i] == 0) {\n      printf(\"-1\\n\");\n      return;\n    }\n  }\n  for (int i = 0; i < d; ++i) {\n    res += max(big[i], big[i + 1]);\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\tvector<pair<int, int> > A;\n\tfor(int i=0; i<N; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tA.emplace_back(a, b);\n\t}\n\tif(A[0].first!=0 || A[1].second!=0 || A[1].first!=A[0].second) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint ab = A[0].second;\n\tint sum = ab;\n\t{\n\t\tvector<int> vec(ab+1);\n\t\tfor(auto & p : A) {\n\t\t\tif(p.first+p.second==ab) {\n\t\t\t\t++vec[p.first];\n\t\t\t}\n\t\t\tif(p.first+p.second<ab) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(vec[0]!=1 || vec[ab]!=1) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i : vec) {\n\t\t\tif(i==0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(2<=i) {\n\t\t\t\tsum += (i-1)*2;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tvector<pair<int, int> > vec;\n\t\tvector<pair<int, int> > vec2;\n\t\tfor(auto & p : A) {\n\t\t\tif(ab<p.first+p.second) {\n\t\t\t\tint aa = p.first+p.second - ab;\n\t\t\t\tint aaHalf = (aa+1)>>1;\n\t\t\t\tint aaa = p.first-aaHalf;\n\t\t\t\tif(aa&1) {\n\t\t\t\t\tvec2.emplace_back(p.first-aaHalf, aaHalf);\n\t\t\t\t\t++sum;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvec.emplace_back(p.first-aaHalf, aaHalf);\n\t\t\t\t\t++sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\tsort(vec2.begin(), vec2.end());\n\t\t{\n\t\t\tint beforeF = -1;\n\t\t\tint beforeS = 0;\n\t\t\tfor(auto & p : vec) {\n\t\t\t\tif(p.first!=beforeF) {\n\t\t\t\t\tbeforeF = p.first;\n\t\t\t\t\tbeforeS = 0;\n\t\t\t\t}\n\t\t\t\tif(p.second!=beforeS && p.second!=beforeS+1) {\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbeforeS = p.second;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint beforeF = -10;\n\t\t\tint beforeS = 0;\n\t\t\tfor(auto & p : vec2) {\n\t\t\t\tif(p.first!=beforeF) {\n\t\t\t\t\tif(p.first!=beforeF+1) {\n\t\t\t\t\t\t++sum;\n\t\t\t\t\t}\n\t\t\t\t\tbeforeF = p.first;\n\t\t\t\t\tbeforeS = 0;\n\t\t\t\t}\n\t\t\t\tif(p.second!=beforeS && p.second!=beforeS+1) {\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbeforeS = p.second;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MX = 120000;\n\nint n;\nint a[MX];\nint b[MX];\nvector<int> go[MX];\n\nset<pair<int, int> > ss;\nset<pair<int, int> > sst;\nset<pair<int, int> > ss2;\nset<pair<int, int> > ss2t;\n\nvector<pair<int, int> > ed;\nvector<int> vv;\nmap<pair<int, int>, int> mm;\n\nvoid ex() {\n//\tif (n != 3)\n//\t\tassert(false);\n\tcout << -1 << \"\\n\";\n\texit(0);\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i] >> b[i];\n\tif (a[0] != 0 || b[1] != 0)\n\t\tex();\n\tfor (int i = 0; i < n; ++i) {\n\t\tgo[a[i]].push_back(i);\n\t}\n\tif ((int)go[0].size() != 1)\n\t\tex();\n\tss.insert(make_pair(b[0], 0));\n\tss2.insert(make_pair(b[0], 0));\n\tfor (int i = 0; i < n; ++i)\n\t\tmm[make_pair(a[i], b[i])] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tsst.clear();\n\t\tss2t.clear();\n\t\tfor (int j: go[i]) {\n\t\t\tauto it = ss.lower_bound(make_pair(b[j] + 1, 0));\n\t\t\tss2t.insert(make_pair(b[j], j));\n\t\t\tif (it != ss.end() && it->first == b[j] + 1) {\n\t\t\t\ted.push_back(make_pair(j, it->second));\n\t\t\t\tss.erase(it);\n\t\t\t\tsst.insert(make_pair(b[j], j));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tauto it = ss2.lower_bound(make_pair(b[j] - 1, 0));\n\t\t\t\tif (it != ss2.end() && it->second <= b[j] + 1) {\n\t\t\t\t\tif (it->first != b[j] - 1)\n\t\t\t\t\t\tsst.insert(make_pair(b[j], j));\n\t\t\t\t\ted.push_back(make_pair(j, it->second));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tex();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto j: ss)\n\t\t\tvv.push_back(j.second);\n\t\tswap(ss, sst);\n\t\tswap(ss2, ss2t);\n\t}\n\tfor (int j: vv) {\n\t\tif (j == 1)\n\t\t\tcontinue;\n\t\tint fl = 0;\n\t\tfor (int d = -1; d <= 1; ++d) {\n\t\t\tif (mm.count(make_pair(a[j] + d, b[j] - 1))) {\n\t\t\t\tfl = 1;\n\t\t\t\ted.push_back(make_pair(mm[make_pair(a[j] + d, b[j] - 1)], j));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!fl) {\n\t\t\tex();\n\t\t}\n\t}\n\tcout << ed.size() << \"\\n\";\n\t/*for (auto j: ed) {\n\t\tcout << j.first + 1 << \" \" << j.second + 1 << \"\\n\";\n\t}*/\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n\nusing namespace std;\n\nmap <pair<int, int>, int> mp[200000];\n\nbool check(pair<int, int> p, int da, int db) {\n    int a = p.first + da;\n    int b = p.second + db;\n    \n    if (a + b < 0) return false;\n    \n    return mp[a + b].count(make_pair(a, b));\n}\n\nbool before(pair<int, int> p) {\n    return check(p, -1, -1) || check(p, -1, 0) || check(p, -1, 1);\n}\n\nbool after(pair<int, int> p) {\n    return check(p, -1, -1) || check(p, 0, -1) || check(p, 1, -1);\n}\n\nint solve() {\n    int n, d, ans, i;\n    map <pair<int, int>, int>::iterator it, it2;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) {\n        int a, b;\n        \n        scanf(\"%d %d\", &a, &b);\n        \n        if (i == 0) {\n            if (a != 0 || b == 0) return -1;\n            \n            d = b;\n        } else if (i == 1) {\n            if (a != d || b != 0) return -1;\n        } else {\n            if (a == 0 || b == 0 || a + b < d) return -1;\n        }\n        \n        mp[a + b][make_pair(a, b)]++;\n    }\n    \n    ans = n * 2 - 2;\n    \n    for (i = d; i < n * 2; i++) {\n        int c;\n        \n        if (mp[i].size() == 0) continue;\n        \n        for (it = mp[i].begin(); it != mp[i].end(); it++) {\n            if (!before(it->first) && it->first.first > 0) return -1;\n            if (!after(it->first) && it->first.second > 0) return -1;\n            \n            if (it != mp[i].begin()) {\n                it2 = it;\n                it2--;\n                \n                if (it2->first.first + 1 == it->first.first) {\n                    ans -= min(it->second, c);\n                    it->second = max(it->second - c, 0);\n                } else if (i == d) {\n                    return -1;\n                }\n            }\n            \n            if (check(it->first, -1, -1)) {\n                ans -= it->second;\n                c = 0;\n            } else {\n                c = it->second;\n            }\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nvoid no(){\n  cout<<-1<<endl;\n  exit(0);\n}\nVI a,b;\nvector<set<in> > cna,cnb;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n;\n  cin>>n;\n  a.resize(n);\n  b.resize(n);\n  forn(i,n)\n    cin>>a[i]>>b[i];\n  if(a[0]!=0 || b[1]!=0)\n    no();\n  forn(i,n){\n    if(i!=0 && a[i]==0)\n      no();\n    if(i!=1 && b[i]==0)\n      no();\n  }\n  if(a[1]!=b[0])\n    no();\n  cna.resize(n+1);\n  cnb.resize(n+1);\n  forn(i,n){\n    cna[a[i]].insert(b[i]);\n    cnb[b[i]].insert(a[i]);\n  }\n  in sm=0;\n  forn(i,n){\n    if(i>=2){\n      if(cna[a[i]-1].count(b[i]-1)){\n\t++sm;\n\tcontinue;\n      }\n    }\n    if(i!=0){\n      if(!cna[a[i]-1].count(b[i]) && !cna[a[i]-1].count(b[i]+1))\n\tno();\n    }\n    if(i!=1){\n      if(!cnb[b[i]-1].count(a[i]) && !cnb[b[i]-1].count(a[i]+1))\n\tno();\n    }\n    sm+=2;\n  }\n  sm-=3;\n  cout<<sm<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main() {\n  int N; scanf(\"%d\", &N);\n  static int A[100000], B[100000];\n  static pair<int, int> ABtbl[100000];\n  static pair<int, int> BAtbl[100000];\n  for(int i = 0; i < N; ++i) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n    ABtbl[i] = make_pair(A[i], B[i]);\n    BAtbl[i] = make_pair(B[i], A[i]);\n  }\n  if(A[0] != 0 || B[1] != 0 || A[1] == 0 || A[1] != B[0]) {\n    printf(\"%d\\n\", -1);\n    return 0;\n  }\n  sort(ABtbl, ABtbl+N);\n  sort(BAtbl, BAtbl+N);\n  for(int i = 0; i < N; ++i) {\n    if(i != 0 &&\n        lower_bound(ABtbl, ABtbl+N, make_pair(A[i]-1, B[i]-1))\n        == upper_bound(ABtbl, ABtbl+N, make_pair(A[i]-1, B[i]+1))) {\n      printf(\"%d\\n\", -1);\n      return 0;\n    }\n    if(i != 1 &&\n        lower_bound(BAtbl, BAtbl+N, make_pair(B[i]-1, A[i]-1))\n        == upper_bound(BAtbl, BAtbl+N, make_pair(B[i]-1, A[i]+1))) {\n      printf(\"%d\\n\", -1);\n      return 0;\n    }\n  }\n  int count = 2 * (N-1);\n  for(int ii = 0; ii < N; ++ii) {\n    if(ii > 0 && ABtbl[ii-1] == ABtbl[ii]) continue;\n    int a = ABtbl[ii].first;\n    int b = ABtbl[ii].second;\n    if(lower_bound(ABtbl, ABtbl+N, make_pair(a-1, b+1))\n        < upper_bound(ABtbl, ABtbl+N, make_pair(a-1, b+1))) {\n      continue;\n    }\n    int have =\n      upper_bound(ABtbl, ABtbl+N, make_pair(a, b))\n        - lower_bound(ABtbl, ABtbl+N, make_pair(a, b));\n    int rem = have;\n    while(true) {\n      int capa = have;\n      if(lower_bound(ABtbl, ABtbl+N, make_pair(a-1, b-1))\n          < upper_bound(ABtbl, ABtbl+N, make_pair(a-1, b-1))) {\n        // fprintf(stderr, \"(%d, %d) -- %d recyclable edges to (%d, %d)\\n\",\n        //     a, b, rem, a-1, b-1);\n        count -= rem;\n        capa -= rem;\n      }\n      ++a;\n      --b;\n      have =\n        upper_bound(ABtbl, ABtbl+N, make_pair(a, b))\n          - lower_bound(ABtbl, ABtbl+N, make_pair(a, b));\n      if(have == 0) break;\n      // fprintf(stderr, \"(%d, %d) -- %d recyclable edges to (%d, %d)\\n\",\n      //     a-1, b+1, min(capa, have), a, b);\n      count -= min(capa, have);\n      rem = have - min(capa, have);\n    }\n  }\n  printf(\"%d\\n\", count);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nbool solve(vector<int> &A, vector<int>& B, int &res) {\n\tif(A[0] != 0) return false;\n\tif(B[1] != 0) return false;\n\tif(A[1] != B[0]) return false;\n\tint d = A[1];\n\t\n\tint N = A.size();\n\tvector<int> minimcnt(d+1, 0);\n\tfor(int i=0; i<N; i++) {\n\t\tif(A[i] + B[i] == d) {\n\t\t\tminimcnt[A[i]] ++;\n\t\t}\n\t\tif(A[i] + B[i] < d) return false;\n\t}\n\tfor(int i=0; i<=d; i++) {\n\t\tif(minimcnt[i] == 0) return false;\n\t} \n\tif(minimcnt[0] > 1) return false;\n\tif(minimcnt[d] > 1) return false;\n\t\n\tmap<int, vector<int> > data;\n\t\n\tfor(int i=0; i<N; i++) {\n\t\tint dist = B[i] - A[i];\n\t\tint sum = A[i] + B[i];\n\t\tif(abs(dist) > d) return false;\n\t\t\n\t\tif(sum>d)\n\t\t\tdata[dist].push_back(sum);\n\t}\n\t\n\tint ans = 0;\n\t\n\tfor(int i=0; i<d; i++) {\n\t\tans += max(minimcnt[i], minimcnt[i+1]);\n\t}\n//\tcout << ans << endl;\n\tvector<int> cnt(d+1, 0);\n\tfor(int k=-d; k<=d; k++) {\n\t//\tcout << data[k].size() << endl;\n\t\tif(data[k].size() == 0) continue;\n\t\t/*\n\t\tif(abs(d - k) % 2 == 1) {\n\t\t\tans += 2;\n\t\t}*/\n//\t\tans += data[k].\n\t\tsort(data[k].begin(), data[k].end());\n\t\tint init = data[k][0];\n\t\tif( (init - d) > 2) return false;\n\t\t\n\t\t\n\t\tfor(int i=1; i<data[k].size(); i++) {\n\t\t\tif(data[k][i] - data[k][i-1] > 2) return false;\n\t\t}\n\t\tfor(int i=0; i<data[k].size(); i++) {\n\t\t\tif(data[k][i] == init) {\n\t\t\t\t//ans += 2;\n\t\t\t\tif(abs(d-k)%2==0) ans++;\n\t\t\t\telse {\n\t\t\t\t\tcnt[(k+d)/2]++;\n//\t\t\t\t\tcout << \"    \" << k << \" \" << d << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse ans += 1;\n\t\t}\n\t}\n\tfor(int i=0; i<cnt.size()-1; i++) {\n\t\tans += max(cnt[i], cnt[i+1]);\n//\t\tcout << cnt[i] << \" \" << cnt[i+1] << endl;\n\t}\n\tans += cnt[0] + cnt.back();\n\t\n\t\n\tres = ans;\n}\n\n\n\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<int> A, B;\n\tfor(int i=0; i<N; i++) {\n\t\tint p,q;\n\t\tcin >> p >> q;\n\t\tA.push_back(p);\n\t\tB.push_back(q);\n\t}\n\tint res = 0;\n\tbool ans = solve(A, B, res);\n\tif(ans) {\n\t\tcout << res << endl;\n\t}\n\telse  {\n\t\tcout << -1 << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\tvector<pair<int, int> > A;\n\tfor(int i=0; i<N; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tA.emplace_back(a, b);\n\t}\n\tif(A[0].first!=0 || A[1].second!=0 || A[1].first!=A[0].second) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint ab = A[0].second;\n\tint sum = ab;\n\t{\n\t\tvector<int> vec(ab+1);\n\t\tfor(auto & p : A) {\n\t\t\tif(p.first+p.second==ab) {\n\t\t\t\t++vec[p.first];\n\t\t\t}\n\t\t\tif(p.first+p.second<ab) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(vec[0]!=1 || vec[ab]!=1) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i : vec) {\n\t\t\tif(i==0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(2<=i) {\n\t\t\t\tsum += (i-1)*2;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tvector<pair<int, int> > vec;\n\t\tfor(auto & p : A) {\n\t\t\tif(ab<p.first+p.second) {\n\t\t\t\tint aa = p.first+p.second - ab;\n\t\t\t\tint aaHalf = (aa+1)>>1;\n\t\t\t\tint aaa = p.first-aaHalf;\n\t\t\t\tif(aa&1) {\n\t\t\t\t\tvec.emplace_back(ab + ab + p.first-aaHalf, aaHalf);\n\t\t\t\t\t++sum;\n\t\t\t\t\tif(aaHalf==1) {\n\t\t\t\t\t\t++sum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvec.emplace_back(p.first-aaHalf, aaHalf);\n\t\t\t\t\t++sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\tint beforeF = -1;\n\t\tint beforeS = 0;\n\t\tfor(auto & p : vec) {\n\t\t\tif(p.first!=beforeF) {\n\t\t\t\tbeforeF = p.first;\n\t\t\t\tbeforeS = 0;\n\t\t\t}\n\t\t\tif(p.second!=beforeS && p.second!=beforeS+1) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbeforeS = p.second;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\nbool comp (pair<int,int> a, pair<int,int>b){\n    return a.FI+a.SE<b.FI+b.SE or (a.FI+a.SE==b.FI+b.SE and a.FI<b.FI);\n}\nint cnt(multiset<pair<int,int>> &s, int a, int b){\n    return s.count(make_pair(a,b));\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,dmax=0;\n    cin >> n;\n    vector<pair<int,int>> d;\n    multiset<pair<int,int>> s;\n    REP(i,n){\n        int a,b;\n        cin >> a>>b;\n        //dmax=max(dmax,a+b);\n        s.insert(make_pair(a,b));\n        d.push_back(make_pair(a,b));\n    }\n    if(d[0].FI!=0 or d[1].SE!=0 or d[1].FI!=d[0].SE or d[0].SE==0){\n        cout << -1 << endl; return 0;\n    }\n    FOR(i,2,n){\n        if(d[i].FI==0 or d[i].SE==0){\n            cout << -1 << endl; return 0;\n        }\n    }\n    FOR(i,1,d[0].SE){\n        if(cnt(s,i,d[0].SE-i)==0){\n            cout << -1 << endl; return 0;\n        }\n    }\n    //0~1\n    int ans=cnt(s,1,d[0].SE-1);\n\n    FOR(i,1,d[0].SE){\n        ans+=max(cnt(s,i,d[0].SE-i),cnt(s,i+1,d[0].SE-i-1));\n    }\n    sort(d.begin(),d.end());\n    d.erase(unique(ALL(d)),d.end());\n    sort(d.begin(),d.end(),comp);\n    bool succ=false;\n    for(auto it=lower_bound(ALL(d),make_pair(1,d[0].SE),comp); it<d.end();it++){\n        int d0=it->FI,d1=it->SE,add=0;\n        //DBG(ans)\n        //cout << d0 << ' ' <<d1  <<' '<<succ<<endl;\n        if(succ){\n            add=cnt(s,d0-1,d1+1);\n            if(cnt(s,d0+1,d1-1)){\n                add=max(add,cnt(s,d0,d1));\n                continue;\n            }\n            else if(cnt(s,d0-1,d1-1)){\n                add+=cnt(s,d0,d1);\n                succ =false;\n            }else if(cnt(s,d0,d1-1)){\n                add=max(add,cnt(s,d0,d1))+cnt(s,d0,d1);\n                succ=false;\n            }else {\n                cout << -1 << endl; return 0;\n            }\n        }else if(cnt(s,d0-1,d1-1)){\n            ans+=cnt(s,d0,d1);\n        }else if(cnt(s,d0-1,d1)or cnt(s,d0-1,d1+1)){\n            ans+=cnt(s,d0,d1);\n            if(cnt(s,d0+1,d1-1)){\n                succ=true;\n                continue;\n            }else if(cnt(s,d0,d1-1)){\n                ans+= cnt(s,d0,d1);\n            }else{\n                cout << -1 << endl; return 0;\n            }\n        }else{\n            cout << -1 << endl; return 0;\n        }\n        ans+=add;\n    }\n\n    cout << ans <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <numeric>\n#include <limits>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define tr(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n\nint N;\nint A[100010], B[100010];\nbool hige[100010];\n\nmap<pair<int, int>, int> cnt;\n\nvoid dmp() {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  rep (i, N) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n\n    if ((A[i] == 0) != (i == 0)) dmp();\n    if ((B[i] == 0) != (i == 1)) dmp();\n  }\n\n  int D = B[0];\n  if (A[1] != D) dmp();\n\n  rep (i, N) cnt[mp(A[i], B[i])] += 1;\n  rep (i, N) hige[i] = cnt.count(mp(A[i] - 1, B[i] - 1));\n\n  map<int, map<int, int>> taba;\n  rep (i, N) {\n    if (hige[i]) continue;\n    taba[A[i] + B[i]][A[i]] += 1;\n  }\n\n  for (int d = 0; d < D; ++d) {\n    if (taba.count(d)) dmp();\n  }\n\n  int ans = N - 2;  //count(hige, hige + N, true);\n\n  for (auto &i : taba) {\n    map<int, int> &m = i.second;\n    int d = i.first;\n\n    for (const auto &j : m) {\n      int a = j.first, b = d - a, c = j.second;\n\n      int prv_c = cnt[mp(a - 1, b + 1)];\n      int nxt_c = cnt[mp(a + 1, b - 1)];\n      // printf(\"%d %d: %d %d %d\\n\", a, b, prv_c, c, nxt_c);\n\n      int bgn = max(0, c - prv_c);\n      int end = max(0, c - nxt_c);\n\n      if (bgn > 0) {\n        // printf(\" %d\\n\", bgn);\n        ans += bgn;\n        if (a > 0 && cnt[mp(a - 1, b)] == 0) {\n          //printf(\"%d %d\\n\", a, b);\n          dmp();\n        }\n      }\n      if (end > 0) {\n        if (b > 0 && cnt[mp(a, b - 1)] == 0) {\n          //          printf(\"%d %d\\n\", a, b);\n          dmp();\n        }\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nint N;\nint A[101010],B[101010];\nmap<pair<int,int>,int> S;\nUF<500000> uf;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tif(i!=0 && A[i]==0) return _P(\"-1\\n\");\n\t\tif(i==0 && A[i]) return _P(\"-1\\n\");\n\t\tif(i!=1 && B[i]==0) return _P(\"-1\\n\");\n\t\tif(i==1 && B[i]) return _P(\"-1\\n\");\n\t\tS[{A[i],B[i]}]=i;\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(i!=0) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i]-1,B[i]})) uf(i,S[{A[i]-1,B[i]}]);\n\t\t\tif(S.count({A[i]-1,B[i]+1})) uf(i,S[{A[i]-1,B[i]+1}]);\n\t\t}\n\t\tif(i!=1) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i],B[i]-1})) uf(i,S[{A[i],B[i]-1}]);\n\t\t\tif(S.count({A[i]+1,B[i]-1})) uf(i,S[{A[i]+1,B[i]-1}]);\n\t\t}\n\t}\n\t\n\tif(uf.count(0)!=N) return _P(\"-1\\n\");\n\tassert(0);\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nint N;\nint A[101010],B[101010];\nmap<pair<int,int>,int> S;\nUF<500000> uf;\nmap<int,int> V[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tif(i!=0 && A[i]==0) return _P(\"-1\\n\");\n\t\tif(i==0 && A[i]) return _P(\"-1\\n\");\n\t\tif(i!=1 && B[i]==0) return _P(\"-1\\n\");\n\t\tif(i==1 && B[i]) return _P(\"-1\\n\");\n\t\tS[{A[i],B[i]}]=i;\n\t\tV[A[i]+B[i]][A[i]]++;\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(i!=0) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i]-1,B[i]})) uf(i,S[{A[i]-1,B[i]}]);\n\t\t\tif(S.count({A[i]-1,B[i]+1})) uf(i,S[{A[i]-1,B[i]+1}]);\n\t\t}\n\t\tif(i!=1) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i],B[i]-1})) uf(i,S[{A[i],B[i]-1}]);\n\t\t\tif(S.count({A[i]+1,B[i]-1})) uf(i,S[{A[i]+1,B[i]-1}]);\n\t\t}\n\t}\n\t\n\tif(uf.count(0)!=N) return _P(\"-1\\n\");\n\tint ret=2*N-2;\n\tFOR(i,2*N) if(V[i].size()) {\n\t\tint pre=-2,left=0;\n\t\tFORR(r,V[i]) {\n\t\t\tx = r.second;\n\t\t\tif(r.first==pre+1) {\n\t\t\t\tret -= min(left,x);\n\t\t\t\tx-=min(left,x);\n\t\t\t}\n\t\t\tif(S.count({r.first-1,(i-r.first)-1})) {\n\t\t\t\tret-=x;\n\t\t\t\tleft=0;\n\t\t\t}\n\t\t\tpre=r.first;\n\t\t\tleft=x;\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n \nset<pair<int,int>> st;\npair<int,int> a[maxn];\nbool vis[maxn];\nint n;\n \nbool cmp(pair<int,int>a,pair<int,int>b) {\n    return a.first + a.second == b.first + b.second ?\n           a.first < b.first : a.first + a.second < b.first + b.second;\n}\n \nbool check_1() {\n    if(a[1].first!=0||a[2].second!=0||a[1].second!=a[2].first)return false;\n    for(int i=3;i<=n;i++)\n      if(a[i].first==0||a[i].second==0)return false;\n    return true;\n}\n \nbool check_2(int&ret) {\n    if(n>2)sort(a+3,a+n+1, cmp);\n    if(a[1].second==0)return false;\n    vis[1] = vis[2] = 1;\n    st.insert(a[1]);\n    st.insert(a[2]);\n    ret += a[1].second;\n    if(a[1].second==1) return true;\n    int cnt = 0;\n    for(int i=3; i<=n; i++) {\n        if(a[i].first + a[i].second != a[1].second) continue;\n        if(st.find(a[i])!=st.end())continue;\n        st.insert(a[i]);\n        vis[i] = 1;\n        cnt++;\n    }\n    return cnt == a[1].second - 1;\n}\n \nbool pd(int x,int y) {\n    int x1 = x - 1, y1, x2, y2 = y - 1;\n    for(int y1 = y-1; y1<=y+1; y1++)\n        for(int x2=x-1; x2<=x+1; x2++) {\n            if(st.find(make_pair(x1,y1))==st.end())continue;\n            if(st.find(make_pair(x2,y2))==st.end())continue;\n            return true;\n        }\n    return false;\n}\n \nbool check_3(int&ret) {\n    for(int i=3; i<=n; i++) {\n        /*if(vis[i])continue;\n        pair<int,int> fa = make_pair(a[i].first-1,a[i].second-1);\n        if(st.find(fa)!=st.end()) {\n            vis[i]=1;\n            ret++;\n            st.insert(a[i]);\n        } else {\n            if(pd(a[i].first,a[i].second)) {\n                vis[i] = 1;\n                ret+=2;\n                st.insert(a[i]);\n            } else return false;\n        }*/\n        int pos = i;\n        for(int j=i;j<=n;j++) {\n          if(a[j].first + a[j].second != a[i].first + a[i].second)break;\n          pos = j;\n        }\n        for(int j=i;j<=pos;j++) {\n          if(vis[j]) continue;\n          if(st.find(make_pair(a[j].first-1,a[j].second-1))!=st.end()) {\n            vis[j] =1;\n            ret++;\n            st.insert(a[j]);\n          }\n        }\n        for(int j=i;j<=pos;j++){\n          if(vis[j])continue;\n          if(pd(a[j].first,a[j].second)){\n            vis[j] =1;\n            ret+=2;\n            st.insert(a[j]);\n          }\n        }\n        for(int j = i+1;j<pos;j++) {\n          if(vis[j])continue;\n          if(vis[j-1]&&vis[j+1]){\n            vis[j]=1;\n            ret+=2;\n            st.insert(a[j]);\n          } else return false;\n        }\n        if((!vis[i]) || (!vis[pos])) return false;\n        i = pos;\n    }\n    return true;\n}\n \nint main() {\n    //freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    int ret = 0;\n    if(!check_1()) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(!check_2(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(!check_3(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    cout<<ret<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef long long LL;\nmap<int, map<int,int> > d; //exists\nmap<int, int> l[210000]; // freq[sum][xval]\nvector<int> xval;// \nvector<int> freq; // \nint n;\nint a[210000], b[210000];\nint main(){\ncout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\nlong long A[100005];\nlong long B[100005];\nint main(){\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i] >> B[i];\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\nbool comp (pair<int,int> a, pair<int,int>b){\n    return a.FI+a.SE<b.FI+b.SE or (a.FI+a.SE==b.FI+b.SE and a.FI<b.FI);\n}\nint cnt(multiset<pair<int,int>> &s, int a, int b){\n    return s.count(make_pair(a,b));\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<pair<int,int>> d;\n    multiset<pair<int,int>> s;\n    REP(i,n){\n        int a,b;\n        cin >> a>>b;\n        s.insert(make_pair(a,b));\n        d.push_back(make_pair(a,b));\n    }\n    if(d[0].FI!=0 or d[1].SE!=0 or d[1].FI!=d[0].SE or d[0].SE==0){\n        cout << -1 << endl; return 0;\n    }\n    FOR(i,2,n){\n        if(d[i].FI==0 or d[i].SE==0){\n            cout << -1 << endl; return 0;\n        }\n    }\n    FOR(i,1,d[0].SE){\n        if(cnt(s,i,d[0].SE-i)==0){\n            cout << -1 << endl; return 0;\n        }\n    }\n    //0~1\n    int ans=cnt(s,1,d[0].SE-1);\n\n    FOR(i,1,d[0].SE){\n        ans+=max(cnt(s,i,d[0].SE-i),cnt(s,i+1,d[0].SE-i-1));\n    }\n    sort(d.begin(),d.end());\n    d.erase(unique(ALL(d)),d.end());\n    sort(d.begin(),d.end(),comp);\n    int v=0;\n    for(auto it=lower_bound(ALL(d),make_pair(1,d[0].SE),comp); it<d.end();it++){\n        int d0=it->FI,d1=it->SE,add=0,now=cnt(s,d0,d1);\n\n        if(v){\n            if(cnt(s,d0-1,d1-1)&&cnt(s,d0+1,d1-1)){\n                add=max(v,now);\n                v=min(v,now);\n            }else if(cnt(s,d0-1,d1-1)){\n                add=v+now;\n                v=0;\n            }else if(cnt(s,d0+1,d1-1)){\n                add=max(v,now);\n                v=now;\n            }else if(cnt(s,d0,d1-1)){\n                add=max(v,now)+now;\n                v=0;\n            }else {\n                cout << -1 << endl; return 0;\n            }\n        }else if(cnt(s,d0-1,d1-1)){\n            add=now;\n        }else if(cnt(s,d0-1,d1)or cnt(s,d0-1,d1+1)){\n            add=now;\n            if(cnt(s,d0+1,d1-1)){\n                v=add;\n            }else if(cnt(s,d0,d1-1)){\n                add*=2;\n            }else{\n                cout << -1 << endl; return 0;\n            }\n        }else{\n            cout << -1 << endl; return 0;\n        }\n        ans+=add;\n    }\n\n    cout << ans <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nconst int MAXN = 100001;\nint ans, a[MAXN], b[MAXN], u[MAXN];\n\nvoid no() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nset<pii> S;\n\nvoid ch(bool x) {\n\tif (!x) no();\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\tcin >> n;\n\tF1(i, n) cin >> a[i] >> b[i];\n\n\tch(a[1] == 0);\n\tch(b[2] == 0);\n\tch(a[2] == b[1]);\n\t\n\tint d = a[2];\n\tch(d > 0);\n\n\tvector<pii> v;\n\n\tans = n - 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i > 2) ch(a[i] > 0 && b[i] > 0);\n\t\tch(a[i] + b[i] >= d);\n\t\tif (a[i] + b[i] == d) {\n\t\t\tif (!u[a[i]]) {\n\t\t\t\tS.insert(pii(a[i], b[i]));\n\t\t\t\tu[a[i]] = 1; m++;\n\t\t\t}\n\t\t\telse ans++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(pii(a[i], b[i]));\n\t\t}\n\t}\n\tch(m == d + 1);\n\tsort(v.begin(), v.end());\n\n\tfor (pii p : v) {\n\t\tif (S.count(pii(p.first - 1, p.second - 1))) continue;\n\t\tif (S.count(pii(p.first, p.second))) { ans++; continue; }\n\t\t//if (S.count(pii(p.first, p.second - 1))) { ans++; S.insert(p); continue; }\n\t\t//if (S.count(pii(p.first - 1, p.second))) { ans++; S.insert(p); continue; }\n\t\tif (S.count(pii(p.first, p.second - 1)) && S.count(pii(p.first - 1, p.second))) { ans++; S.insert(p); continue; }\n\t\tno();\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 100005\n#define M 200005\n#define seed 23333\n\nusing namespace std;\nconst int inf=(int)1e9;\nint i,j,m,n,p,k,A[N],B[N],l;\nmap<pair<int,int>,int>mp;\nvector<int>v[M];\nint f[2][N],ans,sum[N],size[2],now,last;\nint RE()\n{\n\t\tputs(\"-1\");\n\t\texit(0);\n}\nint main()\n{\n\t\tscanf(\"%d\",&n); ans=2*n-2;\n\t\tfor (i=1;i<=n;++i) \n\t\t{\n\t\t\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\t\t\tmp[mk(A[i],B[i])]=1;\n\t\t\t\tif (i!=1&&!A[i]) RE();\n\t\t\t\tif (i!=2&&!B[i]) RE();\n\t\t}\n\t\tfor (i=1;i<=n;++i)\n\t\t{\n\t\t\t\tif (i!=1&&mp.find(mk(A[i]-1,B[i]))==mp.end()&&\n\t\t\t\t\t\tmp.find(mk(A[i]-1,B[i]-1))==mp.end()&&\n\t\t\t\t\t\tmp.find(mk(A[i]-1,B[i]+1))==mp.end()) RE();\n\t\t\t\tif (i!=2&&mp.find(mk(A[i],B[i]-1))==mp.end()&&\n\t\t\t\t\t\tmp.find(mk(A[i]-1,B[i]-1))==mp.end()&&\n\t\t\t\t\t\tmp.find(mk(A[i]+1,B[i]-1))==mp.end()) RE();\n\t\t\t\tv[A[i]+B[i]].pb(A[i]);\n\t\t}\n\t\tfor (i=1;i<=2*n;++i)\n\t\t\t\tif (v[i].size())\n\t\t\t\t{\n\t\t\t\t\t\tA[0]=B[0]=0;\n\t\t\t\t\t\tfor (j=0;j<(int)v[i].size();++j) A[++A[0]]=v[i][j],B[++B[0]]=v[i][j]; \n\t\t\t\t\t\tsort(B+1,B+B[0]+1); B[0]=unique(B+1,B+B[0]+1)-(B+1);\n\t\t\t\t\t\tfor (j=1;j<=B[0];++j) sum[j]=0;\n\t\t\t\t\t\tfor (j=1;j<=A[0];++j) sum[lower_bound(B+1,B+B[0]+1,A[j])-B]++;\n\t\t\t\t\t\tsize[0]=size[1]=now=last=0; now=1;\n\t\t\t\t\t\tsize[1]=sum[1];\n\t\t\t\t\t\tif (mp.find(mk(B[1]-1,i-B[1]-1))!=mp.end())\n\t\t\t\t\t\tfor (j=0;j<=size[now];++j) f[now][j]=size[now]-j;\n\t\t\t\t\t\tfor (j=2;j<=B[0];++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnow^=1; last=now^1;\n\t\t\t\t\t\t\t\tfor (l=0;l<=size[now];++l) f[now][l]=0;\n\t\t\t\t\t\t\t\tif (mp.find(mk(B[1]-1,i-B[1]-1))==mp.end())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t  for (l=0;l<=size[last];++l)\n\t\t\t\t\t\t\t\t\t  \t f[now][sum[j]]=max(f[now][sum[j]],f[last][l]+min(sum[j],l));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t int Max=-inf;\n\t\t\t\t\t\t\t\t\t for (l=0;l<=size[now];++l)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (l<=size[last]) Max=max(Max,f[last][l]+l);\n\t\t\t\t\t\t\t\t\t\t\tf[now][l]=Max;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t Max=-inf;\n\t\t\t\t\t\t\t\t\t for (l=max(size[last],size[now]);l>=0;--l)\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t \t\tif (l<=size[last]) Max=max(Max,f[last][l]);\n\t\t\t\t\t\t\t\t\t \t\tif (l<=size[now])\n\t\t\t\t\t\t\t\t\t \t\tf[now][l]=max(f[now][l],Max+l);\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t for (l=0;l<=size[now];++l)\n\t\t\t\t\t\t\t\t\t \tf[now][l]+=(size[now]-l);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsize[now]=sum[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint Max=0;\n\t\t\t\t\t\tfor (j=0;j<=size[now];++j) Max=max(Max,f[now][j]);\n\t\t\t\t\t\tans-=Max;\n\t\t\t\t}\n\t\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <numeric>\n#include <limits>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define tr(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n\nint N;\nint A[100010], B[100010];\nbool hige[100010];\n\nmap<pair<int, int>, int> cnt;\n\nvoid dmp() {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  rep (i, N) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n\n    if ((A[i] == 0) != (i == 0)) dmp();\n    if ((B[i] == 0) != (i == 1)) dmp();\n  }\n\n  int D = B[0];\n  if (A[1] != D) dmp();\n\n  rep (i, N) cnt[mp(A[i], B[i])] += 1;\n  rep (i, N) hige[i] = cnt.count(mp(A[i] - 1, B[i] - 1));\n\n  map<int, map<int, int>> taba;\n  rep (i, N) {\n    if (hige[i]) continue;\n    taba[A[i] + B[i]][A[i]] += 1;\n  }\n\n  for (int d = 0; d < D; ++d) {\n    if (taba.count(d)) dmp();\n  }\n\n  int ans = N - 1;  //count(hige, hige + N, true);\n\n  for (auto &i : taba) {\n    map<int, int> &m = i.second;\n\n    for (const auto &j : m) {\n      int a = j.first, b = D - a, c = j.second;\n\n      int prv_c = cnt[mp(a - 1, b + 1)];\n      int nxt_c = cnt[mp(a + 1, b - 1)];\n\n      int bgn = max(0, c - prv_c);\n      int end = max(0, c - nxt_c);\n\n      if (bgn > 0) {\n        ans += bgn;\n        if (cnt[mp(a - 1, b)] == 0) dmp();\n      }\n      if (end > 0) {\n        if (cnt[mp(a, b - 1)] == 0) dmp();\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\nlong long A[100005];\nlong long B[100005];\nint main(){\n\tcin >> N;\n\tlong long ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i] >> B[i];\n\t\tif(A[i] == 1 && B[i] == 1){\n\t\t\tans++;\n\t\t}\n\t\tans++;\n\t}\n\n\tcout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool find(pair<int,int> *P,int n,int a,int b)\n{\n  int k=lower_bound(P,P+n,make_pair(a,b))-P;\n  return k<n&&P[k]==make_pair(a,b);\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  static int A[100000],B[100000];\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",A+i,B+i);\n  }\n  if(A[0]!=0||B[1]!=0||A[1]!=B[0]){\n    puts(\"-1\");\n    return 0;\n  }\n  int L=A[1];\n  int C=0;\n  static pair<int,int> P[100000];\n  for(int i=0;i<n;i++){\n    P[i]=make_pair(A[i],B[i]);\n    if((i!=0&&A[i]==0)||(i!=1&&B[i]==0)||A[i]+B[i]<L||A[i]-B[i]>L||B[i]-A[i]>L){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  sort(P,P+n);\n  static bool X[100000];\n  static int Y[100010]={0};\n  X[0]=X[1]=1;\n  for(int i=0;i<n;i++){\n    if(A[i]+B[i]==L){\n      X[i]=1;\n      Y[A[i]]++;\n    }\n    else{\n      int k=lower_bound(P,P+n,make_pair(A[i]-1,B[i]-1))-P;\n      if(k<n&&P[k]==make_pair(A[i]-1,B[i]-1)){\n\t//printf(\"%d\\n\",i);\n\tX[i]=1;\n\tC++;\n      }\n    }\n  }\n  //printf(\"%d %d %d %d\\n\",C,Y[0],Y[1],Y[2]);\n  for(int k=0;k<=L;k++){\n    if(!Y[k]){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  for(int k=0;k<L;k++){\n    C+=max(Y[k],Y[k+1]);\n  }\n  for(int i=0;i<n;i++){\n    if(X[i]){\n      continue;\n    }\n    else{\n      int a1=A[i]-1,b1=min(A[i]-1+L,B[i]+1);\n      int a2=min(B[i]-1+L,A[i]+1),b2=B[i]-1;\n      int k1=lower_bound(P,P+n,make_pair(a1,b1))-P;\n      int k2=lower_bound(P,P+n,make_pair(a2,b2))-P;\n      if(k1<n&&P[k1]==make_pair(a1,b1)&&k2<n&&P[k2]==make_pair(a2,b2)){\n\tif(X[k1]){\n\t  C++;\n\t}\n\tC++;\n      }\n      else{\n\tputs(\"-1\");\n\treturn 0;\n      }\n    }\n  }\n  printf(\"%d\\n\",C);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nvector<int> A[100000];\n\nvoid fail()\n{\n    printf(\"-1\\n\");\n    exit(0);\n}\n\nint main()\n{\n    scanf(\"%d\", &N);\n    int maxb=0;\n    int tmp=0;\n    for(int i=0; i<N; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        if(i==0 && a!=0)\n            fail();\n        if(i==1 && b!=0)\n            fail();\n        if(i==0)\n            tmp=b;\n        if(i==1 && tmp!=a)\n            fail();\n        if(b==0 && i!=1)\n            fail();\n        A[a].push_back(b);\n        maxb=max(maxb, b);\n    }\n    if(A[0].size()!=1)\n        fail();\n    for(int i=0; i<N; i++)\n        sort(A[i].begin(), A[i].end());\n    int ans=N-1;\n    int maxi=0;\n    for(int i=1; i<N; i++) if(!A[i].empty())\n        maxi=i;\n    for(int i=1; i<=maxi; i++)\n    {\n        if(A[i].empty())\n            fail();\n        for(auto& y: A[i])\n        {\n            int l=lower_bound(A[i-1].begin(), A[i-1].end(), y-1)-A[i-1].begin();\n            int r=upper_bound(A[i-1].begin(), A[i-1].end(), y+1)-A[i-1].begin();\n            if(l==r)\n                fail();\n            bool okl=y==0;\n            bool okr=y==maxb;\n            if(A[i-1][l]==y-1)\n                okl=true;\n            if(A[i-1][r-1]==y+1)\n                okr=true;\n            if((y!=0 && A[i-1][l]==y) && (y!=maxb && A[i-1][r-1]==y))\n                ans++;\n            if(i+1<=maxi)\n            {\n                l=lower_bound(A[i+1].begin(), A[i+1].end(), y-1)-A[i+1].begin();\n                r=upper_bound(A[i+1].begin(), A[i+1].end(), y+1)-A[i+1].begin();\n                if(l==r)\n                    fail();\n                if(A[i+1][l]==y-1)\n                    okl=true;\n                if(A[i+1][r-1]==y+1)\n                    okr=true;\n                if((y!=0 && A[i+1][l]==y) && (y!=maxb && A[i+1][r-1]==y))\n                    ans++;\n            }\n            if(!okl || !okr)\n            {\n                l=lower_bound(A[i].begin(), A[i].end(), y-1)-A[i].begin();\n                r=upper_bound(A[i].begin(), A[i].end(), y+1)-A[i].begin();\n                if(l==r)\n                    fail();\n                if(!okl && A[i][l]==y-1)\n                    okl=true, ans++;\n                if(!okr && A[i][r-1]==y+1)\n                    okr=true, ans++;\n            }\n            if(!okl || !okr)\n                fail();\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <numeric>\n#include <limits>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define tr(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n\nint N;\nint A[100010], B[100010];\nbool hige[100010];\n\nmap<pair<int, int>, int> cnt;\n\nvoid dmp() {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  rep (i, N) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n\n    if ((A[i] == 0) != (i == 0)) dmp();\n    if ((B[i] == 0) != (i == 1)) dmp();\n  }\n\n  int D = B[0];\n  if (A[1] != D) dmp();\n\n  rep (i, N) cnt[mp(A[i], B[i])] += 1;\n  rep (i, N) hige[i] = cnt.count(mp(A[i] - 1, B[i] - 1));\n\n  map<int, map<int, int>> taba;\n  rep (i, N) {\n    if (hige[i]) continue;\n    taba[A[i] + B[i]][A[i]] += 1;\n  }\n\n  for (int d = 0; d < D; ++d) {\n    if (taba.count(d)) dmp();\n  }\n\n  int ans = N - 1;  //count(hige, hige + N, true);\n\n  for (auto &i : taba) {\n    map<int, int> &m = i.second;\n\n    for (const auto &j : m) {\n      int a = j.first, b = D - a, c = j.second;\n\n      int prv_c = cnt[mp(a - 1, b + 1)];\n      int nxt_c = cnt[mp(a + 1, b - 1)];\n\n      int bgn = max(0, c - prv_c);\n      int end = max(0, c - nxt_c);\n\n      if (bgn > 0) {\n        ans += bgn;\n        if (a > 0 && cnt[mp(a - 1, b)] == 0) {\n          //printf(\"%d %d\\n\", a, b);\n          dmp();\n        }\n      }\n      if (end > 0) {\n        if (b > 0 && cnt[mp(a, b - 1)] == 0) {\n          //          printf(\"%d %d\\n\", a, b);\n          dmp();\n        }\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nint N;\nint A[101010],B[101010];\nmap<pair<int,int>,int> S;\nUF<500000> uf;\nmap<int,int> V[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tif(i!=0 && A[i]==0) return _P(\"-1\\n\");\n\t\tif(i==0 && A[i]) return _P(\"-1\\n\");\n\t\tif(i!=1 && B[i]==0) return _P(\"-1\\n\");\n\t\tif(i==1 && B[i]) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<B[0]) return _P(\"-1\\n\");\n\t\tS[{A[i],B[i]}]=i;\n\t\tV[A[i]+B[i]][A[i]]++;\n\t}\n\tif(B[0]!=A[1]) return _P(\"-1\\n\");\n\t\n\tFOR(i,N) {\n\t\tif(i!=0) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i]-1,B[i]})) uf(i,S[{A[i]-1,B[i]}]);\n\t\t\tif(S.count({A[i]-1,B[i]+1})) uf(i,S[{A[i]-1,B[i]+1}]);\n\t\t}\n\t\tif(i!=1) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i],B[i]-1})) uf(i,S[{A[i],B[i]-1}]);\n\t\t\tif(S.count({A[i]+1,B[i]-1})) uf(i,S[{A[i]+1,B[i]-1}]);\n\t\t}\n\t}\n\tif(uf.count(0)!=N) return _P(\"-1\\n\");\n\tint ret=2*N-2;\n\tFOR(i,2*N) if(V[i].size()) {\n\t\tint pre=-2,left=0;\n\t\tint del=0;\n\t\tFORR(r,V[i]) {\n\t\t\tx = r.second;\n\t\t\tif(r.first==pre+1) {\n\t\t\t\tret -= min(left,x);\n\t\t\t\tdel+=min(left,x);\n\t\t\t\tx-=min(left,x);\n\t\t\t}\n\t\t\tif(S.count({r.first-1,(i-r.first)-1})) {\n\t\t\t\tret-=x;\n\t\t\t\tdel+=x;\n\t\t\t\tx=0;\n\t\t\t}\n\t\t\tpre=r.first;\n\t\t\tleft=x;\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\tvector<pair<int, int> > A;\n\tfor(int i=0; i<N; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tA.emplace_back(a, b);\n\t}\n\tif(A[0].first!=0 || A[1].second!=0 || A[1].first!=A[0].second) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint ab = A[0].second;\n\tint sum = ab;\n\t{\n\t\tvector<int> vec(ab+1);\n\t\tfor(auto & p : A) {\n\t\t\tif(p.first+p.second==ab) {\n\t\t\t\t++vec[p.first];\n\t\t\t}\n\t\t}\n\t\tif(vec[0]!=1 || vec[ab]!=1) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i : vec) {\n\t\t\tif(i==0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(2<=i) {\n\t\t\t\tsum += (i-1)*2;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tvector<pair<int, int> > vec;\n\t\tfor(auto & p : A) {\n\t\t\tif(p.first+p.second!=ab) {\n\t\t\t\tint aa = p.first+p.second - ab;\n\t\t\t\tint aaHalf = (aa+1)>>1;\n\t\t\t\tint aaa = p.first-aaHalf;\n\t\t\t\tif(aa<=0) {\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(aa&1) {\n\t\t\t\t\tvec.emplace_back(p.first-aaHalf+1, aaHalf);\n\t\t\t\t\t++sum;\n\t\t\t\t}\n\t\t\t\tvec.emplace_back(p.first-(aa>>1), aaHalf);\n\t\t\t\t++sum;\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\tint beforeF = -1;\n\t\tint beforeS = 0;\n\t\tfor(auto & p : vec) {\n\t\t\tif(p.first!=beforeF) {\n\t\t\t\tbeforeF = p.first;\n\t\t\t\tbeforeS = 0;\n\t\t\t}\n\t\t\tif(p.second!=beforeS && p.second!=beforeS+1) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbeforeS = p.second;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nint n;\npair<int,int> a[maxn];\n\nbool check_1(){\n  if(a[1].first!=0||a[2].second!=0||a[2].first!=a[1].second)return false;\n  for(int i=3;i<=n;i++)\n    if(a[i].first==0||a[i].second==0)return false;\n  set<pair<int,int>>st;\n  for(int i=1;i<=n;i++)st.insert(a[i]);\n  for(int i=3;i<=n;i++){\n    int cnt=0;\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first-1,a[i].second+j))!=st.end()){\n        cnt++;\n        break;\n      }\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first+j,a[i].second-1))!=st.end()){\n        cnt++;\n        break;\n      }\n      if(cnt<2)return false;\n  }\n  return true;\n}\n\nbool cmp(pair<int,int> a,pair<int,int> b){\n  int ta = a.first + a.second;\n  int tb = b.first + b.second;\n  return ta == tb ? a.first < b.first: ta < tb;\n}\n\nint cal(){\n  int ret=0;\n  sort(a+1,a+n+1,cmp);\n  map<pair<int,int>,int>mp;\n  for(int i=1;i<=n;i++){\n    int pos = i;\n    for(int j=i;j<=n;j++){\n      if(a[j]!=a[i])break;\n      pos=j;\n    }\n    if(mp.find(make_pair(a[i].first-1,a[i].second-1))!=mp.end()){\n      ret += pos - i+1;\n    } else {\n      int tmp =0;\n      if(mp.find(make_pair(a[i].first-1,a[i].second+1))!=mp.end()){\n        tmp = mp[make_pair(a[i].first-1,a[i].second+1)];\n      }\n      ret+=min(tmp,pos-i+1);\n    }\n    mp[a[i]] = pos-i+1;\n    i =pos;\n  }\n  return ret;\n}\n\nint main() {\n  //  freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    if(!check_1()){\n      cout<<-1<<endl;\n      return 0;\n    }\n    cout<<2*n-2-cal()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n\nusing namespace std;\n\nmap <pair<int, int>, int> mp[200000];\n\nbool check(pair<int, int> p, int da, int db) {\n    int a = p.first + da;\n    int b = p.second + db;\n    \n    if (a + b < 0) return false;\n    \n    return mp[a + b].count(make_pair(a, b));\n}\n\nbool before(pair<int, int> p) {\n    return check(p, -1, -1) || check(p, -1, 0) || check(p, -1, 1);\n}\n\nbool after(pair<int, int> p) {\n    return check(p, -1, -1) || check(p, 0, -1) || check(p, 1, -1);\n}\n\nint solve() {\n    int n, d, ans, i;\n    map <pair<int, int>, int>::iterator it, it2;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) {\n        int a, b;\n        \n        scanf(\"%d %d\", &a, &b);\n        \n        if (i == 0) {\n            if (a != 0 || b == 0) return -1;\n            \n            d = b;\n        } else if (i == 1) {\n            if (a != d || b != 0) return -1;\n        } else {\n            if (a == 0 || b == 0 || a + b < d) return -1;\n        }\n        \n        mp[a + b][make_pair(a, b)]++;\n    }\n    \n    ans = n * 2 - 2;\n    \n    for (i = d; i < n * 2; i++) {\n        int c;\n        \n        if (mp[i].size() == 0) continue;\n        \n        for (it = mp[i].begin(); it != mp[i].end(); it++) {\n            if (!before(it->first) && it->first.first > 0) return -1;\n            if (!after(it->first) && it->first.second > 0) return -1;\n            \n            if (it != mp[i].begin()) {\n                it2 = it;\n                it2--;\n                \n                if (it2->first.first + 1 == it->first.first) {\n                    if (i == d) return -1;\n                    \n                    ans -= min(it->second, c);\n                    it->second = max(it->second - c, 0);\n                }\n            }\n            \n            if (check(it->first, -1, -1)) {\n                ans -= it->second;\n                c = 0;\n            } else {\n                c = it->second;\n            }\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nconst int MAXN = 100001;\nint ans, a[MAXN], b[MAXN], u[MAXN];\n\nvoid no() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nset<pii> S;\n\nvoid ch(bool x) {\n\tif (!x) no();\n}\n\nvoid solve() {\n\tch(a[1] == 0);\n\tch(b[2] == 0);\n\tch(a[2] == b[1]);\n\n\tint d = a[2];\n\tch(d > 0);\n\n\tvector<pii> v;\n\n\tans = n - 1;\n\n\tCL(0, u);\n\tm = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i > 2) ch(a[i] > 0 && b[i] > 0);\n\t\tch(a[i] + b[i] >= d);\n\t\tif (a[i] + b[i] == d) {\n\t\t\tif (!u[a[i]]) {\n\t\t\t\tS.insert(pii(a[i], b[i]));\n\t\t\t\tu[a[i]] = 1; m++;\n\t\t\t}\n\t\t\telse ans++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(pii(a[i], b[i]));\n\t\t}\n\t}\n\tch(m == d + 1);\n\tsort(v.begin(), v.end());\n\n\tfor (pii p : v) {\n\t\tif (S.count(pii(p.first - 1, p.second - 1))) { S.insert(p); continue; }\n\t\tif (S.count(pii(p.first, p.second))) { S.insert(p);  ans++; continue; }\n\t\t//if (S.count(pii(p.first, p.second - 1))) { ans++; S.insert(p); continue; }\n\t\t//if (S.count(pii(p.first - 1, p.second))) { ans++; S.insert(p); continue; }\n\t\tif (S.count(pii(p.first, p.second - 1)) && S.count(pii(p.first - 1, p.second))) { ans++; S.insert(p); continue; }\n\t\tno();\n\t}\n}\n\nvoid read() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\tcin >> n;\n\tF1(i, n) cin >> a[i] >> b[i];\n}\n\nint main() {\n\tread();\n\tsolve();\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\t#include<cstdio>\n\t#include<algorithm>\n\t#include<cstring>\n\t#include<iostream>\n\t#include<vector>\n\t#include<set>\n\t#include<map>\n\t#include<bitset>\n\t#include<cmath>\n\t#include<string>\n\t\n\t#define ls (t<<1)\n\t#define rs ((t<<1)+1)\n\t#define mid ((l+r)>>1)\n\t#define fi first\n\t#define se second\n\t#define mk make_pair\n\t#define pb push_back\n\t\n\t#define N 100005\n\t#define M 200005\n\t#define seed 23333\n\t\n\tusing namespace std;\n\tconst int inf=(int)1e9;\n\tint i,j,m,n,p,k,A[N],B[N],l;\n\tmap<pair<int,int>,int>mp;\n\tvector<int>v[M];\n\tint f[2][N],ans,sum[N],size[2],now,last;\n\tint RE()\n\t{\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t}\n\tint main()\n\t{\n\t\t\tscanf(\"%d\",&n); ans=2*n-2;\n\t\t\tfor (i=1;i<=n;++i) \n\t\t\t{\n\t\t\t\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\t\t\t\tmp[mk(A[i],B[i])]=1;\n\t\t\t\t\tif (i!=1&&!A[i]) RE();\n\t\t\t\t\tif (i!=2&&!B[i]) RE();\n\t\t\t}\n\t\t\tfor (i=1;i<=n;++i)\n\t\t\t{\n\t\t\t\t\tif (i!=1&&mp.find(mk(A[i]-1,B[i]))==mp.end()&&\n\t\t\t\t\t\t\tmp.find(mk(A[i]-1,B[i]-1))==mp.end()&&\n\t\t\t\t\t\t\tmp.find(mk(A[i]-1,B[i]+1))==mp.end()) RE();\n\t\t\t\t\tif (i!=2&&mp.find(mk(A[i],B[i]-1))==mp.end()&&\n\t\t\t\t\t\t\tmp.find(mk(A[i]-1,B[i]-1))==mp.end()&&\n\t\t\t\t\t\t\tmp.find(mk(A[i]+1,B[i]-1))==mp.end()) RE();\n\t\t\t\t\tv[A[i]+B[i]].pb(A[i]);\n\t\t\t}\n\t\t\tfor (i=1;i<=2*n;++i)\n\t\t\t\t\tif (v[i].size())\n\t\t\t\t\t{\n\t\t\t\t\t\t\tA[0]=B[0]=0;\n\t\t\t\t\t\t\tfor (j=0;j<(int)v[i].size();++j) A[++A[0]]=v[i][j],B[++B[0]]=v[i][j]; \n\t\t\t\t\t\t\tsort(B+1,B+B[0]+1); B[0]=unique(B+1,B+B[0]+1)-(B+1);\n\t\t\t\t\t\t\tfor (j=1;j<=B[0];++j) sum[j]=0;\n\t\t\t\t\t\t\tfor (j=1;j<=A[0];++j) sum[lower_bound(B+1,B+B[0]+1,A[j])-B]++;\n\t\t\t\t\t\t\tsize[0]=size[1]=now=last=0; now=1;\n\t\t\t\t\t\t\tsize[1]=sum[1];\n\t\t\t\t\t\t\tif (mp.find(mk(B[1]-1,i-B[1]-1))!=mp.end())\n\t\t\t\t\t\t\tfor (j=0;j<=size[now];++j) f[now][j]=size[now]-j;\n\t\t\t\t\t\t\telse for (j=0;j<=size[now];++j) f[now][j]=0;\n\t\t\t\t\t\t\tfor (j=2;j<=B[0];++j)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnow^=1; last=now^1;\n\t\t\t\t\t\t\t\t\tfor (l=0;l<=size[now];++l) f[now][l]=0;\n\t\t\t\t\t\t\t\t\tif (mp.find(mk(B[j]-1,i-B[j]-1))==mp.end())\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t  for (l=0;l<=size[last];++l)\n\t\t\t\t\t\t\t\t\t\t  \t f[now][sum[j]]=max(f[now][sum[j]],f[last][l]+(B[j]-B[j-1]==1)*min(sum[j],l));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t int Max=-inf;\n\t\t\t\t\t\t\t\t\t\t for (l=0;l<=size[now];++l)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif (l<=size[last]) Max=max(Max,f[last][l]+(B[j]-B[j-1]==1)*l);\n\t\t\t\t\t\t\t\t\t\t\t\tf[now][l]=Max;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t Max=-inf;\n\t\t\t\t\t\t\t\t\t\t for (l=max(size[last],size[now]);l>=0;--l)\n\t\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t \t\tif (l<=size[last]) Max=max(Max,f[last][l]);\n\t\t\t\t\t\t\t\t\t\t \t\tif (l<=size[now])\n\t\t\t\t\t\t\t\t\t\t \t\tf[now][l]=max(f[now][l],Max+(B[j]-B[j-1]==1)*l);\n\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t for (l=0;l<=size[now];++l)\n\t\t\t\t\t\t\t\t\t\t \tf[now][l]+=(size[now]-l);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsize[now]=sum[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint Max=0;\n\t\t\t\t\t\t\tfor (j=0;j<=size[now];++j) Max=max(Max,f[now][j]);\n\t\t\t\t\t\t\tans-=Max;\n\t\t\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 100010;\n\nint N;\nint A[MN], B[MN];\nvector<int> Va[MN], Vb[MN];\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n\n        Va[ A[i] ].push_back(i);\n        Vb[ B[i] ].push_back(i);\n    }\n\n    if(A[0] || B[1]) {\n        printf(\"-1\");\n        return 0;\n    }\n    if(Va[0].size() > 1 || Vb[0].size() > 1) {\n        printf(\"-1\");\n        return 0;\n    }\n\n    multiset<int> pre;\n    pre.insert(B[0]);\n\n    for(int i = 1; i < N; i++) {\n        multiset<int> cur;\n\n        for(int j = 0; j < Va[i].size(); j++) {\n            int x = Va[i][j];\n\n            auto it = pre.lower_bound(B[x] - 1);\n            if(it == pre.end() || B[x] + 1 < *it) {\n                printf(\"-1\");\n                return 0;\n            }\n\n            cur.insert(B[x]);\n        }\n        pre = cur;\n    }\n\n    int ans = N - 1;\n\n    pre.clear();\n    pre.insert(A[1]);\n\n    multiset<int> alive = pre;\n    for(int i = 1; i < N; i++) {\n        multiset<int> cur;\n        multiset<int> tmp;\n\n        for(int j = 0; j < Vb[i].size(); j++) {\n            int x = Vb[i][j];\n\n            auto it = pre.lower_bound(A[x] - 1);\n            if(it == pre.end() || A[x] + 1 < *it) {\n                printf(\"-1\");\n                return 0;\n            }\n            cur.insert(A[x]);\n        }\n\n        vector<int> chk(Vb[i].size(), 0);\n\n        for(int j = 0; j < Vb[i].size(); j++) if(!chk[j]) {\n            int x = Vb[i][j];\n\n            if(alive.find(A[x] + 1) != alive.end()) {\n                chk[j] = 1;\n                alive.erase(alive.find(A[x] + 1));\n                tmp.insert(A[x]);\n            }\n        }\n        for(int j = 0; j < Vb[i].size(); j++) if(!chk[j]) {\n            int x = Vb[i][j];\n\n            if(pre.find(A[x] - 1) != pre.end()) {\n                continue;\n            }\n            tmp.insert(A[x]);\n            ans++;\n        }\n\n        pre = cur;\n        alive = tmp;\n    }\n\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool find(pair<int,int> *P,int n,int a,int b)\n{\n  int k=lower_bound(P,P+n,make_pair(a,b))-P;\n  return k<n&&P[k]==make_pair(a,b);\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  static int A[100000],B[100000];\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",A+i,B+i);\n  }\n  if(A[0]!=0||B[1]!=0||A[1]!=B[0]){\n    puts(\"-1\");\n    return 0;\n  }\n  int L=A[1];\n  int C=L;\n  static pair<int,int> P[100000];\n  for(int i=0;i<n;i++){\n    P[i]=make_pair(A[i],B[i]);\n    if((i!=0&&A[i]==0)||(i!=1&&B[i]==0)||A[i]+B[i]<L||A[i]-B[i]>L||B[i]-A[i]>L){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  sort(P,P+n);\n  static bool X[100000];\n  bool Y[100010]={0};\n  for(int i=0;i<n;i++){\n    if(A[i]+B[i]==L&&!Y[A[i]]){\n      X[i]=1;\n      Y[A[i]]=1;\n    }\n    else{\n      int k=lower_bound(P,P+n,make_pair(A[i]-1,B[i]-1))-P;\n      if(k<n&&P[k]==make_pair(A[i]-1,B[i]-1)){\n\t//printf(\"%d\\n\",i);\n\tX[i]=1;\n\tC++;\n      }\n    }\n  }\n  //printf(\"%d %d %d %d\\n\",C,Y[0],Y[1],Y[2]);\n  for(int k=0;k<=L;k++){\n    if(!Y[k]){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  for(int i=0;i<n;i++){\n    if(X[i]){\n      continue;\n    }\n    else{\n      int a1=A[i]-1,b1=min(A[i]-1+L,B[i]+1);\n      int a2=min(B[i]-1+L,A[i]+1),b2=B[i]-1;\n      int k1=lower_bound(P,P+n,make_pair(a1,b1))-P;\n      int k2=lower_bound(P,P+n,make_pair(a2,b2))-P;\n      if(k1<n&&P[k1]==make_pair(a1,b1)&&k2<n&&P[k2]==make_pair(a2,b2)){\n\tif(X[k1]){\n\t  C++;\n\t}\n\tC++;\n      }\n      else{\n\tputs(\"-1\");\n\treturn 0;\n      }\n    }\n  }\n  printf(\"%d\\n\",C);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <numeric>\n#include <limits>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define tr(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n\nint N;\nint A[100010], B[100010];\nbool hige[100010];\n\nvoid dmp() {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  rep (i, N) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n\n    if ((A[i] == 0) != (i == 0)) dmp();\n    if ((B[i] == 0) != (i == 1)) dmp();\n  }\n\n  int D = B[0];\n  if (A[1] != D) dmp();\n\n  map<pair<int, int>, int> cnt;\n  rep (i, N) cnt[mp(A[i], B[i])] += 1;\n  rep (i, N) hige[i] = cnt.count(mp(A[i] - 1, B[i] - 1));\n\n  map<int, map<int, int>> taba;\n  rep (i, N) {\n    if (hige[i]) {\n      cnt[mp(A[i], B[i])] -= 1;\n    } else {\n      taba[A[i] + B[i]][A[i]] += 1;\n    }\n  }\n\n  for (int d = 0; d < D; ++d) {\n    if (taba.count(d)) dmp();\n  }\n\n  int ans = N - 2;  //count(hige, hige + N, true);\n\n  for (auto &i : taba) {\n    map<int, int> &m = i.second;\n    int d = i.first;\n\n    for (const auto &j : m) {\n      int a = j.first, b = d - a, c = j.second;\n\n      int prv_c = cnt[mp(a - 1, b + 1)];\n      int nxt_c = cnt[mp(a + 1, b - 1)];\n      // printf(\"%d %d: %d %d %d\\n\", a, b, prv_c, c, nxt_c);\n\n      int bgn = max(0, c - prv_c);\n      int end = max(0, c - nxt_c);\n\n      if (bgn > 0) {\n        // printf(\" %d\\n\", bgn);\n        ans += bgn;\n        if (a > 0 && prv_c == 0 && cnt[mp(a - 1, b)] == 0) {\n          //printf(\"%d %d\\n\", a, b);\n          dmp();\n        }\n      }\n      if (end > 0) {\n        if (b > 0 && nxt_c == 0 && cnt[mp(a, b - 1)] == 0) {\n          //          printf(\"%d %d\\n\", a, b);\n          dmp();\n        }\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve();\nvoid precalc();\nclock_t start;\n//int timer = 1;\n\nint testNumber = 1;\n\nbool todo = true;\n\nint main() {\n#ifdef AIM\n    freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n#else\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    start = clock();\n    int t = 1;\n    cout.sync_with_stdio(0);\n    cin.tie(0);\n    precalc();\n    cout.precision(10);\n    cout << fixed;\n    //cin >> t;\n    int testNum = 1;\n    while (t--) {\n        //cerr << testNum << endl;\n        //cout << \"Case #\" << testNum++ << \": \";\n        solve();\n        ++testNumber;\n        //++timer;\n    }\n\n#ifdef AIM\n    cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n    return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n    if (!w)\n        return 1 % mod;\n    if (w & 1)\n        return q * 1LL * binpow(q, w - 1, mod) % mod;\n    return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n    while (w) {\n        q %= w;\n        swap(q, w);\n    }\n    return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n    return q / gcd(q, w) * w;\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n\n//const int mod = 1000000007;\n\n\nvoid solve() {\n    int n;\n    cin >> n;\n    multiset<pair<int, int>> a;\n    int b, c, d, e;\n    cin >> b >> c >> d >> e;\n    if (b != 0 || e != 0 || c != d) {\n        cout << \"-1\\n\";\n        return;\n    }\n    int dist = c;\n    a.insert({dist, 0});\n    a.insert({0, dist});\n\n    for (int i = 2; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        a.insert({x, y});\n        if (x == 0 || y == 0) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n\n    map<int, int> cnt;\n    int ans = n - 1;\n\n    for (auto item : a) {\n        if (abs(item.first - item.second) > dist) {\n            cout << \"-1\\n\";\n            return;\n        }\n        int diff =  item.first + item.second - dist;\n        if (diff < 0) {\n            cout << \"-1\\n\";\n            return;\n        }\n        if (diff == 0) {\n            cnt[item.first]++;\n            continue;\n        }\n        if (diff == 1) {\n            ++ans;\n            continue;\n        }\n        if (a.find(make_pair(item.first  - 1, item.second - 1)) == a.end()) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n    if (cnt.size() != dist + 1) {\n        cout << \"-1\\n\";\n        return;\n    }\n    int sum = 0;\n    for (auto item : cnt) {\n        sum += item.second - 1;\n    }\n\n    for (int i = 1; i <= dist; ++i) {\n        sum -= max(min(cnt[i], cnt[i - 1]) - 1, 0);\n    }\n\n    ans += sum;\n\n    cout << ans << \"\\n\";\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\tvector<pair<int, int> > A;\n\tfor(int i=0; i<N; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tA.emplace_back(a, b);\n\t}\n\tif(A[0].first!=0 || A[1].second!=0 || A[1].first!=A[0].second) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint ab = A[0].second;\n\tint sum = ab;\n\t{\n\t\tvector<int> vec(ab+1);\n\t\tfor(auto & p : A) {\n\t\t\tif(p.first+p.second==ab) {\n\t\t\t\t++vec[p.first];\n\t\t\t}\n\t\t\tif(p.first+p.second<ab) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(vec[0]!=1 || vec[ab]!=1) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i : vec) {\n\t\t\tif(i==0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(2<=i) {\n\t\t\t\tsum += (i-1)*2;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tvector<pair<int, int> > vec;\n\t\tvector<pair<int, int> > vec2;\n\t\tfor(auto & p : A) {\n\t\t\tif(ab<p.first+p.second) {\n\t\t\t\tint aa = p.first+p.second - ab;\n\t\t\t\tint aaHalf = (aa+1)>>1;\n\t\t\t\tint aaa = p.first-aaHalf;\n\t\t\t\tif(aa&1) {\n\t\t\t\t\tvec2.emplace_back(p.first-aaHalf, aaHalf);\n\t\t\t\t\t++sum;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvec.emplace_back(p.first-aaHalf, aaHalf);\n\t\t\t\t\t++sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\tsort(vec2.begin(), vec2.end());\n\t\t{\n\t\t\tint beforeF = -1;\n\t\t\tint beforeS = 0;\n\t\t\tfor(auto & p : vec) {\n\t\t\t\tif(p.first!=beforeF) {\n\t\t\t\t\tbeforeF = p.first;\n\t\t\t\t\tbeforeS = 0;\n\t\t\t\t}\n\t\t\t\tif(p.second!=beforeS && p.second!=beforeS+1) {\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbeforeS = p.second;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint beforeF = -10;\n\t\t\tint beforeS = 0;\n\t\t\tfor(auto & p : vec2) {\n\t\t\t\tif(p.first!=beforeF) {\n\t\t\t\t\tif(s.first!=beforeF+1) {\n\t\t\t\t\t\t++sum;\n\t\t\t\t\t}\n\t\t\t\t\tbeforeF = p.first;\n\t\t\t\t\tbeforeS = 0;\n\t\t\t\t}\n\t\t\t\tif(p.second!=beforeS && p.second!=beforeS+1) {\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbeforeS = p.second;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nset<pair<int,int>> st;\npair<int,int> a[maxn];\nbool vis[maxn];\nint n;\n\nbool cmp(pair<int,int>a,pair<int,int>b) {\n    return a.first + a.second == b.first + b.second ?\n           a.first < b.first : a.first + a.second < b.first + b.second;\n}\n\nbool check_1() {\n    if(a[1].first!=0||a[2].second!=0||a[1].second!=a[2].first)return false;\n    return true;\n}\n\nbool check_2(int&ret) {\n    if(n>2)sort(a+3,a+n+1, cmp);\n    if(a[1].second==0)return false;\n    vis[1] = vis[2] = 1;\n    st.insert(a[1]);\n    st.insert(a[2]);\n    ret += a[1].second;\n    if(a[1].second==1) return true;\n    int cnt = 0;\n    for(int i=3; i<=n; i++) {\n        if(a[i].first + a[i].second != a[1].second) continue;\n        if(st.find(a[i])!=st.end())continue;\n        st.insert(a[i]);\n        vis[i] = 1;\n        cnt++;\n    }\n    return cnt == a[1].second - 1;\n}\n\nbool pd(int x,int y) {\n    int x1 = x - 1, y1, x2, y2 = y - 1;\n    for(int y1 = y-1; y1<=y+1; y1++)\n        for(int x2=x-1; x2<=x+1; x2++) {\n            if(st.find(make_pair(x1,y1))==st.end())continue;\n            if(st.find(make_pair(x2,y2))==st.end())continue;\n            return true;\n        }\n    return false;\n}\n\nbool check_3(int&ret) {\n    for(int i=3; i<=n; i++) {\n        if(vis[i])continue;\n        pair<int,int> fa = make_pair(a[i].first-1,a[i].second-1);\n        if(st.find(fa)!=st.end()) {\n            vis[i]=1;\n            ret++;\n            st.insert(a[i]);\n        } else {\n            if(pd(a[i].first,a[i].second)) {\n                vis[i] = 1;\n                ret+=2;\n                st.insert(a[i]);\n            } else return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n  //  freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    int ret = 0;\n    if(!check_1()) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(!check_2(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(!check_3(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    cout<<ret<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 1e5 + 10;\nint n , x[N] , y[N];\n\nvoid check(bool ok) {\n  if(!ok) {\n    puts(\"-1\");\n    exit(0);\n  }\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  rep(i,0,n) scanf(\"%d%d\",x+i,y+i);\n  check(x[0] == 0 && y[1] == 0 && x[1] > 0 && x[1] == y[0]);\n  rep(i,2,n) check(x[i] > 0 && y[i] > 0);\n  map<pii,int> S;\n  rep(i,0,n) S[mp(x[i],y[i])]++;\n  rep(i,0,n) {\n    if(x[i]) check(S.count(mp(x[i]-1,y[i]-1))||S.count(mp(x[i]-1,y[i]))||S.count(mp(x[i]-1,y[i]+1)));\n    if(y[i]) check(S.count(mp(x[i]-1,y[i]-1))||S.count(mp(x[i],y[i]-1))||S.count(mp(x[i]+1,y[i]-1)));\n  }\n  int res = 2 * n - 2;\n  vector<pair<pii,int> > pts;\n  for(auto e : S) pts.pb(e);\n  sort(all(pts),[&](pair<pii,int> a,pair<pii,int> b){\n      int sa=a.fi.fi+a.fi.se;\n      int sb=b.fi.fi+b.fi.se;\n      if(sa!=sb) return sa < sb;\n      return a.fi.fi < b.fi.fi;\n      });\n  int remain = 0;\n  rep(i,0,sz(pts)) {\n    int x , y , cnt;\n    tie(x , y) = pts[i].fi;\n    cnt = pts[i].se;\n    int match = min(remain , cnt);\n    res -= match;\n    if(S.count(mp(x - 1 , y - 1))) {\n      int link = cnt - match;\n      res -= link;\n      cnt -= link;\n    }\n    if(i + 1 < sz(pts) && x + 1 == pts[i+1].fi.fi && y - 1 == pts[i+1].fi.se)\n      remain = cnt;\n    else\n      remain = 0;\n  }\n  printf(\"%d\\n\",res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\nlong long A[100005];\nlong long B[100005];\nint main(){\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i] >> B[i];\n\t}\n\n\tcout << N << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nint a[100001];\nint b[100001];\nvi adj[100001];\nbool par[100001];\nvi aaa[100001];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\taaa[a[i]].pb(i);\n\t\tadj[b[i]].pb(i);\n\t}\n\tif(a[0]!=0||b[1]!=0)\n\t{\n\t\tcout<<-1<<'\\n';\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\tpar[0] = 1;\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\t//must come from last vec\n\t\tmap<int,vi> ma;\n\t\tmap<int,vi> unused;\n\t\tfor(int j = 0; j < adj[i-1].size(); j++)\n\t\t{\n\t\t\t//cerr<<adj[i-1][j]<<'\\n';\n\t\t\tma[a[adj[i-1][j]]].pb(adj[i-1][j]);\n\t\t}\n\t\tfor(int j = 0; j < adj[i-1].size(); j++)\n\t\t{\n\t\t\tif(!par[adj[i-1][j]]) unused[a[adj[i-1][j]]].pb(adj[i-1][j]);\n\t\t}\n\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t{\n\t\t\tint v = adj[i][j];\n\t\t\tint d = a[v];\n\t\t\t//cerr<<v<<' '<<d<<' '<<unused[d+1].size()<<'\\n';\n\t\t\tif(!par[v]&&!ma[d-1].empty())\n\t\t\t{\n\t\t\t\tpar[v] = true;\n\t\t\t}\n\t\t\telse if(!unused[d+1].empty())\n\t\t\t{\n\t\t\t\tint u = unused[d+1].back();\n\t\t\t\tunused[d+1].pop_back();\n\t\t\t\tpar[u] = true;\n\t\t\t}\n\t\t\telse if(ma[d-1].empty()&&ma[d].empty()&&ma[d+1].empty())\n\t\t\t{\n\t\t\t\tcout<<-1<<'\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//ans++;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(!par[i])\n\t\t{\n\t\t\t//cerr<<i<<'\\n';\n\t\t\tif(!aaa[a[i]-1].empty())\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout<<-1<<'\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tassert(ans>=n-1);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nint n;\npair<int,int> a[maxn];\n\nbool check_1(){\n  if(a[1].first!=0||a[2].second!=0||a[2].first!=a[1].second)return false;\n  for(int i=3;i<=n;i++)\n    if(a[i].first==0||a[i].second==0)return false;\n  set<pair<int,int>>st;\n  for(int i=1;i<=n;i++)st.insert(a[i]);\n  for(int i=3;i<=n;i++){\n    int cnt=0;\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first-1,a[i].second+j))!=st.end()){\n        cnt++;\n        break;\n      }\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first+j,a[i].second-1))!=st.end()){\n        cnt++;\n        break;\n      }\n      if(cnt<2)return false;\n  }\n  return true;\n}\n\nbool cmp(pair<int,int> a,pair<int,int> b){\n  int ta = a.first + a.second;\n  int tb = b.first + b.second;\n  return ta == tb ? a.first < b.first: ta < tb;\n}\n\nint cal(){\n  int ret=0;\n  sort(a+1,a+n+1,cmp);\n  map<pair<int,int>,int>mp;\n  for(int i=1;i<=n;i++){\n    int pos = i;\n    for(int j=i;j<=n;j++){\n      if(a[j]!=a[i])break;\n      pos=j;\n    }\n    if(mp.find(make_pair(a[i].first -1,a[i].second-1))!=mp.end()){\n      ret+=mp[make_pair(a[i].first-1,a[i].second-1)];\n      mp[a[i]] = 0;\n    } else {\n      int tmp =0;\n      if(mp.find(make_pair(a[i].first-1,a[i].second+1))!=mp.end()){\n        tmp = mp[make_pair(a[i].first-1,a[i].second+1)];\n      }\n      int cur = min(tmp, pos - i +1);\n      ret+=cur;\n      mp[a[i]] = pos-i+1;\n    }\n    i =pos;\n  }\n  return ret;\n}\n\nint main() {\n   // freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    if(!check_1()){\n      cout<<-1<<endl;\n      return 0;\n    }\n    cout<<2*n-2-cal()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define N 100005\n#define fr first\n#define se second\n#define check(x,y) (mp.find(make_pair(x,y))!=mp.end())\nusing namespace std;\nstruct msg{\n\tint x,y,num;\n};\npii v[N];\nvector<msg> b[N*2];\nmap<pii,int > mp;\nmap<pii,int >::iterator itr;\nint dp[N][2];\nint n,ans,d;\nvoid end(){\n\tputs(\"-1\");\n\texit(0);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&v[i].first,&v[i].se),mp[v[i]]++;\n\td=v[1].se;\n\tfor(itr=mp.begin();itr!=mp.end();itr++){\n\t\tb[(itr->fr).fr+(itr->fr).se].push_back((msg){(itr->fr).fr,(itr->fr).se,itr->se});\n\t}\n\tfor(int i=0;i<d;i++) if(b[i].size()>0) end();\n\tif(mp[v[1]]!=1||mp[v[2]]!=1||v[1].fr!=0||v[2].se!=0||v[1].se!=v[2].fr) end();\n\t\n\tfor(int i=d;i<=n*2;i++){\n\t\tfor(int j=0;j<b[i].size();j++){\n\t\t\tdp[j][0]=dp[j][1]=0x3f3f3f3f;\n\t\t\tif(j==0){\n\t\t\t\tif(i==d) {dp[j][0]=0;continue;}\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)){\n\t\t\t\t\tdp[j][0]=dp[j][1]=b[i][j].num;\n\t\t\t\t}else if(check(b[i][j].x-1,b[i][j].y)){\n\t\t\t\t\tdp[j][0]=b[i][j].num;\n\t\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\t\tdp[j][1]=b[i][j].num*2;\n\t\t\t\t}else end();\n\t\t\t}else{\n\t\t\t\tint temp=0x3f3f3f3f;\n\t\t\t\tif(b[i][j-1].x+1==b[i][j].x)\n\t\t\t\t\ttemp=dp[j-1][0]+max(b[i][j].num,b[i][j-1].num);\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y))\n\t\t\t\t\ttemp=min(temp,dp[j-1][1]+b[i][j].num);\n\t\t\t\tdp[j][0]=temp;\n\t\t\t\t\n\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\ttemp+=b[i][j].num;\n\t\t\t\telse temp=0x3f3f3f3f;\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)){\n\t\t\t\t\ttemp=min(temp,dp[j-1][1]+b[i][j].num);\n\t\t\t\t\tif(b[i][j-1].x+1==b[i][j].x)\n\t\t\t\t\t\ttemp=min(temp,dp[j-1][0]+b[i][j-1].num+b[i][j].num);\t\n\t\t\t\t} \n\t\t\t\tdp[j][0]=min(dp[j][0],dp[j][1]=temp);\n\t\t\t}\n\t\t}\n\t\tif(b[i].size()==0) continue;\n\t\tif(i==d) ans+=dp[b[i].size()-1][0];\n\t\telse ans+=dp[b[i].size()-1][1];\n\t\tif(ans>1e9) end();\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nset<pair<int,int>> st;\npair<int,int> a[maxn];\nbool vis[maxn];\nint n;\n\nbool cmp(pair<int,int>a,pair<int,int>b){\n    int tt =  min(a.first,a.second) - min(b.first, b.second);\n    if(tt<0)return true;\n    if(tt>0)return false;\n    if(a.first==b.first)return a.second<b.second;\n    if(a.second==b.second)return a.first<b.first;\n    return true;\n}\n\nbool check_1() {\n    if(a[1].first!=0||a[2].second!=0||a[1].second!=a[2].first)return false;\n    return true;\n}\n\nbool check_2(int&ret) {\n    if(n>2)sort(a+3,a+n+1, cmp);\n    if(a[1].second==0)return false;\n    vis[1] = vis[2] = 1;\n    st.insert(a[1]);\n    st.insert(a[2]);\n    ret += a[1].second;\n    if(a[1].second==1) return true;\n    int cnt = 0;\n    for(int i=3; i<=n; i++) {\n        if(a[i].first + a[i].second != a[1].second) continue;\n        if(st.find(a[i])!=st.end())continue;\n        st.insert(a[i]);\n        vis[i] = 1;\n        cnt++;\n    }\n    return cnt == a[1].second - 1;\n}\n\nbool pd(int x,int y) {\n    int x1 = x - 1, y1, x2, y2 = y - 1;\n    for(int y1 = y-1; y1<=y+1; y1++)\n        for(int x2=x-1; x2<=x+1; x2++) {\n            if(st.find(make_pair(x1,y1))==st.end())continue;\n            if(st.find(make_pair(x2,y2))==st.end())continue;\n            return true;\n        }\n    return false;\n}\n\nbool check_3(int&ret) {\n    for(int i=3; i<=n; i++) {\n        if(vis[i])continue;\n        pair<int,int> fa = make_pair(a[i].first-1,a[i].second-1);\n        if(st.find(fa)!=st.end()) {\n            vis[i]=1;\n            ret++;\n            st.insert(a[i]);\n        } else {\n            if(pd(a[i].first,a[i].second)) {\n                vis[i] = 1;\n                ret+=2;\n                st.insert(a[i]);\n            } else return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    //freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    int ret = 0;\n    if(!check_1()) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(!check_2(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(!check_3(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    cout<<ret<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N;\nset<pi> S;\n\nvoid as(bool b) {\n    if (!b) {\n        ps(-1);\n        exit(0);\n    }\n}\n\nbool nex(pi a, pi b) {\n    return a == b || b == mp(a.f+1,a.s-1);\n}\n\nint ans, cur;\n\nvoid elim(bool a, int b) {\n    if (!a) cur = b;\n    else {\n        ans -= min(cur,b);\n        cur = b-min(cur,b);\n    }\n}\n\nbool con(pi x) {\n    return S.count(x);\n}\n\nvoid tri(vpi v) {\n    map<pi,int> m; trav(t,v) m[t] ++;\n    auto V = vector<pair<pi,int>>(all(m));\n    // ps(V);\n    cur = 0;\n    F0R(i,sz(V)) {\n        if (i == 0) cur = V[i].s;\n        elim(con({V[i].f.f-1,V[i].f.s-1}),V[i].s);\n        if (i+1 < sz(V)) elim(1,V[i+1].s);\n    }\n    // ps(\"HA\",ans);\n}\n\nint main() { \n    setIO(); re(N); ans = 2*N-2;\n    vpi v;\n    F0R(i,N) {\n        int A,B; re(A,B);\n        if (i == 0) as(A == 0);\n        else as(A != 0);\n        if (i == 1) as(B == 0);\n        else as(B != 0);\n        v.pb({A,B});\n        S.insert({A,B});\n    }\n    trav(t,S) {\n        if (t.s) {\n            bool ok = 0;\n            FOR(i,-1,2) ok |= S.count({t.f+i,t.s-1});\n            as(ok);\n        }\n        if (t.f) {\n            bool ok = 0;\n            FOR(i,-1,2) ok |= S.count({t.f-1,t.s+i});\n            as(ok);\n        }\n    }\n    sort(all(v),[](pi a, pi b) {\n        if (a.f+a.s != b.f+b.s) return a.f+a.s < b.f+b.s;\n        return a.f < b.f;\n    });\n    for (int i = 0; i < sz(v);) {\n        vpi tmp = {v[i]};\n        while (i+1 < sz(v) && nex(v[i],v[i+1])) tmp.pb(v[++i]);\n        i ++;\n        tri(tmp);\n    }\n    ps(ans);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010],C[101010],D[101010];\nmap<pair<int,int>,vector<int>> M;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tM[{A[i],B[i]}].push_back(i);\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(i==0) {\n\t\t\tif(A[i]) return _P(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tC[i]=1;\n\t\t\tif(M.count({A[i]-1,B[i]-1})+M.count({A[i]-1,B[i]})+M.count({A[i]-1,B[i]+1})==0) return _P(\"-1\\n\");\n\t\t}\n\t\tif(i==1) {\n\t\t\tif(B[i]) return _P(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tD[i]=1;\n\t\t\tif(M.count({A[i]-1,B[i]-1})+M.count({A[i],B[i]-1})+M.count({A[i]+1,B[i]-1})==0) return _P(\"-1\\n\");\n\t\t}\n\t}\n\t\n\tint ret=2*N-2;\n\tFORR(m,M) {\n\t\tauto a=m.first;\n\t\ta.first--;\n\t\ta.second++;\n\t\tif(M.count(a)) {\n\t\t\tx=min(m.second.size(),M[a].size());\n\t\t\tFOR(i,x) {\n\t\t\t\tret--;\n\t\t\t\tC[m.second[i]]=D[M[a][i]]=0;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,N) if(C[i]+D[i]==2 && M.count({A[i]-1,B[i]-1})) ret--;\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main() {\n  int N; scanf(\"%d\", &N);\n  static int A[100000], B[100000];\n  static pair<int, int> ABtbl[100000];\n  static pair<int, int> BAtbl[100000];\n  for(int i = 0; i < N; ++i) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n    ABtbl[i] = make_pair(A[i], B[i]);\n    BAtbl[i] = make_pair(B[i], A[i]);\n  }\n  if(A[0] != 0 || B[1] != 0 || A[1] == 0 || A[1] != B[0]) {\n    printf(\"%d\\n\", -1);\n    return 0;\n  }\n  sort(ABtbl, ABtbl+N);\n  sort(BAtbl, BAtbl+N);\n  for(int i = 2; i < N; ++i) {\n    if(lower_bound(ABtbl, ABtbl+N, make_pair(A[i]-1, B[i]-1))\n        == upper_bound(ABtbl, ABtbl+N, make_pair(A[i]-1, B[i]+1))) {\n      printf(\"%d\\n\", -1);\n      return 0;\n    }\n    if(lower_bound(BAtbl, BAtbl+N, make_pair(B[i]-1, A[i]-1))\n        == upper_bound(BAtbl, BAtbl+N, make_pair(B[i]-1, A[i]+1))) {\n      printf(\"%d\\n\", -1);\n      return 0;\n    }\n  }\n  int count = 2 * (N-1);\n  for(int ii = 0; ii < N; ++ii) {\n    if(ii > 0 && ABtbl[ii-1] == ABtbl[ii]) continue;\n    int a = ABtbl[ii].first;\n    int b = ABtbl[ii].second;\n    if(lower_bound(ABtbl, ABtbl+N, make_pair(a-1, b+1))\n        < upper_bound(ABtbl, ABtbl+N, make_pair(a-1, b+1))) {\n      continue;\n    }\n    int have =\n      upper_bound(ABtbl, ABtbl+N, make_pair(a, b))\n        - lower_bound(ABtbl, ABtbl+N, make_pair(a, b));\n    int rem = have;\n    while(true) {\n      int capa = have;\n      if(lower_bound(ABtbl, ABtbl+N, make_pair(a-1, b-1))\n          < upper_bound(ABtbl, ABtbl+N, make_pair(a-1, b-1))) {\n        // fprintf(stderr, \"(%d, %d) -- %d recyclable edges to (%d, %d)\\n\",\n        //     a, b, rem, a-1, b-1);\n        count -= rem;\n        capa -= rem;\n      }\n      ++a;\n      --b;\n      have =\n        upper_bound(ABtbl, ABtbl+N, make_pair(a, b))\n          - lower_bound(ABtbl, ABtbl+N, make_pair(a, b));\n      if(have == 0) break;\n      // fprintf(stderr, \"(%d, %d) -- %d recyclable edges to (%d, %d)\\n\",\n      //     a, b, max(capa, have), a-1, b+1);\n      count -= max(capa, have);\n      rem = have - max(capa, have);\n    }\n  }\n  printf(\"%d\\n\", count);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\n//const int mod=(int)1e9+7;\n\nconst llint big=(llint)(2.19e15+1)*18;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\n#define dme cout<<\"-1\\n\";return 0\nint main(void){\n\tint n,i;cin>>n;\n\tmap<pair<int,int>,int>ban;\n\tfor(i=0;i<n;i++){\n\t\tint a,b;cin>>a>>b;\n\t\tif((i==0)^(a==0)){dme;}\n\t\tif((i==1)^(b==0)){dme;}\n\t\tban[mp(a+b,a)]++;\n\t}\n\t//dpで解く\n\tint ans=-2,sen=0;\n\tpair<int,int>maebas=mp(-1,-1);\n\tfor(auto it:ban){\n\t\tint a=it.fir.sec;\n\t\tint b=it.fir.fir-a;\n\t\tint kaz=it.sec;\n\t\tif(kaz==0){continue;}\n\t\tif(!(maebas.fir==it.fir.fir&&maebas.sec+1==it.fir.sec)){sen=0;}//前と連結してない\n\t\tif(ban[mp(a-1+b-1,a-1)]>0){ans+=kaz;mineq(sen,kaz);}//接続あり\n\t\telse{\n\t\t\tans+=kaz;ans+=max(0,kaz-sen);sen=kaz;\n\t\t\tif(ban[mp(a-1+b,a-1)]+ban[mp(a+b,a-1)]==0&&a>0&&b>0){dme;}\n\t\t\tif(ban[mp(a+b-1,a)]+ban[mp(a+b,a+1)]==0&&a>0&&b>0){dme;}\n\t\t}\n\t\tmaebas=it.fir;\n\t\t\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool find(pair<int,int> *P,int n,int a,int b)\n{\n  int k=lower_bound(P,P+n,make_pair(a,b))-P;\n  return k<n&&P[k]==make_pair(a,b);\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  static int A[100000],B[100000];\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",A+i,B+i);\n  }\n  if(A[0]!=0||B[1]!=0||A[1]!=B[0]){\n    puts(\"-1\");\n    return 0;\n  }\n  int L=A[1];\n  int C=L;\n  static pair<int,int> P[100000];\n  for(int i=0;i<n;i++){\n    P[i]=make_pair(A[i],B[i]);\n    if((i!=0&&A[i]==0)||(i!=1&&B[i]==0)||A[i]+B[i]<L||A[i]-B[i]>L||B[i]-A[i]>L){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  sort(P,P+n);\n  static bool X[100000];\n  for(int i=0;i<n;i++){\n    if(A[i]+B[i]==L){\n      X[i]=1;\n    }\n    else{\n      int k=lower_bound(P,P+n,make_pair(A[i]-1,B[i]-1))-P;\n      if(k<n&&P[k]==make_pair(A[i]-1,B[i]-1)){\n\t//printf(\"%d\\n\",i);\n\tX[i]=1;\n\tC++;\n      }\n    }\n  }  \n  for(int i=0;i<n;i++){\n    if(X[i]){\n      continue;\n    }\n    else{\n      int a1=A[i]-1,b1=min(A[i]-1+L,B[i]+1);\n      int a2=min(B[i]-1+L,A[i]+1),b2=B[i]-1;\n      int k1=lower_bound(P,P+n,make_pair(a1,b1))-P;\n      int k2=lower_bound(P,P+n,make_pair(a2,b2))-P;\n      if(k1<n&&P[k1]==make_pair(a1,b1)&&k2<n&&P[k2]==make_pair(a2,b2)){\n\tif(X[k1]){\n\t  C++;\n\t}\n\tC++;\n      }\n      else{\n\tputs(\"-1\");\n\treturn 0;\n      }\n    }\n  }\n  printf(\"%d\\n\",C);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\nint main() {\n\tint N;\n\twhile(~scanf(\"%d\", &N)) {\n\t\tvector<int> A(N);\n\t\tvector<int> B(N);\n\t\tfor(int i = 0; i < N; ++ i)\n\t\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\n\t\tbool ok = true;\n\t\tset<pair<int, int>> coordinates;\n\t\tmap<pair<int, int>, vector<int>> unmatched;\n\t\trep(i, N) {\n\t\t\tok &= (A[i] == 0) == (i == 0);\n\t\t\tok &= (B[i] == 0) == (i == 1);\n\t\t\tcoordinates.insert(make_pair(A[i], B[i]));\n\t\t\tunmatched[{A[i], B[i]}].push_back(i);\n\t\t}\n\t\tvector<pair<int, int>> ord(N);\n\t\trep(i, N)\n\t\t\tord[i] = {A[i], i};\n\t\tsort(ord.begin(), ord.end());\n\t\tvector<bool> matched(N);\n\t\tint matching = 0;\n\t\trep(ix, N) {\n\t\t\tint i = ord[ix].second;\n\t\t\tif(i != 0) {\n\t\t\t\tbool ook = false;\n\t\t\t\trer(d, -1, 1)\n\t\t\t\t\took |= coordinates.count({ A[i] - 1, B[i] + d }) != 0;\n\t\t\t\tok &= ook;\n\t\t\t}\n\t\t\tif(i != 1) {\n\t\t\t\tbool ook = false;\n\t\t\t\trer(d, -1, 1)\n\t\t\t\t\took |= coordinates.count({ A[i] + d, B[i] - 1 }) != 0;\n\t\t\t\tok &= ook;\n\t\t\t}\n\t\t\tif(!matched[i] && coordinates.count({ A[i] - 1, B[i] - 1 })) {\n\t\t\t\t++ matching;\n\t\t\t} else {\n\t\t\t\tauto &v = unmatched[{ A[i] + 1, B[i] - 1 }];\n\t\t\t\tif(!v.empty()) {\n\t\t\t\t\tmatched[v.back()] = true;\n\t\t\t\t\tv.pop_back();\n\t\t\t\t\t++ matching;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = N * 2 - 2 - matching;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010];\nint L;\nint did[101010];\nint ok[101010];\n\nset<pair<int,int>> S;\nvector<pair<int,int>> V[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i]>>B[i];\n\t\n\tif(A[0]!=0) return _P(\"-1\\n\");\n\tif(B[1]!=0) return _P(\"-1\\n\");\n\tif(A[1]!=B[0]) return _P(\"-1\\n\");\n\tL=A[1];\n\tok[0]=ok[L]=1;\n\tdid[0]=did[1]=1;\n\t\n\tS.insert({0,L});\n\tS.insert({L,0});\n\tint ret=1;\n\tfor(i=2;i<N;i++) {\n\t\tif(A[i]==0 || B[i]==0) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<L) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]==L && ok[A[i]]==0) {\n\t\t\tdid[i]=1;\n\t\t\tok[A[i]]=1;\n\t\t\tret++;\n\t\t\tS.insert({A[i],B[i]});\n\t\t}\n\t\telse {\n\t\t\tV[A[i]+B[i]].push_back({A[i],i});\n\t\t}\n\t}\n\tFOR(i,L+1) if(ok[i]==0) return _P(\"-1\\n\");\n\tfor(i=L;i<=200000;i++) if(V[i].size()) {\n\t\tsort(ALL(V[i]));\n\t\tFOR(j,4) {\n\t\t\tFORR(r,V[i]) {\n\t\t\t\tx = r.second;\n\t\t\t\tif(did[x]) continue;\n\t\t\t\tif(S.count({A[x]-1,B[x]-1})) ret++;\n\t\t\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdid[x]=1;\n\t\t\t\tS.insert({A[x],B[x]});\n\t\t\t}\n\t\t\t\n\t\t\ty=-1;\n\t\t\tFOR(x,V[i].size()) {\n\t\t\t\tif(x>0 && abs(V[i][x].first-V[i][x-1].first)>1) y=-1;\n\t\t\t\t\n\t\t\t\tif(did[V[i][x].second]) {\n\t\t\t\t\tif(y>=0) {\n\t\t\t\t\t\twhile(y<x) {\n\t\t\t\t\t\t\tdid[V[i][y].second]=1;\n\t\t\t\t\t\t\tS.insert({A[V[i][y].second],B[V[i][y].second]});\n\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ty=x;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treverse(ALL(V[i]));\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tFOR(i,N) if(did[i]==0) return _P(\"-1\\n\");\n\t_P(\"%d\\n\",ret);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define N 100005\n#define fr first\n#define se second\n#define check(x,y) (mp.find(make_pair(x,y))!=mp.end())\nusing namespace std;\nstruct msg{\n\tint x,y,num;\n};\npii v[N];\nvector<msg> b[N*2];\nmap<pii,int > mp;\nmap<pii,int >::iterator itr;\nint dp[N][2];\nint n,ans,d;\nvoid end(){\n\tputs(\"-1\");\n\texit(0);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&v[i].first,&v[i].se),mp[v[i]]++;\n\td=v[1].se;\n\tfor(itr=mp.begin();itr!=mp.end();itr++){\n\t\tb[(itr->fr).fr+(itr->fr).se].push_back((msg){(itr->fr).fr,(itr->fr).se,itr->se});\n\t}\n\tfor(int i=0;i<d;i++) if(b[i].size()>0) end();\n\tif(mp[v[1]]!=1||mp[v[2]]!=1||v[1].fr!=0||v[2].se!=0||v[1].se!=v[2].fr) end();\n\t\n\tfor(int i=d;i<=n*2;i++){\n\t\tfor(int j=0;j<b[i].size();j++){\n\t\t\tdp[j][0]=dp[j][1]=0x3f3f3f3f;\n\t\t\tif(j==0){\n\t\t\t\tif(i==d) {dp[j][0]=0;continue;}\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)){\n\t\t\t\t\tdp[j][0]=dp[j][1]=b[i][j].num;\n\t\t\t\t}else if(check(b[i][j].x-1,b[i][j].y)){\n\t\t\t\t\tdp[j][0]=b[i][j].num;\n\t\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\t\tdp[j][1]=b[i][j].num*2;\n\t\t\t\t}else end();\n\t\t\t}else{\n\t\t\t\tint temp=0x3f3f3f3f;\n\t\t\t\tif(b[i][j-1].x+1==b[i][j].x)\n\t\t\t\t\ttemp=dp[j-1][0]+max(b[i][j].num,b[i][j-1].num);\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y))\n\t\t\t\t\ttemp=min(temp,dp[j-1][1]+b[i][j].num);\n\t\t\t\tdp[j][0]=temp;\n\t\t\t\t\n\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\ttemp+=b[i][j].num;\n\t\t\t\telse temp=0x3f3f3f3f;\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)) temp=min(temp,min(dp[j-1][1],dp[j][0])+b[i][j].num);\n\t\t\t\tdp[j][0]=min(dp[j][0],dp[j][1]=temp);\n\t\t\t}\n\t\t}\n\t\tif(i==d) ans+=dp[b[i].size()-1][0];\n\t\telse ans+=dp[b[i].size()-1][1];\n\t\tif(ans>1e9) end();\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <numeric>\n#include <limits>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define tr(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n\nint N;\nint A[100010], B[100010];\n\nint solve() {\n  try {\n    rep (i, N) {\n      if ((A[i] == 0) != (i == 0)) throw 0;\n      if ((B[i] == 0) != (i == 1)) throw 0;\n    }\n\n    int D = B[0];\n    if (A[1] != D) throw 0;\n\n    map<pair<int, int>, int> cnt;\n    rep (i, N) cnt[mp(A[i], B[i])] += 1;\n\n    map<int, map<int, int>> taba;\n    rep (i, N) {\n      taba[A[i] + B[i]][A[i]] += 1;\n    }\n\n    for (int d = 0; d < D; ++d) {\n      if (taba.count(d)) throw 0;\n    }\n\n    int ans = N - 1;\n\n    for (auto &i : taba) {\n      int d = i.first;\n      map<int, int> &m = i.second;\n\n      int request = 0;  // request from left\n      for (const auto &j : m) {\n        int a = j.first, b = d - a, c = j.second;\n        if (a > 0 && cnt[mp(a - 1, b - 1)] + cnt[mp(a - 1, b)] + cnt[mp(a - 1, b + 1)] == 0) {\n          throw 0;\n        }\n\n        int hige;\n        if (cnt[mp(a - 1, b - 1)]) hige = max(0, c - request);\n        else hige = 0;\n        c -= hige;\n\n        ans += max(0, request - c);\n\n        if (cnt[(mp(a + 1, b - 1))] > 0) {\n          request = c;\n        } else if (b > 0) {\n          if (cnt[mp(a - 1, b - 1)] + cnt[mp(a, b - 1)] + cnt[mp(a + 1, b - 1)] == 0) {\n            throw 0;\n          }\n          ans += c;\n          request = 0;\n        }\n      }\n    }\n    return ans;\n  } catch (...) {\n    return -1;\n  }\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  rep (i, N) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n  }\n\n  int ans1 = solve();\n\n  rep (i, N) swap(A[i], B[i]);\n  swap(A[0], A[1]);\n  swap(B[0], B[1]);\n  int ans2 = solve();\n\n  assert(ans1 == ans2);\n  printf(\"%d\\n\", ans1);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010],C[101010],D[101010];\nmap<pair<int,int>,vector<int>> M;\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tM[{A[i],B[i]}].push_back(i);\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(i==0) {\n\t\t\tif(A[i]) return _P(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tC[i]=1;\n\t\t\tif(M.count({A[i]-1,B[i]-1})+M.count({A[i]-1,B[i]})+M.count({A[i]-1,B[i]+1})==0) return _P(\"-1\\n\");\n\t\t}\n\t\tif(i==1) {\n\t\t\tif(B[i]) return _P(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tD[i]=1;\n\t\t\tif(M.count({A[i]-1,B[i]-1})+M.count({A[i],B[i]-1})+M.count({A[i]+1,B[i]-1})==0) return _P(\"-1\\n\");\n\t\t}\n\t}\n\t\n\tint ret=2*N-2;\n\tFORR(m,M) {\n\t\tauto a=m.first;\n\t\ta.first++;\n\t\ta.second--;\n\t\ty=0;\n\t\tFORR(x,m.second) {\n\t\t\tif(C[x]&&D[x]&&M.count({A[x]-1,B[x]-1})) {\n\t\t\t\tret--;\n\t\t\t\tC[x]=D[x]=0;\n\t\t\t}\n\t\t\tif(D[x]&&M.count(a)&&y<M[a].size()) {\n\t\t\t\tC[M[a][y]]=0;\n\t\t\t\tret--;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nlong long int N;\nchar A[1000000000000];\nint f[12], ans = 0;\n\nint ctoi(char c) {\n\tswitch (c) {\n\tcase '0': return 0;\n\tcase '1': return 1;\n\tcase '2': return 2;\n\tcase '3': return 3;\n\tcase '4': return 4;\n\tcase '5': return 5;\n\tcase '6': return 6;\n\tcase '7': return 7;\n\tcase '8': return 8;\n\tcase '9': return 9;\n\tdefault: return -1;\n\t}\n}\n\nint main(void) {\n\tscanf(\"%lld\", &N);\n\tint cou = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%s\", &A);\n\t\tfor (int j = strlen(A) - 1; j >= 0; --j) {\n\t\t\tf[cou] = std::max(f[cou], ctoi(A[j]));\n\t\t\t++cou;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < cou; ++i) { ans += f[i]; }\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010];\nint L;\nint did[101010];\nint ok[101010];\n\nset<pair<int,int>> S;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i]>>B[i];\n\t\n\tif(A[0]!=0) return _P(\"-1\\n\");\n\tif(B[1]!=0) return _P(\"-1\\n\");\n\tif(A[1]!=B[0]) return _P(\"-1\\n\");\n\tL=A[1];\n\tok[0]=ok[L]=1;\n\tdid[0]=did[1]=1;\n\t\n\tS.insert({0,L});\n\tS.insert({L,0});\n\tvector<pair<int,int>> V;\n\tint ret=1;\n\tfor(i=2;i<N;i++) {\n\t\tif(A[i]==0 || B[i]==0) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<L) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]==L) {\n\t\t\tdid[i]=1;\n\t\t\tif(ok[A[i]]==1) ret++;\n\t\t\tok[A[i]]=1;\n\t\t\tret++;\n\t\t\tS.insert({A[i],B[i]});\n\t\t}\n\t\telse {\n\t\t\tV.push_back({A[i]+B[i],i});\n\t\t}\n\t}\n\tFOR(i,L+1) if(ok[i]==0) return _P(\"-1\\n\");\n\tsort(ALL(V));\n\tFORR(r,V) {\n\t\tx = r.second;\n\t\tif(S.count({A[x]-1,B[x]-1})) {\n\t\t\tret++;\n\t\t}\n\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x],B[x]-1})) {\n\t\t\tret+=2;\n\t\t}\n\t\telse {\n\t\t\treturn _P(\"-1\\n\");\n\t\t}\n\t\tS.insert({A[x],B[x]});\n\t}\n\taseert(0);\n\t_P(\"%d\\n\",ret);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010];\nint L;\nint did[101010];\nint ok[101010];\n\nset<pair<int,int>> S;\nset<pair<int,int>> S2;\nvector<pair<int,int>> V[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tint ret=1;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tif(i>1 && S2.count({A[i],B[i]})) {\n\t\t\tret+=2;\n\t\t\tdid[i]=1;\n\t\t}\n\t\tS2.insert({A[i],B[i]});\n\t}\n\t\n\tif(A[0]!=0) return _P(\"-1\\n\");\n\tif(B[1]!=0) return _P(\"-1\\n\");\n\tif(A[1]!=B[0]) return _P(\"-1\\n\");\n\tL=A[1];\n\tok[0]=ok[L]=1;\n\tdid[0]=did[1]=1;\n\t\n\tS.insert({0,L});\n\tS.insert({L,0});\n\tfor(i=2;i<N;i++) {\n\t\tif(did[i]) continue;\n\t\tif(A[i]==0 || B[i]==0) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<L) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]==L && ok[A[i]]==0) {\n\t\t\tdid[i]=1;\n\t\t\tok[A[i]]=1;\n\t\t\tret++;\n\t\t\tif(S.count({A[i],B[i]})) ret++;\n\t\t\tS.insert({A[i],B[i]});\n\t\t}\n\t\telse {\n\t\t\tV[A[i]+B[i]].push_back({A[i],i});\n\t\t}\n\t}\n\tFOR(i,L+1) if(ok[i]==0) return _P(\"-1\\n\");\n\tfor(i=L;i<=200000;i++) if(V[i].size()) {\n\t\tsort(ALL(V[i]));\n\t\tFOR(j,4) {\n\t\t\tFORR(r,V[i]) {\n\t\t\t\tx = r.second;\n\t\t\t\tif(did[x]) continue;\n\t\t\t\tif(S.count({A[x]-1,B[x]-1})) ret++;\n\t\t\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdid[x]=1;\n\t\t\t\tS.insert({A[x],B[x]});\n\t\t\t}\n\t\t\t\n\t\t\ty=-1;\n\t\t\tFOR(x,V[i].size()) {\n\t\t\t\tif(x>0 && abs(V[i][x].first-V[i][x-1].first)>1) y=-1;\n\t\t\t\t\n\t\t\t\tif(did[V[i][x].second]) {\n\t\t\t\t\tif(y>=0 && y-x>1) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t\twhile(y<x) {\n\t\t\t\t\t\t\tdid[V[i][y].second]=1;\n\t\t\t\t\t\t\tS.insert({A[V[i][y].second],B[V[i][y].second]});\n\t\t\t\t\t\t\tret++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ty=x;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treverse(ALL(V[i]));\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tFOR(i,N) if(did[i]==0) return _P(\"-1\\n\");\n\t_P(\"%d\\n\",ret);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010];\nint L;\nint did[101010];\nint ok[101010];\n\nset<pair<int,int>> S;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i]>>B[i];\n\t\n\tif(A[0]!=0) return _P(\"-1\\n\");\n\tif(B[1]!=0) return _P(\"-1\\n\");\n\tif(A[1]!=B[0]) return _P(\"-1\\n\");\n\tL=A[1];\n\tok[0]=ok[L]=1;\n\tdid[0]=did[1]=1;\n\t\n\tS.insert({0,L});\n\tS.insert({L,0});\n\tvector<pair<int,int>> V;\n\tint ret=1;\n\tfor(i=2;i<N;i++) {\n\t\tif(A[i]==0 || B[i]==0) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<L) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]==L) {\n\t\t\tdid[i]=1;\n\t\t\tif(ok[A[i]]==1) ret++;\n\t\t\tok[A[i]]=1;\n\t\t\tret++;\n\t\t\tS.insert({A[i],B[i]});\n\t\t}\n\t\telse {\n\t\t\tV.push_back({A[i]+B[i],i});\n\t\t}\n\t}\n\tFOR(i,L+1) if(ok[i]==0) return _P(\"-1\\n\");\n\tsort(ALL(V));\n\tFORR(r,V) {\n\t\tx = r.second;\n\t\tif(S.count({A[x]-1,B[x]-1})) {\n\t\t\tret++;\n\t\t}\n\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x],B[x]-1})) {\n\t\t\tret+=2;\n\t\t}\n\t\telse {\n\t\t\treturn _P(\"-1\\n\");\n\t\t}\n\t\tS.insert({A[x],B[x]});\n\t}\n\t_P(\"%d\\n\",ret);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nint A[SIZE],B[SIZE],cnt[2][SIZE];\nVI d[SIZE],d2[SIZE];\nvoid NO(){puts(\"-1\");exit(0);}\nint main(){\n    DRI(N);\n    REP(i,N)RII(A[i+1],B[i+1]);\n    if(A[1]||B[2]||B[1]!=A[2]||A[2]==0)NO();\n    int dd=A[2];\n    int an=dd;\n    int one=0;\n    int oneone=0;\n    REPP(i,3,N+1){\n        if(!A[i]||!B[i])NO();\n        if(A[i]+B[i]==dd){\n            cnt[0][A[i]]++;\n            if(cnt[0][A[i]]>1)an+=2;\n        }\n        else if(A[i]+B[i]==dd+1){\n            cnt[1][A[i]]++;\n            if(cnt[1][A[i]]>1)an+=2;\n            one=1;\n        }\n        else if(A[i]+B[i]<dd)NO();\n        else{\n            oneone=1;\n            an++;\n            int p=A[i]+dd-B[i];\n            if(p%2){\n                int p2=A[i]+dd+1-B[i];\n                if(p2/2<=0||p2/2>dd)NO();\n                d2[p2/2].PB(A[i]-p2/2);\n            }\n            else{\n                if(p/2<0||p/2>dd)NO();\n                d[p/2].PB(A[i]-p/2);\n            }\n        }\n    }\n    REPP(i,1,dd){\n        if(!cnt[0][i])NO();\n    }\n    if(!one&&oneone)NO();\n    if(one){\n        an+=dd+1;\n        REPP(i,1,dd+1){\n            if(!cnt[1][i])NO();\n        }\n        REPP(i,1,dd+1){\n            int lt=0;\n            sort(ALL(d2[i]));\n            REP(j,SZ(d2[i])){\n                if(d2[i][j]!=lt&&d2[i][j]!=lt+1)NO();\n                lt=d2[i][j];\n            }\n        }\n    }\n    REP(i,dd+1){\n        int lt=0;\n        sort(ALL(d[i]));\n        REP(j,SZ(d[i])){\n            if(d[i][j]!=lt&&d[i][j]!=lt+1)NO();\n            lt=d[i][j];\n        }\n    }\n    printf(\"%d\\n\",an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 100005\n#define M 200005\n#define seed 23333\n\nusing namespace std;\nconst int inf=(int)1e9;\nint i,j,m,n,p,k,A[N],B[N],l;\nmap<pair<int,int>,int>mp;\nvector<int>v[M];\nint f[2][N],ans,sum[N],size[2],now,last;\nint RE()\n{\n\t\tputs(\"-1\");\n\t\texit(0);\n}\nint main()\n{\n\t\tscanf(\"%d\",&n); ans=2*n-2;\n\t\tfor (i=1;i<=n;++i) \n\t\t{\n\t\t\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\t\t\tmp[mk(A[i],B[i])]=1;\n\t\t\t\tif (i!=1&&!A[i]) RE();\n\t\t\t\tif (i!=2&&!B[i]) RE();\n\t\t}\n\t\tfor (i=1;i<=n;++i)\n\t\t{\n\t\t\t\tif (i!=1&&mp.find(mk(A[i]-1,B[i]))==mp.end()&&\n\t\t\t\t\t\tmp.find(mk(A[i]-1,B[i]-1))==mp.end()&&\n\t\t\t\t\t\tmp.find(mk(A[i]-1,B[i]+1))==mp.end()) RE();\n\t\t\t\tif (i!=2&&mp.find(mk(A[i],B[i]-1))==mp.end()&&\n\t\t\t\t\t\tmp.find(mk(A[i]-1,B[i]-1))==mp.end()&&\n\t\t\t\t\t\tmp.find(mk(A[i]+1,B[i]-1))==mp.end()) RE();\n\t\t\t\tv[A[i]+B[i]].pb(A[i]);\n\t\t}\n\t\tfor (i=1;i<=2*n;++i)\n\t\t\t\tif (v[i].size())\n\t\t\t\t{\n\t\t\t\t\t\tA[0]=B[0]=0;\n\t\t\t\t\t\tfor (j=0;j<(int)v[i].size();++j) A[++A[0]]=v[i][j],B[++B[0]]=v[i][j]; \n\t\t\t\t\t\tsort(B+1,B+B[0]+1); B[0]=unique(B+1,B+B[0]+1)-(B+1);\n\t\t\t\t\t\tfor (j=1;j<=B[0];++j) sum[j]=0;\n\t\t\t\t\t\tfor (j=1;j<=A[0];++j) sum[lower_bound(B+1,B+B[0]+1,A[j])-B]++;\n\t\t\t\t\t\tsize[0]=size[1]=now=last=0; now=1;\n\t\t\t\t\t\tsize[1]=sum[1];\n\t\t\t\t\t\tif (mp.find(mk(B[1]-1,i-B[1]-1))!=mp.end())\n\t\t\t\t\t\tfor (j=0;j<=size[now];++j) f[now][j]=size[now]-j;\n\t\t\t\t\t\telse for (j=0;j<=size[now];++j) f[now][j]=0;\n\t\t\t\t\t\tfor (j=2;j<=B[0];++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnow^=1; last=now^1;\n\t\t\t\t\t\t\t\tfor (l=0;l<=size[now];++l) f[now][l]=0;\n\t\t\t\t\t\t\t\tif (mp.find(mk(B[1]-1,i-B[1]-1))==mp.end())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t  for (l=0;l<=size[last];++l)\n\t\t\t\t\t\t\t\t\t  \t f[now][sum[j]]=max(f[now][sum[j]],f[last][l]+min(sum[j],l));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t int Max=-inf;\n\t\t\t\t\t\t\t\t\t for (l=0;l<=size[now];++l)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (l<=size[last]) Max=max(Max,f[last][l]+l);\n\t\t\t\t\t\t\t\t\t\t\tf[now][l]=Max;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t Max=-inf;\n\t\t\t\t\t\t\t\t\t for (l=max(size[last],size[now]);l>=0;--l)\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t \t\tif (l<=size[last]) Max=max(Max,f[last][l]);\n\t\t\t\t\t\t\t\t\t \t\tif (l<=size[now])\n\t\t\t\t\t\t\t\t\t \t\tf[now][l]=max(f[now][l],Max+l);\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t for (l=0;l<=size[now];++l)\n\t\t\t\t\t\t\t\t\t \tf[now][l]+=(size[now]-l);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsize[now]=sum[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint Max=0;\n\t\t\t\t\t\tfor (j=0;j<=size[now];++j) Max=max(Max,f[now][j]);\n\t\t\t\t\t\tans-=Max;\n\t\t\t\t}\n\t\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n     \n#define pb emplace_back\n#define fi first\n#define se second\n     \nusing namespace std;\n     \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\n     \n// head\n\nint n;\n\nint a[100010], b[100010];\n\nint main(){\n\n  n = in();\n  REP( i , n ){\n    a[i] = in();\n    b[i] = in();\n  }\n\n  if( a[0] != 0 ){\n    puts( \"-1\" );\n    return 0;\n  }\n  if( b[1] != 0 ){\n    puts( \"-1\" );\n    return 0;\n  }\n  if( a[1] != b[0] ){\n    puts( \"-1\" );\n    return 0;\n  }\n\n  REP( i , n ){\n    if( a[1] + b[i] < a[i] ){\n      puts( \"-1\" );\n      return 0;\n    }\n    if( a[1] + a[i] < b[i] ){\n      puts( \"-1\" );\n      return 0;\n    }\n  }\n\n  puts( \"-1\" );\n  // assert( false );\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <numeric>\n#include <limits>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define tr(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n\nint N;\nint A[100010], B[100010];\n\nint solve() {\n  try {\n    rep (i, N) {\n      if ((A[i] == 0) != (i == 0)) throw 0;\n      if ((B[i] == 0) != (i == 1)) throw 0;\n    }\n\n    int D = B[0];\n    if (A[1] != D) throw 0;\n\n    map<pair<int, int>, int> cnt;\n    rep (i, N) cnt[mp(A[i], B[i])] += 1;\n\n    map<int, map<int, int>> taba;\n    rep (i, N) {\n      if (i == 1) continue;\n      taba[A[i] + B[i]][A[i]] += 1;\n    }\n\n    for (int d = 0; d < D; ++d) {\n      if (taba.count(d)) throw 0;\n    }\n\n    int ans = N - 1;\n\n    for (auto &i : taba) {\n      map<int, int> &m = i.second;\n      int d = i.first;\n\n      int request = 0;  // request from left\n      for (const auto &j : m) {\n        int a = j.first, b = d - a, c = j.second;\n        if (a > 0 && cnt[mp(a - 1, b - 1)] + cnt[mp(a - 1, b)] + cnt[mp(a - 1, b + 1)] == 0) {\n          throw 0;\n        }\n\n        int hige;\n        if (cnt[mp(a - 1, b - 1)]) hige = max(0, c - request);\n        else hige = 0;\n        c -= hige;\n\n        ans += max(0, request - c);\n\n        if (cnt[(mp(a + 1, b - 1))] > 0) {\n          request = c;\n        } else {\n          if (b > 0 && cnt[mp(a - 1, b - 1)] + cnt[mp(a, b - 1)] + cnt[mp(a + 1, b - 1)] == 0) {\n            throw 0;\n          }\n          ans += c;\n          request = 0;\n        }\n      }\n    }\n    return ans;\n  } catch (...) {\n    return -1;\n  }\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  rep (i, N) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n  }\n\n  int ans1 = solve();\n\n  rep (i, N) swap(A[i], B[i]);\n  swap(A[0], A[1]);\n  swap(B[0], B[1]);\n  int ans2 = solve();\n\n  assert(ans1 == ans2);\n  printf(\"%d\\n\", ans1);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\nlong long A[100005];\nlong long B[100005];\nint main(){\n\tcin >> N;\n\tlong long ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i] >> B[i];\n\t}\n\n\tif(A[0] == 0 && B[0] == 1){\n\t\treturn 1;\n\t}else{\n\n\n\t\tcout << N - 1 << endl;\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\nlong long A[100005];\nlong long B[100005];\nint main(){\n\tcin >> N;\n\tlong long ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i] >> B[i];\n\t}\n\n\tif(A[0] == 0 && B[1] == 1){\n\t\treturn 1;\n\t}else{\n\n\n\t\tcout << N - 1 << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n \nset<pair<int,int>> st;\npair<int,int> a[maxn];\nbool vis[maxn];\nint n;\n \nbool cmp(pair<int,int>a,pair<int,int>b) {\n    return a.first + a.second == b.first + b.second ?\n           a.first < b.first : a.first + a.second < b.first + b.second;\n}\n \nbool check_1() {\n    if(a[1].first!=0||a[2].second!=0||a[1].second!=a[2].first)return false;\n    return true;\n}\n \nbool check_2(int&ret) {\n    //if(n>2)sort(a+3,a+n+1, cmp);\n    if(a[1].second==0)return false;\n    vis[1] = vis[2] = 1;\n    st.insert(a[1]);\n    st.insert(a[2]);\n    ret += a[1].second;\n    if(a[1].second==1) return true;\n    int cnt = 0;\n    for(int i=3; i<=n; i++) {\n        if(a[i].first + a[i].second != a[1].second) continue;\n        if(st.find(a[i])!=st.end())continue;\n        st.insert(a[i]);\n        vis[i] = 1;\n        cnt++;\n    }\n    return cnt == a[1].second - 1;\n}\n \nbool pd(int x,int y) {\n    int x1 = x - 1, y1, x2, y2 = y - 1;\n    for(int y1 = y-1; y1<=y+1; y1++)\n        for(int x2=x-1; x2<=x+1; x2++) {\n            if(st.find(make_pair(x1,y1))==st.end())continue;\n            if(st.find(make_pair(x2,y2))==st.end())continue;\n            return true;\n        }\n    return false;\n}\n \nbool check_3(int&ret) {\n    for(int i=1; i<=n; i++) {\n        /*if(vis[i])continue;\n        pair<int,int> fa = make_pair(a[i].first-1,a[i].second-1);\n        if(st.find(fa)!=st.end()) {\n            vis[i]=1;\n            ret++;\n            st.insert(a[i]);\n        } else {\n            if(pd(a[i].first,a[i].second)) {\n                vis[i] = 1;\n                ret+=2;\n                st.insert(a[i]);\n            } else return false;\n        }*/\n        int pos = i;\n        for(int j=i;j<=n;j++) {\n          if(a[j].first + a[j].second != a[i].first + a[i].second)break;\n          pos = j;\n        }\n        for(int j=i;j<=pos;j++) {\n          if(vis[j]) continue;\n          if(st.find(make_pair(a[j].first-1,a[j].second-1))!=st.end()) {\n            vis[j] =1;\n            ret++;\n            st.insert(a[j]);\n          }\n        }\n        for(int j=i;j<=pos;j++){\n          if(vis[j])continue;\n          if(pd(a[j].first,a[j].second)){\n            vis[j] =1;\n            ret+=2;\n            st.insert(a[j]);\n          }\n        }\n        for(int j = i+1;j<pos;j++) {\n          if(vis[j])continue;\n          if(vis[j-1]&&vis[j+1]){\n            vis[j]=1;\n            ret+=2;\n            st.insert(a[j]);\n          } else return false;\n        }\n        if((!vis[i]) || (!vis[pos])) return false;\n        i = pos;\n    }\n    return true;\n}\n \nint main() {\n  //  freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    int ret = 0;\n    if(!check_1()) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    sort(a+1,a+n+1);\n    /*\n    if(!check_2(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }*/\n    if(!check_3(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    cout<<ret<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <numeric>\n#include <limits>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define tr(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n\nint N;\nint A[100010], B[100010];\nbool hige[100010];\n\nmap<pair<int, int>, int> cnt;\n\nvoid dmp() {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  rep (i, N) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n\n    if ((A[i] == 0) != (i == 0)) dmp();\n    if ((B[i] == 0) != (i == 1)) dmp();\n  }\n\n  int D = B[0];\n  if (A[1] != D) dmp();\n\n  rep (i, N) cnt[mp(A[i], B[i])] += 1;\n  rep (i, N) hige[i] = cnt.count(mp(A[i] - 1, B[i] - 1));\n\n  map<int, map<int, int>> taba;\n  rep (i, N) {\n    if (hige[i]) continue;\n    taba[A[i] + B[i]][A[i]] += 1;\n  }\n\n  for (int d = 0; d < D; ++d) {\n    if (taba.count(d)) dmp();\n  }\n\n  int ans = N - 2;  //count(hige, hige + N, true);\n\n  for (auto &i : taba) {\n    map<int, int> &m = i.second;\n    int d = i.first;\n\n    for (const auto &j : m) {\n      int a = j.first, b = d - a, c = j.second;\n\n      int prv_c = cnt[mp(a - 1, b + 1)];\n      int nxt_c = cnt[mp(a + 1, b - 1)];\n      // printf(\"%d %d: %d %d %d\\n\", a, b, prv_c, c, nxt_c);\n\n      int bgn = max(0, c - prv_c);\n      int end = max(0, c - nxt_c);\n\n      if (bgn > 0) {\n        // printf(\" %d\\n\", bgn);\n        ans += bgn;\n        if (a > 0 && (prv_c == 0 && cnt[mp(a - 1, b)] == 0)) {\n          //printf(\"%d %d\\n\", a, b);\n          dmp();\n        }\n      }\n      if (end > 0) {\n        if (b > 0 && (nxt_c == 0 && cnt[mp(a, b - 1)] == 0)) {\n          //          printf(\"%d %d\\n\", a, b);\n          dmp();\n        }\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010];\nint L;\nint did[101010];\nint ok[101010];\n\nset<pair<int,int>> S;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i]>>B[i];\n\t\n\tif(A[0]!=0) return _P(\"-1\\n\");\n\tif(B[1]!=0) return _P(\"-1\\n\");\n\tif(A[1]!=B[0]) return _P(\"-1\\n\");\n\tL=A[1];\n\tok[0]=ok[L]=1;\n\tdid[0]=did[1]=1;\n\t\n\tS.insert({0,L});\n\tS.insert({L,0});\n\tvector<pair<int,int>> V;\n\tint ret=1;\n\tfor(i=2;i<N;i++) {\n\t\tif(A[i]==0 || B[i]==0) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<L) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]==L) {\n\t\t\tdid[i]=1;\n\t\t\tif(ok[A[i]]==1) ret++;\n\t\t\tok[A[i]]=1;\n\t\t\tret++;\n\t\t\tS.insert({A[i],B[i]});\n\t\t}\n\t\telse {\n\t\t\tV.push_back({A[i]+B[i],i});\n\t\t}\n\t}\n\tFOR(i,L+1) if(ok[i]==0) return _P(\"-1\\n\");\n\tsort(ALL(V));\n\tFORR(r,V) {\n\t\tx = r.second;\n\t\tif(S.count({A[x]-1,B[x]-1})) {\n\t\t\tret++;\n\t\t}\n\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\telse {\n\t\t\treturn _P(\"-1\\n\");\n\t\t}\n\t\tS.insert({A[x],B[x]});\n\t}\n\t_P(\"%d\\n\",ret);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MX = 120000;\n\nint n;\nint a[MX];\nint b[MX];\nvector<int> go[MX];\n\nset<pair<int, int> > ss;\nset<pair<int, int> > sst;\nset<pair<int, int> > ss2;\nset<pair<int, int> > ss2t;\n\nvector<pair<int, int> > ed;\nvector<int> vv;\nmap<pair<int, int>, int> mm;\n\nvoid ex() {\n\tif (n != 3)\n\t\tassert(false);\n\tcout << -1 << \"\\n\";\n\texit(0);\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i] >> b[i];\n\tif (a[0] != 0 || b[1] != 0)\n\t\tex();\n\tfor (int i = 0; i < n; ++i) {\n\t\tgo[a[i]].push_back(i);\n\t}\n\tif ((int)go[0].size() != 1)\n\t\tex();\n\tss.insert(make_pair(b[0], 0));\n\tss2.insert(make_pair(b[0], 0));\n\tfor (int i = 0; i < n; ++i)\n\t\tmm[make_pair(a[i], b[i])] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tsst.clear();\n\t\tss2t.clear();\n\t\tfor (int j: go[i]) {\n\t\t\tauto it = ss.lower_bound(make_pair(b[j] + 1, 0));\n\t\t\tss2t.insert(make_pair(b[j], j));\n\t\t\tif (it != ss.end() && it->first == b[j] + 1) {\n\t\t\t\ted.push_back(make_pair(j, it->second));\n\t\t\t\tss.erase(it);\n\t\t\t\tsst.insert(make_pair(b[j], j));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tauto it = ss2.lower_bound(make_pair(b[j] - 1, 0));\n\t\t\t\tif (it != ss2.end() && it->second <= b[j] + 1) {\n\t\t\t\t\tif (it->second != b[j] - 1)\n\t\t\t\t\t\tsst.insert(make_pair(b[j], j));\n\t\t\t\t\ted.push_back(make_pair(j, it->second));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tex();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto j: ss)\n\t\t\tvv.push_back(j.second);\n\t\tswap(ss, sst);\n\t\tswap(ss2, ss2t);\n\t}\n\tfor (int j: vv) {\n\t\tif (j == 1)\n\t\t\tcontinue;\n\t\tint fl = 0;\n\t\tfor (int d = -1; d <= 1; ++d) {\n\t\t\tif (mm.count(make_pair(a[j] + d, b[j] - 1))) {\n\t\t\t\tfl = 1;\n\t\t\t\ted.push_back(make_pair(mm[make_pair(a[j] + d, b[j] - 1)], j));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!fl) {\n\t\t\tex();\n\t\t}\n\t}\n\tcout << ed.size() << \"\\n\";\n\t/*for (auto j: ed) {\n\t\tcout << j.first + 1 << \" \" << j.second + 1 << \"\\n\";\n\t}*/\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <numeric>\n#include <limits>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define tr(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n\nint N;\nint A[100010], B[100010];\n\nvoid dmp() {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  rep (i, N) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n\n    if ((A[i] == 0) != (i == 0)) dmp();\n    if ((B[i] == 0) != (i == 1)) dmp();\n  }\n\n  int D = B[0];\n  if (A[1] != D) dmp();\n\n  map<pair<int, int>, int> cnt;\n  rep (i, N) cnt[mp(A[i], B[i])] += 1;\n\n  map<int, map<int, int>> taba;\n  rep (i, N) {\n    if (i == 1) continue;\n    taba[A[i] + B[i]][A[i]] += 1;\n  }\n\n  for (int d = 0; d < D; ++d) {\n    if (taba.count(d)) dmp();\n  }\n\n  int ans = 1;\n\n  for (auto &i : taba) {\n    map<int, int> &m = i.second;\n    int d = i.first;\n\n    int request = 0;  // request from left\n    for (const auto &j : m) {\n      int a = j.first, b = d - a, c = j.second;\n      if (a > 0 && cnt[mp(a - 1, b - 1)] + cnt[mp(a - 1, b)] + cnt[mp(a - 1, b + 1)] == 0) {\n        dmp();\n      }\n\n      if (a > 0) {\n        ans += c;\n        //printf(\"%d %d: +=%d\\n\", a, b, c);\n      }\n\n      int hige;\n      if (cnt[mp(a - 1, b - 1)]) hige = max(0, c - request);\n      else hige = 0;\n      //printf(\"%d %d: hige=%d\\n\", a, b, hige);\n      c -= hige;\n\n      ans += max(0, request - c);\n\n      if (cnt[(mp(a + 1, b - 1))] > 0) {\n        request = c;\n      } else {\n        if (b > 0 && cnt[mp(a - 1, b - 1)] + cnt[mp(a, b - 1)] + cnt[mp(a + 1, b - 1)] == 0) {\n          dmp();\n        }\n        //printf(\"%d %d: -=%d\\n\", a, b, c);\n        ans += c;\n        request = 0;\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010];\nint L;\nint did[101010];\nint ok[101010];\n\nset<pair<int,int>> S;\nvector<pair<int,int>> V[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i]>>B[i];\n\t\n\tif(A[0]!=0) return _P(\"-1\\n\");\n\tif(B[1]!=0) return _P(\"-1\\n\");\n\tif(A[1]!=B[0]) return _P(\"-1\\n\");\n\tL=A[1];\n\tok[0]=ok[L]=1;\n\tdid[0]=did[1]=1;\n\t\n\tS.insert({0,L});\n\tS.insert({L,0});\n\tint ret=1;\n\tfor(i=2;i<N;i++) {\n\t\tif(A[i]==0 || B[i]==0) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<L) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]==L) {\n\t\t\tdid[i]=1;\n\t\t\tif(ok[A[i]]==1) ret++;\n\t\t\tok[A[i]]=1;\n\t\t\tret++;\n\t\t\tS.insert({A[i],B[i]});\n\t\t}\n\t\telse {\n\t\t\tV[A[i]+B[i]].push_back({A[i],i});\n\t\t}\n\t}\n\tFOR(i,L+1) if(ok[i]==0) return _P(\"-1\\n\");\n\tfor(i=L+1;i<=200000;i++) if(V[i].size()) {\n\t\tsort(ALL(V[i]));\n\t\tFOR(j,2) {\n\t\t\tFORR(r,V[i]) {\n\t\t\t\tx = r.second;\n\t\t\t\tif(did[x]) continue;\n\t\t\t\tif(S.count({A[x]-1,B[x]-1})) ret++;\n\t\t\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdid[x]=1;\n\t\t\t\tS.insert({A[x],B[x]});\n\t\t\t}\n\t\t\treverse(ALL(V[i]));\n\t\t}\n\t\t\n\t}\n\t\n\tFOR(i,N) if(did[i]==0) return _P(\"-1\\n\");\n\t\n\t_P(\"%d\\n\",ret);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <numeric>\n#include <limits>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define tr(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n\nint N;\nint A[100010], B[100010];\nbool hige[100010];\n\nmap<pair<int, int>, int> cnt;\n\nvoid dmp() {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  rep (i, N) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n\n    if ((A[i] == 0) != (i == 0)) dmp();\n    if ((B[i] == 0) != (i == 1)) dmp();\n  }\n\n  int D = B[0];\n  if (A[1] != D) dmp();\n\n  rep (i, N) cnt[mp(A[i], B[i])] += 1;\n  rep (i, N) hige[i] = cnt.count(mp(A[i] - 1, B[i] - 1));\n\n  map<int, map<int, int>> taba;\n  rep (i, N) {\n    if (hige[i]) continue;\n    taba[A[i] + B[i]][A[i]] += 1;\n  }\n\n  for (int d = 0; d < D; ++d) {\n    if (taba.count(d)) dmp();\n  }\n\n  int ans = N - 1;  //count(hige, hige + N, true);\n\n  for (auto &i : taba) {\n    map<int, int> &m = i.second;\n\n    for (const auto &j : m) {\n      int a = j.first, b = D - a, c = j.second;\n\n      int prv_c = cnt[mp(a - 1, b + 1)];\n      int nxt_c = cnt[mp(a + 1, b - 1)];\n\n      int bgn = max(0, c - prv_c);\n      int end = max(0, c - nxt_c);\n\n      if (bgn > 0) {\n        ans += bgn;\n        if (a > 0 || cnt[mp(a - 1, b)] == 0) dmp();\n      }\n      if (end > 0) {\n        if (b > 0 || cnt[mp(a, b - 1)] == 0) dmp();\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\nlong long A[100005];\nlong long B[100005];\nint main(){\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i] >> B[i];\n\t}\n\n\tcout << -1 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\ntypedef pair<int, int> pii;\n\nmap<pii, int> a;\n\nvoid ass(bool ex) {\n    if (!ex) {\n        cout << -1 << '\\n';\n        exit(0);\n    }\n}\n\npii operator+(pii a, pii b) {\n    return pii{a.first + b.first, a.second + b.second};\n}\n\npii operator-(pii a, pii b) {\n    return pii{a.first - b.first, a.second - b.second};\n}\n\npii nx(pii a) {\n    return a + pii{1, -1};\n}\n\nint main() {\n    #ifdef LOCAL\n    assert(freopen(\"a.in\", \"r\", stdin));\n    #else\n    #endif\n    int n;\n    cin >> n;\n    int d;\n    forn (i, n) {\n        int x, y;\n        cin >> x >> y;\n        if (i == 0) {\n            ass(x == 0);\n            d = y;\n        }\n        if (i == 1)\n            ass(y == 0 && d == x);\n        ass(x + y >= d);\n        ass(x >= 0 && y >= 0);\n        if (i != 0)\n            ass(x != 0);\n        if (i != 1)\n            ass(y != 0);\n        a[pii(x, y)]++;\n    }\n    for (auto p: a) {\n        auto c = p.first;\n        if (c.second != 0)\n            ass(a.count(c + pii(0, -1)) || a.count(c + pii(-1, -1)) || a.count(c + pii(1, -1)));\n        if (c.first != 0)\n            ass(a.count(c + pii(-1, 0)) || a.count(c + pii(-1, -1)) || a.count(c + pii(-1, 1)));\n    }\n    //cerr << \"YES\\n\";\n    vector<pair<pii, int>> v;\n    for (auto A: a)\n        v.push_back(A);\n    sort(v.begin(), v.end(), [](pair<pii, int> a, pair<pii, int> b) {\n                int sa = a.first.first + a.first.second;\n                int sb = b.first.first + b.first.second;\n                if (sa != sb)\n                    return sa < sb;\n                return a.first < b.first;\n            });\n    int res = 2 * n - 2;\n\n    int carry = 0;\n    forn (ii, sz(v)) {\n        auto c = v[ii].first;\n        int cnt = v[ii].second;\n        carry = min(carry, cnt);\n        if (a.count(c + pii{-1, -1})) {\n            int k = cnt - carry;\n            res -= k;\n            cnt -= k;\n        }\n        res -= carry;\n        if (ii + 1 < sz(v) && v[ii + 1].first == nx(c))\n            carry = cnt;\n        else\n            carry = 0;\n    }\n    cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve();\nvoid precalc();\nclock_t start;\n//int timer = 1;\n\nint testNumber = 1;\n\nbool todo = true;\n\nint main() {\n#ifdef AIM\n    freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n#else\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    start = clock();\n    int t = 1;\n    cout.sync_with_stdio(0);\n    cin.tie(0);\n    precalc();\n    cout.precision(10);\n    cout << fixed;\n    //cin >> t;\n    int testNum = 1;\n    while (t--) {\n        //cerr << testNum << endl;\n        //cout << \"Case #\" << testNum++ << \": \";\n        solve();\n        ++testNumber;\n        //++timer;\n    }\n\n#ifdef AIM\n    cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n    return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n    if (!w)\n        return 1 % mod;\n    if (w & 1)\n        return q * 1LL * binpow(q, w - 1, mod) % mod;\n    return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n    while (w) {\n        q %= w;\n        swap(q, w);\n    }\n    return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n    return q / gcd(q, w) * w;\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n\n//const int mod = 1000000007;\n\n\nvoid solve() {\n    int n;\n    cin >> n;\n    multiset<pair<int, int>> a;\n    int b, c, d, e;\n    cin >> b >> c >> d >> e;\n    if (b != 0 || e != 0 || c != d) {\n        cout << \"-1\\n\";\n        return;\n    }\n    int dist = c;\n    a.insert({dist, 0});\n    a.insert({0, dist});\n\n    for (int i = 2; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        a.insert({x, y});\n    }\n\n    map<int, int> cnt;\n    int ans = n - 1;\n\n    for (auto item : a) {\n        if (abs(item.first - item.second) > dist) {\n            cout << \"-1\\n\";\n            return;\n        }\n        int diff =  item.first + item.second - dist;\n        if (diff < 0) {\n            cout << \"-1\\n\";\n            return;\n        }\n        if (diff == 0) {\n            cnt[item.first]++;\n            continue;\n        }\n        if (diff == 1) {\n            ++ans;\n            continue;\n        }\n        if (a.find(make_pair(item.first  - 1, item.second - 1)) == a.end()) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n\n    for (auto item : cnt) {\n        if (item.first == 0 || item.first == d) {\n            if (item.second != 1) {\n                cout << \"-1\\n\";\n                return;\n            }\n        }\n        ans += item.second - 1;\n    }\n\n    if (cnt.size() != dist + 1) {\n        cout << \"-1\\n\";\n        return;\n    }\n\n    cout << ans << \"\\n\";\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nint N, A[101010], B[101010];\n\nvoid fail()\n{\n\tputs(\"-1\");\n\texit(0);\n}\n\nint bas[101010];\nmap<pair<int, int>, int> P;\n\nbool is_good(int y, int x)\n{\n\treturn P.count(make_pair(y - 1, x - 1)) > 0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) scanf(\"%d%d\", A + i, B + i);\n\n\tif (A[0] != 0) fail();\n\tif (B[1] != 0) fail();\n\tif (A[1] != B[0]) fail();\n\tint D = A[1];\n\n\tfor (int i = 2; i < N; ++i) {\n\t\tif (A[i] == 0 || B[i] == 0 || A[i] + B[i] < D) fail();\n\t}\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (A[i] + B[i] == D) {\n\t\t\tbas[A[i]] += 1;\n\t\t}\n\t}\n\n\tint ret = 0;\n\tfor (int i = 0; i < D; ++i) {\n\t\tif (bas[i] == 0) fail();\n\t\tret += max(bas[i], bas[i + 1]);\n\t}\n\n\tfor (int i = 0; i < N; ++i) P[make_pair(A[i], B[i])] += 1;\n\t/*\n\tfor (int i = 2; i < N; ++i) if (A[i] + B[i] != D) {\n\tint x = A[i], y = B[i];\n\tif (P.count(make_pair(x - 1, y - 1))) {\n\t++ret;\n\t} else if (P.count(make_pair(x, y - 1)) && P.count(make_pair(x - 1, y))) {\n\tret += 2;\n\t} else fail();\n\t}\n\t*/\n\tfor (map<pair<int, int>, int>::iterator p = P.begin(); p != P.end(); ++p) {\n\t\tint y = p->first.first, x = p->first.second;\n\t\tif (y + x == D) continue;\n\t//\tprintf(\"%d %d\\n\", y, x);\n\t\tif (P.count(make_pair(y - 1, x + 1)) == 0) {\n\t\t\tvector<pair<pair<int, int>, int> > V;\n\t\t\tfor (;;) {\n\t\t\t\tif (P.count(make_pair(y, x)) == 0) break;\n\t\t\t\tint cnt = P[make_pair(y, x)];\n\t\t\t\tif (cnt == 0) break;\n\t\t\t\tV.push_back(make_pair(make_pair(y, x), cnt));\n\t\t\t\ty += 1;\n\t\t\t\tx -= 1;\n\t\t\t}\n\n\t\t\tif (V.size() == 1) {\n\t\t\t//\tputs(\"www\");\n\t\t\t\ty = V[0].first.first, x = V[0].first.second;\n\t\t\t\tif (P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tret += V[0].second;\n\t\t\t\t} else if (P.count(make_pair(y - 1, x)) && P.count(make_pair(y, x - 1))) {\n\t\t\t\t\tret += 2 * V[0].second;\n\t\t\t\t} else fail();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//\tprintf(\"%d\\n\", ret);\n\t\t\tbool waf = false;\n\t\t\t{\n\t\t\t\ty = V[0].first.first, x = V[0].first.second;\n\t\t\t\tif (P.count(make_pair(y - 1, x)) || P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tif (!P.count(make_pair(y - 1, x - 1))) waf = true;\n\t\t\t\t\tret += V[0].second;\n\t\t\t\t} else fail();\n\t\t\t}\n\t\t\t{\n\t\t\t\ty = V[V.size() - 1].first.first, x = V[V.size() - 1].first.second;\n\t\t\t\tif (P.count(make_pair(y, x - 1)) || P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tif (!P.count(make_pair(y - 1, x - 1))) waf = true;\n\t\t\t\t\tret += V[V.size() - 1].second;\n\t\t\t\t} else fail();\n\t\t\t}\n\t\t\t//\tprintf(\"%d\\n\", ret);\n\t\t\tif (!waf) V[0].second = V[V.size() - 1].second = 0;\n\t\t\tfor (int i = 1; i < V.size(); ++i) {\n\t\t\t\ty = V[i].first.first, x = V[i].first.second;\n\t\t\t\tif (P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tret += V[i].second;\n\t\t\t\t\tV[i].second = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < V.size(); ++i) {\n\t\t\t\tret += max(V[i].second, V[i - 1].second);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 10;\nint ds[2][maxn];\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &ds[0][i], &ds[1][i]);\n  }\n  return 1;\n}\n\nint res;\n\nvoid solve() {\n  if (ds[0][0] || ds[1][1]) {\n    printf(\"-1\\n\");\n    return;\n  }\n  int d = ds[0][1];\n  if (ds[1][0] != d) {\n    printf(\"-1\\n\");\n    return;\n  }\n  vector<int> big(d + 1, 0);\n\n  vector<int> vs[2][d + 1];\n  for (int v = 0; v < n; ++v) {\n    int left = ds[0][v] + ds[1][v] - d;\n    if (left < 0 || abs(ds[0][v] - ds[1][v]) > d) {\n      printf(\"-1\\n\");\n      return;\n    }\n    if (left > 0) {\n      vs[left & 1][(ds[0][v] - ds[1][v] + d) / 2].pb((left + 1) / 2);\n    } else {\n      big[ds[0][v]] += 1;\n    }\n  }\n  res = 0;\n  for (int odd = 0; odd < 2; ++odd) {\n    vector<int> cool;\n    for (int i = 0; i <= d - odd; ++i) {\n      auto &cur = vs[odd][i];\n      sort(cur.begin(), cur.end());\n      int last = 0;\n      for (int i = 0; i < sz(cur);) {\n        int i0 = i;\n        while (i < sz(cur) && cur[i] == cur[i0]) {\n          ++i;\n        }\n        //eprintf(\"%dx  %d\\n\", i - i0, cur[i0]);\n        if (cur[i0] != last + 1) {\n          printf(\"-1\\n\");\n          return;\n        }\n        res += i - i0;\n        if (odd && cur[i0] == 1) {\n          cool.pb(i - i0);\n        }\n        ++last;\n      }\n      if (sz(cool) == i) {\n        cool.pb(0);\n      }\n    }\n    if (odd) {\n      for (int i = 0; i < sz(cool); ++i) {\n        while (cool[i]) {\n          int j = i;\n          while (j < sz(cool) && cool[j]) {\n            --cool[j];\n            ++j;\n          }\n          ++res;\n        }\n      }\n    }\n  }\n  if (big[0] != 1 || big[d] != 1) {\n    printf(\"-1\\n\");\n    return;\n  }\n  for (int i = 1; i < d; ++i) {\n    if (big[i] == 0) {\n      printf(\"-1\\n\");\n      return;\n    }\n  }\n  for (int i = 0; i < d; ++i) {\n    res += max(big[i], big[i + 1]);\n  }\n  printf(\"%d\\n\", res);\n}\n\nvoid gen() {\n  int m;\n  while (1) {\n    beg:;\n  n = rnd(10) + 2;\n  m = 0;\n  vector<vector<int> > es(n);\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      if (rnd(4) == 0) {\n        es[i].pb(j), es[j].pb(i);\n        eprintf(\"%d %d\\n\", i, j);\n        ++m;\n      }\n    }\n  }\n\n  for (int i = 0; i < 2; ++i) {\n    auto &dist = ds[i];\n    for (int v = 0; v < n; ++v) {\n      dist[v] = inf;\n    }\n    vector<int> st;\n    st.pb(i);\n    dist[i] = 0;\n    for (int l = 0; l < sz(st); ++l) {\n      int v = st[l];\n      for (int u : es[v]) {\n        if (dist[u] > dist[v] + 1) {\n          st.pb(u);\n          dist[u] = dist[v] + 1;\n        }\n      }\n    }\n    if (sz(st) < n) {\n      goto beg;\n    }\n  }\n  break;\n  }\n  eprintf(\"n = %d\\n\", n);\n  solve();\n  if (res == -1 || res > m) {\n    assert(0);\n  }\n}\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  if (0) {\n  while (1) {\n    gen();\n  }\n  }\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nint A[SIZE],B[SIZE],cnt[2][SIZE];\nVI d[SIZE],d2[SIZE];\nvoid NO(){puts(\"-1\");exit(0);}\nint main(){\n    DRI(N);\n    REP(i,N)RII(A[i+1],B[i+1]);\n    if(A[1]||B[2]||B[1]!=A[2]||A[2]==0)NO();\n    int dd=A[2];\n    int an=dd;\n    int one=0;\n    REPP(i,3,N+1){\n        if(!A[i]||!B[i])NO();\n        if(A[i]+B[i]==dd){\n            cnt[0][A[i]]++;\n            if(cnt[0][A[i]]>1)an+=2;\n        }\n        else if(A[i]+B[i]==dd+1){\n            cnt[1][A[i]]++;\n            if(cnt[1][A[i]]>1)an+=2;\n            one=1;\n        }\n        else{\n            an++;\n            int p=A[i]+dd-B[i];\n            if(p%2){\n                int p2=A[i]+dd+1-B[i];\n                if(p2/2<=0||p2/2>dd)NO();\n                d2[p2/2].PB(A[i]-p2/2);\n            }\n            else{\n                if(p/2<0||p/2>dd)NO();\n                d[p/2].PB(A[i]-p/2);\n            }\n        }\n    }\n    REPP(i,1,dd){\n        if(!cnt[0][i])NO();\n    }\n    if(one){\n        an+=dd+1;\n        REPP(i,1,dd+1){\n            if(!cnt[1][i])NO();\n        }\n        REPP(i,1,dd+1){\n            int lt=0;\n            sort(ALL(d2[i]));\n            REP(j,SZ(d2[i])){\n                if(d2[i][j]!=lt&&d2[i][j]!=lt+1)NO();\n                lt=d2[i][j];\n            }\n        }\n    }\n    REP(i,dd+1){\n        int lt=0;\n        sort(ALL(d[i]));\n        REP(j,SZ(d[i])){\n            if(d[i][j]!=lt&&d[i][j]!=lt+1)NO();\n            lt=d[i][j];\n        }\n    }\n    printf(\"%d\\n\",an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MX = 120000;\n\nint n;\nint a[MX];\nint b[MX];\nvector<int> go[MX];\n\nset<pair<int, int> > ss;\nset<pair<int, int> > sst;\nset<pair<int, int> > ss2;\nset<pair<int, int> > ss2t;\n\nvector<pair<int, int> > ed;\nvector<int> vv;\nmap<pair<int, int>, int> mm;\n\nvoid ex() {\n\tcout << -1 << \"\\n\";\n\texit(0);\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i] >> b[i];\n\tif (a[0] != 0 || b[1] != 0)\n\t\tex();\n\tfor (int i = 0; i < n; ++i) {\n\t\tgo[a[i]].push_back(i);\n\t}\n\tif ((int)go[0].size() != 1)\n\t\tex();\n\tss.insert(make_pair(b[0], 0));\n\tss2.insert(make_pair(b[0], 0));\n\tfor (int i = 0; i < n; ++i)\n\t\tmm[make_pair(a[i], b[i])] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tsst.clear();\n\t\tss2t.clear();\n\t\tfor (int j: go[i]) {\n\t\t\tauto it = ss.lower_bound(make_pair(b[j] + 1, 0));\n\t\t\tss2t.insert(make_pair(b[j], j));\n\t\t\tif (it != ss.end() && it->first == b[j] + 1) {\n\t\t\t\ted.push_back(make_pair(j, it->second));\n\t\t\t\tss.erase(it);\n\t\t\t\tsst.insert(make_pair(b[j], j));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tauto it = ss2.lower_bound(make_pair(b[j] - 1, 0));\n\t\t\t\tif (it != ss2.end() && it->second <= b[j] + 1) {\n\t\t\t\t\tif (it->second != b[j] - 1)\n\t\t\t\t\t\tsst.insert(make_pair(b[j], j));\n\t\t\t\t\ted.push_back(make_pair(j, it->second));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tex();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto j: ss)\n\t\t\tvv.push_back(j.second);\n\t\tswap(ss, sst);\n\t\tswap(ss2, ss2t);\n\t}\n\tfor (int j: vv) {\n\t\tif (j == 1)\n\t\t\tcontinue;\n\t\tint fl = 0;\n\t\tfor (int d = -1; d <= 1; ++d) {\n\t\t\tif (mm.count(make_pair(a[j] + d, b[j] - 1))) {\n\t\t\t\tfl = 1;\n\t\t\t\ted.push_back(make_pair(mm[make_pair(a[j] + d, b[j] - 1)], j));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!fl) {\n\t\t\tex();\n\t\t}\n\t}\n\tcout << ed.size() << \"\\n\";\n\t/*for (auto j: ed) {\n\t\tcout << j.first + 1 << \" \" << j.second + 1 << \"\\n\";\n\t}*/\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 100010;\n\nint N;\nint A[MN], B[MN];\nvector<int> Va[MN], Vb[MN];\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n\n        Va[ A[i] ].push_back(i);\n        Vb[ B[i] ].push_back(i);\n    }\n\n    if(A[0] || B[1]) {\n        printf(\"-1\");\n        return 0;\n    }\n    if(Va[0].size() > 1 || Vb[0].size() > 1) {\n        printf(\"-1\");\n        return 0;\n    }\n\n    multiset<int> pre;\n    pre.insert(B[0]);\n\n    for(int i = 1; i < N; i++) {\n        multiset<int> cur;\n\n        for(int j = 0; j < Va[i].size(); j++) {\n            int x = Va[i][j];\n\n            auto it = pre.lower_bound(B[x] - 1);\n            if(it == pre.end() || B[x] + 1 < *it) {\n                printf(\"-1\");\n                return 0;\n            }\n\n            cur.insert(B[x]);\n        }\n        pre = cur;\n    }\n\n    int ans = N - 1;\n\n    pre.clear();\n    pre.insert(A[1]);\n\n    for(int i = 1; i < N; i++) {\n        multiset<int> cur;\n\n        for(int j = 0; j < Vb[i].size(); j++) {\n            int x = Vb[i][j];\n\n            auto it = pre.lower_bound(A[x] - 1);\n            if(it == pre.end() || A[x] + 1 < *it) {\n                printf(\"-1\");\n                return 0;\n            }\n            cur.insert(A[x]);\n        }\n\n        vector<int> chk(Vb[i].size(), 0);\n        for(int j = 0; j < Vb[i].size(); j++) {\n            int x = Vb[i][j];\n\n            if(pre.find(A[x] - 1) != pre.end()) {\n                chk[j] = 1;\n                continue;\n            }\n        }\n        for(int j = 0; j < Vb[i].size(); j++) if(!chk[j]) {\n            int x = Vb[i][j];\n\n            if(pre.find(A[x] + 1) != pre.end()) {\n                pre.erase(pre.find(A[x] + 1));\n                continue;\n            }\n            else ans++;\n        }\n\n        pre = cur;\n    }\n\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef long long LL;\nmap<int, map<int,int> > d; //exists\nmap<int, map<int,int> > l; // freq[sum][xval]\nvector<int> xval;// \nvector<int> freq; // \nint n;\nint a[210000], b[210000];\nint main(){\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) cin >> a[i] >> b[i];\n\tif(a[0] != 0 || b[1] != 0 || a[1] != b[0] || a[1] == 0 || b[0] == 0){\n\t\t//cout << -1 << endl; return 0;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tif(a[i] + b[i] < a[0] + b[0]){\n\t\t\t//cout << -1 << endl; return 0;\n\t\t}\n\t\tif(i >= 2 && (a[i] == 0 || b[i] == 0) ){\n\t\t\t//cout << -1 << endl; return 0;\n\t\t}\n\t\td[a[i]][b[i]] = 1;\n\t\tl[a[i]+b[i]][a[i]]++;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tif(a[i] > 0){\n\t\t\tif(!d[a[i]-1][b[i]-1] && !d[a[i]-1][b[i]] && !d[a[i]-1][b[i]+1]){\n\t\t\t\t//cout << -1 << endl; return 0;\n\t\t\t}\n\t\t}\n\t\tif(b[i] > 0){\n\t\t\tif(!d[a[i]-1][b[i]-1] && !d[a[i]][b[i]-1] && !d[a[i]+1][b[i]-1]){\n\t\t\t\t//cout << -1 << endl; return 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tLL ans = 0;\n\tfor(int i = 0; i < 210000; i++){\n\t\txval.clear();\n\t\tfreq.clear();\n\t\tfor(map<int, int>::iterator it = l[i].begin(); it != l[i].end(); it++){\n\t\t\txval.push_back(it->first);\n\t\t\tfreq.push_back(it->second);\n\t\t}\n\t\tint l = 0;\n\t\tfor(int j = 0; j < xval.size(); j++){\n\t\t\tint numl = freq[j];\n\t\t\tint numd = freq[j];\n\t\t\tnuml -= l;\n\t\t\tint xc = xval[j];\n\t\t\tint yc = i-xval[j];\n\t\t\tif(xc == 0) numl = 0;\n\t\t\tif(yc == 0) numd = 0;\n\t\t\tif(d[xc-1][yc-1]){\n\t\t\t\tint r = min(numl,numd);\n\t\t\t\tnuml -= r;\n\t\t\t\tnumd -= r;\n\t\t\t\tans += r;\n\t\t\t}\n\t\t\tans += numl;\n\t\t\tl = numd;\n\t\t\tans += numd;\n\t\t\tif(j + 1 == xval.size() || xval[j+1] != xval[j] + 1) l = 0;\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define N 100005\n#define fr first\n#define se second\n#define check(x,y) (mp.find(make_pair(x,y))!=mp.end())\nusing namespace std;\nstruct msg{\n\tint x,y,num;\n};\npii v[N];\nvector<msg> b[N*2];\nmap<pii,int > mp;\nmap<pii,int >::iterator itr;\nint dp[N][2];\nint n,ans,d;\nvoid end(){\n\tputs(\"-1\");\n\texit(0);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&v[i].first,&v[i].se),mp[v[i]]++;\n\td=v[1].se;\n\tfor(itr=mp.begin();itr!=mp.end();itr++){\n\t\tb[(itr->fr).fr+(itr->fr).se].push_back((msg){(itr->fr).fr,(itr->fr).se,itr->se});\n\t}\n\tfor(int i=0;i<d;i++) if(b[i].size()>0) end();\n\tif(mp[v[1]]!=1||mp[v[2]]!=1||v[1].fr!=0||v[2].se!=0||v[1].se!=v[2].fr) end();\n\t\n\tfor(int i=d;i<=n*2;i++){\n\t\tfor(int j=0;j<b[i].size();j++){\n\t\t\tdp[j][0]=dp[j][1]=0x3f3f3f3f;\n\t\t\tif(j==0){\n\t\t\t\tif(i==d) {dp[j][0]=0;continue;}\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)){\n\t\t\t\t\tdp[j][0]=dp[j][1]=b[i][j].num;\n\t\t\t\t}else if(check(b[i][j].x-1,b[i][j].y)){\n\t\t\t\t\tdp[j][0]=b[i][j].num;\n\t\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\t\tdp[j][1]=b[i][j].num*2;\n\t\t\t\t}else end();\n\t\t\t}else{\n\t\t\t\tint temp=0x3f3f3f3f;\n\t\t\t\tif(b[i][j-1].x+1==b[i][j].x)\n\t\t\t\t\ttemp=dp[j-1][0]+max(b[i][j].num,b[i][j-1].num);\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y))\n\t\t\t\t\ttemp=min(temp,dp[j-1][1]+b[i][j].num);\n\t\t\t\tdp[j][0]=temp;\n\t\t\t\t\n\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\ttemp+=b[i][j].num;\n\t\t\t\telse temp=0x3f3f3f3f;\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)) temp=min(temp,min(dp[j-1][1],dp[j][0])+b[i][j].num);\n\t\t\t\tdp[j][0]=min(dp[j][0],dp[j][1]=temp);\n\t\t\t}\n\t\t}\n\t\tif(b[i].size()==0) continue;\n\t\tif(i==d) ans+=dp[b[i].size()-1][0];\n\t\telse ans+=dp[b[i].size()-1][1];\n\t\tif(ans>1e9) end();\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 10;\nint ds[2][maxn];\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &ds[0][i], &ds[1][i]);\n  }\n  return 1;\n}\n\nint res;\n\nvoid solve() {\n  if (ds[0][0] || ds[1][1]) {\n    printf(\"-1\\n\");\n    return;\n  }\n  int d = ds[0][1];\n  if (ds[1][0] != d) {\n    printf(\"-1\\n\");\n    return;\n  }\n  vector<int> big(d + 1, 0);\n\n  vector<int> vs[2][d + 1];\n  for (int v = 0; v < n; ++v) {\n    int left = ds[0][v] + ds[1][v] - d;\n    if (left < 0 || abs(ds[0][v] - ds[1][v]) > d) {\n      printf(\"-1\\n\");\n      return;\n    }\n    if (left > 0) {\n      vs[left & 1][(ds[0][v] - ds[1][v] + d) / 2].pb((left + 1) / 2);\n    } else {\n      big[ds[0][v]] += 1;\n    }\n  }\n  res = 0;\n  for (int odd = 0; odd < 2; ++odd) {\n    vector<int> cool;\n    for (int i = 0; i <= d - odd; ++i) {\n      auto &cur = vs[odd][i];\n      sort(cur.begin(), cur.end());\n      int last = 0;\n      for (int i = 0; i < sz(cur);) {\n        int i0 = i;\n        while (i < sz(cur) && cur[i] == cur[i0]) {\n          ++i;\n        }\n        //eprintf(\"%dx  %d\\n\", i - i0, cur[i0]);\n        if (cur[i0] != last + 1) {\n          printf(\"-1\\n\");\n          return;\n        }\n        res += i - i0;\n        if (odd && cur[i0] == 1) {\n          res += i - i0;\n          cool.pb(i - i0);\n        }\n        ++last;\n      }\n      if (sz(cool) == i) {\n        cool.pb(0);\n      }\n    }\n    if (odd) {\n      for (int i = 0; i < sz(cool) - 1; ++i) {\n        int cur = min(cool[i], cool[i + 1]);\n        res -= cur;\n      }\n    }\n  }\n  if (big[0] != 1 || big[d] != 1) {\n    printf(\"-1\\n\");\n    return;\n  }\n  for (int i = 1; i < d; ++i) {\n    if (big[i] == 0) {\n      printf(\"-1\\n\");\n      return;\n    }\n  }\n  for (int i = 0; i < d; ++i) {\n    res += max(big[i], big[i + 1]);\n  }\n  printf(\"%d\\n\", res);\n}\n\nvoid gen() {\n  int m;\n  while (1) {\n    beg:;\n  n = rnd(5) + 2;\n  m = 0;\n  vector<vector<int> > es(n);\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      if (rnd(4) == 0) {\n        es[i].pb(j), es[j].pb(i);\n        eprintf(\"%d %d\\n\", i, j);\n        ++m;\n      }\n    }\n  }\n\n  for (int i = 0; i < 2; ++i) {\n    auto &dist = ds[i];\n    for (int v = 0; v < n; ++v) {\n      dist[v] = inf;\n    }\n    vector<int> st;\n    st.pb(i);\n    dist[i] = 0;\n    for (int l = 0; l < sz(st); ++l) {\n      int v = st[l];\n      for (int u : es[v]) {\n        if (dist[u] > dist[v] + 1) {\n          st.pb(u);\n          dist[u] = dist[v] + 1;\n        }\n      }\n    }\n    if (sz(st) < n) {\n      goto beg;\n    }\n  }\n  break;\n  }\n  eprintf(\"n = %d\\n\", n);\n  solve();\n  if (res == -1 || res > m) {\n    assert(0);\n  }\n}\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  if (0) {\n  while (1) {\n    gen();\n  }\n  }\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010];\nint L;\nint did[101010];\nint ok[101010];\n\nset<pair<int,int>> S;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i]>>B[i];\n\t\n\tif(A[0]!=0) return _P(\"-1\\n\");\n\tif(B[1]!=0) return _P(\"-1\\n\");\n\tif(A[1]!=B[0]) return _P(\"-1\\n\");\n\tL=A[1];\n\tok[0]=ok[L]=1;\n\tdid[0]=did[1]=1;\n\t\n\tS.insert({0,L});\n\tS.insert({L,0});\n\tvector<pair<int,int>> V;\n\tint ret=1;\n\tfor(i=2;i<N;i++) {\n\t\tif(A[i]==0 || B[i]==0) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<L) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]==L) {\n\t\t\tdid[i]=1;\n\t\t\tif(ok[A[i]]==1) ret++;\n\t\t\tok[A[i]]=1;\n\t\t\tret++;\n\t\t\tS.insert({A[i],B[i]});\n\t\t}\n\t\telse {\n\t\t\tV.push_back({A[i]+B[i],i});\n\t\t}\n\t}\n\tFOR(i,L+1) if(ok[i]==0) return _P(\"-1\\n\");\n\tsort(ALL(V));\n\tFORR(r,V) {\n\t\tx = r.second;\n\t\tif((A[x]+B[x]-L)%2==0) {\n\t\t\tif(S.count({A[x]-1,B[x]-1})==0) return _P(\"-1\\n\");\n\t\t\tret++;\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tif(S.count({A[x]-1,B[x]})==0 || S.count({A[x],B[x]-1})==0) return _P(\"-1\\n\");\n\t\t\tret+=2;\n\t\t}\n\t\tS.insert({A[x],B[x]});\n\t}\n\t_P(\"%d\\n\",ret);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\nlong long A[100005];\nlong long B[100005];\nint main(){\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i] >> B[i];\n\t}\n\tcout << N-1 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\nbool comp (pair<int,int> a, pair<int,int>b){\n    return a.FI+a.SE<b.FI+b.SE or (a.FI+a.SE==b.FI+b.SE and a.FI<b.FI);\n}\nint cnt(multiset<pair<int,int>> &s, int a, int b){\n    return s.count(make_pair(a,b));\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,dmax=0;\n    cin >> n;\n    vector<pair<int,int>> d;\n    multiset<pair<int,int>> s;\n    REP(i,n){\n        int a,b;\n        cin >> a>>b;\n        //dmax=max(dmax,a+b);\n        s.insert(make_pair(a,b));\n        d.push_back(make_pair(a,b));\n    }\n    if(d[0].FI!=0 or d[1].SE!=0 or d[1].FI!=d[0].SE or d[0].SE==0){\n        cout << -1 << endl; return 0;\n    }\n    FOR(i,2,n){\n        if(d[i].FI==0 or d[i].SE==0){\n            cout << -1 << endl; return 0;\n        }\n    }\n    FOR(i,1,d[0].SE){\n        if(cnt(s,i,d[0].SE-i)==0){\n            cout << -1 << endl; return 0;\n        }\n    }\n    //0~1\n    int ans=cnt(s,1,d[0].SE-1);\n\n    FOR(i,1,d[0].SE){\n        ans+=max(cnt(s,i,d[0].SE-i),cnt(s,i+1,d[0].SE-i-1));\n    }\n    sort(d.begin(),d.end());\n    d.erase(unique(ALL(d)),d.end());\n    sort(d.begin(),d.end(),comp);\n    int succ=0;\n    for(auto it=lower_bound(ALL(d),make_pair(1,d[0].SE),comp); it<d.end();it++){\n        int d0=it->FI,d1=it->SE,add=0;\n        //DBG(ans)\n        //cout << d0 << ' ' <<d1  <<' '<<succ<<endl;\n        if(succ){\n            add=succ;\n            if(cnt(s,d0-1,d1-1)){\n                add=cnt(s,d0,d1);\n            }else if(cnt(s,d0+1,d1-1)){\n                add=succ=cnt(s,d0,d1);\n            }else if(cnt(s,d0,d1-1)){\n                add=cnt(s,d0,d1)*2;\n                succ=0;\n            }else {\n                cout << -1 << endl; return 0;\n            }\n        }else if(cnt(s,d0-1,d1-1)){\n            add=cnt(s,d0,d1);\n        }else if(cnt(s,d0-1,d1)or cnt(s,d0-1,d1+1)){\n            add=cnt(s,d0,d1);\n            if(cnt(s,d0+1,d1-1)){\n                succ=add;\n            }else if(cnt(s,d0,d1-1)){\n                add*=2;\n            }else{\n                cout << -1 << endl; return 0;\n            }\n        }else{\n            cout << -1 << endl; return 0;\n        }\n        ans+=add;\n    }\n\n    cout << ans <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n;\nint da[125252], db[125252];\nmap<pii,vi> M;\nint st[125252];\n// befa, befb, afta, aftb\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n)scanf(\"%d%d\",da+i,db+i);\n  REP(i,n){\n    int xa = da[i], xb = db[i];\n    M[pii(xa,xb)].push_back(i);\n  }\n  st[0] |= 1;\n  st[1] |= 2;\n  ll ans = 0;\n  for(auto P:M){\n    pii pos = P.first;\n    int xa = pos.first;\n    int xb = pos.second;\n    int pp = P.second.front();\n    if((st[pp]&1)==0){\n      if(M.count(pii(xa-1,xb-1))){\n        ans += P.second.size();\n        for(auto x:P.second){\n          st[x] |= 3;\n        }\n        continue;\n      }else if(M.count(pii(xa-1,xb+1))){\n        pii to = pii(xa-1,xb+1);\n        auto Q = M[to];\n        ans += max(P.second.size(),Q.size());\n        for(auto x:P.second){\n          st[x] |= 1;\n        }\n        for(auto x:Q){\n          st[x] |= 2;\n        }\n      }else if(M.count(pii(xa-1,xb))){\n        ans += P.second.size();\n        for(auto x:P.second){\n          st[x] |= 1;\n        }\n      }\n    }\n    if((st[pp]&2)==0){\n      if(M.count(pii(xa-1,xb-1))){\n        ans += P.second.size();\n        for(auto x:P.second){\n          st[x] |= 3;\n        }\n        continue;\n      }else if(M.count(pii(xa+1,xb-1))){\n        pii to = pii(xa+1,xb-1);\n        auto Q = M[to];\n        ans += max(P.second.size(),Q.size());\n        for(auto x:P.second){\n          st[x] |= 2;\n        }\n        for(auto x:Q){\n          st[x] |= 1;\n        }\n      }else if(M.count(pii(xa,xb-1))){\n        ans += P.second.size();\n        for(auto x:P.second){\n          st[x] |= 2;\n        }\n      }\n    }\n  }\n  REP(i,n){\n    // DEBUG(st[i]);\n    if(st[i]!=3){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  assert(false);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 100010;\n\nint N;\nint A[MN], B[MN];\nvector<int> Va[MN], Vb[MN];\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n\n        Va[ A[i] ].push_back(i);\n        Vb[ B[i] ].push_back(i);\n    }\n\n    if(A[0] || B[1]) {\n        printf(\"-1\");\n        return 0;\n    }\n\n    multiset<int> pre;\n    pre.insert(B[0]);\n\n    for(int i = 1; i < N; i++) {\n        multiset<int> cur;\n\n        for(int j = 0; j < Va[i].size(); j++) {\n            int x = Va[i][j];\n\n            auto it = pre.lower_bound(B[x] - 1);\n            if(it == pre.end() || B[x] + 1 < *it) {\n                printf(\"-1\");\n                return 0;\n            }\n\n            cur.insert(B[x]);\n        }\n        pre = cur;\n    }\n\n    int ans = N - 1;\n\n    pre.clear();\n    pre.insert(A[1]);\n\n    for(int i = 1; i < N; i++) {\n        multiset<int> cur;\n\n        for(int j = 0; j < Vb[i].size(); j++) {\n            int x = Vb[i][j];\n\n            auto it = pre.lower_bound(A[x] - 1);\n            if(it == pre.end() || A[x] + 1 < *it) {\n                printf(\"-1\");\n                return 0;\n            }\n            cur.insert(A[x]);\n        }\n\n        vector<int> chk(Vb[i].size(), 0);\n        for(int j = 0; j < Vb[i].size(); j++) {\n            int x = Vb[i][j];\n\n            if(pre.find(A[x] - 1) != pre.end()) {\n                chk[j] = 1;\n                continue;\n            }\n        }\n        for(int j = 0; j < Vb[i].size(); j++) if(!chk[j]) {\n            int x = Vb[i][j];\n\n            if(pre.find(A[x] + 1) != pre.end()) {\n                pre.erase(pre.find(A[x] + 1));\n                continue;\n            }\n            else ans++;\n        }\n\n        pre = cur;\n    }\n\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n\nusing namespace std;\n\nmap <pair<int, int>, int> mp[200000];\n\nbool check(pair<int, int> p, int da, int db) {\n    int a = p.first + da;\n    int b = p.second + db;\n    \n    return mp[a + b].count(make_pair(a, b));\n}\n\npair<int, int> before(pair<int, int> p, int c) {\n    int m1, m2;\n    \n    if (check(p, -1, -1)) {\n        m1 = c;\n    } else if (check(p, -1, 0) && check(p, 0, -1)) {\n        m1 = c * 2;\n    } else {\n        m1 = 1e9;\n    }\n    \n    if (check(p, -1, 0)) {\n        m2 = c;\n    } else {\n        m2 = 1e9;\n    }\n    \n    return make_pair(m1, m2);\n}\n\nint solve() {\n    int n, d, m = 0, ans = 0, i;\n    map <pair<int, int>, int>::iterator it, it2;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) {\n        int a, b;\n        \n        scanf(\"%d %d\", &a, &b);\n        \n        if (i == 0) {\n            if (a != 0 || b == 0) return -1;\n            \n            d = b;\n        } else if (i == 1) {\n            if (a != d || b != 0) return -1;\n        } else {\n            if (a == 0 || b == 0 || a + b < d) return -1;\n            \n            m = max(m, a + b);\n        }\n        \n        mp[a + b][make_pair(a, b)]++;\n    }\n    \n    for (it = mp[d].begin(); it != mp[d].end(); it++) {\n        if (it == mp[d].begin()) continue;\n        \n        it2 = it;\n        it2--;\n        \n        if (it2->first.first + 1 != it->first.first) return -1;\n        \n        ans += max(it->second, it2->second);\n    }\n    \n    for (i = d + 1; i <= m; i++) {\n        pair <int, int> p;\n        \n        if (mp[i].size() == 0) continue;\n        \n        for (it = mp[i].begin(); it != mp[i].end(); it++) {\n            if (it == mp[i].begin()) {\n                p = before(it->first, it->second);\n            } else {\n                it2 = it;\n                it2--;\n                \n                if (it2->first.first + 1 != it->first.first) {\n                    if (p.first >= 1e9) return -1;\n                    \n                    ans += p.first;\n                    p = before(it->first, it->second);\n                } else {\n                    int m1 = 1e9, m2 = 1e9, c = max(it->second, it2->second);\n                    \n                    if (check(it->first, -1, -1)) m1 = min(m1, min(p.first + it->second, p.second + c + it->second));\n                    if (check(it->first, 0, -1)) m1 = min(m1, min(p.first + c + it->second, p.second + c + it->second));\n                    if (check(it->first, -1, 0) && check(it->first, 0, -1)) m1 = min(m1, p.first + it->second * 2);\n                    \n                    m2 = min(m2, min(p.first + c, p.second + c));\n                    if (check(it->first, -1, 0)) m2 = min(m2, p.second + it->second);\n                    \n                    p = make_pair(m1, m2);\n                }\n            }\n        }\n        \n        if (p.first >= 1e9) return -1;\n        ans += p.first;\n    }\n    \n    return ans;\n}\n\nint main() {\n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\ntypedef pair<int, int> pii;\n\nmap<pii, int> a;\n\nvoid ass(bool ex) {\n    if (!ex) {\n        cout << -1 << '\\n';\n        exit(0);\n    }\n}\n\npii operator+(pii a, pii b) {\n    return pii{a.first + b.first, a.second + b.second};\n}\n\npii operator-(pii a, pii b) {\n    return pii{a.first - b.first, a.second - b.second};\n}\n\npii nx(pii a) {\n    return a + pii{1, -1};\n}\n\nint main() {\n    #ifdef LOCAL\n    assert(freopen(\"a.in\", \"r\", stdin));\n    #else\n    #endif\n    int n;\n    cin >> n;\n    int d;\n    forn (i, n) {\n        int x, y;\n        cin >> x >> y;\n        if (i == 0) {\n            ass(x == 0);\n            d = y;\n        }\n        if (i == 1)\n            ass(y == 0 && d == x);\n        ass(x + y >= d);\n        ass(x >= 0 && y >= 0);\n        if (i != 0)\n            ass(x != 0);\n        if (i != 1)\n            ass(y != 0);\n        a[pii(x, y)]++;\n    }\n    for (auto p: a) {\n        auto c = p.first;\n        if (c.second != 0)\n            ass(a.count(c + pii(0, -1)) || a.count(c + pii(-1, -1)) || a.count(c + pii(1, -1)));\n        if (c.first != 0)\n            ass(a.count(c + pii(-1, 0)) || a.count(c + pii(-1, -1)) || a.count(c + pii(-1, 1)));\n    }\n    //cerr << \"YES\\n\";\n    vector<pair<pii, int>> v;\n    for (auto A: a)\n        v.push_back(A);\n    sort(v.begin(), v.end(), [](pair<pii, int> a, pair<pii, int> b) {\n                int sa = a.first.first + a.first.second;\n                int sb = b.first.first + b.first.second;\n                if (sa != sb)\n                    return sa < sb;\n                return a.first < b.first;\n            });\n    int res = 2 * n - 2;\n\n    int carry = 0;\n    forn (ii, sz(v)) {\n        auto c = v[ii].first;\n        int cnt = v[ii].second;\n        int ncarry = 0;\n        if (ii + 1 < sz(v) && v[ii + 1].first == nx(c)) {\n            ncarry = min(v[ii + 1].second, cnt);\n            res -= ncarry;\n        }\n        int rem = cnt - carry - ncarry;\n        if (a.count(c + pii{-1, -1}) && rem > 0) {\n            res -= rem;\n        }\n        carry = ncarry;\n    }\n    cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define er erase\n#define bg begin()\n#define ed end()\n#define X first\n#define Y second\n#define fin(name) freopen(name, \"r\", stdin)\n#define fout(name) freopen(name, \"w\", stdout)\n#define files(name) fin(name\".in\"); fout(name\".out\")\n#define enter cout << \"\\n\"\n#define space cout << \" \"\n#define endl \"\\n\"\n#define fi(st,n) for (int i = (st); i <= (n); ++i)\n#define fj(st,n) for (int j = (st); j <= (n); ++j)\n#define fk(st,n) for (int k = (st); k <= (n); ++k)\n#define fq(st,n) for (int q = (st); q <= (n); ++q)\n#define fw(st,n) for (int w = (st); w <= (n); ++w)\n#define ff(i, st, n) for (int (i) = (st); (i) <= (n); ++(i))\n#define ei(st,n) for (int i = (st); i >= (n); --i)\n#define ej(st,n) for (int j = (st); j >= (n); --j)\n#define ek(st,n) for (int k = (st); k >= (n); --k)\n#define ef(i, st, n) for (int (i) = (st); (i) >= (n); --(i))\n#define ri(st,n) for (int i = (st); i < (n); ++i)\n#define rj(st,n) for (int j = (st); j < (n); ++j)\n#define rk(st,n) for (int k = (st); k < (n); ++k)\n#define rq(st,n) for (int q = (st); q < (n); ++q)\n#define rf(i, st, n) for (int (i) = (st); (i) < (n); ++(i))\n#define clean(a) memset((a),0,sizeof (a))\n#define sync ios_base::sync_with_stdio(0);cin.tie(0)\n#define y1 dsklmlvmd\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double dbl;\ntypedef long double ldbl;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int inf = (int)1e9;\nconst dbl eps = (dbl) 1e-8;\nconst int mod = (int) 10000007;\nconst int maxn = (int) 2 * 1e5 + 5;\n//const dbl M_PI = (dbl)2 * (dbl)acos(0);\n\n//cout<<fixed<<setprecision(10);\n//srand(time(0));\n\nint n;\npii a[maxn];\nint l, x, t[maxn], ans;\nset <pii> q;\n\nint main() {\n//    fin(\"t.in\");\n    sync;\n    cin >> n;\n    fi(1, n) {\n    \tcin >> a[i].X >> a[i].Y;\n    }\n    if (a[1].Y != a[2].X || a[1].Y == 0) {\n    \tcout << -1 << endl;\n    \treturn 0;\n    }\n    l = a[1].Y;\n    sort(a + 3, a + n + 1);\n    x = 1;\n    for (int i = 3; i <= n; ++i) {\n    \tt[i] = 0;\n    \tif (a[i].X == x && a[i].Y == l - x) {\n    \t\tt[i] = 1;\n    \t\t++x;\n    \t\tif (x == l)\n    \t\t\tbreak;\n    \t}\n    }\n    if (x != l) {\n    \tcout << -1 << endl;\n    \treturn 0;\n    }\n    fi(0, l) {\n    \tq.ins(mp(i, l - i));\n    }\n    ans = l;\n    for (int i = 3; i <= n; ++i) {\n    \tif (t[i])\n    \t\tcontinue;\n    \tif (a[i].X + a[i].Y < l) {\n    \t\tcout << -1 << endl;\n    \t\treturn 0;\n    \t}\n    \tif (q.count(mp(a[i].X - 1, a[i].Y - 1))) {\n    \t\t++ans;\n    \t\tq.ins(a[i]);\n    \t\tcontinue;\n    \t}\n    \tif (q.count(mp(a[i].X - 1, a[i].Y)) || q.count(mp(a[i].X, a[i].Y - 1))) {\n    \t\tans += 2;\n    \t\tq.ins(a[i]);\n    \t\tcontinue;\n    \t}\n    \t\tcout << -1 << endl;\n    \t\treturn 0;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010],C[101010],D[101010];\nmap<pair<int,int>,vector<int>> M;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcout<<-1<<endl;\n\treturn;\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tM[{A[i],B[i]}].push_back(i);\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(i==0) {\n\t\t\tif(A[i]) return _P(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tC[i]=1;\n\t\t\tif(M.count({A[i]-1,B[i]-1})+M.count({A[i]-1,B[i]})+M.count({A[i]-1,B[i]+1})==0) return _P(\"-1\\n\");\n\t\t}\n\t\tif(i==1) {\n\t\t\tif(B[i]) return _P(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tD[i]=1;\n\t\t\tif(M.count({A[i]-1,B[i]-1})+M.count({A[i],B[i]-1})+M.count({A[i]+1,B[i]-1})==0) return _P(\"-1\\n\");\n\t\t}\n\t}\n\t\n\tint ret=0;\n\tFORR(m,M) {\n\t\tauto a=m.first;\n\t\ta.first--;\n\t\ta.second++;\n\t\tif(M.count(a)) {\n\t\t\tx=min(m.second.size(),M[a].size());\n\t\t\tFOR(i,x) {\n\t\t\t\tret++;\n\t\t\t\tC[m.second[i]]=0;\n\t\t\t\tD[M[a][i]]=0;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,N) {\n\t\tif(C[i]+D[i]==2) {\n\t\t\tif(M.count({A[i]-1,B[i]-1})) ret++;\n\t\t\telse ret+=2;\n\t\t\t\n\t\t}\n\t\telse ret+=C[i]+D[i];\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n \nint a[100001];\nint b[100001];\nvi adj[100001];\nbool par[100001];\nvi aaa[100001];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\taaa[a[i]].pb(i);\n\t\tadj[b[i]].pb(i);\n\t}\n\tif(a[0]!=0||b[1]!=0)\n\t{\n\t\tcout<<-1<<'\\n';\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\tpar[0] = 1;\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\t//must come from last vec\n\t\tmap<int,vi> ma;\n\t\tmap<int,deque<int> > unused;\n\t\tfor(int j = 0; j < adj[i-1].size(); j++)\n\t\t{\n\t\t\t//cerr<<adj[i-1][j]<<'\\n';\n\t\t\tma[a[adj[i-1][j]]].pb(adj[i-1][j]);\n\t\t}\n\t\tfor(int j = 0; j < adj[i-1].size(); j++)\n\t\t{\n\t\t\tif(!par[adj[i-1][j]]) \n\t\t\t{\n\t\t\t\tif(aaa[a[adj[i-1][j]]-1].empty()) unused[a[adj[i-1][j]]].pb(adj[i-1][j]);\n\t\t\t\telse unused[a[adj[i-1][j]]].push_front(adj[i-1][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t{\n\t\t\tint v = adj[i][j];\n\t\t\tint d = a[v];\n\t\t\t//cerr<<v<<' '<<d<<' '<<unused[d+1].size()<<'\\n';\n\t\t\tif(!aaa[d-1].empty())\n\t\t\t{\n\t\t\t\tif(!unused[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tint u = unused[d+1].back();\n\t\t\t\t\tunused[d+1].pop_back();\n\t\t\t\t\tpar[u] = true;\n\t\t\t\t}\n\t\t\t\telse if(!par[v]&&!ma[d-1].empty())\n\t\t\t\t{\n\t\t\t\t\tpar[v] = true;\n\t\t\t\t}\n\t\t\t\telse if(ma[d-1].empty()&&ma[d].empty()&&ma[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tcout<<1231412<<'\\n';\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if((!unused[d+1].empty())&&(aaa[a[unused[d+1].back()]-1].empty()))\n\t\t\t{\n\t\t\t\tif(!unused[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tint u = unused[d+1].back();\n\t\t\t\t\tunused[d+1].pop_back();\n\t\t\t\t\tpar[u] = true;\n\t\t\t\t}\n\t\t\t\telse if(!par[v]&&!ma[d-1].empty())\n\t\t\t\t{\n\t\t\t\t\tpar[v] = true;\n\t\t\t\t}\n\t\t\t\telse if(ma[d-1].empty()&&ma[d].empty()&&ma[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tcout<<142142141<<'\\n';\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(!par[v]&&!ma[d-1].empty())\n\t\t\t\t{\n\t\t\t\t\tpar[v] = true;\n\t\t\t\t}\n\t\t\t\telse if(!unused[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tint u = unused[d+1].back();\n\t\t\t\t\tunused[d+1].pop_back();\n\t\t\t\t\tpar[u] = true;\n\t\t\t\t}\n\t\t\t\telse if(ma[d-1].empty()&&ma[d].empty()&&ma[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tcout<<14121525<<'\\n';\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(!par[i])\n\t\t{\n\t\t\t//cerr<<i<<'\\n';\n\t\t\tif(!aaa[a[i]-1].empty())\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout<<2132412<<'\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tassert(ans>=n-1);\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nint A[SIZE],B[SIZE],cnt[2][SIZE];\nVI d[SIZE],d2[SIZE];\nvoid NO(){puts(\"-1\");exit(0);}\nconst LL INF = 1e18; //INF should be enough large.\ntypedef long long MYTYPE;\nstruct data{\n    MYTYPE v;\n    int id;\n    data(MYTYPE _v,int _id):v(_v),id(_id){}\n    bool operator<(const data& b)const{return v>b.v;}\n};\nset<PII>pp;\nPII fix(PII X){\n    if(X.F>X.S)return MP(X.S,X.F);\n    return X;\n}\nstruct Dijkstra{\n    vector<pair<int,MYTYPE> >e[SIZE];\n    MYTYPE mi[SIZE];\n    bool used[SIZE];\n    int n,tt;\n    void init(int _n){\n        n=_n;\n        REP(i,n+1)e[i].clear();\n    }\n    void add_edge(int x,int y,MYTYPE v=1){\n        pp.insert(fix(MP(x,y)));\n        e[x].PB(MP(y,v));\n        e[y].PB(MP(x,v));\n    }\n    MYTYPE dis(int st,int ed){\n        priority_queue<data>qq;\n        REP(i,n+1)mi[i]=INF,used[i]=0;\n        mi[st]=0;\n        qq.push(data(0,st));\n        while(!qq.empty()){\n            data now=qq.top();qq.pop();\n            if(used[now.id])continue;\n            if(now.id==ed)return mi[ed];\n            used[now.id]=1;\n            REP(i,SZ(e[now.id])){\n                int y=e[now.id][i].F;\n                if(mi[y]>now.v+e[now.id][i].S){\n                    mi[y]=now.v+e[now.id][i].S;\n                    qq.push(data(mi[y],y));\n                }\n            }\n        }\n        return -1;\n    }\n}dij;\nint main(){\n    map<PII,int>H;\n    DRI(N);\n    dij.init(N);\n    REP(i,N){\n        RII(A[i+1],B[i+1]);\n        H[MP(A[i+1],B[i+1])]=i+1;\n    }\n    if(A[1]||B[2]||B[1]!=A[2]||A[2]==0)NO();\n    int dd=A[2];\n    if(dd==1)dij.add_edge(1,2,1);\n    REPP(i,3,N+1){\n        if(A[i]+B[i]<dd)NO();\n        if(H.count(MP(A[i]-1,B[i]-1))){\n            dij.add_edge(H[MP(A[i]-1,B[i]-1)],i);\n        }\n        else{\n            int id1=-1,id2=-1;\n            if(H.count(MP(A[i]-1,min(B[i]+1,A[i]-1+dd)))){\n                id1=H[MP(A[i]-1,min(B[i]+1,A[i]-1+dd))];\n            }\n            if(H.count(MP(min(A[i]+1,B[i]-1+dd),B[i]-1))){\n                id2=H[MP(min(A[i]+1,B[i]-1+dd),B[i]-1)];\n            }\n            if(id1==-1||id2==-1)NO();\n            dij.add_edge(id1,i);\n            dij.add_edge(id2,i);\n        }\n    }\n    dij.dis(1,-1);\n    REPP(i,1,N+1){\n        if(A[i]!=dij.mi[i])NO();\n    }\n    dij.dis(2,-1);\n    REPP(i,1,N+1){\n        if(B[i]!=dij.mi[i])NO();\n    }\n    printf(\"%d\\n\",SZ(pp));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010];\nint L;\nint did[101010];\nint ok[101010];\n\nset<pair<int,int>> S;\nvector<pair<int,int>> V[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i]>>B[i];\n\t\n\tif(A[0]!=0) return _P(\"-1\\n\");\n\tif(B[1]!=0) return _P(\"-1\\n\");\n\tif(A[1]!=B[0]) return _P(\"-1\\n\");\n\tL=A[1];\n\tok[0]=ok[L]=1;\n\tdid[0]=did[1]=1;\n\t\n\tS.insert({0,L});\n\tS.insert({L,0});\n\tint ret=1;\n\tfor(i=2;i<N;i++) {\n\t\tif(A[i]==0 || B[i]==0) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<L) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]==L && ok[A[i]]==0) {\n\t\t\tdid[i]=1;\n\t\t\tok[A[i]]=1;\n\t\t\tret++;\n\t\t\tS.insert({A[i],B[i]});\n\t\t}\n\t\telse {\n\t\t\tV[A[i]+B[i]].push_back({A[i],i});\n\t\t}\n\t}\n\tFOR(i,L+1) if(ok[i]==0) return _P(\"-1\\n\");\n\tfor(i=L;i<=200000;i++) if(V[i].size()) {\n\t\tsort(ALL(V[i]));\n\t\tFOR(j,4) {\n\t\t\tFORR(r,V[i]) {\n\t\t\t\tx = r.second;\n\t\t\t\tif(did[x]) continue;\n\t\t\t\tif(S.count({A[x]-1,B[x]-1})) ret++;\n\t\t\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x],B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\t\t\telse if(S.count({A[x]-1,B[x]+1}) && S.count({A[x]+1,B[x]-1})) ret+=2;\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdid[x]=1;\n\t\t\t\tS.insert({A[x],B[x]});\n\t\t\t}\n\t\t\treverse(ALL(V[i]));\n\t\t}\n\t\t\n\t}\n\t\n\tFOR(i,N) if(did[i]==0) return _P(\"-1\\n\");\n\tassert(0);\n\t_P(\"%d\\n\",ret);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main() {\n  int N; scanf(\"%d\", &N);\n  static int A[100000], B[100000];\n  static pair<int, int> ABtbl[100000];\n  static pair<int, int> BAtbl[100000];\n  for(int i = 0; i < N; ++i) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n    ABtbl[i] = make_pair(A[i], B[i]);\n    BAtbl[i] = make_pair(B[i], A[i]);\n  }\n  if(A[0] != 0 || B[1] != 0 || A[1] == 0 || A[1] != B[0]) {\n    printf(\"%d\\n\", -1);\n    return 0;\n  }\n  sort(ABtbl, ABtbl+N);\n  sort(BAtbl, BAtbl+N);\n  for(int i = 2; i < N; ++i) {\n    if(lower_bound(ABtbl, ABtbl+N, make_pair(A[i]-1, B[i]-1))\n        == upper_bound(ABtbl, ABtbl+N, make_pair(A[i]-1, B[i]+1))) {\n      printf(\"%d\\n\", -1);\n      return 0;\n    }\n    if(lower_bound(BAtbl, BAtbl+N, make_pair(B[i]-1, A[i]-1))\n        == upper_bound(BAtbl, BAtbl+N, make_pair(B[i]-1, A[i]+1))) {\n      printf(\"%d\\n\", -1);\n      return 0;\n    }\n  }\n  int count = 2 * (N-1);\n  for(int ii = 0; ii < N; ++ii) {\n    if(ii > 0 && ABtbl[ii-1] == ABtbl[ii]) continue;\n    int a = ABtbl[ii].first;\n    int b = ABtbl[ii].second;\n    if(lower_bound(ABtbl, ABtbl+N, make_pair(a-1, b+1))\n        < upper_bound(ABtbl, ABtbl+N, make_pair(a-1, b+1))) {\n      continue;\n    }\n    int have =\n      upper_bound(ABtbl, ABtbl+N, make_pair(a, b))\n        - lower_bound(ABtbl, ABtbl+N, make_pair(a, b));\n    int rem = have;\n    while(true) {\n      if(lower_bound(ABtbl, ABtbl+N, make_pair(a-1, b-1))\n          < upper_bound(ABtbl, ABtbl+N, make_pair(a-1, b-1))) {\n        // fprintf(stderr, \"(%d, %d) -- %d recyclable edges to (%d, %d)\\n\",\n        //     a, b, rem, a-1, b-1);\n        count -= rem;\n        rem = 0;\n      }\n      int capa = have - rem;\n      ++a;\n      --b;\n      have =\n        upper_bound(ABtbl, ABtbl+N, make_pair(a, b))\n          - lower_bound(ABtbl, ABtbl+N, make_pair(a, b));\n      if(have == 0) break;\n      // fprintf(stderr, \"(%d, %d) -- %d recyclable edges to (%d, %d)\\n\",\n      //     a, b, max(capa, have), a-1, b+1);\n      count -= max(capa, have);\n      rem = have - max(capa, have);\n    }\n  }\n  printf(\"%d\\n\", count);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nint n;\npair<int,int> a[maxn];\n\nbool check_1(){\n  if(a[1].first!=0||a[2].second!=0||a[2].first!=a[1].second||a[1].second==0)return false;\n  for(int i=3;i<=n;i++)\n    if(a[i].first==0||a[i].second==0||a[i].first+a[i].second<a[1].first+a[1].second)return false;\n  set<pair<int,int>>st;\n  for(int i=1;i<=n;i++)st.insert(a[i]);\n  for(int i=3;i<=n;i++){\n    int cnt=0;\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first-1,a[i].second+j))!=st.end()){\n        cnt++;\n        break;\n      }\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first+j,a[i].second-1))!=st.end()){\n        cnt++;\n        break;\n      }\n      if(cnt<2)return false;\n  }\n  return true;\n}\n\nbool cmp(pair<int,int> a,pair<int,int> b){\n  int ta = a.first + a.second;\n  int tb = b.first + b.second;\n  return ta == tb ? a.first < b.first: ta < tb;\n}\n\nint cal(){\n  int ret=0;\n  sort(a+1,a+n+1,cmp);\n  map<pair<int,int>,int>mp,f;\n  //map<pair<int,int>,int>f[2];\n  for(int i=1;i<=n;i++){\n    int pos = i;\n    vector<pair<int,int>>v;\n    v.push_back(a[i]);\n    for(int j = i;j<=n;j++){\n      if(a[j].first + a[j].second!=a[i].first + a[i].second)break;\n      pos = j;\n      if(mp.find(a[j])==mp.end())mp[a[j]]=1;\n      else mp[a[j]]+=1;\n      f[a[j]]=mp[a[j]];\n      //f[0][a[j]] = f[1][a[j]] = -1;\n      if(j>i&&a[j]!=a[i])v.push_back(a[j]);\n    }/*\n    f[0][v[0]]=0;\n    if(mp.find(make_pair(v[0].first-1,v[0].second-1))!=mp.end()){\n      f[1][v[0]] = mp[v[0]];\n    }\n    for(int j=0;j+1<v.size();j++){\n      if(f[0][v[j]]!=-1){\n        if(v[j].first == v[j+1].first - 1){\n          f[0][v[j+1]] = max(f[0][v[j+1]],f[0][v[j]] + min(mp[v[j]],mp[v[j+1]]));\n        } else {\n          f[0][v[j+1]] = max(f[0][v[j+1]],f[0][v[j]]);\n        }\n        if(mp.find(make_pair(v[j+1].first-1,v[j+1].second-1))!=mp.end()){\n          f[1][v[j+1]] = max(f[1][v[j+1]],f[0][v[j]]+mp[v[j+1]]);\n        }\n      }\n      if(f[1][v[j]]!=-1){\n        f[0][v[j+1]] = max(f[0][v[j+1]],f[1][v[j]]);\n        if(mp.find(make_pair(v[j+1].first-1,v[j+1].second-1))!=mp.end()){\n          f[1][v[j+1]] = max(f[1][v[j+1]],f[1][v[j]]+mp[v[j+1]]);\n        }\n      }\n    }\n    ret += max(0, max(f[0][v[v.size()-1]],f[1][v[v.size()-1]]));\n    */\n    for(int j=1;j<v.size();j++){\n      if(v[j-1].first+1==v[j].first){\n        int tt =min(mp[v[j-1]],mp[v[j]]);\n        ret+=tt;\n        f[v[j-1]] = min(f[v[j-1]],mp[v[j-1]]-tt);\n        f[v[j]] = min(f[v[j]],mp[v[j]]-tt);\n      }\n    }\n    for(int i=0;i<v.size();i++){\n      if(mp.find(make_pair(v[i].first-1,v[i].second-1))!=mp.end()){\n        ret+=f[v[i]];\n      }\n    }\n    i =pos;\n  }\n  return ret;\n}\n\nint main() {\n  //  freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    if(!check_1()){\n      cout<<-1<<endl;\n      return 0;\n    }\n    cout<<2*n-2-cal()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\tvector<pair<int, int> > A;\n\tfor(int i=0; i<N; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tA.emplace_back(a, b);\n\t}\n\tif(A[0].first!=0 || A[1].second!=0 || A[1].first!=A[0].second) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint ab = A[0].second;\n\tint sum = ab;\n\t{\n\t\tvector<int> vec(ab+1);\n\t\tfor(auto & p : A) {\n\t\t\tif(p.first+p.second==ab) {\n\t\t\t\t++vec[p.first];\n\t\t\t}\n\t\t}\n\t\tif(vec[0]!=1 || vec[ab]!=1) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i : vec) {\n\t\t\tif(i==0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(2<=i) {\n\t\t\t\tsum += (i-1)*2;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tvector<pair<int, int> > vec;\n\t\tfor(auto & p : A) {\n\t\t\tif(p.first+p.second!=ab) {\n\t\t\t\tint aa = p.first+p.second - ab;\n\t\t\t\tint aaHalf = (aa+1)>>1;\n\t\t\t\tint aaa = p.first-aaHalf;\n\t\t\t\tif(aa<=0) {\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(aa&1) {\n\t\t\t\t\tvec.emplace_back(p.first-aaHalf, aaHalf);\n\t\t\t\t\t++sum;\n\t\t\t\t}\n\t\t\t\tvec.emplace_back(p.first-(aa>>1), aaHalf);\n\t\t\t\t++sum;\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\tint beforeF = -1;\n\t\tint beforeS = 0;\n\t\tfor(auto & p : vec) {\n\t\t\tif(p.first!=beforeF) {\n\t\t\t\tbeforeF = p.first;\n\t\t\t\tbeforeS = 0;\n\t\t\t}\n\t\t\tif(p.second!=beforeS && p.second!=beforeS+1) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbeforeS = p.second;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define N 100005\n#define fr first\n#define se second\n#define check(x,y) (mp.find(make_pair(x,y))!=mp.end())\nusing namespace std;\nstruct msg{\n\tint x,y,num;\n};\npii v[N];\nvector<msg> b[N*2];\nmap<pii,int > mp;\nmap<pii,int >::iterator itr;\nint dp[N][2];\nint n,ans,d;\nvoid end(){\n\twhile(1);\n\tputs(\"-1\");\n\texit(0);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&v[i].first,&v[i].se),mp[v[i]]++;\n\td=v[1].se;\n\tfor(itr=mp.begin();itr!=mp.end();itr++){\n\t\tb[(itr->fr).fr+(itr->fr).se].push_back((msg){(itr->fr).fr,(itr->fr).se,itr->se});\n\t}\n\tfor(int i=0;i<d;i++) if(b[i].size()>0) end();\n\tif(mp[v[1]]!=1||mp[v[2]]!=1||v[1].fr!=0||v[2].se!=0||v[1].se!=v[2].fr) end();\n\t\n\tfor(int i=d;i<=n*2;i++){\n\t\tfor(int j=0;j<b[i].size();j++){\n\t\t\tdp[j][0]=dp[j][1]=0x3f3f3f3f;\n\t\t\tif(j==0){\n\t\t\t\tif(i==d) {dp[j][0]=0;continue;}\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)){\n\t\t\t\t\tdp[j][0]=dp[j][1]=b[i][j].num;\n\t\t\t\t}else if(check(b[i][j].x-1,b[i][j].y)){\n\t\t\t\t\tdp[j][0]=b[i][j].num;\n\t\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\t\tdp[j][1]=b[i][j].num*2;\n\t\t\t\t}else end();\n\t\t\t}else{\n\t\t\t\tint temp=0x3f3f3f3f;\n\t\t\t\tif(b[i][j-1].x+1==b[i][j].x)\n\t\t\t\t\ttemp=dp[j-1][0]+max(b[i][j].num,b[i][j-1].num);\n\t\t\t\telse if(check(b[i][j].x-1,b[i][j].y))\n\t\t\t\t\ttemp=dp[j-1][1]+b[i][j].num;\n\t\t\t\tdp[j][0]=temp;\n\t\t\t\t\n\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\ttemp+=b[i][j].num;\n\t\t\t\telse temp=0x3f3f3f3f;\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)) temp=min(temp,min(dp[j-1][1],dp[j][0])+b[i][j].num);\n\t\t\t\tdp[j][0]=min(dp[j][0],dp[j][1]=temp);\n\t\t\t}\n\t\t}\n\t\tif(i==d) ans+=dp[b[i].size()-1][0];\n\t\telse ans+=dp[b[i].size()-1][1];\n\t\tif(ans>1e9) end();\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nint a[100001];\nint b[100001];\nvi adj[100001];\nbool par[100001];\nvi aaa[100001];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\taaa[a[i]].pb(i);\n\t\tadj[b[i]].pb(i);\n\t}\n\tif(a[0]!=0||b[1]!=0)\n\t{\n\t\tcout<<-1<<'\\n';\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\tpar[0] = 1;\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\t//must come from last vec\n\t\tmap<int,vi> ma;\n\t\tmap<int,vi> unused;\n\t\tfor(int j = 0; j < adj[i-1].size(); j++)\n\t\t{\n\t\t\t//cerr<<adj[i-1][j]<<'\\n';\n\t\t\tma[a[adj[i-1][j]]].pb(adj[i-1][j]);\n\t\t}\n\t\tfor(int j = 0; j < adj[i-1].size(); j++)\n\t\t{\n\t\t\tif(!par[adj[i-1][j]]) unused[a[adj[i-1][j]]].pb(adj[i-1][j]);\n\t\t}\n\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t{\n\t\t\tint v = adj[i][j];\n\t\t\tint d = a[v];\n\t\t\t//cerr<<v<<' '<<d<<' '<<unused[d+1].size()<<'\\n';\n\t\t\tif(!par[v]&&!ma[d-1].empty())\n\t\t\t{\n\t\t\t\tpar[v] = true;\n\t\t\t}\n\t\t\telse if(!unused[d+1].empty())\n\t\t\t{\n\t\t\t\tint u = unused[d+1].back();\n\t\t\t\tunused[d+1].pop_back();\n\t\t\t\tpar[u] = true;\n\t\t\t}\n\t\t\telse if(ma[d-1].empty()&&ma[d].empty()&&ma[d+1].empty())\n\t\t\t{\n\t\t\t\tcout<<-1<<'\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//ans++;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(!par[i])\n\t\t{\n\t\t\t//cerr<<i<<'\\n';\n\t\t\tif(!aaa[a[i]-1].empty())\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout<<-1<<'\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101010],B[101010];\nint L;\nint did[101010];\nint ok[101010];\n\nset<pair<int,int>> S;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i]>>B[i];\n\t\n\tif(A[0]!=0) return _P(\"-1\\n\");\n\tif(B[1]!=0) return _P(\"-1\\n\");\n\tif(A[1]!=B[0]) return _P(\"-1\\n\");\n\tL=A[1];\n\tok[0]=ok[L]=1;\n\tdid[0]=did[1]=1;\n\t\n\tS.insert({0,L});\n\tS.insert({L,0});\n\tvector<pair<int,int>> V;\n\tint ret=1;\n\tfor(i=2;i<N;i++) {\n\t\tif(A[i]==0 || B[i]==0) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]<L) return _P(\"-1\\n\");\n\t\tif(A[i]+B[i]==L) {\n\t\t\tdid[i]=1;\n\t\t\tok[A[i]]=1;\n\t\t\tret++;\n\t\t\tS.insert({A[i],B[i]});\n\t\t}\n\t\telse {\n\t\t\tV.push_back({A[i]+B[i],i});\n\t\t}\n\t}\n\tFOR(i,L+1) if(ok[i]==0) return _P(\"-1\\n\");\n\tsort(ALL(V));\n\tFORR(r,V) {\n\t\tx = r.second;\n\t\tif((A[x]+B[x]-L)%2==0) {\n\t\t\tif(S.count({A[x]-1,B[x]-1})==0) return _P(\"-1\\n\");\n\t\t\tret++;\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tif(S.count({A[x]-1,B[x]})==0 || S.count({A[x],B[x]-1})==0) return _P(\"-1\\n\");\n\t\t\tret+=2;\n\t\t}\n\t\tS.insert({A[x],B[x]});\n\t}\n\t_P(\"%d\\n\",ret);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 2e4 + 10;\nint ds[2][maxn];\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &ds[0][i], &ds[1][i]);\n  }\n  return 1;\n}\n\nvoid solve() {\n  if (ds[0][0] || ds[1][1]) {\n    printf(\"-1\\n\");\n    return;\n  }\n  int d = ds[0][1];\n  if (ds[1][0] != d) {\n    printf(\"-1\\n\");\n    return;\n  }\n  vector<int> big(d + 1, 0);\n\n  vector<int> vs[2][d + 1];\n  for (int v = 0; v < n; ++v) {\n    int left = ds[0][v] + ds[1][v] - d;\n    if (left < 0 || abs(ds[0][v] - ds[1][v]) > d) {\n      printf(\"-1\\n\");\n      return;\n    }\n    if (left > 0) {\n      vs[left & 1][(ds[0][v] - ds[1][v] + d) / 2].pb((left + 1) / 2);\n    } else {\n      big[ds[0][v]] += 1;\n    }\n  }\n  int res = 0;\n  for (int odd = 0; odd < 2; ++odd) {\n    for (int i = 0; i <= d - odd; ++i) {\n      auto &cur = vs[odd][i];\n      sort(cur.begin(), cur.end());\n      int last = 0;\n      for (int i = 0; i < sz(cur);) {\n        int i0 = i;\n        while (i < sz(cur) && cur[i] == cur[i0]) {\n          ++i;\n        }\n        //eprintf(\"%dx  %d\\n\", i - i0, cur[i0]);\n        if (cur[i0] != last + 1) {\n          printf(\"-1\\n\");\n          return;\n        }\n        res += i - i0;\n        if (odd && cur[i0] == 1) {\n          res += i - i0;\n        }\n        ++last;\n      }\n    }\n  }\n  if (big[0] != 1 || big[d] != 1) {\n    printf(\"-1\\n\");\n    return;\n  }\n  for (int i = 1; i < d; ++i) {\n    if (big[i] == 0) {\n      printf(\"-1\\n\");\n      return;\n    }\n  }\n  for (int i = 0; i < d; ++i) {\n    res += max(big[i], big[i + 1]);\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve();\nvoid precalc();\nclock_t start;\n//int timer = 1;\n\nint testNumber = 1;\n\nbool todo = true;\n\nint main() {\n#ifdef AIM\n    freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n#else\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    start = clock();\n    int t = 1;\n    cout.sync_with_stdio(0);\n    cin.tie(0);\n    precalc();\n    cout.precision(10);\n    cout << fixed;\n    //cin >> t;\n    int testNum = 1;\n    while (t--) {\n        //cerr << testNum << endl;\n        //cout << \"Case #\" << testNum++ << \": \";\n        solve();\n        ++testNumber;\n        //++timer;\n    }\n\n#ifdef AIM\n    cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n    return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n    if (!w)\n        return 1 % mod;\n    if (w & 1)\n        return q * 1LL * binpow(q, w - 1, mod) % mod;\n    return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n    while (w) {\n        q %= w;\n        swap(q, w);\n    }\n    return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n    return q / gcd(q, w) * w;\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n\n//const int mod = 1000000007;\n\n\nvoid solve() {\n    int n;\n    cin >> n;\n    multiset<pair<int, int>> a;\n    int b, c, d, e;\n    cin >> b >> c >> d >> e;\n    if (b != 0 || e != 0 || c != d) {\n        cout << \"-1\\n\";\n        return;\n    }\n    int dist = c;\n    a.insert({dist, 0});\n    a.insert({0, dist});\n\n    for (int i = 2; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        a.insert({x, y});\n    }\n\n    map<int, int> cnt;\n    int ans = n - 1;\n\n    for (auto item : a) {\n        if (abs(item.first - item.second) > dist) {\n            cout << \"-1\\n\";\n            return;\n        }\n        int diff =  item.first + item.second - dist;\n        if (diff < 0) {\n            cout << \"-1\\n\";\n            return;\n        }\n        if (diff == 0) {\n            cnt[item.first]++;\n            continue;\n        }\n        if (diff == 1) {\n            ++ans;\n            continue;\n        }\n        if (a.find(make_pair(item.first  - 1, item.second - 1)) == a.end()) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n    int mx = 0;\n    for (auto item : cnt) {\n        if (item.first == 0 || item.first == d) {\n            if (item.second != 1) {\n                cout << \"-1\\n\";\n                return;\n            }\n        }\n        mx = max(mx, item.second - 1);\n    }\n\n    ans += mx;\n\n    if (cnt.size() != dist + 1) {\n        cout << \"-1\\n\";\n        return;\n    }\n\n    cout << ans << \"\\n\";\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\tvector<pair<int, int> > A;\n\tfor(int i=0; i<N; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tA.emplace_back(a, b);\n\t}\n\tif(A[0].first!=0 || A[1].second!=0 || A[1].first!=A[0].second) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint ab = A[0].second;\n\tint sum = ab;\n\t{\n\t\tvector<int> vec(ab+1);\n\t\tfor(auto & p : A) {\n\t\t\tif(p.first+p.second==ab) {\n\t\t\t\t++vec[p.first];\n\t\t\t}\n\t\t}\n\t\tif(vec[0]!=1 || vec[ab]!=1) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i : vec) {\n\t\t\tif(i==0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(2<=i) {\n\t\t\t\tsum += (i-1)*2;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tvector<pair<int, int> > vec;\n\t\tfor(auto & p : A) {\n\t\t\tif(p.first+p.second!=ab) {\n\t\t\t\tint aa = p.first+p.second - ab;\n\t\t\t\tint aaHalf = (aa+1)>>1;\n\t\t\t\tint aaa = p.first-aaHalf;\n\t\t\t\tif(aa<=1) {\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(aa&1) {\n\t\t\t\t\tvec.emplace_back(p.first-(aa>>1), aaHalf);\n\t\t\t\t\t++sum;\n\t\t\t\t}\n\t\t\t\tvec.emplace_back(p.first-aaHalf, aaHalf);\n\t\t\t\t++sum;\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\tint beforeF = -1;\n\t\tint beforeS = 0;\n\t\tfor(auto & p : vec) {\n\t\t\tif(p.first!=beforeF) {\n\t\t\t\tbeforeF = p.first;\n\t\t\t\tbeforeS = 0;\n\t\t\t}\n\t\t\tif(p.second!=beforeS && p.second!=beforeS+1) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbeforeS = p.second;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nint N;\nint A[101010],B[101010];\nmap<pair<int,int>,int> S;\nUF<500000> uf;\nmap<int,int> V[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tif(i!=0 && A[i]==0) return _P(\"-1\\n\");\n\t\tif(i==0 && A[i]) return _P(\"-1\\n\");\n\t\tif(i!=1 && B[i]==0) return _P(\"-1\\n\");\n\t\tif(i==1 && B[i]) return _P(\"-1\\n\");\n\t\tS[{A[i],B[i]}]=i;\n\t\tV[A[i]+B[i]][A[i]]++;\n\t}\n\tif(B[0]!=A[1]) return _P(\"-1\\n\");\n\t\n\tFOR(i,N) {\n\t\tif(i!=0) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i]-1,B[i]})) uf(i,S[{A[i]-1,B[i]}]);\n\t\t\tif(S.count({A[i]-1,B[i]+1})) uf(i,S[{A[i]-1,B[i]+1}]);\n\t\t}\n\t\tif(i!=1) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i],B[i]-1})) uf(i,S[{A[i],B[i]-1}]);\n\t\t\tif(S.count({A[i]+1,B[i]-1})) uf(i,S[{A[i]+1,B[i]-1}]);\n\t\t}\n\t}\n\tif(uf.count(0)!=N) return _P(\"-1\\n\");\n\tint ret=2*N-2;\n\tFOR(i,2*N) if(V[i].size()) {\n\t\tint pre=-2,left=0;\n\t\tint del=0;\n\t\tFORR(r,V[i]) {\n\t\t\tx = r.second;\n\t\t\tif(r.first==pre+1) {\n\t\t\t\tret -= min(left,x);\n\t\t\t\tdel+=min(left,x);\n\t\t\t\tx-=min(left,x);\n\t\t\t}\n\t\t\tif(S.count({r.first-1,(i-r.first)-1})) {\n\t\t\t\tret-=x;\n\t\t\t\tdel+=x;\n\t\t\t\tx=0;\n\t\t\t}\n\t\t\tpre=r.first;\n\t\t\tleft=x;\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nint A[SIZE],B[SIZE],cnt[2][SIZE];\nVI d[SIZE];\nvoid NO(){puts(\"-1\");exit(0);}\nint main(){\n    DRI(N);\n    REP(i,N)RII(A[i+1],B[i+1]);\n    if(A[1]||B[2]||B[1]!=A[2]||A[2]==0)NO();\n    int dd=A[2];\n    int an=dd;\n    int one=0;\n    REPP(i,3,N+1){\n        if(!A[i]||!B[i])NO();\n        if(A[i]+B[i]==dd){\n            cnt[0][A[i]]++;\n            if(cnt[0][A[i]]>1)an+=2;\n        }\n        else if(A[i]+B[i]==dd+1){\n            cnt[1][A[i]]++;\n            if(cnt[1][A[i]]>1)an+=2;\n            one=1;\n        }\n        else{\n            an++;\n            int p=A[i]+dd-B[i];\n            if(p%2)NO();\n            if(p/2<0||p/2>dd)NO();\n            d[p/2].PB(A[i]-p/2);\n        }\n    }\n    if(one){\n        an+=dd+1;\n        REPP(i,1,dd+1){\n            if(!cnt[1][i])NO();\n        }\n    }\n    REP(i,dd+1){\n        int lt=0;\n        sort(ALL(d[i]));\n        REP(j,SZ(d[i])){\n            if(d[i][j]!=lt&&d[i][j]!=lt+1)NO();\n            lt=d[i][j];\n        }\n    }\n    printf(\"%d\\n\",an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n\nusing namespace std;\n\nmap <pair<int, int>, int> mp[200000];\n\nbool check(pair<int, int> p, int da, int db) {\n    int a = p.first + da;\n    int b = p.second + db;\n    \n    if (a + b < 0) return false;\n    \n    return mp[a + b].count(make_pair(a, b));\n}\n\nbool before(pair<int, int> p) {\n    return check(p, -1, -1) || check(p, -1, 0) || check(p, -1, 1);\n}\n\nbool after(pair<int, int> p) {\n    return check(p, -1, -1) || check(p, 0, -1) || check(p, 1, -1);\n}\n\nint solve() {\n    int n, d, ans, i;\n    map <pair<int, int>, int>::iterator it, it2;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) {\n        int a, b;\n        \n        scanf(\"%d %d\", &a, &b);\n        \n        if (i == 0) {\n            if (a != 0 || b == 0) return -1;\n            \n            d = b;\n        } else if (i == 1) {\n            if (a != d || b != 0) return -1;\n        } else {\n            if (a == 0 || b == 0 || a + b < d) return -1;\n        }\n        \n        mp[a + b][make_pair(a, b)]++;\n    }\n    \n    ans = n * 2 - 2;\n    \n    for (i = d; i < n * 2; i++) {\n        int c;\n        \n        if (mp[i].size() == 0) continue;\n        \n        for (it = mp[i].begin(); it != mp[i].end(); it++) {\n            if (!before(it->first) && it->first.first > 0) return -1;\n            if (!after(it->first) && it->first.second > 0) return -1;\n            \n            if (it != mp[i].begin()) {\n                it2 = it;\n                it2--;\n                \n                if (it2->first.first + 1 == it->first.first) {\n                    ans -= min(it->second, c);\n                    it->second = max(it->second - c, 0);\n                }\n            }\n            \n            if (check(it->first, -1, -1)) {\n                ans -= it->second;\n                c = 0;\n            } else {\n                c = it->second;\n            }\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\nlong long A[100005];\nlong long B[100005];\nint main(){\n\tcin >> N;\n\tlong long ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i] >> B[i];\n\t\tif(A[i] == 1 && B[i] == 1){\n\t\t\tans++;\n\t\t}\n\t}\n\n\tans += N - 1;\n\n\tcout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nint n;\npair<int,int> a[maxn];\n\nbool check_1(){\n  if(a[1].first!=0||a[2].second!=0||a[2].first!=a[1].second)return false;\n  for(int i=3;i<=n;i++)\n    if(a[i].first==0||a[i].second==0)return false;\n  set<pair<int,int>>st;\n  for(int i=1;i<=n;i++)st.insert(a[i]);\n  for(int i=3;i<=n;i++){\n    int cnt=0;\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first-1,a[i].second+j))!=st.end()){\n        cnt++;\n        break;\n      }\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first+j,a[i].second-1))!=st.end()){\n        cnt++;\n        break;\n      }\n      if(cnt<2)return false;\n  }\n  return true;\n}\n\nbool cmp(pair<int,int> a,pair<int,int> b){\n  int ta = a.first + a.second;\n  int tb = b.first + b.second;\n  return ta == tb ? a.first < b.first: ta < tb;\n}\n\nint cal(){\n  int ret=0;\n  sort(a+1,a+n+1,cmp);\n  map<pair<int,int>,int>mp;\n  map<pair<int,int>,int>f[2];\n  for(int i=1;i<=n;i++){\n    int pos = i;\n    vector<pair<int,int>>v;\n    v.push_back(a[i]);\n    for(int j = i;j<=n;j++){\n      if(a[j].first + a[j].second!=a[i].first + a[i].second)break;\n      pos = j;\n      if(mp.find(a[j])==mp.end())mp[a[j]]=1;\n      else mp[a[j]]+=1;\n      f[0][a[j]] = f[1][a[j]] = -1;\n      if(j>i&&a[j]!=a[i])v.push_back(a[j]);\n    }\n    f[0][v[0]]=0;\n    if(mp.find(make_pair(v[0].first-1,v[0].second-1))!=mp.end()){\n      f[1][v[0]] = mp[v[0]];\n    }\n    for(int j=0;j+1<v.size();j++){\n      if(f[0][v[j]]!=-1){\n        if(v[j].first == v[j+1].first - 1){\n          f[0][v[j+1]] = max(f[0][v[j+1]],f[0][v[j]] + min(mp[v[j]],mp[v[j+1]]));\n        } else {\n          f[0][v[j+1]] = max(f[0][v[j+1]],f[0][v[j]]);\n        }\n        if(mp.find(make_pair(v[j+1].first-1,v[j+1].second-1))!=mp.end()){\n          f[1][v[j+1]] = max(f[1][v[j+1]],f[0][v[j]]+mp[v[j+1]]);\n        }\n      }\n      if(f[1][v[j]]!=-1){\n        f[0][v[j+1]] = max(f[0][v[j+1]],f[1][v[j]]);\n        if(mp.find(make_pair(v[j+1].first-1,v[j+1].second-1))!=mp.end()){\n          f[1][v[j+1]] = max(f[1][v[j+1]],f[1][v[j]]+mp[v[j+1]]);\n        }\n      }\n    }\n    ret += max(0, max(f[0][v[v.size()-1]],f[1][v[v.size()-1]]));\n    i =pos;\n  }\n  return ret;\n}\n\nint main() {\n//    freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    if(!check_1()){\n      cout<<-1<<endl;\n      return 0;\n    }\n    cout<<2*n-2-cal()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nvector<int> A[100000];\n\nvoid fail()\n{\n    assert(0);\n    printf(\"-1\\n\");\n    exit(0);\n}\n\nint main()\n{\n    scanf(\"%d\", &N);\n    int maxb=0;\n    int tmp=0;\n    for(int i=0; i<N; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        if(i==0 && a!=0)\n            fail();\n        if(i==1 && b!=0)\n            fail();\n        if(i==0)\n            tmp=b;\n        if(i==1 && tmp!=a)\n            fail();\n        if(b==0 && i!=1)\n            fail();\n        A[a].push_back(b);\n        maxb=max(maxb, b);\n    }\n    if(A[0].size()!=1)\n        fail();\n    for(int i=0; i<N; i++)\n        sort(A[i].begin(), A[i].end());\n    int ans=N-1;\n    int maxi=0;\n    for(int i=1; i<N; i++) if(!A[i].empty())\n        maxi=i;\n    for(int i=1; i<=maxi; i++)\n    {\n        if(A[i].empty())\n            fail();\n        for(auto& y: A[i])\n        {\n            int l=lower_bound(A[i-1].begin(), A[i-1].end(), y-1)-A[i-1].begin();\n            int r=upper_bound(A[i-1].begin(), A[i-1].end(), y+1)-A[i-1].begin();\n            if(l==r)\n                fail();\n            bool okl=y==0;\n            bool okr=y==maxb;\n            if(A[i-1][l]==y-1)\n                okl=true;\n            if(A[i-1][r-1]==y+1)\n                okr=true;\n            if((y!=0 && A[i-1][l]==y) && (y!=maxb && A[i-1][r-1]==y))\n                ans++;\n            if(i+1<=maxi)\n            {\n                l=lower_bound(A[i+1].begin(), A[i+1].end(), y-1)-A[i+1].begin();\n                r=upper_bound(A[i+1].begin(), A[i+1].end(), y+1)-A[i+1].begin();\n                if(l==r)\n                    fail();\n                if(A[i+1][l]==y-1)\n                    okl=true;\n                if(A[i+1][r-1]==y+1)\n                    okr=true;\n                if((y!=0 && A[i+1][l]==y) && (y!=maxb && A[i+1][r-1]==y))\n                    ans++;\n            }\n            if(!okl || !okr)\n            {\n                l=lower_bound(A[i].begin(), A[i].end(), y-1)-A[i].begin();\n                r=upper_bound(A[i].begin(), A[i].end(), y+1)-A[i].begin();\n                if(l==r)\n                    fail();\n                if(!okl && A[i][l]==y-1)\n                    okl=true, ans++;\n                if(!okr && A[i][r-1]==y+1)\n                    okr=true, ans++;\n            }\n            if(!okl || !okr)\n                fail();\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main() {\n  int N; scanf(\"%d\", &N);\n  static int A[100000], B[100000];\n  static pair<int, int> ABtbl[100000];\n  static pair<int, int> BAtbl[100000];\n  for(int i = 0; i < N; ++i) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n    ABtbl[i] = make_pair(A[i], B[i]);\n    BAtbl[i] = make_pair(B[i], A[i]);\n  }\n  if(A[0] != 0 || B[1] != 0 || A[1] == 0 || A[1] != B[0]) {\n    printf(\"%d\\n\", -1);\n    return 0;\n  }\n  sort(ABtbl, ABtbl+N);\n  sort(BAtbl, BAtbl+N);\n  for(int i = 0; i < N; ++i) {\n    if(i != 0 &&\n        lower_bound(ABtbl, ABtbl+N, make_pair(A[i]-1, B[i]-1))\n        == upper_bound(ABtbl, ABtbl+N, make_pair(A[i]-1, B[i]+1))) {\n      printf(\"%d\\n\", -1);\n      return 0;\n    }\n    if(i != 1 &&\n        lower_bound(BAtbl, BAtbl+N, make_pair(B[i]-1, A[i]-1))\n        == upper_bound(BAtbl, BAtbl+N, make_pair(B[i]-1, A[i]+1))) {\n      printf(\"%d\\n\", -1);\n      return 0;\n    }\n  }\n  int count = 2 * (N-1);\n  for(int ii = 0; ii < N; ++ii) {\n    if(ii > 0 && ABtbl[ii-1] == ABtbl[ii]) continue;\n    int a = ABtbl[ii].first;\n    int b = ABtbl[ii].second;\n    if(lower_bound(ABtbl, ABtbl+N, make_pair(a-1, b+1))\n        < upper_bound(ABtbl, ABtbl+N, make_pair(a-1, b+1))) {\n      continue;\n    }\n    int have =\n      upper_bound(ABtbl, ABtbl+N, make_pair(a, b))\n        - lower_bound(ABtbl, ABtbl+N, make_pair(a, b));\n    int rem = have;\n    while(true) {\n      int capa = have;\n      if(lower_bound(ABtbl, ABtbl+N, make_pair(a-1, b-1))\n          < upper_bound(ABtbl, ABtbl+N, make_pair(a-1, b-1))) {\n        // fprintf(stderr, \"(%d, %d) -- %d recyclable edges to (%d, %d)\\n\",\n        //     a, b, rem, a-1, b-1);\n        count -= rem;\n        capa -= rem;\n      }\n      ++a;\n      --b;\n      have =\n        upper_bound(ABtbl, ABtbl+N, make_pair(a, b))\n          - lower_bound(ABtbl, ABtbl+N, make_pair(a, b));\n      if(have == 0) break;\n      // fprintf(stderr, \"(%d, %d) -- %d recyclable edges to (%d, %d)\\n\",\n      //     a, b, max(capa, have), a-1, b+1);\n      count -= max(capa, have);\n      rem = have - max(capa, have);\n    }\n  }\n  printf(\"%d\\n\", count);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n     \n#define pb emplace_back\n#define fi first\n#define se second\n     \nusing namespace std;\n     \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\n     \n// head\n\nint n;\n\nint a[100010], b[100010];\n\nint main(){\n\n  n = in();\n  REP( i , n ){\n    a[i] = in();\n    b[i] = in();\n  }\n\n  if( a[0] != 0 ){\n    puts( \"-1\" );\n    return 0;\n  }\n  if( b[1] != 0 ){\n    puts( \"-1\" );\n    return 0;\n  }\n  if( a[1] != b[0] ){\n    puts( \"-1\" );\n    return 0;\n  }\n\n  REP( i , n ){\n    if( a[1] + b[i] < a[i] ){\n      puts( \"-1\" );\n      return 0;\n    }\n    if( a[1] + a[i] < b[i] ){\n      puts( \"-1\" );\n      return 0;\n    }\n  }\n\n  int ma = 0;\n  int mb = 0;\n  set<int> sa, sb;\n  REP( i , n ){\n    chmax( ma , a[i] );\n    chmax( mb , b[i] );\n  }\n\n  REP( i , n ){\n    sa.insert( a[i] );\n    sb.insert( b[i] );\n  }\n\n  FOR( i , 1 , ma ){\n    if( sa.find( i ) == sa.end() ){\n      puts( \"-1\" );\n      return 0;\n    }\n  }\n\n  FOR( i , 1 , mb ){\n    if( sb.find( i ) == sb.end() ){\n      puts( \"-1\" );\n      return 0;\n    }\n  }\n\n  \n  assert( false );\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n \nusing namespace std;\n \nmap <pair<int, int>, int> mp[200000];\n \nbool check(pair<int, int> p, int da, int db) {\n    int a = p.first + da;\n    int b = p.second + db;\n    \n    return mp[a + b].count(make_pair(a, b));\n}\n\nbool before(pair<int, int> p) {\n    return check(p, -1, -1) || check(p, -1, 0);\n}\n\nbool after(pair<int, int> p) {\n    return check(p, -1, -1) || check(p, 0, -1);\n}\n\nint calc(vector <pair<bool, int> >& v) {\n    int ans = 0, c = 0, i;\n    \n    for (i = 0; i < v.size(); i++) {\n        ans += v[i].second;\n        \n        if (v[i].first) {\n            c = min(c, v[i].second);\n        } else {\n            if (v[i].second > c) ans += v[i].second - c;\n            c = v[i].second;\n        }\n    }\n    \n    return ans;\n}\n \nint solve() {\n    int n, d, ans = 0, i;\n    map <pair<int, int>, int>::iterator it, it2;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) {\n        int a, b;\n        \n        scanf(\"%d %d\", &a, &b);\n        \n        if (i == 0) {\n            if (a != 0 || b == 0) return -1;\n            \n            d = b;\n        } else if (i == 1) {\n            if (a != d || b != 0) return -1;\n        } else {\n            if (a == 0 || b == 0 || a + b < d) return -1;\n        }\n        \n        mp[a + b][make_pair(a, b)]++;\n    }\n    \n    for (it = mp[d].begin(); it != mp[d].end(); it++) {\n        if (it == mp[d].begin()) continue;\n        \n        it2 = it;\n        it2--;\n        \n        if (it2->first.first + 1 != it->first.first) return -1;\n        \n        ans += max(it->second, it2->second);\n    }\n    \n    for (i = d + 1; i < n * 2; i++) {\n        vector <pair<bool, int> > v;\n        \n        if (mp[i].size() == 0) continue;\n        \n        for (it = mp[i].begin(); it != mp[i].end(); it++) {\n            if (it == mp[i].begin()) {\n                if (!before(it->first)) return -1;\n                \n                v.push_back(make_pair(check(it->first, -1, -1), it->second));\n            } else {\n                it2 = it;\n                it2--;\n                \n                if (it2->first.first + 1 != it->first.first) {\n                    if (!after(it2->first) || !before(it->first)) return -1;\n                    \n                    ans += calc(v);\n                    v.clear();\n                }\n                \n                v.push_back(make_pair(check(it->first, -1, -1), it->second));\n            }\n        }\n        \n        it--;\n        if (!after(it->first)) return -1;\n        \n        ans += calc(v);\n    }\n    \n    return ans;\n}\n \nint main() {\n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nmap <pair<int, int>, int> mp;\nmap <pair<pair<int, int>, pair<int, int> >, int> mp2;\n\nbool check(int a, int b, int da, int db) {\n    return mp.count(make_pair(a + da, b + db));\n}\n\nvoid add(int a, int b, int da, int db, int c) {\n    pair<int, int> p1 = make_pair(a, b);\n    pair<int, int> p2 = make_pair(a + da, b + db);\n    \n    if (p1 > p2) swap(p1, p2);\n    \n    mp2[make_pair(p1, p2)] = max(mp2[make_pair(p1, p2)], c);\n}\n\nint solve() {\n    int n, d, ans = 0, i;\n    map <pair<int, int>, int>::iterator it;\n    map <pair<pair<int, int>, pair<int, int> >, int>::iterator it2;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) {\n        int a, b;\n        \n        scanf(\"%d %d\", &a, &b);\n        \n        if (i == 0) {\n            if (a != 0 || b == 0) return -1;\n            \n            d = b;\n        } else if (i == 1) {\n            if (a != d || b != 0) return -1;\n        } else {\n            if (a == 0 || b == 0 || a + b < d) return -1;\n        }\n        \n        mp[make_pair(a, b)]++;\n    }\n    \n    for (it = mp.begin(); it != mp.end(); it++) {\n        int a = it->first.first;\n        int b = it->first.second;\n        int c = it->second;\n        \n        if (a != 0) {\n            if (check(a, b, -1, 1)) {\n                add(a, b, -1, 1, c);\n            } else if (check(a, b, -1, -1)) {\n                add(a, b, -1, -1, c);\n            } else if (check(a, b, -1, 0)) {\n                add(a, b, -1, 0, c);\n            } else {\n                return -1;\n            }\n        }\n        \n        if (b != 0) {\n            if (check(a, b, 1, -1)) {\n                add(a, b, 1, -1, c);\n            } else if (check(a, b, -1, -1)) {\n                add(a, b, -1, -1, c);\n            } else if (check(a, b, 0, -1)) {\n                add(a, b, 0, -1, c);\n            } else {\n                return -1;\n            }\n        }\n    }\n    \n    for (it2 = mp2.begin(); it2 != mp2.end(); it2++) ans += it2->second;\n    \n    return ans;\n}\n\nint main() {\n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n \nset<pair<int,int>> st;\npair<int,int> a[maxn];\nbool vis[maxn];\nint n;\n \nbool cmp(pair<int,int>a,pair<int,int>b) {\n    return a.first + a.second == b.first + b.second ?\n           a.first < b.first : a.first + a.second < b.first + b.second;\n}\n \nbool check_1() {\n    if(a[1].first!=0||a[2].second!=0||a[1].second!=a[2].first)return false;\n    return true;\n}\n \nbool check_2(int&ret) {\n    if(n>2)sort(a+3,a+n+1, cmp);\n    if(a[1].second==0)return false;\n    vis[1] = vis[2] = 1;\n    st.insert(a[1]);\n    st.insert(a[2]);\n    ret += a[1].second;\n    if(a[1].second==1) return true;\n    int cnt = 0;\n    for(int i=3; i<=n; i++) {\n        if(a[i].first + a[i].second != a[1].second) continue;\n        if(st.find(a[i])!=st.end())continue;\n        st.insert(a[i]);\n        vis[i] = 1;\n        cnt++;\n    }\n    return cnt == a[1].second - 1;\n}\n \nbool pd(int x,int y) {\n    int x1 = x - 1, y1, x2, y2 = y - 1;\n    for(int y1 = y-1; y1<=y+1; y1++)\n        for(int x2=x-1; x2<=x+1; x2++) {\n            if(st.find(make_pair(x1,y1))==st.end())continue;\n            if(st.find(make_pair(x2,y2))==st.end())continue;\n            return true;\n        }\n    return false;\n}\n \nbool check_3(int&ret) {\n    for(int i=3; i<=n; i++) {\n        /*if(vis[i])continue;\n        pair<int,int> fa = make_pair(a[i].first-1,a[i].second-1);\n        if(st.find(fa)!=st.end()) {\n            vis[i]=1;\n            ret++;\n            st.insert(a[i]);\n        } else {\n            if(pd(a[i].first,a[i].second)) {\n                vis[i] = 1;\n                ret+=2;\n                st.insert(a[i]);\n            } else return false;\n        }*/\n        int pos = i;\n        for(int j=i;j<=n;j++) {\n          if(a[j].first + a[j].second != a[i].first + a[i].second)break;\n          pos = j;\n        }\n        for(int j=i;j<=pos;j++) {\n          if(vis[j]) continue;\n          if(st.find(make_pair(a[j].first-1,a[j].second-1))!=st.end()) {\n            vis[j] =1;\n            ret++;\n            st.insert(a[j]);\n          }\n        }\n        for(int j=i;j<=pos;j++){\n          if(vis[j])continue;\n          if(pd(a[j].first,a[j].second)){\n            vis[j] =1;\n            ret+=2;\n            st.insert(a[j]);\n          }\n        }\n        for(int j = i+1;j<pos;j++) {\n          if(vis[j])continue;\n          if(vis[j-1]&&vis[j+1]){\n            vis[j]=1;\n            ret+=2;\n            st.insert(a[j]);\n          } else return false;\n        }\n        if((!vis[i]) || (!vis[pos])) return false;\n        i = pos;\n    }\n    return true;\n}\n \nint main() {\n    //freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    int ret = 0;\n    if(!check_1()) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(!check_2(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(!check_3(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    cout<<ret<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nint N;\nint A[101010],B[101010];\nmap<pair<int,int>,int> S;\nUF<500000> uf;\nmap<int,int> V[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tif(i!=0 && A[i]==0) return _P(\"-1\\n\");\n\t\tif(i==0 && A[i]) return _P(\"-1\\n\");\n\t\tif(i!=1 && B[i]==0) return _P(\"-1\\n\");\n\t\tif(i==1 && B[i]) return _P(\"-1\\n\");\n\t\tS[{A[i],B[i]}]=i;\n\t\tV[A[i]+B[i]][A[i]]++;\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(i!=0) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i]-1,B[i]})) uf(i,S[{A[i]-1,B[i]}]);\n\t\t\tif(S.count({A[i]-1,B[i]+1})) uf(i,S[{A[i]-1,B[i]+1}]);\n\t\t}\n\t\tif(i!=1) {\n\t\t\tif(S.count({A[i]-1,B[i]-1})) uf(i,S[{A[i]-1,B[i]-1}]);\n\t\t\tif(S.count({A[i],B[i]-1})) uf(i,S[{A[i],B[i]-1}]);\n\t\t\tif(S.count({A[i]+1,B[i]-1})) uf(i,S[{A[i]+1,B[i]-1}]);\n\t\t}\n\t}\n\tif(uf.count(0)!=N) return _P(\"-1\\n\");\n\tint ret=2*N-2;\n\tFOR(i,2*N) if(V[i].size()) {\n\t\tint pre=-2,left=0;\n\t\tint del=0;\n\t\tFORR(r,V[i]) {\n\t\t\tx = r.second;\n\t\t\tif(r.first==pre+1) {\n\t\t\t\tret -= min(left,x);\n\t\t\t\tdel+=min(left,x);\n\t\t\t\tx-=min(left,x);\n\t\t\t}\n\t\t\tif(S.count({r.first-1,(i-r.first)-1})) {\n\t\t\t\tret-=x;\n\t\t\t\tdel+=x;\n\t\t\t\tx=0;\n\t\t\t}\n\t\t\tpre=r.first;\n\t\t\tleft=x;\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool find(pair<int,int> *P,int n,int a,int b)\n{\n  int k=lower_bound(P,P+n,make_pair(a,b))-P;\n  return k<n&&P[k]==make_pair(a,b);\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  static int A[100000],B[100000];\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",A+i,B+i);\n  }\n  if(A[0]!=0||B[1]!=0||A[1]!=B[0]){\n    puts(\"-1\");\n    return 0;\n  }\n  int L=A[1];\n  int C=1;\n  static pair<int,int> P[100000];\n  for(int i=0;i<n;i++){\n    P[i]=make_pair(A[i],B[i]);\n    if((i!=0&&A[i]==0)||(i!=1&&B[i]==0)||A[i]+B[i]<L||A[i]-B[i]>L||B[i]-A[i]>L){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  sort(P,P+n);\n  static bool X[100000];\n  for(int i=0;i<n;i++){\n    if(i==0||i==1){\n      X[i]=1;\n    }\n    else{\n      int k=lower_bound(P,P+n,make_pair(A[i]-1,B[i]-1))-P;\n      if(k<n&&P[k]==make_pair(A[i]-1,B[i]-1)){\n\t//printf(\"%d\\n\",i);\n\tX[i]=1;\n\tC++;\n      }\n    }\n  }  \n  for(int i=0;i<n;i++){\n    if(X[i]){\n      continue;\n    }\n    else{\n      int a1=A[i]-1,b1=min(A[i]-1+L,B[i]+1);\n      int a2=min(B[i]-1+L,A[i]+1),b2=B[i]-1;\n      int k1=lower_bound(P,P+n,make_pair(a1,b1))-P;\n      int k2=lower_bound(P,P+n,make_pair(a2,b2))-P;\n      if(k1<n&&P[k1]==make_pair(a1,b1)&&k2<n&&P[k2]==make_pair(a2,b2)){\n\tif(X[k1]){\n\t  C++;\n\t}\n\tC++;\n      }\n      else{\n\tputs(\"-1\");\n\treturn 0;\n      }\n    }\n  }\n  printf(\"%d\\n\",C);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\nconst int inf = 1000000007;\n\nint n;\nstruct P {\n    int x,y,id;\n    P() {}\n    P(int x,int y, int id):x(x),y(y),id(id) {}\n    bool operator<(const P&a)const {\n        return x==a.x?y<a.y:x<a.x;\n    }\n} p[maxn];\n\nint main() {\n //   freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        p[i]=P(x,y,i);\n    }\n    if(p[1].y!=p[2].x||p[1].y>n-1||p[1].x!=0||p[2].y!=0)cout<<-1<<endl;\n    else {\n        if(n==2) {\n            cout<<1<<endl;\n        } else {\n            sort(p+3,p+n);\n            unordered_map<int,int>umap;\n            bool fail = false;\n            for(int i=3; i<=n; i++) {\n                if(p[i].x+p[i].y==p[1].y&&p[i].x&&p[i].y) {\n                    umap[p[i].x] = 1;\n                }\n                if((!p[i].x)||(!p[i].y))fail=true;\n                if(p[i].x>p[i].y+p[1].y||p[i].y>p[i].x+p[1].y)fail=true;\n                if(p[i].x+p[i].y<p[1].y)fail=true;\n            }\n            for(int i=1; i<p[1].y; i++)if(umap.find(i)==umap.end()) {\n                    fail = true;\n                    break;\n                }\n            int ret=0;\n            umap.clear();\n            umap[0]=1;\n            for(int i=3; i<=n; i++) {\n                if(p[i].y==p[i].x+p[1].y) {\n                    if(umap.find(p[i].x-1)==umap.end()) {\n                        fail=true;\n                        break;\n                    } else {\n                        umap[p[i].x]=1;\n                        ret++;\n                    }\n                }\n            }\n            umap.clear();\n            umap[0]=1;\n            for(int i=3; i<=n; i++) {\n                if(p[i].x==p[i].y+p[1].y) {\n                    if(umap.find(p[i].y-1)==umap.end()) {\n                        fail=true;\n                        break;\n                    } else {\n                        umap[p[i].y]=1;\n                        ret++;\n                    }\n                }\n            }\n            umap.clear();\n            for(int i=3; i<=n; i++) {\n                if(p[i].x+p[i].y==p[1].y) {\n                    if(umap.find(p[i].x)==umap.end()) {\n                        umap[p[i].x]=1;\n                    } else umap[p[i].x]++;\n                }\n            }\n            umap[0] = 1;\n            umap[p[1].y]=1;\n            for(int i=0; i<p[1].y; i++) {\n                if(umap.find(i)==umap.end()||umap.find(i+1)==umap.end()) {\n                    fail = true;\n                    break;\n                }\n                ret+=max(umap[i],umap[i+1]);\n            }\n            map<pair<int,int>,int>mp;\n            unordered_map<int,int>umapx,umapy;\n            mp[make_pair(0,p[1].y)]=1;\n            mp[make_pair(p[1].y,0)]=1;\n            umapx[0]=umapx[p[1].y]=1;\n            umapy[0]=umapy[p[1].y]=1;\n            for(int i=1; i<p[1].y; i++) {\n                mp[make_pair(i,p[1].y-i)] = 1;\n                umapx[i]=1;\n                umapy[p[1].y-i]=1;\n            }\n            for(int i=3; i<=n; i++) {\n                if(p[i].x+p[i].y==p[1].y)continue;\n                if(p[i].x==p[i].y+p[1].y)continue;\n                if(p[i].y==p[i].x+p[1].y)continue;\n                if(mp[make_pair(p[i].x -1,p[i].y-1)]) {\n                    ret++;\n                    umapx[p[i].x]=1;\n                    umapy[p[i].y]=1;\n                    mp[make_pair(p[i].x,p[i].y)]=1;\n                } else {\n                    //cout<<p[i].x<<\" \"<<p[i].y<<endl;\n                    if(umapx.find(p[i].x-1)!=umapx.end()&&umapy.find(p[i].y-1)!=umapy.end()) {\n                        ret+=2;\n                        mp[make_pair(p[i].x,p[i].y)]=1;\n                        umapx[p[i].x]=1;\n                        umapy[p[i].y]=1;\n                    } else {\n                        fail=true;\n                        break;\n                    }\n                }\n            }\n            if(fail)cout<<-1<<endl;\n            else cout<<ret<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define N 100005\n#define fr first\n#define se second\n#define check(x,y) (mp.find(make_pair(x,y))!=mp.end())\nusing namespace std;\nstruct msg{\n\tint x,y,num;\n};\npii v[N];\nvector<msg> b[N*2];\nmap<pii,int > mp;\nmap<pii,int >::iterator itr;\nint dp[N][2];\nint n,ans,d;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&v[i].first,&v[i].se),mp[v[i]]++;\n\td=v[1].se;\n\tfor(itr=mp.begin();itr!=mp.end();itr++){\n\t\tb[(itr->fr).fr+(itr->fr).se].push_back((msg){(itr->fr).fr,(itr->fr).se,itr->se});\n\t}\n\tfor(int i=0;i<d;i++) if(b[i].size()>0) return puts(\"-1\"),0;\n\tif(mp[v[1]]!=1||mp[v[2]]!=1||v[1].fr!=0||v[2].se!=0) return puts(\"-1\"),0;\n\t\n\tfor(int i=d;i<=n*2;i++){\n\t\tmemset(dp,0,sizeof(int)*(b[i].size()+2)*2);\n\t\tfor(int j=0;j<b[i].size();j++){\n\t\t\tdp[j][0]=dp[j][1]=0x3f3f3f3f;\n\t\t\tif(j==0){\n\t\t\t\tif(i==d) {dp[j][0]=0;continue;}\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)){\n\t\t\t\t\tdp[j][0]=dp[j][1]=b[i][j].num;\n\t\t\t\t}else if(check(b[i][j].x-1,b[i][j].y)){\n\t\t\t\t\tdp[j][0]=b[i][j].num;\n\t\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\t\tdp[j][1]=b[i][j].num+dp[j][0];\n\t\t\t\t}else return puts(\"-1\"),0;\n\t\t\t}else{\n\t\t\t\tint temp=0x3f3f3f3f;\n\t\t\t\tif(b[i][j-1].x+1==b[i][j].x)\n\t\t\t\t\ttemp=dp[j-1][0]+max(b[i][j].num,b[i][j-1].num);\n\t\t\t\telse if(check(b[i][j].x-1,b[i][j].y))\n\t\t\t\t\ttemp=dp[j-1][1]+b[i][j].num;\n\t\t\t\tdp[j][0]=temp;\n\t\t\t\t\n\t\t\t\tif(check(b[i][j].x,b[i][j].y-1))\n\t\t\t\t\ttemp+=b[i][j].num;\n\t\t\t\telse temp=0x3f3f3f3f;\n\t\t\t\tif(check(b[i][j].x-1,b[i][j].y-1)) temp=min(temp,dp[j-1][1]+b[i][j].num);\n\t\t\t\tdp[j][0]=min(dp[j][0],dp[j][1]=temp);\n\t\t\t}\n\t\t}\n\t\tif(i==d) ans+=dp[b[i].size()-1][0];\n\t\telse ans+=dp[b[i].size()-1][1];\n\t\tif(ans>1e9) return puts(\"-1\"),0;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nconst int MAXN = 100001;\nint ans, a[MAXN], b[MAXN], u[MAXN];\n\nvoid no() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nset<pii> S;\n\nvoid ch(bool x) {\n\tif (!x) no();\n}\n\nint cc(pii p1, pii p2) {\n\tif (p1.first + p1.second != p2.first + p2.second) return p1.first + p1.second < p2.first + p2.second;\n\treturn p1 < p2;\n}\n\nvoid solve() {\n\tch(a[1] == 0);\n\tch(b[2] == 0);\n\tch(a[2] == b[1]);\n\n\tint d = a[2];\n\tch(d > 0);\n\n\tvector<pii> v;\n\n\tans = n - 1;\n\n\tCL(0, u);\n\tm = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i > 2) ch(a[i] > 0 && b[i] > 0);\n\t\tch(a[i] + b[i] >= d);\n\t\tif (a[i] + b[i] == d && !u[a[i]]) {\n\t\t\tS.insert(pii(a[i], b[i]));\n\t\t\tu[a[i]] = 1; m++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(pii(a[i], b[i]));\n\t\t}\n\t}\n\tch(m == d + 1);\n\tsort(v.begin(), v.end(), cc);\n\n\tset<pii> S2;\n\n\tfor (pii p : v) {\n\t\tif (S.count(pii(p.first - 1, p.second - 1))) { S.insert(p); continue; }\n\t\tif (S.count(pii(p.first, p.second))) { \n\t\t\tif (S.count(p) && S2.count(pii(p.first - 1, p.second + 1))) continue;\n\t\t\tS2.insert(p);  S.insert(p);  ans++; continue;\n\t\t}\n\t\t//if (S.count(pii(p.first, p.second - 1))) { ans++; S.insert(p); S2.insert(p);  continue; }\n\t\t//if (S.count(pii(p.first - 1, p.second))) { ans++; S.insert(p); S2.insert(p);  continue; }\n\t\tif (S.count(pii(p.first, p.second - 1)) && S.count(pii(p.first - 1, p.second))) { ans++; S2.insert(p);  S.insert(p); continue; }\n\t\tno();\n\t}\n}\n\nvoid read() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\tcin >> n;\n\tF1(i, n) cin >> a[i] >> b[i];\n}\n\nint main() {\n\tif (1) {\n\t\tread();\n\t\tsolve();\n\t\tcout << ans << endl;\n\t\texit(0);\n\t}\n\n\tF0(it, 10000000) {\n\t\tint edges = 0;\n\t\tn = 5 + rand()%10;\n\t\tvector<int> p(n + 1);\n\t\tvector< vector<int> > d(n + 1, vector<int>(n + 1, inf));\n\t\tF1(i, n) d[i][i] = 0;\n\t\tF1(i, n) p[i] = i;\n\t\tint cnt = n - 1;\n\t\twhile (cnt > 0) {\n\t\t\tint i = rand() % n + 1;\n\t\t\tint j = rand() % n + 1;\n\t\t\tif (i == j) continue;\n\t\t\td[i][j] = d[j][i] = 1;\n\t\t\tedges++;\n\t\t\twhile (i != p[i]) i = p[i];\n\t\t\twhile (j != p[j]) j = p[j];\n\t\t\tif (i != j) {\n\t\t\t\tp[i] = j;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t\tF1(k, n)F1(i, n) F1(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\tF1(i, n) {\n\t\t\tif (d[1][i] >= inf || d[2][i] >= inf) throw 12;\n\t\t\ta[i] = d[1][i];\n\t\t\tb[i] = d[2][i];\n\t\t}\n\n\t\tsolve();\n\t\tif (edges < ans) {\n\t\t\tcout << endl;\n\t\t\tcout << edges << \" \" << ans << endl;\n\t\t\tF1(i, n) cout << a[i] << \" \" << b[i] << endl;\n\t\t\tthrow 12;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n     \n#define pb emplace_back\n#define fi first\n#define se second\n     \nusing namespace std;\n     \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\n     \n// head\n\nint n;\n\nint a[100010], b[100010];\n\nint main(){\n\n  n = in();\n  REP( i , n ){\n    a[i] = in();\n    b[i] = in();\n  }\n\n  if( a[0] != 0 ){\n    puts( \"-1\" );\n    return 0;\n  }\n  if( b[1] != 0 ){\n    puts( \"-1\" );\n    return 0;\n  }\n  if( a[1] != b[0] ){\n    puts( \"-1\" );\n    return 0;\n  }\n\n  REP( i , n ){\n    if( a[1] + b[i] < a[i] ){\n      puts( \"-1\" );\n      return 0;\n    }\n    if( a[1] + a[i] < b[i] ){\n      puts( \"-1\" );\n      return 0;\n    }\n  }\n\n  assert( false );\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nint a[100001];\nint b[100001];\nvi adj[100001];\nbool par[100001];\nvi aaa[100001];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\taaa[a[i]].pb(i);\n\t\tadj[b[i]].pb(i);\n\t}\n\tif(a[0]!=0||b[1]!=0)\n\t{\n\t\tcout<<-1<<'\\n';\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\tpar[0] = 1;\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\t//must come from last vec\n\t\tmap<int,vi> ma;\n\t\tmap<int,deque<int> > unused;\n\t\tfor(int j = 0; j < adj[i-1].size(); j++)\n\t\t{\n\t\t\t//cerr<<adj[i-1][j]<<'\\n';\n\t\t\tma[a[adj[i-1][j]]].pb(adj[i-1][j]);\n\t\t}\n\t\tfor(int j = 0; j < adj[i-1].size(); j++)\n\t\t{\n\t\t\tif(!par[adj[i-1][j]]) \n\t\t\t{\n\t\t\t\tif(aaa[a[adj[i-1][j]]-1].empty()) unused[a[adj[i-1][j]]].pb(adj[i-1][j]);\n\t\t\t\telse unused[a[adj[i-1][j]]].push_front(adj[i-1][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t{\n\t\t\tint v = adj[i][j];\n\t\t\tint d = a[v];\n\t\t\t//cerr<<v<<' '<<d<<' '<<unused[d+1].size()<<'\\n';\n\t\t\tif(!aaa[d-1].empty())\n\t\t\t{\n\t\t\t\tif(!unused[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tint u = unused[d+1].back();\n\t\t\t\t\tunused[d+1].pop_back();\n\t\t\t\t\tpar[u] = true;\n\t\t\t\t}\n\t\t\t\telse if(!par[v]&&!ma[d-1].empty())\n\t\t\t\t{\n\t\t\t\t\tpar[v] = true;\n\t\t\t\t}\n\t\t\t\telse if(ma[d-1].empty()&&ma[d].empty()&&ma[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tcout<<-1<<'\\n';\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if((!unused[d+1].empty())&&(aaa[a[unused[d+1].back()]-1].empty()))\n\t\t\t{\n\t\t\t\tif(!unused[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tint u = unused[d+1].back();\n\t\t\t\t\tunused[d+1].pop_back();\n\t\t\t\t\tpar[u] = true;\n\t\t\t\t}\n\t\t\t\telse if(!par[v]&&!ma[d-1].empty())\n\t\t\t\t{\n\t\t\t\t\tpar[v] = true;\n\t\t\t\t}\n\t\t\t\telse if(ma[d-1].empty()&&ma[d].empty()&&ma[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tcout<<-1<<'\\n';\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(!par[v]&&!ma[d-1].empty())\n\t\t\t\t{\n\t\t\t\t\tpar[v] = true;\n\t\t\t\t}\n\t\t\t\telse if(!unused[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tint u = unused[d+1].back();\n\t\t\t\t\tunused[d+1].pop_back();\n\t\t\t\t\tpar[u] = true;\n\t\t\t\t}\n\t\t\t\telse if(ma[d-1].empty()&&ma[d].empty()&&ma[d+1].empty())\n\t\t\t\t{\n\t\t\t\t\tcout<<-1<<'\\n';\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(!par[i])\n\t\t{\n\t\t\t//cerr<<i<<'\\n';\n\t\t\tif(!aaa[a[i]-1].empty())\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout<<-1<<'\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tassert(ans>=n-1);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nint n;\npair<int,int> a[maxn];\n\nbool check_1(){\n  if(a[1].first!=0||a[2].second!=0||a[2].first!=a[1].second||a[1].second==0)return false;\n  for(int i=3;i<=n;i++)\n    if(a[i].first==0||a[i].second==0||a[i].first+a[i].second<a[1].first+a[1].second)return false;\n  set<pair<int,int>>st;\n  for(int i=1;i<=n;i++)st.insert(a[i]);\n  for(int i=3;i<=n;i++){\n    int cnt=0;\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first-1,a[i].second+j))!=st.end()){\n        cnt++;\n        break;\n      }\n    for(int j=-1;j<=1;j++)\n      if(st.find(make_pair(a[i].first+j,a[i].second-1))!=st.end()){\n        cnt++;\n        break;\n      }\n      if(cnt<2)return false;\n  }\n  return true;\n}\n\nbool cmp(pair<int,int> a,pair<int,int> b){\n  int ta = a.first + a.second;\n  int tb = b.first + b.second;\n  return ta == tb ? a.first < b.first: ta < tb;\n}\n\nint cal(){\n  int ret=0;\n  sort(a+1,a+n+1,cmp);\n  map<pair<int,int>,int>mp,f;\n  //map<pair<int,int>,int>f[2];\n  for(int i=1;i<=n;i++){\n    int pos = i;\n    vector<pair<int,int>>v;\n    v.push_back(a[i]);\n    for(int j = i;j<=n;j++){\n      if(a[j].first + a[j].second!=a[i].first + a[i].second)break;\n      pos = j;\n      if(mp.find(a[j])==mp.end())mp[a[j]]=1;\n      else mp[a[j]]+=1;\n      f[a[j]]=mp[a[j]];\n      //f[0][a[j]] = f[1][a[j]] = -1;\n      if(j>i&&a[j]!=a[i])v.push_back(a[j]);\n    }/*\n    f[0][v[0]]=0;\n    if(mp.find(make_pair(v[0].first-1,v[0].second-1))!=mp.end()){\n      f[1][v[0]] = mp[v[0]];\n    }\n    for(int j=0;j+1<v.size();j++){\n      if(f[0][v[j]]!=-1){\n        if(v[j].first == v[j+1].first - 1){\n          f[0][v[j+1]] = max(f[0][v[j+1]],f[0][v[j]] + min(mp[v[j]],mp[v[j+1]]));\n        } else {\n          f[0][v[j+1]] = max(f[0][v[j+1]],f[0][v[j]]);\n        }\n        if(mp.find(make_pair(v[j+1].first-1,v[j+1].second-1))!=mp.end()){\n          f[1][v[j+1]] = max(f[1][v[j+1]],f[0][v[j]]+mp[v[j+1]]);\n        }\n      }\n      if(f[1][v[j]]!=-1){\n        f[0][v[j+1]] = max(f[0][v[j+1]],f[1][v[j]]);\n        if(mp.find(make_pair(v[j+1].first-1,v[j+1].second-1))!=mp.end()){\n          f[1][v[j+1]] = max(f[1][v[j+1]],f[1][v[j]]+mp[v[j+1]]);\n        }\n      }\n    }\n    ret += max(0, max(f[0][v[v.size()-1]],f[1][v[v.size()-1]]));\n    */\n    for(int j=1;j<v.size();j++){\n      if(v[j-1].first+1==v[j].first){\n        int tt =min(mp[v[j-1]],mp[v[j]]);\n        ret+=tt;\n        f[v[j-1]] = min(f[v[j-1]],mp[v[j-1]]-tt);\n        f[v[j]] = min(f[v[j]],mp[v[j]]-tt);\n      }\n    }\n    for(int j=0;j<v.size();j++){\n      if(mp.find(make_pair(v[j].first-1,v[j].second-1))!=mp.end()){\n        ret+=f[v[j]];\n      }\n    }\n    i =pos;\n  }\n  return ret;\n}\n\nint main() {\n    //freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    if(!check_1()){\n      cout<<-1<<endl;\n      return 0;\n    }\n    cout<<2*n-2-cal()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nset<pair<int,int>> st;\npair<int,int> a[maxn];\nbool vis[maxn];\nint n;\n\nbool check_1() {\n    if(a[1].first!=0||a[2].second!=0||a[1].second!=a[2].first)return false;\n    return true;\n}\n\nbool check_2(int&ret) {\n    if(n>2)sort(a+3,a+n+1);\n    if(a[1].second==0)return false;\n    vis[1] = vis[2] = 1;\n    st.insert(a[1]);\n    st.insert(a[2]);\n    ret += a[1].second;\n    if(a[1].second==1) return true;\n    int cnt = 0;\n    for(int i=3; i<=n; i++) {\n        if(a[i].first + a[i].second != a[1].second) continue;\n        if(st.find(a[i])!=st.end())continue;\n        st.insert(a[i]);\n        vis[i] = 1;\n        cnt++;\n    }\n    return cnt == a[1].second - 1;\n}\n\nbool pd(int x,int y) {\n    for(int x1=x-1; x1<=x+1; x1++)\n        for(int y1=y-1; y1<=y+1; y1++) {\n            if(st.find(make_pair(x1,y1))==st.end())continue;\n            for(int x2=x-1; x2<=x+1; x2++)\n                for(int y2=y-1; y2<=y+1; y2++) {\n                     if(min(x1,x2)+1!=x||min(y1,y2)+1!=y)continue;\n                     if(st.find(make_pair(x2,y2))==st.end())continue;\n                     //cout<<x1<<\" \"<<y1<<\",\"<<x2<<\" \"<<y2<<endl;\n                     return true;\n                }\n        }\n    return false;\n}\n\nbool check_3(int&ret) {\n    for(int i=3; i<=n; i++) {\n        if(vis[i])continue;\n        pair<int,int> fa = make_pair(a[i].first-1,a[i].second-1);\n        if(st.find(fa)!=st.end()) {\n            vis[i]=1;\n            ret++;\n            st.insert(a[i]);\n        } else {\n            if(pd(a[i].first,a[i].second)) {\n                vis[i] = 1;\n                ret+=2;\n                st.insert(a[i]);\n            } else return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n  //  freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    int ret = 0;\n    if(!check_1()) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(!check_2(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(!check_3(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    cout<<ret<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef long long LL;\nmap<int, map<int,int> > d; //exists\nmap<int, map<int,int> > l; // freq[sum][xval]\nvector<int> xval;// \nvector<int> freq; // \nint n;\nint a[210000], b[210000];\nint main(){\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) cin >> a[i] >> b[i];\n\tif(a[0] != 0 || b[1] != 0 || a[1] != b[0] || a[1] == 0 || b[0] == 0){\n\t\tcout << -1 << endl; return 0;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tif(a[i] + b[i] < a[0] + b[0]){\n\t\t\tcout << -1 << endl; return 0;\n\t\t}\n\t\tif(i >= 2 && (a[i] == 0 || b[i] == 0) ){\n\t\t\tcout << -1 << endl; return 0;\n\t\t}\n\t\td[a[i]][b[i]] = 1;\n\t\tl[a[i]+b[i]][a[i]]++;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tif(a[i] > 0){\n\t\t\tif(!d[a[i]-1][b[i]-1] && !d[a[i]-1][b[i]] && !d[a[i]-1][b[i]+1]){\n\t\t\t\tcout << -1 << endl; return 0;\n\t\t\t}\n\t\t}\n\t\tif(b[i] > 0){\n\t\t\tif(!d[a[i]-1][b[i]-1] && !d[a[i]][b[i]-1] && !d[a[i]+1][b[i]-1]){\n\t\t\t\tcout << -1 << endl; return 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tLL ans = 0;\n\tfor(int i = 0; i < 210000; i++){\n\t\txval.clear();\n\t\tfreq.clear();\n\t\tfor(map<int, int>::iterator it = l[i].begin(); it != l[i].end(); it++){\n\t\t\txval.push_back(it->first);\n\t\t\tfreq.push_back(it->second);\n\t\t}\n\t\tint l = 0;\n\t\tfor(int j = 0; j < xval.size(); j++){\n\t\t\tint numl = freq[j];\n\t\t\tint numd = freq[j];\n\t\t\tnuml -= l;\n\t\t\tif(numl < 0) numl = 0;\n\t\t\tint xc = xval[j];\n\t\t\tint yc = i-xval[j];\n\t\t\tif(xc == 0) numl = 0;\n\t\t\tif(yc == 0) numd = 0;\n\t\t\tif(d[xc-1][yc-1]){\n\t\t\t\tint r = min(numl,numd);\n\t\t\t\tnuml -= r;\n\t\t\t\tnumd -= r;\n\t\t\t\tans += r;\n\t\t\t}\n\t\t\tans += numl;\n\t\t\tl = numd;\n\t\t\tans += numd;\n\t\t\tif(j + 1 == xval.size() || xval[j+1] != xval[j] + 1) l = 0;\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n;\nint da[125252], db[125252];\nmap<pii,vi> M;\nint st[125252];\n// befa, befb, afta, aftb\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n)scanf(\"%d%d\",da+i,db+i);\n  REP(i,n){\n    int xa = da[i], xb = db[i];\n    M[pii(xa+xb,xb)].push_back(i);\n  }\n  st[0] |= 1;\n  st[1] |= 2;\n  ll ans = 0;\n  for(auto P:M){\n    pii pos = P.first;\n    int xa = pos.first-pos.second;\n    int xb = pos.second;\n    int pp = P.second.front();\n    // DEBUG(pp);\n    if((st[pp]&1)==0){\n      if(M.count(pii(xa-1+xb-1,xb-1))){\n        ans += P.second.size();\n        for(auto x:P.second){\n          st[x] |= 3;\n          // printf(\"%d 3\\n\",x);\n        }\n        continue;\n      }else if(M.count(pii(xa-1+xb+1,xb+1))){\n        pii to = pii(xa-1+xb+1,xb+1);\n        auto Q = M[to];\n        ans += max(P.second.size(),Q.size());\n        for(auto x:P.second){\n          st[x] |= 1;\n          // printf(\"%d 1\\n\",x);\n        }\n        for(auto x:Q){\n          st[x] |= 2;\n          // printf(\"%d 2\\n\",x);\n        }\n      }else if(M.count(pii(xa-1+xb,xb))){\n        ans += P.second.size();\n        for(auto x:P.second){\n          st[x] |= 1;\n          // printf(\"%d 1\\n\",x);\n        }\n      }\n    }\n    // DEBUG(pp);\n    if((st[pp]&2)==0){\n      if(M.count(pii(xa-1+xb-1,xb-1))){\n        ans += P.second.size();\n        for(auto x:P.second){\n          st[x] |= 3;\n          // printf(\"%d 3\\n\",x);\n        }\n        continue;\n      }else if(M.count(pii(xa+1+xb-1,xb-1))){\n        pii to = pii(xa+1+xb-1,xb-1);\n        auto Q = M[to];\n        ans += max(P.second.size(),Q.size());\n        for(auto x:P.second){\n          st[x] |= 2;\n          // printf(\"%d 2\\n\",x);\n        }\n        for(auto x:Q){\n          st[x] |= 1;\n          // printf(\"%d 1\\n\",x);\n        }\n      }else if(M.count(pii(xa+xb-1,xb-1))){\n        ans += P.second.size();\n        for(auto x:P.second){\n          st[x] |= 2;\n          // printf(\"%d 2\\n\",x);\n        }\n      }\n    }\n  }\n  REP(i,n){\n    // DEBUG(st[i]);\n    if(st[i]!=3){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <ctime>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n \nset<pair<int,int>> st;\npair<int,int> a[maxn];\nbool vis[maxn];\nint n;\n \nbool cmp(pair<int,int>a,pair<int,int>b) {\n    return a.first + a.second == b.first + b.second ?\n           a.first < b.first : a.first + a.second < b.first + b.second;\n}\n \nbool check_1() {\n    if(a[1].first!=0||a[2].second!=0||a[1].second!=a[2].first)return false;\n    for(int i=3;i<=n;i++)\n      if(a[i].first==0||a[i].second==0)return false;\n    return true;\n}\n \nbool check_2(int&ret) {\n    if(n>2)sort(a+3,a+n+1, cmp);\n    if(a[1].second==0)return false;\n    vis[1] = vis[2] = 1;\n    st.insert(a[1]);\n    st.insert(a[2]);\n    ret += a[1].second;\n    if(a[1].second==1) return true;\n    int cnt = 0;\n    for(int i=3; i<=n; i++) {\n        if(a[i].first + a[i].second != a[1].second) continue;\n        if(st.find(a[i])!=st.end())continue;\n        st.insert(a[i]);\n        vis[i] = 1;\n        cnt++;\n    }\n    return cnt == a[1].second - 1;\n}\n \nbool pd(int x,int y) {\n    int x1 = x - 1, y1, x2, y2 = y - 1;\n    for(int y1 = y-1; y1<=y+1; y1++)\n        for(int x2=x-1; x2<=x+1; x2++) {\n            if(st.find(make_pair(x1,y1))==st.end())continue;\n            if(st.find(make_pair(x2,y2))==st.end())continue;\n            return true;\n        }\n    return false;\n}\n \nbool check_3(int&ret) {\n    for(int i=3; i<=n; i++) {\n        /*if(vis[i])continue;\n        pair<int,int> fa = make_pair(a[i].first-1,a[i].second-1);\n        if(st.find(fa)!=st.end()) {\n            vis[i]=1;\n            ret++;\n            st.insert(a[i]);\n        } else {\n            if(pd(a[i].first,a[i].second)) {\n                vis[i] = 1;\n                ret+=2;\n                st.insert(a[i]);\n            } else return false;\n        }*/\n        int pos = i;\n        for(int j=i;j<=n;j++) {\n          if(a[j].first + a[j].second != a[i].first + a[i].second)break;\n          pos = j;\n        }\n        for(int j=i;j<=pos;j++) {\n          if(vis[j]) continue;\n          if(st.find(make_pair(a[j].first-1,a[j].second-1))!=st.end()) {\n            vis[j] =1;\n            ret++;\n            st.insert(a[j]);\n          }\n        }\n        for(int j=i;j<=pos;j++){\n          if(vis[j])continue;\n          if(pd(a[j].first,a[j].second)){\n            vis[j] =1;\n            ret+=2;\n            st.insert(a[j]);\n          }\n        }\n        for(int j = i;j<=pos;j++) {\n          if(vis[j])continue;\n          if(st.find(make_pair(a[j].first-1,a[j].second+1))!=st.end()&&st.find(make_pair(a[j].first+1,a[j].second-1))!=st.end()){\n            vis[j]=1;\n            ret+=2;\n            st.insert(a[j]);\n          } else return false;\n        }\n        i = pos;\n    }\n    return true;\n}\n \nint main() {\n   // freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n;\n    for(int i=1; i<=n; i++) {\n        int x,y;\n        cin>>x>>y;\n        a[i].first = x;\n        a[i].second = y;\n    }\n    int ret = 0;\n    if(!check_1()) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(!check_2(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(!check_3(ret)) {\n        cout<<-1<<endl;\n        return 0;\n    }\n    cout<<ret<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 10;\nint ds[2][maxn];\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &ds[0][i], &ds[1][i]);\n  }\n  return 1;\n}\n\nint res;\n\nvoid solve() {\n  if (ds[0][0] || ds[1][1]) {\n    printf(\"-1\\n\");\n    return;\n  }\n  int d = ds[0][1];\n  if (ds[1][0] != d) {\n    printf(\"-1\\n\");\n    return;\n  }\n  vector<int> big(d + 1, 0);\n\n  vector<int> vs[2][d + 1];\n  for (int v = 0; v < n; ++v) {\n    int left = ds[0][v] + ds[1][v] - d;\n    if (left < 0 || abs(ds[0][v] - ds[1][v]) > d) {\n      printf(\"-1\\n\");\n      return;\n    }\n    if (left > 0) {\n      vs[left & 1][(ds[0][v] - ds[1][v] + d) / 2].pb((left + 1) / 2);\n    } else {\n      big[ds[0][v]] += 1;\n    }\n  }\n  res = 0;\n  for (int odd = 0; odd < 2; ++odd) {\n    vector<int> cool;\n    for (int i = 0; i <= d - odd; ++i) {\n      auto &cur = vs[odd][i];\n      sort(cur.begin(), cur.end());\n      int last = 0;\n      for (int i = 0; i < sz(cur);) {\n        int i0 = i;\n        while (i < sz(cur) && cur[i] == cur[i0]) {\n          ++i;\n        }\n        //eprintf(\"%dx  %d\\n\", i - i0, cur[i0]);\n        if (cur[i0] != last + 1) {\n          printf(\"-1\\n\");\n          return;\n        }\n        res += i - i0;\n        if (odd && cur[i0] == 1) {\n          cool.pb(i - i0);\n        }\n        ++last;\n      }\n      if (sz(cool) == i) {\n        cool.pb(0);\n      }\n    }\n    if (odd) {\n      cool.pb(0);\n      for (int i = 0; i < sz(cool) - 1; ++i) {\n        int cur = cool[i + 1] - cool[i];\n        if (cur > 0) {\n          res += cur;\n        }\n      }\n    }\n  }\n  if (big[0] != 1 || big[d] != 1) {\n    printf(\"-1\\n\");\n    return;\n  }\n  for (int i = 1; i < d; ++i) {\n    if (big[i] == 0) {\n      printf(\"-1\\n\");\n      return;\n    }\n  }\n  for (int i = 0; i < d; ++i) {\n    res += max(big[i], big[i + 1]);\n  }\n  printf(\"%d\\n\", res);\n}\n\nvoid gen() {\n  int m;\n  while (1) {\n    beg:;\n  n = rnd(10) + 2;\n  m = 0;\n  vector<vector<int> > es(n);\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      if (rnd(4) == 0) {\n        es[i].pb(j), es[j].pb(i);\n        eprintf(\"%d %d\\n\", i, j);\n        ++m;\n      }\n    }\n  }\n\n  for (int i = 0; i < 2; ++i) {\n    auto &dist = ds[i];\n    for (int v = 0; v < n; ++v) {\n      dist[v] = inf;\n    }\n    vector<int> st;\n    st.pb(i);\n    dist[i] = 0;\n    for (int l = 0; l < sz(st); ++l) {\n      int v = st[l];\n      for (int u : es[v]) {\n        if (dist[u] > dist[v] + 1) {\n          st.pb(u);\n          dist[u] = dist[v] + 1;\n        }\n      }\n    }\n    if (sz(st) < n) {\n      goto beg;\n    }\n  }\n  break;\n  }\n  eprintf(\"n = %d\\n\", n);\n  solve();\n  if (res == -1 || res > m) {\n    assert(0);\n  }\n}\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  if (0) {\n  while (1) {\n    gen();\n  }\n  }\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n// 内部定数\n#define D_ON\t\t\t1\t\t\t\t\t\t\t\t\t\t// 汎用フラグ - ON\n#define D_OFF\t\t\t0\t\t\t\t\t\t\t\t\t\t// 汎用フラグ - OFF\n#define D_VTX_MAX\t\t100000\t\t\t\t\t\t\t\t\t// 最大頂点数\n#define D_TREE_MAX\t\tD_VTX_MAX\t\t\t\t\t\t\t\t// 木の最大データ数\n#define D_TREE_WCNT\t\t2\t\t\t\t\t\t\t\t\t\t// 木の方向数\n#define D_TREE_LEFT\t\t0\t\t\t\t\t\t\t\t\t\t// 木の方向 - 左側\n#define D_TREE_RIGHT\t1\t\t\t\t\t\t\t\t\t\t// 木の方向 - 右側\n\n// 内部構造体 - 頂点情報\ntypedef struct Vtx {\n\tint miLen1;\t\t\t\t\t\t\t\t\t\t\t\t\t// 頂点１への距離\n\tint miLen2;\t\t\t\t\t\t\t\t\t\t\t\t\t// 頂点２への距離\n\tint miSum;\t\t\t\t\t\t\t\t\t\t\t\t\t// 合計距離\n} Vtx;\n\n// 内部構造体 - 木構造\ntypedef struct Tree {\n\tVtx *mzpVtx;\t\t\t\t\t\t\t\t\t\t\t\t// 頂点\n\tint mi1Height[D_TREE_WCNT];\t\t\t\t\t\t\t\t\t// 木の高さ\n\tstruct Tree *mzp1Child[D_TREE_WCNT];\t\t\t\t\t\t// 子\n} Tree;\n\n// 内部変数\nstatic FILE *szpFpI;\t\t\t\t\t\t\t\t\t\t\t// 入力\nstatic Vtx sz1Vtx[D_VTX_MAX];\t\t\t\t\t\t\t\t\t// 頂点\nstatic int siVCnt;\t\t\t\t\t\t\t\t\t\t\t\t// 頂点数\nstatic int siVLen;\t\t\t\t\t\t\t\t\t\t\t\t// 頂点１・２間の距離\nstatic Tree sz1Tree[D_TREE_MAX];\t\t\t\t\t\t\t\t// 木の実データ\nstatic int siTCnt;\t\t\t\t\t\t\t\t\t\t\t\t// 木の実データ数\nstatic Tree *szpTop;\t\t\t\t\t\t\t\t\t\t\t// 先頭の木データ\n\n// 内部変数 - テスト用\n#ifdef D_TEST\n\tstatic int siRes;\n\tstatic FILE *szpFpA;\n\tstatic int siTNo;\n#endif\n\n// １行出力\nint\nfOutLine(\n\tchar *pcpLine\t\t\t\t// <I> １行\n)\n{\n\tchar lc1Buf[1024];\n\n#ifdef D_TEST\n\tlc1Buf[0] = '\\0';\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, pcpLine)) {\n\t\tsiRes = -1;\n\t}\n#else\n\tprintf(\"%s\", pcpLine);\n#endif\n\n\treturn 0;\n}\n\n// ソート関数 - 合計距離昇順\nint\nfSortFnc(\n\tconst void *pzpVal1\t\t\t// <I> 値１\n\t, const void *pzpVal2\t\t// <I> 値２\n)\n{\n\tVtx *lzpVal1 = (Vtx *)pzpVal1;\n\tVtx *lzpVal2 = (Vtx *)pzpVal2;\n\n\t// 合計距離昇順\n\tif (lzpVal1->miSum > lzpVal2->miSum) {\n\t\treturn 1;\n\t}\n\telse if (lzpVal1->miSum < lzpVal2->miSum) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n// 木データ - 作成\nTree *\nfTreeMake(\n\tVtx *pzpVtx\t\t\t\t\t// <I> 頂点\n)\n{\n\t// 対象の木データ\n\tTree *lzpTree = &(sz1Tree[siTCnt]);\n\tsiTCnt++;\n\n\t// データセット\n\tmemset(lzpTree, 0, sizeof(Tree));\t\t\t\t\t// 初期化\n\tlzpTree->mzpVtx = pzpVtx;\n\n\treturn lzpTree;\n}\n\n// 木データ - 比較 - 距離昇順\nint\nfTreeCmp(\n\tTree *pzpTree\t\t\t\t// <I> 木データ\n\t, int piLen1\t\t\t\t// <I> 頂点１への距離\n\t, int piLen2\t\t\t\t// <I> 頂点２への距離\n)\n{\n\t// 頂点\n\tVtx *lzpVtx = pzpTree->mzpVtx;\n\n\t// 距離昇順\n\tif (piLen1 < lzpVtx->miLen1) {\t\t\t// 左側\n\t\treturn -1;\n\t}\n\telse if (piLen1 > lzpVtx->miLen1) {\t\t// 右側\n\t\treturn 1;\n\t}\n\tif (piLen2 < lzpVtx->miLen2) {\t\t\t// 左側\n\t\treturn -1;\n\t}\n\telse if (piLen2 > lzpVtx->miLen2) {\t\t// 右側\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n// 木データ - 検索\nTree *\nfTreeSrh(\n\tint piLen1\t\t\t\t\t// <I> 頂点１への距離\n\t, int piLen2\t\t\t\t// <I> 頂点２への距離\n)\n{\n\t// 先頭の木データ\n\tTree *lzpNow = szpTop;\n\n\t// 検索\n\twhile (1) {\n\n\t\t// データ有無\n\t\tif (lzpNow == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\t// 比較\n\t\tint liRet = fTreeCmp(lzpNow, piLen1, piLen2);\n\t\tif (liRet == 0) {\t\t\t\t\t\t\t\t// 一致\n\t\t\treturn lzpNow;\n\t\t}\n\n\t\t// 子へ移動\n\t\tif (liRet < 0) {\t\t\t\t\t\t\t\t// 左側\n\t\t\tlzpNow = lzpNow->mzp1Child[D_TREE_LEFT];\n\t\t}\n\t\telse {\t\t\t\t\t\t\t\t\t\t\t// 右側\n\t\t\tlzpNow = lzpNow->mzp1Child[D_TREE_RIGHT];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n// 木データ - 高さ取得\nint\nfTreeGetHeight(\n\tTree *pzpTree\t\t\t\t// <I> 対象の木情報\n)\n{\n\t// データ有無\n\tif (pzpTree == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (pzpTree->mi1Height[D_TREE_LEFT] >= pzpTree->mi1Height[D_TREE_RIGHT]) {\n\t\treturn pzpTree->mi1Height[D_TREE_LEFT] + 1;\n\t}\n\telse {\n\t\treturn pzpTree->mi1Height[D_TREE_RIGHT] + 1;\n\t}\n}\n\n// 木データ - 右回転(親は子[左]の右下へ・子[左]は親の左上へ)\nint\nfTreeRttR(\n\tTree **pzppTree\t\t\t\t// <I> 回転対象\n)\n{\n\t// 現在の子[左]\n\tTree *lzpChild = (*pzppTree)->mzp1Child[D_TREE_LEFT];\n\n\t// 右回転\n\t(*pzppTree)->mzp1Child[D_TREE_LEFT] = lzpChild->mzp1Child[D_TREE_RIGHT];\t// 親の左側 = 子[左]の右側\n\t(*pzppTree)->mi1Height[D_TREE_LEFT] = lzpChild->mi1Height[D_TREE_RIGHT];\t// 親の高さ(左) = 子[左]の高さ(右)\n\tlzpChild->mzp1Child[D_TREE_RIGHT] = *pzppTree;\t\t\t\t\t\t\t\t// 子[左]の右側 = 親\n\tlzpChild->mi1Height[D_TREE_RIGHT] = fTreeGetHeight(*pzppTree);\t\t\t\t// 子[左]の高さ(右) - 親の高さ\n\t*pzppTree = lzpChild;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 親 = 子[左]\n\n\treturn 0;\n}\n\n// 木データ - 左回転(親は子[右]の左下へ・子[右]は親の右上へ)\nint\nfTreeRttL(\n\tTree **pzppTree\t\t\t\t// <I> 回転対象\n)\n{\n\t// 現在の子[右]\n\tTree *lzpChild = (*pzppTree)->mzp1Child[D_TREE_RIGHT];\n\n\t// 左回転\n\t(*pzppTree)->mzp1Child[D_TREE_RIGHT] = lzpChild->mzp1Child[D_TREE_LEFT];\t// 親の右側 = 子[右]の左側\n\t(*pzppTree)->mi1Height[D_TREE_RIGHT] = lzpChild->mi1Height[D_TREE_LEFT];\t// 親の高さ(右) = 子[右]の高さ(左)\n\tlzpChild->mzp1Child[D_TREE_LEFT] = *pzppTree;\t\t\t\t\t\t\t\t// 子[右]の左側 = 親\n\tlzpChild->mi1Height[D_TREE_LEFT] = fTreeGetHeight(*pzppTree);\t\t\t\t// 子[右]の高さ(左) - 親の高さ\n\t*pzppTree = lzpChild;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 親 = 子[右]\n\n\treturn 0;\n}\n\n// 木データ - 追加・削除の共通処理\n// 戻り値：[2]高さの変更あり [1]高さの変更なし\nint\nfTreeComAddDel(\n\tTree **pzppNow\t\t\t\t// <I> 現在の木情報\n\t, int piWay\t\t\t\t\t// <I> 対象の方向\n)\n{\n\t// 高さの変更があるかチェック\n\tint liNew = fTreeGetHeight((*pzppNow)->mzp1Child[piWay]);\n\tif ((*pzppNow)->mi1Height[piWay] == liNew) {\t\t\t\t\t\t\t\t\t\t\t\t// 変化なし\n\t\treturn 1;\n\t}\n\t(*pzppNow)->mi1Height[piWay] = liNew;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 更新\n\n\t// 高さが離れている場合、回転\n\tif ((*pzppNow)->mi1Height[D_TREE_LEFT] - (*pzppNow)->mi1Height[D_TREE_RIGHT] > 1) {\t\t\t// 左側が高い\n\t\tfTreeRttR(pzppNow);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 右回転\n\t}\n\telse if ((*pzppNow)->mi1Height[D_TREE_RIGHT] - (*pzppNow)->mi1Height[D_TREE_LEFT] > 1) {\t// 右側が高い\n\t\tfTreeRttL(pzppNow);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 左回転\n\t}\n\n\treturn 2;\n}\n\n// 木データ - 追加\n// 戻り値：[2]高さの変更あり [1]高さの変更なし [0]追加なし\nint\nfTreeAdd(\n\tTree **pzppNow\t\t\t\t// <I> 現在の木情報\n\t, Vtx *pzpVtx\t\t\t\t// <I> 頂点\n)\n{\n\t// 作成\n\tif (*pzppNow == NULL) {\n\t\t*pzppNow = fTreeMake(pzpVtx);\n\t\treturn 2;\n\t}\n\n\t// 比較\n\tint liRet = fTreeCmp(*pzppNow, pzpVtx->miLen1, pzpVtx->miLen2);\n\n\t// 一致\n\tif (liRet == 0) {\n\t\treturn 0;\n\t}\n\n\t// 方向の判別\n\tint liWay;\n\tif (liRet < 0) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 左側\n\t\tliWay = D_TREE_LEFT;\n\t}\n\telse {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 右側\n\t\tliWay = D_TREE_RIGHT;\n\t}\n\n\t// 下位へ\n\tliRet = fTreeAdd(&((*pzppNow)->mzp1Child[liWay]), pzpVtx);\n\tif (liRet < 2) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 高さの変更あり以外\n\t\treturn liRet;\n\t}\n\n\t// 追加・削除の共通処理\n\treturn fTreeComAddDel(pzppNow, liWay);\n}\n\n// 実行メイン\nint\nfMain(\n)\n{\n\tint i, j, liRet;\n\tchar lc1Buf[1024];\n\n\t// データ - 初期化\n\tsiTCnt = 0;\n\tszpTop = NULL;\n\n\t// 頂点数 - 取得\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\tsscanf(lc1Buf, \"%d\", &siVCnt);\n\n\t// 頂点 - 取得\n\tfor (i = 0; i < siVCnt; i++) {\n\t\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\t\tsscanf(lc1Buf, \"%d%d\", &sz1Vtx[i].miLen1, &sz1Vtx[i].miLen2);\n\t\tsz1Vtx[i].miSum = sz1Vtx[i].miLen1 + sz1Vtx[i].miLen2;\n\t}\n\n\t// 頂点１・２の距離\n\tif (sz1Vtx[0].miLen1 != 0) {\n\t\treturn -1;\n\t}\n\tif (sz1Vtx[1].miLen2 != 0) {\n\t\treturn -1;\n\t}\n\tif (sz1Vtx[0].miLen1 != sz1Vtx[1].miLen2) {\n\t\treturn -1;\n\t}\n\tsiVLen = sz1Vtx[0].miLen2;\n\n\t// 頂点 - ソート\n\tqsort(sz1Vtx, siVCnt, sizeof(Vtx), fSortFnc);\n\n\t// 頂点１・２間の距離より短い距離\n\tif (sz1Vtx[0].miSum < siVLen) {\n\t\treturn -1;\n\t}\n\n\t// 距離でループ\n\tint liVNo = 0;\n\tsz1Vtx[siVCnt].miSum = INT_MAX;\n\tint liECnt = -2;\n\tfor (i = siVLen; i <= siVCnt * 2; i++) {\n\n\t\t// 対象頂点 - 取得\n\t\tif (sz1Vtx[liVNo].miSum != i) {\n\t\t\tcontinue;\n\t\t}\n\t\tint liSNo = liVNo;\n\t\tint liENo;\n\t\twhile (1) {\n\t\t\tliENo = liVNo;\n\t\t\tliVNo++;\n\t\t\tif (sz1Vtx[liVNo].miSum != i) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// 頂点でループ\n\t\tchar mcDown = D_ON;\n\t\tint liACntLine = 0;\n\t\tint liACntAll = 0;\n\t\tfor (j = liSNo; j <= liENo; j++) {\n\n\t\t\t// 頂点 - 追加\n\t\t\tliRet = fTreeAdd(&szpTop, &sz1Vtx[j]);\n\t\t\tif (liRet > 0) {\n\t\t\t\tliACntLine++;\n\t\t\t}\n\t\t\tliACntAll++;\n\n\t\t\t// 下位頂点の有無\n\t\t\tTree *lzpTree = fTreeSrh(sz1Vtx[j].miLen1 - 1, sz1Vtx[j].miLen2 - 1);\n\t\t\tif (lzpTree == NULL) {\n\t\t\t\tmcDown = D_OFF;\n\t\t\t}\n\t\t}\n\n\t\t// 辺の本数 - 加算\n\t\tif (mcDown == D_ON) {\t\t\t\t\n\t\t\tliECnt += liACntAll;\n\t\t}\n\t\telse {\n\n\t\t\t// 下位頂点のない頂点あり\n\t\t\tif (i == siVLen) {\n\t\t\t\tif (liACntLine != i + 1) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (liACntLine != i - 1) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tliECnt += liACntAll + 1;\n\t\t}\n\t}\n\n\treturn liECnt;\n}\n\n// １回実行\nint\nfOne(\n)\n{\n\tint liRet;\n\tchar lc1Buf[1024];\n\n\t// 入力 - セット\n#ifdef D_TEST\n\tsprintf(lc1Buf, \".\\\\Test\\\\T%d.txt\", siTNo);\n\tszpFpI = fopen(lc1Buf, \"r\");\n\tsprintf(lc1Buf, \".\\\\Test\\\\A%d.txt\", siTNo);\n\tszpFpA = fopen(lc1Buf, \"r\");\n\tsiRes = 0;\n#else\n\tszpFpI = stdin;\n#endif\n\n\t// 実行メイン\n\tliRet = fMain();\n\n\t// 出力\n\tsprintf(lc1Buf, \"%d\\n\", liRet);\n\tfOutLine(lc1Buf);\n\n\t// 残データ有無\n#ifdef D_TEST\n\tlc1Buf[0] = '\\0';\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, \"\")) {\n\t\tsiRes = -1;\n\t}\n#endif\n\n\t// テストファイルクローズ\n#ifdef D_TEST\n\tfclose(szpFpI);\n\tfclose(szpFpA);\n#endif\n\n\t// テスト結果\n#ifdef D_TEST\n\tif (siRes == 0) {\n\t\tprintf(\"OK %d\\n\", siTNo);\n\t}\n\telse {\n\t\tprintf(\"NG %d\\n\", siTNo);\n\t}\n#endif\n\n\treturn 0;\n}\n\n// プログラム開始\nint\nmain()\n{\n\n#ifdef D_TEST\n\tint i;\n\tfor (i = D_TEST_SNO; i <= D_TEST_ENO; i++) {\n\t\tsiTNo = i;\n\t\tfOne();\n\t}\n#else\n\tfOne();\n#endif\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct ll{\n  int data;\n  int num;\n  struct ll *next;\n} DL;\n\nDL *createList(int data, int n){\n  DL *new;\n  new = (DL *)malloc(sizeof(DL));\n  int i;\n  new->data = data;\n  new->num = n;\n\n  return new;\n}\n\nvoid addList(DL **head, DL *add){\n  add->next = *head;\n  *head = add;\n  return;\n}\n\nvoid deleteList(DL **pt){\n  DL *del = *pt;\n  *pt = del->next;\n\n  free(del);\n  return;\n}\n\nvoid printList(DL *head){\n  puts(\"LIST---------------\");\n  while(head != NULL){\n    printf(\"[%d]%d \", head->num, head->data);\n    head = head->next;\n  }\n  putchar('\\n');\n  puts(\"---------------LIST\");\n  return;\n}\n\nvoid printArray(int *data1, int *data2, int n)\n{\n  int i;\n  printf(\"d1[ \");\n  for(i=0; i<n; i++){\n    printf(\"%d \", data1[i]);\n  }\n  printf(\"] d2[ \");\n  for(i=0; i<n; i++){\n    printf(\"%d \", data2[i]);\n  }\n  printf(\"]\\n\");\n  return;\n}\n\nint main()\n{\n  int N;\n  int a, b;\n  int find1, find2;\n  int i, j, n, index, flg, find;\n  int *ss;\n  int data1[100000]={0};\n  int data2[100000]={0};\n\n  DL *head1=NULL;\n  DL *head2=NULL;\n  DL **search = NULL;\n  scanf(\"%d\", &N);\n\n  // \n  for(i=0; i<N; i++){\n    scanf(\"%d%d\", &a, &b);\n    find1=find2=0;\n    a++;b++;\n    if(a==1){\n      data1[i]=a;\n      find1++;\n    }\n    if(b==1){\n      data2[i]=b;\n      find2++;\n    }\n    for(j=0; j<N; j++){\n      if(data1[j] == a-1){\n        data1[i]=a;\n        find1++;\n      }\n      if(data2[j] == b-1){\n        data2[i]=b;\n        find2++;\n      }\n      if(find1 && find2) break;\n    }\n    if(j==N){\n      if(!find1){\n        DL *add = createList(a, i);\n        addList(&head1, add);\n      }\n      if(!find2){\n        DL *add = createList(b, i);\n        addList(&head2, add);\n      }\n    }\n  }\n\n\n  // リストの探索で、喋れる言語がなくなるまでループする。\n  // 新たに喋れる言語が見つからないとき(flg==0)か、リストのデータがなくなった時(head==NULL)にこのループを終了する。\n  find1 = 1;\n  while(find1 && head1 != NULL){\n    search = &head1;\n    find1 = 0;\n    while(*search != NULL){\n      n = (*search)->num;\n      a = (*search)->data;\n      for(i=0; i<N; i++){\n        if(data1[i] == a-1 && abs(data2[n] - data2[i]) == 1){\n          find1++;\n          break;\n        }\n      }\n      if(find1){\n        data1[n] = a;\n        deleteList(search);\n      }else{\n        search = &(*search)->next;\n      }\n    }\n  }\n\n  if(head1 == NULL){\n    find2 = 1;\n    while(find2 && head2 != NULL){\n      search = &head2;\n      find2 = 0;\n      while(*search != NULL){\n        n = (*search)->num;\n        b = (*search)->data;\n        for(i=0; i<N; i++){\n          if(data2[i] == b-1 && abs(data1[n] - data1[i]) == 1){\n            find2++;\n            break;\n          }\n        }\n        if(find2){\n          data2[n] = b;\n          deleteList(search);\n        }else{\n          search = &(*search)->next;\n        }\n      }\n    }\n  }\n  printf(head1==NULL && head2==NULL ? \"YES\" : \"NO\");\n  return(0);\n}\n"
  },
  {
    "language": "Python",
    "code": "n = input()\nAB = [map(int, raw_input().split()) for i in xrange(n)]\nif not AB[0][0] == AB[1][1] == 0:\n    print -1\n    exit(0)\nif not AB[0][1] == AB[1][0]:\n    print -1\n    exit(0)\nparent = range(n)\ndef root(x):\n    if x == parent[x]:\n        return x\n    parent[x] = root(parent[x])\n    return parent[x]\ndef unite(x, y):\n    px = root(x)\n    py = root(y)\n    if px < py:\n        parent[py] = px\n    elif px > py:\n        parent[px] = py\n    return min(px, py)\nd = AB[0][1]\nused = [0]*n\nchain = [0]*d\nS = {}\nAm = {}\nBm = {}\nunite(0, 1)\nused[0] = used[1] = 1\nfor i in xrange(n):\n    ABi = AB[i]\n    if ABi[0] + ABi[1] == d and 1 < ABi[0] < d and not chain[ABi[0]]:\n        used[i] = 1\n        chain[ABi[0]] = 1\n        unite(0, i)\n    S[tuple(ABi)] = i\n    Am[ABi[0]] = i\n    Bm[ABi[1]] = i\nif sum(chain) != d-1:\n    print -1\n    exit(0)\nans = d\nfor i in xrange(n):\n    if not used[i]:\n        a, b = AB[i]\n        if (a-1, b-1) in S:\n            used[i] = 1\n            unite(i, S[a-1, b-1])\n            ans += 1\n        else:\n            if a-1 not in Am and b-1 not in Bm:\n                print -1\n                exit(0)\n            unite(i, Am[a-1])\n            unite(i, Bm[b-1])\n            ans += 2\nfor i in xrange(n):\n    root(i)\nif sum(parent) == 0:\n    print ans\nelse:\n    print -1\n"
  }
]