[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nint parent[MAX_N];\nint size[MAX_N];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    if (rootX != rootY) {\n        if (size[rootX] < size[rootY]) {\n            int temp = rootX;\n            rootX = rootY;\n            rootY = temp;\n        }\n        parent[rootY] = rootX;\n        size[rootX] += size[rootY];\n    }\n}\n\nint main() {\n    int n;\n    char s[MAX_N];\n    scanf(\"%d %s\", &n, s);\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        size[i] = 1;\n    }\n\n    int edges[MAX_N][2];\n    int edgeCount = 0;\n\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            int components[MAX_N] = {0};\n            int componentCount = 0;\n            \n            for (int k = 1; k <= n; k++) {\n                parent[k] = k;\n                size[k] = 1;\n            }\n\n            for (int k = 0; k < edgeCount; k++) {\n                if (k != i - 1) {\n                    unionSet(edges[k][0], edges[k][1]);\n                }\n            }\n\n            for (int k = 1; k <= n; k++) {\n                int root = find(k);\n                if (components[root] == 0) {\n                    componentCount++;\n                    components[root] = size[root];\n                }\n            }\n\n            int valid = 1;\n            for (int k = 1; k <= n; k++) {\n                if (s[k-1] == '1' && components[find(k)] != k) {\n                    valid = 0;\n                    break;\n                }\n                if (s[k-1] == '0' && components[find(k)] == k) {\n                    valid = 0;\n                    break;\n                }\n            }\n\n            if (valid) {\n                edges[edgeCount][0] = i;\n                edges[edgeCount][1] = j;\n                edgeCount++;\n                break;\n            }\n        }\n        if (edgeCount < i) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n    }\n\n    for (int i = 0; i < edgeCount; i++) {\n        printf(\"%d %d\\n\", edges[i][0], edges[i][1]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[n+1];\n    scanf(\"%s\", s);\n    \n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '1') count++;\n    }\n    \n    if (count == 0 || s[n-1] != '1') {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    \n    int star_possible = 1;\n    for (int i = 0; i < n-1; i++) {\n        if (s[i] == '1') {\n            star_possible = 0;\n            break;\n        }\n    }\n    \n    if (star_possible) {\n        for (int i = 2; i <= n; i++) {\n            printf(\"1 %d\\n\", i);\n        }\n        return 0;\n    }\n    \n    int possible = 1;\n    for (int i = 0; i < n/2; i++) {\n        if (s[i] != s[n-2-i]) {\n            possible = 0;\n            break;\n        }\n    }\n    \n    if (!possible) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    \n    int center = -1;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '1') {\n            center = i + 1;\n            break;\n        }\n    }\n    \n    if (center == -1) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    \n    int current = center;\n    for (int i = 1; i <= n; i++) {\n        if (i == center) continue;\n        printf(\"%d %d\\n\", current, i);\n        if (i < center || (i > center && s[i-1] == '1')) {\n            current = i;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<pair<int, int>> edges;\n\n    int root = 1;\n    int next = 2;\n    bool possible = true;\n\n    if (s[n-1] != '1') {\n        possible = false;\n    }\n\n    if (possible) {\n        for (int i = 0; i < n - 1; ++i) {\n            if (s[i] == '1') {\n                edges.emplace_back(root, next);\n                root = next;\n                next++;\n            } else {\n                edges.emplace_back(1, next);\n                next++;\n            }\n        }\n    }\n\n    if (!possible) {\n        cout << -1 << endl;\n    } else {\n        for (auto &edge : edges) {\n            cout << edge.first << \" \" << edge.second << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeConstruction {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.next();\n        int n = s.length();\n        \n        List<Integer> ones = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '1') {\n                ones.add(i + 1);\n            }\n        }\n        \n        if (ones.isEmpty()) {\n            System.out.println(-1);\n            return;\n        }\n        \n        if (ones.get(ones.size() - 1) != n) {\n            System.out.println(-1);\n            return;\n        }\n        \n        for (int i = 0; i < ones.size() - 1; i++) {\n            if (ones.get(i + 1) - ones.get(i) > 1) {\n                System.out.println(-1);\n                return;\n            }\n        }\n        \n        List<Integer> parents = new ArrayList<>();\n        int current = ones.get(0);\n        for (int i = 1; i < current; i++) {\n            parents.add(current);\n        }\n        \n        for (int i = 1; i < ones.size(); i++) {\n            int prev = ones.get(i - 1);\n            int next = ones.get(i);\n            for (int j = prev + 1; j < next; j++) {\n                parents.add(prev);\n            }\n            parents.add(prev);\n        }\n        \n        for (int parent : parents) {\n            System.out.println(parent + \" \" + (parents.indexOf(parent) + 2));\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:02:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeConstruction {\n    public static void solve(String s) {\n        int n = s.length();\n        List<int[]> edges = new ArrayList<>();\n        \n        if (n == 1) {\n            if (s.charAt(0) == '0') {\n                System.out.println(\"YES\");\n                return;\n            } else {\n                System.out.println(\"NO\");\n                return;\n            }\n        }\n        \n        if (s.charAt(0) == '1') {\n            System.out.println(\"NO\");\n            return;\n        }\n        \n        int[] parent = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            parent[i] = i;\n        }\n        \n        int[] rank = new int[n + 1];\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) return;\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n        \n        for (int i = 1; i < n; i++) {\n            if (s.charAt(i) == '0') {\n                int u = i, v = i + 1;\n                edges.add(new int[]{u, v});\n                union(u, v);\n            } else {\n                boolean found = false;\n                for (int j = 1; j < i; j++) {\n                    if (find(j) != find(i + 1)) {\n                        edges.add(new int[]{j, i + 1});\n                        union(j, i + 1);\n                        found = true;\n                        break;\n                    }\n                }\n                \n                if (!found) {\n                    System.out.println(\"NO\");\n                    return;\n                }\n            }\n        }\n        \n        System.out.println(\"YES\");\n        for (int[] edge : edges) {\n            System.out.println(edge[0] + \" \" + edge[1]);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.next();\n        solve(s);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:02:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nclass DSU {\npublic:\n    vector<int> parent, rank;\n    DSU(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    bool unite(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return false;\n        \n        if (rank[px] < rank[py]) swap(px, py);\n        parent[py] = px;\n        if (rank[px] == rank[py]) rank[px]++;\n        return true;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int n;\n    string s;\n    cin >> n >> s;\n    \n    vector<pair<int, int>> edges;\n    DSU dsu(n);\n    \n    for (int i = 0; i < n - 1; i++) {\n        int u = 0, v = 0;\n        for (int j = 0; j < n; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (dsu.find(j) != dsu.find(k)) {\n                    u = j;\n                    v = k;\n                    break;\n                }\n            }\n            if (u != v) break;\n        }\n        \n        dsu.unite(u, v);\n        edges.emplace_back(u + 1, v + 1);\n    }\n    \n    bool possible = true;\n    for (int i = 0; i < n; i++) {\n        DSU check(n);\n        int componentSize = 0;\n        \n        for (int j = 0; j < edges.size(); j++) {\n            if (j == i) continue;\n            check.unite(edges[j].first - 1, edges[j].second - 1);\n        }\n        \n        set<int> roots;\n        for (int j = 0; j < n; j++) {\n            roots.insert(check.find(j));\n        }\n        componentSize = roots.size();\n        \n        if (s[i] == '1' && componentSize != n - 1) possible = false;\n        if (s[i] == '0' && componentSize == n - 1) possible = false;\n    }\n    \n    if (!possible) {\n        cout << -1 << endl;\n        return 0;\n    }\n    \n    for (auto& [u, v] : edges) {\n        cout << u << \" \" << v << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:03:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def construct_tree(s):\n    n = len(s)\n    edges = []\n    degree = [0] * n\n\n    if s[0] == '0':\n        return \"No tree can be constructed\"\n    \n    for i in range(1, n):\n        if s[i] == '1':\n            edges.append((i, i + 1))\n            degree[i - 1] += 1\n            degree[i] += 1\n        else:\n            found = False\n            for j in range(i - 1):\n                if degree[j] < 2:\n                    edges.append((j + 1, i + 1))\n                    degree[j] += 1\n                    degree[i] += 1\n                    found = True\n                    break\n            if not found:\n                return \"No tree can be constructed\"\n    \n    return edges\n\n# Example usage:\ns = \"1110\"\nedges = construct_tree(s)\nif isinstance(edges, str):\n    print(edges)\nelse:\n    for u, v in edges:\n        print(u, v)",
    "timestamp": "2025-08-13 13:24:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class TreeConstruction {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.nextLine();\n        scanner.close();\n\n        int n = s.length();\n        List<int[]> edges = new ArrayList<>();\n\n        int maxLeaf = 1;\n        for (int i = 2; i <= n; i++) {\n            if (s.charAt(i - 1) == '1' && maxLeaf < i) {\n                maxLeaf = i;\n            }\n        }\n\n        if (maxLeaf == 1 || s.charAt(maxLeaf - 1) != '1') {\n            System.out.println(\"No valid tree exists\");\n            return;\n        }\n\n        int[] parent = new int[n + 1];\n        for (int i = 2; i <= maxLeaf; i++) {\n            parent[i] = i - 1;\n            edges.add(new int[]{i - 1, i});\n        }\n\n        int leafCount = maxLeaf;\n        for (int i = 2; i < maxLeaf; i++) {\n            if (s.charAt(i - 1) == '0') {\n                while (leafCount < n) {\n                    leafCount++;\n                    edges.add(new int[]{i, leafCount});\n                }\n            }\n        }\n\n        if (edges.size() != n - 1) {\n            System.out.println(\"No valid tree exists\");\n            return;\n        }\n\n        for (int[] edge : edges) {\n            System.out.println(edge[0] + \" \" + edge[1]);\n        }\n    }\n}",
    "timestamp": "2025-08-13 13:24:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int u, v;\n} Edge;\n\n// Function to construct the tree\nint construct_tree(const char *s, int n, Edge *edges) {\n    int *degree = (int *)malloc(n * sizeof(int));\n    int *components = (int *)malloc(n * sizeof(int));\n    memset(degree, 0, n * sizeof(int));\n    memset(components, 0, n * sizeof(int));\n    \n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '1') {\n            components[i + 1] = 1;\n        }\n    }\n    \n    int edge_count = 0;\n    for (int i = 2; i <= n; ++i) {\n        if (components[i]) {\n            int parent = i - 1;\n            edges[edge_count].u = parent;\n            edges[edge_count].v = i;\n            degree[parent]++;\n            degree[i]++;\n            edge_count++;\n        }\n    }\n    \n    int current = 1;\n    for (int i = 1; i <= edge_count; ++i) {\n        while(degree[current] > 1) {\n            current++;\n        }\n        if (edges[i - 1].u == current || edges[i - 1].v == current) {\n            continue;\n        }\n        \n        if (edges[i - 1].u > 1) {\n            edges[i - 1].u = current;\n        } else {\n            edges[i - 1].v = current;\n        }\n        \n        degree[current]++;\n        current++;\n    }\n    \n    free(degree);\n    free(components);\n    \n    return n - 1;\n}\n\nint main() {\n    char s[] = \"011100110\";\n    int n = strlen(s);\n    Edge *edges = (Edge *)malloc((n - 1) * sizeof(Edge));\n    \n    construct_tree(s, n, edges);\n    \n    printf(\"Edges:\\n\");\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d %d\\n\", edges[i].u, edges[i].v);\n    }\n    \n    free(edges);\n    return 0;\n}",
    "timestamp": "2025-08-13 13:24:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    \n    // Check if condition for n (having a tree) is satisfied\n    if (s[n - 2] != '1' || s[0] != '0') {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    int componentCount = 0;\n    vector<pair<int, int>> edges;\n    int last_component_end = 1;\n\n    for (int component_size = n - 1; component_size >= 1; --component_size) {\n        if (s[component_size - 1] == '1') {\n            for (int i = last_component_end + 1; i <= last_component_end + component_size - 1; ++i) {\n                edges.push_back({last_component_end, i});\n            }\n            edges.push_back({last_component_end, ++componentCount});\n            last_component_end += component_size;\n        }\n    }\n    \n    if (edges.size() != n - 1) {\n        cout << \"-1\\n\";\n    } else {\n        for (auto &edge : edges) {\n            cout << edge.first << \" \" << edge.second << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:24:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(s):\n    n = len(s)\n    \n    if n == 1:\n        return [0, 0] if s[0] == '0' else None\n    \n    # For 0, every edge must split the tree into components different from any specified size\n    # For 1, there must exist an edge that splits the tree into components of exactly that size\n    \n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px != py:\n            parent[px] = py\n    \n    edges = []\n    \n    for i in range(n-1):\n        # Try different edge connections\n        for u in range(n):\n            for v in range(u+1, n):\n                # Reset parent for new configuration\n                parent = list(range(n))\n                edges = []\n                \n                # Add edges except current candidate\n                for j in range(n-1):\n                    if j != i or (j == i and u != edges[j][0] and v != edges[j][1]):\n                        union(edges[j][0], edges[j][1])\n                \n                # Add current candidate edge\n                edges.append((u, v))\n                union(u, v)\n                \n                # Check if current configuration works\n                components = {}\n                for x in range(n):\n                    root = find(x)\n                    components[root] = components.get(root, 0) + 1\n                \n                valid = True\n                for j in range(n):\n                    if s[j] == '1' and not any(size == j+1 for size in components.values()):\n                        valid = False\n                        break\n                    if s[j] == '0' and any(size == j+1 for size in components.values()):\n                        valid = False\n                        break\n                \n                if valid:\n                    return edges\n    \n    return None\n\ndef main():\n    s = input().strip()\n    result = solve(s)\n    \n    if result is None:\n        print(-1)\n    else:\n        print(len(result))\n        for u, v in result:\n            print(u+1, v+1)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 13:25:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    if s[0] != '1' or s[-1] != '1':\n        print(-1)\n        return\n    \n    for i in range(n-1):\n        if s[i] != s[n-2 -i]:\n            print(-1)\n            return\n    \n    q = deque()\n    current = 1\n    q.append(current)\n    edges = []\n    \n    for i in range(1, n):\n        if s[i-1] == '1':\n            next_node = i + 1\n            edges.append((current, next_node))\n            q.append(next_node)\n            current = next_node\n        else:\n            parent = q.popleft()\n            edges.append((parent, i + 1))\n    \n    for u, v in edges:\n        print(u, v)\n\nsolve()",
    "timestamp": "2025-08-13 13:25:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function constructTree(s) {\n    const n = s.length;\n    const edges = [];\n\n    // Add n-1 edges for a linear chain structure\n    for (let i = 1; i < n; i++) {\n        edges.push([i, i + 1]);\n    }\n\n    if (n <= 3) return edges;\n\n    for (let i = 2; i < n; i++) {\n        if (s[i] === '1') {\n            let found = false;\n            for (let u = 1; u <= i; u++) {\n                for (let v = u + 1; v <= i + 1; v++) {\n                    if (edges.findIndex(edge => (edge[0] === u && edge[1] === v) || (edge[0] === v && edge[1] === u)) === -1) {\n                        edges.push([u, v]);\n                        found = true;\n                        break;\n                    }\n                }\n                if (found) break;\n            }\n            if (!found) return null; // If we can’t create such an edge, return null\n        } else if (s[i] === '0') {\n            // Ensure no edge removal results in a component of size i\n            let graph = new Array(n + 1).fill(null).map(() => []);\n            edges.forEach(([u, v]) => {\n                graph[u].push(v);\n                graph[v].push(u);\n            });\n\n            // Try to remove each edge and see if it creates a component of size i\n            let possible = false;\n            for (let [u, v] of edges) {\n                let visited = new Array(n + 1).fill(false);\n                function dfs(node, count = 0) {\n                    visited[node] = true;\n                    count++;\n                    for (let neighbor of graph[node]) {\n                        if (!visited[neighbor] && !(node === u && neighbor === v || node === v && neighbor === u)) {\n                            count = dfs(neighbor, count);\n                        }\n                    }\n                    return count;\n                }\n\n                visited[v] = true;\n                if (dfs(u) === i || dfs(v) === i) {\n                    possible = true;\n                    break;\n                }\n            }\n            if (possible) return null; // If any removal resulted in a component of size i, return null\n        }\n    }\n\n    return edges;\n}\n\nconst s = \"110\"; // Example usage\nconsole.log(constructTree(s)); // Output example: [[1, 2], [2, 3]]",
    "timestamp": "2025-08-13 13:25:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function constructTree(s) {\n    const n = s.length;\n    const graph = Array.from({ length: n + 1 }, () => []);\n    const parent = Array(n + 1).fill(0);\n\n    function addEdge(u, v) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    function dfs(node, par) {\n        parent[node] = par;\n        for (const child of graph[node]) {\n            if (child !== par) {\n                dfs(child, node);\n            }\n        }\n    }\n\n    function checkComponentSize(removedEdge) {\n        const visited = Array(n + 1).fill(false);\n        const components = [];\n\n        function componentDfs(node, component) {\n            visited[node] = true;\n            component.push(node);\n            for (const neighbor of graph[node]) {\n                if (!visited[neighbor] && (node !== removedEdge[0] || neighbor !== removedEdge[1]) &&\n                    (node !== removedEdge[1] || neighbor !== removedEdge[0])) {\n                    componentDfs(neighbor, component);\n                }\n            }\n        }\n\n        for (let i = 1; i <= n; i++) {\n            if (!visited[i]) {\n                const component = [];\n                componentDfs(i, component);\n                components.push(component);\n            }\n        }\n\n        return components;\n    }\n\n    for (let i = 1; i < n; i++) {\n        addEdge(i, i + 1);\n    }\n\n    dfs(1, 0);\n\n    for (let i = 0; i < n; i++) {\n        const possibleRemovals = [];\n        for (let j = 1; j < n; j++) {\n            const u = j, v = j + 1;\n            const components = checkComponentSize([u, v]);\n            \n            if (s[i] === '1' && components.some(comp => comp.length === i + 1)) {\n                possibleRemovals.push([u, v]);\n            }\n            if (s[i] === '0' && !components.some(comp => comp.length === i + 1)) {\n                possibleRemovals.push([u, v]);\n            }\n        }\n\n        if (possibleRemovals.length === 0) {\n            return null;\n        }\n    }\n\n    const edges = [];\n    for (let i = 1; i < n; i++) {\n        edges.push([i, i + 1]);\n    }\n\n    return edges;\n}",
    "timestamp": "2025-08-13 13:25:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    rl.on('line', (input) => {\n        const s = input.trim();\n        const n = s.length;\n        const res = [];\n        let possible = true;\n        let ones = [];\n        \n        for (let i = 0; i < n; i++) {\n            if (s[i] === '1') {\n                ones.push(i + 1);\n            }\n        }\n        \n        if (ones.length === 0) {\n            possible = false;\n        } else {\n            const m = ones.length;\n            for (let i = 0; i < m - 1; i++) {\n                res.push([ones[i], ones[i + 1]]);\n            }\n            \n            let current = ones[m - 1];\n            for (let i = 1; i <= n; i++) {\n                if (i < ones[0]) {\n                    res.push([current, i]);\n                } else if (ones.indexOf(i) === -1) {\n                    if (ones[0] !== 1) {\n                        res.push([ones[0] - 1, i]);\n                    } else {\n                        possible = false;\n                        break;\n                    }\n                }\n            }\n            \n            for (let i = 1; i <= n; i++) {\n                if (s[i - 1] === '1') {\n                    let found = false;\n                    for (let j = 0; j < res.length; j++) {\n                        const [u, v] = res[j];\n                        if (u === i || v === i) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        possible = false;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        if (!possible) {\n            console.log(\"NO\");\n        } else {\n            console.log(\"YES\");\n            res.forEach(edge => console.log(edge[0], edge[1]));\n        }\n        rl.close();\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:25:39"
  }
]