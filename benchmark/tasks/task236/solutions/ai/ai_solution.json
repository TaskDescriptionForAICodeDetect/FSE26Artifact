[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x;\n    int y;\n    int r;\n} Antenna;\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    \n    while (T--) {\n        int N;\n        scanf(\"%d\", &N);\n        Antenna *antennas = (Antenna *)malloc(N * sizeof(Antenna));\n        \n        int minX = 100000, maxX = -100000;\n        int minY = 100000, maxY = -100000;\n        \n        for (int i = 0; i < N; i++) {\n            scanf(\"%d %d %d\", &antennas[i].x, &antennas[i].y, &antennas[i].r);\n            minX = min(minX, antennas[i].x - antennas[i].r);\n            maxX = max(maxX, antennas[i].x + antennas[i].r);\n            minY = min(minY, antennas[i].y - antennas[i].r);\n            maxY = max(maxY, antennas[i].y + antennas[i].r);\n        }\n        \n        int width = maxX - minX;\n        int height = maxY - minY;\n        int **grid = (int **)calloc(width, sizeof(int *));\n        for (int i = 0; i < width; i++) {\n            grid[i] = (int *)calloc(height, sizeof(int));\n        }\n        \n        for (int i = 0; i < N; i++) {\n            int x1 = antennas[i].x - antennas[i].r - minX;\n            int x2 = antennas[i].x + antennas[i].r - minX;\n            int y1 = antennas[i].y - antennas[i].r - minY;\n            int y2 = antennas[i].y + antennas[i].r - minY;\n            \n            for (int x = max(0, x1); x < min(width, x2); x++) {\n                for (int y = max(0, y1); y < min(height, y2); y++) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n        \n        int area = 0;\n        for (int x = 0; x < width; x++) {\n            for (int y = 0; y < height; y++) {\n                if (grid[x][y]) {\n                    area++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", area);\n        \n        for (int i = 0; i < width; i++) {\n            free(grid[i]);\n        }\n        free(grid);\n        free(antennas);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:13:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AntennaCoverage {\n    static class Antenna {\n        int x, y, power;\n        \n        Antenna(int x, int y, int power) {\n            this.x = x;\n            this.y = y;\n            this.power = power;\n        }\n    }\n    \n    public static double calculateTotalCoverage(List<Antenna> antennas) {\n        if (antennas == null || antennas.isEmpty()) {\n            return 0;\n        }\n        \n        List<Rectangle> rectangles = new ArrayList<>();\n        \n        for (Antenna antenna : antennas) {\n            rectangles.add(new Rectangle(\n                antenna.x - antenna.power, \n                antenna.y - antenna.power, \n                antenna.x + antenna.power, \n                antenna.y + antenna.power\n            ));\n        }\n        \n        return mergeRectangles(rectangles);\n    }\n    \n    static class Rectangle {\n        int x1, y1, x2, y2;\n        \n        Rectangle(int x1, int y1, int x2, int y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n        }\n    }\n    \n    static double mergeRectangles(List<Rectangle> rectangles) {\n        if (rectangles.isEmpty()) return 0;\n        \n        // Sort rectangles by left coordinate\n        Collections.sort(rectangles, (a, b) -> Integer.compare(a.x1, b.x1));\n        \n        double totalArea = 0;\n        Rectangle current = rectangles.get(0);\n        \n        for (int i = 1; i < rectangles.size(); i++) {\n            Rectangle next = rectangles.get(i);\n            \n            // No overlap\n            if (next.x1 > current.x2) {\n                totalArea += calculateRectangleArea(current);\n                current = next;\n            }\n            // Overlap or merge\n            else {\n                current.x2 = Math.max(current.x2, next.x2);\n                current.y1 = Math.max(current.y1, next.y1);\n                current.y2 = Math.min(current.y2, next.y2);\n            }\n        }\n        \n        // Add last rectangle\n        totalArea += calculateRectangleArea(current);\n        \n        return totalArea;\n    }\n    \n    static double calculateRectangleArea(Rectangle r) {\n        return Math.max(0, r.x2 - r.x1) * Math.max(0, r.y2 - r.y1);\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        List<Antenna> antennas = new ArrayList<>();\n        antennas.add(new Antenna(0, 0, 2));\n        antennas.add(new Antenna(3, 3, 1));\n        \n        double totalCoverage = calculateTotalCoverage(antennas);\n        System.out.println(\"Total Coverage: \" + totalCoverage);\n    }\n}",
    "timestamp": "2025-08-05 19:13:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    int power;\n};\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        int N;\n        cin >> N;\n        vector<Point> antennas(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> antennas[i].x >> antennas[i].y >> antennas[i].power;\n        }\n\n        set<pair<int, int>> covered;\n        for (const auto& ant : antennas) {\n            int x1 = ant.x - ant.power;\n            int x2 = ant.x + ant.power;\n            int y1 = ant.y - ant.power;\n            int y2 = ant.y + ant.power;\n\n            for (int x = x1; x <= x2; ++x) {\n                for (int y = y1; y <= y2; ++y) {\n                    covered.insert({x, y});\n                }\n            }\n        }\n\n        cout << covered.size() << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:14:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_ANTENNAS 1000\n#define MAX_COORD 10000\n\ntypedef struct {\n    int x, y, power;\n} Antenna;\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint calculateCoveredArea(Antenna* antennas, int n) {\n    int minX = INT_MAX, maxX = INT_MIN;\n    int minY = INT_MAX, maxY = INT_MIN;\n\n    for (int i = 0; i < n; i++) {\n        int x1 = antennas[i].x - antennas[i].power;\n        int x2 = antennas[i].x + antennas[i].power;\n        int y1 = antennas[i].y - antennas[i].power;\n        int y2 = antennas[i].y + antennas[i].power;\n\n        minX = min(minX, x1);\n        maxX = max(maxX, x2);\n        minY = min(minY, y1);\n        maxY = max(maxY, y2);\n    }\n\n    int width = maxX - minX + 1;\n    int height = maxY - minY + 1;\n    char** grid = malloc(height * sizeof(char*));\n    for (int i = 0; i < height; i++) {\n        grid[i] = calloc(width, sizeof(char));\n    }\n\n    for (int i = 0; i < n; i++) {\n        int x1 = antennas[i].x - antennas[i].power - minX;\n        int x2 = antennas[i].x + antennas[i].power - minX;\n        int y1 = antennas[i].y - antennas[i].power - minY;\n        int y2 = antennas[i].y + antennas[i].power - minY;\n\n        for (int y = y1; y <= y2; y++) {\n            for (int x = x1; x <= x2; x++) {\n                grid[y][x] = 1;\n            }\n        }\n    }\n\n    int coveredArea = 0;\n    for (int y = 0; y < height; y++) {\n        for (int x = 0; x < width; x++) {\n            if (grid[y][x]) coveredArea++;\n        }\n        free(grid[y]);\n    }\n    free(grid);\n\n    return coveredArea;\n}\n\nint main() {\n    int testCases;\n    scanf(\"%d\", &testCases);\n\n    while (testCases--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        Antenna antennas[MAX_ANTENNAS];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %d\", &antennas[i].x, &antennas[i].y, &antennas[i].power);\n        }\n\n        int totalArea = calculateCoveredArea(antennas, n);\n        printf(\"%d\\n\", totalArea);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:14:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct Antenna {\n    int x, y, power;\n};\n\nint calculateCoveredArea(vector<Antenna>& antennas) {\n    vector<pair<int, int>> xCoords, yCoords;\n    \n    for (auto& antenna : antennas) {\n        xCoords.push_back({antenna.x - antenna.power, 1});\n        xCoords.push_back({antenna.x + antenna.power + 1, -1});\n        yCoords.push_back({antenna.y - antenna.power, 1});\n        yCoords.push_back({antenna.y + antenna.power + 1, -1});\n    }\n    \n    sort(xCoords.begin(), xCoords.end());\n    sort(yCoords.begin(), yCoords.end());\n    \n    int totalArea = 0;\n    int prevX = xCoords[0].first;\n    int activeX = 0;\n    \n    for (auto& [x, delta] : xCoords) {\n        if (activeX > 0) {\n            totalArea += (x - prevX);\n        }\n        \n        activeX += delta;\n        prevX = x;\n    }\n    \n    int prevY = yCoords[0].first;\n    int activeY = 0;\n    \n    for (auto& [y, delta] : yCoords) {\n        if (activeY > 0) {\n            totalArea *= (y - prevY);\n        }\n        \n        activeY += delta;\n        prevY = y;\n    }\n    \n    return totalArea;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Antenna> antennas(n);\n    \n    for (int i = 0; i < n; i++) {\n        cin >> antennas[i].x >> antennas[i].y >> antennas[i].power;\n    }\n    \n    int result = calculateCoveredArea(antennas);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:14:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AntennaCoverage {\n    static class Square {\n        int x1, y1, x2, y2;\n        Square(int x, int y, int p) {\n            this.x1 = x - p;\n            this.y1 = y - p;\n            this.x2 = x + p;\n            this.y2 = y + p;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt();\n        for (int t = 0; t < T; t++) {\n            int N = scanner.nextInt();\n            List<Square> squares = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n                int p = scanner.nextInt();\n                squares.add(new Square(x, y, p));\n            }\n\n            List<Square> merged = new ArrayList<>();\n            for (Square s : squares) {\n                List<Square> temp = new ArrayList<>();\n                temp.add(s);\n                for (Square m : merged) {\n                    Square last = temp.get(temp.size() - 1);\n                    if (overlap(last, m)) {\n                        temp.remove(temp.size() - 1);\n                        temp.add(merge(last, m));\n                    } else {\n                        temp.add(m);\n                    }\n                }\n                merged = temp;\n            }\n\n            int totalArea = 0;\n            for (Square s : merged) {\n                totalArea += (s.x2 - s.x1) * (s.y2 - s.y1);\n            }\n            System.out.println(totalArea);\n        }\n        scanner.close();\n    }\n\n    private static boolean overlap(Square a, Square b) {\n        return !(a.x2 < b.x1 || b.x2 < a.x1 || a.y2 < b.y1 || b.y2 < a.y1);\n    }\n\n    private static Square merge(Square a, Square b) {\n        int x1 = Math.min(a.x1, b.x1);\n        int y1 = Math.min(a.y1, b.y1);\n        int x2 = Math.max(a.x2, b.x2);\n        int y2 = Math.max(a.y2, b.y2);\n        return new Square((x1 + x2) / 2, (y1 + y2) / 2, (x2 - x1) / 2);\n    }\n}",
    "timestamp": "2025-08-05 19:14:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def total_coverage_area(antennas):\n    events = []\n    for x, y, power in antennas:\n        events.append((x - power, y - power, x + power, y + power))\n    \n    events.sort()\n    \n    def merge_intervals(intervals):\n        if not intervals:\n            return []\n        merged_intervals = []\n        current_start, current_end = intervals[0]\n        for start, end in intervals[1:]:\n            if start <= current_end:\n                current_end = max(current_end, end)\n            else:\n                merged_intervals.append((current_start, current_end))\n                current_start, current_end = start, end\n        merged_intervals.append((current_start, current_end))\n        return merged_intervals\n    \n    active_intervals = []\n    total_area = 0\n    \n    for x_start, y_start, x_end, y_end in events:\n        new_intervals = []\n        for y_s, y_e in active_intervals:\n            if y_e < y_start:\n                new_intervals.append((y_s, y_e))\n            elif y_s > y_end:\n                new_intervals.append((y_s, y_e))\n            else:\n                y_s = min(y_s, y_start)\n                y_e = max(y_e, y_end)\n                new_intervals.append((y_s, y_e))\n        \n        new_intervals.append((y_start, y_end))\n        new_intervals.sort()\n        active_intervals = merge_intervals(new_intervals)\n\n        if new_intervals != active_intervals:\n            total_area += x_end - x_start\n    \n    for y_start, y_end in active_intervals:\n        total_area += y_end - y_start\n    \n    return total_area\n\n# Example usage:\nantennas = [(1, 1, 1), (4, 4, 1)]\nprint(total_coverage_area(antennas))",
    "timestamp": "2025-08-13 03:03:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass Antenna {\n    int x, y, power;\n    \n    Antenna(int x, int y, int power) {\n        this.x = x;\n        this.y = y;\n        this.power = power;\n    }\n}\n\npublic class AntennaCoverage {\n    \n    public static int calculateCoverage(List<Antenna> antennas) {\n        Set<String> coveredPoints = new HashSet<>();\n        \n        for (Antenna antenna : antennas) {\n            int xStart = antenna.x - antenna.power;\n            int xEnd = antenna.x + antenna.power;\n            int yStart = antenna.y - antenna.power;\n            int yEnd = antenna.y + antenna.power;\n            \n            for (int x = xStart; x <= xEnd; x++) {\n                for (int y = yStart; y <= yEnd; y++) {\n                    coveredPoints.add(x + \",\" + y);\n                }\n            }\n        }\n        \n        return coveredPoints.size();\n    }\n    \n    public static void main(String[] args) {\n        List<Antenna> antennas = Arrays.asList(\n            new Antenna(1, 1, 4),\n            new Antenna(3, 3, 2),\n            new Antenna(-1, -1, 1)\n        );\n        \n        System.out.println(\"Total covered area: \" + calculateCoverage(antennas));\n    }\n}",
    "timestamp": "2025-08-13 03:03:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, power;\n} Antenna;\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Antenna *antennas = malloc(n * sizeof(Antenna));\n    int *events = malloc(4 * n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &antennas[i].x, &antennas[i].y, &antennas[i].power);\n        int p = antennas[i].power;\n        events[4*i] = antennas[i].x - p;\n        events[4*i + 1] = antennas[i].x + p;\n        events[4*i + 2] = antennas[i].y - p;\n        events[4*i + 3] = antennas[i].y + p;\n    }\n\n    qsort(events, 4 * n, sizeof(int), compare);\n\n    int *unique_vals = malloc(4 * n * sizeof(int));\n    int count = 1;\n    unique_vals[0] = events[0];\n\n    for (int i = 1; i < 4 * n; i++) {\n        if (events[i] != events[i - 1])\n            unique_vals[count++] = events[i];\n    }\n\n    int total_area = 0;\n    for (int i = 0; i < count - 1; i++) {\n        int x_start = unique_vals[i];\n        int x_end = unique_vals[i + 1];\n\n        for (int j = 0; j < count - 1; j++) {\n            int y_start = unique_vals[j];\n            int y_end = unique_vals[j + 1];\n            \n            int covered = 0;\n            for (int k = 0; k < n && !covered; k++) {\n                int p = antennas[k].power;\n                if (antennas[k].x - p <= x_start && antennas[k].x + p >= x_end &&\n                    antennas[k].y - p <= y_start && antennas[k].y + p >= y_end) {\n                    covered = 1;\n                }\n            }\n\n            if (covered) {\n                total_area += (x_end - x_start) * (y_end - y_start);\n            }\n        }\n    }\n\n    printf(\"%d\\n\", total_area);\n\n    free(antennas);\n    free(events);\n    free(unique_vals);\n    return 0;\n}",
    "timestamp": "2025-08-13 03:03:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_coverage_area(antennas):\n    # Find the bounding box of all antennas\n    min_x = min(x - power for x, power in antennas)\n    max_x = max(x + power for x, power in antennas)\n    min_y = min(y - power for y, power in antennas)\n    max_y = max(y + power for y, power in antennas)\n    \n    # Create a grid to track coverage\n    grid = [[0] * (max_x - min_x + 1) for _ in range(max_y - min_y + 1)]\n    \n    # Mark covered areas\n    for x, y, power in antennas:\n        for dx in range(-power, power + 1):\n            for dy in range(-power, power + 1):\n                nx, ny = x + dx - min_x, y + dy - min_y\n                if max(abs(dx), abs(dy)) <= power:\n                    grid[ny][nx] = 1\n    \n    # Count total covered area\n    return sum(sum(row) for row in grid)\n\n# Input processing\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        antennas = []\n        for _ in range(N):\n            x, y, power = map(int, input().split())\n            antennas.append((x, y, power))\n        \n        print(calculate_coverage_area(antennas))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:03:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_covered_area(antennas):\n    covered = set()\n    for x, y, power in antennas:\n        for dx in range(-power, power + 1):\n            for dy in range(-power, power + 1):\n                covered.add((x + dx, y + dy))\n    return len(covered)\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    T = int(input[idx])\n    idx += 1\n    for _ in range(T):\n        N = int(input[idx])\n        idx += 1\n        antennas = []\n        for _ in range(N):\n            x = int(input[idx])\n            y = int(input[idx + 1])\n            power = int(input[idx + 2])\n            antennas.append((x, y, power))\n            idx += 3\n        print(calculate_covered_area(antennas))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:04:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Event {\n    int x;\n    int y1, y2;\n    bool start; // true for starting edge, false for ending edge\n    Event(int x, int y1, int y2, bool start) : x(x), y1(y1), y2(y2), start(start) {}\n};\n\nbool compareEvents(const Event& a, const Event& b) {\n    if (a.x != b.x)\n        return a.x < b.x;\n    return a.start > b.start; // start events should come before end events at the same x\n}\n\nint calculateCoveredArea(vector<tuple<int, int, int>>& antennas) {\n    vector<Event> events;\n    for (const auto& [cx, cy, power] : antennas) {\n        int x1 = cx - power, x2 = cx + power;\n        int y1 = cy - power, y2 = cy + power;\n        events.emplace_back(x1, y1, y2, true);\n        events.emplace_back(x2, y1, y2, false);\n    }\n\n    sort(events.begin(), events.end(), compareEvents);\n\n    int lastX = 0, totalArea = 0;\n    multiset<pair<int, int>> active;\n    int currentY = 0;\n\n    for (const auto& event : events) {\n        int x = event.x;\n        \n        totalArea += currentY * (x - lastX);\n\n        if (event.start) {\n            active.emplace(event.y1, event.y2);\n        } else {\n            active.erase(active.find({event.y1, event.y2}));\n        }\n\n        currentY = 0;\n        int currentCoverage = 0, lastY = -1e9;\n        for (const auto& [y1, y2] : active) {\n            if (y1 > lastY) {\n                currentY += currentCoverage;\n                currentCoverage = 0;\n                lastY = y1;\n            }\n            currentCoverage += y2 - y1 + 1;\n        }\n        currentY += currentCoverage;\n\n        lastX = x;\n    } \n\n    return totalArea;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<tuple<int, int, int>> antennas;\n    while (n--) {\n        int x, y, power;\n        cin >> x >> y >> power;\n        antennas.emplace_back(x, y, power);\n    }\n\n    cout << calculateCoveredArea(antennas) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:09:40"
  }
]