[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Area {\n\tArea(double x, double y, double s){\n\t\tx1 = x - s; y1 = y - s;\n\t\tx2 = x + s; y2 = y + s;\n\t}\n\tdouble x1, y1, x2, y2;\n};\n\nint main(){\n\tfor(int dataset = 1; true; ++dataset){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<Area> areas;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tdouble x, y, s;\n\t\t\tcin >> x >> y >> s;\n\t\t\tareas.push_back(Area(x, y, s));\n\t\t}\n\t\tset<double> xpos;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\txpos.insert(areas[i].x1);\n\t\t\txpos.insert(areas[i].x2);\n\t\t}\n\t\tdouble answer = 0.0, height = 0.0, curx = *(xpos.begin());\n\t\tfor(set<double>::iterator it = xpos.begin(); it != xpos.end(); ++it){\n\t\t\tanswer += height * (*it - curx);\n\t\t\tcurx = *it;\n\t\t\tvector< pair<double, int> > ypos;\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tif(areas[i].x1 <= *it && *it < areas[i].x2){\n\t\t\t\t\typos.push_back(make_pair(areas[i].y1, 1));\n\t\t\t\t\typos.push_back(make_pair(areas[i].y2, -1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(ypos.begin(), ypos.end());\n\t\t\tint depth = 0;\n\t\t\tdouble nextheight = 0.0, prevy = 0.0;\n\t\t\tfor(int i = 0; i < ypos.size(); ++i){\n\t\t\t\tpair<double, int> entry = ypos[i];\n\t\t\t\tif(depth == 0 && entry.second > 0){\n\t\t\t\t\tprevy = entry.first;\n\t\t\t\t}else if(depth == 1 && entry.second < 0){\n\t\t\t\t\tnextheight += (entry.first - prevy);\n\t\t\t\t\tprevy = entry.first;\n\t\t\t\t}\n\t\t\t\tdepth += entry.second;\n\t\t\t}\n\t\t\theight = nextheight;\n\t\t}\n\t\tprintf(\"%d %.2lf\\n\", dataset, answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\nint n; double X1[100], X2[100], Y1[100], Y2[100];\nint x[200][200]; vector<pair<double, int>>X, Y;\npair<int, int>X3[200], Y3[200];\nint main() {\n\tint cnt = 0;\n\twhile (true) {\n\t\tcin >> n; cnt++; X.clear(); Y.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < 40000; i++) { x[i / 200][i % 200] = 0; X3[i / 200] = make_pair(-1, -1); Y3[i / 200] = make_pair(-1, -1); }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble L1, L2, L3; cin >> L1 >> L2 >> L3;\n\t\t\tX1[i] = L1 - L3, X2[i] = L1 + L3; Y1[i] = L2 - L3, Y2[i] = L2 + L3;\n\t\t\tX.push_back(make_pair(X1[i], i)); X.push_back(make_pair(X2[i], i));\n\t\t\tY.push_back(make_pair(Y1[i], i)); Y.push_back(make_pair(Y2[i], i));\n\t\t}\n\t\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end());\n\t\tfor (int i = 0; i < 2 * n; i++) {\n\t\t\tint H = X[i].second; if (X3[H].first == -1) { X3[H].first = i; } else { X3[H].second = i; }\n\t\t\tint I = Y[i].second; if (Y3[I].first == -1) { Y3[I].first = i; } else { Y3[I].second = i; }\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = X3[i].first; j < X3[i].second; j++) {\n\t\t\t\tfor (int k = Y3[i].first; k < Y3[i].second; k++)x[j][k] = 1;\n\t\t\t}\n\t\t}\n\t\tdouble cnt2 = 0.0;\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tfor (int j = 0; j < 2 * n - 1; j++) {\n\t\t\t\tif (x[i][j] == 0)continue;\n\t\t\t\tcnt2 += (X[i + 1].first - X[i].first)*(Y[j + 1].first - Y[j].first);\n\t\t\t}\n\t\t}\n\t\tcout << cnt << ' ' << fixed << setprecision(2) << cnt2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nusing D = double;\n\nconstexpr D EPS = 1e-8;\n\nint main(){\n  int n, testcase = 0;\n  while(cin >> n, n){\n    ++testcase;\n    vector<D> X, Y;\n    vector<D> X_, Y_, R_;\n    for(int i = 0; i < n; ++i){\n      D x, y, r;\n      cin >> x >> y >> r;\n      X_.push_back(x);\n      Y_.push_back(y);\n      R_.push_back(r);\n      X.push_back(x-r);\n      X.push_back(x+r);\n      Y.push_back(y-r);\n      Y.push_back(y+r);\n    }\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n    vector<vector<int>> A(2*n+1,vector<int>(2*n+1,0));\n    for(int i = 0; i < n; ++i){\n      D x = X_[i], y = Y_[i], rr = R_[i];\n      int l = -1, r = -1, t = -1, b = -1;\n      for(int j = 0; j < 2*n; ++j){\n        if(abs(x-rr-X[j]) < EPS) l = j;\n        if(abs(x+rr-X[j]) < EPS) r = j;\n      }\n      for(int j = 0; j < 2*n; ++j){\n        if(abs(y-rr-Y[j]) < EPS) t = j;\n        if(abs(y+rr-Y[j]) < EPS) b = j;\n      }\n      ++A[l][t];\n      --A[l][b];\n      --A[r][t];\n      ++A[r][b];\n    }\n    for(int i = 0; i < 2*n; ++i){\n      for(int j = 0; j < 2*n; ++j){\n        A[i][j+1] += A[i][j];\n      }\n    }\n    for(int i = 0; i < 2*n; ++i){\n      for(int j = 0; j < 2*n; ++j){\n        A[i+1][j] += A[i][j];\n      }\n    }\n    D ans = 0;\n    for(int i = 0; i < 2*n; ++i){\n      for(int j = 0; j < 2*n; ++j){\n        if(A[i][j] <= 0) continue;\n        ans += (X[i+1]-X[i])*(Y[j+1]-Y[j]);\n      }\n    }\n    printf(\"%d %.2f\\n\",testcase,ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define N 2002\n\nusing namespace std;\n\nclass Point{\npublic:\n  int x;\n  int y;\n  int r;\n};\n\nbool data[N][N];\nvoid syokika();\nint mx=N-1, my=N-1;\nmain(){\n  int n;\n  Point in[100];\n  for(int count=1;;count++){\n    cin >> n;\n    if(n==0) break;\n    double x, y, r;\n    my=-1;\n    mx=-1;\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> r;\n      x*=10;\n      y*=10;\n      r*=10;\n      int ix, iy, ir;\n      in[i].x=(int)x;\n      in[i].y=(int)y;\n      in[i].r=(int)r;\n      if(my<(in[i].y+in[i].r)) my=in[i].y+in[i].r;\n      if(mx<(in[i].x+in[i].r)) mx=in[i].x+in[i].r;\n    }\n    if(mx>=N) mx=N-1;\n    if(my>=N) my=N-1;\n    syokika();\n    for(int i=0;i<n;i++){\n      for(int a=in[i].y-in[i].r;a<=in[i].y+in[i].r;a++){\n\tif(a<0) continue;\n\tfor(int b=in[i].x-in[i].r;b<=in[i].x+in[i].r;b++){\n\t  if(b<0) continue;\n\t  data[a][b]=true;\n\t}\n      }\n    }\n    int sum=0;\n    for(int i=0;i<my;i++){\n      for(int j=0;j<mx;j++){\n\tif(data[i][j]) sum++;\n      }\n    }\n    //    printf(\"!%d\\n\", sum);\n    double ans=sum/100;\n    printf(\"%d %.2f\\n\", count, ans);\n  }\n  return 0;\n}\n\nvoid syokika(){\n  for(int i=0;i<=my;i++){\n    for(int j=0;j<=mx;j++){\n      data[i][j]=false;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nvector<double> xv,yv,rv;\nconst double eps = 1e-9;\n\nint main() {\n    int n,tc = 1;\n    double x,y,r;\n    while(cin>>n, n) {\n        xv.clear(); yv.clear(); rv.clear();\n        priority_queue<double, vector<double>, greater<double> > q;\n        for(int i=0; i<n; ++i) {\n            cin>>x>>y>>r;\n            xv.push_back(x); yv.push_back(y); rv.push_back(r);\n            q.push(x-r-eps); q.push(x+r-eps);\n        }\n\n        x = q.top(); q.pop();\n        double ans = 0;\n        while(!q.empty()) {\n            double nx = q.top(); q.pop();\n            double ll = -(1<<29);\n\n            vector<pair<double,double> > rrv;\n            for(int i=0; i<n; ++i)\n                if(fabs(nx - xv[i]) < rv[i])\n                    rrv.push_back(make_pair(yv[i]-rv[i],yv[i]+rv[i]));\n\n            sort(rrv.begin(), rrv.end());\n            double len = 0;\n            for(int i=0; i<rrv.size(); ++i) {\n                //cout<<i<<\" : \"<<rrv[i].first<<\",\"<<rrv[i].second<<endl;\n                len += max(0.0, rrv[i].second-max(ll,rrv[i].first));\n                ll = max(ll, rrv[i].second);\n            }\n\n            ans += (nx-x) * len;\n            //cout<<\"add \"<<len<<\"*(\"<<nx<<\"-\"<<x<<\")\"<<endl;\n            x = nx;\n        }\n\n        printf(\"%d %.2f\\n\", tc++, ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\nRect recs[101];\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n};\nEvent evs[1001];\n\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  vector<int> ls;\n  vector<int> rs;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int par=find(x);\n    ls[par]=l;\n    rs[par]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    int NN=0;\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      if(EQ(r,0))continue;\n      recs[NN].first=P(x-r,y-r);\n      recs[NN].second=P(x+r,y+r);\n      evs[2*NN]=Event(y-r,true,i);\n      evs[2*NN+1]=Event(y+r,false,i);\n      NN++;\n    }\n    sort(evs,evs+2*NN);\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    // yÌ¬³¢ÔÉCxgð\n    for(int i=0;i<2*NN;i++){\n      Event &e=evs[i];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      prvy=e.y;\n      // _ðÇÁ\n      if(e.isIn){\n\t// »Ìã,¡ñÌ_ðÜßé\n\tv.push_back(e.id);\n      }\n      else{\n\t//if(find(v.begin(),v.end(),e.id)!=v.end())\n\t  v.erase(find(v.begin(),v.end(),e.id));\n      }\n      // ¡ñÌ¡ðvZ\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  // ÍÍª©Ôéæ¤ÈçÎAunite\n\t  if((EQ(uft.rs[i],uft.ls[j])\n\t      ||(uft.rs[i]>uft.ls[j]))\n\t     &&(EQ(uft.ls[i],uft.rs[j])\n\t\t||(uft.ls[i]<uft.rs[j]))){\n\t    double minx=min(uft.ls[i],uft.ls[j]);\n\t    double maxx=max(uft.rs[i],uft.rs[j]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    res=(int)(res+0.005+EPS);\n    printf(\"%d %.2f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n};\nEvent evs[1001];\nRect recs[1001];\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  vector<int> ls,rs;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int par=find(x);\n    ls[par]=l;\n    rs[par]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    int NN=0;\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      recs[NN].first=P(x-r,y-r);\n      recs[NN].second=P(x+r,y+r);\n      if(EQ(r,0))continue;\n      evs[2*NN]=Event(y-r,true,i);\n      evs[2*NN+1]=Event(y+r,false,i);\n      NN++;\n    }\n    sort(evs,evs+2*NN);\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    // yÌ¬³¢ÔÉCxgð\n    for(int i=0;i<2*NN;i++){\n      Event &e=evs[i];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      prvy=e.y;\n      // _ÌÇÁAí\n      if(e.isIn)v.push_back(e.id);\n      else v.erase(find(v.begin(),v.end(),e.id));\n      // ¡ñÌ¡ðvZ\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  // ÍÍª©Ôéæ¤ÈçÎAunite\n\t  if((EQ(uft.rs[uft.find(i)]\n\t\t ,uft.ls[uft.find(j)])\n\t      ||(uft.rs[uft.find(i)]\n\t\t >uft.ls[uft.find(j)]))\n\t     &&(EQ(uft.ls[uft.find(i)]\n\t\t   ,uft.rs[uft.find(j)])\n\t\t||(uft.ls[uft.find(i)]\n\t\t   <uft.rs[uft.find(j)]))){\n\t    double minx=min(uft.ls[uft.find(i)]\n\t\t\t    ,uft.ls[uft.find(j)]);\n\t    double maxx=max(uft.rs[uft.find(i)]\n\t\t\t    ,uft.rs[uft.find(j)]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    printf(\"%d %.2f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n  Point p1, p2;\n};\n\ntypedef Segment Line;\ntypedef Segment Rect;\n\nclass Region {\npublic:\n  Point p;\n  double r;\n  bool operator < (const Region &re) const {\n    return r != re.r ? r < re.r : p < re.p;\n  }\n};\n\nint n;\nRegion re[100];\n\nbool isOn(Rect a, Rect b) {\n  if(a.p1.x >= b.p2.x) return false;\n  if(a.p1.y >= b.p2.y) return false;\n  if(a.p2.x <= b.p1.x) return false;\n  if(a.p2.y <= b.p1.y) return false;\n  return true;\n}\n\ndouble solve() {\n  vector<Rect> v;\n  vector<Rect>::iterator it;\n  Rect rt;\n  sort(re, re+n);\n  for(int i = 0; i < n; ++i) {\n    rt.p1 = Point(re[i].p.x - re[i].r, re[i].p.y - re[i].r);\n    rt.p2 = Point(re[i].p.x + re[i].r, re[i].p.y + re[i].r);\n\n    it = v.begin();\n    vector<Rect> tmpV;\n    while(it != v.end()) {\n      if(it->p1.x >= rt.p1.x && it->p1.x <=rt.p2.x &&\n\t it->p1.y >= rt.p1.y && it->p1.y <=rt.p2.y ) {\n\tit = v.erase(it);\n      } else {\n\tif(isOn(rt, *it)) {\n\t  if(it->p1.x >= rt.p1.x && it->p2.x <= rt.p2.x) {\n\t    if(it->p1.y < rt.p1.y) {\n\t      it->p2.y = rt.p1.y;\n\t    } else {\n\t      it->p1.y = rt.p2.y;\n\t    }\n\t  }\n\t  else if(it->p1.y >= rt.p1.y && it->p2.y <= rt.p2.y) {\n\t    if(it->p1.x < rt.p1.x) {\n\t      it->p2.x = rt.p1.x;\n\t    } else {\n\t      it->p1.x = rt.p2.x;\n\t    }\n\t  }\n\t  else {\n\t    Rect tmp = *it;\n\t    if(it->p1.y < rt.p1.y) {\n\t      it->p2.y = rt.p1.y;\n\t      tmp.p1.y = rt.p1.y;\n\t    } else {\n\t      it->p1.y = rt.p2.y;\n\t      tmp.p2.y = rt.p2.y;\n\t    }\n\n\t    if(tmp.p1.x < rt.p1.x) {\n\t      tmp.p2.x = rt.p1.x;\n\t    } else {\n\t      tmp.p1.x = rt.p2.x;\n\t    }\n\t    tmpV.push_back(tmp);\n\t  }\n\t}\n\t++it;\n      }\n    }\n    v.push_back(rt);\n    for(int j = 0; j < tmpV.size(); ++j) {\n      v.push_back(tmpV[j]);\n    }\n  }\n\n  double ans = 0;\n  for(int i = 0; i < v.size(); ++i) {\n    ans += (v[i].p2.x-v[i].p1.x)*(v[i].p2.y-v[i].p1.y);\n  }\n  return ans;\n}\n\nmain() {\n  int t = 1;\n  while((cin >> n) && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> re[i].p.x >> re[i].p.y >> re[i].r;\n    }\n    printf(\"%d %.2f\\n\", t, solve());\n    ++t;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint n,X1[100],X2[100],Y1[100],Y2[100];\nint nx,ny;\ndouble xv[200],yv[200];\nbool v[200][200];\n\nint main()\n{\n\tint cs=1;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tdouble x[200],y[200],r[200];\n\t\trep(i,n)\n\t\t{\n\t\t\tscanf(\"%lf%lf%lf\",x+i,y+i,r+i);\n\t\t\txv[i*2]=x[i]-r[i]; xv[i*2+1]=x[i]+r[i];\n\t\t\tyv[i*2]=y[i]-r[i]; yv[i*2+1]=y[i]+r[i];\n\t\t}\n\t\trep(i,2*n)x[i]=xv[i],y[i]=yv[i];\n\t\tsort(xv,xv+2*n); sort(yv,yv+2*n);\n\t\tnx=unique(xv,xv+2*n)-xv; ny=unique(yv,yv+2*n)-yv;\n\t\trep(i,n)\n\t\t{\n\t\t\tX1[i]=lower_bound(xv,xv+nx,x[i*2])-xv;\n\t\t\tX2[i]=lower_bound(xv,xv+nx,x[i*2+1])-xv;\n\t\t\tY1[i]=lower_bound(yv,yv+ny,y[i*2])-yv;\n\t\t\tY2[i]=lower_bound(yv,yv+ny,y[i*2+1])-yv;\n\t\t}\n\t\t\n\t\tdouble ans=0;\n\t\trep(i,ny)rep(j,nx)v[i][j]=0;\n\t\trep(i,n)\n\t\t{\n\t\t\tfor(int y=Y1[i];y<Y2[i];y++)for(int x=X1[i];x<X2[i];x++)\n\t\t\tif(!v[y][x])\n\t\t\t{\n\t\t\t\tans+=(yv[y+1]-yv[y])*(xv[x+1]-xv[x]);\n\t\t\t\tv[y][x]=1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %.2f\\n\",cs++,ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\nint N;\n#define MN 101\nvector<double> X, Y, R;\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    X.resize(N); Y.resize(N); R.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i] >> R[i];\n    }\n    return true;\n}\n\ntemplate<typename A, typename B>\nostream& operator<<(ostream& os, map<A, B> m) {\n    for (typename map<A, B>::iterator it = m.begin(); it != m.end(); it++) {\n        os << \"(\" << it->first << \", \" << it->second << \"), \";\n    }\n    return os;\n}\n\nmap<double, int> Compress(vector<double>& vs) {\n    sort(whole(vs));\n    vs.erase(unique(whole(vs)), vs.end());\n    map<double, int> Ret;\n    for (int i = 0; i < vs.size(); i++) {\n        Ret[ vs[i] ] = i + 1;\n    }\n    return Ret;\n}\n\nvoid solve() {\n    static int T = 1;\n    vector<double> dX, dY;\n    for (int i = 0; i < N; i++) {\n        dX.push_back(X[i] - R[i]);\n        dX.push_back(X[i] + R[i]);\n        dY.push_back(Y[i] - R[i]);\n        dY.push_back(Y[i] + R[i]);\n    }\n    map<double, int> mX = Compress(dX),\n                     mY = Compress(dY);\n    //cout << \"mX: \" << mX << endl;\n    int nX = dX.size() + 1, nY = dY.size() + 1;\n    bool F[nY][nX]; memset(F, 0, sizeof(F));\n    for (int i = 0; i < N; i++) {\n        int sx = mX[ X[i] - R[i] ],\n            sy = mY[ Y[i] - R[i] ],\n            gx = mX[ X[i] + R[i] ],\n            gy = mY[ Y[i] + R[i] ];\n        //cout << sx << \" \" << gx << \" \" << sy << \" \" << gy << endl;\n        for (int y = sy; y < gy; y++) {\n            for (int x = sx; x < gx; x++) {\n                F[y][x] = true;\n            }\n        }\n    }\n    /*\n    for (int i = 0; i < nY; i++) {\n        for (int j = 0; j < nX; j++) {\n            cout << setw(2) << F[i][j];\n        }\n        cout << endl;\n    }\n    */\n    double Area = 0;\n    for (int y = 0; y < nY - 1; y++) {\n        for (int x = 0; x < nX - 1; x++) {\n            if (F[y][x]) {\n                Area += (dY[y] - dY[y - 1]) * (dX[x] - dX[x - 1]);\n            }\n        }\n    }\n    printf(\"%d %.2f\\n\", T, Area);\n    T++;\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<map>\n#include<complex>\n\n#define START 0\n#define END 1\nusing namespace std;\n\ntypedef complex<double> point;\n\nconst double infty = 1e40;\nconst double eps = 1e-10;\n\nbool eq(double a, double b){\n  return abs(b-a) < eps;\n}\n\nstruct anntena{\n  point ul, rd;\n  anntena(point a, point b):ul(a),rd(b){}\n  bool isinside(const point &t){\n    if( ul.real()<=t.real()&&t.real()<=rd.real()&&\n\tul.imag()>=t.imag()&&t.imag()>=rd.imag())return true;\n    return false;\n  }\n};\n\nint main()\n{\n  int n;\n  int tc=1;\n  while(cin>>n && n>0){\n    double res = 0;\n    set<double> X;\n    set<double> Y;\n    vector<anntena> va;\n\n    for(int i = 0; i < n; ++i){\n      double x,y,r;\n      scanf(\"%lf%lf%lf\", &x, &y, &r);\n      //cin >> x >> y >> r;\n      X.insert(x-r);\n      X.insert(x+r);\n      Y.insert(y-r);\n      Y.insert(y+r);\n      va.push_back( anntena(point(x-r,y+r), point(x+r,y-r) ) );\n    }\n    for(set<double>::iterator itx = X.begin(); itx != X.end(); ++itx){\n\n      double x = *itx;\n      ++itx;\n      if(itx==X.end())break;\n      double nx = *itx;\n      --itx;\n      double span_x = nx - x;\n      for(set<double>::iterator ity = Y.begin(); ity != Y.end(); ++ity){\n\tdouble y = *ity;\n\t++ity;\n\tif(ity==Y.end())break;\n\tdouble ny = *ity;\n\t--ity;\n\tdouble span_y = ny - y;\n\t/*\n\tpoint lu = point(x,ny);\n\tpoint ru = point(nx,ny);\n\tpoint ld = point(x,y);\n\tpoint rd = point(nx,y);\n\t*/\n\tpoint cent = point((x+nx)/2,(y+ny)/2);\n\t//bool lu_cont = false;\n\t//bool rd_cont = false;\n\tbool cent_cont = false;\n\tfor(int i = 0; i < (int)va.size(); ++i){\n\t  if( va[i].isinside( cent ) ) cent_cont = true;\n\t  //if( va[i].isinside( rd ) ) rd_cont = true;\n\t}\n\tif( cent_cont ){//&& rd_cont ){\n\t  res += span_x * span_y;\n\t}\n      } \n    }\n    printf(\"%d %.2lf\\n\", tc, res);\n    ++tc;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <utility>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  int cnt = 1;\n  while(1){\n    int n;\n    cin >> n;\n    if(!n)break;\n    vector<double> sx(n);\n    vector<double> sy(n);\n    vector<double> tx(n);\n    vector<double> ty(n);\n    vector<double> xa;\n    vector<double> ya;\n    REP(i,n) {\n      double x,y,r;\n      cin >> x >> y >> r;\n      sx[i] = x - r;\n      sy[i] = y - r;\n      tx[i] = x + r;\n      ty[i] = y + r;\n      xa.push_back(sx[i]);\n      xa.push_back(tx[i]);\n      ya.push_back(sy[i]);\n      ya.push_back(ty[i]);\n    }\n    xa.push_back(0.0);\n    ya.push_back(0.0);\n    sort(begin(xa),end(xa));\n    sort(begin(ya),end(ya));\n    auto xei = unique(begin(xa),end(xa));\n    auto yei = unique(begin(ya),end(ya));\n    xa.resize(xei-begin(xa));\n    ya.resize(yei-begin(ya));\n    vector<vector<int>> tb(ya.size(), vector<int>(xa.size()));\n    REP(i,n){\n      int begx = lower_bound(begin(xa),end(xa),sx[i]) - begin(xa);\n      int begy = lower_bound(begin(ya),end(ya),sy[i]) - begin(ya);\n      int edx = lower_bound(begin(xa),end(xa),tx[i]) - begin(xa);\n      int edy = lower_bound(begin(ya),end(ya),ty[i]) - begin(ya);\n      for (int j = begy; j < edy; ++j) {\n        for (int k = begx; k < edx; ++k) {\n          tb[j][k] = 1;\n        }\n      }\n    }\n    double area = 0.0;\n    REP(i,ya.size() - 1){\n      REP(j,xa.size() - 1){\n        if(tb[i][j] == 1){\n          area += (ya[i+1] - ya[i])*(xa[j+1] - xa[j]);\n        }\n      }\n    }\n    printf(\"%d %.2lf\\n\", cnt, area);\n    ++cnt;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Point{\npublic:\n  double Lx,Rx,Uy,Dy;\n  int j;\n};\n\nint main(){\n  int i,j,k,n,c,cc=0;\n  double x,y,r,ans;\n  Point p[100],q[10000];\n  while(1){\n    cc++;\n    cin >> n;\n    if(n == 0) break;\n\n    ans = 0;\n    c = 0;\n    for(i=0;i<n;i++){\n      cin >> x >> y >> r;\n      p[i].Uy = y + r;\n      p[i].Dy = y - r;\n      p[i].Lx = x - r;\n      p[i].Rx = x + r;\n      ans += pow(2*r,2);\n    }\n\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n\tif((p[i].Lx <= p[j].Lx && p[j].Lx <= p[i].Rx || p[i].Lx <= p[j].Rx && p[j].Rx <= p[i].Rx) && (p[i].Dy <= p[j].Dy && p[j].Dy <= p[i].Uy || p[i].Dy <= p[j].Uy && p[j].Uy <= p[i].Uy)){\n\t  double lx,rx,uy,dy;\n\t  lx = max(p[i].Lx,p[j].Lx);\n\t  rx = min(p[i].Rx,p[j].Rx);\n\t  dy = max(p[i].Dy,p[j].Dy);\n\t  uy = min(p[i].Uy,p[j].Uy);\n\n\t  for(k=0;k<c;k++){\n\t    if(q[k].Uy == uy && q[k].Dy == dy && q[k].Lx == lx && q[k].Rx == rx && q[k].j == j) break;\n\t  }\n\t  \n\t  if(k == c) ans -= (rx - lx) * (uy - dy);\n\n\t  q[c].Uy = uy;\n\t  q[c].Dy = dy;\n\t  q[c].Lx = lx;\n\t  q[c].Rx = rx;\n\t  q[c].j = j;\n\t  c++;\n\t}\n      }\n    }\n    \n    printf(\"%d %.2f\\n\",cc,ans);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint W,H;\ndouble X1[222],Y1[222],X2[222],Y2[222];\nint sx1[222],sy1[222];\nint sx2[222],sy2[222];\nbool F[555][555];\ndouble dx[555],dy[555];\n\nint zip( double *Z1, double *Z2, int *z1, int *z2, double *d ){\n  vector<double> ps;\n  for(int i=0;i<N;i++){\n    ps.push_back( Z1[i] );\n    ps.push_back( Z2[i] );\n  }\n  sort( ps.begin(), ps.end() );\n  ps.erase( unique( ps.begin(), ps.end() ), ps.end() );\n  int w = ps.size();\n  for(int i=0;i<w;i++){\n    z1[i] = lower_bound( ps.begin(), ps.end(), X1[i] ) - ps.begin();\n    z2[i] = lower_bound( ps.begin(), ps.end(), X2[i] ) - ps.begin();\n  }\n  for(int i=0;i<w;i++){\n    d[i] = ps[i];\n  }\n  return w;\n}\n\nint main(){\n  int ttt=0;\n  while( ~scanf(\"%d\",&N) && N ){\n    memset( F,0,sizeof( F ) );\n    for(int i=0;i<N;i++){\n      double x,y,r; scanf(\"%lf%lf%lf\",&x,&y,&r);\n      X1[i] = x - r;\n      X2[i] = x + r;\n      Y1[i] = y - r;\n      Y2[i] = y + r;\n    }\n    W = zip( X1, X2, sx1, sx2, dx );\n    H = zip( Y1, Y2, sy1, sy2, dy );\n    for(int i=0;i<N;i++){\n      //cout << sx1[i] << \" - \" <<sx2[i] << endl;\n      //cout << sy1[i] << \" - \" <<sy2[i] << endl;\n      for(int x=sx1[i];x<sx2[i];x++){\n        for(int y=sy1[i];y<sy2[i];y++){\n          F[x][y] = true;\n        }\n      }\n    }\n    double res = 0.0;\n    for(int x=0;x<W;x++){\n      for(int y=0;y<H;y++){\n        if( F[x][y] ) {\n          //cout << dx[x+1]-dx[x] << \" * \" << dy[y+1]-dy[y] << endl;\n          res += ( dx[x+1]-dx[x] ) * ( dy[y+1]-dy[y] );      \n\n        }\n      }\n    }\n    printf(\"%d %.2lf\\n\",++ttt,res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<double,int>P;\ntypedef pair<double,double>Pi;\ntypedef pair<Pi,int>PP;\nint main(){\n  int n,T=0;\n  while(cin>>n,n){\n    cout<<++T<<\" \";\n  double a[101],b[101],c[101];\n  vector<P> v;\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      v.push_back(P(b[i]-c[i],i));\n      v.push_back(P(b[i]+c[i],i));\n    }\n    sort(v.begin(),v.end());\n    double h=-1e9,w=0;\n    double ans=0;\n    vector<PP> s;\n    for(int i=0;i<v.size();i++){\n      bool f=1;\n      for(int j=0;j<s.size();j++){\n\tif(s[j].second==v[i].second)s.erase(s.begin()+j),f=0;\n      }\n\n      if(f)s.push_back(PP(Pi(a[v[i].second]-c[v[i].second],a[v[i].second]+c[v[i].second]),v[i].second));\n\n      if(h!=v[i].first)ans+=(v[i].first-h)*w,h=v[i].first;\n      sort(s.begin(),s.end());\n\n      w=s[0].first.second-s[0].first.first;\n      double pr=s[0].first.second;\n\n      for(int j=0;j<s.size();j++){\n\tif(s[j].first.first<pr)w+=max(0.0,s[j].first.second-pr);\n\telse w+=s[j].first.second-s[j].first.first;\n\tpr=max(s[j].first.second,pr);\n\n\n      }\n    }\n    printf(\"%.2f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n  Point p1, p2;\n};\n\ntypedef Segment Line;\ntypedef Segment Rect;\n\nclass Region {\npublic:\n  Point p;\n  double r;\n  bool operator < (const Region &re) const {\n    return r != re.r ? r < re.r : p < re.p;\n  }\n};\n\nint n;\nRegion re[100];\n\nbool isOn(Rect a, Rect b) {\n  if(a.p1.x > b.p2.x) return false;\n  if(a.p1.y > b.p2.y) return false;\n  if(a.p2.x < b.p1.x) return false;\n  if(a.p2.y < b.p1.y) return false;\n  return true;\n}\n\ndouble solve() {\n  vector<Rect> v;\n  vector<Rect>::iterator it;\n  Rect rt;\n  sort(re, re+n);\n  for(int i = 0; i < n; ++i) {\n    rt.p1 = Point(re[i].p.x - re[i].r, re[i].p.y - re[i].r);\n    rt.p2 = Point(re[i].p.x + re[i].r, re[i].p.y + re[i].r);\n\n    it = v.begin();\n    vector<Rect> tmpV;\n    while(it != v.end()) {\n      if(it->p1.x >= rt.p1.x && it->p1.x <=rt.p2.x &&\n\t it->p1.y >= rt.p1.y && it->p1.y <=rt.p2.y ) {\n\tit = v.erase(it);\n      } else {\n\tif(isOn(rt, *it)) {\n\t  if(it->p1.x >= rt.p1.x && it->p2.x <= rt.p2.x) {\n\t    if(it->p1.y < rt.p1.y) {\n\t      it->p2.y = rt.p1.y;\n\t    } else {\n\t      it->p1.y = rt.p2.y;\n\t    }\n\t  }\n\t  else if(it->p1.y >= rt.p1.y && it->p2.y <= rt.p2.y) {\n\t    if(it->p1.x < rt.p1.x) {\n\t      it->p2.x = rt.p1.x;\n\t    } else {\n\t      it->p1.x = rt.p2.x;\n\t    }\n\t  }\n\t  else {\n\t    Rect tmp = *it;\n\t    if(it->p1.y < rt.p1.y) {\n\t      it->p2.y = rt.p1.y;\n\t      tmp.p1.y = rt.p1.y;\n\t    } else {\n\t      it->p1.y = rt.p2.y;\n\t      tmp.p2.y = rt.p2.y;\n\t    }\n\n\t    if(tmp.p1.x < rt.p1.x) {\n\t      tmp.p2.x = rt.p1.x;\n\t    } else {\n\t      tmp.p1.x = rt.p2.x;\n\t    }\n\t    tmpV.push_back(tmp);\n\t  }\n\t}\n\t++it;\n      }\n    }\n    v.push_back(rt);\n    for(int j = 0; j < tmpV.size(); ++j) {\n      v.push_back(tmpV[j]);\n    }\n  }\n\n  double ans = 0;\n  for(int i = 0; i < v.size(); ++i) {\n    ans += (v[i].p2.x-v[i].p1.x)*(v[i].p2.y-v[i].p1.y);\n  }\n  return ans;\n}\n\nmain() {\n  int t = 1;\n  while((cin >> n) && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> re[i].p.x >> re[i].p.y >> re[i].r;\n    }\n    printf(\"%d %.2f\\n\", t, solve());\n    ++t;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nstruct Box { double x, y, r; };\n\nconst double EPS = 1e-9;\n\nvoid solve(int n) {\n\tvector< double > h, w;\n\tvector< Box > vb;\n\t\n\tfor_(i,0,n) {\n\t\tdouble x, y, r;\n\t\tcin >> x >> y >> r;\n\t\tvb.push_back(Box{x, y, r});\n\t\th.push_back(y - r);\n\t\th.push_back(y + r);\n\t\tw.push_back(x - r);\n\t\tw.push_back(x + r);\n\t}\n\t\n\tsort(h.begin(), h.end());\n\tsort(w.begin(), w.end());\n\t\n\th.erase(unique(h.begin(), h.end()), h.end());\n\tw.erase(unique(w.begin(), w.end()), w.end());\n\t\n\tint H = h.size(), W = w.size();\n\tdouble ans = 0;\n\t\n\tfor_(i,0,H-1) for_(j,0,W-1) {\n\t\tdouble lx = w[j], rx = w[j + 1];\n\t\tdouble ly = h[i], ry = h[i + 1];\n\t\t\n\t\tfor_(k,0,n) {\n\t\t\tBox b = vb[k];\n\t\t\t\n\t\t\tif (b.x - b.r < lx + EPS &&\n\t\t\t\tb.y - b.r < ly + EPS &&\n\t\t\t\tb.x + b.r > rx - EPS &&\n\t\t\t\tb.y + b.r > ry - EPS) {\n\t\t\t\tans += (rx - lx) * (ry - ly);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << setprecision(2) << setiosflags(ios::fixed) << ans << endl;\n}\n\nint main() {\n\tint case_number = 0, n;\n\t\n\twhile (cin >> n, n) {\n\t\t++case_number;\n\t\tcout << case_number << \" \";\n\t\tsolve(n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\nvector<pair<pair<double, int> , Pd> > ls;\nbool use[300];\n\ndouble calc(vector<Pd> range){\n\tdouble res = 0.0;\n\tsort(range.begin(), range.end());\n\trep(i, (int)range.size() - 1){\n\t\tif(range[i+1].second > range[i].second){\n\t\t\tres += range[i+1].second - max(range[i+1].first, range[i].second);\n\t\t}else{\n\t\t\trange[i+1].second = range[i].second;\n\t\t}\n\t}\n\tif(!range.empty()){\n\t\tres += range[0].second - range[0].first;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, sz;\n\tint cnt = 1;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\trep(i, n){\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tls.push_back(make_pair(make_pair(y - r, i), Pd(x - r, x + r)));\n\t\t\tls.push_back(make_pair(make_pair(y + r, i), Pd(x - r, x + r)));\n\t\t}\n\t\tsort(ls.begin(), ls.end());\n\t\tmemset(use, false, sizeof(use));\n\t\tsz = ls.size();\n\t\tdouble pre = -1e4;\n\t\tdouble res = 0.0;\n\t\trep(i, sz){\n\t\t\tint id = ls[i].first.second;\n\t\t\tdouble cur = ls[i].first.first;\n\t\t\tvector<Pd> range;\n\t\t\trep(i, sz){\n\t\t\t\tif(use[i]) range.push_back(ls[i].second);\n\t\t\t}\n\t\t\tres += (cur - pre) * calc(range);\n\t\t\tpre = cur;\n\t\t\tuse[id] = !use[id];\t\t\t\n\t\t}\n\t\tcout << cnt++ << \" \" << fixed << setprecision(2) << (int)(res * 100 + 0.5) / 100.0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<map>\n#include<complex>\n\n#define START 0\n#define END 1\nusing namespace std;\n\ntypedef complex<double> point;\n\nconst double infty = 1e40;\nconst double eps = 1e-10;\n\nbool eq(double a, double b){\n  return abs(b-a) < eps;\n}\n\nstruct anntena{\n  point ul, rd;\n  anntena(point a, point b):ul(a),rd(b){}\n  bool isinside(const point &t){\n    if( ul.real()<=t.real()&&t.real()<=rd.real()&&\n\tul.imag()>=t.imag()&&t.imag()>=rd.imag())return true;\n    return false;\n  }\n};\n\nint main()\n{\n  int n;\n  int tc=1;\n  while(cin>>n && n>0){\n    double res = 0;\n    set<double> X;\n    set<double> Y;\n    vector<anntena> va;\n\n    for(int i = 0; i < n; ++i){\n      double x,y,r;\n      scanf(\"%lf%lf%lf\", &x, &y, &r);\n      //cin >> x >> y >> r;\n      X.insert(x-r);\n      X.insert(x+r);\n      Y.insert(y-r);\n      Y.insert(y+r);\n      va.push_back( anntena(point(x-r,y+r), point(x+r,y-r) ) );\n    }\n    for(set<double>::iterator itx = X.begin(); itx != X.end(); ++itx){\n\n      double x = *itx;\n      ++itx;\n      if(itx==X.end())break;\n      double nx = *itx;\n      --itx;\n      double span_x = nx - x;\n      for(set<double>::iterator ity = Y.begin(); ity != Y.end(); ++ity){\n\tdouble y = *ity;\n\t++ity;\n\tif(ity==Y.end())break;\n\tdouble ny = *ity;\n\t--ity;\n\tdouble span_y = ny - y;\n\tpoint ul = point(x,ny);\n\tpoint rd = point(nx,y);\n\tbool ul_cont = false;\n\tbool rd_cont = false;\n\tfor(int i = 0; i < (int)va.size(); ++i){\n\t  if( va[i].isinside( ul ) ) ul_cont = true;\n\t  if( va[i].isinside( rd ) ) rd_cont = true;\n\t}\n\tif( ul_cont && rd_cont ){\n\t  res += span_x * span_y;\n\t}\n      } \n    }\n    printf(\"%d %.2lf\\n\", tc, res);\n    ++tc;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Point {\n\tdouble x;\n\tdouble y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() :x(0), y(0) {}\n};\n\nstruct Rectangle {\n\tPoint topLeft;\n\tPoint bottomRight;\n\tRectangle(Point topLeft, Point bottomRight) :topLeft(topLeft), bottomRight(bottomRight) {}\n\tRectangle(){}\n};\n\nint compress(vector<double> &x, unordered_map<double, int>& zip, vector<double>& unzip) {\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tunzip.resize(x.size());\n\tfor (size_t i = 0; i < x.size(); i++)\n\t{\n\t\tzip[x[i]] = i;\n\t\tunzip[i] = x[i];\n\t}\n\treturn zip.size();\n}\n\ndouble solve(const vector<Rectangle> rectangles) {\n\tvector<double> xs;\n\tunordered_map<double, int> xZip;\n\tvector<double> xUnzip;\n\tvector<double> ys;\n\tunordered_map<double, int> yZip;\n\tvector<double> yUnzip;\n\n\tfor (auto &r : rectangles) {\n\t\txs.push_back(r.topLeft.x);\n\t\txs.push_back(r.bottomRight.x);\n\t\tys.push_back(r.topLeft.y);\n\t\tys.push_back(r.bottomRight.y);\n\t}\n\tvector<vector<bool> > checker(ys.size(), vector<bool>(xs.size(), false));\n\tcompress(xs, xZip, xUnzip);\n\tcompress(ys, yZip, yUnzip);\n\n\tfor (auto &r : rectangles) {\n\t\tfor (int y = yZip[r.topLeft.y]; y < yZip[r.bottomRight.y]; ++y) {\n\t\t\tfor (int x = xZip[r.topLeft.x]; x < xZip[r.bottomRight.x]; ++x) {\n\t\t\t\tchecker[y][x] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble res = 0.0;\n\tfor (int y = 0; y < yUnzip.size()-1 ; ++y) for (int x = 0; x < xUnzip.size()-1; ++x) if (checker[y][x]) {\n\t\tres += (yUnzip[y + 1] - yUnzip[y]) * (xUnzip[x + 1] - xUnzip[x]);\n\t}\n\treturn res;\n\t\n}\n\nint main(void) {\n\tint cnt = 0;\n\twhile (1) {\n\t\t++cnt;\n\t\tvector<Rectangle> rectangles;\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\trectangles.push_back(Rectangle(Point(x - r, y - r), Point(x + r, y + r)));\n\t\t}\n\t\tcout << fixed << setprecision(2) << cnt << \" \" <<  solve(rectangles) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n};\nEvent evs[1001];\nRect recs[1001];\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  vector<int> ls,rs;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int p=find(x);\n    ls[p]=l;\n    rs[p]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    int NN=0;\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      recs[i].first=P(x-r,y-r);\n      recs[i].second=P(x+r,y+r);\n      if(EQ(r,0))continue;\n      evs[2*NN]=Event(y-r,true,i);\n      evs[2*NN+1]=Event(y+r,false,i);\n      NN++;\n    }\n    sort(evs,evs+2*NN);\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    // yÌ¬³¢ÔÉCxgð\n    for(int k=0;k<2*NN;k++){\n      Event &e=evs[k];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      prvy=e.y;\n      // _ÌÇÁAí\n      if(e.isIn)v.push_back(e.id);\n      else v.erase(find(v.begin(),v.end(),e.id));\n      // ¡ñÌ¡ðvZ\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  // ÍÍª©Ôéæ¤ÈçÎAunite\n\t  if((EQ(uft.rs[uft.find(i)]\n\t\t ,uft.ls[uft.find(j)])\n\t      ||(uft.rs[uft.find(i)]\n\t\t >uft.ls[uft.find(j)]))\n\t     &&(EQ(uft.ls[uft.find(i)]\n\t\t   ,uft.rs[uft.find(j)])\n\t\t||(uft.ls[uft.find(i)]\n\t\t   <uft.rs[uft.find(j)]))){\n\t    double minx=min(uft.ls[uft.find(i)]\n\t\t\t    ,uft.ls[uft.find(j)]);\n\t    double maxx=max(uft.rs[uft.find(i)]\n\t\t\t    ,uft.rs[uft.find(j)]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    printf(\"%d %.2f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ndouble unit = 1.0/(1<<15);\ntypedef complex<double> P;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nbool cmp(const pair<P,P>&a,const pair<P,P>&b){\n\treturn a.first.imag() < b.first.imag();\n}\nint main(){\n\tint n,N=0;\n\twhile(cin >> n ,n){\n\t\tvector< pair<P,P> > data;\n\t\tdouble ans = 0;\n\t\trep(i,n){\n\t\t\tdouble a,b,r;\n\t\t\tcin >> a >> b >> r;\n\t\t\tdata.push_back(make_pair(P(a-r,b-r),P(a+r,b+r)));\n\t\t}\n\t\tsort(data.begin(),data.end(),cmp);\n\t\tfor(double x=-200;x<=200;x += unit){\n\t\t\tvector< pair<double,double> > L;\n\t\t\trep(i,n){\n\t\t\t\tif(data[i].first.real() <= x && x <= data[i].second.real()){\n\t\t\t\t\tL.push_back(make_pair(data[i].first.imag(),data[i].second.imag()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(L.size() == 0)continue;\n\t\t\tdouble sz = 0;\n\t\t\tdouble cs = L[0].first, ce = L[0].second;\t\t\n\t\t\tfor(int i=1;i<L.size();i++){\n\t\t\t\tif(L[i].first <= ce)ce = max(ce,L[i].second);\n\t\t\t\telse sz += ce-cs , cs = L[i].first , ce = L[i].second;\n\t\t\t}\n\t\t\tsz += ce-cs;\n\t\t\tans += sz * unit;\n\t\t}\n\t\tprintf(\"%d %.2lf\\n\",++N,ans);\n\t}\n \n}"
  },
  {
    "language": "C++",
    "code": "//24\n#include<iostream>\n#include<algorithm>\n#include<iomanip>\n\nusing namespace std;\n\nstruct L{\n  int y,l,r,f;\n  bool operator<(L a)const{\n    return y<a.y;\n  }\n};\n\nint main(){\n  int cs=0;\n  for(int n;cin>>n,n;){\n    L l[200];\n    for(int i=0;i<n;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      L &a=l[2*i],&b=l[2*i+1];\n      a.l=b.l=(x-r)*100+.5;\n      a.r=b.r=(x+r)*100+.5;\n      a.y=(y-r)*100+.5;\n      b.y=(y+r)*100+.5;\n      a.f=1;\n      b.f=-1;\n    }\n    sort(l,l+n*2);\n    int c[40001]={};\n    int sum=0;\n    for(int i=0;i<2*n-1;i++){\n      for(int j=l[i].l;j<l[i].r;j++){\n\tc[j]+=l[i].f;\n      }\n      int h=l[i+1].y-l[i].y;\n      sum+=(40001-count(c,c+40001,0))*h;\n    }\n    cout.precision(2);\n    sum+=50;\n    cout<<++cs<<' '<<fixed<<sum/10000<<'.'<<setw(2)<<setfill('0')<<sum/100%100<<endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "//24\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nstruct L{\n  int y,l,r,f;\n  bool operator<(L a)const{\n    return y<a.y;\n  }\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    L l[200];\n    for(int i=0;i<n;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      L &a=l[2*i],&b=l[2*i+1];\n      a.l=b.l=(x-r)*100+.5;\n      a.r=b.r=(x+r)*100+.5;\n      a.y=(y-r)*100+.5;\n      b.y=(y+r)*100+.5;\n      a.f=1;\n      b.f=-1;\n    }\n    sort(l,l+n*2);\n    int c[40001]={};\n    int sum=0;\n    for(int i=0;i<2*n-1;i++){\n      for(int j=l[i].l;j<l[i].r;j++){\n\tc[j]+=l[i].f;\n      }\n      int h=l[i+1].y-l[i].y;\n      sum+=(40001-count(c,c+40001,0))*h;\n    }\n    cout.precision(2);\n    cout<<fixed<<sum/10000.<<endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(v) begin(v), end(v)\nbool mas[444][444];\n\nvoid color(int x, int y, int gx, int gy)\n{\n  mas[x][y] = true;\n  if(x+1 < gx) color(x+1, y, gx, gy);\n  if(y+1 < gy) color(x, y+1, gx, gy);\n}\n\nint main(){\n  int n;\n  int t = 0;\n  while(cin >> n, n) {\n    t++;\n    memset(mas, false, sizeof(mas));\n    vector<double> xx, yy;\n    vector<double> X, Y;\n    rep(i, n) {\n      double x, y, r;\n      cin >> x >> y >> r;\n      xx.push_back(x - r);\n      xx.push_back(x + r);\n      yy.push_back(y - r);\n      yy.push_back(y + r);\n      X.push_back(x - r);\n      X.push_back(x + r);\n      Y.push_back(y - r);\n      Y.push_back(y + r);\n    }\n    sort(all(X)); \n    sort(all(Y));\n    X.erase(unique(all(X)), X.end());\n    Y.erase(unique(all(Y)), Y.end());\n    for(int i = 0; i < (int)xx.size(); i+=2) {\n      xx[i] = find(all(X), xx[i]) - begin(X);\n      yy[i] = find(all(Y), yy[i]) - begin(Y);\n      xx[i+1] = find(all(X), xx[i+1]) - begin(X);\n      yy[i+1] = find(all(Y), yy[i+1]) - begin(Y);\n      color(xx[i], yy[i], xx[i+1], yy[i+1]);\n    }\n    /*//\n    rep(i, Y.size()) {\n      rep(j, X.size()) cout << (int)mas[j][i];\n      cout << endl;\n    }\n    //*/\n    double ans = 0;\n    rep(i, X.size()-1) rep(j, Y.size()-1) {\n      if(!mas[i][j]) continue;\n      ans += (X[i+1]-X[i]) * (Y[j+1]-Y[j]);\n      //cout << X[i+1] << \" \" << X[i] <<  \" \" << Y[j+1] << \" \" << Y[j] << endl;\n    }\n    printf(\"%d %.2f\\n\", t, ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<cstdio>\n#define DIF 5000\n#define all(n) n.begin(),n.end()\nusing namespace std;\n\nvoid draw(vector<vector<bool> >& graph,int sx,int sy,int ex,int ey)\n{\n  for(int i=sy;i<ey;i++)\n    for(int j=sx;j<ex;j++)\n      graph[i][j] = true;\n}\n\nint main()\n{\n  int n,NARI = 1;\n  while(cin >> n,n)\n    {      \n      vector<double> X,Y,X1,X2,Y1,Y2;\n      vector<vector<bool> > graph;\n      graph.resize(210);\n\n      for(int i=0;i<210;i++)\n\t{\n\t  graph[i].resize(210);\n\t  for(int j=0;j<210;j++)\n\t    graph[i][j] = false;\n\t}\n\n      for(int i=0;i<n;i++)\n\t{\n\t  double x,y,r;\n\t  cin >> x >> y >> r;\n\t  X.push_back(x+r),X.push_back(x-r);\n\t  Y.push_back(y+r),Y.push_back(y-r);\n\t  X1.push_back(x-r),Y1.push_back(y-r);\n\t  X2.push_back(x+r),Y2.push_back(y+r);\n\t}\n\n      sort(all(X));\n      sort(all(Y));\n      X.erase(unique(all(X)),X.end());\n      Y.erase(unique(all(Y)),Y.end());\n\n      for(int i=0;i<n;i++)\n\t{\n\n\t  X1[i] = find(all(X),X1[i]) - X.begin();\n\t  Y1[i] = find(all(Y),Y1[i]) - Y.begin();\n\n\t  X2[i] = find(all(X),X2[i]) - X.begin();\n\t  Y2[i] = find(all(Y),Y2[i]) - Y.begin();\n\n\t}\n\n      for(int i=0;i<n;i++)\n\t  draw(graph,X1[i],Y1[i],X2[i],Y2[i]);\n\n      double ans = 0;\n      for(int i=0;i<Y.size()-1;i++)\n\tfor(int j=0;j<X.size()-1;j++)\n\t  if(graph[i][j])\n\t      ans += (X[j+1]-X[j])*(Y[i+1]-Y[i]);\n\t    \n      cout << NARI++ << setiosflags(ios::fixed) << setprecision(2)<< \" \" << ans << endl;\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, int> P;\n\nint main(){\n  int N;\n  int casenum = 1;\n  while(cin>>N && N){\n    printf(\"%d \", casenum++);\n    map<double, vector<P> > eventx;\n    map<double, vector<P> > delx;\n    set<double> searchx;\n    REP(i, N){\n      double x, y, d;\n      cin>>x>>y>>d;\n      searchx.insert(x - d);\n      searchx.insert(x + d);\n      eventx[x - d].push_back(P(y - d, 1));\n      eventx[x - d].push_back(P(y + d, -1));\n      delx[x + d].push_back(P(y - d, 1));\n      delx[x + d].push_back(P(y + d, -1));\n    }\n    vector<P> evs;\n    //set<P> evs;\n    double bfx = 0;\n    double bfy = 0;\n    double ans = 0;\n    FORIT(sx, searchx){\n      ans += (*sx - bfx) * bfy;\n      if(delx.count(*sx)){\n        FORIT(it, delx[*sx]) evs.erase(find(evs.begin(), evs.end(), *it));\n      }\n      if(eventx.count(*sx)){\n        FORIT(it, eventx[*sx]) evs.push_back(*it);\n      }\n      sort(evs.begin(), evs.end());\n      bfx = *sx;\n      bfy = 0;\n      int cnt = 0;\n      double ty = 0;\n      FORIT(event, evs){\n        if(cnt > 0){\n          bfy += (event->first - ty);\n        }\n        ty = event->first;\n        cnt += event->second;\n      }\n    }\n    printf(\"%.2lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<P,double> Pd;\nPd p[101];\nvector<Pd> d;\n\nmap <double,int> M;\nmap <int,double> M2;\nvector <Pd> Y[301];\n\n\ndouble calc(){\n  double sum=0;\n  vector <P> a;\n  for(int i=0;M2.count(i+1);i++){\n    sort(a.begin(),a.end());\n    for(int j=0;j<Y[i].size();j++){\n      if(Y[i][j].s==1)a.push_back(Y[i][j].f);\n      else a.erase(lower_bound(a.begin(),a.end(),Y[i][j].f));\n    }\n    sort(a.begin(),a.end());\n    \n    double l=0,r=0,m=0;\n    for(int j=0;j<a.size();j++){\n      if(a[j].f<r)r=max(r,a[j].s);\n      else m+=r-l,l=a[j].f,r=a[j].s;\n    }\n    m+=r-l;\n    sum+=m*(M2[i+1]-M2[i]);\n  }\n  return sum;\n}\n\nint main(){\n  int n,T=1;\n  \n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i].f.f>>p[i].f.s>>p[i].s;\n    vector<double> a;\n    for(int i=0;i<n;i++){\n      a.push_back(p[i].f.s+p[i].s);\n      a.push_back(p[i].f.s-p[i].s);\n    }\n\n    sort(a.begin(),a.end());\n    M.clear();\n    M2.clear();\n    for(int i=0,cnt=0;i<a.size();i++)if(!M.count(a[i]))M2[cnt]=a[i],M[a[i]]=cnt++;\n\n    for(int i=0;i<300;i++)Y[i].clear();\n\n    for(int i=0;i<n;i++){\n      double l=p[i].f.f-p[i].s,r=p[i].f.f+p[i].s;\n      Y[M[p[i].f.s-p[i].s]].push_back(Pd(P(l,r),1));\n      Y[M[p[i].f.s+p[i].s]].push_back(Pd(P(l,r),-1));\n    }\n    printf(\"%d %.2f\\n\",T++,calc());\n  }\n  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ndouble unit = 0.001;\ntypedef complex<double> P;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nbool cmp(const pair<P,P>&a,const pair<P,P>&b){\n\treturn a.first.imag() < b.first.imag();\n}\nint main(){\n\tint n,N=0;\n\twhile(cin >> n ,n){\n\t\tvector< pair<P,P> > data;\n\t\tdouble ans = 0;\n\t\trep(i,n){\n\t\t\tdouble a,b,r;\n\t\t\tcin >> a >> b >> r;\n\t\t\tdata.push_back(make_pair(P(a-r,b-r),P(a+r,b+r)));\n\t\t}\n\t\tsort(data.begin(),data.end(),cmp);\n\t\tfor(double x=-200;x<=400;x += unit){\n\t\t\tvector< pair<double,double> > L;\n\t\t\trep(i,n){\n\t\t\t\tif(data[i].first.real() <= x && x <= data[i].second.real()){\n\t\t\t\t\tL.push_back(make_pair(data[i].first.imag(),data[i].second.imag()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(L.size() == 0)continue;\n\t\t\tdouble sz = 0;\n\t\t\tdouble cs = L[0].first, ce = L[0].second;\t\t\n\t\t\tfor(int i=1;i<L.size();i++){\n\t\t\t\tif(L[i].first <= ce)ce = max(ce,L[i].second);\n\t\t\t\telse sz += ce-cs , cs = L[i].first , ce = L[i].second;\n\t\t\t}\n\t\t\tsz += ce-cs;\n\t\t\tans += sz * unit;\n\t\t}\n\t\tprintf(\"%d %.2lf\\n\",++N,ans);\n\t}\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Point {\n\tdouble x;\n\tdouble y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() :x(0), y(0) {}\n};\n\nstruct Rectangle {\n\tPoint topLeft;\n\tPoint bottomRight;\n\tRectangle(Point topLeft, Point bottomRight) :topLeft(topLeft), bottomRight(bottomRight) {}\n\tRectangle(){}\n};\n\nint compress(vector<double> &x, unordered_map<double, int>& zip, vector<int>& unzip) {\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tunzip.resize(x.size());\n\tfor (size_t i = 0; i < x.size(); i++)\n\t{\n\t\tzip[x[i]] = i;\n\t\tunzip[i] = x[i];\n\t}\n\treturn zip.size();\n}\n\ndouble solve(const vector<Rectangle> rectangles) {\n\tvector<double> xs;\n\tunordered_map<double, int> xZip;\n\tvector<int> xUnzip;\n\tvector<double> ys;\n\tunordered_map<double, int> yZip;\n\tvector<int> yUnzip;\n\n\tfor (auto &r : rectangles) {\n\t\txs.push_back(r.topLeft.x);\n\t\txs.push_back(r.bottomRight.x);\n\t\tys.push_back(r.topLeft.y);\n\t\tys.push_back(r.bottomRight.y);\n\t}\n\tvector<vector<bool> > checker(ys.size(), vector<bool>(xs.size(), false));\n\tcompress(xs, xZip, xUnzip);\n\tcompress(ys, yZip, yUnzip);\n\n\tfor (auto &r : rectangles) {\n\t\tfor (int y = yZip[r.topLeft.y]; y < yZip[r.bottomRight.y]; ++y) {\n\t\t\tfor (int x = xZip[r.topLeft.x]; x < xZip[r.bottomRight.x]; ++x) {\n\t\t\t\tchecker[y][x] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble res = 0.0;\n\tfor (int y = 0; y < yUnzip.size()-1 ; ++y) for (int x = 0; x < xUnzip.size()-1; ++x) if (checker[y][x]) {\n\t\tres += (yUnzip[y + 1] - yUnzip[y]) * (xUnzip[x + 1] - xUnzip[x]);\n\t}\n\treturn res;\n\t\n}\n\nint main(void) {\n\tint cnt = 0;\n\twhile (1) {\n\t\t++cnt;\n\t\tvector<Rectangle> rectangles;\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\trectangles.push_back(Rectangle(Point(x - r, y - r), Point(x + r, y + r)));\n\t\t}\n\t\tcout << fixed << setprecision(2) << cnt << \" \" <<  solve(rectangles) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\nRect recs[101];\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n};\nEvent evs[1001];\n\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  vector<int> ls;\n  vector<int> rs;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int par=find(x);\n    ls[par]=l;\n    rs[par]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      recs[i].first=P(x-r,y-r);\n      recs[i].second=P(x+r,y+r);\n      evs[2*i]=Event(y-r,true,i);\n      evs[2*i+1]=Event(y+r,false,i);\n    }\n    sort(evs,evs+2*N);\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    // yÌ¬³¢ÔÉCxgð\n    for(int i=0;i<2*N;i++){\n      Event &e=evs[i];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      prvy=e.y;\n      // _ðÇÁ\n      if(e.isIn){\n\t// »Ìã,¡ñÌ_ðÜßé\n\tv.push_back(e.id);\n      }\n      else{\n\tif(find(v.begin(),v.end(),e.id)!=v.end())\n\t  v.erase(find(v.begin(),v.end(),e.id));\n      }\n      // ¡ñÌ¡ðvZ\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  // ÍÍª©Ôéæ¤ÈçÎAunite\n\t  if((EQ(uft.rs[i],uft.ls[j])\n\t      ||(uft.rs[i]>uft.ls[j]))\n\t     &&(EQ(uft.ls[i],uft.rs[j])\n\t\t||(uft.ls[i]<uft.rs[j]))){\n\t    double minx=min(uft.ls[i],uft.ls[j]);\n\t    double maxx=max(uft.rs[i],uft.rs[j]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    printf(\"%d %.10f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<P,double> Pd;\nPd p[101];\nvector<Pd> d;\n\nmap <double,int> M;\nmap <int,double> M2;\nvector <Pd> Y[301];\n\n\ndouble calc(){\n  double sum=0;\n  vector <P> a;\n  for(int i=0;i<300&&M2.count(i+1);i++){\n    sort(a.begin(),a.end());\n    for(int j=0;j<Y[i].size();j++){\n      if(Y[i][j].s==1)a.push_back(Y[i][j].f);\n      else a.erase(lower_bound(a.begin(),a.end(),Y[i][j].f));\n    }\n    sort(a.begin(),a.end());\n    \n    double l=0,r=0,m=0;\n    for(int j=0;j<a.size();j++){\n      if(a[j].f<r)r=max(r,a[j].s);\n      else m+=r-l,l=a[j].f,r=a[j].s;\n    }\n    m+=r-l;\n    sum+=m*(M2[i+1]-M2[i]);\n  }\n  return sum;\n}\n\nint main(){\n  int n,T=1;\n  \n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i].f.f>>p[i].f.s>>p[i].s;\n    vector<double> a;\n    for(int i=0;i<n;i++){\n      a.push_back(p[i].f.s+p[i].s);\n      a.push_back(p[i].f.s-p[i].s);\n    }\n\n    sort(a.begin(),a.end());\n    M.clear();\n    M2.clear();\n    for(int i=0,cnt=0;i<a.size();i++)if(!M.count(a[i]))M2[cnt]=a[i],M[a[i]]=cnt++;\n\n    for(int i=0;i<300;i++)Y[i].clear();\n    for(int i=0;i<n;i++){\n      int l=p[i].f.f-p[i].s,r=p[i].f.f+p[i].s;\n      Y[M[p[i].f.s-p[i].s]].push_back(Pd(P(l,r),1));\n      Y[M[p[i].f.s+p[i].s]].push_back(Pd(P(l,r),-1));\n    }\n    for(int i=0;i<301;i++) sort(Y[i].begin(),Y[i].end());\n    printf(\"%d %.2f\\n\",T++,calc());\n \n  }\n  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef pair<ld, ld> Point;\n\ntemplate<class T>\nvoid compress(vector<T> v, map<T, int>& zip, vector<T>& unzip)\n{\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)), v.end());\n\tunzip.resize(v.size());\n\tREP(i, v.size())\n\t{\n\t\tzip[v[i]] = i;\n\t\tunzip[i] = v[i];\n\t}\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(2);\n\tint n;\n\tfor (int cs = 1; cin >> n, n; cs++)\n\t{\n\t\tvector<pair<Point, ld>> v;\n\t\tvector<ld> x, y;\n\t\tREP(i, n)\n\t\t{\n\t\t\tld tx, ty, rad; cin >> tx >> ty >> rad;\n\t\t\tld lx, dy, rx, uy;\n\t\t\tlx = tx - rad, rx = tx + rad;\n\t\t\tdy = ty - rad, uy = ty + rad;\n\t\t\tv.emplace_back(Point(tx, ty), rad);\n\t\t\tx.emplace_back(lx);\n\t\t\tx.emplace_back(rx);\n\t\t\ty.emplace_back(dy);\n\t\t\ty.emplace_back(uy);\n\t\t}\n\t\tmap<ld, int> x_zip, y_zip;\n\t\tvector<ld> x_unzip, y_unzip;\n\t\tcompress(x, x_zip, x_unzip);\n\t\tcompress(y, y_zip, y_unzip);\n\t\tbool fld[500][500] = {};\n\t\tfor (auto i : v)\n\t\t{\n\t\t\tld tx, ty, rad;\n\t\t\ttx = i.first.first, ty = i.first.second;\n\t\t\trad = i.second;\n\t\t\tld lx, dy, rx, uy;\n\t\t\tlx = tx - rad, rx = tx + rad;\n\t\t\tdy = ty - rad, uy = ty + rad;\n\t\t\tFOR(j, x_zip[lx], x_zip[rx])FOR(k, y_zip[dy], y_zip[uy])\n\t\t\t{\n\t\t\t\tfld[j][k] = true;\n\t\t\t}\n\t\t}\n\t\tld ans = 0;\n\t\tREP(i, 500)REP(j, 500)\n\t\t{\n\t\t\tif (!fld[i][j]) continue;\n\t\t\tld lx, dy, rx, uy;\n\t\t\tlx = x_unzip[i], rx = x_unzip[i + 1];\n\t\t\tdy = y_unzip[j], uy = y_unzip[j + 1];\n\t\t\tans += (rx - lx) * (uy - dy);\n\t\t}\n\t\tcout << cs << \" \" << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, int> P;\n\nint main(){\n  int N;\n  int casenum = 1;\n  while(cin>>N && N){\n    printf(\"%d \", casenum++);\n    map<double, vector<P> > eventx;\n    map<double, vector<P> > delx;\n    set<double> searchx;\n    REP(i, N){\n      double x, y, d;\n      cin>>x>>y>>d;\n      searchx.insert(x - d);\n      searchx.insert(x + d);\n      eventx[x - d].push_back(P(y - d, 1));\n      eventx[x - d].push_back(P(y + d, -1));\n      delx[x + d].push_back(P(y - d, 1));\n      delx[x + d].push_back(P(y + d, -1));\n    }\n    vector<P> evs;\n    //set<P> evs;\n    double bfx = 0;\n    double bfy = 0;\n    double ans = 0;\n    FORIT(sx, searchx){\n      ans += (*sx - bfx) * bfy;\n      if(delx.count(*sx)){\n        FORIT(it, delx[*sx]){\n          vector<P>::iterator findit = find(evs.begin(), evs.end(), *it);\n          assert(findit != evs.end());\n          evs.erase(findit);\n        }\n      }\n      if(eventx.count(*sx)){\n        FORIT(it, eventx[*sx]) evs.push_back(*it);\n      }\n      sort(evs.begin(), evs.end());\n      bfx = *sx;\n      bfy = 0;\n      int cnt = 0;\n      double ty = 0;\n      FORIT(event, evs){\n        if(cnt > 0){\n          bfy += abs(event->first - ty);\n        }\n        ty = event->first;\n        cnt += event->second;\n      }\n    }\n    printf(\"%.2lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//24\n#include<iostream>\n#include<algorithm>\n#include<iomanip>\n\nusing namespace std;\n\nstruct L{\n  int y,l,r,f;\n  bool operator<(L a)const{\n    return y<a.y;\n  }\n};\n\nint main(){\n  int cs=0;\n  for(int n;cin>>n,n;){\n    L l[200];\n    for(int i=0;i<n;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      L &a=l[2*i],&b=l[2*i+1];\n      a.l=b.l=(x-r)*100+.5+20000;\n      a.r=b.r=(x+r)*100+.5+20000;\n      a.y=(y-r)*100+.5+20000;\n      b.y=(y+r)*100+.5+20000;\n      a.f=1;\n      b.f=-1;\n    }\n    sort(l,l+n*2);\n    int c[60001]={};\n    unsigned sum=0;\n    for(int i=0;i<2*n-1;i++){\n      for(int j=l[i].l;j<l[i].r;j++){\n\tc[j]+=l[i].f;\n      }\n      int h=l[i+1].y-l[i].y;\n      sum+=(60001-count(c,c+60001,0U))*h;\n    }\n    cout.precision(2);\n    cout<<++cs<<' '<<fixed<<sum/10000.<<endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<cstdio>\n#define DIF 5000\n#define all(n) n.begin(),n.end()\nusing namespace std;\n\nvoid draw(vector<vector<bool> >& graph,int sx,int sy,int ex,int ey)\n{\n  for(int i=sy;i<ey;i++)\n    for(int j=sx;j<ex;j++)\n      graph[i][j] = true;\n}\n\nint main()\n{\n  int n,NARI = 1;\n  while(cin >> n,n)\n    {      \n      vector<double> X,Y,X1,X2,Y1,Y2;\n      vector<vector<bool> > graph;\n      graph.resize(310);\n\n      for(int i=0;i<310;i++)\n\t{\n\t  graph[i].resize(310);\n\t  for(int j=0;j<310;j++)\n\t    graph[i][j] = false;\n\t}\n\n      for(int i=0;i<n;i++)\n\t{\n\t  double x,y,r;\n\t  cin >> x >> y >> r;\n\t  X.push_back(x+r),X.push_back(x-r);\n\t  Y.push_back(y+r),Y.push_back(y-r);\n\t  X1.push_back(x-r),Y1.push_back(y-r);\n\t  X2.push_back(x+r),Y2.push_back(y+r);\n\t}\n\n      sort(all(X));\n      sort(all(Y));\n      X.erase(unique(all(X)),X.end());\n      Y.erase(unique(all(Y)),Y.end());\n\n      for(int i=0;i<n;i++)\n\t{\n\n\t  X1[i] = find(all(X),X1[i]) - X.begin();\n\t  Y1[i] = find(all(Y),Y1[i]) - Y.begin();\n\n\t  X2[i] = find(all(X),X2[i]) - X.begin();\n\t  Y2[i] = find(all(Y),Y2[i]) - Y.begin();\n\n\t}\n\n      for(int i=0;i<n;i++)\n\t  draw(graph,X1[i],Y1[i],X2[i],Y2[i]);\n\n      double ans = 0;\n      for(int i=0;i<Y.size()-1;i++)\n\tfor(int j=0;j<X.size()-1;j++)\n\t  if(graph[i][j])\n\t      ans += (X[j+1]-X[j])*(Y[i+1]-Y[i]);\n\t    \n      cout << NARI++ << setiosflags(ios::fixed) << setprecision(2)<< \" \" << ans << endl;\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<double,int>P;\ntypedef pair<double,double>Pi;\ntypedef pair<Pi,int>PP;\nint main(){\n  int n,T=0;\n  while(cin>>n,n){\n    cout<<++T<<\" \";\n    double a[101],b[101],c[101];\n    vector<P> v;\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      v.push_back(P(b[i]-c[i],-i));\n      v.push_back(P(b[i]+c[i],i));\n    }\n    sort(v.begin(),v.end());\n    double h=-1e9,w=0;\n    double ans=0;\n    vector<PP> s;\n    for(int i=0;i<v.size();i++){\n      ans+=(v[i].first-h)*w,h=v[i].first;\n      bool f=1;\n      for(int j=0;j<s.size();j++)\n    if(s[j].second==-v[i].second)s.erase(s.begin()+j),f=0;\n \n      if(f)s.push_back(PP(Pi(a[-v[i].second]-c[-v[i].second],a[-v[i].second]+c[-v[i].second]),-v[i].second));\n \n      sort(s.begin(),s.end());\n \n      w=s[0].first.second-s[0].first.first;\n      double pr=s[0].first.second;\n \n      for(int j=0;j<s.size();j++){\n    if(s[j].first.first<pr)w+=max(0.0,s[j].first.second-pr);\n    else w+=s[j].first.second-s[j].first.first;\n    pr=max(s[j].first.second,pr);\n \n      }\n    }\n    printf(\"%.2f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct P {\n  double x;\n  double y1, y2;                // y1 < y2\n  bool f;                       // 0:in, 1:out\n  int id;\n};\nconst bool operator<(const P &a, const P &b) {\n  return a.x != b.x ? a.x < b.x : a.f < b.f;\n}\n\ntypedef pair<double,double> pdd;\nint main() {\n  int n;\n  int nn = 0;\n  while(cin >> n, n) {\n    vector<P> v;\n    REP(i,n) {\n      double x,y,r;\n      cin >> x >> y >> r;\n      v.push_back((P){x-r,y-r,y+r,0,i});\n      v.push_back((P){x+r,y-r,y+r,1,i});\n    }\n    sort(ALL(v));\n    double x = -INF;\n    double res = 0;\n    vector<pdd> ys(n);\n    double dy = 0;\n    FOR(it, v) {\n//      printf(\"%f %f (%f,%f) %d\\n\", x,it->x,it->y1,it->y2,it->f);\n      \n      if (x == -INF) x = it->x;\n      \n      res += (it->x - x) * dy;\n      \n      x = it->x;\n      \n      if (it->f == 0)\n        ys[it->id] = pdd(it->y1, it->y2);\n      else {\n        ys[it->id] = pdd(0,0);\n      }\n\n      // dy ÌvZ\n      double y1=-INF,y2=-INF;       // »Ýl¦Ä¢éÍÍ\n      dy = 0;\n      vector<pdd> tmp = ys;\n      sort(ALL(tmp));\n      FOR(jt, tmp) {\n        if (jt->first == 0 && jt->second == 0) continue;\n        if (y2 <= jt->first) {\n          dy += y2-y1;\n          y1 = jt->first;\n          y2 = jt->second;\n        } else if (y2 <= jt->second) {\n          y2 = jt->second;\n        } else {      \n        }\n      }\n      dy += y2-y1;\n    }\n    printf(\"%d %.2f\\n\", ++nn, res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\nRect recs[101];\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n};\nEvent evs[1001];\n\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  vector<int> ls;\n  vector<int> rs;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int par=find(x);\n    ls[par]=l;\n    rs[par]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      recs[i].first=P(x-r,y-r);\n      recs[i].second=P(x+r,y+r);\n      evs[2*i]=Event(y-r,true,i);\n      evs[2*i+1]=Event(y+r,false,i);\n    }\n    sort(evs,evs+2*N);\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    // yÌ¬³¢ÔÉCxgð\n    for(int i=0;i<2*N;i++){\n      Event &e=evs[i];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      prvy=e.y;\n      // _ðÇÁ\n      if(e.isIn){\n\t// »Ìã,¡ñÌ_ðÜßé\n\tv.push_back(e.id);\n      }\n      else{\n\tif(find(v.begin(),v.end(),e.id)!=v.end())\n\t  v.erase(find(v.begin(),v.end(),e.id));\n      }\n      // ¡ñÌ¡ðvZ\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  // ÍÍª©Ôéæ¤ÈçÎAunite\n\t  if((EQ(uft.rs[i],uft.ls[j])\n\t      ||(uft.rs[i]>uft.ls[j]))\n\t     &&(EQ(uft.ls[i],uft.rs[j])\n\t\t||(uft.ls[i]<uft.rs[j]))){\n\t    double minx=min(uft.ls[i],uft.ls[j]);\n\t    double maxx=max(uft.rs[i],uft.rs[j]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    res=(int)(res+0.005+EPS);\n    printf(\"%d %.2f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct interval{\n\tT a,b;\n\tint id;\n\tbool operator<(const interval &I)const{ return a+EPS<I.a || abs(a-I.a)<EPS && b+EPS<I.b; }\n};\n\ndouble calc_width(vector< interval<double> > &I){\n\tint n=I.size();\n\tif(n==0) return 0;\n\tsort(I.begin(),I.end());\n\n\tdouble res=0;\n\tdouble left=0,right=0;\n\trep(i,n){\n\t\tif(i==0 || right+EPS<I[i].a){\n\t\t\tres+=right-left;\n\t\t\tleft=I[i].a;\n\t\t\tright=I[i].b;\n\t\t}\n\t\telse{\n\t\t\tright=max(right,I[i].b);\n\t\t}\n\t}\n\tres+=right-left;\n\n\treturn res;\n}\n\nint main(){\n\tfor(int test=1,n;scanf(\"%d\",&n),n;test++){\n\t\tpair< double,interval<double> > E[200];\n\t\trep(i,n){\n\t\t\tdouble x,y,r; scanf(\"%lf%lf%lf\",&x,&y,&r);\n\t\t\tE[2*i+0]=make_pair(y-r,(interval<double>){x-r,x+r,i});\n\t\t\tE[2*i+1]=make_pair(y+r,(interval<double>){x-r,x+r,i});\n\t\t}\n\t\tsort(E,E+2*n);\n\n\t\tvector< interval<double> > I;\n\t\tdouble ans=0,h=0,w=0;\n\t\trep(t,2*n){\n\t\t\tinterval<double> J=E[t].second;\n\n\t\t\tbool in=true;\n\t\t\trep(i,I.size()) if(I[i].id==J.id) { in=false; I.erase(I.begin()+i); break; }\n\t\t\tif(in) I.push_back(J);\n\n\t\t\tans+=(E[t].first-h)*w;\n\t\t\th=E[t].first;\n\t\t\tw=calc_width(I);\n\t\t}\n\n\t\tprintf(\"%d %.2f\\n\",test,ans+EPS);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#define DIF 5000\n#define all(n) n.begin(),n.end()\nusing namespace std;\n\nvoid draw(vector<vector<bool> >& graph,int sx,int sy,int ex,int ey)\n{\n  for(int i=sy;i<ey;i++)\n    for(int j=sx;j<ex;j++)\n      graph[i][j] = true;\n}\n\nint main()\n{\n  int n,NARI = 1;\n  while(cin >> n,n)\n    {      \n      vector<int> X,Y,X1,X2,Y1,Y2;\n      vector<vector<bool> > graph;\n      graph.resize(310);\n\n      for(int i=0;i<310;i++)\n\t{\n\t  graph[i].resize(310);\n\t  for(int j=0;j<310;j++)\n\t    graph[i][j] = false;\n\t}\n\n      for(int i=0;i<n;i++)\n\t{\n\t  double x,y,r;\n\t  cin >> x >> y >> r;\n\t  X.push_back(x+r),X.push_back(x-r);\n\t  Y.push_back(y+r),Y.push_back(y-r);\n\t  X1.push_back(x-r),Y1.push_back(y-r);\n\t  X2.push_back(x+r),Y2.push_back(y+r);\n\t}\n      sort(all(X));\n      sort(all(Y));\n      X.erase(unique(all(X)),X.end());\n      Y.erase(unique(all(Y)),Y.end());\n\n      for(int i=0;i<n;i++)\n\t{\n\n\t  X1[i] = find(all(X),X1[i]) - X.begin();\n\t  Y1[i] = find(all(Y),Y1[i]) - Y.begin();\n\n\t  X2[i] = find(all(X),X2[i]) - X.begin();\n\t  Y2[i] = find(all(Y),Y2[i]) - Y.begin();\n\n\t}\n\n      for(int i=0;i<n;i++)\n\t  draw(graph,X1[i],Y1[i],X2[i],Y2[i]);\n\n      double ans = 0;\n      for(int i=0;i<Y.size()-1;i++)\n\tfor(int j=0;j<X.size()-1;j++)\n\t  if(graph[i][j])\n\t      ans += (X[j+1]-X[j])*(Y[i+1]-Y[i]);\n\t    \n\t  \t    \n      cout << NARI++ << setiosflags(ios::fixed) << setprecision(2)<< \" \" << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep( i, begin, end) for( int i = begin; i < end; i++ )\nusing namespace std;\n \nstruct coverage {\n    double x1, x2, y1, y2;\n    coverage( double x1, double x2, double y1, double y2 ) : x1( x1 ), x2( x2 ), y1( y1 ), y2( y2 ) { }\n};\n\nbool confirm( const coverage &region1, const coverage &region2 )\n{\n    return( region1.x1 < region2.x2 && region2.x1 < region1.x2 && region1.y1 < region2.y2 && region2.y1 < region1.y2 );\n}\n \nint main() {\n    int n, order = 0;\n    double x, y, r, area;\n    while( cin >> n ) {\n        if( n == 0 )\n            break;\n        vector<coverage> square;\n        vector<double> sx, sy;\n        rep ( i, 0, n ) {\n            cin >> x >> y >> r;\n            square.push_back( coverage( x - r, x + r, y - r, y + r) );\n            sx.push_back( x - r );\n            sx.push_back( x + r );\n            sy.push_back( y - r );\n            sy.push_back( y + r );\n        }\n        area = 0;\n        sort( sx.begin(), sx.end() );\n        sort( sy.begin(), sy.end() );\n \n        int a, b, c, flag;\n        for( a = 0; a < sx.size() - 1; a++ )\n            for( b = 0; b < sy.size() - 1; b++ )\n                for( c = flag = 0; c < square.size(); c++) {\n                    if( confirm( square[c], coverage( sx[ a ], sx[ a + 1 ], sy[ b ], sy[ b + 1 ] ) ) )\n                        if( flag == 0 ) {\n                            area += ( sx[ a + 1 ] - sx[ a ] ) * ( sy[ b + 1 ] - sy[ b ] );\n\t\t\t\t\t\t\tflag++;\n\t\t\t\t\t\t}\n                }\n        cout << ++order << \" \" << fixed << setprecision(2) << area << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\nRect recs[101];\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n};\nEvent evs[1001];\n\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  vector<int> ls;\n  vector<int> rs;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int par=find(x);\n    ls[par]=l;\n    rs[par]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      recs[i].first=P(x-r,y-r);\n      recs[i].second=P(x+r,y+r);\n      evs[2*i]=Event(y-r,true,i);\n      evs[2*i+1]=Event(y+r,false,i);\n    }\n    sort(evs,evs+2*N);\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    // yÌ¬³¢ÔÉCxgð\n    for(int i=0;i<2*N;i++){\n      Event &e=evs[i];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      prvy=e.y;\n      // _ðÇÁ\n      if(e.isIn){\n\t// »Ìã,¡ñÌ_ðÜßé\n\tv.push_back(e.id);\n      }\n      else{\n\t//if(find(v.begin(),v.end(),e.id)!=v.end())\n\t  v.erase(find(v.begin(),v.end(),e.id));\n      }\n      // ¡ñÌ¡ðvZ\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  // ÍÍª©Ôéæ¤ÈçÎAunite\n\t  if((EQ(uft.rs[i],uft.ls[j])\n\t      ||(uft.rs[i]>uft.ls[j]))\n\t     &&(EQ(uft.ls[i],uft.rs[j])\n\t\t||(uft.ls[i]<uft.rs[j]))){\n\t    double minx=min(uft.ls[i],uft.ls[j]);\n\t    double maxx=max(uft.rs[i],uft.rs[j]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    res=(int)(res+0.005+EPS);\n    printf(\"%d %.2f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, int> P;\n\nint main(){\n  int N;\n  int casenum = 1;\n  while(cin>>N && N){\n    printf(\"%d \", casenum++);\n    map<double, vector<P> > eventx;\n    map<double, vector<P> > delx;\n    set<double> searchx;\n    REP(i, N){\n      double x, y, d;\n      cin>>x>>y>>d;\n      searchx.insert(x - d);\n      searchx.insert(x + d);\n      eventx[x - d].push_back(P(y - d, 1));\n      eventx[x - d].push_back(P(y + d, -1));\n      delx[x + d].push_back(P(y - d, 1));\n      delx[x + d].push_back(P(y + d, -1));\n    }\n    set<P> evs;\n    double bfx = 0;\n    double bfy = 0;\n    double ans = 0;\n    FORIT(sx, searchx){\n      ans += (*sx - bfx) * bfy;\n      if(delx.count(*sx)){\n        FORIT(it, delx[*sx]) evs.erase(*it);\n      }\n      if(eventx.count(*sx)){\n        FORIT(it, eventx[*sx]) evs.insert(*it);\n      }\n      bfx = *sx;\n      bfy = 0;\n      int cnt = 0;\n      double ty = 0;\n      FORIT(event, evs){\n        if(cnt > 0){\n          bfy += (event->first - ty);\n        }\n        ty = event->first;\n        cnt += event->second;\n      }\n    }\n    printf(\"%.2lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<tuple>\n#include<algorithm>\nusing namespace std;\n\nenum {Y, X1, X2, FLAG};\nenum {TOP, BOTTOM};\n\n#define EDGE tuple<double, double, double, int>\n\nint main() {\n    int data = 0;\n    int n;\n    while(cin>>n, n) {\n        data++;\n        vector<EDGE> edge;\n        for(int i=0; i<n; i++) {\n            double x, y, r;\n            cin>>x>>y>>r;\n            edge.push_back(EDGE(y-r, x-r, x+r, TOP));\n            edge.push_back(EDGE(y+r, x-r, x+r, BOTTOM));\n        }\n        sort(edge.begin(), edge.end());\n\n        double answer = 0.0;\n        vector<double> point;\n        point.push_back(get<X1>(edge[0]));\n        point.push_back(get<X2>(edge[0]));\n        for(int i=1; i<edge.size(); i++) {\n            double w, h;\n            w = *max_element(point.begin(), point.end()) - *min_element(point.begin(), point.end());\n            h = get<Y>(edge[i]) - get<Y>(edge[i-1]);\n            answer += w * h;\n            double x1, x2;\n            x1 = get<X1>(edge[i]);\n            x2 = get<X2>(edge[i]);\n            if(get<FLAG>(edge[i]) == TOP) {\n                point.push_back(x1);\n                point.push_back(x2);\n            } else {\n                point.erase(find(point.begin(), point.end(), x1));\n                point.erase(find(point.begin(), point.end(), x2));\n            }\n        }\n        cout<<setiosflags(ios::fixed)<<setprecision(2)<<data<<\" \"<<answer<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nvoid input(int &val) {\n    double temp; cin >> temp;\n    val = temp*10+eps;\n}\nvoid input(int &x, int &y, int &r) {\n    input(x);\n    input(y);\n    input(r);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int id = 1;\n    int n;\n    cout << fixed << setprecision(2);\n    const int H = 6002, W = 6002;\n    while (cin >> n, n) {\n        vector< vector<char> > m(H, vector<char>(W, 0));\n        REP(i, n) {\n            int x, y, r;\n            input(x, y, r);\n            int x1 = x-r+2000, y1 = y-r+2000;\n            int x2 = x+r+2000, y2 = y+r+2000;\n            m[y1][x1]++; m[y2][x1]--;\n            m[y1][x2]--; m[y2][x2]++;\n        }\n        REP(x, W) REP(y, H-1) {\n            m[y+1][x] += m[y][x];\n        }\n        REP(y, H) REP(x, W-1) {\n            m[y][x+1] += m[y][x];\n        }\n        ll ans = 0;\n        REP(y, H-1) REP(x, W-1) {\n            if (m[y][x]) ++ans;\n        }\n        cout << id << \" \" << ans/100. << endl;\n        ++id;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//24\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nstruct L{\n  int y,l,r,f;\n  bool operator<(L a)const{\n    return y<a.y;\n  }\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    L l[200];\n    for(int i=0;i<n;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      L &a=l[2*i],&b=l[2*i+1];\n      a.l=b.l=(x-r)*100+.5;\n      a.r=b.r=(x+r)*100+.5;\n      a.y=(y-r)*100+.5;\n      b.y=(y+r)*100+.5;\n      a.f=1;\n      b.f=-1;\n    }\n    sort(l,l+n*2);\n    int c[20001]={};\n    int sum=0;\n    for(int i=0;i<2*n-1;i++){\n      for(int j=l[i].l;j<l[i].r;j++){\n\tc[j]+=l[i].f;\n      }\n      int h=l[i+1].y-l[i].y;\n      sum+=(20001-count(c,c+20001,0))*h;\n    }\n    cout.precision(2);\n    cout<<fixed<<sum/10000.<<endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<set>\nusing namespace std;\n\nclass Square {\npublic:\n    Square(double x, double y, double r) :x_(x), y_(y), r_(r) {}\n\n    double left() const {return x_ - r_;}\n    double right() const {return x_ + r_;}\n    double bottom() const {return y_ - r_;}\n    double top() const {return y_ + r_;}\n\nprivate:\n    double x_, y_, r_;\n};\n\nint main() {\n    int step = 0;\n    int n;\n    while(cin >> n, n) {\n        vector<Square> square;\n        set<double> line;\n        for(int i = 0; i < n; ++i) {\n            double x, y, r;\n            cin >> x >> y >> r;\n            square.push_back(Square(x, y, r));\n            line.insert(x - r);\n            line.insert(x + r);\n        }\n\n        double answer = 0.0;\n        double previous_x = 0.0;\n        double previous_distance = 0.0;\n\n        for(const auto& l: line) {\n            const bool IN = true;\n            const bool OUT = false;\n            struct Node {\n                double y;\n                bool in;\n                Node(double y, bool b) :y(y), in(b) {}\n                bool operator<(const Node& n) const {return y != n.y ? y < n.y : in > n.in;}\n            };\n\n            answer += previous_distance * (l - previous_x);\n            previous_x = l;\n            previous_distance = 0.0;\n\n            multiset<Node> node;\n            for(const auto& s: square) {\n                if(s.right() <= l || l < s.left()) continue;\n                node.insert(Node(s.bottom(), IN));\n                node.insert(Node(s.top(), OUT));\n            }\n            double y;\n            int in = 0;\n            for(const auto& n: node) {\n                if(in == 0) y = n.y;\n                previous_distance += n.y - y;\n                y = n.y;\n                in += n.in ? 1 : -1;\n            }\n        }\n\n        cout << setprecision(2) << fixed << ++step << \" \" << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define all(a) (a).begin(),(a).end()\n#define rep(i,a) for(int i=0;i<(a);i++)\n#define pb push_back\nusing namespace std;\n\nint main(){\n  int n;\n  double xl[110],xr[110],yd[110],yu[110],r;\n  bool g[220][220];\n  int test = 1;\n\n  while(scanf(\"%d\",&n),n){\n    vector<double> h,w;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&xl[i],&yd[i],&r);\n      xl[i] -= r; xr[i] = xl[i]+r+r;\n      yd[i] -= r; yu[i] = yd[i]+r+r;\n      w.pb(xl[i]); w.pb(xr[i]);\n      h.pb(yd[i]); h.pb(yu[i]);\n    }\n\n    sort(all(h));\n    h.erase(unique(all(h)),h.end());\n    sort(all(w));\n    w.erase(unique(all(w)),w.end());\n\n    rep(i,n){\n      xl[i] = lower_bound(all(w),xl[i]) - w.begin();\n      xr[i] = lower_bound(all(w),xr[i]) - w.begin();\n      yd[i] = lower_bound(all(h),yd[i]) - h.begin();\n      yu[i] = lower_bound(all(h),yu[i]) - h.begin();\n    }\n\n    rep(i,h.size())rep(j,w.size())g[i][j] = false;\n    rep(i,n)\n      for(int j=yd[i];j<yu[i];j++)\n\tfor(int k=xl[i];k<xr[i];k++)g[j][k] = true;\n\n    double ans = 0;\n    rep(i,h.size())rep(j,w.size())\n      if(g[i][j])ans += (h[i+1]-h[i])*(w[j+1]-w[j]);\n    printf(\"%d %.2lf\\n\",test++,ans);\n  }\n}\n    \n\n    \n      "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 105;\n\nvector<double> X,Y,X1,Y1,X2,Y2;\nbool flag[MAX_N*2][MAX_N*2];\nint n;\n\nint main()\n{\n\tdouble p,q,r;\n\tint id=1;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0){\n\t\t\tbreak;\n\t\t}\n\t\tX.clear(),Y.clear(),X1.clear(),Y1.clear(),X2.clear(),Y2.clear();\n\t\trep(i,n*2){\n\t\t\trep(j,n*2){\n\t\t\t\tflag[i][j] = false;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tscanf(\"%lf%lf%lf\",&p,&q,&r);\n\t\t\tX.push_back(p+r),X.push_back(p-r);\n\t\t\tY.push_back(q+r),Y.push_back(q-r);\n\t\t\tX1.push_back(p-r),X2.push_back(p+r);\n\t\t\tY1.push_back(q-r),Y2.push_back(q+r);\n\t\t}\n\t\tsort(X.begin(),X.end());\n\t\tsort(Y.begin(),Y.end());\n\t\tX.erase(unique(X.begin(),X.end()),X.end());\n\t\tY.erase(unique(Y.begin(),Y.end()),Y.end());\n\t\trep(i,n){\n\t\t\tX1[i] = lower_bound(X.begin(),X.end(),X1[i]) - X.begin();\n\t\t\tY1[i] = lower_bound(Y.begin(),Y.end(),Y1[i]) - Y.begin();\n\t\t\tX2[i] = lower_bound(X.begin(),X.end(),X2[i]) - X.begin();\n\t\t\tY2[i] = lower_bound(Y.begin(),Y.end(),Y2[i]) - Y.begin();\n\t\t}\n\t\trep(i,n){\n\t\t\tfor(int j=Y1[i];j<Y2[i];j++){\n\t\t\t\tfor(int k=X1[i];k<X2[i];k++){\n\t\t\t\t\tflag[j][k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = 0;\n\t\trep(i,Y.size()-1){\n\t\t\trep(j,X.size()-1){\n\t\t\t\tif(flag[i][j]){\n\t\t\t\t\tans += (X[j+1]-X[j])*(Y[i+1]-Y[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %.2f\\n\",id,ans);\n\t\tid++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int MAX_YX = 1500;\n\nint v[MAX_YX][MAX_YX], N;\n\ndouble solve(){\n  memset(v, 0, sizeof(v));\n  vector<double> L, T, R, B;\n  set<double> Ys, Xs;\n  REP(i, N){\n    double x, y, _r; cin >>x >>y >>_r;\n    x += 210; y += 210;\n    double l = x - _r, t = y + _r, r = x + _r, b = y - _r;\n    L.push_back(l); T.push_back(t); R.push_back(r); B.push_back(b);\n    Ys.insert(t); Ys.insert(b); Xs.insert(l); Xs.insert(r);\n  }\n  Ys.insert(0); Ys.insert(1e6 + 10);\n  Xs.insert(0); Xs.insert(1e6 + 10);\n  vector<double> Y(Ys.begin(), Ys.end());\n  vector<double> X(Xs.begin(), Xs.end());\n  double res = 0.0;\n  REP(i, N){\n    int xl = lower_bound(X.begin(), X.end(), L[i]) - X.begin();\n    int xr = lower_bound(X.begin(), X.end(), R[i]) - X.begin();\n    int yt = lower_bound(Y.begin(), Y.end(), T[i]) - Y.begin();\n    int yb = lower_bound(Y.begin(), Y.end(), B[i]) - Y.begin();\n    FOR(x, xl, xr){\n      FOR(y, yb, yt){\n        if(v[x][y] == 0) res += (Y[y + 1] - Y[y]) * (X[x + 1] - X[x]);\n        v[x][y] = true;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int t = 1;\n  while(cin >> N && N) printf(\"%d %.2lf\\n\", t++, solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\ndouble x[110];\ndouble y[110];\ndouble r[110];\ndouble xz[210];\ndouble yz[210];\nint s[210][210];\nint main(){\n\tint a;\n\tint T=0;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf%lf\",x+i,y+i,r+i);\n\t\tfor(int i=0;i<a;i++){\n\t\t\txz[i*2]=x[i]-r[i];xz[i*2+1]=x[i]+r[i];\n\t\t\tyz[i*2]=y[i]-r[i];yz[i*2+1]=y[i]+r[i];\n\t\t}\n\t\tstd::sort(xz,xz+a*2);\n\t\tstd::sort(yz,yz+a*2);\n\t\tfor(int i=0;i<210;i++)for(int j=0;j<210;j++)\n\t\t\ts[i][j]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint X1=lower_bound(xz,xz+a*2,x[i]-r[i])-xz;\n\t\t\tint X2=lower_bound(xz,xz+a*2,x[i]+r[i])-xz;\n\t\t\tint Y1=lower_bound(yz,yz+a*2,y[i]-r[i])-yz;\n\t\t\tint Y2=lower_bound(yz,yz+a*2,y[i]+r[i])-yz;\n\t\t\ts[X1][Y1]++;s[X1][Y2]--;s[X2][Y1]--;s[X2][Y2]++;\n\t\t}\n\t\tfor(int i=0;i<210;i++){\n\t\t\tfor(int j=1;j<210;j++)s[i][j]+=s[i][j-1];\n\t\t}\n\t\tfor(int i=0;i<210;i++){\n\t\t\tfor(int j=1;j<210;j++)s[j][i]+=s[j-1][i];\n\t\t}\n\t\t\n\t\tdouble ret=0;\n\t\tfor(int i=0;i<210;i++)for(int j=0;j<210;j++)if(s[i][j])\n\t\t\tret+=(xz[i+1]-xz[i])*(yz[j+1]-yz[j]);\n\t\tprintf(\"%d %.2f\\n\",++T,ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(v) begin(v), end(v)\nbool mas[444][444];\n\nvoid color(int x, int y, int gx, int gy)\n{\n  for(int i = x; i < gx; i++) {\n    for(int j = y; j < gy; j++) mas[i][j] = true;\n  }  \n}\n\nint main(){\n  int n;\n  int t = 0;\n  while(cin >> n, n) {\n    t++;\n    memset(mas, false, sizeof(mas));\n    vector<double> xx, yy;\n    vector<double> X, Y;\n    rep(i, n) {\n      double x, y, r;\n      cin >> x >> y >> r;\n      xx.push_back(x - r);\n      xx.push_back(x + r);\n      yy.push_back(y - r);\n      yy.push_back(y + r);\n      X.push_back(x - r);\n      X.push_back(x + r);\n      Y.push_back(y - r);\n      Y.push_back(y + r);\n    }\n    sort(all(X)); \n    sort(all(Y));\n    X.erase(unique(all(X)), X.end());\n    Y.erase(unique(all(Y)), Y.end());\n    for(int i = 0; i < (int)xx.size(); i+=2) {\n      xx[i] = find(all(X), xx[i]) - begin(X);\n      yy[i] = find(all(Y), yy[i]) - begin(Y);\n      xx[i+1] = find(all(X), xx[i+1]) - begin(X);\n      yy[i+1] = find(all(Y), yy[i+1]) - begin(Y);\n      color(xx[i], yy[i], xx[i+1], yy[i+1]);\n    }\n    /*//\n    rep(i, Y.size()) {\n      rep(j, X.size()) cout << (int)mas[j][i];\n      cout << endl;\n    }\n    //*/\n    double ans = 0;\n    rep(i, X.size()-1) rep(j, Y.size()-1) {\n      if(!mas[i][j]) continue;\n      ans += (X[i+1]-X[i]) * (Y[j+1]-Y[j]);\n      //cout << X[i+1] << \" \" << X[i] <<  \" \" << Y[j+1] << \" \" << Y[j] << endl;\n    }\n    printf(\"%d %.2f\\n\", t, ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct R\n{\n\tdouble x1,x2,y1,y2;\n\tR(double x1,double x2,double y1,double y2):x1(x1),x2(x2),y1(y1),y2(y2){}\n};\nbool F(const R &a,const R &b)\n{\n\treturn(a.x1<b.x2&&b.x1<a.x2&&a.y1<b.y2&&b.y1<a.y2);\n}\nint main()\n{\n\tint n,i,j,k,T=0;\n\tdouble x,y,p,res;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tvector<R>v;\n\t\tvector<double>vx,vy;\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%lf%lf%lf\",&x,&y,&p);\n\t\t\tv.push_back(R(x-p,x+p,y-p,y+p));\n\t\t\tvx.push_back(x-p);\n\t\t\tvx.push_back(x+p);\n\t\t\tvy.push_back(y-p);\n\t\t\tvy.push_back(y+p);\n\t\t}\n\t\tint f;\n\t\tres=0;\n\t\tsort(vx.begin(),vx.end());\n\t\tsort(vy.begin(),vy.end());\n\n\t\tfor(i=0;i+1<vx.size();++i)\n\t\t\tfor(j=0;j+1<vy.size();++j)\n\t\t\t\tfor(f=k=0;k<v.size();++k)\n\t\t\t\t\tif(F(v[k],R(vx[i],vx[i+1],vy[j],vy[j+1])))\n\t\t\t\t\t\tif(f++==0)\n\t\t\t\t\t\t\tres+=(vx[i+1]-vx[i])*(vy[j+1]-vy[j]);\n\t\tprintf(\"%d %.2f\\n\",++T,res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <algorithm>\n#define rep(x,n) for(int x=0;x<(n);x++)\n#define all(vec) vec.begin(),vec.end()\n\n\nusing namespace std;\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& vec){\n    os << \"[\";\n    for(const auto& v : vec){\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nint main(){\n    int k = 0;\n    while(true){\n        k++;\n        int n; cin >> n;\n        if(n == 0) break;\n        // (X1,Y1) is upper left.\n        // (X1,Y1) is lower right.\n        vector<double> X1(n),X2(n),Y1(n),Y2(n);\n        rep(i,n){\n            double x,y,r;\n            cin >> x >> y >> r;\n            X1[i] = x-r;\n            X2[i] = x+r;\n            Y1[i] = y-r;\n            Y2[i] = y+r;\n        }\n        vector<double> X,Y;\n        X.insert(X.end(),all(X1));\n        X.insert(X.end(),all(X2));\n        Y.insert(Y.end(),all(Y1));\n        Y.insert(Y.end(),all(Y2));\n\n        sort(all(X));\n        sort(all(Y));\n\n        X.erase(unique(all(X)),X.end());\n        Y.erase(unique(all(Y)),Y.end());\n\n        rep(i,n){\n            X1[i] = lower_bound(all(X),X1[i]) - X.begin();\n            X2[i] = lower_bound(all(X),X2[i]) - X.begin();\n            Y1[i] = lower_bound(all(Y),Y1[i]) - Y.begin();\n            Y2[i] = lower_bound(all(Y),Y2[i]) - Y.begin();\n        }\n        vector<vector<char>> is_on(X.size(),vector<char>(Y.size()));\n        for(int i=0;i<n;i++){\n            for(int sx=X1[i];sx<X2[i];sx++){\n                for(int sy=Y1[i];sy<Y2[i];sy++){\n                    is_on[sx][sy] = true;\n                }\n            }\n        }\n        double ans = 0;\n        for(int i=0;i<X.size()-1;i++){\n            for(int j=0;j<Y.size()-1;j++){\n                if(is_on[i][j]){\n                    ans += (X[i+1]-X[i]) * (Y[j+1]-Y[j]);\n                }\n            }\n        }\n        cout << fixed << setprecision(2);\n        cout << k << \" \" << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<P,double> Pd;\nPd p[101];\nmap <double,int> M;\nmap <int,double> M2;\nvector <Pd> Y[301];\n\n\ndouble calc(){\n  double sum=0;\n  vector <P> a;\n  for(int i=0;M2.count(i+1);i++){\n    \n    for(int j=0;j<Y[i].size();j++)\n      if(Y[i][j].s==1)a.push_back(Y[i][j].f);\n      else a.erase(find(a.begin(),a.end(),Y[i][j].f));\n    \n    sort(a.begin(),a.end());\n    double l=-1e9,r=-1e9,m=0;\n    for(int j=0;j<a.size();j++){\n      if(a[j].f<r)r=max(r,a[j].s);\n      else m+=r-l,l=a[j].f,r=a[j].s;\n    }\n    m+=r-l;\n    sum+=m*(M2[i+1]-M2[i]);\n  }\n  return sum;\n}\n\nint main(){\n  int n,T=1;\n  \n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i].f.f>>p[i].f.s>>p[i].s;\n    vector<double> a;\n    for(int i=0;i<n;i++){\n      a.push_back(p[i].f.s+p[i].s);\n      a.push_back(p[i].f.s-p[i].s);\n    }\n\n    sort(a.begin(),a.end());\n    M.clear();\n    M2.clear();\n    for(int i=0,cnt=0;i<a.size();i++){\n      assert(cnt<201);\n      if(!M.count(a[i]))M2[cnt]=a[i],M[a[i]]=cnt++;\n    }\n\n    for(int i=0;i<300;i++)Y[i].clear();\n\n    for(int i=0;i<n;i++){\n      double l=p[i].f.f-p[i].s,r=p[i].f.f+p[i].s;\n      Y[M[p[i].f.s-p[i].s]].push_back(Pd(P(l,r),1));\n      Y[M[p[i].f.s+p[i].s]].push_back(Pd(P(l,r),-1));\n    }\n    printf(\"%d %.2f\\n\",T++,calc());\n    \n  }\n  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid area(double bx, double by, double ux, double uy, bool b[201][201]) {\n\tFOR(i, bx, ux)\n\t\tFOR(j, by, uy)\n\t\t\tb[i][j] = true;\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n, cnt = 1;\n\twhile(cin >> n, n) {\n\t\tvector<double> x, y, bx, by, ux, uy;\n\t\tREP(i, n) {\n\t\t\tdouble x2, y2, r;\n\t\t\tcin >> x2 >> y2 >> r;\n\t\t\tx.pb(x2-r); x.pb(x2+r);\n\t\t\ty.pb(y2-r); y.pb(y2+r);\n\t\t\tbx.pb(x2-r); by.pb(y2-r);\n\t\t\tux.pb(x2+r); uy.pb(y2+r);\n\t\t}\n\t\tsort(x.begin(), x.end());\n\t\tsort(y.begin(), y.end());\n\n\t\tx.erase(unique(x.begin(), x.end()), x.end());\n\t\ty.erase(unique(y.begin(), y.end()), y.end());\n\n\t\tREP(i, n) {\n\t\t\tbx[i] = find(x.begin(), x.end(), bx[i]) - x.begin();\n\t\t\tby[i] = find(y.begin(), y.end(), by[i]) - y.begin();\n\t\t\tux[i] = find(x.begin(), x.end(), ux[i]) - x.begin();\n\t\t\tuy[i] = find(y.begin(), y.end(), uy[i]) - y.begin();\n\t\t}\n\n\t\tbool b[201][201] = {};\n\t\tREP(i, n)\n\t\t\tarea(bx[i], by[i], ux[i], uy[i], b);\n\n\t\tdouble sum = 0;\n\t\tREP(i, x.size()) REP(j, y.size())\n\t\t\tif(b[i][j])\n\t\t\t\tsum += (x[i+1] - x[i]) * (y[j+1] - y[j]);\n\n\t\tcout << fixed << setprecision(2) << cnt << ' ' << sum << endl;\n\n\t\tcnt++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tvoid set(double arg_left,double arg_right,double arg_top,double arg_under){\n\t\tleft = arg_left;\n\t\tright = arg_right;\n\t\ttop = arg_top;\n\t\tunder = arg_under;\n\t}\n\n\tdouble left,right,top,under;\n\tint left_index,right_index,top_index,under_index;\n};\n\nint N;\nint test_case = 1;\n\nbool check[206][206];\n\nvoid func(){\n\n\tInfo info[N];\n\tdouble x,y,r;\n\n\tvector<double> First_X,First_Y;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&x,&y,&r);\n\n\t\tinfo[i].set(x-r,x+r,y+r,y-r);\n\t\tFirst_X.push_back(x-r);\n\t\tFirst_X.push_back(x+r);\n\t\tFirst_Y.push_back(y+r);\n\t\tFirst_Y.push_back(y-r);\n\t}\n\n\tvector<double> Second_X,Second_Y;\n\n\tsort(First_X.begin(),First_X.end());\n\n\tdouble pre = -99999.0;\n\n\tfor(int i = 0; i < First_X.size(); i++){\n\t\tif(pre != First_X[i]){\n\t\t\tSecond_X.push_back(First_X[i]);\n\t\t}\n\t\tpre = First_X[i];\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < Second_X.size(); k++){\n\t\t\tif(info[i].left == Second_X[k]){\n\t\t\t\tinfo[i].left_index = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < Second_X.size(); k++){\n\t\t\tif(info[i].right == Second_X[k]){\n\t\t\t\tinfo[i].right_index = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(First_Y.begin(),First_Y.end());\n\n\tpre = -999999.0;\n\n\tfor(int i = 0; i < First_Y.size(); i++){\n\t\tif(pre != First_Y[i]){\n\t\t\tSecond_Y.push_back(First_Y[i]);\n\t\t}\n\t\tpre = First_Y[i];\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < Second_Y.size(); k++){\n\t\t\tif(info[i].top == Second_Y[k]){\n\t\t\t\tinfo[i].top_index = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < Second_Y.size(); k++){\n\t\t\tif(info[i].under == Second_Y[k]){\n\t\t\t\tinfo[i].under_index = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= 205; i++){\n\t\tfor(int k = 0; k <= 205; k++){\n\t\t\tcheck[i][k] = false;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int row = info[i].under_index; row <= info[i].top_index-1; row++){\n\t\t\tfor(int col = info[i].left_index; col <= info[i].right_index-1;col++){\n\t\t\t\tcheck[row][col] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans = 0.0,height,width;\n\n\tfor(int row = 0; row <= 205; row++){\n\t\theight = Second_Y[row+1]-Second_Y[row];\n\t\tfor(int col = 0; col <= 205; col++){\n\t\t\tif(check[row][col]){\n\t\t\t\twidth = Second_X[col+1]-Second_X[col];\n\t\t\t\tans += height*width;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d %.2lf\\n\",test_case,ans);\n\n\ttest_case++;\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, int> P;\n\nint main(){\n  int N;\n  int casenum = 1;\n  while(cin>>N && N){\n    printf(\"%d \", casenum++);\n    map<double, vector<P> > eventx;\n    map<double, vector<P> > delx;\n    set<double> searchx;\n    REP(i, N){\n      double x, y, d;\n      cin>>x>>y>>d;\n      searchx.insert(x - d);\n      searchx.insert(x + d);\n      eventx[x - d].push_back(P(y - d, 1));\n      eventx[x - d].push_back(P(y + d, -1));\n      delx[x + d].push_back(P(y - d, 1));\n      delx[x + d].push_back(P(y + d, -1));\n    }\n    set<P> evs;\n    double bfx = 0;\n    double bfy = 0;\n    double ans = 0;\n    FORIT(sx, searchx){\n      ans += (*sx - bfx) * bfy;\n      if(eventx.count(*sx)){\n        FORIT(it, eventx[*sx]) evs.insert(*it);\n      }\n      if(delx.count(*sx)){\n        FORIT(it, delx[*sx]) evs.erase(*it);\n      }\n      bfx = *sx;\n      bfy = 0;\n      int cnt = 0;\n      double ty = 0;\n      FORIT(event, evs){\n        if(cnt > 0){\n          bfy += (event->first - ty);\n        }\n        ty = event->first;\n        cnt += event->second;\n      }\n    }\n    printf(\"%.2lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define N 2002\n\nusing namespace std;\n\nclass Point{\npublic:\n  int x;\n  int y;\n  int r;\n};\n\nbool data[N][N];\nvoid syokika();\nint mx=N-1, my=N-1;\nmain(){\n  int n;\n  Point in[100];\n  for(int count=1;;count++){\n    cin >> n;\n    if(n==0) break;\n    double x, y, r;\n    my=-1;\n    mx=-1;\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> r;\n      x*=10;\n      y*=10;\n      r*=10;\n      int ix, iy, ir;\n      in[i].x=(int)x;\n      in[i].y=(int)y;\n      in[i].r=(int)r;\n      if(my<(in[i].y+in[i].r)) my=in[i].y+in[i].r;\n      if(mx<(in[i].x+in[i].r)) mx=in[i].x+in[i].r;\n    }\n    if(mx>=N) mx=N-1;\n    if(my>=N) my=N-1;\n    syokika();\n    for(int i=0;i<n;i++){\n      for(int a=in[i].y-in[i].r;a<=in[i].y+in[i].r;a++){\n\tfor(int b=in[i].x-in[i].r;b<=in[i].x+in[i].r;b++){\n\t  data[a][b]=true;\n\t}\n      }\n    }\n    int sum=0;\n    for(int i=0;i<=my;i++){\n      for(int j=0;j<=mx;j++){\n\tif(data[i][j]) sum++;\n      }\n    }\n    double ans=sum/100;\n    printf(\"%d %.2f\\n\", count, ans-1);\n  }\n  return 0;\n}\n\nvoid syokika(){\n  for(int i=0;i<=my;i++){\n    for(int j=0;j<=mx;j++){\n      data[i][j]=false;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ndouble unit = 1.0/(1<<13);\ntypedef complex<double> P;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint n,N=0;\n\twhile(cin >> n ,n){\n\t\tvector< pair<P,P> > data;\n\t\tdouble ans = 0;\n\t\trep(i,n){\n\t\t\tdouble a,b,r;\n\t\t\tcin >> a >> b >> r;\n\t\t\tdata.push_back(make_pair(P(a-r,b-r),P(a+r,b+r)));\n\t\t}\n\t\tfor(double x=-200;x<=200;x += unit){\n\t\t\tvector< pair<double,double> > L;\n\t\t\trep(i,n){\n\t\t\t\tif(data[i].first.real() <= x && x <= data[i].second.real()){\n\t\t\t\t\tL.push_back(make_pair(data[i].first.imag(),data[i].second.imag()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(L.size() == 0)continue;\n\t\t\tsort(L.begin(),L.end());\n\t\t\tdouble sz = 0;\n\t\t\tdouble cs = L[0].first, ce = L[0].second;\t\t\n\t\t\tfor(int i=1;i<L.size();i++){\n\t\t\t\tif(L[i].first <= ce)ce = max(ce,L[i].second);\n\t\t\t\telse sz += ce-cs , cs = L[i].first , ce = L[i].second;\n\t\t\t}\n\t\t\tsz += ce-cs;\n\t\t\tans += sz * unit;\n\t\t}\n\t\tprintf(\"%d %.2lf\\n\",++N,ans);\n\t}\n \n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\nvector<pair<pair<double, int> , Pd> > ls;\nbool use[300];\n\ndouble calc(vector<Pd> range){\n\tdouble res = 0.0;\n\tsort(range.begin(), range.end());\n\tint sz = range.size();\n\tdouble last = -1e10;\n\trep(i, sz){\n\t\tif(range[i].second > last){\n\t\t\tres += range[i].second - max(last, range[i].first);\n\t\t\tlast = range[i].second;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, sz;\n\tint cnt = 1;\n\t//ifstream in(\"input.txt\");\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\trep(i, n){\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tls.push_back(make_pair(make_pair(y - r, i), Pd(x - r, x + r)));\n\t\t\tls.push_back(make_pair(make_pair(y + r, i), Pd(x - r, x + r)));\n\t\t}\n\t\tsort(ls.begin(), ls.end());\n\t\tmemset(use, false, sizeof(use));\n\t\tsz = ls.size();\n\t\tdouble pre = -1e4;\n\t\tdouble res = 0.0;\n\t\trep(i, sz){\n\t\t\tint id = ls[i].first.second;\n\t\t\tdouble cur = ls[i].first.first;\n\t\t\tvector<Pd> range;\n\t\t\trep(i, sz){\n\t\t\t\tif(use[ls[i].first.second]) range.push_back(ls[i].second);\n\t\t\t}\n\t\t\tres += (cur - pre) * calc(range);\n\t\t\tpre = cur;\n\t\t\tuse[id] = !use[id];\n\t\t}\n\t\tstd::cout << cnt++ << \" \" << fixed << setprecision(2) << res << endl;\n\t}\n\t//in.close();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint W,H;\ndouble X1[222],Y1[222],X2[222],Y2[222];\nint sx1[222],sy1[222];\nint sx2[222],sy2[222];\nbool F[555][555];\ndouble dx[555],dy[555];\n\nconst double eps = 1e-10;\n\nint search( const vector<double>& ps, double x ){\n  for( int i=0;i<ps.size();i++ )\n     if( abs( ps[i] - x ) < eps ) return i;    \n  assert(false);\n  return -1;\n}\n\nint zip( double *Z1, double *Z2, int *z1, int *z2, double *d ){\n  vector<double> ps;\n  for(int i=0;i<N;i++){\n    ps.push_back( Z1[i] );\n    ps.push_back( Z2[i] );\n  }\n  sort( ps.begin(), ps.end() );\n  ps.erase( unique( ps.begin(), ps.end() ), ps.end() );\n  int w = ps.size();\n  for(int i=0;i<N;i++){\n    z1[i] = search( ps, Z1[i] );\n    z2[i] = search( ps, Z2[i] );\n  }\n  for(int i=0;i<w;i++){\n    d[i] = ps[i];\n  }\n  return w;\n}\n\nint main(){\n  int ttt=0;\n  while( ~scanf(\"%d\",&N) && N ){\n    memset( F,0,sizeof( F ) );\n    for(int i=0;i<N;i++){\n      double x,y,r; scanf(\"%lf%lf%lf\",&x,&y,&r);\n      X1[i] = x - r;\n      X2[i] = x + r;\n      Y1[i] = y - r;\n      Y2[i] = y + r;\n    }\n    W = zip( X1, X2, sx1, sx2, dx );\n    H = zip( Y1, Y2, sy1, sy2, dy );\n    for(int i=0;i<N;i++){\n      //cout << sx1[i] << \" - \" <<sx2[i] << endl;\n      //cout << sy1[i] << \" - \" <<sy2[i] << endl;\n      for(int x=sx1[i];x<sx2[i];x++){\n        for(int y=sy1[i];y<sy2[i];y++){\n          F[x][y] = true;\n        }\n      }\n    }\n    double res = 0.0;\n    for(int x=0;x<W;x++){\n      for(int y=0;y<H;y++){\n        if( F[x][y] ) {\n          //cout << dx[x+1]-dx[x] << \" * \" << dy[y+1]-dy[y] << endl;\n          res += ( dx[x+1]-dx[x] ) * ( dy[y+1]-dy[y] );      \n\n        }\n      }\n    }\n    printf(\"%d %.2lf\\n\",++ttt,res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nvoid input(int &val) {\n    double temp; cin >> temp;\n    val = temp*10+eps;\n}\nvoid input(int &x, int &y, int &r) {\n    input(x);\n    input(y);\n    input(r);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int id = 1;\n    int n;\n    cout << fixed << setprecision(2);\n    const int H = 6002, W = 6002;\n    while (cin >> n, n) {\n        vector< vector<int> > m(H, vector<int>(W, 0));\n        REP(i, n) {\n            int x, y, r;\n            input(x, y, r);\n            int x1 = x-r+2000, y1 = y-r+2000;\n            int x2 = x+r+2000, y2 = y+r+2000;\n            m[y1][x1]++; m[y2][x1]--;\n            m[y1][x2]--; m[y2][x2]++;\n        }\n        REP(x, W) REP(y, H-1) {\n            m[y+1][x] += m[y][x];\n        }\n        REP(y, H) REP(x, W-1) {\n            m[y][x+1] += m[y][x];\n        }\n        ll ans = 0;\n        REP(y, H-1) REP(x, W-1) {\n            if (m[y][x]) ++ans;\n        }\n        cout << id << \" \" << ans/100. << endl;\n        ++id;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=(int)b;i<(int)n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define eps 1e-10\nclass rec{\npublic:\n  double low,up,;\n  rec(){};\n  rec(double tl,double tu){low=tl;up=tu;}\n  bool operator<(const rec&a)const {\n    if ( !(abs(low-a.low)<eps))return low < a.low;\n    else return up < a.up;\n  }\n};\n\n\ndouble solve(vector<double> &kukan,vector<rec>  *data){\n  double ret= 0;\n  rep(i,kukan.size()){\n    double nowup=-100000,width=kukan[i];\n    double tmp=0;\n    rep(j,data[i].size()){\n      if ( data[i][j].up < nowup)continue;\n      else if ( nowup < data[i][j].low)tmp+=(data[i][j].up-data[i][j].low)*width;\n      else tmp+=(data[i][j].up-nowup)*width;\n      nowup=data[i][j].up;\n    }\n    ret+=tmp;\n  }\n  return ret;\n}\n\nvoid construct(double x1,double x2,double y1,double y2,vector<rec> *data,vector<double> &inx){\n  rep(i,inx.size()-1){\n    if ( x1-eps< inx[i] && inx[i+1]<x2+eps){\n      data[i].push_back(rec(y1,y2));\n    }\n  }\n  return;\n}\n\nmain(){\n  int n,tc=1;\n  while(cin>>n && n){\n    double x[n],y[n],r[n];\n    vector<double> inx,kukan;\n    set<double> S;\n    rep(i,n){\n      cin>>x[i]>>y[i]>>r[i];\n      if (S.find(x[i]-r[i]) ==S.end())S.insert(x[i]-r[i]),inx.push_back(x[i]-r[i]);\n      if (S.find(x[i]+r[i]) ==S.end())S.insert(x[i]+r[i]),inx.push_back(x[i]+r[i]);\n    }\n    //inx.push_back(0);//deleted\n    sort(inx.begin(),inx.end());\n    rep(i,inx.size()-1)kukan.push_back(inx[i+1]-inx[i]);\n    vector<rec> data[kukan.size()];\n\n    \n    rep(i,n)construct(x[i]-r[i],x[i]+r[i],y[i]-r[i],y[i]+r[i],data,inx);\n    rep(i,kukan.size())sort(data[i].begin(),data[i].end());\n\n    printf(\"%d %.2lf\\n\",tc++,solve(kukan,data));\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n};\n\nint main()\n{\n    int sequenceNum = 0;\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<double> x(2*n), y(2*n);\n        vector<Point> p1(n), p2(n);\n        for(int i=0; i<n; ++i){\n            double x0, y0, r;\n            cin >> x0 >> y0 >> r;\n            x[2*i] = p1[i].x = x0 - r;\n            x[2*i+1] = p2[i].x = x0 + r;\n            y[2*i] = p1[i].y = y0 - r;\n            y[2*i+1] = p2[i].y = y0 + r;\n        }\n        sort(x.begin(), x.end());\n        sort(y.begin(), y.end());\n\n        double ret = 0.0;\n        for(int i=0; i<2*n-1; ++i){\n            for(int j=0; j<2*n-1; ++j){\n                for(int k=0; k<n; ++k){\n                    if(p1[k].x <= x[i] && x[i+1] <= p2[k].x && p1[k].y <= y[j] && y[j+1] <= p2[k].y){\n                        ret += (y[j+1] - y[j]) * (x[i+1] - x[i]);\n                        break;\n                    }\n                }\n            }\n        }\n        printf(\"%d %.02f\\n\", ++sequenceNum, ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<double,int>P;\ntypedef pair<double,double>Pi;\ntypedef pair<Pi,int>PP;\nint main(){\n  int n,T=0;\n  while(cin>>n,n){\n    cout<<++T<<\" \";\n    double a[101],b[101],c[101];\n    vector<P> v;\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      v.push_back(P(b[i]-c[i],i));\n      v.push_back(P(b[i]+c[i],i));\n    }\n\n    sort(v.begin(),v.end());\n    double h=-1e9,w=0;\n    double ans=0;\n    vector<PP> s;\n    for(int i=0;i<v.size();i++){\n      bool f=1;\n      ans+=(v[i].first-h)*w,h=v[i].first;\n      for(int j=0;j<s.size();j++)\n\tif(s[j].second==v[i].second)s.erase(s.begin()+j),f=0;\n \n      if(f)s.push_back(PP(Pi(a[v[i].second]-c[v[i].second],a[v[i].second]+c[v[i].second]),v[i].second));\n \n      sort(s.begin(),s.end());\n      w=0;\n      if(s.size()){\n\tw=s[0].first.second-s[0].first.first;\n\tdouble pr=s[0].first.second;\n\t\n\t\n\tfor(int j=0;j<s.size();j++){\n\t  if(s[j].first.first<pr)w+=max(0.0,s[j].first.second-pr);\n\t  else w+=s[j].first.second-s[j].first.first;\n\t  pr=max(s[j].first.second,pr);\n\t}\n      }\n    }\n    printf(\"%.2f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n;\n  double xl[110],xr[110],yd[110],yu[110],x,y,r;\n  vector<double> h,w;\n  bool use[1000][1000];\n  int test = 1;\n\n  while(scanf(\"%d\",&n),n){\n    h.clear(); w.clear();\n\n    for(int i=0;i<n;i++){\n      scanf(\"%lf%lf%lf\",&x,&y,&r);\n      xl[i] = x-r; xr[i] = x+r;\n      yd[i] = y-r; yu[i] = y+r;\n      w.push_back(xl[i]); w.push_back(xr[i]);\n      h.push_back(yd[i]); h.push_back(yu[i]);\n    }\n\n    sort(h.begin(),h.end());\n    h.erase(unique(h.begin(),h.end()),h.end());\n    sort(w.begin(),w.end());\n    w.erase(unique(w.begin(),w.end()),w.end());\n\n    for(int i=0;i<n;i++){\n      xl[i] = lower_bound(w.begin(),w.end(),xl[i]) - w.begin();\n      xr[i] = lower_bound(w.begin(),w.end(),xr[i]) - w.begin();\n      yd[i] = lower_bound(h.begin(),h.end(),yd[i]) - h.begin();\n      yu[i] = lower_bound(h.begin(),h.end(),yu[i]) - h.begin();\n    }\n\n    for(int i=0;i<h.size();i++)\n      for(int j=0;j<w.size();j++)use[i][j] = false;\n\n    for(int i=0;i<n;i++){\n      for(int j=yd[i];j<yu[i];j++){\n\tfor(int k=xl[i];k<xr[i];k++){\n\t  use[j][k] = true;\n\t}\n      }\n    }\n    double ans = 0;\n    for(int i=0;i<h.size();i++){\n      for(int j=0;j<w.size();j++){\n\tif(use[i][j])ans += (h[i+1]-h[i])*(w[j+1]-w[j]);\n      }\n    }\n    printf(\"%d %.2lf\\n\",test++,ans);\n\n  }\n}\n    \n\n    \n      "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tdouble x;\n\tdouble y;\n\tdouble r;\n\tData(double _x,double _y,double _r){\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t}\n};\n\nbitset<64000000> stage;\n\nint main(){\n\tint n;\n\tint idx = 1;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tvector<Data> Points;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y,r;\n\t\t\tscanf(\"%lf %lf %lf\",&x,&y,&r);\n\t\t\tPoints.push_back(Data(x,y,r));\n\n\t\t\tint cx = x*10.0;\n\t\t\tint cy = y*10.0;\n\t\t\tint ra = r*10.0; \n\n\t\t\tfor(int dy= cy-ra;dy<cy+ra;dy++){\n\t\t\t\tfor(int dx = cx-ra;dx < cx+ra; dx++){\n\t\t\t\t\tstage[(dy+2000)*8000+(dx+2000)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %.2lf\\n\",idx++,stage.count()/(double)100);\t\t\n\t\tstage.reset();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<double,int>P;\ntypedef pair<double,double>Pi;\ntypedef pair<Pi,int>PP;\nint main(){\n  int n,T=0;\n  while(cin>>n,n){\n    cout<<++T<<\" \";\n    double a[101],b[101],c[101];\n    vector<P> v;\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      v.push_back(P(b[i]-c[i],i));\n      v.push_back(P(b[i]+c[i],i));\n    }\n    sort(v.begin(),v.end());\n    double h=-1e9,w=0;\n    double ans=0;\n    vector<PP> s;\n    for(int i=0;i<v.size();i++){\n      ans+=(v[i].first-h)*w,h=v[i].first;\n      bool f=1;\n      for(int j=0;j<s.size();j++)\n\tif(s[j].second==v[i].second)s.erase(s.begin()+j),f=0;\n\n      if(f)s.push_back(PP(Pi(a[v[i].second]-c[v[i].second],a[v[i].second]+c[v[i].second]),v[i].second));\n\n      sort(s.begin(),s.end());\n\n      w=s[0].first.second-s[0].first.first;\n      double pr=s[0].first.second;\n\n      for(int j=0;j<s.size();j++){\n\tif(s[j].first.first<pr)w+=max(0.0,s[j].first.second-pr);\n\telse w+=s[j].first.second-s[j].first.first;\n\tpr=max(s[j].first.second,pr);\n\n      }\n    }\n    printf(\"%.2f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n#include <map>\n\ndouble x[111],y[111],r[111];\nint g[300][300];\n\n\nint main(){\n    int cnt = 1;\n    int n;\n    while(cin>>n && n){\n        map<double,int> m1,m2;\n        vector<double> xs,ys;\n        rep(i,n){\n            cin>>x[i]>>y[i]>>r[i];\n            xs.eb(x[i]+r[i]);\n            xs.eb(x[i]-r[i]);\n            ys.eb(y[i]+r[i]);\n            ys.eb(y[i]-r[i]);\n        }\n        sort(all(xs));\n        sort(all(ys));\n        xs.erase(unique(all(xs)), xs.end());\n        ys.erase(unique(all(ys)), ys.end());\n        memset(g,0,sizeof(g));\n        rep(i,n){\n            int x1 = lower_bound(all(xs), x[i]-r[i])- xs.begin();\n            int x2 = lower_bound(all(xs), x[i]+r[i])- xs.begin();\n            int y1 = lower_bound(all(ys), y[i]-r[i])- ys.begin();\n            int y2 = lower_bound(all(ys), y[i]+r[i])- ys.begin();\n            g[y1][x1]++;\n            g[y1][x2]--;\n            g[y2][x1]--;\n            g[y2][x2]++;\n        }\n        rep(i,300) loop(j,1,300) g[i][j] += g[i][j-1];\n        loop(i,1,300) rep(j,300) g[i][j] += g[i-1][j];\n        rep(i,8){\n            rep(j,8){\n                cout << g[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        double ans = 0;\n        rep(i,ys.size()-1)rep(j,xs.size()-1){\n            if(g[i][j]){\n                double h = ys[i+1]-ys[i], w=xs[j+1]-xs[j];\n                dump(h,w);\n                ans += h*w;\n            }\n        }\n        printf(\"%d %.2lf\\n\", cnt++, ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nvoid input(int &val) {\n    double temp; cin >> temp;\n    val = temp*10+eps;\n}\nvoid input(int &x, int &y, int &r) {\n    input(x);\n    input(y);\n    input(r);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int id = 1;\n    int n;\n    cout << fixed << setprecision(2);\n    const int H = 6002, W = 6002;\n    while (cin >> n, n) {\n        vector< vector<short> > m(H, vector<char>(W, 0));\n        REP(i, n) {\n            int x, y, r;\n            input(x, y, r);\n            int x1 = x-r+2000, y1 = y-r+2000;\n            int x2 = x+r+2000, y2 = y+r+2000;\n            m[y1][x1]++; m[y2][x1]--;\n            m[y1][x2]--; m[y2][x2]++;\n        }\n        REP(x, W) REP(y, H-1) {\n            m[y+1][x] += m[y][x];\n        }\n        REP(y, H) REP(x, W-1) {\n            m[y][x+1] += m[y][x];\n        }\n        ll ans = 0;\n        REP(y, H-1) REP(x, W-1) {\n            if (m[y][x]) ++ans;\n        }\n        cout << id << \" \" << ans/100. << endl;\n        ++id;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(v) begin(v), end(v)\nbool mas[444][444];\n\nvoid color(int x, int y, int gx, int gy)\n{\n  mas[x][y] = true;\n  if(x+1 < gx) color(x+1, y, gx, gy);\n  if(y+1 < gy) color(x, y+1, gx, gy);\n}\n\nint main(){\n  int n;\n  int t = 0;\n  while(cin >> n, n) {\n    t++;\n    memset(mas, false, sizeof(mas));\n    vector<double> xx, yy;\n    vector<double> X, Y;\n    rep(i, n) {\n      double x, y, r;\n      cin >> x >> y >> r;\n      xx.push_back(x - r);\n      xx.push_back(x + r);\n      yy.push_back(y - r);\n      yy.push_back(y + r);\n      X.push_back(x - r);\n      X.push_back(x + r);\n      Y.push_back(y - r);\n      Y.push_back(y + r);\n    }\n    sort(all(X)); \n    sort(all(Y));\n    X.erase(unique(all(X)), X.end());\n    Y.erase(unique(all(Y)), Y.end());\n    for(int i = 0; i < (int)xx.size(); i+=2) {\n      xx[i] = find(all(X), xx[i]) - begin(X);\n      yy[i] = find(all(Y), yy[i]) - begin(Y);\n      xx[i+1] = find(all(X), xx[i+1]) - begin(X);\n      yy[i+1] = find(all(Y), yy[i+1]) - begin(Y);\n      color(xx[i], yy[i], xx[i+1], yy[i+1]);\n    }\n    /*//\n    rep(i, Y.size()) {\n      rep(j, X.size()) cout << (int)mas[j][i];\n      cout << endl;\n    }\n    //*/\n    double ans = 0;\n    rep(i, X.size()-1) rep(j, Y.size()-1) {\n      if(!mas[i][j]) continue;\n      ans += (X[i+1]-X[i]) * (Y[j+1]-Y[j]);\n      //cout << X[i+1] << \" \" << X[i] <<  \" \" << Y[j+1] << \" \" << Y[j] << endl;\n    }\n    printf(\"%d %.2f\\n\", t, ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<P,double> Pd;\nPd p[101];\nmap <double,int> M;\nmap <int,double> M2;\nvector <Pd> Y[301];\n\n\ndouble calc(){\n  double sum=0;\n  vector <P> a;\n  for(int i=0;M2.count(i+1);i++){\n    sort(a.begin(),a.end());\n\n    for(int j=0;j<Y[i].size();j++)\n      if(Y[i][j].s==1)a.push_back(Y[i][j].f);\n      else a.erase(lower_bound(a.begin(),a.end(),Y[i][j].f));\n    \n    sort(a.begin(),a.end());\n    \n    double l=-1e9,r=-1e9,m=0;\n    for(int j=0;j<a.size();j++){\n      if(a[j].f<r)r=max(r,a[j].s);\n      else m+=r-l,l=a[j].f,r=a[j].s;\n    }\n    m+=r-l;\n    sum+=m*(M2[i+1]-M2[i]);\n  }\n  return sum;\n}\n\nint main(){\n  int n,T=1;\n  \n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i].f.f>>p[i].f.s>>p[i].s;\n    vector<double> a;\n    for(int i=0;i<n;i++){\n      a.push_back(p[i].f.s+p[i].s);\n      a.push_back(p[i].f.s-p[i].s);\n    }\n\n    sort(a.begin(),a.end());\n    M.clear();\n    M2.clear();\n    for(int i=0,cnt=0;i<a.size();i++)if(!M.count(a[i]))M2[cnt]=a[i],M[a[i]]=cnt++;\n\n    for(int i=0;i<300;i++)Y[i].clear();\n\n    for(int i=0;i<n;i++){\n      double l=p[i].f.f-p[i].s,r=p[i].f.f+p[i].s;\n      Y[M[p[i].f.s-p[i].s]].push_back(Pd(P(l,r),1));\n      Y[M[p[i].f.s+p[i].s]].push_back(Pd(P(l,r),-1));\n    }\n    double ans=(int)(calc()*100);\n    printf(\"%d %.2f\\n\",T++,ans/100.0);\n    \n  }\n  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n};\nclass Circle {\npublic:\n\tPoint p; ld r;\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\treturn lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n\t}\n}\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n//直線lに幅dをつける\nvector<Line> make_w(Line l, ld d) {\n\tPoint dif = l.b - l.a;\n\tdif = dif*Point{0, 1};\n\tdif = dif * (d / abs(dif));\n\tvector<Line> ret;\n\tfor (int id = 1; id >= -1; id -= 2) {\n\t\tPoint a = l.a + dif * (ld)id;\n\t\tPoint b = l.b + dif * (ld)id;\n\t\tret.push_back({ a,b });\n\t}\n\treturn ret;\n}\n\ntypedef vector<Point> polygon;\npolygon ConvexHull(polygon p) {\n\tint n = p.size();\n\tint k = 0;\n\tsort(p.begin(), p.end());\n\tpolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = p[i++]) {\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], p[i]) <= 0)--k;\n\t}\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], p[i]) <= 0)--k;\n\t}\n\tch.resize(k - 1);\n\treturn ch;\n}\npolygon convex_cut(const polygon &p, Line l) {\n\tvector<Point> ret;\n\trep(i, p.size()) {\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.a, l.b, a) != -1)ret.push_back(a);\n\t\tif (ccw(l.a, l.b, a)*ccw(l.a, l.b, b)<0) {\n\t\t\tret.push_back(is_ll({ a,b }, l));\n\t\t}\n\t}\n\treturn ret;\n}\nld area(const polygon &p){\n\tld ret = 0;\n\tint n = p.size();\n\trep(j, n)ret += cross(p[j], p[(j + 1) % n]);\n\treturn ret / 2.0;\n}\nld max_distance(const polygon &p) {\n\t//assert(p.size()>1);\n\tpolygon g = ConvexHull(p);\n\tint n = g.size(), a = 0, b = 1;\n\tld ret = abs(g[0] - g[1]);\n\twhile (a < n) {\n\t\tPoint p1 = g[a%n], p2 = g[(a + 1) % n];\n\t\tPoint q1 = g[b%n], q2 = g[(b + 1) % n];\n\t\tif (arg((p2 - p1) / (q1 - q2)) > 0)++b; else ++a;\n\t\tret = max(ret, abs(p1 - q1));\n\t}\n\treturn ret;\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2 * d);\n\tld dfr = c1.r*c1.r - rc * rc;\n\tif (abs(dfr) < eps)dfr = 0.0;\n\tif (dfr < 0.0)return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0)res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\nbool in_Circle(Circle a, Circle b) {\n\tld dist = abs(b.p - a.p);\n\treturn dist < b.r - a.r+eps;\n}\n\nint n;\nvoid solve() {\n\tvector<pair<pair<ld,int>, LDP>> v;\n\trep(i, n) {\n\t\tld x, y, r; cin >> x >> y >> r;\n\t\tv.push_back({ {x - r,0},{y - r,y + r} });\n\t\tv.push_back({ {x + r,1},{y - r,y + r} });\n\t}\n\tsort(v.begin(), v.end());\n\tvector<pair<LDP,int>> u;\n\tld ans = 0;\n\tld loc = -1;\n\trep(i, v.size()) {\n\t\t//cout << i << endl;\n\t\tif (i > 0&&v[i].first.first!=v[i-1].first.first) {\n\t\t\tld sum = 0;\n\t\t\trep(j, u.size()) {\n\t\t\t\tsum += u[j].first.second - u[j].first.first;\n\t\t\t}\n\t\t\t//cout << sum << \" \" << v[i].first.first - loc << endl;\n\t\t\tans += sum * (v[i].first.first - loc);\n\t\t}\n\t\tint id = v[i].first.second;\n\t\tld l = v[i].second.first, r = v[i].second.second;\n\t\tif (id == 0) {\n\t\t\tvector<LDP> used;\n\t\t\tint len = u.size();\n\t\t\trep(j, len) {\n\t\t\t\tld la = u[j].first.first, lb = u[j].first.second;\n\t\t\t\tif (min(lb, r) > max(la, l)) {\n\t\t\t\t\tif (la < l) {\n\t\t\t\t\t\tu[j].first.first = l;\n\t\t\t\t\t\tu.push_back({ {la,l},u[j].second });\n\t\t\t\t\t}\n\t\t\t\t\tif (r<lb) {\n\t\t\t\t\t\tu[j].first.second = r;\n\t\t\t\t\t\tu.push_back({ {r,lb},u[j].second });\n\t\t\t\t\t}\n\t\t\t\t\tu[j].second++;\n\t\t\t\t\tused.push_back({ la,lb });\n\t\t\t\t}\n\t\t\t}\n\t\t\tld cur = l;\n\t\t\trep(j, used.size()) {\n\t\t\t\tld a = used[j].first, b = used[j].second;\n\t\t\t\tif (a > cur) {\n\t\t\t\t\tu.push_back({ {cur,a},1 });\n\t\t\t\t}\n\t\t\t\tcur = used[j].second;\n\t\t\t}\n\t\t\tif (r >cur) {\n\t\t\t\tu.push_back({ {cur,r},1 });\n\t\t\t}\n\t\t\tsort(u.begin(), u.end());\n\t\t}\n\t\telse {\n\t\t\trep(j, u.size()) {\n\t\t\t\tld la = u[j].first.first, lb = u[j].first.second;\n\t\t\t\tif (min(lb, r) > max(la, l)) {\n\t\t\t\t\tu[j].second--;\n\t\t\t\t\t//cout << u[j].first.first << \" \" << u[j].first.second << \" \" << u[j].second << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = (int)u.size() - 1; j >= 0; j--) {\n\t\t\t\tif (u[j].second == 0)u.erase(u.begin() + j);\n\t\t\t}\n\t\t}\n\t\tloc = v[i].first.first;\n\t\t//rep(j, u.size())cout << u[j].first.first << \" \" << u[j].first.second << \" \"<<u[j].second<<endl;\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(2);\n\tint t = 1;\n\twhile (cin >> n, n) {\n\t\tcout << t << \" \";\n\t\tsolve();\n\t\tt++;\n\t}\n\t//solve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define N 2001\n\nusing namespace std;\n\nclass Point{\npublic:\n  int x;\n  int y;\n  int r;\n};\n\nbool data[N][N];\nvoid syokika();\nint mx=N, my=N;\nmain(){\n  int n;\n  Point in[100];\n  for(int count=1;;count++){\n    cin >> n;\n    if(n==0) break;\n    double x, y, r;\n    my=-1;\n    mx=-1;\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> r;\n      x*=10;\n      y*=10;\n      r*=10;\n      int ix, iy, ir;\n      in[i].x=(int)x;\n      in[i].y=(int)y;\n      in[i].r=(int)r;\n      if(my<(in[i].y+in[i].r)) my=in[i].y+in[i].r;\n      if(mx<(in[i].x+in[i].r)) mx=in[i].x+in[i].r;\n    }\n    if(mx>N) mx=N;\n    if(my>N) my=N;\n    syokika();\n    for(int i=0;i<n;i++){\n      for(int a=in[i].y-in[i].r;a<=in[i].y+in[i].r;a++){\n\tfor(int b=in[i].x-in[i].r;b<=in[i].x+in[i].r;b++){\n\t  data[a][b]=true;\n\t}\n      }\n    }\n    int sum=0;\n    for(int i=0;i<=my;i++){\n      for(int j=0;j<=mx;j++){\n\tif(data[i][j]) sum++;\n      }\n    }\n    double ans=sum/100;\n    printf(\"%d %.2f\\n\", count, ans-1);\n  }\n  return 0;\n}\n\nvoid syokika(){\n  for(int i=0;i<my;i++){\n    for(int j=0;j<mx;j++){\n      data[i][j]=false;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n};\nEvent evs[1001];\nRect recs[1001];\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  vector<int> ls,rs;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int par=find(x);\n    ls[par]=l;\n    rs[par]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    int NN=0;\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      if(EQ(r,0))continue;\n      recs[NN].first=P(x-r,y-r);\n      recs[NN].second=P(x+r,y+r);\n      evs[2*NN]=Event(y-r,true,i);\n      evs[2*NN+1]=Event(y+r,false,i);\n      NN++;\n    }\n    sort(evs,evs+2*NN);\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    // yÌ¬³¢ÔÉCxgð\n    for(int i=0;i<2*NN;i++){\n      Event &e=evs[i];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      prvy=e.y;\n      // _ÌÇÁAí\n      if(e.isIn)v.push_back(e.id);\n      else v.erase(find(v.begin(),v.end(),e.id));\n      // ¡ñÌ¡ðvZ\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  // ÍÍª©Ôéæ¤ÈçÎAunite\n\t  if((EQ(uft.rs[uft.find(i)],uft.ls[uft.find(j)])\n\t      ||(uft.rs[uft.find(i)]>uft.ls[uft.find(j)]))\n\t     &&(EQ(uft.ls[uft.find(i)],uft.rs[uft.find(j)])\n\t\t||(uft.ls[uft.find(i)]<uft.rs[uft.find(j)]))){\n\t    double minx=min(uft.ls[uft.find(i)]\n\t\t\t    ,uft.ls[uft.find(j)]);\n\t    double maxx=max(uft.rs[uft.find(i)]\n\t\t\t    ,uft.rs[uft.find(j)]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    printf(\"%d %.2f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n#include <map>\n\ndouble x[111],y[111],r[111];\nint g[300][300];\n\n\nint main(){\n    int cnt = 1;\n    int n;\n    while(cin>>n && n){\n        map<double,int> m1,m2;\n        vector<double> xs,ys;\n        rep(i,n){\n            cin>>x[i]>>y[i]>>r[i];\n            xs.eb(x[i]+r[i]);\n            xs.eb(x[i]-r[i]);\n            ys.eb(y[i]+r[i]);\n            ys.eb(y[i]-r[i]);\n        }\n        sort(all(xs));\n        sort(all(ys));\n        xs.erase(unique(all(xs)), xs.end());\n        ys.erase(unique(all(ys)), ys.end());\n        memset(g,0,sizeof(g));\n        rep(i,n){\n            int x1 = lower_bound(all(xs), x[i]-r[i])- xs.begin();\n            int x2 = lower_bound(all(xs), x[i]+r[i])- xs.begin();\n            int y1 = lower_bound(all(ys), y[i]-r[i])- ys.begin();\n            int y2 = lower_bound(all(ys), y[i]+r[i])- ys.begin();\n            g[y1][x1]++;\n            g[y1][x2]--;\n            g[y2][x1]--;\n            g[y2][x2]++;\n        }\n        rep(i,300) loop(j,1,300) g[i][j] += g[i][j-1];\n        loop(i,1,300) rep(j,300) g[i][j] += g[i-1][j];\n        // rep(i,8){\n        //     rep(j,8){\n        //         cout << g[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        double ans = 0;\n        rep(i,ys.size()-1)rep(j,xs.size()-1){\n            if(g[i][j]){\n                double h = ys[i+1]-ys[i], w=xs[j+1]-xs[j];\n                dump(h,w);\n                ans += h*w;\n            }\n        }\n        printf(\"%d %.2lf\\n\", cnt++, ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\nvector<pair<pair<double, int> , Pd> > ls;\nbool use[300];\n\ndouble calc(vector<Pd> range){\n\tdouble res = 0.0;\n\tsort(range.begin(), range.end());\n\tbool update = true;\n\tint sz = range.size();\n\twhile(update){\n\t\tupdate = false;\n\t\tint c = 0;\n\t\trep(i, sz){\n\t\t\tif(i == sz - 1){\n\t\t\t\trange[c++] = range[i];\n\t\t\t}else if(range[i].second < range[i+1].first){\n\t\t\t\trange[c++] = range[i];\n\t\t\t}else{\n\t\t\t\trange[c++] = Pd(min(range[i].first, range[i+1].first), max(range[i].second, range[i+1].second));\n\t\t\t\ti++;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\tsz = c;\n\t\trange.resize(sz);\n\t}\n\n\trep(i, sz){\n\t\tres += range[i].second - range[i].first;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, sz;\n\tint cnt = 1;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\trep(i, n){\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tls.push_back(make_pair(make_pair(y - r, i), Pd(x - r, x + r)));\n\t\t\tls.push_back(make_pair(make_pair(y + r, i), Pd(x - r, x + r)));\n\t\t}\n\t\tsort(ls.begin(), ls.end());\n\t\tmemset(use, false, sizeof(use));\n\t\tsz = ls.size();\n\t\tdouble pre = -1e4;\n\t\tdouble res = 0.0;\n\t\trep(i, sz){\n\t\t\tint id = ls[i].first.second;\n\t\t\tdouble cur = ls[i].first.first;\n\t\t\tvector<Pd> range;\n\t\t\trep(i, sz){\n\t\t\t\tif(use[i]) range.push_back(ls[i].second);\n\t\t\t}\n\t\t\tres += (cur - pre) * calc(range);\n\t\t\tpre = cur;\n\t\t\tuse[id] = !use[id];\t\t\t\n\t\t}\n\t\tcout << cnt++ << \" \" << fixed << setprecision(2) << (int)(res * 100 + 0.5) / 100.0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<double,int>P;\ntypedef pair<double,double>Pi;\ntypedef pair<Pi,int>PP;\nint main(){\n  int n,T=0;\n  while(cin>>n,n){\n    cout<<++T<<\" \";\n    double a[101],b[101],c[101];\n    vector<P> v;\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      v.push_back(P(b[i]-c[i],i));\n      v.push_back(P(b[i]+c[i],-i));\n    }\n    sort(v.begin(),v.end());\n    double h=-1e9,w=0;\n    double ans=0;\n    vector<PP> s;\n    for(int i=0;i<v.size();i++){\n      ans+=(v[i].first-h)*w,h=v[i].first;\n      bool f=1;\n      for(int j=0;j<s.size();j++)\n\tif(s[j].second==-v[i].second)s.erase(s.begin()+j),f=0;\n \n      if(f)s.push_back(PP(Pi(a[v[i].second]-c[v[i].second],a[v[i].second]+c[v[i].second]),v[i].second));\n \n      sort(s.begin(),s.end());\n \n      w=s[0].first.second-s[0].first.first;\n      double pr=s[0].first.second;\n \n      for(int j=0;j<s.size();j++){\n\tif(s[j].first.first<pr)w+=max(0.0,s[j].first.second-pr);\n\telse w+=s[j].first.second-s[j].first.first;\n\tpr=max(s[j].first.second,pr);\n \n      }\n    }\n    printf(\"%.2f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#define DIF 5000\n#define all(n) n.begin(),n.end()\nusing namespace std;\n\nvoid draw(vector<vector<bool> >& graph,int sx,int sy,int ex,int ey)\n{\n  for(int i=sy;i<ey;i++)\n    for(int j=sx;j<ex;j++)\n      graph[i][j] = true;\n}\n\nint main()\n{\n  int n,NARI = 1;\n  while(cin >> n,n)\n    {      \n      vector<int> X,Y,X1,X2,Y1,Y2;\n      vector<vector<bool> > graph;\n      graph.resize(310);\n\n      for(int i=0;i<310;i++)\n\t{\n\t  graph[i].resize(310);\n\t  for(int j=0;j<310;j++)\n\t    graph[i][j] = false;\n\t}\n\n      for(int i=0;i<n;i++)\n\t{\n\t  double x,y,r;\n\t  cin >> x >> y >> r;\n\t  X.push_back(x+r),X.push_back(x-r);\n\t  Y.push_back(y+r),Y.push_back(y-r);\n\t  X1.push_back(x-r),Y1.push_back(y-r);\n\t  X2.push_back(x+r),Y2.push_back(y+r);\n\t}\n      sort(all(X));\n      sort(all(Y));\n      X.erase(unique(all(X)),X.end());\n      Y.erase(unique(all(Y)),Y.end());\n\n      for(int i=0;i<n;i++)\n\t{\n\n\t  X1[i] = find(all(X),X1[i]) - X.begin();\n\t  Y1[i] = find(all(Y),Y1[i]) - Y.begin();\n\n\t  X2[i] = find(all(X),X2[i]) - X.begin();\n\t  Y2[i] = find(all(Y),Y2[i]) - Y.begin();\n\n\t}\n\n      for(int i=0;i<n;i++)\n\t  draw(graph,X1[i],Y1[i],X2[i],Y2[i]);\n\n      double ans = 0;\n      for(int i=0;i<Y.size();i++)\n\tfor(int j=0;j<X.size();j++)\n\t  if(graph[i][j])\n\t      ans += (X[j+1]-X[j])*(Y[i+1]-Y[i]);\n\t    \n\t  \t    \n      cout << NARI++ << setiosflags(ios::fixed) << setprecision(2)<< \" \" << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<tuple>\n#include<map>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum {Y, FLAG, X1, X2};\nenum {TOP, BOTTOM};\n\n#define EDGE tuple<double, int, double, double>\n#define SQUARE tuple<double, double, double>\n\nbool touch(SQUARE s1, SQUARE s2) {\n    double x1, y1, r1;\n    double x2, y2, r2;\n    x1 = get<0>(s1), y1= get<1>(s1), r1 = get<2>(s1);\n    x2 = get<0>(s2), y2= get<1>(s2), r2 = get<2>(s2);\n    bool intersectH = ((x1-r1)-(x2+r2)) * ((x1+r1)-(x2-r2)) < 0.0;\n    bool intersectV = ((y1-r1)-(y2+r2)) * ((y1+r1)-(y2-r2)) < 0.0;\n    return intersectH && intersectV;\n}\n\ntemplate<class T>\nclass DisjointSet {\npublic:\n    map<T, T> parent;\n    map<T, int> rank;\n    void make(T node) {\n        parent[node] = node;\n        rank[node] = 0;\n    }\n    T find(T node) {\n        return node == parent[node] ? parent[node] : parent[node] = find(parent[node]);\n    }\n    void link(T node1, T node2) {\n        if(rank[node1] < rank[node2]) swap(node1, node2);\n        parent[node2] = node1;\n        if(rank[node1] == rank[node2]) rank[node1]++;\n    }\n    void unite(T node1, T node2) {\n        link(find(node1), find(node2));\n    }\n};\n\nint main() {\n    int data = 0;\n    int n;\n    while(cin>>n, n) {\n        data++;\n        vector<SQUARE> square;\n        DisjointSet<int> s;\n        set<int> group;\n        for(int i=0; i<n; i++) {\n            double x, y, r;\n            cin>>x>>y>>r;\n            square.push_back(SQUARE(x, y, r));\n            s.make(i);\n        }\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(i == j) continue;\n                if(touch(square[i], square[j])) s.unite(i, j);\n            }\n        }\n\n        for(int i=0; i<n; i++) {\n            group.insert(s.find(i));\n        }\n\n        double area = 0.0;\n        for(auto it=group.begin(); it != group.end(); it++) {\n            vector<EDGE> edge;\n            for(int i=0; i<n; i++) {\n                if(s.find(i) != *it) continue;\n                double x, y, r;\n                x = get<1>(square[i]);\n                y = get<0>(square[i]);\n                r = get<2>(square[i]);\n                edge.push_back(EDGE(y-r, TOP, x-r, x+r));\n                edge.push_back(EDGE(y+r, BOTTOM, x-r, x+r));\n            }\n            sort(edge.begin(), edge.end());\n            vector<double> point;\n            point.push_back(get<X1>(edge[0]));\n            point.push_back(get<X2>(edge[0]));\n            for(int i=1; i<edge.size(); i++) {\n                double w, h;\n                w = *max_element(point.begin(), point.end()) - *min_element(point.begin(), point.end());\n                h = get<Y>(edge[i]) - get<Y>(edge[i-1]);\n                area += w * h;\n                double x1, x2;\n                x1 = get<X1>(edge[i]);\n                x2 = get<X2>(edge[i]);\n                if(get<FLAG>(edge[i]) == TOP) {\n                    point.push_back(x1);\n                    point.push_back(x2);\n                } else {\n                    point.erase(find(point.begin(), point.end(), x1));\n                    point.erase(find(point.begin(), point.end(), x2));\n                }\n            }\n        }\n        cout<<setiosflags(ios::fixed)<<setprecision(2)<<data<<\" \"<<area<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\nvector<pair<pair<double, int> , Pd> > ls;\nbool use[300];\n\ndouble calc(vector<Pd> range){\n\tdouble res = 0;\n\tsort(range.begin(), range.end());\n\trep(i, (int)range.size() - 1){\n\t\tif(range[i+1].second > range[i].second){\n\t\t\tres += range[i+1].second - max(range[i+1].first, range[i].second);\n\t\t}else{\n\t\t\trange[i+1].second = range[i].second;\n\t\t}\n\t}\n\tif(!range.empty()){\n\t\tres += range[0].second - range[0].first;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, sz;\n\tint cnt = 1;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\trep(i, n){\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tls.push_back(make_pair(make_pair(y - r, i), Pd(x - r, x + r)));\n\t\t\tls.push_back(make_pair(make_pair(y + r, i), Pd(x - r, x + r)));\n\t\t}\n\t\tsort(ls.begin(), ls.end());\n\t\tmemset(use, false, sizeof(use));\n\t\tsz = ls.size();\n\t\tdouble pre = -1e4;\n\t\tdouble res = 0.0;\n\t\trep(i, sz){\n\t\t\tint id = ls[i].first.second;\n\t\t\tdouble cur = ls[i].first.first;\n\t\t\tvector<Pd> range;\n\t\t\trep(i, sz){\n\t\t\t\tif(use[i]) range.push_back(ls[i].second);\n\t\t\t}\n\t\t\tres += (cur - pre) * calc(range);\n\t\t\tpre = cur;\n\t\t\tuse[id] = !use[id];\t\t\t\n\t\t}\n\t\tcout << cnt++ << \" \" << fixed << setprecision(2) << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct interval{\n\tT a,b;\n\tint id;\n\tbool operator<(const interval &I)const{ return a+EPS<I.a || abs(a-I.a)<EPS && b+EPS<I.b; }\n};\n\ndouble calc_width(vector< interval<double> > &I){\n\tint n=I.size();\n\tif(n==0) return 0;\n\tsort(I.begin(),I.end());\n\n\tdouble res=0;\n\tdouble left=I[0].a,right=I[0].b;\n\trep(i,n){\n\t\tif(right+EPS<I[i].a){\n\t\t\tres+=right-left;\n\t\t\tleft=I[i].a;\n\t\t}\n\t\telse{\n\t\t\tright=max(right,I[i].b);\n\t\t}\n\t}\n\tres+=right-left;\n\n\treturn res;\n}\n\nint main(){\n\tfor(int test=1,n;scanf(\"%d\",&n),n;test++){\n\t\tvector< pair< double,interval<double> > > E;\n\t\trep(i,n){\n\t\t\tdouble x,y,r; scanf(\"%lf%lf%lf\",&x,&y,&r);\n\t\t\tE.push_back(make_pair(y-r,(interval<double>){x-r,x+r,i}));\n\t\t\tE.push_back(make_pair(y+r,(interval<double>){x-r,x+r,i}));\n\t\t}\n\t\tsort(E.begin(),E.end());\n\n\t\tvector< interval<double> > I;\n\t\tdouble ans=0,h=0,w=0;\n\t\tbool b[100]={}; // b[i] := ( 正方形 i に対応する区間を見ているかどうか )\n\t\trep(t,E.size()){\n\t\t\tinterval<double> J=E[t].second;\n\t\t\tif(!b[J.id]){\n\t\t\t\tI.push_back(J);\n\t\t\t\tb[J.id]=true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(i,I.size()) if(I[i].id==J.id) { I.erase(I.begin()+i); break; }\n\t\t\t\tb[J.id]=false;\n\t\t\t}\n\n\t\t\tans+=(E[t].first-h)*w;\n\t\t\th=E[t].first;\n\t\t\tw=calc_width(I);\n\t\t}\n\n\t\tprintf(\"%d %.2f\\n\",test,ans+EPS);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tdouble x;\n\tdouble y;\n\tdouble r;\n\tData(double _x,double _y,double _r){\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t}\n};\n\nbitset<6400000000LL> stage;\n\nint main(){\n\tint n;\n\tint idx = 1;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tvector<Data> Points;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y,r;\n\t\t\tscanf(\"%lf %lf %lf\",&x,&y,&r);\n\t\t\tPoints.push_back(Data(x,y,r));\n\n\t\t\tint cx = x*100.0;\n\t\t\tint cy = y*100.0;\n\t\t\tint ra = r*100.0; \n\n\t\t\tfor(ll dy= cy-ra;dy<cy+ra;dy++){\n\t\t\t\tfor(ll dx = cx-ra;dx < cx+ra; dx++){\n\t\t\t\t\tstage[(dy+20000)*80000+(dx+20000)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %.2lf\\n\",idx++,stage.count()/(double)10000);\t\t\n\t\tstage.reset();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int N, tc = 1;\n    while (cin >> N, N) {\n        vector<double> X1(N), Y1(N), X2(N), Y2(N);\n        vector<double> xs, ys;\n        for (int i = 0; i < N; i++) {\n            double x, y, r;\n            cin >> x >> y >> r;\n            X1[i] = x - r; Y1[i] = y - r;\n            X2[i] = x + r; Y2[i] = y + r;\n            xs.push_back(X1[i]); xs.push_back(X2[i]);\n            ys.push_back(Y1[i]); ys.push_back(Y2[i]);\n        }\n\n        sort(xs.begin(), xs.end());\n        xs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n        sort(ys.begin(), ys.end());\n        ys.erase(unique(ys.begin(), ys.end()), ys.end());\n        \n        double res = 0;\n        for (int i = 0; i < (int)xs.size()-1; i++) {\n            for (int j = 0; j < (int)ys.size()-1; j++) {\n                int cnt = 0;\n                for (int k = 0; k < N; k++) {\n                    if (X1[k] <= xs[i] && xs[i+1] <= X2[k] &&\n                        Y1[k] <= ys[j] && ys[j+1] <= Y2[k]) {\n                        cnt++;\n                    }\n                }\n                if (cnt > 0) {\n                    res += (xs[i+1] - xs[i]) * (ys[j+1] - ys[j]);\n                }\n            }\n        } \n        printf(\"%d %.10f\\n\", tc++, res);\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define N 8001\n\nusing namespace std;\n\nclass Point{\npublic:\n  int x;\n  int y;\n  int r;\n};\n\nbool data[N][N];\nvoid syokika();\nint mx, my, Mx, My;\nmain(){\n  int n;\n  Point in[100];\n  for(int count=1;;count++){\n    cin >> n;\n    if(n==0) break;\n    double x, y, r;\n    My=-1;\n    Mx=-1;\n    my=9000;\n    mx=9000;\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> r;\n      x*=10;\n      y*=10;\n      r*=10;\n      int ix, iy, ir;\n      in[i].x=(int)x;\n      in[i].y=(int)y;\n      in[i].r=(int)r;\n      if(My<(in[i].y+in[i].r)) My=in[i].y+in[i].r;\n      if(Mx<(in[i].x+in[i].r)) Mx=in[i].x+in[i].r;\n      if(my>(in[i].y-in[i].r)) my=in[i].y-in[i].r;\n      if(mx>(in[i].x-in[i].r)) mx=in[i].x-in[i].r;\n    }\n    syokika();\n    for(int i=0;i<n;i++){\n      for(int a=in[i].y-in[i].r+4000;a<in[i].y+in[i].r+4000;a++){\n\tfor(int b=in[i].x-in[i].r+4000;b<in[i].x+in[i].r+4000;b++){\n\t  data[a][b]=true;\n\t}\n      }\n    }\n    int sum=0;\n    for(int i=my+4000;i<My+4000;i++){\n      for(int j=mx+4000;j<Mx+4000;j++){\n\tif(data[i][j]) sum++;\n      }\n    }\n    double ans=sum/100.0;\n    printf(\"%d %.2f\\n\", count, ans);\n  }\n  return 0;\n}\n\nvoid syokika(){\n  for(int i=my+4000;i<=My+4000;i++){\n    for(int j=mx+4000;j<=Mx+4000;j++){\n      data[i][j]=false;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nvector<double> xv,yv,rv;\n\nint main() {\n    int n,tc = 1;\n    double x,y,r;\n    while(cin>>n, n) {\n        xv.clear(); yv.clear(); rv.clear();\n        priority_queue<double, vector<double>, greater<double> > q;\n        for(int i=0; i<n; ++i) {\n            cin>>x>>y>>r;\n            xv.push_back(x); yv.push_back(y); rv.push_back(r);\n            q.push(x-r); q.push(x+r);\n        }\n\n        x = q.top();\n        double ans = 0;\n        while(!q.empty()) {\n            double nx = q.top(); q.pop();\n            double ll = -(1<<29);\n\n            vector<pair<double,double> > rrv;\n            for(int i=0; i<n; ++i)\n                if(xv[i]-rv[i] < nx && xv[i]+rv[i] >= nx)\n                    rrv.push_back(make_pair(yv[i]-rv[i],yv[i]+rv[i]));\n\n            sort(rrv.begin(), rrv.end());\n\n            if(rrv.size() == 0) continue;\n            double len = 0;\n            for(int i=0; i<rrv.size(); ++i) {\n                len += max(0.0, rrv[i].second-max(ll,rrv[i].first));\n                ll = max(ll, rrv[i].second);\n            }\n\n            ans += (nx-x) * len;\n            x = nx;\n        }\n\n        printf(\"%d %.2f\\n\", tc++, ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nstruct Box { double x, y, r; };\n\nconst double EPS = 1e-9;\n\nvoid solve(int n) {\n\tvector< double > h, w;\n\tvector< Box > vb;\n\t\n\tfor_(i,0,n) {\n\t\tdouble x, y, r;\n\t\tcin >> x >> y >> r;\n\t\tvb.push_back(Box{x, y, r});\n\t\th.push_back(y - r);\n\t\th.push_back(y + r);\n\t\tw.push_back(x - r);\n\t\tw.push_back(x + r);\n\t}\n\t\n\tsort(h.begin(), h.end());\n\tsort(w.begin(), w.end());\n\t\n\th.erase(unique(h.begin(), h.end()), h.end());\n\tw.erase(unique(w.begin(), w.end()), w.end());\n\t\n\tint H = h.size(), W = w.size();\n\tdouble ans = 0;\n\t\n\tfor_(i,0,H-1) for_(j,0,W-1) {\n\t\tdouble lx = w[j], rx = w[j + 1];\n\t\tdouble ly = h[i], ry = h[i + 1];\n\t\t\n\t\tfor_(k,0,n) {\n\t\t\tBox b = vb[k];\n\t\t\t\n\t\t\tif (b.x - b.r < lx + EPS &&\n\t\t\t\tb.y - b.r < ly + EPS &&\n\t\t\t\tb.x + b.r > rx - EPS &&\n\t\t\t\tb.y + b.r > ry - EPS) {\n\t\t\t\tans += (rx - lx) * (ry - ly);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << setprecision(9) << setiosflags(ios::fixed) << ans << endl;\n}\n\nint main() {\n\tint case_number = 0, n;\n\t\n\twhile (cin >> n, n) {\n\t\t++case_number;\n\t\tcout << case_number << \" \";\n\t\tsolve(n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint memo[6200][6200];\n\n#define M(x,y) memo[y+2100][x+2100]\n\nint main(){\n  int n;\n  int cc = 1;\n  while(scanf(\"%d\",&n),n){\n    int ans = 0;\n    while(n-->0){\n      double x,y,z;\n      scanf(\"%lf%lf%lf\",&x,&y,&z);\n      int x1,x2,y1,y2;\n      x1 = (x - z) * 10 + 1e-10;\n      y1 = (y - z) * 10 + 1e-10;\n      x2 = (x + z) * 10 + 1e-10;\n      y2 = (y + z) * 10 + 1e-10;\n      for(int yy = y1; yy < y2; yy++){\n        for(int xx = x1; xx < x2; xx++){\n          if(M(xx,yy) != cc){\n            ans++;\n            M(xx, yy) = cc;\n          }\n        }\n      }\n    }\n    printf(\"%d %.2f\\n\",cc,(ans/100.0));\n    cc++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <iomanip>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n#define X real()\n#define Y imag()\n\nint conv(double c, vector<double> &a){\n    vector<double>::iterator it = lower_bound(a.begin(), a.end(), c);\n    return 2*(it -a.begin()) +1;\n}\n\nint main(){\n    for(int ds=1; ; ds++){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<P> a(n);\n        vector<double> r(n);\n        vector<double> x(2*n), y(2*n);\n        for(int i=0; i<n; i++){\n            double xin,yin;\n            cin >> xin >> yin >> r[i];\n            a[i] = P(xin, yin);\n            x[2*i] = a[i].X -r[i];\n            x[2*i+1] = a[i].X +r[i];\n            y[2*i] = a[i].Y -r[i];\n            y[2*i+1] = a[i].Y +r[i];\n        }\n        sort(x.begin(), x.end());\n        x.erase(unique(x.begin(), x.end()), x.end());\n        sort(y.begin(), y.end());\n        y.erase(unique(y.begin(), y.end()), y.end());\n\n        vector<vector<bool> > field(2*x.size()+1, vector<bool>(2*y.size()+1, false));\n        for(int i=0; i<n; i++){\n            int xa = conv(a[i].X -r[i], x);\n            int ya = conv(a[i].Y -r[i], y);\n            int xb = conv(a[i].X +r[i], x);\n            int yb = conv(a[i].Y +r[i], y);\n            for(int j=xa; j<=xb; j++){\n                for(int k=ya; k<=yb; k++){\n                    field[j][k] = true;\n                }\n            }\n        }\n\n        double ans = 0;\n        for(int i=2; i<(int)field.size()-2; i+=2){\n            for(int j=2; j<(int)field[0].size()-2; j+=2){\n                if(field[i][j]){\n                    ans += (x[i/2] -x[i/2-1]) *(y[j/2] -y[j/2-1]);\n                }\n            }\n        }\n        cout << fixed << setprecision(2);\n        cout << ds << \" \" << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint memo[6200][6200];\n\n#define M(x,y) memo[y+2100][x+2100]\n\nint main(){\n  int n;\n  int cc = 1;\n  while(scanf(\"%d\",&n),n){\n    int ans = 0;\n    while(n-->0){\n      double x,y,z;\n      scanf(\"%lf%lf%lf\",&x,&y,&z);\n      int x1,x2,y1,y2;\n      x1 = (x - z) * 10 + 1e-10;\n      y1 = (y - z) * 10 + 1e-10;\n      x2 = (x + z) * 10 + 1e-10;\n      y2 = (y + z) * 10 + 1e-10;\n      for(int yy = y1; yy < y2; yy++){\n        for(int xx = x1; xx < x2; xx++){\n          if(M(xx,yy) != cc){\n            ans++;\n            M(xx, yy) = cc;\n          }\n        }\n      }\n    }\n    printf(\"%.1f\\n\",(ans/100.0));\n    cc++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n;\n\tint co=0;\n\twhile(cin>>n,n){\n\t\tco++;\n\t\tvector<double>x,y,x1,x2,y1,y2;\n\t\tvvi in(210,vi(210));\n\t\trep(i,n){\n\t\t\tdouble a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tx.pb(a-c);x.pb(a+c);\n\t\t\ty.pb(b-c);y.pb(b+c);\n\t\t\tx1.pb(a-c);x2.pb(a+c);\n\t\t\ty1.pb(b-c);y2.pb(b+c);\n\t\t}\n\t\tsort(all(x));\n\t\tsort(all(y));\n\t\tx.erase(unique(all(x)),x.end());\n\t\ty.erase(unique(all(y)),y.end());\n\t\trep(i,n){\n\t\t\tint a=find(all(x),x1[i])-x.begin();\n\t\t\tint b=find(all(x),x2[i])-x.begin();\n\t\t\tint c=find(all(y),y1[i])-y.begin();\n\t\t\tint d=find(all(y),y2[i])-y.begin();\n\t\t\tloop(j,a,b)loop(k,c,d)\n\t\t\t\tin[j][k]=true;\n\t\t}\n\t\tdouble sum=0;\n\t\trep(i,210)rep(j,210)if(in[i][j])\n\t\t\tsum+=(x[i+1]-x[i])*(y[j+1]-y[j]);\n\t\tcout<<co<<\" \"<<shosu(9)<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nvector<double> xv,yv,rv;\n\nint main() {\n    int n,tc = 1;\n    double x,y,r;\n    while(cin>>n, n) {\n        xv.clear(); yv.clear(); rv.clear();\n        priority_queue<double, vector<double>, greater<double> > q;\n        for(int i=0; i<n; ++i) {\n            cin>>x>>y>>r;\n            xv.push_back(x); yv.push_back(y); rv.push_back(r);\n            q.push(x-r); q.push(x+r);\n        }\n\n        x = q.top();\n        double ans = 0;\n        while(!q.empty()) {\n            double nx = q.top(); q.pop();\n            double ll = 0;\n\n            vector<pair<double,double> > rrv;\n            for(int i=0; i<n; ++i)\n                if(xv[i]-rv[i] < nx && xv[i]+rv[i] >= nx)\n                    rrv.push_back(make_pair(yv[i]-rv[i],yv[i]+rv[i]));\n\n            sort(rrv.begin(), rrv.end());\n\n            if(rrv.size() == 0) continue;\n            double be = -1,en = -1;\n            for(int i=0; i<rrv.size(); ++i) {\n                if(rrv[i].first > en) {\n                    ans += (nx - x) * (en - be);\n                    ll += (en-be);\n                    be = rrv[i].first;\n                    en = rrv[i].second;\n                }else if(rrv[i].second < en) {\n                    ;\n                }else{\n                    en = rrv[i].second;\n                }\n            }\n            ans += (nx-x) * (en-be);\n            ll += en-be;\n\n            //cout<<\"add \"<<ll<<\"*(\"<<nx<<\"-\"<<x<<\")\"<<endl;\n            x = nx;\n        }\n\n        printf(\"%d %.2f\\n\", tc++, ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct P {\n  double x;\n  double y1, y2;                // y1 < y2\n  bool f;                       // 0:in, 1:out\n};\nconst bool operator<(const P &a, const P &b) {\n  return a.x < b.x;\n}\n\ntypedef pair<double,double> pdd;\nint main() {\n  int n;\n  int nn = 0;\n  while(cin >> n, n) {\n    vector<P> v;\n    REP(i,n) {\n      double x,y,r;\n      cin >> x >> y >> r;\n      v.push_back((P){x-r,y-r,y+r,0});\n      v.push_back((P){x+r,y-r,y+r,1});\n    }\n    sort(ALL(v));\n    double x = -1;\n    double res = 0;\n    set<pdd> se;\n    double dy = 0;\n    FOR(it, v) {\n//      printf(\"%f %f (%f,%f) %d\\n\", x,it->x,it->y1,it->y2,it->f);\n      \n      if (x<0) x = it->x;\n      \n      res += (it->x - x) * dy;\n      \n      x = it->x;\n      \n      if (it->f == 0)\n        se.insert(pdd(it->y1,it->y2));\n      else\n        se.erase(pdd(it->y1,it->y2));\n\n      // dy ÌvZ\n      double y1=-1,y2=-1;       // »Ýl¦Ä¢éÍÍ\n      dy = 0;\n      FOR(jt, se) {\n        if (y2 <= jt->first) {\n          dy += y2-y1;\n          y1 = jt->first;\n          y2 = jt->second;\n        } else if (y2 <= jt->second) {\n          y2 = jt->second;\n        } else {      \n        }\n      }\n      dy += y2-y1;\n    }\n    printf(\"%d %.2f\\n\", ++nn, res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nnamespace Geometry{\n    typedef long double D;\n    typedef complex<long double> P;\n    typedef pair<P,D> C;\n    \n    const D EPS=1e-9;\n    const D PI=asin(1)*2;\n    const D INF=1e18;\n    \n    const static bool comp(const P &p1,const P &p2){return p1.real()==p2.real()?p1.imag()<p2.imag():p1.real()<p2.real();}\n    \n    D dot(P p1,P p2){return p1.real()*p2.real()+p1.imag()*p2.imag();}\n    \n    D cross(P p1,P p2){return p1.real()*p2.imag()-p1.imag()*p2.real();}\n    \n    P project(P vec,P x){return vec*(x/vec).real();}\n    \n    P project(P p1,P p2,P x){return p1+project(p2-p1,x-p1);}\n    \n    P reflect(P vec,P x){return vec*conj(x/vec);}\n    \n    P reflect(P p1,P p2,P x){return p1+reflect(p2-p1,x-p1);}\n    \n    bool intersectSL(P p1,P p2,P vec){vec/=abs(vec); p1/=vec; p2/=vec; return (p1.imag()<EPS && p2.imag()>-EPS) || (p1.imag()>-EPS && p2.imag()<EPS);}\n    \n    bool intersectSL(P p1,P p2,P p3,P p4){return intersectSL(p1-p4,p2-p4,p3-p4);}\n    \n    bool intersectSS(P p1,P p2,P p3,P p4){return (dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS) || (dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS)?false:intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);}\n    \n    D distLP(P vec,P x){return abs((x/vec).imag())*abs(vec);}\n    \n    D distLP(P p1,P p2,P x){return distLP(p2-p1,x-p1);}\n    \n    D distSP(P p1,P p2,P x){return dot(p2-p1,x-p1)<-EPS?abs(x-p1):dot(p1-p2,x-p2)<-EPS?abs(x-p2):distLP(p1,p2,x);}\n    \n    D distSS(P p1,P p2,P p3,P p4){return intersectSS(p1,p2,p3,p4)?0.0:min(min(distSP(p1,p2,p3),distSP(p1,p2,p4)),min(distSP(p3,p4,p1),distSP(p3,p4,p2)));}\n    \n    P crosspointLL(P p1,P p2,P vec){return abs(cross(p2-p1,vec))<EPS?vec:vec*cross(p2-p1,p2)/cross(p2-p1,vec);}\n    \n    P crosspointLL(P p1,P p2,P p3,P p4){return p4+crosspointLL(p1-p4,p2-p4,p3-p4);}\n    \n    P crosspointSS(P p1,P p2,P p3,P p4){return distSP(p1,p2,p3)<EPS?p3:distSP(p1,p2,p4)<EPS?p4:crosspointLL(p1,p2,p3,p4);}\n    \n    bool intersectShL(P p1,P p2,P vec){vec/=abs(vec); return intersectSL(p1,p2,vec) && crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;}\n    \n    bool intersectShL(P p1,P p2,P p3,P p4){return intersectShL(p1-p3,p2-p3,p4-p3);}\n    \n    //1::in,0::on edge,-1::out\n    int contain(const vector<P> &poly,const P &p){\n        vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},{-93763,-78049},{56957,10007}};\n        vector<bool> cnt(5,false);\n        for(int i=1;i<=poly.size();i++){\n            if(distSP(poly[i-1],poly[i%poly.size()],p)<EPS){return 0;}\n            for(int j=0;j<5;j++){\n                if(intersectShL(poly[i-1],poly[i%poly.size()],p,p+A[j])){cnt[j]=!cnt[j];}\n            }\n        }\n        int in=0;\n        for(int j=0;j<5;j++){if(cnt[j]){in++;}}\n        return in>=3?1:-1;\n    }\n    \n    vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n        vector<P> ret;\n        for(int i=1;i<=poly.size();i++){\n            if(cross(p2-p1,poly[i-1]-p1)>-EPS){ret.push_back(poly[i-1]);}\n            if(intersectSL(poly[i-1],poly[i%poly.size()],p1,p2) && distLP(p1,p2,poly[i-1])>EPS && distLP(p1,p2,poly[i%poly.size()])>EPS){ret.push_back(crosspointLL(poly[i-1],poly[i%poly.size()],p1,p2));}\n        }\n        return ret;\n    }\n    \n    D area(const vector<P> &poly){\n        D ans=0;\n        for(int i=2;i<poly.size();i++){ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);}\n        return abs(ans)/2;\n    }\n    \n    vector<P> convexhull(vector<P> pts){\n        vector<P> ret;\n        sort(pts.begin(),pts.end(),comp);\n        for(auto &I:pts){\n            if(!ret.empty() && I==ret.back()){continue;}\n            while(ret.size()>=2 && cross(ret.back()-ret[ret.size()-2],I-ret.back())<-EPS){ret.pop_back();}\n            ret.push_back(I);\n        }\n        reverse(pts.begin(),pts.end());\n        for(auto &I:pts){\n            if(!ret.empty() && I==ret.back()){continue;}\n            while(ret.size()>=2 && cross(ret.back()-ret[ret.size()-2],I-ret.back())<-EPS){ret.pop_back();}\n            ret.push_back(I);\n        }\n        if(ret[0]==ret.back()){ret.pop_back();}\n        return ret;\n    }\n    \n    //4::seperate,3::circumscribe,2::intersect,1::inscribe,0::contain,-1::same\n    int intersectCC(C c1,C c2){\n        D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n        if(d<EPS && dif<EPS){return -1;}\n        if(d-r>EPS){return 4;}\n        if(d-r>-EPS){return 3;}\n        if(d-dif>EPS){return 2;}\n        if(d-dif>-EPS){return 1;}\n        return 0;\n    }\n    \n    vector<P> crosspointLC(P p1,P p2,C c){\n        vector<P> ret;\n        P pr=project(p1,p2,c.F);\n        D d=distLP(p1,p2,c.F);\n        if(d-c.S>EPS){return ret;}\n        if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n        P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n        ret.push_back(pr-vec);\n        ret.push_back(pr+vec);\n        return ret;\n    }\n    \n    vector<P> crosspointSC(P p1,P p2,C c){\n        vector<P> ret;\n        for(auto &I:crosspointLC(p1,p2,c)){if(distSP(p1,p2,I)<EPS){ret.push_back(I);}}\n        return ret;\n    }\n    \n    vector<P> crosspointCC(C c1,C c2){\n        vector<P> ret;\n        P vec=c2.F-c1.F;\n        D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n        D h=sqrt(c1.S*c1.S-base*base);\n        vec/=abs(vec);\n        ret.push_back(c1.F+vec*P(base,-h));\n        ret.push_back(c1.F+vec*P(base,h));\n        return ret;\n    }\n    \n    vector<P> tangentCP(C c,P p){return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));}\n    \n    vector<pair<P,P>> tangentCC(C c1,C c2){\n        vector<pair<P,P>> ret;\n        P d=c2.F-c1.F;\n        for(D i:{-1,1}){\n            D r=c1.S+c2.S*i;\n            if(intersectCC(c1,c2)>i+1){\n                for(P s:{-1i,1i}){\n                    P p=r+s*sqrt(norm(d)-norm(r));\n                    ret.push_back({c1.F+d*c1.S/norm(d)*p,c2.F-d*i*c2.S/norm(d)*p});\n                }\n            }\n        }\n        return ret;\n    }\n    \n    D area(const vector<P> &poly,C c){\n        D ret=0;\n        for(int i=0;i<poly.size();i++){\n            P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n            if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){ret+=cross(a,b);}\n            else{\n                vector<P> A=crosspointSC(a,b,{0,c.S});\n                if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n                else{\n                    ret+=(abs(a)<c.S?cross(a,A[0]):c.S*c.S*arg(A[0]/a));\n                    ret+=(abs(b)<c.S?cross(A.back(),b):c.S*c.S*arg(b/A.back()));\n                    ret+=cross(A[0],A.back());\n                }\n            }\n        }\n        return abs(ret)/2;\n    }\n    \n    //反時計回り\n    D diameter(const vector<P> &poly){\n        D ret=0;\n        ll l=0,r=0,n=poly.size();\n        if(n==2){return abs(poly[0]-poly[1]);}\n        for(int i=0;i<n;i++){\n            if(comp(poly[l],poly[i])){l=i;}\n            if(comp(poly[i],poly[r])){r=i;}\n        }\n        ll sl=r,sr=l;\n        while(sl!=l || sr!=r){\n            ret=max(ret,abs(poly[r]-poly[l]));\n            if(cross(poly[(l+1)%n]-poly[l],poly[(r+1)%n]-poly[r])<0){(++l)%=n;}\n            else{(++r)%=n;}\n        }\n        return ret;\n    }\n    \n    D closestpair(vector<P> pt){\n        sort(pt.begin(),pt.end(),comp);\n        D ret=INF;\n        for(ll i=1;i<pt.size();i<<=1){\n            for(ll j=0;i+j<pt.size();j+=i*2){\n                ll m=i+j;\n                vector<P> R;\n                D l=-INF,r=INF;\n                for(ll k=j;k<m;k++){l=max(l,pt[k].real());}\n                for(ll k=0;m+k<pt.size() && k<i;k++){r=min(r,pt[m+k].real());}\n                for(ll k=0;m+k<pt.size() && k<i;k++){if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}}\n                ll idx=0;\n                for(ll k=j;k<m;k++){\n                    if(r-pt[k].real()>ret){continue;}\n                    while(idx<R.size() && pt[k].imag()-R[idx].imag()>ret){idx++;}\n                    for(ll n=idx;n<R.size() && R[n].imag()-pt[k].imag()<ret;n++){ret=min(ret,abs(R[n]-pt[k]));}\n                }\n                inplace_merge(pt.begin()+j,pt.begin()+m,j+i*2<pt.size()?pt.begin()+j+2*i:pt.end(),[](const P &a,const P &b){return a.imag()==b.imag()?a.real()<b.real():a.imag()<b.imag();});\n            }\n        }\n        return ret;\n    }\n    \n    istream & operator >> (istream &i,P &p){D x,y; i>>x>>y; p={x,y}; return i;}\n    istream & operator >> (istream &i,C &p){D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;}\n};\n\nusing namespace Geometry;\n\n\n\n\nint main(){\n    ll n,t=1;\n    while(cin>>n,n){\n        vector<C> A(n);\n        vector<pair<pair<P,P>,int>> L(2*n);\n        cin>>A;\n        for(int i=0;i<n;i++){\n            P vec=A[i].S; vec*=P(0,1); vec-=A[i].S;\n            L[i]={{A[i].F+vec*P(0,1),A[i].F+vec},1};\n            L[i+n]={{A[i].F-vec,A[i].F-vec*P(0,1)},-1};\n        }\n        sort(L.begin(),L.end(),[&](pair<pair<P,P>,int> a,pair<pair<P,P>,int> b){return comp(a.F.F,b.F.F) || (a.F.F==b.F.F && comp(a.F.S,b.F.S)) || (a.F==b.F && a.S<b.S);});\n        map<D,ll> M;\n        map<ll,D> R;\n        for(auto &I:L){M[I.F.F.imag()]=M[I.F.S.imag()];}\n        ll cnt=0;\n        for(auto &I:M){I.S=cnt; R[cnt++]=I.F;}\n        vector<int> B(cnt,0);\n        D ls=-E;\n        D ans=0;\n        for(auto &I:L){\n            for(int i=0;i<cnt;i++){\n                if(B[i]>0){ans+=(R[i+1]-R[i])*(I.F.F.real()-ls);}\n            }\n            ls=I.F.F.real();\n            for(ll i=M[I.F.F.imag()];i<M[I.F.S.imag()];i++){B[i]+=I.S;}\n        }\n        cout<<t<<\" \"; t++;\n        cout<<fixed<<setprecision(2)<<ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Point {\n\tdouble x;\n\tdouble y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() :x(0), y(0) {}\n};\n\nstruct Rectangle {\n\tPoint topLeft;\n\tPoint bottomRight;\n\tRectangle(Point topLeft, Point bottomRight) :topLeft(topLeft), bottomRight(bottomRight) {}\n\tRectangle(){}\n};\n\nint compress(vector<double> &x, unordered_map<double, int>& zip, vector<int>& unzip) {\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tunzip.resize(x.size());\n\tfor (size_t i = 0; i < x.size(); i++)\n\t{\n\t\tzip[x[i]] = i;\n\t\tunzip[i] = x[i];\n\t}\n\treturn zip.size();\n}\n\ndouble solve(const vector<Rectangle> rectangles) {\n\tvector<double> xs;\n\tunordered_map<double, int> xZip;\n\tvector<int> xUnzip;\n\tvector<double> ys;\n\tunordered_map<double, int> yZip;\n\tvector<int> yUnzip;\n\n\tfor (auto &r : rectangles) {\n\t\txs.push_back(r.topLeft.x);\n\t\txs.push_back(r.bottomRight.x);\n\t\tys.push_back(r.topLeft.y);\n\t\tys.push_back(r.bottomRight.y);\n\t}\n\tvector<vector<bool> > checker(ys.size(), vector<bool>(xs.size(), false));\n\tcompress(xs, xZip, xUnzip);\n\tcompress(ys, yZip, yUnzip);\n\n\tfor (auto &r : rectangles) {\n\t\tfor (int y = yZip[r.topLeft.y]; y < yZip[r.bottomRight.y]; ++y) {\n\t\t\tfor (int x = xZip[r.topLeft.x]; x < xZip[r.bottomRight.x]; ++x) {\n\t\t\t\tchecker[y][x] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble res = 0.0;\n\tfor (int y = 0; y < yUnzip.size()-1 ; ++y) for (int x = 0; x < xUnzip.size()-1; ++x) if (checker[y][x]) {\n\t\tres += (yUnzip[y + 1] - yUnzip[y]) * (xUnzip[x + 1] - xUnzip[x]);\n\t}\n\treturn res;\n\t\n}\n\nint main(void) {\n\tint cnt = 0;\n\twhile (1) {\n\t\t++cnt;\n\t\tvector<Rectangle> rectangles;\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\trectangles.push_back(Rectangle(Point(x - r, y - r), Point(x + r, y + r)));\n\t\t}\n\t\tcout << fixed << setprecision(10) << cnt << \" \" <<  solve(rectangles) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define N 4000\n\nusing namespace std;\n\nclass Point{\npublic:\n  int x;\n  int y;\n  int r;\n};\n\nbool data[N][N];\nvoid syokika();\nint mx, my;\nmain(){\n  int n;\n  Point in[100];\n  for(int count=1;;count++){\n    cin >> n;\n    if(n==0) break;\n    double x, y, r;\n    my=-1;\n    mx=-1;\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> r;\n      x*=10;\n      y*=10;\n      r*=10;\n      int ix, iy, ir;\n      in[i].x=(int)x;\n      in[i].y=(int)y;\n      in[i].r=(int)r;\n      if(my<(in[i].y+in[i].r)) my=in[i].y+in[i].r;\n      if(mx<(in[i].x+in[i].r)) mx=in[i].x+in[i].r;\n    }\n    syokika();\n    for(int i=0;i<n;i++){\n      for(int a=in[i].y-in[i].r;a<in[i].y+in[i].r;a++){\n\tif(a<0) continue;\n\tfor(int b=in[i].x-in[i].r;b<in[i].x+in[i].r;b++){\n\t  if(b<0) continue;\n\t  data[a][b]=true;\n\t}\n      }\n    }\n    int sum=0;\n    for(int i=0;i<my;i++){\n      for(int j=0;j<mx;j++){\n\tif(data[i][j]) sum++;\n      }\n    }\n    //    printf(\"!%d\\n\", sum);\n    double ans=sum/100.0;\n    printf(\"%d %.2f\\n\", count, ans);\n  }\n  return 0;\n}\n\nvoid syokika(){\n  for(int i=0;i<=my;i++){\n    for(int j=0;j<=mx;j++){\n      data[i][j]=false;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\nvector<pair<pair<double, int> , Pd> > ls;\nbool use[300];\n\ndouble calc(vector<Pd> range){\n\tdouble res = 0;\n\tsort(range.begin(), range.end());\n\trep(i, (int)range.size() - 1){\n\t\tif(range[i+1].second > range[i].second){\n\t\t\tres += range[i+1].second - max(range[i+1].first, range[i].second);\n\t\t}\n\t}\n\tif(!range.empty()){\n\t\tres += range[0].second - range[0].first;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, sz;\n\tint cnt = 1;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\trep(i, n){\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tls.push_back(make_pair(make_pair(y - r, i), Pd(x - r, x + r)));\n\t\t\tls.push_back(make_pair(make_pair(y + r, i), Pd(x - r, x + r)));\n\t\t}\n\t\tsort(ls.begin(), ls.end());\n\t\tmemset(use, false, sizeof(use));\n\t\tsz = ls.size();\n\t\tdouble pre = -1e4;\n\t\tdouble res = 0.0;\n\t\trep(i, sz){\n\t\t\tint id = ls[i].first.second;\n\t\t\tdouble cur = ls[i].first.first;\n\t\t\tvector<Pd> range;\n\t\t\trep(i, sz){\n\t\t\t\tif(use[i]) range.push_back(ls[i].second);\n\t\t\t}\n\t\t\tres += (cur - pre) * calc(range);\n\t\t\tpre = cur;\n\t\t\tuse[id] = !use[id];\t\t\t\n\t\t}\n\t\tcout << cnt++ << \" \" << fixed << setprecision(2) << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n#define all(a) (a).begin(),(a).end()\n\nusing vd = vector<double>;\nusing vvd = vector<vd>;\n\nvoid add(vvd &sections, const vd &e){\n  sections.push_back({e[2],0}); // 始点イベント\n  sections.push_back({e[3],1}); // 終点イベント\n}\n\nvoid del(vvd &sections, const vd &e){\n  vd tmp = {e[2],0};\n  auto itr = find(all(sections),tmp);\n  sections.erase(itr);\n  tmp = {e[3],1};\n  itr = find(all(sections),tmp);\n  sections.erase(itr);\n}\n\ndouble sum(vvd &sections){\n  double res = 0;\n  sort(all(sections));\n  double l = sections[0][0];\n  int cnt = 1;\n  FOR(i,1,sections.size())\n    if(sections[i][1] == 0){\n      cnt++;\n      if(cnt == 1) l = sections[i][0];\n    }else{\n      cnt--;\n      if(cnt == 0) res += sections[i][0] - l;\n    }\n\n  return res;\n}\n\nsigned main(){\n  int n, cnt = 1;\n  while(cin >> n, n){\n    vvd es;\n    rep(i,n){\n      double x,y,r;\n      cin >> x >> y >> r;\n      es.push_back({x-r,0,y-r,y+r}); // 追加イベント\n      es.push_back({x+r,1,y-r,y+r}); // 削除イベント\n    }\n    sort(all(es));\n\n    double ans = 0;\n    vvd sections;\n    add(sections, es[0]);\n    FOR(i,1,es.size()){\n      if(es[i][0] != es[i-1][0])\n\tans += (es[i][0] - es[i-1][0]) * sum(sections);\n\n      if(es[i][1] == 0)\n\tadd(sections,es[i]);\n      else\n\tdel(sections,es[i]);\n    }\n    printf(\"%d %.2lf\\n\",cnt,ans);\n    cnt++;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<double, double> squareCorner;\ntypedef pair<squareCorner, squareCorner> squareCorners;\n\ndouble totalLength (vector<squareCorners> squares, double x) {\n    // Ignore squares not crossing the ray line\n    for(vector<squareCorners>::iterator it = squares.begin(); it!=squares.end(); it++) {\n        double x0 = it->first.first;\n        double x1 = it->second.first;\n        if (x < x0 || x >= x1) {\n            squares.erase(it);\n            it--;\n        }\n    }\n\n    // Add y[01] to a list\n    vector<pair<double, bool> > ys;\n    for(squareCorners p : squares) {\n        double y0 = p.first.second;\n        double y1 = p.second.second;\n        ys.push_back(make_pair(y0, true));\n        ys.push_back(make_pair(y1, false));\n    }\n\n    // Sort list\n    sort(ys.begin(), ys.end());\n\n    // Compute sum distance\n    int beginning = 0;\n    double l = 0;\n    double startSegment = 0.;\n    for(pair<double, bool> p: ys) {\n        bool isBeginning = p.second;\n        double y = p.first;\n\n        if (beginning == 0)\n            startSegment = y;\n        beginning += isBeginning ? 1 : -1;\n        if (beginning == 0)\n            l += y - startSegment;\n    }\n\n    return l;\n}\n\nint main () {\n    int N;\n    cin >> N;\n    int cpt = 0;\n\n    // Read info for one Problem\n    while (N != 0) {\n        cpt++;\n        vector<squareCorners> squares;\n        set<double> xs;\n\n        // Read info about each antenna\n        for (int i=0; i<N; i++) {\n            double cx, cy, r;\n            cin >> cx >> cy >> r;\n            double x0 = cx - r,\n                   x1 = cx + r,\n                   y0 = cy - r,\n                   y1 = cy + r;\n            xs.insert(x0);\n            xs.insert(x1);\n            squares.push_back(make_pair(make_pair(x0, y0), make_pair(x1, y1)));\n        }\n\n        double area = 0.;\n        set<double>::iterator it=xs.begin();\n        double prevY = *it;\n        double prevWidth = totalLength(squares, prevY);\n        it++;\n        while (it != xs.end()) {\n            area += prevWidth * (*it - prevY);\n            prevY = *it;\n            prevWidth = totalLength(squares, *it);\n            it++;\n        }\n\n        area = round(area*100)/100;\n\n        printf(\"%d %.2f\\n\", cpt, area);\n        cin >> N;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\ndouble totalLength (vector<pair<pair<double, double>, pair<double, double> > > squares, double x) {\n    // Ignore squares not crossing the ray line\n    for(auto it = squares.begin(); it!=squares.end(); it++) {\n        double x0 = it->first.first;\n        double x1 = it->second.first;\n        if (x < x0 || x >= x1) {\n            squares.erase(it);\n            it--;\n        }\n    }\n\n    // Add y[01] to a list\n    vector<pair<double, bool> > ys;\n    for(auto p : squares) {\n        double y0 = p.first.second;\n        double y1 = p.second.second;\n        ys.push_back(make_pair(y0, true));\n        ys.push_back(make_pair(y1, false));\n    }\n\n    // Sort list\n    sort(ys.begin(), ys.end());\n\n    // Compute sum distance\n    int beginning = 0;\n    double l = 0;\n    double startSegment = 0.;\n    for(auto p: ys) {\n        bool isBeginning = p.second;\n        double y = p.first;\n\n        if (beginning == 0)\n            startSegment = y;\n        beginning += isBeginning ? 1 : -1;\n        if (beginning == 0)\n            l += y - startSegment;\n    }\n\n    return l;\n}\n\nint main () {\n    int N;\n    cin >> N;\n    int cpt = 0;\n\n    // Read info for one Problem\n    while (N != 0) {\n        cpt++;\n        vector<pair<pair<double, double>, pair<double, double> > > squares;\n        set<double> xs;\n\n        // Read info about each antenna\n        for (int i=0; i<N; i++) {\n            double cx, cy, r;\n            cin >> cx >> cy >> r;\n            double x0 = cx - r,\n                   x1 = cx + r,\n                   y0 = cy - r,\n                   y1 = cy + r;\n            xs.insert(x0);\n            xs.insert(x1);\n            squares.push_back(make_pair(make_pair(x0, y0), make_pair(x1, y1)));\n        }\n\n        double area = 0.;\n        auto it=xs.begin();\n        double prevY = *it;\n        double prevWidth = totalLength(squares, prevY);\n        it++;\n        while (it != xs.end()) {\n            area += prevWidth * (*it - prevY);\n            prevY = *it;\n            prevWidth = totalLength(squares, *it);\n            it++;\n        }\n\n        area = round(area*100)/100;\n\n        printf(\"%d %.2f\\n\", cpt, area);\n        cin >> N;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n};\nEvent evs[1001];\nRect recs[1001];\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  vector<double> ls,rs;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int p=find(x);\n    ls[p]=l;\n    rs[p]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    int NN=0;\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      recs[i].first=P(x-r,y-r);\n      recs[i].second=P(x+r,y+r);\n      if(EQ(r,0))continue;\n      evs[2*NN]=Event(y-r,true,i);\n      evs[2*NN+1]=Event(y+r,false,i);\n      NN++;\n    }\n    sort(evs,evs+2*NN);\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    // yÌ¬³¢ÔÉCxgð\n    for(int k=0;k<2*NN;k++){\n      Event &e=evs[k];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      prvy=e.y;\n      // _ÌÇÁAí\n      if(e.isIn)v.push_back(e.id);\n      else v.erase(find(v.begin(),v.end(),e.id));\n      // ¡ñÌ¡ðvZ\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  // ÍÍª©Ôéæ¤ÈçÎAunite\n\t  if((EQ(uft.rs[uft.find(i)]\n\t\t ,uft.ls[uft.find(j)])\n\t      ||(uft.rs[uft.find(i)]\n\t\t >uft.ls[uft.find(j)]))\n\t     &&(EQ(uft.ls[uft.find(i)]\n\t\t   ,uft.rs[uft.find(j)])\n\t\t||(uft.ls[uft.find(i)]\n\t\t   <uft.rs[uft.find(j)]))){\n\t    double minx=min(uft.ls[uft.find(i)]\n\t\t\t    ,uft.ls[uft.find(j)]);\n\t    double maxx=max(uft.rs[uft.find(i)]\n\t\t\t    ,uft.rs[uft.find(j)]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    printf(\"%d %.2f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tdouble x;\n\tdouble y;\n\tdouble r;\n\tData(double _x,double _y,double _r){\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t}\n};\n\nbitset<10000> found; \nbool filled[400][400];\nint main(){\n\tint n;\n\tint idx = 1;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tvector<Data> Points;\n\t\tmemset(filled,0,sizeof(filled));\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y,r;\n\t\t\tscanf(\"%lf %lf %lf\",&x,&y,&r);\n\t\t\tPoints.push_back(Data(x,y,r));\n\n\t\t\t//x=200; cx=20000;\n\t\t\t//x=0 cx=0;\n\t\t\t//r=200 ra=20000;\n\t\t\t//-20000<square<20000\n\n\t\t\tint cx = x*100.0;\n\t\t\tint cy = y*100.0;\n\t\t\tint ra = r*100.0; \n\t\t\t\n\t\t\tfor(int y=0;y<40000;y+=100){\n\t\t\t\tfor(int x=0;x<40000;x+=100){\n\t\t\t\t\tif(cx - ra + 20000 <= x && x+100 < cx+ra + 20000\n\t\t\t\t\t&& cy - ra + 20000 <= y && y+100 < cy+ra + 20000){\n\t\t\t\t\t\tfilled[y/100][x/100] = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tint res=0;\n\n\n\t\tfor(int y=0;y<40000;y+=100){\n\t\t\tfor(int x=0;x<40000;x+=100){\n\t\t\t\tif(filled[y/100][x/100]){\n\t\t\t\t\tres+= 10000;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse{\n\n\t\t\t\t\tfound.reset();\n\t\t\t\t\tfor(int i=0;i<Points.size();i++){\n\t\t\t\t\t\tint cx = Points[i].x*100.0 + 20000;\n\t\t\t\t\t\tint cy = Points[i].y*100.0 + 20000;\n\t\t\t\t\t\tint ra = Points[i].r*100.0;\n\n\n\t\t\t\t\t\tif(cx+ra < x || x+100 <= cx - ra) continue;\n\t\t\t\t\t\tif(cy+ra < y || y+100 <= cy - ra) continue;\n\t\t\t\t\t\tfor(int dy= max(cy-ra,y);dy<min(cy+ra,y+100);dy++){\n\t\t\t\t\t\t\tfor(int dx = max(cx-ra,x);dx < min(cx+ra,x+100); dx++){\n\t\t\t\t\t\t\t\tfound[(dy-y)*100+(dx-x)] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tres += found.count();\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %.2lf\\n\",idx++,res/(double)10000);\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n};\nEvent evs[1001];\nRect recs[1001];\n\nclass UnionFindTree{\npublic:\n  vector<int> par;\n  vector<int> rank;\n  vector<double> ls,rs;\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int p=find(x);\n    ls[p]=l;\n    rs[p]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    int NN=0;\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      recs[i].first=P(x-r,y-r);\n      recs[i].second=P(x+r,y+r);\n      if(EQ(r,0))continue;\n      evs[2*NN]=Event(y-r,true,i);\n      evs[2*NN+1]=Event(y+r,false,i);\n      NN++;\n    }\n    sort(evs,evs+2*NN);\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    for(int k=0;k<2*NN;k++){\n      Event &e=evs[k];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      prvy=e.y;\n      if(e.isIn)v.push_back(e.id);\n      else v.erase(find(v.begin(),v.end(),e.id));\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  int pari=uft.find(i);\n\t  int parj=uft.find(j);\n\t  if((EQ(uft.rs[pari],uft.ls[parj])\n\t      ||(uft.rs[pari]>uft.ls[parj]))\n\t     &&(EQ(uft.ls[pari],uft.rs[parj])\n\t\t||(uft.ls[pari]<uft.rs[parj]))){\n\t    double minx=min(uft.ls[pari],uft.ls[parj]);\n\t    double maxx=max(uft.rs[pari],uft.rs[parj]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    printf(\"%d %.2f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n\n#define REP(i,n) for(i=0; i < (n); i++)\n#define REPONE(i, n) for(i=1; i <= (n); i++)\n#define LOOP(n) for(int loopCount=1; loopCount <= (n); loopCount++)\n#define ITER(c) __typeof((c).begin())\n#define EACH(c,it) for(ITER(c) it =(c).begin(); it!=(c).end(); it++)\n#define SZ(c) ((int) (c).size())\n#define ALL(c) c.begin(), c.end()\n#define SUM(c) accumulate(ALL(c), 0)\n#define EXIST(c,v) (find(ALL(c), (v)) != (c).end())\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\nstatic const double EPS = 1e-9;\nstatic const double PI = 3.141592653589793238462643383279;\ntypedef long long ll;\n\nint main(){\n    int i, j, n, cnt=1;\n    double r, x, y;\n    while(scanf(\"%d\",&n)){\n        if(!n) break;\n        set<double> eventline;\n        vector<double> xs, ys, rs;\n        REP(i,n){\n            scanf(\"%lf%lf%lf\",&x,&y,&r);\n            xs.PB(x);\n            eventline.insert(x-r+EPS);\n            eventline.insert(x+r+EPS);\n            ys.PB(y);\n            rs.PB(r);\n        }\n        double ans = 0.0, len = 0.0;\n        EACH(eventline,it){\n            vector< pair<double,double> > ranges;\n            double lb = -(1<<20);\n            REP(i,n){\n                if(fabs((*it) - xs[i]) < rs[i])\n                    ranges.PB(MP(ys[i] - rs[i], ys[i] + rs[i]));\n            }\n            len = 0;\n            sort(ALL(ranges));\n            REP(i,SZ(ranges)){\n                len += max(0.0,ranges[i].second-max(lb,ranges[i].first));\n                lb = max(lb, ranges[i].second);\n            }\n            if(len > EPS){\n                ITER(eventline) itt = it; advance(itt,1);\n                ans += len * ((*itt) - (*it));\n            }\n        }\n\n        printf(\"%d %.2f\\n\",cnt++,ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\nRect recs[101];\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n};\nEvent evs[1001];\n\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  vector<int> ls;\n  vector<int> rs;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int par=find(x);\n    ls[par]=l;\n    rs[par]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    int NN=0;\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      if(EQ(r,0))continue;\n      recs[NN].first=P(x-r,y-r);\n      recs[NN].second=P(x+r,y+r);\n      evs[2*NN]=Event(y-r,true,i);\n      evs[2*NN+1]=Event(y+r,false,i);\n      NN++;\n    }\n    sort(evs,evs+2*NN);\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    // yÌ¬³¢ÔÉCxgð\n    for(int i=0;i<2*NN;i++){\n      Event &e=evs[i];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      prvy=e.y;\n      // _ðÇÁ\n      if(e.isIn){\n\t// »Ìã,¡ñÌ_ðÜßé\n\tv.push_back(e.id);\n      }\n      else{\n\t//if(find(v.begin(),v.end(),e.id)!=v.end())\n\t  v.erase(find(v.begin(),v.end(),e.id));\n      }\n      // ¡ñÌ¡ðvZ\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  // ÍÍª©Ôéæ¤ÈçÎAunite\n\t  if((EQ(uft.rs[i],uft.ls[j])\n\t      ||(uft.rs[i]>uft.ls[j]))\n\t     &&(EQ(uft.ls[i],uft.rs[j])\n\t\t||(uft.ls[i]<uft.rs[j]))){\n\t    double minx=min(uft.ls[i],uft.ls[j]);\n\t    double maxx=max(uft.rs[i],uft.rs[j]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    printf(\"%d %.2f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//24\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nstruct L{\n  int y,l,r,f;\n  bool operator<(L a)const{\n    return y<a.y;\n  }\n};\n\nint main(){\n  int cs=0;\n  for(int n;cin>>n,n;){\n    L l[200];\n    for(int i=0;i<n;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      L &a=l[2*i],&b=l[2*i+1];\n      a.l=b.l=(x-r)*100+.5;\n      a.r=b.r=(x+r)*100+.5;\n      a.y=(y-r)*100+.5;\n      b.y=(y+r)*100+.5;\n      a.f=1;\n      b.f=-1;\n    }\n    sort(l,l+n*2);\n    int c[40001]={};\n    int sum=0;\n    for(int i=0;i<2*n-1;i++){\n      for(int j=l[i].l;j<l[i].r;j++){\n\tc[j]+=l[i].f;\n      }\n      int h=l[i+1].y-l[i].y;\n      sum+=(40001-count(c,c+40001,0))*h;\n    }\n    cout.precision(2);\n    cout<<++cs<<' '<<fixed<<sum/10000.<<endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<cstdio>\n#define DIF 5000\n#define all(n) n.begin(),n.end()\nusing namespace std;\n\nvoid draw(vector<vector<bool> >& graph,int sx,int sy,int ex,int ey)\n{\n  for(int i=sy;i<ey;i++)\n    for(int j=sx;j<ex;j++)\n      graph[i][j] = true;\n}\n\nint main()\n{\n  int n,NARI = 1;\n  while(cin >> n,n)\n    {      \n      vector<int> X,Y,X1,X2,Y1,Y2;\n      vector<vector<bool> > graph;\n      graph.resize(310);\n\n      for(int i=0;i<310;i++)\n\t{\n\t  graph[i].resize(310);\n\t  for(int j=0;j<310;j++)\n\t    graph[i][j] = false;\n\t}\n\n      for(int i=0;i<n;i++)\n\t{\n\t  double x,y,r;\n\t  cin >> x >> y >> r;\n\t  X.push_back(x+r),X.push_back(x-r);\n\t  Y.push_back(y+r),Y.push_back(y-r);\n\t  X1.push_back(x-r),Y1.push_back(y-r);\n\t  X2.push_back(x+r),Y2.push_back(y+r);\n\t}\n\n      sort(all(X));\n      sort(all(Y));\n      X.erase(unique(all(X)),X.end());\n      Y.erase(unique(all(Y)),Y.end());\n\n      for(int i=0;i<n;i++)\n\t{\n\n\t  X1[i] = find(all(X),X1[i]) - X.begin();\n\t  Y1[i] = find(all(Y),Y1[i]) - Y.begin();\n\n\t  X2[i] = find(all(X),X2[i]) - X.begin();\n\t  Y2[i] = find(all(Y),Y2[i]) - Y.begin();\n\n\t}\n\n      for(int i=0;i<n;i++)\n\t  draw(graph,X1[i],Y1[i],X2[i],Y2[i]);\n\n      double ans = 0;\n      for(int i=0;i<Y.size()-1;i++)\n\tfor(int j=0;j<X.size()-1;j++)\n\t  if(graph[i][j])\n\t      ans += (X[j+1]-X[j])*(Y[i+1]-Y[i]);\n\t    \n      //cout << NARI++ << setiosflags(ios::fixed) << setprecision(2)<< \" \" << ans << endl;\n      printf(\"%d %.2lf\\n\",NARI++,ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n;\n\tint co=0;\n\twhile(cin>>n,n){\n\t\tco++;\n\t\tvector<double>x,y,x1,x2,y1,y2;\n\t\tvvi in(210,vi(210));\n\t\trep(i,n){\n\t\t\tdouble a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tx.pb(a-c);x.pb(a+c);\n\t\t\ty.pb(b-c);y.pb(b+c);\n\t\t\tx1.pb(a-c);x2.pb(a+c);\n\t\t\ty1.pb(b-c);y2.pb(b+c);\n\t\t}\n\t\tsort(all(x));\n\t\tsort(all(y));\n\t\tx.erase(unique(all(x)),x.end());\n\t\ty.erase(unique(all(y)),y.end());\n\t\trep(i,n){\n\t\t\tint a=find(all(x),x1[i])-x.begin();\n\t\t\tint b=find(all(x),x2[i])-x.begin();\n\t\t\tint c=find(all(y),y1[i])-y.begin();\n\t\t\tint d=find(all(y),y2[i])-y.begin();\n\t\t\tloop(j,a,b)loop(k,c,d)\n\t\t\t\tin[j][k]=true;\n\t\t}\n\t\tdouble sum=0;\n\t\trep(i,210)rep(j,210)if(in[i][j])\n\t\t\tsum+=(x[i+1]-x[i])*(y[j+1]-y[j]);\n\t\tcout<<co<<\" \"<<shosu(2)<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, c; double x, y, r;\nint main() {\n\twhile (cin >> n, n) {\n\t\tvector<double> xa(n), ya(n), xb(n), yb(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y >> r;\n\t\t\txa[i] = x - r; ya[i] = y - r;\n\t\t\txb[i] = x + r; yb[i] = y + r;\n\t\t}\n\t\tvector<double> xc, yc;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txc.push_back(xa[i]);\n\t\t\tyc.push_back(ya[i]);\n\t\t\txc.push_back(xb[i]);\n\t\t\tyc.push_back(yb[i]);\n\t\t}\n\t\tsort(xc.begin(), xc.end());\n\t\txc.resize(unique(xc.begin(), xc.end()) - xc.begin());\n\t\tsort(yc.begin(), yc.end());\n\t\tyc.resize(unique(yc.begin(), yc.end()) - yc.begin());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txa[i] = lower_bound(xc.begin(), xc.end(), xa[i]) - xc.begin();\n\t\t\tya[i] = lower_bound(yc.begin(), yc.end(), ya[i]) - yc.begin();\n\t\t\txb[i] = lower_bound(xc.begin(), xc.end(), xb[i]) - xc.begin();\n\t\t\tyb[i] = lower_bound(yc.begin(), yc.end(), yb[i]) - yc.begin();\n\t\t}\n\t\tvector<vector<int> > imos(yc.size(), vector<int>(xc.size()));\n\t\tvector<vector<int> > sum(yc.size() + 1, vector<int>(xc.size() + 1));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\timos[ya[i]][xa[i]]++;\n\t\t\timos[ya[i]][xb[i]]--;\n\t\t\timos[yb[i]][xa[i]]--;\n\t\t\timos[yb[i]][xb[i]]++;\n\t\t}\n\t\tdouble ret = 0;\n\t\tfor (int i = 0; i < yc.size(); i++) {\n\t\t\tfor (int j = 0; j < xc.size(); j++) {\n\t\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + imos[i][j];\n\t\t\t\tif (sum[i + 1][j + 1] > 0) ret += (xc[j + 1] - xc[j]) * (yc[i + 1] - yc[i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %.2lf\\n\", ++c, ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<P,double> Pd;\nPd p[101];\nmap <double,int> M;\nmap <int,double> M2;\nvector <Pd> Y[301];\n\n\ndouble calc(){\n  double sum=0;\n  vector <P> a;\n  for(int i=0;M2.count(i+1);i++){\n    sort(a.begin(),a.end());\n\n    for(int j=0;j<Y[i].size();j++){\n      if(Y[i][j].s==1)a.push_back(Y[i][j].f);\n      else a.erase(lower_bound(a.begin(),a.end(),Y[i][j].f));\n    }\n    sort(a.begin(),a.end());\n    \n    double l=-1e9,r=-1e9,m=0;\n    for(int j=0;j<a.size();j++){\n      if(a[j].f<r)r=max(r,a[j].s);\n      else m+=r-l,l=a[j].f,r=a[j].s;\n    }\n    m+=r-l;\n    sum+=m*(M2[i+1]-M2[i]);\n  }\n  return sum;\n}\n\nint main(){\n  int n,T=1;\n  \n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i].f.f>>p[i].f.s>>p[i].s;\n    vector<double> a;\n    for(int i=0;i<n;i++){\n      a.push_back(p[i].f.s+p[i].s);\n      a.push_back(p[i].f.s-p[i].s);\n    }\n\n    sort(a.begin(),a.end());\n    M.clear();\n    M2.clear();\n    for(int i=0,cnt=0;i<a.size();i++)if(!M.count(a[i]))M2[cnt]=a[i],M[a[i]]=cnt++;\n\n    for(int i=0;i<300;i++)Y[i].clear();\n\n    for(int i=0;i<n;i++){\n      double l=p[i].f.f-p[i].s,r=p[i].f.f+p[i].s;\n      Y[M[p[i].f.s-p[i].s]].push_back(Pd(P(l,r),1));\n      Y[M[p[i].f.s+p[i].s]].push_back(Pd(P(l,r),-1));\n    }\n    printf(\"%d %.2f\\n\",T++,calc());\n  }\n  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define N 2001\n\nusing namespace std;\n\nbool data[N][N];\nvoid syokika();\n\nmain(){\n  int n;\n  for(int count=1;;count++){\n    cin >> n;\n    if(n==0) break;\n    syokika();\n    double x, y, r;\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> r;\n      x*=10;\n      y*=10;\n      r*=10;\n      int ix, iy, ir;\n      ix=(int)x;\n      iy=(int)y;\n      ir=(int)r;\n      for(int a=ix-ir;a<=ix+ir;a++){\n\tfor(int b=iy-ir;b<=iy+ir;b++){\n\t  data[a][b]=true;\n\t}\n      }\n    }\n    int sum=0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n\tif(data[i][j]) sum++;\n      }\n    }\n    double ans=sum/100;\n    printf(\"%d %.2f\\n\", count, ans-1);\n  }\n  return 0;\n}\n\nvoid syokika(){\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      data[i][j]=false;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n};\nEvent evs[1001];\nRect recs[1001];\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  vector<int> ls,rs;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int par=find(x);\n    ls[par]=l;\n    rs[par]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    int NN=0;\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      if(EQ(r,0))continue;\n      recs[NN].first=P(x-r,y-r);\n      recs[NN].second=P(x+r,y+r);\n      evs[2*NN]=Event(y-r,true,i);\n      evs[2*NN+1]=Event(y+r,false,i);\n      NN++;\n    }\n    sort(evs,evs+2*NN);\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    // yÌ¬³¢ÔÉCxgð\n    for(int i=0;i<2*NN;i++){\n      Event &e=evs[i];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      prvy=e.y;\n      // _ÌÇÁAí\n      if(e.isIn)v.push_back(e.id);\n      else v.erase(find(v.begin(),v.end(),e.id));\n      // ¡ñÌ¡ðvZ\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  // ÍÍª©Ôéæ¤ÈçÎAunite\n\t  if((EQ(uft.rs[uft.find(i)],uft.ls[uft.find(j)])\n\t      ||(uft.rs[uft.find(i)]>uft.ls[uft.find(j)]))\n\t     &&(EQ(uft.ls[uft.find(i)],uft.rs[uft.find(j)])\n\t\t||(uft.ls[uft.find(i)]<uft.rs[uft.find(j)]))){\n\t    double minx=min(uft.ls[uft.find(i)]\n\t\t\t    ,uft.ls[uft.find(j)]);\n\t    double maxx=max(uft.rs[uft.find(i)]\n\t\t\t    ,uft.rs[uft.find(j)]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    res=(int)(res+0.005+EPS);\n    printf(\"%d %.2f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main()\n{\n  int n; int t = 0;\n  while(cin >> n, n) {\n    t++;\n    double x[101], y[101], r[101];\n    vector<double> X, Y;\n    for(int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i];\n      X.push_back(x[i]-r[i]); X.push_back(x[i]+r[i]);\n      Y.push_back(y[i]-r[i]); Y.push_back(y[i]+r[i]);\n    }\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n    X.erase(unique(X.begin(), X.end()), X.end());\n    Y.erase(unique(Y.begin(), Y.end()), Y.end());    \n    vector<P> xx(n), yy(n);\n    for(int i = 0; i < n; i++) {\n      xx[i].first  = find(X.begin(), X.end(), x[i]-r[i]) - X.begin();\n      xx[i].second = find(X.begin(), X.end(), x[i]+r[i]) - X.begin();\n      yy[i].first  = find(Y.begin(), Y.end(), y[i]-r[i]) - Y.begin();\n      yy[i].second = find(Y.begin(), Y.end(), y[i]+r[i]) - Y.begin();\n    }\n    bool mas[202][202] = {{false}};\n    for(int i = 0; i < n; i++) {\n      for(int j = yy[i].first; j <= yy[i].second; j++) {\n\tfor(int k = xx[i].first; k <= xx[i].second; k++) mas[j][k] = true;\n      }\n    }\n    double ans = 0.0;\n    for(int i = 0; i < (int)Y.size()-1; i++) {\n      for(int j = 0; j < (int)X.size()-1; j++) {\n\tif(mas[i][j]) ans += (X[j+1]-X[j])*(Y[i+1]-Y[i]);\n      }\n    }\n    printf(\"%d %.2f\\n\", t, ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stdexcept>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n\n  int n,cnt = 1;\n  while(true){\n    cin >> n;\n    if(n == 0)break;\n    set<P> graph;\n    P p[2] = {P(0,0),P(0,0)};\n    double _x,_y,_r;\n    rep(k,n){\n      cin >> _x >> _y >> _r;\n      P lb,rt;\n \n      lb = P(_x*10-_r*10,_y*10-_r*10),rt = P(_x*10+_r*10,_y*10+_r*10);\n      if(p[0].F <= lb.F && lb.F <= p[1].F && p[0].F <= rt.F && rt.F <= p[1].F && p[0].S <= lb.S && lb.S <= p[1].S && p[0].S <= rt.S && rt.S <= p[1].S)continue;\n      if((p[1].F-p[0].F)*(p[1].S-p[0].S) < (rt.F-lb.F)*(rt.S-lb.S)){\n\tp[0] = lb,p[1] = rt;\n      }\n      for(int i=lb.F;i<rt.F;i++){\n\tfor(int j=lb.S;j<rt.S;j++){\n\t  graph.insert(P(i,j));\n\t}\n      }\n    }\n    cout << setiosflags(ios::fixed) << setprecision(2) <<  cnt++ << \" \" << (double)graph.size()/100.0 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\nRect recs[101];\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n};\nEvent evs[1001];\n\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  vector<int> ls;\n  vector<int> rs;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int par=find(x);\n    ls[par]=l;\n    rs[par]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      recs[i].first=P(x-r,y-r);\n      recs[i].second=P(x+r,y+r);\n      evs[2*i]=Event(y-r,true,i);\n      evs[2*i+1]=Event(y+r,false,i);\n    }\n    sort(evs,evs+2*N);\n    // for(int i=0;i<2*N;i++)\n    //   cout<<evs[i].y<<endl;\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    // yÌ¬³¢ÔÉCxgð\n    for(int i=0;i<2*N;i++){\n      Event &e=evs[i];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      //cout<<e.y<<\" \"<<res<<\" \"<<sumLen<<endl;\n      prvy=e.y;\n      // _ðÇÁ\n      if(e.isIn){\n\t// »Ìã,¡ñÌ_ðÜßé\n\tv.push_back(e.id);\n      }\n      else\n\tv.erase(find(v.begin(),v.end(),e.id));\n      // ¡ñÌ¡ðvZ\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  // ÍÍª©Ôéæ¤ÈçÎAunite\n\t  if((EQ(uft.rs[i],uft.ls[j])\n\t      ||(uft.rs[i]>uft.ls[j]))\n\t     &&(EQ(uft.ls[i],uft.rs[j])\n\t\t||(uft.ls[i]<uft.rs[j]))){\n\t    double minx=min(uft.ls[i],uft.ls[j]);\n\t    double maxx=max(uft.rs[i],uft.rs[j]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    printf(\"%d %.10f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<double,int>P;\ntypedef pair<double,double>Pi;\ntypedef pair<Pi,int>PP;\nint main(){\n  int n,T=0;\n  while(cin>>n,n){\n    cout<<++T<<\" \";\n    double a[101],b[101],c[101];\n    vector<P> v;\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      v.push_back(P(b[i]-c[i],i));\n      v.push_back(P(b[i]+c[i],i));\n    }\n\n    sort(v.begin(),v.end());\n    double h=-1e9,w=0;\n    double ans=0;\n    vector<PP> s;\n    for(int i=0;i<v.size();i++){\n      bool f=1;\n      ans+=(v[i].first-h)*w,h=v[i].first;\n      for(int j=0;j<s.size();j++)\n\tif(s[j].second==v[i].second)s.erase(s.begin()+j),f=0;\n \n      if(f)s.push_back(PP(Pi(a[v[i].second]-c[v[i].second],a[v[i].second]+c[v[i].second]),v[i].second));\n \n      sort(s.begin(),s.end());\n \n      w=s[0].first.second-s[0].first.first;\n      double pr=s[0].first.second;\n\n \n      for(int j=0;j<s.size();j++){\n\tif(s[j].first.first<pr)w+=max(0.0,s[j].first.second-pr);\n\telse w+=s[j].first.second-s[j].first.first;\n\tpr=max(s[j].first.second,pr);\n \n      }\n    }\n    printf(\"%.2f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tdouble x;\n\tdouble y;\n\tdouble r;\n\tData(double _x,double _y,double _r){\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t}\n};\n\nbitset<40000*40000> stage;\n\nint main(){\n\tint n;\n\tint idx = 1;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tvector<Data> Points;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y,r;\n\t\t\tscanf(\"%lf %lf %lf\",&x,&y,&r);\n\t\t\tPoints.push_back(Data(x,y,r));\n\n\t\t\t//x=200; cx=20000;\n\t\t\t//x=0 cx=0;\n\t\t\t//r=200 ra=20000;\n\t\t\t//-20000<square<20000\n\n\t\t\tint cx = x*100.0;\n\t\t\tint cy = y*100.0;\n\t\t\tint ra = r*100.0; \n\n\t\t\tfor(ll dy= cy-ra;dy<cy+ra;dy++){\n\t\t\t\tfor(ll dx = cx-ra;dx < cx+ra; dx++){\n\t\t\t\t\tstage[(dy+20000)*40000+(dx+20000)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %.2lf\\n\",idx++,stage.count()/(double)10000);\t\t\n\t\tstage.reset();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint W,H;\nint X1[222],Y1[222],X2[222],Y2[222];\nint sx1[222],sy1[222];\nint sx2[222],sy2[222];\nbool F[555][555];\nint dx[555],dy[555];\n\nint zip( int *Z1, int *Z2, int *z1, int *z2, int *d ){\n  vector<int> ps;\n  for(int i=0;i<N;i++){\n    ps.push_back( Z1[i] );\n    ps.push_back( Z2[i] );\n  }\n  sort( ps.begin(), ps.end() );\n  ps.erase( unique( ps.begin(), ps.end() ), ps.end() );\n  int w = ps.size();\n  for(int i=0;i<w;i++){\n    z1[i] = lower_bound( ps.begin(), ps.end(), X1[i] ) - ps.begin();\n    z2[i] = lower_bound( ps.begin(), ps.end(), X2[i] ) - ps.begin();\n  }\n  for(int i=0;i<w;i++){\n    d[i] = ps[i];\n  }\n  return w;\n}\n\nint main(){\n  int ttt=0;\n  while( ~scanf(\"%d\",&N) && N ){\n    memset( F,0,sizeof( F ) );\n    for(int i=0;i<N;i++){\n      int x,xx,y,yy,r,rr;\n      scanf(\"%d.%d %d.%d %d.%d\",&x,&xx,&y,&yy,&r,&rr);\n      x = x*10 + xx;\n      y = y*10 + yy;\n      r = r*10 + rr;\n      X1[i] = x - r;\n      X2[i] = x + r;\n      Y1[i] = y - r;\n      Y2[i] = y + r;\n    }\n    W = zip( X1, X2, sx1, sx2, dx );\n    H = zip( Y1, Y2, sy1, sy2, dy );\n    for(int i=0;i<N;i++){\n      //cout << sx1[i] << \" - \" <<sx2[i] << endl;\n      //cout << sy1[i] << \" - \" <<sy2[i] << endl;\n      for(int x=sx1[i];x<sx2[i];x++){\n        for(int y=sy1[i];y<sy2[i];y++){\n          F[x][y] = true;\n        }\n      }\n    }\n    long long res = 0.0;\n    for(int x=0;x<W;x++){\n      for(int y=0;y<H;y++){\n        if( F[x][y] ) {\n          //cout << dx[x+1]-dx[x] << \" * \" << dy[y+1]-dy[y] << endl;\n          res += (long long)( dx[x+1]-dx[x] ) * (long long)( dy[y+1]-dy[y] );      \n\n        }\n      }\n    }\n    printf(\"%d %lld.%02lld\\n\",++ttt,res/100LL,res%100LL);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<P,double> Pd;\nPd p[101];\nvector<Pd> d;\n\nmap <double,int> M;\nmap <int,double> M2;\nvector <Pd> Y[301];\n\n\ndouble calc(){\n  double sum=0;\n  vector <P> a;\n  for(int i=0;i<300&&M2.count(i+1);i++){\n    sort(a.begin(),a.end());\n    for(int j=0;j<Y[i].size();j++){\n      if(Y[i][j].s==1)a.push_back(Y[i][j].f);\n      else a.erase(lower_bound(a.begin(),a.end(),Y[i][j].f));\n    }\n    sort(a.begin(),a.end());\n    \n    double l=0,r=0,m=0;\n    for(int j=0;j<a.size();j++){\n      if(a[j].f<r)r=max(r,a[j].s);\n      else m+=r-l,l=a[j].f,r=a[j].s;\n    }\n    m+=r-l;\n    sum+=m*(M2[i+1]-M2[i]);\n  }\n  return sum;\n}\n\nint main(){\n  int n,T=1;\n\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i].f.f>>p[i].f.s>>p[i].s;\n    vector<double> a;\n    for(int i=0;i<n;i++){\n      a.push_back(p[i].f.s+p[i].s);\n      a.push_back(p[i].f.s-p[i].s);\n    }\n\n    sort(a.begin(),a.end());\n    M.clear();\n    for(int i=0,cnt=0;i<a.size();i++)if(!M.count(a[i]))M2[cnt]=a[i],M[a[i]]=cnt++;\n\n    for(int i=0;i<300;i++)Y[i].clear();\n    for(int i=0;i<n;i++){\n      int l=p[i].f.f-p[i].s,r=p[i].f.f+p[i].s;\n      Y[M[p[i].f.s-p[i].s]].push_back(Pd(P(l,r),1));\n      Y[M[p[i].f.s+p[i].s]].push_back(Pd(P(l,r),-1));\n    }\n    for(int i=0;i<301;i++) sort(Y[i].begin(),Y[i].end());\n    printf(\"%d %.2f\\n\",T++,calc());\n \n  }\n  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#define DIF 5000\n#define all(n) n.begin(),n.end()\nusing namespace std;\n\nvoid draw(vector<vector<bool> >& graph,int sx,int sy,int ex,int ey)\n{\n  for(int i=sy;i<ey;i++)\n    for(int j=sx;j<ex;j++)\n      graph[i][j] = true;\n}\n\nint main()\n{\n  int n,NARI = 1;\n  while(cin >> n,n)\n    {      \n      vector<int> X,Y,X1,X2,Y1,Y2;\n      vector<vector<bool> > graph;\n      graph.resize(210);\n\n      for(int i=0;i<210;i++)\n\t{\n\t  graph[i].resize(210);\n\t  for(int j=0;j<210;j++)\n\t    graph[i][j] = false;\n\t}\n\n      for(int i=0;i<n;i++)\n\t{\n\t  double x,y,r;\n\t  cin >> x >> y >> r;\n\t  X.push_back(x+r),X.push_back(x-r);\n\t  Y.push_back(y+r),Y.push_back(y-r);\n\t  X1.push_back(x-r),Y1.push_back(y-r);\n\t  X2.push_back(x+r),Y2.push_back(y+r);\n\t}\n      sort(all(X));\n      sort(all(Y));\n      X.erase(unique(all(X)),X.end());\n      Y.erase(unique(all(Y)),Y.end());\n\n      for(int i=0;i<n;i++)\n\t{\n\n\t  X1[i] = find(all(X),X1[i]) - X.begin();\n\t  Y1[i] = find(all(Y),Y1[i]) - Y.begin();\n\n\t  X2[i] = find(all(X),X2[i]) - X.begin();\n\t  Y2[i] = find(all(Y),Y2[i]) - Y.begin();\n\n\t}\n\n      for(int i=0;i<n;i++)\n\t  draw(graph,X1[i],Y1[i],X2[i],Y2[i]);\n\n      double ans = 0;\n      for(int i=0;i<Y.size()-1;i++)\n\tfor(int j=0;j<X.size()-1;j++)\n\t  if(graph[i][j])\n\t      ans += (X[j+1]-X[j])*(Y[i+1]-Y[i]);\n\t    \n\t  \t    \n      cout << NARI++ << setiosflags(ios::fixed) << setprecision(2)<< \" \" << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nstruct bar{\n\tdouble x1, x2, y;\n\tbool f;\n\t\n\tbar(double x1, double x2, double y, bool f)\n\t\t: x1(x1), x2(x2), y(y), f(f) {}\n\t\n\tbool operator<(const bar &b) const{\n\t\treturn y < b.y;\n\t}\n};\n\nint main(){\n\tint n;\n\tdouble x, y, r;\n\tfor(int number = 1; scanf(\"%d\", &n), n != 0; ++number){\n\t\tvector<bar> bars;\n\t\tvector<double> xs;\n\t\tbars.reserve(2 * n);\n\t\txs.reserve(2 * n);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf%lf\", &x, &y, &r);\n\t\t\tdouble x1 = x - r;\n\t\t\tdouble x2 = x + r;\n\t\t\t\n\t\t\txs.push_back(x1);\n\t\t\txs.push_back(x2);\n\t\t\tbars.push_back( bar(x1, x2, y - r, true) );\n\t\t\tbars.push_back( bar(x1, x2, y + r, false) );\n\t\t}\n\t\t\n\t\tsort(xs.begin(), xs.end());\n\t\txs.erase( unique(xs.begin(), xs.end()), xs.end() );\n\t\tsort(bars.begin(), bars.end());\n\n\t\tdouble ans = 0.0;\n\t\tfor(int i = 1; i < xs.size(); ++i){\n\t\t\tint cnt = 0;\n\t\t\tdouble prev = 0.0;\n\t\t\tdouble len = 0.0;\n\n\t\t\tfor(int j = 0; j < bars.size(); ++j){\n\t\t\t\tif( bars[j].x1 < xs[i] && bars[j].x2 >= xs[i] ){\n\t\t\t\t\tif( bars[j].f ){\n\t\t\t\t\t\tif( ++cnt == 1 ){\n\t\t\t\t\t\t\tprev = bars[j].y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif( --cnt == 0 ){\n\t\t\t\t\t\t\tlen += bars[j].y - prev;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans += (xs[i] - xs[i-1]) * len;\n\t\t}\n\t\t\n\t\tprintf(\"%d %.2f\\n\", number, ans);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint W,H;\nint X1[222],Y1[222],X2[222],Y2[222];\nint sx1[222],sy1[222];\nint sx2[222],sy2[222];\nbool F[555][555];\nint dx[555],dy[555];\n\nint zip( int *Z1, int *Z2, int *z1, int *z2, int *d ){\n  vector<int> ps;\n  for(int i=0;i<N;i++){\n    ps.push_back( Z1[i] );\n    ps.push_back( Z2[i] );\n  }\n  sort( ps.begin(), ps.end() );\n  ps.erase( unique( ps.begin(), ps.end() ), ps.end() );\n  int w = ps.size();\n  for(int i=0;i<w;i++){\n    z1[i] = lower_bound( ps.begin(), ps.end(), X1[i] ) - ps.begin();\n    z2[i] = lower_bound( ps.begin(), ps.end(), X2[i] ) - ps.begin();\n  }\n  for(int i=0;i<w;i++){\n    d[i] = ps[i];\n  }\n  return w;\n}\n\nint main(){\n  int ttt=0;\n  while( ~scanf(\"%d\",&N) && N ){\n    memset( F,0,sizeof( F ) );\n    for(int i=0;i<N;i++){\n      int x,xx,y,yy,r,rr;\n      scanf(\"%d.%d %d.%d %d.%d\",&x,&xx,&y,&yy,&r,&rr);\nassert( xx<10 );\nassert( yy<10 );\nassert( rr<10 );\n      x = x*10 + xx;\n      y = y*10 + yy;\n      r = r*10 + rr;\n      X1[i] = x - r;\n      X2[i] = x + r;\n      Y1[i] = y - r;\n      Y2[i] = y + r;\n    }\n    W = zip( X1, X2, sx1, sx2, dx );\n    H = zip( Y1, Y2, sy1, sy2, dy );\n    for(int i=0;i<N;i++){\n      //cout << sx1[i] << \" - \" <<sx2[i] << endl;\n      //cout << sy1[i] << \" - \" <<sy2[i] << endl;\n      for(int x=sx1[i];x<sx2[i];x++){\n        for(int y=sy1[i];y<sy2[i];y++){\n          F[x][y] = true;\n        }\n      }\n    }\n    long long res = 0.0;\n    for(int x=0;x<W;x++){\n      for(int y=0;y<H;y++){\n        if( F[x][y] ) {\n          //cout << dx[x+1]-dx[x] << \" * \" << dy[y+1]-dy[y] << endl;\n          res += (long long)( dx[x+1]-dx[x] ) * (long long)( dy[y+1]-dy[y] );      \n\n        }\n      }\n    }\n    printf(\"%d %lld.%02lld\\n\",++ttt,res/100LL,res%100LL);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct interval{\n\tT a,b;\n\tint id;\n\tbool operator<(const interval &I)const{ return a+EPS<I.a || abs(a-I.a)<EPS && b+EPS<I.b; }\n};\n\ndouble calc_width(vector< interval<double> > &I){\n\tint n=I.size();\n\tif(n==0) return 0;\n\tsort(I.begin(),I.end());\n\n\tdouble res=0;\n\tdouble left=I[0].a,right=I[0].b;\n\trep(i,n){\n\t\tif(right+EPS<I[i].a){\n\t\t\tres+=right-left;\n\t\t\tleft=I[i].a;\n\t\t}\n\t\telse{\n\t\t\tright=max(right,I[i].b);\n\t\t}\n\t}\n\tres+=right-left;\n\n\treturn res;\n}\n\nint main(){\n\tfor(int test=1,n;scanf(\"%d\",&n),n;test++){\n\t\tvector< pair< double,interval<double> > > E;\n\t\trep(i,n){\n\t\t\tdouble x,y,r; scanf(\"%lf%lf%lf\",&x,&y,&r);\n\t\t\tE.push_back(make_pair(y-r,(interval<double>){x-r,x+r,i}));\n\t\t\tE.push_back(make_pair(y+r,(interval<double>){x-r,x+r,i}));\n\t\t}\n\t\tsort(E.begin(),E.end());\n\n\t\tvector< interval<double> > I;\n\t\tdouble ans=0,h=0,w=0;\n\t\tbool b[100]={}; // b[i] := ( 正方形 i に対応する区間を見ているかどうか )\n\t\trep(t,E.size()){\n\t\t\tinterval<double> J=E[t].second;\n\t\t\tif(!b[J.id]){\n\t\t\t\tI.push_back(J);\n\t\t\t\tb[J.id]=true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(i,I.size()) if(I[i].id==J.id) { I.erase(I.begin()+i); break; }\n\t\t\t\tb[J.id]=false;\n\t\t\t}\n\n\t\t\tans+=(E[t].first-h)*w;\n\t\t\th=E[t].first;\n\t\t\tw=calc_width(I);\n\t\t}\n\n\t\tprintf(\"%d %.2f\\n\",test,ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<double,int>P;\ntypedef pair<double,double>Pi;\ntypedef pair<P,double>PP;\nint main(){\n  int n,T=0;\n  while(cin>>n,n){\n    cout<<++T<<\" \";\n    double a[101],b[101],c[101];\n    vector<P> v;\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      v.push_back(P(b[i]-c[i],-i));\n      v.push_back(P(b[i]+c[i],i));\n    }\n\n    sort(v.begin(),v.end());\n    double h=-1e9,w=0;\n    double ans=0;\n    vector<PP> s;\n    for(int i=0;i<v.size();i++){\n      ans+=(v[i].first-h)*w,h=v[i].first;\n\n      bool f=1;\n      for(int j=0;j<s.size();j++)\n\tif(s[j].first.second==-v[i].second)s.erase(s.begin()+j),f=0;\n\n      if(f)s.push_back(PP(P(a[v[i].second]-c[v[i].second],v[i].second),a[v[i].second]+c[v[i].second]));\n\n      sort(s.begin(),s.end());\n\n      w=s[0].second-s[0].first.first;\n      double pr=s[0].second;\n\n      for(int j=0;j<s.size();j++){\n\tif(s[j].first.first<pr)w+=max(0.0,s[j].second-pr);\n\telse w+=s[j].second-s[j].first.first;\n\tpr=max(s[j].second,pr);\n\n      }\n    }\n    printf(\"%.2f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\n\nvector<pair<P, P> > p;\nvector<double> xx;\n\nint main() {\n  int n;\n  for (int iii = 1;; ++iii) {\n    cin >> n;\n    if (n == 0) break;\n    p.clear();\n    xx.clear();\n    rep (i, n) {\n      double x, y, r;\n      cin >> x >> y >> r;\n      p.push_back(make_pair(P(x - r, y - r), P(x + r, y + r)));\n      xx.push_back(x - r);\n      xx.push_back(x + r);\n    }\n    sort(xx.begin(), xx.end());\n    double res = 0;\n    rep (i, xx.size() - 1) {\n      vector<pair<double,int> > imos;\n      double m = (xx[i] + xx[i + 1]) / 2;\n      rep (j, n) {\n\tif (p[j].first.X <= m && m <= p[j].second.X) {\n\t  imos.push_back(make_pair(p[j].first.Y, 1));\n\t  imos.push_back(make_pair(p[j].second.Y, -1));\n\t}\n      }\n      sort(imos.begin(), imos.end());\n      int im = 1;\n      rep (j, imos.size() - 1) {\n\tif (im > 0) {\n\t  res += (xx[i + 1] - xx[i]) * (imos[j + 1].first - imos[j].first);\n\t}\n\tim += imos[j + 1].second;\n      }\n    }\n    printf(\"%d %.2lf\\n\", iii, res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<double,int>P;\ntypedef pair<double,double>Pi;\ntypedef pair<Pi,int>PP;\nint main(){\n  int n,T=0;\n  while(cin>>n,n){\n    cout<<++T<<\" \";\n    double a[101],b[101],c[101];\n    vector<P> v;\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      v.push_back(P(b[i]-c[i],i));\n      v.push_back(P(b[i]+c[i],i));\n    }\n    sort(v.begin(),v.end());\n    double h=-1e9,w=0;\n    double ans=0;\n    vector<PP> s;\n    for(int i=0;i<v.size();i++){\n      bool f=1;\n      for(int j=0;j<s.size();j++){\n\tif(s[j].second==v[i].second)s.erase(s.begin()+j),f=0;\n      }\n\n      if(f)s.push_back(PP(Pi(a[v[i].second]-c[v[i].second],a[v[i].second]+c[v[i].second]),v[i].second));\n\n      ans+=(v[i].first-h)*w,h=v[i].first;\n      sort(s.begin(),s.end());\n\n      w=s[0].first.second-s[0].first.first;\n      double pr=s[0].first.second;\n\n      for(int j=0;j<s.size();j++){\n\tif(s[j].first.first<pr)w+=max(0.0,s[j].first.second-pr);\n\telse w+=s[j].first.second-s[j].first.first;\n\tpr=max(s[j].first.second,pr);\n\n      }\n    }\n    printf(\"%.2f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\nvector<pair<pair<double, int> , Pd> > ls;\nbool use[300];\n\ndouble calc(vector<Pd> range){\n\tdouble res = 0.0;\n\tsort(range.begin(), range.end());\n\tbool update = true;\n\tint sz = range.size();\n\twhile(update){\n\t\tupdate = false;\n\t\tint c = 0;\n\t\trep(i, sz){\n\t\t\tif(i == sz - 1){\n\t\t\t\trange[c++] = range[i];\n\t\t\t}else if(range[i].second < range[i].first){\n\t\t\t\trange[c++] = range[i];\n\t\t\t}else{\n\t\t\t\trange[c++] = Pd(min(range[i].first, range[i+1].first), max(range[i].second, range[i+1].second));\n\t\t\t\ti++;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\tsz = c;\n\t\trange.resize(sz);\n\t}\n\n\trep(i, sz){\n\t\tres += range[i].second - range[i].first;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, sz;\n\tint cnt = 1;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\trep(i, n){\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tls.push_back(make_pair(make_pair(y - r, i), Pd(x - r, x + r)));\n\t\t\tls.push_back(make_pair(make_pair(y + r, i), Pd(x - r, x + r)));\n\t\t}\n\t\tsort(ls.begin(), ls.end());\n\t\tmemset(use, false, sizeof(use));\n\t\tsz = ls.size();\n\t\tdouble pre = -1e4;\n\t\tdouble res = 0.0;\n\t\trep(i, sz){\n\t\t\tint id = ls[i].first.second;\n\t\t\tdouble cur = ls[i].first.first;\n\t\t\tvector<Pd> range;\n\t\t\trep(i, sz){\n\t\t\t\tif(use[i]) range.push_back(ls[i].second);\n\t\t\t}\n\t\t\tres += (cur - pre) * calc(range);\n\t\t\tpre = cur;\n\t\t\tuse[id] = !use[id];\t\t\t\n\t\t}\n\t\tcout << cnt++ << \" \" << fixed << setprecision(2) << (int)(res * 100 + 0.5) / 100.0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\ntypedef pair<P,P> Rect;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\nint N;\n\nclass Event{\npublic:\n  double y;\n  bool isIn;\n  int id;\n  bool operator<(const Event& e)const{\n    return e.y>this->y; \n  }\n  Event(){}\n  Event(double y_,bool isIn_,int id_){\n    y=y_;\n    isIn=isIn_;\n    id=id_;\n  }\n};\nEvent evs[1001];\nRect recs[1001];\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  vector<int> ls,rs;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      ls.push_back(0);\n      rs.push_back(0);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,double l,double r){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    int par=find(x);\n    ls[par]=l;\n    rs[par]=r;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nint main(){\n  int cnt=0;\n  while(cin>>N&&N){\n    int NN=0;\n    for(int i=0;i<N;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      recs[i].first=P(x-r,y-r);\n      recs[i].second=P(x+r,y+r);\n      if(EQ(r,0))continue;\n      evs[2*NN]=Event(y-r,true,i);\n      evs[2*NN+1]=Event(y+r,false,i);\n      NN++;\n    }\n    sort(evs,evs+2*NN);\n    double prvy=-INF;\n    double sumLen=0;\n    double res=0;\n    vector<int> v;\n    // yÌ¬³¢ÔÉCxgð\n    for(int i=0;i<2*NN;i++){\n      Event &e=evs[i];\n      if(!EQ(prvy,-INF))res+=sumLen*(e.y-prvy);\n      prvy=e.y;\n      // _ÌÇÁAí\n      if(e.isIn)v.push_back(e.id);\n      else v.erase(find(v.begin(),v.end(),e.id));\n      // ¡ñÌ¡ðvZ\n      UnionFindTree uft(v.size());\n      for(int i=0;i<v.size();i++){\n\tuft.ls[i]=recs[v[i]].first.real();\n\tuft.rs[i]=recs[v[i]].second.real();\n      }\n      for(int i=0;i<v.size();i++){\n\tfor(int j=i+1;j<v.size();j++){\n\t  // ÍÍª©Ôéæ¤ÈçÎAunite\n\t  if((EQ(uft.rs[uft.find(i)]\n\t\t ,uft.ls[uft.find(j)])\n\t      ||(uft.rs[uft.find(i)]\n\t\t >uft.ls[uft.find(j)]))\n\t     &&(EQ(uft.ls[uft.find(i)]\n\t\t   ,uft.rs[uft.find(j)])\n\t\t||(uft.ls[uft.find(i)]\n\t\t   <uft.rs[uft.find(j)]))){\n\t    double minx=min(uft.ls[uft.find(i)]\n\t\t\t    ,uft.ls[uft.find(j)]);\n\t    double maxx=max(uft.rs[uft.find(i)]\n\t\t\t    ,uft.rs[uft.find(j)]);\n\t    uft.unite(i,j,minx,maxx);\n\t  }\n\t}\n      }\n      set<int> s;\n      for(int i=0;i<v.size();i++)\n\ts.insert(uft.find(i));\n      sumLen=0;\n      for(set<int>::iterator it\n\t    =s.begin();it!=s.end();it++){\n\tsumLen+=(uft.rs[*it]-uft.ls[*it]);\n      }\n    }\n    cnt++;\n    printf(\"%d %.2f\\n\",cnt,res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nstruct node {\n    ll y, l, r;\n    bool isadd;\n\n    bool operator<(const node& a) {\n        return y < a.y;\n    }\n};\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll tc = 1;\n    while(1) {\n        ll n;\n        cin >> n;\n        if(!n) break;\n        vector<node> v;\n        REP(i, n) {\n            double x, y, r;\n            cin >> x >> y >> r;\n            ll xx = x*100, yy = y*100, rr = r*100;\n            v.push_back({yy-rr+20000, xx-rr+20000, xx+rr+20000, true});\n            v.push_back({yy+rr+20000, xx-rr+20000, xx+rr+20000, false});\n        }\n        sort(ALL(v));\n\n        vector<int> now(40001);\n        ll prev = 0, width = 0, ans = 0;\n        REP(i, v.size()) {\n            // (y座標のdiff) * width\n            ans += (v[i].y - prev) * width;\n            // cout << \"y:\" << v[i].y << \" prev:\" << prev << \" width:\" << width << \" ans:\" << ans << endl;\n            prev = v[i].y;\n            // widthの計算\n            // cout << \"l:\" << v[i].l << \" r:\" << v[i].r << \" isadd:\" << v[i].isadd << endl;\n            if(v[i].isadd) FOR(x, v[i].l, v[i].r) now[x]++;\n            else FOR(x, v[i].l, v[i].r) now[x]--;\n            // cout << now << endl;\n            width = 0;\n            REP(x, 40001) width += (now[x]>0);\n        }\n\n        cout << tc << \" \" << fixed << setprecision(2) << ans/10000.0 << endl;\n        tc++;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Point{\npublic:\n  double Lx,Rx,Uy,Dy;\n};\n\nint main(){\n  int i,j,k,n,c,cc=0;\n  double x,y,r,ans;\n  Point p[100],q[10000];\n  while(1){\n    cc++;\n    cin >> n;\n    if(n == 0) break;\n\n    ans = 0;\n    c = 0;\n    for(i=0;i<n;i++){\n      cin >> x >> y >> r;\n      p[i].Uy = y + r;\n      p[i].Dy = y - r;\n      p[i].Lx = x - r;\n      p[i].Rx = x + r;\n      ans += pow(2*r,2);\n    }\n\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n\tif((p[i].Lx <= p[j].Lx && p[j].Lx <= p[i].Rx || p[i].Lx <= p[j].Rx && p[j].Rx <= p[i].Rx) && (p[i].Dy <= p[j].Dy && p[j].Dy <= p[i].Uy || p[i].Dy <= p[j].Uy && p[j].Uy <= p[i].Uy)){\n\t  double lx,rx,uy,dy;\n\t  lx = max(p[i].Lx,p[j].Lx);\n\t  rx = min(p[i].Rx,p[j].Rx);\n\t  dy = max(p[i].Dy,p[j].Dy);\n\t  uy = min(p[i].Uy,p[j].Uy);\n\n\t  for(k=0;k<c;k++){\n\t    if(q[k].Uy == uy && q[k].Dy == dy && q[k].Lx == lx && q[k].Rx == rx) break;\n\t  }\n\t  \n\t  if(k == c) ans -= (rx - lx) * (uy - dy);\n\n\t  q[c].Uy = uy;\n\t  q[c].Dy = dy;\n\t  q[c].Lx = lx;\n\t  q[c].Rx = rx;\n\t  c++;\n\t}\n      }\n    }\n    \n    printf(\"%d %.2f\\n\",cc,ans);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<P,double> Pd;\nPd p[101];\nmap <double,int> M;\nmap <int,double> M2;\nvector <Pd> Y[301];\n\n\ndouble calc(){\n  double sum=0;\n  vector <P> a;\n  for(int i=0;M2.count(i+1);i++){\n    sort(a.begin(),a.end());\n\n    for(int j=0;j<Y[i].size();j++){\n      if(Y[i][j].s==1)a.push_back(Y[i][j].f);\n      else a.erase(lower_bound(a.begin(),a.end(),Y[i][j].f));\n    }\n    sort(a.begin(),a.end());\n    \n    double l=0,r=-1e9,m=0;\n    for(int j=0;j<a.size();j++){\n      if(a[j].f<r)r=max(r,a[j].s);\n      else m+=r-l,l=a[j].f,r=a[j].s;\n    }\n    m+=r-l;\n    sum+=m*(M2[i+1]-M2[i]);\n  }\n  return sum;\n}\n\nint main(){\n  int n,T=1;\n  \n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i].f.f>>p[i].f.s>>p[i].s;\n    vector<double> a;\n    for(int i=0;i<n;i++){\n      a.push_back(p[i].f.s+p[i].s);\n      a.push_back(p[i].f.s-p[i].s);\n    }\n\n    sort(a.begin(),a.end());\n    M.clear();\n    M2.clear();\n    for(int i=0,cnt=0;i<a.size();i++)if(!M.count(a[i]))M2[cnt]=a[i],M[a[i]]=cnt++;\n\n    for(int i=0;i<300;i++)Y[i].clear();\n\n    for(int i=0;i<n;i++){\n      double l=p[i].f.f-p[i].s,r=p[i].f.f+p[i].s;\n      Y[M[p[i].f.s-p[i].s]].push_back(Pd(P(l,r),1));\n      Y[M[p[i].f.s+p[i].s]].push_back(Pd(P(l,r),-1));\n    }\n    printf(\"%d %.2f\\n\",T++,calc());\n  }\n  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main()\n{\n  int n; int t = 0;\n  while(cin >> n, n) {\n    t++;\n    double x[101], y[101], r[101];\n    vector<double> X, Y;\n    for(int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i];\n      X.push_back(x[i]-r[i]); X.push_back(x[i]+r[i]);\n      Y.push_back(y[i]-r[i]); Y.push_back(y[i]+r[i]);\n    }\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n    X.erase(unique(X.begin(), X.end()), X.end());\n    Y.erase(unique(Y.begin(), Y.end()), Y.end());    \n    vector<P> xx(n), yy(n);\n    for(int i = 0; i < n; i++) {\n      xx[i].first  = find(X.begin(), X.end(), x[i]-r[i]) - X.begin();\n      xx[i].second = find(X.begin(), X.end(), x[i]+r[i]) - X.begin();\n      yy[i].first  = find(Y.begin(), Y.end(), y[i]-r[i]) - Y.begin();\n      yy[i].second = find(Y.begin(), Y.end(), y[i]+r[i]) - Y.begin();\n    }\n    bool mas[202][202] = {{false}};\n    for(int i = 0; i < n; i++) {\n      for(int j = yy[i].first; j < yy[i].second; j++) {\n\tfor(int k = xx[i].first; k < xx[i].second; k++) mas[j][k] = true;\n      }\n    }\n    double ans = 0.0;\n    for(int i = 0; i < (int)Y.size()-1; i++) {\n      for(int j = 0; j < (int)X.size()-1; j++) {\n\tif(mas[i][j])  ans += (X[j+1]-X[j])*(Y[i+1]-Y[i]);\n      }\n    }\n    printf(\"%d %.2f\\n\", t, ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int N, tc = 1;\n    while (cin >> N, N) {\n        vector<double> X1(N), Y1(N), X2(N), Y2(N);\n        vector<double> xs, ys;\n        for (int i = 0; i < N; i++) {\n            double x, y, r;\n            cin >> x >> y >> r;\n            X1[i] = x - r; Y1[i] = y - r;\n            X2[i] = x + r; Y2[i] = y + r;\n            xs.push_back(X1[i]); xs.push_back(X2[i]);\n            ys.push_back(Y1[i]); ys.push_back(Y2[i]);\n        }\n\n        sort(xs.begin(), xs.end());\n        xs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n        sort(ys.begin(), ys.end());\n        ys.erase(unique(ys.begin(), ys.end()), ys.end());\n        \n        double res = 0;\n        for (int i = 0; i < (int)xs.size()-1; i++) {\n            for (int j = 0; j < (int)ys.size()-1; j++) {\n                int cnt = 0;\n                for (int k = 0; k < N; k++) {\n                    if (X1[k] <= xs[i] && xs[i+1] <= X2[k] &&\n                        Y1[k] <= ys[j] && ys[j+1] <= Y2[k]) {\n                        cnt++;\n                    }\n                }\n                if (cnt > 0) {\n                    res += (xs[i+1] - xs[i]) * (ys[j+1] - ys[j]);\n                }\n            }\n        } \n        printf(\"%d %.2f\\n\", tc++, res);\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<map>\n#include<complex>\n\n#define START 0\n#define END 1\nusing namespace std;\n\ntypedef complex<double> point;\n\nconst double infty = 1e40;\nconst double eps = 1e-10;\n\nbool eq(double a, double b){\n  return abs(b-a) < eps;\n}\n\nstruct anntena{\n  point ul, rd;\n  anntena(point a, point b):ul(a),rd(b){}\n  bool isinside(const point &t){\n    if( ul.real()<=t.real()&&t.real()<=rd.real()&&\n\tul.imag()>=t.imag()&&t.imag()>=rd.imag())return true;\n    return false;\n  }\n};\n\nint main()\n{\n  int n;\n  int tc=1;\n  while(cin>>n && n>0){\n    double res = 0;\n    set<double> X;\n    set<double> Y;\n    vector<anntena> va;\n\n    for(int i = 0; i < n; ++i){\n      double x,y,r;\n      scanf(\"%lf%lf%lf\", &x, &y, &r);\n      X.insert(x-r);\n      X.insert(x+r);\n      Y.insert(y-r);\n      Y.insert(y+r);\n      va.push_back( anntena(point(x-r,y+r), point(x+r,y-r) ) );\n    }\n    for(set<double>::iterator itx = X.begin(); itx != X.end(); ++itx){\n\n      double x = *itx;\n      ++itx;\n      if(itx==X.end())break;\n      double nx = *itx;\n      --itx;\n      double span_x = nx - x;\n      for(set<double>::iterator ity = Y.begin(); ity != Y.end(); ++ity){\n\tdouble y = *ity;\n\t++ity;\n\tif(ity==Y.end())break;\n\tdouble ny = *ity;\n\t--ity;\n\tdouble span_y = ny - y;\n\tpoint cent = point((x+nx)/2,(y+ny)/2);\n\tbool cent_cont = false;\n\tfor(int i = 0; i < (int)va.size(); ++i){\n\t  if( va[i].isinside( cent ) ) cent_cont = true;\n\t}\n\tif( cent_cont ){\n\t  res += span_x * span_y;\n\t}\n      } \n    }\n    printf(\"%d %.2lf\\n\", tc, res);\n    ++tc;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int tc=1,n;cin>>n,n;tc++){\n\t\tvd xs(n),ys(n),rs(n);\n\t\trep(i,n) cin>>xs[i]>>ys[i]>>rs[i];\n\t\t\n\t\tvd Y;\n\t\trep(i,n){\n\t\t\tY.push_back(ys[i]-rs[i]);\n\t\t\tY.push_back(ys[i]+rs[i]);\n\t\t}\n\t\t\n\t\tauto feq=[](double a,double b){return abs(a-b)<EPS;};\n\t\tauto fle=[](double a,double b){return a<b-EPS;};\n\t\t\n\t\tsort(all(Y),fle); Y.erase(unique(all(Y),feq),Y.end());\n\t\t\n\t\tvector<vector<pdd>> segs(Y.size());\n\t\trep(i,n){\n\t\t\tint first=lower_bound(all(Y),ys[i]-rs[i]-EPS)-Y.begin();\n\t\t\tint last=lower_bound(all(Y),ys[i]+rs[i]-EPS)-Y.begin();\n\t\t\trepi(j,first,last)\n\t\t\t\tsegs[j].emplace_back(xs[i]-rs[i],xs[i]+rs[i]);\n\t\t}\n\t\t\n\t\trep(i,segs.size())\n\t\t\tsort(all(segs[i]),[fle,feq](pdd a,pdd b){return fle(a.first,b.first)||feq(a.first,b.first)&&fle(a.second,b.second);});\n\t\t\n\t\tdouble res=0;\n\t\trep(i,segs.size()-1){\n\t\t\tdouble r=-INFTY;\n\t\t\tfor(pdd seg:segs[i]){\n\t\t\t\tif(r<seg.second)\n\t\t\t\t\tres+=(Y[i+1]-Y[i])*(seg.second-max(seg.first,r));\n\t\t\t\tr=max(r,seg.second);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d %.2f\\n\",tc,res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n  Point p1, p2;\n};\n\ntypedef Segment Line;\ntypedef Segment Rect;\n\nclass Region {\npublic:\n  Point p;\n  double r;\n  bool operator < (const Region &re) const {\n    return r != re.r ? r < re.r : p < re.p;\n  }\n};\n\nint n;\nRegion re[100];\n\nbool isOn(Rect a, Rect b) {\n  if(a.p1.x >= b.p2.x) return false;\n  if(a.p1.y >= b.p2.y) return false;\n  if(a.p2.x <= b.p1.x) return false;\n  if(a.p2.y <= b.p1.y) return false;\n  return true;\n}\n\ndouble solve() {\n  vector<Rect> v;\n  vector<Rect>::iterator it;\n  Rect rt;\n  sort(re, re+n);\n  for(int i = 0; i < n; ++i) {\n    rt.p1 = Point(re[i].p.x - re[i].r, re[i].p.y - re[i].r);\n    rt.p2 = Point(re[i].p.x + re[i].r, re[i].p.y + re[i].r);\n\n    it = v.begin();\n    vector<Rect> tmpV;\n    while(it != v.end()) {\n      if(it->p1.x >= rt.p1.x && it->p1.x <=rt.p2.x &&\n\t it->p1.y >= rt.p1.y && it->p1.y <=rt.p2.y ) {\n\tit = v.erase(it);\n      } else {\n\tif(isOn(rt, *it)) {\n\t  if(it->p1.x > rt.p1.x && it->p2.x < rt.p2.x) {\n\t    if(it->p1.y < rt.p1.y) {\n\t      it->p2.y = rt.p1.y;\n\t    } else {\n\t      it->p1.y = rt.p2.y;\n\t    }\n\t  }\n\t  else if(it->p1.y > rt.p1.y && it->p2.y < rt.p2.y) {\n\t    if(it->p1.x < rt.p1.x) {\n\t      it->p2.x = rt.p1.x;\n\t    } else {\n\t      it->p1.x = rt.p2.x;\n\t    }\n\t  }\n\t  else {\n\t    Rect tmp = *it;\n\t    if(it->p1.y < rt.p1.y) {\n\t      it->p2.y = rt.p1.y;\n\t      tmp.p1.y = rt.p1.y;\n\t    } else {\n\t      it->p1.y = rt.p2.y;\n\t      tmp.p2.y = rt.p2.y;\n\t    }\n\n\t    if(tmp.p1.x < rt.p1.x) {\n\t      tmp.p2.x = rt.p1.x;\n\t    } else {\n\t      tmp.p1.x = rt.p2.x;\n\t    }\n\t    tmpV.push_back(tmp);\n\t  }\n\t}\n\t++it;\n      }\n    }\n    v.push_back(rt);\n    for(int j = 0; j < tmpV.size(); ++j) {\n      v.push_back(tmpV[j]);\n    }\n  }\n\n  double ans = 0;\n  for(int i = 0; i < v.size(); ++i) {\n    ans += (v[i].p2.x-v[i].p1.x)*(v[i].p2.y-v[i].p1.y);\n  }\n  return ans;\n}\n\nmain() {\n  int t = 1;\n  while((cin >> n) && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> re[i].p.x >> re[i].p.y >> re[i].r;\n    }\n    printf(\"%d %.2f\\n\", t, solve());\n    ++t;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int sequenceNum = 0;\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<double> x(2*n), y(2*n), x1(n), y1(n), x2(n), y2(n);\n        for(int i=0; i<n; ++i){\n            double x0, y0, r;\n            cin >> x0 >> y0 >> r;\n            x[2*i] = x1[i] = x0 - r;\n            x[2*i+1] = x2[i] = x0 + r;\n            y[2*i] = y1[i] = y0 - r;\n            y[2*i+1] = y2[i] = y0 + r;\n        }\n        sort(x.begin(), x.end());\n        sort(y.begin(), y.end());\n\n        double ret = 0.0;\n        for(int i=0; i<2*n-1; ++i){\n            for(int j=0; j<2*n-1; ++j){\n                for(int k=0; k<n; ++k){\n                    if(x1[k] <= x[i] && x[i+1] <= x2[k] && y1[k] <= y[j] && y[j+1] <= y2[k]){\n                        ret += (y[j+1] - y[j]) * (x[i+1] - x[i]);\n                        break;\n                    }\n                }\n            }\n        }\n        printf(\"%d %.02f\\n\", ++sequenceNum, ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, int> P;\n\nint main(){\n  int N;\n  int casenum = 1;\n  while(cin>>N && N){\n    printf(\"%d \", casenum++);\n    map<double, vector<P> > eventx;\n    map<double, vector<P> > delx;\n    set<double> searchx;\n    REP(i, N){\n      double x, y, d;\n      cin>>x>>y>>d;\n      searchx.insert(x - d);\n      searchx.insert(x + d);\n      eventx[x - d].push_back(P(y - d, 1));\n      eventx[x - d].push_back(P(y + d, -1));\n      delx[x + d].push_back(P(y - d, 1));\n      delx[x + d].push_back(P(y + d, -1));\n    }\n    vector<P> evs;\n    //set<P> evs;\n    double bfx = 0;\n    double bfy = 0;\n    double ans = 0;\n    FORIT(sx, searchx){\n      ans += (*sx - bfx) * bfy;\n      if(eventx.count(*sx)){\n        FORIT(it, eventx[*sx]) evs.push_back(*it);\n      }\n      if(delx.count(*sx)){\n        FORIT(it, delx[*sx]){\n          vector<P>::iterator findit = find(evs.begin(), evs.end(), *it);\n          assert(findit != evs.end());\n          evs.erase(findit);\n        }\n      }\n      sort(evs.begin(), evs.end());\n      bfx = *sx;\n      bfy = 0;\n      int cnt = 0;\n      double ty = 0;\n      FORIT(event, evs){\n        if(cnt > 0){\n          bfy += abs(event->first - ty);\n        }\n        ty = event->first;\n        cnt += event->second;\n      }\n    }\n    printf(\"%.2lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\nint n; double X1[100], X2[100], Y1[100], Y2[100];\nint x[200][200]; vector<pair<double, int> >X, Y;\npair<int, int>X3[200], Y3[200];\nint main() {\n\tint cnt = 0;\n\twhile (true) {\n\t\tcin >> n; cnt++; X.clear(); Y.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < 40000; i++) { x[i / 200][i % 200] = 0; X3[i / 200] = make_pair(-1, -1); Y3[i / 200] = make_pair(-1, -1); }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble L1, L2, L3; cin >> L1 >> L2 >> L3;\n\t\t\tX1[i] = L1 - L3, X2[i] = L1 + L3; Y1[i] = L2 - L3, Y2[i] = L2 + L3;\n\t\t\tX.push_back(make_pair(X1[i], i)); X.push_back(make_pair(X2[i], i));\n\t\t\tY.push_back(make_pair(Y1[i], i)); Y.push_back(make_pair(Y2[i], i));\n\t\t}\n\t\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end());\n\t\tfor (int i = 0; i < 2 * n; i++) {\n\t\t\tint H = X[i].second; if (X3[H].first == -1) { X3[H].first = i; } else { X3[H].second = i; }\n\t\t\tint I = Y[i].second; if (Y3[I].first == -1) { Y3[I].first = i; } else { Y3[I].second = i; }\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = X3[i].first; j < X3[i].second; j++) {\n\t\t\t\tfor (int k = Y3[i].first; k < Y3[i].second; k++)x[j][k] = 1;\n\t\t\t}\n\t\t}\n\t\tdouble cnt2 = 0.0;\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tfor (int j = 0; j < 2 * n - 1; j++) {\n\t\t\t\tif (x[i][j] == 0)continue;\n\t\t\t\tcnt2 += (X[i + 1].first - X[i].first)*(Y[j + 1].first - Y[j].first);\n\t\t\t}\n\t\t}\n\t\tcout << cnt << ' ' << fixed << setprecision(2) << cnt2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<double, double> squareCorner;\ntypedef pair<squareCorner, squareCorner> squareCorners;\n\ndouble totalLength (vector<squareCorners> squares, double x) {\n    // Ignore squares not crossing the ray line\n    for(vector<squareCorners>::iterator it = squares.begin(); it!=squares.end(); it++) {\n        double x0 = it->first.first;\n        double x1 = it->second.first;\n        if (x < x0 || x >= x1) {\n            squares.erase(it);\n            it--;\n        }\n    }\n\n    // Add y[01] to a list\n    vector<pair<double, bool> > ys;\n    for(unsigned i=0; i<squares.size(); i++) {\n        squareCorners p = squares[i];\n        double y0 = p.first.second;\n        double y1 = p.second.second;\n        ys.push_back(make_pair(y0, true));\n        ys.push_back(make_pair(y1, false));\n    }\n\n    // Sort list\n    sort(ys.begin(), ys.end());\n\n    // Compute sum distance\n    int beginning = 0;\n    double l = 0;\n    double startSegment = 0.;\n    for(unsigned i=0; i<ys.size(); i++) {\n        pair<double, bool> p = ys[i];\n        bool isBeginning = p.second;\n        double y = p.first;\n\n        if (beginning == 0)\n            startSegment = y;\n        beginning += isBeginning ? 1 : -1;\n        if (beginning == 0)\n            l += y - startSegment;\n    }\n\n    return l;\n}\n\nint main () {\n    int N;\n    cin >> N;\n    int cpt = 0;\n\n    // Read info for one Problem\n    while (N != 0) {\n        cpt++;\n        vector<squareCorners> squares;\n        set<double> xs;\n\n        // Read info about each antenna\n        for (int i=0; i<N; i++) {\n            double cx, cy, r;\n            cin >> cx >> cy >> r;\n            double x0 = cx - r,\n                   x1 = cx + r,\n                   y0 = cy - r,\n                   y1 = cy + r;\n            xs.insert(x0);\n            xs.insert(x1);\n            squares.push_back(make_pair(make_pair(x0, y0), make_pair(x1, y1)));\n        }\n\n        double area = 0.;\n        set<double>::iterator it=xs.begin();\n        double prevY = *it;\n        double prevWidth = totalLength(squares, prevY);\n        it++;\n        while (it != xs.end()) {\n            area += prevWidth * (*it - prevY);\n            prevY = *it;\n            prevWidth = totalLength(squares, *it);\n            it++;\n        }\n\n        area = round(area*100)/100;\n\n        printf(\"%d %.2f\\n\", cpt, area);\n        cin >> N;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nstruct Rect {\n    double x, y, w, h;\n\n    Rect() {}\n    Rect(double x, double y, double w, double h) : x(x), y(y), w(w), h(h) {}\n\n    bool intersect(const Rect &other) const {\n        return (other.x < x+w) && (other.x+other.w > x) && (other.y < y+h) && (other.y+other.h > y);\n    }\n\n    bool include(double x_, double y_) const {\n        return (x < x_) && (x_ < x+w) && (y < y_) && (y_ < y+h);\n    }\n\n    bool include(const Rect &other) const {\n        return (x < other.x) && (x+w > other.x+other.w) && (y < other.y) && (y+h > other.y+other.h);\n    }\n\n    bool include_x(double x_) const {\n        return x < x_ && x_ < x+w;\n    }\n\n    bool include_y(double y_) const {\n        return y < y_ && y_ < y+h;\n    }\n\n    double area() const {\n        return w*h;\n    }\n};\n\nostream& operator << (ostream &os, const Rect &r) {\n    os << '(' << r.x << ',' << r.y << ',' << r.w << ',' << r.h << ')';\n    return os;\n}\n\nint main() {\n    for(int C = 1; ; ++C) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Rect> v;\n        while(N--) {\n            double cx, cy, s;\n            cin >> cx >> cy >> s;\n\n            const Rect r(cx-s, cy-s, s*2, s*2);\n            vector<Rect> next;\n            for(int i = 0; i < v.size(); ++i) {\n                if(r.include(v[i])) continue;\n\n                Rect ri = v[i];\n                if(!r.intersect(ri)) {\n                    next.push_back(ri);\n                }\n                else {\n                    if(ri.include_x(r.x)) {\n                        const Rect cr(ri.x, ri.y, r.x-ri.x, ri.h);\n                        next.push_back(cr);\n                        ri = Rect(cr.x+cr.w, cr.y, ri.w-cr.w, cr.h);\n                    }\n                    if(ri.include_x(r.x+r.w)) {\n                        const Rect cr(r.x+r.w, ri.y, ri.x+ri.w-(r.x+r.w), ri.h);\n                        next.push_back(cr);\n                        ri = Rect(ri.x, ri.y, ri.w-cr.w, ri.h);\n                    }\n                    if(ri.include_y(r.y)) {\n                        const Rect cr(ri.x, ri.y, ri.w, r.y-ri.y);\n                        next.push_back(cr);\n                        ri = Rect(cr.x, cr.y+cr.h, cr.w, ri.h-cr.h);\n                    }\n                    if(ri.include_y(r.y+r.h)) {\n                        const Rect cr(ri.x, r.y+r.h, ri.w, ri.y+ri.h-(r.y+r.h));\n                        next.push_back(cr);\n                        ri = Rect(ri.x, ri.y, ri.w, ri.h-cr.h);\n                    }\n                }\n            }\n            next.push_back(r);\n            v = next;\n        }\n        \n        double ans = 0;\n        //cout << v.size() << endl;\n        for(int i = 0; i < v.size(); ++i) {\n            //cout << v[i] << endl;\n            ans += v[i].area();\n        }\n        printf(\"%d %.2f\\n\", C, ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int n, cnt = 1;\n    while(cin >> n, n){\n        vector<double> x(n), y(n), r(n), xax, yax;\n        xax.push_back(-300.0); yax.push_back(-300.0);\n        xax.push_back(300.0);  yax.push_back(300.0);\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i] >> r[i];\n            xax.push_back(x[i]-r[i]); xax.push_back(x[i]+r[i]);\n            yax.push_back(y[i]-r[i]); yax.push_back(y[i]+r[i]);\n        }\n        sort(xax.begin(), xax.end());\n        sort(yax.begin(), yax.end());\n        xax.erase(unique(xax.begin(),xax.end()), xax.end());\n        yax.erase(unique(yax.begin(),yax.end()), yax.end());\n        int xn = xax.size(), yn = yax.size();\n        auto fx = [&](double val)->int{\n            return lower_bound(xax.begin(), xax.end(), val)-xax.begin();\n        };\n        auto fy = [&](double val)->int{\n            return lower_bound(yax.begin(), yax.end(), val)-yax.begin();\n        };\n        vector<vector<int>> v(xn, vector<int>(yn, 0));\n        for(int i = 0; i < n; i++){\n            int a = fx(x[i]-r[i]), b = fx(x[i]+r[i]), c = fy(y[i]-r[i]), d = fy(y[i]+r[i]);\n            v[a][c]++, v[b][d]++;\n            v[a][d]--, v[b][c]--;\n        }\n        for(int i = 0; i < xn; i++) for(int j = 1; j < yn; j++) v[i][j] += v[i][j-1];\n        for(int j = 0; j < yn; j++) for(int i = 1; i < xn; i++) v[i][j] += v[i-1][j];\n        double s = 0;\n        for(int i = 0; i < xn; i++){\n            for(int j = 0; j < yn; j++){\n                if(v[i][j] == 0)    continue;\n                s += (xax[i+1]-xax[i])*(yax[j+1]-yax[j]);\n            }\n        }\n        printf(\"%d %.2f\\n\", cnt++, ((int)(s*100))/100.0);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<tuple>\n#include<algorithm>\nusing namespace std;\n\nenum {Y, FLAG, X1, X2};\nenum {TOP, BOTTOM};\n\n#define EDGE tuple<double, double, double, int>\n\nint main() {\n    int data = 0;\n    int n;\n    while(cin>>n, n) {\n        data++;\n        vector<EDGE> edge;\n        for(int i=0; i<n; i++) {\n            double x, y, r;\n            cin>>x>>y>>r;\n            edge.push_back(EDGE(y-r, TOP, x-r, x+r));\n            edge.push_back(EDGE(y+r, BOTTOM, x-r, x+r));\n        }\n        sort(edge.begin(), edge.end());\n\n        double answer = 0.0;\n        vector<double> point;\n        point.push_back(get<X1>(edge[0]));\n        point.push_back(get<X2>(edge[0]));\n        for(int i=1; i<edge.size(); i++) {\n            double w, h;\n            w = *max_element(point.begin(), point.end()) - *min_element(point.begin(), point.end());\n            h = get<Y>(edge[i]) - get<Y>(edge[i-1]);\n            answer += w * h;\n            double x1, x2;\n            x1 = get<X1>(edge[i]);\n            x2 = get<X2>(edge[i]);\n            if(get<FLAG>(edge[i]) == TOP) {\n                point.push_back(x1);\n                point.push_back(x2);\n            } else {\n                point.erase(find(point.begin(), point.end(), x1));\n                point.erase(find(point.begin(), point.end(), x2));\n            }\n        }\n        cout<<setiosflags(ios::fixed)<<setprecision(2)<<data<<\" \"<<answer<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int uli;\nstruct ival{\n   int t;\n   double x,yi,yf;\n   bool operator <(ival a)const{\n      if(x!=a.x)return x<a.x;\n      if(yi!=a.yi)return yi<a.yi;\n      if(yf!=a.yf)return yf<a.yf;\n      return t<a.t;\n   }\n};\nvector<ival>q;\nmultiset<pair<double,double> >s;\nmultiset<pair<double,double> >::iterator it;\ndouble len(){\n   if(s.empty())return 0;\n   double ans=0;\n   double lft=s.begin()->first;\n   double rht=lft;\n   for(it=s.begin();it!=s.end();it++){\n      if(it->first>rht){\n         ans+=rht-lft;\n         lft=it->first;\n         rht=it->second;\n      }\n      else rht=max(rht,it->second);\n   }\n   ans+=rht-lft;\n   return ans;\n}\nint main(){\n   int n,tt=0;\n   while(scanf(\"%d\",&n)==1){\n      if(n==0)break;\n      s.clear();\n      q.clear();\n      for(int i=0;i<n;i++){\n         double xi,yi,r;\n         scanf(\"%lf %lf %lf\",&xi,&yi,&r);\n         ival ivi={0,xi-r,yi-r,yi+r};\n         ival ivf={1,xi+r,yi-r,yi+r};\n         q.push_back(ivi);\n         q.push_back(ivf);\n      }\n      sort(q.begin(),q.end());\n      double ans=0.0;\n      double xi=q[0].x;\n      for(int i=0;i<int(q.size());i++){\n         ival iv=q[i];\n         ans+=(iv.x-xi)*len();\n         xi=iv.x;\n         if(iv.t==0){\n            s.insert(make_pair(iv.yi,iv.yf));\n         }\n         else{\n            it=s.find(make_pair(iv.yi,iv.yf));\n            s.erase(it);\n         }\n      }\n      printf(\"%d %.2lf\\n\",++tt,ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct P {\n  double x;\n  double y1, y2;                // y1 < y2\n  bool f;                       // 0:in, 1:out\n};\nconst bool operator<(const P &a, const P &b) {\n  return a.x < b.x;\n}\n\ntypedef pair<double,double> pdd;\nint main() {\n  int n;\n  int nn = 0;\n  while(cin >> n, n) {\n    vector<P> v;\n    REP(i,n) {\n      double x,y,r;\n      cin >> x >> y >> r;\n      v.push_back((P){x-r,y-r,y+r,0});\n      v.push_back((P){x+r,y-r,y+r,1});\n    }\n    sort(ALL(v));\n    double x = -1;\n    double res = 0;\n    multiset<pdd> se;\n    double dy = 0;\n    FOR(it, v) {\n//      printf(\"%f %f (%f,%f) %d\\n\", x,it->x,it->y1,it->y2,it->f);\n      \n      if (x<0) x = it->x;\n      \n      res += (it->x - x) * dy;\n      \n      x = it->x;\n      \n      if (it->f == 0)\n        se.insert(pdd(it->y1,it->y2));\n      else {\n        int hoge = se.erase(pdd(it->y1,it->y2));\n        REP(i,hoge-1)\n          se.insert(pdd(it->y1,it->y2));\n      }\n\n      // dy ÌvZ\n      double y1=-1,y2=-1;       // »Ýl¦Ä¢éÍÍ\n      dy = 0;\n      FOR(jt, se) {\n        if (y2 <= jt->first) {\n          dy += y2-y1;\n          y1 = jt->first;\n          y2 = jt->second;\n        } else if (y2 <= jt->second) {\n          y2 = jt->second;\n        } else {      \n        }\n      }\n      dy += y2-y1;\n    }\n    printf(\"%d %.2f\\n\", ++nn, res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  for(int N, tc=1; cin >> N && N; tc++) {\n    vector<double> xs, ys;\n    vector<tuple<double, double, double>> squares;\n    rep(i, N) {\n      double x, y, r; cin >> x >> y >> r;\n      xs.push_back(x-r); xs.push_back(x+r);\n      ys.push_back(y-r); ys.push_back(y+r);\n      squares.emplace_back(x, y, r);\n    }\n    sort(all(xs));\n    xs.erase(unique(all(xs)), xs.end());\n    sort(all(ys));\n    ys.erase(unique(all(ys)), ys.end());\n    map<int, double> xmp, ymp;\n    int xcnt = 0, ycnt = 0;\n    for(auto e: xs) xmp[xcnt++] = e;\n    for(auto e: ys) ymp[ycnt++] = e;\n\n    double ans = 0.0;\n    rep(i, ycnt - 1) {\n      double yl = ymp[i], yr = ymp[i + 1];\n      double centy = (yl + yr) / 2.0;\n      rep(j, xcnt - 1) {\n        double xl = xmp[j], xr = xmp[j + 1];\n        double centx = (xl + xr) / 2.0;\n        bool ok = 0;\n        for(auto& q: squares) {\n          double sx, sy, sr; tie(sx, sy, sr) = q;\n          if(   sy-sr <= centy && centy <= sy+sr\n            &&  sx-sr <= centx && centx <= sx+sr) {\n            ok = 1; break;\n          }\n        }\n        if(ok) ans += (yr - yl) * (xr - xl);\n      }\n    }\n\n    printf(\"%d %.2f\\n\", tc, round(ans * 100) / 100.0);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\nvector<pair<pair<double, int> , Pd> > ls;\nbool use[300];\n\ndouble calc(vector<Pd> range){\n\tdouble res = 0.0;\n\tsort(range.begin(), range.end());\n\trep(i, (int)range.size() - 1){\n\t\tif(range[i+1].second > range[i].second){\n\t\t\tres += range[i+1].second - max(range[i+1].first, range[i].second);\n\t\t}else{\n\t\t\trange[i+1].second = range[i].second;\n\t\t}\n\t}\n\tif(!range.empty()){\n\t\tres += range[0].second - range[0].first;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, sz;\n\tint cnt = 1;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\trep(i, n){\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tls.push_back(make_pair(make_pair(y - r, i), Pd(x - r, x + r)));\n\t\t\tls.push_back(make_pair(make_pair(y + r, i), Pd(x - r, x + r)));\n\t\t}\n\t\tsort(ls.begin(), ls.end());\n\t\tmemset(use, false, sizeof(use));\n\t\tsz = ls.size();\n\t\tdouble pre = -1e4;\n\t\tdouble res = 0.0;\n\t\trep(i, sz){\n\t\t\tint id = ls[i].first.second;\n\t\t\tdouble cur = ls[i].first.first;\n\t\t\tvector<Pd> range;\n\t\t\trep(i, sz){\n\t\t\t\tif(use[i]) range.push_back(ls[i].second);\n\t\t\t}\n\t\t\tres += (cur - pre) * calc(range);\n\t\t\tpre = cur;\n\t\t\tuse[id] = !use[id];\t\t\t\n\t\t}\n\t\tcout << cnt++ << \" \" << fixed << setprecision(2) << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nstruct Rect{\n\tdouble l, t, r, b;\n\tbool contain(const Rect &rc){\n\t\treturn l - EPS < rc.l &&\n\t\t\tt - EPS < rc.t &&\n\t\t\tr + EPS > rc.r &&\n\t\t\tb + EPS > rc.b;\n\t}\n\tdouble S(){\n\t\treturn (r - l)*(b - t);\n\t}\n};\n\nint n;\nRect rect[500];\ndouble x[500], y[500];\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(2);\n\tint t = 1;\n\twhile (cin >> n, n){\n\t\trep(i, n){\n\t\t\tdouble xx, yy, rr;\n\t\t\tcin >> xx >> yy >> rr;\n\t\t\trect[i] = Rect{ xx - rr, yy - rr, xx + rr, yy + rr };\n\t\t\tx[i * 2] = xx - rr, x[i * 2 + 1] = xx + rr;\n\t\t\ty[i * 2] = yy - rr, y[i * 2 + 1] = yy + rr;\n\t\t}\n\t\tsort(x, x + 2 * n);\n\t\tsort(y, y + 2 * n);\n\n\t\tdouble ans = 0;\n\t\trep(i, 2 * n - 1) rep(j, 2 * n - 1) {\n\t\t\tRect r = {x[i], y[j], x[i+1], y[j+1]};\n\t\t\tint cnt = 0;\n\t\t\trep(k, n){\n\t\t\t\tif (rect[k].contain(r)) ++cnt;\n\t\t\t}\n\t\t\tif (cnt > 0) ans += r.S();\n\t\t}\n\t\tcout << t++ << \" \" <<  ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1202: Mobile Phone Coverage\n// 2017.12.5 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { int x1, y1, x2, y2; } T;\nT tbl[102];\nint xx[202], xs;\nint yy[202], ys;\nchar map[202][202];\n\nchar buf[32], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p == ' ') p++;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tn *= 100;\n\tif (*p == '.') {\n\t\tp++;\n\t\tif (*p >= '0') n += 10*(*p++ & 0xf);\n\t\tif (*p >= '0') n +=     *p++ & 0xf;\n\t}\n\treturn n;\n}\n\nint bsch(int *a, int x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (a[m] == x) break;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn m;\n}\n\nint uniq(int *a, int n)\n{\n\tint i, j;\n\t\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && a[j] == a[i]) j++;\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint main()\n{\n\tint n, i, x, y, r, x1, y1, x2, y2;\n\tint cno = 0;\n\tlong long t, ans;\n\n\twhile (fgets(buf, sizeof(buf), stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\t\tfor (xs = ys = 0, i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, sizeof(buf), stdin);\n\t\t\tx = getint(), y = getint(), r = getint();\n\t\t\tx1 = x-r, y1 = y-r, x2 = x+r, y2 = y+r;\n\t\t\ttbl[i].x1 = x1, tbl[i].y1 = y1, tbl[i].x2 = x2, tbl[i].y2 = y2;\n\t\t\txx[xs++] = x1, xx[xs++] = x2, yy[ys++] = y1, yy[ys++] = y2;\n\t\t}\n\t\tqsort(xx, xs, sizeof(int), cmp); xs = uniq(xx, xs);\n\t\tqsort(yy, ys, sizeof(int), cmp); ys = uniq(yy, ys);\n\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tx1 = bsch(xx, tbl[i].x1, xs);\n\t\t\tx2 = bsch(xx, tbl[i].x2, xs);\n\t\t\ty1 = bsch(yy, tbl[i].y1, ys);\n\t\t\ty2 = bsch(yy, tbl[i].y2, ys);\n\t\t\tfor (y = y1; y < y2; y++) for (x = x1; x < x2; x++) map[y][x] = 1;\n\t\t}\n\n\t\tans = 0;\n\t\tfor (y = 0; y < ys; y++) {\n\t\t\tt = yy[y+1] - yy[y];\n\t\t\tfor (x = 0; x < xs; x++) {\n\t\t\t\tif (map[y][x]) ans += t * (xx[x+1]-xx[x]);\n\t\t\t}\n\t\t}\n\t\tans /= 100;\n\t\tprintf(\"%d %lld.%02lld\\n\", ++cno, ans/100, ans%100);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1202: Mobile Phone Coverage\n// 2017.10.31 bal4u@uu\n// IMOS method\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BASE 2000\nint map[6004][6004];\nint xmin, xmax, ymin, ymax;\nchar buf[32], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tn *= 10;\n\tif (*p == '.') n += *++p & 0xf, p++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, x, y, r, ans;\n\tint cno = 0;\n\n\twhile (fgets(buf, sizeof(buf), stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\t\tmemset(map, 0, sizeof(map));\n\t\txmin = ymin = 6000, xmax = ymax = 0;\n\t\twhile (n--) {\n\t\t\tfgets(p=buf, sizeof(buf), stdin);\n\t\t\tx = getint()+BASE, p++, y = getint()+BASE, p++, r = getint();\n\t\t\tif (x-r < xmin) xmin = x-r;\n\t\t\tif (x+r > xmax) xmax = x+r;\n\t\t\tif (y-r < ymin) ymin = y-r;\n\t\t\tif (y+r > ymax) ymax = y+r;\n\t\t\tmap[y-r][x-r]++;\n\t\t\tmap[y-r][x+r]--;\n\t\t\tmap[y+r][x-r]--;\n\t\t\tmap[y+r][x+r]++;\n\t\t}\n\t\tfor (y = ymin; y <= ymax; y++) for (x = xmin; x <= xmax; x++) map[y][x] += map[y][x-1];\n\t\tfor (y = ymin; y <= ymax; y++) for (x = xmin; x <= xmax; x++) map[y][x] += map[y-1][x];\n\t\tfor (ans = 0, y = ymin; y <= ymax; y++) for (x = xmin; x <= xmax; x++)\n\t\t\tif (map[y][x] > 0) ans++;\n\t\tprintf(\"%d %d.%02d\\n\", ++cno, ans/100, ans%100);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1202\nTitle\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint n;\ndouble cx[100],cy[100],s[100];\n\ndouble x[200],y[200];\n//\nint d_comp(const void *x , const void *y)\n{\n  return(*(double *)x - *(double *)y);\n}\nint inrects(double x,double y)\n{\n  int i;\n\n  for(i=0;i<n;i++)\n    if(x >= cx[i]-s[i] && x<= cx[i]+s[i] && y >= cy[i]-s[i] && y<= cy[i]+s[i])\n      return(-1);\n\t\n  return(0);\n}\nmain()\n{\n  int i,j,cnt,tim;\n  double ssum;\n\n  tim=0;\n  while(scanf(\"%d\",&n) && n)\n    {\n      cnt = 0;\n      for(i=0;i<n;i++)\n\t{\n\t  scanf(\"%lf %lf %lf\",&(cx[i]),&(cy[i]),&(s[i]));\n\t  x[cnt]=cx[i]+s[i];\n\t  x[cnt+1]=cx[i]-s[i];\n\t  y[cnt]=cy[i]+s[i];\n\t  y[cnt+1]=cy[i]-s[i];\n\t  cnt+=2;\n\t}\n\n      qsort(x,cnt,sizeof(double),d_comp);\n      qsort(y,cnt,sizeof(double),d_comp);\n\n\n      ssum=0.0;\n      for(i=0;i<cnt-1;i++)\n\tfor(j=0;j<cnt-1;j++)\n\t  {\n\t    //printf(\"%.2lf %.2lf=\",x[i],y[j]);\n\t    if(inrects((x[i]+x[i+1])/2,(y[j]+y[j+1])/2))\n\t      {\n\t\t//printf(\"%.2lf\\n\",((x[i+1]-x[i])*(y[j+1]-y[j])));\n\t      ssum += ((x[i+1]-x[i])*(y[j+1]-y[j]));\n\t      }\n\t  }\n      tim++;\n      printf(\"%d %.2lf\\n\",tim,ssum);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\nint asumisu(const void* x, const void* y) {\n\tdouble a = *(const double*)x, b = *(const double*)y;\n\treturn a < b ? -1 : a > b;\n}\n\nint n;\ndouble x[128], y[128], r[128];\n\ndouble sx[128], sy[128], dx[128], dy[128];\n\nint sumipe;\ndouble maaya[128 * 4];\n\nint hayamin(double target) {\n\tint l = 0, r = sumipe - 1;\n\twhile (l <= r) {\n\t\tint m = l + (r - l) / 2;\n\t\tif (maaya[m] == target) return m;\n\t\telse if (maaya[m] < target) l = m + 1;\n\t\telse r = m - 1;\n\t}\n\texit(2);\n\treturn 0;\n}\n\nint kugyu[128 * 4][128 * 4];\n\nint main(void) {\n\tint horieyui = 1;\n\twhile (scanf(\"%d\", &n) == 1 && n > 0) {\n\t\tint i, j;\n\t\tdouble answer;\n\t\tmaaya[0] = -1e100;\n\t\tsumipe = 1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (scanf(\"%lf%lf%lf\", &x[i], &y[i], &r[i]) != 3) return 1;\n\t\t\tmaaya[sumipe++] = sx[i] = x[i] - r[i];\n\t\t\tmaaya[sumipe++] = dx[i] = x[i] + r[i];\n\t\t\tmaaya[sumipe++] = sy[i] = y[i] - r[i];\n\t\t\tmaaya[sumipe++] = dy[i] = y[i] + r[i];\n\t\t}\n\t\tqsort(maaya, sumipe, sizeof(*maaya), asumisu);\n\t\tsumipe = 1;\n\t\tfor (i = 1; i < n * 4 + 1; i++) {\n\t\t\tif (maaya[sumipe - 1] != maaya[i]) maaya[sumipe++] = maaya[i];\n\t\t}\n\t\tfor (i = 0; i < sumipe; i++) {\n\t\t\tmemset(kugyu[i], 0, sizeof(kugyu[i][0]) * sumipe);\n\t\t}\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tint sxi = hayamin(sx[i]), dxi = hayamin(dx[i]);\n\t\t\tint syi = hayamin(sy[i]), dyi = hayamin(dy[i]);\n\t\t\tkugyu[syi][sxi]++;\n\t\t\tkugyu[syi][dxi]--;\n\t\t\tkugyu[dyi][sxi]--;\n\t\t\tkugyu[dyi][dxi]++;\n\t\t}\n\t\tfor (i = 1; i < sumipe; i++) {\n\t\t\tfor (j = 1; j < sumipe; j++) kugyu[i][j] += kugyu[i - 1][j];\n\t\t}\n\t\tfor (i = 1; i < sumipe; i++) {\n\t\t\tfor (j = 1; j < sumipe; j++) kugyu[i][j] += kugyu[i][j - 1];\n\t\t}\n\t\tanswer = 0;\n\t\tfor (i = 0; i < sumipe; i++) {\n\t\t\tfor (j = 0; j < sumipe; j++) {\n\t\t\t\tif (kugyu[i][j] > 0) answer += (maaya[i + 1] - maaya[i]) * (maaya[j + 1] - maaya[j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %.2f\\n\", horieyui++, round(answer * 100.0) / 100.0);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1202\nTitle\n*/\n#include <stdio.h>\n// Select Below\n#include <stdlib.h>\n//#include <string.h>\n#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint n;\ndouble cx[100],cy[100],s[100];\n\ndouble x[200],y[200];\n//\nint d_comp(const void *x , const void *y)\n{\n  return(*(double *)x > *(double *)y);\n}\nint inrects(double x,double y)\n{\n  int i;\n\n  for(i=0;i<n;i++)\n    if(x >= cx[i]-s[i] && x<= cx[i]+s[i] && y >= cy[i]-s[i] && y<= cy[i]+s[i])\n      return(-1);\n\t\n  return(0);\n}\nprintx()\n{ int i;\n  for(i=0;i<6;i++)\n    printf(\"%.2lf:\",x[i]);\n  printf(\"\\n\");\n}\nmain()\n{\n  int i,j,cnt,tim;\n  double ssum;\n\n  tim=0;\n  while(scanf(\"%d\",&n) && n)\n    {\n      cnt = 0;\n      for(i=0;i<n;i++)\n\t{\n\t  scanf(\"%lf %lf %lf\",&(cx[i]),&(cy[i]),&(s[i]));\n\t  x[cnt]=cx[i]+s[i];\n\t  x[cnt+1]=cx[i]-s[i];\n\t  y[cnt]=cy[i]+s[i];\n\t  y[cnt+1]=cy[i]-s[i];\n\t  cnt+=2;\n\t}\n      \n      \n      qsort(x,cnt,sizeof(double),d_comp);\n      qsort(y,cnt,sizeof(double),d_comp);\n      \n\n      ssum=0.0;\n      for(i=0;i<cnt-1;i++)\n\tfor(j=0;j<cnt-1;j++)\n\t  {\n\n\t    if(inrects((x[i]+x[i+1])/2,(y[j]+y[j+1])/2))\n\t      {\n\n\t      ssum += ((x[i+1]-x[i])*(y[j+1]-y[j]));\n\t      }\n\t  }\n      tim++;\n      printf(\"%d %.2lf\\n\",tim,ssum);\n    }\nreturn(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\tpublic static class Rec implements Comparable<Rec> {\n\t\tdouble start, end;\n\t\tdouble max, min;\n\t\t\n\t\tpublic Rec(double start, double end, double max, double min) {\n\t\t\tsuper();\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t\tthis.max = max;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Rec arg0) {\n\t\t\treturn (this.max - this.min) - (arg0.max - arg0.min) > 0 ? -1 :\n\t\t\t\t(this.max - this.min) - (arg0.max - arg0.min) < 0 ? 1 : 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tint count = 1;\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Rec> walls = new ArrayList<Rec>(n);\n\t\t\tTreeSet<Double> set = new TreeSet<Double>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal double x = sc.nextDouble();\n\t\t\t\tfinal double y = sc.nextDouble();\n\t\t\t\tfinal double r = sc.nextDouble();\n\t\t\t\t\n\t\t\t\tset.add(x - r);\n\t\t\t\tset.add(x + r);\n\t\t\t\twalls.add(new Rec(x - r, x + r, y + r, y - r));\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(walls);\n\t\t\tArrayList<Double> list = new ArrayList<Double>(set);\n\t\t\t\n\t\t\tArrayList<LinkedList<Double>> min = new ArrayList<LinkedList<Double>>(list.size());\n\t\t\tArrayList<LinkedList<Double>> max = new ArrayList<LinkedList<Double>>(list.size());\n\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\tmax.add(new LinkedList<Double>());\n\t\t\t\tmin.add(new LinkedList<Double>());\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tfor(Rec r : walls){\n\t\t\t\t\n\t\t\t\tfinal int start = Collections.binarySearch(list, r.start);\n\t\t\t\tfinal int end = Collections.binarySearch(list, r.end);\n\t\t\t\t\n\t\t\t\tfor(int i = start; i < end; i++){\n\t\t\t\t\tdouble r_max = r.max;\n\t\t\t\t\tdouble r_min = r.min;\n\t\t\t\t\t\n\t\t\t\t\tif(max.get(i).size() == 0&& min.get(i).size() == 0){\n\t\t\t\t\t\tmax.get(i).add(r_max);\n\t\t\t\t\t\tmin.get(i).add(r_min);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tListIterator<Double> max_iter = max.get(i).listIterator();\n\t\t\t\t\t\tListIterator<Double> min_iter = min.get(i).listIterator();\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean found = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile(max_iter.hasNext() && min_iter.hasNext()){\n\t\t\t\t\t\t\tdouble i_max = max_iter.next(), i_min = min_iter.next();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(i_max >= r_max && i_min <= r_min){\n\t\t\t\t\t\t\t\t//System.out.println(\"a\");\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(i_max < r_max && i_min > r_min){\n\t\t\t\t\t\t\t\tmax_iter.remove();\n\t\t\t\t\t\t\t\tmin_iter.remove();\n\t\t\t\t\t\t\t\t//max_iter.set(r.max);\n\t\t\t\t\t\t\t\t//min_iter.set(r.min);\n\t\t\t\t\t\t\t\t//System.out.println(\"b\");\n\t\t\t\t\t\t\t\t//found = true;\n\t\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t\t}else if(i_max < r_max && i_max >= r_min && i_min <= r_min){\n\t\t\t\t\t\t\t\tr_min = i_min;\n\t\t\t\t\t\t\t\t//max_iter.set(r.max);\n\t\t\t\t\t\t\t\tmax_iter.remove();\n\t\t\t\t\t\t\t\tmin_iter.remove();\n\t\t\t\t\t\t\t\t//System.out.println(\"c\");\n\t\t\t\t\t\t\t\t//found = true;\n\t\t\t\t\t\t\t}else if(i_min > r_min && i_max >= r_max && i_min <= r_max){\n\t\t\t\t\t\t\t\tr_max = i_max;\n\t\t\t\t\t\t\t\t//min_iter.set(r.min);\n\t\t\t\t\t\t\t\tmax_iter.remove();\n\t\t\t\t\t\t\t\tmin_iter.remove();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//found = true;\n\t\t\t\t\t\t\t\t//System.out.println(\"d\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!found){\n\t\t\t\t\t\t\t//System.out.println(\"min => \" + min.get(i) + \" \" + r.min);\n\t\t\t\t\t\t\t//System.out.println(\"max => \" + max.get(i) + \" \" + r.max);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tmax.get(i).add(r_max);\n\t\t\t\t\t\t\tmin.get(i).add(r_min);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//for(int i = 0; i < list.size(); i++){\n\t\t\t//\tSystem.out.println(i + \"(\"+ list.get(i) +\")\" + \": min = \" + min.get(i) + \" , max = \" + max.get(i));\n\t\t\t//}\n\t\t\t\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i = 0; i < list.size() - 1; i++){\n\t\t\t\tListIterator<Double> max_iter = max.get(i).listIterator();\n\t\t\t\tListIterator<Double> min_iter = min.get(i).listIterator();\n\t\t\t\t\n\t\t\t\twhile(max_iter.hasNext() && min_iter.hasNext()){\n\t\t\t\t\tdouble i_max = max_iter.next(), i_min = min_iter.next();\n\t\t\t\t\t\n\t\t\t\t\tsum += (i_max - i_min) * (list.get(i + 1) - list.get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%d %.2f\\n\", count, sum);\n\t\t\tcount++;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tint [][] map;\n\tint ans;\n\tString [][] boards;\n\tboolean isused [];\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint datasetcount = 1;\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdouble [] xlist = new double[n * 2];\n\t\t\tdouble [] ylist = new double[n * 2];\n\t\t\tdouble [][] inputlist = new double[n][4];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdouble inputx = sc.nextDouble();\n\t\t\t\tdouble inputy = sc.nextDouble();\n\t\t\t\tdouble inputr = sc.nextDouble();\n\t\t\t\t//calc a vertex\n\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\tdouble x;\n\t\t\t\t\tif(j == 0){\n\t\t\t\t\t\tx = inputx - inputr;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tx = inputx + inputr;\n\t\t\t\t\t}\n\t\t\t\t\tinputlist[i][j] = x;\n\t\t\t\t\txlist[i * 2 + j] = x;\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\tdouble y;\n\t\t\t\t\tif(j == 0){\n\t\t\t\t\t\ty = inputy - inputr;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ty = inputy + inputr;\n\t\t\t\t\t}\n\t\t\t\t\tinputlist[i][j + 2] = y;\n\t\t\t\t\tylist[i * 2 + j] = y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tArrays.sort(xlist);\n\t\t\tArrays.sort(ylist);\n\t\t\t//debug\n//\t\t\tfor(int i = 0; i < xlist.length; i++){\n//\t\t\t\tSystem.out.print(xlist[i] + \" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int i = 0; i < ylist.length; i++){\n//\t\t\t\tSystem.out.print(ylist[i] + \" \" );\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t\t\n\t\t\t//create a mesh\n\t\t\tboolean [][] mesh = new boolean[ylist.length -1][xlist.length -1];\n\t\t\tfor(int i = 0; i < n; i++){\n//\t\t\t\tdouble firstXvalue = inputlist[i][0];\n//\t\t\t\tdouble firstYvalue = inputlist[i][1];\n//\t\t\t\tdouble lastXvalue = inputlist[i][2];\n//\t\t\t\tdouble lastYvalue = inputlist[i][3];\n\t\t\t\tint firstXind = Arrays.binarySearch(xlist, inputlist[i][0]);\n\t\t\t\tint lastXind  = Arrays.binarySearch(xlist, inputlist[i][1]);\n\t\t\t\tint firstYind = Arrays.binarySearch(ylist, inputlist[i][2]);\n\t\t\t\tint lastYind  = Arrays.binarySearch(ylist, inputlist[i][3]);\n\t\t\t\t//System.out.println(\"valuedebug= \" + inputlist[i][0] + \" \" + inputlist[i][1] + \" \" + inputlist[i][2] + \" \" + inputlist[i][3]);\n\t\t\t\t//System.out.println(\"indexdebug= \" + firstXind + \" \" + lastXind + \" \" + firstYind + \" \" + lastYind);\n\t\t\t\tfor(int meshY = firstYind; meshY < lastYind; meshY++){\n\t\t\t\t\tfor(int meshX = firstXind; meshX < lastXind; meshX++){\n\t\t\t\t\t\tmesh[meshY][meshX] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//calc a area\n\t\t\tdouble res = 0.0;\n\t\t\tfor(int i = 0; i < mesh.length; i++){\n\t\t\t\tfor(int j = 0; j < mesh[i].length; j++){\n\t\t\t\t\tif(mesh[i][j]){\n\t\t\t\t\t\tdouble sideX = xlist[j + 1] - xlist[j];\n\t\t\t\t\t\tdouble sideY = ylist[i + 1] - ylist[i];\n\t\t\t\t\t\tdouble nowarea = sideX * sideY;\n\t\t\t\t\t\tres += nowarea;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//debug\n//\t\t\tSystem.out.println(\"meshdebug= \");\n//\t\t\tfor(int i = 0; i < mesh.length; i++){\n//\t\t\t\tfor(int j = 0; j < mesh.length; j++){\n//\t\t\t\t\tSystem.out.print(mesh[i][j] + \" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\tSystem.out.printf(\"%d %.2f\\n\",datasetcount++, res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n//public class Problem1202_MobilePhoneCoverage_Brute {\npublic class Main {\n\tprivate Maxnorm maxnorm;\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t//\tProblem1202_MobilePhoneCoverage_Brute test = new Problem1202_MobilePhoneCoverage_Brute();\n\t\t\tMain test = new Main();\n\t\t\t\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tString line;\n\t\t\twhile((line = reader.readLine()) != null) {\n\t\t\t\tint antennaNumber = Integer.parseInt(line);\n\t\t\t\tcount++;\n\t\t\t\tif(antennaNumber < 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\ttest.createNorm();\n\t\t\t\t\tfor(int i = 0; i < antennaNumber; i++) {\n\t\t\t\t\t\ttest.addAntenna(reader.readLine());\n\t\t\t\t\t}\n\t\t\t\t\tdouble area = test.getArea();\n\t\t\t\t\tSystem.out.printf(\"%d %.2f\\n\", count,area);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tvoid createNorm() {\n\t\tmaxnorm = new Maxnorm();\n\t}\n\tvoid addAntenna(String line) {\n\t\t\n\t\tString[] textArray = line.split(\" \");\n\t\tif(textArray.length != 3) {\n\t\t\ttextArray = line.split(\"  \");\n\t\t}\n\t\tint x = (int)(Double.parseDouble(textArray[0]) * 10);\n\t\tint y = (int)(Double.parseDouble(textArray[1]) * 10);\n\t\tint r = (int)(Double.parseDouble(textArray[2]) * 10);\n\t\t\n\t\tmaxnorm.addAntenna(x, y, r);\n\t}\n\tdouble getArea() {\n\t\tint area = maxnorm.getArea();\n\t\tdouble result = (double)area / 100;\n\t\t\n\t\treturn result;\n\t}\n\t//MaxnormNXÅÍSÄÌx/yÀWð10{, ÊÏð100{µ½lÅ\\í·Bi®Å\\í·Æ¢¤±Æ)\n\tprivate class Maxnorm {\n\t\tboolean[][] area;\t//area[210][220] = (x,y) ; (10,20)\n\t\tfinal int MAX_X = 6000;\n\t\tfinal int MAX_Y = 6000;\n\t\t\n\t\tMaxnorm() {\n\t\t\tarea = new boolean[MAX_X][MAX_X];\t//0 <= x+r <= 400, -200 <= x-r <= 200Byà¯l\n\t\t}\n\t\tvoid addAntenna(int x, int y, int r) {\n\t\t\tfor(int i = x - r +2000; i < x + r + 2000; i++) {\n\t\t\t\tfor(int j = y - r + 2000; j < y + r + 2000; j++) {\n\t\t\t\t\tarea[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint getArea() {\n\t\t\tint result = 0;\n\t\t\tfor(int i = 0; i < MAX_X; i++) {\n\t\t\t\tfor(int j = 0; j < MAX_Y; j++) {\n\t\t\t\t\tif(area[i][j]) {\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().doIt();\n\t}\n\tvoid doIt(){\n\t\tnew AOJ1202();\n\t}\n\t\n\tclass AOJ1202{\n\t\tAOJ1202(){\n\t\t\tint QNUM=1;\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tTreeSet<Double> hx=new TreeSet<Double>(),hy=new TreeSet<Double>();\n\t\t\t\tArrayList<Square> sq=new ArrayList<Square>();\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tdouble x=sc.nextDouble(),y=sc.nextDouble(),d=sc.nextDouble();\n\t\t\t\t\tdouble lx=x-d,rx=x+d,by=y-d,uy=y+d;\n\t\t\t\t\thx.add(lx);\thx.add(rx);\thy.add(by);\thy.add(uy);\n\t\t\t\t\tsq.add(new Square(lx,rx,by,uy));\n\t\t\t\t}\n\t\t\t\tArrayList<Double> mx=new ArrayList<Double>(),my=new ArrayList<Double>();\n\t\t\t\tfor(double d:hx)\tmx.add(d);\n\t\t\t\tfor(double d:hy)\tmy.add(d);\n\t\t\t\tboolean[][] b=new boolean[mx.size()][my.size()];\n\t\t\t\tfor(Square s:sq){\n\t\t\t\t\tfor(int x=0; x<mx.size(); x++){\n\t\t\t\t\t\tfor(int y=0; y<my.size(); y++){\n\t\t\t\t\t\t\tif(s.lx<=mx.get(x) && mx.get(x)<s.rx && s.by<=my.get(y) && my.get(y)<s.uy)\tb[x][y]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdouble ans=0.0;\n\t\t\t\tfor(int x=0; x+1<mx.size(); x++){\n\t\t\t\t\tfor(int y=0; y+1<my.size(); y++){\n\t\t\t\t\t\tif(b[x][y])\tans+=abs((mx.get(x+1)-mx.get(x))*(my.get(y+1)-my.get(y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.printf(\"%d %.2f\\n\",(QNUM++),ans);\n\t\t\t}\n\t\t}\n\t\tclass Square{\n\t\t\tdouble lx,rx,by,uy;\n\t\t\tSquare(double lx,double rx,double by,double uy){this.lx=lx; this.rx=rx; this.by=by; this.uy=uy;}\n\t\t}\n\t}\n\t\n\tclass AOJ1204{\n\t\tint N,INF=Integer.MAX_VALUE/4;\n\t\tint[] pl;\n\t\tAOJ1204(){\n\t\t\twhile(true){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tpl=new int[N];\n\t\t\t\tfor(int u=0; u<=4; u++){\n\t\t\t\t\tString line=sc.next();\n\t\t\t\t\tfor(int idx=0; idx<N; idx++){\n\t\t\t\t\t\tif(line.charAt(idx)=='X')\tpl[idx]=u;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean[][] map=new boolean[N*10+1][5];\n\t\t\t\tfor(int i=0; i<N; i++)\tmap[i][pl[i]]=true;\n\t\t\t\tSystem.out.println(solve(map,0,1));\n\t\t\t}\n\t\t}\n\t\tint solve(boolean[][] map,int lidx,int depth){\n\t\t\tif(depth==10){\n\t\t\t\treturn lidx+N;\n\t\t\t}\n\t\t\tint ret=INF;\n\t\t\tfor(int offset=1; offset<=N; offset++){\n\t\t\t\tint idx=lidx+offset;\n\t\t\t\tif(idx+N>=ret)\tbreak;\n\t\t\t\tboolean flag=true;\n\t\t\t\tint tmp=0;\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tif(map[idx+i][pl[i]]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\ttmp=i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmap[idx+i][pl[i]]=true;\n\t\t\t\t}\n\t\t\t\tif(flag)\tret=min(ret, solve(map,idx,depth+1));\n\t\t\t\tfor(int i=0; i<(flag?N:tmp); i++)\tmap[idx+i][pl[i]]=false;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\t\n\t\n\tclass AOJ1282{\n\t\tAOJ1282(){\n\t\t\twhile(true){\n\t\t\t\tString s=sc.nextLine();\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1228{\n\t\tfinal int[] vx={0,1,1,0,-1,-1}, vy={-1,0,1,1,0,-1};\n\t\tfinal int OFFSET=100,MAX=210;\n\t\tAOJ1228(){\n\t\t\tfinal int N=sc.nextInt();\n\t\t\tsc.nextLine();\n\t\t\tfor(int I=0; I<N; I++){\n\t\t\t\tString seq1=sc.nextLine(),seq2=sc.nextLine(),dammy=sc.nextLine();\n\t\t\t\tboolean[][] map1=new boolean[MAX][MAX];\n\t\t\t\tint x=OFFSET,y=OFFSET;\n\t\t\t\tmap1[x][y]=true;\n\t\t\t\tfor(char c:seq1.toCharArray()){\n\t\t\t\t\tint v=c-'a';\n\t\t\t\t\tx+=vx[v];\ty+=vy[v];\n\t\t\t\t\tmap1[x][y]=true;\n\t\t\t\t}\n\t\t\t\tmap1=offset(map1);\n\t\t\t\t//debug\n\t\t\t\t//disp(map1,20);\n\t\t\t\tboolean ans=false;\n\t\t\t\tfor(int rot=0; rot<6; rot++){\n\t\t\t\t\tx=OFFSET;\ty=OFFSET;\n\t\t\t\t\tboolean[][] map2=new boolean[MAX][MAX];\n\t\t\t\t\tmap2[x][y]=true;\n\t\t\t\t\tfor(char c:seq2.toCharArray()){\n\t\t\t\t\t\tint v=(c-'a'+rot)%6;\n\t\t\t\t\t\tx+=vx[v];\ty+=vy[v];\n\t\t\t\t\t\t//debug \n\t\t\t\t\t\t//System.out.print(\"(\"+x+\",\"+y+\") \");\n\t\t\t\t\t\tmap2[x][y]=true;\n\t\t\t\t\t}\n\t\t\t\t\t//debug\n\t\t\t\t\t//System.out.println();\n\t\t\t\t\t//disp(offset(map2),20);\n\t\t\t\t\tif(Arrays.deepEquals(map1, offset(map2))){\n\t\t\t\t\t\tans=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean[][] offset(boolean[][] b){\n\t\t\tint xmin=MAX,ymin=MAX;\n\t\t\tfor(int x=0; x<MAX; x++){\n\t\t\t\tfor(int y=0; y<MAX; y++){\n\t\t\t\t\tif(b[x][y]){\n\t\t\t\t\t\txmin=min(xmin,x);\tymin=min(ymin,y);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][] nb=new boolean[MAX][MAX];\n\t\t\tfor(int x=xmin; x<MAX; x++){\n\t\t\t\tfor(int y=ymin; y<MAX; y++)\tnb[x-xmin][y-ymin]=b[x][y];\n\t\t\t}\n\t\t\treturn nb;\n\t\t}\n\t\tvoid disp(boolean[][] b,int n){\n\t\t\tfor(int y=0; y<n; y++){\n\t\t\t\tfor(int x=0; x<n; x++)\tSystem.out.print(b[x][y]?\"#\":\".\");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(\"---------------\");\n\t\t}\n\t}\n\t\n\tclass AOJ1219{\n\t\tAOJ1219(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt(),S=sc.nextInt();\n\t\t\t\tif(N==0 || S==0)\tbreak;\n\t\t\t\tArrayList<ArrayList<Integer>> guard=new ArrayList<ArrayList<Integer>>();\n\t\t\t\tint ans=0,remain=-1,now=-1;\n\t\t\t\tint[] idx=new int[N],r=new int[N];\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tguard.add(new ArrayList<Integer>());\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tint in=sc.nextInt();\n\t\t\t\t\t\tif(in==0)\tbreak;\n\t\t\t\t\t\tguard.get(i).add(in);\n\t\t\t\t\t}\n\t\t\t\t\tr[i]=guard.get(i).get(0);\n\t\t\t\t}\n\t\t\t\t//System.out.println(guard);\n\t\t\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\t\t\tfor(int i=1; i<S; i++){\n\t\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\t\tif(idx[j]%2==0){\t// 放電\n\t\t\t\t\t\t\tif(--r[j]<=0){\n\t\t\t\t\t\t\t\tidx[j]=(idx[j]+1)%guard.get(j).size();\n\t\t\t\t\t\t\t\tr[j]=guard.get(j).get(idx[j]);\n\t\t\t\t\t\t\t\tif(queue.isEmpty() && remain<=0){\n\t\t\t\t\t\t\t\t\tnow=j;\n\t\t\t\t\t\t\t\t\tremain=r[j]+1;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tqueue.add(j);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(--remain==0){\n\t\t\t\t\t\tidx[now]=(idx[now]+1)%guard.get(now).size();\n\t\t\t\t\t\tr[now]=guard.get(now).get(idx[now]);\n\t\t\t\t\t\tif(!queue.isEmpty()){\n\t\t\t\t\t\t\tnow=queue.poll();\n\t\t\t\t\t\t\tremain=r[now];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans+=queue.size();\n//\t\t\t\t\tSystem.out.println(\"AI\"+i+\" N\"+now+\" R\"+remain+\" \"+queue.size());\n//\t\t\t\t\tSystem.out.println(Arrays.toString(r));\n//\t\t\t\t\tSystem.out.println(Arrays.toString(idx));\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\tclass Guard{\n\t\t\tint[] c;\n\t\t\t\n\t\t}\n\t}\n\t\n\tclass AOJ1218{\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx={0,1,0,-1},vy={1,0,-1,0};\n\t\tint W,H;\n\t\tAOJ1218(){\n\t\t\twhile(true){\n\t\t\t\tW=sc.nextInt();\tH=sc.nextInt();\n\t\t\t\tif(W==0 || H==0)\tbreak;\n\t\t\t\tint sx=-1,sy=-1,gx=-1,gy=-1,cx=-1,cy=-1;\n\t\t\t\tboolean[][] wall=new boolean[W][H];\n\t\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\t\tswitch(sc.nextInt()){\n\t\t\t\t\t\tcase 1:\twall[x][y]=true;\tbreak;\n\t\t\t\t\t\tcase 2:\tcx=x; cy=y; break;\n\t\t\t\t\t\tcase 3:\tgx=x; gy=y; break;\n\t\t\t\t\t\tcase 4:\tsx=x; sy=y; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPriorityQueue<Pos> open=new PriorityQueue<Main.AOJ1218.Pos>();\n\t\t\t\topen.add(new Pos(sx,sy,cx,cy,0));\n\t\t\t\tint[][][][] closed=new int[W][H][W][H];\n\t\t\t\tfor(int i=0; i<W; i++)for(int j=0; j<H; j++)for(int k=0; k<W; k++)for(int m=0; m<H; m++)closed[i][j][k][m]=INF;\n\t\t\t\tclosed[sx][sy][cx][cy]=0;\n\t\t\t\tboolean flag=false;\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tPos now=open.poll();\n\t\t\t\t\t//System.out.println(now);\n\t\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\t\tint xx=now.x+vx[i],yy=now.y+vy[i];\n\t\t\t\t\t\tif(!isInRange(xx,yy))\tcontinue;\n\t\t\t\t\t\tif(wall[xx][yy])\tcontinue;\n\t\t\t\t\t\tif(xx==now.cx && yy==now.cy){\n\t\t\t\t\t\t\tint xxx=xx+vx[i],yyy=yy+vy[i];\n\t\t\t\t\t\t\tif(!isInRange(xxx,yyy))\tcontinue;\n\t\t\t\t\t\t\tif(wall[xxx][yyy])\tcontinue;\n\t\t\t\t\t\t\tif(closed[xx][yy][xxx][yyy]<=now.step+1)\tcontinue;\n\t\t\t\t\t\t\tif(xxx==gx && yyy==gy){\n\t\t\t\t\t\t\t\tSystem.out.println(now.step+1);\n\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new Pos(xx,yy,xxx,yyy,now.step+1));\n\t\t\t\t\t\t\tclosed[xx][yy][xxx][yyy]=now.step+1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(closed[xx][yy][now.cx][now.cy]<=now.step)\tcontinue;\n\t\t\t\t\t\t\topen.add(new Pos(xx,yy,now.cx,now.cy,now.step));\n\t\t\t\t\t\t\tclosed[xx][yy][now.cx][now.cy]=now.step;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flag)\tSystem.out.println(-1);\n\t\t\t}\n\t\t}\n\t\tboolean isInRange(int x,int y){return 0<=x && x<W && 0<=y && y<H;}\n\t\tclass Pos implements Comparable<Pos>{\n\t\t\tint x,y,cx,cy,step;\n\t\t\tPos(int x,int y,int cx,int cy,int step){this.x=x; this.y=y; this.cx=cx; this.cy=cy; this.step=step;}\n\t\t\t@Override public int compareTo(Pos o) {\n\t\t\t\tif(this.step<o.step)\treturn -1;\n\t\t\t\tif(this.step>o.step)\treturn 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t@Override public String toString(){return \"(\"+x+\",\"+y+\") (\"+cx+\",\"+cy+\") \"+step;}\n\t\t}\n\t}\n\t\n\t// 0:55WA 1:20AC\n\tclass AOJ1227{\n\t\tArrayList<ArrayList<String>> dic,dic2ans;\n\t\tAOJ1227(){\n\t\t\tString s=\"22233344455566677778889999\";\n\t\t\tchar[] dic2=new char[26];\n\t\t\tfor(int i=0; i<26; i++)\tdic2[i]=s.charAt(i);\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tdic=new ArrayList<ArrayList<String>>(10);\n\t\t\t\tdic2ans=new ArrayList<ArrayList<String>>(10);\n\t\t\t\tfor(int i=0; i<10; i++){\n\t\t\t\t\tdic.add(new ArrayList<String>());\n\t\t\t\t\tdic2ans.add(new ArrayList<String>());\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tString in=sc.next();\n\t\t\t\t\tStringBuilder sb=new StringBuilder(in);\n\t\t\t\t\tfor(int j=0; j<sb.length(); j++)\tsb.setCharAt(j, dic2[sb.charAt(j)-'a']);\n\t\t\t\t\tint init=sb.charAt(0)-'0';\n\t\t\t\t\tdic.get(init).add(sb.toString());\n\t\t\t\t\tdic2ans.get(init).add(in);\n\t\t\t\t}\n\t\t\t\t//System.out.println(dic);\n\t\t\t\t//System.out.println(dic2ans);\n\t\t\t\tString in=sc.next();\n\t\t\t\tsolve(in, 0, new String());\n\t\t\t\tSystem.out.println(\"--\");\n\t\t\t}\n\t\t}\n\t\tvoid solve(String in,int idx,String ans){\n\t\t\tif(idx==in.length())\tSystem.out.println(ans+\".\");\n//\t\t\telse if(idx>in.length()){\n//\t\t\t\tSystem.out.println(\"index out of\");\n//\t\t\t\tSystem.out.println(idx+\" \"+ans);\n//\t\t\t}\n\t\t\telse{\n\t\t\t\tint init=in.charAt(idx)-'0';\n\t\t\t\tfor(int i=0; i<dic.get(init).size(); i++){\n\t\t\t\t\tString s=dic.get(init).get(i);\n\t\t\t\t\tif(in.startsWith(s, idx))\tsolve(in, idx+s.length(), ans+(ans.length()==0?dic2ans.get(init).get(i):\" \"+dic2ans.get(init).get(i)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 21:50-22:16 22:32WA\n\t// ICPC Asia Japan 2001 B\n\tclass AOJ1225{\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1225(){\n\t\t\twhile(true){\n\t\t\t\tArrayList<Deal> sell=new ArrayList<Deal>(),buy=new ArrayList<Deal>();\n\t\t\t\tHashMap<String,Dealer> dealer=new HashMap<String,Dealer>();\n\t\t\t\tHashMap<String,Commodities> comm=new HashMap<String, Commodities>();\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tfor(int I=0; I<N; I++){\n\t\t\t\t\tString d=sc.next(),ff=sc.next(),c=sc.next();\n\t\t\t\t\tint a=sc.nextInt();\n\t\t\t\t\tboolean f=ff.equals(\"BUY\");\n\t\t\t\t\tif(!dealer.containsKey(d))\tdealer.put(d, new Dealer(0, 0));\n\t\t\t\t\tArrayList<Deal> tmp=(f?sell:buy);\n\t\t\t\t\tint idx=-1,m=(f?INF:-1);\n\t\t\t\t\tfor(int i=0; i<tmp.size(); i++){\n\t\t\t\t\t\tif(tmp.get(i).c.equals(c) && !tmp.get(i).d.equals(d) && (f?m>tmp.get(i).a:m<tmp.get(i).a) && (f?a>=tmp.get(i).a:a<=tmp.get(i).a)){\n\t\t\t\t\t\t\tm=tmp.get(i).a;\tidx=i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(idx>=0){\n\t\t\t\t\t\ta=(a+tmp.get(idx).a)/2;\n\t\t\t\t\t\tif(!comm.containsKey(c))\tcomm.put(c, new Commodities(a));\n\t\t\t\t\t\telse\tcomm.get(c).add(a);\n\t\t\t\t\t\tdealer.get(d).add(f?0:a, f?a:0);\n\t\t\t\t\t\tdealer.get(tmp.get(idx).d).add(f?a:0, f?0:a);\n\t\t\t\t\t\ttmp.remove(idx);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp=(f?buy:sell);\n\t\t\t\t\t\ttmp.add(new Deal(d,c,a));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrayList<String> keys=new ArrayList<String>();\n\t\t\t\tfor(String key:comm.keySet())\tkeys.add(key);\n\t\t\t\tCollections.sort(keys);\n\t\t\t\tfor(String key:keys){\n\t\t\t\t\tCommodities now=comm.get(key);\n\t\t\t\t\tSystem.out.println(key+\" \"+now.min+\" \"+now.getAve()+\" \"+now.max);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"--\");\n\t\t\t\tkeys.clear();\n\t\t\t\tfor(String key:dealer.keySet())\tkeys.add(key);\n\t\t\t\tCollections.sort(keys);\n\t\t\t\tfor(String key:keys)\tSystem.out.println(key+\" \"+dealer.get(key).out+\" \"+dealer.get(key).in);\n\t\t\t\tSystem.out.println(\"----------\");\n\t\t\t}\n\t\t}\n\t\tclass Deal{\n\t\t\tString d,c;\tint a;\n\t\t\tDeal(String d,String c,int a){\tthis.d=d; this.c=c; this.a=a;}\n\t\t}\n\t\tclass Dealer{\n\t\t\tint in,out;\n\t\t\tDealer(int in,int out){this.in=in; this.out=out;}\n\t\t\tvoid add(int in,int out){this.in+=in; this.out+=out;}\n\t\t}\n\t\tclass Commodities{\n\t\t\tint max,min,sum,num;\n\t\t\tCommodities(int a){\n\t\t\t\tthis.max=a; this.min=a; this.sum=a;\n\t\t\t\tthis.num=1;\n\t\t\t}\n\t\t\tvoid add(int a){\n\t\t\t\tthis.max=max(this.max,a);\tthis.min=min(this.min,a);\n\t\t\t\tthis.sum+=a;\tthis.num++;\n\t\t\t}\n\t\t\tint getAve(){ return this.sum/this.num;}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Mobile Phone Coverage\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble EPS = 1e-8;\n\t\tint T = 1;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tdouble[][] p = new double[n][3];\n\t\t\tPriorityQueue<Double> qx = new PriorityQueue<Double>();\n\t\t\tPriorityQueue<Double> qy = new PriorityQueue<Double>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x = sc.nextDouble();\n\t\t\t\tdouble y = sc.nextDouble();\n\t\t\t\tdouble r = sc.nextDouble();\n\t\t\t\tif(!qx.contains(x-r))qx.add(x-r);\n\t\t\t\tif(!qy.contains(y-r))qy.add(y-r);\n\t\t\t\tif(!qx.contains(x+r))qx.add(x+r);\n\t\t\t\tif(!qy.contains(y+r))qy.add(y+r);\n\t\t\t\tp[i][0] = x; p[i][1] = y; p[i][2] = r;\n\t\t\t}\n\t\t\tdouble[] x = new double[qx.size()];\n\t\t\tdouble[] y = new double[qy.size()];\n\t\t\tint id = 0;\n\t\t\twhile(!qx.isEmpty())x[id++]=qx.poll();\n\t\t\tid = 0;\n\t\t\twhile(!qy.isEmpty())y[id++]=qy.poll();\n\t\t\tdouble ans = 0;\n\t\t\tfor(int i=0;i<x.length-1;i++)for(int j=0;j<y.length-1;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tdouble lx = p[k][0]-p[k][2];\n\t\t\t\t\tdouble rx = p[k][0]+p[k][2];\n\t\t\t\t\tdouble dy = p[k][1]-p[k][2];\n\t\t\t\t\tdouble uy = p[k][1]+p[k][2];\n\t\t\t\t\tif(lx<x[i]+EPS&&x[i+1]<rx+EPS&&dy<y[j]+EPS&&y[j+1]<uy+EPS){\n\t\t\t\t\t\tans += (x[i+1]-x[i])*(y[j+1]-y[j]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%d %.2f\\n\", T++, ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tR[] rs;\n\tint caze;\n\n\tvoid run(){\n\t\tfor(caze=1;; caze++){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tdouble r=sc.nextDouble();\n\t\t\t\trs[i]=new R(x-r, y-r, x+r, y+r);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tTreeSet<Double> setX=new TreeSet<Double>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tsetX.add(rs[i].x1);\n\t\t\tsetX.add(rs[i].x2);\n\t\t}\n\t\tDouble[] xs=setX.toArray(new Double[0]);\n\t\tsort(xs);\n\t\tint m=xs.length;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tTreeSet<R>[] setR=new TreeSet[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tsetR[i]=new TreeSet<R>();\n\t\t}\n\t\t// setR[0].add(rs[0]);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tsetR[binarySearch(xs, rs[i].x1)].add(rs[i]);\n\t\t}\n\t\tfor(int j=0; j<m-1; j++){\n\t\t\tfor(R r : setR[j]){\n\t\t\t\tif(xs[j+1]+EPS<r.x2){\n\t\t\t\t\tsetR[j+1].add(r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<m; j++){\n\t\t\tdebug(\"j\", j, \"x\", xs[j]);\n\t\t\tfor(R r : setR[j]){\n\t\t\t\tdebug(r.x2, r.y1, r.y2);\n\t\t\t}\n\t\t\tdebug();\n\t\t}\n\t\tdouble sum=0;\n\t\tfor(int k=0; k<m-1; k++){\n\t\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\t\tfor(R r : setR[k]){\n\t\t\t\tint i=seg.size(), j=seg.size();\n\t\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\t\tdouble y=seg.get(p);\n\t\t\t\t\tif(y>=r.y2){\n\t\t\t\t\t\tj=p;\n\t\t\t\t\t}\n\t\t\t\t\tif(y>=r.y1){\n\t\t\t\t\t\ti=p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\t\tseg.remove(i);\n\t\t\t\t}\n\t\t\t\tif(j%2==0){\n\t\t\t\t\tseg.add(i, r.y2);\n\t\t\t\t}\n\t\t\t\tif(i%2==0){\n\t\t\t\t\tseg.add(i, r.y1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble len=0;\n\t\t\tfor(int i=0; i<seg.size(); i+=2){\n\t\t\t\tlen=seg.get(i+1)-seg.get(i);\n\t\t\t}\n\t\t\tsum+=len*(xs[k+1]-xs[k]);\n\t\t}\n\t\tdebug(sum);\n\t\tprintln(String.format(\"%d %.2f\", caze, sum+EPS));\n\t}\n\n\tvoid test(){\n\t\tdouble[] x1={1, 3, 4, 1.0, 6., 11, 9.50};\n\t\tdouble[] x2={2, 4, 5, 2.5, 10, 12, 10.5};\n\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\tfor(int k=0; k<x1.length; k++){\n\t\t\tint i=seg.size(), j=seg.size();\n\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\tdouble x=seg.get(p);\n\t\t\t\tif(x>=x2[k]){\n\t\t\t\t\tj=p;\n\t\t\t\t}\n\t\t\t\tif(x>=x1[k]){\n\t\t\t\t\ti=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug(\"x1\", \"x2\", x1[k], x2[k]);\n\t\t\tdebug(\"i\", \"j\", i, j);\n\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\tseg.remove(i);\n\t\t\t}\n\t\t\tif(j%2==0){\n\t\t\t\tseg.add(i, x2[k]);\n\t\t\t}\n\t\t\tif(i%2==0){\n\t\t\t\tseg.add(i, x1[k]);\n\t\t\t}\n\t\t\tdebug(seg.toArray());\n\t\t}\n\t\tdebug(seg.toArray());\n\t}\n\n\tclass R implements Comparable<R>{\n\t\tdouble x1, y1, x2, y2;\n\n\t\tR(double x1, double y1, double x2, double y2){\n\t\t\tthis.x1=x1;\n\t\t\tthis.y1=y1;\n\t\t\tthis.x2=x2;\n\t\t\tthis.y2=y2;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(R arg0){\n\t\t\tif(y1-y2+EPS<0){\n\t\t\t\treturn -1;\n\t\t\t}else if(y1-y2>0+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else if(x1-x2+EPS<0){\n\t\t\t\treturn -1;\n\t\t\t}else if(x1-x2>0+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tR[] rs;\n\tint caze;\n\n\tvoid run(){\n\t\tfor(caze=1;; caze++){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tdouble r=sc.nextDouble();\n\t\t\t\trs[i]=new R(x-r, y-r, x+r, y+r);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tTreeSet<Double> setX=new TreeSet<Double>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tsetX.add(rs[i].x1);\n\t\t\tsetX.add(rs[i].x2);\n\t\t}\n\t\tDouble[] xs=setX.toArray(new Double[0]);\n\t\tsort(xs);\n\t\tint m=xs.length;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tTreeSet<R>[] setR=new TreeSet[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tsetR[i]=new TreeSet<R>();\n\t\t}\n\t\t// setR[0].add(rs[0]);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tsetR[binarySearch(xs, rs[i].x1)].add(rs[i]);\n\t\t}\n\t\tfor(int j=0; j<m-1; j++){\n\t\t\tfor(R r : setR[j]){\n\t\t\t\tif(xs[j+1]+EPS<r.x2){\n\t\t\t\t\tsetR[j+1].add(r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<m; j++){\n\t\t\tdebug(\"j\", j, \"x\", xs[j]);\n\t\t\tfor(R r : setR[j]){\n\t\t\t\tdebug(r.x2, r.y1, r.y2);\n\t\t\t}\n\t\t\tdebug();\n\t\t}\n\t\tdouble sum=0;\n\t\tfor(int k=0; k<m-1; k++){\n\t\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\t\tfor(R r : setR[k]){\n\t\t\t\tint i=seg.size(), j=seg.size();\n\t\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\t\tdouble y=seg.get(p);\n\t\t\t\t\tif(y>=r.y2){\n\t\t\t\t\t\tj=p;\n\t\t\t\t\t}\n\t\t\t\t\tif(y>=r.y1){\n\t\t\t\t\t\ti=p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\t\tseg.remove(i);\n\t\t\t\t}\n\t\t\t\tif(j%2==0){\n\t\t\t\t\tseg.add(i, r.y2);\n\t\t\t\t}\n\t\t\t\tif(i%2==0){\n\t\t\t\t\tseg.add(i, r.y1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble len=0;\n\t\t\tfor(int i=0; i<seg.size(); i+=2){\n\t\t\t\tlen=seg.get(i+1)-seg.get(i);\n\t\t\t}\n\t\t\tsum+=len*(xs[k+1]-xs[k]);\n\t\t}\n\t\tdebug(sum);\n\t\tprintln(String.format(\"%d %.2f\", caze, sum+0.005+EPS));\n\t}\n\n\tvoid test(){\n\t\tdouble[] x1={1, 3, 4, 1.0, 6., 11, 9.50};\n\t\tdouble[] x2={2, 4, 5, 2.5, 10, 12, 10.5};\n\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\tfor(int k=0; k<x1.length; k++){\n\t\t\tint i=seg.size(), j=seg.size();\n\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\tdouble x=seg.get(p);\n\t\t\t\tif(x>=x2[k]){\n\t\t\t\t\tj=p;\n\t\t\t\t}\n\t\t\t\tif(x>=x1[k]){\n\t\t\t\t\ti=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug(\"x1\", \"x2\", x1[k], x2[k]);\n\t\t\tdebug(\"i\", \"j\", i, j);\n\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\tseg.remove(i);\n\t\t\t}\n\t\t\tif(j%2==0){\n\t\t\t\tseg.add(i, x2[k]);\n\t\t\t}\n\t\t\tif(i%2==0){\n\t\t\t\tseg.add(i, x1[k]);\n\t\t\t}\n\t\t\tdebug(seg.toArray());\n\t\t}\n\t\tdebug(seg.toArray());\n\t}\n\n\tclass R implements Comparable<R>{\n\t\tdouble x1, y1, x2, y2;\n\n\t\tR(double x1, double y1, double x2, double y2){\n\t\t\tthis.x1=x1;\n\t\t\tthis.y1=y1;\n\t\t\tthis.x2=x2;\n\t\t\tthis.y2=y2;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(R arg0){\n\t\t\tif(y1-y2+EPS<0){\n\t\t\t\treturn -1;\n\t\t\t}else if(y1-y2>0+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else if(x1-x2+EPS<0){\n\t\t\t\treturn -1;\n\t\t\t}else if(x1-x2>0+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic double[] x, y, r;\n\n\tpublic static void main(String[] args) {\n\t\tint t = 1;\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tx = new double[N];\n\t\t\ty = new double[N];\n\t\t\tr = new double[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tSystem.out.printf(\"%d %.2f\\n\", t, solve());\n\t\t\t++t;\n\t\t}\n\t}\n\n\tstatic double solve() {\n\t\tdouble[] xs = new double[N * 2];\n\t\tdouble[] ys = new double[N * 2];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\txs[2 * i] = x[i] - r[i];\n\t\t\txs[2 * i + 1] = x[i] + r[i];\n\t\t\tys[2 * i] = y[i] - r[i];\n\t\t\tys[2 * i + 1] = y[i] + r[i];\n\t\t}\n\t\tArrays.sort(xs);\n\t\tArrays.sort(ys);\n\t\tboolean[][] covered = new boolean[2 * N][2 * N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x1 = Arrays.binarySearch(xs, x[i] - r[i]);\n\t\t\tint x2 = Arrays.binarySearch(xs, x[i] + r[i]);\n\t\t\tint y1 = Arrays.binarySearch(ys, y[i] - r[i]);\n\t\t\tint y2 = Arrays.binarySearch(ys, y[i] + r[i]);\n\t\t\tfor (int j = x1; j < x2; ++j) {\n\t\t\t\tfor (int k = y1; k < y2; ++k) {\n\t\t\t\t\tcovered[j][k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = 0;\n\t\tfor (int i = 0; i < 2 * N; ++i) {\n\t\t\tfor (int j = 0; j < 2 * N; ++j) {\n\t\t\t\tif (covered[i][j]) {\n\t\t\t\t\tans += (xs[i + 1] - xs[i]) * (ys[j + 1] - ys[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n//public class Problem1202_MobilePhoneCoverage_Brute {\npublic class Main {\n\tprivate Maxnorm maxnorm;\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t//\tProblem1202_MobilePhoneCoverage_Brute test = new Problem1202_MobilePhoneCoverage_Brute();\n\t\t\tMain test = new Main();\n\t\t\t\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tString line;\n\t\t\twhile((line = reader.readLine()) != null) {\n\t\t\t\tint antennaNumber = Integer.parseInt(line);\n\t\t\t\tcount++;\n\t\t\t\tif(antennaNumber < 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\ttest.createNorm();\n\t\t\t\t\tfor(int i = 0; i < antennaNumber; i++) {\n\t\t\t\t\t\ttest.addAntenna(reader.readLine());\n\t\t\t\t\t}\n\t\t\t\t\tdouble area = test.getArea();\n\t\t\t\t\tSystem.out.printf(\"%d %.2f\\n\", count,area);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tvoid createNorm() {\n\t\tmaxnorm = new Maxnorm();\n\t}\n\tvoid addAntenna(String line) {\n\t\tString[] textArray = line.split(\" \");\n\t\t\n\t\tint x = (int)(Double.parseDouble(textArray[0]) * 10);\n\t\tint y = (int)(Double.parseDouble(textArray[1]) * 10);\n\t\tint r = (int)(Double.parseDouble(textArray[2]) * 10);\n\t\t\n\t\tmaxnorm.addAntenna(x, y, r);\n\t}\n\tdouble getArea() {\n\t\tint area = maxnorm.getArea();\n\t\tdouble result = (double)area / 100;\n\t\t\n\t\treturn result;\n\t}\n\t//MaxnormNXÅÍSÄÌx/yÀWð10{, ÊÏð100{µ½lÅ\\í·Bi®Å\\í·Æ¢¤±Æ)\n\tprivate class Maxnorm {\n\t\tboolean[][] area;\t//area[210][220] = (x,y) ; (10,20)\n\t\tfinal int MAX_X = 6000;\n\t\tfinal int MAX_Y = 6000;\n\t\t\n\t\tMaxnorm() {\n\t\t\tarea = new boolean[MAX_X][MAX_X];\t//0 <= x+r <= 400, -200 <= x-r <= 200Byà¯l\n\t\t}\n\t\tvoid addAntenna(int x, int y, int r) {\n\t\t\tfor(int i = x - r +2000; i < x + r + 2000; i++) {\n\t\t\t\tfor(int j = y - r + 2000; j < y + r + 2000; j++) {\n\t\t\t\t\tarea[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint getArea() {\n\t\t\tint result = 0;\n\t\t\tfor(int i = 0; i < MAX_X; i++) {\n\t\t\t\tfor(int j = 0; j < MAX_Y; j++) {\n\t\t\t\t\tif(area[i][j]) {\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tR[] rs;\n\tint caze;\n\n\tvoid run(){\n\t\tfor(caze=1;; caze++){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tdouble r=sc.nextDouble();\n\t\t\t\trs[i]=new R(x-r, y-r, x+r, y+r);\n\t\t\t}\n\t\t\tsolve();\n\t\t\t// debug(solveX(), solveY());\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tTreeSet<Double> setX=new TreeSet<Double>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tsetX.add(rs[i].x1);\n\t\t\tsetX.add(rs[i].x2);\n\t\t}\n\t\tDouble[] xs=setX.toArray(new Double[0]);\n\t\tsort(xs);\n\t\tint m=xs.length;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tTreeSet<R>[] setR=new TreeSet[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tsetR[i]=new TreeSet<R>();\n\t\t}\n\n\t\tfor(int j=0; j<m-1; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(rs[i].x1<xs[j]+EPS&&xs[j]+EPS<rs[i].x2){\n\t\t\t\t\tsetR[j].add(rs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble sum=0;\n\t\tfor(int k=0; k<m-1; k++){\n\t\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\t\tfor(R r : setR[k]){\n\t\t\t\tif(abs(r.y1-r.y2)<EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint i=seg.size(), j=seg.size();\n\t\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\t\tdouble y=seg.get(p);\n\t\t\t\t\tif(y+EPS>r.y2){\n\t\t\t\t\t\tj=p;\n\t\t\t\t\t}\n\t\t\t\t\tif(y+EPS>r.y1){\n\t\t\t\t\t\ti=p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\t\tseg.remove(i);\n\t\t\t\t}\n\t\t\t\tif(j%2==0){\n\t\t\t\t\tseg.add(i, r.y2);\n\t\t\t\t}\n\t\t\t\tif(i%2==0){\n\t\t\t\t\tseg.add(i, r.y1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble len=0;\n\t\t\tfor(int i=0; i<seg.size(); i+=2){\n\t\t\t\tlen+=seg.get(i+1)-seg.get(i);\n\t\t\t}\n\t\t\tsum+=len*(xs[k+1]-xs[k]);\n\t\t}\n\t\tdebug(sum);\n\t\tprintln(String.format(\"%d %.2f\", caze, sum+EPS));\n\t}\n\n\tdouble solveX(){\n\t\tTreeSet<Double> setX=new TreeSet<Double>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tsetX.add(rs[i].x1);\n\t\t\tsetX.add(rs[i].x2);\n\t\t}\n\t\tDouble[] xs=setX.toArray(new Double[0]);\n\t\tsort(xs);\n\t\tint m=xs.length;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tTreeSet<R>[] setR=new TreeSet[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tsetR[i]=new TreeSet<R>();\n\t\t}\n\n\t\tfor(int j=0; j<m-1; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(rs[i].x1<xs[j]+EPS&&xs[j]+EPS<rs[i].x2){\n\t\t\t\t\tsetR[j].add(rs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble sum=0;\n\t\tfor(int k=0; k<m-1; k++){\n\t\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\t\tfor(R r : setR[k]){\n\t\t\t\tif(abs(r.y1-r.y2)<EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint i=seg.size(), j=seg.size();\n\t\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\t\tdouble y=seg.get(p);\n\t\t\t\t\tif(y+EPS>r.y2){\n\t\t\t\t\t\tj=p;\n\t\t\t\t\t}\n\t\t\t\t\tif(y+EPS>r.y1){\n\t\t\t\t\t\ti=p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\t\tseg.remove(i);\n\t\t\t\t}\n\t\t\t\tif(j%2==0){\n\t\t\t\t\tseg.add(i, r.y2);\n\t\t\t\t}\n\t\t\t\tif(i%2==0){\n\t\t\t\t\tseg.add(i, r.y1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble len=0;\n\t\t\tfor(int i=0; i<seg.size(); i+=2){\n\t\t\t\tlen=seg.get(i+1)-seg.get(i);\n\t\t\t}\n\t\t\tsum+=len*(xs[k+1]-xs[k]);\n\t\t}\n\t\t// println(String.format(\"%d %.2f\", caze, sum+EPS));\n\t\treturn sum;\n\t}\n\n\tdouble solveY(){\n\t\tTreeSet<Double> setY=new TreeSet<Double>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tsetY.add(rs[i].y1);\n\t\t\tsetY.add(rs[i].y2);\n\t\t}\n\t\tDouble[] ys=setY.toArray(new Double[0]);\n\t\tsort(ys);\n\t\tint m=ys.length;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tTreeSet<R>[] setR=new TreeSet[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tsetR[i]=new TreeSet<R>();\n\t\t}\n\n\t\tfor(int j=0; j<m-1; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(rs[i].y1<ys[j]+EPS&&ys[j]+EPS<rs[i].y2){\n\t\t\t\t\tsetR[j].add(rs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdebug(\"ys\", ys);\n\n\t\tdouble sum=0;\n\t\tfor(int k=0; k<m-1; k++){\n\t\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\t\tfor(R r : setR[k]){\n\t\t\t\tif(abs(r.x1-r.x2)<EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint i=seg.size(), j=seg.size();\n\t\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\t\tdouble x=seg.get(p);\n\t\t\t\t\tif(x+EPS>r.x2){\n\t\t\t\t\t\tj=p;\n\t\t\t\t\t}\n\t\t\t\t\tif(x+EPS>r.x1){\n\t\t\t\t\t\ti=p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\t\tseg.remove(i);\n\t\t\t\t}\n\t\t\t\tif(j%2==0){\n\t\t\t\t\tseg.add(i, r.x2);\n\t\t\t\t}\n\t\t\t\tif(i%2==0){\n\t\t\t\t\tseg.add(i, r.x1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug(\"seg\", seg.toArray());\n\t\t\tdouble len=0;\n\t\t\tfor(int i=0; i<seg.size(); i+=2){\n\t\t\t\tlen=seg.get(i+1)-seg.get(i);\n\t\t\t}\n\t\t\tdebug(len);\n\t\t\tsum+=len*(ys[k+1]-ys[k]);\n\t\t}\n\t\treturn sum;\n\t}\n\n\tvoid test(){\n\t\tdouble[] x1={1, 3, 4, 1.0, 6., 11, 9.50, 20};\n\t\tdouble[] x2={2, 4, 5, 2.5, 10, 12, 10.5, 20};\n\t\t// x1=new double[20];\n\t\t// x2=new double[20];\n\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\tfor(int k=0; k<x1.length; k++){\n\t\t\t// x1[k]=(int)(Math.random()*2)+((int)(Math.random()*50))/50.0;\n\t\t\t// x2[k]=(int)(Math.random()*2)+((int)(Math.random()*50))/50.0;\n\t\t\tif(abs(x2[k]-x1[k])<EPS){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(x2[k]<x1[k]){\n\t\t\t\tdouble t=x1[k];\n\t\t\t\tx1[k]=x2[k];\n\t\t\t\tx2[k]=t;\n\t\t\t}\n\t\t\tint i=seg.size(), j=seg.size();\n\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\tdouble x=seg.get(p);\n\t\t\t\tif(x>=x2[k]){\n\t\t\t\t\tj=p;\n\t\t\t\t}\n\t\t\t\tif(x>=x1[k]){\n\t\t\t\t\ti=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug(\"x1\", \"x2\", x1[k], x2[k]);\n\t\t\tdebug(\"i\", \"j\", i, j);\n\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\tseg.remove(i);\n\t\t\t}\n\t\t\tif(j%2==0){\n\t\t\t\tseg.add(i, x2[k]);\n\t\t\t}\n\t\t\tif(i%2==0){\n\t\t\t\tseg.add(i, x1[k]);\n\t\t\t}\n\t\t\tdebug(seg.toArray());\n\t\t}\n\t\tdebug(seg.toArray());\n\t}\n\n\tclass R implements Comparable<R>{\n\t\tdouble x1, y1, x2, y2;\n\n\t\tR(double x1, double y1, double x2, double y2){\n\t\t\tthis.x1=x1;\n\t\t\tthis.y1=y1;\n\t\t\tthis.x2=x2;\n\t\t\tthis.y2=y2;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(R arg0){\n\t\t\tif(y1-y2+EPS<0){\n\t\t\t\treturn -1;\n\t\t\t}else if(y1-y2>0+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else if(x1-x2+EPS<0){\n\t\t\t\treturn -1;\n\t\t\t}else if(x1-x2>0+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tR[] rs;\n\tint caze;\n\n\tvoid run(){\n\t\tfor(caze=1;; caze++){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tdouble r=sc.nextDouble();\n\t\t\t\trs[i]=new R(x-r, y-r, x+r, y+r);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tTreeSet<Double> setX=new TreeSet<Double>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tsetX.add(rs[i].x1);\n\t\t\tsetX.add(rs[i].x2);\n\t\t}\n\t\tDouble[] xs=setX.toArray(new Double[0]);\n\t\tsort(xs);\n\t\tint m=xs.length;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tTreeSet<R>[] setR=new TreeSet[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tsetR[i]=new TreeSet<R>();\n\t\t}\n\t\t// setR[0].add(rs[0]);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tsetR[binarySearch(xs, rs[i].x1)].add(rs[i]);\n\t\t}\n\t\tfor(int j=0; j<m-1; j++){\n\t\t\tfor(R r : setR[j]){\n\t\t\t\tif(xs[j+1]+EPS<r.x2){\n\t\t\t\t\tsetR[j+1].add(r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<m; j++){\n\t\t\tdebug(\"j\", j, \"x\", xs[j]);\n\t\t\tfor(R r : setR[j]){\n\t\t\t\tdebug(r.x2, r.y1, r.y2);\n\t\t\t}\n\t\t\tdebug();\n\t\t}\n\t\tdouble sum=0;\n\t\tfor(int k=0; k<m-1; k++){\n\t\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\t\tfor(R r : setR[k]){\n\t\t\t\tint i=seg.size(), j=seg.size();\n\t\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\t\tdouble y=seg.get(p);\n\t\t\t\t\tif(y>=r.y2){\n\t\t\t\t\t\tj=p;\n\t\t\t\t\t}\n\t\t\t\t\tif(y>=r.y1){\n\t\t\t\t\t\ti=p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\t\tseg.remove(i);\n\t\t\t\t}\n\t\t\t\tif(j%2==0){\n\t\t\t\t\tseg.add(i, r.y2);\n\t\t\t\t}\n\t\t\t\tif(i%2==0){\n\t\t\t\t\tseg.add(i, r.y1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble len=0;\n\t\t\tfor(int i=0; i<seg.size(); i+=2){\n\t\t\t\tlen=seg.get(i+1)-seg.get(i);\n\t\t\t}\n\t\t\tsum+=len*(xs[k+1]-xs[k]);\n\t\t}\n\t\tdebug(sum);\n\t\tprintln(String.format(\"%d %.2f\", caze, sum));\n\t}\n\n\tvoid test(){\n\t\tdouble[] x1={1, 3, 4, 1.0, 6., 11, 9.50};\n\t\tdouble[] x2={2, 4, 5, 2.5, 10, 12, 10.5};\n\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\tfor(int k=0; k<x1.length; k++){\n\t\t\tint i=seg.size(), j=seg.size();\n\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\tdouble x=seg.get(p);\n\t\t\t\tif(x>=x2[k]){\n\t\t\t\t\tj=p;\n\t\t\t\t}\n\t\t\t\tif(x>=x1[k]){\n\t\t\t\t\ti=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug(\"x1\", \"x2\", x1[k], x2[k]);\n\t\t\tdebug(\"i\", \"j\", i, j);\n\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\tseg.remove(i);\n\t\t\t}\n\t\t\tif(j%2==0){\n\t\t\t\tseg.add(i, x2[k]);\n\t\t\t}\n\t\t\tif(i%2==0){\n\t\t\t\tseg.add(i, x1[k]);\n\t\t\t}\n\t\t\tdebug(seg.toArray());\n\t\t}\n\t\tdebug(seg.toArray());\n\t}\n\n\tclass R implements Comparable<R>{\n\t\tdouble x1, y1, x2, y2;\n\n\t\tR(double x1, double y1, double x2, double y2){\n\t\t\tthis.x1=x1;\n\t\t\tthis.y1=y1;\n\t\t\tthis.x2=x2;\n\t\t\tthis.y2=y2;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(R arg0){\n\t\t\tif(y1-y2+EPS<0){\n\t\t\t\treturn -1;\n\t\t\t}else if(y1-y2>0+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else if(x1-x2+EPS<0){\n\t\t\t\treturn -1;\n\t\t\t}else if(x1-x2>0+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tfor(int set=1;;set++){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tArrayList<ArrayList<Edge>> map = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i=0;i<=80000;i++){\n\t\t\t\tmap.add(new ArrayList<Edge>());\n\t\t\t}\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x = sc.nextDouble();\n\t\t\t\tdouble y = sc.nextDouble();\n\t\t\t\tdouble r = sc.nextDouble();\n\n\t\t\t\tint left = (int)((x - r) * 100) + 40000;\n\t\t\t\tint right = (int)((x + r) * 100) + 40000;\n\t\t\t\tfor(int j=left;j<right;j++){\n\t\t\t\t\tmap.get(j).add(new Edge((int)((y-r)*100),true));\n\t\t\t\t\tmap.get(j).add(new Edge((int)((y+r)*100),false));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\tfor(int i=0;i<=80000;i++){\n\t\t\t\tif(map.get(i).isEmpty()) continue;\n\t\t\t\tCollections.sort(map.get(i));\n\t\t\t\tint level = 0;\n\t\t\t\tint top = 0;\n\t\t\t\tfor(Edge e : map.get(i)){\n\t\t\t\t\tif(e.d){\n\t\t\t\t\t\tif(level == 0) top = e.place;\n\t\t\t\t\t\tlevel++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlevel--;\n\t\t\t\t\t\tif(level == 0) ans += (e.place - top);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.printf(\"%d %.2f\\n\",set,0.0001*ans);\n\t\t}\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint place;\n\tboolean d; //true : from, false : to\n\n\tEdge(int place,boolean d){\n\t\tthis.place = place;\n\t\tthis.d = d;\n\t}\n\n\tpublic int compareTo(Edge e){\n\t\tif(place < e.place) return -1;\n\t\tif(place > e.place) return 1;\n\t\tif(d == false && e.d == true) return 1;\n\t\tif(d == true && e.d == false) return -1;\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tR[] rs;\n\tint caze;\n\n\tvoid run(){\n\t\tfor(caze=1;; caze++){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tdouble r=sc.nextDouble();\n\t\t\t\trs[i]=new R(x-r, y-r, x+r, y+r);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tTreeSet<Double> setX=new TreeSet<Double>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tsetX.add(rs[i].x1);\n\t\t\tsetX.add(rs[i].x2);\n\t\t}\n\t\tDouble[] xs=setX.toArray(new Double[0]);\n\t\tsort(xs);\n\t\tint m=xs.length;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tTreeSet<R>[] setR=new TreeSet[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tsetR[i]=new TreeSet<R>();\n\t\t}\n\n\t\tfor(int j=0; j<m-1; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(rs[i].x1<xs[j]+EPS&&xs[j]+EPS<rs[i].x2){\n\t\t\t\t\tsetR[j].add(rs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble sum=0;\n\t\tfor(int k=0; k<m-1; k++){\n\t\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\t\tfor(R r : setR[k]){\n\t\t\t\tif(abs(r.y1-r.y2)<EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint i=seg.size(), j=seg.size();\n\t\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\t\tdouble y=seg.get(p);\n\t\t\t\t\tif(y+EPS>r.y2){\n\t\t\t\t\t\tj=p;\n\t\t\t\t\t}\n\t\t\t\t\tif(y+EPS>r.y1){\n\t\t\t\t\t\ti=p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\t\tseg.remove(i);\n\t\t\t\t}\n\t\t\t\tif(j%2==0){\n\t\t\t\t\tseg.add(i, r.y2);\n\t\t\t\t}\n\t\t\t\tif(i%2==0){\n\t\t\t\t\tseg.add(i, r.y1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble len=0;\n\t\t\tfor(int i=0; i<seg.size(); i+=2){\n\t\t\t\tlen=seg.get(i+1)-seg.get(i);\n\t\t\t}\n\t\t\tsum+=len*(xs[k+1]-xs[k]);\n\t\t}\n\t\tdebug(sum);\n\t\tprintln(String.format(\"%d %.2f\", caze, sum+EPS));\n\t}\n\n\tvoid test(){\n\t\tdouble[] x1={1, 3, 4, 1.0, 6., 11, 9.50, 20};\n\t\tdouble[] x2={2, 4, 5, 2.5, 10, 12, 10.5, 20};\n\t\t// x1=new double[20];\n\t\t// x2=new double[20];\n\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\tfor(int k=0; k<x1.length; k++){\n\t\t\t// x1[k]=(int)(Math.random()*2)+((int)(Math.random()*50))/50.0;\n\t\t\t// x2[k]=(int)(Math.random()*2)+((int)(Math.random()*50))/50.0;\n\t\t\tif(abs(x2[k]-x1[k])<EPS){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(x2[k]<x1[k]){\n\t\t\t\tdouble t=x1[k];\n\t\t\t\tx1[k]=x2[k];\n\t\t\t\tx2[k]=t;\n\t\t\t}\n\t\t\tint i=seg.size(), j=seg.size();\n\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\tdouble x=seg.get(p);\n\t\t\t\tif(x>=x2[k]){\n\t\t\t\t\tj=p;\n\t\t\t\t}\n\t\t\t\tif(x>=x1[k]){\n\t\t\t\t\ti=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug(\"x1\", \"x2\", x1[k], x2[k]);\n\t\t\tdebug(\"i\", \"j\", i, j);\n\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\tseg.remove(i);\n\t\t\t}\n\t\t\tif(j%2==0){\n\t\t\t\tseg.add(i, x2[k]);\n\t\t\t}\n\t\t\tif(i%2==0){\n\t\t\t\tseg.add(i, x1[k]);\n\t\t\t}\n\t\t\tdebug(seg.toArray());\n\t\t}\n\t\tdebug(seg.toArray());\n\t}\n\n\tclass R implements Comparable<R>{\n\t\tdouble x1, y1, x2, y2;\n\n\t\tR(double x1, double y1, double x2, double y2){\n\t\t\tthis.x1=x1;\n\t\t\tthis.y1=y1;\n\t\t\tthis.x2=x2;\n\t\t\tthis.y2=y2;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(R arg0){\n\t\t\tif(y1-y2+EPS<0){\n\t\t\t\treturn -1;\n\t\t\t}else if(y1-y2>0+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else if(x1-x2+EPS<0){\n\t\t\t\treturn -1;\n\t\t\t}else if(x1-x2>0+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n//public class Problem1202_MobilePhoneCoverage_Brute {\npublic class Main {\n\tprivate Maxnorm maxnorm;\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t//\tProblem1202_MobilePhoneCoverage_Brute test = new Problem1202_MobilePhoneCoverage_Brute();\n\t\t\tMain test = new Main();\n\t\t\t\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tString line;\n\t\t\twhile((line = reader.readLine()) != null) {\n\t\t\t\tint antennaNumber = Integer.parseInt(line);\n\t\t\t\tcount++;\n\t\t\t\tif(antennaNumber < 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\ttest.createNorm();\n\t\t\t\t\tfor(int i = 0; i < antennaNumber; i++) {\n\t\t\t\t\t\ttest.addAntenna(reader.readLine());\n\t\t\t\t\t}\n\t\t\t\t\tdouble area = test.getArea();\n\t\t\t\t\tSystem.out.printf(\"%d %.2f\\n\", count,area);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tvoid createNorm() {\n\t\tmaxnorm = new Maxnorm();\n\t}\n\tvoid addAntenna(String line) {\n\t\tString[] textArray = line.split(\" \");\n\t\tfor(int i = 0; i < textArray.length; i++) {\t//10{·é\n\t\t\tString text = textArray[i];\n\t\t\tint position = text.indexOf('.');\n\t\t\ttext = text.substring(0,position) + text.substring(position+1);\n\t\t\ttextArray[i] = text;\n\t\t}\n\t\tint x = Integer.parseInt(textArray[0]);\n\t\tint y = Integer.parseInt(textArray[1]);\n\t\tint r = Integer.parseInt(textArray[2]);\n\t\t\n\t\tmaxnorm.addAntenna(x, y, r);\n\t}\n\tdouble getArea() {\n\t\tint area = maxnorm.getArea();\n\t\tdouble result = (double)area / 100;\n\t\t\n\t\treturn result;\n\t}\n\t//MaxnormNXÅÍSÄÌx/yÀWð10{, ÊÏð100{µ½lÅ\\í·Bi®Å\\í·Æ¢¤±Æ)\n\tprivate class Maxnorm {\n\t\tboolean[][] area;\t//area[210][220] = (x,y) ; (10,20)\n\t\tfinal int MAX_X = 600;\n\t\tfinal int MAX_Y = 600;\n\t\t\n\t\tMaxnorm() {\n\t\t\tarea = new boolean[MAX_X][MAX_X];\t//0 <= x+r <= 400, -200 <= x-r <= 200Byà¯l\n\t\t}\n\t\tvoid addAntenna(int x, int y, int r) {\n\t\t\tfor(int i = x - r +200; i < x + r + 200; i++) {\n\t\t\t\tfor(int j = y - r + 200; j < y + r + 200; j++) {\n\t\t\t\t\tarea[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint getArea() {\n\t\t\tint result = 0;\n\t\t\tfor(int i = 0; i < MAX_X; i++) {\n\t\t\t\tfor(int j = 0; j < MAX_Y; j++) {\n\t\t\t\t\tif(area[i][j]) {\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.awt.geom.Point2D.Double;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n    \tnew C().doIt();\n    }\n    class C{\n    \tvoid doIt(){\n    \t\tint cnt = 1;\n            while(true){\n                int n = sc.nextInt();\n                if(n == 0) break;\n                double [] xlist = new double[n * 2];\n                double [] ylist = new double[n * 2];\n                Point2D [] Fplist = new Point2D[n * 2];\n                Point2D [] Lplist = new Point2D[n * 2];\n                for(int i = 0; i < n; i++){\n                    double x = sc.nextDouble();\n                    double y = sc.nextDouble();\n                    double r = sc.nextDouble();\n                    Fplist[i] = new Point2D.Double(x - r,y - r);\n                    Lplist[i] = new Point2D.Double(x + r,y + r);\n                    xlist[i * 2] = x - r;xlist[i * 2 + 1] = x + r;\n                    ylist[i * 2] = y - r;ylist[i * 2 + 1] = y + r;\n                }\n                Arrays.sort(xlist);\n                Arrays.sort(ylist);\n                 \n                boolean [][] map = new boolean[ylist.length -1][xlist.length -1];\n                for(int i = 0; i < n; i++){\n                \tPoint2D fp = new Point2D.Double(Arrays.binarySearch(xlist, Fplist[i].getX()),Arrays.binarySearch(ylist, Fplist[i].getY()));\n                \tPoint2D lp = new Point2D.Double(Arrays.binarySearch(xlist, Lplist[i].getX()),Arrays.binarySearch(ylist, Lplist[i].getY()));\n//                    System.out.println(fx+\" \"+lx+\" \"+fy+\" \"+ly);\n                    for(int j = (int)fp.getY(); j < (int)lp.getY(); j++){\n                        for(int k = (int)fp.getX(); k < (int)lp.getX(); k++){\n                            map[j][k] = true;\n                        }\n                    }\n                }\n                double ans = 0.0;\n                for(int i = 0; i < map.length; i++){\n//                \tSystem.out.println(map.length+\" \"+map[i].length);\n                    for(int j = 0; j < map[i].length; j++){\n                        if(map[i][j]){\n                            double X = xlist[j + 1] - xlist[j];\n                            double Y = ylist[i + 1] - ylist[i];\n//                            System.out.println(xlist[j + 1]+\" \"+xlist[j]+\" \"+ylist[i + 1]+\" \"+ylist[i]);\n                            double area = X * Y;\n                            ans += area;\n                        }\n                    }\n//                    System.out.println();\n                }\n                \n                \n//                for(int i = 0; i < map.length; i++){\n//                    for(int j = 0; j < map[i].length; j++){\n//                    \tSystem.out.print(map[i][j] ? 0:1);\n//                    }\n//                    System.out.println();\n//                }\n                System.out.printf(\"%d %.2f\\n\",cnt++, ans);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n//public class Problem1202_MobilePhoneCoverage_Brute {\npublic class Main {\n\tprivate Maxnorm maxnorm;\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t//\tProblem1202_MobilePhoneCoverage_Brute test = new Problem1202_MobilePhoneCoverage_Brute();\n\t\t\tMain test = new Main();\n\t\t\t\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tString line;\n\t\t\twhile((line = reader.readLine()) != null) {\n\t\t\t\tint antennaNumber = Integer.parseInt(line);\n\t\t\t\tcount++;\n\t\t\t\tif(antennaNumber < 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\ttest.createNorm();\n\t\t\t\t\tfor(int i = 0; i < antennaNumber; i++) {\n\t\t\t\t\t\ttest.addAntenna(reader.readLine());\n\t\t\t\t\t}\n\t\t\t\t\tdouble area = test.getArea();\n\t\t\t\t\tSystem.out.printf(\"%d %.2f\\n\", count,area);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tvoid createNorm() {\n\t\tmaxnorm = new Maxnorm();\n\t}\n\tvoid addAntenna(String line) {\n\t\tString[] textArray = line.split(\" \");\n\t\t\n\t\tint x = (int)(Double.parseDouble(textArray[0]) * 10);\n\t\tint y = (int)(Double.parseDouble(textArray[1]) * 10);\n\t\tint r = (int)(Double.parseDouble(textArray[2]) * 10);\n\t\t\n\t\tmaxnorm.addAntenna(x, y, r);\n\t}\n\tdouble getArea() {\n\t\tint area = maxnorm.getArea();\n\t\tdouble result = (double)area / 100;\n\t\t\n\t\treturn result;\n\t}\n\t//MaxnormNXÅÍSÄÌx/yÀWð10{, ÊÏð100{µ½lÅ\\í·Bi®Å\\í·Æ¢¤±Æ)\n\tprivate class Maxnorm {\n\t\tboolean[][] area;\t//area[210][220] = (x,y) ; (10,20)\n\t\tfinal int MAX_X = 600;\n\t\tfinal int MAX_Y = 600;\n\t\t\n\t\tMaxnorm() {\n\t\t\tarea = new boolean[MAX_X][MAX_X];\t//0 <= x+r <= 400, -200 <= x-r <= 200Byà¯l\n\t\t}\n\t\tvoid addAntenna(int x, int y, int r) {\n\t\t\tfor(int i = x - r +200; i < x + r + 200; i++) {\n\t\t\t\tfor(int j = y - r + 200; j < y + r + 200; j++) {\n\t\t\t\t\tarea[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint getArea() {\n\t\t\tint result = 0;\n\t\t\tfor(int i = 0; i < MAX_X; i++) {\n\t\t\t\tfor(int j = 0; j < MAX_Y; j++) {\n\t\t\t\t\tif(area[i][j]) {\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\tpublic static class Rec implements Comparable<Rec> {\n\t\tdouble start, end;\n\t\tdouble max, min;\n\t\t\n\t\tpublic Rec(double start, double end, double max, double min) {\n\t\t\tsuper();\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t\tthis.max = max;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Rec arg0) {\n\t\t\treturn this.start - arg0.start < 0 ? -1 :\n\t\t\t\t\tthis.start - arg0.start > 0 ? 1 : 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tint count = 1;\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Rec> walls = new ArrayList<Rec>(n);\n\t\t\tTreeSet<Double> set = new TreeSet<Double>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal double x = sc.nextDouble();\n\t\t\t\tfinal double y = sc.nextDouble();\n\t\t\t\tfinal double r = sc.nextDouble();\n\t\t\t\t\n\t\t\t\tset.add(x - r);\n\t\t\t\tset.add(x + r);\n\t\t\t\twalls.add(new Rec(x - r, x + r, y + r, y - r));\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(walls);\n\t\t\tArrayList<Double> list = new ArrayList<Double>(set);\n\t\t\t\n\t\t\tdouble min[] = new double[list.size()];\n\t\t\tArrays.fill(min, Double.MAX_VALUE);\n\t\t\tdouble max[] = new double[list.size()];\n\t\t\t\n\t\t\t\n\t\t\tfor(Rec r : walls){\n\t\t\t\t\n\t\t\t\tfinal int start = Collections.binarySearch(list, r.start);\n\t\t\t\tfinal int end = Collections.binarySearch(list, r.end);\n\t\t\t\t\n\t\t\t\tfor(int i = start; i < end; i++){\n\t\t\t\t\tmax[i] = Math.max(max[i], r.max);\n\t\t\t\t\tmin[i] = Math.min(min[i], r.min);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\tSystem.out.println(i + \"(\"+ list.get(i) +\")\" + \": min = \" + min[i] + \" , max = \" + max[i]);\n\t\t\t}\n\t\t\t*/\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i = 0; i < list.size() - 1; i++){\n\t\t\t\tsum += (max[i] - min[i]) * (list.get(i + 1) - list.get(i));\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count + \" \" + sum);\n\t\t\tcount++;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\tpublic static class Rec implements Comparable<Rec> {\n\t\tdouble start, end;\n\t\tdouble max, min;\n\t\t\n\t\tpublic Rec(double start, double end, double max, double min) {\n\t\t\tsuper();\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t\tthis.max = max;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Rec arg0) {\n\t\t\treturn (this.max - this.min) - (arg0.max - arg0.min) > 0 ? -1 :\n\t\t\t\t(this.max - this.min) - (arg0.max - arg0.min) < 0 ? 1 : 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tint count = 1;\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Rec> walls = new ArrayList<Rec>(n);\n\t\t\tTreeSet<Double> set = new TreeSet<Double>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal double x = sc.nextDouble();\n\t\t\t\tfinal double y = sc.nextDouble();\n\t\t\t\tfinal double r = sc.nextDouble();\n\t\t\t\t\n\t\t\t\tset.add(x - r);\n\t\t\t\tset.add(x + r);\n\t\t\t\twalls.add(new Rec(x - r, x + r, y + r, y - r));\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(walls);\n\t\t\tArrayList<Double> list = new ArrayList<Double>(set);\n\t\t\t\n\t\t\tArrayList<LinkedList<Double>> min = new ArrayList<LinkedList<Double>>(list.size());\n\t\t\tArrayList<LinkedList<Double>> max = new ArrayList<LinkedList<Double>>(list.size());\n\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\tmax.add(new LinkedList<Double>());\n\t\t\t\tmin.add(new LinkedList<Double>());\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tfor(Rec r : walls){\n\t\t\t\t\n\t\t\t\tfinal int start = Collections.binarySearch(list, r.start);\n\t\t\t\tfinal int end = Collections.binarySearch(list, r.end);\n\t\t\t\t\n\t\t\t\tfor(int i = start; i < end; i++){\n\t\t\t\t\tdouble r_max = r.max;\n\t\t\t\t\tdouble r_min = r.min;\n\t\t\t\t\t\n\t\t\t\t\tif(max.get(i).size() == 0&& min.get(i).size() == 0){\n\t\t\t\t\t\tmax.get(i).add(r_max);\n\t\t\t\t\t\tmin.get(i).add(r_min);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tListIterator<Double> max_iter = max.get(i).listIterator();\n\t\t\t\t\t\tListIterator<Double> min_iter = min.get(i).listIterator();\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean found = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile(max_iter.hasNext() && min_iter.hasNext()){\n\t\t\t\t\t\t\tdouble i_max = max_iter.next(), i_min = min_iter.next();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(i_max >= r_max && i_min <= r_min){\n\t\t\t\t\t\t\t\t//System.out.println(\"a\");\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(i_max < r_max && i_min > r_min){\n\t\t\t\t\t\t\t\tmax_iter.remove();\n\t\t\t\t\t\t\t\tmin_iter.remove();\n\t\t\t\t\t\t\t\t//max_iter.set(r.max);\n\t\t\t\t\t\t\t\t//min_iter.set(r.min);\n\t\t\t\t\t\t\t\t//System.out.println(\"b\");\n\t\t\t\t\t\t\t\t//found = true;\n\t\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t\t}else if(i_max < r_max && i_max >= r_min && i_min <= r_min){\n\t\t\t\t\t\t\t\tr_min = i_min;\n\t\t\t\t\t\t\t\t//max_iter.set(r.max);\n\t\t\t\t\t\t\t\tmax_iter.remove();\n\t\t\t\t\t\t\t\tmin_iter.remove();\n\t\t\t\t\t\t\t\t//System.out.println(\"c\");\n\t\t\t\t\t\t\t\t//found = true;\n\t\t\t\t\t\t\t}else if(i_min > r_min && i_max >= r_max && i_min <= r_max){\n\t\t\t\t\t\t\t\tr_max = i_max;\n\t\t\t\t\t\t\t\t//min_iter.set(r.min);\n\t\t\t\t\t\t\t\tmax_iter.remove();\n\t\t\t\t\t\t\t\tmin_iter.remove();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//found = true;\n\t\t\t\t\t\t\t\t//System.out.println(\"d\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!found){\n\t\t\t\t\t\t\t//System.out.println(\"min => \" + min.get(i) + \" \" + r.min);\n\t\t\t\t\t\t\t//System.out.println(\"max => \" + max.get(i) + \" \" + r.max);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tmax.get(i).add(r_max);\n\t\t\t\t\t\t\tmin.get(i).add(r_min);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//for(int i = 0; i < list.size(); i++){\n\t\t\t//\tSystem.out.println(i + \"(\"+ list.get(i) +\")\" + \": min = \" + min.get(i) + \" , max = \" + max.get(i));\n\t\t\t//}\n\t\t\t\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i = 0; i < list.size() - 1; i++){\n\t\t\t\tListIterator<Double> max_iter = max.get(i).listIterator();\n\t\t\t\tListIterator<Double> min_iter = min.get(i).listIterator();\n\t\t\t\t\n\t\t\t\twhile(max_iter.hasNext() && min_iter.hasNext()){\n\t\t\t\t\tdouble i_max = max_iter.next(), i_min = min_iter.next();\n\t\t\t\t\t\n\t\t\t\t\tsum += (i_max - i_min) * (list.get(i + 1) - list.get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count + \" \" + sum);\n\t\t\tcount++;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tR[] rs;\n\tint caze;\n\n\tvoid run(){\n\t\tfor(caze=1;; caze++){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tdouble r=sc.nextDouble();\n\t\t\t\trs[i]=new R(x-r, y-r, x+r, y+r);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tTreeSet<Double> setX=new TreeSet<Double>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tsetX.add(rs[i].x1);\n\t\t\tsetX.add(rs[i].x2);\n\t\t}\n\t\tDouble[] xs=setX.toArray(new Double[0]);\n\t\tsort(xs);\n\t\tint m=xs.length;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tTreeSet<R>[] setR=new TreeSet[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tsetR[i]=new TreeSet<R>();\n\t\t}\n\t\t// setR[0].add(rs[0]);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tsetR[binarySearch(xs, rs[i].x1)].add(rs[i]);\n\t\t}\n\t\tfor(int j=0; j<m-1; j++){\n\t\t\tfor(R r : setR[j]){\n\t\t\t\tif(xs[j+1]+EPS<r.x2){\n\t\t\t\t\tsetR[j+1].add(r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<m; j++){\n\t\t\tdebug(\"j\", j, \"x\", xs[j]);\n\t\t\tfor(R r : setR[j]){\n\t\t\t\tdebug(r.x2, r.y1, r.y2);\n\t\t\t}\n\t\t\tdebug();\n\t\t}\n\t\tdouble sum=0;\n\t\tfor(int k=0; k<m-1; k++){\n\t\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\t\tfor(R r : setR[k]){\n\t\t\t\tint i=seg.size(), j=seg.size();\n\t\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\t\tdouble y=seg.get(p);\n\t\t\t\t\tif(y+EPS>r.y2){\n\t\t\t\t\t\tj=p;\n\t\t\t\t\t}\n\t\t\t\t\tif(y+EPS>r.y1){\n\t\t\t\t\t\ti=p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\t\tseg.remove(i);\n\t\t\t\t}\n\t\t\t\tif(j%2==0){\n\t\t\t\t\tseg.add(i, r.y2);\n\t\t\t\t}\n\t\t\t\tif(i%2==0){\n\t\t\t\t\tseg.add(i, r.y1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble len=0;\n\t\t\tfor(int i=0; i<seg.size(); i+=2){\n\t\t\t\tlen=seg.get(i+1)-seg.get(i);\n\t\t\t}\n\t\t\tsum+=len*(xs[k+1]-xs[k]);\n\t\t}\n\t\tdebug(sum);\n\t\tprintln(String.format(\"%d %.4f\", caze, sum));\n\t}\n\n\tvoid test(){\n\t\tdouble[] x1={1, 3, 4, 1.0, 6., 11, 9.50};\n\t\tdouble[] x2={2, 4, 5, 2.5, 10, 12, 10.5};\n\t\tLinkedList<Double> seg=new LinkedList<Double>();\n\t\tfor(int k=0; k<x1.length; k++){\n\t\t\tint i=seg.size(), j=seg.size();\n\t\t\tfor(int p=seg.size()-1; p>=0; p--){\n\t\t\t\tdouble x=seg.get(p);\n\t\t\t\tif(x>=x2[k]){\n\t\t\t\t\tj=p;\n\t\t\t\t}\n\t\t\t\tif(x>=x1[k]){\n\t\t\t\t\ti=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug(\"x1\", \"x2\", x1[k], x2[k]);\n\t\t\tdebug(\"i\", \"j\", i, j);\n\t\t\tfor(int p=i; p<j; p++){\n\t\t\t\tseg.remove(i);\n\t\t\t}\n\t\t\tif(j%2==0){\n\t\t\t\tseg.add(i, x2[k]);\n\t\t\t}\n\t\t\tif(i%2==0){\n\t\t\t\tseg.add(i, x1[k]);\n\t\t\t}\n\t\t\tdebug(seg.toArray());\n\t\t}\n\t\tdebug(seg.toArray());\n\t}\n\n\tclass R implements Comparable<R>{\n\t\tdouble x1, y1, x2, y2;\n\n\t\tR(double x1, double y1, double x2, double y2){\n\t\t\tthis.x1=x1;\n\t\t\tthis.y1=y1;\n\t\t\tthis.x2=x2;\n\t\t\tthis.y2=y2;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(R arg0){\n\t\t\tif(y1-y2+EPS<0){\n\t\t\t\treturn -1;\n\t\t\t}else if(y1-y2>0+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else if(x1-x2+EPS<0){\n\t\t\t\treturn -1;\n\t\t\t}else if(x1-x2>0+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "JavaScript",
    "code": "process.stdin.resume();\nprocess.stdin.setEncoding(\"utf8\");\nprocess.stdin.on(\"data\", function (chunk) {\n    var input = chunk.trim().split(\"\\n\");\n    var order = 1;\n    while (true) {\n        var n = input.shift();\n        if (n == 0)\n            break;\n        var dataset = [];\n        var x1 = [];\n        var x2 = [];\n        var y1 = [];\n        var y2 = [];\n        var sx = [];\n        var sy = [];\n        for (var i = 0; i < n; i++) {\n            dataset.push(input.shift().split(/\\s+/).map(Number));\n            x1.push(dataset[i][0] - dataset[i][2]);\n            x2.push(dataset[i][0] + dataset[i][2]);\n            y1.push(dataset[i][1] - dataset[i][2]);\n            y2.push(dataset[i][1] + dataset[i][2]);\n            sx.push(dataset[i][0] - dataset[i][2]);\n            sx.push(dataset[i][0] + dataset[i][2]);\n            sy.push(dataset[i][1] - dataset[i][2]);\n            sy.push(dataset[i][1] + dataset[i][2]);\n        }\n        var area = 0;\n        sx.sort(function(a, b){return a-b});\n        sy.sort(function(a, b){return a-b});\n        for (var a = 0; a < sx.length - 1; a++)\n            for (var b = 0; b < sy.length - 1; b++)\n                for (var c = flag = 0; c < x1.length; c++) {\n                    if ((x1[c] < sx[a + 1]) && (sx[a] < x2[c]) && (y1[c] < sy[b + 1]) && (sy[b] < y2[c]))\n                        if (flag == 0) {\n                            area += (sx[a + 1] - sx[a]) * (sy[b + 1] - sy[b]);\n                            flag++;\n                        }\n                }\n        console.log(order + \" \" + area.toFixed(2));\n        order++;\n    }\n});"
  },
  {
    "language": "JavaScript",
    "code": "process.stdin.resume();\nprocess.stdin.setEncoding(\"utf8\");\nprocess.stdin.on(\"data\", function (chunk) {\n    var input = chunk.trim().split(\"\\n\");\n    var order = 1;\n    while (true) {\n        var n = input.shift();\n        if (n == 0)\n            break;\n        var dataset = [];\n        var x1 = [];\n        var x2 = [];\n        var y1 = [];\n        var y2 = [];\n        var sx = [];\n        var sy = [];\n        for (var i = 0; i < n; i++) {\n            dataset.push(input.shift().split(\" \").map(Number));\n            x1.push(dataset[i][0] - dataset[i][2]);\n            x2.push(dataset[i][0] + dataset[i][2]);\n            y1.push(dataset[i][1] - dataset[i][2]);\n            y2.push(dataset[i][1] + dataset[i][2]);\n            sx.push(dataset[i][0] - dataset[i][2]);\n            sx.push(dataset[i][0] + dataset[i][2]);\n            sy.push(dataset[i][1] - dataset[i][2]);\n            sy.push(dataset[i][1] + dataset[i][2]);\n        }\n        var area = 0;\n        sx.sort();\n        sy.sort();\n        for (var a = 0; a < sx.length - 1; a++)\n            for (var b = 0; b < sy.length - 1; b++)\n                for (var c = flag = 0; c < x1.length; c++) {\n                    if (x1[c] < sx[a + 1] && sx[a] < x2[c] && y1[c] < sy[b + 1] && sy[b] < y2[c])\n                        if (flag == 0) {\n                            area += (sx[a + 1] - sx[a]) * (sy[b + 1] - sy[b]);\n                            flag++;\n                        }\n        }\n        console.log(order + \" \" + area.toFixed(2));\n        order++;\n    }\n});"
  },
  {
    "language": "Ruby",
    "code": "cnt = 1\nwhile n = gets.to_i\n  break if n == 0\n  xs = []\n  ys = []\n  ps = []\n  n.times do\n    x, y, r = gets.split.map(&:to_f)\n    ps << [x, y, r]\n    xs << x - r << x + r\n    ys << y - r << y + r\n  end\n  xs.sort!.uniq!; ys.sort!.uniq!\n  p = ys.size.times.map{ [0] * xs.size }\n  ps.each do |x, y, r|\n    (xs.index(x - r)...xs.index(x + r)).each do |i|\n      (ys.index(y - r)...ys.index(y + r)).each do |j|\n        p[j][i] += 1\n      end\n    end\n  end\n  ret = 0\n  xs.each_cons(2).with_index do |(x0, x1), i|\n    ys.each_cons(2).with_index do |(y0, y1), j|\n      ret += (x1 - x0) * (y1 - y0) if p[j][i] > 0\n    end\n  end\n  puts \"%.2f %d\" % [ret, cnt]\n  cnt += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "while (n=gets.to_i)>0\n  map = {}\n\n  n.times{\n    x,y,r = gets.split.map(&:to_f)\n    map[x-r] ||= []\n    map[x-r] << [y-r,y+r,1]\n    map[x+r] ||= []\n    map[x+r] << [y-r,y+r,-1]\n  }\n\n  ans = 0\n\n  prei = 0\n  sum = 0\n\n  line = {}\n  map.keys.sort.each{|i|\n    #p [sum*(i-prei),map[i],i,sum]\n    ans += sum*(i-prei)\n\n    map[i].each{|s,e,j|\n      line[s] ||= 0\n      line[s] += j\n      line[e] ||= 0\n      line[e] -= j\n    }\n\n    sum = 0\n    cnt = 0\n    ind = 0\n    line.keys.sort.each{|j|\n      if cnt > 0\n        sum += j-ind\n      end\n      cnt += line[j]\n      ind = j\n    }\n\n    prei = i\n  }\n\n  puts \"%.2f\"%ans\nend"
  },
  {
    "language": "Ruby",
    "code": "\nY, X1, X2, Flag = (0...4).to_a\nTop, Bottom = 0, 1\n\ndata = 0\nwhile (n = gets.to_i) != 0 do\n  edge = Array.new\n  n.times do\n    x, y, r = gets.split.map(&:to_f)\n    edge.push([y-r, x-r, x+r, Top], [y+r, x-r, x+r, Bottom])\n  end\n  edge.sort!{|a, b| a[Y] <=> b[Y]}\n\n  answer = 0.0\n  point = Array.new.push(edge.first[X1], edge.first[X2])\n  for i in 1...edge.size do\n    answer += (point.max - point.min) * (edge[i][Y] - edge[i-1][Y])\n    x1, x2 = edge[i][X1], edge[i][X2]\n    case edge[i][Flag]\n      when Top\n        point.push(x1, x2)\n      when Bottom\n        point.delete_at(point.index(x1))\n        point.delete_at(point.index(x2))\n    end\n  end\n  data += 1\n  printf \"%d %.2f\\n\", data, answer\nend"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nid = 0\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  rects = []\n  xhash = {}\n  yhash = {}\n\n  n.times do\n    xi, yi, ri = gets.split.map(&:to_f)\n    rect = [xi - ri, yi - ri, xi + ri, yi + ri]\n    xhash[rect[0]] = xhash[rect[2]] = 1\n    yhash[rect[1]] = yhash[rect[3]] = 1\n    rects << rect\n  end\n\n  xs = xhash.keys.sort\n  ys = yhash.keys.sort\n  #p [xs, ys]\n\n  xs.each_with_index{|f, i| xhash[f] = i}\n  ys.each_with_index{|f, i| yhash[f] = i}\n  #p [xhash, yhash]\n\n  w = xs.length - 1\n  h = ys.length - 1\n\n  cells = h.times.map{w.times.map{false}}\n\n  rects.each do |x0, y0, x1, y1|\n    i0 = xhash[x0]\n    i1 = xhash[x1]\n    j0 = yhash[y0]\n    j1 = yhash[y1]\n    for j in (j0...j1)\n      for i in (i0...i1)\n        cells[j][i] = true\n      end\n    end\n  end\n  #p cells\n\n  ar = 0.0\n  for j in (0...h)\n    for i in (0...w)\n      if cells[j][i]\n        ar += (xs[i + 1] - xs[i]) * (ys[j + 1] - ys[j])\n      end\n    end\n  end\n\n  id += 1\n  puts [id, \"%.2f\" % ar.round(2)].join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "class Interval\n\tdef initialize(*args)\n\t\t@min, @max = args\n\tend\n\tattr_reader :min, :max\nend\n\ndef merged_length(intervals)\n\ta = intervals.map{|i| [i.min, i.max]}.sort_by(&:first)\n\tmerged = []\n\ta.each{|l, r|\n\t\tif merged.empty? or merged[-1][1] < l\n\t\t\tmerged << [l, r]\n\t\telse\n\t\t\tmerged[-1][1] = r if r > merged[-1][1]\n\t\tend\n\t}\n\tmerged.map{|l, r| r - l}.inject(0, :+)\nend\n\nloop.with_index {|_, k|\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tevent_queue = []\n\tn.times {\n\t\tx, y, r = gets.split.map(&:to_f)\n\t\ti = Interval.new(y - r, y + r)\n\t\tevent_queue << [x - r, :add, i]\n\t\tevent_queue << [x + r, :del, i]\n\t}\n\tevent_queue.sort_by!(&:first)\n\n\tarea = 0\n\tlen = 0\n\tintervals = []\n\tx = 0\n\tuntil event_queue.empty?\n\t\tarea += len * (event_queue[0][0] - x)\n\t\tx = event_queue[0][0]\n\t\twhile !event_queue.empty? && event_queue[0][0] == x\n\t\t\t_, command, interval = event_queue.shift\n\t\t\tif command == :add\n\t\t\t\tintervals << interval\n\t\t\telse\n\t\t\t\tintervals.delete interval\n\t\t\tend\n\t\tend\n\t\t\n\t\tlen = merged_length(intervals)\n\tend\n\n\tprintf(\"%d %.2f\\n\", k+1, area)\n}"
  },
  {
    "language": "Ruby",
    "code": "probnum = 1\n\nwhile (n=gets.to_i)>0\n  map = {}\n\n  n.times{\n    x,y,r = gets.split.map(&:to_f)\n    map[x-r] ||= []\n    map[x-r] << [y-r,y+r,1]\n    map[x+r] ||= []\n    map[x+r] << [y-r,y+r,-1]\n  }\n\n  ans = 0\n\n  prei = 0\n  sum = 0\n\n  line = {}\n  map.keys.sort.each{|i|\n    #p [sum*(i-prei),map[i],i,sum]\n    ans += sum*(i-prei)\n\n    map[i].each{|s,e,j|\n      line[s] ||= 0\n      line[s] += j\n      line[e] ||= 0\n      line[e] -= j\n    }\n\n    sum = 0\n    cnt = 0\n    ind = 0\n    line.keys.sort.each{|j|\n      if cnt > 0\n        sum += j-ind\n      end\n      cnt += line[j]\n      ind = j\n    }\n\n    prei = i\n  }\n\n  puts \"%d %.2f\"%[probnum,ans]\n  probnum += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "cnt = 1\nwhile n = gets.to_i\n  break if n == 0\n  xs = []\n  ys = []\n  ps = []\n  n.times do\n    x, y, r = gets.split.map(&:to_f)\n    ps << [x, y, r]\n    xs << x - r << x + r\n    ys << y - r << y + r\n  end\n  xs.sort!.uniq!; ys.sort!.uniq!\n  p = ys.size.times.map{ [0] * xs.size }\n  ps.each do |x, y, r|\n    (xs.index(x - r)...xs.index(x + r)).each do |i|\n      (ys.index(y - r)...ys.index(y + r)).each do |j|\n        p[j][i] += 1\n      end\n    end\n  end\n  ret = 0\n  xs.each_cons(2).with_index do |(x0, x1), i|\n    ys.each_cons(2).with_index do |(y0, y1), j|\n      ret += (x1 - x0) * (y1 - y0) if p[j][i] > 0\n    end\n  end\n  puts \"%d %.2f\" % [cnt, ret]\n  cnt += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "class DisjointSet\n  attr_accessor :parent, :rank\n  def initialize\n    @parent = {}\n    @rank = {}\n  end\n  def make(node)\n    @parent[node] = node\n    @rank[node] = 0\n  end\n  def union(node1, node2)\n    link(find(node1), find(node2))\n  end\n  def link(node1, node2)\n    node1, node2 = node2, node1 if @rank[node1] < @rank[node2]\n    @parent[node2] = node1\n    @rank[node1] += 1 if @rank[node1] == @rank[node2]\n  end\n  def find(node)\n    (@parent[node] == node) ? node : (@parent[node] = find(@parent[node]))\n  end\nend\n\nX, Y, R = (0...3).to_a\nLeft, Right, Top, Bottom = (0...4).to_a\n\ndef touch?(s1, s2)\n  t1 = [s1[X]-s1[R], s1[X]+s1[R], s1[Y]-s1[R], s1[Y]+s1[R]]\n  t2 = [s2[X]-s2[R], s2[X]+s2[R], s2[Y]-s2[R], s2[Y]+s2[R]]\n  intersectW = (t1[Right]-t2[Left]) * (t1[Left]-t2[Right]) < 0.0\n  intersectH = (t1[Top]-t2[Bottom]) * (t1[Bottom]-t2[Top]) < 0.0\n  intersectW && intersectH\nend\n\ndata = 0\nwhile (n = gets.to_i) != 0 do\n  data += 1\n  set = DisjointSet.new\n  square = Array.new\n  n.times do |i|\n    square.push(gets.split.map(&:to_f))\n    set.make(i)\n  end\n  n.times do |i1|\n    n.times do |i2|\n      next if i1 == i2\n      set.union(i1, i2) if touch?(square[i1], square[i2])\n    end\n  end\n\n  group = Array.new\n  n.times do |i|\n    group.push(set.parent[i])\n  end\n  group.sort!.uniq!\n\n  area = 0.0\n  group.each do |g|\n    edge = Array.new\n    n.times do |i|\n      next if set.parent[i] != g\n      x, y, r = square[i]\n      edge.push([y-r, x-r, x+r, Top], [y+r, x-r, x+r, Bottom])\n    end\n    edge.sort!{|a, b| a[0] <=> b[0]}\n    point = Array.new.push(edge.first[1], edge.first[2])\n    for i in 1...edge.size do\n      area += (point.max - point.min) * (edge[i][0] - edge[i-1][0])\n      x1, x2 = edge[i][1], edge[i][2]\n      case edge[i][3]\n        when Top\n          point.push(x1, x2)\n        when Bottom\n          point.delete_at(point.index(x1))\n          point.delete_at(point.index(x2))\n      end\n    end\n  end\n  printf \"%d %.2f\\n\", data, area\nend"
  },
  {
    "language": "Ruby",
    "code": "class Interval\n\tdef initialize(*args)\n\t\t@min, @max = args\n\tend\n\tattr_reader :min, :max\nend\n\ndef merged_length(intervals)\n\ta = intervals.map{|i| [i.min, i.max]}.sort_by(&:first)\n\tmerged = []\n\ta.each{|l, r|\n\t\tif merged.empty? or merged[-1][1] < l\n\t\t\tmerged << [l, r]\n\t\telse\n\t\t\tmerged[-1][1] = r if r > merged[-1][1]\n\t\tend\n\t}\n\tmerged.map{|l, r| r - l}.inject(:+)\nend\n\nloop.with_index {|_, k|\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tevent_queue = []\n\tn.times {\n\t\tx, y, r = gets.split.map(&:to_f)\n\t\ti = Interval.new(y - r, y + r)\n\t\tevent_queue << [x - r, :add, i]\n\t\tevent_queue << [x + r, :del, i]\n\t}\n\tevent_queue.sort_by!(&:first)\n\n\tarea = 0\n\tlen = 0\n\tintervals = []\n\tx = 0\n\tuntil event_queue.empty?\n\t\tarea += len * (event_queue[0][0] - x)\n\t\tx = event_queue[0][0]\n\t\twhile !event_queue.empty? && event_queue[0][0] == x\n\t\t\t_, command, interval = event_queue.shift\n\t\t\tif command == :add\n\t\t\t\tintervals << interval\n\t\t\telse\n\t\t\t\tintervals.delete interval\n\t\t\tend\n\t\tend\n\t\t\n\t\tlen = merged_length(intervals)\n\tend\n\n\tprintf(\"%d %.2f\\n\", k+1, area)\n}"
  },
  {
    "language": "Ruby",
    "code": "cnt = 1\nwhile n = gets.to_i\n  break if n == 0\n  xs = []\n  ys = []\n  ps = []\n  n.times do\n    x, y, r = gets.split.map(&:to_f)\n    ps << [x, y, r]\n    xs << x - r << x + r\n    ys << y - r << y + r\n  end\n  xs.sort!.uniq!; ys.sort!.uniq!\n  p = ys.size.times.map{ [0] * xs.size }\n  ps.each do |x, y, r|\n    (xs.index(x - r)...xs.index(x + r)).each do |i|\n      (ys.index(y - r)...ys.index(y + r)).each do |j|\n        p[j][i] += 1\n      end\n    end\n  end\n  ret = 0\n  xs.each_cons(2).with_index do |(x0, x1), i|\n    ys.each_cons(2).with_index do |(y0, y1), j|\n      ret += (x1 - x0) * (y1 - y0) if p[j][i] > 0\n    end\n  end\n  puts \"#{cnt} #{ret}\"\n  cnt += 1\nend"
  },
  {
    "language": "Python",
    "code": "# AOJ 1202: Mobile Phone Coverage\n# Python3 2018.7.28\n\nfrom bisect import bisect_left\ncno = 0\nwhile True:\n\tn = int(input())\n\tif n == 0: break\n\ttbl, xx, yy = [], set(), set()\n\tfor i in range(n):\n\t\tx, y, r = map(float, input().split())\n\t\tx, y, r = int(100*x), int(100*y), int(100*r)\n\t\tx1, y1, x2, y2 = x-r, y-r, x+r, y+r\n\t\ttbl.append((x1, y1, x2, y2))\n\t\txx.add(x1); xx.add(x2)\n\t\tyy.add(y1); yy.add(y2)\n\txx = sorted(xx); yy = sorted(yy)\n\tarr = [[0 for c in range(201)] for r in range(201)]\n\tfor x1, y1, x2, y2 in tbl:\n\t\tl = bisect_left(xx, x1); r = bisect_left(xx, x2)\n\t\tu = bisect_left(yy, y1); d = bisect_left(yy, y2)\n\t\tfor y in range(u, d):\n\t\t\tfor x in range(l, r): arr[y][x] = 1\n\tans = 0\n\tfor r in range(1, len(yy)):\n\t\tt = yy[r]-yy[r-1]\n\t\tfor c in range(1, len(xx)):\n\t\t\tif arr[r-1][c-1]: ans += t * (xx[c]-xx[c-1])\n\tans //= 100\n\tcno += 1\n\tprint(cno, \"{:d}.{:02d}\".format(ans//100, ans%100))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef is_contained(a, area):\n    rx1, ry1, rx2, ry2 = a\n    for r in area:\n        x1, y1, x2, y2 = r\n        if x1 <= rx1 <= x2 and x1 <= rx2 <= x2 and \\\n           y1 <= ry1 <= y2 and y1 <= ry2 <= y2:\n            return True\n    return False\n\ndef is_inside(x, y, rect):\n    rx1, ry1, rx2, ry2 = rect\n    return (rx1 <= x <= rx2) and (ry1 <= y <= ry2)\n\ndef add_area(a, area):\n    if is_contained(a, area):\n        return area\n    xs, ys, xe, ye = a\n    if xs >= xe or ys >= ye:\n        return area\n    ret = area\n    if area == []:\n        return [a]\n    rr = []\n    for r in area:\n        rxs, rys, rxe, rye = r\n        if xs <= rxs < xe and ys <= rys < ye and xe <= rxe and ye <= rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye]]\n        elif xs <= rxs < xe and ys < rye <= ye and rys <= ys and xe <= rxe:\n            rr = [[xs, ys, rxs, rye], [xs, rye, xe, ye]]\n        elif xs < rxe <= xe and ys <= rys < ye and rxs <= xs and ye <= rye:\n            rr = [[xs, ys, rxe, rys], [rxe, ys, xe, ye]]\n        elif xs < rxe <= xe and ys < rye <= ye and rxs <= xs and rys <= ys:\n            rr = [[xs, rye, rxe, ye], [rxe, ys, xe, ye]]\n        elif xs <= rxs and ys <= rys < ye and rxe <= xe and ye <= rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye], [rxe, rys, xe, ye]]\n        elif xs <= rxs and ys < rye <= ye and rxe <= xe and rys <= ys:\n            rr = [[xs, rye, xe, ye], [xs, ys, rxs, rye], [rxe, ys, xe, rye]]\n        elif xs <= rxs < xe and ys <= rys and rye <= ye and xe <= rxe:\n            rr = [[xs, ys, rxs, ye], [rxs, ys, xe, rys], [rxs, rye, xe, ye]]\n        elif xs < rxe <= xe and ys <= rys and rye <= ye and rxs <= xs:\n            rr = [[rxe, ys, xe, ye], [xs, ys, rxe, rys], [xs, rye, rxe, ye]]\n        elif rxs <= xs and xe <= rxe and ys <= rys < ye:\n            rr = [[xs, ys, xe, rys]]\n        elif rys <= ys and ye <= rye and xs <= rxs < xe:\n            rr = [[xs, ys, rxs, ye]]\n        elif rxs <= xs and xe <= rxe and ys < rye <= ye:\n            rr = [[xs, rye, xe, ye]]\n        elif rys <= ys and ye <= rye and xs < rxe <= xe:\n            rr = [[rxe, ys, xe, ye]]\n        if rr != []:\n            for q in rr:\n                ret = add_area(q, ret)\n            break\n    if rr == []:\n        ret.append(a)\n    return ret\n\ndef calc_area(area):\n    s = 0.0\n    for r in area:\n        s += (r[2]- r[0]) * (r[3] - r[1])\n    return s\n\nn = 0\nc = 0\narea = []\nfor line in sys.stdin:\n    if n == 0:\n        n = int(line)\n        c += 1\n        area = []\n        if n == 0:\n            break\n    else:\n        ant = list(map(float, line.strip().split()))\n        r = [ant[0] - ant[2], ant[1] - ant[2], ant[0] + ant[2], ant[1] + ant[2]]\n        area = add_area(r, area)\n        n -= 1\n        if n == 0:\n            print(\"%d %.2f\" % (c, calc_area(area)))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef is_contained(a, area):\n    rx1, ry1, rx2, ry2 = a\n    for r in area:\n        x1, y1, x2, y2 = r\n        if x1 <= rx1 <= x2 and x1 <= rx2 <= x2 and \\\n           y1 <= ry1 <= y2 and y1 <= ry2 <= y2:\n            return True\n    return False\n\ndef is_inside(x, y, rect):\n    rx1, ry1, rx2, ry2 = rect\n    return (rx1 < x < rx2) and (ry1 < y < ry2)\n\ndef add_area(a, area):\n    if is_contained(a, area):\n        return area\n    xs, ys, xe, ye = a\n    if xs >= xe or ys >= ye:\n        return area\n    ret = area\n    if area == []:\n        return [a]\n    rr = []\n    for r in area:\n        rxs, rys, rxe, rye = r\n        if is_inside(rxs, rys, a) and xe < rxe and ye < rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye]]\n        elif is_inside(rxs, rye, a) and rys < ys and xe < rxe:\n            rr = [[xs, ys, rxs, rye], [xs, rye, xe, ye]]\n        elif is_inside(rxe, rys, a) and rxs < xs and ye < rye:\n            rr = [[xs, ys, rxe, rys], [rxe, ys, xe, ye]]\n        elif is_inside(rxe, rye, a) and rxs < xs and rys < ys:\n            rr = [[xs, rye, rxe, ye], [rxe, ys, xe, ye]]\n        elif is_inside(rxs, rys, a) and is_inside(rxe, rys, a) and ye < rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye], [rxe, rys, xe, ye]]\n        elif is_inside(rxs, rye, a) and is_inside(rxe, rye, a) and rys < ys:\n            rr = [[xs, rye, xe, ye], [xs, ys, rxs, rye], [rxe, ys, xe, rye]]\n        elif is_inside(rxs, rys, a) and is_inside(rxs, rye, a) and xe < rxe:\n            rr = [[xs, ys, rxs, ye], [rxs, ys, xe, rys], [rxs, rye, xe, ye]]\n        elif is_inside(rxe, rys, a) and is_inside(rxe, rye, a) and rxs < xs:\n            rr = [[rxe, ys, xe, ye], [xs, ys, rxe, rys], [xs, rye, rxe, ye]]\n        elif rxs < xs and xe < rxe and ys < rys < ye:\n            rr = [[xs, ys, xe, rys]]\n        elif rys < ys and ye < rye and xs < rxs < xe:\n            rr = [[xs, ys, rxs, ye]]\n        elif rxs < xs and xe < rxe and ys < rye < ye:\n            rr = [[xs, rye, xe, ye]]\n        elif rys < ys and ye < rye and xs < rxe < xe:\n            rr = [[rxe, ys, xe, ye]]\n        if rr != []:\n            for q in rr:\n                ret = add_area(q, ret)\n            break\n    if rr == []:\n        ret.append(a)\n    return ret\n\ndef calc_area(area):\n    s = 0.0\n    for r in area:\n        s += (r[2]- r[0]) * (r[3] - r[1])\n    return s\n\nn = 0\nc = 0\narea = []\nfor line in sys.stdin:\n    if n == 0:\n        n = int(line)\n        c += 1\n        area = []\n        if n == 0:\n            break\n    else:\n        ant = list(map(float, line.strip().split(\" \")))\n        r = [ant[0] - ant[2], ant[1] - ant[2], ant[0] + ant[2], ant[1] + ant[2]]\n        area = add_area(r, area)\n        n -= 1\n        if n == 0:\n            print(\"%d %.2f\" % (c, calc_area(area)))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef is_contained(a, area):\n    rx1, ry1, rx2, ry2 = a\n    for r in area:\n        x1, y1, x2, y2 = r\n        if x1 <= rx1 <= x2 and x1 <= rx2 <= x2 and \\\n           y1 <= ry1 <= y2 and y1 <= ry2 <= y2:\n            return True\n    return False\n\ndef is_inside(x, y, rect):\n    rx1, ry1, rx2, ry2 = rect\n    return (rx1 < x < rx2) and (ry1 < y < ry2)\n\ndef add_area(a, area):\n    if is_contained(a, area):\n        return area\n    xs, ys, xe, ye = a\n    if xs >= xe or ys >= ye:\n        return area\n    ret = area\n    if area == []:\n        return [a]\n    rr = []\n    for r in area:\n        rxs, rys, rxe, rye = r\n        if is_inside(rxs, rys, a) and xe < rxe and ye < rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye]]\n        elif is_inside(rxs, rye, a) and rys < ys and xe < rxe:\n            rr = [[xs, ys, rxs, rye], [xs, rye, xe, ye]]\n        elif is_inside(rxe, rys, a) and rxs < xs and ye < rye:\n            rr = [[xs, ys, rxe, rys], [rxe, ys, xe, ye]]\n        elif is_inside(rxe, rye, a) and rxs < xs and rys < ys:\n            rr = [[xs, rye, rxe, ye], [rxe, ys, xe, ye]]\n        elif is_inside(rxs, rys, a) and is_inside(rxe, rys, a) and ye < rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye], [rxe, rys, xe, ye]]\n        elif is_inside(rxs, rye, a) and is_inside(rxe, rye, a) and rys < ys:\n            rr = [[xs, rye, xe, ye], [xs, ys, rxs, rye], [rxe, ys, xe, rye]]\n        elif is_inside(rxs, rys, a) and is_inside(rxs, rye, a) and xe < rxe:\n            rr = [[xs, ys, rxs, ye], [rxs, ys, xe, rys], [rxs, rye, xe, ye]]\n        elif is_inside(rxe, rys, a) and is_inside(rxe, rye, a) and rxs < xs:\n            rr = [[rxe, ys, xe, ye], [xs, ys, rxe, rys], [xs, rye, rxe, ye]]\n        elif rxs < xs and xe < rxe and ys < rys < ye:\n            rr = [[xs, ys, xe, rys]]\n        elif rys < ys and ye < rye and xs < rxs < xe:\n            rr = [[xs, ys, rxs, ye]]\n        elif rxs < xs and xe < rxe and ys < rye < ye:\n            rr = [[xs, rye, xe, ye]]\n        elif rys < ys and ye < rye and xs < rxe < xe:\n            rr = [[rxe, ys, xe, ye]]\n        if rr != []:\n            for q in rr:\n                ret = add_area(q, ret)\n            break\n    if rr == []:\n        ret.append(a)\n    return ret\n\ndef calc_area(area):\n    s = 0.0\n    for r in area:\n        s += (r[2]- r[0]) * (r[3] - r[1])\n    return s\n\nn = 0\nc = 0\narea = []\nfor line in sys.stdin:\n    if n == 0:\n        n = int(line)\n        c += 1\n        area = []\n        if n == 0:\n            break\n    else:\n        ant = list(map(float, line.strip().split(\" \")))\n        r = [ant[0] - ant[2], ant[1] - ant[2], ant[0] + ant[2], ant[1] + ant[2]]\n        area = add_area(r, area)\n        n -= 1\n        if n == 0:\n            print(\"%d %.2f\" % (c, calc_area(area)))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef is_contained(a, area):\n    rx1, ry1, rx2, ry2 = a\n    for r in area:\n        x1, y1, x2, y2 = r\n        if x1 <= rx1 <= x2 and x1 <= rx2 <= x2 and \\\n           y1 <= ry1 <= y2 and y1 <= ry2 <= y2:\n            return True\n    return False\n\ndef is_inside(x, y, rect):\n    rx1, ry1, rx2, ry2 = rect\n    return (rx1 <= x <= rx2) and (ry1 <= y <= ry2)\n\ndef add_area(a, area):\n    if is_contained(a, area):\n        return area\n    xs, ys, xe, ye = a\n    if xs >= xe or ys >= ye:\n        return area\n    ret = area\n    if area == []:\n        return [a]\n    rr = []\n    for r in area:\n        rxs, rys, rxe, rye = r\n        if xs <= rxs < xe and ys <= rys < ye and xe <= rxe and ye <= rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye]]\n        elif xs <= rxs < xe and ys < rye <= ye and rys <= ys and xe <= rxe:\n            rr = [[xs, ys, rxs, rye], [xs, rye, xe, ye]]\n        elif xs < rxe <= xe and ys <= rys < ye and rxs <= xs and ye <= rye:\n            rr = [[xs, ys, rxe, rys], [rxe, ys, xe, ye]]\n        elif xs < rxe <= xe and ys < rye <= ye and rxs <= xs and rys <= ys:\n            rr = [[xs, rye, rxe, ye], [rxe, ys, xe, ye]]\n        elif xs <= rxs and ys <= rys < ye and rxe <= xe and ye <= rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye], [rxe, rys, xe, ye]]\n        elif xs <= rxs and ys < rye <= ye and rxe <= xe and rys <= ys:\n            rr = [[xs, rye, xe, ye], [xs, ys, rxs, rye], [rxe, ys, xe, rye]]\n        elif xs <= rxs < xe and ys <= rys and rye <= ye and xe <= rxe:\n            rr = [[xs, ys, rxs, ye], [rxs, ys, xe, rys], [rxs, rye, xe, ye]]\n        elif xs < rxe <= xe and ys <= rys and rye <= ye and rxs <= xs:\n            rr = [[rxe, ys, xe, ye], [xs, ys, rxe, rys], [xs, rye, rxe, ye]]\n        elif rxs <= xs and xe <= rxe and ys <= rys < ye:\n            rr = [[xs, ys, xe, rys]]\n        elif rys <= ys and ye <= rye and xs <= rxs < xe:\n            rr = [[xs, ys, rxs, ye]]\n        elif rxs <= xs and xe <= rxe and ys < rye <= ye:\n            rr = [[xs, rye, xe, ye]]\n        elif rys <= ys and ye <= rye and xs < rxe <= xe:\n            rr = [[rxe, ys, xe, ye]]\n        if rr != []:\n            for q in rr:\n                ret = add_area(q, ret)\n            break\n    if rr == []:\n        ret.append(a)\n    return ret\n\ndef calc_area(area):\n    s = 0.0\n    for r in area:\n        s += (r[2]- r[0]) * (r[3] - r[1])\n    return s\n\nn = 0\nc = 0\narea = []\nfor line in sys.stdin:\n    if n == 0:\n        n = int(line)\n        c += 1\n        area = []\n        if n == 0:\n            break\n    else:\n        ant = list(map(float, line.strip().split()))\n        r = [ant[0] - ant[2], ant[1] - ant[2], ant[0] + ant[2], ant[1] + ant[2]]\n        area = add_area(r, area)\n        n -= 1\n        if n == 0:\n            print(\"%d %.2f\" % (c, calc_area(area)))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef is_contained(a, area):\n    rx1, ry1, rx2, ry2 = a\n    for r in area:\n        x1, y1, x2, y2 = r\n        if x1 <= rx1 <= x2 and x1 <= rx2 <= x2 and \\\n           y1 <= ry1 <= y2 and y1 <= ry2 <= y2:\n            return True\n    return False\n\ndef add_area(a, area):\n    if is_contained(a, area):\n        return area\n    xs, ys, xe, ye = a\n    if xs >= xe or ys >= ye:\n        return area\n    ret = area\n    if area == []:\n        return [a]\n    rr = []\n    for r in area:\n        rxs, rys, rxe, rye = r\n        if xs < rxs < xe and ys < rys < ye and xe <= rxe and ye <= rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye]]\n        elif xs < rxs < xe and ys < rye < ye and rys <= ys and xe <= rxe:\n            rr = [[xs, ys, rxs, rye], [xs, rye, xe, ye]]\n        elif xs < rxe < xe and ys < rys < ye and rxs <= xs and ye <= rye:\n            rr = [[xs, ys, rxe, rys], [rxe, ys, xe, ye]]\n        elif xs < rxe < xe and ys < rye < ye and rxs <= xs and rys <= ys:\n            rr = [[xs, rye, rxe, ye], [rxe, ys, xe, ye]]\n        elif xs < rxs and ys <= rys < ye and rxe < xe and ye <= rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye], [rxe, rys, xe, ye]]\n        elif xs < rxs and ys < rye <= ye and rxe < xe and rys <= ys:\n            rr = [[xs, rye, xe, ye], [xs, ys, rxs, rye], [rxe, ys, xe, rye]]\n        elif xs <= rxs < xe and ys < rys and rye < ye and xe <= rxe:\n            rr = [[xs, ys, rxs, ye], [rxs, ys, xe, rys], [rxs, rye, xe, ye]]\n        elif xs < rxe <= xe and ys < rys and rye < ye and rxs <= xs:\n            rr = [[rxe, ys, xe, ye], [xs, ys, rxe, rys], [xs, rye, rxe, ye]]\n        elif rxs <= xs and xe <= rxe and ys < rys < ye and ye <= rye:\n            rr = [[xs, ys, xe, rys]]\n        elif rys <= ys and ye <= rye and xs < rxs < xe and xe <= rxe:\n            rr = [[xs, ys, rxs, ye]]\n        elif rxs <= xs and xe <= rxe and ys < rye < ye and rys <= ys:\n            rr = [[xs, rye, xe, ye]]\n        elif rys <= ys and ye <= rye and xs < rxe < xe and rxs <= xs:\n            rr = [[rxe, ys, xe, ye]]\n        elif xs < rxs < xe and xs < rxe < xe and ys < rys < ye and ys < rye < ye:\n            rr = [[xs, ys, rxs, rye], [xs, rye, rxe, ye], [rxe, rys, xe, ye], [rxs, ys, xe, rys]]\n        elif rxs <= xs and xe <= rxe and ys < rys and rye < ye:\n            rr = [[xs, ys, xe, rys], [xs, rye, xe, ye]]\n        elif rys <= ys and ye <= rye and xs < rxs and rxe < xe:\n            rr = [[xs, ys, rxs, ye], [rxe, ys, xe, ye]]\n        if rr != []:\n            for q in rr:\n                ret = add_area(q, ret)\n            break\n    if rr == []:\n        ret.append(a)\n    return ret\n\ndef calc_area(area):\n    s = 0.0\n    for r in area:\n        s += (r[2]- r[0]) * (r[3] - r[1])\n    return s\n\nn = 0\nc = 0\narea = []\nfor line in sys.stdin:\n    if n == 0:\n        n = int(line)\n        c += 1\n        area = []\n        if n == 0:\n            break\n    else:\n        ant = list(map(float, line.strip().split()))\n        r = [ant[0] - ant[2], ant[1] - ant[2], ant[0] + ant[2], ant[1] + ant[2]]\n        area = add_area(r, area)\n        n -= 1\n        if n == 0:\n            print(\"%d %.2f\" % (c, calc_area(area)))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef is_contained(a, area):\n    rx1, ry1, rx2, ry2 = a\n    for r in area:\n        x1, y1, x2, y2 = r\n        if x1 <= rx1 <= x2 and x1 <= rx2 <= x2 and \\\n           y1 <= ry1 <= y2 and y1 <= ry2 <= y2:\n            return True\n    return False\n\ndef is_inside(x, y, rect):\n    rx1, ry1, rx2, ry2 = rect\n    return (rx1 < x < rx2) and (ry1 < y < ry2)\n\ndef add_area(a, area):\n    if is_contained(a, area):\n        return area\n    xs, ys, xe, ye = a\n    if xs >= xe or ys >= ye:\n        return area\n    ret = area\n    if area == []:\n        return [a]\n    rr = []\n    for r in area:\n        rxs, rys, rxe, rye = r\n        if is_inside(rxs, rys, a) and xe < rxe and ye < rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye]]\n        elif is_inside(rxs, rye, a) and rys < ys and xe < rxe:\n            rr = [[xs, ys, rxs, rye], [xs, rye, xe, ye]]\n        elif is_inside(rxe, rys, a) and rxs < xs and ye < rye:\n            rr = [[xs, ys, rxe, rys], [rxe, ys, xe, ye]]\n        elif is_inside(rxe, rye, a) and rxs < xs and rys < ys:\n            rr = [[xs, rye, rxe, ye], [rxe, ys, xe, ye]]\n        elif is_inside(rxs, rys, a) and is_inside(rxe, rys, a) and ye < rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye], [rxe, rys, xe, ye]]\n        elif is_inside(rxs, rye, a) and is_inside(rxe, rye, a) and rys < ys:\n            rr = [[xs, rye, xe, ye], [xs, ys, rxs, rye], [rxe, ys, xe, rye]]\n        elif is_inside(rxs, rys, a) and is_inside(rxs, rye, a) and xe < rxe:\n            rr = [[xs, ys, rxs, ye], [rxs, ys, xe, rys], [rxs, rye, xe, ye]]\n        elif is_inside(rxe, rys, a) and is_inside(rxe, rye, a) and rxs < xs:\n            rr = [[rxe, ys, xe, ye], [xs, ys, rxe, rys], [xs, rye, rxe, ye]]\n        elif rxs < xs and xe < rxe and ys < rys < ye:\n            rr = [[xs, ys, xe, rys]]\n        elif rys < ys and ye < rye and xs < rxs < xe:\n            rr = [[xs, ys, rxs, ye]]\n        elif rxs < xs and xe < rxe and ys < rye < ye:\n            rr = [[xs, rye, xe, ye]]\n        elif rys < ys and ye < rye and xs < rxe < xe:\n            rr = [[rxe, ys, xe, ye]]\n        if rr != []:\n            for q in rr:\n                ret = add_area(q, ret)\n            break\n    if rr == []:\n        ret.append(a)\n    return ret\n\ndef calc_area(area):\n    s = 0.0\n    for r in area:\n        s += (r[2]- r[0]) * (r[3] - r[1])\n    return s\n\nn = 0\nc = 0\narea = []\nfor line in sys.stdin:\n    if n == 0:\n        n = int(line)\n        c += 1\n        area = []\n        if n == 0:\n            break\n    else:\n        ant = list(map(float, line.strip().split()))\n        r = [ant[0] - ant[2], ant[1] - ant[2], ant[0] + ant[2], ant[1] + ant[2]]\n        area = add_area(r, area)\n        n -= 1\n        if n == 0:\n            print(\"%d %.2f\" % (c, calc_area(area)))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef is_contained(a, area):\n    rx1, ry1, rx2, ry2 = a\n    for r in area:\n        x1, y1, x2, y2 = r\n        if x1 <= rx1 <= x2 and x1 <= rx2 <= x2 and \\\n           y1 <= ry1 <= y2 and y1 <= ry2 <= y2:\n            return True\n    return False\n\ndef is_inside(x, y, rect):\n    rx1, ry1, rx2, ry2 = rect\n    return (rx1 < x < rx2) and (ry1 < y < ry2)\n\ndef add_area(a, area):\n    if is_contained(a, area):\n        return area\n    xs, ys, xe, ye = a\n    if xs >= xe or ys >= ye:\n        return area\n    ret = area\n    if area == []:\n        return [a]\n    rr = []\n    for r in area:\n        rxs, rys, rxe, rye = r\n        if is_inside(rxs, rys, a) and xe < rxe and ye < rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye]]\n        elif is_inside(rxs, rye, a) and rys < ys and xe < rxe:\n            rr = [[xs, ys, rxs, rye], [xs, rye, xe, ye]]\n        elif is_inside(rxe, rys, a) and rxs < xs and ye < rye:\n            rr = [[xs, ys, rxe, rys], [rxe, ys, xe, ye]]\n        elif is_inside(rxe, rye, a) and rxs < xs and rys < ys:\n            rr = [[xs, rye, rxe, ye], [rxe, ys, xe, ye]]\n        elif is_inside(rxs, rys, a) and is_inside(rxe, rys, a) and ye < rye:\n            rr = [[xs, ys, xe, rys], [xs, rys, rxs, ye], [rxe, rys, xe, ye]]\n        elif is_inside(rxs, rye, a) and is_inside(rxe, rye, a) and rys < ys:\n            rr = [[xs, rye, xe, ye], [xs, ys, rxs, rye], [rxe, ys, xe, rye]]\n        elif is_inside(rxs, rys, a) and is_inside(rxs, rye, a) and xe < rxe:\n            rr = [[xs, ys, rxs, ye], [rxs, ys, xe, rys], [rxs, rye, xe, ye]]\n        elif is_inside(rxe, rys, a) and is_inside(rxe, rye, a) and rxs < xs:\n            rr = [[rxe, ys, xe, ye], [xs, ys, rxe, rys], [xs, rye, rxe, ye]]\n        elif rxs < xs and xe < rxe and ys < rys < ye:\n            rr = [[xs, ys, xe, rys]]\n        elif rys < ys and ye < rye and xs < rxs < xe:\n            rr = [[xs, ys, rxs, ye]]\n        elif rxs < xs and xe < rxe and ys < rye < ye:\n            rr = [[xs, rye, xe, ye]]\n        elif rys < ys and ye < rye and xs < rxe < xe:\n            rr = [[rxe, ys, xe, ye]]\n        if rr != []:\n            for q in rr:\n                ret = add_area(q, ret)\n            break\n    if rr == []:\n        ret.append(a)\n    return ret\n\ndef calc_area(area):\n    s = 0.0\n    for r in area:\n        s += (r[2]- r[0]) * (r[3] - r[1])\n    return s\n\nn = 0\nc = 0\narea = []\nfor line in sys.stdin:\n    if n == 0:\n        n = int(line)\n        c += 1\n        area = []\n        if n == 0:\n            break\n    else:\n        ant = list(map(float, line.strip().split(\" \")))\n        r = [ant[0] - ant[2], ant[1] - ant[2], ant[0] + ant[2], ant[1] + ant[2]]\n        area = add_area(r, area)\n        n -= 1\n        if n == 0:\n            print(\"%d %.2f\" % (c, calc_area(area)))\n"
  }
]