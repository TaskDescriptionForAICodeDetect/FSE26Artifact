[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int u, v, d, a;\n} Road;\n\nint N, M, L;\nRoad roads[10000];\nint dist[101];\nint attackers[101];\n\nvoid bellman_ford(int start) {\n    for (int i = 1; i <= N; i++) {\n        dist[i] = INT_MAX;\n        attackers[i] = INT_MAX;\n    }\n    dist[start] = 0;\n    attackers[start] = 0;\n\n    for (int i = 1; i <= N - 1; i++) {\n        for (int j = 0; j < M; j++) {\n            int u = roads[j].u;\n            int v = roads[j].v;\n            int d = roads[j].d;\n            int a = roads[j].a;\n\n            if (dist[u] != INT_MAX && dist[u] + d <= L) {\n                if (dist[u] + d < dist[v] || (dist[u] + d == dist[v] && attackers[u] + a < attackers[v])) {\n                    dist[v] = dist[u] + d;\n                    attackers[v] = attackers[u] + a;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        scanf(\"%d %d %d\", &N, &M, &L);\n\n        for (int i = 0; i < M; i++) {\n            scanf(\"%d %d %d %d\", &roads[i].u, &roads[i].v, &roads[i].d, &roads[i].a);\n        }\n\n        bellman_ford(1);\n\n        if (dist[N] <= L) {\n            printf(\"%d\\n\", attackers[N]);\n        } else {\n            printf(\"-1\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:09:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Road {\n    int to, distance, attackers;\n    Road(int t, int d, int a) : to(t), distance(d), attackers(a) {}\n};\n\nstruct State {\n    int node, cost;\n    int attackers;\n    State(int n, int c, int a) : node(n), cost(c), attackers(a) {}\n    bool operator>(const State& other) const {\n        return attackers > other.attackers;\n    }\n};\n\nint dijkstra(const vector<vector<Road>>& graph, int N, int L) {\n    priority_queue<State, vector<State>, greater<State>> pq;\n    vector<vector<int>> min_attackers(N + 1, vector<int>(L + 1, INT_MAX));\n    \n    pq.emplace(1, 0, 0);\n    min_attackers[1][0] = 0;\n    \n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n        \n        if (current.node == N) {\n            return current.attackers;\n        }\n        \n        if (current.attackers > min_attackers[current.node][current.cost]) {\n            continue;\n        }\n        \n        for (const Road& road : graph[current.node]) {\n            int new_cost = current.cost + road.distance;\n            if (new_cost > L) {\n                continue;\n            }\n            \n            int new_attackers = current.attackers + road.attackers;\n            if (new_attackers < min_attackers[road.to][new_cost]) {\n                min_attackers[road.to][new_cost] = new_attackers;\n                pq.emplace(road.to, new_cost, new_attackers);\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int T;\n    cin >> T;\n    while (T--) {\n        int N, M, L;\n        cin >> N >> M >> L;\n        \n        vector<vector<Road>> graph(N + 1);\n        for (int i = 0; i < M; ++i) {\n            int u, v, d, a;\n            cin >> u >> v >> d >> a;\n            graph[u].emplace_back(v, d, a);\n            graph[v].emplace_back(u, d, a);\n        }\n        \n        int result = dijkstra(graph, N, L);\n        if (result == -1) {\n            cout << \"IMPOSSIBLE\\n\";\n        } else {\n            cout << result << \"\\n\";\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:10:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge {\n    int to, distance, attackers;\n\n    Edge(int to, int distance, int attackers) {\n        this.to = to;\n        this.distance = distance;\n        this.attackers = attackers;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int N = scanner.nextInt();\n            int M = scanner.nextInt();\n            int L = scanner.nextInt();\n            \n            List<List<Edge>> graph = new ArrayList<>();\n            for (int i = 0; i <= N; i++) {\n                graph.add(new ArrayList<>());\n            }\n            \n            for (int i = 0; i < M; i++) {\n                int A = scanner.nextInt();\n                int B = scanner.nextInt();\n                int D = scanner.nextInt();\n                int K = scanner.nextInt();\n                graph.get(A).add(new Edge(B, D, K));\n                graph.get(B).add(new Edge(A, D, K));\n            }\n            \n            int[][] dp = new int[N + 1][L + 1];\n            for (int[] row : dp) {\n                Arrays.fill(row, Integer.MAX_VALUE);\n            }\n            dp[1][0] = 0;\n            \n            PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n            pq.offer(new int[]{1, 0, 0});\n            \n            int result = Integer.MAX_VALUE;\n            \n            while (!pq.isEmpty()) {\n                int[] current = pq.poll();\n                int node = current[0];\n                int cost = current[1];\n                int attackers = current[2];\n                \n                if (node == N) {\n                    result = attackers;\n                    break;\n                }\n                \n                if (attackers > dp[node][cost]) {\n                    continue;\n                }\n                \n                for (Edge edge : graph.get(node)) {\n                    int newCost = cost + edge.distance;\n                    if (newCost > L) {\n                        continue;\n                    }\n                    int newAttackers = attackers + edge.attackers;\n                    if (newAttackers < dp[edge.to][newCost]) {\n                        dp[edge.to][newCost] = newAttackers;\n                        pq.offer(new int[]{edge.to, newCost, newAttackers});\n                    }\n                }\n            }\n            \n            System.out.println(result == Integer.MAX_VALUE ? -1 : result);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:10:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PrincessRescue {\n    static class Road {\n        int start, end, distance, attackers;\n        Road(int start, int end, int distance, int attackers) {\n            this.start = start;\n            this.end = end;\n            this.distance = distance;\n            this.attackers = attackers;\n        }\n    }\n\n    static final int INF = Integer.MAX_VALUE;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int dataset = 0; dataset < datasets; dataset++) {\n            int N = scanner.nextInt();\n            int M = scanner.nextInt();\n            int L = scanner.nextInt();\n\n            List<Road> roads = new ArrayList<>();\n            for (int i = 0; i < M; i++) {\n                int u = scanner.nextInt();\n                int v = scanner.nextInt();\n                int d = scanner.nextInt();\n                int a = scanner.nextInt();\n                roads.add(new Road(u, v, d, a));\n                roads.add(new Road(v, u, d, a));\n            }\n\n            int[][] dp = new int[N + 1][L + 1];\n            for (int[] row : dp) Arrays.fill(row, INF);\n            dp[1][0] = 0;\n\n            for (int budget = 0; budget <= L; budget++) {\n                for (int node = 1; node <= N; node++) {\n                    if (dp[node][budget] == INF) continue;\n                    \n                    for (Road road : roads) {\n                        if (road.start != node) continue;\n                        \n                        int newBudget = budget + road.distance;\n                        if (newBudget > L) continue;\n                        \n                        dp[road.end][newBudget] = Math.min(\n                            dp[road.end][newBudget], \n                            dp[node][budget] + road.attackers\n                        );\n                    }\n                }\n            }\n\n            int minAttackers = INF;\n            for (int budget = 0; budget <= L; budget++) {\n                minAttackers = Math.min(minAttackers, dp[N][budget]);\n            }\n\n            System.out.println(minAttackers == INF ? -1 : minAttackers);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:10:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX_WAYPOINTS 100\n#define MAX_ROADS 10000\n\ntypedef struct {\n    int from;\n    int to;\n    int distance;\n    int attackers;\n} Road;\n\nRoad roads[MAX_ROADS];\nint dp[MAX_WAYPOINTS][MAX_WAYPOINTS][MAX_ROADS];\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint solve(int N, int M, int L) {\n    for (int i = 0; i < MAX_WAYPOINTS; i++) {\n        for (int j = 0; j < MAX_WAYPOINTS; j++) {\n            for (int k = 0; k < MAX_ROADS; k++) {\n                dp[i][j][k] = INT_MAX;\n            }\n        }\n    }\n\n    dp[0][0][0] = 0;\n\n    for (int k = 0; k < M; k++) {\n        for (int start = 0; start < N; start++) {\n            for (int end = 0; end < N; end++) {\n                if (dp[start][end][k] == INT_MAX) continue;\n\n                for (int r = 0; r < M; r++) {\n                    if (roads[r].from == end) {\n                        int newDist = dp[start][end][k] + roads[r].distance;\n                        int newAttackers = dp[start][end][k] + roads[r].attackers;\n\n                        if (newDist <= L) {\n                            dp[start][roads[r].to][k+1] = min(\n                                dp[start][roads[r].to][k+1],\n                                newAttackers\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int minAttackers = INT_MAX;\n    for (int k = 0; k < M; k++) {\n        if (dp[0][N-1][k] != INT_MAX) {\n            minAttackers = min(minAttackers, dp[0][N-1][k]);\n        }\n    }\n\n    return minAttackers == INT_MAX ? -1 : minAttackers;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        int N, M, L;\n        scanf(\"%d %d %d\", &N, &M, &L);\n\n        for (int i = 0; i < M; i++) {\n            scanf(\"%d %d %d %d\", \n                &roads[i].from, \n                &roads[i].to, \n                &roads[i].distance, \n                &roads[i].attackers\n            );\n            roads[i].from--;\n            roads[i].to--;\n        }\n\n        int result = solve(N, M, L);\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:10:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 505;\n\nstruct Road {\n    int to, dist, attackers;\n};\n\nstruct State {\n    int node, cost, attackers;\n    bool operator>(const State& other) const {\n        return attackers > other.attackers || \n               (attackers == other.attackers && cost > other.cost);\n    }\n};\n\nint dijkstra(int N, int L, vector<vector<Road>>& graph) {\n    vector<vector<int>> dp(N, vector<int>(L + 1, INT_MAX));\n    priority_queue<State, vector<State>, greater<State>> pq;\n    \n    pq.push({0, 0, 0});\n    dp[0][0] = 0;\n    \n    while (!pq.empty()) {\n        State curr = pq.top();\n        pq.pop();\n        \n        if (curr.node == N - 1) return curr.attackers;\n        \n        if (curr.attackers > dp[curr.node][curr.cost]) continue;\n        \n        for (auto& road : graph[curr.node]) {\n            int newCost = curr.cost + road.dist;\n            int newAttackers = curr.attackers + road.attackers;\n            \n            if (newCost <= L && (dp[road.to][newCost] == INT_MAX || \n                newAttackers < dp[road.to][newCost])) {\n                dp[road.to][newCost] = newAttackers;\n                pq.push({road.to, newCost, newAttackers});\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int T;\n    cin >> T;\n    \n    while (T--) {\n        int N, M, L;\n        cin >> N >> M >> L;\n        \n        vector<vector<Road>> graph(N);\n        \n        for (int i = 0; i < M; i++) {\n            int u, v, d, k;\n            cin >> u >> v >> d >> k;\n            u--; v--;\n            graph[u].push_back({v, d, k});\n            graph[v].push_back({u, d, k});\n        }\n        \n        int result = dijkstra(N, L, graph);\n        cout << result << \"\\n\";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:10:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef minimum_attackers(num_waypoints, roads, budget):\n    graph = {i: [] for i in range(1, num_waypoints + 1)}\n\n    for u, v, distance, attackers in roads:\n        graph[u].append((v, distance, attackers))\n        graph[v].append((u, distance, attackers))\n\n    min_attackers = [float('inf')] * (num_waypoints + 1)\n    min_attackers[1] = 0\n\n    pq = [(0, 0, 1)]  # (cost, attackers, current_waypoint)\n\n    while pq:\n        current_cost, current_attackers, current_waypoint = heapq.heappop(pq)\n        \n        if current_cost > budget:\n            continue\n        \n        if current_attackers > min_attackers[current_waypoint]:\n            continue\n\n        for neighbor, distance, attackers in graph[current_waypoint]:\n            new_cost = current_cost + distance\n            new_attackers = current_attackers + attackers\n\n            if new_cost > budget:\n                continue\n\n            if new_attackers < min_attackers[neighbor]:\n                min_attackers[neighbor] = new_attackers\n                heapq.heappush(pq, (new_cost, new_attackers, neighbor))\n\n    if min_attackers[num_waypoints] == float('inf'):\n        return -1\n    return min_attackers[num_waypoints]\n\ndef process_datasets(datasets):\n    results = []\n    for (N, M, L), roads in datasets:\n        result = minimum_attackers(N, roads, L)\n        results.append(result)\n    return results\n\n# Example usage:\ndatasets = [\n    ((3, 3, 10), [(1, 2, 4, 6), (2, 3, 4, 5), (1, 3, 8, 8)]), # Example dataset format: (N, M, L), [(u, v, distance, attackers), ...]\n    # Add more datasets if needed\n]\n\nprint(process_datasets(datasets))",
    "timestamp": "2025-08-13 05:14:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PrincessProtection {\n\n    static class Road {\n        int destination;\n        int distance;\n        int attackers;\n\n        Road(int destination, int distance, int attackers) {\n            this.destination = destination;\n            this.distance = distance;\n            this.attackers = attackers;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int datasets = scanner.nextInt();\n        for (int d = 0; d < datasets; d++) {\n            int N = scanner.nextInt();\n            int M = scanner.nextInt();\n            int L = scanner.nextInt();\n\n            List<List<Road>> graph = new ArrayList<>();\n            for (int i = 0; i <= N; i++) {\n                graph.add(new ArrayList<>());\n            }\n\n            for (int i = 0; i < M; i++) {\n                int u = scanner.nextInt();\n                int v = scanner.nextInt();\n                int distance = scanner.nextInt();\n                int attackers = scanner.nextInt();\n                graph.get(u).add(new Road(v, distance, attackers));\n                graph.get(v).add(new Road(u, distance, attackers));  // Assume undirected roads\n            }\n\n            int minAttackers = dijkstraMinAttackers(graph, 1, N, L);\n            System.out.println(minAttackers);\n        }\n        scanner.close();\n    }\n\n    private static int dijkstraMinAttackers(List<List<Road>> graph, int start, int end, int budget) {\n        int[] minAttackers = new int[graph.size()];\n        Arrays.fill(minAttackers, Integer.MAX_VALUE);\n        minAttackers[start] = 0;\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        pq.add(new int[]{start, 0, 0});  // {currentNode, currentDistance, totalAttackers}\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int node = current[0];\n            int distance = current[1];\n            int attackers = current[2];\n\n            if (node == end) {\n                return attackers;\n            }\n\n            for (Road road : graph.get(node)) {\n                int newDistance = distance + road.distance;\n                int newAttackers = attackers + road.attackers;\n\n                if (newDistance <= budget && newAttackers < minAttackers[road.destination]) {\n                    minAttackers[road.destination] = newAttackers;\n                    pq.add(new int[]{road.destination, newDistance, newAttackers});\n                }\n            }\n        }\n        return -1;  // If there's no path within budget\n    }\n}",
    "timestamp": "2025-08-13 05:14:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\n#define MAXN 1000\n#define MAXM 10000\n\ntypedef struct {\n    int from;\n    int to;\n    int distance;\n    int attackers;\n} Road;\n\ntypedef struct {\n    int waypoint;\n    int min_attackers;\n} Node;\n\nRoad roads[MAXM];\nNode nodes[MAXN];\nint N, M, L;\n\n// Helper function for sorting roads by distance\nint compareRoads(const void *a, const void *b) {\n    return ((Road *)a)->distance - ((Road *)b)->distance;\n}\n\n// Prim's algorithm adapted for this problem\nvoid findMinimumAttackers(int start) {\n    nodes[start].min_attackers = 0;\n    \n    for (int i = 0; i < N; ++i) {\n        int min_distance_index = -1;\n        for (int j = 0; j < M; ++j) {\n            if (nodes[roads[j].from].min_attackers != INT_MAX &&\n                nodes[roads[j].to].min_attackers == INT_MAX &&\n                roads[j].distance <= L) {\n                if (min_distance_index == -1 ||\n                    roads[j].attackers < roads[min_distance_index].attackers) {\n                    min_distance_index = j;\n                }\n            }\n        }\n        \n        if (min_distance_index != -1) {\n            nodes[roads[min_distance_index].to].min_attackers =\n                nodes[roads[min_distance_index].from].min_attackers +\n                roads[min_distance_index].attackers;\n        }\n    }\n}\n\nint main() {\n    int datasets;\n    \n    scanf(\"%d\", &datasets);\n    \n    for (int d = 0; d < datasets; ++d) {\n        scanf(\"%d %d %d\", &N, &M, &L);\n        \n        for (int i = 0; i < M; ++i) {\n            scanf(\"%d %d %d %d\", &roads[i].from, &roads[i].to,\n                                &roads[i].distance, &roads[i].attackers);\n        }\n        \n        qsort(roads, M, sizeof(Road), compareRoads);\n        \n        for (int i = 0; i < N; ++i) {\n            nodes[i].waypoint = i;\n            nodes[i].min_attackers = INT_MAX;\n        }\n        \n        findMinimumAttackers(0);\n        \n        int min_attackers = INT_MAX;\n        \n        for (int i = 1; i < N; ++i) {\n            if (nodes[i].min_attackers < min_attackers) {\n                min_attackers = nodes[i].min_attackers;\n            }\n        }\n        \n        printf(\"%d\\n\", min_attackers);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 05:14:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve_princess_route(N, M, L, roads):\n    graph = [[] for _ in range(N)]\n    for u, v, dist, attackers in roads:\n        graph[u-1].append((v-1, dist, attackers))\n        graph[v-1].append((u-1, dist, attackers))\n\n    min_attackers = float('inf')\n    \n    for start in range(N-1):\n        for end in range(start+1, N):\n            pq = [(0, start, 0)]\n            visited = set()\n            \n            while pq:\n                total_cost, current, total_attackers = heapq.heappop(pq)\n                \n                if current == end:\n                    min_attackers = min(min_attackers, total_attackers)\n                    break\n                \n                if (current, total_cost) in visited:\n                    continue\n                \n                visited.add((current, total_cost))\n                \n                for next_node, road_dist, road_attackers in graph[current]:\n                    new_cost = total_cost + road_dist\n                    new_attackers = total_attackers + road_attackers\n                    \n                    if new_cost <= L:\n                        heapq.heappush(pq, (new_cost, next_node, new_attackers))\n\n    return min_attackers if min_attackers != float('inf') else -1\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N, M, L = map(int, input().split())\n        roads = []\n        for _ in range(M):\n            u, v, dist, attackers = map(int, input().split())\n            roads.append((u, v, dist, attackers))\n        \n        result = solve_princess_route(N, M, L, roads)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:15:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    while ptr < len(input):\n        N = int(input[ptr])\n        M = int(input[ptr+1])\n        L = int(input[ptr+2])\n        ptr +=3\n        \n        adj = [[] for _ in range(N+1)]\n        for _ in range(M):\n            u = int(input[ptr])\n            v = int(input[ptr+1])\n            d = int(input[ptr+2])\n            a = int(input[ptr+3])\n            ptr +=4\n            adj[u].append((v, d, a))\n            adj[v].append((u, d, a))\n        \n        # Dijkstra's algorithm: (total_attackers, total_distance, node)\n        INF = float('inf')\n        dist = [INF] * (N+1)\n        attack = [INF] * (N+1)\n        heap = []\n        # Start at node 1 (assuming 1 is the start)\n        heapq.heappush(heap, (0, 0, 1))\n        dist[1] = 0\n        attack[1] = 0\n        \n        while heap:\n            current_a, current_d, u = heapq.heappop(heap)\n            if u == N:\n                break\n            if current_a > attack[u] or (current_a == attack[u] and current_d > dist[u]):\n                continue\n            for (v, d, a) in adj[u]:\n                new_d = current_d + d\n                new_a = current_a + a\n                if new_d > L:\n                    continue\n                if new_a < attack[v] or (new_a == attack[v] and new_d < dist[v]):\n                    attack[v] = new_a\n                    dist[v] = new_d\n                    heapq.heappush(heap, (new_a, new_d, v))\n        \n        if attack[N] != INF:\n            print(attack[N])\n        else:\n            print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 05:15:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nstruct Road {\n    int destination;\n    int distance;\n    int attackers;\n};\n\nstruct Path {\n    int waypoint;\n    int cost;\n    int attackers;\n    bool operator>(const Path& other) const {\n        if (attackers == other.attackers) {\n            return cost > other.cost;\n        }\n        return attackers > other.attackers;\n    }\n};\n\nint minimizeAttackers(int N, int M, int L, vector<vector<Road>>& graph) {\n    priority_queue<Path, vector<Path>, greater<Path>> pq;\n    vector<vector<int>> dp(N, vector<int>(L + 1, numeric_limits<int>::max()));\n\n    dp[0][0] = 0;\n    pq.push({0, 0, 0});\n\n    while (!pq.empty()) {\n        Path current = pq.top();\n        pq.pop();\n\n        if (current.attackers > dp[current.waypoint][current.cost])\n            continue;\n\n        for (auto& road : graph[current.waypoint]) {\n            int new_cost = current.cost + road.distance;\n            if (new_cost > L)\n                continue;\n            int new_attackers = current.attackers + road.attackers;\n            if (new_attackers < dp[road.destination][new_cost]) {\n                dp[road.destination][new_cost] = new_attackers;\n                pq.push({road.destination, new_cost, new_attackers});\n            }\n        }\n    }\n\n    int min_attackers = numeric_limits<int>::max();\n    for (int cost = 0; cost <= L; ++cost) {\n        min_attackers = min(min_attackers, dp[N - 1][cost]);\n    }\n    return min_attackers;\n}\n\nint main() {\n    int T, N, M, L;\n    cin >> T;\n    while (T--) {\n        cin >> N >> M >> L;\n        vector<vector<Road>> graph(N);\n        for (int i = 0; i < M; ++i) {\n            int u, v, d, a;\n            cin >> u >> v >> d >> a;\n            --u; --v;  // Assuming input is 1-indexed\n            graph[u].push_back({v, d, a});\n            graph[v].push_back({u, d, a});\n        }\n        cout << minimizeAttackers(N, M, L, graph) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:23:57"
  }
]