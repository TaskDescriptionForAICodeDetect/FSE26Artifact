[
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nclass Princess {\npublic:\n  int pos;\n  int money;\n  int attacked_count;\n  Princess(int _p,int _m,int _atk) :pos(_p), money(_m), attacked_count(_atk){}\n  bool operator<(const Princess& p) const {\n    return attacked_count < p.attacked_count;\n  }\n  bool operator>(const Princess& p) const {\n    return attacked_count > p.attacked_count;\n  }\n};\n\nint main(){\n  int total_inns,total_roads,total_money;\n  while(~scanf(\"%d %d %d\",&total_inns,&total_roads,&total_money)){\n    if(total_inns == 0 && total_roads == 0 && total_money == 0) break;\n\n    int cost[101][101];\n    int robber[101][101];\n    int dp[101][101];\n    memset(cost,0x3f,sizeof(cost));\n    memset(robber,0x3f,sizeof(robber));\n    memset(dp,0x3f,sizeof(dp));\n\n    for(int road_idx=0;road_idx<total_roads;road_idx++){\n      int from,to;\n      int dist,robber_num;\n      scanf(\"%d %d %d %d\",&from,&to,&dist,&robber_num);\n      cost[from][to] = dist;\n      cost[to][from] = dist;\n      robber[from][to] = robber_num;\n      robber[to][from] = robber_num;\n    }\n\n    priority_queue<Princess,vector<Princess>,greater<Princess> > que;\n    que.push(Princess(1,total_money,0));\n    \n\n    while(!que.empty()){\n      Princess pr = que.top();\n      int from = pr.pos;\n      int remaining_money = pr.money;\n      int attacked_count = pr.attacked_count;\n      que.pop();\n\n      for(int to=2;to<=total_inns;to++){\n\tif(to == from) continue;\n\tif(cost[from][to] == INF) continue;\n\n\n\tif(cost[from][to] <= remaining_money){\n\t  //use_money\n\t  int next_atk = attacked_count;\n\t  int next_money = remaining_money - cost[from][to];\n\n\t  if(dp[to][next_money] <= next_atk) continue;\n\n\t  dp[to][next_money] = next_atk;\n\t  Princess next(to,next_money,next_atk);\n\t  que.push(next);\n\n\t  //dont use\n\t  int next_atk2 = attacked_count + robber[from][to];\n\t  int next_money2 = remaining_money;\n\n\t  if(dp[to][next_money2] <= next_atk2) continue;\n\n\t  dp[to][next_money2] = next_atk2;\n\t  Princess next2(to,next_money2,next_atk2);\n\t  que.push(next2);\n\t}\n\telse{\n\t  //dont use\n\t  int next_atk2 = attacked_count + robber[from][to];\n\t  int next_money2 = remaining_money;\n\n\t  if(dp[to][next_money2] <= next_atk2) continue;\n\n\t  dp[to][next_money2] = next_atk2;\n\t  Princess next2(to,next_money2,next_atk2);\n\t  que.push(next2);\n\t}\n      }\n    }\n\n    int res = INF;\n    for(int money=0;money<=100;money++){\n      res = min(res,dp[total_inns][money]);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct P\n{\n    int p, money, damage;\n\n    bool operator >(const P& p ) const  {\n        return damage > p.damage;\n    }\n};\n\nstruct edge\n{\n    int to, cost, enemy;\n};\n\nint main() {\n    int town_n, road_n, money;\n\n    while(cin >> town_n >> road_n >> money, town_n|road_n|money){\n        vector<edge> E[town_n + 1];\n\n        REP(i, road_n){\n            int from ,to, cost, enemy;\n            cin >> from >> to >> cost >> enemy;\n\n            E[from].push_back({to, cost, enemy});\n            E[to].push_back({from, cost, enemy});\n        }\n\n        int G[town_n + 1][money + 1];\n        fill_n((int*)G, (town_n + 1)*(money + 1), 1<<11);\n        G[1][money] = 0;\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({1, money, 0});\n        int result = -1;\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n//            printf(\"now town :%d, money:%d, damage: %d\\n\", p.p, p.money, p.damage);\n            if(p.p == town_n){\n                result = p.damage;\n                break;\n            }\n\n            for(edge e:E[p.p]){\n                int to = e.to;\n                int usedmoney = p.money - e.cost;\n                int damaged = p.damage + e.enemy;\n\n                //お金を使う\n                if(usedmoney >= 0 && G[e.to][usedmoney] > p.damage){\n                    que.push({to, usedmoney, p.damage});\n                    G[e.to][usedmoney] = p.damage;\n                }\n                //お金を使わない\n                if(G[e.to][p.money] > damaged){\n                    que.push({to, p.money, damaged});\n                    G[e.to][p.money] = damaged;\n                }\n            }\n        }\n\n        if(result == -1)\n            assert(result);\n\n        cout << result << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct NODE{\n  vector<int> to_node;\n  vector<int> to_cost;\n  vector<int> to_man;\n  bool done_c;\n  bool done_m;\n  bool start;\n  int cost;\n  int man;\n  int nom;\n};\nint main(){\n  int n,m,l;\n  while(cin >>n>>m>>l,n|m|l){\n    NODE inn[100];\n    vector<int> ans;\n    while(m--){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      inn[a-1].to_node.push_back(b-1);\n      inn[a-1].to_cost.push_back(c);\n      inn[a-1].to_man.push_back(d);\n      inn[b-1].to_node.push_back(a-1);\n      inn[b-1].to_cost.push_back(c);\n      inn[b-1].to_man.push_back(d);\n    }\n    for(int i=0; i<n; i++){\n      inn[i].start = false;\n      inn[i].nom = 1000000;\n    }\n    inn[0].nom = 0;\n    for(int i=0; i<n; i++){\n      int at = 0,pom = 10000000;\n      for(int j=0; j<n; j++){\n\tif((!(inn[j].start)) && pom>inn[j].nom){at = j; pom = inn[j].nom;}\n      }\n      inn[at].start = true;\n      for(int j=0; j<inn[at].to_node.size(); j++){\n\tint togo = inn[at].to_node[j];\n\tif(!inn[togo].start){inn[togo].nom = min(inn[at].to_man[j] + inn[at].nom,inn[togo].nom);}\n      }\n    }\n    for(int k=0; k<n; k++){\n      for(int i=0; i<n; i++){\n\tinn[i].cost = 1000000;\n\tinn[i].done_c = false;\n      }\n      inn[k].cost = 0;\n      for(int i=0; i<n; i++){\n\tint at = 0,pom = 10000000;\n\tfor(int j=0; j<n; j++){\n\t  if((!(inn[j].done_c)) && pom>inn[j].cost){at = j; pom = inn[j].cost;}\n\t}\n\tinn[at].done_c = true;\n\tfor(int j=0; j<inn[at].to_node.size(); j++){\n\t  int togo = inn[at].to_node[j];\n\t  if(!inn[togo].done_c){inn[togo].cost = min(inn[at].to_cost[j] + inn[at].cost,inn[togo].cost);}\n\t}\n      }\n      for(int i=0; i<n; i++){\n\tinn[i].man = 1000000;\n\tinn[i].done_m = false;\n      }\n      inn[k].cost = 0;\n      for(int i=0; i<n; i++){\n\tint at = 0,pom = 10000000;\n\tfor(int j=0; j<n; j++){\n\t  if((!(inn[j].done_m)) && pom>inn[j].man){at = j; pom = inn[j].man;}\n\t}\n\tinn[at].done_m = true;\n\tfor(int j=0; j<inn[at].to_node.size(); j++){\n\t  int togo = inn[at].to_node[j];\n\t  if(!inn[togo].done_m){inn[togo].man = min(inn[at].to_man[j] + inn[at].man,inn[togo].man);if(inn[togo].cost<=l){inn[togo].man = 0;}}\n\t}\n      }\n      ans.push_back(inn[k].nom + inn[n-1].man);\n    }\n    sort(ans.begin(),ans.end());\n    cout <<ans[0]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#define fr first\n#define sc second\n#define INF (1 << 25)\nusing namespace std;\n\ntypedef pair<int,int> F;\ntypedef pair<F,int> P;\nstruct edge{\n    int to,dis,enemy; edge(){}\n    edge(int to,int dis,int enemy):to(to),dis(dis),enemy(enemy){}\n};\n\nint n,m,l,costed[128][128]; \nvector< vector<edge> > info(128);\n\nvoid init(){\n    for(int i=0;i<128;i++){\n        for(int j=0;j<128;j++) costed[i][j] = INF;\n    }\n    info.resize(0); info.resize(128);\n}\n\nvoid add_info(){\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    info[a].push_back(edge(b,c,d));\n    info[b].push_back(edge(a,c,d));\n}\n\nint Dijkstra(){\n    priority_queue<P,vector<P>,greater<P> > que;\n    que.push(P(F(0,1),l)); costed[1][l] = 0;\n    while(!que.empty()){\n        P p = que.top(); que.pop();\n        int now = p.fr.sc,en = p.fr.fr,mo = p.sc;\n        if(now == n) return en;\n        for(int i=0;i<info[now].size();i++){\n            edge e = info[now][i];\n            if(e.enemy + en < costed[e.to][mo]){\n                que.push(P(F(e.enemy + en,e.to),mo));\n                costed[e.to][mo] = e.enemy + en;\n            }\n            if(e.enemy == 0 ){\n                if(en < costed[e.to][mo]){\n                    que.push(P(F(en,e.to),mo));\n                    costed[e.to][mo] = en;\n                }\n            }\n            if(e.dis <= mo){\n                if(en < costed[e.to][mo-e.dis]){\n                    que.push(P(F(en,e.to),mo-e.dis));\n                    costed[e.to][mo] = en;\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin>>n>>m>>l,n||m||l){\n        init();\n        for(int i=0;i<m;i++) add_info();\n        cout << Dijkstra() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110]={};\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(now==n){\n    ans=min(ans,sum);\n    return;\n  }\n  if(memo[nokori][now]<=sum)return;\n  for(int i=nokori;i<=l;i++)\n    memo[i][now]=sum;\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      used[E[now][i].to]=true;\n      if(nokori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n      for(int j=0;j<l+5;j++)\n      memo[j][i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\n#define INF 0x7fffffff\n\nusing namespace std;\n\ntypedef pair<int, pair<int,int> > PP;\n\nstruct edge{\n\tint to, D, E;\n\tedge(int t, int d, int e): to(t), D(d), E(e) {}\n};\n\n\nint main(){\n\tint N, M, L, A, B, D, E;\n\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\t\n\twhile( cin>>N>>M>>L, N|M|L ){\n\t\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\t\tvector<edge> v[105];\n\t\tint dh[105][105];\n\t\tfor(int i=0; i<M; i++){\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tv[A].push_back( edge(B, D, E) );\n\t\t\tv[B].push_back( edge(A, D, E) );\n\t\t}\n\t\tfill(dh[0], dh[0]+105*105, INF);\n\t\t\n\t\tque.push( make_pair(0, make_pair(1,L)) );\n\t\twhile( !que.empty() ){\n\t\t\tPP p = que.top(); que.pop();\n\t\t\tint psf = p.second.first, pss = p.second.second;\n\t\t\tif( pss >= 0 && p.first < dh[psf][pss] ){\n\t\t\t\tdh[psf][pss] = p.first;\n\t\t\t\tfor(int i=0; i<v[psf].size(); i++){\n\t\t\t\t\tedge e = v[psf][i];\n\t\t\t\t\tque.push( make_pair(p.first + e.E, make_pair(e.to, pss)) );\n\t\t\t\t\tque.push( make_pair(p.first, make_pair(e.to, pss-e.D)) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int i=0; i<=L; i++)\n\t\t\tans = min(ans, dh[N][i] );\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=1001001001;\nstruct edge{\n    int to,cost,num;\n    edge(int to,int cost,int num)\n        :to(to),cost(cost),num(num){}\n};\n\nstruct data{\n    int pos,cost,money;\n    data(int pos,int cost,int money)\n        :pos(pos),cost(cost),money(money){}\n\n    bool operator<(const data &d)const{\n        return cost>d.cost;\n    }\n};\n\nint N,M,L;\nvector<edge>G[100];\nint dist[100][101];\n\nvoid solve(){\n    fill_n(*dist,100*101,INF);\n    dist[0][L]=0;\n    priority_queue<data>que;\n    que.push(data(0,0,L));\n\n    while(que.size()){\n        data d=que.top();que.pop();\n        if(dist[d.pos][d.money]<d.cost)continue;\n        for(int i=0;i<G[d.pos].size();i++){\n            edge &e=G[d.pos][i];\n            if(dist[e.to][d.money]>d.cost+e.num){\n                dist[e.to][d.money]=d.cost+e.num;\n                que.push(data(e.to,dist[e.to][d.money],d.money));\n            }\n            if(e.cost<=d.money&&dist[e.to][d.money-e.cost]>d.cost){\n                dist[e.to][d.money-e.cost]=d.cost;\n                que.push(data(e.to,dist[e.to][d.money-e.cost],d.money-e.cost));\n            }\n        }\n    }\n\n    int mi=INF;\n    for(int i=0;i<=L;i++)mi=min(mi,dist[N-1][i]);\n    cout<<mi<<endl;\n}\n\nint main(){\n    while(cin>>N>>M>>L,N||M||L){\n        fill_n(G,100,vector<edge>());\n        for(int i=0;i<M;i++){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;a--;b--;\n            G[a].push_back(edge(b,c,d));\n            G[b].push_back(edge(a,c,d));\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N, M, L;\nstruct edge{\n  int to, d, n;\n  edge() {}\n  edge(int to, int d, int n) :\n    to(to), d(d), n(n) {}\n};\nvector<edge> edges[101];\nint memo[101][101];\nint dfs(int p, int l, int sum){\n  //printf(\"%d %d -> %d\\n\", p, l, sum);\n  if(p == N - 1) return sum;\n  memo[p][l] = min((memo[p][l]!=-1)?memo[p][l]:INF, sum);\n  int res = INF;\n  FORIT(it, edges[p]){\n    edge e = *it;\n    if(memo[e.to][l] == -1 || memo[e.to][l] > sum + e.n && res > sum + e.n)res = min(res, dfs(e.to, l, sum + e.n));\n    if(l - e.d >= 0 && (memo[e.to][l-e.d] == -1 || memo[e.to][l-e.d] > sum && res > sum)) res = min(res, dfs(e.to, l - e.d, sum));\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>N>>M>>L && N){\n    REP(i, 101)edges[i].clear();\n    memset(memo, -1, sizeof(memo));\n    REP(i, M){\n      int A,B,D,E;\n      cin>>A>>B>>D>>E;\n      A--; B--;\n      edges[A].push_back(edge(B, D, E));\n      edges[B].push_back(edge(A, D, E));\n    }\n    int ans = dfs(0, L, 0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n// int n_dir = 4;\n// int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; [> CSS order <]\n// enum direction {\n\t// UP, RIGHT, DOWN, LEFT\n// };\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// };\n// #define FORDIR(d) REP (d, n_dir)\n\ntypedef complex<int> P;\n#define Y real()\n#define X imag()\nP dyx[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\n// P dyx[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\n\nint g_height, g_width;\nbool in_field(P p) {\n\treturn (0 <= p.Y && p.Y < g_height) && (0 <= p.X && p.X < g_width);\n}\n\n/*}}}*/\n\n// My version of (Extended) Dijkstra\n// Pros: easy to access `costs` -- just `costs(node)`\n//       vector with many parameters is confusing e.g. `costs[param1][param2][param3]...`\n\n// Node should have only parameters with which Node can be distinguished\nclass Node {\npublic:\n\t// Parameters to distinguish Nodes\n\tint id;\n\tint budget;\n\n\tNode(int _id, int _budget): id(_id), budget(_budget) {\n\t}\n};\n\n// for priority_queue\ntypedef pair<int, Node> Qtype; // cost and Node\nclass Comp {\npublic:\n\tbool operator() (const Qtype& l, const Qtype& r) const {\n\t\t// compair costs for each Node\n\t\treturn (l.F > r.F);\n\t}\n};\n\n// easy access to saved costs\n// #define MAX_N 100\n// #define MAX_L 100\n// VVI g_saved_costs(MAX_N, VI(MAX_L));\n// void init_saved_costs()\n// {\n\t// REP (i, MAX_N) {\n\t\t// REP (j, MAX_L) {\n\t\t\t// g_saved_costs[i][j] = INF;\n\t\t// }\n\t// }\n// }\nVVI g_saved_costs;\nint saved_cost(Node n)\n{\n\treturn g_saved_costs[n.id][n.budget];\n}\nvoid save_cost(Node n, int cost)\n{\n\tg_saved_costs[n.id][n.budget] = cost;\n}\n\nint main()\n{\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N) {\n\t\tVVI dist(N, VI(N, INF));\n\t\tVVI gang(N, VI(N, INF));\n\t\tREP (_, M) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e; --a, --b;\n\t\t\tdist[a][b] = dist[b][a] = d;\n\t\t\tgang[a][b] = gang[b][a] = e;\n\t\t}\n\n\t\t// Initialize g_saved_costs\n\t\t// init_saved_costs();\n\t\tg_saved_costs.clear();\n\t\tg_saved_costs = VVI(N, VI(L+1, INF));\n\t\tpriority_queue< Qtype, vector<Qtype>, Comp > q;\n\n\t\tq.push( MP(0, Node(0, L)) );\n\t\twhile (!q.empty()) {\n\t\t\tQtype t = q.top(); q.pop();\n\t\t\tint cost_here = t.F; Node node = t.S;\n\n\t\t\t// Skip if already visited\n\t\t\tif (cost_here > saved_cost(node)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsave_cost(node, cost_here);\n\n\t\t\tREP (i, N) {\n\t\t\t\tif (dist[node.id][i] != INF) {\n\t\t\t\t\t// without guard\n\t\t\t\t\tq.push(MP(cost_here + gang[node.id][i], Node(i, node.budget)));\n\t\t\t\t\tif (dist[node.id][i] <= node.budget) {\n\t\t\t\t\t\t// with guard\n\t\t\t\t\t\tq.push(MP(cost_here, Node(i, node.budget - dist[node.id][i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tREP (i, L+1) {\n\t\t\tans = min(ans, saved_cost(Node(N-1, i)));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n/*\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\t\t*/\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n/*\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\t\t*/\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, deque<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, deque<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<vector<int>> memo(N+1, vector<int>(101, 0));\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (memo[current.loc][current.money]) {\n                continue;\n            }\n            memo[current.loc][current.money] = 1;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (0 <= current.money - e.dist) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\n#define rep(X,Y) for(int (X)=0;(X)<(Y);++(X))\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define pb push_back\n\nusing namespace std;\n\nstruct edge {int to, cost, pp;};\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PIP;\n\n#define MAX_V 101\n#define MAX_L 101\n#define INF 1000000000\n\nvector<edge> G[MAX_V];\nint d[MAX_L][MAX_V];\n\nint l,n,m;\n\n\nvoid dij(){\n\tpriority_queue<PIP, vector<PIP>, greater<PIP> > q;\n\t\n\td[l][1] = 0;\n\tq.push(PIP(0,P(l,1)));\n\twhile(!q.empty()){\n\t\tPIP p = q.top();q.pop();\n\t\tint ll = p.second.first;\n\t\tint v = p.second.second;\n\t\tif(ll < 0)continue;\n\t\tif(d[ll][v] < p.first)continue;\n\t\trep(i,G[v].size()){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[ll][e.to] > d[ll][v] + e.pp ){\n\t\t\t\td[ll][e.to] = d[ll][v] + e.pp;\n\t\t\t\tq.push(PIP(d[ll][e.to],P(ll,e.to)));\n\t\t\t}\n\t\t\tif( ll-e.cost < 0)continue;\n\t\t\tif(d[ll-e.cost][e.to] > d[ll][v]){\n\t\t\t\td[ll-e.cost][e.to] = d[ll][v];\n\t\t\t\tq.push(PIP(d[ll-e.cost][e.to],P(ll-e.cost,e.to)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid init(){\n\tl = n = m = 0;\n\trep(i,101)G[i].clear();\n\trep(i,101)rep(j,101)d[i][j] = INF;\n}\n\n\t\n\n\nint main(){\n\twhile(1){\n\t\tint ans = INF;\n\t\tinit();\n\t\tcin >> n >> m >> l;\n\t\tif(!n)break;\n\t\trep(i,m){\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tG[a].push_back((edge){b,d,e});\n\t\t\tG[b].push_back((edge){a,d,e});\n\t\t}\n\t\tdij();\n\t\trep(i,l+1){\n\t\t\tans = min(ans, d[i][n]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (int)1e9\nusing namespace std;\n\nstruct data {\n  int p, d, c;\n};\nbool operator<(const data &l, const data &r) {\n  if(l.c != r.c) return l.c > r.c;\n  if(l.d != r.d) return l.d > r.d;\n  return l.p > r.p;\n}\n\nint n, m, l;\nint dp[105][105] = {0};\nvector<data> edges[105];\npriority_queue<data> pq;\n\nint solve();\n\nint main() {\n  while(1) {\n    cin >> n >> m >> l;\n    if(n + m + l == 0) break;\n    for(int i = 0; i < m; ++i) {\n      int a, b, d, e;\n      cin >> a >> b >> d >> e;\n      edges[--a].push_back({--b, d, e});\n      edges[b].push_back({a, d, e});\n    }\n    cout << solve() << endl;\n    for(int i = 0; i < n; ++i)\n      edges[i].erase(edges[i].begin(), edges[i].end());\n  }\n  return 0;\n}\n\nint solve() {\n  for(int i = 0; i < n; ++i)\n    for(int k = 0; k <= l; ++k) dp[i][k] = inf;\n  pq.push({0, 0, 0});\n  while(pq.size() > 0) {\n    data now = pq.top();\n    pq.pop();\n    if(dp[now.p][now.d] <= now.c) continue;\n    dp[now.p][now.d] = now.c;\n    for(int i = 0; i < edges[now.p].size(); ++i) {\n      data nextp = now;\n      nextp.p = edges[now.p][i].p;\n      if(edges[now.p][i].c != 0)\n        nextp.d += edges[now.p][i].d;\n      if(nextp.d <= l) pq.push(nextp);\n      nextp.d = now.d;\n      nextp.c += edges[now.p][i].c;\n      pq.push(nextp);\n    }\n  }\n  int ans = inf;\n  for(int i = 0; i <= l; ++i) ans = min(ans, dp[n - 1][i]);\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nint main(){\n\tfor(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n;){\n\t\tint s=0,g=n-1;\n\n\t\tstatic int dis[100][100],cost[100][100];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\tdis[i][j]=(i==j?0:-1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\tscanf(\"%d%d%d%d\",&a,&b,&d,&e);\n\t\t\ta--,b--;\n\t\t\tdis[a][b]=dis[b][a]=d;\n\t\t\tcost[a][b]=cost[b][a]=e;\n\t\t}\n\n\t\tstatic int cmin[100][101];\n\t\tstatic bool visited[100][101];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<=l;j++){\n\t\t\tcmin[i][j]=1<<30;\n\t\t\tvisited[i][j]=false;\n\t\t}\n\n\t\tint ans;\n\t\tpriority_queue< pair<int,pii> > pq;\tpq.push(mp(0,mp(s,l)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\tint nowcost=-a.first,u=a.second.first,bud=a.second.second;\n\t\t\tif(u==g){ ans=nowcost; break; }\n\t\t\tif(visited[u][bud])\tcontinue;\n\t\t\tvisited[u][bud]=true;\n\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(~dis[u][v]){\n\t\t\t\t\tint nextcost=nowcost+cost[u][v];\n\t\t\t\t\tint nextbud=bud;\n\t\t\t\t\tif(!visited[v][nextbud]){\n\t\t\t\t\t\tif(nextcost<cmin[v][nextbud]){\n\t\t\t\t\t\t\tpq.push(mp(-nextcost,mp(v,nextbud)));\n\t\t\t\t\t\t\tcmin[v][nextbud]=nextcost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnextcost=nowcost;\n\t\t\t\t\tnextbud=bud-dis[u][v];\n\t\t\t\t\tif(nextbud>=0 && !visited[v][nextbud]){\n\t\t\t\t\t\tif(nextcost<cmin[v][nextbud]){\n\t\t\t\t\t\t\tpq.push(mp(-nextcost,mp(v,nextbud)));\n\t\t\t\t\t\t\tcmin[v][nextbud]=nextcost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define D(x) cout << #x \" = \" << x << endl\n#define DD(x, y) cout << \"(\" #x \", \" #y \") = (\" << x << \", \" << y << \")\" << endl\n#define DDD(x, y, z) cout << \"(\" #x \", \" #y \", \" #z \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define DV(v) for (auto __macro_vi : v){ cout << __macro_vi << \" \";} cout << endl;\n#define DA(a, n) for (int __macro_i = 0; __macro_i < n; ++__macro_i) { cout << a[__macro_i] << \" \"; } cout << endl;\n#define REP(i, n) for (int i = 0; i < n; ++i)\n#define ALL(v) (v).begin(), (v).end()\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<cmath>\n#include<queue>\n#include<string>\n#include<sstream>\n\nusing namespace std;\n\nclass Graph{\nprivate:\n    struct Node {\n        int index;\n        bool done;\n        long long dist;\n        vector<pair<int, int>> adj;\n        Node() : done(false), dist(INF) {}\n\n        bool operator>(const Node& another) const {\n            return dist > another.dist;\n        }\n    };\n\n    vector<Node> nodes;\n\n    void range_check(int i) {\n        if (i < 0 || i >= n) {\n            cout << \"dijkstra: Invalid node index: \" << i << endl;\n            throw \"Exception\";\n        }\n    }\npublic:\n    const static long long INF = 1LL << 62;\n    const int n;\n\n    // n nodes directed graph\n    Graph(int _n) : n(_n) {\n        nodes = vector<Node>(_n);\n        for (int i = 0; i < _n; ++i) {\n            nodes[i].index = i;\n        } \n    }\n\n    // add directed edge from u-th node to v-th node\n    void addEdge(int u, int v, int w) {\n        range_check(u);\n        range_check(v);\n        nodes[u].adj.push_back(make_pair(v, w));\n        if (w < 0) {\n            cout << \"dijkstra: All weights must be positive: \" << w << \" (\" << u << \" -- \" << v << \")\" << endl;\n            throw \"Exception\";\n        }\n    }\n\n    // add undirected edge between u-th node and v-th node\n    void addUndirectedEdge(int u, int v, int w) {\n        addEdge(u, v, w);\n        addEdge(v, u, w);\n    }\n\n    // calculate shortest distance from s-th node\n    void dijkstra(int s) {\n        range_check(s);\n\n        priority_queue<Node, vector<Node>, greater<Node>> pq;\n\n        nodes[s].dist = 0;\n        pq.push(nodes[s]);\n\n        while (!pq.empty()) {\n            Node top = pq.top();\n            pq.pop();\n            top.done = true;\n\n            int u = top.index;\n            // D(u);\n            for (pair<int, int> p : top.adj) {\n                int v = p.first;\n                int w = p.second;\n                if (nodes[v].done) continue;\n\n                long long newdist = nodes[u].dist + (long long)w;\n                if (nodes[v].dist > newdist) {\n                    nodes[v].dist = newdist;\n                    pq.push(nodes[v]);\n                }\n            }\n        }\n    }\n\n    // shortest distance to i\n    long long shortestDistTo(int i) const {\n        return nodes[i].dist;\n    }\n\n    // dump this graph\n    string dump() const {\n        ostringstream os;\n        os << \"node -> adj-node(distance), ...\" << endl;\n        for (Node node : nodes) {\n            os << node.index << \" -> \";\n            for (pair<int, int> p : node.adj) {\n                os << p.first << \"(\" << p.second << \"), \" << node.dist;\n            }\n            os << endl;\n        }\n        return os.str();\n    }\n};\n\nint n, m, l;\nint nodei(int i, int li) {\n    return i + li * n;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(1) {\n        cin >> n >> m >> l;\n        if (n == 0) break;\n        auto g = Graph(n * (l + 1));\n        REP(i, m) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            REP(li, l + 1) g.addUndirectedEdge(nodei(a, li), nodei(b, li), e);\n            REP(li, l + 1) {\n                if (li + d > l) break;\n                g.addEdge(nodei(a, li + d), nodei(b, li), 0);\n                g.addEdge(nodei(b, li + d), nodei(a, li), 0);\n            }\n        }\n        long long ans = 1LL << 62;\n        g.dijkstra(nodei(0, l));\n        // D(nodei(0, l));\n        // cout << g.dump() << endl;\n        // D(ans);\n        REP(li, l + 1) {\n            // DDD(li, nodei(n - 1, li), g.shortestDistTo(nodei(n - 1, li)));\n            ans = min(ans, g.shortestDistTo(nodei(n - 1, li)));\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\nbool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy < b.enemy;\n}\n\nbool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\t\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tstatus = priority_queue();\n\n\t\t/*\n\t\twhile( !status.empty() ) {\n\t\t\tstatus.pop() ;\n\t\t}\t\n\t\t*/\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip;\n\nint dp[105][105];\n\nint main(void) {\n    int i,j;\n    int n, m, l;\n    while(cin >> n >> m >> l, n){\n        vector<vector<pip> > v(n);\n        rep(i,m){\n            int a,b,d,e;\n            cin >> a >> b >> d >> e;\n            a--,b--;\n            v[a].push_back(pip(b,pii(d,e)));//to,cost,num\n            v[b].push_back(pip(a,pii(d,e)));\n        }\n        priority_queue<pip,vector<pip>,greater<pip> > q;\n\n        rep(i,105)rep(j,105)dp[i][j] = INF;\n        dp[0][0] = 0;\n        q.push(pip(0,pii(0,0)));//num,v,cost\n        while(q.size()){\n\n            int now_v = q.top().second.first;\n            int now_cost = q.top().second.second;\n            int now_num = q.top().first;\n            q.pop();\n\n            if(dp[now_v][now_cost] < now_num)continue;\n\n            rep(i,v[now_v].size()){\n                int next_v = v[now_v][i].first;\n\n                //護衛するときは、お金がかかるが襲われる人数は増えない\n                int next_cost1 = now_cost + v[now_v][i].second.first;\n                int next_num1 = now_num;\n\n                if(next_cost1 <= l && dp[next_v][next_cost1] > next_num1){\n                    dp[next_v][next_cost1] = next_num1;\n                    q.push(pip(next_num1,pii(next_v,next_cost1)));\n                }\n\n                //護衛しないときは、お金はかからないが襲われる人数が増える\n                int next_cost2 = now_cost;\n                int next_num2 = now_num + v[now_v][i].second.second;\n\n                if(next_cost2 <= l && dp[next_v][next_cost2] > next_num2){\n                    dp[next_v][next_cost2] = next_num2;\n                    q.push(pip(next_num2,pii(next_v,next_cost2)));\n                }\n\n            }\n        }\n        int ans = INF;\n        rep(i,l+1){\n            ans = min(ans, dp[n-1][i]);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<vector<int>> memo(N+1, vector<int>(M+1, 0));\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (memo[current.loc][current.money]) {\n                continue;\n            }\n            memo[current.loc][current.money] = 1;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (0 <= current.money - e.dist) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nclass Princess {\npublic:\n  int pos;\n  int money;\n  int attacked_count;\n  Princess(int _p,int _m,int _atk) :pos(_p), money(_m), attacked_count(_atk){}\n  bool operator<(const Princess& p) const {\n    return attacked_count < p.attacked_count;\n  }\n  bool operator>(const Princess& p) const {\n    return attacked_count > p.attacked_count;\n  }\n};\n\nint main(){\n  int total_inns,total_roads,total_money;\n  while(~scanf(\"%d %d %d\",&total_inns,&total_roads,&total_money)){\n    if(total_inns == 0 && total_roads == 0 && total_money == 0) break;\n\n    int cost[101][101];\n    int robber[101][101];\n    int dp[101][101];\n    memset(cost,0x3f,sizeof(cost));\n    memset(robber,0x3f,sizeof(robber));\n    memset(dp,0x3f,sizeof(dp));\n\n    for(int road_idx=0;road_idx<total_roads;road_idx++){\n      int from,to;\n      int dist,robber_num;\n      scanf(\"%d %d %d %d\",&from,&to,&dist,&robber_num);\n      cost[from][to] = dist;\n      cost[to][from] = dist;\n      robber[from][to] = robber_num;\n      robber[to][from] = robber_num;\n    }\n\n    priority_queue<Princess,vector<Princess>,greater<Princess> > que;\n    que.push(Princess(1,total_money,0));\n    \n\n    while(!que.empty()){\n      Princess pr = que.top();\n      int from = pr.pos;\n      int remaining_money = pr.money;\n      int attacked_count = pr.attacked_count;\n      que.pop();\n\n      for(int to=2;to<=total_inns;to++){\n\tif(to == from) continue;\n\tif(cost[from][to] == INF) continue;\n\n\n\tif(cost[from][to] <= remaining_money){\n\t  //use_money\n\t  int next_atk = attacked_count;\n\t  int next_money = remaining_money - cost[from][to];\n\n\t  if(dp[to][next_money] > next_atk){\n\t    dp[to][next_money] = next_atk;\n\t    Princess next(to,next_money,next_atk);\n\t    que.push(next);\n\t  }\n\n\t  //dont use\n\t  int next_atk2 = attacked_count + robber[from][to];\n\t  int next_money2 = remaining_money;\n\n\t  if(dp[to][next_money2] > next_atk2){\n\t    dp[to][next_money2] = next_atk2;\n\t    Princess next2(to,next_money2,next_atk2);\n\t    que.push(next2);\n\t  }\n\t}\n\telse{\n\t  //dont use\n\t  int next_atk2 = attacked_count + robber[from][to];\n\t  int next_money2 = remaining_money;\n\n\t  if(dp[to][next_money2] > next_atk2){\n\t    dp[to][next_money2] = next_atk2;\n\t    Princess next2(to,next_money2,next_atk2);\n\t    que.push(next2);\n\t  }\n\t}\n      }\n    }\n\n    int res = INF;\n    for(int money=0;money<=100;money++){\n      res = min(res,dp[total_inns][money]);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n\nconst int INF = 1e9;\nint D[101][101];\nint E[101][101];\nint memo[101][101];\n\nint main() {\n\n\tint n, m, l;\n\n\twhile (cin >> n >> m >> l && n) {\n\n\t\trep(i, 101)rep(j, 101) {\n\t\t\tD[i][j] = INF;\n\t\t\tE[i][j] = 0;\n\t\t\tmemo[i][j] = INF;\n\t\t}\n\t\trep(i, m) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tD[a][b] = D[b][a] = d;\n\t\t\tE[a][b] = E[b][a] = e;\n\t\t}\n\t\tqueue<pair<int, int>> q;\n\t\tq.push(make_pair(1, l));\n\t\tmemo[1][l] = 0;\n\t\twhile (q.size()) {\n\t\t\tint now = q.front().first;\n\t\t\tint res = q.front().second;\n\t\t\tq.pop();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (D[now][i] != INF) {\n\t\t\t\t\tif (res - D[now][i] >= 0) {\n\t\t\t\t\t\tif (memo[i][res - D[now][i]] > memo[now][res]) {\n\t\t\t\t\t\t\tmemo[i][res - D[now][i]] = memo[now][res];\n\t\t\t\t\t\t\tq.push(make_pair(i, res - D[now][i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (memo[i][res] > memo[now][res] + E[now][i]) {\n\t\t\t\t\t\tmemo[i][res] = memo[now][res] + E[now][i];\n\t\t\t\t\t\tq.push(make_pair(i, res));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i <= l; i++) {\n\t\t\tans = min(ans, memo[n][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tto = cost = num = 0;\n\t}\n\tInfo(int arg_to,ll arg_cost,ll arg_num){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tnum = arg_num;\n\t}\n\tint to;\n\tll cost,num;\n};\n\nstruct Data{\n\tvoid set(ll arg_budget,ll arg_num_sum,int arg_town){\n\t\tbudget = arg_budget;\n\t\tnum_sum = arg_num_sum;\n\t\ttown = arg_town;\n\t}\n\tll budget,num_sum;\n\tint town;\n};\n\nint main(){\n\n\tint N,M,L,from,to,next_town,tmp_cost,tmp_num;\n\tll dist,num,ans;\n\tll dp[101][101];\n\n\tvector<Info> V[101];\n\n\tqueue<Data> Q;\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&L);\n\t\tif(N == 0 && M == 0 && L == 0)break;\n\n\t\tfor(int i = 1; i <= N; i++)V[i].clear();\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 0; k <= L; k++)dp[i][k] = BIG_NUM;\n\t\t}\n\n\t\tfor(int i = 1; i <= M; i++){\n\t\t\tscanf(\"%d %d %lld %lld\",&from,&to,&dist,&num);\n\t\t\tV[from].push_back(Info(to,dist,num));\n\t\t\tV[to].push_back(Info(from,dist,num));\n\t\t}\n\n\t\tData first;\n\t\tfirst.set(L,0,1);\n\t\tdp[1][L] = 0;\n\n\t\tQ.push(first);\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().town == N){\n\t\t\t\tQ.pop();\n\t\t\t}else if(Q.front().num_sum > dp[Q.front().town][Q.front().budget]){\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\n\t\t\t\tfor(int i = 0; i < V[Q.front().town].size(); i++){\n\t\t\t\t\tnext_town = V[Q.front().town][i].to;\n\t\t\t\t\ttmp_cost = V[Q.front().town][i].cost;\n\t\t\t\t\ttmp_num = V[Q.front().town][i].num;\n\n\t\t\t\t\tif(Q.front().budget >= tmp_cost && dp[next_town][Q.front().budget-tmp_cost] > dp[Q.front().town][Q.front().budget]){\n\t\t\t\t\t\tdp[next_town][Q.front().budget-tmp_cost] = dp[Q.front().town][Q.front().budget];\n\t\t\t\t\t\tData next;\n\t\t\t\t\t\tnext.set(Q.front().budget-tmp_cost,Q.front().num_sum,next_town);\n\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[next_town][Q.front().budget] > dp[Q.front().town][Q.front().budget]+tmp_num){\n\t\t\t\t\t\tdp[next_town][Q.front().budget] = dp[Q.front().town][Q.front().budget]+tmp_num;\n\t\t\t\t\t\tData next;\n\t\t\t\t\t\tnext.set(Q.front().budget,Q.front().num_sum+tmp_num,next_town);\n\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\n\t\tans = BIG_NUM;\n\t\tfor(int i = 0; i <= L; i++)ans = min(ans,dp[N][i]);\n\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_V 101\n#define MAX_E 10000\n#define INF 1e9\n \nint N, M, L;\nstruct edge{\n    int to, dist, enemy;\n    edge(int to, int dist, int enemy) : to(to), dist(dist), enemy(enemy) {}\n};\n \nstruct State{\n    int v, dist, l;\n    State(int v, int dist, int l) : v(v), dist(dist), l(l) {}\n \n    bool operator < (const State &s)const{\n\treturn dist > s.dist;\n    }\n};\n \nvector<edge> G[MAX_E];\nint d[MAX_V][MAX_V];\n \nint dijkstra(){\n    int res = INF;\n    priority_queue<State> Q;\n    fill(d[0], d[N], INF);\n    d[0][L] = 0;\n    Q.push(State(0,0,L));\n \n    while(!Q.empty()){\n\tState st = Q.top(); Q.pop();\n\tint v = st.v;\n \n\tif(v == N-1){\n\t    res = min(res, st.dist);\n\t    continue;\n\t}\n \n\tfor(int i = 0 ; i < (int)G[v].size() ; i++){\n\t    edge e = G[v][i];\n\t    if(d[e.to][st.l] > d[v][st.l] + e.enemy){\n\t\td[e.to][st.l] = d[v][st.l] + e.enemy;\n\t\tQ.push(State(e.to, d[e.to][st.l], st.l));\n\t    }\n\t}\n\tfor(int i = 0 ; i < (int)G[v].size() ; i++){\n\t    edge e = G[v][i];\n\t    if(st.l - e.dist >= 0 && d[e.to][st.l-e.dist] > d[v][st.l]){\n\t\td[e.to][st.l-e.dist] = d[v][st.l];\n\t\tQ.push(State(e.to, d[e.to][st.l-e.dist], st.l-e.dist));\n\t    }\n\t}\n    }\n    return res;\n}\n \nint main(){\n    int a, b, d, e;\n    while(cin >> N >> M >> L, (N | M | L)){\n\tfor(int i = 0 ; i < MAX_E ; i++){\n\t    G[i].clear();\n\t}\n\tfor(int i = 0 ; i < M ; i++){\n\t    cin >> a >> b >> d >> e;\n\t    a--, b--;\n\t    G[a].push_back(edge(b,d,e));\n\t    G[b].push_back(edge(a,d,e));\n\t}\n\tcout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct inn{\n\tint n,c,r;\n\tinn(int n,int c,int r):n(n),c(c),r(r){}\n\tbool operator<(const inn& other)const{\n\t\treturn r<other.r;\n\t}\n};\nconst int MAX=INT_MAX/10;\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n){\n\t\tvvi dist(n,vi(n,-1));\n\t\tvvi risk(n,vi(n,-1));\n\t\tREP(i,m){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\tdist[a-1][b-1]=d;\n\t\t\tdist[b-1][a-1]=d;\n\t\t\trisk[a-1][b-1]=e;\n\t\t\trisk[b-1][a-1]=e;\n\t\t}\n\t\t\n\t\tpriority_queue<inn> q;\n\t\tq.push(inn(0,0,0));\n\t\tvvi cost(n,vi(l+1,MAX));\n\t\tcost[0][0]=0;\n\t\twhile(!q.empty()){\n\t\t\tinn in=q.top();q.pop();\n\t\t\tif(cost[in.n][in.c]<in.r){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(i,n){\n\t\t\t\tif(i!=in.n&&dist[in.n][i]!=-1){\n\t\t\t\t\tREP(j,2){\n\t\t\t\t\t\tint nr=in.r+(j==1?0:risk[in.n][i]);\n\t\t\t\t\t\tint nc=in.c+(j==0?0:dist[in.n][i]);\n\t\t\t\t\t\tif(nc<=l&&cost[i][nc]>nr){\n\t\t\t\t\t\t\tcost[i][nc]=nr;\n\t\t\t\t\t\t\tq.push(inn(i,nc,nr));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint best=INT_MAX;\n\t\tREP(i,l+1){\n\t\t\tbest=min(best,cost[n-1][i]);\n\t\t}\n\t\tcout<<best<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct edge{\n    int to, dist, attack;\n};\n\nstruct P {\n    int from, money, enemy;\n\n    bool operator >(const P& p) const {\n        return enemy > p.enemy;\n    }\n};\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nint N, M, L;\n\nint main() {\n    while (cin >> N >> M >> L, N|M|L) {\n        vector<vector<edge>> E(N+1);\n        REP(i, M) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            E[from].push_back((edge){to, dist, enemy});\n            E[to].push_back((edge){from, dist, enemy});\n        }\n\n        bool G[N+1][L+1];\n        fill_n((bool *)G, (N+1)*(L+1), false);\n\n        priority_queue<P, vector<P>, greater<P>> q;\n        // start\n        q.push((P){1, L, 0});\n        int enemy = 0;\n        while (!q.empty()) {\n            P p = q.top(); q.pop();\n            // goal\n            if (p.from == N) {\n                enemy = p.enemy;\n                break;\n            }\n            if (G[p.from][p.money]) continue;\n            G[p.from][p.money] = true;\n            for (edge e : E[p.from]) {\n                if (p.money >= e.dist) {\n                    q.push((P){e.to, p.money - e.dist, p.enemy});\n                }\n                q.push((P){e.to, p.money, p.enemy + e.attack});\n            }\n        }\n\n        cout << enemy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nbool operator==(const State& lhs, const State& rhs)\n{\n    return lhs.loc == rhs.loc && lhs.money == rhs.money && lhs.damage == rhs.damage;\n}\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<vector<int>> memo(101, vector<int>(101, 0));\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (memo[current.loc][current.money]) {\n                continue;\n            }\n            memo[current.loc][current.money] = 1;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (0 <= current.money - e.dist) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct inn{\n\tint n,c,r;\n\tinn(int n,int c,int r):n(n),c(c),r(r){}\n\tbool operator<(const inn& other)const{\n\t\treturn r<other.r;\n\t}\n};\nconst int MAX=INT_MAX/10;\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n){\n\t\tvvi dist(n,vi(n,-1));\n\t\tvvi risk(n,vi(n,MAX));\n\t\tREP(i,m){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\tdist[a-1][b-1]=d;\n\t\t\tdist[b-1][a-1]=d;\n\t\t\trisk[a-1][b-1]=e;\n\t\t\trisk[b-1][a-1]=e;\n\t\t}\n\t\t\n\t\tpriority_queue<inn> q;\n\t\tq.push(inn(0,0,0));\n\t\tvvi cost(n,vi(l+1,MAX));\n\t\tcost[0][0]=0;\n\t\twhile(!q.empty()){\n\t\t\tinn in=q.top();q.pop();\n\t\t\tif(cost[in.n][in.c]<in.r){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(i,n){\n\t\t\t\tif(i!=in.n&&dist[in.n][i]!=-1){\n\t\t\t\t\tREP(j,2){\n\t\t\t\t\t\tint nr=in.r+(j==1?0:risk[in.n][i]);\n\t\t\t\t\t\tint nc=in.c+(j==0?0:dist[in.n][i]);\n\t\t\t\t\t\tif(nc<=l&&cost[i][nc]>nr){\n\t\t\t\t\t\t\tcost[i][nc]=nr;\n\t\t\t\t\t\t\tq.push(inn(i,nc,nr));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint best=INT_MAX;\n\t\tREP(i,l+1){\n\t\t\tbest=min(best,cost[n-1][i]);\n\t\t}\n\t\tcout<<best<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\n//int checker[4];\n//int ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\t//int check[4];\n\tState() {}\n\t//\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\t/*\n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t\t*/\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n/*\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n*/\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min = b;\n\t\twhile ( itr != points[i].end() ) {\n\t\t\tif ( (*itr).second > min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t} else if ( (*itr).second <= min ) {\n\t\t\t\t(*itr).second = min;\n\t\t\t}\n\t\t\tmin++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t/*\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\t*/\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\t//ncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//copy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t/*\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n//\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef pair <int,pair <int,int> > P;\n#define dis first\n#define node second.first\n#define mo second.second\n#define INF 1000000000;\nint N,M,L;\npair <int,int> mp[101][101];\n \nP mk(int a,int b, int c){\n  P res;\n  res.dis = a, res.node = b; res.mo = c;\n  return res;\n}\n \nint dijkstra(){\n  priority_queue < P, vector<P>, greater<P> > Q;\n  int D[101][101],visited[101][101]={};\n  for(int i=0;i<=L;i++)\n    for(int j=0;j<=N;j++) D[i][j] = INF;\n  Q.push(mk(0,1,0)),  D[0][1] = 0;\n \n  while(!Q.empty()) {\n    P t = Q.top(); Q.pop();\n    if(visited[t.mo][t.node] != 0) continue;\n    visited[t.mo][t.node] = 1;\n    if(t.node == N) return t.dis;\n \n    for(int i=1;i<=N;i++){\n      if(mp[t.node][i].first == -1) continue;\n      int nmo = t.mo+mp[t.node][i].first;\n      int ndis = t.dis + mp[t.node][i].second;\n      if(nmo <=L && D[nmo][i] > t.dis )Q.push(mk(t.dis,i,nmo));\n      if(D[t.mo][i] > ndis ) Q.push(mk(ndis,i,t.mo));\n    }\n  }\n  return -1;   \n}\n \nint main() {\n \n  while(1) {\n  cin >> N >> M >> L;\n  if(N==0 && M==0 && L==0) break;\n  for(int i=0;i<=N;i++)\n    for(int j=0;j<=N;j++) mp[i][j].first= -1;\n \n  for(int i=0;i<M;i++){\n    int x,y,z,w;\n    cin >> x >> y >> z >> w;\n    mp[x][y].first = z,mp[x][y].second = w;\n    mp[y][x].first = z,mp[y][x].second = w;\n  }\n  cout << dijkstra() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\nvector<pa3> G[133];\nbool sumi[133][124];\npriority_queue<pa3,vector<pa3>,greater<pa3>> pq; \nvoid solve(){\n\tint n,m,l;\n\tcin>>n>>m>>l;\n\tif(n==0 && m==0) exit(0);\n\tfor(int i=1;i<=n;i++){\n\t\tG[i].clear();\n\t\tfor(int ii=0;ii<120;ii++)sumi[i][ii]=0;\n\t}\n\t\n\tfor(int i=0;i<m;i++){\n\t\tint y,yy,dd,ee;\n\t\t\n\t\tcin>>y>>yy>>dd>>ee;\n\t\t\tG[y].pb({yy,dd,ee});\n\t\t\tG[yy].pb({y,dd,ee});\n\t}\n\twhile(pq.size()){\n\t\tpq.pop();\n\t}\n\t\t\tpq.push({0,1,l});\n\twhile(pq.size()){\n\t\tauto z=pq.top();\n\t\tpq.pop();\n\t\tif(sumi[z.y][z.z])continue;\n\t\tsumi[z.y][z.z]=1;\n\t\t//cout<<z.y<<\" \"<<z.z<<\"   \"<<z.x<<endl;\n\t\tif(z.y==n){\n\t\t\tcout<<z.x<<endl;\n\t\t\treturn;\n\t\t}\n\t\tfor(auto v:G[z.y]){\n\t\t//\tcout<<\"  \"<<z.x<<\" \"<<v.z<<endl;\n\t\t\t\tpq.push({z.x+v.z,v.x,z.z});\n\t\t\tif(z.z>=v.y){\n\t\t\t\tpq.push({z.x,v.x,z.z-v.y});\n\t\t\t}\n\t\t}\n\t\n\t}\n\tprintf(\"Impossible\\n\");\n//\tcout<<\"Impossible\"<<endl;\n\treturn ;\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \n \twhile(1){\n \t\tsolve();\n \t}\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int from;\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    if(a.enemy==b.enemy){\n        return a.money < b.money;\n    }else {\n        return a.enemy > b.enemy;\n    }\n}\n\nstruct node maps[100];\n\nint main()\n{\n    int n,m,l;\n\n    while ((cin>>n>>m>>l) && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            a--;\n            b--;\n            maps[a].data.push_back((struct data){b,d,e});\n            maps[b].data.push_back((struct data){a,d,e});\n        }\n        queue.push((struct state){0,0,l,0});\n        while (!queue.empty()){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                cout<<s.enemy<<endl;\n                while (!queue.empty()){\n                    queue.pop();\n                }\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.to!=s.from) {\n                        if (d.dis <= s.money) {\n                            queue.push((struct state) {s.number, d.to, s.money - d.dis, s.enemy});\n                        }\n                        queue.push((struct state) {s.number, d.to, s.money, s.enemy + d.ene});\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX 100\n#define INFTY (1<<21)\n#define rep(i, n) for ( int i = 0; i < n; i++)\nint N, M, L, D[MAX][MAX], E[MAX][MAX];\n\nint dijkstra(){\n    int cost[MAX][MAX+1];\n    bool visited[MAX][MAX+1];\n    rep(i, N) rep(j, L+1){\n\tcost[i][j] = INFTY;\n\tvisited[i][j] = false;\n    }\n    cost[0][L] = 0;\n    \n    while(1){\n\tpair<int, int> u;\n\tint minv = INFTY;\n\trep(i, N) rep(j, L+1){\n\t    if ( !visited[i][j] && minv > cost[i][j] ){\n\t\tu = make_pair(i, j);\n\t\tminv = cost[i][j];\n\t    }\n\t}\n\tif ( minv == INFTY ) break;\n\tvisited[u.first][u.second] = true;\n\tif ( u.first == N-1 ) return cost[u.first][u.second];\n\tfor ( int v = 0; v < N; v++ ){\n\t    if ( D[u.first][v] == INFTY ) continue;\n\t    if ( !visited[v][u.second] ){\n\t\tcost[v][u.second] = min(cost[v][u.second], cost[u.first][u.second] + E[u.first][v]);\n\t    }\n\t    if ( u.second < D[u.first][v] ) continue;\n\t    int l = u.second - D[u.first][v];\n\t    if ( visited[v][l] ) continue;\n\t    cost[v][l] = min(cost[v][l], cost[u.first][u.second]);\n\t}\n    }\n}\n\nmain(){\n    int s, t, d, e;\n    while( cin >> N >> M >> L && N ){\n\trep(i, N) rep(j, N){ D[i][j] = INFTY; E[i][j] = 0; }\n\trep(i, M){\n\t    cin >> s >> t >> d >> e; s--; t--;\n\t    D[s][t] = D[t][s] = d;\n\t    E[s][t] = E[t][s] = e;\n\t}\n\tcout << dijkstra() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF (1<<9)\n\nstruct P {\n    int from, money, damage;\n\n    bool operator >(const P& p) const {\n        return damage > p.damage;\n    }\n};\n\nstruct edge {\n    int from, cost, damage;\n};\n\nint main() {\n    int town_n, road_n, money;\n    while (cin >> town_n >> road_n >> money, town_n|road_n|money) {\n        vector<vector<edge>> E(town_n+1);\n        REP(i, road_n) {\n            int to, from, cost, damage;\n            cin >> to >> from >> cost >> damage;\n            E[to].push_back({from, cost, damage});\n            E[from].push_back({to, cost, damage});\n        }\n\n        int G[town_n+1][money+1];\n        fill_n((int *)G, (town_n+1)*(money+1), INF);\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({1, money, 0});\n\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            if (p.from == town_n) {\n                cout << p.damage << endl;\n                break;\n            }\n\n            if (G[p.from][p.money] > p.damage) {\n                G[p.from][p.money] = p.damage;\n                for (edge e : E[p.from]) {\n                    if (p.money >= e.cost) {\n                        que.push({e.from, p.money - e.cost, p.damage});\n                    }\n                    que.push({e.from, p.money, p.damage + e.damage});\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nint n;\nint dist[101][101];\nint atk[101][101];\nint memo[101][101]; //memo[i][j] : ??????j??§?????????i???????????¨??????????°??\\???\\?????°\nconst int INF = 1000000000;\n\nstruct V{\n  int p,m;\n  V(int p,int m):p(p),m(m){}\n};\n\nbool operator < (const V& a,const V& b){\n  return memo[a.p][a.m] > memo[b.p][b.m];\n}\n\nint solve(int s,int l){\n  for(int i=0;i<=100;++i)\n    for(int j=0;j<=100;++j)\n      memo[i][j]=INF;\n  memo[s][l] = 0;\n  priority_queue<V> Q;\n  Q.push(V(s,l));\n\n  while(!Q.empty()){\n    V x=Q.top(); Q.pop();\n    int cur = x.p, mon = x.m, cst=memo[cur][mon];\n    for(int i=0;i<n;++i){\n      if(dist[cur][i]){\n\tif(cst+atk[cur][i] < memo[i][mon]){\n\t  memo[i][mon] = cst+atk[cur][i];\n\t  Q.push(V(i,mon));\n\t}\n\tif(mon-dist[cur][i]>=0){\n\t  if(memo[i][mon-dist[cur][i]] > cst){\n\t    memo[i][mon-dist[cur][i]] = cst;\n\t    Q.push(V(i,mon-dist[cur][i]));\n\t  }\n\t}\n      }\n    }\n  }\n\n  int ret = INF;\n  for(int i=0;i<=l;++i) ret = min(ret, memo[n-1][i]);\n  return ret;\n}\nint main(){\n  int m,l;\n  while(cin>>n>>m>>l,n||m||l){\n    memset(dist,0,sizeof(dist));\n    memset(atk,0,sizeof(atk));\n    while(m--){\n      int a,b,d,e;\n      cin >> a >> b >> d >> e;\n      a--;b--;\n      dist[a][b] = dist[b][a] = d;\n      atk[a][b] = atk[b][a] = e;\n    }\n    cout<<solve(0,l)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nstruct edge {\n    int to;\n    int cost;\n    int numOfTheaf;\n};\n\nstruct info {\n    int now;\n    int sumOfCost;\n    int sumOfTheaf;\n    bool operator < (const info &o) const {\n        return  sumOfTheaf > o.sumOfTheaf;\n    }\n};\n\nint main() {\n    int n, m, l;\n    while (cin >> n >> m >> l, n) {\n        vector <vector <edge> > G(n);\n        rep (i, m) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--; b--;\n            G[a].push_back({b, d, e});\n            G[b].push_back({a, d, e});\n        }\n        //       to, sumOfCost -> sumOfTheaf\n        int dist[110][110] = {};\n        rep (i, 110) rep (j, 110) dist[i][j] = 1e9;\n        bool used[110][110][110] = {};\n        //bool used[110][110] = {};\n\n        //info -> now, sumOfCost, sumOfTheaf\n        priority_queue <info> que;\n        que.push({0, 0, 0});\n\n        dist[0][0] = 0;\n\n        while (!que.empty()) {\n            info tmp = que.top(); que.pop();\n            //cout << tmp.now << endl;\n            if ( used[tmp.now][tmp.sumOfCost][tmp.sumOfTheaf] ) continue;\n            used[tmp.now][tmp.sumOfCost][tmp.sumOfTheaf] = true;\n            rep (i, G[tmp.now].size()) {\n                //護衛を雇わない場合\n                {\n                    if ( dist[G[tmp.now][i].to][tmp.sumOfCost] > dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf ) {\n                         dist[G[tmp.now][i].to][tmp.sumOfCost] = dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf;\n                         que.push({G[tmp.now][i].to, tmp.sumOfCost, dist[G[tmp.now][i].to][tmp.sumOfCost]});\n                    }\n                }\n                //護衛を雇う場合\n                {\n                //お金こえちゃだめ\n                    if ( G[tmp.now][i].cost + tmp.sumOfCost > l ) continue;\n                    if ( dist[G[tmp.now][i].to][tmp.sumOfCost + G[tmp.now][i].cost] > dist[tmp.now][tmp.sumOfCost] ) {\n                         dist[G[tmp.now][i].to][tmp.sumOfCost] = dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf;\n                        dist[G[tmp.now][i].to][tmp.sumOfCost + G[tmp.now][i].cost] = dist[tmp.now][tmp.sumOfCost];\n                        que.push({G[tmp.now][i].to, tmp.sumOfCost + G[tmp.now][i].cost, tmp.sumOfTheaf});\n                    }\n                }\n            }\n        }\n        int ans = 1e9;\n        rep (i, l + 1) ans = min(ans, dist[n - 1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nstruct State {\n  int v, c, rest;\n};\n\nbool operator<(const State &a, const State &b) {\n  return a.c > b.c;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n, m, l;\n  while(cin >> n >> m >> l, n) {\n    P cost[n][n];\n    rep(i, n)rep(j, n) cost[i][j] = P(INF, INF);\n    rep(i, m) {\n      int u, v, len, num;\n      cin >> u >> v >> len >> num; u--, v--;\n      cost[u][v] = cost[v][u] = P(len, num);\n    }\n\n    priority_queue<State> q;\n    q.push(State{0, 0, l});\n    bool visited[n][l + 1] = {};\n    int ans = 0;\n    while(!q.empty()) {\n      State s = q.top(); q.pop();\n\n      if (s.v == n - 1) {\n        ans = s.c;\n        break;\n      }\n\n      if (visited[s.v][s.rest]) continue;\n      else visited[s.v][s.rest] = true;\n\n      rep(i, n) {\n        if (cost[s.v][i] != P(INF, INF)) {\n          q.push(State{i, s.c + cost[s.v][i].se, s.rest});\n          if (cost[s.v][i].fi <= s.rest) q.push(State{i, s.c, s.rest - cost[s.v][i].fi});\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n/*\n12 11 55\n2 4 22 86\n4 9 72 80\n6 11 73 85\n7 8 93 98\n5 11 4 85\n8 10 20 41\n5 12 74 41\n6 7 3 9\n1 3 64 71\n2 10 27 43\n3 9 16 70\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n    \nusing namespace std;\n    \nint N, M, L;\n    \nstruct edge {\n    int to, distance, enemy;\n};\n    \nstruct P {\n    int from, money, enemy;\n    \n    bool operator >(const P& p) const {\n        return enemy > p.enemy;\n    }\n};\n \nstruct pair {\n    int money, enemy;\n}\n    \nint main() {\n    while (cin >> N >> M >> L, N|M|L) {\n        vector<vector<edge> > E(N);\n        int a, b, d, e;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> d >> e;\n            E[a-1].push_back({b, d, e});\n            E[b-1].push_back({a, d, e});\n        }\n    \n        priority_queue<P, vector<P>, greater<P>> q;\n        city arr[N];\n        for(int i = 0; i < N; i++) {\n            arr[i].money = 0;\n        }   \n        q.push((P){0, L, 0});\n        while(!q.empty()) {\n            P p = q.top(); q.pop();\n            // goal\n            if (p.from == N-1) {\n                cout << p.enemy << endl;\n                break;\n            }\n            if (p.money >= arr[p.from].money) {\n                arr[p.from].money = p.money;\n                arr[p.from].enemy = p.enemy;\n            } else if (p.enemy <= arr[p.from].enemy) {\n                continue;\n            }\n  \n            for (int i = 0; i < E[p.from].size() ; i++) {\n                edge e = E[p.from][i];\n                q.push((P){e.to-1, p.money, p.enemy+e.enemy});\n                if (p.money-e.distance >= 0) {\n                    q.push((P){e.to-1, p.money-e.distance, p.enemy});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXM 10000\n#define MAXL 110\n#define MAXN 110\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nstruct edge {\n    int to, dist, cost;\n};\n\nstruct state {\n    int pos, yosan, all_cost;\n};\n\nvector<edge> G[MAXN];\nint N, M, L;\n\nint dijkstra(void) {\n    int d[MAXN][MAXL];\n    for (int i = 1; i <= N; i++) \n        for (int j = 0; j <= L; j++)\n            d[i][j] = INF;\n\n    d[1][L] = 0;\n    state s; s.pos = 1; s.yosan = L; s.all_cost = 0;\n    queue<state> que;\n    que.push(s);\n    while (!que.empty()) {\n        state now = que.front(); que.pop();\n        if (d[now.pos][now.yosan] < now.all_cost) continue;\n        for (int i = 0; i < G[now.pos].size(); i++) {\n            edge e = G[now.pos][i];\n            // 雇わない\n            if (d[e.to][now.yosan] > now.all_cost + e.cost) {\n                d[e.to][now.yosan] = now.all_cost + e.cost;\n                state s; s.pos = e.to; s.yosan = now.yosan; s.all_cost = now.all_cost + e.cost;\n                que.push(s);\n            }\n            // 雇う\n            if (now.yosan >= e.dist && d[e.to][now.yosan-e.dist] > now.all_cost) {\n                d[e.to][now.yosan-e.dist] = now.all_cost;\n                state s; s.pos = e.to; s.yosan = now.yosan-e.dist; s.all_cost = now.all_cost;\n                que.push(s);\n            }\n        }\n    }\n    int ret = INF;\n    for (int i = 0; i <= L; i++) {\n        ret = min(ret, d[N][i]);\n    }\n    return ret;\n}\n\nint main(void) {\n    while (1) {\n        cin >> N >> M >> L;\n        if (N == 0 && M == 0 && L == 0) break;\n        for (int i = 0; i < MAXN; i++) G[i].clear();\n        for (int i = 0; i < M; i++) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            edge es; es.to = b; es.dist = d; es.cost = e;\n            G[a].push_back(es);\n            es.to = a; G[b].push_back(es);\n        }\n        cout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<array>\n\n#define fin cin\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nclass Input{\npublic:\n\tint a;\n\tint b;\n\tint d;\n\tint e;\n\tInput(int _a, int _b, int _d, int _e){\n\t\ta = _a;\n\t\tb = _b;\n\t\td = _d;\n\t\te = _e;\n\t}\n\tbool operator < (Input& other){\n\t\treturn (this->a < other.a);\n\t}\n\tbool operator > (Input& other){\n\t\treturn (this->a > other.a);\n\t}\n\n};\n\nconst int initnum = 10000000;\n\nstd::vector<Input> in_v{};\nstd::array<std::array<int, 100>, 100> cost;\n\nint main()\n{\n\t//std::ifstream fin(\"in.txt\");\n\t//cost[0].fill(0);\n\t//for(int i = 1; i < 100; i++)cost[i].fill(10000000);\n\n\twhile(true)\n\t{\n\t\tcost[0].fill(0);\n\t\t//cost[1].fill(0);\n\t\tfor(int i = 1; i < 100; i++)cost[i].fill(initnum);\n\t\n\t\tint n, m, l;\n\t\tfin >> n >> m >> l;\n\t\tif((n | m | l) == 0)break;\n\t\t//cout << n << \" \" << m << \" \" << l << endl;\n\t\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b, d, e;\n\t\t\tfin >> a >> b >> d >> e;\n\t\t\tin_v.push_back(Input(a-1, b-1, d, e));\n\t\t\tin_v.push_back(Input(b-1, a-1, d, e));\n\t\t}\n\t\tsort(in_v.begin(), in_v.end());\n\n\t\tstd::queue<Input> in_q;\n\t\tfor(auto in : in_v)in_q.push(in);\n\n\t\tin_v.clear();\n\t\tin_v.shrink_to_fit();\n\n\t\twhile(!in_q.empty())\n\t\t{\n\t\t\tInput tmp = in_q.front();\n\t\t\tin_q.pop();\n\n\t\t\tfor(int _cost = 0; _cost <= l; _cost++)\n\t\t\t{\n\n\t\t\t\tif(cost[tmp.a][_cost] == initnum)\n\t\t\t\t{\n\t\t\t\t\tin_q.push(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcost[tmp.b][_cost] = std::min(\n\t\t\t\t\tcost[tmp.b][_cost],\n\t\t\t\t\tstd::min(\n\t\t\t\t\t\t(_cost + tmp.d <= l ? (cost[tmp.a][_cost + tmp.d]) : initnum / 10),\n\t\t\t\t\t\tcost[tmp.a][_cost] + tmp.e\n\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\t\t\tfor(int i = 0; i <= l + 2; i++){\n\t\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\n\t\t}\n\t\tint min_cost = 10000000;\n\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tif(cost[n - 1][i] < min_cost)min_cost = cost[n - 1][i];\n\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t}\n\t\tcout << min_cost << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct A{\n\tint p,l,e;\n\tA(){}\n\tA(int a,int b,int c):p(a),l(b),e(c){}\n\tbool operator<(const A &a)const{return e>a.e;}\n};\nstruct Edge{\n\tint to,d,e;\n\tEdge(int a,int b,int c):to(a),d(b),e(c){}\n};\nvector<Edge> edge[100];\n\nint n,m,l;\n\nint cost[100][101];\nint dijkstra(){\n\tpriority_queue<A> pq;\n\tpq.push(A(0,l,0));\n\tfor(int i=0;i<n;i++)for(int j=0;j<=l;j++)cost[i][j]=1<<29;\n\tcost[0][l]=0;\n\twhile(!pq.empty()){\n\t\tA a=pq.top();\n\t\tpq.pop();\n\t\tif(cost[a.p][a.l]<a.e)continue;\n\t\tif(a.p==n-1)return a.e;\n\t\tvector<Edge> &e = edge[a.p];\n\t\tfor(int i=0;i<e.size();i++){\n\t\t\tif(e[i].d <= a.l){\n\t\t\t\tA b=A(e[i].to,a.l-e[i].d,a.e); \n\t\t\t\tif(b.e < cost[b.p][b.l]){\n\t\t\t\t\tcost[b.p][b.l]=b.e;\n\t\t\t\t\tpq.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tA b=A(e[i].to,a.l,a.e+e[i].e);\n\t\t\tif(b.e < cost[b.p][b.l]){\n\t\t\t\tcost[b.p][b.l]=b.e;\n\t\t\t\tpq.push(b);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\twhile(cin>>n>>m>>l,n|m|l){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint p,q,r,s;\n\t\t\tcin>>q>>p>>r>>s;\n\t\t\tp--;q--;\n\t\t\tedge[p].push_back(Edge(q,r,s));\n\t\t\tedge[q].push_back(Edge(p,r,s));\n\t\t}\n\t\tcout<<dijkstra()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);cout<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_const<decltype(l)>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline void assert_equal(T1 expected, T2 actual) { if (!(expected == actual)) { cerr << \"assertion fault: expected=\" << expected << \" actual=\" << actual << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_less(T1 actual, T2 threshold) { if (!(actual < threshold)) { cerr << \"assertion fault: \" << actual << \" < (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_eqless(T1 actual, T2 threshold) { if (!(actual <= threshold)) { cerr << \"assertion fault: \" << actual << \" <= (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream &o, const Vec& p) { o << '['; for (auto& e : p) o << e << ','; o << ']'; return o; }\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nclass GraphE {\npublic:\n    typedef int W_T;\n    struct Edge {\n        int u, v;\n        W_T value;\n        Edge(int from = 0, int to = 0, W_T value = 0) :u(from), v(to), value(value) {}\n        inline int to(int _v) const { return _v == v ? u : v; }\n    };\n    size_t n;\n    vector<vector<int>> vertex_to;\n    vector<Edge> edges;\n\n    GraphE(int n = 1) :n(n), vertex_to(n) { }\n\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n    void connect(int from, int to, W_T val = 0) {\n        vertex_to[(size_t)from].push_back((int)edges.size());\n        vertex_to[(size_t)to].push_back((int)edges.size());\n        edges.emplace_back(from, to, val);\n    }\n};\n\n\n//ll dp[101][101];\n\nvoid solve(int N, int M, int L) {\n\n    GraphE graph(N);\n    vector<pair<int, ll>> edgeval; // dist,nOfEnemy\n    edgeval.reserve(M);\n\n    repeat(i, M) {\n        int a, b, d, e;\n        scanner >> a >> b >> d >> e;\n        --a; --b;\n        graph.connect(a, b);\n        edgeval.emplace_back(d, ll(e));\n    }\n\n    //fill(dp[0], dp[101], ll(1e18));\n    vector<vector<ll>> dp(101);\n    repeat(i, N) dp[i].resize(L + 1, ll(1e18));\n\n    priority_queue<tuple<ll,ll,int>> pq;\n    dp[0][L] = 0;\n    pq.emplace(0,L,0);\n\n    ll best = 1e18;\n\n    while (!pq.empty()) {\n        ll enemy,money;\n        int idx;\n        tie(enemy,money,idx) = pq.top(); pq.pop();\n        enemy = -enemy;\n\n        if (idx == N - 1) {\n            minset(best, enemy);\n            continue;\n        }\n\n        if (enemy > dp[idx][money]) continue;\n        \n        for (int ei : graph.vertex_to[idx]) {\n            int d; ll e; int to;\n            tie(d, e) = edgeval[ei];\n            to = graph.edges[ei].to(idx);\n            if (money >= d && dp[to][money-d] > enemy) {\n                dp[to][money-d] = enemy;\n                pq.emplace(-(enemy), money - d, to);\n            }\n            if (dp[to][money] > enemy + e) {\n                dp[to][money] = enemy + e;\n                pq.emplace(-(enemy + e), money, to);\n            }\n        }\n    }\n    assert(best < ll(1e18));\n    printer << best << '\\n';\n}\n\n\nint main() {\n\n    int n, m, l;\n    while (scanner >> n >> m >> l, n != 0 || m != 0 || l != 0) {\n        solve(n, m, l);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nstatic const int INF = 1E8;\nstruct Edge{int A, B, D, E;};\nint N, M, L;\nint A, B, D, E;\nvector<Edge> g[111];\nint d[111][111];\nvector<int> tmp(3);\n\nint main()\n{\n  while(cin >> N >> M >> L, N){\n    rep(i, 111) g[i].clear();\n    rep(i, M){\n      cin >> A >> B >> D >> E;\n      g[A - 1].push_back((Edge){A - 1, B - 1, D, E});\n      g[B - 1].push_back((Edge){B - 1, A - 1, D, E});\n    }\n\n    rep(i, 111) rep(j, 111) d[i][j] = INF;\n    d[0][0] = 0;\n    priority_queue<vector<int>, vector<vector<int> >, greater<vector<int> > > que;\n    tmp[0] = 0,  tmp[1] = 0,  tmp[2] = 0;\n    que.push(tmp);\n    while(!que.empty()){\n      vector<int> top = que.top();  que.pop();\n      int cnt = top[0];\n      int cost = top[1];\n      int h = top[2];\n      //if(d[h][cost] < cnt) continue;\n      rep(i, g[h].size()){\n        Edge e = g[h][i];\n        tmp[2] = e.B;\n        if(cost <= L && d[e.B][cost] > cnt + e.E) {\n          d[e.B][cost] = cnt + e.E;\n          tmp[0] = cnt + e.E;\n          tmp[1] = cost;\n          que.push(tmp);\n        }\n        if(cost + e.D <= L && d[e.B][cost + e.D] > cnt){\n          d[e.B][cost + e.D] = cnt;\n          tmp[0] = cnt;\n          tmp[1] = cost + e.D;\n          que.push(tmp);\n        }\n      }\n    }\n    int res = INF;\n    rep(i, 111) res = min(res, d[N - 1][i]);\n    printf(\"%d\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n/*\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\t\t*/\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n/*\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\t\t*/\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min = b;\n\t\twhile ( itr != points[i].end() ) {\n\t\t\tif ( (*itr).second > min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t} else {\n\t\t\t\t(*itr).second = min+1;\n\t\t\t}\n\t\t\titr++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t\t\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\t\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n#define MAX_V 100\n#define MAX_B 100\n\nstruct edge{pii to;int cost;};\nvector<edge> G[MAX_V][MAX_B+1];\nint d[MAX_V][MAX_B+1];\n\nvoid dijkstra(pii s){\n    priority_queue< pair<int,pii>,vector<pair<int,pii>>,greater<pair<int,pii>> > que;\n    rep(i,MAX_V)rep(j,MAX_B+1)d[i][j]=INF;\n    d[s.first][s.second]=0;\n    que.push(make_pair(0,s));\n    \n    while(que.size()){\n        pair<int,pii> p=que.top();\n        que.pop();\n        \n        int v=p.second.first;\n        int b=p.second.second;\n        if(d[v][b]<p.first)continue;\n        \n        rep(i,G[v][b].size()){\n            edge e=G[v][b][i];\n            if(d[e.to.first][e.to.second]>d[v][b]+e.cost){\n                d[e.to.first][e.to.second]=d[v][b]+e.cost;\n                que.push(make_pair(d[e.to.first][e.to.second],e.to));\n            }\n        }\n    }\n}\n\nint main(){\n    int v,e,l;\n    while(cin>>v>>e>>l&&(v||e||l)){\n        rep(i,MAX_V)rep(j, MAX_B+1)G[i][j].clear();\n        rep(i,e){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            a--,b--;\n            rep(i,l){\n                G[a][i].pb(edge{pii(b,i),d});\n                if(i+c<=l)G[a][i].pb(edge{pii(b,i+c),0});\n            }\n            rep(i,l){\n                G[b][i].pb(edge{pii(a,i),d});\n                if(i+c<=l)G[b][i].pb(edge{pii(a,i+c),0});\n            }\n        }\n        \n        dijkstra(pii(0,0));\n        int ans = INF;\n        rep(i,l+1)ans = min(ans,d[v-1][i]);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#define INF 10000000\n#define MN 101\nusing namespace std;\ntypedef long long ll;\n\ntypedef struct P\n{\n\tint pos,mon,eve;\n\tbool operator <(const P &a)const{ return eve>a.eve;};\n}P;\ntypedef struct E{int to,cost,eve;}E;\n\nint N,M,L;\nint amb[MN][MN];\nvector<E> G[MN];\n\nint bfs(int s,int t,int y)\n{\n\tint r=INF;\n\tpriority_queue<P>Q;\n\tmemset(amb,0x7f,sizeof(amb));\n\tamb[s][y]=0;\n\tP p={s,y,0};\n\tQ.push(p);\n\tfor(;!Q.empty();)\n\t{\n\t\tp=Q.top();Q.pop();\n\t\tif(p.pos==t)\n\t\t{\n\t\t\tr=min(r,p.eve);\n\t\t\treturn p.eve;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<G[p.pos].size();i++)\n\t\t{;\n\t\t\tE np=G[p.pos][i];\n\t\t\tif(amb[np.to][p.mon]>p.eve+np.eve)//not gard\n\t\t\t{\n\t\t\t\tamb[np.to][p.mon]=p.eve+np.eve;\n\t\t\t\tP ins={np.to,p.mon,amb[np.to][p.mon]};\n\t\t\t\tQ.push(ins);\n\t\t\t}\n\t\t\tif(p.mon>=np.cost&&amb[np.to][p.mon-np.cost]>p.eve)//hire gard\n\t\t\t{\n\t\t\t\tamb[np.to][p.mon-np.cost]=p.eve;\n\t\t\t\tP ins={np.to,p.mon-np.cost,amb[np.to][p.mon-np.cost]};\n\t\t\t\tQ.push(ins);\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d%d\",&N,&M,&L),N+M+L;)\n\t{\n\t\tfor(int i=0;i<MN;i++)G[i].clear();\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tint s,t,l,e;\n\t\t\tscanf(\"%d%d%d%d\",&s,&t,&l,&e);\n\t\t\ts--;t--;\n\t\t\tE tmp={t,l,e};\n\t\t\tG[s].push_back(tmp);\n\t\t\ttmp.to=s;\n\t\t\tG[t].push_back(tmp);\n\t\t}\n\t\tprintf(\"%d\\n\",bfs(0,N-1,L));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct {\n\tint to;\n\tint D;\n\tint E;\n} Edge;\n\nclass State {\npublic:\n\n\tint now;\n\tint money;\n\tint damaged;\n\n\tState(int now, int money, int damaged) {\n\t\tthis->now = now;\n\t\tthis->money = money;\n\t\tthis->damaged = damaged;\n\t}\n\n};\n\nconst int INF  = 999999;\n\nvector<Edge> G[101];\n\nint d[101][101];\n\nint N, M, L;\n\nint toV(int n, int l) {\n\treturn n * L + l;\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N + M + L != 0) {\n\t\tqueue<State> q;\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tG[i].clear();\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint A, B, D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tEdge e { B, D, E };\n\t\t\tEdge e2 { A, D, E };\n\t\t\tG[A].push_back(e);\n\t\t\tG[B].push_back(e2);\n\t\t}\n\t\tq.push(State(1, L, 0));\n\t\twhile (!q.empty()){\n\t\t\tState s = q.front();\n\t\t\tq.pop();\n\t\t\tif (s.damaged > d[s.now][s.money]) continue;\n\t\t\td[s.now][s.money] = s.damaged;\n\t\t\t\n\t\t\tfor (Edge e : G[s.now])\n\t\t\t{\n\t\t\t\tq.push(State(e.to, s.money, s.damaged + e.E));\n\t\t\t\tif (s.money - e.D >= 0) {\n\t\t\t\t\tq.push(State(e.to, s.money - e.D, s.damaged));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = INF;\n\t\tfor (int i = 0; i <= L; i++) {\n\t\t\tm = min(m, d[N][i]);\n\t\t}\n\t\tcout << m << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct edge { int to, cost; };\n\nint N, M, L;\nint A[10000], B[10000], D[10000], E[10000];\n\nvector<edge> G[100]; // E\nvector<int> G1[100]; // D\n\nint d[100][101]; // to, restMoney\n\nint getNum(int to, int restMoney) {\n  return to * (L + 1) + restMoney;\n}\n\nP getP(int num) {\n  return P(num / (L + 1), num % (L + 1)); // to, restMoney\n}\n\nint dijkstra() {\n  for (int i = 0; i < N; i++)\n    for (int j = 0; j <= L; j++)\n      d[i][j] = INF;\n  for (int i = 0; i <= L; i++) d[0][i] = 0;\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, L));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    P temp = getP(p.second);\n    int v = temp.first;\n    int money = temp.second;\n    if (p.first > d[v][money]) continue;\n    for (int i = 0; i < G[v].size(); i++) {\n      edge e = G[v][i];\n      int length = G1[v][i];\n      if (d[e.to][money] > d[v][money] + e.cost) {\n        d[e.to][money] = d[v][money] + e.cost;\n        que.push(P(d[e.to][money], getNum(e.to, money)));\n      }\n      if (money >= length && d[e.to][money - length] > d[v][money]) {\n        d[e.to][money - length] = d[v][money];\n        que.push(P(d[e.to][money - length], getNum(e.to, money - length)));\n      }\n    }\n  }\n  int ans = INF;\n  for (int i = 0; i <= L; i++) ans = min(ans, d[N - 1][i]);\n  return ans;\n}\n\n\nint main(){\n  while (1) {\n    scanf (\"%d%d%d\", &N, &M, &L);\n    if (N == 0) break;\n    for(int i = 0; i < 100; i++) G[i].clear(), G1[i].clear();\n    for (int i = 0; i < M; i++) {\n      scanf(\"%d%d%d%d\", &A[i], &B[i], &D[i], &E[i]);\n      A[i]--; B[i]--;\n      edge e1, e2;\n      e1.to = B[i], e2.to = A[i], e1.cost = e2.cost = E[i];\n      G[A[i]].push_back(e1); G1[A[i]].push_back(D[i]);\n      G[B[i]].push_back(e2); G1[B[i]].push_back(D[i]);\n    }\n    printf(\"%d\\n\", dijkstra());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<vector>\n#include<functional>\n#include<algorithm>\n\nusing namespace std;\n\nint n,m,l;\nclass edge{\npublic:\n\tint t,d,e;\n\tedge(){}\n\tedge(int it,int id,int ie){\n\t\tt=it;\n\t\td=id;\n\t\te=ie;\n\t}\n};\n\nclass data{\npublic:\n\tint v,l,cost;\n\tdata(){}\n\tdata(int iv,int il,int icost){\n\t\tv=iv;\n\t\tl=il;\n\t\tcost=icost;\n\t}\n\n\tbool operator<(const data &d1)const{\n\t\treturn d1.cost<cost;\n\t}\n};\nvector<edge> G[101];\nint dp[101][101];\nint dijk(){\n\tpriority_queue<data> que;\n\tmemset(dp,-1,sizeof(dp));\n\tdp[1][l]=0;\n\tque.push(data(1,l,0));\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v][q.l]<q.cost)continue;\n\t\tif(q.v==n)return q.cost;\n\t\tdp[q.v][q.l]=q.cost;\n\t\tfor(int i=0;i<G[q.v].size();i++){\n\t\t\tedge e=G[q.v][i];\n\t\t\tif(e.d<=q.l){\n\t\t\t\tif(dp[e.t][q.l-e.d]>q.cost || dp[e.t][q.l-e.d]==-1){\n\t\t\t\t\tdp[e.t][q.l-e.d]=q.cost;\n\t\t\t\t\tque.push(data(e.t,q.l-e.d,q.cost));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[e.t][q.l]>q.cost+e.e || dp[e.t][q.l]==-1){\n\t\t\t\tdp[e.t][q.l]=q.cost+e.e;\n\t\t\t\tque.push(data(e.t,q.l,q.cost+e.e));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&n,&m,&l);\n\t\tif(n+m+l==0)break;\n\t\tfor(int i=1;i<=n;i++)G[i].clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tscanf(\"%d %d %d %d\",&a,&b,&d,&e);\n\t\t\tG[a].push_back(edge(b,d,e));\n\t\t\tG[b].push_back(edge(a,d,e));\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <string>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <cinttypes>\n\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef int64_t ll;\ntypedef uint64_t ull;\n\nconst int INF = 1e9;\nconst double EPS = 1e-9;\n\ntypedef pair<int, int> P;\ninline P operator+(const P& p1, const P& p2) {\n  return P(p1.first + p2.first, p1.second + p2.second);\n}\n\n\nint main() {\n  static int dp[101][101]; // ??????????????? = ?\\???????????????°\n  \n  while (true) {\n    int N, M, L;\n    cin >> N >> M >> L;\n    if (N + M + L == 0) {\n      break;\n    }\n    \n    struct Edge {\n      int to;\n      int length;\n      int threat;\n\n      Edge(int to, int length, int threat):\n        to(to), length(length), threat(threat) { }\n    };\n\n    vector<Edge> G[101];\n    for (int i = 0; i < M; i++) {\n      int A, B, D, E;\n      cin >> A >> B >> D >> E;\n      G[A].push_back(Edge(B, D, E));\n      G[B].push_back(Edge(A, D, E));\n    }\n\n    for (int i = 1; i <= N; i++) {\n      for (int j = 0; j <= L; j++) {\n        dp[i][j] = INF;\n      }\n    }\n    dp[1][0] = 0;\n    \n    struct Search {\n      int v;\n      int cost;\n      Search(int v, int cost): v(v), cost(cost) { }\n    };\n\n    queue<Search> que;\n    que.push(Search(1, 0));\n    \n    while (!que.empty()) {\n      Search s = que.front();\n      que.pop();\n      for (Edge e : G[s.v]) {\n        int u = e.to;\n        // ????????????\n        if (dp[u][s.cost] > dp[s.v][s.cost] + e.threat) { \n          dp[u][s.cost] = dp[s.v][s.cost] + e.threat;\n          que.push(Search(u, s.cost));\n        }\n        // ??????\n        if (s.cost + e.length <= L) { \n          if (dp[u][s.cost + e.length] > dp[s.v][s.cost]) {\n            dp[u][s.cost + e.length] = dp[s.v][s.cost];\n            que.push(Search(u, s.cost + e.length));\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int i = 0; i <= L; i++) {\n      ans = min(ans, dp[N][i]);\n    }\n    cout << ans << endl;\n   \n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<vector>\n#include<map>\nusing namespace std;\n#define fr first\n#define sc second\n#define INFTY 1000000\ntypedef pair< int,int > iiP;\ntypedef pair< int,iiP > P;\n//盗賊の人数 , 場所 , カネ\nstruct edge{\n  int to,kyori,people;\n  edge(){}\n  edge(int to,int kyori,int people):to(to),kyori(kyori),people(people){};\n};\nint N,M,L;\nint min_people[101][101];\n//場所 , カネ\nvector< vector<edge> > info;\nint dijkstra();\nint main(){\n  while(cin >> N >> M >> L && (N||M||L)){\n      info.resize(N + 1);\n      for(int i=0,a,b,d,e;i<M;i++){\n\tcin >> a >> b >> d >> e;\n\tinfo[a].push_back(edge(b,d,e));\n\tinfo[b].push_back(edge(a,d,e));\n      }\n      cout << dijkstra() << endl;\n      info.clear();\n    }\n}\nint dijkstra(){\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++){\n      min_people[i][j] = INFTY;\n    }\n  }\n  \n   priority_queue< P,vector<P>,greater<P> > que;\n  que.push(P(0,iiP(1,L)));\n\n  while(!que.empty()){\n    P p = que.top();\n    int peop = p.fr , now = p.sc.fr , money = p.sc.sc ;\n    que.pop();\n    if( now == N ) return peop;\n    if( peop > min_people[now][money]) continue;\n    for(int i=0;i<info[now].size();i++){\n      edge e = info[now][i];\n      if ( peop < min_people[e.to][money - e.kyori] && money >= e.kyori){ //やとってみよ\n\tmin_people[e.to][money - e.kyori] = peop;\n\tque.push(P(peop,iiP(e.to,money-e.kyori)));\n      }\n      if( peop + e.people < min_people[e.to][money]){ //やとうのヤダ\n\tmin_people[e.to][money] = peop + e.people;\n\tque.push(P(min_people[e.to][money],iiP(e.to,money)));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n/*\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\t\t*/\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n/*\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\t\t*/\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min = b;\n\t\twhile ( itr != points[i].end() ) {\n\t\t\tif ( (*itr).second > min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t} else {\n\t\t\t\t(*itr).second = min;\n\t\t\t}\n\t\t\titr++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t\t\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\t\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct NODE{\n  vector<int> to_node;\n  vector<int> to_cost;\n  vector<int> to_man;\n  bool done_c;\n  bool done_m;\n  bool start;\n  int cost;\n  int man;\n  int nom;\n};\nint main(){\n  int n,m,l;\n  while(cin >>n>>m>>l,n|m|l){\n    NODE inn[100];\n    vector<int> ans;\n    while(m--){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      inn[a-1].to_node.push_back(b-1);\n      inn[a-1].to_cost.push_back(c);\n      inn[a-1].to_man.push_back(d);\n      inn[b-1].to_node.push_back(a-1);\n      inn[b-1].to_cost.push_back(c);\n      inn[b-1].to_man.push_back(d);\n    }\n    for(int i=0; i<n; i++){\n      inn[i].start = false;\n      inn[i].nom = 20000000;\n    }\n    inn[0].nom = 0;\n    for(int i=0; i<n; i++){\n      int at = 0,pom = 20000000;\n      for(int j=0; j<n; j++){\n\tif((!(inn[j].start)) && pom>inn[j].nom){at = j; pom = inn[j].nom;}\n      }\n      inn[at].start = true;\n      for(int j=0; j<inn[at].to_node.size(); j++){\n\tint togo = inn[at].to_node[j];\n\tif(!inn[togo].start){inn[togo].nom = min(inn[at].to_man[j] + inn[at].nom,inn[togo].nom);}\n      }\n    }\n    for(int k=0; k<n; k++){\n      for(int i=0; i<n; i++){\n\tinn[i].cost = 20000000;\n\tinn[i].done_c = false;\n      }\n      inn[k].cost = 0;\n      for(int i=0; i<n; i++){\n\tint at = 0,pom = 20000000;\n\tfor(int j=0; j<n; j++){\n\t  if((!(inn[j].done_c)) && pom>inn[j].cost){at = j; pom = inn[j].cost;}\n\t}\n\tinn[at].done_c = true;\n\tfor(int j=0; j<inn[at].to_node.size(); j++){\n\t  int togo = inn[at].to_node[j];\n\t  if(!inn[togo].done_c){inn[togo].cost = min(inn[at].to_cost[j] + inn[at].cost,inn[togo].cost);}\n\t}\n      }\n      for(int i=0; i<n; i++){\n\tinn[i].man = 20000000;\n\tinn[i].done_m = false;\n      }\n      inn[k].cost = 0;\n      for(int i=0; i<n; i++){\n\tint at = 0,pom = 20000000;\n\tfor(int j=0; j<n; j++){\n\t  if((!(inn[j].done_m)) && pom>inn[j].man){at = j; pom = inn[j].man;}\n\t}\n\tinn[at].done_m = true;\n\tfor(int j=0; j<inn[at].to_node.size(); j++){\n\t  int togo = inn[at].to_node[j];\n\t  if(!inn[togo].done_m){inn[togo].man = min(inn[at].to_man[j] + inn[at].man,inn[togo].man);if(inn[togo].cost<=l){inn[togo].man = 0;}}\n\t}\n      }\n      ans.push_back(inn[k].nom + inn[n-1].man);\n    }\n    sort(ans.begin(),ans.end());\n    cout <<ans[0]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n  \nusing namespace std;\n  \nint N, M, L;\n  \nstruct edge {\n    int to, distance, enemy;\n};\n  \nstruct P {\n    int from, money, enemy;\n  \n    bool operator >(const P& p) const {\n        return enemy > p.enemy;\n    }\n};\n\nstruct edge {\n    int to, distance, enemy;\n};\n  \nint main() {\n    while (cin >> N >> M >> L, N|M|L) {\n        vector<vector<edge> > E(N);\n        int a, b, d, e;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> d >> e;\n            E[a-1].push_back({b, d, e});\n            E[b-1].push_back({a, d, e});\n        }\n  \n        priority_queue<P, vector<P>, greater<P>> q;\n        city arr[N];\n        for(int i = 0; i < N; i++) {\n            arr[i].money = 0;\n        }   \n        q.push((P){0, L, 0});\n            while(!q.empty()) {\n            P p = q.top(); q.pop();\n            // goal\n            if (p.from == N-1) {\n                cout << p.enemy << endl;\n                break;\n            }\n            if (p.money >= arr[p.from].money) {\n                arr[p.from].money = p.money;\n                arr[p.from].enemy = p.enemy;\n            } else if (p.enemy <= arr[p.from].enemy) {\n                continue;\n            }\n\n            for (int i = 0; i < E[p.from].size() ; i++) {\n                edge e = E[p.from][i];\n                q.push((P){e.to-1, p.money, p.enemy+e.enemy});\n                if (p.money-e.distance >= 0) {\n                    q.push((P){e.to-1, p.money-e.distance, p.enemy});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n\nclass E{\npublic:\n  int to,dist,value;\n  E(int to,int dist,int value):to(to),dist(dist),value(value){}\n};\n\nconst int N = 111;\n\nint n,m,r;\nvector<E> edge[N];\n\nbool input(){\n  cin>>n>>m>>r;\n  if(n==0)return false;\n\n  rep(i,N)edge[i].clear();\n\n  rep(i,m){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    edge[a].push_back(E(b,c,d));\n    edge[b].push_back(E(a,c,d));\n  }\n\n  \n  return true;\n}\n\n\n\nclass Q{\npublic:\n  int pos;\n  int life;\n  int val;\n  Q(int a,int b,int c):pos(a),life(b),val(c){}\n  bool operator<(const Q& a)const{\n    if(val!=a.val) return val>a.val;\n    return life<a.life;\n  }\n};\n\nint visit[N][N];\n\nint solve(){\n  rep(i,N)rep(j,N)visit[i][j]=0;\n  //puts(\"hello\");\n\n  priority_queue<Q> que;\n  que.push(Q(1,r,0));\n\n  int ans = -1;\n  while(!que.empty()){\n    priority_queue<Q> cp = que;\n\n\n    Q u = que.top();\n    que.pop();\n\n    //printf(\"@@ %d %d %d   %d\\n\",u.pos,u.life,u.val, que.size());\n\n    if(visit[u.pos][u.life]==1)continue;\n    visit[u.pos][u.life]=1;\n\n    //printf(\"** %d %d %d\\n\",u.pos,u.life,u.val);\n\n    if(u.pos==n){\n      if(ans==-1 || ans>u.val)ans=u.val;\n      return u.val;\n    }\n\n    rep(i,edge[u.pos].size()){\n      E e = edge[u.pos][i];\n      if(u.life-e.dist>=0)que.push(Q(e.to, u.life-e.dist, u.val));\n      que.push(Q(e.to, u.life, u.val+e.value));\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(input())cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct E{\n\tint to, len, num;\n};\n\nint n, m, l;\nint cost[100][200];\nvector<E> edge[100];\n\nvoid solve(){\n\trep(i,100) rep(j,200) cost[i][j] = INF;\n\trep(i,100) edge[i].clear();\n\trep(i,m){\n\t\tint a, b, d, e;\n\t\tcin >> a >> b >> d >> e;\n\t\ta--; b--;\n\t\tedge[a].push_back((E){b,d,e});\n\t\tedge[b].push_back((E){a,d,e});\n\t}\n\tcost[0][l] = 0;\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(P(0,l));\n\twhile(true){\n\t\tif(que.size() == 0) break;\n\t\tP q = que.top();\n\t\tque.pop();\n\t\tint v = q.second/1000, co = q.second%1000;\n\t\trep(i,edge[v].size()){\n\t\t\tE e = edge[v][i];\n\t\t\tif(co >= e.len && cost[e.to][co-e.len] > cost[v][co]){\n\t\t\t\tcost[e.to][co-e.len] = cost[v][co];\n\t\t\t\tque.push(P(cost[e.to][co-e.len],e.to*1000+co-e.len));\n\t\t\t}\n\t\t\tif(cost[e.to][co] > cost[v][co]+e.num){\n\t\t\t\tcost[e.to][co] = cost[v][co]+e.num;\n\t\t\t\tque.push(P(cost[e.to][co],e.to*1000+co));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i,200) ans = min(ans,cost[n-1][i]);\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n >> m >> l;\n\t\tif(n==0&&m==0&&l==0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define fi first\n#define se second\n#define mkp make_pair\n\ntypedef pair<int,int> pii;\n\nint cost[110][110];\n\nstruct s {\n\tint l, p, c;\n\ts(){}\n\ts(int l_,int p_,int c_) {l=l_;p=p_;c=c_;}\n};\nbool operator<(const s & a, const s & b) {\n\tif(a.l != b.l) return a.l < b.l;\n\treturn a.c > b.c;\n}\n\nint main() {\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N || M || L) {\n\t\tvector<vector<pair<int,pii> > > G(N);\n\t\tfor(int i = 0; i < 110; i++) for(int j = 0; j < 110; j++) cost[i][j] = 1e9;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--; b--;\n\t\t\tG[a].push_back(mkp(b,pii(d,e)));\n\t\t\tG[b].push_back(mkp(a,pii(d,e)));\n\t\t}\n\t\tpriority_queue<s> q;\n\t\tq.push(s(L,0,0));\n\t\tcost[L][0] = 0;\n\t\twhile(q.size()) {\n\t\t\ts cur = q.top(); q.pop();\n\t\t\tif(cur.c > cost[cur.l][cur.p]) continue;\n\t\t\tfor(int i = 0; i < G[cur.p].size(); i++) {\n\t\t\t\tif(cost[cur.l][G[cur.p][i].fi] > cur.c + G[cur.p][i].se.se) {\n\t\t\t\t\tcost[cur.l][G[cur.p][i].fi] = cur.c + G[cur.p][i].se.se;\n\t\t\t\t\tq.push(s(cur.l, G[cur.p][i].fi, cost[cur.l][G[cur.p][i].fi]));\n\t\t\t\t}\n\t\t\t\tif(cur.l >= G[cur.p][i].se.fi && cost[cur.l-G[cur.p][i].se.fi][G[cur.p][i].fi] > cur.c) {\n\t\t\t\t\tcost[cur.l-G[cur.p][i].se.fi][G[cur.p][i].fi] = cur.c;\n\t\t\t\t\tq.push(s(cur.l-G[cur.p][i].se.fi, G[cur.p][i].fi, cur.c));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 1e9;\n\t\tfor(int i = 0; i <= L; i++) {\n\t\t\tres = min(res, cost[i][N-1]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<functional>\n#include<map>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = (LL)1e9*(LL)1e5;\n\ntypedef vector<LL> VLL;\ntypedef pair<LL, int> E;\ntypedef vector<list<E>> ADJ;\n#define mp(a,b) make_pair(a,b)\n#define cost(_v) _v.first\n#define to(_v) _v.second\nstruct edge{\n\tLL cost;\n\tLL enemy;\n};\nedge inf = { INF, INF };\ninline VLL dijkstra(int s, ADJ adj){\n\tint n = (int)adj.size();\n\tVLL res(n, -1);\n\tpriority_queue<E, vector<E>, greater<E>> que;\n\tque.push(mp(0ll, s));\n\twhile (que.empty() == false){\n\t\tauto tmp = que.top(); que.pop();\n\t\tauto c = cost(tmp);\n\t\tauto v = to(tmp);\n\t\tif (res[v] >= 0)continue;\n\t\tres[v] = c;\n\t\tfor (auto &i : adj[v]){\n\t\t\tauto d = cost(i);\n\t\t\tauto u = to(i);\n\t\t\tif (res[u] >= 0)continue;\n\t\t\tque.push(mp(c + d, u));\n\t\t}\n\t}\n\n\treturn res;\n};\n\n\nint main(){\n\twhile (1){\n\t\tint N, M, L;\n\t\tcin >> N >> M >> L;\n\t\tif (N + M + L == 0)return 0;\n\t\tvector<vector<LL>> dp(N + 1, vector<LL>(L + 1, INF));\n\t\tvector<vector<edge>> d(N + 1,vector<edge>(N + 1, inf));\n\t\tADJ adj(N + 1);\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint A, B ;\n\t\t\tLL D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\td[A][B].cost = d[B][A].cost = D;\n\t\t\td[A][B].enemy = d[B][A].enemy = E;\n\t\t\tadj[A].push_back(mp(E, B));\n\t\t\tadj[B].push_back(mp(E, A));\n\t\t}\n\t\tfor (int i = 1; i < N+1; i++){\n\t\t\td[i][i].cost =d[i][i].enemy = 0;\n\t\t}\n\t\tdp[1][0] = 0;\n\n\t\t\n\n\t\tfor (int l = 0; l < L; l++){\n\t\t\tif(l)for (int i = 1; i <= N; i++){\n\t\t\t\tdp[i][l] = min(dp[i][l], dp[i][l - 1]);\n\t\t\t}\n\t\t\tadj[1].clear();\n\t\t\tfor (int i = 2; i < N+1; i++){\n\t\t\t\tadj[1].push_back(mp(min(d[1][i].enemy,dp[i][l]), i));\n\t\t\t}\n\t\t\tauto ddd=dijkstra(1, adj);\n\t\t\tfor (int i = 1; i < N+1; i++){\n\t\t\t\tdp[i][l] = ddd[i];\n\t\t\t}\n\t\t\tfor (int i = 1; i <= N; i++){\n\t\t\t\tfor (int j = 1; j <= N; j++){\n\t\t\t\t\tif (l + d[i][j].cost>L)continue;\n\t\t\t\t\tdp[j][l + d[i][j].cost] = min(dp[i][l], dp[j][l + d[i][j].cost]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLL res = INF;\n\t\tfor (int i = 1; i < L+1; i++){\n\t\t\tres = min(res, dp[N][i]);\n\t\t}\n\t\t//cout << \"res:\";\n\t\tcout << res << endl;\n\n\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\t//\tState() {}\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min = b;\n\t\twhile ( itr != points[i].end() ) {\n\t\t\tif ( (*itr).second > min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t} else if ( (*itr).second <= min ) {\n\t\t\t\t(*itr).second = min;\n\t\t\t}\n\t\t\titr++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t\t\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nclass State {\npublic:\n\tint budget;\n\tint people;\n\tint wheres;\n\tState() {};\n\tState( int b, int p, int n ) { budget = b; people = p; wheres = n; };\n};\n\npriority_queue<State, vector<State>, greater<State> > status;\n//priority_queue<State> status;\n\nint map[101][101];\nint off[101][101];\n\nbool operator< (const State& a, const State& b)\n{\n\tif ( a.people == b.people )\n\t\treturn a.budget > b.budget;\n\treturn a.people < b.people;\n}\n\nbool operator> (const State& a, const State& b)\n{\n\tif ( a.people == b.people )\n\t\treturn a.budget < b.budget;\n\treturn a.people > b.people;\t\n}\n\nint main () {\n\n\twhile ( true ) {\n\t\tint  N,M,L;\n\n\t\tcin >> N >> M >> L;\n\n\t\tif ( N == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<=N; i++ ) {\n\t\t\tfor ( int j=0; j<=N; j++ ) {\n\t\t\t\tmap[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint a, b, d, e;\n\n\t\tfor ( int i=0; i<M; i++ ) {\n\t\t\tcin >> a >> b >> d>> e;\n\n\t\t\tmap[a][b] = d;\n\t\t\toff[a][b] = e;\n\t\t\tmap[b][a] = d;\n\t\t\toff[b][a] = e;\n\t\t}\n\n\n\t\tstatus.push(State(L, 0, 1));\n\t\tint ans;\n\t\tans = 10000000;\n\t\tbool have = false;\n\t\twhile( !status.empty() ) {\n\t\t\tState now;\n\t\t\tnow = status.top();\n\t\t\tstatus.pop();\n\t\t\t\n\t\t\tif ( now.people >= ans ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << now.budget<< \"\\t\";\n\t\t\tcout << now.people<< \"\\t\";\n\t\t\tcout << now.wheres<< endl;\n\t\t\t*/\n\t\t\tif ( now.wheres == N ) {\n\t\t\t\tif ( ans > now.people) {\n\t\t\t\t\thave = true;\n\t\t\t\t\tans = now.people;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor ( int i=1; i<=N; i++ ) {\n\t\t\t\t\tif ( i != now.wheres ) {\n\t\t\t\t\t\tif ( map[now.wheres][i] > 0 ) {\n\t\t\t\t\t\t\tif ( off[now.wheres][i] != 0 ) {\n\t\t\t\t\t\t\t\tif ( now.budget - map[now.wheres][i] >= 0 ) {\n\t\t\t\t\t\t\t\t\tstatus.push(State(now.budget-map[now.wheres][i],now.people,i));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstatus.push(State(now.budget,now.people+off[now.wheres][i],i));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstatus.push(State(now.budget,now.people,i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( ans == -1 )\n\t\t\tcout << \"No\" << endl;\n\t\telse\n\t\t\tcout << \"Ans: \" <<ans << endl;\n\t}\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);cout<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_const<decltype(l)>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline void assert_equal(T1 expected, T2 actual) { if (!(expected == actual)) { cerr << \"assertion fault: expected=\" << expected << \" actual=\" << actual << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_less(T1 actual, T2 threshold) { if (!(actual < threshold)) { cerr << \"assertion fault: \" << actual << \" < (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_eqless(T1 actual, T2 threshold) { if (!(actual <= threshold)) { cerr << \"assertion fault: \" << actual << \" <= (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream &o, const Vec& p) { o << '['; for (auto& e : p) o << e << ','; o << ']'; return o; }\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nclass GraphE {\npublic:\n    typedef int W_T;\n    struct Edge {\n        int u, v;\n        W_T value;\n        Edge(int from = 0, int to = 0, W_T value = 0) :u(from), v(to), value(value) {}\n        inline int to(int _v) const { return _v == v ? u : v; }\n    };\n    size_t n;\n    vector<vector<int>> vertex_to;\n    vector<Edge> edges;\n\n    GraphE(int n = 1) :n(n), vertex_to(n) { }\n\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n    void connect(int from, int to, W_T val = 0) {\n        vertex_to[(size_t)from].push_back((int)edges.size());\n        vertex_to[(size_t)to].push_back((int)edges.size());\n        edges.emplace_back(from, to, val);\n    }\n};\n\n\n//ll dp[101][101];\n\nvoid solve(int N, int M, int L) {\n\n    GraphE graph(N);\n    vector<pair<int, ll>> edgeval; // dist,nOfEnemy\n    edgeval.reserve(M);\n\n    repeat(i, M) {\n        int a, b, d, e;\n        scanner >> a >> b >> d >> e;\n        --a; --b;\n        graph.connect(a, b);\n        edgeval.emplace_back(d, ll(e));\n    }\n\n    //fill(dp[0], dp[101], ll(1e18));\n    vector<vector<ll>> dp(101);\n    repeat(i, N) dp[i].resize(L + 1, ll(1e18));\n\n    priority_queue<tuple<ll,ll,int>> pq;\n    dp[0][L] = 0;\n    pq.emplace(0,L,0);\n\n    ll best = 1e18;\n\n    while (!pq.empty()) {\n        ll enemy,money;\n        int idx;\n        tie(enemy,money,idx) = pq.top(); pq.pop();\n        enemy = -enemy;\n\n        if (idx == N - 1) {\n            minset(best, enemy);\n            continue;\n        }\n        \n        for (int ei : graph.vertex_to[idx]) {\n            int d; ll e; int to;\n            tie(d, e) = edgeval[ei];\n            to = graph.edges[ei].to(idx);\n            if (money >= d && dp[to][money-d] > enemy + e) {\n                dp[to][money-d] = enemy;\n                pq.emplace(-(enemy), money - d, to);\n            }\n            if (dp[to][money] > enemy + e) {\n                dp[to][money] = enemy + e;\n                pq.emplace(-(enemy + e), money, to);\n            }\n        }\n    }\n    printer << best << '\\n';\n}\n\n\nint main() {\n\n    int n, m, l;\n    while (scanner >> n >> m >> l, n != 0 || m != 0 || l != 0) {\n        solve(n, m, l);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#define INF 10e6;\nusing namespace std;\n\nint cost[101][101][2];  //0距離　1人数\nint check[101][101];\n\nint N,M,L;\n\nstruct node{\n\tint dis;\n\tint n;\n\tint cost;\n\tbool operator <(node a)const{\n    return dis < a.dis;\n  \t}\n\tbool operator >(node a)const{\n    return dis > a.dis;\n  \t}\n};\n\n\nint dijkstra(int g,int l){\n\tnode start;\n\tint ans;\n\tstart.dis=0,start.n=1,start.cost=l;\n\tpriority_queue < node,vector<node>, greater<node> > p;\n\tp.push(start);\n\twhile(!p.empty()){\n\t\tnode tmp=p.top();\n\t\tp.pop(); \n\t\tif(check[tmp.n][tmp.cost]<=tmp.dis)\n\t\t\tcontinue;\n\t\telse\n\t\t\tcheck[tmp.n][tmp.cost]=tmp.dis; \n\t\tif(tmp.n == g){\n\t\t\tans=tmp.dis;\n\t\t\treturn ans;\n\t\t}\n\t\tfor(int i=1;i<=g;i++){\n\t\t\tif(tmp.n == i)\n\t\t\t\tcontinue;\n\t\t\tnode next;\n\t\t\tnext.n=i;\n\t\t\tif(tmp.cost >= cost[tmp.n][i][0]){\n\t\t\t\tnext.cost=tmp.cost-cost[tmp.n][i][0];\n\t\t\t\tnext.dis=tmp.dis;\n\t\t\t\tp.push(next);\n\t\t\t}\n\t\t\tnext.cost=tmp.cost;\n\t\t\tnext.dis=tmp.dis+cost[tmp.n][i][1];\n\t\t\tp.push(next);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile (cin >> N >> M >> L,N|M|L){\n\t\tfor(int i=0;i<101;i++)\n\t\t\tfor(int j=0;j<101;j++)\n\t\t\t\tcheck[i][j]=cost[i][j][0]=cost[i][j][1]=INF;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tcost[a][b][0]=cost[b][a][0]=d; \n\t\t\tcost[a][b][1]=cost[b][a][1]=e;\n\t\t}\n\t\tint res=dijkstra(N,L);\n\t\tcout << res <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {int to, dist, cost;};\n\nvector<edge> g[105];\nint d[105][105];\nsigned main() {\n\twhile(true) {\n\t\tint n, m, l;\n\t\tcin >> n >> m >> l;\n\t\tif(!n) break;\n\t\tfor(int i=0; i<n; ++i) g[i].clear();\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--, b--;\n\t\t\tg[a].push_back({b, d, e});\n\t\t\tg[b].push_back({a, d, e});\n\t\t}\n\t\t\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\td[0][l] = 0;\n\t\tpriority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> que;\n\t\tque.push({0, 0, l});\n\t\t\n\t\twhile(que.size()) {\n\t\t\tvector<int> v = que.top(); que.pop();\n\t\t\tint cost = v[0], city = v[1], money = v[2];\n\t\t\t//cout << cost << \" \" << city << \" \" << money << endl;\n\t\t\tif(d[city][money] < cost) continue;\n\t\t\tfor(edge e: g[city]) {\n\t\t\t\t// ??????????¶????????????????\n\t\t\t\tif(e.dist <= money) {\n\t\t\t\t\tif(d[e.to][money-e.dist] > d[city][money]) {\n\t\t\t\t\t\td[e.to][money-e.dist] = d[city][money];\n\t\t\t\t\t\tque.push({d[e.to][money-e.dist], e.to, money-e.dist});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// ??????????¶?????????????\n\t\t\t\tif(d[e.to][money] > d[city][money] + e.cost) {\n\t\t\t\t\td[e.to][money] = d[city][money] + e.cost;\n\t\t\t\t\tque.push({d[e.to][money], e.to, money});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 0x3f3f3f3f;\n\t\tfor(int i=0; i<l+1; ++i) {\n\t\t\tret = min(ret, d[n-1][i]);\n\t\t\t//cout << d[n-1][i] << \" \";\n\t\t}\n\t\t//cout << endl;\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cstdint>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <chrono>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <utility>\n#include <limits>\n#include <list>\n#include <type_traits>\n\n/* template start */\n \n#define rep(i, a, b) for (long long i = (a); (i) < (b); (i)++)\n#define all(i) i.begin(), i.end()\n\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\nvoid debug_out(){std::cerr<<std::endl;}\n\ntemplate<typename Head,typename... Tail>\nvoid debug_out(Head h,Tail... t){\n  std::cerr<<\" \"<<h;\n  if(sizeof...(t)>0)std::cout<<\" :\";\n  debug_out(t...);\n}\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (std::size_t i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n\ntemplate<typename Num>\nconstexpr Num mypow(Num a, long long b) {\n  if(b==0)return 1;\n  if (a==0)return 0;\n  Num x = 1;\n  while (b > 0) {\n    if(b & 1)x*=a;\n    a*=a;\n    b >>= 1;\n  }\n  return x;\n}\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr bool operator==(const modint rhs) const noexcept {return a==rhs.a;}\n  constexpr bool operator!=(const modint rhs) const noexcept {return !(*this==rhs);}\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\n/* template end */\n\nusing ll = long long;\n\nint main() {\n  std::cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  ll n,m,l;\n\n  using P=std::pair<ll,ll>;\n  \n  while(std::cin>>n>>m>>l,n||m||l){\n    std::vector<std::vector<P>> graph(n*(l+1));\n    rep(i,0,m){\n      ll a,b,d,e;\n      std::cin>>a>>b>>d>>e;\n      a--;b--;\n      rep(j,0,l+1-d){\n        graph[n*(j+d)+b].emplace_back(n*j+a,0);\n        graph[n*(j+d)+a].emplace_back(n*j+b,0);\n      }\n      rep(j,0,l+1){\n        graph[n*j+a].emplace_back(n*j+b,e);\n        graph[n*j+b].emplace_back(n*j+a,e);\n      }\n    }\n    constexpr ll INF=1e18;\n    std::vector<ll> d(n*(l+1),INF);\n    std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n    d[n*l]=0;\n    que.emplace(0,n*l);\n    while(!que.empty()){\n      P now=que.top();que.pop();\n      ll v=now.second;\n      if(d[v]<now.first)continue;\n      for(const auto& e:graph[v]){\n        if(d[e.first] > d[v]+e.second){\n          d[e.first]=d[v]+e.second;\n          que.emplace(d[e.first],e.first);\n        }\n      }\n    }\n\n    ll min=INF;\n    rep(i,0,l+1)chmin(min,d[n*i+n-1]);\n    std::cout<<min<<\"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int INF = 1e9;\n\nstruct Edge {\n    int to, cost, enemy;\n    Edge(int t, int c, int e) : to(t), cost(c), enemy(e) {}\n};\n\nstruct info {\n    int cur, cost, enemy;\n    info(int s, int c, int e) : cur(s), cost(c), enemy(e) {}\n};\n\nbool operator<(const info &a, const info &b) { return a.enemy >= b.enemy; }\n\nint main() {\n    int n, m, l;\n    while (cin >> n >> m >> l) {\n        if (n == 0 && m == 0 && l == 0) break;\n        vector<Edge> g[n];\n        for (int i = 0; i < m; i++) {\n            int s, t, d, e;\n            cin >> s >> t >> d >> e;\n            g[s - 1].push_back(Edge(t - 1, d, e));\n            g[t - 1].push_back(Edge(s - 1, d, e));\n        }\n        priority_queue<info> que;\n        que.push(info(0, 0, 0));\n        vector<vector<int> > dp(110, vector<int>(110, INF));\n        dp[0][0] = 0;\n        while (!que.empty()) {\n            int cur = que.top().cur;\n            int cost = que.top().cost;\n            int enemy = que.top().enemy;\n            que.pop();\n            if (dp[cur][cost] < enemy) continue;\n            for (int i = 0; i < g[cur].size(); i++) {\n                Edge nx = g[cur][i];\n                int nxc = cost + nx.cost;\n                if (nxc <= l && dp[nx.to][nxc] > enemy) {\n                    dp[nx.to][nxc] = enemy;\n                    que.push(info(nx.to, nxc, enemy));\n                }\n                if (dp[nx.to][cost] > enemy + nx.enemy) {\n                    dp[nx.to][cost] = enemy + nx.enemy;\n                    que.push(info(nx.to, cost, enemy + nx.enemy));\n                }\n            }\n        }\n        int ans = INF;\n        for (int i = 0; i <= l; i++) {\n            ans = min(ans, dp[n - 1][i]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nint n,m,L;\nint dp[111][111];\nmain()\n{\n\twhile(cin>>n>>m>>L,n)\n\t{\n\t\tfor(int i=1;i<=n;i++)for(int j=0;j<=L;j++)dp[i][j]=1e9;\n\t\tvector<pair<int,pair<int,int> > >G[111];\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a,b,d,e;cin>>a>>b>>d>>e;\n\t\t\tG[a].push_back({b,{d,e}});\n\t\t\tG[b].push_back({a,{d,e}});\n\t\t}\n\t\tpriority_queue<pair<pair<int,int>,int> >P;\n\t\tP.push({{0,L},1});\n\t\tdp[1][L]=0;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint sum=-P.top().first.first;\n\t\t\tint le=P.top().first.second;\n\t\t\tint u=P.top().second;\n\t\t\tP.pop();\n\t\t\tif(dp[u][le]<sum)continue;\n\t\t\tfor(int i=0;i<G[u].size();i++)\n\t\t\t{\n\t\t\t\tint v=G[u][i].first;\n\t\t\t\tint dis=G[u][i].second.first;\n\t\t\t\tint com=G[u][i].second.second;\n\t\t\t\tif(le>=dis)\n\t\t\t\t{\n\t\t\t\t\tif(dp[v][le-dis]>sum)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[v][le-dis]=sum;\n\t\t\t\t\t\tP.push({{-sum,le-dis},v});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dp[v][le]>sum+com)\n\t\t\t\t{\n\t\t\t\t\tdp[v][le]=sum+com;\n\t\t\t\t\tP.push({{-sum-com,le},v});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=1e9;\n\t\tfor(int i=0;i<=L;i++)if(ans>dp[n][i])ans=dp[n][i];\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long int;\n\nconst int INF = 1000000000;\n\nconst int MAX_N = 105;\n\nint N, M, L;\n\nclass Edge{\npublic:\n    Edge(int from = -1, int to = -1, int dist = -1, int e = -1) : from(from), to(to), dist(dist), e(e) {}\n    int from, to, dist, e;\n    \n    int money;\n    int damage;\n    int pos;\n\n    bool operator < (const Edge& e) const {\n        return e.damage < e.damage;\n    }\n    bool operator > (const Edge& e) const {\n        return e.damage > e.damage;\n    }\n};\n\nvector<Edge> edges[MAX_N];\n\nint dist[MAX_N][MAX_N];\n\nbool input()\n{\n    for(int i = 0; i < MAX_N; i++) {\n        edges[i].clear();\n    }\n    cin >> N >> M >> L;\n    if(N == 0 && M == 0 && L == 0) {\n        return false;\n    }\n    for(int i = 0; i < M; i++) {\n        int a,b,c,d;\n        cin >> a >> b >> c >> d; a--; b--;\n        edges[a].push_back(Edge(a,b,c,d));\n        edges[b].push_back(Edge(b,a,c,d));\n    }\n    return true;\n}\n\nint main()\n{\n    while(input()) {\n        for(int i = 0; i < MAX_N; i++) {\n            for(int j = 0; j < MAX_N; j++) {\n                dist[i][j] = INF;\n            }\n        }\n\n        priority_queue<Edge, vector<Edge>, greater<Edge>> pque;\n        Edge start; start.pos = 0; start.money = L; start.damage = 0; pque.push(start);\n        dist[0][L] = 0;\n\n        while(pque.size()) {\n            Edge e = pque.top();\n            pque.pop();\n            int pos = e.pos;\n            int money = e.money;\n            int damage = e.damage;\n            // cerr << dist[pos][money] << \" \" << damage << endl;\n            if(dist[pos][money] < damage) {\n                continue;\n            }\n\n            // cerr << \"OK\" << endl;\n\n            for(int d = 0; d < edges[pos].size(); d++) {\n                Edge edge = edges[pos][d];\n                int next = edge.to;\n                //金を使わない\n                if(dist[next][money] > dist[pos][money] + edges[pos][d].e) {\n                    dist[next][money] = dist[pos][money] + edges[pos][d].e;\n                    Edge nextState; \n                    nextState.damage = dist[next][money];\n                    nextState.money = money;\n                    nextState.pos = next;\n                    // cerr << nextState.pos << \" \" << nextState.damage << endl;\n                    pque.push(nextState);\n                }\n                //金を使う\n                if(money - edge.dist >= 0) {\n                    if(dist[next][money - edge.dist] > dist[pos][money]) {\n                        dist[next][money - edge.dist] = dist[pos][money];\n                        Edge nextState; \n                        nextState.damage = dist[next][money - edge.dist];\n                        nextState.money = money - edge.dist;\n                        nextState.pos = next;\n\n                        pque.push(nextState);\n                    }  \n                }\n            }\n        }\n\n        int ans = INF;\n        for(int i = 0; i <= L; i++) {\n            ans = min(ans, dist[N-1][i]);\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\n#define UNDEF 500000\n\nusing namespace std;\n\nint main()\n{\n\tint n, m, l, i;\n\tint len[101][101];\n\tint hos[101][101];\n\tint djk_money[2][101];\n\tint djk_enemy[2][101];\n\n\t//0...àgíÈ¢[g\n\t//1...àg¤[g\n\n\tqueue<int> que;\n\tqueue<int> out;\n\n\twhile(cin >> n >> m >> l, (n||m||l))\n\t{\n\t\tmemset(len, -1, sizeof(len));\n\t\tmemset(hos, -1, sizeof(hos));\n\t\tmemset(djk_money, -1, sizeof(djk_money));\n\t\tmemset(djk_enemy, -1, sizeof(djk_enemy));\n\t\tque.push(1);\n\t\tdjk_enemy[0][1] = 0;\n\t\tdjk_enemy[1][1] = 0;\n\t\tdjk_money[0][1] = l;\n\t\tdjk_money[1][1] = l;\n\n\t\tfor( i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a;\n\t\t\tcin >> b;\n\n\t\t\tcin >> len[a][b];\n\t\t\tcin >> hos[a][b];\n\n\t\t\tlen[b][a] = len[a][b];\n\t\t\thos[b][a] = hos[a][b];\n\t\t}\n\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tint st = que.front();\n\t\t\tque.pop();\n\n\t\t\tfor( i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif( len[st][i] > 0 && hos[st][i] > 0)\n\t\t\t\t{\n\t\t\t\t\tbool flg = 0;\n\n\t\t\t\t\tif( djk_enemy[0][i] < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdjk_enemy[0][i] = UNDEF;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( djk_enemy[1][i] < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdjk_enemy[1][i] = UNDEF;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor( int k = 0; k <= 1; k++)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tif( djk_enemy[0][i] > djk_enemy[k][st] + hos[st][i] )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdjk_enemy[0][i] = djk_enemy[k][st] + hos[st][i];\n\t\t\t\t\t\t\tdjk_money[0][i] = djk_money[k][st];\n\t\t\t\t\t\t\tflg = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( djk_enemy[1][i] > djk_enemy[k][st] && djk_money[k][st] - len[st][i] >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdjk_enemy[1][i] = djk_enemy[k][st];\n\t\t\t\t\t\t\tdjk_money[1][i] = djk_money[k][st] - len[st][i];\n\t\t\t\t\t\t\tflg = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg)\n\t\t\t\t\t\tque.push(i);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tout.push( min(djk_enemy[0][n], djk_enemy[1][n]) );\n\n\t}\n\n\twhile(!out.empty())\n\t{\n\t\tint r = out.front();\n\t\tcout << r << endl;\n\t\tout.pop();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max()/2;\n\nstruct Edge{\n    int to,d,cost;\n    Edge(int to,int d,int cost): to(to),d(d), cost(cost){}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct State{\n    int node,money,damage;\n    State(int node,int money,int damage):node(node),money(money),damage(damage){} \n};\n\nbool operator < (const State &e, const State &f){\n    return e.damage > f.damage;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m,l;\n    //int cnt=0;\n    while(cin>>n>>m>>l,n||m||l){\n        //cnt++;\n        //if(cnt==89) cout<<n<<\" \"<<m<<\" \"<<l<<endl;;\n        Graph g(n);\n        for(int i=0;i<m;i++){\n            int a,b,d,e;cin>>a>>b>>d>>e;\n            //if(cnt==89) cout<<a<<\" \"<<b<<\" \"<<d<<\" \"<<e<<endl;;\n            a--;b--;\n            g[a].push_back(Edge(b,d,e));\n            g[b].push_back(Edge(a,d,e));\n        }\n        vector<vector<int>> dp(111,vector<int>(111,INF));\n        // dp[i][j]\n        dp[0][l]=0;\n        priority_queue<State> que;\n        que.push(State(0,l,0)); // State(node, money,damage)\n        int res=INF;\n        while(!que.empty()){\n            State s=que.top();que.pop();\n            int node=s.node,money=s.money,damage=s.damage;\n            if(node==n-1){\n                res=min(res,damage);\n            }\n            if(dp[node][money]<damage) continue;\n            for(const auto &e: g[node]){\n                // Edge(to,d,cost)\n                int next=e.to, d=e.d, cost=e.cost;\n                if(money>=d){\n                    if(dp[next][money-d]>damage){\n                        dp[next][money-d]=damage;\n                        que.push(State(next,money-d,damage));\n                    }\n                }\n                if(dp[next][money]<=damage+cost) continue;\n                dp[next][money] = damage + cost;\n                que.push(State(next, money, damage+cost));\n            }\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nlong long slv(int, int,int);\n\nvector<vector<pair<int, int>>> s(101, vector<pair<int, int>>(101));\nvector<vector< int>> sflag(101, vector<int>(101, 0));\nint n, m, l;\n\nvector<vector<long long>> dp(101, vector<long long>(101, 0));\nvector<vector<int>> dpflag(101, vector<int>(101, 0));\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m >> l;\n\t\tif (n == 0&& m==0&&l==0)return 0;\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ts[b][a] = make_pair(d, e);\n\t\t\tsflag[b][a] = 1;\n\t\t\ts[a][b] = make_pair(d, e);\n\t\t\tsflag[a][b] = 1;\n\t\t}\n\t\t\n\t\tcout  << slv(n, l,0) <<endl;\n\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tdpflag[i][j] = 0;\n                sflag[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long slv(int N, int L,int count) {\n\tif (count > 200)return 100000000000;\n\tcount++;\n\tfor (int j = 0; j <= 101;j++) dpflag[1][j] = 1;\n\n\tif (dpflag[N][L] == 1) return dp[N][L];\n\tlong long min =   1000000000000;\n\tfor (int a = 1; a <= n; ++a) {\n\t\tlong long x = 2000000000000;\n\t\tlong long y = 3000000000000;\n\t\tif (sflag[N][a] == 1) {\n\t\t\tint LL = L - s[N][a].first;\n\t\t\tif (LL >= 0) {\n\t\t\t\tx = slv(a, LL,count);\n\t\t\t}\n\t\t\ty = slv(a, L,count) + s[N][a].second;\n\t\t}\n\t\tif (min>x) min = x;\n\t\tif (min>y) min = y;\n\t}\n\tdpflag[N][L] = 1;\n\tdp[N][L] = min;\n\n\treturn min;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <unordered_set>\n#include <unordered_map>\n#include <limits>\n#include <map>\n#include <cassert>\n\nstruct Edge {\n  int from, to, distance, attack;\n};\n\nstruct Info {\n  int attacks, place, money;\n\n  friend bool operator >(Info const& lhs, Info const& rhs) {\n    return lhs.attacks > rhs.attacks;\n  }\n};\n\nint solve(int N, int M, int L) {\n  std::vector<std::vector<Edge>> adj_list(N);\n  for (int i = 0; i < M; i++) {\n    int f, t, d, e;\n    std::cin >> f >> t >> d >> e;\n    adj_list[f - 1].push_back(Edge{f - 1, t - 1, d, e});\n    adj_list[t - 1].push_back(Edge{t - 1, f - 1, d, e});\n  }\n\n  std::priority_queue<Info, std::vector<Info>, std::greater<Info>> queue;\n  queue.push(Info{0, 0, L});\n  while (!queue.empty()) {\n    auto info = queue.top();\n    queue.pop();\n    //std::cout << \"info: \" << info.attacks << \" \" << info.place << \" \" << info.money << std::endl;\n    if (info.place == N - 1) {\n      return info.attacks;\n    }\n    for (auto const& edge : adj_list[info.place]) {\n     if (edge.distance <= info.money) {\n       //std::cout << \"pushing: \" << info.attacks << \" \" << edge.to << \" \" << info.money - edge.distance << std::endl;\n       queue.push(Info{info.attacks, edge.to, info.money - edge.distance});\n     }\n     //std::cout << \"pushing: \" << info.attacks + edge.attack << \" \" << edge.to << \" \" << info.money << std::endl;\n     queue.push(Info{info.attacks + edge.attack, edge.to, info.money});\n    }\n  }\n  assert(false);\n}\n\nint main() {\n  int N, M, L;\n  while (std::cin >> N >> M >> L) {\n    if (N == 0 && M == 0 && L == 0) {\n      break;\n    }\n    std::cout << solve(N, M, L) << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int from;\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    if(a.enemy==b.enemy){\n        return a.money < b.money;\n    }else {\n        return a.enemy > b.enemy;\n    }\n}\n\nstruct node maps[(int)1e8];\n\nint main()\n{\n    int n,m,l;\n\n    while ((cin>>n>>m>>l) && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            a--;\n            b--;\n            maps[a].data.push_back((struct data){b,d,e});\n            maps[b].data.push_back((struct data){a,d,e});\n        }\n        queue.push((struct state){0,0,l,0});\n        while (!queue.empty()){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                cout<<s.enemy<<endl;\n                while (!queue.empty()){\n                    queue.pop();\n                }\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.to!=s.from) {\n                        if (d.dis <= s.money) {\n                            queue.push((struct state) {s.number, d.to, s.money - d.dis, s.enemy});\n                        }\n                        queue.push((struct state) {s.number, d.to, s.money, s.enemy + d.ene});\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nint n;\nint dist[101][101];\nint atk[101][101];\nint memo[101][101]; //memo[i][j] : ??????j??§?????????i???????????¨??????????°??\\???\\?????°\nbool used[101][101];\nconst int INF = 1000000000;\n\nstruct V{\n  int p,m;\n  V(int p,int m):p(p),m(m){}\n};\n\nbool operator < (const V& a,const V& b){\n  return memo[a.p][a.m]<memo[b.p][b.m];\n}\n\nint solve(int s,int l){\n  for(int i=0;i<=100;++i)\n    for(int j=0;j<=100;++j){\n      used[i][j]=false;\n      memo[i][j]=INF;\n    }\n  \n  memo[s][l] = 0;\n  priority_queue<V> Q;\n  Q.push(V(s,l));\n\n  while(!Q.empty()){\n    V x=Q.top(); Q.pop();\n    int cur = x.p, mon = x.m, cst=memo[cur][mon];\n    for(int i=0;i<n;++i){\n      if(dist[cur][i]){\n\tif(cst+atk[cur][i] < memo[i][mon]){\n\t  memo[i][mon] = cst+atk[cur][i];\n\t  Q.push(V(i,mon));\n\t}\n\tif(mon-dist[cur][i]>=0){\n\t  if(memo[i][mon-dist[cur][i]] > cst){\n\t    memo[i][mon-dist[cur][i]] = cst;\n\t    Q.push(V(i,mon-dist[cur][i]));\n\t  }\n\t}\n      }\n    }\n  }\n\n  int ret = INF;\n  for(int i=0;i<=l;++i) ret = min(ret, memo[n-1][i]);\n  return ret;\n}\nint main(){\n  int m,l;\n  while(cin>>n>>m>>l,n||m||l){\n    memset(dist,0,sizeof(dist));\n    memset(atk,0,sizeof(atk));\n    while(m--){\n      int a,b,d,e;\n      cin >> a >> b >> d >> e;\n      a--;b--;\n      dist[a][b] = dist[b][a] = d;\n      atk[a][b] = atk[b][a] = e;\n    }\n    cout<<solve(0,l)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\n//int checker[4];\n//int ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\t//int check[4];\n\tState() {}\n\t//\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\t/*\n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t\t*/\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n/*\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n*/\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t/*\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\t*/\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\t//ncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//copy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t/*\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n//\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint map[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nclass State {\npublic:\n\tint where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\nbool operator< ( const State& a, const State& b) {\n\treturn a.enemy < b.enemy;\n}\n\nbool operator> ( const State& a, const State& b) {\n\treturn a.enemy > b.enemy;\n}\n\nvoid error( string str ) {\n\tcout << str << endl;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\nbool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\nvoid add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[1/BASE]);\n}\n\nint main () {\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<=n; i++ ) {\n\t\t\tfor ( int j=0; j<=n; j++ ) {\n\t\t\t\tmap[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmap[a-1][b-1] = map[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\twhile( !status.empty() ) {\n\t\t\tstatus.pop() ;\n\t\t}\t\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<=n; i++ ) {\n\t\t\t\tif ( map[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\tstatus.push(State(i,now.enemy,now.budget));\n\t\t\t\t\t\t} else {\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ( now.budget - map[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\tstatus.push(State(i,now.enemy, now.budget - map[now.where][i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstatus.push(State(i,now.enemy+off[now.where][i], now.budget));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include <cfloat>\n\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nstruct Edge{\n  int to,distance,thief;\n  Edge(int t,int d,int th):to(t),distance(d),thief(th){}\n};\n\nint main(){\n  cout << std::fixed << std::setprecision(16);\n  cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  while(true){\n    int n,m,l;\n    cin>>n>>m>>l;\n    if(n==0) break;\n\n    std::vector<Edge> node[101];\n    for(int i=0;i<m;i++){\n      int a,b,d,e;\n      cin>>a>>b>>d>>e;\n      node[a].push_back(Edge(b,d,e));\n      node[b].push_back(Edge(a,d,e));\n    }\n\n    int dp[101][101];\n    const int INF=INT32_MAX/2;\n    for(int r=0;r<=n;r++){\n      for(int c=0;c<=l;c++){\n        dp[r][c]=INF;\n      }\n    }\n    dp[1][l]=0;\n\n    for(int loop=0;loop<n;loop++){\n      for(int from=1;from<=n;from++){\n        for(auto e:node[from]){\n          for(int cost_from=0;cost_from<=l;cost_from++){\n            if(dp[from][cost_from]==INF) continue;\n            //お金を払う\n            if(cost_from-e.distance>=0){\n              dp[e.to][cost_from-e.distance]=std::min(\n                  dp[e.to][cost_from-e.distance],\n                  dp[from][cost_from]\n              );\n            }\n            dp[e.to][cost_from]=std::min(\n                dp[e.to][cost_from],\n                dp[from][cost_from]+e.thief\n            );\n          }\n        }\n      }\n    }\n\n    int result=INF;\n    for(int i=0;i<=l;i++){\n      result=std::min(result,dp[n][i]);\n    }\n    cout<<result<<endl;\n  }\n\n\n\n\n\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\n\nconst int inf = 1 << 28;\n\nstruct Edge{\n    int to, cost, weight;\n    Edge(){}\n    Edge(int to_, int cost_, int weight_):to(to_), cost(cost_), weight(weight_){}\n};\n\nint N, M, L;\nvector<vector<Edge> > G;\nvector<vector<int> > w;\n\nint solve(int s){\n    w.assign(N+1, vector<int>(L+1, inf));\n    w[s][L] = 0;\n    priority_queue<pair<int, int> > q;\n    for(q.emplace(L, s); !q.empty();){\n        int c = q.top().first, v = q.top().second; q.pop();\n        if(v == N)continue;\n        for(auto e: G[v]){\n            if(e.cost <= c && w[v][c] < w[e.to][c-e.cost]){\n                w[e.to][c-e.cost] = w[v][c];\n                q.emplace(c - e.cost, e.to);\n            }\n            if(e.weight + w[v][c] < w[e.to][c]){\n                w[e.to][c] = e.weight + w[v][c];\n                q.emplace(c, e.to);\n            }\n        }\n    }\n    return *min_element(all(w[N]));\n}\n\nint main(){\n    while(cin >> N >> M >> L, N|M|L){\n        G.assign(N+1, vector<Edge>(0));\n        rep(i, M){\n            int A, B, D, E;\n            cin >> A >> B >> D >> E;\n            G[A].emplace_back(B, D, E);\n            G[B].emplace_back(A, D, E);\n        }\n        cout << solve(1) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<vector<int>> memo(N+1, vector<int>(L+1, 0));\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (memo[current.loc][current.money]) {\n                continue;\n            }\n            memo[current.loc][current.money] = 1;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n            for (size_t i=0; i < edges[current.loc].size(); ++i) {\n                const Edge& e = edges[current.loc][i];\n                // 護衛を雇う\n                if (0 <= current.money - e.dist) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n\t\n\titr++;\n\tint min = b+1;\n\t\n\twhile( itr != points[i].end() ) {\t\t\t\t\t\t\t\t\t\n\t\tif ((*itr).second > min) {\n\t\t\t(*itr).second = min;\n\t\t} else {\n\t\t\tmin = (*itr).second+1;\n\t\t}\n\t\titr++;\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    return a.enemy>b.enemy;\n}\n\nstruct node maps[(int)1e8];\n\nint main()\n{\n    int n,m,l;\n\n    while ((cin>>n>>m>>l) && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            maps[a-1].data.push_back((struct data){b-1,d,e});\n            maps[b-1].data.push_back((struct data){a-1,d,e});\n        }\n        queue.push((struct state){0,l,0});\n        bool flag=true;\n        while (flag){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                cout<<s.enemy<<endl;\n                flag= false;\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.dis<=s.money){\n                        queue.push((struct state){d.to,s.money-d.dis,s.enemy});\n                    }\n                    queue.push((struct state){d.to,s.money,s.enemy+d.ene});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nHokudai Practice Constest 2014\nG - Brave Princess Revisited\n\nティツァツ」テヲツウツ陛ッツシツ堙」ツδ?」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥ (テ」ツつーテ」ツδゥテ」ツδ陛ヲツ慊?ァツ淞ュティツキツッ)\nテヲツ閉オテ」ツ?ョテヲツ閉ーテ」ツつ津ィツセツコテ」ツ?ョテ」ツつウテ」ツつケテ」ツδ暗」ツ?ィテ」ツ?療」ツ?淌」ツつーテ」ツδゥテ」ツδ陛ヲツ慊?ァツ淞ュティツキツッテ・ツ閉湘ゥツ。ツ古」ツ?ォテ・ツクツーテァツ敖?」ツ?ァテ」ツ?催」ツつ凝」ツ?禿」ツ?ィテ」ツ?ッテヲツッツ氾ィツシツεァツ堋?・ツョツケテヲツ伉禿」ツ?ォテ」ツつ湘」ツ?凝」ツつ凝」ツ??\nテ」ツ?療」ツ?凝」ツ?療」ツ??ィツュツキティツ。ツ崚」ツつ津ゥツ崢?」ツ??」ツ?凝・ツ青ヲテ」ツ?凝」ツ?ァティツセツコテ」ツ?ョテ」ツつウテ」ツつケテ」ツδ暗」ツ?古・ツ、ツ嘉」ツつ湘」ツつ凝ヲツ?ァティツウツェテ」ツ?古」ツ?づ」ツつ凝」ツ?淌」ツつ?」ツ??」ツ?敕」ツ?ョテ」ツ?セテ」ツ?セテ」ツ?ァテ」ツ?ッティツァツ」テ」ツ?妥」ツ?ェテ」ツ??」ツ??\nテ」ツ?禿」ツ?禿」ツ?ァテ」ツ??ヲツョツ凝ゥツ?喪テ」ツ?ョテ」ツ?ィテ」ツ?催」ツ?ォテ・ツョツソテ・ツ?エvテ」ツ?ォテ」ツ??」ツつ凝ァツ環カテヲツ??v,r)テ」ツつ津ゥツ?づァツつケテ」ツ?ィテ」ツ?凖」ツつ凝ヲツ仰。テ・ツシツオテ」ツつーテ」ツδゥテ」ツδ陛」ツつ津ィツ?ε」ツ?暗」ツつ凝」ツ??\nテヲツ慊?ァツ淞ュティツキツッテ」ツ?ァテ」ツ?ッテ」ツ??ヲツョツ凝ゥツ?妥」ツ?古・ツ青古」ツ?佚」ツ?ァテ」ツ?づ」ツつ古」ツ?ーテ」ツ??、ツサツ・テゥツ卍催」ツ?ョティツュツキティツ。ツ崚」ツ?ョテゥツ崢?」ツ??ヲツ鳴ケテ」ツ?ッテ・ツ青古」ツ?佚」ツ?ォテ」ツ?ェテ」ツつ凝」ツ?淌」ツつ?」ツ??\nテ」ツ?敕」ツ?ョテヲツ仰。テ・ツシツオテ」ツつーテ」ツδゥテ」ツδ陛、ツクツ甘」ツ?ァテヲツ慊?ァツ淞ュティツキツッテ・ツ閉湘ゥツ。ツ古」ツつ津ィツァツ」テ」ツ?妥」ツ?ーテ」ツつ暗」ツ??」ツ??\n\nテヲツ仰。テ・ツシツオテ」ツつーテ」ツδゥテ」ツδ陛」ツ?ッテゥツ?づァツつケテ」ツ?鍬N = 10^4テ・ツ?凝」ツ??ィツセツコテ」ツ?鍬M = 10^6テヲツ慊ャテ」ツ?ィテ」ツ?ェテ」ツつ凝」ツ?淌」ツつ?」ツ??\nテ・ツ環ケテァツ篠?」ツ?ョテ」ツつ暗」ツ??ヲツ慊?ァツ淞ュティツキツッテ」ツつ「テ」ツδォテ」ツつエテ」ツδェテ」ツつコテ」ツδ?」ツつ津ァツ板ィテ」ツ??」ツつ凝・ツソツ?ィツヲツ?」ツ?古」ツ?づ」ツつ凝」ツ??\nテ」ツδ?」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥテヲツウツ陛」ツつ恥riority queueテ」ツつ津ァツ板ィテ」ツ??」ツ?ヲテ・ツョツ淌ィツ」ツ?」ツ?凖」ツつ古」ツ?ーテ・ツ債?・ツ按?」ツ?ァテ」ツ?づ」ツつ凝」ツ??\n\nテヲツ卍づゥツ鳴禿ィツィツ暗ァツョツ療ゥツ?湘ッツシツ唹(LM logN)\nテァツゥツコテゥツ鳴禿ィツィツ暗ァツョツ療ゥツ?湘ッツシツ唹(LM)\n*/\n\n#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<vector>\n \n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> tri;\n\nconst int INF = 1e8;\nint num[110][110];\n\nint main(){\n  int n,m,l;\n  while(cin >> n >> m >> l, n){\n    //テ」ツつーテ」ツδゥテ」ツδ陛」ツ?ョテゥツ堋」テヲツ篠・テ」ツδェテ」ツつケテ」ツδ暗ィツ。ツィテァツ渉セ\n    //g[i].fs: テヲツ閉オテ」ツ?ョテヲツ閉ー, g[i].sc.fs: ティツ。ツ古」ツ?催・ツ?暗」ツ?ョテ・ツョツソテ・ツ?エ, g[i].sc.sc: テゥツ閉キテ」ツ??ティツュツキティツ。ツ崚」ツつ津ゥツ崢?」ツ??ヲツ鳴凖ゥツ??\n    vector<tri> g[110];\n \n    for(int i=0;i<m;i++){\n      int a,b,d,e;\n      cin >> a >> b >> d >> e;\n      g[a].push_back(tri(e,pii(b,d)));\n      g[b].push_back(tri(e,pii(a,d)));\n    }\n \n    //テ・ツ按敕ヲツ慊淌・ツ個?\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<=l;j++)num[i][j] = INF;\n    }    \n    num[1][l] = 0;\n\n    //テヲツ伉?ゥツ??」ツ?ョテ・ツ?ェテ・ツ?暗・ツコツヲテ、ツサツ佚」ツ?催」ツつュテ」ツδ・テ」ツδシ\n    priority_queue<tri ,vector<tri> ,greater<tri> > q;\n    q.push(tri(0,pii(1,l)));\n \n    //テ」ツδ?」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥ\n    while(q.size()){\n      tri p = q.top();q.pop();\n      //p.fs: テヲツ閉オテ」ツ?ョテァツキツ湘ヲツ閉ー, p.sc.fs: テァツ渉セテ・ツ慊ィテ・ツ慊ー, p.sc.sc: テヲツョツ凝ゥツ??\n      int enemy = p.fs, pos = p.sc.fs, money = p.sc.sc;\n \n      for(int i=0;i<(int)g[pos].size();i++){\n\tint nxt = g[pos][i].sc.fs, cost = g[pos][i].sc.sc;\n\tif(cost <= money){\n\t  int rem = money - cost;\n\t  if(num[nxt][rem] > enemy){\n\t    num[nxt][rem] = enemy;\n\t    q.push(tri(enemy,pii(nxt,rem)));\n\t  }\n\t}\n\tif(num[nxt][money] > enemy + g[pos][i].fs){\n\t  num[nxt][money] = enemy + g[pos][i].fs;\n\t  q.push(tri(enemy+g[pos][i].fs, pii(nxt,money)));\n\t}\n      }\n    }\n   \n    //テ」ツつエテ」ツδシテ」ツδォテ」ツ?ァテ」ツ?ョテヲツョツ凝ゥツ?妥」ツ?ッテァツクツ崚」ツつ甘」ツ?古」ツ?ェテ」ツ??」ツ?ョテ」ツ?ァテ」ツ??」ツ?凖」ツ?ケテ」ツ?ヲテ」ツ?ョテ、ツクツュテ」ツ?凝」ツつ嘉ヲツ慊?・ツーツ湘・ツ?、テ」ツつ津ヲツアツづ」ツつ?」ツつ?\n    int ans = INF;\n    for(int i=0;i<=l;i++)ans = min(ans,num[n][i]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 6/14 8:54 ~\n */\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#define INF 1000000\n\nusing namespace std;\n\nstruct edge {\n  int to, cost, dis;\n};\ntypedef pair<int, int> P;\n\nvector<edge> G[101];\n\n// init\n\n// input\nint iN; // 0 <= N <= 100,000\nint iM; // 1 <= P <= 100\nint iL; // 1 <= P <= 100\n\n// manage\nint d[101][101];\n\n// ú»\nvoid init() {\n}\n\n// üÍ\nbool input() {\n  int i;\n  edge e;\n  int a, b, d, c;\n\n  scanf(\"%d %d %d\", &iN, &iM, &iL);\n  if (iN == 0 && iM == 0 && iL == 0) return false;\n\n  for (i = 0; i < iN; i++) {\n    G[i].clear();\n  }\n  for (i = 0; i < iM; i++) {\n    scanf(\"%d %d %d %d\", &a, &b, &d, &c);\n    e.cost = c;\n    e.dis = d;\n    e.to = b;\n    G[a].push_back(e);\n    e.to = a;\n    G[b].push_back(e);\n  }\n\n  return true;\n}\n\n// \nvoid manage(){\n  priority_queue<P, vector<P> , greater<P> > que;\n\n  fill(d[0], d[0] + 101 * 101, INF);\n  d[1][iL] = 0;\n  que.push(P(0, 1 * 101 + iL));\n\n  while (!que.empty()) {\n    P p = que.top();\n    que.pop();\n    int v = p.second / 101;\n    int c = p.second % 101;\n    if (d[v][c] < p.first)\n      continue;\n    for (int i = 0; i < (int) G[v].size(); i++) {\n      edge e = G[v][i];\n      if (e.dis <= c && d[e.to][c - e.dis] > d[v][c]) {\n        d[e.to][c - e.dis] = d[v][c];\n        que.push(P(d[e.to][c - e.dis], e.to * 101 + (c - e.dis)));\n      }\n      if (d[e.to][c] > d[v][c] + e.cost) {\n        d[e.to][c] = d[v][c] + e.cost;\n        que.push(P(d[e.to][c], e.to * 101 + c));\n      }\n    }\n  }\n}\n\n// oÍ\nvoid output(){\n  int i, out;\n  out = d[iN][0];\n  for (i = 1; i <= iL; i++) {\n    out = min(out, d[iN][i]);\n  }\n  printf(\"%d\\n\", out);\n}\n\n// mizoSâ¤Ê\nint main() {\n  init(); // ú»\n  while(1) {\n    if (!input()) break; // üÍ + I¹»è\n    manage(); // \n    output(); // oÍ\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nclass State {\npublic:\n\tint budget;\n\tint people;\n\tint wheres;\n\tState() {};\n\tState( int b, int p, int n ) { budget = b; people = p; wheres = n; };\n};\n\npriority_queue<State, vector<State>, greater<State>> status;\n//priority_queue<State> status;\n\nint map[101][101];\nint off[101][101];\n\nbool operator< (const State& a, const State& b)\n{\n\tif ( a.people == b.people )\n\t\treturn a.budget < b.budget;\n\treturn a.people < b.people;\n}\n\nbool operator> (const State& a, const State& b)\n{\n\tif ( a.people == b.people )\n\t\treturn a.budget > b.budget;\n\treturn a.people > b.people;\t\n}\n\nint main () {\n\n\twhile ( true ) {\n\t\tint  N,M,L;\n\n\t\tcin >> N >> M >> L;\n\n\t\tif ( N == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<=N; i++ ) {\n\t\t\tfor ( int j=0; j<=N; j++ ) {\n\t\t\t\tmap[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint a, b, d, e;\n\n\t\tfor ( int i=0; i<M; i++ ) {\n\t\t\tcin >> a >> b >> d>> e;\n\n\t\t\tmap[a][b] = d;\n\t\t\toff[a][b] = e;\n\t\t\tmap[b][a] = d;\n\t\t\toff[b][a] = e;\n\t\t}\n\n\n\t\tstatus.push(State(L, 0, 1));\n\t\tint ans;\n\t\tans = 10000000;\n\t\tbool have = false;\n\t\twhile( !status.empty() ) {\n\t\t\tState now;\n\t\t\tnow = status.top();\n\t\t\tstatus.pop();\n\t\t\t\n\t\t\tif ( now.people >= ans ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << now.budget<< \"\\t\";\n\t\t\tcout << now.people<< \"\\t\";\n\t\t\tcout << now.wheres<< endl;\n\t\t\t*/\n\t\t\tif ( now.wheres == N ) {\n\t\t\t\tif ( ans > now.people) {\n\t\t\t\t\thave = true;\n\t\t\t\t\tans = now.people;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor ( int i=1; i<=N; i++ ) {\n\t\t\t\t\tif ( i != now.wheres ) {\n\t\t\t\t\t\tif ( map[now.wheres][i] > 0 ) {\n\t\t\t\t\t\t\tif ( off[now.wheres][i] != 0 ) {\n\t\t\t\t\t\t\t\tif ( now.budget - map[now.wheres][i] >= 0 ) {\n\t\t\t\t\t\t\t\t\tstatus.push(State(now.budget-map[now.wheres][i],now.people,i));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstatus.push(State(now.budget,now.people+off[now.wheres][i],i));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstatus.push(State(now.budget,now.people,i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( ans == -1 )\n\t\t\tcout << \"No\" << endl;\n\t\telse\n\t\t\tcout << \"Ans: \" <<ans << endl;\n\t}\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110][110]={};\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(now==n){\n    ans=min(ans,sum);\n    return;\n  }\n  if(memo[nokori][now]<=sum)return;\n  for(int i=0;i<=nokori;i++)\n    memo[i][now]=sum;\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      used[E[now][i].to]=true;\n      if(nokori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }else\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n      for(int j=0;j<l+5;j++)\n      memo[j][i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int INF = 1e9;\n\nstruct edge {\n\tint A, B, D, E;\n};\n\nstruct node {\n\tint v;\n\tint used;\n\tint cost;\n\tbool operator<(const node& that) const {\n\t\treturn cost > that.cost;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N | M | L) {\n\t\tvector<vector<edge>> G(N);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint A, B, D, E;\n\t\t\tcin >> A >> B >> D >> E; A--, B--;\n\t\t\tG[A].push_back((edge){ A, B, D, E });\n\t\t\tG[B].push_back((edge){ B, A, D, E });\n\t\t}\n\t\tvector<vector<int>> dp(N, vector<int>(L + 1, INF));\n\t\tpriority_queue<node> pq;\n\t\tpq.push((node) { 0, 0, 0 });\n\t\twhile (!pq.empty()) {\n\t\t\tauto p = pq.top(); pq.pop();\n\t\t\tint v = p.v, use = p.used, cost = p.cost;\n\t\t\tif (dp[v][use] != INF) continue;\n\t\t\tdp[v][use] = cost;\n\t\t\tfor (auto& e : G[v]) {\n\t\t\t\tif (dp[e.B][use] == INF) {\n\t\t\t\t\tpq.push((node) { e.B, use, cost + e.E });\n\t\t\t\t}\n\t\t\t\tif (use + e.D <= L && dp[e.B][use + e.D] == INF) {\n\t\t\t\t\tpq.push((node) { e.B, use + e.D, cost });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << *min_element(dp[N - 1].begin(), dp[N - 1].end()) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n \nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n \nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push(make_pair(0, s));\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        int cost = st.first;\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push(make_pair([to], to));\n            }\n        }\n    }\n    return d;\n}\n \nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back(make_pair(e, vv(b, j)));\n                edge[vv(b, j)].push_back(make_pair(e, vv(a, j)));\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back(make_pair(0, vv(b, j - d)));\n                    edge[vv(b, j)].push_back(make_pair(0, vv(a, j - d)));\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n \n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n             \n            res = min(res,val);\n        }\n \n        cout << res << endl;\n    }\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 temp.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define For(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define Rep(i,n) For(i,0,n)\n#define Each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\n\n#define INF INT_MAX/3\n\n#define MAX_N 100+1\n#define MAX_M 2000+1\n#define MAX_L 100+1\n\nstruct edge{\n\tint to, cost, th;\n\tedge(int a, int b, int c):to(a),cost(b),th(c){}\n};\n\nstruct state{\n\tint v, cost, tsum;\n\tstate(int a, int b, int c):v(a),cost(b),tsum(c){}\n};\n\nbool operator<(const state& a, const state& b){ return a.tsum > b.tsum; }\n\nvector<edge> G[MAX_M];\nint tsum[MAX_N][MAX_L];\n\nint N, M, L;\n\nvoid solve(){\n\tRep(i,MAX_N)Rep(j,MAX_L) tsum[i][j] = INF;\n\n\tint res = INF;\n\tpriority_queue<state> Q;\n\tQ.push(state(0,L,0));\n\twhile(!Q.empty()){\n\t\tstate s = Q.top(); Q.pop();\n\t\t//dbg(s.v);\n\t\tif(s.v == N-1){ res = min(res, s.tsum); continue; }\n\t\tif(tsum[s.v][s.cost] != INF) continue;\n\t\ttsum[s.v][s.cost] = s.tsum;\n\t\tRep(i, G[s.v].size()){\n\t\t\tif(G[s.v][i].cost <= s.cost){\n\t\t\t\tQ.push(state(G[s.v][i].to, s.cost-G[s.v][i].cost, s.tsum));\n\t\t\t}\n\t\t\tQ.push(state(G[s.v][i].to, s.cost, s.tsum+G[s.v][i].th));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d %d\", &N, &M, &L);\n\t\tif(N == 0) break;\n\t\tRep(i,N) G[i].clear();\n\t\tRep(i,M){\n\t\t\tint a, b, c, d;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\t\ta--; b--;\n\t\t\tG[a].pb(edge(b,c,d));\n\t\t\tG[b].pb(edge(a,c,d));\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#define fr first\n#define sc second\n#define INF (1 << 25)\nusing namespace std;\n\ntypedef pair<int,int> F;\ntypedef pair<F,int> P;\nstruct edge{\n    int to,dis,enemy; edge(){}\n    edge(int to,int dis,int enemy):to(to),dis(dis),enemy(enemy){}\n};\n\nint n,m,l,costed[128][128]; \nvector< vector<edge> > info(128);\n\nvoid init(){\n    for(int i=0;i<128;i++){\n        for(int j=0;j<128;j++) costed[i][j] = INF;\n    }\n    info.resize(0); info.resize(128);\n}\n\nvoid add_info(){\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    info[a].push_back(edge(b,c,d));\n    info[b].push_back(edge(a,c,d));\n}\n\nint Dijkstra(){\n    priority_queue<P,vector<P>,greater<P> > que;\n    que.push(P(F(0,1),l)); costed[1][l] = 0;\n    while(!que.empty()){\n        P p = que.top(); que.pop();\n        int now = p.fr.sc,en = p.fr.fr,mo = p.sc;\n        if(now == n) return en;\n        for(int i=0;i<info[now].size();i++){\n            edge e = info[now][i];\n            if(e.enemy + en < costed[e.to][mo]){\n                que.push(P(F(e.enemy + en,e.to),mo));\n                costed[e.to][mo] = e.enemy + en;\n            }\n            if(e.enemy == 0){\n                if(en < costed[e.to][mo]){\n                    que.push(P(F(en,e.to),mo));\n                    costed[e.to][mo] = en;\n                }\n            }\n            if(e.dis <= mo){\n                if(en < costed[e.to][mo-e.dis]){\n                    que.push(P(F(en,e.to),mo-e.dis));\n                    costed[e.to][mo-e.dis] = en;\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin>>n>>m>>l,n||m||l){\n        init();\n        for(int i=0;i<m;i++) add_info();\n        cout << Dijkstra() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nstruct edge{int to,cost,d;};\nusing P=pair<pair<int,int>,int>;\nconst int INF=1<<29;\nconst int MAX_V=110;\nconst int MAX_L=110;\nvector<edge> G[MAX_V];\nint d[MAX_L][MAX_V];\nint V,E,L;\n//O(E*L*logV)\nvoid dijkstra(int s){\n  priority_queue<P,vector<P>,greater<P>> que;\n  REP(i,110)\n    fill(d[i],d[i]+V,INF);\n  d[0][s]=0;\n  que.push(P(make_pair(0,0),s));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int v=p.second;\n    if(d[p.first.second][v]<p.first.first)continue;\n    REP(i,G[v].size()){\n      edge e=G[v][i];\n      //attacked\n      if(d[p.first.second][e.to]>d[p.first.second][v]+e.cost){\n\td[p.first.second][e.to]=d[p.first.second][v]+e.cost;\n\tque.push(P(make_pair(d[p.first.second][e.to],p.first.second),e.to));\n      }\n      //not attacked\n      int used=p.first.second+e.d;\n      if(used<=L){\n\tif(d[used][e.to]>d[p.first.second][v]){\n\t  d[used][e.to]=d[p.first.second][v];\n\t  que.push(P(make_pair(d[used][e.to],used),e.to));\n\t}\n      }\n    }\n  }\n}\n\nint main(){ _;\n  int n,m,l,a,b,dist,thief;\n  while(cin>>n>>m>>l,(n|m|l)!=0){\n    V=n;E=m;L=l;\n    REP(i,V)G[i].clear();\n    REP(i,m){\n      cin>>a>>b>>dist>>thief;\n      a--;b--;\n      G[a].push_back(edge{b,thief,dist});\n      G[b].push_back(edge{a,thief,dist});\n    }\n    dijkstra(0);\n    int result=INF;\n    REP(i,l+1)\n      if(result>d[i][n-1])\n\tresult=d[i][n-1];\n    cout<<result<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nlong long slv(int, int);\n\nvector<vector<pair<int, int>>> s(101, vector<pair<int, int>>(101));\nvector<vector< int>> sflag(101, vector<int>(101, 0));\nint n, m, l;\n\nvector<vector<long long>> dp(101, vector<long long>(101, 0));\nvector<vector<int>> dpflag(101, vector<int>(101, 0));\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m >> l;\n\t\tif (n == 0)return 0;\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ts[b][a] = make_pair(d, e);\n\t\t\tsflag[b][a] = 1;\n\t\t}\n\t\tlong long answer = 100000000000;\n\t\tfor (int i = 1; i <= l; ++i) {\n\t\t\tif (answer > slv(n, i)) answer = slv(n, i);\n\n\t\t}\n\t\tcout << answer << endl;\n\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tdpflag[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\n\n\t}\n}\n\n\n\n\n\nlong long slv(int N, int L) {\n\tdpflag[1][0] = 1;\n\n\tif (dpflag[N][L] == 1) return dp[N][L];\n\tlong long min = 1000000000000;\n\tfor (int a = 0; a <= n; ++a) {\n\t\tlong long x = 1000000000000;\n\t\tlong long y = 1000000000000;\n\t\tif (sflag[N][a] == 1) {\n\t\t\tint LL = L - s[N][a].first;\n\t\t\tif (LL >= 0) {\n\t\t\t\tx = slv(a, LL);\n\t\t\t}\n\t\t\ty = slv(a, L) + s[N][a].second;\n\n\n\t\t}\n\t\tif (min>x) min = x;\n\t\tif (min>y) min = y;\n\n\n\t}\n\tdpflag[N][L] = 1;\n\tdp[N][L] = min;\n\treturn min;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n \nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint n,m,l;\nvector<vector<PP> > edge;\n\n\nint solve()\n{\n\t\n\t//??????i??§?????????j????????????????????°\n\tvector<vector<long> > memo(n,vector<long>(l+1,1000000));\n\t\n\tfor(int i=0;i<=l;i++) memo[0][i]=0;\n\t\n\tpriority_queue<PP,vector<PP>,greater<PP> > q;\n\t\n\t//?????¨??°0,??????0,?????????l\n\tq.push(PP(0,P(0,l)));\n\t\n\twhile(!q.empty()){\n\t\tPP tmp=q.top(); q.pop();\n\t\t\n\t\tint now_v=tmp.first;\n\t\tint now_e=tmp.second.first;\n\t\tint now_l=tmp.second.second;\n\t\t\t\t\t\t\t\t\n\t\tfor(int i=0;i<edge[now_v].size();i++){\n\t\t\tint to=edge[now_v][i].first;\n\t\t\tint e_num=edge[now_v][i].second.second;\n\t\t\tint cost=edge[now_v][i].second.first;\n\n\t\t\t//???????????????\n\t\t\tif(now_l>=cost){\n\t\t\t\tif(memo[to][now_l-cost]>memo[now_v][now_l]){\n\t\t\t\t\tmemo[to][now_l-cost]=memo[now_v][now_l];\n\t\t\t\t\tq.push(PP(to,P(now_e,now_l-cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//?????????????????????\n\t\t\tif(memo[to][now_l]>memo[now_v][now_l]+e_num){\n\t\t\t\tmemo[to][now_l]=memo[now_v][now_l]+e_num;\n\t\t\t\tq.push(PP(to,P(now_e+e_num,now_l)));\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tint ans=memo[n-1][0];\n\tfor(int i=1;i<=l;i++) ans=min(ans,memo[n-1][i]);\n\t\n\treturn ans;\n\t\n}\n\nint main()\n{\n\t\n\twhile(cin>>n>>m>>l,n){\t\t\n\t\t\t\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--; b--;\n\t\t\t\n\t\t\tedge[a].push_back(PP(b,P(d,e)));\n\t\t\tedge[b].push_back(PP(a,P(d,e)));\n\t\t\t\n\t\t}\n\t\tcout<<solve()<<endl;\n\t\t\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define INF 1000000000\nusing namespace std;\ntypedef long long ll;\n\nstruct edge { ll n, d, e; };\nstruct state {\n  ll n, l, s;\n  bool operator<(const state &state) const { return s > state.s; }\n};\n\nint main(void) {\n  int N, M, L;\n  while(cin >> N >> M >> L, N || M || L) {\n    vector<edge> G[100];\n\n    REP(i, 0, M) {\n      int A, B, D, E;\n      cin >> A >> B >> D >> E;\n      G[A - 1].push_back((edge) { B - 1, D, E });\n      G[B - 1].push_back((edge) { A - 1, D, E });\n    }\n\n    ll dp[100][101];\n    REP(i, 0, N) REP(j, 0, L + 1) dp[i][j] = INF;\n    dp[0][0] = 1;\n\n    priority_queue<state> q;\n    q.push((state) { 0, 0, 0 });\n    while(q.size()) {\n      state c = q.top();\n      q.pop();\n\n      if(c.n == N - 1) {\n        cout << c.s << endl;\n        break;\n      }\n\n      if(dp[c.n][c.l] <= c.s) continue;\n      dp[c.n][c.l] = c.s;\n\n      REP(i, 0, G[c.n].size()) {\n        q.push((state) { G[c.n][i].n, c.l, c.s + G[c.n][i].e });\n        if(c.l + G[c.n][i].d <= L) {\n          q.push((state) { G[c.n][i].n, c.l + G[c.n][i].d, c.s });\n        }\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXN = 110, MAXM = 5500, MAXL = 110, MAXD = 10010, INF = 20000;\n\nint n,m,l,a,b,d,e;\nint enemy[MAXN][MAXN];\nint dist[MAXN][MAXN];\nbool used[MAXN][MAXL];\n\ntypedef pair<int,int> pp;\ntypedef pair<int,pp> ppp;\n\nint main()\n{\n    while(cin >> n >> m >> l && n )\n    {\n        memset(enemy, INF, sizeof(enemy));\n        memset(dist, MAXD, sizeof(dist));\n        memset(used, false, sizeof(used));\n        priority_queue<ppp, vector<ppp>, greater<ppp> > que;\n        que.push(ppp(0,pp(0,1)));\n\n        REP(m)\n        {\n            cin >> a >> b >> d >> e;\n            enemy[b][a] = e;\n            enemy[a][b] = e;\n            dist[b][a] = d;\n            dist[a][b] = dist[b][a];\n        }\n        int ans = 0;\n        while(1)\n        {\n            ppp q = que.top(); que.pop();\n            int nowe = q.first, cost = q.second.first, node = q.second.second;\n            if(node == n){ans = nowe; break;}\n            if(used[nowe][cost])continue;\n            used[nowe][cost] = 1;\n            for(int i=1;i<=n;i++)if(dist[node][i] != MAXD)\n            {\n                que.push(ppp(nowe + enemy[node][i], pp(nowe, i)));\n                if(cost + dist[node][i] <= l)\n                    que.push(ppp(nowe, pp(cost + dist[node][i], i)));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define mp(a,b) make_pair(a,b)\nusing namespace std;\nstruct edge{int to,cost,danger;};\ntypedef pair<int, int > P;\ntypedef pair<int, P > PP;\n\nint main(){\n  int n,m,l;\n  int inf = 1<<20;\n  cin >> n >> m >> l;\n  while(n!=0){\n    int i,j,k;\n    priority_queue<PP,vector<PP>,greater<PP> > q;\n    P x,b;\n    edge e;\n    vector<edge> v[100];\n    for(i=0;i<m;i++){\n      cin >> k >> e.to >> e.cost >> e.danger;\n      k--;e.to--;\n      v[k].push_back(e);\n      //cout << k << \":\" << e.to << endl;\n      int buf=k;\n      k=e.to;e.to=buf;\n      //cout << k << \":\" << e.to << endl;\n      v[k].push_back(e);\n    }\n    int o=inf;\n    int d[101][101];\n    fill(d[0],d[100],inf);\n    d[0][l]=0;\n    q.push(mp(0,mp(0,l)));\n    \n    while(!q.empty()){\n      PP p=q.top();q.pop();\n      x = p.second;\n      if(d[x.first][x.second] < p.first) continue; \n      //d[x.first][x.second] =p.first;\n      //cout << p.first << endl;\n\n      for(i=0;i<v[x.first].size();i++){\n\t//cout << x.first <<\":\"<<v[x.first][i].to<<endl;\n\tif(d[v[x.first][i].to][x.second]>d[x.first][x.second]+v[x.first][i].danger){\n\t  d[v[x.first][i].to][x.second]=d[x.first][x.second]+v[x.first][i].danger;\n\t  q.push(mp(d[v[x.first][i].to][x.second],mp(v[x.first][i].to,x.second)));\n\t}\n\tif(x.second>=v[x.first][i].cost){\n\t  if(d[v[x.first][i].to][x.second-v[x.first][i].cost]>d[x.first][x.second]){\n\t    d[v[x.first][i].to][x.second-v[x.first][i].cost]=d[x.first][x.second];\n\t    q.push(mp(d[v[x.first][i].to][x.second-v[x.first][i].cost],\n\t\t      mp(v[x.first][i].to,x.second-v[x.first][i].cost)));\n\t  }\n\t}\n      }\n    }\n    for(i=0;i<=l;i++) o=min(o,d[n-1][i]);\n    cout << o << endl;\n    cin >> n >> m >> l;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define pb push_back \n#include<vector>\n#include<queue>\n#include<functional>\n#include<utility>\n#define all(c) c.begin(), c.end()\n#define rep(i,n) for(int i = 0; i < (n); i++)\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nstruct State {\n  int v, l, dist;\n  bool operator<(const State& o) const {\n    return dist > o.dist;\n  }\n};\n const int INF = 100000000;\nint main(){\n  int n,m,l;\n  while(cin >>n>>m>>l,n||m) {\n    VVI cost(n, VI(n, INF));\n    VVI foes(n, VI(n, INF));\n    rep(i,m) {\n      int a,b,d,e;\n      cin >>a>>b>>d>>e;\n      a--; b--;\n      foes[a][b] = foes[b][a] = e;\n      cost[a][b] = cost[b][a] = d;\n    }\n   \n    VVI dist(l+1, VI(n, INF));\n    dist[l][0] = 0;\n    priority_queue<State, vector<State> > que;\n    que.push((State){0,l,0});\n    while(!que.empty()) {\n      State s = que.top();\n      que.pop();\n      if (dist[s.l][s.v] < s.dist) continue;\n      //      cout << s.l << \" \"<<s.v << \" \"<<s.dist << endl;\n      for(int i = 0; i < n; i++) {\n\tif (s.l >= cost[i][s.v]) {\n\t  int nl = s.l - cost[i][s.v];\n\t  if (dist[nl][i] > s.dist) {\n\t    dist[nl][i] = s.dist;\n\t    que.push((State){i,nl,s.dist});\n\t  }\n\t}\n\tif (dist[s.l][i] > s.dist + foes[i][s.v]) {\n\t  dist[s.l][i] = s.dist + foes[i][s.v];\n\t  que.push((State){i,s.l,dist[s.l][i]});\n\t}\t\n      }\n    }\n    int minFoes = INF;\n    rep(i,l+1) minFoes = min(minFoes, dist[i][n-1]);\n    cout << minFoes << endl;\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m,l;\nvector<vector<int>> g;\nvector<int> path;\nint ans;\n\nvoid dfs(int x){\n\t//cout << x << endl;\n\tpath.emplace_back(x);\n\tif(x == n-1){\n\t\tans++;\n\t\treturn;\n\t}\n\tfor(auto a:g[x]){\n\t\tif(find(path.begin(), path.end(), a) != path.end()) continue;\n\t\tdfs(a);\n\t}\n\tpath.pop_back();\n}\n\nint main(){\n\twhile(cin >> n >> m >> l,n && m && l){\n\t\tans = 0;\n\t\tfor(int i=0;i<n;i++) g.emplace_back(vector<int>());\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tg[a].emplace_back(b);\n\t\t\tg[b].emplace_back(a);\n\t\t}\n\t\tdfs(0);\n\t\tcout << ans << endl;\n\t\tg.clear();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 100000000000000000\n#define MOD 1000000007\n\n\ntypedef long long ll;\ntypedef pair<ll,pair<ll,ll> > P;\n\nll d[111][111];\n\nint main()\n{\n\tint n,m,l;\n\twhile(cin >> n >> m >> l,n|m|l){\n\t\tvector<vector<P> > v(n);\n\t\tREP(i,111)REP(j,111)d[i][j] = LLINF;\n\t\tREP(i,m){\n\t\t\tint a,b,c,d;cin >> a >> b >> c >> d;\n\t\t\ta--;b--;\n\t\t\tv[a].PB(MP(b,MP(c,d)));\n\t\t\tv[b].PB(MP(a,MP(c,d)));\n\t\t}\n\t\t\n\t\td[0][l] = 0;\n\t\tpriority_queue<P,vector<P>,greater<P> > pq;\n\t\tpq.push(MP(0,MP(0,l)));\n\t\twhile(!pq.empty()){\n\t\t\tP now = pq.top();pq.pop();\n\t\t\tint node = now.SE.FI;\n\t\t\tint kinnka = now.SE.SE;\n\t\t\tint teki = now.FI;\n\t\t\tif(teki > d[node][kinnka])continue;\n\t\t\tREP(i,v[node].size()){\n\t\t\t\tint aite = v[node][i].FI;\n\t\t\t\tint kyori = v[node][i].SE.FI;\n\t\t\t\tint plus = v[node][i].SE.SE;\n\t\t\t\t\n\t\t\t\tif(kinnka >= kyori){\n\t\t\t\t\tif(d[aite][kinnka-kyori] > teki){\n\t\t\t\t\t\td[aite][kinnka-kyori] = teki;\n\t\t\t\t\t\tpq.push(MP(teki,MP(aite,kinnka-kyori)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(d[aite][kinnka] > teki + plus){\n\t\t\t\t\td[aite][kinnka] = teki + plus;\n\t\t\t\t\tpq.push(MP(teki + plus,MP(aite,kinnka)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = LLINF;\n\t\tREP(i,l+1)ans = min(ans,d[n-1][i]);\n\t\tDBG(cout << \"ANS IS \";);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <stack>\n#include <algorithm>\n\nstd::pair<int, int> road[101][101]; //first?????¢ second???\nint dp[101][100];//[??????][??´???] = ??¢????\\????????????°\n\nstruct Node {\n\tint pos, money, attacked;\n};\n\nint main() {\n\tint n, m, l;\n\twhile (std::cin >> n >> m >> l && (n || m || l)) {\n\t\tfor (int i = 0; i < 101; i++) for (int j = 0; j < 101; j++) road[i][j] = std::make_pair(0, 0);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, e;\n\t\t\tstd::cin >> x >> y >> d >> e;\n\t\t\troad[x][y] = std::make_pair(d, e);\n\t\t\troad[y][x] = std::make_pair(d, e);\n\t\t}\n\n\t\tstd::stack<Node> s;\n\t\ts.push({1, l, 0});\n\n\t\tint min = 1919810;\n\t\twhile (!s.empty()) {\n\t\t\tauto node = s.top(); s.pop();\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (!road[node.pos][i].first) continue;\n\t\t\t\tauto next = node;\n\t\t\t\tnext.pos = i;\n\n\t\t\t\t//????????????\n\t\t\t\t{\n\t\t\t\t\tauto n2 = next;\n\t\t\t\t\tn2.attacked += road[node.pos][i].second;\n\t\t\t\t\tif (!dp[n2.money][i] || dp[n2.money][i] > next.attacked) {\n\t\t\t\t\t\tif (i == n) min = std::min(min, n2.attacked); //????????????\n\t\t\t\t\t\telse s.push(n2);\n\t\t\t\t\t\tdp[n2.money][i] = n2.attacked;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\tif (next.money >= road[node.pos][i].first) {\n\t\t\t\t\tnext.money -= road[node.pos][i].first;\n\t\t\t\t\tif (!dp[next.money][i] || dp[next.money][i] > next.attacked) {\n\t\t\t\t\t\tif (i == n) min = std::min(min, next.attacked); //????????????\n\t\t\t\t\t\telse s.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << min << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nconst int INF=12345678;\n\ntypedef pair<int,int> pi;\n\nstruct edge\n{\n    int to,dist,enem;\n};\n\nvector<edge> G[100];\n\nint main()\n{\n    int n,m,l;\n    while(cin >>n >>m >>l,n)\n    {\n        rep(i,100) G[i].clear();\n\n        rep(i,m)\n        {\n            int a,b,d,e;\n            scanf(\" %d %d %d %d\",&a,&b,&d,&e);\n            --a;\n            --b;\n            G[a].pb(edge{b,d,e});\n            G[b].pb(edge{a,d,e});\n        }\n\n        //i?????????j????????£?????¶?????§????????????????????°???????°????\n        int cost[100][101];\n\n        fill(cost[0],cost[100],INF);\n        cost[0][l]=0;\n\n        queue<pi> que;\n        que.push(pi(0,l));\n        while(!que.empty())\n        {\n            pi v=que.front();\n            que.pop();\n\n            int now=v.fi;\n            int money=v.se;\n            rep(i,G[now].size())\n            {\n                edge E=G[now][i];\n\n                //?????????????????????\n                if(money>=E.dist)\n                {\n                    if(cost[E.to][money-E.dist]>cost[now][money])\n                    {\n                        cost[E.to][money-E.dist]=cost[now][money];\n                        que.push(pi(E.to,money-E.dist));\n                    }\n                }\n\n                //????????????????????????\n                if(cost[E.to][money]>cost[now][money]+E.enem)\n                {\n                    cost[E.to][money]=cost[now][money]+E.enem;\n                    que.push(pi(E.to,money));\n                }\n            }\n        }\n\n        int ans=INF;\n        rep(i,l+1) ans=min(ans,cost[n-1][i]);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#define fr first\n#define sc second\n#define INF (1 << 25)\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> iP;\nstruct edge{\n  int to,dis,enemy; edge(){}\n  edge(int to,int dis,int enemy):to(to),dis(dis),enemy(enemy){}\n};\n\nint n,m,money;\nint costed[128][128];\nvector<vector<edge> >info(128);\n\nvoid init(){\n  for(int i=0;i<128;i++){\n    for(int j=0;j<128;j++) costed[i][j] = INF;\n  }\n  info.resize(0); info.resize(128);\n}\n\nvoid add_info(){\n  int a,b,c,d;\n  cin >> a >> b >> c >> d;\n  info[a].push_back(edge(b,c,d));\n  info[b].push_back(edge(a,c,d));\n}\n\nint Dijkstra(){\n  priority_queue<iP,vector<iP>,greater<iP> > que;\n  que.push(iP(P(0,1),money));\n  costed[money][1] = 0;\n  while(!que.empty()){\n    iP p = que.top(); que.pop();\n    int now =  p.fr.sc,att = p.fr.fr,mo = p.sc;\n    if(now == n) return att;\n    for(int i=0;i<info[now].size();i++){\n      edge e = info[now][i];\n      if(e.enemy + att < costed[mo][e.to]){\n\tque.push(iP(P(att + e.enemy,e.to),mo));\n\tcosted[mo][e.to] = e.enemy + att;\n      }\n      if(mo >= e.dis){\n\tque.push(iP(P(att,e.to),mo-e.dis));\n\tcosted[mo-e.dis][e.to] = att;\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> n >> m >> money,n||m||money){\n    init();\n    while(m--) add_info();\n    cout << Dijkstra() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\nbool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy < b.enemy;\n}\n\nbool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\t\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\nbool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\nvoid add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\twhile( !status.empty() ) {\n\t\t\tstatus.pop() ;\n\t\t}\t\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tif ( points[i].find(e) == points[i].end() ) {\n\t\t\t\t\t\t\t\tpoints[i][e] = b;\n\t\t\t\t\t\t\t\tstatus.push(State(i,e,b));\n\t\t\t\t\t\t\t} else if ( points[i][e] < b ) {\n\t\t\t\t\t\t\t\tpoints[i][e] = b;\n\t\t\t\t\t\t\t\tstatus.push(State(i,e,b));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tif ( points[i].find(e) == points[i].end() ) {\n\t\t\t\t\t\t\t\t\tpoints[i][e] = b;\n\t\t\t\t\t\t\t\t\tstatus.push(State(i,e, b));\n\t\t\t\t\t\t\t\t} else if ( points[i][e] < b ) {\n\t\t\t\t\t\t\t\t\tpoints[i][e] = b;\n\t\t\t\t\t\t\t\t\tstatus.push(State(i,e,b));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tif ( points[i].find(e) == points[i].end() ) {\n\t\t\t\t\t\t\t\tpoints[i][e] = b;\n\t\t\t\t\t\t\t\tstatus.push(State(i,e,b));\n\t\t\t\t\t\t\t} else if ( points[i][e] < b ) {\n\t\t\t\t\t\t\t\tpoints[i][e] = b;\n\t\t\t\t\t\t\t\tstatus.push(State(i,e,b));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n//#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\n//using namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e17+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint solve(void){\n\tint n,m,L,i,j;cin>>n>>m>>L;\n\tif(n==0){return 0;}\n\tvector<vector<tuple<int,int,int>>>go(n);\n\twhile(m--){\n\t\tint a,b,d,e;cin>>a>>b>>d>>e;a--;b--;\n\t\tgo[a].pub(mt(b,d,e));\n\t\tgo[b].pub(mt(a,d,e));\n\t}\n\tint den[101][101];\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<=L;j++){\n\t\t\tden[i][j]=mod;\n\t\t}\n\t}\n\tden[0][L]=0;\n\tpriority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>> que;\n\t//危険度,所持金,場所\n\tque.push(mt(0,L,0));\n\twhile(que.size()){\n\t\tint now=get<0>(que.top());\n\t\tint syo=get<1>(que.top());\n\t\tint tow=get<2>(que.top());\n\t\tque.pop();\n\t\tif(den[tow][syo]<now){continue;}\n\t\t//cerr<<\"now=\"<<now<<\"syo=\"<<syo<<\"tow=\"<<tow<<endl;\n\t\tint aaa=syo-1;\n\t\twhile(aaa>=0&&mineq(den[tow][aaa],den[tow][syo])){aaa--;}\n\t\tfor(auto it:go[tow]){\n\t\t\t//cerr<<\"de\"<<endl;\n\t\t\tint ter=get<0>(it);\n\t\t\tint cost=get<1>(it);\n\t\t\tint kya=get<2>(it);\n\t\t\tif(mineq(den[ter][syo],now+kya)){que.push(mt(now+kya,syo,ter));}\n\t\t\tif(syo>=cost&&mineq(den[ter][syo-cost],now)){que.push(mt(now,syo-cost,ter));}\n\t\t}\n\t}\n\tcout<<den[n-1][0]<<endl;\n\treturn 1;\n\t\n}\n\nint main(void){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\n#include <fstream>\n#include <random>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define revrep(i, n) for(int i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n#define sz(x) ((int)(x).size())\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst int INF = 1 << 30;//10^9\nll MOD = 1000000007;\n//const ll MOD = 998244353;\ndouble EPS = 1e-10;\n\nvector<ll> dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, 0, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A){printf(\"%.12lf\\n\", A);}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\nint N, M, L;\nstruct edge{int to, cost, peo;};\nvector<edge> E[110];\nint dist[110][110];//場所, 使った予算\nvoid dijkstra(){\n  rep(i, 110)rep(j, 110) dist[i][j] = INF;\n  dist[0][0] = 0;\n  typedef pair<int, pair<int, int>> P;\n  priority_queue<P, vector<P>, greater<P>> pque;\n  pque.push({0, {0, 0}});\n  while(!pque.empty()){\n    P p = pque.top();\n    pque.pop();\n    if(dist[p.s.f][p.s.s] < p.f) continue;\n    for(edge e: E[p.s.f]){\n      if(dist[e.to][p.s.s] > p.f + e.peo){\n        dist[e.to][p.s.s] = p.f + e.peo;\n        pque.push({dist[e.to][p.s.s], {e.to, p.s.s}});\n      }\n      if(p.s.s+e.cost > L) continue;\n      if(dist[e.to][p.s.s+e.cost] > p.f){\n        dist[e.to][p.s.s+e.cost] = p.f;\n        pque.push({dist[e.to][p.s.s+e.cost], {e.to, p.s.s+e.cost}});\n      }\n    }\n  }\n  int ans = INF;\n  rep(i, L+1) ans = min(ans, dist[N-1][i]);\n  cout << ans << endl;\n}\n\nvoid solve(){\n  while(true){\n    cin >> N >> M >> L;\n    if(N == 0 && M == 0 && L == 0) return;\n    rep(i, M){\n      int a, b, d, e;\n      cin >> a >> b >> d >> e;\n      a--, b--;\n      E[a].pb({b, d, e});\n      E[b].pb({a, d, e});\n    }\n    dijkstra();\n    rep(i, N) E[i].resize(0);\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n\nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n\nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push(make_pair(0, s));\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        int cost = st.first;\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push(make_pair(d[to], to));\n            }\n        }\n    }\n    return d;\n}\n\nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back(make_pair(e, vv(b, j)));\n                edge[vv(b, j)].push_back({e, vv(a, j)});\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back(make_pair(0, vv(b, j - d)));\n                    edge[vv(b, j)].push_back(make_pair(0, vv(a, j - d)));\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n\n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n            \n            res = min(res,val);\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <queue>\n#include <map>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-9\n\nint dp[128][128]; //[node][kane]\nint node[128][128]; //distance\nint enemy[128][128];\n\nint main(){\n\tint n,m,l;\n\twhile(scanf(\"%d%d%d\",&n,&m,&l),n|m|l){\n\t\trep(i,128)rep(j,128){\n\t\t\tdp[i][j]=INT_MAX; node[i][j]=enemy[i][j]=INT_MAX;\n\t\t}\n\t\trep(i,m){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\tnode[a][b] = node[b][a] = c;\n\t\t\tenemy[a][b] = enemy[b][a] = d;\n\t\t}\n\t\tdp[1][l] = 0;\n\t\tfor(;;){\n\t\t\tbool flag = false;\n\t\t\tREP(i,1,n){\n\t\t\t\trep(j,l+1)if( dp[i][j]!=INT_MAX ){\n\t\t\t\t\tREP(k,1,n+1)if( node[i][k]!=INT_MAX ){\n\t\t\t\t\t\tif( j>=node[i][k] && dp[k][j-node[i][k]]>dp[i][j] ){\n\t\t\t\t\t\t\tdp[k][j-node[i][k]] = dp[i][j];\n\t\t\t\t\t\t\t//printf(\"%d->%d ye_kane:%d  e:%d\\n\",i,k,j-node[i][k],dp[i][j]);\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( dp[k][j]>dp[i][j]+enemy[i][k] ){\n\t\t\t\t\t\t\tdp[k][j] = dp[i][j]+enemy[i][k];\n\t\t\t\t\t\t\t//printf(\"%d->%d no_kane:%d  e:%d\\n\",i,k,j,dp[k][j]);\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !flag )break;\n\t\t}\n\t\tint ans = INT_MAX;\n\t\trep(i,l+1){\n\t\t\t//printf(\"%d,%d  : %d\\n\",n,i,dp[n][i]);\n\t\t\tans=min(ans,dp[n][i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n\tint from, to, cost, enemy;\n\tedge ( int f, int t, int c, int e ) : from(f), to(t), cost(c), enemy(e) {}\n\tbool operator < (const edge &e ) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<edge> VE;\ntypedef vector<VE> VVE;\n\nconst int INF = 1 << 29;\n\nint solve ( int N, int M, int L )\n{\n\tVVE E(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, d, e;\n\t\tcin >> a >> b >> d >> e;\n\t\tE[a-1].push_back(edge(a-1, b-1, d, e));\n\t\tE[b-1].push_back(edge(b-1, a-1, d, e));\n\t}\n\tVVI mincost(N, VI(L+1, INF));\n\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\tque.push(PP(0, P(0, L)));\n\tmincost[0][L] = 0;\n\twhile (!que.empty()) {\n\t\tPP pp = que.top(); que.pop();\n\t\tint v = pp.second.first, l = pp.second.second;\n\t\tif (mincost[v][l] < pp.first) { continue; }\n\t\tfor (int i = 0, I = E[v].size(); i < I; ++i) {\n\t\t\tedge e = E[v][i];\n\t\t\tint c = l - e.cost;\n\t\t\tif (0 <= c && mincost[e.to][c] > pp.first) {\n\t\t\t\tmincost[e.to][c] = pp.first;\n\t\t\t\tque.push(PP(mincost[e.to][c], P(e.to, c)));\n\t\t\t}\n\t\t\tif (mincost[e.to][l] > pp.first + e.enemy) {\n\t\t\t\tmincost[e.to][l] = pp.first + e.enemy;\n\t\t\t\tque.push(PP(mincost[e.to][l], P(e.to, l)));\n\t\t\t}\n\t\t}\n\t}\n\tint res = INF;\n\tfor (int i = 0; i <= L; ++i) {\n\t\tres = min(res, mincost[N-1][i]);\n\t}\n\treturn res;\n}\n\nint main ( void )\n{\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n|m|l) {\n\t\tcout << solve(n, m, l) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) if((x)>(y))(x)=(y)\n#define chmax(x,y) if((x)<(y))(x)=(y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// d[i][j]: 街iに総コストjかけて到着する際に遭遇する盗賊の数の最小値\nint n, m, s, a, b, l, x, d[101][101];\nvector<pair<int,pii> > e[101];\n\nvoid dijkstra() {\n\tpriority_queue<pair<int,int>, vector<pair<int,int> >, greater<pair<int,int> > > que;\n\trep(i,n) rept(j,s) d[i][j] = inf;\n\td[0][0] = 0;\n\tque.push({0,0});\n\twhile(!que.empty()) {\n\t\tint v = que.top().second, cs = que.top().fi; que.pop();\n\t\tfor (int i = 0; i < e[v].size(); ++i) {\n\t\t\tint to = e[v][i].first, dist = e[v][i].se.fi, bd = e[v][i].se.se;\n\t\t\t// 護衛を雇う場合\n\t\t\tif (cs+dist<=s && d[to][cs+dist] > d[v][cs]) {\n\t\t\t\td[to][cs+dist] = d[v][cs];\n\t\t\t\tque.push({d[to][cs+dist], to});\n\t\t\t}\n\t\t\t// 雇わない場合\n\t\t\tif (d[to][cs] > d[v][cs] + bd) {\n\t\t\t\td[to][cs] = d[v][cs] + bd;\n\t\t\t\tque.push({d[to][cs], to});\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n >> m >> s;\n\t\tif (n==0) break;\n\t\trep(i,n) e[i].clear();\n\t\trep(i,m) {\n\t\t\tcin >> a >> b >> l >> x;\n\t\t\ta--, b--;\n\t\t\te[a].pb({b,{l,x}}), e[b].pb({a,{l,x}});\n\t\t}\n\t\tdijkstra();\n\t\tint res = inf;\n\t\trept(i,s) chmin(res,d[n-1][i]);\n\t\tcout << res << ln << flush;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\n//aoj 2151\nstruct Edge{\n\tint to, cost, enemy;\n\tEdge(){};\n\tEdge(int to, int cost, int enemy): to(to), cost(cost), enemy(enemy){};\n};\n\nvector<Edge> edge[110];\nint dist[110][110];\n\nint main(){\n\twhile(1){\n\t\tint n = in.nextInt(), m = in.nextInt(), l = in.nextInt();\n\t\tif(n == 0 && m == 0 && l == 0) break;\n\t\trep(i, 110) edge[i].clear();\n\t\trep(i, 110) rep(j, 110) dist[i][j] = i==0 ? 0: INF;\n\n\t\trep(i, m) {\n\t\t\tint a = in.nextInt()-1, b = in.nextInt()-1, d = in.nextInt(), e = in.nextInt();\n\t\t\tedge[a].pb({b, d, e});\n\t\t\tedge[b].pb({a, d, e});\n\t\t}\n\n\t\tauto dijkstra = [&]{\n\t\t\ttypedef pair<int, pii> P;\n\t\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\t\tq.push({0, {0, l}});\n\t\t\tP p;\n\t\t\twhile(!q.empty()){\n\t\t\t\tp = q.top(); q.pop();\n\t\t\t\tint cost = p.fi, from = p.se.fi, mny = p.se.se;\n\t\t\t\tfor(auto e : edge[from]){\n\t\t\t\t\tint to = e.to, c = e.cost, enmy = e.enemy;\n\t\t\t\t\tif(dist[to][mny] > cost + enmy){\n\t\t\t\t\t\tdist[to][mny] = cost + enmy;\n\t\t\t\t\t\tq.push({cost + enmy, {to, mny}});\n\t\t\t\t\t}\n\t\t\t\t\tif(mny < c) continue;\n\t\t\t\t\tif(dist[to][mny-c] > cost){\n\t\t\t\t\t\tdist[to][mny-c] = cost;\n\t\t\t\t\t\tq.push({cost, {to, mny - c}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdijkstra();\n\n\t\tint ans = INF;\n\t\trep(i, l + 1) ans = min(ans, dist[n-1][i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \"\\n\"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nvoid solve(int N,int M,int L) {\n    struct edge{\n        int to;\n        int left;\n        int dist;\n        int thief;\n    };\n    vector<vector<vector<edge>>> g(N,vector<vector<edge>>(110));\n    REP(i,M) {\n        int a,b,d,e;\n        cin>>a>>b>>d>>e;\n        REP(j,110) {\n            g[a-1][j].push_back(edge{b-1,j,d,e});  // ????????????\n            if(j-d>=0) g[a-1][j].push_back(edge{b-1,j-d,d,e});  // ??????\n        }\n        REP(j,110) {\n            g[b-1][j].push_back(edge{a-1,j,d,e});  // ????????????\n            if(j-d>=0) g[b-1][j].push_back(edge{a-1,j-d,d,e});  // ??????\n        }\n    }\n    vector<vector<int>> dp(N,vector<int>(110,INF));\n    dp[0][L]=0;\n    priority_queue<pair<int,pii>,vector<pair<int,pii>>,greater<pair<int,pii>>> pq;\n    pq.push({0,{0,L}});\n    while(!pq.empty()) {\n        int y=pq.top().second.first;\n        int z=pq.top().second.second;\n        pq.pop();\n        FORE(e,g[y][z]) {\n            if(z==e.left) {\n                if(dp[e.to][e.left]>dp[y][z]+e.thief) {\n                    dp[e.to][e.left]=dp[y][z]+e.thief;\n                    pq.push({dp[e.to][e.left],{e.to,e.left}});\n                }\n            }\n            else {\n                if(dp[e.to][e.left]>dp[y][z]) {\n                    dp[e.to][e.left]=dp[y][z];\n                    pq.push({dp[e.to][e.left],{e.to,e.left}});\n                }\n            }\n        }\n    }\n    int ans=INF;\n    REP(i,110) chmin(ans,dp[N-1][i]);\n    cout<<ans<<endl;\n}\nsigned main() {\n    while(1) {\n        int N,M,L;\n        cin>>N>>M>>L;\n        if(N+M+L==0) break;\n        solve(N,M,L);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define MAX 100000000\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<int,p> P;\n//G@ê@à\nstruct edge{\n\tint to,cost,enem;\n};\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n||m||l){\n\t\tvector<edge> tab[110];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedge pre;\n\t\t\tpre.cost=d;\n\t\t\tpre.enem=e;\n\t\t\tpre.to=b;\n\t\t\ttab[a].push_back(pre);\n\t\t\tpre.to=a;\n\t\t\ttab[b].push_back(pre);\n\t\t}\n\t\tint d[110][110];\n\t\t//d[ê][à]=G;\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<100;j++){\n\t\t\td[i][j]=MAX;\n\t\t}\n\t\td[0][l]=0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,p(0,l)));\n\t\twhile(!que.empty()){\n\t\t\tP now=que.top();\n\t\t\tque.pop();\n\t\t\tint nowplace=now.second.first;\n\t\t\tint nowenem=now.first;\n\t\t\tint nowmoney=now.second.second;\n\t\t\tif(d[nowplace][nowmoney]<nowenem)\n\t\t\t\tcontinue;\n\t\t\tfor(int i=0;i<(int)tab[nowplace].size();i++){\n\t\t\t\tedge e=tab[nowplace][i];\n\t\t\t\tif(e.cost<=nowmoney&&d[e.to][nowmoney-e.cost]>nowenem){\n\t\t\t\t\td[e.to][nowmoney-e.cost]=nowenem;\n\t\t\t\t\tque.push(P(nowenem,p(e.to,nowmoney-e.cost)));\n\t\t\t\t}\n\t\t\t\tif(d[e.to][nowmoney]>nowenem+e.enem){\n\t\t\t\t\td[e.to][nowmoney]=nowenem+e.enem;\n\t\t\t\t\tque.push(P(nowenem+e.enem,p(e.to,nowmoney)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=MAX;\n\t\tfor(int i=0;i<=l;i++)\n\t\tans=min(ans,d[n-1][i]);\n\t\tcout<<ans<<endl;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct NODE{\n  vector<int> to_node;\n  vector<int> to_cost;\n  vector<int> to_man;\n  bool done_c;\n  bool done_m;\n  bool start;\n  int cost;\n  int man;\n  int nom;\n};\nint main(){\n  int n,m,l;\n  while(cin >>n>>m>>l,n|m|l){\n    NODE inn[100];\n    vector<int> ans;\n    while(m--){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      inn[a-1].to_node.push_back(b-1);\n      inn[a-1].to_cost.push_back(c);\n      inn[a-1].to_man.push_back(d);\n      inn[b-1].to_node.push_back(a-1);\n      inn[b-1].to_cost.push_back(c);\n      inn[b-1].to_man.push_back(d);\n    }\n    for(int i=0; i<n; i++){\n      inn[i].start = false;\n      inn[i].nom = 10000000;\n    }\n    inn[0].nom = 0;\n    for(int i=0; i<n; i++){\n      int at = 0,pom = 10000000;\n      for(int j=0; j<n; j++){\n\tif((!(inn[j].start)) && pom>inn[j].nom){at = j; pom = inn[j].nom;}\n      }\n      inn[at].start = true;\n      for(int j=0; j<inn[at].to_node.size(); j++){\n\tint togo = inn[at].to_node[j];\n\tif(!inn[togo].start){inn[togo].nom = min(inn[at].to_man[j] + inn[at].nom,inn[togo].nom);}\n      }\n    }\n    for(int k=0; k<n; k++){\n      for(int i=0; i<n; i++){\n\tinn[i].cost = 10000000;\n\tinn[i].done_c = false;\n      }\n      inn[k].cost = 0;\n      for(int i=0; i<n; i++){\n\tint at = 0,pom = 10000000;\n\tfor(int j=0; j<n; j++){\n\t  if((!(inn[j].done_c)) && pom>inn[j].cost){at = j; pom = inn[j].cost;}\n\t}\n\tinn[at].done_c = true;\n\tfor(int j=0; j<inn[at].to_node.size(); j++){\n\t  int togo = inn[at].to_node[j];\n\t  if(!inn[togo].done_c){inn[togo].cost = min(inn[at].to_cost[j] + inn[at].cost,inn[togo].cost);}\n\t}\n      }\n      for(int i=0; i<n; i++){\n\tinn[i].man = 10000000;\n\tinn[i].done_m = false;\n      }\n      inn[k].man = 0;\n      for(int i=0; i<n; i++){\n\tint at = 0,pom = 10000000;\n\tfor(int j=0; j<n; j++){\n\t  if((!(inn[j].done_m)) && pom>inn[j].man){at = j; pom = inn[j].man;}\n\t}\n\tinn[at].done_m = true;\n\tfor(int j=0; j<inn[at].to_node.size(); j++){\n\t  int togo = inn[at].to_node[j];\n\t  if(!inn[togo].done_m){inn[togo].man = min(inn[at].to_man[j] + inn[at].man,inn[togo].man);if(inn[togo].cost<=l){inn[togo].man = 0;}}\n\t}\n      }\n      ans.push_back(inn[k].nom + inn[n-1].man);\n    }\n    cout <<ans[0]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lld;\n\n#define INF (1<<20)\ntypedef pair< int , int > P;\ntypedef pair< int , P > Pi;\nstruct Edge { int to,cost,des; };\nvector< vector< Edge > > Graph;\nint V,E,L;\n\nint Dijkstra(int s,int g) {\n  int min_cost[111][111];\n  fill_n(*min_cost,111*111,INF);\n  priority_queue < Pi ,vector< Pi >,greater< Pi > > que;\n  que.push(Pi(0,P(L,s)));\n  min_cost[s][L] = 0;\n  while(!que.empty()){\n    int cost = que.top().first;\n    int des = que.top().second.first;\n    int now = que.top().second.second;\n    que.pop();\n    if(now == g) return cost;\n    if(cost > min_cost[now][des]) continue;\n    for(int i=0;i<Graph[now].size();i++){\n      Edge e = Graph[now][i];\n      if(des >= e.des && min_cost[e.to][des-e.des] > cost){\n\tmin_cost[e.to][des-e.des] = cost;\n\tque.push(Pi(cost,P(des-e.des,e.to)));\n      }\n      if(min_cost[e.to][des] > cost + e.cost){\n\tmin_cost[e.to][des] = cost + e.cost;\n\tque.push(Pi(min_cost[e.to][des],P(des,e.to)));\n      }\n    }\n  }\n  return (-1);\n}\n\nint main(){\n  while(cin >> V >> E >> L , (V||E||L)){\n    Graph.resize(V+1);\n    for(int i=0;i<E;i++){\n      int a,b,c,d;\n      cin >> a >> b >> c >> d;\n      a--; b--;\n      Edge e; e.to = b; e.cost = d; e.des = c;\n      Graph[a].push_back(e);\n      e.to = a;\n      Graph[b].push_back(e);\n    }\n    cout << Dijkstra(0,V-1) << endl;\n    Graph.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct edge\n {\n \tint to,cost,enemy;\n }; \n\n struct P\n {\n \tint from, money, enemy;\n \tbool operator >(const P &p) const{\n \t\treturn enemy>p.enemy;\n \t}\n };\n\nint main() {\n\tint N,M,L;\n\twhile(cin >> N >> M >> L, N|M|L){\n\t\tvector<vector<edge> > E=vector<vector<edge> >(N+1);\n\t\tREP(i, M){\n\t\t\tint from, to, cost, enemy;\n\t\t\tcin >> from >> to >> cost >> enemy;\n\t\t\tE[from].push_back((edge){to, cost, enemy});\n\t\t\tE[to].push_back((edge){from, cost, enemy});\n\t\t}\n\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tvector<int> costs=vector<int>(N+1);\n\t\tREP(i, costs.size()){\n\t\t\tcosts[i]=INT_MAX;\n\t\t}\n\n\t\tque.push((P){1, L, 0});\n\t\tint res=-1;\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.from==N){\n\t\t\t\tres=p.enemy;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(p.enemy>=costs[p.from])continue;\n\t\t\tcosts[p.from]=p.enemy;\n\t\t\tREP(i, E[p.from].size()){\n\t\t\t\tedge e=E[p.from][i];\n\t\t\t\tif(p.money>=e.cost){\n\t\t\t\t\tque.push((P){e.to, p.money-e.cost,p.enemy});\n\t\t\t\t}\n\t\t\t\tque.push((P){e.to, p.money, p.enemy+e.enemy});\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nclass State {\npublic:\n\tint budget;\n\tint people;\n\tint wheres;\n\tState() {};\n\tState( int b, int p, int n ) { budget = b; people = p; wheres = n; };\n};\n\npriority_queue<State, vector<State>, greater<State> > status;\n//priority_queue<State> status;\n\nint map[101][101];\nint off[101][101];\nbool check[101];\n\nbool operator< (const State& a, const State& b)\n{\n\tif ( a.people == b.people )\n\t\treturn a.budget > b.budget;\n\treturn a.people < b.people;\n}\n\nbool operator> (const State& a, const State& b)\n{\n\tif ( a.people == b.people )\n\t\treturn a.budget < b.budget;\n\treturn a.people > b.people;\t\n}\n\nint main () {\n\n\twhile ( true ) {\n\t\tint  N,M,L;\n\n\t\tcin >> N >> M >> L;\n\n\t\tif ( N == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<=N; i++ ) {\n\t\t\tfor ( int j=0; j<=N; j++ ) {\n\t\t\t\tmap[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tcheck[i] = true;\n\t\t}\n\n\t\tint a, b, d, e;\n\n\t\tfor ( int i=0; i<M; i++ ) {\n\t\t\tcin >> a >> b >> d>> e;\n\n\t\t\tmap[a][b] = d;\n\t\t\toff[a][b] = e;\n\t\t\tmap[b][a] = d;\n\t\t\toff[b][a] = e;\n\t\t}\n\n\n\t\tstatus.push(State(L, 0, 1));\n\t\tint ans;\n\t\tans = 10000000;\n\t\tbool have = false;\n\t\twhile( !status.empty() ) {\n\t\t\tState now;\n\t\t\tnow = status.top();\n\t\t\tstatus.pop();\n\t\t\t\n\t\t\tif ( now.people >= ans ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << now.budget<< \"\\t\";\n\t\t\tcout << now.people<< \"\\t\";\n\t\t\tcout << now.wheres<< endl;\n\t\t\t*/\n\t\t\tif ( now.wheres == N ) {\n\t\t\t\tif ( ans > now.people) {\n\t\t\t\t\thave = true;\n\t\t\t\t\tans = now.people;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( check[now.wheres] ) {\n\t\t\t\tnow.wheres = false;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\n\t\t\t\n\t\t\tfor ( int i=1; i<=N; i++ ) {\n\t\t\t\t\tif ( i != now.wheres ) {\n\t\t\t\t\t\tif ( map[now.wheres][i] > 0 ) {\n\t\t\t\t\t\t\tif ( off[now.wheres][i] != 0 ) {\n\t\t\t\t\t\t\t\tif ( now.budget - map[now.wheres][i] >= 0 ) {\n\t\t\t\t\t\t\t\t\tstatus.push(State(now.budget-map[now.wheres][i],now.people,i));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstatus.push(State(now.budget,now.people+off[now.wheres][i],i));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstatus.push(State(now.budget,now.people,i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( ans == -1 )\n\t\t\tcout << \"No\" << endl;\n\t\telse\n\t\t\tcout << \"Ans: \" <<ans << endl;\n\t}\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int MAX_N = 110;\n\nint n, m, l, ans;\n\nclass C{\n    public:\n        int next, dis, thief;\n        C(int _next, int _dis, int _thief);\n};\n\nC::C(int _next, int _dis, int _thief){\n    next = _next;\n    dis = _dis;\n    thief = _thief;\n}\n\nvector< vector<C> > v;\n\nvoid dfs(int now, int money, int sum_thief, vector<bool> visited){\n    if(now == (n - 1)){\n        ans = min(ans, sum_thief);\n    } else{\n        int s = v[now].size();\n        REP(i, s){\n            C next = v[now][i];\n            if(visited[next.next] == false){\n                visited[next.next] = true;\n                if(money >= next.dis){\n                    dfs(next.next, money - next.dis, sum_thief, visited);\n                }\n                dfs(next.next, money, sum_thief + next.thief, visited);\n                visited[next.next] = false;\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >>n >>m >>l && (n || m || l)){\n        ans = INF;\n        v = vector< vector<C> >(n + 1, vector<C>());\n        REP(i, m){\n            int a, b, d, e;\n            cin >>a >>b >>d >>e;\n            a--;\n            b--;\n            v[a].push_back( C(b, d, e) );\n            v[b].push_back( C(a, d, e) );\n        }\n        vector<bool> visited(n, false);\n        dfs(0, l, 0, visited);\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N, M, L;\nstruct edge{\n  int to, d, n;\n  edge() {}\n  edge(int to, int d, int n) :\n    to(to), d(d), n(n) {}\n};\nvector<edge> edges[101];\nint memo[101][101];\nint dfs(int p, int l, int sum){\n  //printf(\"%d %d -> %d\\n\", p, l, sum);\n  if(p == N - 1) return sum;\n  memo[p][l] = min((memo[p][l]!=-1)?memo[p][l]:INF, sum);\n  int res = INF;\n  FORIT(it, edges[p]){\n    edge e = *it;\n    if(memo[e.to][l] == -1 || memo[e.to][l] > sum + e.n)res = min(res, dfs(e.to, l, sum + e.n));\n    if(l - e.d >= 0 && (memo[e.to][l-e.d] == -1 || memo[e.to][l-e.d] > sum)) res = min(res, dfs(e.to, l - e.d, sum));\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>N>>M>>L && N){\n    REP(i, 101)edges[i].clear();\n    memset(memo, -1, sizeof(memo));\n    REP(i, M){\n      int A,B,D,E;\n      cin>>A>>B>>D>>E;\n      A--; B--;\n      edges[A].push_back(edge(B, D, E));\n      edges[B].push_back(edge(A, D, E));\n    }\n    int ans = dfs(0, L, 0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Brave Princess Revisited\n//Level: 2\n//Category: グラフ,Graph,最短経路,ダイクストラ法,Dijkstra\n//Note:\n\n/*\n * [今いるノード][所持金]を状態にして、刺客の人数について最短経路を求める。\n *\n * ダイクストラ法でオーダーは O(M log N)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Road {\n    int to, fee;\n    int cost;\n\n    Road() {}\n    Road(int t, int f, int c) : to(t), fee(f), cost(c) {}\n};\n\nstruct Tag {\n    int node, money;\n    int cost;\n\n    Tag() {}\n    Tag(int n, int m, int c) : node(n), money(m), cost(c) {}\n\n    bool operator < (const Tag &other) const {\n        return cost > other.cost; // Reverse order\n    }\n};\n\nconst int INF = 10000*100*10;\n\nbool solve() {\n    int N, M, L;\n    cin >> N >> M >> L;\n    if(!N && !M & !L) return false;\n\n    vector<vector<Road> > roads(N);\n    for(int _ = 0; _ < M; ++_) {\n        int a, b, d, e;\n        cin >> a >> b >> d >> e;\n        --a; --b;\n        roads[a].push_back(Road(b, d, e));\n        roads[b].push_back(Road(a, d, e));\n    }\n\n    int ans = INF;\n    priority_queue<Tag> q;\n    vector<vector<int> > memo(N, vector<int>(L+1, INF));\n    memo[0][L] = 0;\n    q.push(Tag(0, L, 0));\n    while(!q.empty()) {\n        const Tag t = q.top();\n        q.pop();\n        if(memo[t.node][t.money] < t.cost) continue;\n        if(t.node == N-1) {\n            ans = t.cost;\n            break;\n        }\n\n        const vector<Road> &v = roads[t.node];\n        for(vector<Road>::const_iterator it = v.begin(); it != v.end(); ++it) {\n            {\n                // Use guard\n                const int nm = t.money - it->fee;\n                if(nm >= 0 && t.cost < memo[it->to][nm]) {\n                    memo[it->to][nm] = t.cost;\n                    q.push(Tag(it->to, nm, t.cost));\n                }\n            }\n            {\n                // Not use guard\n                const int nc = t.cost + it->cost;\n                if(nc < memo[it->to][t.money]) {\n                    memo[it->to][t.money] = nc;\n                    q.push(Tag(it->to, t.money, nc));\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    for(int case_num = 1; solve(); ++case_num) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#define INFTY 1000000000 \nusing namespace std;\n \nint main() {\n    int N, M, L;\n    int a,b;\n    int now,dist;\n    int tmp;\n    cin >> N >> M >> L;\n    for(;N!=0;){\n        vector<vector<bool>> graph(N,vector<bool>(N,false));\n        vector<vector<int>> distance(N,vector<int>(N)),evect(N,vector<int>(N));\n        vector<vector<int>> dp(N,vector<int>(L+1,INFTY));\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\n        for(int i=0; i< M; i++){\n            cin >> a >> b;\n            a--;b--;\n            graph[a][b] = true; graph[b][a] = true;\n            cin >> distance[a][b] >> evect[a][b];\n            distance[b][a] = distance[a][b];\n            evect[b][a] = evect[a][b];\n        }\n        for(int j=L; j>=0 ; j--){\n            q.push(pair<int,int>(0,0));\n            vector<bool> used(N,false);\n            for(;!q.empty();){\n                tie(dist,now) = q.top();\n                q.pop();\n                if(used[now]) continue;\n                used[now] = true;\n                dp[now][j] = dist;\n                for(int i=0; i< N; i++){\n                    if(graph[now][i]){\n                        if(j+distance[now][i]<=L){\n                            tmp = min(dist+evect[now][i],dp[now][j+distance[now][i]]);\n                        }else{ \n                            tmp = dist+evect[now][i];\n                        }\n                        if(dp[i][j] <= tmp) continue;\n                        q.push(pair<int,int>(tmp,i)); \n                    }\n                }\n            }\n        }\n\n        int ans=dp[N-1][L];\n        for(int i=0; i<L ; i++){\n            ans=min(ans,dp[N-1][i]);\n        }\n        cout << ans << endl;\n \n        cin >> N >> M >> L;\n    }\n \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n// int n_dir = 4;\n// int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; [> CSS order <]\n// enum direction {\n\t// UP, RIGHT, DOWN, LEFT\n// };\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// };\n// #define FORDIR(d) REP (d, n_dir)\n\ntypedef complex<int> P;\n#define Y real()\n#define X imag()\nP dyx[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\n// P dyx[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\n\nint g_height, g_width;\nbool in_field(P p) {\n\treturn (0 <= p.Y && p.Y < g_height) && (0 <= p.X && p.X < g_width);\n}\n\n/*}}}*/\n\n// My version of (Extended) Dijkstra\n// Pros: easy to access `costs` -- just `costs(node)`\n//       vector with many parameters is confusing e.g. `costs[param1][param2][param3]...`\n\n// Node should have only parameters with which Node can be distinguished\nclass Node {\npublic:\n\t// Parameters to distinguish Nodes\n\tint id;\n\tint budget;\n\n\tNode(int _id, int _budget): id(_id), budget(_budget) {\n\t}\n};\n\n// for priority_queue\ntypedef pair<int, Node> Qtype; // cost and Node\nclass Comp {\npublic:\n\tbool operator() (const Qtype& l, const Qtype& r) const {\n\t\t// compair costs for each Node\n\t\treturn (l.F > r.F);\n\t}\n};\n\n// easy access to saved costs\n#define MAX_N 100\n#define MAX_L 100\nVVI g_saved_costs(MAX_N, VI(MAX_L));\nvoid init_saved_costs()\n{\n\tREP (i, MAX_N) {\n\t\tREP (j, MAX_L) {\n\t\t\tg_saved_costs[i][j] = INF;\n\t\t}\n\t}\n}\n// VVI g_saved_costs;\nint saved_cost(Node n)\n{\n\treturn g_saved_costs[n.id][n.budget];\n}\nvoid save_cost(Node n, int cost)\n{\n\tg_saved_costs[n.id][n.budget] = cost;\n}\n\nint main()\n{\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N) {\n\t\tVVI dist(N, VI(N, INF));\n\t\tVVI gang(N, VI(N, INF));\n\t\tREP (_, M) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e; --a, --b;\n\t\t\tdist[a][b] = dist[b][a] = d;\n\t\t\tgang[a][b] = gang[b][a] = e;\n\t\t}\n\n\t\t// Initialize g_saved_costs\n\t\tinit_saved_costs();\n\t\t// g_saved_costs = VVI(N, VI(L+1, INF));\n\t\tpriority_queue< Qtype, vector<Qtype>, Comp > q;\n\n\t\tq.push( MP(0, Node(0, L)) );\n\t\twhile (!q.empty()) {\n\t\t\tQtype t = q.top(); q.pop();\n\t\t\tint cost_here = t.F; Node node = t.S;\n\n\t\t\t// Skip if already visited\n\t\t\tif (cost_here > saved_cost(node)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsave_cost(node, cost_here);\n\n\t\t\tREP (i, N) {\n\t\t\t\tif (dist[node.id][i] != INF) {\n\t\t\t\t\t// without guard\n\t\t\t\t\tq.push(MP(cost_here + gang[node.id][i], Node(i, node.budget)));\n\t\t\t\t\tif (dist[node.id][i] <= node.budget) {\n\t\t\t\t\t\t// with guard\n\t\t\t\t\t\tq.push(MP(cost_here, Node(i, node.budget - dist[node.id][i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tREP (i, L+1) {\n\t\t\tans = min(ans, saved_cost(Node(N-1, i)));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<functional>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct State {\n\tint enemy, town, cost;\n\tState(int _enemy, int _town, int _cost) {\n\t\tenemy = _enemy;\n\t\ttown = _town;\n\t\tcost = _cost;\n\t}\n};\n\nstruct Road {\n\tint to, cost, enemy;\n\tRoad(int _to, int _cost, int _enemy) {\n\t\tto = _to;\n\t\tcost = _cost;\n\t\tenemy = _enemy;\n\t}\n};\n\nint N, M, L;\nvector<Road> road[100];\n\nint dijkstra() {\n\tvector<vector<int>>d(100, vector<int>(101, 1000000000));\n\tauto comp = [](const State& s1, const State& s2) {return s1.enemy > s2.enemy; };\n\tpriority_queue<State, vector<State>, decltype(comp)> q(comp);\n\td[0][0] = 0;\n\tq.push(State(0, 0, 0));\n\twhile (!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tif (s.town == N - 1)return s.enemy;\n\t\tif (d[s.town][s.cost] < s.enemy)continue;\n\t\tfor (int i = 0; i < road[s.town].size(); i++) {\n\t\t\tRoad r = road[s.town][i];\n\t\t\tif (d[r.to][s.cost] > d[s.town][s.cost] + r.enemy) {\n\t\t\t\td[r.to][s.cost] = d[s.town][s.cost] + r.enemy;\n\t\t\t\tq.push(State(d[r.to][s.cost], r.to, s.cost));\n\t\t\t}\n\t\t\tif (r.cost + s.cost > L)continue;\n\t\t\tif (d[r.to][s.cost + r.cost] > d[s.town][s.cost]) {\n\t\t\t\td[r.to][s.cost + r.cost] = d[s.town][s.cost];\n\t\t\t\tq.push(State(d[r.to][s.cost + r.cost], r.to, s.cost + r.cost));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N) {\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\troad[a - 1].push_back(Road(b - 1, d, e));\n\t\t\troad[b - 1].push_back(Road(a - 1, d, e));\n\t\t}\n\t\tcout << dijkstra() << endl;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\troad[i].clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<functional>\n#include<map>\n#include<fstream>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = (LL)1e9*(LL)1e5;\n\ntypedef vector<LL> VLL;\ntypedef pair<LL, int> E;\ntypedef vector<list<E>> ADJ;\n#define mp(a,b) make_pair(a,b)\n#define cost(_v) _v.first\n#define to(_v) _v.second\nstruct edge{\n\tLL cost;\n\tLL enemy;\n};\nedge inf = { INF, INF };\ninline VLL dijkstra(int s, ADJ adj){\n\tint n = (int)adj.size();\n\tVLL res(n, -1);\n\tpriority_queue<E, vector<E>, greater<E>> que;\n\tque.push(mp(0ll, s));\n\twhile (que.empty() == false){\n\t\tauto tmp = que.top(); que.pop();\n\t\tauto c = cost(tmp);\n\t\tauto v = to(tmp);\n\t\tif (res[v] >= 0)continue;\n\t\tres[v] = c;\n\t\tfor (auto &i : adj[v]){\n\t\t\tauto d = cost(i);\n\t\t\tauto u = to(i);\n\t\t\tif (res[u] >= 0)continue;\n\t\t\tque.push(mp(c + d, u));\n\t\t}\n\t}\n\n\treturn res;\n};\n\n\nint main(){\n\n\t//ofstream cout(\"out.txt\");\n\twhile (1){\n\t\tint N, M, L;\n\t\tcin >> N >> M >> L;\n\t\tif (N + M + L == 0)return 0;\n\t\tvector<vector<LL>> dp(N + 1, vector<LL>(L + 1, INF));\n\t\tvector<vector<edge>> d(N + 1,vector<edge>(N + 1, inf));\n\t\tADJ adj(N + 1);\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint A, B ;\n\t\t\tLL D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\td[A][B].cost = d[B][A].cost = D;\n\t\t\td[A][B].enemy = d[B][A].enemy = E;\n\t\t\tadj[A].push_back(mp(E, B));\n\t\t\tadj[B].push_back(mp(E, A));\n\t\t}\n\t\tfor (int i = 1; i < N+1; i++){\n\t\t\td[i][i].cost =d[i][i].enemy = 0;\n\t\t}\n\t\tdp[1][0] = 0;\n\n\t\t\n\n\t\tfor (int l = 0; l < L; l++){\n\t\t\tfor (int i = 1; i <= N; i++){\n\t\t\t\tdp[i][l] = min(dp[i][l], dp[i][max(0,l - 1)]);\n\t\t\t}\n\t\t\tadj[1].clear();\n\t\t\tfor (int i = 2; i < N+1; i++){\n\t\t\t\tadj[1].push_back(mp(min(d[1][i].enemy,dp[i][l]), i));\n\t\t\t}\n\t\t\tauto ddd=dijkstra(1, adj);\n\t\t\tfor (int i = 1; i < N+1; i++){\n\t\t\t\tdp[i][l] = ddd[i];\n\t\t\t}\n\t\t\tfor (int i = 1; i <= N; i++){\n\t\t\t\tfor (int j = 1; j <= N; j++){\n\t\t\t\t\tif (l + d[i][j].cost>L)continue;\n\t\t\t\t\tdp[j][l + d[i][j].cost] = min(dp[i][l], dp[j][l + d[i][j].cost]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; i++){\n\t\t\tdp[i][L] = min(dp[i][L], dp[i][L - 1]);\n\t\t}\n\t\tadj[1].clear();\n\t\tfor (int i = 2; i < N + 1; i++){\n\t\t\tadj[1].push_back(mp(min(d[1][i].enemy, dp[i][L]), i));\n\t\t}\n\t\tauto ddd = dijkstra(1, adj);\n\t\tfor (int i = 1; i < N + 1; i++){\n\t\t\tdp[i][L] = ddd[i];\n\t\t}\n\t\tLL res = INF;\n\t\tfor (int i = 0; i < L+1; i++){\n\t\t\tres = min(res, dp[N][i]);\n\t\t}\n\t\t//cout << \"res:\";\n\t\tcout << res << endl;\n\n\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1e+8;\nint N, M, L;\n\nstruct edge{\n\tint to, d, cost;\n\tedge(int to_, int d_, int cost_){\n\t\tto = to_; d = d_; cost = cost_;\n\t}\n};\nstruct State{\n\tint cost, l, v;\n\tState(int cost_, int l_, int v_){\n\t\tcost = cost_; l = l_; v = v_;\n\t}\n};\nbool operator<(const State &a, const State &b){\n\tif( a.cost < b.cost ) return false;\n\tif( a.cost > b.cost ) return true;\n\tif( a.l < b.l ) return true;\n\tif( a.l > b.l ) return false;\n\treturn a.v < b.v;\n}\nvector<edge> G[101];\n\nvoid add_edge(int u, int v, int d, int cost){\n\tG[u].push_back( edge(v, d, cost) );\n\tG[v].push_back( edge(u, d, cost) );\n}\n\n// dp[l][v] := テ、ツスツソテ」ツ?」テ」ツ?淌、ツコツ暗ァツョツ療」ツ??l テ」ツ?ァテゥツ?づァツつケテ」ツ??v テ」ツ?ョテ」ツ?ィテ」ツ?催」ツ?ョティツ・ツイテ」ツつ湘」ツつ古」ツ?淌ヲツ閉オテ」ツ?ョテヲツ閉ー\nint dp[101][101];\n\nint dijkstra(){\n\tfor(int i=0 ; i < 101 ; i++ ){\n\t\tfor(int j=0 ; j < 101 ; j++ ){\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tpriority_queue<State> q;\n\tq.push( State(0, 0, 0) );\n\tdp[0][0] = 0;\n\t\n\tint res = INF;\n\twhile( !q.empty() ){\n\t\tint cost = q.top().cost, l = q.top().l, v = q.top().v;\n\t\tq.pop();\n\t\tif( v == N-1 ){\n\t\t\tres = min(res, cost);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tint to = G[v][i].to, d = G[v][i].d;\n\t\t\t\n\t\t\t// テ」ツ?甘ゥツ?妥」ツつ津、ツスツソテ」ツ??\n\t\t\tif( l + d <= L ){\n\t\t\t\tint next_l = l + d;\n\t\t\t\tint next_cost = cost;\n\t\t\t\tif( next_cost < dp[next_l][to] ){\n\t\t\t\t\tdp[next_l][to] = next_cost;\n\t\t\t\t\tq.push( State(next_cost, next_l, to) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// テ」ツ?甘ゥツ?妥」ツつ津、ツスツソテ」ツつ湘」ツ?ェテ」ツ??\n\t\t\tint next_cost = cost + G[v][i].cost;\n\t\t\tif( next_cost < dp[l][to] ){\n\t\t\t\tdp[l][to] = next_cost;\n\t\t\t\tq.push( State(next_cost, l, to) );\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> N >> M >> L , N || M || L ){\n\t\tfor(int i=0 ; i < 101 ; i++ ) G[i].clear();\n\t\t\n\t\tfor(int i=0 ; i < M ; i++ ){\n\t\t\tint A, B, C, D;\n\t\t\tcin >> A >> B >> C >> D;\n\t\t\tA--; B--;\n\t\t\tadd_edge(A, B, C, D);\n\t\t}\n\t\tcout << dijkstra() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nint N,M,L;\nstruct Edge {\n    int to,d,e;\n};\nstruct Node {\n    int v,cost,money;\n\n    bool operator<(const Node& rhs) const {\n        return cost>rhs.cost;\n    }\n};\nvector<Edge> G[102];\n\nvoid solve() {\n    int dp[102][102];\n    rep(i,102) rep(j,102) dp[i][j]=INF;\n    rep(i,102) G[i].clear();\n\n    dp[0][L]=0;\n    rep(i,M) {\n        int a,b,d,e;\n        cin>>a>>b>>d>>e;\n        a--;\n        b--;\n        G[a].push_back({b,d,e});\n        G[b].push_back({a,d,e});\n    }\n\n    priority_queue<Node,vector<Node>> que;\n    que.push({0,0,L});\n    while(que.size()) {\n        Node node=que.top();\n        que.pop();\n        int v=node.v;\n        int money=node.money;\n\n        //printf(\"[debug] %d %d %d : %d\\n\",v,node.cost,money,dp[v][money]);\n        rep(i,G[v].size()) {\n            Edge e=G[v][i];\n\n            if(chmin(dp[e.to][money],dp[v][money]+e.e)) {\n                que.push({e.to,dp[e.to][money],money});\n            }\n            if(money-e.d>=0 && chmin(dp[e.to][money-e.d],dp[v][money])) {\n                que.push({e.to,dp[e.to][money-e.d],money-e.d});\n            }\n\n        }\n    }\n\n    int ans=INF;\n    rep(i,L+1) chmin(ans,dp[N-1][i]);\n\n    cout<<ans<<endl;\n\n}\n\nint main() {\n    while(cin>>N>>M>>L) {\n        if(!N) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n\t/*\n\titr++;\n\tint min = b+1;\n\t\n\twhile( itr != points[i].end() ) {\t\t\t\t\t\t\t\t\t\n\t\tif ((*itr).second > min) {\n\t\t\t(*itr).second = min;\n\t\t} else {\n\t\t\tmin = (*itr).second+1;\n\t\t}\n\t\titr++;\n\t}\n\t*/\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct edge\n {\n \tint to,cost,enemy;\n }; \n\n struct P\n {\n \tint from, money, enemy;\n \tbool operator >(const P &p) const{\n \t\treturn enemy>p.enemy;\n \t}\n };\n\nint main() {\n\tint N,M,L;\n\twhile(cin >> N >> M >> L, N|M|L){\n\t\tvector<vector<edge> > E=vector<vector<edge> >(N+1);\n\t\tREP(i, M){\n\t\t\tint from, to, cost, enemy;\n\t\t\tcin >> from >> to >> cost >> enemy;\n\t\t\tE[from].push_back((edge){to, cost, enemy});\n\t\t\tE[to].push_back((edge){from, cost, enemy});\n\t\t}\n\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tvector<int> costs=vector<int>(N+1);\n\t\tREP(i, costs.size()){\n\t\t\tcosts[i]=-1;\n\t\t}\n\n\t\tque.push((P){1, L, 0});\n\t\tint res=-1;\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.from==N){\n\t\t\t\tres=p.enemy;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(p.enemy<=costs[p.from])continue;\n\t\t\tcosts[p.from]=p.enemy;\n\t\t\tREP(i, E[p.from].size()){\n\t\t\t\tedge e=E[p.from][i];\n\t\t\t\tif(p.money>=e.cost){\n\t\t\t\t\tque.push((P){e.to, p.money-e.cost,p.enemy});\n\t\t\t\t}\n\t\t\t\tque.push((P){e.to, p.money, p.enemy+e.enemy});\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define mp(a,b) make_pair(a,b)\nusing namespace std;\nstruct edge{int to,cost,danger;};\ntypedef pair<int, int > P;\ntypedef pair<int, P > PP;\n\nint main(){\n  int n,m,l;\n  int inf = 1<<20;\n  cin >> n >> m >> l;\n  while(n!=0){\n    int i,j,k;\n    priority_queue<PP,vector<PP>,greater<PP> > q;\n    P x,b;\n    edge e;\n    vector<edge> v[100];\n    for(i=0;i<m;i++){\n      cin >> k >> e.to >> e.cost >> e.danger;\n      k--;e.to--;\n      v[k].push_back(e);\n      //cout << k << \":\" << e.to << endl;\n      int buf=k;\n      k=e.to;e.to=buf;\n      //cout << k << \":\" << e.to << endl;\n      v[k].push_back(e);\n    }\n    int o=inf;\n    int d[101][100];\n    fill(d[0],d[100],inf);\n    d[0][l]=0;\n    q.push(mp(0,mp(0,l)));\n    \n    while(!q.empty()){\n      PP p=q.top();q.pop();\n      x = p.second;\n      if(d[x.first][x.second] < p.first) continue; \n\n      //cout << p.first << endl;\n\n      for(i=0;i<v[x.first].size();i++){\n\t//cout << x.first <<\":\"<<v[x.first][i].to<<endl;\n\tif(d[v[x.first][i].to][x.second]>d[x.first][x.second]+v[x.first][i].danger){\n\t  d[v[x.first][i].to][x.second]=d[x.first][x.second]+v[x.first][i].danger;\n\t  q.push(mp(d[v[x.first][i].to][x.second],mp(v[x.first][i].to,x.second)));\n\t}\n\tif(x.second>=v[x.first][i].cost){\n\t  if(d[v[x.first][i].to][x.second-v[x.first][i].cost]>d[x.first][x.second]){\n\t    d[v[x.first][i].to][x.second-v[x.first][i].cost]=d[x.first][x.second];\n\t    q.push(mp(d[v[x.first][i].to][x.second-v[x.first][i].cost],mp(v[x.first][i].to,x.second-v[x.first][i].cost)));\n\t  }\n\t}\n      }\n    }\n    for(i=0;i<=l;i++) o=min(o,d[n-1][i]);\n    cout << o << endl;\n    cin >> n >> m >> l;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\n#define INF 0x7fffffff\n\nusing namespace std;\n\ntypedef pair<int, pair<int,int> > PP;\n\nstruct edge{\n\tint to, D, E;\n\tedge(int t, int d, int e): to(t), D(d), E(e) {}\n};\n\n\nint main(){\n\tint N, M, L, A, B, D, E;\n\n\twhile( cin>>N>>M>>L, N|M|L ){\n\t\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\t\tvector<edge> v[105];\n\t\tint dh[105][105];\n\t\tfor(int i=0; i<M; i++){\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tv[A].push_back( edge(B, D, E) );\n\t\t\tv[B].push_back( edge(A, D, E) );\n\t\t}\n\t\tfill(dh[0], dh[0]+105*105, INF);\n\t\t\n\t\tque.push( make_pair(0, make_pair(1,L)) );\n\t\twhile( !que.empty() ){\n\t\t\tPP p = que.top(); que.pop();\n\t\t\tint psf = p.second.first, pss = p.second.second;\n\t\t\tif( pss >= 0 && p.first < dh[psf][pss] ){\n\t\t\t\tdh[psf][pss] = p.first;\n\t\t\t\tfor(int i=0; i<v[psf].size(); i++){\n\t\t\t\t\tedge e = v[psf][i];\n\t\t\t\t\tque.push( make_pair(p.first + e.E, make_pair(e.to, pss)) );\n\t\t\t\t\tque.push( make_pair(p.first, make_pair(e.to, pss-e.D)) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int i=0; i<=L; i++)\n\t\t\tans = min(ans, dh[N][i] );\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define MAX 100000000\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<int,p> P;\n//G@ê@à\nstruct edge{\n\tint to,cost,enem;\n};\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n||m||l){\n\t\tvector<edge> tab[110];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedge pre;\n\t\t\tpre.cost=d;\n\t\t\tpre.enem=e;\n\t\t\tpre.to=b;\n\t\t\ttab[a].push_back(pre);\n\t\t\tpre.to=a;\n\t\t\ttab[b].push_back(pre);\n\t\t}\n\t\tint d[110][110];\n\t\t//d[ê][à]=G;\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<100;j++){\n\t\t\td[i][j]=MAX;\n\t\t}\n\t\td[0][l]=0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,p(0,l)));\n\t\twhile(!que.empty()){\n\t\t\tP now=que.top();\n\t\t\tque.pop();\n\t\t\tint nowplace=now.second.first;\n\t\t\tint nowenem=now.first;\n\t\t\tint nowmoney=now.second.second;\n\t\t\tif(d[nowplace][nowmoney]<nowenem)\n\t\t\t\tcontinue;\n\t\t\td[nowplace][nowmoney]=nowenem;\n\t\t\tfor(int i=0;i<(int)tab[nowplace].size();i++){\n\t\t\t\tedge e=tab[nowplace][i];\n\t\t\t\tif(e.cost<=nowmoney&&d[e.to][nowmoney-e.cost]>nowenem){\n\t\t\t\t\td[e.to][nowmoney-e.cost]=nowenem;\n\t\t\t\t\tque.push(P(nowenem,p(e.to,nowmoney-e.cost)));\n\t\t\t\t}\n\t\t\t\tif(d[e.to][nowmoney]>nowenem+e.enem){\n\t\t\t\t\td[e.to][nowmoney]=nowenem+e.enem;\n\t\t\t\t\tque.push(P(nowenem+e.enem,p(e.to,nowmoney)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=MAX;\n\t\tfor(int i=0;i<=l;i++)\n\t\tans=min(ans,d[n-1][i]);\n\t\tcout<<ans<<endl;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include<set>\n#include <vector>\n\n#define F first\n#define S second\n#define MAX_V 110\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P3;\n\nstruct edge{int to,d,e;};\n\nvector<edge>g[MAX_V];\nint d[MAX_V][101],n,m,l;\n\nvoid dijkstra(int s){\n  priority_queue<P3>que;\n\n  fill(d[0],d[MAX_V],INF);\n  d[s][l]=0;\n  que.push(P3(0,P(l,s)));\n\n  while(!que.empty()){\n    P3 p=que.top();que.pop();\n    int v=p.S.S;\n    if(d[v][p.S.F]<p.F)continue;\n\n    for(int i=0;i<g[v].size();i++){\n      edge e=g[v][i];\n      if(d[e.to][p.S.F]>d[v][p.S.F]+e.e){\n        d[e.to][p.S.F]=d[v][p.S.F]+e.e;\n        que.push(P3(d[e.to][p.S.F],P(p.S.F,e.to)));\n      }\n\n      if(p.S.F-e.d>=0 && d[e.to][p.S.F-e.d]>d[v][p.S.F]){\n        d[e.to][p.S.F-e.d]=d[v][p.S.F];\n        que.push(P3(d[e.to][p.S.F-e.d],P(p.S.F-e.d,e.to)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  while(cin >> n >> m >> l,n|m|l){\n    for(int i=0;i<MAX_V;i++)g[i].clear();\n    int a,b,d1,e;\n    for(int i=0;i<m;i++){\n      cin >> a >> b >> d1 >> e;\n      edge e1,e2;\n      e1.to=b,e1.d=d1,e1.e=e;\n      e2.to=a,e2.d=d1,e2.e=e;\n      g[a].push_back(e1);\n      g[b].push_back(e2);\n    }\n\n    dijkstra(1);\n    int ans=INF;\n    for(int j=0;j<101;j++){\n      ans=min(ans,d[n][j]);\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nint N, M, L;\nint d[5000], e[5000];\nbitset<100> visited;\n\nint solve(int v, int p, int l, vector<pair<int, P>> g[]) {\n    if (v == N-1) {\n        return 0;\n    }\n\n    int res = 1e8;\n    for (auto tmp : g[v]) {\n        int u = tmp.first;\n        int d = tmp.second.first;\n        int e = tmp.second.second;\n        if (visited[u]) continue;\n        if (u == v) continue;\n        visited[u] = true;\n        res = min(res, solve(u, v, l, g) + e);\n        if (e > 0 and l >= d) res = min(res, solve(u, v, l-d, g));\n        visited[u] = false;\n    }\n\n    return res;\n}\n\nint main() {\n    while (cin >> N >> M >> L and N and M and L) {\n        vector<pair<int, P>> g[101];\n        visited.reset();\n        rep(i, M) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            g[a].push_back({b, {d, e}});\n            g[b].push_back({a, {d, e}});\n        }\n        visited[0] = true;\n        cout << solve(0, -1, L, g) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int INF = INT_MAX / 4;\n\nstruct Edge\n{\n\tint to, dist, emer;\n\n\tEdge( int t, int d, int e ) : to( t ), dist( d ), emer( e )\n\t{\n\t\treturn;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n, m, l; cin >> n >> m >> l, n | m | l; )\n\t{\n\t\tvector< vector<Edge> > G( n );\n\t\tREP( i, 0, m )\n\t\t{\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--;\n\t\t\tb--;\n\n\t\t\tG[a].PB( Edge( b, d, e ) );\n\t\t\tG[b].PB( Edge( a, d, e ) );\n\t\t}\n\n\t\tVVI costs( n, VI( l + 1, INF ) );\n\t\tcosts[0][l] = 0;\n\n\t\tpriority_queue< PII, VPII, greater<PII> > que;\n\t\tque.push( MP( 0, l ) );\n\t\t// ( cost, v * 1000 + money )\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tint c = que.top().fst;\n\t\t\tint v = que.top().snd / 1000;\n\t\t\tint money = que.top().snd % 1000;\n\t\t\tque.pop();\n\n\t\t\tif ( costs[v][ money ] < c )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFOR( e, G[v] )\n\t\t\t{\n\t\t\t\tif ( costs[v][ money ] + e.emer < costs[ e.to ][ money ] )\n\t\t\t\t{\n\t\t\t\t\tcosts[ e.to ][ money ] = costs[v][ money ] + e.emer;\n\t\t\t\t\tque.push( MP( costs[v][ money ] + e.emer, e.to * 1000 + money ) );\n\t\t\t\t}\n\t\t\t\tif ( 0 <= money - e.dist && costs[v][ money ] < costs[ e.to ][ money - e.dist ] )\n\t\t\t\t{\n\t\t\t\t\tcosts[ e.to ][ money - e.dist ] = costs[v][ money ];\n\t\t\t\t\tque.push( MP( costs[v][ money ], e.to * 1000 + money - e.dist ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << *min_element( ALL( costs.back() ) ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1 << 30;\n\nstruct edge{\n\tint to;\n\tint cost;\n\tint enemy;\n};\n\nvector<edge> G[200];\nint dis[200][200];\n\nint main(){\n\tint n, m, l;\n\twhile(cin >> n >> m >> l && (n || m || l)){\n\t\tmemset(dis, -1, sizeof(dis));\n\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tedge e;\n\t\t\tint from;\n\t\t\tint to;\n\t\t\tcin >> from >> e.to >> e.cost >> e.enemy;\n\t\t\tG[from].push_back(e);\n\t\t\tto = from;\n\t\t\tfrom = e.to;\n\t\t\te.to = to;\n\t\t\tG[from].push_back(e);\n\t\t}\n\t\tdis[1][l] = 0;\n\t\tque.push(PP(0, P(1, l)));\n\t\twhile(!que.empty()){\n\t\t\tPP pp = que.top(); que.pop();\n\t\t\tP p = pp.second;\n\t\t\tif(dis[p.first][p.second] < pp.first) continue;\n\t\t\tfor(int i = 0; i < G[p.first].size(); i++){\n\t\t\t\tedge e = G[p.first][i];\n\t\t\t\tif(dis[e.to][p.second] < 0 || dis[e.to][p.second] > dis[p.first][p.second] + e.enemy){\n\t\t\t\t\tdis[e.to][p.second] = dis[p.first][p.second] + e.enemy;\n\t\t\t\t\tque.push(PP(dis[e.to][p.second], P(e.to, p.second)));\n\t\t\t\t}\n\t\t\t\tif(p.second >= e.cost){\n\t\t\t\t\tif(dis[e.to][p.second - e.cost] < 0 || dis[e.to - e.cost][p.second] > dis[p.first][p.second]){\n\t\t\t\t\t\tdis[e.to][p.second - e.cost] = dis[p.first][p.second];\n\t\t\t\t\t\tque.push(PP(dis[e.to][p.second - e.cost], P(e.to, p.second - e.cost)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min_dis = INF;\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tif(dis[n][i] >= 0) min_dis = min(min_dis, dis[n][i]);\n\t\t}\n\t\tcout << min_dis << endl;\n\t\tfor(int i = 0; i < 200; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n#define INF 10000000\n\nint main() {\n\tint n, m;\n\tlong long int l;\n\twhile (cin >> n >> m >> l) {\n\t\tif (n == 0 && m == 0 && l == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< vector<long long int> > cc(n, vector<long long int>(n, INF));\n\t\tvector< vector<long long int> > dd(n, vector<long long int>(n, INF));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcc[i][i] = dd[i][i] = 0;\n\t\t}\n\t\tint a, b;\n\t\tlong long int d, e;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tcc[a][b] = cc[b][a] = d;\n\t\t\tdd[a][b] = dd[b][a] = e;\n\t\t}\n\t\tlong long int ans = INF;\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tcc[i][j] = min(cc[i][j], cc[i][k] + cc[k][j]);\n\t\t\t\t\tdd[i][j] = min(dd[i][j], dd[i][k] + dd[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (cc[i][j] <= l) {\n\t\t\t\t\tans = min(ans, dd[0][i] + dd[j][n - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\t//\tState() {}\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min = b;\n\t\twhile ( itr != points[i].end() ) {\n\t\t\tif ( (*itr).second > min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t} else {\n\t\t\t\t(*itr).second = min;\n\t\t\t}\n\t\t\titr++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t\t\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\t\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nstruct State{\n    int v, l, c;\n    State(int v, int l, int c): v(v), l(l), c(c) {}\n    bool operator<(const State& right ) const {\n        return c > right.c;\n    }\n};\n\nstruct edge{\n    int to, l, c;\n    edge(int to, int l, int c): to(to), l(l), c(c) {}\n};\n\nint dp[102][102];\n\nint main(){\n    while(true){\n        int N, M, L;\n        cin >> N >> M >> L;\n        if(N == 0) break;\n\n        vector<vector<edge>> G(N);\n        for(int i=0;i<M;i++){\n            int A, B, D, E;\n            cin >> A >> B >> D >> E;\n            A--; B--;\n            G[A].emplace_back(B, D, E);\n            G[B].emplace_back(A, D, E);\n        }\n\n        int ans = -1;\n        priority_queue<State> que;\n        que.emplace(0, L, 0);\n\n        memset(dp, -1, sizeof(dp));\n        dp[0][L] = 0;\n\n        while(que.size()){\n            State s = que.top(); que.pop();\n            if(dp[s.v][s.l] != -1 && dp[s.v][s.l] < s.c) continue;\n            if(s.v == N-1){\n                ans = s.c;\n                break;\n            }\n            for(edge e : G[s.v]){\n                int nv = e.to, nl = s.l, nc = s.c + e.c;\n                if(dp[nv][nl] == -1 || dp[nv][nl] > nc){\n                    dp[nv][nl] = nc;\n                    que.emplace(nv, nl, nc);\n                }\n            }\n            for(edge e : G[s.v]){\n                if(s.l >= e.l){\n                    int nv = e.to, nl = s.l - e.l, nc = s.c;\n                    if(dp[nv][nl] == -1 || dp[nv][nl] > nc){\n                        dp[nv][nl] = nc;\n                        que.emplace(nv, nl, nc);\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\n//-----------------------------------------------------------------------------\n\nstruct Edge {\n\tint to,dist,danger;\n\tEdge(int to,int dist,int danger):to(to),dist(dist),danger(danger) {}\n};\n\nint hotel,road,money;\nvector<Edge> G[100];\nint d[100][110];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true) {\n\t\tcin>>hotel>>road>>money;\n\t\tif(hotel==0) break;\n\t\tREP(i,road) {\n\t\t\tint u,v,dist,danger;\n\t\t\tcin>>u>>v>>dist>>danger;\n\t\t\tu--,v--;\n\t\t\tG[u].pb(Edge(v,dist,danger));\n\t\t\tG[v].pb(Edge(u,dist,danger));\n\t\t}\n\t\tint d[100][110];\n\t\tREP(i,100) REP(j,110) d[i][j]=INF;\n\t\tpriority_queue<PP,vector<PP>,greater<PP> > pq;\n\t\tpq.push(PP(0,P(0,money)));\n\t\td[0][money]=0;\n\t\twhile(!pq.empty()) {\n\t\t\tPP p=pq.top();pq.pop();\n\t\t\tint v=p.fi,danger_sum=p.se.fi,rest=p.se.se;\n\t\t\tif(d[v][rest]<danger_sum) continue;\n\t\t\tfor(auto e:G[v]) {\n\t\t\t\tif(d[e.to][rest]>danger_sum+e.danger) {\n\t\t\t\t\td[e.to][rest]=danger_sum+e.danger;\n\t\t\t\t\tpq.push(PP(e.to,P(d[e.to][rest],rest)));\n\t\t\t\t}\n\t\t\t\tif(rest-e.dist<0) continue;\n\t\t\t\tif(d[e.to][rest-e.dist]>danger_sum) {\n\t\t\t\t\td[e.to][rest-e.dist]=danger_sum;\n\t\t\t\t\tpq.push(PP(e.to,P(d[e.to][rest-e.dist],rest-e.dist)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tREP(i,110) ans=min(ans,d[hotel-1][i]);\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long int;\n\nstruct Edge{\n    int from, to, dist, enemy;\n};\n\nstruct Node{\n    int num, money, cost;\n    bool operator<(const Node& obj)const{\n        return cost > obj.cost;\n    };\n};\n\nint mini[102][102]; // mini[money][num]\n\nint main(){\n    int n, m, l;\n    while(cin >> n >> m >> l, n != 0){\n        vector<Edge> graph[103];\n        for(int i=0;i<m;++i){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            graph[a].push_back((Edge){a, b, d, e});\n            graph[b].push_back((Edge){b, a, d, e});\n        }\n\n        for(int i=0;i<=100;++i){\n            for(int j=0;j<=100;++j){\n                mini[i][j] = INT_MAX;\n            }\n        }\n\n        mini[l][1] = 0;\n        priority_queue<Node> que;\n        que.push((Node){1, l, 0});\n\n        while(!que.empty()){\n            Node curr = que.top(); que.pop();\n            if(curr.num == n){\n                cout << curr.cost << endl;\n                break;\n            }\n\n            for(auto e : graph[curr.num]){\n                if(curr.money >= e.dist && mini[curr.money-e.dist][e.to] > curr.cost){\n                    mini[curr.money-e.dist][e.to] = curr.cost;\n                    que.push((Node){e.to, curr.money-e.dist, curr.cost});\n                }\n                if(mini[curr.money][e.to] > curr.cost + e.enemy){\n                    mini[curr.money][e.to] = curr.cost + e.enemy;\n                    que.push((Node){e.to, curr.money, curr.cost+e.enemy});\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int n, m, l;\n    while(1){\n        cin >> n >> m >> l;\n        if(n == 0 && m == 0 && l == 0) break;\n        int touzoku[101][101] = {};\n        int money[101][101] = {};\n        int result[101][101];\n        // result[i][j]???j????????£???i????????????????????§?????£??????????????°\n        memset(result, 1000000, sizeof(result));\n        memset(touzoku, -1, sizeof(touzoku));\n        for(int i = 0; i < m; i++){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            touzoku[a][b] = e;\n            touzoku[b][a] = e;\n            money[a][b] = d;\n            money[b][a] = d;\n        }\n        result[0][l] = 0;\n        priority_queue<pair<int, pair<int, int> > > qu;\n        qu.push(make_pair(0, make_pair(0, 0)));\n        while(!qu.empty()){\n            int t = (qu.top()).first;\n            int nowtown = ((qu.top()).second).second;\n            int usedmoney = ((qu.top()).second).first;\n            // cout << t << \" \" << nowtown << \" \" << usedmoney << endl;\n            qu.pop();\n            // cout << result[nowtown] << \" \" << t << endl;\n            if(result[nowtown][usedmoney] <= t) continue;\n            // cout << \"hoge\" << endl;\n            result[nowtown][usedmoney] = t;\n            if(nowtown == n - 1) continue;\n            for(int i = 0; i < n; i++){\n                // cout << touzoku[nowtown][i] << endl;\n                if(touzoku[nowtown][i] != -1){\n                    if(usedmoney + money[nowtown][i] <= l){\n                        qu.push(make_pair(t, make_pair(usedmoney + money[nowtown][i], i)));\n                    }\n                    qu.push(make_pair(t + touzoku[nowtown][i], make_pair(usedmoney, i)));\n                }\n            }\n        }\n        int ans = 10000000;\n        for(int i = 0; i < l + 1; i++) ans = min(ans, result[n - 1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int to,d,e;\n  Edge(int to,int d,int e):to(to),d(d),e(e){}\n};\n\nint N,M,L;\nvector<Edge>G[128];\nint dist[128][128];\n\nvoid dijkstra(){\n  rep(i,128) fill(dist[i], dist[i]+N, INF);\n  dist[L][0] = 0;\n  priority_queue<P, vector<P>, greater<P> >q;\n  q.push(P(L, 0));\n\n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    int v = p.second, m = p.first;\n    rep(i,G[v].size()){\n      Edge e = G[v][i];\n      if(e.d <= m){\n\tif(dist[m-e.d][e.to] > dist[m][v] + e.d){\n\t  dist[m-e.d][e.to] = dist[m][v];\n\t  q.push(P(m-e.d, e.to));\n\t}\n      }\n      if(dist[m][e.to] > dist[m][v] + e.e){\n\tdist[m][e.to] = dist[m][v] + e.e;\n\tq.push(P(m, e.to));\n      }\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d%d%d\", &N,&M,&L) && N+M+L){\n    rep(i,128) G[i].clear();\n    rep(i,M){\n      int a,b,d,e;\n      scanf(\"%d%d%d%d\",&a,&b,&d,&e); a--; b--;\n      G[a].push_back(Edge(b,d,e));\n      G[b].push_back(Edge(a,d,e));\n    }\n\n    dijkstra();\n    int res = INF;\n    rep(i,L+1) res = min(res, dist[i][N-1]);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define tr(it,container) for(typeof(container.begin()) it = container.begin(); \\\n                                                  it != container.end(); ++it)\n#define mp(a,b) make_pair((a),(b))\n\ntypedef long long ll;\ntypedef complex<double> point;\n\n// up right down left\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\nconst double EPS = 1e-9;\nconst int days[]     = {31,28,31,30,31,30,31,31,30,31,30,31};\nconst int daysleap[] = {31,29,31,30,31,30,31,31,30,31,30,31};\n\nconst int INF = 500000000;\n\nstruct Edge{\n    int from,to,cost,danger;\n    Edge(int from,int to,int cost,int danger)\n        : from(from),to(to),cost(cost),danger(danger) {}\n};\n\nint solve(vector<vector<Edge> > graph,int L){\n    int n = graph.size();\n    vector<vector<int> > dp(n,vector<int>(L+1,INF));\n    dp[0][0] = 0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            for(int k=0;k<graph[i].size();k++){\n                const Edge& edge = graph[j][k];\n                for(int l=0;l<=L;l++){\n                    if(dp[j][l] >= INF) continue;\n                    if(l+edge.cost <= L){\n                        int new_cost = l+edge.cost;\n                        int to = edge.to;\n                        int here = dp[j][l];\n                        dp[to][new_cost] = min(dp[to][new_cost],dp[j][l]);\n                    }\n                    dp[edge.to][l] = min(dp[edge.to][l],dp[j][l]+edge.danger);\n                }\n            }\n        }\n    }\n    int ret = INF;\n    for(int i=0;i<=L;i++){\n        ret = min(ret,dp.back()[i]);\n    }\n    return ret;\n}\n\nint main(){\n    while(true){\n        int n,m,l;\n        cin >> n >> m >> l;\n        if(n == 0) break;\n        vector<vector<Edge> > edges(n);\n        for(int i=0;i<m;i++){\n            int a,b,d,e;\n            cin >> a >> b >> d >> e;\n            a--;b--;\n            edges[a].push_back(Edge(a,b,d,e));\n            edges[b].push_back(Edge(b,a,d,e));\n        }\n        cout << solve(edges,l) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nstruct edge { int to, dist, cost; };\nbool operator<(const edge& e1, const edge& e2) { return e1.cost < e2.cost; }\nint N, M, L, a1, a2, a3, a4;\nint main() {\n\twhile (cin >> N >> M >> L, N | M | L) {\n\t\tvector<vector<edge> > G(N);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a1 >> a2 >> a3 >> a4; a1--, a2--;\n\t\t\tG[a1].push_back(edge{ a2, a3, a4 });\n\t\t\tG[a2].push_back(edge{ a1, a3, a4 });\n\t\t}\n\t\tvector<vector<int> > d(N, vector<int>(L + 1, 999999999)); d[0][L] = 0;\n\t\tpriority_queue<edge> que; que.push(edge{ 0, L, 0 });\n\t\twhile (!que.empty()) {\n\t\t\tedge u = que.top(); que.pop();\n\t\t\tfor (edge e : G[u.to]) {\n\t\t\t\tif (u.dist >= e.dist) {\n\t\t\t\t\tint dist1 = u.dist - e.dist;\n\t\t\t\t\tint cost1 = -u.cost;\n\t\t\t\t\tif (d[e.to][dist1] > cost1) {\n\t\t\t\t\t\td[e.to][dist1] = cost1;\n\t\t\t\t\t\tque.push(edge{ e.to, dist1, -cost1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint dist2 = u.dist;\n\t\t\t\tint cost2 = -u.cost + e.cost;\n\t\t\t\tif (d[e.to][dist2] > cost2) {\n\t\t\t\t\td[e.to][dist2] = cost2;\n\t\t\t\t\tque.push(edge{ e.to, dist2, -cost2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << *min_element(d[N - 1].begin(), d[N - 1].end()) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#define INF 10e6;\nusing namespace std;\n\nint cost[101][101][2];  //0距離　1人数\n\nint N,M,L;\n\nstruct node{\n\tint dis;\n\tint n;\n\tint cost;\n\tbool operator <(node a)const{\n    return dis < a.dis;\n  \t}\n\tbool operator >(node a)const{\n    return dis > a.dis;\n  \t}\n};\n\n\nint dijkstra(int g,int l){\n\tnode start;\n\tint ans;\n\tstart.dis=0,start.n=1,start.cost=l;\n\tpriority_queue < node,vector<node>, greater<node> > p;\n\tp.push(start);\n\twhile(!p.empty()){\n\t\tnode tmp=p.top();\n\t\tp.pop();\n\t\tif(tmp.n == g){\n\t\t\tans=tmp.dis;\n\t\t\treturn ans;\n\t\t}\n\t\tfor(int i=1;i<=g;i++){\n\t\t\tif(tmp.n == i)\n\t\t\t\tcontinue;\n\t\t\tnode next;\n\t\t\tnext.n=i;\n\t\t\tif(tmp.cost >= cost[tmp.n][i][0]){\n\t\t\t\tnext.cost=tmp.cost-cost[tmp.n][i][0];\n\t\t\t\tnext.dis=tmp.dis;\n\t\t\t\tp.push(next);\n\t\t\t}\n\t\t\tnext.cost=tmp.cost;\n\t\t\tnext.dis=tmp.dis+cost[tmp.n][i][1];\n\t\t\tp.push(next);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile (cin >> N >> M >> L,N|M|L){\n\t\tfor(int i=0;i<101;i++)\n\t\t\tfor(int j=0;j<101;j++)\n\t\t\t\tcost[i][j][0]=cost[i][j][1]=INF;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tcost[a][b][0]=cost[b][a][0]=d; \n\t\t\tcost[a][b][1]=cost[b][a][1]=e;\n\t\t}\n\t\tint res=dijkstra(N,L);\n\t\tcout << res <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nusing ar3 = array<int, 3>; // to-pos, length(money), threaten\n\nint solve(const vector<vector<ar3>> edges, const int initMoney) {\n\t// init\n\tconst int N = edges.size();\n\tvector<vector<int>> dp(N, vector<int>(initMoney + 1, INF));\n\tpriority_queue<pii> pq;\n\tdp[0][initMoney] = 0;\n\tpq.push({ initMoney,0 });\n\n\t// calc\n\twhile (!pq.empty()) {\n\t\tauto now = pq.top(); pq.pop();\n\t\tint money = now.first;\n\t\tint pos = now.second;\n\t\tint score = dp[pos][money];\n\t\tfor (auto edge : edges[pos]) {\n\t\t\tint next = edge[0];\n\t\t\tint cost = edge[1];\n\t\t\tint enemy = edge[2];\n\n\t\t\t// dangerous\n\t\t\tint nscore = score + enemy;\n\t\t\tif (dp[next][money] > nscore) {\n\t\t\t\tdp[next][money] = nscore;\n\t\t\t\tpq.push({ money,next });\n\t\t\t}\n\n\t\t\t// safe\n\t\t\tint nmoney = money - cost;\n\t\t\tif (nmoney < 0)continue;\n\t\t\tif (dp[next][nmoney] > score) {\n\t\t\t\tdp[next][nmoney] = score;\n\t\t\t\tpq.push({ nmoney,next });\n\t\t\t}\n\t\t}\n\t}\n\n\treturn *min_element(dp.back().begin(), dp.back().end());\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint N, M, L;\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0)break;\n\n\t\tvector<vector<ar3>> info(N);\n\t\tREP(i, M) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--; b--;\n\t\t\tinfo[a].push_back({ b,c,d });\n\t\t\tinfo[b].push_back({ a,c,d });\n\t\t}\n\n\t\tcout << solve(info, L) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint N,M,L;\n\nstruct edge{int to,dist,enemy;};\nstruct state{\n    int node,dist,enemy;\n    bool operator<(const state& right)const{\n        return enemy>right.enemy;\n    }\n};\n\nvector<vector<edge>> v(110);\nint dp[110][110] = {};\nint inf = 1e9;\n\nint main(){\n    while(cin >> N >> M >> L && N>0){\n        for(int i=1;i<=N;i++) v[i].clear();\n        int a,b,d,e;\n        for(int i=0;i<M;i++){\n            cin >> a >> b >> d >> e;\n            v[a].push_back({b,d,e});\n            v[b].push_back({a,d,e});\n        }\n        for(int i=1;i<=N;i++) for(int j=0;j<=L;j++) dp[i][j] = inf;\n        dp[1][L] = 0;\n        priority_queue<state> Q;\n        Q.push({1,L,0});\n        while(!Q.empty()){\n            state now = Q.top(); Q.pop();\n            if(dp[now.node][now.dist]<now.enemy) continue;\n            for(auto x:v[now.node]){\n                state ne = now;\n                ne.node = x.to;\n                //雇わない\n                ne.dist = now.dist;\n                ne.enemy = now.enemy+x.enemy;\n                if(dp[ne.node][ne.dist]>ne.enemy){\n                    dp[ne.node][ne.dist] = ne.enemy;\n                    Q.push(ne);\n                }\n                if(now.dist-x.dist>=0){\n                    ne.dist = now.dist-x.dist;\n                    ne.enemy = now.enemy;\n                    if(dp[ne.node][ne.dist]>ne.enemy){\n                        dp[ne.node][ne.dist] = ne.enemy;\n                        Q.push(ne);\n                    }\n                }\n            }\n        }\n        int ans = inf;\n        for(int i=0;i<=L;i++) ans = min(ans,dp[N][i]);\n        cout << ans << endl;\n    }   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nstruct edge{\n    public:\n        int to,dist,mu;\n        edge(){}\n        edge(int t,int d,int m) : to(t),dist(d),mu(m){}\n};\n\nusing P = pair<int,pair<int,int>>; // killer , node ,remaining\nP makeP(int i,int j,int k){\n    return make_pair(i,make_pair(j,k));\n}\n\n\nvoid solve(int N,int M,int L){\n    vector<vector<edge>> G(N);\n    rep(i,M){\n        int a,b,d,e;\n        cin>>a>>b>>d>>e;\n        a--;\n        b--;\n        G[a].push_back(edge(b,d,e));\n        G[b].push_back(edge(a,d,e));\n    }\n\n    vector<vector<int>> vis(N+2,vector<int>(L+2,INF));\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.push(makeP(0,0,L));\n    vis[0][L]=0;\n    while(!que.empty()){\n        auto q = que.top();\n        que.pop();\n        int u = q.second.first;\n        int rem = q.second.second;\n        int killer = q.first;\n\n//        cerr << \"POP : u=\" << u << \" rem=\" << rem << \" killer=\" << killer << endl; \n\n        if(u==N-1){\n            cout << killer << endl;\n            return;\n        }\n\n\n        if(vis[u][rem] < killer) continue;\n\n        for(edge e : G[u]){\n            int v=e.to;\n            int cost=e.dist;\n            int n_killer=e.mu;\n\n            // not use\n            if(vis[v][rem] > killer+n_killer){\n                vis[v][rem] = killer + n_killer;\n                que.push(makeP(vis[v][rem],v,rem));\n            }\n\n            if(rem-cost>=0 and vis[v][rem-cost]>killer){\n                vis[v][rem-cost] = killer;\n                que.push(makeP(vis[v][rem-cost],v,rem-cost));\n            }\n        }\n    }\n    assert(false);\n}\n\nint main(){\n    int n,m,l;\n    while(cin>>n>>m>>l){\n        if(n==0 && m==0 && l==0) break;\n        solve(n,m,l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<functional>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define INF INT_MAX/2\n\nstruct St {\n\tint node;\n\tint money;\n\tint attack;\n\tSt(int _node, int _money, int _attack) {\n\t\tnode = _node;\n\t\tmoney = _money;\n\t\tattack = _attack;\n\t}\n\n\tbool operator >(const St &e) const {\n\t\treturn attack > e.attack;\n\t}\n};\n\n\nint dp[101][101]; // i?????????????±???§??????????????????j????????????????\\???????????????°???????°????\nint main()\n{\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tpair<int, int> p[101][101];\n\t\tREP(i, 0, N) {\n\t\t\tREP(j, 0, N) {\n\t\t\t\tp[i][j].first = p[i][j].second = INF;\n\t\t\t}\n\t\t}\n\t\tREP(i, 0, M) {\n\t\t\tint A, B, D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tp[A - 1][B - 1].first = p[B - 1][A - 1].first = D;\n\t\t\tp[A - 1][B - 1].second = p[B - 1][A - 1].second = E;\n\t\t}\n\n\t\tREP(i, 0, N) {\n\t\t\tREP(j, 0, L + 1) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][L] = 0;\n\n\t\tpriority_queue<St, vector<St>, greater<St>> pq;\n\t\tSt st(0, L, 0);\n\t\tpq.push(st);\n\t\twhile (!pq.empty()) {\n\t\t\tSt now = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tint nowN = now.node;\n\t\t\tint nowM = now.money;\n\t\t\tint nowA = now.attack;\n\n\t\t\tif (dp[nowN][nowM] < nowA) continue;\n\t\t\tREP(i, 0, N) {\n\t\t\t\tif (p[nowN][i].first == INF) continue;\n\n\t\t\t\t/* ??????????????? */\n\t\t\t\tif (p[nowN][i].first <= nowM) {\n\t\t\t\t\tint nextM = nowM - p[nowN][i].first;\n\t\t\t\t\tint nextA = nowA;\n\n\t\t\t\t\tif (nextA < dp[i][nextM]) {\n\t\t\t\t\t\tdp[i][nextM] = nextA;\n\t\t\t\t\t\tSt nextS(i, nextM, nextA);\n\t\t\t\t\t\tpq.push(nextS);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\t/* ????????????????????? */\n\t\t\t\tint nextM = nowM;\n\t\t\t\tint nextA = nowA + p[nowN][i].second;\n\n\t\t\t\tif (nextA < dp[i][nextM]) {\n\t\t\t\t\tdp[i][nextM] = nextA;\n\t\t\t\t\tSt nextS(i, nextM, nextA);\n\t\t\t\t\tpq.push(nextS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tREP(i, 0, L + 1) {\n\t\t\tans = min(ans, dp[N - 1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nclass Edge {\npublic:\n    int next;\n    int dist;\n    int weight;\n    Edge() {}\n    Edge(int n, int d, int w) {\n\tnext = n;\n\tdist = d;\n\tweight = w;\n    }\n};\n\nclass Info {\npublic:\n    int node;\n    int dist;\n    int left;\n    Info(int n, int d, int l) {\n\tnode = n;\n\tdist = d;\n\tleft = l;\n    }\n    bool operator< (const Info &a) const {\n\tif (dist == a.dist && node == a.node) return left < a.left;\n\treturn dist > a.dist;\n    }\n};\n\nint dist[100][110];\nvector<vector<Edge>> nexts;\n\nsigned main() {\n    int N, M, L;\n    while (cin >> N >> M >> L) {\n\tif (N == 0) break;\n\n\tnexts.clear();\n\tnexts.resize(N);\n\trep(i, 100) rep(j, 101) dist[i][j] = INT_MAX;\n\n\tint A, B, D, E;\n\trep(i, M) {\n\t    cin >> A >> B >> D >> E;\n\t    A--; B--;\n\t    nexts[A].push_back(Edge(B, D, E));\n\t    nexts[B].push_back(Edge(A, D, E));\n\t}\n\n\tpriority_queue<Info> q;\n\tq.push(Info(0, 0, L));\n\twhile (!q.empty()) {\n\t    Info info = q.top(); q.pop();\n\t    if (info.dist > dist[info.node][info.left]) continue;\n\t    if (info.node == N - 1) {\n\t\tcout << info.dist << endl;\n\t\tbreak;\n\t    }\n\t    for (Edge &edge : nexts[info.node]) {\n\t\tif (info.left >= edge.dist && edge.weight > 0) {\n\t\t    if (dist[edge.next][info.left - edge.dist] > info.dist) {\n\t\t\tREP(i, 0, info.left - edge.dist) {\n\t\t\t    if (info.dist >= dist[edge.next][i]) break;\n\t\t\t    dist[edge.next][i] = info.dist;\n\t\t\t}\n\t\t\tq.push(Info(edge.next, info.dist, info.left - edge.dist));\n\t\t    }\n\t\t}\n\t\tint ndist = info.dist + edge.weight;\n\t\tif (dist[edge.next][info.left] > ndist) {\n\t\t    REP(i, 0, info.left) {\n\t\t\tif (dist[edge.next][i] >= ndist) break;\n\t\t\tdist[edge.next][i] = ndist;\n\t\t    }\n\t\t    q.push(Info(edge.next, ndist, info.left));\n\t\t}\n\t    }\n\t}\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n\nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n\nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> used(V,0);\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push(make_pair(0, s));\n\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        if(used[v]) continue;\n        used[v]=true;\n        int cost = st.first;\n        if(cost==INF){\n            break;\n        }\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push(make_pair(d[to], to));\n            }\n        }\n    }\n    return d;\n}\n\nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back(make_pair(e, vv(b, j)));\n                edge[vv(b, j)].push_back(make_pair(e, vv(a, j)));\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back(make_pair(0, vv(b, j - d)));\n                    edge[vv(b, j)].push_back(make_pair(0, vv(a, j - d)));\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n\n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n            \n            res = min(res,val);\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 101;\nconst int MAX_V = 10000;\nconst int INF = 1e+8;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to, d, e;\n\tedge(int v_, int d_, int e_){ \n\t\tto = v_; d = d_; e = e_; \n\t};\n};\n\n// g[u] := ノード u と隣接するエッジのvectorを返す\nvector<edge> g[MAX_N];\n// G[u] := ノード u と隣接するエッジのvectorを返す (解を求めるために使うグラフ)\nvector<edge> G[MAX_V];\n// p = (頂点,持っているお金)をひとつの頂点とみなし, h[p] で対応する頂点番号を返す\nmap<P,int> h;\n// N : 宿の数, id: 生成する頂点番号の管理に使う\nint N, id;\n// d[v] := 始点から頂点 v までの最短距離\nint d[MAX_V];\n// 直前の頂点\nint prev[MAX_V];\n// 最短の頂点番号\nint goal;\n//\nmap<int,bool> hoge;\n//\nint cnt;\n\n// デバッグ用\nvoid debug( vector<int> path ){\n\tfor(map<P,int>::iterator it = h.begin() ; it != h.end() ; ++it ){\n\t\tcout << \"<\" << (it->first).first << \",\" << (it->first).second << \">\";\n\t\tcout << \" = \" << it->second << endl;\n\t}\n\tfor(int i=0 ; i < path.size() ; i++ ){\n\t\tcout << path[i];\n\t\tif( i != path.size()-1 )\n\t\t\tcout << \" => \";\n\t}\n\tcout << endl;\n}\n\n// 初期化\nvoid init(){\n\tfor(int i=0 ; i < MAX_N ; i++ ){\n\t\tg[i].clear();\n\t}\n\th.clear();\n\thoge.clear();\n\tcnt = INF;\n}\n\n// 辺の追加\nvoid add_edge(int u, int v, int d, int e){\n\tedge ed( v , d , e );\n\tg[u].push_back( ed );\n\ted.to = u;\n\tg[v].push_back( ed );\n}\n\n// 辺の追加2\nvoid add_edge2(int u, int v, int cost){\n\tedge ed( v , 0 , cost );\n\tG[u].push_back( ed );\n\t// cout << \"add : (\" << u << \",\" << v << \") = \" << cost << endl; \n}\n\n// <頂点番号,持っているお金>を頂点, 襲われる人数をエッジのコストとしたグラフをつくる\nvoid dfs(int v, int L, map<int,bool> memo){\n\tif( v == N-1 ) return;\n\t\n\tP from( v , L );\n\tif( !h.count( from ) ){\n\t\th[from] = id;\n\t\tid++;\n\t}\n\tint a = h[from];\n\tif( from.first == N-1 ) hoge[a] = true;\n\t\n\tfor(int i=0 ; i < g[v].size() ; i++ ){\n\t\tedge ed = g[v][i];\n\t\tif( memo.count(ed.to) && memo[ed.to] ) continue;\n\t\tmemo[ed.to] = true;\n\t\t\n\t\tP next_1( ed.to , L );\n\t\tif( !h.count( next_1 ) ){\n\t\t\th[next_1] = id;\n\t\t\tid++;\n\t\t}\n\t\tint b = h[next_1];\n\t\tif( next_1.first == N-1 ) hoge[b] = true;\n\t\tadd_edge2( a , b , ed.e );\n\t\tdfs( ed.to , L , memo );\n\t\t\n\t\tif( L >= ed.d ){\n\t\t\tP next_2( ed.to , L - ed.d );\n\t\t\tif( !h.count( next_2 ) ){\n\t\t\t\th[next_2] = id;\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tint c = h[next_2];\n\t\t\tif( next_2.first == N-1 ) hoge[c] = true;\n\t\t\tadd_edge2( a , c , 0 );\n\t\t\tdfs( ed.to , L - ed.d , memo );\n\t\t}\n\t\tmemo[ed.to] = false;\n\t}\n}\n\n// ダイクストラ法\nvoid dijkstra(){\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tfill( d , d + MAX_V , INF );\n\tfill( prev , prev + MAX_V , -1 );\n\td[0] = 0;\n\tq.push( P(0,0) );\n\twhile( !q.empty() ){\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif( hoge.count(v) ){\n\t\t\tcnt = min( cnt , p.first );\n\t\t}\n\t\t\n\t\tif( d[v] < p.first ) continue;\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tedge ed = G[v][i];\n\t\t\tif( d[ed.to] > d[v] + ed.e ){\n\t\t\t\td[ed.to] = d[v] + ed.e;\n\t\t\t\tq.push( P( d[ed.to] , ed.to ) );\n\t\t\t\tprev[ed.to] = v;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 最小値を求める\nint solve(){\n\tint ans = INF;\n\tfor(map<P,int>::iterator it = h.begin() ; it != h.end() ; ++it ){\n\t\tif( (it->first).first == N-1 ){\n\t\t\tint v = h[ it->first ];\n\t\t\tans = min( ans , d[v] );\n\t\t}\n\t}\n\treturn ans;\n}\n\n// 経路復元\nvector<int> get_path(int t){\n\tvector<int> path;\n\tfor( ; t != -1 ; t = prev[t] )\n\t\tpath.push_back( t );\n\treverse( path.begin() , path.end() );\n\treturn path;\n}\n\nint main(){\n\tint M, L;\n\twhile( cin >> N >> M >> L, N || M || L ){\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < M ; i++ ){\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--; b--;\n\t\t\tadd_edge( a , b , d , e );\n\t\t}\n\t\t\n\t\t// グラフの生成\n\t\tid = 0;\n\t\tmap<int,bool> memo;\n\t\tmemo[0] = true;\n\t\tdfs( 0 , L , memo );\n\t\t// ダイクストラ法\n\t\tdijkstra();\n\t\t// 最小コストを求める\n\t\tint ans = solve();\n\t\t// デバッグ\n\t\tvector<int> path = get_path( goal );\n\t\t//debug( path );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, deque<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n\t\n\tint min = b+1;\n\t\n\twhile( itr != points[i].end() ) {\t\t\t\t\t\t\t\t\t\n\t\tif ((*itr).second > min) {\n\t\t\t(*itr).second = min;\n\t\t} else {\n\t\t\tmin = (*itr).second+1;\n\t\t}\n\t\titr++;\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, deque<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing i3 = std::array<int, 3>;\n\n\tusing vi = std::vector<int>;\n\tusing vvi = std::vector<vi>;\n\n\tusing vi3 = std::vector<i3>;\n\tusing vvi3 = std::vector<vi3>;\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint N, M, L;\n\t\tscanf(\"%d%d%d\", &N, &M, &L);\n\t\tif (N == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\n\t\tvvi3 graph(N);\n\t\t// {to, cost, dist}\n\t\tfor (int i{}; i < M; i++)\n\t\t{\n\t\t\tint A, B, D, E;\n\t\t\tscanf(\"%d%d%d%d\", &A, &B, &D, &E);\n\t\t\tA--; B--;\n\t\t\tgraph[A].push_back({B, D, E});\n\t\t\tgraph[B].push_back({A, D, E});\n\t\t}\n\t\tvvi dist(N, vi(L + 1, 1 << 30));\n\t\tdist[0][L] = 0;\n\t\tstd::priority_queue<i3, std::vector<i3>, std::greater<i3>> dij;\n\t\t// {dist, position, rest}\n\t\tdij.push({0, 0, L});\n\t\twhile (!dij.empty())\n\t\t{\n\t\t\t// {dist, position, rest}\n\t\t\tauto now{dij.top()};\n\t\t\tdij.pop();\n\t\t\tif (now[0] > dist[now[1]][now[2]]) continue;\n\t\t\tif (now[1] == N - 1)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", now[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// {to, cost, dist}\n\t\t\tfor (auto& next: graph[now[1]])\n\t\t\t{\n\t\t\t\tif (now[0] + next[2] < dist[next[0]][now[2]])\n\t\t\t\t{\n\t\t\t\t\tdist[next[0]][now[2]] = now[0] + next[2];\n\t\t\t\t\tdij.push({now[0] + next[2], next[0], now[2]});\n\t\t\t\t}\n\t\t\t\tif (next[1] <= now[2] && now[0] < dist[next[0]][now[2] - next[1]])\n\t\t\t\t{\n\t\t\t\t\tdist[next[0]][now[2] - next[1]] = now[0];\n\t\t\t\t\tdij.push({now[0], next[0], now[2] - next[1]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\nint n, m, l;\n\nint d[110][110][110];\n\nint dist[110][110];\n\nint main(){\n\twhile(1){\n\t\tn = in.nextInt(); m = in.nextInt(); l = in.nextInt();\n\t\tif(n == 0 && m == 0 && l == 0) break;\n\t\trep(i, 110) rep(j, 110) rep(k, 110) d[i][j][k] = (i == j ? 0 : INF);\n\t\trep(i, 110) rep(j, 110) dist[i][j] = INF;\n\n\t\trep(i, m){\n\t\t\tint a = in.nextInt() - 1 , b = in.nextInt() - 1, c = in.nextInt(), e = in.nextInt();\n\t\t\td[a][b][l] = d[b][a][l] = e;\n\t\t\tdist[a][b] = dist[b][a] = c;\n\t\t}\n\n\t\tfor(int money = l; money >= 0; money--){\n\t\t\trep(k, n){\n\t\t\t\trep(i, n){\n\t\t\t\t\trep(j, n){\n\t\t\t\t\t\td[i][j][money] = min({d[i][j][money + 1], d[i][j][money], d[i][k][l] + d[k][j][l]});\n\t\t\t\t\t\tif(dist[i][k] <= money) d[i][j][money-dist[i][k]] = min(d[i][j][money-dist[i][k]], d[k][j][l]);\n\t\t\t\t\t\tif(dist[k][j] <= money) d[i][j][money-dist[j][k]] = min(d[i][j][money-dist[j][k]], d[i][k][l]);\n\t\t\t\t\t\tif(dist[i][k] + dist[k][j] <= money) d[i][j][money-(dist[i][k]+dist[k][j])] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, l + 1) ans = min(ans, d[0][n-1][i]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF (1<<9)\n\nstruct P {\n    int from, money, damage;\n\n    bool operator >(const P& p) const {\n        return damage > p.damage;\n    }\n};\n\nstruct edge {\n    int from, cost, damage;\n};\n\nint main() {\n    int town_n, road_n, money;\n    while (cin >> town_n >> road_n >> money, town_n|road_n|money) {\n        vector<vector<edge>> E(town_n+1);\n        REP(i, road_n) {\n            int to, from, cost, damage;\n            cin >> to >> from >> cost >> damage;\n            E[to].push_back({from, cost, damage});\n            E[from].push_back({to, cost, damage});\n        }\n\n        bool G[town_n+1][money+1];\n        fill_n((int *)G, (town_n+1)*(money+1), false);\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({1, money, 0});\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            if (p.from == town_n) {\n                cout << p.damage << endl;\n                break;\n            }\n\n            if (!G[p.from][p.money]) {\n                G[p.from][p.money] = true;\n                for (edge e : E[p.from]) {\n                    if (p.money >= e.cost) {\n                        que.push({e.from, p.money - e.cost, p.damage});\n                    }\n                    que.push({e.from, p.money, p.damage + e.damage});\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 150\n\nint x[MAX_N][MAX_N][2];\nint n, m, l, minx;\nint dp[MAX_N][MAX_N];\n\nint DP(int p, int v) {\n\tmemset(dp, 127, sizeof(dp));\n\tfor (int i = 0; i < p; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (x[j][k][0] < 1000000) {\n\t\t\t\t\tfor (int l = 0; l <= v; l++) {\n\t\t\t\t\t\tif (dp[j][l] < 10000000) {\n\t\t\t\t\t\t\tdp[k][l] = min(dp[k][l], dp[j][l] + x[j][k][1]);\n\t\t\t\t\t\t\tif(l>=x[j][k][0]){\n\t\t\t\t\t\t\t\tdp[j][l - x[j][k][1]] = min(dp[k][l - x[j][k][1]], dp[j][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tminx = 1145141919;\n\tfor (int i = 0; i <= v; i++) {\n\t\tminx = min(minx, dp[p - 1][i]);\n\t}\n\treturn minx;\n}\n\nint a, b, c, d;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m >> l;\n\t\tif (n == 0 && m == 0 && l == 0) { break; }\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tx[a][b][0] = c;\n\t\t\tx[a][b][1] = d;\n\t\t\tx[b][a][0] = c;\n\t\t\tx[b][a][1] = d;\n\t\t}\n\t\tcout << DP(n, l) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst, n;\n  Weight weight;\n  Edge(int src, int dst, Weight weight, int n) :\n    src(src), dst(dst), weight(weight), n(n) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint l;\n\n// ¹öª¢çÈ¢ê\nint dijkstra2(const Graph &g, int s) {\n  int n = g.size();\n  Weight dist[n][l+1];\n  REP(i,n) {\n    REP(j,l+1)\n      dist[i][j] = INF;\n  }\n  dist[s][l] = 0;\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0, l)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (dist[e.dst][e.n] < e.weight) continue;\n    FOR(f,g[e.dst]) {\n      if (e.n >= f->weight && dist[f->dst][e.n-f->weight] > e.weight) { // Ù¤\n        dist[f->dst][e.n-f->weight] = e.weight;\n        Q.push(Edge(f->src, f->dst, e.weight, e.n-f->weight));\n      }\n      if (dist[f->dst][e.n] > e.weight + f->n) { // ÙíÈ¢\n        dist[f->dst][e.n] = e.weight+f->n;\n        Q.push(Edge(f->src, f->dst, e.weight+f->n, e.n));\n      }\n    }\n  }\n  int res = INF;\n  REP(i,l+1) {\n    res = min(res, dist[n-1][i]);\n  }\n  return res;\n}\n\n\nint main() {\n  int n,m;\n  while(cin>>n>>m>>l,n) {\n    Graph g(n);\n    REP(i,m) {\n      int a,b,d,e;\n      cin >>a>>b>>d>>e;\n      a--;b--;\n      g[a].push_back(Edge(a,b,d,e));\n      g[b].push_back(Edge(b,a,d,e));\n    }\n    cout << dijkstra2(g, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct P\n{\n    int p, money, damage;\n\n    bool operator >(const P& p ) const  {\n        return damage > p.damage;\n    }\n};\n\nstruct edge\n{\n    int to, cost, enemy;\n};\n\nint main() {\n    int town_n, road_n, money;\n\n    while(cin >> town_n >> road_n >> money, town_n|road_n|money){\n        vector<edge> E[town_n + 1];\n\n        REP(i, road_n){\n            int from ,to, cost, enemy;\n            cin >> from >> to >> cost >> enemy;\n\n            E[from].push_back({to, cost, enemy});\n            E[to].push_back({from, cost, enemy});\n        }\n\n        int G[town_n + 1][money + 1];\n        fill_n((int*)G, (town_n + 1)*(money + 1), INT_MAX);\n        G[1][money] = 0;\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({1, money, 0});\n        int result = -1;\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n//            printf(\"now town :%d, money:%d, damage: %d\\n\", p.p, p.money, p.damage);\n            if(p.p == town_n){\n                result = p.damage;\n                break;\n            }\n\n            for(edge e:E[p.p]){\n                int to = e.to;\n                int usedmoney = p.money - e.cost;\n                int damaged = p.damage + e.enemy;\n\n                //お金を使う\n                if(usedmoney >= 0 && G[e.to][usedmoney] > p.damage){\n                    que.push({to, usedmoney, p.damage});\n                    G[e.to][usedmoney] = p.damage;\n                }\n                //お金を使わない\n                if(G[e.to][p.money] > damaged){\n                    que.push({to, p.money, damaged});\n                    G[e.to][p.money] = damaged;\n                }\n            }\n        }\n\n        if(result == -1)\n            assert(result);\n\n        cout << result << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, L;\n\nstruct State {\n    int v, sum, dist;\n    State(int v, int sum, int dist) : v(v), sum(sum), dist(dist) {}\n    bool operator<(const State& a) const {\n        return dist > a.dist;\n    }\n};\n\nstruct edge {\n    int to, money, enemy;\n    edge(int to, int money, int enemy):to(to),money(money),enemy(enemy){}\n};\n\nvector<edge> G[101];\nint d[101][101];\n\nvoid dijkstra(int s)\n{\n    for (int i = 0; i <= 100; ++i) for (int j = 0; j < N; ++j) d[i][j] = inf;\n\n    priority_queue<State> q;\n    q.push(State(s, 0, 0));\n\n    d[0][s] = 0;\n\n    while (q.size()) {\n        State st = q.top(); q.pop();\n\n        if (d[st.sum][st.v] < st.dist) continue;\n\n        for (int i = 0; i < G[st.v].size(); ++i) {\n            edge e = G[st.v][i];\n\n            if (st.sum + e.money <= L && d[st.sum + e.money][e.to] >= st.dist) {\n                d[st.sum + e.money][e.to] = st.dist;\n                q.push(State(e.to, st.sum + e.money, d[st.sum + e.money][e.to]));\n            }\n\n            if (d[st.sum][e.to] > st.dist + e.enemy) {\n                d[st.sum][e.to] = st.dist + e.enemy;\n                q.push(State(e.to, st.sum, d[st.sum][e.to]));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    while (scanf(\"%d%d%d\", &N, &M, &L), N) {\n        for (int i = 0; i < N; ++i) G[i].clear();\n\n        for (int i = 0; i < M; ++i) {\n            int A, B, D, E;\n            scanf(\"%d%d%d%d\", &A, &B, &D, &E);\n            A--, B--;\n            G[A].push_back(edge(B, D, E));\n            G[B].push_back(edge(A, D, E));\n        }\n\n        dijkstra(0);\n\n        int mi = inf;\n\n        for (int i = 0; i <= 100; ++i) {\n            chmin(mi, d[i][N - 1]);\n        }\n\n        printf(\"%d\\n\", mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110][110];\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(now==n){\n    ans=min(ans,sum);\n    return;\n  }\n  if(memo[nokori][now]<=sum)return;\n  for(int i=0;i<l;i++)\n    memo[i][now]=min(sum,memo[i][now]);\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      used[E[now][i].to]=true;\n      if(nokori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n      for(int j=0;j<l+5;j++)\n      memo[j][i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<string.h>\nstruct S{int i,c,m;S(int i,int c,int m):i(i),c(c),m(m){}bool operator<(const S&r)const{return c>r.c;}};\n#define C(d) memset(d,X,sizeof(d))\nint main()\n{\n\tint N,M,L,A,B,D,E,X=0x7f7f7f7f;\n\tint d[100][100],e[100][100],x[100][100],i,j;\n\twhile(scanf(\"%d%d%d\",&N,&M,&L),N)\n\t{\n\t\tC(d),C(e),C(x);\n\t\twhile(M--)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&A,&B,&D,&E);\n\t\t\tA--,B--;\n\t\t\td[A][B]=d[B][A]=D;\n\t\t\te[A][B]=e[B][A]=E;\n\t\t}\n\t\tstd::priority_queue<S>q;\n\t\tq.push(S(0,0,L));\n\t\tfor(;;)\n\t\t{\n\t\t\tS p(q.top());q.pop();\n\t\t\tif(x[p.i][p.m]<=p.c)continue;\n\t\t\tif(p.i==N-1){printf(\"%d\\n\",p.c);break;}\n\t\t\tx[p.i][p.m]=p.c;\n\t\t\tfor(i=0;i<N;++i)\n\t\t\t{\n\t\t\t\tif(d[p.i][i]==X)continue;\n\t\t\t\tif(d[p.i][i]<=p.m)q.push(S(i,p.c,p.m-d[p.i][i]));\n\t\t\t\tq.push(S(i,p.c+e[p.i][i],p.m));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Edge {\n  int to;\n  int dist;\n  int cost;\n  Edge() {;}\n  Edge(int to, int dist, int cost) : to(to), dist(dist), cost(cost) {;}\n  bool operator<(const Edge &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nbool visit[110][110];\nint dist[110][110];\nvector<Edge> g[110];\n\nint main() {\n  int n, m, l;\n  while (scanf(\"%d %d %d\", &n, &m, &l), n|m|l) {\n    REP(i, 110) { g[i].clear(); }\n    REP(i, m) {\n      int a, b, d, e;\n      scanf(\"%d %d %d %d\", &a, &b, &d, &e);\n      a--; b--;\n      g[a].push_back(Edge(b, d, e));\n      g[b].push_back(Edge(a, d, e));\n    }\n    MEMSET(visit, false);\n    MEMSET(dist, 0x0f);\n    priority_queue<Edge> que;\n    que.push(Edge(0, 0, 0));\n    int ans = 1 << 30;\n    while (!que.empty()) {\n      Edge e = que.top();\n      que.pop();\n      if (visit[e.to][e.dist]) { continue; }\n      visit[e.to][e.dist] = true;\n      if (e.to == n - 1) { ans = min(ans, e.cost); }\n      FORIT(it, g[e.to]) {\n        int to = it->to;\n        int ndist = e.dist;\n        int ncost = e.cost + it->cost;\n        if (visit[to][ndist]) { continue; }\n        if (ncost >= dist[to][ndist]) { continue; }\n        dist[to][ndist] = ncost;\n        que.push(Edge(to, ndist, ncost));\n      }\n      FORIT(it, g[e.to]) {\n        int to = it->to;\n        int ndist = e.dist + it->dist;\n        int ncost = e.cost;\n        if (ndist > l) { continue; }\n        if (visit[to][ndist]) { continue; }\n        if (ncost >= dist[to][ndist]) { continue; }\n        dist[to][ndist] = ncost;\n        que.push(Edge(to, ndist, ncost));\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nlong long slv(int, int,int);\n\nvector<vector<pair<int, int>>> s(101, vector<pair<int, int>>(101));\nvector<vector< int>> sflag(101, vector<int>(101, 0));\nint n, m, l;\n\nvector<vector<long long>> dp(101, vector<long long>(101, 0));\nvector<vector<int>> dpflag(101, vector<int>(101, 0));\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m >> l;\n\t\tif (n == 0)return 0;\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ts[b][a] = make_pair(d, e);\n\t\t\tsflag[b][a] = 1;\n\t\t\ts[a][b] = make_pair(d, e);\n\t\t\tsflag[a][b] = 1;\n\t\t}\n\t\tlong long answer = 100000000000;\n\t\tfor (int i = 0; i <= l; ++i) {\n\t\t\tif (answer > slv(n, i,0)) answer = slv(n, i,0);\n\n\t\t}\n\t\tcout  << answer <<endl;\n\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tdpflag[i][j] = 0;\n                sflag[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long slv(int N, int L,int count) {\n\tif (count > 200)return 100000000000;\n\tcount++;\n\tfor (int j = 0; j <= 101;j++) dpflag[1][j] = 1;\n\n\tif (dpflag[N][L] == 1) return dp[N][L];\n\tlong long min =   1000000000000;\n\tfor (int a = 1; a <= n; ++a) {\n\t\tlong long x = 2000000000000;\n\t\tlong long y = 3000000000000;\n\t\tif (sflag[N][a] == 1) {\n\t\t\tint LL = L - s[N][a].first;\n\t\t\tif (LL >= 0) {\n\t\t\t\tx = slv(a, LL,count);\n\t\t\t}\n\t\t\ty = slv(a, L,count) + s[N][a].second;\n\t\t}\n\t\tif (min>x) min = x;\n\t\tif (min>y) min = y;\n\t}\n\tdpflag[N][L] = 1;\n\tdp[N][L] = min;\n\n\treturn min;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n#define INF 1000000000\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\nll n,m,l,G[200][200],d[200][200],h[200][200];\nbool used[200][200];\nll memo[200][200];\n\nll dfs(ll i,ll j) {\n    if(i == n - 1) {\n        return 0;\n    }\n    if(used[i][j] && memo[i][j] < 0) {\n        return INF;\n    }\n    if(memo[i][j] >= 0) {\n        return memo[i][j];\n    }\n    used[i][j] = true;\n\n    ll ret = G[i][n - 1];\n    REP(k,n) {\n        if(h[i][k] < INF && i != k) {\n            ret = min(ret,dfs(k,j) + h[i][k]);\n            if(j - d[i][k] >= 0)\n                ret = min(ret,dfs(k,j - d[i][k]));\n        }\n    }\n    return memo[i][j] = ret;\n}\n\nint main(){\n    while(1) {\n        cin >> n >> m >> l;\n        if(n == 0) \n            break;\n\n        REP(i,101) {\n            REP(j,101) {\n                memo[i][j] = -1;\n                used[i][j] = false;\n            }\n        }\n        REP(i,n) {\n            REP(j,n) {\n                G[i][j] = d[i][j] = (i != j ? INF : 0);\n                h[i][j] = (i != j ? INF : 0);\n            }\n        }\n\n        REP(i,m) {\n            ll a,b,dd,e;\n            cin >> a >> b >> dd >> e;\n            a--;b--;\n\n            d[a][b] = d[b][a] = dd;\n            h[a][b] = h[b][a] = G[a][b] = G[b][a] = e;\n        }\n\n        REP(k,n) {\n            REP(i,n) {\n                REP(j,n) {\n                    G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n                }\n            }\n        }\n        cout << dfs(0,l) << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 100000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct miti{\n  int t;\n  int d;\n  LL e;\n};\n\nstruct edge{\n  pair<int,int> t;\n  LL e;\n  bool operator<(const struct edge& r) const{\n    return e>r.e;\n  }\n};\n\nint main(){\n  while(1){\n    int n,m,l;\n    cin >> n >> m >> l;\n    if(n==0) return 0;\n    vector<list<struct miti>> e(n);\n    int a,b,d,ee;\n    for(int i=0;i<m;i++){\n      cin >> a >> b >> d >> ee;\n      e[a-1].push_back({b-1,d,ee});\n      e[b-1].push_back({a-1,d,ee});\n    }\n    vector<vector<LL>> dist(n,vector<LL>(l+1,INF));\n    dist[0][l]=0;\n    priority_queue<struct edge> dijk;\n    for(auto ei:e[0]){\n      if(l-ei.d>=0) dijk.push({{ei.t,l-ei.d},0});\n      dijk.push({{ei.t,l},ei.e});\n    }\n    struct edge ed;\n    while(!dijk.empty()){\n      ed=dijk.top();\n      dijk.pop();\n      if(dist[ed.t.first][ed.t.second]==INF){\n        dist[ed.t.first][ed.t.second]=ed.e;\n        for(auto ei:e[ed.t.first]){\n          if(ed.t.second-ei.d>=0){\n            if(dist[ei.t][ed.t.second-ei.d]==INF){\n              dijk.push({{ei.t,ed.t.second-ei.d},ed.e});\n            }\n          }\n          if(dist[ei.t][ed.t.second]==INF){\n            dijk.push({{ei.t,ed.t.second},ed.e+ei.e});\n          }\n        }\n      }\n    }\n    LL ans=INF;\n    for(int i=0;i<=l;i++){\n      ans=min(ans,dist[n-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\nint N, M, L, a, b, d, e;\nint cnt;\nint hyou[110][110];\n\nint main() {\n\twhile(cin >> N >> M >> L, N) {\n\t\tvector<tuple<int, int, int>> road[110];\n\t\trep(n, N) rep(i, L + 1) hyou[n][i] = 100000000;\n\t\thyou[0][0] = 0;\n\t\trep(m, M) {\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta --;\n\t\t\tb --;\n\t\t\troad[a].push_back(make_tuple(b, d, e));\n\t\t\troad[b].push_back(make_tuple(a, d, e));\n\t\t}\n\t\tdeque<int> dq;\n\t\tdq.push_back(0);\n\t\twhile(!dq.empty()) {\n\t\t\tint p = dq.front() / 1000;\n\t\t\tint c = dq.front() % 1000;\n\t\t\tint t = hyou[p][c];\n\t\t\tdq.pop_front();\n\t\t\tfor(auto r : road[p]) {\n\t\t\t\tint to = get<0>(r);\n\t\t\t\tint nt = get<2>(r) + t;\n\t\t\t\tint nc = get<1>(r) + c;\n\t\t\t\tif(hyou[to][c] > nt) {\n\t\t\t\t\thyou[to][c] = nt;\n\t\t\t\t\tdq.push_back(to * 1000 + c);\n\t\t\t\t}\n\t\t\t\tif (nc <= L and hyou[to][nc] > t) {\n\t\t\t\t\thyou[to][nc] = t;\n\t\t\t\t\tdq.push_back(to * 1000 + nc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 100000000;\n\t\trep(i, L + 1) {\n\t\t\tans = min(hyou[N - 1][i], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct P\n{\n    int p, money, damage;\n\n    bool operator >(const P& p ) const  {\n        return damage > p.damage;\n    }\n};\n\nstruct edge\n{\n    int to, cost, enemy;\n};\n\nint main() {\n    int town_n, road_n, money;\n\n    while(cin >> town_n >> road_n >> money, town_n|road_n|money){\n        vector<edge> E[town_n + 1];\n\n        REP(i, road_n){\n            int from ,to, cost, enemy;\n            cin >> from >> to >> cost >> enemy;\n\n            E[from].push_back({to, cost, enemy});\n            E[to].push_back({from, cost, enemy});\n        }\n\n        int G[town_n+1][money+1];\n        fill_n((int * )G, (town_n+1)*(money+1), 1<<11);\n        G[1][money] = 0;\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({1, money, 0});\n        int result = -1;\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n//            printf(\"now town :%d, money:%d, damage: %d\\n\", p.p, p.money, p.damage);\n            if(p.p == town_n){\n                result = p.damage;\n                break;\n            }\n\n            for(edge e:E[p.p]){\n                int to = e.to;\n                int usedmoney = p.money - e.cost;\n                int damaged = p.damage + e.enemy;\n\n                //お金を使う\n                if(usedmoney >= 0 && G[e.to][usedmoney] > p.damage){\n                    que.push({to, usedmoney, p.damage});\n                    G[e.to][usedmoney] = p.damage;\n                }\n                //お金を使わない\n                if(G[e.to][p.money] > damaged){\n                    que.push({to, p.money, damaged});\n                    G[e.to][p.money] = damaged;\n                }\n            }\n        }\n\n        cout << result << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, deque<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, deque<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m,l;\n    while(cin >> n >> m >> l){\n        vector<vector<piii>>edge(n);\n        if(n+m+l == 0)break;\n        rep(i,m){\n            int a,b,d,e; cin >> a >> b >> d >> e;\n            --a,--b;\n            edge[a].push_back(piii(b,pii(e,d)));\n            edge[b].push_back(piii(a,pii(e,d)));\n        }\n        vector<vector<int>>d(n,vector<int>(l+1,INF));\n        d[0][l] = 0;\n        priority_queue<piii,vector<piii>,greater<piii>>que;\n        que.push(piii(0,pii(0,l)));\n        while(!que.empty()){\n            piii pos = que.top();\n            que.pop();\n            int dis = pos.first;\n            int now = pos.second.first;\n            int mny = pos.second.second;\n            if(dis > d[now][mny])continue;\n            rep(i,edge[now].size()){\n                int next = edge[now][i].first;\n                int cost = edge[now][i].second.first;\n                int fee = edge[now][i].second.second;\n                if(mny >= fee && d[next][mny - fee] > dis){\n                    d[next][mny - fee] = dis;\n                    que.push(piii(dis,pii(next,mny -fee)));\n                }\n                if(d[next][mny] > dis + cost){\n                    d[next][mny] = dis+ cost;\n                    que.push(piii(dis+cost,pii(next,mny)));\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,l+1)cmin(ans, d[n-1][i]);\n        cout <<  ans  << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<vector<int>> memo(N+1, vector<int>(101, 0));\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (memo[current.loc][current.money]) {\n                continue;\n            }\n            memo[current.loc][current.money] = 1;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n            for (size_t i=0; i < edges[current.loc].size(); ++i) {\n                const Edge& e = edges[current.loc][i];\n                // 護衛を雇う\n                if (0 <= current.money - e.dist) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct edge {\n  int to, d, e;\n};\n\nbool visited[102];\nvector<edge> es[102];\nint N, M, L, dp[102][102];\n\nint dfs(int cur, int remain) {\n  if (cur == (N - 1)) return 0;\n  \n  visited[cur] = true;\n  int& ret = dp[cur][remain];\n  if (ret >= 0) {\n    visited[cur] = false;\n    return ret;\n  }\n  ret = 1 << 30;\n\n  rep(i,es[cur].size()) {\n    edge e = es[cur][i];\n    if (visited[e.to]) continue;\n\n    // やとわずすすんでみる\n    ret = min(ret, e.e + dfs(e.to, remain));\n    \n    // やとえるばあいはやとってみる\n    if (e.e > 0 && remain >= e.d) {\n      ret = min(ret, dfs(e.to, remain - e.d));\n    }\n  }\n  \n  visited[cur] = false;\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d%d%d\", &N, &M, &L), N) {\n    rep(i,N) es[i].clear();\n    int a, b, d, e;\n    rep(i,M) {\n      scanf(\"%d%d%d%d\", &a, &b, &d, &e);\n      --a; --b;\n      es[a].push_back((edge){b, d, e});\n      es[b].push_back((edge){a, d, e});\n    }\n    memset(dp, -1, sizeof dp);\n    printf(\"%d\\n\", dfs(0, L));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second \n#define mp make_pair\n#define inf 1<<30\nusing namespace std;\n\nint main()\n{\n  int N,M,L,a,b,c,d;\n  int dis[101][101],th[101][101];\n  int dp[101][101];\n\n  while(1){\n    cin>>N>>M>>L;\n    if(N+M+L==0)break;\n    for(int i=0;i<101;i++){\n      for(int j=0;j<101;j++){\n\tdis[i][j]=th[i][j]=dp[i][j]=inf;\n      }\n    }\n    for(int i=0;i<M;i++){\n      cin>>a>>b>>c>>d;\n      a--;b--;\n      dis[a][b]=c;\n      dis[b][a]=c;\n      th[a][b]=d;\n      th[b][a]=d;\n    }\n    int ans=inf;\n    dp[0][L]=0;\n    priority_queue<pair<int,pair<int,int> > > pq;\n    pq.push(mp(0,mp(0,L)));\n    while(!pq.empty()){\n      pair<int,pair<int,int> > u=pq.top();\n      pq.pop();\n\n      if(dp[u.s.f][u.s.s]<u.f)continue;\n      if(u.s.f==N-1){\n\tans=min(ans,u.f);\n\tcontinue;\n      }\n      \n      for(int i=0;i<N;i++){\n\tif(dis[u.s.f][i]==inf)continue;\n\tint c=u.s.s-dis[u.s.f][i];\n\tif(0<=c){\n\t  if(u.f<dp[i][c]){\n\t    dp[i][c]=u.f;\n\t    pq.push(mp(u.f,mp(i,c)));\n\t  }\n\t}\n\tif(u.f+th[u.s.f][i]<dp[i][u.s.s]){\n\t  dp[i][u.s.s]=u.f+th[u.s.f][i];\n\t  pq.push(mp(u.f+th[u.s.f][i],mp(i,u.s.s)));\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n <= r; } // n in [l, r]?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\ntypedef pair<int, pint> P; // (cost, pos, rem l)\nll dp[111][111]; // (pos, rem l)\npriority_queue<P, vector<P>, greater<P> > q;\nvoid push(int cost, int pos, int rem)\n{\n    if (cost < dp[pos][rem])\n    {\n        dp[pos][rem] = cost;\n        q.push(P(cost, pint(pos, rem)));\n    }\n}\nint main()\n{\n    int n, m, l;\n    while (cin >> n >> m >> l, n)\n    {\n        const ll inf = ten(9);\n        ll d[111][111];\n        ll e[111][111];\n        rep(i, n) rep(j, n)\n            d[i][j] = e[i][j] = inf;\n\n        while (m--)\n        {\n            int a, b, _d, _e;\n            cin >> a >> b >> _d >> _e;\n            --a, --b;\n            d[a][b] = d[b][a] = _d;\n            e[a][b] = e[b][a] = _e;\n        }\n\n        rep(i, n) erep(j, l)\n            dp[i][j] = inf;\n\n        q = priority_queue<P, vector<P>, greater<P> >();\n        dp[0][l] = 0;\n        q.push(P(0, pint(0, l)));\n        while (!q.empty())\n        {\n            P te = q.top();\n            q.pop();\n            \n            int c = te.first, pos = te.second.first, rem = te.second.second;\n            if (pos == n - 1)\n                break;\n            if (c > dp[pos][rem])\n                continue;\n\n            rep(to, n)\n            {\n                push(c + e[pos][to], to, rem);\n                if (rem >= d[pos][to])\n                    push(c, to, rem - d[pos][to]);\n            }\n        }\n        cout << *min_element(dp[n - 1], dp[n - 1] + l + 1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <queue>\n#include <vector>\n#include <tuple>\nusing namespace std;\n\nstruct edge {\n\tint to, cost, enemy;\n\tedge(int to_, int cost_, int enemy_):to(to_), cost(cost_), enemy(enemy_) {}\n};\n\ntypedef vector<vector<edge>> graph;\n\nint dijkstra(const graph &G, int l) {\n\ttypedef tuple<int, int, int> state; // dist, v, money\n\tconst int n = G.size();\n\t\n\tvector<vector<int>> dist(n, vector<int>(l + 1, numeric_limits<int>::max()));\n\tpriority_queue<state, vector<state>, greater<state>> que;\n\n\tdist[0][l] = 0;\n\tque.push(state(0, 0, l));\n\t\n\twhile(!que.empty()) {\n\t\tint d, v, money;\n\t\ttie(d, v, money) = que.top();\n\t\tque.pop();\n\n\t\tif(dist[v][money] < d) continue;\n\t\tif(v == n - 1) return d;\n\t\t\n\t\tfor(const auto &e : G[v]) {\n\t\t\t{ // don't employ\n\t\t\t\tconst int next_dist = d + e.enemy;\n\t\t\t\tif(dist[e.to][money] > next_dist) {\n\t\t\t\t\tdist[e.to][money] = next_dist;\n\t\t\t\t\tque.push(state(next_dist, e.to, money));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(e.cost <= money) { // employ\n\t\t\t\tconst int next_money = money - e.cost;\n\t\t\t\tif(dist[e.to][next_money] > d) {\n\t\t\t\t\tdist[e.to][next_money] = d;\n\t\t\t\t\tque.push(state(d, e.to, next_money));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tassert(false);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t\n\tfor(int n, m, l; cin >> n >> m >> l && n;) {\n\t\tgraph G(n);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\t--a; --b;\n\t\t\tG[a].emplace_back(b, d, e);\n\t\t\tG[b].emplace_back(a, d, e);\n\t\t}\n\t\t\n\t\tcout << dijkstra(G, l) << endl;\n\t}\n\t\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct edge\n {\n \tint to,cost,enemy;\n }; \n\n struct P\n {\n \tint from, money, enemy;\n \tbool operator >(const P &p) const{\n \t\treturn enemy>p.enemy;\n \t}\n };\n\nint main() {\n\tint N,M,L;\n\twhile(cin >> N >> M >> L, N|M|L){\n\t\tvector<vector<edge> > E=vector<vector<edge> >(N+1);\n\t\tREP(i, M){\n\t\t\tint from, to, cost, enemy;\n\t\t\tcin >> from >> to >> cost >> enemy;\n\t\t\tE[from].push_back((edge){to, cost, enemy});\n\t\t\tE[to].push_back((edge){from, cost, enemy});\n\t\t}\n\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tvector<int> costs=vector<int>(N+1);\n\t\tREP(i, costs.size()){\n\t\t\tcosts[i]=-1;\n\t\t}\n\n\t\tque.push((P){1, L, 0});\n\t\tint res=-1;\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.money<=costs[p.from])continue;\n\t\t\tcosts[p.from]=p.money;\n\t\t\tif(p.from==N){\n\t\t\t\tres=p.enemy;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, E[p.from].size()){\n\t\t\t\tedge e=E[p.from][i];\n\t\t\t\tif(p.money>=e.cost){\n\t\t\t\t\tque.push((P){e.to, p.money-e.cost,p.enemy});\n\t\t\t\t}\n\t\t\t\tque.push((P){e.to, p.money, p.enemy+e.enemy});\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct {\n\tint to;\n\tint D;\n\tint E;\n} Edge;\n\nclass State {\npublic:\n\n\tint now;\n\tint money;\n\tint damaged;\n\n\tState(int now, int money, int damaged) {\n\t\tthis->now = now;\n\t\tthis->money = money;\n\t\tthis->damaged = damaged;\n\t}\n\n};\n\nconst int INF  = 999999;\n\nvector<Edge> G[101];\n\nint d[101][101];\n\nint N, M, L;\n\nint toV(int n, int l) {\n\treturn n * L + l;\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N + M + L != 0) {\n\t\tqueue<State> q;\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tG[i].clear();\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint A, B, D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tEdge e { B, D, E };\n\t\t\tEdge e2 { A, D, E };\n\t\t\tG[A].push_back(e);\n\t\t\tG[B].push_back(e2);\n\t\t}\n\t\tq.push(State(1, L, 0));\n\t\twhile (!q.empty()){\n\t\t\tState s = q.front();\n\t\t\tq.pop();\n\t\t\tif (s.damaged >= d[s.now][s.money]) continue;\n\t\t\td[s.now][s.money] = s.damaged;\n\t\t\t\n\t\t\tfor (Edge e : G[s.now])\n\t\t\t{\n\t\t\t\tq.push(State(e.to, s.money, s.damaged + e.E));\n\t\t\t\tif (s.money - e.D >= 0) {\n\t\t\t\t\tq.push(State(e.to, s.money - e.D, s.damaged));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = INF;\n\t\tfor (int i = 0; i <= L; i++) {\n\t\t\tm = min(m, d[N][i]);\n\t\t}\n\t\tcout << m << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Edge;\ntypedef pair<int, P> State;\nconst int INF = 1 << 30;\nvector<Edge> G[100];\nint cost[100][101];\nint main() {\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N) {\n\t\tfor (int i = 0; i < N; i++) G[i].clear();\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint A, B, D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tA--; B--;\n\t\t\tG[A].push_back(Edge(B, P(D, E)));\n\t\t\tG[B].push_back(Edge(A, P(D, E)));\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j <= L; j++) cost[i][j] = INF;\n\t\t}\n\t\tcost[0][L] = 0;\n\t\tpriority_queue<State, vector<State>, greater<State> > Q;\n\t\tQ.push(State(0, P(0, L)));\n\t\twhile (!Q.empty()) {\n\t\t\tState s = Q.top(); Q.pop();\n\t\t\tint d = s.first;\n\t\t\tint from = s.second.first;\n\t\t\tint budget = s.second.second;\n\t\t\tif (cost[from][budget] < d) continue;\n\t\t\tfor (int i = 0; i < G[from].size(); i++) {\n\t\t\t\tint to = G[from][i].first;\n\t\t\t\tint D = G[from][i].second.first;\n\t\t\t\tint E = G[from][i].second.second;\n\t\t\t\tif (cost[to][budget] > cost[from][budget] + E) {\n\t\t\t\t\tcost[to][budget] = cost[from][budget] + E;\n\t\t\t\t\tQ.push(State(cost[to][budget], P(to, budget)));\n\t\t\t\t}\n\t\t\t\tif (D <= budget) {\n\t\t\t\t\tif (cost[to][budget - D] > cost[from][budget]) {\n\t\t\t\t\t\tcost[to][budget - D] = cost[from][budget];\n\t\t\t\t\t\tQ.push(State(cost[to][budget - D], P(to, budget - D)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i <= L; i++) {\n\t\t\tans = min(ans, cost[N - 1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    return a.enemy>b.enemy;\n}\n\nstruct node maps[(int)1e5];\n\nint main()\n{\n    int n,m,l;\n\n    while ((cin>>n>>m>>l) && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            maps[a-1].data.push_back((struct data){b-1,d,e});\n            maps[b-1].data.push_back((struct data){a-1,d,e});\n        }\n        queue.push((struct state){0,l,0});\n        bool flag=true;\n        while (flag){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                cout<<s.enemy<<endl;\n                flag= false;\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.dis<=s.money){\n                        queue.push((struct state){d.to,s.money-d.dis,s.enemy});\n                    }\n                    queue.push((struct state){d.to,s.money,s.enemy+d.ene});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second \n#define mp make_pair\n#define inf 1<<30\nusing namespace std;\n\nint main()\n{\n  int N,M,L,a,b,c,d;\n  int dis[101][101],th[101][101];\n  int dp[101][101];\n\n  while(1){\n    cin>>N>>M>>L;\n    if(N+M+L==0)break;\n    for(int i=0;i<101;i++){\n      for(int j=0;j<101;j++){\n\tdis[i][j]=th[i][j]=dp[i][j]=inf;\n      }\n    }\n    for(int i=0;i<M;i++){\n      cin>>a>>b>>c>>d;\n      a--;b--;\n      dis[a][b]=c;\n      dis[b][a]=c;\n      th[a][b]=d;\n      th[b][a]=d;\n    }\n    int ans=inf;\n    dp[0][L]=0;\n    priority_queue<pair<int,pair<int,int> > > pq;\n    pq.push(mp(0,mp(0,L)));\n    while(!pq.empty()){\n      pair<int,pair<int,int> > u=pq.top();\n      pq.pop();\n      u.f=(-1)*u.f;\n      if(dp[u.s.f][u.s.s]<u.f)continue;\n      if(u.s.f==N-1){\n\tans=u.f;\n\tbreak;\n      }\n      \n      for(int i=0;i<N;i++){\n\tif(dis[u.s.f][i]==inf)continue;\n\tint c=u.s.s-dis[u.s.f][i];\n\tif(0<=c){\n\t  if(u.f<dp[i][c]){\n\t    dp[i][c]=u.f;\n\t    pq.push(mp(u.f*(-1),mp(i,c)));\n\t  }\n\t}\n\tif(u.f+th[u.s.f][i]<dp[i][u.s.s]){\n\t  dp[i][u.s.s]=u.f+th[u.s.f][i];\n\t  pq.push(mp((u.f+th[u.s.f][i])*(-1),mp(i,u.s.s)));\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, deque<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min;\n\t\twhile( itr != points[i].end() ) {\t\t\t\t\t\t\t\t\t\n\t\t\tif ((*itr).second > min) {\n\t\t\t\t(*itr).second = min;\n\t\t\t} else if ( (*itr).second < min ) {\n\t\t\t\tmin = (*itr).second+1;\n\t\t\t}\n\t\t\titr++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, deque<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\n//adjlist[A].first ===== コスト！\n\nvector<int> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\n\nint main(){\n\n    while(1){\n        int n, m, l; cin >> n >> m >> l;\n        if(!n) break;\n        vector<vector<pair<int, int> > > adjlist(100001);\n\n        for(int i = 0; i < m; i++){\n            int a, b, d, e; cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            //護衛を雇わないとき\n            for(int j = 0; j <= l; j++){\n                int A = a + j * 100;\n                int B = b + j * 100;\n                adjlist[A].push_back({e, B});\n                adjlist[B].push_back({e, A});\n                //cout << A << \" \" << B << \" \" << e << endl;            \n            }\n\n            //護衛を雇うとき\n            for(int j = l; j - d >= 0; j--){\n                int A = a + j * 100;\n                int B = b + (j - d) * 100;\n                adjlist[A].push_back({0, B});\n                //cout << A << \" \" << B << \" \" << 0 << endl;                            \n                A = b + j * 100;\n                B = a + (j - d) * 100;\n                adjlist[A].push_back({0, B});     \n                //cout << A << \" \" << B << \" \" << 0 << endl;                                       \n            }\n        }\n\n        vector<int> result(100001);\n        result = dijk(100 * l, 100001, adjlist);\n        //cout << result[G] << endl;\n\n        /*for(int i = 0; i < 10001; i++){\n            cout << i << \": \" << result[i] << endl;\n        }*/\n        int ans = INF;\n        for(int i = 0; i <= l; i++){\n            //cout << n - 1 + 100 * i << \" \" << result[n - 1 + 100 * i] << endl;\n            ans = min(ans, result[n - 1 + i * 100]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 100\n#define MAX_E 10000\n#define INF 1e9\n\nint N, M, L;\nstruct edge{\n  int to, dist, enemy;\n  edge(int to, int dist, int enemy) : to(to), dist(dist), enemy(enemy) {}\n};\n\nstruct State{\n  int v, dist, l;\n  State(int v, int dist, int l) : v(v), dist(dist), l(l) {}\n\n  bool operator < (const State &s)const{\n    return dist > s.dist;\n  }\n};\n\nvector<edge> G[MAX_E];\nint d[MAX_V][MAX_V];\n\nint dijkstra(){\n  int res = INF;\n  priority_queue<State> Q;\n  fill(d[0], d[N], INF);\n  d[0][L] = 0;\n  Q.push(State(0,0,L));\n\n  while(!Q.empty()){\n    State st = Q.top(); Q.pop();\n    int v = st.v;\n\n    if(v == N-1){\n      res = min(res, st.dist);\n      continue;\n    }\n\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      edge e = G[v][i];\n      if(d[e.to][st.l] > d[v][st.l] + e.enemy){\n        d[e.to][st.l] = d[v][st.l] + e.enemy;\n        Q.push(State(e.to, d[e.to][st.l], st.l));\n      }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      edge e = G[v][i];\n      if(st.l - e.dist >= 0 && d[e.to][st.l-e.dist] > d[v][st.l]){\n        d[e.to][st.l-e.dist] = d[v][st.l];\n        Q.push(State(e.to, d[e.to][st.l-e.dist], st.l-e.dist));\n      }\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  int a, b, d, e;\n  while(cin >> N >> M >> L, (N | M | L)){\n    for(int i = 0 ; i < MAX_E ; i++){\n      G[i].clear();\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> a >> b >> d >> e;\n      a--, b--;\n      G[a].push_back(edge(b,d,e));\n      G[b].push_back(edge(a,d,e));\n    }\n    cout << dijkstra() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint N, M, L;\n\nstruct edge {\n\tint to, distance, enemy;\n};\n\nstruct P {\n\tint from, money, enemy;\n\t\n\tbool operator >(const P& p) const {\n\t\treturn enemy > p.enemy;\n\t}\n};\n\nstruct city {\n\tint money, enemy;\n};\n\nint main() {\n\twhile (cin >> N >> M >> L, N|M|L) {\n\t\tvector<vector<edge> > E(N);\n\t\tint a, b, d, e;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tE[a-1].push_back({b, d, e});\n\t\t\tE[b-1].push_back({a, d, e});\n\t\t}\n\t\t\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tcity arr[N];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tarr[i].money = 0;\n\t\t\t// arr[i].enemy = ;\n\t\t}\n\t\tq.push((P){0, L, 0});\n\t\t\twhile(!q.empty()) {\n\t\t\tP p = q.top(); q.pop();\n\t\t\t// goal\n\t\t\tif (p.from == N-1) {\n\t\t\t\tcout << p.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p.money > arr[p.from].money) {\n\t\t\t\tarr[p.from].money = p.money;\n\t\t\t\tarr[p.from].enemy = p.enemy;\n\t\t\t} else if (p.enemy <= arr[p.from].enemy) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < E[p.from].size(); i++) {\n\t\t\t\tedge e = E[p.from][i];\n\t\t\t\tq.push((P){e.to-1, p.money, p.enemy+e.enemy});\n\t\t\t\tif (p.money-e.distance >= 0) {\n\t\t\t\t\tq.push((P){e.to-1, p.money-e.distance, p.enemy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<array>\n\n#define fin cin\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nclass Input{\npublic:\n\tint a;\n\tint b;\n\tint d;\n\tint e;\n\tInput(int _a, int _b, int _d, int _e){\n\t\ta = _a;\n\t\tb = _b;\n\t\td = _d;\n\t\te = _e;\n\t}\n\tbool operator < (Input& other) const\n\t{\n\t\t if(this->a < other.a)return true;\n\t\t else return this->b < other.b;\n\t}\n\tbool operator > (Input& other) const\n\t{\n\t\t if(this->a > other.a)return true;\n\t\t else return this->b > other.b;\n\t}\n\n};\n\nconst int initnum = 10000000;\n\nstd::vector<Input> in_v{};\nstd::array<std::array<int, 100>, 100> cost;\n\nint main()\n{\n\t//std::ifstream fin(\"in.txt\");\n\t//cost[0].fill(0);\n\t//for(int i = 1; i < 100; i++)cost[i].fill(10000000);\n\n\twhile(true)\n\t{\n\t\tcost[0].fill(0);\n\t\t//cost[1].fill(0);\n\t\tfor(int i = 1; i < 100; i++)cost[i].fill(initnum);\n\t\n\t\tint n, m, l;\n\t\tfin >> n >> m >> l;\n\t\tif((n | m | l) == 0)break;\n\t\t//cout << n << \" \" << m << \" \" << l << endl;\n\t\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b, d, e;\n\t\t\tfin >> a >> b >> d >> e;\n\t\t\tin_v.push_back(Input(a-1, b-1, d, e));\n\t\t\tin_v.push_back(Input(b-1, a-1, d, e));\n\t\t}\n\t\tsort(in_v.begin(), in_v.end());\n\n\t\tstd::queue<Input> in_q;\n\t\tfor(auto in : in_v)in_q.push(in);\n\n\t\tin_v.clear();\n\t\tin_v.shrink_to_fit();\n\n\t\twhile(!in_q.empty())\n\t\t{\n\t\t\tInput tmp = in_q.front();\n\t\t\tin_q.pop();\n\n\t\t\tfor(int _cost = 0; _cost <= l; _cost++)\n\t\t\t{\n\n\t\t\t\tif(cost[tmp.a][_cost] == initnum)\n\t\t\t\t{\n\t\t\t\t\tin_q.push(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcost[tmp.b][_cost] = std::min(\n\t\t\t\t\tcost[tmp.b][_cost],\n\t\t\t\t\tstd::min(\n\t\t\t\t\t\t(_cost + tmp.d <= l ? (cost[tmp.a][_cost + tmp.d]) : initnum / 10),\n\t\t\t\t\t\tcost[tmp.a][_cost] + tmp.e\n\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\t\t\tfor(int i = 0; i <= l + 2; i++){\n\t\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\n\t\t}\n\t\tint min_cost = 10000000;\n\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tif(cost[n - 1][i] < min_cost)min_cost = cost[n - 1][i];\n\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t}\n\t\tcout << min_cost << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110][110];\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(now==n){\n    ans=min(ans,sum);\n    return;\n  }\n  if(memo[nokori][now]<=sum)return;\n  for(int i=0;i<nokori;i++)\n    memo[i][now]=min(sum,memo[now]);\n\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      used[E[now][i].to]=true;\n      if(nokori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n      for(int j=0;j<l+5;j++)\n      memo[j][i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <functional>\nusing namespace std;\n\ntypedef long long W;\n\nconst W INF = 1LL << 50;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\ntypedef pair<W, int> P;\ntypedef vector<vector <edge > > Graph;\n\nvoid dijkstra(int s, const Graph& G, vector<W>& d) {\n\tpriority_queue< P, vector<P>, greater<P> > que;\n\tfill(d.begin(), d.end(), INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint toV(int n, int l) {\n\treturn 100 * n + l;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tGraph G(10000);\n\t\twhile(M--) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--, b--;\n\t\t\tfor(int l = 0; l <= L; l++) {\n\t\t\t\tif(l - d >= 0) {\n\t\t\t\t\tG[toV(a, l)].push_back(edge{ toV(b, l - d), 0 });\n\t\t\t\t\tG[toV(b, l)].push_back(edge{ toV(a, l - d), 0 });\n\t\t\t\t}\n\t\t\t\tG[toV(a, l)].push_back(edge{ toV(b, l), e });\n\t\t\t\tG[toV(b, l)].push_back(edge{ toV(a, l), e });\n\t\t\t}\n\t\t}\n\t\tvector<W> d(10000);\n\t\tdijkstra(toV(0, L), G, d);\n\t\tW ans = INF;\n\t\tfor(int l = 0; l <= L; l++) {\n\t\t\tans = min(ans, d[toV(N - 1, l)]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\t//\tState() {}\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min = b;\n\t\twhile ( itr != points[i].end() ) {\n\t\t\tif ( (*itr).second > min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t} else if ( (*itr).second <= min ) {\n\t\t\t\t(*itr).second = min;\n\t\t\t}\n\t\t\tmin++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t\t\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1 << 30;\n\nstruct edge{\n\tint to;\n\tint cost;\n\tint enemy;\n};\n\nvector<edge> G[101];\nint dis[101][101];\n\nint main(){\n\tint n, m, l;\n\twhile(cin >> n >> m >> l && (n || m || l)){\n\t\tmemset(dis, -1, sizeof(dis));\n\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tedge e;\n\t\t\tint from;\n\t\t\tint to;\n\t\t\tcin >> from >> e.to >> e.cost >> e.enemy;\n\t\t\tG[from].push_back(e);\n\t\t\tto = from;\n\t\t\tfrom = e.to;\n\t\t\te.to = to;\n\t\t\tG[from].push_back(e);\n\t\t}\n\t\tdis[1][l] = 0;\n\t\tque.push(PP(0, P(1, l)));\n\t\twhile(!que.empty()){\n\t\t\tPP pp = que.top(); que.pop();\n\t\t\tP p = pp.second;\n\t\t\tif(dis[p.first][p.second] < pp.first) continue;\n\t\t\tfor(int i = 0; i < G[p.first].size(); i++){\n\t\t\t\tedge e = G[p.first][i];\n\t\t\t\tif(dis[e.to][p.second] < 0 || dis[e.to][p.second] > dis[p.first][p.second] + e.enemy){\n\t\t\t\t\tdis[e.to][p.second] = dis[p.first][p.second] + e.enemy;\n\t\t\t\t\tque.push(PP(dis[e.to][p.second], P(e.to, p.second)));\n\t\t\t\t}\n\t\t\t\tif(p.second >= e.cost){\n\t\t\t\t\tif(dis[e.to][p.second - e.cost] < 0 || dis[e.to - e.cost][p.second] < dis[p.first][p.second]){\n\t\t\t\t\t\tdis[e.to][p.second - e.cost] = dis[p.first][p.second];\n\t\t\t\t\t\tque.push(PP(dis[e.to][p.second - e.cost], P(e.to, p.second - e.cost)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min_dis = INF;\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tif(dis[n][i] >= 0) min_dis = min(min_dis, dis[n][i]);\n\t\t}\n\t\tcout << min_dis << endl;\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second \n#define mp make_pair\n#define inf 1<<30\nusing namespace std;\n\nvector<pair<int,pair<int,int> > > v[101];\n\nint main()\n{\n  int N,M,L,a,b,c,d;\n  int dp[101][101];\n\n  while(1){\n    cin>>N>>M>>L;\n    if(N+M+L==0)break;\n    for(int i=0;i<101;i++){\n      for(int j=0;j<101;j++){\n\tdp[i][j]=inf;\n      }\n      v[i].clear();\n    }\n    for(int i=0;i<M;i++){\n      cin>>a>>b>>c>>d;\n      a--;b--;\n      v[a].push_back(mp(b,mp(c,d)));\n      v[b].push_back(mp(a,mp(c,d)));\n    }\n\n    int ans=inf;\n    dp[0][L]=0;\n    priority_queue<pair<int,pair<int,int> > > pq;\n    pq.push(mp(0,mp(0,L)));\n    while(!pq.empty()){\n      pair<int,pair<int,int> > u=pq.top();\n      pq.pop();\n      int now=u.s.f,money=u.s.s,cost=(-1)*u.f;\n      if(dp[now][money]<cost)continue;\n      if(now==N-1){\n\tans=cost;\n\tbreak;\n      }\n      \n      for(int i=0;i<v[now].size();i++){\n\tint next=v[now][i].f,dis=v[now][i].s.f,e=v[now][i].s.s;\n\tint c=money-dis;\n\tif(0<=c){\n\t  if(cost<dp[next][c]){\n\t    dp[next][c]=cost;\n\t    pq.push(mp(cost*(-1),mp(next,c)));\n\t  }\n\t}\n\tif(cost+e<dp[next][money]){\n\t  dp[next][money]=cost+e;\n\t  pq.push(mp((cost+e)*(-1),mp(next,money)));\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nstruct road\n{\n\tint to, cost, k;//???????????????????????????\n};\nvector<road>rinsetu[100];\nint mincost[100][101];//i??°??????j????????£?????????\nstruct A\n{\n\tint x, y, z;//??´????????????????????????\n};\nbool operator <(A b, A c) {\n\tif (b.z != c.z)return b.z > c.z;\n\treturn b.x * 1000 + b.y > c.x * 1000 + c.y;\n}\nsigned main() {\n\tint a, b, c;\n\twhile (scanf(\"%d%d%d\", &a, &b, &c), a || b || c) {\n\t\tfor (int d = 0; d < a; d++) {\n\t\t\trinsetu[d].clear();\n\t\t}\n\t\tfor (int d = 0; d < b; d++) {\n\t\t\tint e, f, g, h; scanf(\"%d%d%d%d\", &e, &f, &g, &h);\n\t\t\te--; f--;\n\t\t\trinsetu[e].push_back({ f,g,h });\n\t\t\trinsetu[f].push_back({ e,g,h });\n\t\t}\n\t\tmemset(mincost, 0x3f, sizeof(mincost));\n\t\tmincost[0][c] = 0;\n\t\tpriority_queue<A>Q;\n\t\tQ.push({0,c,0});\n\t\twhile (Q.size()) {\n\t\t\tA d = Q.top(); Q.pop();\n\t\t\tcout << d.x << \" \" << d.y << \" \" << d.z << endl;\n\t\t\tif (d.z > mincost[d.x][d.y])continue;\n\t\t\tfor (road i : rinsetu[d.x]) {\n\t\t\t\t//?????????????????????\n\t\t\t\tif (mincost[i.to][d.y] > d.z + i.k) {\n\t\t\t\t\tmincost[i.to][d.y] = d.z + i.k;\n\t\t\t\t\tQ.push({i.to,d.y,d.z + i.k });\n\t\t\t\t}\n\t\t\t\t//???????????????\n\t\t\t\tif (d.y >= i.cost) {\n\t\t\t\t\tif (mincost[i.to][d.y - i.cost] > d.z) {\n\t\t\t\t\t\tmincost[i.to][d.y - i.cost] = d.z;\n\t\t\t\t\t\tQ.push({ i.to, d.y - i.cost, d.z });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint MIN = 1 << 29;\n\t\tfor (int i = 0; i <= c; i++) {\n\t\t\tMIN = min(MIN, mincost[a-1][i]);\n\t\t}\n\t\tprintf(\"%d\\n\", MIN);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,m,l,x,y,di,num;\nint d1[101][101],d2[101][101],d[101][101];\nint main(){\n  while(cin>>n>>m>>l,n){\n    memset(d1,0,sizeof(d1));\n    memset(d2,0,sizeof(d2));\n    r(i,n)r(j,101)d[i][j]=1e8;\n    r(i,m){\n      cin>>x>>y>>di>>num;x--;y--;\n      d1[y][x]=d1[x][y]=di;\n      d2[y][x]=d2[x][y]=num;\n    }\n    d[0][l]=0;\n    r(o,n)r(i,n)r(j,n)if(d1[i][j])r(k,l+1)if(d[i][k]!=1e8){\n      if(d1[i][j]<=k)d[j][k-d1[i][j]]=min(d[j][k-d1[i][j]],d[i][k]);\n      d[j][k]=min(d[j][k],d[i][k]+d2[i][j]);\n    }\n    int ans=1e9;\n    r(i,l+1)ans=min(ans,d[n-1][i]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n \n#define rep(i, n) for(int i = 0; i < (n); ++i)\n \nusing namespace std;\n\nconst int inf = 1e9;\n\ntypedef pair<int, int> P;\n\nstruct E{\n    E(int to, int cost): to(to), cost(cost){}\n\n    int to, cost;\n};\n\nint n, m, l;\nvector<E> g[10100];\nint d[10100];\n\nvoid add_edge(int p, int a, int q, int b, int e){\n    g[p * n + a].push_back(E(q * n + b, e));\n}\n\nint dijkstra(){\n    fill_n(d, (l + 1) * n, inf);\n\n    priority_queue<P, vector<P>, greater<P>> q;\n    d[l * n] = 0;\n    q.push(P(0, l * n));\n    while(!q.empty()){\n        P v = q.top();\n        q.pop();\n        if(v.first > d[v.second]){\n            continue;\n        }\n        for(E& e: g[v.second]){\n            if(d[e.to] > v.first + e.cost){\n                d[e.to] = v.first + e.cost;\n                q.push(P(d[e.to], e.to));\n            }\n        }\n    }\n\n    int ans = inf;\n    rep(i, l + 1){\n        ans = min(d[i * n + n - 1], ans);\n    }\n    return ans;\n}\n\nint main(){\n    while(1){\n        cin >> n >> m >> l;\n        \n        if(n == 0){\n            break;\n        }\n\n        rep(i, (l + 1) * n){\n            g[i].clear();\n        }\n\n        rep(i, m){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n\n            for(int j = l; j - d >= 0; --j){\n                add_edge(j, a - 1, j - d, b - 1, 0);\n                add_edge(j, b - 1, j - d, a - 1, 0);\n            }\n            rep(j, l + 1){\n                add_edge(j, b - 1, j, a - 1, e);\n                add_edge(j, a - 1, j, b - 1, e);\n            }\n        }\n\n        cout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst size_t SIZE = 110;\nconst size_t MAX_N = SIZE * SIZE;\nconst ll inf = 5e15;\n\nll make_id(ll n, ll c) {\n    return c * SIZE + n;\n}\n\nll dists[MAX_N];\nV<TLL> edges[SIZE];\n\nbool solve() {\n    ll N, M, L;\n    cin >> N >> M >> L;\n    if (!(N + M + L)) return false;\n    fill(dists, dists + MAX_N, inf);\n    for (ll i = 0; i < SIZE; i++) edges[i].clear();\n    for (ll i = 0; i < M; i++) {\n        ll a, b, d, e;\n        cin >> a >> b >> d >> e;\n        a--; b--;\n        edges[a].emplace_back(b, d, e);\n        edges[b].emplace_back(a, d, e);\n    }\n    dists[make_id(0, 0)] = 0;\n    priority_queue<PLL, V<PLL>, greater<PLL>> pq;\n    pq.emplace(0, 0);\n    while (pq.size()) {\n        ll cur_d, cur_n;\n        tie(cur_d, cur_n) = pq.top();\n        pq.pop();\n        if (dists[cur_n] < cur_d) continue;\n        ll n = cur_n % SIZE;\n        ll used = cur_n / SIZE;\n        for (auto &&e : edges[n]) {\n            ll a, b, c;\n            tie(a, b, c) = e;\n            ll nxt_cl[] = { used + b, used, };\n            ll nxt_dl[] = { cur_d, cur_d + c, };\n            for (ll i = 0; i < 2; i++) {\n                ll nxt_c = nxt_cl[i];\n                ll nxt_d = nxt_dl[i];\n                ll nid = make_id(a, nxt_c);\n                if (L < nxt_c) continue;\n                if (dists[nid] <= nxt_d) continue;\n                dists[nid] = nxt_d;\n                pq.emplace(nxt_d, nid);\n            }\n        }\n    }\n\n    ll ans = inf;\n    for (ll i = 0; i <= L; i++) chmin(ans, dists[make_id(N - 1, i)]);\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, deque<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min;\n\t\twhile( itr != points[i].end() ) {\t\t\t\t\t\t\t\t\t\n\t\t\tif ((*itr).second > min) {\n\t\t\t\t(*itr).second = min;\n\t\t\t} else {\n\t\t\t\tmin = (*itr).second+1;\n\t\t\t}\n\t\t\titr++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, deque<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pll = pair<ll, ll>;\n\nconstexpr int MAX_N = 101*101;\nconstexpr int MAX_L = 100;\n\nclass Dijkstra {\n    public:\n    ll d[MAX_N];\n    priority_queue< Pll, vector<Pll>, greater<Pll> > que;\n    vector<tuple<int, int, int>> edges[MAX_N];\n\n    Dijkstra(){}\n\n    void dijkstra(ll start, int l){\n        fill(d, d+MAX_N, 1LL<<60);\n        d[start*(MAX_L+1) + l] = 0;\n        que.push(Pll(0, start*(MAX_L+1) + l));\n\n        while(!que.empty()){\n            Pll v = que.top(); que.pop();\n            int v_node = v.second/(MAX_L+1), v_l = v.second % (MAX_L+1);\n            if(d[v.second] < v.first) continue;\n            for(auto e: edges[v_node]){\n                int e_node, e_dist, e_theives;\n                tie(e_node, e_dist, e_theives) = e;\n\n                // 護衛をつける\n                // cerr << v_node << \", \" << v_l << \" -> \" << e_node << \", \" << e_dist << \", \" << e_theives << endl;\n                if(v_l-e_dist >= 0 && d[e_node*(MAX_L+1)+(v_l-e_dist)] > d[v.second]){\n                    d[e_node*(MAX_L+1)+(v_l-e_dist)] = d[v.second];\n                    que.push(Pll(d[e_node*(MAX_L+1)+(v_l-e_dist)], e_node*(MAX_L+1)+(v_l-e_dist)));\n                }\n\n                // 護衛をつけない\n                if(d[e_node*(MAX_L+1)+v_l] > d[v.second] + e_theives) {\n                    d[e_node*(MAX_L+1)+v_l] = d[v.second] + e_theives;\n                    que.push(Pll(d[e_node*(MAX_L+1)+v_l], e_node*(MAX_L+1)+v_l));\n                }\n            }\n        }\n    }\n};\n\nll solve(int n, int m, int l) {\n    int a,b,d,e;\n    Dijkstra dijkstra = Dijkstra();\n    for(int i=0;i<m;++i) {\n        cin >> a >> b >> d >> e;\n        --a; --b;\n        dijkstra.edges[a].push_back(make_tuple(b, d, e));\n        dijkstra.edges[b].push_back(make_tuple(a, d, e));\n    }\n\n    dijkstra.dijkstra(0, l);\n\n    // for(int i=0;i<n;++i) {\n    //     for(int j=0;j<=l;++j) {\n    //         cout << dijkstra::d[i*(MAX_L+1)+j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    \n    ll ret = 1<<30;\n    for(int i=0;i<=l;++i) {\n        ret = min(ret, dijkstra.d[(n-1)*(MAX_L+1)+i]);\n    }\n    return ret;\n}\n\nint main() {\n    int n,m,l;\n    while(cin >> n >> m >> l && n) {\n        cout << solve(n, m, l) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int from;\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    return a.enemy>b.enemy;\n}\n\nint main()\n{\n    int n,m,l;\n\n    while ((cin>>n>>m>>l) && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n        struct node maps[200];\n\n        for (int j = 0; j < 100; ++j) {\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            a--;\n            b--;\n            maps[a].data.push_back((struct data){b,d,e});\n            maps[b].data.push_back((struct data){a,d,e});\n        }\n        queue.push((struct state){0,0,l,0});\n        bool flag=true;\n        while (flag){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                cout<<s.enemy<<endl;\n                flag= false;\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.to!=s.from) {\n                        if (d.dis <= s.money) {\n                            queue.push((struct state) {s.number, d.to, s.money - d.dis, s.enemy});\n                        }\n                        queue.push((struct state) {s.number, d.to, s.money, s.enemy + d.ene});\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nstatic const int INF = 1E8;\nstruct Edge{int A, B, D, E;};\nint N, M, L;\nint A, B, D, E;\nvector<Edge> g[111];\nint d[111];\nvector<int> tmp(3);\n\nint main()\n{\n  while(cin >> N >> M >> L, N){\n    rep(i, 111) g[i].clear();\n    rep(i, M){\n      cin >> A >> B >> D >> E;\n      g[A - 1].push_back((Edge){A - 1, B - 1, D, E});\n      g[B - 1].push_back((Edge){B - 1, A - 1, D, E});\n    }\n\n    rep(i, 111) d[i] = INF;\n    d[0] = 0;\n    priority_queue<vector<int>, vector<vector<int> >, greater<vector<int> > > que;\n    tmp[0] = 0,  tmp[1] = 0,  tmp[2] = 0;\n    que.push(tmp);\n    while(!que.empty()){\n      vector<int> top = que.top();  que.pop();\n      int cnt = top[0];\n      int cost = top[1];\n      int h = top[2];\n      //if(d[h] > cnt) continue;\n      if(h == N - 1){\n        printf(\"%d\\n\", cnt);\n        break;\n      }\n      rep(i, g[h].size()){\n        Edge e = g[h][i];\n        tmp[2] = e.B;\n        if(cost <= L && d[e.B] > cnt + e.E){\n          d[e.B] = cnt + e.E;\n          tmp[0] = cnt + e.E;\n          tmp[1] = cost;\n          que.push(tmp);\n        }\n        if(cost + e.D <= L && d[e.B] > cnt){\n          d[e.B] = cnt;\n          tmp[0] = cnt;\n          tmp[1] = cost + e.D;\n          que.push(tmp);\n        }\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <functional>\nusing namespace std;\n\ntypedef long long W;\n\nconst W INF = 1LL << 50;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\ntypedef pair<W, int> P;\ntypedef vector<vector <edge > > Graph;\n\nvoid dijkstra(int s, const Graph& G, vector<W>& d) {\n\tpriority_queue< P, vector<P>, greater<P> > que;\n\tfill(d.begin(), d.end(), INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint toV(int n, int l) {\n\treturn 101 * n + l;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tGraph G(10100);\n\t\twhile(M--) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--, b--;\n\t\t\tfor(int l = 0; l <= L; l++) {\n\t\t\t\tif(l - d >= 0) {\n\t\t\t\t\tG[toV(a, l)].push_back(edge{ toV(b, l - d), 0 });\n\t\t\t\t\tG[toV(b, l)].push_back(edge{ toV(a, l - d), 0 });\n\t\t\t\t}\n\t\t\t\tG[toV(a, l)].push_back(edge{ toV(b, l), e });\n\t\t\t\tG[toV(b, l)].push_back(edge{ toV(a, l), e });\n\t\t\t}\n\t\t}\n\t\tvector<W> d(10100);\n\t\tdijkstra(toV(0, L), G, d);\n\t\tW ans = INF;\n\t\tfor(int l = 0; l <= L; l++) {\n\t\t\tans = min(ans, d[toV(N - 1, l)]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<math.h>\n#include<cmath>\n#include<bitset>\n#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,pll> P;\nstruct edge{\n  ll to;\n  ll cost;\n  ll en;\n  edge(ll t,ll w,ll e) : to(t),cost(w),en(e){}\n};\nint main(){\n  while(1){\n    vector<vector<edge> > g(110);\n    ll i,j,n,m,l,a,b,d,e;\n    ll ds[110][110],ns[110][110];\n    const ll INF=1000000000000;\n    priority_queue<P,vector<P>,greater<P> > que;\n    scanf(\"%lld %lld %lld\\n\",&n,&m,&l);\n    if(n==0 && m==0 && l==0){\n      return 0;\n    }\n    for(i=0;i<m;i++){\n      scanf(\"%lld %lld %lld %lld\\n\",&a,&b,&d,&e);\n      a--,b--;\n      g[a].push_back(edge(b,d,e));\n      g[b].push_back(edge(a,d,e));\n    }\n    for(i=0;i<n;i++){\n      for(j=0;j<=l;j++){\n        ds[i][j]=INF,ns[i][j]=0;\n      }\n    }\n    ds[0][0]=0,ns[0][0]=1;\n    que.push(make_pair(0,pll(0,0)));\n    while(!que.empty()){\n      P p=que.top();\n      ll v=p.second.first,w=p.second.second;\n      que.pop();\n      for(i=0;i<g[v].size();i++){\n        edge us=g[v][i];\n        if(w+us.cost<=l && ds[us.to][w+us.cost]>ds[v][w] && ns[us.to][w+us.cost]==0){\n          ds[us.to][w+us.cost]=ds[v][w];\n          que.push(make_pair(ds[us.to][w+us.cost],pll(us.to,w+us.cost)));\n        }\n        if(ds[us.to][w]>ds[v][w]+us.en && ns[us.to][w]==0){\n          ds[us.to][w]=ds[v][w]+us.en;\n          que.push(make_pair(ds[us.to][w],pll(us.to,w)));\n        }\n      }\n      ns[v][w]=1;\n    }\n    ll ans=INF;\n    for(i=0;i<=l;i++){\n      ans=min(ans,ds[n-1][i]);\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 101\n#define MAX_E 10000\n#define INF 1e9\n\nint N, M, L;\nstruct edge{\n  int to, dist, enemy;\n  edge(int to, int dist, int enemy) : to(to), dist(dist), enemy(enemy) {}\n};\n\nstruct State{\n  int v, dist, l;\n  State(int v, int dist, int l) : v(v), dist(dist), l(l) {}\n\n  bool operator < (const State &s)const{\n    return dist > s.dist;\n  }\n};\n\nvector<edge> G[MAX_E];\nint d[MAX_V][MAX_V];\n\nint dijkstra(){\n  int res = INF;\n  priority_queue<State> Q;\n  fill(d[0], d[N], INF);\n  d[0][L] = 0;\n  Q.push(State(0,0,L));\n\n  while(!Q.empty()){\n    State st = Q.top(); Q.pop();\n    int v = st.v;\n\n    if(v == N-1){\n      res = min(res, st.dist);\n      continue;\n    }\n\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      edge e = G[v][i];\n      if(d[e.to][st.l] > d[v][st.l] + e.enemy){\n        d[e.to][st.l] = d[v][st.l] + e.enemy;\n        Q.push(State(e.to, d[e.to][st.l], st.l));\n      }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      edge e = G[v][i];\n      if(st.l - e.dist >= 0 && d[e.to][st.l-e.dist] > d[v][st.l]){\n        d[e.to][st.l-e.dist] = d[v][st.l];\n        Q.push(State(e.to, d[e.to][st.l-e.dist], st.l-e.dist));\n      }\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  int a, b, d, e;\n  while(cin >> N >> M >> L, (N | M | L)){\n    for(int i = 0 ; i < MAX_E ; i++){\n      G[i].clear();\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> a >> b >> d >> e;\n      a--, b--;\n      G[a].push_back(edge(b,d,e));\n      G[b].push_back(edge(a,d,e));\n    }\n    cout << dijkstra() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<numeric>\n#include<vector>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define rforeach(t,p) for(t::reverse_iterator it=p.rbegin();it!=p.rend();++it)\n#define all(p) p.begin(),p.end()\nusing namespace std;\ntypedef pair<int,int> pp;\ntypedef pair<int,pp> ppp;\n#define LOAD 110\n\n\nint main()\n{\n    int n,m,l;\n    //cin >> n>>m>>l;\n    while(cin >> n >> m >> l && (n || m|| l))\n    {\n        int len[LOAD][LOAD],thi[LOAD][LOAD];\n        for(int i=0;i<LOAD;i++)for(int j=0;j<LOAD;j++)\n        {\n            len[i][j]=len[j][i]=thi[i][j]=thi[j][i]=-1;   \n        }\n        for(int i=0;i<m;i++)\n        {\n            int a,b,c,d;\n            cin >> a>>b>>c>>d;\n            len[a][b]=len[b][a]=c;\n            thi[a][b]=thi[b][a]=d;\n\n        }\n        set<ppp> in;\n        //set<int> visit;\n        in.insert(ppp(0,pp(l,1)));\n        bool pass[LOAD][LOAD];\n        \n        while(!in.empty())\n        {\n            ppp a=(*in.begin());\n            in.erase(in.begin());\n            int e=a.first;\n            int mon=a.second.first;\n            int pos=a.second.second;\n            if(pos==n){cout << e << endl;break;}\n            for(int i=2;i<n+1;i++)if((len[pos][i] != -1 ))\n            {\n                //cout << i << endl;\n                in.insert(ppp(e+thi[pos][i],pp(mon,i)));\n                if(mon+1 >len[pos][i])\n                    in.insert(ppp(e,pp(mon-len[pos][i],i)));\n                //pass[pos][i]=true;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nint num[101][101];\nint dist[101][101];\n#define INF 100000000\n\nclass state{\npublic:\n\tint now,money,cost;\n\tstate(int now,int money,int cost):now(now),cost(cost),money(money){}\n\tbool operator < (const state &a){\n\t\treturn cost>a.cost;\n\t}\n};\n\nbool operator < (state a,state b){\n\treturn a.cost>b.cost;\n}\n\nint main()\n{\n\tint n,m,l;\n\twhile(cin>>n>>m>>l && n!=0){\n\n\t\tint C[101][101];\n\t\tfor(int i=0;i<101;i++)\n\t\t\tfor(int j=0;j<101;j++)\n\t\t\t\tnum[i][j]=dist[i][j]=C[i][j]=INF;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint in,out,d,e;cin>>in>>out>>d>>e;\n\t\t\tnum[in][out]=num[out][in]=e;\n\t\t\tdist[in][out]=dist[out][in]=d;\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(1,l,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate t=Q.top(); Q.pop();\n\t\t\tif(C[t.now][t.money]<=t.cost) continue;\n\t\t\tC[t.now][t.money]=t.cost;\n\t\t\tif(t.now==n){cout<<t.cost<<endl; break;}\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(dist[t.now][i]<INF){\n\t\t\t\t\tif(t.money-dist[t.now][i]>=0)\n\t\t\t\t\t\tQ.push(state(i,t.money-dist[t.now][i],t.cost));\n\t\t\t\t\tQ.push(state(i,t.money,t.cost+num[t.now][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nint num[101][101];\nint dist[101][101];\n#define INF 100000000\n\nclass state{\npublic:\n\tint now,money,cost;\n\tstate(int now,int money,int cost):now(now),cost(cost),money(money){}\n\tbool operator < (const state &a){\n\t\treturn cost>a.cost;\n\t}\n};\n\nbool operator < (state a,state b){\n\treturn a.cost>b.cost;\n}\n\nint main()\n{\n\tint n,m,l;\n\twhile(cin>>n>>m>>l && n!=0){\n\n\t\tint C[101][101];\n\t\tfor(int i=0;i<101;i++)\n\t\t\tfor(int j=0;j<101;j++)\n\t\t\t\tnum[i][j]=dist[i][j]=C[i][j]=INF;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint in,out,d,e;cin>>in>>out>>d>>e;\n\t\t\tnum[in][out]=num[out][in]=e;\n\t\t\tdist[in][out]=dist[out][in]=d;\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(1,l,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate t=Q.top(); Q.pop();\n\t\t\tif(C[t.now][t.money]<=t.cost) continue;\n\t\t\tif(t.now==n){cout<<t.cost<<endl; break;}\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(dist[t.now][i]<INF){\n\t\t\t\t\tif(t.money-dist[t.now][i]>=0)\n\t\t\t\t\t\tQ.push(state(i,t.money-dist[t.now][i],t.cost));\n\t\t\t\t\tQ.push(state(i,t.money,t.cost+num[t.now][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 10000000;\nint main(){\n  while (1){\n    int N, M, L;\n    cin >> N >> M >> L;\n    if (N == 0 && M == 0 && L == 0){\n      break;\n    }\n    int V = N * (L + 1);\n    vector<vector<pair<int, int>>> G(V);\n    for (int i = 0; i < M; i++){\n      int A, B, D, E;\n      cin >> A >> B >> D >> E;\n      A--;\n      B--;\n      for (int j = 0; j <= L; j++){\n        G[A * (L + 1) + j].push_back(make_pair(E, B * (L + 1) + j));\n        G[B * (L + 1) + j].push_back(make_pair(E, A * (L + 1) + j));\n      }\n      for (int j = 0; j <= L - D; j++){\n        G[A * (L + 1) + j].push_back(make_pair(0, B * (L + 1) + j + D));\n        G[B * (L + 1) + j].push_back(make_pair(0, A * (L + 1) + j + D));\n      }\n    }\n    vector<int> d(V, INF);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push(make_pair(0, 0));\n    while (!pq.empty()){\n      int c = pq.top().first;\n      int v = pq.top().second;\n      pq.pop();\n      if (d[v] == INF){\n        d[v] = c;\n        for (auto P : G[v]){\n          int w = P.second;\n          if (d[w] == INF){\n            pq.push(make_pair(c + P.first, w));\n          }\n        }\n      }\n    }\n    int ans = INF;\n    for (int i = 0; i <= L; i++){\n      ans = min(ans, d[(N - 1) * (L + 1) + i]);\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, L;\n\nstruct State {\n    int v, sum, dist;\n    State(int v, int sum, int dist) : v(v), sum(sum), dist(dist) {}\n    bool operator<(const State& a) const {\n        return dist > a.dist;\n    }\n};\n\nstruct edge {\n    int to, money, enemy;\n    edge(int to, int money, int enemy):to(to),money(money),enemy(enemy){}\n};\n\nvector<edge> G[101];\nint d[101][101];\n\nvoid dijkstra(int s)\n{\n    for (int i = 0; i <= 100; ++i) for (int j = 0; j < N; ++j) d[i][j] = inf;\n\n    priority_queue<State> q;\n    q.push(State(s, 0, 0));\n\n    d[0][s] = 0;\n\n    while (q.size()) {\n        State st = q.top(); q.pop();\n\n        if (d[st.sum][st.v] < st.dist) continue;\n\n        for (int i = 0; i < G[st.v].size(); ++i) {\n            edge e = G[st.v][i];\n\n            if (st.sum + e.money <= L) {\n                if (d[st.sum + e.money][e.to] < st.dist) continue;\n                d[st.sum + e.money][e.to] = st.dist;\n                q.push(State(e.to, st.sum + e.money, d[st.sum + e.money][e.to]));\n            }\n\n            if (d[st.sum][e.to] < st.dist + e.enemy) continue;\n            d[st.sum][e.to] = st.dist + e.enemy;\n            q.push(State(e.to, st.sum, d[st.sum][e.to]));\n        }\n    }\n}\n\nsigned main()\n{\n    while (scanf(\"%d%d%d\", &N, &M, &L), N) {\n        for (int i = 0; i < N; ++i) G[i].clear();\n\n        for (int i = 0; i < M; ++i) {\n            int A, B, D, E;\n            scanf(\"%d%d%d%d\", &A, &B, &D, &E);\n            A--, B--;\n            G[A].push_back(edge(B, D, E));\n            G[B].push_back(edge(A, D, E));\n        }\n\n        dijkstra(0);\n\n        int mi = inf;\n\n        for (int i = 0; i <= 100; ++i) {\n            chmin(mi, d[i][N - 1]);\n        }\n\n        printf(\"%d\\n\", mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint N, M, L;\n\nstruct Edge {\n\tint to, dist, enemy;\n\tEdge(int _t, int _d, int _e) : to(_t), dist(_d), enemy(_e) {}\n};\nbool operator > (const Edge& e1, const Edge& e2) {\n\tif (e1.enemy < e2.enemy) return true;\n\telse if (e1.to < e2.to) return true;\n\treturn e1.dist < e2.dist;\n}\nbool operator == (const Edge& e1, const Edge& e2) {\n\tif (e1.enemy == e2.enemy && e1.to==e2.to && e1.dist == e2.dist) return true;\n\treturn false;\n}\nbool operator != (const Edge& e1, const Edge& e2) { return !(e1 == e2); }\nbool operator < (const Edge& e1, const Edge& e2) { return !(e1 > e2) && (e1 != e2); }\nbool operator >= (const Edge& e1, const Edge& e2) { return (e1 > e2) && (e1 == e2); }\nbool operator <= (const Edge& e1, const Edge& e2) { return (e1 < e2) && (e1 == e2); }\n\nconst int INF = 1e9;\nint d[110][110];\n\nint main() {\n\twhile (1) {\n\t\tcin >> N >> M >> L; if (N==0 && M==0 && L==0) break;\n\t\tvector< vector<Edge> > G(N+1, vector<Edge>());\n\t\t\n\t\tfor (int i=0; i<M; i++) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e;\n\t\t\tG[a].push_back(Edge(b, d, e));\n\t\t\tG[b].push_back(Edge(a, d, e));\n\t\t}\n\t\t\n\t\tfor (int i=0; i<=N; i++) fill(d[i], d[i] + L + 1, INF);\n\t\t\n\t\td[1][0] = 0;\n\t\t\n\t\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\t\tq.push( Edge(1, 0, 0) );\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\t\n\t\t\tfor (int i=0; i<(int)G[e.to].size(); i++) {\n\t\t\t\tEdge ne = G[e.to][i];\n\t\t\t\t\n\t\t\t\tif (e.dist + ne.dist <= L) {\n\t\t\t\t\tif (d[ne.to][e.dist + ne.dist] > e.enemy) {\n\t\t\t\t\t\td[ne.to][e.dist + ne.dist] = e.enemy;\n\t\t\t\t\t\tq.push(Edge(ne.to, e.dist + ne.dist, e.enemy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (d[ne.to][e.dist] > e.enemy + ne.enemy) {\n\t\t\t\t\td[ne.to][e.dist] = e.enemy + ne.enemy;\n\t\t\t\t\tq.push(Edge(ne.to, e.dist, e.enemy + ne.enemy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tfor (int i=0; i<=L; i++) ans = min(ans, d[N][i]);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint main(void){\n\tint n, m, l, a, b, d[100][100], e[100][100], f[100][101], i, j, k, x, y, z, mn;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&l);\n\t\tif(n + m + l == 0) break;\n\t\tmemset(d,-1,sizeof(d));\n\t\tmemset(e,-1,sizeof(e));\n\t\tfor(i = 0;i < m;i++){\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&j,&k);\n\t\t\td[a - 1][b - 1] = j;\n\t\t\td[b - 1][a - 1] = j;\n\t\t\te[a - 1][b - 1] = k;\n\t\t\te[b - 1][a - 1] = k;\n\t\t}\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[0][l] = 0;\n\t\tque.push(PP(0,P(l,0))); // 敵との合流回数 お金 町の番号\n\t\twhile(que.size()){\n\t\t\tx = que.top().first, y = que.top().second.first, z = que.top().second.second;\n\t\t\tque.pop();\n\t\t\tfor(i = 0;i < n;i++){\n\t\t\t\tif(d[z][i] != -1){\n\t\t\t\t\tif(y >= d[z][i] && (f[i][y - d[z][i]] == -1 || f[i][y - d[z][i]] > f[z][y])){\n\t\t\t\t\t\tque.push(PP(x,P(y - d[z][i],i)));\n\t\t\t\t\t\tf[i][y - d[z][i]] = x;\n\t\t\t\t\t}\n\t\t\t\t\tif(f[i][y] == -1 || f[i][y] > x + e[z][i]){\n\t\t\t\t\t\tque.push(PP(x + e[z][i],P(y,i)));\n\t\t\t\t\t\tf[i][y] = x + e[z][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmn = 0x7FFFFFFF;\n\t\tfor(i = 0;i <= l;i++)\n\t\t\tif(f[n - 1][i] != -1) mn = min(mn,f[n - 1][i]);\n\t\tprintf(\"%d\\n\",mn);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 101;\nconst int MAX_V = 10000;\nconst int INF = 1e+8;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to, d, e;\n\tedge(int v_, int d_, int e_){ \n\t\tto = v_; d = d_; e = e_; \n\t};\n};\n\n// g[u] := ノード u と隣接するエッジのvectorを返す\nvector<edge> g[MAX_N];\n// G[u] := ノード u と隣接するエッジのvectorを返す (解を求めるために使うグラフ)\nvector<edge> G[MAX_V];\n// p = (頂点,持っているお金)をひとつの頂点とみなし, h[p] で対応する頂点番号を返す\nmap<P,int> h;\n// N : 宿の数, id: 生成する頂点番号の管理に使う\nint N, id;\n// d[v] := 始点から頂点 v までの最短距離\nint d[MAX_V];\n\n// デバッグ用\nvoid debug( vector<int> path ){\n\tfor(map<P,int>::iterator it = h.begin() ; it != h.end() ; ++it ){\n\t\tcout << \"<\" << (it->first).first << \",\" << (it->first).second << \">\";\n\t\tcout << \" = \" << it->second << endl;\n\t}\n\tfor(int i=0 ; i < path.size() ; i++ ){\n\t\tcout << path[i];\n\t\tif( i != path.size()-1 )\n\t\t\tcout << \" => \";\n\t}\n\tcout << endl;\n}\n\nvoid debug_2(){\n\tcout << \"[debug]\" << endl;\n\tfor(int v=0 ; v < id ; v++ ){\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tedge ed = G[v][i];\n\t\t\tcout << \"(\" << v << \",\" << ed.to << \") = \" << ed.e << endl;\n\t\t}\n\t}\n\tcout << endl;\n}\n\n// 初期化\nvoid init(){\n\tfor(int i=0 ; i < MAX_N ; i++ ){\n\t\tg[i].clear();\n\t}\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t}\n\th.clear();\n}\n\n// 辺の追加\nvoid add_edge(int u, int v, int d, int e){\n\tedge ed( v , d , e );\n\tg[u].push_back( ed );\n\ted.to = u;\n\tg[v].push_back( ed );\n}\n\n// 辺の追加2\nbool add_edge2(int u, int v, int cost){\n\tbool flag = false;\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tif( G[u][i].to == v ){\n\t\t\tflag = true;\n\t\t}\n\t}\n\tif( flag ) return false;\n\tedge ed( v , 0 , cost );\n\tG[u].push_back( ed );\n\t//ed.to = u;\n\t//G[v].push_back( ed );\n\treturn true;\n}\n\n// <頂点番号,持っているお金>を頂点, 襲われる人数をエッジのコストとしたグラフをつくる\nvoid dfs(int v, int L, map<int,bool> memo){\n\tif( v == N-1 ) return;\n\t\n\tP from( v , L );\n\tif( !h.count( from ) ){\n\t\th[from] = id;\n\t\tid++;\n\t}\n\tint a = h[from];\n\t\n\tfor(int i=0 ; i < g[v].size() ; i++ ){\n\t\tedge ed = g[v][i];\n\t\tif( memo.count(ed.to) && memo[ed.to] ) continue;\n\t\tmemo[ed.to] = true;\n\t\t\n\t\tP next_1( ed.to , L );\n\t\tif( !h.count( next_1 ) ){\n\t\t\th[next_1] = id;\n\t\t\tid++;\n\t\t}\n\t\tint b = h[next_1];\n\t\tbool flag = add_edge2( a , b , ed.e );\n\t\tif( flag ) dfs( ed.to , L , memo );\n\t\t\n\t\tif( L >= ed.d ){\n\t\t\tP next_2( ed.to , L - ed.d );\n\t\t\tif( !h.count( next_2 ) ){\n\t\t\t\th[next_2] = id;\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tint c = h[next_2];\n\t\t\tflag = add_edge2( a , c , 0 );\n\t\t\tif( flag ) dfs( ed.to , L - ed.d , memo );\n\t\t}\n\t\tmemo[ed.to] = false;\n\t}\n}\n\n// ダイクストラ法\nvoid dijkstra(){\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tfill( d , d + MAX_V , INF );\n\td[0] = 0;\n\tq.push( P(0,0) );\n\twhile( !q.empty() ){\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\t\n\t\tif( d[v] < p.first ) continue;\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tedge ed = G[v][i];\n\t\t\tif( d[ed.to] > d[v] + ed.e ){\n\t\t\t\td[ed.to] = d[v] + ed.e;\n\t\t\t\tq.push( P( d[ed.to] , ed.to ) );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 最小値を求める\nint solve(){\n\tint ans = INF;\n\tfor(map<P,int>::iterator it = h.begin() ; it != h.end() ; ++it ){\n\t\tif( (it->first).first == N-1 ){\n\t\t\tint v = h[ it->first ];\n\t\t\tans = min( ans , d[v] );\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint M, L;\n\twhile( cin >> N >> M >> L, N || M || L ){\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < M ; i++ ){\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--; b--;\n\t\t\tadd_edge( a , b , d , e );\n\t\t}\n\t\t\n\t\t// グラフの生成\n\t\tid = 0;\n\t\tmap<int,bool> memo;\n\t\tmemo[0] = true;\n\t\tdfs( 0 , L , memo );\n\t\t// ダイクストラ法\n\t\tdijkstra();\n\t\t// 最小コストを求める\n\t\tint ans = solve();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nstruct edge {\n    int to;\n    int cost;\n    int numOfTheaf;\n};\n\nstruct info {\n    int now;\n    int sumOfCost;\n    int sumOfTheaf;\n    bool operator < (const info &o) const {\n        return  sumOfTheaf > o.sumOfTheaf;\n    }\n};\n\nint main() {\n    int n, m, l;\n    while (cin >> n >> m >> l, n) {\n        vector <vector <edge> > G(n);\n        rep (i, m) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--; b--;\n            G[a].push_back({b, d, e});\n            G[b].push_back({a, d, e});\n        }\n        //       to, sumOfCost -> sumOfTheaf\n        int dist[110][110] = {}; rep (i, 110) rep (j, 110) dist[i][j] = 1e9;\n        bool used[110][110] = {};\n\n        //info -> now, sumOfCost, sumOfTheaf\n        priority_queue <info> que;\n        que.push({0, 0, 0});\n\n        dist[0][0] = 0;\n\n        while (!que.empty()) {\n            info tmp = que.top(); que.pop();\n            if ( used[tmp.now][tmp.sumOfCost] ) continue;\n            used[tmp.now][tmp.sumOfCost] = true;\n            rep (i, G[tmp.now].size()) {\n                //護衛を雇わない場合\n                {\n                    if ( dist[G[tmp.now][i].to][tmp.sumOfCost] > dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf ) {\n                         dist[G[tmp.now][i].to][tmp.sumOfCost] = dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf;\n                         que.push({G[tmp.now][i].to, tmp.sumOfCost, dist[G[tmp.now][i].to][tmp.sumOfCost]});\n                    }\n                }\n                //護衛を雇う場合\n                {\n                //お金こえちゃだめ\n                    if ( G[tmp.now][i].cost + tmp.sumOfCost > l ) continue;\n                    if ( dist[G[tmp.now][i].to][tmp.sumOfCost + G[tmp.now][i].cost] > dist[tmp.now][tmp.sumOfCost] ) {\n                         dist[G[tmp.now][i].to][tmp.sumOfCost] = dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf;\n                        dist[G[tmp.now][i].to][tmp.sumOfCost + G[tmp.now][i].cost] = dist[tmp.now][tmp.sumOfCost];\n                        que.push({G[tmp.now][i].to, tmp.sumOfCost + G[tmp.now][i].cost, tmp.sumOfTheaf});\n                    }\n                }\n            }\n        }\n        int ans = 1e9;\n        rep (i, l + 1) ans = min(ans, dist[n - 1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\n#define rep(X,Y) for(int (X)=0;(X)<(Y);++(X))\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define pb push_back\n\nusing namespace std;\n\nstruct edge {int to, cost, pp;};\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PIP;\n\n#define MAX_V 101\n#define MAX_L 101\n#define INF 1000000000\n\nvector<edge> G[MAX_V];\nint d[MAX_L][MAX_V];\n\nint l,n,m;\n\n\nvoid dij(){\n\tpriority_queue<PIP, vector<PIP>, greater<PIP> > q;\n\t\n\td[l][1] = 0;\n\tq.push(PIP(0,P(l,1)));\n\twhile(!q.empty()){\n\t\tPIP p = q.top();q.pop();\n\t\tint ll = p.second.first;\n\t\tint v = p.second.second;\n\t\tif(ll < 0)continue;\n\t\tif(d[ll][v] < p.first)continue;\n\t\trep(i,G[v].size()){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[ll][e.to] > d[ll][v] + e.pp ){\n\t\t\t\td[ll][e.to] = d[ll][v] + e.pp;\n\t\t\t\tq.push(PIP(d[ll][e.to],P(ll,e.to)));\n\t\t\t}\n\t\t\tif( ll-e.cost < 0)continue;\n\t\t\tif(d[ll-e.cost][e.to] > d[ll][v]){\n\t\t\t\td[ll-e.cost][e.to] = d[ll][v];\n\t\t\t\tq.push(PIP(d[ll-e.cost][e.to],P(ll-e.cost,e.to)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid init(){\n\tl = n = m = 0;\n\trep(i,101)G[i].clear();\n\trep(i,101)rep(j,101)d[i][j] = INF;\n}\n\n\t\n\n\nint main(){\n\twhile(1){\n\t\tint ans = INF;\n\t\tinit();\n\t\tcin >> n >> m >> l;\n\t\tif(!l)break;\n\t\trep(i,m){\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tG[a].push_back((edge){b,d,e});\n\t\t\tG[b].push_back((edge){a,d,e});\n\t\t}\n\t\tdij();\n\t\trep(i,l+1){\n\t\t\tans = min(ans, d[i][n]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) if((x)>(y))(x)=(y)\n#define chmax(x,y) if((x)<(y))(x)=(y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// d[i][j]: 街iに総コストjかけて到着する際に遭遇する盗賊の数の最小値\nint n, m, s, a, b, l, x, d[101][101];\nvector<pair<int,pii> > e[101];\n\nvoid dijkstra() {\n\tpriority_queue<pair<pii,int>, vector<pair<pii,int> >, greater<pair<pii,int> > > que;\n\trep(i,n) rept(j,s) d[i][j] = inf;\n\td[0][0] = 0;\n\tque.push({{0,0},0});\n\twhile(!que.empty()) {\n\t\tint v = que.top().second, th = que.top().fi.fi, cs = que.top().fi.se; que.pop();\n\t\tif (d[v][cs]<th) continue;\n\t\tfor (int i = 0; i < e[v].size(); ++i) {\n\t\t\tint to = e[v][i].first, dist = e[v][i].se.fi, bd = e[v][i].se.se;\n\t\t\t// 護衛を雇う場合\n\t\t\tif (cs+dist<=s && d[to][cs+dist] > d[v][cs]) {\n\t\t\t\td[to][cs+dist] = d[v][cs];\n\t\t\t\tque.push({{d[to][cs+dist], cs+dist}, to});\n\t\t\t}\n\t\t\t// 雇わない場合\n\t\t\tif (d[to][cs] > d[v][cs] + bd) {\n\t\t\t\td[to][cs] = d[v][cs] + bd;\n\t\t\t\tque.push({{d[to][cs], cs}, to});\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n >> m >> s;\n\t\tif (n==0) break;\n\t\trep(i,n) e[i].clear();\n\t\trep(i,m) {\n\t\t\tcin >> a >> b >> l >> x;\n\t\t\ta--, b--;\n\t\t\te[a].pb({b,{l,x}}), e[b].pb({a,{l,x}});\n\t\t}\n\t\tdijkstra();\n\t\tint res = inf;\n\t\trept(i,s) chmin(res,d[n-1][i]);\n\t\tcout << res << ln << flush;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXN = 101, MAXL = 101, MAXE = 10000;\nlong long INF = MAXN * MAXE;\ntypedef pair<int, int> pp;\ntypedef pair<int, pp> ppp;\nstruct edge{int to, dist, enemy;};\n\nlong long d[MAXN][MAXL];\nint n, m, l;\nint a, b, dist, e;\n\nint main()\n{\n    while(cin >> n >> m >> l && n)\n    {\n        memset(d, INF, sizeof(d));\n        vector<edge> g[MAXN];\n\n        REP(m)\n        {\n            cin >> a >> b >> dist >> e;\n            a--;\n            b--;\n\n            g[a].push_back((edge){b, dist, e});\n            g[b].push_back((edge){a, dist, e});\n        }\n\n        priority_queue<ppp, vector<ppp>, greater<ppp> > que;\n        que.push(ppp(0,pp(-l, 0)));\n        REP(l + 1)d[0][i] = 0;\n\n        int ans = 0;\n        while(!que.empty())\n        {\n            ppp p = que.top(); que.pop();\n            int nowe = p.first, nowl = -p.second.first, now = p.second.second;\n            //cout << \"es:\" << nowe << \" mo:\" << nowl << \" now:\"<< now << endl;\n\n            if(now == n -1 ){ans = nowe; break;}\n                /*bool f = false;\n                REP(nowl + 1)if(d[now][i] < nowe) f = true;\n                if(f) continue;\n            */\n\n            REP(g[now].size())\n            {\n                edge ed = g[now][i];\n                //cout <<\"edge to:\" << ed.to <<\" dist:\"<< ed.dist<<\" enemy:\" << ed.enemy << endl;\n\n                if(nowl >= ed.dist &&( d[ed.to][nowl - ed.dist] > d[now][nowl]) )\n                {\n                    //cout <<\"edge to:\" << ed.to <<\" dist:\"<< ed.dist<<\" enemy:\" << ed.enemy << endl;\n                    d[ed.to][nowl - ed.dist] = d[now][nowl];\n                    que.push(ppp(d[ed.to][nowl - ed.dist], pp(-nowl+ ed.dist, ed.to)) ) ;\n                }\n\n                if(d[ed.to][nowl] > d[now][nowl] + ed.enemy)\n                {\n                    d[ed.to][nowl] = d[now][nowl] + ed.enemy;\n                    que.push(ppp(d[ed.to][nowl], pp(-nowl, ed.to)));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\nconst int inf = 1 << 28;\n\nstruct Edge{\n    int to, cost, weight;\n    Edge(){}\n    Edge(int to_, int cost_, int weight_):to(to_), cost(cost_), weight(weight_){}\n};\n\nint N, M, L;\nvector<vector<Edge> > G;\nvector<vector<int> > mem;\n\nint solve(int s){\n    mem.assign(N+1, vector<int>(L+1, -inf));\n    mem[s][L] = 0;\n    typedef tuple<int, int, int> State;\n    priority_queue<State> q;\n    for(q.emplace(0, L, s); !q.empty();){\n        int w, c, v; tie(w, c, v) = q.top(); q.pop();\n        if(v == N)return -w;\n        for(auto e: G[v]){\n            if(e.cost <= c && mem[e.to][c-e.cost] < w){\n                mem[e.to][c-e.cost] = w;\n                q.emplace(w, c - e.cost, e.to);\n            }\n            if(mem[e.to][c] < w - e.weight){\n                mem[e.to][c] = w - e.weight;\n                q.emplace(w - e.weight, c, e.to);\n            }\n        }\n    }\n    return inf;\n}\n\nint main(){\n    while(cin >> N >> M >> L, N|M|L){\n        G.assign(N+1, vector<Edge>(0));\n        rep(i, M){\n            int A, B, D, E;\n            cin >> A >> B >> D >> E;\n            G[A].emplace_back(B, D, E);\n            G[B].emplace_back(A, D, E);\n        }\n        cout << solve(1) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ntypedef pair<int,int>PAIR;//(ダメージ量)&(宿番号*1000+残金)\nint main(){\n    \n\t/*\n\tAOJ2151\n\t[宿屋(1~100)]に[残金(0~100)]を持って\n\t最低ダメージでたどり着くようにして\n\t解けばよい？\n\t\n\t\n\t*/\n\t\n\tint N,M,L;\n\twhile(cin>>N>>M>>L,N){\n\t\tint load[101][101][2];//AからBへの/距離(=支払い)/襲われる数(=ダメージ量)\n\t\tmemset(load,-1,sizeof(load));\n\t\tbool flag[101][101]={0};//宿屋//金//すでに最低ダメージでたどり着いているならフラグを立てる\n\t\t\n\t\tfor(int i=0,A,B,D,E;i<M;i++){\n\t\t\tcin>>A>>B>>D>>E;\n\t\t\tload[A][B][0]=load[B][A][0]=D;\n\t\t\tload[A][B][1]=load[B][A][1]=E;\n\t\t}\n\t\tpriority_queue<PAIR,vector<PAIR>,greater<PAIR> > Q;\n\t\tQ.push(make_pair(0,1000+L));\n\t\t\n\t\tfor(int dam,pos,mon;!Q.empty();){\n\t\t\t\n\t\t\tdam=Q.top().first;\n\t\t\tpos=Q.top().second/1000;\n\t\t\tmon=Q.top().second%1000;\n\t\t\tQ.pop();\n\t\t\tif(pos==N){\n\t\t\t\tcout<<dam<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(flag[pos][mon]==0){\n\t\t\t\tflag[pos][mon]=1;\n\t\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\t\tif(load[pos][i][0]>0){//道がある\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(flag[i][mon]==0){//雇わずに襲われる場合\n\t\t\t\t\t\t\tQ.push(make_pair(dam+load[pos][i][1],i*1000+mon));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(load[pos][i][0]<=mon){//雇うお金がある場合\n\t\t\t\t\t\t\tif(flag[i][mon-load[pos][i][0]]==0){\n\t\t\t\t\t\t\t\tQ.push(make_pair(dam,i*1000+mon-load[pos][i][0]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\ntypedef pair<ll,mp> mmp;//cost,now,sumdis\n#define inf 1e9\ntypedef struct edge{\n\tll to,cost,dis;\n}edge;\n\nint main(){\n\twhile(1){\n\t\tll n,m,l;\n\t\tcin>>n>>m>>l;\n\t\tif(n==0)break;\n\t\tvector<vector<edge> > g(n);\n\t\tpriority_queue<mmp,vector<mmp>,greater<mmp> > q;\n\t\tfor(ll i=0;i<m;i++){\n\t\t\tll a,b;\n\t\t\tedge e;\n\t\t\tcin>>a>>b>>e.dis>>e.cost;\n\t\t\ta--,b--;\n\t\t\te.to = b;\n\t\t\tg[a].push_back(e);\n\t\t\te.to = a;\n\t\t\tg[b].push_back(e);\n\t\t}\n\t\tvector<vector<ll> > dp(n,vector<ll>(l+1,inf) );\n\t\tq.push( mmp( 0,mp(0,0) ) );\n\t\tdp[0][0] = 0;\n\t\twhile(!q.empty()){\n\t\t\tmmp now = q.top();\n\t\t\tq.pop();\n\t\t\tll dan  = now.first;\n\t\t\t//cout<<dan<<endl;\n\t\t\tmp tmp = now.second;\n\t\t\t//cout<<tmp.first<<' '<<tmp.second<<endl;\n\t\t\tif(tmp.second>l)continue;\n\t\t\tif(dp[tmp.first][tmp.second] < dan) continue;\n\t\t\tfor(int i=0;i<g[tmp.first].size();i++){\n\t\t\t\t//cout<<i<<' '<<\"ok\"<<endl;\n\t\t\t\tedge e = g[tmp.first][i];\n\t\t\t\tif(e.cost+dan < dp[e.to][tmp.second]){\n\t\t\t\t\tdp[e.to][tmp.second] = e.cost+dan;\n\t\t\t\t\tq.push( mmp(dp[e.to][tmp.second], mp(e.to ,tmp.second ) ) );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(tmp.second+e.dis <=  l){\n\t\t\t\t\t//cout<<\"l \"<<l<<' '<<tmp.second+e.dis<<endl;\n\t\t\t\t\tif( dan < dp[e.to][tmp.second+e.dis]) {\n\t\t\t\t\t//cout<<tmp.second+e.dis<<endl;\n\t\t\t\t\tdp[e.to][tmp.second+e.dis] = dan;\n\t\t\t\t\tq.push(mmp( dan, mp(e.to,tmp.second+e.dis) ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tll res = inf ;\n\t\tfor(int i=0;i<=l;i++)res = min(res,dp[n-1][i]);\n\t\tcout<<res<<endl;\n\n\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, pair<ll, ll> > P3;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\n#define REP(i, n) for (int i = 0; i < n; i++)\n\nstruct edge{\n    ll to, d, cost;\n};\n\nll N, M, L, dmin[105][105]; // dmin[i][j]:頂点iに所持金jで到達する最小コスト\nvector<edge> g[105];\n\n\nll dijkstra(){\n    REP(i,N)fill(dmin[i],dmin[i]+L+1, LLINF/3);\n    dmin[0][L] = 0;\n    priority_queue<P3, vector<P3>, greater<P3> > que;\n    que.push({0,{0,L}});\n    while(!que.empty()){\n        P3 p = que.top();\n        que.pop();\n        ll u = p.second.first, l = p.second.second;\n        if(dmin[u][l] < p.first) continue;\n        for(auto &e : g[u]){\n            ll v = e.to, dt=e.d, c = e.cost;\n            if(l>=dt && dmin[v][l-dt] > dmin[u][l]){ // 護衛を雇う遷移\n                dmin[v][l-dt] = dmin[u][l];\n                que.push({dmin[v][l-dt],{v,l-dt}});\n            }\n            if(dmin[v][l] > dmin[u][l] + c){ // 雇わない遷移\n                dmin[v][l] = dmin[u][l] + c;\n                que.push({dmin[v][l],{v,l}});\n            }\n        }\n    }\n    ll res = LLINF;\n    REP(i,L+1){\n        res = min(res, dmin[N-1][i]);\n    }\n    return res;\n}\n\nint main() {\n    while(1){\n        cin >> N >> M >> L;\n        if(N==0)break;\n        REP(i,N)g[i].clear();\n        REP(i,M){\n            ll a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            g[a].push_back({b,d,e});\n            g[b].push_back({a,d,e});\n        }\n        cout << dijkstra() << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint cost;\n\tint enemy;\n};\n\nclass Situation{\npublic:\n\tint cost;\n\tint node;\n\tint money;\n\n\tSituation(int cost_,int node_,int money_){\n\t\tcost=cost_;\n\t\tnode=node_;\n\t\tmoney=money_;\n\t}\n\tSituation();\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\n\nint V;\n\nconst int MAX_V = 101;\n\nvector<edge> G[MAX_V][MAX_V];\n//  éêÉ écèàzÅ½Çè­Å¬RXg\nint d[MAX_V][MAX_V];\nconst int INF = 100000000;\n\n//int prevv[MAX_V];\nint L;\nint N;\nint M;\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n\tfor(int i = 0; i < MAX_V; i++)\n\t\tfill(d[i],d[i]+MAX_V,INF);\n\td[s][L] = 0;\n\tque.push(Situation(0,s,L));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint node = p.node;\n\t\tint money=p.money;\n\t\tif(d[node][money] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[node][money].size(); i++){\n\t\t\tedge e = G[node][money][i];\n\t\t\t// ¨àðgÁÄìµÄàç¤ê\n\t\t\tif(money-e.cost>=0){\n\t\t\t\tif(d[e.to][money-e.cost] > d[node][money]){\n\t\t\t\t\td[e.to][money-e.cost] = d[node][money];\n\t\t\t\t\tque.push(Situation(d[e.to][money-e.cost],e.to,money-e.cost));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ìÈµÌê\n\t\t\tif(d[e.to][money]>d[node][money]+e.enemy){\n\t\t\t\td[e.to][money]=d[node][money]+e.enemy;\n\t\t\t\tque.push(Situation(d[e.to][money],e.to,money));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>N>>M>>L&&!(N==0&&M==0&&L==0)){\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tfor(int j = 0; j < MAX_V; j++)\n\t\t\t\tG[i][j].clear();\n\t\tint from,to,cost,enemy;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin>>from>>to>>cost>>enemy;\n\t\t\tfrom--;\n\t\t\tto--;\n\t\t\tedge e;\n\t\t\te.cost=cost;\n\t\t\te.to=to;\n\t\t\te.enemy=enemy;\n\t\t\t\n\t\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\t\tG[from][i].push_back(e);\n\t\t\te.to=from;\n\t\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\t\tG[to][i].push_back(e);\n\t\t}\n\t\tdijkstra(0);\n\t\tint minCost=INF;\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tminCost=min(minCost,d[N-1][i]);\n\t\tcout<<minCost<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\npii cost[101][101];\nbool visit[101][101];\n\nstruct node {\n\tint cost, money, pos;\n\tnode(int c, int m, int p) {\n\t\tcost = c;\n\t\tmoney = m;\n\t\tpos = p;\n\t}\n};\nbool operator<( const node& l, const node& r ) {\n\tif( l.cost == r.cost ) {\n\t\treturn l.money < r.money;\n\t}\n\treturn l.cost > r.cost;\n}\n\nint main() {\n\tint n, m, l;\n\twhile( cin >> n >> m >> l, n||m||l ) {\n\t\trep(i,101) rep(j,101) cost[i][j].first = cost[i][j].second = -1;\n\t\trep(i, m) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tcost[a][b].first = cost[b][a].first = d;\n\t\t\tcost[a][b].second = cost[b][a].second = e;\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tmemset( visit, 0, sizeof(visit) );\n\t\tque.push( node(0, l, 1) );\n\t\twhile( !que.empty() ) {\n\t\t\tnode nd = que.top();\n\t\t\tque.pop();\n\t\t\tif( visit[nd.pos][nd.money] ) continue;\n\t\t\tvisit[nd.pos][nd.cost] = true;\n\t\t\tif( nd.pos == n ) {\n\t\t\t\tcout << nd.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\tif( cost[nd.pos][i].second != -1 ) {\n\t\t\t\t\tif( !visit[i][nd.money] ) {\n\t\t\t\t\t\tque.push( node(nd.cost+cost[nd.pos][i].second, nd.money, i) );\n\t\t\t\t\t}\n\t\t\t\t\tif( nd.money >= cost[nd.pos][i].first && !visit[i][nd.money-cost[nd.pos][i].first] ) {\n\t\t\t\t\t\tque.push( node(nd.cost, nd.money-cost[nd.pos][i].first, i) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        int edge_memo[101][101];\n        for (auto& rows : edge_memo) {\n            for (auto& elem : rows) {\n                elem = INT_MAX;\n            }\n        }\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                auto& m = edge_memo[current.loc][e.to];\n                // 護衛を雇う\n                if (e.dist <= current.money) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                if (damage != m) {\n                    pq.push({e.to, current.money, damage});\n                    m = damage;\n                }\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const int INF=1<<24;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\n\n\n\n\n\nstruct E{\n\tint v,l,thief;\n};\n\nint N,M,L;\nvector<vector<E> > a;\npriority_queue<E> pq;\nint dp[110][110];\n\nbool operator < (E a,E b){\n\treturn a.thief>b.thief;\n}\n\n\nint dij(){\n\trep(i,110) rep(j,110) dp[i][j]=INF;\n\tE tmp;\n\ttmp.v=0;\n\ttmp.l=0;\n\ttmp.thief=0;\n\tpq.push(tmp);\n\tdp[0][0]=0;\n\tint ans=INF;\n\twhile(!pq.empty()){\n\t\tE now = pq.top();\n\t\t//cout<<now.v<<\" \"<<now.l<<\" \"<<now.thief<<endl;\n\t\tpq.pop();\n\t\tif(now.v==N-1){\n\t\t\tif(now.l<=L) ans=min(ans,now.thief);\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,a[now.v].size()){\n\t\t\tE next = a[now.v][i];\n\t\t\t//雇う\n\t\t\tif(now.thief<dp[next.l+now.l][next.v]){\n\t\t\t\tif(next.l+now.l>105) continue;\n\t\t\t\t// if(next.l+now.l>110) cout<<\"hoge \"<<dp[next.l+now.l][next.v]<<\" \"<<next.l+now.l<<endl; \n\t\t\t\tdp[next.l+now.l][next.v]=now.thief;\n\t\t\t\t// cout<<\"dp \"<<dp[next.l+now.l][next.v]<<\" \"<<next.l+now.l<<\" \"<<next.v<<endl;\n\t\t\t\tE t1=next;\n\t\t\t\tt1.l+=now.l;\n\t\t\t\tt1.thief=now.thief;\n\t\t\t\tpq.push(t1);\n\t\t\t}\n\t\t\t//雇わない\n\t\t\tif(now.thief+next.thief<dp[now.l][next.v]){\n\t\t\t\tdp[now.l][next.v]=now.thief+next.thief;\n\t\t\t\t// cout<<\"dp \"<<dp[now.l][next.v]<<\" \"<<now.l<<\" \"<<next.v<<endl;\n\t\t\t\tE t1=next;\n\t\t\t\tt1.l=now.l;\n\t\t\t\tt1.thief+=now.thief;\n\t\t\t\tpq.push(t1);\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\twhile(cin>>N>>M>>L,N||M||L){\n\t\ta.resize(N);\n\t\trep(i,N) a.clear();\n\t\trep(i,M){\n\t\t\tint b,c,l,thi;\n\t\t\tcin>>b>>c>>l>>thi;\n\t\t\tb--;\n\t\t\tc--;\n\t\t\tE t1,t2;\n\t\t\tt1.v=b;\n\t\t\tt1.l=l;\n\t\t\tt1.thief=thi;\n\t\t\tt2.v=c;\n\t\t\tt2.l=l;\n\t\t\tt2.thief=thi;\n\t\t\ta[c].PB(t1);\n\t\t\ta[b].PB(t2);\n\t\t}\n\t\tcout<<dij()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint N,M,L;\npair<int,int> road[110][110];  //????????¢????????°???\nint dp[110][110];  //d[i][j]:?????????i,???????????????j?????¨????????????????????§?\\??????????????°??????°\n\nint dfs(int nowNode, int nowMoney, int nowPeople, set<int> state){\n  if(nowNode == N-1) return nowPeople;\n  if(dp[nowNode][nowMoney] != INF) return dp[nowNode][nowMoney];\n  int ret = INF;\n  state.insert(nowNode);\n  REP(nextNode,0,N){\n    if(road[nowNode][nextNode].F == INF || state.find(nextNode)!=state.end()) continue;\n    if(road[nowNode][nextNode].F <= nowMoney){ /*?????????????????????????????¢??¢???*/\n      ret = min(ret,\n        min(dfs(nextNode,nowMoney,nowPeople + road[nowNode][nextNode].S, state),\n            dfs(nextNode,nowMoney-road[nowNode][nextNode].F,nowPeople, state)));\n    }else{  /*?????????????????????????????¢??????*/\n      ret = min(ret,dfs(nextNode,nowMoney,nowPeople + road[nowNode][nextNode].S, state));\n    }\n  }\n  return dp[nowNode][nowMoney] = ret;\n}\n\nint main() {\n  while(1){\n    cin>>N>>M>>L;\n    if(N==0&&M==L&&L==0) break;\n    REP(i,0,N)REP(j,0,N)road[i][j]=make_pair(INF,INF);\n    REP(i,0,M){\n      int a,b,d,e;\n      cin>>a>>b>>d>>e;\n      road[a-1][b-1] = make_pair(d,e);\n      road[b-1][a-1] = make_pair(d,e);\n    }\n\n    REP(i,0,N)REP(j,0,L+1) dp[i][j] = INF;\n    set<int> s;\n    cout<<dfs(0,L,0,s)<<endl;\n\n    /*\n    priority_queue< pair< int ,pair<int,int> > > PQ; //?????°???<????????????????????????>\n    PQ.push(make_pair(0,make_pair(0,L)));\n    dp[0][L] = 0; //?????????\n\n    while(!PQ.empty()){\n      int nowNode = PQ.top.S.F;\n      int nowMoney = PQ.top.S.S;\n      int nowPeople = (-1)*PQ.top.F;\n      PQ.pop();\n      if(dp[nowNode][nowMoney] < nowPeople) continue;\n      REP(nextNode,0,N){\n        if(road[nowNode][nextNode].F == INF) continue;\n        REP(money,0,nowMoney){\n          int nextMoney;\n          int nextPeople;\n          if(if(road[nowNode][nextNode].F <= nowMoney){\n            nextMoney = nowMoney - road[nowNode][nextNode].F\n            nextPeople = nowPeople;\n          }else{\n            nextMoney = nowMoney;\n            nextPeople = nowPeople + road[nowNode][nextNode].S;\n          }\n          dp[nextNode][nextMoney] = min(dp[nextNode][nextMoney], nextPeople);\n          PQ.push_back(make_pair((-1)*dp[nextNode][nextMoney], make_pair(nextNode,nextMoney) ));\n        }\n      }\n    }\n    cout<<*max_element(dp[N-1],dp[N-1]+L)\n    */\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    return a.enemy>b.enemy;\n}\n\nstruct node maps[100];\n\nint main()\n{\n    int n,m,l;\n\n    while ((cin>>n>>m>>l) && (n>0 || m>0 || l>0)){\n        priority_queue<struct state,vector<struct state>,greater<struct state>> queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            maps[a-1].data.push_back((struct data){b-1,d,e});\n            maps[b-1].data.push_back((struct data){a-1,d,e});\n        }\n        queue.push((struct state){0,l,0});\n        while (!queue.empty()){\n            //printf(\"!N:%d , M:%2d , E:%2d\\n\",queue.top().number,queue.top().money,queue.top().enemy);\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                cout<<s.enemy<<endl;\n                while(!queue.empty()){\n                    queue.pop();\n                }\n            }else{\n                for(struct data d: maps[s.number].data){\n                    //printf(\"[DATA]%d\\n\",d.to);\n                    if(d.dis<=s.money){\n                        queue.push((struct state){d.to,s.money-d.dis,s.enemy});\n                        //printf(\"*N:%d , M:%2d , E:%2d\\n\",queue.top().number,queue.top().money,queue.top().enemy);\n                    }\n                    queue.push((struct state){d.to,s.money,s.enemy+d.ene});\n                    //printf(\" N:%d , M:%2d , E:%2d\\n\",d.to,s.money,s.enemy+d.ene);\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, deque<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, deque<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n   \nusing namespace std;\n   \nint N, M, L;\n   \nstruct edge {\n    int to, distance, enemy;\n};\n   \nstruct P {\n    int from, money, enemy;\n   \n    bool operator >(const P& p) const {\n        return enemy > p.enemy;\n    }\n};\n \nstruct edge {\n    int to, distance, enemy;\n};\n\nstruct pair {\n    int money, enemy;\n}\n   \nint main() {\n    while (cin >> N >> M >> L, N|M|L) {\n        vector<vector<edge> > E(N);\n        int a, b, d, e;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> d >> e;\n            E[a-1].push_back({b, d, e});\n            E[b-1].push_back({a, d, e});\n        }\n   \n        priority_queue<P, vector<P>, greater<P>> q;\n        city arr[N];\n        for(int i = 0; i < N; i++) {\n            arr[i].money = 0;\n        }   \n        q.push((P){0, L, 0});\n        while(!q.empty()) {\n            P p = q.top(); q.pop();\n            // goal\n            if (p.from == N-1) {\n                cout << p.enemy << endl;\n                break;\n            }\n            if (p.money >= arr[p.from].money) {\n                arr[p.from].money = p.money;\n                arr[p.from].enemy = p.enemy;\n            } else if (p.enemy <= arr[p.from].enemy) {\n                continue;\n            }\n \n            for (int i = 0; i < E[p.from].size() ; i++) {\n                edge e = E[p.from][i];\n                q.push((P){e.to-1, p.money, p.enemy+e.enemy});\n                if (p.money-e.distance >= 0) {\n                    q.push((P){e.to-1, p.money-e.distance, p.enemy});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lld;\n\n#define INF (1<<30)\ntypedef pair< int , int > P;\ntypedef pair< int , P > Pi;\nstruct Edge { int to,cost,des; };\nvector< vector< Edge > > Graph;\nint V,E,L;\n\nint Dijkstra(int s,int g) {\n  int min_cost[111][111];\n  fill_n(*min_cost,111*111,INF);\n  priority_queue < Pi ,vector< Pi >,greater< Pi > > que;\n  que.push(Pi(0,P(L,s)));\n  min_cost[s][L] = 0;\n  while(!que.empty()){\n    int cost = que.top().first;\n    int des = que.top().second.first;\n    int now = que.top().second.second;\n    que.pop();\n    if(now == g) return cost;\n    if(cost > min_cost[now][des]) continue;\n    for(int i=0;i<Graph[now].size();i++){\n      Edge e = Graph[now][i];\n      if(des - e.des >= 0){\n\tque.push(Pi(cost,P(des-e.des,e.to)));\n      }\n      if(min_cost[e.to][des] > cost + e.cost){\n\tmin_cost[e.to][des] = cost + e.cost;\n\tque.push(Pi(min_cost[e.to][des],P(des,e.to)));\n      }\n    }\n  }\n  return (-1);\n}\n\nint main(){\n  while(cin >> V >> E >> L , V){\n    Graph.clear();\n    Graph.resize(V);\n    for(int i=0;i<E;i++){\n      int a,b,c,d;\n      cin >> a >> b >> c >> d;\n      a--; b--;\n      Edge e; e.to = b; e.cost = d; e.des = c;\n      Graph[a].push_back(e);\n      e.to = a;\n      Graph[b].push_back(e);\n    }\n    cout << Dijkstra(0,V-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n\nstd::pair<int, int> road[101][101]; //first?????¢ second???\nint dp[101][101];//[??????][??´???] = ??¢????\\????????????°\n\nstruct Node {\n\tint pos, money, attacked;\n\tbool operator > (const Node& rhs) const {\n\t\treturn attacked > rhs.attacked;\n\t}\n\tbool operator < (const Node& rhs) const {\n\t\treturn attacked < rhs.attacked;\n\t}\n};\n\nint main() {\n\tint n, m, l;\n\twhile (std::cin >> n >> m >> l && (n || m || l)) {\n\t\tstd::memset(dp, -1, sizeof(dp));\n\t\tfor (int i = 0; i < 101; i++) for (int j = 0; j < 101; j++) road[i][j] = std::make_pair(0, 0);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, e;\n\t\t\tstd::cin >> x >> y >> d >> e;\n\t\t\troad[x][y] = std::make_pair(d, e);\n\t\t\troad[y][x] = std::make_pair(d, e);\n\t\t}\n\n\t\tstd::stack<Node> s;\n\t\t//std::priority_queue<Node> s;\n\t\ts.push({1, l, 0});\n\n\t\tint min = 1919810;\n\t\twhile (!s.empty()) {\n\t\t\tauto node = s.top(); s.pop();\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (!road[node.pos][i].first) continue;\n\t\t\t\tauto next = node;\n\t\t\t\tnext.pos = i;\n\n\t\t\t\t//????????????\n\t\t\t\t{\n\t\t\t\t\tauto n2 = next;\n\t\t\t\t\tn2.attacked += road[node.pos][i].second;\n\t\t\t\t\tif (dp[n2.money][i] == -1 || dp[n2.money][i] > n2.attacked) {\n\t\t\t\t\t\tdp[n2.money][i] = n2.attacked;\n\t\t\t\t\t\tif (i == n) min = std::min(min, n2.attacked); //????????????\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//????????????????????????????????\\???????\\????????????????\n\t\t\t\t\t\t\tbool isOk = true;\n\t\t\t\t\t\t\tfor (int j = n2.money + 1; j <= l; j++) {\n\t\t\t\t\t\t\t\tif (dp[j][i] >= 0 && dp[j][i] <= n2.attacked) {\n\t\t\t\t\t\t\t\t\tisOk = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isOk) {\n\t\t\t\t\t\t\t\ts.push(n2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\tif (next.money >= road[node.pos][i].first) {\n\t\t\t\t\tnext.money -= road[node.pos][i].first;\n\t\t\t\t\tif (dp[next.money][i] == -1 || dp[next.money][i] > next.attacked) {\n\t\t\t\t\t\tdp[next.money][i] = next.attacked;\n\t\t\t\t\t\tif (i == n) min = std::min(min, next.attacked); //????????????\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//????????????????????????????????\\???????\\????????????????\n\t\t\t\t\t\t\tbool isOk = true;\n\t\t\t\t\t\t\tfor (int j = next.money + 1; j <= l; j++) {\n\t\t\t\t\t\t\t\tif (dp[j][i] >= 0 && dp[j][i] <= next.attacked) {\n\t\t\t\t\t\t\t\t\tisOk = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isOk) {\n\t\t\t\t\t\t\t\ts.push(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << min << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nclass State {\npublic:\n\tint budget;\n\tint people;\n\tint wheres;\n\tState() {};\n\tState( int b, int p, int n ) { budget = b; people = p; wheres = n; };\n};\n\npriority_queue<State, vector<State>, greater<State> > status;\n//priority_queue<State> status;\n\nint map[101][101];\nint off[101][101];\n\nbool operator< (const State& a, const State& b)\n{\n\tif ( a.people == b.people )\n\t\treturn a.budget < b.budget;\n\treturn a.people < b.people;\n}\n\nbool operator> (const State& a, const State& b)\n{\n\tif ( a.people == b.people )\n\t\treturn a.budget > b.budget;\n\treturn a.people > b.people;\t\n}\n\nint main () {\n\n\twhile ( true ) {\n\t\tint  N,M,L;\n\n\t\tcin >> N >> M >> L;\n\n\t\tif ( N == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<=N; i++ ) {\n\t\t\tfor ( int j=0; j<=N; j++ ) {\n\t\t\t\tmap[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint a, b, d, e;\n\n\t\tfor ( int i=0; i<M; i++ ) {\n\t\t\tcin >> a >> b >> d>> e;\n\n\t\t\tmap[a][b] = d;\n\t\t\toff[a][b] = e;\n\t\t\tmap[b][a] = d;\n\t\t\toff[b][a] = e;\n\t\t}\n\n\n\t\tstatus.push(State(L, 0, 1));\n\t\tint ans;\n\t\tans = 10000000;\n\t\tbool have = false;\n\t\twhile( !status.empty() ) {\n\t\t\tState now;\n\t\t\tnow = status.top();\n\t\t\tstatus.pop();\n\t\t\t\n\t\t\tif ( now.people >= ans ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << now.budget<< \"\\t\";\n\t\t\tcout << now.people<< \"\\t\";\n\t\t\tcout << now.wheres<< endl;\n\t\t\t*/\n\t\t\tif ( now.wheres == N ) {\n\t\t\t\tif ( ans > now.people) {\n\t\t\t\t\thave = true;\n\t\t\t\t\tans = now.people;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor ( int i=1; i<=N; i++ ) {\n\t\t\t\t\tif ( i != now.wheres ) {\n\t\t\t\t\t\tif ( map[now.wheres][i] > 0 ) {\n\t\t\t\t\t\t\tif ( off[now.wheres][i] != 0 ) {\n\t\t\t\t\t\t\t\tif ( now.budget - map[now.wheres][i] >= 0 ) {\n\t\t\t\t\t\t\t\t\tstatus.push(State(now.budget-map[now.wheres][i],now.people,i));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstatus.push(State(now.budget,now.people+off[now.wheres][i],i));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstatus.push(State(now.budget,now.people,i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( ans == -1 )\n\t\t\tcout << \"No\" << endl;\n\t\telse\n\t\t\tcout << \"Ans: \" <<ans << endl;\n\t}\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\nusing namespace std;\nstruct S{\n\tint town,l;\n\tS(int a=0,int b=0):town(a),l(b){}\n};\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n){\n\t\tstruct{\n\t\t\tint d,e;\n\t\t}g[100][101]; int cost[100][101];\n\t\trep(i,100)rep(j,101)g[i][j].d=cost[i][j]=INF;\n\t\tint a,b,d,e;\n\t\trep(i,m){\n\t\t\tcin>>a>>b>>d>>e,a--,b--;\n\t\t\tg[a][b].d=g[b][a].d=d;\n\t\t\tg[a][b].e=g[b][a].e=e;\n\t\t}\n\t\tvector<S> F;\n\t\tF.push_back(S(0,l)),cost[0][l]=0;\n\t\twhile(!F.empty()){\n\t\t\tvector<S> nF;\n\t\t\trep(i,F.size()){\n\t\t\t\tS cS=F[i],nS;\n\t\t\t\trep(guard,2)rep(j,n){\n\t\t\t\t\tint tcost=guard*g[cS.town][j].d,dcost=guard?0:g[cS.town][j].e;\n\t\t\t\t\tif(g[cS.town][j].d!=INF&&tcost<=cS.l&&\n\t\t\t\t\tcost[j][cS.l-tcost]>cost[cS.town][cS.l]+dcost){\n\t\t\t\t\t\tcost[j][cS.l-tcost]=cost[cS.town][cS.l]+dcost;\n\t\t\t\t\t\tnS=cS,nS.town=j,nS.l-=tcost;\n\t\t\t\t\t\tnF.push_back(nS);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tF=nF;\n\t\t}\n\t\tint mn=INF;\n\t\trep(i,l+1)if(mn>cost[n-1][i])mn=cost[n-1][i];\n\t\tcout<<mn<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110];\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(now==n){\n    ans=min(ans,sum);\n    return;\n  }\n  if(memo[now]<=sum)return;\n    memo[now]=sum;\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      used[E[now][i].to]=true;\n      if(nokori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n     \n      memo[i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXN = 101, MAXL = 101, INF = 110000 ;\nint d[MAXN][MAXL];\n\nstruct edge{int to, dist, enemy;};\n\nint n, m, l, a, b, dist, e;\n\ntypedef pair<int, int> pp;\ntypedef pair<int, pp> ppp;\n\nint main()\n{\n    while(cin >> n >> m >> l && n)\n    {\n        //memset(d , INF, sizeof(int) * MAXN * MAXL);\n        rep(i,n)rep(j,l + 1)d[i][j] = 110000 ;\n        vector<edge> g[MAXN];\n        REP(m)\n        {\n            cin >> a >> b >> dist >> e;\n            a--; b--;\n            g[a].push_back((edge){b, dist, e});\n            g[b].push_back((edge){a, dist, e});\n        }\n\n        priority_queue<ppp, vector<ppp>, greater<ppp> > que;\n        que.push(ppp(0, pp( -l , 0)));\n        d[0][l] = 0;\n        int ans = 1000;\n\n        //cout << d[1][l] << endl;\n\n        while(!que.empty())\n        {\n            ppp p = que.top(); que.pop();\n            int nowe = p.first, nowl = -p.second.first, now = p.second.second;\n            //cout << \"e:\" << nowe << \"  l:\" << nowl << \"  now:\" << now << endl;\n            if(now == n -1 ){ans = nowe; break;}\n            \n            REP(g[now].size())\n            {\n                edge ed = g[now][i];\n                //cout << \"to:\" << ed.to << \" dist:\" << ed.dist << \" enemy:\" << ed.enemy << endl;\n                //cout << \"d[ed.to]:\"<< d[ed.to][nowl] << endl;\n                if(nowl - ed.dist >= 0 && nowe < d[ed.to][nowl - ed.dist] )\n                {\n                    d[ed.to][nowl - ed.dist] = nowe;\n                    que.push(ppp(nowe, pp(ed.dist - nowl, ed.to)));\n                }\n                if(nowe + ed.enemy < d[ed.to][nowl])\n                {\n                    d[ed.to][nowl] = nowe + ed.enemy;\n                    que.push(ppp(nowe + ed.enemy, pp(-nowl, ed.to)));\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  //bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// Dijkstra (Verified: AOJ2005)\n// dの要素数は頂点数と等しくあるべき．\nvoid dijkstra(Graph &g, Array &d, int s) {\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    Weight dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        que.push(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\n\nint main()\n{\n  while(1){\n    int n,m,l;\n    cin>>n>>m>>l;\n    if(!n)break;\n    Graph g((n+1)*(l+2));\n    REP(i,m){\n      int a,b,d,e;\n      cin>>a>>b>>d>>e;\n      --a;--b;\n      REP(j,l+1){\n        int s=a*(l+1)+j;\n        int t=b*(l+1)+j;\n        g[s].push_back({s,t,e});\n        g[t].push_back({t,s,e});\n        if(j+d<=l){\n          g[s].push_back({s,t+d,0});\n          g[t].push_back({t,s+d,0});\n        }\n      }\n    }\n    Array a((n+1)*(l+2));\n    dijkstra(g, a, 0);\n    int minn = 1000000000;\n    REP(i,l+1){\n      minn=min(minn,a[(n-1)*(l+1)+i]);\n    }\n    cout<<minn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint from,to,dist,enemy;\n\tEdge(){}\n\tEdge(int f,int t,int d,int e):from(f),to(t),dist(d),enemy(e){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nstruct State{\n\tint v,money,enemy;\n\tState(){}\n\tState(int v,int m,int e):v(v),money(m),enemy(e){}\n\tbool operator<(const State& s)const{return enemy<s.enemy;}\n\tbool operator>(const State& s)const{return enemy>s.enemy;}\n};\n\nint main()\n{\n\tfor(int n,m,l;cin>>n>>m>>l,n|m|l;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint f,t,d,e; cin>>f>>t>>d>>e; f--,t--;\n\t\t\tg[f].emplace_back(f,t,d,e);\n\t\t\tg[t].emplace_back(t,f,d,e);\n\t\t}\n\t\t\n\t\tvvi dp(n,vi(l+1,INFTY)); // [頂点][残金]=>襲撃人数\n\t\tpriority_queue<State,vector<State>,greater<State>> pq;\n\t\tpq.emplace(0,l,0);\n\t\twhile(!pq.empty()){\n\t\t\tState cur=pq.top(); pq.pop();\n\t\t\tif(dp[cur.v][cur.money]!=INFTY) continue;\n\t\t\tdp[cur.v][cur.money]=cur.enemy;\n\t\t\tfor(Edge e:g[cur.v]){\n\t\t\t\tpq.emplace(e.to,cur.money,cur.enemy+e.enemy);\n\t\t\t\tif(e.dist<=cur.money)\n\t\t\t\t\tpq.emplace(e.to,cur.money-e.dist,cur.enemy);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res=INFTY;\n\t\trep(i,l+1)\n\t\t\tres=min(res,dp[n-1][i]);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 101;\nconst int MAX_V = 10000;\nconst int INF = 1e+8;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to, d, e;\n\tedge(int v_, int d_, int e_){ \n\t\tto = v_; d = d_; e = e_; \n\t};\n};\n\n// g[u] := ノード u と隣接するエッジのvectorを返す\nvector<edge> g[MAX_N];\n// G[u] := ノード u と隣接するエッジのvectorを返す (解を求めるために使うグラフ)\nvector<edge> G[MAX_V];\n// p = (頂点,持っているお金)をひとつの頂点とみなし, h[p] で対応する頂点番号を返す\nmap<P,int> h;\n// N : 宿の数, id: 生成する頂点番号の管理に使う\nint N, id;\n// d[v] := 始点から頂点 v までの最短距離\nint d[MAX_V];\n// 直前の頂点\nint prev[MAX_V];\n// 最短の頂点番号\nint goal;\n//\nmap<int,bool> hoge;\n//\nint cnt;\n\n// デバッグ用\nvoid debug( vector<int> path ){\n\tfor(map<P,int>::iterator it = h.begin() ; it != h.end() ; ++it ){\n\t\tcout << \"<\" << (it->first).first << \",\" << (it->first).second << \">\";\n\t\tcout << \" = \" << it->second << endl;\n\t}\n\tfor(int i=0 ; i < path.size() ; i++ ){\n\t\tcout << path[i];\n\t\tif( i != path.size()-1 )\n\t\t\tcout << \" => \";\n\t}\n\tcout << endl;\n}\n\nvoid debug_2(){\n\tcout << \"[debug]\" << endl;\n\tfor(int v=0 ; v < id ; v++ ){\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tedge ed = G[v][i];\n\t\t\tcout << \"(\" << v << \",\" << ed.to << \") = \" << ed.e << endl;\n\t\t}\n\t}\n\tcout << endl;\n}\n\n// 初期化\nvoid init(){\n\tfor(int i=0 ; i < MAX_N ; i++ ){\n\t\tg[i].clear();\n\t}\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t}\n\th.clear();\n\thoge.clear();\n\tcnt = INF;\n}\n\n// 辺の追加\nvoid add_edge(int u, int v, int d, int e){\n\tedge ed( v , d , e );\n\tg[u].push_back( ed );\n\ted.to = u;\n\tg[v].push_back( ed );\n}\n\n// 辺の追加2\nvoid add_edge2(int u, int v, int cost){\n\tedge ed( v , 0 , cost );\n\tG[u].push_back( ed );\n}\n\n// <頂点番号,持っているお金>を頂点, 襲われる人数をエッジのコストとしたグラフをつくる\nvoid dfs(int v, int L, map<int,bool> memo){\n\tif( v == N-1 ) return;\n\t\n\tP from( v , L );\n\tif( !h.count( from ) ){\n\t\th[from] = id;\n\t\tid++;\n\t}\n\tint a = h[from];\n\tif( from.first == N-1 ) hoge[a] = true;\n\t\n\tfor(int i=0 ; i < g[v].size() ; i++ ){\n\t\tedge ed = g[v][i];\n\t\tif( memo.count(ed.to) && memo[ed.to] ) continue;\n\t\tmemo[ed.to] = true;\n\t\t\n\t\tP next_1( ed.to , L );\n\t\tif( !h.count( next_1 ) ){\n\t\t\th[next_1] = id;\n\t\t\tid++;\n\t\t}\n\t\tint b = h[next_1];\n\t\tif( next_1.first == N-1 ) hoge[b] = true;\n\t\tadd_edge2( a , b , ed.e );\n\t\tdfs( ed.to , L , memo );\n\t\t\n\t\tif( L >= ed.d ){\n\t\t\tP next_2( ed.to , L - ed.d );\n\t\t\tif( !h.count( next_2 ) ){\n\t\t\t\th[next_2] = id;\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tint c = h[next_2];\n\t\t\tif( next_2.first == N-1 ) hoge[c] = true;\n\t\t\tadd_edge2( a , c , 0 );\n\t\t\tdfs( ed.to , L - ed.d , memo );\n\t\t}\n\t\tmemo[ed.to] = false;\n\t}\n}\n\n// ダイクストラ法\nvoid dijkstra(){\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tfill( d , d + MAX_V , INF );\n\tfill( prev , prev + MAX_V , -1 );\n\td[0] = 0;\n\tq.push( P(0,0) );\n\twhile( !q.empty() ){\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif( hoge.count(v) ){\n\t\t\tcnt = min( cnt , p.first );\n\t\t}\n\t\t\n\t\tif( d[v] < p.first ) continue;\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tedge ed = G[v][i];\n\t\t\tif( d[ed.to] > d[v] + ed.e ){\n\t\t\t\td[ed.to] = d[v] + ed.e;\n\t\t\t\tq.push( P( d[ed.to] , ed.to ) );\n\t\t\t\tprev[ed.to] = v;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 最小値を求める\nint solve(){\n\tint ans = INF;\n\tfor(map<P,int>::iterator it = h.begin() ; it != h.end() ; ++it ){\n\t\tif( (it->first).first == N-1 ){\n\t\t\tint v = h[ it->first ];\n\t\t\tans = min( ans , d[v] );\n\t\t}\n\t}\n\treturn ans;\n}\n\n// 経路復元\nvector<int> get_path(int t){\n\tvector<int> path;\n\tfor( ; t != -1 ; t = prev[t] )\n\t\tpath.push_back( t );\n\treverse( path.begin() , path.end() );\n\treturn path;\n}\n\nint main(){\n\tint M, L;\n\twhile( cin >> N >> M >> L, N || M || L ){\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < M ; i++ ){\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--; b--;\n\t\t\tadd_edge( a , b , d , e );\n\t\t}\n\t\t\n\t\t// グラフの生成\n\t\tid = 0;\n\t\tmap<int,bool> memo;\n\t\tmemo[0] = true;\n\t\tdfs( 0 , L , memo );\n\t\t// ダイクストラ法\n\t\tdijkstra();\n\t\t// 最小コストを求める\n\t\tint ans = solve();\n\t\t// デバッグ\n\t\tvector<int> path = get_path( goal );\n\t\t//debug_2();\n\t\t//debug( path );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nvector<vector<pair<int, int>>> s(101, vector<pair<int, int>>(101));\nvector<vector< int>> sflag(101, vector<int>(101, 0));\nint n, m, l;\n\nvector<vector<long long>> slv(101, vector<long long>(101, 0));\nvector<vector<int>> slvflag(101, vector<int>(101, 0));\n\nint main() {\n\twhile (true) {\n        for (int i = 0; i < 101; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\tslv[i][j] = 0;\n\t\t\t\tslvflag[i][j] = 0;\n                sflag[i][j]=0;\n                slvflag[1][j] = 1;\n\t\t\t}\n\t\t}\n\t\tcin >> n >> m >> l;\n\t\tif (n == 0&& m==0&&l==0)return 0;\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ts[b][a] = make_pair(d, e);\n\t\t\tsflag[b][a] = 1;\n\t\t\ts[a][b] = make_pair(d, e);\n\t\t\tsflag[a][b] = 1;\n\t\t}\n\t\tfor(int time = 0;time <= n;time++){\n            for (int i = 0; i <=n; i++) {\n\t\t\t    for (int j = 0; j <=l; j++) {\n                    if(slvflag[i][j]==1){\n                        for(int a=1;a<=n;a++){\n                            if(sflag[i][a]==1){\n                                if(slvflag[a][j]==0){\n                                    slv[a][j] = slv[i][j]+s[i][a].second;\n                                    slvflag[a][j]=1;\n                                }else{\n                                    slv[a][j] =min(slv[a][j], slv[i][j]+s[i][a].second);\n                                }\n                                int x = j + s[i][a].first;\n                                if(x<=l){\n\n                                    if(slvflag[a][x]==0){\n                                        slv[a][x] = slv[i][j];\n                                        slvflag[a][x]=1;\n                                    }else{\n                                        slv[a][x] = min(slv[i][j],slv[a][x]);\n                                    }\n                                }\n\n\n                            }\n                        }\n                    }\n                }\n            }\n\n            \n\n\n        }\n        \n\t\tcout  << slv[n][l] <<endl;\n\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nclass Edge\n{\npublic:\n    int to, cost, risk;\n    Edge(int to0, int cost0, int risk0){\n        to = to0;\n        cost = cost0;\n        risk = risk0;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n, m, l;\n        cin >> n >> m >> l;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edges(n+1);\n        for(int i=0; i<m; ++i){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            edges[a].push_back(Edge(b, d, e));\n            edges[b].push_back(Edge(a, d, e));\n        }\n\n        vector<vector<int> > dp(n+1, vector<int>(l+1, INF));\n        dp[1][l] = 0;\n        multimap<int, pair<int, int> > mm;\n        mm.insert(make_pair(0, make_pair(1, l)));\n\n        for(;;){\n            int curr = mm.begin()->second.first;\n            int money = mm.begin()->second.second;\n            int risk = mm.begin()->first;\n            mm.erase(mm.begin());\n            if(dp[curr][money] < risk)\n                continue;\n            if(curr == n){\n                cout << risk << endl;\n                break;\n            }\n\n            for(unsigned i=0; i<edges[curr].size(); ++i){\n                int next = edges[curr][i].to;\n\n                int risk2 = risk + edges[curr][i].risk;\n                if(risk2 < dp[next][money]){\n                    dp[next][money] = risk2;\n                    mm.insert(make_pair(risk2, make_pair(next, money)));\n                }\n\n                int money2 = money - edges[curr][i].cost;\n                if(money2 >= 0 && risk < dp[next][money2]){\n                    dp[next][money2] = risk;\n                    mm.insert(make_pair(risk, make_pair(next, money2)));\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n) - 1; i >= k; i--)\n\n#define debug(x) cerr <<#x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pi pair<int,int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n#define tup tuple<long long,int,int>\n\ntypedef long long ll;\nconst ll inf = 900900900100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int MID = 255;\nusing namespace std;\n#define MAX_N 110\n\nint dp[110][100100] = {};\nint main(){\n    int n,m,l;\n    while(cin >> n >> m >> l,n) {\n        rep(i,110) rep(j,100100) dp[i][j] = 0;\n        vector<tup> E[MAX_N];\n        rep(i,m){\n            int a,b,d,e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            E[a].pb(tup(e,b,d));\n            E[b].pb(tup(e,a,d));\n        }\n        priority_queue<tup,vector<tup>,greater<tup> > que;\n\n        ll d[MAX_N][110];\n        rep(i,MAX_N) rep(j,110) d[i][j] = inf;\n\n        rep(i,110) d[0][i] = 0;\n        que.push(tup(0,0,l));\n        while(!que.empty()) {\n            tup p = que.top();\n            que.pop();\n            ll cost = get<0>(p);\n            int v = get<1>(p);\n            int money = get<2>(p);\n            if (d[v][money] < cost) continue;\n            rep(i, E[v].size()) {\n                tup e = E[v][i];\n                //普通に動く\n                if (d[get<1>(e)][money] > d[v][money] + get<0>(e)) {\n                    d[get<1>(e)][money] = d[v][money] + get<0>(e);\n                    que.push(tup(d[get<1>(e)][money], get<1>(e),money));\n                }\n                //お金をはらう\n                if(get<2>(e) <= money) {\n                    if (d[get<1>(e)][money - get<2>(e)] > d[v][money]) {\n                        d[get<1>(e)][money - get<2>(e)] = d[v][money];\n                        que.push(tup(d[get<1>(e)][money - get<2>(e)], get<1>(e),money - get<2>(e)));\n                    }\n                }\n            }\n        }\n        ll ma = inf;\n        rep(i,l + 1){\n            ma = min(ma,d[n - 1][i]);\n        }\n        cout << ma << endl;\n        // cout << \"d[n-1] : \" << d[n - 1] << endl;\n        // int tt = n - 1;\n        // vector<int> WW;\n        // vector<int> VV;\n        // while(true) {\n        //     for(auto e : E[tt]) {\n        //         if(get<1>(e) == bv[tt]) {\n        //             WW.pb(get<2>(e));\n        //             VV.pb(get<0>(e));\n        //             break;\n        //         }\n        //     }\n        //     if(tt == 0) break;\n        //     tt = bv[tt];\n        // }\n\n\n        // REP(i, 1, l + 1) {\n        //     REP(j, 1, WW.size() + 1) {\n        //         dp[i][j] = dp[i][j - 1];\n        //         if( >= WW[j - 1]) {\n        //             dp[i][j] = max(dp[i][j - 1], dp[i - WW[j - 1]][j - 1] + VV[j - 1]);\n        //         }\n        //     }\n        // }\n        // cout << d[n - 1] - dp[l][WW.size()] << endl;\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n/*----------------------------------ここからマクロ----------------------------------*/\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define vecin(a) rep(i,a.size())cin >> a[i]\n#define vecout(a) rep(i,a.size()){cout << a[i];cout << (i == a.size() - 1 ? \"\\n\":\" \");}\n#define overload4(_1,_2,_3,_4,name,...) name\n#define rep1(n) for(int i=0;i<n;++i)\n#define rep2(i,n) for(int i=0;i<n;++i)\n#define rep3(i,a,b) for(int i=a;i<b;++i)\n#define rep4(i,a,b,c) for(int i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(int i=n-1;i>=0;i--)\n#define rrep2(i,n) for(int i=n-1;i>=0;i--)\n#define rrep3(i,a,b) for(int i=a;i>=b;i--)\n#define rrep4(i,a,b,c) for(int i=a;i>=b;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define mp make_pair\n#define debug(x) cerr << #x << \": \" << x << \"\\n\"\n#define myset ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define doset(x) cout << fixed << setprecision(x)\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\nusing dou = double;\nconst int inf = 1 << 30;\nconst ll INF = 1LL << 60;\nconst dou pi = 3.14159265358;\nconst ll mod = 1000000007LL;\n//const ll mod = 998244353LL;\ntypedef pair<ll,ll> P;\nostream &operator<<(ostream &os, const P q){os << q.first << \",\" << q.second;return os;}\nusing graph = vector<vector<ll>>;\ntemplate<class T, class U> inline bool chmin(T& a, const U& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> inline bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> inline bool change(T& a,U& b){if(a > b){swap(a,b);return 1;}return 0;}\n\n//nのm乗をMODで割ったあまりO(logm)\nll modpow(ll n,ll m,ll MOD){\n    if(m == 0)return 1;\n    if(m < 0)return -1;\n    ll res = 1;\n    while(m){\n        if(m & 1)res = (res * n) % MOD;\n        m >>= 1;\n        n *= n;\n        n %= MOD;\n    }\n    return res;\n}\n\nll mypow(ll n,ll m){\n    if(m == 0)return 1;\n    if(m < 0)return -1;\n    ll res = 1;\n    while(m){\n        if(m & 1)res = (res * n);\n        m >>= 1;\n        n *= n;\n    }\n    return res;\n}\n\n//0の場合のアレンジに注意\ntemplate<class T>\nT gcd(T a,T b){\n    a = abs(a);b = abs(b);\n    if(a == 0)return b;\n    else if(b == 0)return a;\n    if(a < b)swap(a,b);\n    if(a % b == 0)return b;\n    else return gcd(b,a%b);\n}\ntemplate<class T>\nT lcm(T a,T b){\n    return a / gcd(a,b) * b;\n}\n\n//素数判定O(sqrt(N))\ntemplate<class T>\ninline bool isp(T n){\n    bool res = true;\n    if(n == 1)return false;\n    else{\n        for(ll i = 2;i * i <= n;i++){\n            if(n % i == 0){\n                res = false;\n                break;\n            }\n        }\n        return res;\n    }\n}\nconst ll cmax = 1000000;\nvector<ll> fac(cmax),finv(cmax),inv(cmax);\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < cmax; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nll nCk(ll n, ll k){\n    if(fac[0] == 0)COMinit();\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\ntemplate<class T = ll>\nT in(){T x;cin >> x;return x;}\n\n/*----------------------------------マクロここまで----------------------------------*/\n\n\ntypedef pair<int,pair<int,int>> pii;\nint main(){\n    myset;\n    int N,M,L;\n    struct edge{\n        int to,cost,tou;\n    };\n    while(1){\n        cin >> N >> M >> L;\n        if(N == 0 && M == 0 && L == 0)break;\n        vector<edge> es[110];\n        int a,b,c,d;\n        rep(i,M){\n            cin >> a >> b >> c >> d;\n            a--;b--;\n            es[a].push_back({b,c,d});\n            es[b].push_back({a,c,d});\n        }\n        vector<vector<int>> dist(N,vector<int>(L + 1,inf));//dist[i][j]:iに予算jで行くための最小盗賊\n        dist[0][0] = 0;\n        priority_queue<pii,vector<pii>,greater<pii>> que;//tou,where,予算\n        que.push(mp(0,mp(0,0)));\n        int cnt = 0;\n        while(!que.empty()){\n            pii p = que.top();\n            que.pop();\n            int d = p.first,w = p.second.first,y = p.second.second;\n            //debug(d);debug(w);debug(y);\n            if(d > dist[w][y])continue;\n            cnt++;\n            for(auto e : es[w]){\n                //if(e.cost + y > L)continue;\n                if(chmin(dist[e.to][y],dist[w][y] + e.tou)){\n                    que.push(mp(dist[e.to][y],mp(e.to,y)));\n                }\n                if(e.cost + y <= L){\n                    if(chmin(dist[e.to][y + e.cost],dist[w][y])){\n                        que.push(mp(dist[e.to][y + e.cost],mp(e.to,y + e.cost)));\n                    }\n                }\n            }\n        }\n        int ans = inf;\n        rep(i,L + 1){\n            chmin(ans,dist[N - 1][i]);\n        }\n        cout << ans << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n     \nusing namespace std;\n     \nint N, M, L;\n     \nstruct edge {\n    int to, distance, enemy;\n};\n     \nstruct P {\n    int from, money, enemy;\n     \n    bool operator >(const P& p) const {\n        return enemy > p.enemy;\n    }\n};\n  \nstruct pair {\n    int money, enemy;\n};\n     \nint main() {\n    while (cin >> N >> M >> L, N|M|L) {\n        vector<vector<edge> > E(N);\n        int a, b, d, e;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> d >> e;\n            E[a-1].push_back({b, d, e});\n            E[b-1].push_back({a, d, e});\n        }\n     \n        priority_queue<P, vector<P>, greater<P>> q;\n        city arr[N];\n        for(int i = 0; i < N; i++) {\n            arr[i].money = 0;\n        }   \n        q.push((P){0, L, 0});\n        while(!q.empty()) {\n            P p = q.top(); q.pop();\n            // goal\n            if (p.from == N-1) {\n                cout << p.enemy << endl;\n                break;\n            }\n            if (p.money >= arr[p.from].money) {\n                arr[p.from].money = p.money;\n                arr[p.from].enemy = p.enemy;\n            } else if (p.enemy <= arr[p.from].enemy) {\n                continue;\n            }\n   \n            for (int i = 0; i < E[p.from].size() ; i++) {\n                edge e = E[p.from][i];\n                q.push((P){e.to-1, p.money, p.enemy+e.enemy});\n                if (p.money-e.distance >= 0) {\n                    q.push((P){e.to-1, p.money-e.distance, p.enemy});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define INF 1000000000\nusing namespace std;\ntypedef long long ll;\n\nstruct edge { ll n, d, e; };\nstruct state {\n  ll n, l, s;\n  bool operator<(const state &state) const { return s > state.s; }\n};\n\nint main(void) {\n  int N, M, L;\n  while(cin >> N >> M >> L, N && M && L) {\n    vector<edge> G[100];\n\n    REP(i, 0, M) {\n      int A, B, D, E;\n      cin >> A >> B >> D >> E;\n      G[A - 1].push_back((edge) { B - 1, D, E });\n      G[B - 1].push_back((edge) { A - 1, D, E });\n    }\n\n    ll dp[100][101];\n    REP(i, 0, N) REP(j, 0, L + 1) dp[i][j] = INF;\n    dp[0][0] = 1;\n\n    priority_queue<state> q;\n    q.push((state) { 0, 0, 0 });\n    while(q.size()) {\n      state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.l << \" \" << c.s << endl;\n\n      if(c.n == N - 1) {\n        cout << c.s << endl;\n        break;\n      }\n\n      if(dp[c.n][c.l] <= c.s) continue;\n      dp[c.n][c.l] = c.s;\n\n      REP(i, 0, G[c.n].size()) {\n        q.push((state) { G[c.n][i].n, c.l, c.s + G[c.n][i].e });\n        if(c.l + G[c.n][i].d <= L) {\n          q.push((state) { G[c.n][i].n, c.l + G[c.n][i].d, c.s });\n        }\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* 2012-10-26T15:07:08 */\n#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, __VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n#define show_bits(b, s)\n#endif\n\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { IFC(s[i] == ' '); if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n/*}}}*/\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tint N, T, H, L;\n\tcin >> N >> T >> H >> L;\n\tvector<PII> members;\n\tREP (i, N) {\n\t\tint t, h; cin >> t >> h;\n\t\tmembers.PB(MP(t, h));\n\t}\n\tint ans;\n\tint cash = 0;\n\tREP (i, N) {\n\t\tPII &m = members[i];\n\t\tif (m.F > 0) {\n\t\t\tm.F--;\n\t\t\tcash += 10;\n\t\t\tT++;\n\t\t\tif (T > L) {\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (m.S > 0) {\n\t\t\tm.S--;\n\t\t\tcash += 100;\n\t\t}\n\t\telse {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cash >= 90) {\n\t\t\tcash -= 90;\n\t\t\tT -= cash / 10;\n\t\t\tcash = 0;\n\t\t\tif (T < 0) {\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (i == N-1) {\n\t\t\ti = -1;\n\t\t}\n\t}\n\t++ans;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n\nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n\nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push(make_pair(0, s));\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        int cost = st.first;\nif(cost==INF) break;\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push(make_pair(d[to], to));\n            }\n        }\n    }\n    return d;\n}\n\nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back(make_pair(e, vv(b, j)));\n                edge[vv(b, j)].push_back({e, vv(a, j)});\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back(make_pair(0, vv(b, j - d)));\n                    edge[vv(b, j)].push_back(make_pair(0, vv(a, j - d)));\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n\n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n            \n            res = min(res,val);\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Edge{\n  int e, d, to;\n  Edge(int e, int d, int to):\n    e(e), d(d), to(to) {}\n};\n\nbool operator<(const Edge& a, const Edge& b){\n  return a.e != b.e ? a.e < b.e : a.d != b.d ? a.d < b.d : a.to < b.to;\n}\n\nint solve(vector< vector<Edge> > &G, int L){\n  int N = G.size(), INF = 1e9;\n  vector< vector<int> > DP(N, vector<int>(L+1,INF));\n  priority_queue<Edge> wait;\n  wait.push(Edge(0,L,0));\n  while(!wait.empty()){\n    int e = -wait.top().e, l = wait.top().d, v = wait.top().to;\n    wait.pop();\n    if(e >= DP[v][l]) continue;\n    DP[v][l] = e;\n    for(int i = 0; i < G[v].size(); ++i){\n      int e_ = G[v][i].e, d_ = G[v][i].d, v_ = G[v][i].to;\n      if(e+e_ < DP[v_][l]) wait.push(Edge(-(e+e_),l,v_));\n      if(l >= d_ && e < DP[v_][l-d_]) wait.push(Edge(-e,l-d_,v_));\n    }\n  }\n  int ret = INF;\n  for(int i = 0; i <= L; ++i) ret = min(ret,DP[N-1][i]);\n  return ret;\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L, N){\n    vector< vector<Edge> > G(N);\n    int a, b, d, e;\n    for(int i = 0; i < M; ++i){\n      cin >> a >> b >> d >> e;\n      --a;--b;\n      G[a].push_back(Edge(e,d,b));\n      G[b].push_back(Edge(e,d,a));\n    }\n    cout << solve(G,L) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, int> PI;\n\nstruct edge {\n\tint from,to;\n\tint cost, res;\n\n\tedge(int t,int c) : to(t),cost(c) {}\n\tedge(int t,int c,int r) : to(t), cost(c), res(r) {}\n\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nvector<edge> G[105];\nint d[105][105];\n\nvoid dijkstra(int s, int l) {\n\trep(i, 105) rep(j, 105) d[i][j] = INF;\n\td[s][l] = 0;\n\n\tpriority_queue<PI, vector<PI>, greater<PI> > que;\n\tque.push(mp(mp(0, -l), s));\n\n\twhile(que.size()) {\n\t\tPI p = que.top(); que.pop();\n\t\tint cost = p.first.first;\n\t\tint coin = p.first.second;\n\t\tint v = p.second;\n\t\tcoin *= -1;\n\n\t\tif(d[v][coin] < cost) continue;\n\t\t\n\t\trep(i, G[v].size()) {\n\t\t\tedge e = G[v][i];\n\n\t\t\tif(d[e.to][coin] > d[v][coin] + e.res) {\n\t\t\t\td[e.to][coin] = d[v][coin] + e.res;\n\t\t\t\tque.push(mp(mp(d[e.to][coin], -coin), e.to));\n\t\t\t}\n\n\t\t\tint nc = coin - e.cost;\n\t\t\tif(nc >= 0 && d[e.to][nc] > d[v][coin]) {\n\t\t\t\td[e.to][nc] = d[v][coin];\n\t\t\t\tque.push(mp(mp(d[e.to][nc], -nc), e.to));\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nint main() {\n\tint n, m, l;\n\twhile(cin >> n >> m >> l)  {\n\t\tif(n == 0 && m == 0 && l == 0) break;\n\n\t\trep(i, 105) G[i].clear();\n\n\t\trep(i, m) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\n\t\t\ta--; b--;\n\n\t\t\tG[a].push_back(edge(b, c, d));\n\t\t\tG[b].push_back(edge(a, c, d));\n\t\t}\n\n\t\tdijkstra(0, l);\n\n\t\tint ans = INF;\n\t\trep(i, l+1) {\n\t\t\tans = min(ans, d[n-1][i]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define MAX 100000000\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<int,p> P;\n//G@ê@à\nstruct edge{\n\tint to,cost,enem;\n};\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n||m||l){\n\t\tvector<edge> tab[110];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedge pre;\n\t\t\tpre.cost=d;\n\t\t\tpre.enem=e;\n\t\t\tpre.to=b;\n\t\t\ttab[a].push_back(pre);\n\t\t\tpre.to=a;\n\t\t\ttab[b].push_back(pre);\n\t\t}\n\t\tint d[110][110];\n\t\t//d[ê][à]=G;\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<100;j++){\n\t\t\td[i][j]=MAX;\n\t\t}\n\t\td[0][l]=0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,p(0,l)));\n\t\twhile(!que.empty()){\n\t\t\tP now=que.top();\n\t\t\tque.pop();\n\t\t\tint nowplace=now.second.first;\n\t\t\tint nowenem=now.first;\n\t\t\tint nowmoney=now.second.second;\n\t\t\tif(d[nowplace][nowmoney]<nowenem)\n\t\t\t\tcontinue;\n\t\t\tif(nowplace==n-1)\n\t\t\tbreak;\n\t\t\tfor(int i=0;i<(int)tab[nowplace].size();i++){\n\t\t\t\tedge e=tab[nowplace][i];\n\t\t\t\tif(e.cost<=nowmoney&&d[e.to][nowmoney-e.cost]>nowenem){\n\t\t\t\t\td[e.to][nowmoney-e.cost]=nowenem;\n\t\t\t\t\tque.push(P(nowenem,p(e.to,nowmoney-e.cost)));\n\t\t\t\t}\n\t\t\t\tif(d[e.to][nowmoney]>nowenem+e.enem){\n\t\t\t\t\td[e.to][nowmoney]=nowenem+e.enem;\n\t\t\t\t\tque.push(P(nowenem+e.enem,p(e.to,nowmoney)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=MAX;\n\t\tfor(int i=0;i<=l;i++)\n\t\tans=min(ans,d[n-1][i]);\n\t\tcout<<ans<<endl;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n, m, l;\nstruct S{\n    int now, d, e;\n    //このままソートするとコストの昇順になる。priority_queueだと逆になる\n    //priority_queue<S, vector<S>, greater<S> >の時はoperator>を定義しないと壊れる\n    bool operator<(const S &s) const{\n        return e > s.e;\n    }\n};\nstruct edge{\n   int to, d, e;\n};\nvector<edge> G[110];\nint dst[110][110];\n\nvoid dijkstra(int s){\n    rep(i, 0, 110) rep(j, 0, 110) dst[i][j] = INF;\n    dst[s][0] = 0;\n\n    priority_queue<S> q;\n    q.push({s, 0, 0});\n    while(!q.empty()){\n        S p = q.top(); q.pop();\n        int from = p.now;\n        int dist = p.d;\n        int cost = p.e;\n        // cout << from << ' ' << dist << ' ' << cost << endl;\n        if(dst[from][dist] < cost) continue;\n        rep(i, 0, G[from].size()){\n            edge e = G[from][i];\n            int next = e.to;\n            int newCost = e.e + cost;\n            int newDist = e.d + dist;\n            if(dst[next][newDist] > cost && newDist <= l){\n                dst[next][newDist] = cost;\n                q.push({next, newDist, cost});\n            }\n            if(dst[next][dist] > newCost){\n                dst[next][dist] = newCost;\n                q.push({next, dist, newCost});\n            }\n        }\n    }\n    int ans = INF;\n    // rep(i, 0, n){\n    //     rep(j, 0, l + 1){\n    //         cout << dst[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    rep(i, 0, l + 1){\n        chmin(ans, dst[n - 1][i]);\n    }\n    cout << ans << endl;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> m >> l;\n        if(n + m + l == 0) break;\n        rep(i, 0, n) G[i].clear();\n        rep(i, 0, m){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--; b--;\n            G[a].push_back({b, d, e});\n            G[b].push_back({a, d, e});\n        }\n        dijkstra(0);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n \nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n \nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\nvector<int> used(V,0);\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push(make_pair(0, s));\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        int cost = st.first;\nif(used[v]) continue;\nused[v]=true;\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push(make_paird[to], to));\n            }\n        }\n    }\n    return d;\n}\n \nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back(make_pair(e, vv(b, j)));\n                edge[vv(b, j)].push_back(make_piar(e, vv(a, j)));\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back(make_pair(0, vv(b, j - d)));\n                    edge[vv(b, j)].push_back(make_pair(0, vv(a, j - d)));\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n \n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n             \n            res = min(res,val);\n        }\n \n        cout << res << endl;\n    }\n    return 0;\n}\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nstruct edge{\n    int to, cost, attack;\n    edge(int to, int cost, int attack): to(to), cost(cost), attack(attack){}\n};\n\nstruct State{\n    int v, l, a;\n    State(int v, int l, int a): v(v), l(l), a(a){}\n    bool operator<(const State& right ) const {\n        return a == right.a ? l < right.l : a > right.a;\n    }\n};\n\nint main(){\n    while(1){\n        int N, M, L;\n        cin >> N >> M >> L;\n        if(N == 0) break;\n\n        vector<vector<edge>> E(N);\n        for(int i=0;i<M;i++){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--; b--;\n            E[a].emplace_back(b, d, e);\n            E[b].emplace_back(a, d, e);\n        }\n\n        bool viewed[101][101];\n        memset(viewed, 0, sizeof(viewed));\n\n        priority_queue<State> que;\n        que.emplace(0, L, 0);\n\n        while(que.size()){\n            State s = que.top(); que.pop();\n            if(viewed[s.v][s.l]) continue;\n            viewed[s.v][s.l] = true;\n            if(s.v == N-1){\n                cout << s.a << endl;\n                break;\n            }\n            for(edge& e: E[s.v]){\n                if(!viewed[e.to][s.l]){\n                    que.emplace(e.to, s.l, s.a+e.attack);\n                }\n                int nl = s.l-e.cost;\n                if(nl >= 0 && !viewed[e.to][nl]){\n                    que.emplace(e.to, nl, s.a);\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n// int n_dir = 4;\n// int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; [> CSS order <]\n// enum direction {\n\t// UP, RIGHT, DOWN, LEFT\n// };\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// };\n// #define FORDIR(d) REP (d, n_dir)\n\ntypedef complex<int> P;\n#define Y real()\n#define X imag()\nP dyx[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\n// P dyx[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\n\nint g_height, g_width;\nbool in_field(P p) {\n\treturn (0 <= p.Y && p.Y < g_height) && (0 <= p.X && p.X < g_width);\n}\n\n/*}}}*/\n\n// My version of (Extended) Dijkstra\n// Pros: easy to access `costs` -- just `costs(node)`\n//       vector with many parameters is confusing e.g. `costs[param1][param2][param3]...`\n\n// Node should have only parameters with which Node can be distinguished\nclass Node {\npublic:\n\t// Parameters to distinguish Nodes\n\tint id;\n\tint budget;\n\n\tNode(int _id, int _budget): id(_id), budget(_budget) {\n\t}\n};\n\n// for priority_queue\ntypedef pair<int, Node> Qtype; // cost and Node\nclass Comp {\npublic:\n\tbool operator() (const Qtype& l, const Qtype& r) const {\n\t\t// compair costs for each Node\n\t\treturn (l.F > r.F);\n\t}\n};\n\n// easy access to saved costs\n// #define MAX_N 100\n// #define MAX_L 100\n// VVI g_saved_costs(MAX_N, VI(MAX_L));\n// void init_saved_costs()\n// {\n\t// REP (i, MAX_N) {\n\t\t// REP (j, MAX_L) {\n\t\t\t// g_saved_costs[i][j] = INF;\n\t\t// }\n\t// }\n// }\nVVI g_saved_costs;\nint saved_cost(Node n)\n{\n\treturn g_saved_costs[n.id][n.budget];\n}\nvoid save_cost(Node n, int cost)\n{\n\tg_saved_costs[n.id][n.budget] = cost;\n}\n\nint main()\n{\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N) {\n\t\tVVI dist(N, VI(N, INF));\n\t\tVVI gang(N, VI(N, INF));\n\t\tREP (_, M) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e; --a, --b;\n\t\t\tdist[a][b] = dist[b][a] = d;\n\t\t\tgang[a][b] = gang[b][a] = e;\n\t\t}\n\n\t\t// Initialize g_saved_costs\n\t\t// init_saved_costs();\n\t\tg_saved_costs = VVI(N, VI(L+1, INF));\n\t\tpriority_queue< Qtype, vector<Qtype>, Comp > q;\n\n\t\tq.push( MP(0, Node(0, L)) );\n\t\twhile (!q.empty()) {\n\t\t\tQtype t = q.top(); q.pop();\n\t\t\tint cost_here = t.F; Node node = t.S;\n\n\t\t\t// Skip if already visited\n\t\t\tif (cost_here > saved_cost(node)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsave_cost(node, cost_here);\n\n\t\t\tREP (i, N) {\n\t\t\t\tif (dist[node.id][i] != INF) {\n\t\t\t\t\t// without guard\n\t\t\t\t\tq.push(MP(cost_here + gang[node.id][i], Node(i, node.budget)));\n\t\t\t\t\tif (dist[node.id][i] <= node.budget) {\n\t\t\t\t\t\t// with guard\n\t\t\t\t\t\tq.push(MP(cost_here, Node(i, node.budget - dist[node.id][i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tREP (i, L+1) {\n\t\t\tans = min(ans, saved_cost(Node(N-1, i)));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nlong long slv(int, int,int);\n\nvector<vector<pair<int, int>>> s(101, vector<pair<int, int>>(101));\nvector<vector< int>> sflag(101, vector<int>(101, 0));\nint n, m, l;\n\nvector<vector<long long>> dp(101, vector<long long>(101, 0));\nvector<vector<int>> dpflag(101, vector<int>(101, 0));\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m >> l;\n\t\tif (n == 0&& m==0&&l==0)return 0;\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ts[b][a] = make_pair(d, e);\n\t\t\tsflag[b][a] = 1;\n\t\t\ts[a][b] = make_pair(d, e);\n\t\t\tsflag[a][b] = 1;\n\t\t}\n\t\t\n\t\tcout  << slv(n, l,0) <<endl;\n\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tdpflag[i][j] = 0;\n                sflag[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long slv(int N, int L,int count) {\n\tif (count > 200)return 100000000000;\n\tcount++;\n\tfor (int j = 0; j <= 101;j++) dpflag[1][j] = 1;\n\n\tif (dpflag[N][L] == 1) return dp[N][L];\n\tlong long min =   1000000000000;\n\tfor (int a = 1; a <= n; ++a) {\n\t\tlong long x = 2000000000000;\n\t\tlong long y = 3000000000000;\n\t\tif (sflag[N][a] == 1) {\n\t\t\tint LL = L - s[N][a].first;\n\t\t\tif (LL >= 0) {\n\t\t\t\tx = slv(a, LL,count);\n\t\t\t}\n\t\t\ty = slv(a, L,count) + s[N][a].second;\n\t\t}\n\t\tif (min>x) min = x;\n\t\tif (min>y) min = y;\n\t}\n\tdpflag[N][L] = 1;\n\tdp[N][L] = min;\n\n\treturn min;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n \nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n \nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push(make_pair(0, s));\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        int cost = st.first;\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push(make_pair[to], to));\n            }\n        }\n    }\n    return d;\n}\n \nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back(make_pair(e, vv(b, j)));\n                edge[vv(b, j)].push_back(make_pair(e, vv(a, j)));\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back(make_pair(0, vv(b, j - d)));\n                    edge[vv(b, j)].push_back(make_pair(0, vv(a, j - d)));\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n \n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n             \n            res = min(res,val);\n        }\n \n        cout << res << endl;\n    }\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<functional>\n#include<map>\n#include<fstream>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = (LL)1e9*(LL)1e5;\n\ntypedef vector<LL> VLL;\ntypedef pair<LL, int> E;\ntypedef vector<list<E>> ADJ;\n#define mp(a,b) make_pair(a,b)\n#define cost(_v) _v.first\n#define to(_v) _v.second\nstruct edge{\n\tLL cost;\n\tLL enemy;\n};\nedge inf = { INF, INF };\ninline VLL dijkstra(int s, ADJ adj){\n\tint n = (int)adj.size();\n\tVLL res(n, -1);\n\tpriority_queue<E, vector<E>, greater<E>> que;\n\tque.push(mp(0ll, s));\n\twhile (que.empty() == false){\n\t\tauto tmp = que.top(); que.pop();\n\t\tauto c = cost(tmp);\n\t\tauto v = to(tmp);\n\t\tif (res[v] >= 0)continue;\n\t\tres[v] = c;\n\t\tfor (auto &i : adj[v]){\n\t\t\tauto d = cost(i);\n\t\t\tauto u = to(i);\n\t\t\tif (res[u] >= 0)continue;\n\t\t\tque.push(mp(c + d, u));\n\t\t}\n\t}\n\n\treturn res;\n};\n\n\nint main(){\n\n\t//ofstream cout(\"out.txt\");\n\twhile (1){\n\t\tint N, M, L;\n\t\tcin >> N >> M >> L;\n\t\tif (N + M + L == 0)return 0;\n\t\tvector<vector<LL>> dp(N + 1, vector<LL>(L + 1, INF));\n\t\tvector<vector<edge>> d(N + 1,vector<edge>(N + 1, inf));\n\t\tADJ adj(N + 1);\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint A, B ;\n\t\t\tLL D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\td[A][B].cost = d[B][A].cost = D;\n\t\t\td[A][B].enemy = d[B][A].enemy = E;\n\t\t\tadj[A].push_back(mp(E, B));\n\t\t\tadj[B].push_back(mp(E, A));\n\t\t}\n\t\tfor (int i = 1; i < N+1; i++){\n\t\t\td[i][i].cost =d[i][i].enemy = 0;\n\t\t}\n\t\tdp[1][0] = 0;\n\n\t\t\n\n\t\tfor (int l = 0; l < L; l++){\n\t\t\tfor (int i = 1; i <= N; i++){\n\t\t\t\tdp[i][l] = min(dp[i][l], dp[i][max(0,l - 1)]);\n\t\t\t}\n\t\t\tadj[1].clear();\n\t\t\tfor (int i = 2; i < N+1; i++){\n\t\t\t\tadj[1].push_back(mp(min(d[1][i].enemy,dp[i][l]), i));\n\t\t\t}\n\t\t\tauto ddd=dijkstra(1, adj);\n\t\t\tfor (int i = 1; i < N+1; i++){\n\t\t\t\tdp[i][l] = ddd[i];\n\t\t\t}\n\t\t\tfor (int i = 1; i <= N; i++){\n\t\t\t\tfor (int j = 1; j <= N; j++){\n\t\t\t\t\tif (l + d[i][j].cost>L)continue;\n\t\t\t\t\tdp[j][l + d[i][j].cost] = min(dp[i][l], dp[j][l + d[i][j].cost]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; i++){\n\t\t\tdp[i][L] = min(dp[i][L], dp[i][max(L - 1,0)]);\n\t\t}\n\t\tadj[1].clear();\n\t\tfor (int i = 2; i < N + 1; i++){\n\t\t\tadj[1].push_back(mp(min(d[1][i].enemy, dp[i][L]), i));\n\t\t}\n\t\tauto ddd = dijkstra(1, adj);\n\t\tfor (int i = 1; i < N + 1; i++){\n\t\t\tdp[i][L] = ddd[i];\n\t\t}\n\t\tLL res = INF;\n\t\tfor (int i = 0; i < L+1; i++){\n\t\t\tres = min(res, dp[N][i]);\n\t\t}\n\t\t//cout << \"res:\";\n\t\tcout << res << endl;\n\n\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\nbool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy < b.enemy;\n}\n\nbool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\t\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tstatus = priority_queue<State, vector<State>, greater<State> >();\n\n\t\t/*\n\t\twhile( !status.empty() ) {\n\t\t\tstatus.pop() ;\n\t\t}\t\n\t\t*/\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nconst int MAX = 101;\nconst int INF = (1<<25);\nint N,M,L;\nint node[MAX][MAX];\n\nstruct Edge{int to,d,killer;};\nvector<Edge> E[MAX];\n\nvoid input(){\n  for(int i = 0; i < M; i++){\n    int from;\n    Edge e;\n    cin >> from >> e.to >> e.d >> e.killer;\n    E[from].push_back(e);\n    swap(from,e.to);\n    E[from].push_back(e);\n  }\n}\n\nvoid solve(){\n  \n  priority_queue<PP, vector<PP>, greater<PP> > Q;\n\n  node[L][1] = 0;\n\n  Q.push(PP(0,P(L,1)));\n\n  while(!Q.empty()){\n    PP pp = Q.top();\n    Q.pop();\n    \n    int t = pp.first;\n    int mon = pp.second.first;\n    int pos = pp.second.second;  \n    if(node[mon][pos] < t) continue;\n\n    for(int i = 0; i < E[pos].size(); i++){\n    \n\n      //employ\n      if(mon >= E[pos][i].d){\n\tif(node[mon-E[pos][i].d][E[pos][i].to] > t){\n\t  node[mon-E[pos][i].d][E[pos][i].to] = t;\n\t  PP pp1;\n\t  pp1.first = t;\n\t  pp1.second.first = mon-E[pos][i].d;\n\t  pp1.second.second = E[pos][i].to;\n\t  Q.push(pp1);\n\t}\n      }\n\n      //not employ\n      if(node[mon][E[pos][i].to] > t+E[pos][i].killer){\n\tnode[mon][E[pos][i].to] = t+E[pos][i].killer;\n\tPP pp1;\n\tpp1.first = t+E[pos][i].killer;\n\tpp1.second.first = mon;\n\tpp1.second.second = E[pos][i].to;\n\n\tQ.push(pp1);\n      }\n    }\n  }\n  int ans = INF;\n\n  for(int i = 0; i <= L; i++)\n    ans = min(ans,node[i][N]);\n  cout << ans << endl;\n}\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    E[i].clear();\n\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++) node[i][j] = INF;\n\n}\n\nint main(){\n\n  while(cin >> N >> M >> L && N+M+L){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nint N, M, K, H, W, L, R;\n\nstruct Edge {\n\tint to, cost, damage;\n\tEdge(int t, int c, int d) {\n\t\tto = t, cost = c, damage = d;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> N >> M >> K, N) {\n\t\tvector<vector<Edge>>edge(N);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> L >> R >> H >> W;\n\t\t\tL--;\n\t\t\tR--;\n\t\t\tedge[L].push_back(Edge(R, H, W));\n\t\t\tedge[R].push_back(Edge(L, H, W));\n\t\t}\n\t\tvector<vector<int>>dis(N, vector<int>(K + 1, MOD));\n\t\tdis[0][K] = 0;\n\t\tpriority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>PQ;\n\t\tPQ.push({ 0,{0,K} });\n\t\twhile (!PQ.empty()) {\n\t\t\tauto box = PQ.top();\n\t\t\tPQ.pop();\n\t\t\tint c = box.first;\n\t\t\tint cn = box.second.first;\n\t\t\tint cm = box.second.second;\n\t\t\tif (dis[cn][cm] < c)continue;\n\t\t\tfor (auto i : edge[cn]) {\n\t\t\t\tif (dis[i.to][cm] > c + i.damage) {\n\t\t\t\t\tdis[i.to][cm] = c + i.damage;\n\t\t\t\t\tPQ.push({ dis[i.to][cm],{i.to,cm} });\n\t\t\t\t}\n\t\t\t\tif (cm >= i.cost) {\n\t\t\t\t\tif (dis[i.to][cm - i.cost] > c) {\n\t\t\t\t\t\tdis[i.to][cm - i.cost] = c;\n\t\t\t\t\t\tPQ.push({ dis[i.to][cm - i.cost],{i.to,cm - i.cost\t} });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = MOD;\n\t\tfor (int i = 0; i <= K; i++)ans = min(ans, dis.back()[i]);\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<numeric>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define rforeach(t,p) for(t::reverse_iterator it=p.rbegin();it!=p.rend();++it)\n#define all(p) p.begin(),p.end()\nusing namespace std;\n\nstruct hoge{\nhoge(int a,int b,int c,int d):enemy(a),money(b),position(c),old(d){}\n    int enemy;\n    int money;\n    int position;\n    int old;\n};\n\nbool operator<(const hoge& left, const hoge& right)\n{\n  return left.enemy < right.enemy ;\n}\n\n#define LOAD 110\n\nint main()\n{\n    int n,m,l;\n    while(cin >> n >> m >> l && (n || m|| l))\n    {\n        int len[LOAD][LOAD],thi[LOAD][LOAD];\n        for(int i=0;i<LOAD;i++)for(int j=0;j<LOAD;j++)\n        {\n            len[i][j]=len[j][i]=thi[i][j]=thi[j][i]=-1;   \n        }\n        for(int i=0;i<m;i++)\n        {\n            int a,b,c,d;\n            cin >> a>>b>>c>>d;\n            len[a][b]=len[b][a]=c;\n            thi[a][b]=thi[b][a]=d;\n        }\n        set<hoge> in;\n        in.insert(hoge(0,l,1,0));\n        \n        while(true)\n        {\n            hoge a=(*in.begin());\n            in.erase(in.begin());\n            int e=a.enemy;\n            int mon=a.money;\n            int pos=a.position;\n            if(pos==n){cout << e << endl;break;}\n            for(int i=2;i<n+1;i++)if((len[pos][i] != -1 )&&(a.old!=i))\n            {\n                in.insert(hoge(e+thi[pos][i],mon,i,pos));\n                if(mon+1 >len[pos][i])\n                    in.insert(hoge(e,mon-len[pos][i],i,pos));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<functional>\n#include<map>\n#include<fstream>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = (LL)1e9*(LL)1e5;\n\ntypedef vector<LL> VLL;\ntypedef pair<LL, int> E;\ntypedef vector<list<E>> ADJ;\n#define mp(a,b) make_pair(a,b)\n#define cost(_v) _v.first\n#define to(_v) _v.second\nstruct edge{\n\tLL cost;\n\tLL enemy;\n};\nedge inf = { INF, INF };\ninline VLL dijkstra(int s, ADJ adj){\n\tint n = (int)adj.size();\n\tVLL res(n, -1);\n\tpriority_queue<E, vector<E>, greater<E>> que;\n\tque.push(mp(0ll, s));\n\twhile (que.empty() == false){\n\t\tauto tmp = que.top(); que.pop();\n\t\tauto c = cost(tmp);\n\t\tauto v = to(tmp);\n\t\tif (res[v] >= 0)continue;\n\t\tres[v] = c;\n\t\tfor (auto &i : adj[v]){\n\t\t\tauto d = cost(i);\n\t\t\tauto u = to(i);\n\t\t\tif (res[u] >= 0)continue;\n\t\t\tque.push(mp(c + d, u));\n\t\t}\n\t}\n\n\treturn res;\n};\n\n\nint main(){\n\n\t//ofstream cout(\"out.txt\");\n\twhile (1){\n\t\tint N, M, L;\n\t\tcin >> N >> M >> L;\n\t\tif (N + M + L == 0)return 0;\n\t\tvector<vector<LL>> dp(N + 1, vector<LL>(L + 1, INF));\n\t\tvector<vector<edge>> d(N + 1,vector<edge>(N + 1, inf));\n\t\tADJ adj(N + 1);\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint A, B ;\n\t\t\tLL D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\td[A][B].cost = d[B][A].cost = D;\n\t\t\td[A][B].enemy = d[B][A].enemy = E;\n\t\t\tadj[A].push_back(mp(E, B));\n\t\t\tadj[B].push_back(mp(E, A));\n\t\t}\n\t\tfor (int i = 1; i < N+1; i++){\n\t\t\td[i][i].cost =d[i][i].enemy = 0;\n\t\t}\n\t\tdp[1][0] = 0;\n\n\t\t\n\n\t\tfor (int l = 0; l < L; l++){\n\t\t\tif(l)for (int i = 1; i <= N; i++){\n\t\t\t\tdp[i][l] = min(dp[i][l], dp[i][l - 1]);\n\t\t\t}\n\t\t\tadj[1].clear();\n\t\t\tfor (int i = 2; i < N+1; i++){\n\t\t\t\tadj[1].push_back(mp(min(d[1][i].enemy,dp[i][l]), i));\n\t\t\t}\n\t\t\tauto ddd=dijkstra(1, adj);\n\t\t\tfor (int i = 1; i < N+1; i++){\n\t\t\t\tdp[i][l] = ddd[i];\n\t\t\t}\n\t\t\tfor (int i = 1; i <= N; i++){\n\t\t\t\tfor (int j = 1; j <= N; j++){\n\t\t\t\t\tif (l + d[i][j].cost>L)continue;\n\t\t\t\t\tdp[j][l + d[i][j].cost] = min(dp[i][l], dp[j][l + d[i][j].cost]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; i++){\n\t\t\tdp[i][L] = min(dp[i][L], dp[i][L - 1]);\n\t\t}\n\t\tadj[1].clear();\n\t\tfor (int i = 2; i < N + 1; i++){\n\t\t\tadj[1].push_back(mp(min(d[1][i].enemy, dp[i][L]), i));\n\t\t}\n\t\tauto ddd = dijkstra(1, adj);\n\t\tfor (int i = 1; i < N + 1; i++){\n\t\t\tdp[i][L] = ddd[i];\n\t\t}\n\t\tLL res = INF;\n\t\tfor (int i = 0; i < L+1; i++){\n\t\t\tres = min(res, dp[N][i]);\n\t\t}\n\t\t//cout << \"res:\";\n\t\tcout << res << endl;\n\n\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint N, M, L;\n\nstruct edge {\n\tint to, distance, enemy;\n};\n\nstruct P {\n\tint from, money, enemy;\n\t\n\tbool operator >(const P& p) const {\n\t\treturn enemy > p.enemy;\n\t}\n};\n\nstruct city {\n\tint money, enemy;\n};\n\nint main() {\n\twhile (cin >> N >> M >> L, N|M|L) {\n\t\tvector<vector<edge> > E(N);\n\t\tint a, b, d, e;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tE[a-1].push_back({b, d, e});\n\t\t\tE[b-1].push_back({a, d, e});\n\t\t}\n\t\t\n\t\tbool G[N+1][L+1];\n\t\tfill_n((bool *)G, (N+1)*(L+1), false);\n\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tcity arr[N];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tarr[i].money = 0;\n\t\t\t// arr[i].enemy = ;\n\t\t}\n\t\tq.push((P){0, L, 0});\n\t\twhile(!q.empty()) {\n\t\t\tP p = q.top(); q.pop();\n\t\t\t// goal\n\t\t\tif (p.from == N-1) {\n\t\t\t\tcout << p.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (G[p.from][p.money]) continue;\n\t\t\tG[p.from][p.money] = true;\n\t\t\tfor (int i = 0; i < E[p.from].size(); i++) {\n\t\t\t\tedge e = E[p.from][i];\n\t\t\t\tq.push((P){e.to-1, p.money, p.enemy+e.enemy});\n\t\t\t\tif (p.money-e.distance >= 0) {\n\t\t\t\t\tq.push((P){e.to-1, p.money-e.distance, p.enemy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nvector<tuple<int, int, int>> vertexs[200];\nint dp[200][200];\nvoid solve(){\n\twhile (true) {\n\t\tint n, m, l;\n\t\tcin >> n >> m >> l;\n\t\tif (n == 0) return;\n\t\tREP(i, n) {\n\t\t\tvertexs[i].clear();\n\t\t}\n\t\tREP(i, m) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--; b--;\n\t\t\tvertexs[a].push_back(make_tuple(b, c, d));\n\t\t\tvertexs[b].push_back(make_tuple(a, c, d));\n\t\t}\n\t\tREP(i, 200) {\n\t\t\tREP(q, 200) {\n\t\t\t\tdp[i][q] = 1e9;\n\t\t\t}\n\t\t}\n\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> next;\n\t\t\n\t\tREP(i, l + 1) {\n\t\t\tdp[0][i] = 0;\n\t\t\tnext.push(make_tuple(0, 0, i));\n\t\t}\n\n\t\twhile (next.empty() == false) {\n\t\t\ttuple<int, int, int> now = next.top();\n\t\t\tnext.pop();\n\t\t\tif (get<0>(now) != dp[get<1>(now)][get<2>(now)]) continue;\n\t\t\tfor (auto x : vertexs[get<1>(now)]) {\n\t\t\t\t//first we think of nothing\n\t\t\t\tif (dp[get<0>(x)][get<2>(now)] > get<0>(now) + get<2>(x)) {\n\t\t\t\t\tdp[get<0>(x)][get<2>(now)] = get<0>(now) + get<2>(x);\n\t\t\t\t\tnext.push(make_tuple(get<0>(now) + get<2>(x), get<0>(x), get<2>(now)));\n\t\t\t\t}\n\t\t\t\tif (get<2>(now) - get<1>(x) < 0) continue;\n\t\t\t\tif (dp[get<0>(x)][get<2>(now) - get<1>(x)] > get<0>(now)) {\n\t\t\t\t\tdp[get<0>(x)][get<2>(now) - get<1>(x)] = get<0>(now);\n\t\t\t\t\tnext.push(make_tuple(get<0>(now), get<0>(x), get<2>(now) - get<1>(x)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[n - 1][0] << endl;\n\t}\n}\n\n#undef int\n\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151&lang=jp\nusing namespace std;\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<62\n\nstruct edge {\n\tint from, to;\n\tint dist, cost;\n\tedge() {}\n\tedge(int from, int to, int dist, int cost) :from(from), to(to), dist(dist), cost(cost) {}\n};\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M, L;\n\twhile (cin >> N >> M >> L, N | M | L) {\n\t\tvector<vector<edge>> G(N);\n\t\tfor (int i = 0; i < M;i++) {\n\t\t\tll A, B, D, E; cin >> A >> B >> D >> E;\n\t\t\tA--; B--;\n\t\t\tG[A].push_back(edge(A, B, D, E));\n\t\t\tG[B].push_back(edge(B, A, D, E));\n\t\t}\n\n\t\t/*                         hotel          balance */\n\t\tvector<vector<ll>> Assasin(N, vector<ll>(L + 1, INF));\n\t\t/*             hotel, balance*/\n\t\tusing Key = tuple<ll, ll>;\n\t\tqueue<Key> q;\n\t\tq.push(Key(0, L));\n\t\tAssasin[0][L] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tll hotel, balance;\n\t\t\ttie(hotel, balance) = q.front(); q.pop();\n\t\t\t//cout << hotel << \" \" << balance << endl;\n\t\t\tfor (auto e : G[hotel]) {\n\t\t\t\tif (e.dist <= balance) {\n\t\t\t\t\tif (Assasin[e.to][balance - e.dist] > Assasin[hotel][balance]) {\n\t\t\t\t\t\tAssasin[e.to][balance - e.dist] = Assasin[hotel][balance];\n\t\t\t\t\t\tq.push(Key(e.to, balance - e.dist));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (Assasin[e.to][balance] > Assasin[hotel][balance] + e.cost) {\n\t\t\t\t\tAssasin[e.to][balance] = Assasin[hotel][balance] + e.cost;\n\t\t\t\t\tq.push(Key(e.to, balance));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll Ans = INF;\n\t\tfor (int i = 0; i <= L;i++) {\n\t\t\tAns = min(Ans, Assasin[N - 1][i]);\n\t\t}\n\t\tcout << Ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nstatic const int INF = 1E8;\nstruct Edge{int A, B, D, E;};\nint N, M, L;\nint A, B, D, E;\nvector<Edge> g[111];\nint d[111];\nvector<int> tmp(3);\n\nint main()\n{\n  while(cin >> N >> M >> L, N){\n    rep(i, 111) g[i].clear();\n    rep(i, M){\n      cin >> A >> B >> D >> E;\n      g[A - 1].push_back((Edge){A - 1, B - 1, D, E});\n      g[B - 1].push_back((Edge){B - 1, A - 1, D, E});\n    }\n\n    rep(i, 111) d[i] = INF;\n    d[0] = 0;\n    priority_queue<vector<int>, vector<vector<int> >, greater<vector<int> > > que;\n    tmp[0] = 0,  tmp[1] = 0,  tmp[2] = 0;\n    que.push(tmp);\n    while(!que.empty()){\n      vector<int> top = que.top();  que.pop();\n      int cnt = top[0];\n      int cost = top[1];\n      int h = top[2];\n      if(d[h] > cnt) continue;\n      if(h == N - 1){\n        //        printf(\"%d\\n\", cnt);\n        //break;\n      }\n      rep(i, g[h].size()){\n        Edge e = g[h][i];\n        tmp[2] = e.B;\n        if(cost <= L && d[e.B] > cnt + e.E){\n          d[e.B] = cnt + e.E;\n          tmp[0] = cnt + e.E;\n          tmp[1] = cost;\n          que.push(tmp);\n        }\n        if(cost + e.D <= L && d[e.B] > cnt){\n          d[e.B] = cnt;\n          tmp[0] = cnt;\n          tmp[1] = cost + e.D;\n          que.push(tmp);\n        }\n      }\n    }\n\n    printf(\"%d\\n\", d[N - 1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint N, M, L;\n\nstruct edge {\n\tint to, distance, enemy;\n};\n\nstruct P {\n\tint from, money, enemy;\n\t\n\tbool operator >(const P& p) const {\n\t\treturn enemy > p.enemy;\n\t}\n};\n\nstruct city {\n\tint money, enemy;\n};\n\nint main() {\n\twhile (cin >> N >> M >> L, N|M|L) {\n\t\tvector<vector<edge> > E(N);\n\t\tint a, b, d, e;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tE[a-1].push_back({b, d, e});\n\t\t\tE[b-1].push_back({a, d, e});\n\t\t}\n\t\t\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tcity arr[N];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tarr[i].money = 0;\n\t\t\t// arr[i].enemy = ;\n\t\t}\n\t\tq.push((P){0, L, 0});\n\t\t\twhile(!q.empty()) {\n\t\t\tP p = q.top(); q.pop();\n\t\t\t// goal\n\t\t\tif (p.from == N-1) {\n\t\t\t\tcout << p.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p.money >= arr[p.from].money) {\n\t\t\t\tarr[p.from].money = p.money;\n\t\t\t\tarr[p.from].enemy = p.enemy;\n\t\t\t} else if (p.enemy <= arr[p.from].enemy) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < E[p.from].size(); i++) {\n\t\t\t\tedge e = E[p.from][i];\n\t\t\t\tq.push((P){e.to-1, p.money, p.enemy+e.enemy});\n\t\t\t\tif (p.money-e.distance >= 0) {\n\t\t\t\t\tq.push((P){e.to-1, p.money-e.distance, p.enemy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint loadD[100][100];\nint loadE[100][100];\n\nbool memo[101][100];\nint n;\n\nstruct data{\n  int pos;\n  int money;\n  int ene;\n  data(int a,int b,int c){\n    pos = a;\n    money = b;\n    ene = c;\n  }\n};\n\nbool operator < (const data &a, const data &b){\n  return a.ene > b.ene;\n}\n\nint main(){\n  int m,l;\n  while(scanf(\"%d%d%d\",&n,&m,&l), n+m+l){\n    memset(loadD, 0, sizeof(loadD));\n    memset(memo, 0, sizeof(memo));\n    REP(i,m){\n      int a,b,d,e;\n      scanf(\"%d%d%d%d\",&a,&b,&d,&e);\n      loadD[a-1][b-1] = loadD[b-1][a-1] = d;\n      loadE[a-1][b-1] = loadE[b-1][a-1] = e;\n    }\n    priority_queue<data> pq;\n    pq.push(data(0, l, 0));\n\n    while(pq.size()){\n      int pos   = pq.top().pos;\n      int money = pq.top().money;\n      int ene   = pq.top().ene;\n      pq.pop();\n\n      if(pos == n-1){\n        printf(\"%d\\n\",ene);\n        break;\n      }\n      if(memo[money][pos]) continue;\n      memo[money][pos] = true;\n\n      REP(i,n){\n        int d = loadD[pos][i];\n        int e = loadE[pos][i];\n        if(d != 0){\n          if(d <= money && !memo[money-d][i])\n            pq.push(data(i, money-d, ene));\n          pq.push(data(i, money, ene+e));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nint N;\nint dist[100][100];\nint en[100][100];\nbool visited[100];\n\nint solve(int a, int L) {\n\tif (a == N - 1) return 0;\n\n\tvisited[a] = true;\n\n\tint min = 100000000;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dist[a][i] == 0 || visited[i]) continue;\n\n\t\tint c1 = solve(i, L) + en[a][i];\n\t\tif (dist[a][i] <= L) {\n\t\t\tint c2 = solve(i, L - dist[a][i]);\n\t\t\tif (c2 < c1) c1 = c2;\n\t\t}\n\n\t\tif (min > c1) min = c1;\n\t}\n\n\tvisited[a] = false;\n\n\treturn min;\n}\n\nint main() {\n\twhile (true) {\n\t\tint M, L;\n\n\t\tscanf(\"%d%d%d\", &N, &M, &L);\n\t\tif (N == 0) break;\n\n\t\tmemset(dist, 0, sizeof(int) * 100 * 100);\n\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b, d, e;\n\t\t\tscanf(\"%d%d%d%d\", &a, &b, &d, &e);\n\t\t\tdist[a - 1][b - 1] = dist[b - 1][a - 1] = d;\n\t\t\ten[a - 1][b - 1] = en[b - 1][a - 1] = e;\n\t\t}\n\n\t\tprintf(\"%d\\n\", solve(0, L));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nstruct edge {\n    int to, cost, num;\n    edge(int t, int c, int n) : to(t), cost(c), num(n) {}\n};\n\nint N, M, L;\nint A[10010], B[10010], D[10010], E[10010];\nint dis[110][110];\nvector<edge> G[110];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> N >> M >> L, N) {\n        REP (i, 110) G[i].clear();\n        REP (i, M) {\n            cin >> A[i] >> B[i] >> D[i] >> E[i];\n            A[i]--, B[i]--;\n            G[A[i]].emplace_back(B[i], D[i], E[i]);\n            G[B[i]].emplace_back(A[i], D[i], E[i]);\n        }\n        const int INF = 1 << 30;\n        fill_n((int*)dis, 110 * 110, INF);\n        dis[0][L] = 0;\n        using P = tuple<int, int, int>;\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.emplace(0, 0, L);\n        while (!que.empty()) {\n            int dd, v, c;\n            tie(dd, v, c) = que.top(); que.pop();\n            if (dis[v][c] < dd) continue;\n            for (auto& e : G[v]) {\n                if (e.cost <= c) {\n                    if (dis[e.to][c - e.cost] > dis[v][c]) {\n                        dis[e.to][c - e.cost] = dis[v][c];\n                        que.emplace(dis[e.to][c - e.cost], e.to, c - e.cost);\n                    }\n                }\n                if (dis[e.to][c] > dis[v][c] + e.num) {\n                    dis[e.to][c] = dis[v][c] + e.num;\n                    que.emplace(dis[e.to][c], e.to, c);\n                }\n            }\n        }\n        int ans = INF;\n        REP (i, 110) ans = min(ans, dis[N - 1][i]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 1, 1, -1, -1};\nint dx[]={1, -1, 0, 0, 1, -1, -1, 1};\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define mp make_pair\n#define fi first\n#define sc second\n#define INF 1000000000\n\nstruct edge {ll from,to,D,E;};\n\nll n,m,l;\nedge es[200000];\nll dp[200][200];\n\nint main() {\n\twhile(true) {\n\t\tcin >> n >> m >> l;\n\n\t\tif(n == 0)\n\t\t\tbreak;\n\n\t\tREP(i,m) {\n\t\t\tll a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--;b--;\n\n\t\t\tes[i*2] = (edge) {a,b,d,e};\n\t\t\tes[i*2+1] = (edge) {b,a,d,e};\n\t\t}\n\n\t\tREP(i,n)REP(j,l+1)dp[i][j] = INF;\n\n\t\tREP(i,l+1)dp[n-1][i] = 0;\n\n\t\twhile(true) {\n\t\t\tbool f = true;\n\n\t\t\tREP(i,m*2) {\n\t\t\t\tedge e = es[i];\n\n\t\t\t\tREP(j,l+1) {\n\t\t\t\t\tif(dp[e.from][j] > dp[e.to][j] + e.E){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tdp[e.from][j] = dp[e.to][j] + e.E;\n\t\t\t\t\t}\n\t\t\t\t\tif(j + e.D <= l && dp[e.from][j] > dp[e.to][j + e.D]) {\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tdp[e.from][j] = dp[e.to][j + e.D];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(f)\n\t\t\t\tbreak;\n\n\t\t}\n\t\tcout << dp[0][0] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n  \nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n  \nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push(make_pair(0, s));\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        int cost = st.first;\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push(make_pair([to], to));\n            }\n        }\n    }\n    return d;\n}\n  \nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back(make_pair(e, vv(b, j)));\n                edge[vv(b, j)].push_back(make_pair(e, vv(a, j)));\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back(make_pair(0, vv(b, j - d)));\n                    edge[vv(b, j)].push_back(make_pair(0, vv(a, j - d)));\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n  \n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n              \n            res = min(res,val);\n        }\n  \n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nstruct road {\n\tint to;\n\tint cost;\n\tint attack;\n};\nstruct aa {\n\tint now;\n\tint money;\n\tint damage;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.damage> r.damage;\n\t}\n};\nint N, M, L;\nint memo[100][10001];\nint check(const vector<vector<road>>&edges, int amoney) {\n\tfor (int i = 0; i < 100; ++i) {\n\t\tfor (int j = 0; j < 10001; ++j) {\n\t\t\tmemo[i][j] = 999999999;\n\t\t}\n\t}\n\tmemo[0][amoney] = 0;\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tque.push(aa{ 0,amoney,0 });\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tif (atop.now == N - 1)return atop.damage;\n\t\telse {\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\t{\n\t\t\t\t\tif (atop.money >= e.cost) {\n\t\t\t\t\t\tif (memo[e.to][atop.money - e.cost]>atop.damage) {\n\t\t\t\t\t\t\tmemo[e.to][atop.money - e.cost] = atop.damage;\n\t\t\t\t\t\t\tque.push({ e.to,atop.money - e.cost,atop.damage });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tif (memo[e.to][atop.money]>atop.damage+e.attack) {\n\t\t\t\t\t\t\tmemo[e.to][atop.money] = atop.damage + e.attack;\n\t\t\t\t\t\t\tque.push({ e.to,atop.money,atop.damage + e.attack });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> N >> M >> L;\n\t\tif (!N)break;\n\t\tvector<vector<road>>roads(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e;\n\t\t\ta--; b--;\n\t\t\troads[a].push_back(road{ b,d,e });\n\t\t\troads[b].push_back(road{ a,d,e });\n\t\t}\n\t\tlong long amin = -1;\n\t\tlong long amax = 99999999;\n\t\tint ans = check(roads, L);\n\t\tcout << ans << endl;\n\t\t/*while (amin + 1 != amax) {\n\t\t\tlong long amid = (amin + amax) / 2;\n\t\t\tif (check(roads,amid)) {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t}\n\t\tcout << amax << endl;*/\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n#define INF 1000000000\n\nint main() {\n\tint n, m;\n\tlong long int l;\n\twhile (cin >> n >> m >> l) {\n\t\tif (n == 0 && m == 0 && l == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< vector<long long int> > cc(n, vector<long long int>(n, INF));\n\t\tvector< vector<long long int> > dd(n, vector<long long int>(n, INF));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcc[i][i] = dd[i][i] = 0;\n\t\t}\n\t\tint a, b;\n\t\tlong long int d, e;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tcc[a][b] = cc[b][a] = d;\n\t\t\tdd[a][b] = dd[b][a] = e;\n\t\t}\n\t\tlong long int ans = INF;\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tcc[i][j] = min(cc[i][j], cc[i][k] + cc[k][j]);\n\t\t\t\t\tdd[i][j] = min(dd[i][j], dd[i][k] + dd[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (cc[0][i] <= l) {\n\t\t\t\tans = min(ans, dd[i][n - 1]);\n\t\t\t}\n\t\t\tif (cc[i][n - 1] <= l) {\n\t\t\t\tans = min(ans, dd[0][i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \"\\n\"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nvoid solve(int N,int M,int L) {\n    struct edge{\n        int to;\n        int left;\n        int dist;\n        int thief;\n    };\n    vector<vector<vector<edge>>> g(N,vector<vector<edge>>(110));\n    REP(i,M) {\n        int a,b,d,e;\n        cin>>a>>b>>d>>e;\n        REP(j,110) {\n            g[a-1][j].push_back(edge{b-1,j,d,e});  // ????????????\n            if(j-d>=0) g[a-1][j].push_back(edge{b-1,j-d,d,e});  // ??????\n        }\n        REP(j,110) {\n            g[b-1][j].push_back(edge{a-1,j,d,e});  // ????????????\n            if(j-d>=0) g[b-1][j].push_back(edge{a-1,j-d,d,e});  // ??????\n        }\n    }\n    vector<vector<int>> dp(N,vector<int>(110,INF));\n    dp[0][L]=0;\n    priority_queue<pair<int,pii>,vector<pair<int,pii>>,greater<pair<int,pii>>> pq;\n    pq.push({0,{0,L}});\n    while(!pq.empty()) {\n        int y=pq.top().second.first;\n        int z=pq.top().second.second;\n        pq.pop();\n        FORE(e,g[y][z]) {\n            if(z==e.left) {\n                if(dp[e.to][e.left]>dp[y][z]+e.thief) {\n                    dp[e.to][e.left]=dp[y][z]+e.thief;\n                    pq.push({dp[e.to][e.left],{e.to,e.left}});\n                }\n            }\n            else {\n                if(dp[e.to][e.left]>dp[y][z]) {\n                    dp[e.to][e.left]=dp[y][z];\n                    pq.push({dp[e.to][e.left],{e.to,e.left}});\n                }\n            }\n        }\n    }\n    int ans=INF;\n    REP(i,110) chmin(ans,dp[N-1][i]);\n    cout<<ans<<endl;\n}\nsigned main() {\n    while(1) {\n        int N,M,L;\n        cin>>N>>M>>L;\n        if(N+M+L==0) break;\n        solve(N,M,L);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nint main() {\n    int N, M, L;\n    int a,b;\n    int now;\n    cin >> N >> M >> L;\n    for(;N!=0;){\n        vector<vector<bool>> graph(N,vector<bool>(N,false));\n        vector<vector<int>> distance(N,vector<int>(N)),evect(N,vector<int>(N));\n        //vector<vector<int>> dp(N,vector<int>(L+1,1000000000));\n        vector<vector<int>> dp_old(N,vector<int>(L+1,1000000000));\n        queue<int> vertex;\n        for(int i=0; i< M; i++){\n            cin >> a >> b;\n            a--;b--;\n            graph[a][b] = true; graph[b][a] = true;\n            cin >> distance[a][b] >> evect[a][b];\n            distance[b][a] = distance[a][b];\n            evect[b][a] = evect[a][b];\n        }\n        for(int i=0;i<=L;i++){\n            dp_old[0][i] = 0;\n            //dp[0][i] = 0;\n        }\n        for(int itr=0;itr<N/2 + 1;itr++){\n            vector<bool> reached(N,false);\n            reached[0] = true;\n            if(itr==0){\n                for(int i=0; i<N; i++){\n                    if(graph[0][i]){\n                        vertex.push(i);\n                        //graph[0][i] = false;\n                        //graph[i][0] = false;\n                        dp_old[i][L] = evect[0][i];\n                        //dp[i][L] = evect[0][i];\n                        if(L>=distance[0][i]){\n                            dp_old[i][L-distance[0][i]] = 0;\n                            //dp[i][L-distance[0][i]] = 0;\n                        }\n                    }\n                }\n            }else{\n                for(int i=0 ; i< N ; i++){\n                    if(graph[0][i]){\n                        vertex.push(i);\n                    }\n                }\n            }\n            for(;!vertex.empty();){\n                now = vertex.front();\n                reached[now] = true;\n                vertex.pop();\n                for(int i=1; i<N; i++){\n                    if(graph[now][i]){\n                        if(!reached[i])vertex.push(i);\n                        for(int j=0;j<=L; j++){\n                            if(j+distance[now][i]<=L){\n                                dp_old[now][j] = min(dp_old[now][j],min(dp_old[i][j]+evect[now][i],dp_old[i][j+distance[now][i]]));\n                                //dp_old[i][j] = min(dp_old[i][j],min(dp_old[now][j]+evect[now][i],dp_old[now][j+distance[now][i]]));\n                                //dp_old[now][j] = dp[now][j];\n                                //dp_old[i][j] = dp[i][j];\n                            }else{\n                                dp_old[now][j] = min(dp_old[i][j]+evect[now][i],dp_old[now][j]);\n                                //dp_old[i][j] = min(dp_old[now][j]+evect[now][i],dp_old[i][j]);\n                                //dp_old[now][j] = dp[now][j];\n                                //dp_old[i][j] = dp[i][j];\n                            }\n                        }\n                    }\n                }\n                //swap(dp,dp_old);\n            }\n        }\n        //swap(dp,dp_old);\n        int ans=dp_old[N-1][L];\n        for(int i=0; i<L ; i++){\n            ans=min(ans,dp_old[N-1][i]);\n        }\n        cout << ans << endl;\n\n        cin >> N >> M >>L;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint N, M, L;\n\nstruct edge {\n\tint to, distance, enemy;\n};\n\nstruct P {\n\tint from, money, enemy;\n\t\n\tbool operator >(const P& p) const {\n\t\treturn enemy > p.enemy;\n\t}\n};\n\nstruct city {\n\tint money, enemy;\n};\n\nint main() {\n\twhile (cin >> N >> M >> L, N|M|L) {\n\t\tvector<vector<edge> > E(N);\n\t\tint a, b, d, e;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tE[a-1].push_back({b, d, e});\n\t\t\tE[b-1].push_back({a, d, e});\n\t\t}\n\t\t\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tcity arr[N];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tarr[i].money = 0;\n\t\t\t// arr[i].enemy = ;\n\t\t}\n\t\tq.push((P){0, L, 0});\n\t\t\twhile(!q.empty()) {\n\t\t\tP p = q.top(); q.pop();\n\t\t\t// goal\n\t\t\tif (p.from == N-1) {\n\t\t\t\tcout << p.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < E[p.from].size(); i++) {\n\t\t\t\tif (p.money >= arr[p.from].money) {\n\t\t\t\t\tarr[p.from].money = p.money;\n\t\t\t\t\tarr[p.from].enemy = p.enemy;\n\t\t\t\t} else if (p.enemy <= arr[p.from].enemy) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tedge e = E[p.from][i];\n\t\t\t\tq.push((P){e.to-1, p.money, p.enemy+e.enemy});\n\t\t\t\tif (p.money-e.distance >= 0) {\n\t\t\t\t\tq.push((P){e.to-1, p.money-e.distance, p.enemy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n\nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n\nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push({0, s});\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        int cost = st.first;\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push({d[to], to});\n            }\n        }\n    }\n    return d;\n}\n\nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back({e, vv(b, j)});\n                edge[vv(b, j)].push_back({e, vv(a, j)});\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back({0, vv(b, j - d)});\n                    edge[vv(b, j)].push_back({0, vv(a, j - d)});\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n\n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n            \n            res = min(res,val);\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nstruct edge {\n    int to;\n    int cost;\n    int numOfTheaf;\n};\n\nstruct info {\n    int now;\n    int sumOfCost;\n    int sumOfTheaf;\n    bool operator < (const info &o) const {\n        return  sumOfTheaf > o.sumOfTheaf;\n    }\n};\n\nint main() {\n    int n, m, l;\n    while (cin >> n >> m >> l, n) {\n        vector <vector <edge> > G(n);\n        rep (i, m) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--; b--;\n            G[a].push_back({b, d, e});\n            G[b].push_back({a, d, e});\n        }\n        //       to, sumOfCost -> sumOfTheaf\n        int dist[110][110] = {}; rep (i, 110) rep (j, 110) dist[i][j] = 1e9;\n        bool used[110][110] = {};\n\n        //info -> now, sumOfCost, sumOfTheaf\n        priority_queue <info> que;\n        que.push({0, 0, 0});\n\n        dist[0][0] = 0;\n\n        while (!que.empty()) {\n            info tmp = que.top(); que.pop();\n            if ( used[tmp.now][tmp.sumOfCost] ) continue;\n            used[tmp.now][tmp.sumOfCost] = true;\n            rep (i, G[tmp.now].size()) {\n                //護衛を雇わない場合\n                {\n                    if ( dist[G[tmp.now][i].to][tmp.sumOfCost] > dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf ) {\n                        dist[G[tmp.now][i].to][tmp.sumOfCost] = dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf;\n                        que.push({G[tmp.now][i].to, tmp.sumOfCost, dist[G[tmp.now][i].to][tmp.sumOfCost]});\n                    }\n                }\n                //護衛を雇う場合\n                {\n                //お金こえちゃだめ\n                    if ( G[tmp.now][i].cost + tmp.sumOfCost > l ) continue;\n                    if ( dist[G[tmp.now][i].to][tmp.sumOfCost + G[tmp.now][i].cost] > dist[tmp.now][tmp.sumOfCost] ) {\n                        dist[G[tmp.now][i].to][tmp.sumOfCost + G[tmp.now][i].cost] = dist[tmp.now][tmp.sumOfCost];\n                        que.push({G[tmp.now][i].to, tmp.sumOfCost + G[tmp.now][i].cost, tmp.sumOfTheaf});\n                    }\n                }\n            }\n        }\n        int ans = 1e9;\n        rep (i, l + 1) ans = min(ans, dist[n - 1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<tuple>\n#include<queue>\n#define INFTY 1000000000 \nusing namespace std;\n \nint main() {\n    int N, M, L;\n    int a,b;\n    int now,dist;\n    int tmp;\n    cin >> N >> M >> L;\n    for(;N!=0;){\n        vector<vector<bool>> graph(N,vector<bool>(N,false));\n        vector<vector<int>> distance(N,vector<int>(N)),evect(N,vector<int>(N));\n        vector<vector<int>> dp(N,vector<int>(L+1,INFTY));\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\n        for(int i=0; i< M; i++){\n            cin >> a >> b;\n            a--;b--;\n            graph[a][b] = true; graph[b][a] = true;\n            cin >> distance[a][b] >> evect[a][b];\n            distance[b][a] = distance[a][b];\n            evect[b][a] = evect[a][b];\n        }\n        for(int j=L; j>=0 ; j--){\n            q.push(pair<int,int>(0,0));\n            vector<bool> used(N,false);\n            for(;!q.empty();){\n                tie(dist,now) = q.top();\n                q.pop();\n                if(used[now]) continue;\n                used[now] = true;\n                dp[now][j] = dist;\n                for(int i=0; i< N; i++){\n                    if(graph[now][i]){\n                        if(j+distance[now][i]<=L){\n                            tmp = min(dist+evect[now][i],dp[now][j+distance[now][i]]);\n                        }else{ \n                            tmp = dist+evect[now][i];\n                        }\n                        if(dp[i][j] <= tmp) continue;\n                        q.push(pair<int,int>(tmp,i)); \n                    }\n                }\n            }\n        }\n\n        int ans=dp[N-1][L];\n        for(int i=0; i<L ; i++){\n            ans=min(ans,dp[N-1][i]);\n        }\n        cout << ans << endl;\n \n        cin >> N >> M >> L;\n    }\n \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nbool operator==(const State& lhs, const State& rhs)\n{\n    return lhs.loc == rhs.loc && lhs.money == rhs.money && lhs.damage == rhs.damage;\n}\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<State> memo(101);\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (memo[current.loc] == current) {\n                continue;\n            }\n            memo[current.loc] = current;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (e.dist <= current.money) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint N, M, L;\n\nstruct Edge {\n\tint to, cost, enemy;\n\tEdge(int _t, int _c, int _e) : to(_t), cost(_c), enemy(_e) {}\n};\nbool operator > (const Edge& e1, const Edge& e2) {\n\tif (e1.enemy < e2.enemy) return true;\n\telse if (e1.to > e2.to) return true;\n\treturn e1.cost < e2.cost;\n}\nbool operator == (const Edge& e1, const Edge& e2) {\n\tif (e1.enemy == e2.enemy && e1.to==e2.to && e1.cost == e2.cost) return true;\n\treturn false;\n}\nbool operator != (const Edge& e1, const Edge& e2) { return !(e1 == e2); }\nbool operator < (const Edge& e1, const Edge& e2) { return !(e1 > e2) && (e1 != e2); }\nbool operator >= (const Edge& e1, const Edge& e2) { return (e1 > e2) || (e1 == e2); }\nbool operator <= (const Edge& e1, const Edge& e2) { return (e1 < e2) || (e1 == e2); }\n\nconst int INF = 1e9;\nint d[110][110];\n\nint main() {\n\twhile (1) {\n\t\tcin >> N >> M >> L; if (N==0 && M==0 && L==0) break;\n\t\tvector< vector<Edge> > G(N+1, vector<Edge>());\n\t\t\n\t\tfor (int i=0; i<M; i++) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e;\n\t\t\tG[a].push_back(Edge(b, d, e));\n\t\t\tG[b].push_back(Edge(a, d, e));\n\t\t}\n\t\t\n\t\tfor (int i=0; i<=N; i++) fill(d[i], d[i] + L + 1, INF);\n\t\t\n\t\td[1][0] = 0;\n\t\t\n\t\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\t\tq.push( Edge(1, 0, 0) );\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\t\n\t\t\tfor (int i=0; i<(int)G[e.to].size(); i++) {\n\t\t\t\tEdge ne = G[e.to][i];\n\t\t\t\t\n\t\t\t\tif (e.cost + ne.cost <= L) {\n\t\t\t\t\tif (d[ne.to][e.cost + ne.cost] > e.enemy) {\n\t\t\t\t\t\td[ne.to][e.cost + ne.cost] = e.enemy;\n\t\t\t\t\t\tq.push(Edge(ne.to, e.cost + ne.cost, e.enemy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (d[ne.to][e.cost] > e.enemy + ne.enemy) {\n\t\t\t\t\td[ne.to][e.cost] = e.enemy + ne.enemy;\n\t\t\t\t\tq.push(Edge(ne.to, e.cost, e.enemy + ne.enemy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tfor (int i=0; i<=L; i++) ans = min(ans, d[N][i]);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nlong long slv(int, int,int);\n\nvector<vector<pair<int, int>>> s(101, vector<pair<int, int>>(101));\nvector<vector< int>> sflag(101, vector<int>(101, 0));\nint n, m, l;\n\nvector<vector<long long>> dp(101, vector<long long>(101, 0));\nvector<vector<int>> dpflag(101, vector<int>(101, 0));\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m >> l;\n\t\tif (n == 0)return 0;\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ts[b][a] = make_pair(d, e);\n\t\t\tsflag[b][a] = 1;\n\t\t\ts[a][b] = make_pair(d, e);\n\t\t\tsflag[a][b] = 1;\n\t\t}\n\t\tlong long answer = 100000000000;\n\t\tfor (int i = 1; i <= l; ++i) {\n\t\t\tif (answer > slv(n, i,0)) answer = slv(n, i,0);\n\n\t\t}\n\t\tcout << answer << endl;\n\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tdpflag[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\n\n\t}\n}\n\n\n\n\n\nlong long slv(int N, int L,int count) {\n\tif (count > 200)return 100000000000;\n\tcount++;\n\tfor (int j = 1; j <= l;j++) dpflag[1][j] = 1;\n\n\tif (dpflag[N][L] == 1) return dp[N][L];\n\tlong long min =   1000000000000;\n\tfor (int a = 0; a <= n; ++a) {\n\t\tlong long x = 2000000000000;\n\t\tlong long y = 3000000000000;\n\t\tif (sflag[N][a] == 1) {\n\t\t\tint LL = L - s[N][a].first;\n\t\t\tif (LL >= 0) {\n\t\t\t\tx = slv(a, LL,count);\n\t\t\t}\n\t\t\ty = slv(a, L,count) + s[N][a].second;\n\n\n\t\t}\n\t\tif (min>x) min = x;\n\t\tif (min>y) min = y;\n\n\n\t}\n\tdpflag[N][L] = 1;\n\tdp[N][L] = min;\n\n\treturn min;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\nclass State\n{\npublic:\n  int pos, money, danger;\n\n  State(int p, int m, int d)\n    :pos(p), money(m), danger(d) {}\n\n  bool operator < (const State& st) const\n  {\n    return this->danger > st.danger;\n  }\n};\n\nint main()\n{\n  const int INF = 1 << 30;\n  const int MAX_N = 100;\n  const int MAX_L = 101;\n\n  int N, M, L;\n  int cost[MAX_N][MAX_L];\n  bool visited[MAX_N][MAX_L];\n  pair<int, int> edge[MAX_N][MAX_N];\n\n  while (scanf(\"%d %d %d\", &N, &M, &L) != EOF) {\n    if (N == 0 && M == 0 && L == 0)\n      break;\n\n    for (int i = 0; i < MAX_N; ++i) {\n      for (int j = 0; j < MAX_N; ++j)\n\tedge[i][j].first = edge[i][j].second = INF;\n    }\n\n    for (int i = 0; i < MAX_N; ++i) {\n      for (int j = 0; j < MAX_L; ++j) {\n\tcost[i][j] = INF;\n\tvisited[i][j] = false;\n      }\n    }\n\n    for (int i = 0; i < M; ++i) {\n      int A, B, D, E;\n      scanf(\"%d %d %d %d\", &A, &B, &D, &E);\n      --A;\n      --B;\n      edge[A][B].first = edge[B][A].first = D;\n      edge[A][B].second = edge[B][A].second = E;\n    }\n\n    priority_queue<State> que;\n    cost[0][L] = 0;\n    que.push(State(0, L, 0));\n\n    while (!que.empty()) {\n      State st = que.top();\n      que.pop();\n\n      if (st.pos == N-1) {\n\tprintf(\"%d\\n\", st.danger);\n\tbreak;\n      }\n\n      if (cost[st.pos][st.money] < st.danger || visited[st.pos][st.money])\n\tcontinue;\n\n      visited[st.pos][st.money] = true;\n      for (int i = 0; i < N; ++i) {\n\tif (edge[st.pos][i].first == INF)\n\t  continue;\n\n\tif (st.money >= edge[st.pos][i].first) {\n\t  int m = st.money - edge[st.pos][i].first;\n\t  if (st.danger < cost[i][m]) {\n\t    cost[i][m] = st.danger;\n\t    que.push(State(i, m, st.danger));\n\t  }\n\t}\n\n\tint d = st.danger + edge[st.pos][i].second;\n\tif (d < cost[i][st.money]) {\n\t  cost[i][st.money] = d;\n\t  que.push(State(i, st.money, d));\n\t}\n      }\n\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define MAX 100000000\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<int,p> P;\n//G@ê@à\nstruct edge{\n\tint to,cost,enem;\n};\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n||m||l){\n\t\tvector<edge> tab[110];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedge pre;\n\t\t\tpre.cost=d;\n\t\t\tpre.enem=e;\n\t\t\tpre.to=b;\n\t\t\ttab[a].push_back(pre);\n\t\t\tpre.to=a;\n\t\t\ttab[b].push_back(pre);\n\t\t}\n\t\tint d[110][110];\n\t\t//d[ê][à]=G;\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<=l;j++){\n\t\t\td[i][j]=MAX;\n\t\t}\n\t\td[0][l]=0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,p(0,l)));\n\t\twhile(!que.empty()){\n\t\t\tP now=que.top();\n\t\t\tque.pop();\n\t\t\tint nowplace=now.second.first;\n\t\t\tint nowenem=now.first;\n\t\t\tint nowmoney=now.second.second;\n\t\t\tif(d[nowplace][nowmoney]<nowenem)\n\t\t\t\tcontinue;\n\t\t\tif(nowplace==n-1)\n\t\t\tbreak;\n\t\t\td[nowplace][nowmoney]=nowenem;\n\t\t\tfor(int i=0;i<(int)tab[nowplace].size();i++){\n\t\t\t\tedge e=tab[nowplace][i];\n\t\t\t\tif(e.cost<=nowmoney&&d[e.to][nowmoney-e.cost]>nowenem){\n\t\t\t\t\td[e.to][nowmoney-e.cost]=nowenem;\n\t\t\t\t\tque.push(P(nowenem,p(e.to,nowmoney-e.cost)));\n\t\t\t\t}\n\t\t\t\tif(d[e.to][nowmoney]>nowenem+e.enem){\n\t\t\t\t\td[e.to][nowmoney]=nowenem+e.enem;\n\t\t\t\t\tque.push(P(nowenem+e.enem,p(e.to,nowmoney)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=MAX;\n\t\tfor(int i=0;i<=l;i++)\n\t\tans=min(ans,d[n-1][i]);\n\t\tcout<<ans<<endl;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110][110]={};\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(now==n){\n    ans=min(ans,sum);\n    return;\n  }\n  if(memo[nokori][now]<=sum)return;\n  for(int i=0;i<=nokori;i++)\n    memo[i][now]=sum;\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      used[E[now][i].to]=true;\n      if(nokori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n      for(int j=0;j<l+5;j++)\n      memo[j][i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct edge {\n  int to, d, e;\n};\n\nbool visited[102];\nvector<edge> es[102];\nint N, M, L, dp[102][102];\n\nint dfs(int cur, int remain) {\n  if (cur == (N - 1)) return 0;\n  \n  visited[cur] = true;\n  int& ret = dp[cur][remain];\n\n  if (ret >= 0) return ret;\n\n  ret = 1 << 30;\n\n  rep(i,es[cur].size()) {\n    edge e = es[cur][i];\n    if (visited[e.to]) continue;\n\n    // やとわずすすんでみる\n    ret = min(ret, e.e + dfs(e.to, remain));\n    \n    // やとえるばあいはやとってみる\n    if (e.e > 0 && remain >= e.d) {\n      ret = min(ret, dfs(e.to, remain - e.d));\n    }\n  }\n  \n  visited[cur] = false;\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d%d%d\", &N, &M, &L), N) {\n    rep(i,N) es[i].clear();\n    int a, b, d, e;\n    rep(i,M) {\n      scanf(\"%d%d%d%d\", &a, &b, &d, &e);\n      --a; --b;\n      es[a].push_back((edge){b, d, e});\n      es[b].push_back((edge){a, d, e});\n    }\n    memset(dp, -1, sizeof dp);\n    printf(\"%d\\n\", dfs(0, L));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\npair<int,int> memo[110];\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(now==n){\n    ans=min(ans,sum);\n    return;\n  }\n  if(memo[now].F<=sum)return;\n  if(memo[now].S>nokori)return;\n  memo[now]=mp(sum,nokori);\n\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      used[E[now][i].to]=true;\n      if(nokori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n      memo[i]=mp(INF,0);\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define MAX 100000000\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<int,p> P;\n//G@ê@à\nstruct edge{\n\tint to,cost,enem;\n};\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n||m||l){\n\t\tvector<edge> tab[110];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedge pre;\n\t\t\tpre.cost=d;\n\t\t\tpre.enem=e;\n\t\t\tpre.to=b;\n\t\t\ttab[a].push_back(pre);\n\t\t\tpre.to=a;\n\t\t\ttab[b].push_back(pre);\n\t\t}\n\t\tint d[110][110];\n\t\t//d[ê][à]=G;\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<100;j++){\n\t\t\td[i][j]=MAX;\n\t\t}\n\t\td[0][l]=0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,p(0,l)));\n\t\twhile(!que.empty()){\n\t\t\tP now=que.top();\n\t\t\tque.pop();\n\t\t\tint nowplace=now.second.first;\n\t\t\tint nowenem=now.first;\n\t\t\tint nowmoney=now.second.second;\n\t\t\tif(d[nowplace][nowmoney]<nowenem)\n\t\t\t\tcontinue;\n\t\t\td[nowplace][nowmoney]=nowenem;\n\t\t\tif(nowplace==n-1)\n\t\t\tbreak;\n\t\t\tfor(int i=0;i<(int)tab[nowplace].size();i++){\n\t\t\t\tedge e=tab[nowplace][i];\n\t\t\t\tif(e.cost<=nowmoney){\n\t\t\t\t\tque.push(P(nowenem,p(e.to,nowmoney-e.cost)));\n\t\t\t\t}\n\t\t\t\tque.push(P(nowenem+e.enem,p(e.to,nowmoney)));\n\t\t\t}\n\t\t}\n\t\tint ans=MAX;\n\t\tfor(int i=0;i<=l;i++)\n\t\tans=min(ans,d[n-1][i]);\n\t\tcout<<ans<<endl;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <unordered_map>\n#include <limits>\n#include <map>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nstruct Edge {\n  size_t from, to, distance, attack;\n};\n\nstruct Info {\n  size_t attacks, place, money;\n\n  friend bool operator >(Info const& lhs, Info const& rhs) {\n    if (lhs.attacks != rhs.attacks) {\n      return lhs.attacks > rhs.attacks;\n    }\n    if (lhs.money != rhs.money) {\n      return lhs.money < rhs.money;\n    }\n    return lhs.place > rhs.place;\n  }\n};\n\nsize_t solve(size_t N, size_t M, size_t L) {\n  std::vector<std::vector<Edge>> adj_list(N);\n  for (size_t i = 0; i < M; i++) {\n    size_t f, t, d, e;\n    std::cin >> f >> t >> d >> e;\n    adj_list[f - 1].push_back(Edge{f - 1, t - 1, d, e});\n    adj_list[t - 1].push_back(Edge{t - 1, f - 1, d, e});\n  }\n  \n  std::priority_queue<Info, std::vector<Info>, std::greater<Info>> queue;\n  // ??°???n??????????????????????°?attack\n  std::vector<std::vector<size_t>> min_attacks(N, std::vector<size_t>(L + 1, 2 << 29));\n  min_attacks[0][L] = 0;\n  queue.push(Info{0, 0, L});\n  while (!queue.empty()) {\n    auto info = queue.top();\n    queue.pop();\n    //std::cout << \"info \" << info.attacks << \" \" << info.place << \" \" << info.money << std::endl;\n    if (min_attacks[info.place][info.money] < info.attacks) {\n      continue;\n    }\n    for (auto const& edge : adj_list[info.place]) {\n     if (edge.distance <= info.money) {\n       if (info.attacks < min_attacks[edge.to][info.money - edge.distance]) {\n         min_attacks[edge.to][info.money - edge.distance] = info.attacks;\n         queue.push(Info{info.attacks, edge.to, info.money - edge.distance});\n       }\n     }\n     if (info.attacks + edge.attack < min_attacks[edge.to][info.money]) {\n       min_attacks[edge.to][info.money] = info.attacks + edge.attack;\n       queue.push(Info{info.attacks + edge.attack, edge.to, info.money});\n     }\n    }\n  }\n  size_t min_attack = 2 << 29;\n  for (auto const& attacks : min_attacks[N - 1]) {\n    if (min_attack > attacks) {\n      min_attack = attacks;\n    }\n  }\n  return min_attack;\n}\n\nint main() {\n  size_t N, M, L;\n  while (std::cin >> N >> M >> L) {\n    if (N == 0 && M == 0 && L == 0) {\n      break;\n    }\n    std::cout << solve(N, M, L) << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n    int a, b, dist, atk;\n    P(){}\n    ~P(){}\n    P(const P& r) : a(r.a), b(r.b), dist(r.dist), atk(r.atk) {}\n    P(int a, int b, int c, int d) : a(a), b(b), dist(c), atk(d) {}\n};\n\nconst int INF = 1<<29;\n\nvector<P> G;\nint dp[100][101];\n\nvoid append_edge(int& a, int& b, int& c, int& d){\n    G.push_back(P(a, b, c, d));\n    G.push_back(P(b, a, c, d));\n}\n\nint N, M, L;\n\nint main(){\n    while(scanf(\"%d%d%d\", &N, &M, &L) && (N||M||L)){\n        int a, b, c, d;\n        G.clear();\n        for(int x = 0; x < N; x++){\n            fill(dp[x], dp[x]+L+1, INF); } for(int x = 0; x < M; x++){\n                scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n                append_edge(--a, --b, c, d);\n            }\n        dp[0][0] = 0;\n        for(int x = 0; x < N; x++){\n            for(int v = 0; v < G.size(); v++){\n                int a = G[v].a, b = G[v].b,\n                    dist = G[v].dist, atk = G[v].atk;\n                for(int w = 0; w <= L; w++){\n                    dp[a][w] = min(dp[a][w], dp[b][w]+atk);\n                    if(w >= dist) dp[a][w] = min(dp[a][w], dp[b][w-dist]);\n                }\n            }\n        }\n        int min_atk = INF;\n        for(int x = 0; x <= L; x++){\n            min_atk = min(min_atk, dp[N-1][x]);\n        }\n        printf(\"%d\\n\", min_atk);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct edge{\n    int to, dist, attack;\n};\n\nstruct P {\n    int from, money, enemy;\n\n    bool operator >(const P& p) const {\n        return enemy > p.enemy;\n    }\n};\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nint N, M, L;\n\nint main() {\n    while (cin >> N >> M >> L, N|M|L) {\n        vector<vector<edge>> E(N+1);\n        REP(i, M) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            E[from].push_back((edge){to, dist, enemy});\n            E[to].push_back((edge){from, dist, enemy});\n        }\n\n        bool G[N+1][L+1];\n        fill_n((bool *)G, (N+1)*(L+1), false);\n\n        priority_queue<P, vector<P>, greater<P>> q;\n        // start\n        q.push((P){1, L, 0});\n        int enemy = 0;\n        while (!q.empty()) {\n            P p = q.top(); q.pop();\n\n            // goal\n            if (p.from == N) {\n                enemy = p.enemy;\n                break;\n            }\n\n            if (G[p.from][p.money]) continue;\n            G[p.from][p.money] = true;\n\n            for (edge e : E[p.from]) {\n                if (p.money >= e.dist) {\n                    q.push((P){e.to, p.money - e.dist, p.enemy});\n                }\n                q.push((P){e.to, p.money, p.enemy + e.attack});\n            }\n        }\n\n        cout << enemy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n \nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n \nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push(make_pair(0, s));\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        int cost = st.first;\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push(make_paird[to], to));\n            }\n        }\n    }\n    return d;\n}\n \nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back(make_pair(e, vv(b, j)));\n                edge[vv(b, j)].push_back(make_piar(e, vv(a, j)));\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back(make_pair(0, vv(b, j - d)));\n                    edge[vv(b, j)].push_back(make_pair(0, vv(a, j - d)));\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n \n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n             \n            res = min(res,val);\n        }\n \n        cout << res << endl;\n    }\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <unordered_set>\n#include <vector>\n#include <functional>\n#include <iostream>\n\nusing namespace std;\n\ntemplate <typename S, typename P, typename GS>\nstruct Dijkstra\n{\n    struct Hash { size_t operator()(S const& s) const { return s.hash(); } };\n\n    Dijkstra(GS f) : fn(f) {}\n    GS fn;\n\n    std::unordered_set<S, Hash> solve(S init)\n    {\n        std::priority_queue<S, std::vector<S>, std::greater<S>> pq;\n        std::unordered_set<S, Hash> ss;\n\n        pq.push(init);\n        while(!pq.empty()){\n            S s = pq.top(); pq.pop();\n            auto g = ss.find(s);\n            if(g != ss.end()) { if(*g > s) continue; else ss.erase(g); }\n            ss.insert(s);\n            fn.iterP(s, [&](P const & p){ pq.push(p.apply(s)); });\n        }\n\n        // auto l = &*(ss.begin());\n        // for(auto& e: ss){\n        //     if(e > *l)\n        //         l = &e;\n        // }\n\n        // return *l;\n        return ss;\n    }\n};\n\n\n// 状態を表す型\nstruct S {\n    int n; int l; int total;\n\n    // 評価値の高さを比較\n    bool operator>(S const & e) const { return total < e.total; }\n\n    // 状態が等しいか比較\n    bool operator==(S const & e) const { return n == e.n && l == e.l; }\n\n    // ハッシュ関数\n    size_t hash() const { return n + l; }\n};\n\n// パス(枝)を表す型\nstruct P {\n    int n, d, e;\n    bool b;\n\n    // ある状態から、このパスを通った次の状態への遷移\n    S apply(S const & s) const { return {n, b ? s.l - d : s.l, b ? s.total : s.total + e}; }\n};\n\n// 全体の状態\nstruct GS\n{\n    // ある状態から通ることができるパスを列挙する\n    template <typename Fn>\n    void iterP(S & s, Fn fn)\n    {\n        if(s.n == N-1)\n            return;\n\n        for(auto& p: paths[s.n]){\n            fn(p);\n            if(p.d <= s.l) fn({p.n, p.d, p.e, true});\n        }\n    }\n\n    int N, M, L;\n    std::vector<std::vector<P>> paths;\n};\n\n\n\n\n\nint main()\n{\n    int N, M, L;\n    while(cin >> N >> M >> L, N){\n        GS gs;\n        gs.N = N; gs.M = M; gs.L = L;\n        vector<vector<P>> ps(N);\n        for(auto& e: ps) e = vector<P>();\n\n        for(int i = 0; i < M; ++i){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            ps[a-1].push_back({b-1, d, e, false});\n            ps[b-1].push_back({a-1, d, e, false});\n        }\n        gs.paths = ps;\n        Dijkstra<S, P, GS> dijkstra(gs);\n        // auto res = dijkstra.solve({0, L, 0});\n        // cout << res.n << endl;\n        // cout << res.l << endl;\n        // cout << res.total << endl;\n        unsigned int cst = -1;\n        for(auto e: dijkstra.solve({0, L, 0})){\n            // cout << e.n << endl;\n            // cout << e.l << endl;\n            // cout << e.total << endl << endl;\n            if(e.n == N-1 && e.total < cst) cst = e.total;\n        }\n\n        cout << cst << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nlong long slv(int, int);\n\nvector<vector<pair<int, int>>> s(101, vector<pair<int, int>>(101));\nvector<vector< int>> sflag(101, vector<int>(101, 0));\nint n, m, l;\n\nint main() {\n\tcin >> n >> m >> l;\n\tif (n == 0)return 0;\n\n\tfor (int i = 0; i<m; i++) {\n\t\tint a, b, d, e;\n\t\tcin >> a >> b >> d >> e;\n\t\ts[b][a] = make_pair(d, e);\n\t\tsflag[b][a] = 1;\n\t}\n\tlong long answer = 100000000000;\n\tfor (int i = 1; i <= l; ++i) {\n\t\tif (answer> slv(n, i)) answer = slv(n, i);\n\n\t}\n\tcout << answer << endl;\n\n\n\n\n}\n\nvector<vector<long long>> dp(101, vector<long long>(101, 0));\n\nvector<vector<int>> dpflag(101, vector<int>(101, 0));\n\n\n\nlong long slv(int N, int L) {\n\tdpflag[1][0] = 1;\n\n\tif (dpflag[N][L] == 1) return dp[N][L];\n\tlong long min = 1000000000000;\n\tfor (int a = 0; a <= n; ++a) {\n\t\tlong long x = 1000000000000;\n\t\tlong long y = 1000000000000;\n\t\tif (sflag[N][a] == 1) {\n\t\t\tint LL = L - s[N][a].first;\n\t\t\tif (LL >= 0) {\n\t\t\t\tx = slv(a, LL);\n\t\t\t}\n\t\t\ty = slv(a, L) + s[N][a].second;\n\n\n\t\t}\n\t\tif (min>x) min = x;\n\t\tif (min>y) min = y;\n\n\n\t}\n\tdpflag[N][L] = 1;\n\tdp[N][L] = min;\n\treturn min;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <unordered_set>\n#include <vector>\n#include <functional>\n#include <iostream>\n\nusing namespace std;\n\ntemplate <typename S, typename GS>\nstruct Dijkstra2D\n{\n    Dijkstra2D(GS f, size_t r, size_t c) : fn(f), R(r), C(c) {}\n    GS fn;\n    size_t R, C;\n\n    S solve(S init)\n    {\n        std::priority_queue<S, std::vector<S>, std::greater<S>> q;\n        std::vector<std::vector<bool>> m(R, std::vector<bool>(C, false));\n\n        q.push(init);\n        while(!q.empty()){\n            S s = q.top(); q.pop();\n            if(m[s.i][s.j]) continue;\n            if(s.isEnd()) return s;\n            m[s.i][s.j] = 1;\n            fn.iterP(s, [&](S const & t){ if(!m[t.i][t.j]) { q.push(t); } });\n        }\n\n        S s{};\n        return s;\n    }\n};\n\n\n// ??¶????????¨??????\nstruct S {\n    int i; int j; int total; int N;\n    bool operator>(S const & e) const { return total > e.total; }\n    bool isEnd() const { return i == N-1; }\n};\n\n// ??????(???)?????¨??????\nstruct P {\n    int i, d, e;\n    bool b;\n    int N;\n    S apply(S const & s) const { return {i, b ? s.j - d : s.j, b ? s.total : s.total + e, N}; }\n};\n\n// ??¨????????¶???\nstruct GS\n{\n    // ????????¶????????????????????¨?????§???????????????????????????\n    template <typename Fn>\n    void iterP(S & s, Fn fn)\n    {\n        for(auto& p: paths[s.i]){\n            fn({p.i, s.j, s.total + p.e, N});\n            if(p.d <= s.j) fn({p.i, s.j - p.d, s.total, N});\n        }\n    }\n\n    int N, M, L;\n    std::vector<std::vector<P>> paths;\n};\n\n\nint main()\n{\n    int N, M, L;\n    while(cin >> N >> M >> L, N){\n        GS gs;\n        gs.N = N; gs.M = M; gs.L = L;\n        vector<vector<P>> ps(N);\n        for(auto& e: ps) e = vector<P>();\n\n        for(int i = 0; i < M; ++i){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            ps[a-1].push_back({b-1, d, e, false});\n            ps[b-1].push_back({a-1, d, e, false});\n        }\n        gs.paths = ps;\n        Dijkstra2D<S, GS> dijkstra(gs, N, L);\n        S res = dijkstra.solve({0, L, 0, N});\n        cout << res.total << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n \nusing namespace std;\n \nint N, M, L;\n \nstruct edge {\n    int to, distance, enemy;\n};\n \nstruct P {\n    int from, money, enemy;\n \n    bool operator >(const P& p) const {\n        return enemy > p.enemy;\n    }\n};\n \nint main() {\n    while (cin >> N >> M >> L, N|M|L) {\n        vector<vector<edge> > E(N);\n        int a, b, d, e;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> d >> e;\n            E[a-1].push_back({b, d, e});\n            E[b-1].push_back({a, d, e});\n        }\n \n        priority_queue<P, vector<P>, greater<P>> q;\n        q.push((P){0, L, 0});\n            while(!q.empty()) {\n            P p = q.top(); q.pop();\n            // goal\n            if (p.from == N-1) {\n                cout << p.enemy << endl;\n                break;\n            }\n            for (int i = 0; i < E[p.from].size() ; i++) {\n                edge e = E[p.from][i];\n                q.push((P){e.to-1, p.money, p.enemy+e.enemy});\n                if (p.money-e.distance >= 0) {\n                    q.push((P){e.to-1, p.money-e.distance, p.enemy});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct edge\n {\n \tint to,cost,enemy;\n }; \n\n struct P\n {\n \tint from, money, enemy;\n \tbool operator >(const P &p) const{\n \t\treturn enemy>p.enemy;\n \t}\n };\n\nint main() {\n\tint N,M,L;\n\twhile(cin >> N >> M >> L, N|M|L){\n\t\tvector<vector<edge> > E=vector<vector<edge> >(N+1);\n\t\tREP(i, M){\n\t\t\tint from, to, cost, enemy;\n\t\t\tcin >> from >> to >> cost >> enemy;\n\t\t\tE[from].push_back((edge){to, cost, enemy});\n\t\t\tE[to].push_back((edge){from, cost, enemy});\n\t\t}\n\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tque.push((P){1, L, 0});\n\t\tint res=-1;\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.from==N){\n\t\t\t\tres=p.enemy;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, E[p.from].size()){\n\t\t\t\tedge e=E[p.from][i];\n\t\t\t\tif(p.money>=e.cost){\n\t\t\t\t\tque.push((P){e.to, p.money-e.cost,p.enemy});\n\t\t\t\t}\n\t\t\t\tque.push((P){e.to, p.money, p.enemy+e.enemy});\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\nconst int inf=1e9;\nint bprdp[110][110];//node,budget = enemy\nstruct bpredge{\n\tint to,d,e;\n};\nbool operator<(const bpredge& e1, const bpredge& e2) { return e1.e < e2.e; }\nint main(){\n\tint N,M,L;\n\twhile(cin>>N>>M>>L,N){\n\t\tREP(i,0,N) REP(j,0,L+1) bprdp[i][j]=inf;\n\t\tbprdp[0][L]=0;\n\t\tvector<bpredge> vt[110];\n\t\tREP(i,0,M){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--;b--;\n\t\t\tvt[a].push_back(bpredge{b,d,e});\n\t\t\tvt[b].push_back(bpredge{a,d,e});\n\t\t}\n\t\tpriority_queue<bpredge> pq;\n\t\tpq.push(bpredge{0,L,0});\n\n\t\twhile(!pq.empty()){\n\t\t\tbpredge now=pq.top();pq.pop();\n\t\t\tfor(auto e: vt[now.to]){\n\t\t\t\tif(now.d>=e.d){\n\t\t\t\t\tif(bprdp[e.to][now.d-e.d] > -now.e){\n\t\t\t\t\t\tbprdp[e.to][now.d-e.d]= -now.e;\n\t\t\t\t\t\tpq.push({e.to,now.d-e.d,now.e});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bprdp[e.to][now.d]> -now.e + e.e){\n\t\t\t\t\tbprdp[e.to][now.d]=-now.e + e.e;\n\t\t\t\t\tpq.push(bpredge{e.to,now.d,now.e-e.e});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\tREP(i,0,L+1){\n\t\t\tans=min(bprdp[N-1][i],ans);\n\t\t}\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint x[150][150][2],n,m,l,a,b,c,d,i,j,k,o,minx,INF=1<<25,dp[150][150];\nint DP(int p,int v){memset(dp,127,sizeof(dp));dp[0][v]=0;for(i=0;i<p;i++){for(j=0;j<n;j++){for(k=0;k<n;k++){if(x[j][k][0]<INF){\nfor(o=0;o<=v;o++){if(dp[j][o]<INF){dp[k][o]=min(dp[k][o],dp[j][o]+x[j][k][1]);if(o>=x[j][k][0]){dp[k][o-x[j][k][0]]=min(dp[k][o-x[j][k][0]],dp[j][o]);\n}}}}}}}minx=INF;for(i=0;i<=v;i++){minx=min(minx,dp[p-1][i]);}return minx;}\nmain(){while(1){memset(x,127,sizeof(x));cin>>n>>m>>l;if(!n){break;}for(i=0;i<m;i++){cin>>a>>b>>c>>d;a--;b--;x[a][b][0]=c;x[a][b][1]=d;\nx[b][a][0]=c;x[b][a][1]=d;}cout<<DP(n,l)<<endl;}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXN = 120, MAXM = 5500, MAXL = 110, MAXD = 10010, INF = 20000;\n\nint n,m,l,a,b,d,e;\nint enemy[MAXN][MAXN];\nint dist[MAXN][MAXN];\nbool used[MAXN][MAXL];\n\ntypedef pair<int,int> pp;\ntypedef pair<int,pp> ppp;\n\nint main()\n{\n    while(cin >> n >> m >> l && n)\n    {\n        memset(enemy, INF, sizeof(enemy));\n        memset(dist, MAXD, sizeof(dist));\n        memset(used, false, sizeof(used));\n        priority_queue<ppp, vector<ppp>, greater<ppp> > que;\n        que.push(ppp(0,pp(0,1)));\n\n        REP(m)\n        {\n            cin >> a >> b >> d >> e;\n            enemy[b][a] = e;\n            enemy[a][b] = e;\n            dist[b][a] = d;\n            dist[a][b] = dist[b][a];\n        }\n        int ans = 0;\n        while(1)\n        {\n            ppp q = que.top(); que.pop();\n            int nowe = q.first, cost = q.second.first, node = q.second.second;\n            if(node == n){ans = nowe; break;}\n            if(cost>l || used[node][cost])continue;\n            used[node][cost] = 1;\n            for(int i=1;i<=n;i++)if(dist[node][i] != MAXD)\n            {\n                que.push(ppp(nowe + enemy[node][i], pp(nowe, i)));\n                if(cost + dist[node][i] <= l)\n                    que.push(ppp(nowe, pp(cost + dist[node][i], i)));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint dist[110][110];\nvector<int> G[110];\nvector<int> D[110];\nvector<int> E[110];\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L && N + M + L){\n    REP(i, 110) {\n      G[i].clear();\n      D[i].clear();\n      E[i].clear();\n    }\n    \n    REP(i, M){\n      int a, b, d, e;\n      cin >> a >> b >> d >> e;\n      G[a].push_back(b);\n      D[a].push_back(d);\n      E[a].push_back(e);\n      G[b].push_back(a);\n      D[b].push_back(d);\n      E[b].push_back(e);\n    }\n    priority_queue<pair<int,P>, vector<pair<int,P> >, greater<pair<int,P> > > que;\n\n    fill(&dist[0][0], &dist[0][0] + 110 * 110, INF);\n    dist[1][L] = 0;\n      \n    que.push(MP(0, P(1, L)));\n      \n    while(!que.empty()){\n      int c = que.top().first;\n      int v = que.top().second.first;\n      int l = que.top().second.second;\n      que.pop();\n      if(v == N){\n        cout << c << endl;\n        break;\n      }\n      if(c > dist[v][l]) continue;\n        \n      REP(i, G[v].size()){\n        int to    = G[v][i];\n        int cost  = D[v][i];\n        int enemy = E[v][i];\n        if(cost <= l && c < dist[to][l-cost]){\n          dist[to][l-cost] = c;\n          que.push(MP(c, P(to, l-cost)));\n        }\n          \n        if(c + enemy < dist[to][l]){\n          dist[to][l] = c + enemy;\n          que.push(MP(c + enemy, P(to, l)));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nstruct node {\n  int n;\n  int money;\n  int tozoku;\n  //int to;\n  bool operator<(const node &t)const {\n    return (tozoku != t.tozoku) ? tozoku > t.tozoku : money > t.money;\n  }\n};\n\nstruct edge {\n  int dist;\n  int tozoku;\n};\n\nnode G[100][101];\nedge e[100][100];\nint n, m, l;\n\nint search()\n{\n  priority_queue<node> que;\n  node start;\n  start.n = 0, start.money = l, start.tozoku = 0;\n  que.push(start);\n  while (!que.empty()) {\n    node n_node = que.top();\n    //cout<< \"n, money, tozoku = \" << n_node.n << \" \" << n_node.money << \" \" << n_node.tozoku << endl;\n    que.pop();\n    if (n_node.n == n - 1) return n_node.tozoku;\n    for (int i = 0; i < n; i++) {\n      //cout << e[n_node.n][i].dist << \" \" << e[n_node.n][i].tozoku << endl;\n      if (e[n_node.n][i].dist != 100000) {\n\tif (G[i][n_node.money].tozoku > n_node.tozoku + e[n_node.n][i].tozoku) {\n\t  node t_node;\n\t  t_node.n = i, t_node.money = n_node.money, t_node.tozoku = n_node.tozoku + e[n_node.n][i].tozoku;\n\t  que.push(t_node);\n\t}\n\tif (n_node.money >= e[n_node.n][i].dist && G[i][n_node.money -  e[n_node.n][i].dist].tozoku > n_node.tozoku) {\n\t  node t_node;\n\t  t_node.n = i, t_node.money = n_node.money - e[n_node.n][i].dist, t_node.tozoku = n_node.tozoku;\n\t  que.push(t_node);\n\t}\n      }\n    }\n  }\n}\n\nint main()\n{\n  while (1) {\n    for (int i = 0; i < 100; i++) {\n      for (int j = 0; j < 101; j++) {\n\tG[i][j].n = i;\n\tG[i][j].money = j;\n\tG[i][j].tozoku = 100000;\n      }\n    }\n    for (int i = 0; i < 100; i++) {\n      for (int j = 0; j < 100; j++) {\n\te[i][j].dist = 100000;\n      }\n    }\n\n    scanf(\"%d %d %d \", &n, &m, &l);\n    if (n == 0 && m == 0 && l == 0) break;\n   \n    for (int i = 0; i < m; i++) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      x--, y--;\n      ////cout<< x << \" \" << y << endl;\n\n      scanf(\"%d %d \", &e[x][y].dist, &e[x][y].tozoku);\n      e[y][x].dist = e[x][y].dist, e[y][x].tozoku = e[x][y].tozoku;\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\t//cout<< \"edge \"<< e[i][j].dist << \" \" << e[i][j].tozoku << \" \";\n      }\n      //cout<< endl;\n    }\n    cout<< search() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\n//とりあえずsrcも持っとくとよい\nstruct NODE{\n\tint src,dst,cost,damage;\n\tNODE(int src,int dst,int cost,int damage) : src(src) , dst(dst) , cost(cost) , damage(damage) {}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.damage > b.damage; // gyaku for dijkstra\n}\nint main(){\n\tint N,M,L;\n\twhile(cin >> N >> M >> L && N){\n\t\tvector< vector<NODE> > g(N); // NODEの構造をEdgeに流用\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--,b--;\n\t\t\tg[a].push_back(NODE(a,b,c,d));\n\t\t\tg[b].push_back(NODE(b,a,c,d));\n\t\t}\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(0,-1,L,0)); // dstはQのほうでは使わない\n\t\tint done[101][101] = {};\n\t\t\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( done[q.src][q.cost]++ ) continue;\n\t\t\tif( q.src == N - 1 ){\n\t\t\t\tcout << q.damage << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < g[q.src].size() ; i++){\n\t\t\t\tint useCost = g[q.src][i].cost;\n\t\t\t\tif( useCost <= q.cost ){ //use\n\t\t\t\t\tQ.push(NODE(g[q.src][i].dst,-1,q.cost-useCost,q.damage));\n\t\t\t\t}\n\t\t\t\tQ.push(NODE(g[q.src][i].dst,-1,q.cost,q.damage+g[q.src][i].damage)); // no use\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXN = 120, MAXM = 5500, MAXL = 110, MAXD = 101, INF = 20000;\n\nint n,m,l,a,b,d,e;\nint enemy[MAXN][MAXN];\nint dist[MAXN][MAXN];\nbool used[MAXN][MAXL];\n\ntypedef pair<int,int> pp;\ntypedef pair<int,pp> ppp;\n\nint main()\n{\n    while(cin >> n >> m >> l && n)\n    {\n        memset(enemy, INF, sizeof(enemy));\n        memset(dist, MAXD, sizeof(dist));\n        memset(used, false, sizeof(used));\n        priority_queue<ppp, vector<ppp>, greater<ppp> > que;\n        que.push(ppp(0,pp(0,1)));\n\n        REP(m)\n        {\n            cin >> a >> b >> d >> e;\n            enemy[b][a] = e;\n            enemy[a][b] = e;\n            dist[a][b] = d;\n            dist[b][a] = d;\n        }\n\n        int ans = 0;\n        while(1)\n        {\n            ppp q = que.top(); que.pop();\n            int nowenemy = q.first, cost = q.second.first, node = q.second.second;\n\n            if(node == n){ans = nowenemy; break;}\n            if(used[node][cost])continue;\n            \n            used[node][cost] = 1;\n            for(int i=1;i<=n;i++)if(dist[node][i] != MAXD)\n            {\n                que.push(ppp(nowenemy + enemy[node][i], pp(nowenemy, i)));\n                if(cost + dist[node][i] <= l)\n                    que.push(ppp(nowenemy, pp(cost + dist[node][i], i)));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 101;\nconst int MAX_V = 10000;\nconst int INF = 1e+8;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to, d, e;\n\tedge(int v_, int d_, int e_){ \n\t\tto = v_; d = d_; e = e_; \n\t};\n};\n\n// g[u] := ノード u と隣接するエッジのvectorを返す\nvector<edge> g[MAX_N];\n// G[u] := ノード u と隣接するエッジのvectorを返す (解を求めるために使うグラフ)\nvector<edge> G[MAX_V];\n// p = (頂点,持っているお金)をひとつの頂点とみなし, h[p] で対応する頂点番号を返す\nmap<P,int> h;\n// N : 宿の数, id: 生成する頂点番号の管理に使う\nint N, id;\n// d[v] := 始点から頂点 v までの最短距離\nint d[MAX_V];\n// 直前の頂点\n//int prev[MAX_V];\n// 最短の頂点番号\n//int goal;\n//\n//map<int,bool> hoge;\n//\n//int cnt;\n\n// デバッグ用\nvoid debug( vector<int> path ){\n\tfor(map<P,int>::iterator it = h.begin() ; it != h.end() ; ++it ){\n\t\tcout << \"<\" << (it->first).first << \",\" << (it->first).second << \">\";\n\t\tcout << \" = \" << it->second << endl;\n\t}\n\tfor(int i=0 ; i < path.size() ; i++ ){\n\t\tcout << path[i];\n\t\tif( i != path.size()-1 )\n\t\t\tcout << \" => \";\n\t}\n\tcout << endl;\n}\n\nvoid debug_2(){\n\tcout << \"[debug]\" << endl;\n\tfor(int v=0 ; v < id ; v++ ){\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tedge ed = G[v][i];\n\t\t\tcout << \"(\" << v << \",\" << ed.to << \") = \" << ed.e << endl;\n\t\t}\n\t}\n\tcout << endl;\n}\n\n// 初期化\nvoid init(){\n\tfor(int i=0 ; i < MAX_N ; i++ ){\n\t\tg[i].clear();\n\t}\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t}\n\th.clear();\n\t//hoge.clear();\n\t//cnt = INF;\n}\n\n// 辺の追加\nvoid add_edge(int u, int v, int d, int e){\n\tedge ed( v , d , e );\n\tg[u].push_back( ed );\n\ted.to = u;\n\tg[v].push_back( ed );\n}\n\n// 辺の追加2\nvoid add_edge2(int u, int v, int cost){\n\tedge ed( v , 0 , cost );\n\tG[u].push_back( ed );\n}\n\n// <頂点番号,持っているお金>を頂点, 襲われる人数をエッジのコストとしたグラフをつくる\nvoid dfs(int v, int L, map<int,bool> memo){\n\tif( v == N-1 ) return;\n\t\n\tP from( v , L );\n\tif( !h.count( from ) ){\n\t\th[from] = id;\n\t\tid++;\n\t}\n\tint a = h[from];\n\t//if( from.first == N-1 ) hoge[a] = true;\n\t\n\tfor(int i=0 ; i < g[v].size() ; i++ ){\n\t\tedge ed = g[v][i];\n\t\tif( memo.count(ed.to) && memo[ed.to] ) continue;\n\t\tmemo[ed.to] = true;\n\t\t\n\t\tP next_1( ed.to , L );\n\t\tif( !h.count( next_1 ) ){\n\t\t\th[next_1] = id;\n\t\t\tid++;\n\t\t}\n\t\tint b = h[next_1];\n\t\t//if( next_1.first == N-1 ) hoge[b] = true;\n\t\tadd_edge2( a , b , ed.e );\n\t\tdfs( ed.to , L , memo );\n\t\t\n\t\tif( L >= ed.d ){\n\t\t\tP next_2( ed.to , L - ed.d );\n\t\t\tif( !h.count( next_2 ) ){\n\t\t\t\th[next_2] = id;\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tint c = h[next_2];\n\t\t\t//if( next_2.first == N-1 ) hoge[c] = true;\n\t\t\tadd_edge2( a , c , 0 );\n\t\t\tdfs( ed.to , L - ed.d , memo );\n\t\t}\n\t\tmemo[ed.to] = false;\n\t}\n}\n\n// ダイクストラ法\nvoid dijkstra(){\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tfill( d , d + MAX_V , INF );\n\t//fill( prev , prev + MAX_V , -1 );\n\td[0] = 0;\n\tq.push( P(0,0) );\n\twhile( !q.empty() ){\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\t/*if( hoge.count(v) ){\n\t\t\tcnt = min( cnt , p.first );\n\t\t}*/\n\t\t\n\t\tif( d[v] < p.first ) continue;\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tedge ed = G[v][i];\n\t\t\tif( d[ed.to] > d[v] + ed.e ){\n\t\t\t\td[ed.to] = d[v] + ed.e;\n\t\t\t\tq.push( P( d[ed.to] , ed.to ) );\n\t\t\t\t//prev[ed.to] = v;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 最小値を求める\nint solve(){\n\tint ans = INF;\n\tfor(map<P,int>::iterator it = h.begin() ; it != h.end() ; ++it ){\n\t\tif( (it->first).first == N-1 ){\n\t\t\tint v = h[ it->first ];\n\t\t\tans = min( ans , d[v] );\n\t\t}\n\t}\n\treturn ans;\n}\n\n// 経路復元\n/*vector<int> get_path(int t){\n\tvector<int> path;\n\tfor( ; t != -1 ; t = prev[t] )\n\t\tpath.push_back( t );\n\treverse( path.begin() , path.end() );\n\treturn path;\n}*/\n\nint main(){\n\tint M, L;\n\twhile( cin >> N >> M >> L, N || M || L ){\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < M ; i++ ){\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--; b--;\n\t\t\tadd_edge( a , b , d , e );\n\t\t}\n\t\t\n\t\t// グラフの生成\n\t\tid = 0;\n\t\tmap<int,bool> memo;\n\t\tmemo[0] = true;\n\t\tdfs( 0 , L , memo );\n\t\t// ダイクストラ法\n\t\tdijkstra();\n\t\t// 最小コストを求める\n\t\tint ans = solve();\n\t\t// デバッグ\n\t\t//vector<int> path = get_path( goal );\n\t\t//debug_2();\n\t\t//debug( path );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint cost[101][101];\nint main(){\n\tint c,N,m,i,j,k,x,y;\n\tfor(;scanf(\"%d%d%d\",&N,&m,&c),N;){\n\t\tvector<map<int,int> >dist(N+1);\n\t\tvector<map<int,int> >fee(N+1);\n\t\tmemset(cost,99,sizeof(cost));\n\t\tfor(k=0;k<m;k++){\n\t\t\tscanf(\"%d%d%d%d\",&i,&j,&x,&y);\n\t\t\tdist[i][j]=dist[j][i]=y;\n\t\t\tfee[i][j]=fee[j][i]=x;\n\t\t}\n\t\tfor(i=0;i<=c;i++)cost[1][i]=0;\n\t\tfor(;~c;c--){\n\t\t\tvector<bool>used(N+1);\n\t\t\tfor(;;){ //dijkstra\n\t\t\t\tint m=9999999;\n\t\t\t\tfor(i=1;i<=N;i++)if(!used[i]&&m>cost[i][c])m=cost[i][c];\n\t\t\t\tif(m==9999999)break;\n\t\t\t\tfor(j=1;j<=N;j++)if(m==cost[j][c]){\n\t\t\t\t\tmap<int,int>::iterator it=dist[j].begin();\n\t\t\t\t\tfor(used[j]=1;it!=dist[j].end();it++)if(!used[it->first]){\n\t\t\t\t\t\tif(cost[it->first][c]>it->second+cost[j][c])cost[it->first][c]=it->second+cost[j][c];\n\t\t\t\t\t\tif(fee[j][it->first]<=c&&cost[it->first][max(0,c-fee[j][it->first])]>cost[j][c])\n\t\t\t\t\t\t\tcost[it->first][max(0,c-fee[j][it->first])]=cost[j][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cost[N][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint N, M, L;\n\nstruct Edge {\n\tint to, dist, enemy;\n\tEdge(int _t, int _d, int _e) : to(_t), dist(_d), enemy(_e) {}\n};\nbool operator > (const Edge& e1, const Edge& e2) {\n\tif (e1.enemy < e2.enemy) return true;\n\telse if (e1.to > e2.to) return true;\n\treturn e1.dist < e2.dist;\n}\nbool operator == (const Edge& e1, const Edge& e2) {\n\tif (e1.enemy == e2.enemy && e1.to==e2.to && e1.dist == e2.dist) return true;\n\treturn false;\n}\nbool operator != (const Edge& e1, const Edge& e2) { return !(e1 == e2); }\nbool operator < (const Edge& e1, const Edge& e2) { return !(e1 > e2) && (e1 != e2); }\nbool operator >= (const Edge& e1, const Edge& e2) { return (e1 > e2) && (e1 == e2); }\nbool operator <= (const Edge& e1, const Edge& e2) { return (e1 < e2) && (e1 == e2); }\n\nconst int INF = 1e9;\nint d[110][110];\n\nint main() {\n\twhile (1) {\n\t\tcin >> N >> M >> L; if (N==0 && M==0 && L==0) break;\n\t\tvector< vector<Edge> > G(N+1, vector<Edge>());\n\t\t\n\t\tfor (int i=0; i<M; i++) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e;\n\t\t\tG[a].push_back(Edge(b, d, e));\n\t\t\tG[b].push_back(Edge(a, d, e));\n\t\t}\n\t\t\n\t\tfor (int i=0; i<=N; i++) fill(d[i], d[i] + L + 1, INF);\n\t\t\n\t\td[1][0] = 0;\n\t\t\n\t\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\t\tq.push( Edge(1, 0, 0) );\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\t\n\t\t\tfor (int i=0; i<(int)G[e.to].size(); i++) {\n\t\t\t\tEdge ne = G[e.to][i];\n\t\t\t\t\n\t\t\t\tif (e.dist + ne.dist <= L) {\n\t\t\t\t\tif (d[ne.to][e.dist + ne.dist] > e.enemy) {\n\t\t\t\t\t\td[ne.to][e.dist + ne.dist] = e.enemy;\n\t\t\t\t\t\tq.push(Edge(ne.to, e.dist + ne.dist, e.enemy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (d[ne.to][e.dist] > e.enemy + ne.enemy) {\n\t\t\t\t\td[ne.to][e.dist] = e.enemy + ne.enemy;\n\t\t\t\t\tq.push(Edge(ne.to, e.dist, e.enemy + ne.enemy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tfor (int i=0; i<=L; i++) ans = min(ans, d[N][i]);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n//(襲われた数, 宿, 所持金)\ntypedef pair<int, pii> State;\n\n#define F first\n#define S second\n\nint main(void){\n    for(int n, m, l; cin >> n >> m >> l, n;){\n        \n        //(次の宿, 長さ, 刺客の数)\n        vector<vector<pair<int, pii>>> edge(n);\n\n        rep(i, m){\n            int a, b, d, e; cin >> a >> b >> d >> e;\n            a--, b--;\n\n            edge[a].pb(mp(b, mp(d, e)));\n            edge[b].pb(mp(a, mp(d, e)));\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(mp(0, mp(0, l)));\n\n        //key: (宿, 所持金), val: (襲われた数)\n        vvi minCost(n, vi(l + 1, inf));\n\n        while(!q.empty()){\n            int cur_cost = q.top().F;\n            int cur_v = q.top().S.F;\n            int cur_money = q.top().S.S;\n            q.pop();\n\n            if(minCost[cur_v][cur_money] != inf) continue;\n            minCost[cur_v][cur_money] = cur_cost;\n\n            for(pair<int, pii> e : edge[cur_v]){\n                int next_v = e.F;\n                int d_money = e.S.F;\n                int d_cost = e.S.S;\n\n                int next_money = cur_money;\n                int next_cost = cur_cost + d_cost;\n                rep(i, 2){\n                    if(next_money < 0) break;\n\n                    q.push(mp(next_cost, mp(next_v, next_money)));\n\n                    next_money -= d_money;\n                    next_cost -= d_cost;\n                }\n            }\n        }\n\n        int res = inf;\n        for(int c : minCost[n - 1]){\n            res = min(res, c);\n        }\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v);\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream&, const tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream& os, const tuple<T...>& t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream& operator<<(ostream& os, const tuple<T...>& t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream&, tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream& is, tuple<T...>& t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream& operator>>(istream& is, tuple<T...>& t){ _it<0>(is, t); return is; }\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\n\n// グラフ用ヘッダ\n\nstruct Edge {\n    int src, dst;\n    int weight, money;\n    Edge(int src, int dst, int weight, int money) :\n        src(src), dst(dst), weight(weight), money(money) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint dp[111][111];\n\nint main(){\n    int N,M,L;\n    while(cin>>N>>M>>L && N){\n        Graph g(N);\n        rep(i,M){\n            int a,b,d,e;\n            cin>>a>>b>>d>>e; a--; b--;\n            swap(d,e);\n            g[a].eb(a,b,d,e);\n            g[b].eb(b,a,d,e);\n        }\n        rep(i,111)rep(j,111) dp[i][j] = 1<<29;\n        dp[0][L] = 0;\n        typedef tuple<int,int,int> State;\n        priority_queue<State> q;\n        q.emplace(0,0,L);\n        while(q.size()){\n            int c,v,money;\n            tie(c,v,money) = q.top(); q.pop();\n            c = -c;\n            if(dp[v][money] < c) continue;\n            for(auto & e : g[v]){\n                if(dp[v][money] + e.weight < dp[e.dst][money]){\n                    dp[e.dst][money] = dp[v][money] + e.weight;\n                    q.emplace(-dp[v][money]+e.weight, e.dst, money);\n                }\n                if(money >= e.money && dp[v][money] < dp[e.dst][money-e.money]){\n                    dp[e.dst][money-e.money] = dp[v][money];\n                    q.emplace(-dp[v][money], e.dst, money-e.money);\n                }\n            }\n        }\n        int ans = dp[N-1][0];\n        rep(i,111) ans = min(ans, dp[N-1][i]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct edge{\n    int to, dist, attack;\n};\n\nstruct P {\n    int from, money, enemy;\n\n    bool operator >(const P& p) const {\n        return enemy > p.enemy;\n    }\n};\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nint N, M, L;\n\nint main() {\n    while (cin >> N >> M >> L, N|M|L) {\n        vector<vector<edge>> E(N+1);\n        REP(i, M) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            E[from].push_back((edge){to, dist, enemy});\n            E[to].push_back((edge){from, dist, enemy});\n        }\n\n        //bool G[N+1][L+1];\n        //fill_n((bool *)G, (N+1)*(L+1), false);\n\n        priority_queue<P, vector<P>, greater<P>> q;\n        // start\n        q.push((P){1, L, 0});\n        int enemy = 0;\n        while (!q.empty()) {\n            P p = q.top(); q.pop();\n            // goal\n            if (p.from == N) {\n                enemy = p.enemy;\n                break;\n            }\n            //if (G[p.from][p.money]) continue;\n            //G[p.from][p.money] = true;\n            for (edge e : E[p.from]) {\n                if (p.money >= e.dist) {\n                    q.push((P){e.to, p.money - e.dist, p.enemy});\n                }\n                q.push((P){e.to, p.money, p.enemy + e.attack});\n            }\n        }\n\n        cout << enemy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, L;\n\nstruct State {\n    int v, sum, dist;\n    State(int v, int sum, int dist) : v(v), sum(sum), dist(dist) {}\n    bool operator<(const State& a) const {\n        return dist > a.dist;\n    }\n};\n\nstruct edge {\n    int to, money, enemy;\n    edge(int to, int money, int enemy):to(to),money(money),enemy(enemy){}\n};\n\nvector<edge> G[101];\nint d[101][101];\n\nvoid dijkstra(int s)\n{\n    for (int i = 0; i <= 100; ++i) for (int j = 0; j < N; ++j) d[i][j] = inf;\n\n    priority_queue<State> q;\n    q.push(State(s, 0, 0));\n\n    d[0][s] = 0;\n\n    while (q.size()) {\n        State st = q.top(); q.pop();\n\n        if (d[st.sum][st.v] < st.dist) continue;\n\n        for (int i = 0; i < G[st.v].size(); ++i) {\n            edge e = G[st.v][i];\n\n            if (st.sum + e.money <= L) {\n                do {\n                if (d[st.sum + e.money][e.to] <= st.dist) continue;\n                d[st.sum + e.money][e.to] = st.dist;\n                q.push(State(e.to, st.sum + e.money, d[st.sum + e.money][e.to]));\n                } while(0);\n            }\n\n            if (d[st.sum][e.to] > st.dist + e.enemy) {\n                d[st.sum][e.to] = st.dist + e.enemy;\n                q.push(State(e.to, st.sum, d[st.sum][e.to]));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    while (scanf(\"%d%d%d\", &N, &M, &L), N) {\n        for (int i = 0; i < N; ++i) G[i].clear();\n\n        for (int i = 0; i < M; ++i) {\n            int A, B, D, E;\n            scanf(\"%d%d%d%d\", &A, &B, &D, &E);\n            A--, B--;\n            G[A].push_back(edge(B, D, E));\n            G[B].push_back(edge(A, D, E));\n        }\n\n        dijkstra(0);\n\n        int mi = inf;\n\n        for (int i = 0; i <= 100; ++i) {\n            chmin(mi, d[i][N - 1]);\n        }\n\n        printf(\"%d\\n\", mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 102;\n\nstruct edge{\n\tint to;\n\tint cost;\n    int damage;\n};\n\nstruct state{\n    int pos;\n    int damage;\n    int rem;\n    bool operator<(const state& another) const {\n\t\treturn damage > another.damage;\n\t}\n};\n\nint a[MAX_N],d[MAX_N][MAX_N];\nvector<edge> G[MAX_N];\nint n,m,L;\n\nvoid dijkstra(int s)\n{\n\tpriority_queue<state> que;\n\td[s][L] = 0;\n\tque.push((state){s,0,L});\n\twhile(!que.empty()){\n\t\tstate S = que.top();\n\t\tque.pop();\n\t\tint v = S.pos;\n        int c  = S.rem;\n\t\tif(d[v][c] < S.damage) continue;\n\t\tvector<edge>::iterator it = G[v].begin();\n\t\trep(i,G[v].size()){\n            if(c - G[v][i].cost >= 0){\n                if(d[G[v][i].to][c - G[v][i].cost] > d[v][c]){\n    \t\t\t\td[G[v][i].to][c - G[v][i].cost] = d[v][c];\n    \t\t\t\tque.push((state){G[v][i].to,d[G[v][i].to][c - G[v][i].cost],c - G[v][i].cost});\n    \t\t\t}\n            }\n            if(d[G[v][i].to][c] > d[v][c] + G[v][i].damage){\n                d[G[v][i].to][c] = d[v][c] + G[v][i].damage;\n                que.push((state){G[v][i].to,d[G[v][i].to][c],c});\n            }\n\t\t}\n\t}\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d%d%d\",&n,&m,&L);\n        if(n == 0 && m == 0 && L == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear();\n        }\n        rep(i,m){\n            int w,x,y,z;\n            scanf(\"%d%d%d%d\",&w,&x,&y,&z);\n            G[w-1].push_back((edge){x-1,y,z});\n            G[x-1].push_back((edge){w-1,y,z});\n        }\n        rep(i,n){\n            fill(d[i],d[i]+L+1,INF);\n        }\n        dijkstra(0);\n        int res = INF;\n        rep(i,L+1){\n            res = min(res,d[n-1][i]);\n        }\n        printf(\"%d\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\n#include <functional>\n#include<vector>\n#include<math.h>\n#include<bitset>\n#include<string>\n#include <deque>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include <random>\n#include<type_traits>\n#include<stack>\n#include <sstream> \n#include <limits>\n#include <numeric>\n#include<string.h>\nusing namespace std;\n#define ll long long int\n#define all(v) begin(v), end(v)\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n//typedef vector<int> V;\n//typedef vector<VV> VVV;\n\ntemplate<typename T>\nvoid remove(std::vector<T>& vector, unsigned int index)\n{\n\tvector.erase(vector.begin() + index);\n}\n\nstruct edge { int to, cost,theef; };\ntypedef pair<int, int > P;\nstruct pp { int point, now, money;};\n\n//V頂点数\nint V;\nvector<edge>G[100000];//max頂点数\nint d[105][105];//n,予算\n\nvoid dijktra(int s,int l) {\n\tqueue<pp> que;\n\tfor (int i = 0; i <V+3; i++) {\n\t\tfill(d[i], d[i] + l + 3, 100000000);\n\t}\n\n\td[s][l] = 0;\n\tpp ppp = { 0, s, l };\n\tque.push(ppp);\n\n\twhile (!que.empty()) {\n\t\tpp p = que.front(); que.pop();\n\t\tint v = p.now;\n\t\tif (d[v][p.money] < p.point)continue;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to][p.money] > d[v][p.money] + e.theef) {\n\t\t\t\td[e.to][p.money] = d[v][p.money] + e.theef;\n\t\t\t\tppp = { d[e.to][p.money], e.to,p.money };\n\t\t\t\tque.push(ppp);\n\t\t\t}\n\t\t\tif ((p.money - e.cost) < 0)continue;\n\t\t\tif (d[e.to][p.money - e.cost] > d[v][p.money]) {\n\t\t\t\td[e.to][p.money - e.cost] = d[v][p.money];\n\t\t\t\tppp = { d[e.to][p.money - e.cost], e.to,p.money-e.cost };\n\t\t\t\tque.push(ppp);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main() {\n\tint n, m, l, a, b, d2, e;\n\tcin >> n >> m >> l;\n\twhile (n != 0) {\n\t\tV = n;//頂点数\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> d2 >> e;\n\t\t\tedge e1 = { b,d2 ,e };\n\t\t\tedge e2 = { a,d2,e };\n\t\t\tG[a].push_back(e1);//aからbへコストcの辺\n\t\t\tG[b].push_back(e2);\n\t\t}\n\t\tint min = 1000000;\n\t\tdijktra(1, l);//頂点aからの最短距離配列生成\n\t\tfor (int i = 0; i <= l; i++) {\n\t\t\tif (min > d[V][i])min = d[V][i];\n\t\t}\n\t\tcout << min << endl;\n\t\tcin >> n >> m >> l;\n\t\tfor (int i = 1; i <= V; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\n\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint n, m;\nint ind(int v, int l) { return v + l*n; }\n\nvoid dijkstra(Graph &g, vector<weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tweight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint l;\n\twhile (cin >> n >> m >> l, n)\n\t{\n\t\tGraph g(n*(l + 1));\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--; b--;\n\t\t\tREP(j, l + 1)\n\t\t\t{\n\t\t\t\tg[ind(a, j)].push_back(edge{ ind(b, j), d });\n\t\t\t\tg[ind(b, j)].push_back(edge{ ind(a, j), d });\n\t\t\t}\n\t\t\tFOR(j, c, l + 1)\n\t\t\t{\n\t\t\t\tint from = ind(a, j);\n\t\t\t\tint to = ind(b, j - c);\n\t\t\t\tg[from].push_back(edge{ to, 0 });\n\t\t\t\tg[to].push_back(edge{ from, 0 });\n\t\t\t}\n\t\t}\n\t\tvector<weight> d;\n\t\tdijkstra(g, d, ind(0, l));\n\t\tint ans = INF;\n\t\tREP(i, l + 1) chmin(ans, d[ind(n - 1, i)]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\nbool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy < b.enemy;\n}\n\nbool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\t\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\nbool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\nvoid add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\nvoid insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min;\n\t\tmin = b;\n\t\titr++;\n\n\t\t//while( itr != points[i].end() ) {\n\t\t\t\t\t\t\t\t\t\n\t\t\tif ((*itr).second>min) {\n\t\t\t\t(*itr).second = min;\n\t\t\t} else if ( (*itr).second<min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t}\n\t\t\titr++;\n\t\t\t//}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tchar tab = '\\t';\n\t\t//cout << \"Prob: \" << n << tab << m << tab << l << endl;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\twhile( !status.empty() ) {\n\t\t\tstatus.pop() ;\n\t\t}\t\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tint min;\n\t\t\t\t\t\tmap<int,int>::iterator itr;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\titr = points[i].find(e);\n\t\t\t\t\t\t\tif ( itr == points[i].end() ) {\n\t\t\t\t\t\t\t\tpoints[i][e] = b;\n\t\t\t\t\t\t\t\tstatus.push(State(i,e,b));\n\t\t\t\t\t\t\t} else if ( (*itr).second < b ) {\n\t\t\t\t\t\t\t\t(*itr).second = b;\n\t\t\t\t\t\t\t\tstatus.push(State(i,e,b));\n\t\t\t\t\t\t\t\tmin = b;\n\t\t\t\t\t\t\t\twhile( itr != points[i].end() ) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif ((*itr).second>min) {\n\t\t\t\t\t\t\t\t\t\t(*itr).second = min;\n\t\t\t\t\t\t\t\t\t} else if ( (*itr).second<min ) {\n\t\t\t\t\t\t\t\t\t\tmin = (*itr).second;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\titr++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tif ( points[i].find(e) == points[i].end() ) {\n\t\t\t\t\t\t\t\t\tpoints[i][e] = b;\n\t\t\t\t\t\t\t\t\tstatus.push(State(i,e, b));\n\t\t\t\t\t\t\t\t} else if ( points[i][e] < b ) {\n\t\t\t\t\t\t\t\t\tpoints[i][e] = b;\n\t\t\t\t\t\t\t\t\tstatus.push(State(i,e,b));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tif ( points[i].find(e) == points[i].end() ) {\n\t\t\t\t\t\t\t\tpoints[i][e] = b;\n\t\t\t\t\t\t\t\tstatus.push(State(i,e,b));\n\t\t\t\t\t\t\t} else if ( points[i][e] < b ) {\n\t\t\t\t\t\t\t\tpoints[i][e] = b;\n\t\t\t\t\t\t\t\tstatus.push(State(i,e,b));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<array>\n\n#define fin cin\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nclass Input{\npublic:\n\tint a;\n\tint b;\n\tint d;\n\tint e;\n\tInput(int _a, int _b, int _d, int _e){\n\t\ta = _a;\n\t\tb = _b;\n\t\td = _d;\n\t\te = _e;\n\t}\n\toperator < (Input& other){\n\t\treturn (this->a < other.a);\n\t}\n\toperator > (Input& other){\n\t\treturn (this->a > other.a);\n\t}\n\n};\n\nconst int initnum = 10000000;\n\nstd::vector<Input> in_v{};\nstd::array<std::array<int, 100>, 100> cost;\n\nint main()\n{\n\t//std::ifstream fin(\"in.txt\");\n\t//cost[0].fill(0);\n\t//for(int i = 1; i < 100; i++)cost[i].fill(10000000);\n\n\twhile(true)\n\t{\n\t\tcost[0].fill(0);\n\t\t//cost[1].fill(0);\n\t\tfor(int i = 1; i < 100; i++)cost[i].fill(initnum);\n\t\n\t\tint n, m, l;\n\t\tfin >> n >> m >> l;\n\t\tif((n | m | l) == 0)break;\n\t\t//cout << n << \" \" << m << \" \" << l << endl;\n\t\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b, d, e;\n\t\t\tfin >> a >> b >> d >> e;\n\t\t\tin_v.push_back(Input(a-1, b-1, d, e));\n\t\t\tin_v.push_back(Input(b-1, a-1, d, e));\n\t\t}\n\t\tsort(in_v.begin(), in_v.end());\n\n\t\tstd::queue<Input> in_q;\n\t\tfor(auto in : in_v)in_q.push(in);\n\n\t\tin_v.clear();\n\t\tin_v.shrink_to_fit();\n\n\t\twhile(!in_q.empty())\n\t\t{\n\t\t\tInput tmp = in_q.front();\n\t\t\tin_q.pop();\n\n\t\t\tfor(int _cost = 0; _cost <= l; _cost++)\n\t\t\t{\n\n\t\t\t\tif(cost[tmp.a][_cost] == initnum)\n\t\t\t\t{\n\t\t\t\t\tin_q.push(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcost[tmp.b][_cost] = std::min(\n\t\t\t\t\tcost[tmp.b][_cost],\n\t\t\t\t\tstd::min(\n\t\t\t\t\t\t(_cost + tmp.d <= l ? (cost[tmp.a][_cost + tmp.d]) : initnum / 10),\n\t\t\t\t\t\tcost[tmp.a][_cost] + tmp.e\n\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\t\t\tfor(int i = 0; i <= l + 2; i++){\n\t\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\n\t\t}\n\t\tint min_cost = 10000000;\n\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tif(cost[n - 1][i] < min_cost)min_cost = cost[n - 1][i];\n\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t}\n\t\tcout << min_cost << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\nusing ll = long long;\nstruct edge {\n    int to, d, e;\n};\nvector<edge> G[101];\nint dp[101][101];\nint N, M, L;\nvoid init() {\n    REP(i, N + 1) {\n        G[i].clear();\n        REP(j, L + 1) { dp[i][j] = 1e9; }\n    }\n    dp[0][L] = 0;\n}\n\nusing arr3 = array<int, 3>;\nbool solve() {\n    cin >> N >> M >> L;\n    if (N == 0) return false;\n    init();\n\n    REP(i, M) {\n        int u, v, d, e;\n        cin >> u >> v >> d >> e;\n        u--, v--;\n        G[u].push_back({v, d, e});\n        G[v].push_back({u, d, e});\n    }\n\n    priority_queue<arr3, vector<arr3>, greater<arr3>> que;\n    que.push({0, 0, L});\n    while (!que.empty()) {\n        arr3 arr = que.top();\n        que.pop();\n        int res = arr[0], n = arr[1], rem = arr[2];\n        if (res > dp[n][rem]) continue;\n        for (auto e : G[n]) {\n            //護衛を雇う\n            if (rem >= e.d) {\n                if (dp[n][rem] < dp[e.to][rem - e.d]) {\n                    dp[e.to][rem - e.d] = dp[n][rem];\n                    que.push({dp[e.to][rem - e.d], e.to, rem - e.d});\n                }\n            }\n            //雇わない\n            if (dp[n][rem] + e.e < dp[e.to][rem]) {\n                dp[e.to][rem] = dp[n][rem] + e.e;\n                que.push({dp[e.to][rem], e.to, rem});\n            }\n        }\n    }\n    int ans = 1e9;\n    REP(i, L + 1) {\n        // cout << i << \": \" << dp[N - 1][i] << endl;\n        ans = min(ans, dp[N - 1][i]);\n    }\n    cout << ans << endl;\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\nbool operator< ( const State& a, const State& b) {\n\treturn a.enemy < b.enemy;\n}\n\nbool operator> ( const State& a, const State& b) {\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n \nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint n,m,l;\nvector<vector<PP> > edge;\n\n\nint solve()\n{\n\t\n\t//??????i??§?????????j????????????????????°\n\tvector<vector<long> > memo(n,vector<long>(l+1,1000000));\n\t\n\tfor(int i=0;i<=l;i++) memo[0][i]=0;\n\t\n\tpriority_queue<PP,vector<PP>,greater<PP> > q;\n\t\n\t//?????¨??°0,??????0,?????????l\n\tq.push(PP(0,P(0,l)));\n\t\n\twhile(!q.empty()){\n\t\tPP tmp=q.top(); q.pop();\n\t\t\n\t\tint now_v=tmp.first;\n\t\tint now_e=tmp.second.first;\n\t\tint now_l=tmp.second.second;\n\t\t\t\t\t\t\t\t\n\t\tfor(int i=0;i<edge[now_v].size();i++){\n\t\t\tint to=edge[now_v][i].first;\n\t\t\tint e_num=edge[now_v][i].second.second;\n\t\t\tint cost=edge[now_v][i].second.first;\n\n\t\t\t//???????????????\n\t\t\tif(now_l>=cost){\n\t\t\t\tif(memo[to][now_l-cost]>memo[now_v][now_l]){\n\t\t\t\t\tmemo[to][now_l-cost]=memo[now_v][now_l];\n\t\t\t\t\tq.push(PP(to,P(now_e,now_l-cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//?????????????????????\n\t\t\tif(memo[to][now_l]>memo[now_v][now_l]+e_num){\n\t\t\t\tmemo[to][now_l]=memo[now_v][now_l]+e_num;\n\t\t\t\tq.push(PP(to,P(now_e+e_num,now_l)));\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tlong ans=memo[n-1][0];\n\tfor(int i=1;i<=l;i++) ans=min(ans,memo[n-1][i]);\n\t\n\treturn ans;\n\t\n}\n\nint main()\n{\n\t\n\twhile(cin>>n>>m>>l,n){\t\t\n\t\t\t\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--; b--;\n\t\t\t\n\t\t\tedge[a].push_back(PP(b,P(d,e)));\n\t\t\tedge[b].push_back(PP(a,P(d,e)));\n\t\t\t\n\t\t}\n\t\tcout<<solve()<<endl;\n\t\t\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nclass State {\npublic:\n\tint budget;\n\tint people;\n\tint wheres;\n\tState() {};\n\tState( int b, int p, int n ) { budget = b; people = p; wheres = n; };\n};\n\npriority_queue<State, vector<State>, greater<State>> status;\n//priority_queue<State> status;\n\nint map[101][101];\nint off[101][101];\n\nbool operator< (const State& a, const State& b)\n{\n\tif ( a.people == b.people )\n\t\treturn a.budget < b.budget;\n\treturn a.people < b.people;\n}\n\nbool operator> (const State& a, const State& b)\n{\n\tif ( a.people == b.people )\n\t\treturn a.budget > b.budget;\n\treturn a.people > b.people;\t\n}\n\nint main () {\n\n\twhile ( true ) {\n\t\tint  N,M,L;\n\n\t\tcin >> N >> M >> L;\n\n\t\tif ( N == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<=N; i++ ) {\n\t\t\tfor ( int j=0; j<=N; j++ ) {\n\t\t\t\tmap[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint a, b, d, e;\n\n\t\tfor ( int i=0; i<M; i++ ) {\n\t\t\tcin >> a >> b >> d>> e;\n\n\t\t\tmap[a][b] = d;\n\t\t\toff[a][b] = e;\n\t\t\tmap[b][a] = d;\n\t\t\toff[b][a] = e;\n\t\t}\n\n\n\t\tstatus.push(State(L, 0, 1));\n\t\tint ans;\n\t\tans = 1000000000;\n\t\tbool have = false;\n\t\twhile( !status.empty() ) {\n\t\t\tState now;\n\t\t\tnow = status.top();\n\t\t\tstatus.pop();\n\t\t\t\n\t\t\tif ( now.people >= ans ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << now.budget<< \"\\t\";\n\t\t\tcout << now.people<< \"\\t\";\n\t\t\tcout << now.wheres<< endl;\n\t\t\t*/\n\t\t\tif ( now.wheres == N ) {\n\t\t\t\tif ( ans > now.people) {\n\t\t\t\t\thave = true;\n\t\t\t\t\tans = now.people;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor ( int i=1; i<=N; i++ ) {\n\t\t\t\t\tif ( i != now.wheres ) {\n\t\t\t\t\t\tif ( map[now.wheres][i] > 0 ) {\n\t\t\t\t\t\t\tif ( off[now.wheres][i] != 0 ) {\n\t\t\t\t\t\t\t\tif ( now.budget - map[now.wheres][i] >= 0 ) {\n\t\t\t\t\t\t\t\t\tstatus.push(State(now.budget-map[now.wheres][i],now.people,i));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstatus.push(State(now.budget,now.people+off[now.wheres][i],i));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstatus.push(State(now.budget,now.people,i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( ans == -1 )\n\t\t\tcout << \"No\" << endl;\n\t\telse\n\t\t\tcout << \"Ans: \" <<ans << endl;\n\t}\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint cost[101][101];\nint main(){\n\tint c,N,m,i,j,k,x,y;\n\tfor(;scanf(\"%d%d%d\",&N,&m,&c),N;){\n\t\tvector<map<int,int> >dist(N+1);\n\t\tvector<map<int,int> >fee(N+1);\n\t\tmemset(cost,99,sizeof(cost));\n\t\tfor(k=0;k<m;k++){\n\t\t\tscanf(\"%d%d%d%d\",&i,&j,&x,&y);\n\t\t\tdist[i][j]=dist[j][i]=y;\n\t\t\tfee[i][j]=fee[j][i]=x;\n\t\t}\n\t\tfor(i=0;i<=c;i++)cost[1][i]=0;\n\t\tfor(;~c;c--){\n\t\t\tvector<bool>used(N+1);\n\t\t\tfor(;;){ //dijkstra\n\t\t\t\tint m=9999999;\n\t\t\t\tfor(i=1;i<=N;i++)if(!used[i]&&m>cost[i][c])m=cost[i][c];\n\t\t\t\tif(m==9999999)break;\n\t\t\t\tfor(j=1;j<=N;j++)if(m==cost[j][c]){\n\t\t\t\t\tmap<int,int>::iterator it=dist[j].begin();\n\t\t\t\t\tfor(used[j]=1;it!=dist[j].end();it++){\n\t\t\t\t\t\tif(cost[it->first][c]>it->second+cost[j][c])cost[it->first][c]=it->second+cost[j][c];\n\t\t\t\t\t\tif(fee[j][it->first]<=c&&cost[it->first][max(0,c-fee[j][it->first])]>cost[j][c])\n\t\t\t\t\t\t\tcost[it->first][max(0,c-fee[j][it->first])]=cost[j][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cost[N][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nconst int INF = 1<<30;\nint adj[100][100];\nint traitor[100][100];\nint visited[100];\nint dist[100];\n\nstruct State{\n  int dang,pos,money;\n  State(int dang,int pos,int money) : dang(dang), pos(pos), money(money) {;}\n};\n\nbool operator<(const State &r,const State &l) {\n  return r.dang > l.dang;\n}\n\nint main() {\n  int N,M,L;\n  int A,B,D,E;\n  while(cin>>N>>M>>L, N|M|L) {\n    for(int i=0; i<100; ++i) {\n      for(int j=0; j<100; ++j) adj[i][j] = INF,traitor[i][j] = 0;\n      adj[i][i] = 0;\n      visited[i] = 0;\n      dist[i] = INF;\n    }\n\n    for(int i=0; i<M; ++i) {\n      cin>>A>>B>>D>>E;\n      A--,B--;\n      adj[A][B] = adj[B][A] = D;\n      traitor[A][B] = traitor[B][A] = E;\n    }\n\n    priority_queue<State> Q;\n    Q.push(State(0,0,0));\n    visited[0] = 1;\n    dist[0] = 0;\n    while(!Q.empty()) {\n      State now = Q.top(); Q.pop();\n      if(now.pos == N-1) {\n\tcout<<now.dang<<endl;\n\tbreak;\n      }\n      visited[now.pos] = 1;\n\n      //cout<<now.pos<<\" \"<<now.dang<<endl;\n      for(int i=0; i<N; ++i) {\n\tif(visited[i]) continue;\n\tif(adj[now.pos][i] < INF) {\n\t  if(L-now.money >= adj[now.pos][i])\n\t    Q.push(State(now.dang, i, now.money+adj[now.pos][i]));\n\t  Q.push(State(now.dang+traitor[now.pos][i], i, now.money));\n\t}\n      }\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nconst int INF = 1<<30;\nint adj[100][100];\nint traitor[100][100];\nint visited[100];\nint dist[100];\n\nstruct State{\n  int dang,pos,money;\n  State(int dang,int pos,int money) : dang(dang), pos(pos), money(money) {;}\n};\n\nbool operator<(const State &r,const State &l) {\n  return r.dang > l.dang;\n}\n\nint main() {\n  int N,M,L;\n  int A,B,D,E;\n  while(cin>>N>>M>>L, N|M|L) {\n    for(int i=0; i<100; ++i) {\n      for(int j=0; j<100; ++j) adj[i][j] = INF,traitor[i][j] = 0;\n      adj[i][i] = 0;\n      visited[i] = 0;\n      dist[i] = INF;\n    }\n\n    for(int i=0; i<M; ++i) {\n      cin>>A>>B>>D>>E;\n      A--,B--;\n      adj[A][B] = adj[B][A] = D;\n      traitor[A][B] = traitor[B][A] = E;\n    }\n\n    priority_queue<State> Q;\n    Q.push(State(0,0,0));\n    visited[0] = 1;\n    dist[0] = 0;\n    while(!Q.empty()) {\n      State now = Q.top(); Q.pop();\n      dist[now.pos] = min(dist[now.pos], now.dang);\n\n      visited[now.pos] = 1;\n      for(int i=0; i<N; ++i) {\n\tif(visited[i]) continue;\n\tif(adj[now.pos][i] < INF) {\n\t  if(L-now.money >= adj[now.pos][i])\n\t    Q.push(State(now.dang, i, now.money+adj[now.pos][i]));\n\t  Q.push(State(now.dang+traitor[now.pos][i], i, now.money));\n\t}\n      }\n    }\n    cout<<dist[N-1]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\nbool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy < b.enemy;\n}\n\nbool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\t\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\n\t\t/*\n\t\twhile( !status.empty() ) {\n\t\t\tstatus.pop() ;\n\t\t}\t\n\t\t*/\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint N, M, L;\n\nstruct Edge {\n\tint to, cost, enemy;\n\tEdge(int _t, int _c, int _e) : to(_t), cost(_c), enemy(_e) {}\n};\nbool operator > (const Edge& e1, const Edge& e2) {\n\tif (e1.enemy < e2.enemy) return true;\n\telse if (e1.to > e2.to) return true;\n\treturn e1.cost < e2.cost;\n}\nbool operator == (const Edge& e1, const Edge& e2) {\n\tif (e1.enemy == e2.enemy && e1.to==e2.to && e1.cost == e2.cost) return true;\n\treturn false;\n}\nbool operator != (const Edge& e1, const Edge& e2) { return !(e1 == e2); }\nbool operator < (const Edge& e1, const Edge& e2) { return !(e1 > e2) && (e1 != e2); }\nbool operator >= (const Edge& e1, const Edge& e2) { return (e1 > e2) && (e1 == e2); }\nbool operator <= (const Edge& e1, const Edge& e2) { return (e1 < e2) && (e1 == e2); }\n\nconst int INF = 1e9;\nint d[110][110];\n\nint main() {\n\twhile (1) {\n\t\tcin >> N >> M >> L; if (N==0 && M==0 && L==0) break;\n\t\tvector< vector<Edge> > G(N+1, vector<Edge>());\n\t\t\n\t\tfor (int i=0; i<M; i++) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e;\n\t\t\tG[a].push_back(Edge(b, d, e));\n\t\t\tG[b].push_back(Edge(a, d, e));\n\t\t}\n\t\t\n\t\tfor (int i=0; i<=N; i++) fill(d[i], d[i] + L + 1, INF);\n\t\t\n\t\td[1][0] = 0;\n\t\t\n\t\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\t\tq.push( Edge(1, 0, 0) );\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\t\n\t\t\tfor (int i=0; i<(int)G[e.to].size(); i++) {\n\t\t\t\tEdge ne = G[e.to][i];\n\t\t\t\t\n\t\t\t\tif (e.cost + ne.cost <= L) {\n\t\t\t\t\tif (d[ne.to][e.cost + ne.cost] > e.enemy) {\n\t\t\t\t\t\td[ne.to][e.cost + ne.cost] = e.enemy;\n\t\t\t\t\t\tq.push(Edge(ne.to, e.cost + ne.cost, e.enemy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (d[ne.to][e.cost] > e.enemy + ne.enemy) {\n\t\t\t\t\td[ne.to][e.cost] = e.enemy + ne.enemy;\n\t\t\t\t\tq.push(Edge(ne.to, e.cost, e.enemy + ne.enemy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tfor (int i=0; i<=L; i++) ans = min(ans, d[N][i]);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n) - 1; i >= k; i--)\n\n#define debug(x) cerr <<#x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pi pair<int,int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n#define tup tuple<long long,int,int>\n#define mt make_tuple\n\ntypedef long long ll;\nconst ll inf = 900900900100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int MID = 255;\nusing namespace std;\n#define MAX_N 110\n\nint dp[110][100100] = {};\nint main(){\n    int n,m,l;\n    while(cin >> n >> m >> l,n) {\n        rep(i,110) rep(j,100100) dp[i][j] = 0;\n        vector<tup> E[MAX_N];\n        rep(i,m){\n            int a,b,d;\n            long long e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            E[a].pb(mt(e,b,d));\n            E[b].pb(mt(e,a,d));\n        }\n        priority_queue<tup,vector<tup>,greater<tup> > que;\n\n        ll d[MAX_N][110];\n        rep(i,MAX_N) rep(j,110) d[i][j] = inf;\n\n        rep(i,110) d[0][i] = 0;\n        que.push(mt(0,0,l));\n        while(!que.empty()) {\n            tup p = que.top();\n            que.pop();\n            ll cost = get<0>(p);\n            int v = get<1>(p);\n            int money = get<2>(p);\n            if (d[v][money] < cost) continue;\n            rep(i, E[v].size()) {\n                tup e = E[v][i];\n                //普通に動く\n                if (d[get<1>(e)][money] > d[v][money] + get<0>(e)) {\n                    d[get<1>(e)][money] = d[v][money] + get<0>(e);\n                    que.push(mt(d[get<1>(e)][money], get<1>(e),money));\n                }\n                //お金をはらう\n                if(get<2>(e) <= money) {\n                    if (d[get<1>(e)][money - get<2>(e)] > d[v][money]) {\n                        d[get<1>(e)][money - get<2>(e)] = d[v][money];\n                        que.push(mt(d[get<1>(e)][money - get<2>(e)], get<1>(e),money - get<2>(e)));\n                    }\n                }\n            }\n        }\n        ll ma = inf;\n        rep(i,l + 1){\n            ma = min(ma,d[n - 1][i]);\n        }\n        cout << ma << endl;\n        // cout << \"d[n-1] : \" << d[n - 1] << endl;\n        // int tt = n - 1;\n        // vector<int> WW;\n        // vector<int> VV;\n        // while(true) {\n        //     for(auto e : E[tt]) {\n        //         if(get<1>(e) == bv[tt]) {\n        //             WW.pb(get<2>(e));\n        //             VV.pb(get<0>(e));\n        //             break;\n        //         }\n        //     }\n        //     if(tt == 0) break;\n        //     tt = bv[tt];\n        // }\n\n\n        // REP(i, 1, l + 1) {\n        //     REP(j, 1, WW.size() + 1) {\n        //         dp[i][j] = dp[i][j - 1];\n        //         if( >= WW[j - 1]) {\n        //             dp[i][j] = max(dp[i][j - 1], dp[i - WW[j - 1]][j - 1] + VV[j - 1]);\n        //         }\n        //     }\n        // }\n        // cout << d[n - 1] - dp[l][WW.size()] << endl;\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n// int n_dir = 4;\n// int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; [> CSS order <]\n// enum direction {\n\t// UP, RIGHT, DOWN, LEFT\n// };\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// };\n// #define FORDIR(d) REP (d, n_dir)\n\ntypedef complex<int> P;\n#define Y real()\n#define X imag()\nP dyx[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\n// P dyx[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\n\nint g_height, g_width;\nbool in_field(P p) {\n\treturn (0 <= p.Y && p.Y < g_height) && (0 <= p.X && p.X < g_width);\n}\n\n/*}}}*/\n\n// My version of (Extended) Dijkstra\n// Pros: easy to access `costs` -- just `costs(node)`\n//       vector with many parameters is confusing e.g. `costs[param1][param2][param3]...`\n\n// Node should have only parameters with which Node can be distinguished\nclass Node {\npublic:\n\t// Parameters to distinguish Nodes\n\tint id;\n\tint budget;\n\n\tNode(int _id, int _budget): id(_id), budget(_budget) {\n\t}\n};\n\n// for priority_queue\ntypedef pair<int, Node> Qtype; // cost and Node\nclass Comp {\npublic:\n\tbool operator() (const Qtype& l, const Qtype& r) const {\n\t\t// compair costs for each Node\n\t\treturn (l.F > r.F);\n\t}\n};\n\n// easy access to saved costs\n#define MAX_N 100\n#define MAX_L 100\nVVI g_saved_costs(MAX_N, VI(MAX_L));\nvoid init_saved_costs()\n{\n\tREP (i, MAX_N) {\n\t\tREP (j, MAX_L) {\n\t\t\tg_saved_costs[i][j] = INF;\n\t\t}\n\t}\n}\n// VVI g_saved_costs;\nint saved_cost(Node n)\n{\n\treturn g_saved_costs[n.id][n.budget];\n}\nvoid save_cost(Node n, int cost)\n{\n\tg_saved_costs[n.id][n.budget] = cost;\n}\n\nint main()\n{\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N) {\n\t\tVVI dist(N, VI(N, INF));\n\t\tVVI gang(N, VI(N, INF));\n\t\tREP (_, M) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e; --a, --b;\n\t\t\tdist[a][b] = dist[b][a] = d;\n\t\t\tgang[a][b] = gang[b][a] = e;\n\t\t}\n\n\t\t// Initialize g_saved_costs\n\t\tinit_saved_costs();\n\t\t// g_saved_costs = VVI(N, VI(L+1, INF));\n\t\tpriority_queue< Qtype, vector<Qtype>, Comp > q;\n\n\t\tq.push( MP(0, Node(0, L)) );\n\t\twhile (!q.empty()) {\n\t\t\tQtype t = q.top(); q.pop();\n\t\t\tint cost_here = t.F; Node node = t.S;\n\n\t\t\t// Skip if already visited\n\t\t\tif (cost_here > saved_cost(node)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsave_cost(node, cost_here);\n\n\t\t\tREP (i, N) {\n\t\t\t\tif (dist[node.id][i] != INF) {\n\t\t\t\t\t// without guard\n\t\t\t\t\tq.push(MP(cost_here + gang[node.id][i], Node(i, node.budget)));\n\t\t\t\t\tif (dist[node.id][i] <= node.budget) {\n\t\t\t\t\t\t// with guard\n\t\t\t\t\t\tbool vain = false;\n\t\t\t\t\t\tfor (int b = node.budget; b >= node.budget - dist[node.id][i]; --b) {\n\t\t\t\t\t\t\tif (saved_cost(Node(i, b)) <= cost_here) {\n\t\t\t\t\t\t\t\tvain = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tIFC(vain);\n\t\t\t\t\t\tq.push(MP(cost_here, Node(i, node.budget - dist[node.id][i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tREP (i, L+1) {\n\t\t\tans = min(ans, saved_cost(Node(N-1, i)));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n \nusing namespace std;\n \nint N, M, L;\n \nstruct edge {\n    int to, distance, enemy;\n};\n \nstruct P {\n    int from, money, enemy;\n \n    bool operator >(const P& p) const {\n        return enemy > p.enemy;\n    }\n};\n \nint main() {\n    while (cin >> N >> M >> L, N|M|L) {\n        vector<vector<edge> > E(N);\n        int a, b, d, e;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> d >> e;\n            E[a-1].push_back({b, d, e});\n            E[b-1].push_back({a, d, e});\n        }\n \n        priority_queue<P, vector<P>, greater<P>> q;\n        q.push((P){0, L, 0});\n            while(!q.empty()) {\n            P p = q.top(); q.pop();\n            // goal\n            if (p.from == N-1) {\n                cout << p.enemy << endl;\n                break;\n            }\n            for (int i = 0; i < E[p.from].size() ; i++) {\n                edge e = E[p.from][i];\n                q.push((P){e.to-1, p.money, p.enemy+e.enemy});\n                if (p.money-e.distance >= 0) {\n                    q.push((P){e.to-1, p.money-e.distance, p.enemy});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define MAX 100000000\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<int,p> P;\n//G@ê@à\nstruct edge{\n\tint to,cost,enem;\n};\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n||m||l){\n\t\tvector<edge> tab[110];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedge pre;\n\t\t\tpre.cost=d;\n\t\t\tpre.enem=e;\n\t\t\tpre.to=b;\n\t\t\ttab[a].push_back(pre);\n\t\t\tpre.to=a;\n\t\t\ttab[b].push_back(pre);\n\t\t}\n\t\tint d[110][110];\n\t\t//d[ê][à]=G;\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<100;j++){\n\t\t\td[i][j]=MAX;\n\t\t}\n\t\td[0][l]=0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,p(0,l)));\n\t\twhile(!que.empty()){\n\t\t\tP now=que.top();\n\t\t\tque.pop();\n\t\t\tint nowplace=now.second.first;\n\t\t\tint nowenem=now.first;\n\t\t\tint nowmoney=now.second.second;\n\t\t\tif(d[nowplace][nowmoney]<nowenem)\n\t\t\t\tcontinue;\n\t\t\td[nowplace][nowmoney]=nowenem;\n\t\t\tif(nowplace==n-1)\n\t\t\tbreak;\n\t\t\tfor(int i=0;i<(int)tab[nowplace].size();i++){\n\t\t\t\tedge e=tab[nowplace][i];\n\t\t\t\tif(e.cost<=nowmoney&&d[e.to][nowmoney-e.cost]>nowenem){\n\t\t\t\t\tque.push(P(nowenem,p(e.to,nowmoney-e.cost)));\n\t\t\t\t}if(d[e.to][nowmoney]>nowenem+e.enem)\n\t\t\t\tque.push(P(nowenem+e.enem,p(e.to,nowmoney)));\n\t\t\t}\n\t\t}\n\t\tint ans=MAX;\n\t\tfor(int i=0;i<=l;i++)\n\t\tans=min(ans,d[n-1][i]);\n\t\tcout<<ans<<endl;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N || M || L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (e.dist <= current.money) {\n                    pq.push({e.to, current.money - e.dist, current.damage});\n                }\n                // 護衛を雇わない\n                pq.push({e.to, current.money, current.damage + e.enemy});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <stack>\n#include <algorithm>\n\nstd::pair<int, int> road[101][101]; //first?????¢ second???\nint dp[101][101];//[??????][??´???] = ??¢????\\????????????°\n\nstruct Node {\n\tint pos, money, attacked;\n};\n\nint main() {\n\tint n, m, l;\n\twhile (std::cin >> n >> m >> l && (n || m || l)) {\n\t\tstd::memset(dp, 0, sizeof(dp));\n\t\tfor (int i = 0; i < 101; i++) for (int j = 0; j < 101; j++) road[i][j] = std::make_pair(0, 0);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, e;\n\t\t\tstd::cin >> x >> y >> d >> e;\n\t\t\troad[x][y] = std::make_pair(d, e);\n\t\t\troad[y][x] = std::make_pair(d, e);\n\t\t}\n\n\t\tstd::stack<Node> s;\n\t\ts.push({1, l, 0});\n\n\t\tint min = 1919810;\n\t\twhile (!s.empty()) {\n\t\t\tauto node = s.top(); s.pop();\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (!road[node.pos][i].first) continue;\n\t\t\t\tauto next = node;\n\t\t\t\tnext.pos = i;\n\n\t\t\t\t//????????????\n\t\t\t\t{\n\t\t\t\t\tauto n2 = next;\n\t\t\t\t\tn2.attacked += road[node.pos][i].second;\n\t\t\t\t\tif (!dp[n2.money][i] || dp[n2.money][i] > next.attacked) {\n\t\t\t\t\t\tif (i == n) min = std::min(min, n2.attacked); //????????????\n\t\t\t\t\t\telse s.push(n2);\n\t\t\t\t\t\tdp[n2.money][i] = n2.attacked;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\tif (next.money >= road[node.pos][i].first) {\n\t\t\t\t\tnext.money -= road[node.pos][i].first;\n\t\t\t\t\tif (!dp[next.money][i] || dp[next.money][i] > next.attacked) {\n\t\t\t\t\t\tif (i == n) min = std::min(min, next.attacked); //????????????\n\t\t\t\t\t\telse s.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << min << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \nusing namespace std;\nint n,m,l;\nvoid dijkstra(int v,vector<vector<pair<int,int> > > &edge,vector<int> &d);\nint main(){\n        ios::sync_with_stdio(false);\n        while(cin>>n>>m>>l,n){\n                        vector<int> a(m),b(m),d(m),e(m);\n                        for(int i=0;i<m;i++){\n                                cin>>a[i]>>b[i]>>d[i]>>e[i];\n                                a[i]--,b[i]--;\n                        }\n                        vector<vector<pair<int,int> > > edge(n*(l+1));\n                        for(int i=0;i<m;i++){                      \n                                for(int r=0;r<=l;r++){ \n                                        if(r-d[i]>=0){ \n                                                edge[r*n+a[i]].push_back(make_pair(0,(r-d[i])*n+b[i])); \n                                                edge[r*n+b[i]].push_back(make_pair(0,(r-d[i])*n+a[i])); \n                                        } \n                                        edge[r*n+a[i]].push_back(make_pair(e[i],r*n+b[i])); \n                                        edge[r*n+b[i]].push_back(make_pair(e[i],r*n+a[i])); \n                                } \n \n                        } \n                        vector<int> di(n*(l+1),1e8); \n                        dijkstra(0,edge,di); \n                        int res=1e8; \n                        for(int i=0;i<=l;i++){ \n                                res=min(res,di[i*n+n-1]); \n                        } \n                        cout<<res<<endl; \n        } \n        return 0; \n} \n \nvoid dijkstra(int v,vector<vector<pair<int,int> > > &edge,vector<int> &d){ \n        priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q; \n        v=v+n*l; \n        d[v]=0; \n        for(int i=0;i<edge.size()-1;i++){ \n                for(int i=0;i<edge[v].size();i++){ \n                        if(d[edge[v][i].second]>=1e8){ \n                                q.push(make_pair(edge[v][i].first,edge[v][i].second+d[v])); \n                        } \n                } \n                while(true){ \n                        pair<int,int> p=q.top(); \n                        q.pop(); \n                        if(d[p.second]>=1e8){ \n                                d[p.second]=p.first; \n                                v=p.second; \n                                break; \n                        } \n                } \n \n        } \n        return; \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nstatic const int INF = 1E8;\nstruct Edge{int A, B, D, E;};\nint N, M, L;\nint A, B, D, E;\nvector<Edge> g[111];\nint d[111];\nvector<int> tmp(3);\n\ninline bool operator < (const Edge& v, const Edge& w)\n{\n  return v.E < w.E;\n}\n\nint main()\n{\n  while(cin >> N >> M >> L, N){\n    rep(i, 111) g[i].clear();\n    rep(i, M){\n      cin >> A >> B >> D >> E;\n      g[A - 1].push_back((Edge){A - 1, B - 1, D, E});\n      g[B - 1].push_back((Edge){B - 1, A - 1, D, E});\n    }\n\n    rep(i, 111) d[i] = INF;\n    d[0] = 0;\n    priority_queue<vector<int>, vector<vector<int> >, greater<vector<int> > > que;\n    tmp[0] = 0,  tmp[1] = 0,  tmp[2] = 0;\n    que.push(tmp);\n    while(!que.empty()){\n      vector<int> top = que.top();  que.pop();\n      int cnt = top[0];\n      int cost = top[1];\n      int h = top[2];\n      if(d[h] > cnt) continue;\n      if(h == N - 1){\n        printf(\"%d\\n\", cnt);\n        break;\n      }\n      rep(i, g[h].size()){\n        Edge e = g[h][i];\n        tmp[2] = e.B;\n        if(cost <= L && d[e.B] > cnt + e.E){\n          d[e.B] = cnt + e.E;\n          tmp[0] = cnt + e.E;\n          tmp[1] = cost;\n          que.push(tmp);\n        }\n        if(cost + e.D <= L && d[e.B] > cnt){\n          d[e.B] = cnt;\n          tmp[0] = cnt;\n          tmp[1] = cost + e.D;\n          que.push(tmp);\n        }\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nconst int INF = 1<<30;\nint adj[100][100];\nint traitor[100][100];\nint visited[100];\nint dist[100];\n\nstruct State{\n  int dang,pos,money;\n  State(int dang,int pos,int money) : dang(dang), pos(pos), money(money) {;}\n};\n\nbool operator<(const State &r,const State &l) {\n  return r.dang > l.dang;\n}\n\nint main() {\n  int N,M,L;\n  int A,B,D,E;\n  while(cin>>N>>M>>L, N|M|L) {\n    for(int i=0; i<100; ++i) {\n      for(int j=0; j<100; ++j) adj[i][j] = INF,traitor[i][j] = 0;\n      adj[i][i] = 0;\n      visited[i] = 0;\n      dist[i] = INF;\n    }\n\n    for(int i=0; i<M; ++i) {\n      cin>>A>>B>>D>>E;\n      A--,B--;\n      adj[A][B] = adj[B][A] = D;\n      traitor[A][B] = traitor[B][A] = E;\n    }\n\n    priority_queue<State> Q;\n    Q.push(State(0,0,0));\n    visited[0] = 1;\n    dist[0] = 0;\n    while(!Q.empty()) {\n      State now = Q.top(); Q.pop();\n      dist[now.pos] = min(dist[now.pos], now.dang);\n      if(now.pos == N-1) {\n\t//cout<<now.dang<<endl;\n\tbreak;\n      }\n\n      visited[now.pos] = 1;\n      //cout<<now.pos<<\" \"<<now.dang<<endl;\n      for(int i=0; i<N; ++i) {\n\tif(visited[i]) continue;\n\tif(adj[now.pos][i] < INF) {\n\t  if(L-now.money >= adj[now.pos][i])\n\t    Q.push(State(now.dang, i, now.money+adj[now.pos][i]));\n\t  Q.push(State(now.dang+traitor[now.pos][i], i, now.money));\n\t}\n      }\n    }\n\n    cout<<dist[N-1]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nclass DIJ{\n\tpublic:\n\tstruct edge{\n\t\tint to,cost,nu;\n\t};\n\tvector<vector<edge> >G;\n\tint n,L;\n\tvvi d;//distance\n\tDIJ(int size,int l){\n\t\tn=size;\n\t\tL=l;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int a,int b,int c,int d){\n\t\tedge e={b,c,d},ee={a,c,d};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t}\n\tvoid dij(int s){\n\t\td=vvi(n,vi(L+1,inf));\n\t\td[s][L]=0;\n\t\tpriority_queue<pip>q;\n\t\tq.push(pip(L,pii(s,0)));//cost now nu\n\t\twhile(!q.empty()){\n\t\t\tpip p=q.top();\n\t\t\tq.pop();\n\t\t\tint pos=p.second.first,cost=p.first,nu=p.second.second;\n\t\t\tif(nu>d[pos][cost])continue;\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e=G[pos][i];\n\t\t\t\tint to=e.to;\n\t\t\t\tint nowcost=cost;\n\t\t\t\tint nownu=nu+e.nu;\n\t\t\t\tif(nownu<d[to][nowcost]){\n\t\t\t\t\td[to][nowcost]=nownu;\n\t\t\t\t\tq.push(pip(nowcost,pii(to,nownu)));\n\t\t\t\t}\n\t\t\t\tnowcost=cost-e.cost;\n\t\t\t\tnownu=nu;\n\t\t\t\tif(nowcost>=0&&nownu<d[to][nowcost]){\n\t\t\t\t\td[to][nowcost]=nownu;\n\t\t\t\t\tq.push(pip(nowcost,pii(to,nownu)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n){\n\t\tDIJ dij(n,l);\n\t\twhile(m--){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\ta--;b--;\n\t\t\tdij.add_edge(a,b,c,d);\n\t\t}\n\t\tdij.dij(0);\n\t\tint out=inf;\n\t\trep(i,l+1)out=min(out,dij.d[n-1][i]);\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\ntypedef pair<mp,int> mmp;\n\nint es[105][105];\nint cs[105][105];\n\nint rs[105][105];\n\nint main(void){\n\tfor(;;){\n\t\tmemst(es,-1);\n\t\tmemst(cs,-1);\n\t\tmemst(rs,-1);\n\t\t\n\t\tint n,m,l;\n\t\tscanf(\"%d%d%d\",&n,&m,&l);\n\t\tif(n==0)break;\n\t\t\n\t\trep(i,m){\n\t\t\tint a,b,c,e;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&e);\n\t\t\ta--; b--;\n\t\t\tcs[a][b] = cs[b][a] = c;\n\t\t\tes[a][b] = es[b][a] = e;\n\t\t}\n\t\t\n\t\tpque(mmp) que;\n\t\tque.push(mmp(mp(0,0),0));\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tmmp pa = que.top();\n\t\t\tque.pop();\n\t\t\tint no = pa.sec,\n\t\t\t\tne = pa.fir.fir,\n\t\t\t\tnc = pa.fir.sec;\n\t\t\t//printf(\"%d %d %d\\n\",no,nc,ne);\n\t\t\trep(to,n){\n\t\t\t\tif(to==no)continue;\n\t\t\t\tint c = cs[no][to],\n\t\t\t\t\te = es[no][to];\n\t\t\t\tif(c<0)continue;\n\t\t\t\trep(k,2){\n\t\t\t\t\tint tc = nc,\n\t\t\t\t\t\tte = ne + e;\n\t\t\t\t\tif(k>0 && nc+c<=l){\n\t\t\t\t\t\ttc = nc + c;\n\t\t\t\t\t\tte = ne;\n\t\t\t\t\t}\n\t\t\t\t\tif(rs[to][tc]>=0 && rs[to][tc]<=te)continue;\n\t\t\t\t\trs[to][tc] = te;\n\t\t\t\t\t//printf(\" %d %d %d\\n\",to,tc,te);\n\t\t\t\t\tque.push(mmp(mp(te,tc),to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = IINF;\n\t\treg(i,0,l){\n\t\t\tint na = rs[n-1][i];\n\t\t\tif(na<0)continue;\n\t\t\tans = min(ans,na);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    return a.enemy>b.enemy;\n}\n\nstruct node maps[100];\n\nint main()\n{\n    int n,m,l;\n\n    while ((cin>>n>>m>>l) && (n>0 || m>0 || l>0)){\n        priority_queue<struct state,vector<struct state>,greater<struct state>> queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            maps[a-1].data.push_back((struct data){b-1,d,e});\n            maps[b-1].data.push_back((struct data){a-1,d,e});\n        }\n        queue.push((struct state){0,l,0});\n        while (!queue.empty()){\n            //printf(\"!N:%d , M:%2d , E:%2d\\n\",queue.top().number,queue.top().money,queue.top().enemy);\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                cout<<s.enemy<<endl;\n                while(!queue.empty()){\n                    queue.pop();\n                }\n            }else{\n                for(struct data d: maps[s.number].data){\n                    //printf(\"[DATA]%d\\n\",d.to);\n                    if(d.dis<=s.money){\n                        queue.push((struct state){d.to,s.money-d.dis,s.enemy});\n                        //printf(\"*N:%d , M:%2d , E:%2d\\n\",queue.top().number,queue.top().money,queue.top().enemy);\n                    }\n                    queue.push((struct state){d.to,s.money,s.enemy+d.ene});\n                    //printf(\" N:%d , M:%2d , E:%2d\\n\",d.to,s.money,s.enemy+d.ene);\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint cost[101][101];\nint main(){\n\tint c,N,m,i,j,k,x,y;\n\tfor(;scanf(\"%d%d%d\",&N,&m,&c),N;){\n\t\tvector<map<int,int> >dist(N+1);\n\t\tvector<map<int,int> >fee(N+1);\n\t\tmemset(cost,99,sizeof(cost));\n\t\tfor(k=0;k<m;k++){\n\t\t\tscanf(\"%d%d%d%d\",&i,&j,&x,&y);\n\t\t\tdist[i][j]=dist[j][i]=y;\n\t\t\tfee[i][j]=fee[j][i]=x;\n\t\t}\n\t\tfor(i=0;i<=c;i++)cost[1][i]=0;\n\t\tfor(;~c;c--){\n\t\t\tvector<bool>used(N+1);\n\t\t\tfor(;;){ //dijkstra\n\t\t\t\tint m=9999999;\n\t\t\t\tfor(i=1;i<=N;i++)if(!used[i]&&m>cost[i][c])m=cost[i][c];\n\t\t\t\tif(m==9999999)break;\n\t\t\t\tfor(j=1;j<=N;j++)if(m==cost[j][c]){\n\t\t\t\t\tmap<int,int>::iterator it=dist[j].begin();\n\t\t\t\t\tfor(used[j]=1;it!=dist[j].end();it++)if(!used[it->first]){\n\t\t\t\t\t\tif(cost[it->first][c]>it->second+cost[j][c])cost[it->first][c]=it->second+cost[j][c];\n\t\t\t\t\t\tif(fee[j][it->first]<=c)//&&cost[it->first][max(0,c-fee[j][it->first])]>cost[j][c])\n\t\t\t\t\t\t\tcost[it->first][max(0,c-fee[j][it->first])]=cost[j][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cost[N][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n// int n_dir = 4;\n// int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; [> CSS order <]\n// enum direction {\n\t// UP, RIGHT, DOWN, LEFT\n// };\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// };\n// #define FORDIR(d) REP (d, n_dir)\n\ntypedef complex<int> P;\n#define Y real()\n#define X imag()\nP dyx[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\n// P dyx[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\n\nint g_height, g_width;\nbool in_field(P p) {\n\treturn (0 <= p.Y && p.Y < g_height) && (0 <= p.X && p.X < g_width);\n}\n\n/*}}}*/\n\n// My version of (Extended) Dijkstra\n// Pros: easy to access `costs` -- just `costs(node)`\n//       vector with many parameters is confusing e.g. `costs[param1][param2][param3]...`\n\n// Node should have only parameters with which Node can be distinguished\nclass Node {\npublic:\n\t// Parameters to distinguish Nodes\n\tint id;\n\tint budget;\n\n\tNode(int _id, int _budget): id(_id), budget(_budget) {\n\t}\n};\n\n// for priority_queue\ntypedef pair<int, Node> Qtype; // cost and Node\nclass Comp {\npublic:\n\tbool operator() (const Qtype& l, const Qtype& r) const {\n\t\t// compair costs for each Node\n\t\treturn (l.F > r.F);\n\t}\n};\n\n// easy access to saved costs\n// #define MAX_N 100\n// #define MAX_L 100\n// VVI g_saved_costs(MAX_N, VI(MAX_L));\n// void init_saved_costs()\n// {\n\t// REP (i, MAX_N) {\n\t\t// REP (j, MAX_L) {\n\t\t\t// g_saved_costs[i][j] = INF;\n\t\t// }\n\t// }\n// }\nVVI g_saved_costs;\nint saved_cost(Node n)\n{\n\treturn g_saved_costs[n.id][n.budget];\n}\nvoid save_cost(Node n, int cost)\n{\n\tg_saved_costs[n.id][n.budget] = cost;\n}\n\nint main()\n{\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N) {\n\t\tVVI dist(N, VI(N, INF));\n\t\tVVI gang(N, VI(N, INF));\n\t\tREP (_, M) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e; --a, --b;\n\t\t\tdist[a][b] = dist[b][a] = d;\n\t\t\tgang[a][b] = gang[b][a] = e;\n\t\t}\n\n\t\t// Initialize g_saved_costs\n\t\t// init_saved_costs();\n\t\tg_saved_costs = VVI(N, VI(L+1, INF));\n\t\tpriority_queue< Qtype, vector<Qtype>, Comp > q;\n\n\t\tq.push( MP(0, Node(0, L)) );\n\t\twhile (!q.empty()) {\n\t\t\tQtype t = q.top(); q.pop();\n\t\t\tint cost_here = t.F; Node node = t.S;\n\n\t\t\t// Skip if already visited\n\t\t\tif (cost_here > saved_cost(node)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsave_cost(node, cost_here);\n\n\t\t\tREP (i, N) {\n\t\t\t\tif (dist[node.id][i] != INF) {\n\t\t\t\t\t// without guard\n\t\t\t\t\tq.push(MP(cost_here + gang[node.id][i], Node(i, node.budget)));\n\t\t\t\t\tif (dist[node.id][i] <= node.budget) {\n\t\t\t\t\t\t// with guard\n\t\t\t\t\t\tif (saved_cost(Node(i, node.budget)) <= cost_here) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(MP(cost_here, Node(i, node.budget - dist[node.id][i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tREP (i, L+1) {\n\t\t\tans = min(ans, saved_cost(Node(N-1, i)));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct edge {\n  int to, d, e;\n};\n\nstruct state {\n  int cur, cost, remain;\n  bool operator<(const state& o) const {\n    return cost > o.cost;\n  }\n};\n\nvector<edge> es[102];\nint L, N, M, d[102][102];\n\nint solve() {\n  rep(i,102) rep(j,102) d[i][j] = 1 << 30;\n  \n  priority_queue<state> Q;\n  Q.push((state){0, 0, L});\n  \n  while (!Q.empty()) {\n    state s = Q.top(); Q.pop();\n    int cur = s.cur, cost = s.cost, remain = s.remain;\n    if (s.cost > d[s.cur][s.remain]) continue;\n    if (cur == N-1) {\n      return cost;\n    }\n    rep(i,es[s.cur].size()) {\n      edge e = es[cur][i];\n      // やとわない\n      if (d[e.to][remain] > e.e + cost) {\n        d[e.to][remain] = e.e + cost;\n        Q.push((state){e.to, e.e + cost, remain});\n      }\n      // やとってみる\n      if (remain >= e.d && d[e.to][remain - e.d] > cost) {\n        d[e.to][remain - e.d] = cost;\n        Q.push((state){e.to, cost, remain - e.d});\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while (scanf(\"%d%d%d\", &N, &M, &L), N) {\n    rep(i,102) es[i].clear();\n    int a, b, d, e;\n    rep(i,M) {\n      scanf(\"%d%d%d%d\", &a, &b, &d, &e);\n      --a; --b;\n      es[a].push_back((edge){b, d, e});\n      es[b].push_back((edge){a, d, e});\n    }\n    // memset(visited, 0, sizeof visited);\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nclass Edge {\npublic:\n    int next;\n    int dist;\n    int weight;\n    Edge() {}\n    Edge(int n, int d, int w) {\n\tnext = n;\n\tdist = d;\n\tweight = w;\n    }\n};\n\nclass Info {\npublic:\n    int node;\n    int dist;\n    int left;\n    Info(int n, int d, int l) {\n\tnode = n;\n\tdist = d;\n\tleft = l;\n    }\n    bool operator< (const Info &a) const {\n\tif (dist == a.dist && node == a.node) return left < a.left;\n\treturn dist > a.dist;\n    }\n};\n\nint dist[100][110];\nvector<vector<Edge>> nexts;\n\nsigned main() {\n    int N, M, L;\n    while (cin >> N >> M >> L) {\n\tif (N == 0) break;\n\n\tnexts.clear();\n\tnexts.resize(N);\n\trep(i, 100) rep(j, 101) dist[i][j] = INT_MAX;\n\n\tint A, B, D, E;\n\trep(i, M) {\n\t    cin >> A >> B >> D >> E;\n\t    A--; B--;\n\t    nexts[A].push_back(Edge(B, D, E));\n\t    nexts[B].push_back(Edge(A, D, E));\n\t}\n\n\tpriority_queue<Info> q;\n\tq.push(Info(0, 0, L));\n\trep(i, 101) dist[0][i] = 0;\n\twhile (!q.empty()) {\n\t    Info info = q.top(); q.pop();\n\t    if (info.dist > dist[info.node][info.left]) continue;\n\t    if (info.node == N - 1) {\n\t\tcout << info.dist << endl;\n\t\tbreak;\n\t    }\n\t    for (Edge &edge : nexts[info.node]) {\n\t\tif (info.left >= edge.dist && edge.weight > 0) {\n\t\t    if (dist[edge.next][info.left - edge.dist] > info.dist) {\n\t\t\trep(i, info.left - edge.dist) {\n\t\t\t    if (info.dist >= dist[edge.next][i] - 1) break;\n\t\t\t    dist[edge.next][i] = info.dist - 1;\n\t\t\t}\n\t\t\tdist[edge.next][info.left - edge.dist] = info.dist;\n\t\t\tq.push(Info(edge.next, info.dist, info.left - edge.dist));\n\t\t    }\n\t\t}\n\t\tint ndist = info.dist + edge.weight;\n\t\tif (dist[edge.next][info.left] > ndist) {\n\t\t    rep(i, info.left) {\n\t\t\tif (dist[edge.next][i] >= ndist - 1) break;\n\t\t\tdist[edge.next][i] = ndist - 1;\n\t\t    }\n\t\t    dist[edge.next][info.left] = ndist;\n\t\t    q.push(Info(edge.next, ndist, info.left));\n\t\t}\n\t    }\n\t}\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(int n, int m, int l) {\n    vector<vector<int>> dp(n, vector<int>(l + 1, 1e9));\n    dp[0][l] = 0;\n    vector<vector<tuple<int, int, int>>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int a, b, d, e;\n        cin >> a >> b >> d >> e;\n        a--, b--;\n        adj[a].emplace_back(b, d, e);\n        adj[b].emplace_back(a, d, e);\n    }\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> que;\n    que.emplace(0, l);\n    while (!que.empty()) {\n        auto top = que.top();\n        que.pop();\n        int v = top.first, k = top.second;\n        for (auto &t : adj[v]) {\n            int u = get<0>(t), d = get<1>(t), e = get<2>(t);\n            // 何も守らない\n            if (dp[v][k] + e < dp[u][k]) {\n                dp[u][k] = dp[v][k] + e;\n                que.emplace(u, k);\n            }\n            if (d <= k && dp[v][k] < dp[u][k - d]) {\n                dp[u][k - d] = dp[v][k];\n                que.emplace(u, k - d);\n            }\n        }\n    }\n    int ret = 1e9;\n    for (int i = 0; i <= l; i++) {\n        ret = min(ret, dp.back()[i]);\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (1) {\n        int n, m, l;\n        cin >> n >> m >> l;\n        if (n == 0) break;\n        cout << solve(n, m, l) << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<cassert>\n#include<cstdint>\n#include<map>\nusing namespace std;\n\ntypedef int64_t i64;typedef int32_t i32;\ntypedef int16_t i16;typedef int8_t i8;\ntypedef uint64_t ui64;typedef uint32_t ui32;\ntypedef uint16_t ui16;typedef uint8_t ui8;\n\ntypedef i64 int__;\n#define rep(i,j) for(int__ i=0;i<j;i++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);i++)\n#define all(v) begin(v),end(v)\n\nconst i32 INF=1<<30;//10E10\n\nclass Path{  \npublic:\n  struct Edge{int to,cost,dist;Edge(int to_,int cost_,int d):to(to_),cost(cost_),dist(d){;}};\n\n  int node_size;\n  vector< vector<Edge> > E_list;//??\\?¶??????????\n\n  \n  Path(int node_size_){E_list.resize(node_size_);node_size=node_size_;}\n  \n  void add_arc(int x,int y,int c,int d)\n  {\n    E_list[x].push_back(Edge(y,c,d));\n  }\n  void add_edge(int x,int y,int c,int d)\n  {\n    E_list[x].push_back(Edge(y,c,d));\n    E_list[y].push_back(Edge(x,c,d));\n  }\n};\n\nstruct djk_state{\n  int index;\n  int cost;\n  int money;\n  djk_state(int i,int c,int m):index(i),cost(c),money(m){;}\n  bool operator<(const djk_state &r)const{return cost<r.cost;}\n  bool operator>(const djk_state &r)const{return cost>r.cost;}\n};\n\n\nint dijkstra(Path &Graph,int N,int M,int L){\n  priority_queue< djk_state ,vector<djk_state>,greater<djk_state> > que;\n  vector<int> ans;\n  bool visited[101][101]={};//[money][index]\n  \n  que.push(djk_state(0,0,L));\n    \n  while(!que.empty()){\n    djk_state now=que.top();que.pop();    \n\n    //printf(\"index %d money %d\\n\",now.index,now.money);\n\n    if(visited[now.money][now.index])continue;\n    visited[now.money][now.index]=true;\n    if(now.index==N-1){\n      ans.push_back(now.cost);\n      continue;\n    }\n    \n    for(Path::Edge e : Graph.E_list[now.index]){\n      if(now.money-e.dist>=0)\n\tque.push(djk_state(e.to,now.cost,now.money-e.dist));\n      que.push(djk_state(e.to,now.cost+e.cost,now.money));\n    }\n    \n  }\n  int answer=INF;\n  rep(i,ans.size())answer=min(answer,ans[i]);\n  return answer;\n}\n\n\n\n\nint main()\n{\n  while(1){\n    int N,M,L;\n    cin>>N>>M>>L;\n    if(N==0)break;\n    Path G(N);\n    rep(i,M){\n      int a,b,d,e;\n      cin>>a>>b>>d>>e;\n      G.add_edge(a-1,b-1,e,d);\n    }\n    cout<<dijkstra(G,N,M,L)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<array>\n\n#define fin cin\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nclass Input{\npublic:\n\tint a;\n\tint b;\n\tint d;\n\tint e;\n\tInput(int _a, int _b, int _d, int _e){\n\t\ta = _a;\n\t\tb = _b;\n\t\td = _d;\n\t\te = _e;\n\t}\n\toperator < (Input& other)\n\t{\n\t\treturn this->a < other.a;\n\t}\n\toperator > (Input& other)\n\t{\n\t\treturn this->a > other.a;\n\t}\n\n};\n\nconst int initnum = 10000000;\n\nstd::vector<Input> in_v{};\nstd::array<std::array<int, 100>, 100> cost;\n\nint main()\n{\n\t//std::ifstream fin(\"in.txt\");\n\t//cost[0].fill(0);\n\t//for(int i = 1; i < 100; i++)cost[i].fill(10000000);\n\n\twhile(true)\n\t{\n\t\tcost[0].fill(0);\n\t\t//cost[1].fill(0);\n\t\tfor(int i = 1; i < 100; i++)cost[i].fill(initnum);\n\t\n\t\tint n, m, l;\n\t\tfin >> n >> m >> l;\n\t\tif((n | m | l) == 0)break;\n\t\t//cout << n << \" \" << m << \" \" << l << endl;\n\t\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b, d, e;\n\t\t\tfin >> a >> b >> d >> e;\n\t\t\tin_v.push_back(Input(a-1, b-1, d, e));\n\t\t\tin_v.push_back(Input(b-1, a-1, d, e));\n\t\t}\n\t\tsort(in_v.begin(), in_v.end());\n\n\t\tstd::queue<Input> in_q;\n\t\tfor(auto in : in_v)in_q.push(in);\n\n\t\tin_v.clear();\n\t\tin_v.shrink_to_fit();\n\n\t\twhile(!in_q.empty())\n\t\t{\n\t\t\tInput tmp = in_q.front();\n\t\t\tin_q.pop();\n\n\t\t\tfor(int _cost = 0; _cost <= l; _cost++)\n\t\t\t{\n\n\t\t\t\tif(cost[tmp.a][_cost] == initnum)\n\t\t\t\t{\n\t\t\t\t\tin_q.push(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcost[tmp.b][_cost] = std::min(\n\t\t\t\t\tcost[tmp.b][_cost],\n\t\t\t\t\tstd::min(\n\t\t\t\t\t\t(_cost + tmp.d <= l ? (cost[tmp.a][_cost + tmp.d]) : initnum / 10),\n\t\t\t\t\t\tcost[tmp.a][_cost] + tmp.e\n\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\t\t\tfor(int i = 0; i <= l + 2; i++){\n\t\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\n\t\t}\n\t\tint min_cost = 10000000;\n\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tif(cost[n - 1][i] < min_cost)min_cost = cost[n - 1][i];\n\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t}\n\t\tcout << min_cost << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct NODE{\n  vector<int> to;\n  vector<int> cost;\n  vector<int> man;\n  int den;\n  bool done;\n  NODE(){done = false;den = 10000000;}\n};\nint main(){\n  int n,m,l;\n  while(cin >>n>>m>>l,n||m||l){\n    NODE city[101][101];\n    for(int i=0,a,b,d,e; i<m; i++){\n      cin >>a>>b>>d>>e;\n      for(int j=0; j<=l; j++){\n\tcity[a-1][j].to.push_back(b-1);\n\tcity[a-1][j].cost.push_back(d);\n\tcity[a-1][j].man.push_back(e);\n\tcity[b-1][j].to.push_back(a-1);\n\tcity[b-1][j].cost.push_back(d);\n\tcity[b-1][j].man.push_back(e);\n      }\n    }\n    city[0][l].den = 0;\n    for(;;){\n      int n_a = -1,n_b,next_den = 10000000;\n      for(int i=0; i<n; i++){\n\tfor(int j=0; j<=l; j++){\n\t  if(city[i][j].done) continue;\n\t  if(next_den > city[i][j].den){next_den = city[i][j].den; n_a = i; n_b = j;}\n\t}\n      }\n      if(n_a == -1) break;\n      city[n_a][n_b].done = true;\n      for(int i=0; i<city[n_a][n_b].to.size(); i++){\n\tint next_to = city[n_a][n_b].to[i];\n\tint next_cost = city[n_a][n_b].cost[i];\n\tint next_man = city[n_a][n_b].man[i];\n\tif(n_b-next_cost>=0) city[next_to][n_b-next_cost].den = min(city[next_to][n_b-next_cost].den, next_den);\n\tcity[next_to][n_b].den = min(city[next_to][n_b].den,next_den+next_man);\n      }\n    }\n    int ans = 10000000;\n    for(int i=0; i<=l; i++) ans = min(ans,city[n-1][i].den);\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110][110];\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(memo[nokori][now]<=sum)return;\n  memo[nokori][now]=sum;\n  if(now==n){\n    ans=min(ans,sum);\n  }\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      if(nokori-E[now][i].cost>=0)\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n      for(int j=0;j<l+5;j++)\n\tmemo[j][i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n// int n_dir = 4;\n// int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; [> CSS order <]\n// enum direction {\n\t// UP, RIGHT, DOWN, LEFT\n// };\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// };\n// #define FORDIR(d) REP (d, n_dir)\n\ntypedef complex<int> P;\n#define Y real()\n#define X imag()\nP dyx[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\n// P dyx[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\n\nint g_height, g_width;\nbool in_field(P p) {\n\treturn (0 <= p.Y && p.Y < g_height) && (0 <= p.X && p.X < g_width);\n}\n\n/*}}}*/\n\n// My version of (Extended) Dijkstra\n// Pros: easy to access `costs` -- just `costs(node)`\n//       vector with many parameters is confusing e.g. `costs[param1][param2][param3]...`\n\n// Node should have only parameters with which Node can be distinguished\nclass Node {\npublic:\n\t// Parameters to distinguish Nodes\n\tint id;\n\tint budget;\n\n\tNode(int _id, int _budget): id(_id), budget(_budget) {\n\t}\n};\n\n// for priority_queue\ntypedef pair<int, Node> Qtype; // cost and Node\nclass Comp {\npublic:\n\tbool operator() (const Qtype& l, const Qtype& r) const {\n\t\t// compair costs for each Node\n\t\treturn (l.F > r.F);\n\t}\n};\n\n// easy access to saved costs\n// #define MAX_N 100\n// #define MAX_L 100\n// VVI g_saved_costs(MAX_N, VI(MAX_L));\n// void init_saved_costs()\n// {\n\t// REP (i, MAX_N) {\n\t\t// REP (j, MAX_L) {\n\t\t\t// g_saved_costs[i][j] = INF;\n\t\t// }\n\t// }\n// }\nVVI g_saved_costs;\nint saved_cost(Node n)\n{\n\treturn g_saved_costs[n.id][n.budget];\n}\nvoid save_cost(Node n, int cost)\n{\n\tg_saved_costs[n.id][n.budget] = cost;\n}\n\nint main()\n{\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N) {\n\t\tVVI dist(N, VI(N, INF));\n\t\tVVI gang(N, VI(N, INF));\n\t\tREP (_, M) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e; --a, --b;\n\t\t\tdist[a][b] = dist[b][a] = d;\n\t\t\tgang[a][b] = gang[b][a] = e;\n\t\t}\n\n\t\t// Initialize g_saved_costs\n\t\t// init_saved_costs();\n\t\tg_saved_costs = VVI(N, VI(L+1, INF));\n\t\tpriority_queue< Qtype, vector<Qtype>, Comp > q;\n\n\t\tq.push( MP(0, Node(0, L)) );\n\t\twhile (!q.empty()) {\n\t\t\tQtype t = q.top(); q.pop();\n\t\t\tint cost_here = t.F; Node node = t.S;\n\n\t\t\t// Skip if already visited\n\t\t\tif (cost_here > saved_cost(node)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsave_cost(node, cost_here);\n\n\t\t\tREP (i, N) {\n\t\t\t\tif (dist[node.id][i] != INF) {\n\t\t\t\t\t// trim vain moves\n\t\t\t\t\tbool vain = false;\n\t\t\t\t\tREP (b, node.budget + 1) {\n\t\t\t\t\t\tif (saved_cost(Node(i, b)) <= cost_here) {\n\t\t\t\t\t\t\tvain = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tIFC(vain);\n\t\t\t\t\t// without guard\n\t\t\t\t\tq.push(MP(cost_here + gang[node.id][i], Node(i, node.budget)));\n\t\t\t\t\tif (dist[node.id][i] <= node.budget) {\n\t\t\t\t\t\t// with guard\n\t\t\t\t\t\tq.push(MP(cost_here, Node(i, node.budget - dist[node.id][i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tREP (i, L+1) {\n\t\t\tans = min(ans, saved_cost(Node(N-1, i)));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <random>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n\nusing namespace std;\nusing ll = long long;\n\nconst ll mod = 1000000007;\n\n// int dx[4]={1,0,-1,0};\n// int dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\n// bool debug=false;\n\n/*---------------------------------------------------*/\n\nconst int INF = 100000000;\n\nstruct Edge {\n    int to;\n    int dist;\n    int enemy;\n};\n\ntypedef tuple<int, int, int> TP;\n\nvoid solve(int N, int M, int L) {\n    int A, B, D, E;\n    vector<Edge> G[N + 1];\n    for(int i = 0; i < M; i++) {\n        cin >> A >> B >> D >> E;\n        G[A].push_back({B, D, E});\n        G[B].push_back({A, D, E});\n    }\n    vector<vector<int>> dp = vector<vector<int>>(N + 1, vector<int>(L + 1, INF));\n    \n    // cost, money, curr\n    priority_queue<TP, vector<TP>, greater<TP>> que;\n    que.push(make_tuple(0, L, 1));\n    dp[1][L] = 0;\n    while(que.size()) {\n        // assert(que.size() <= 10000);\n        TP tp = que.top(); que.pop();\n        int cost, money, curr;\n        tie(cost, money, curr) = tp;\n        //cerr << cost << endl;\n        if(dp[curr][money] < cost) continue;\n        for(Edge e : G[curr]) {\n            if(dp[curr][money] + e.enemy < dp[e.to][money]) { \n                assert(0 <= dp[curr][money]);\n                dp[e.to][money] = dp[curr][money] + e.enemy;\n                que.push(make_tuple(dp[e.to][money], money, e.to));\n            }\n            if(e.dist <= money && dp[curr][money] < dp[e.to][money - e.dist]) {\n                // //cerr << \"debug: \" << e.dist << \" \" << money << \" \" << cost << endl;\n                // assert(0 <= dp[curr][money]);\n                dp[e.to][money - e.dist] = dp[curr][money];\n                que.push(make_tuple(dp[e.to][money - e.dist], money - e.dist, e.to));\n            }\n        }\n    }\n\n    int ans = INF;\n    for(int i = 0; i <= L; i++) {\n        ans = min(ans, dp[N][i]);\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    int N, M, L;\n    while(cin >> N >> M >> L) {\n        if(N == 0 && M == 0 && L == 0) break;\n        solve(N, M, L);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nstruct state {\n\tint p, l, c;\n\tstate(int p, int l, int c) : p(p), l(l), c(c) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tint A, B, D, E;\n\t\tvvi dist(N, vi(N, INF)), enemy(N, vi(N, INF));\n\t\tREP(i, M) {\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tdist[A-1][B-1] = dist[B-1][A-1] = D;\n\t\t\tenemy[A-1][B-1] = enemy[B-1][A-1] = E;\n\t\t}\n\n\t\tvvi cost(N, vi(L+1, INF));\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(0, L, 0));\n\t\tint ans = INF;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.p == N-1) {\n\t\t\t\tans = min(ans, st.c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP(t, N) {\n\t\t\t\tif(st.p != t && dist[st.p][t] != INF) {\n\t\t\t\t\tif(dist[st.p][t] <= st.l) {\n\t\t\t\t\t\tint nl = st.l-dist[st.p][t];\n\t\t\t\t\t\tif(st.c < cost[t][nl]) {\n\t\t\t\t\t\t\tcost[t][nl] = st.c;\n\t\t\t\t\t\t\tQ.push(state(t, nl, st.c));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nc = st.c+enemy[st.p][t];\n\t\t\t\t\tif(nc < cost[t][st.l]) {\n\t\t\t\t\t\tcost[t][st.l] = nc;\n\t\t\t\t\t\tQ.push(state(t, st.l, nc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nint main() {\n    int N, M, L;\n    int a,b;\n    int now;\n    cin >> N >> M >> L;\n    for(;N!=0;){\n        vector<vector<bool>> graph(N,vector<bool>(N,false));\n        vector<vector<int>> distance(N,vector<int>(N)),evect(N,vector<int>(N));\n        //vector<vector<int>> dp(N,vector<int>(L+1,1000000000));\n        vector<vector<int>> dp_old(N,vector<int>(L+1,1000000000));\n        queue<int> vertex;\n        for(int i=0; i< M; i++){\n            cin >> a >> b;\n            a--;b--;\n            graph[a][b] = true; graph[b][a] = true;\n            cin >> distance[a][b] >> evect[a][b];\n            distance[b][a] = distance[a][b];\n            evect[b][a] = evect[a][b];\n        }\n        for(int i=0;i<=L;i++){\n            dp_old[0][i] = 0;\n            //dp[0][i] = 0;\n        }\n        for(int itr=0;itr<1;itr++){\n            vector<bool> reached(N,false);\n            reached[0] = true;\n            if(itr==0){\n                for(int i=0; i<N; i++){\n                    if(graph[0][i]){\n                        vertex.push(i);\n                        //graph[0][i] = false;\n                        //graph[i][0] = false;\n                        dp_old[i][L] = evect[0][i];\n                        //dp[i][L] = evect[0][i];\n                        if(L>=distance[0][i]){\n                            dp_old[i][L-distance[0][i]] = 0;\n                            //dp[i][L-distance[0][i]] = 0;\n                        }\n                    }\n                }\n            }else{\n                for(int i=0 ; i< N ; i++){\n                    if(graph[0][i]){\n                        vertex.push(i);\n                    }\n                }\n            }\n            for(;!vertex.empty();){\n                now = vertex.front();\n                reached[now] = true;\n                vertex.pop();\n                for(int i=1; i<N; i++){\n                    if(graph[now][i]){\n                        if(!reached[i])vertex.push(i);\n                        for(int j=0;j<=L; j++){\n                            if(j+distance[now][i]<=L){\n                                dp_old[now][j] = min(dp_old[now][j],min(dp_old[i][j]+evect[now][i],dp_old[i][j+distance[now][i]]));\n                                //dp_old[i][j] = min(dp_old[i][j],min(dp_old[now][j]+evect[now][i],dp_old[now][j+distance[now][i]]));\n                                //dp_old[now][j] = dp[now][j];\n                                //dp_old[i][j] = dp[i][j];\n                            }else{\n                                dp_old[now][j] = min(dp_old[i][j]+evect[now][i],dp_old[now][j]);\n                                //dp_old[i][j] = min(dp_old[now][j]+evect[now][i],dp_old[i][j]);\n                                //dp_old[now][j] = dp[now][j];\n                                //dp_old[i][j] = dp[i][j];\n                            }\n                        }\n                    }\n                }\n                //swap(dp,dp_old);\n            }\n        }\n        //swap(dp,dp_old);\n        int ans=dp_old[N-1][L];\n        for(int i=0; i<L ; i++){\n            ans=min(ans,dp_old[N-1][i]);\n        }\n        cout << ans << endl;\n\n        cin >> N >> M >>L;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n\nstd::pair<int, int> road[101][101]; //first距離 second敵\nint dp[101][101];//[残金][場所] = 既に襲われた数\n\nstruct Node {\n\tint pos, money, attacked;\n\tbool operator > (const Node& rhs) const {\n\t\treturn attacked > rhs.attacked;\n\t}\n\tbool operator < (const Node& rhs) const {\n\t\treturn attacked < rhs.attacked;\n\t}\n};\n\nint main() {\n\tint n, m, l;\n\twhile (std::cin >> n >> m >> l && (n || m || l)) {\n\t\tstd::memset(dp, -1, sizeof(dp));\n\t\tfor (int i = 0; i < 101; i++) for (int j = 0; j < 101; j++) road[i][j] = std::make_pair(0, 0);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, e;\n\t\t\tstd::cin >> x >> y >> d >> e;\n\t\t\troad[x][y] = std::make_pair(d, e);\n\t\t\troad[y][x] = std::make_pair(d, e);\n\t\t}\n\n\t\tstd::stack<Node> s;\n\t\t//std::priority_queue<Node> s;\n\t\ts.push({1, l, 0});\n\n\t\tint min = 1919810;\n\t\twhile (!s.empty()) {\n\t\t\tauto node = s.top(); s.pop();\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (!road[node.pos][i].first) continue;\n\t\t\t\tauto next = node;\n\t\t\t\tnext.pos = i;\n\n\t\t\t\t//雇わない\n\t\t\t\t{\n\t\t\t\t\tauto n2 = next;\n\t\t\t\t\tn2.attacked += road[node.pos][i].second;\n\t\t\t\t\tif (dp[n2.money][i] == -1 || dp[n2.money][i] > n2.attacked) {\n\t\t\t\t\t\tdp[n2.money][i] = n2.attacked;\n\t\t\t\t\t\tif (i == n) min = std::min(min, n2.attacked); //ごーーる\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//よりお金を残して今と同等かそれ以下の襲撃数なら意味なし\n\t\t\t\t\t\t\tbool isOk = true;\n\t\t\t\t\t\t\tfor (int j = n2.money + 1; j <= l; j++) {\n\t\t\t\t\t\t\t\tif (dp[j][i] >= 0 && dp[j][i] <= n2.attacked) {\n\t\t\t\t\t\t\t\t\tisOk = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isOk) {\n\t\t\t\t\t\t\t\ts.push(n2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//雇う\n\t\t\t\tif (next.money >= road[node.pos][i].first) {\n\t\t\t\t\tnext.money -= road[node.pos][i].first;\n\t\t\t\t\tif (dp[next.money][i] == -1 || dp[next.money][i] > next.attacked) {\n\t\t\t\t\t\tdp[next.money][i] = next.attacked;\n\t\t\t\t\t\tif (i == n) min = std::min(min, next.attacked); //ごーーる\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//よりお金を残して今と同等かそれ以下の襲撃数なら意味なし\n\t\t\t\t\t\t\tbool isOk = true;\n\t\t\t\t\t\t\tfor (int j = next.money + 1; j <= l; j++) {\n\t\t\t\t\t\t\t\tif (dp[j][i] >= 0 && dp[j][i] <= next.attacked) {\n\t\t\t\t\t\t\t\t\tisOk = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isOk) {\n\t\t\t\t\t\t\t\ts.push(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << min << std::endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint N,M,L;\npair<int,int> road[110][110];  //????????¢????????°???\nint dp[110][110];  //d[i][j]:?????????i,???????????????j?????¨????????????????????§?\\??????????????°??????°\n/*\nint dfs(int nowNode, int nowMoney, int nowPeople, set<int> state){\n  if(nowNode == N-1) return nowPeople;\n  if(dp[nowNode][nowMoney] != INF) return dp[nowNode][nowMoney];\n  int ret = INF;\n  state.insert(nowNode);\n  REP(nextNode,0,N){\n    if(road[nowNode][nextNode].F == INF || state.find(nextNode)!=state.end()) continue;\n    if(road[nowNode][nextNode].F <= nowMoney){\n      ret = min(ret,\n        min(dfs(nextNode,nowMoney,nowPeople + road[nowNode][nextNode].S, state),\n            dfs(nextNode,nowMoney-road[nowNode][nextNode].F,nowPeople, state)));\n    }else{\n      ret = min(ret,dfs(nextNode,nowMoney,nowPeople + road[nowNode][nextNode].S, state));\n    }\n  }\n  return dp[nowNode][nowMoney] = ret;\n}\n*/\n\nint main() {\n  while(1){\n    cin>>N>>M>>L;\n    if(N==0&&M==L&&L==0) break;\n    REP(i,0,N)REP(j,0,N)road[i][j]=make_pair(INF,INF);\n    REP(i,0,M){\n      int a,b,d,e;\n      cin>>a>>b>>d>>e;\n      road[a-1][b-1] = make_pair(d,e);\n      road[b-1][a-1] = make_pair(d,e);\n    }\n\n    REP(i,0,N)REP(j,0,L+1) dp[i][j] = INF;\n\n    /*\n    set<int> s;\n    cout<<dfs(0,L,0,s)<<endl;\n    */\n\n\n    priority_queue< pair< int ,pair<int,int> > > PQ; //?????°???<????????????????????????>\n    PQ.push(make_pair(0,make_pair(0,L)));\n    dp[0][L] = 0;\n\n    while(!PQ.empty()){\n      int nowNode = PQ.top().S.F;\n      int nowMoney = PQ.top().S.S;\n      int nowPeople = (-1)*PQ.top().F;\n      PQ.pop();\n\n      //test\n      //cout<<\"nowNode:\"<<nowNode<<\", nowMoney:\"<<nowMoney<<\", nowPeople:\"<<nowPeople<<endl;\n\n      if(dp[nowNode][nowMoney] < nowPeople) continue;\n      REP(nextNode,0,N){\n        if(road[nowNode][nextNode].F == INF) continue;\n        int nextMoney;\n        int nextPeople;\n        if(road[nowNode][nextNode].F <= nowMoney){\n          nextMoney = nowMoney - road[nowNode][nextNode].F;\n          nextPeople = nowPeople;\n          if(dp[nextNode][nextMoney] > nextPeople){\n            dp[nextNode][nextMoney] = nextPeople;\n            PQ.push(make_pair((-1)*dp[nextNode][nextMoney], make_pair(nextNode,nextMoney) ));\n            //test\n            //cout<<\"--- nextNode:\"<<nextNode<<\", nextPeople:\"<<nextPeople<<endl;\n          }\n        }\n        nextMoney = nowMoney;\n        nextPeople = nowPeople + road[nowNode][nextNode].S;\n        if(dp[nextNode][nextMoney] > nextPeople){\n          dp[nextNode][nextMoney] = nextPeople;\n          PQ.push(make_pair((-1)*dp[nextNode][nextMoney], make_pair(nextNode,nextMoney) ));\n          //test\n          //cout<<\"--- nextNode:\"<<nextNode<<\", nextPeople:\"<<nextPeople<<endl;\n        }\n      }\n    }\n    cout<<*min_element(dp[N-1],dp[N-1]+L+1)<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n) - 1; i >= k; i--)\n\n#define debug(x) cerr <<#x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pi pair<int,int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n#define tup tuple<long long,int,int>\n\ntypedef long long ll;\nconst ll inf = 900900900100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int MID = 255;\nusing namespace std;\n#define MAX_N 110\n\nint dp[110][100100] = {};\nint main(){\n    int n,m,l;\n    while(cin >> n >> m >> l,n) {\n        rep(i,110) rep(j,100100) dp[i][j] = 0;\n        vector<tup> E[MAX_N];\n        rep(i,m){\n            int a,b,d;\n            long long e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            E[a].pb(tup(e,b,d));\n            E[b].pb(tup(e,a,d));\n        }\n        priority_queue<tup,vector<tup>,greater<tup> > que;\n\n        ll d[MAX_N][110];\n        rep(i,MAX_N) rep(j,110) d[i][j] = inf;\n\n        rep(i,110) d[0][i] = 0;\n        que.push(tup(0,0,l));\n        while(!que.empty()) {\n            tup p = que.top();\n            que.pop();\n            ll cost = get<0>(p);\n            int v = get<1>(p);\n            int money = get<2>(p);\n            if (d[v][money] < cost) continue;\n            rep(i, E[v].size()) {\n                tup e = E[v][i];\n                //普通に動く\n                if (d[get<1>(e)][money] > d[v][money] + get<0>(e)) {\n                    d[get<1>(e)][money] = d[v][money] + get<0>(e);\n                    que.push(tup(d[get<1>(e)][money], get<1>(e),money));\n                }\n                //お金をはらう\n                if(get<2>(e) <= money) {\n                    if (d[get<1>(e)][money - get<2>(e)] > d[v][money]) {\n                        d[get<1>(e)][money - get<2>(e)] = d[v][money];\n                        que.push(tup(d[get<1>(e)][money - get<2>(e)], get<1>(e),money - get<2>(e)));\n                    }\n                }\n            }\n        }\n        ll ma = inf;\n        rep(i,l + 1){\n            ma = min(ma,d[n - 1][i]);\n        }\n        cout << ma << endl;\n        // cout << \"d[n-1] : \" << d[n - 1] << endl;\n        // int tt = n - 1;\n        // vector<int> WW;\n        // vector<int> VV;\n        // while(true) {\n        //     for(auto e : E[tt]) {\n        //         if(get<1>(e) == bv[tt]) {\n        //             WW.pb(get<2>(e));\n        //             VV.pb(get<0>(e));\n        //             break;\n        //         }\n        //     }\n        //     if(tt == 0) break;\n        //     tt = bv[tt];\n        // }\n\n\n        // REP(i, 1, l + 1) {\n        //     REP(j, 1, WW.size() + 1) {\n        //         dp[i][j] = dp[i][j - 1];\n        //         if( >= WW[j - 1]) {\n        //             dp[i][j] = max(dp[i][j - 1], dp[i - WW[j - 1]][j - 1] + VV[j - 1]);\n        //         }\n        //     }\n        // }\n        // cout << d[n - 1] - dp[l][WW.size()] << endl;\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define INF 1000000000\nusing namespace std;\ntypedef pair<int, int> pii;\n\nstruct edge { int n, d, e; };\nstruct state {\n  int n, l, s;\n  bool operator<(const state &state) const { return s > state.s; }\n};\n\nint main(void) {\n  int N, M, L;\n  while(cin >> N >> M >> L, N && M && L) {\n    vector<edge> G[100];\n\n    REP(i, 0, M) {\n      int A, B, D, E;\n      cin >> A >> B >> D >> E;\n      G[A - 1].push_back((edge) { B - 1, D, E });\n      G[B - 1].push_back((edge) { A - 1, D, E });\n    }\n\n    int dp[100][101];\n    REP(i, 0, N) REP(j, 0, L + 1) dp[i][j] = INF;\n    dp[0][0] = 1;\n\n    priority_queue<state> q;\n    q.push((state) { 0, 0, 0 });\n    while(q.size()) {\n      state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.l << \" \" << c.s << endl;\n\n      if(c.n == N - 1) {\n        cout << c.s << endl;\n        break;\n      }\n\n      if(dp[c.n][c.l] <= c.s) continue;\n      dp[c.n][c.l] = c.s;\n\n      REP(i, 0, G[c.n].size()) {\n        q.push((state) { G[c.n][i].n, c.l, c.s + G[c.n][i].e });\n        if(c.l + G[c.n][i].d <= L) {\n          q.push((state) { G[c.n][i].n, c.l + G[c.n][i].d, c.s });\n        }\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nstatic const int INF = 1E8;\nstruct Edge{int A, B, D, E;};\nint N, M, L;\nint A, B, D, E;\nvector<Edge> g[111];\nint d[111];\nvector<int> tmp(3);\n\ninline bool operator < (const Edge& v, const Edge& w)\n{\n  return v.E < w.E;\n}\n\nint main()\n{\n  while(cin >> N >> M >> L, N){\n    rep(i, 111) g[i].clear();\n    rep(i, M){\n      cin >> A >> B >> D >> E;\n      g[A - 1].push_back((Edge){A - 1, B - 1, D, E});\n      g[B - 1].push_back((Edge){B - 1, A - 1, D, E});\n    }\n\n    rep(i, 111) d[i] = INF;\n    d[0] = 0;\n    priority_queue<vector<int>, vector<vector<int> >, greater<vector<int> > > que;\n    tmp[0] = 0,  tmp[1] = 0,  tmp[2] = 0;\n    que.push(tmp);\n    while(!que.empty()){\n      vector<int> top = que.top();  que.pop();\n      int cnt = top[0];\n      int cost = top[1];\n      int h = top[2];\n      //if(d[h] > cnt) continue;\n      if(h == N - 1){\n        printf(\"%d\\n\", cnt);\n        break;\n      }\n      rep(i, g[h].size()){\n        Edge e = g[h][i];\n        tmp[2] = e.B;\n        if(cost <= L && d[e.B] >= cnt + e.E){\n          d[e.B] = cnt + e.E;\n          tmp[0] = cnt + e.E;\n          tmp[1] = cost;\n          que.push(tmp);\n        }\n        if(cost + e.D <= L && d[e.B] >= cnt){\n          d[e.B] = cnt;\n          tmp[0] = cnt;\n          tmp[1] = cost + e.D;\n          que.push(tmp);\n        }\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n\nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n\nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>,vector<pair<int,int>>,greater<pair<int,int>>> que; //cost v\n    que.push(make_pair(0, s));\n\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        \n        int cost = st.first;\n        \n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push(make_pair(d[to], to));\n            }\n        }\n    }\n    return d;\n}\n\nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for(int i=0;i<n;i++){\n            for(int j=1;j<=l;j++){\n                edge[vv(i,j)].push_back(make_pair(0,vv(i,j-1)));\n            }\n        }\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back(make_pair(e, vv(b, j)));\n                edge[vv(b, j)].push_back(make_pair(e, vv(a, j)));\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back(make_pair(0, vv(b, j - d)));\n                    edge[vv(b, j)].push_back(make_pair(0, vv(a, j - d)));\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = d[vv(n-1,0)];\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nint main() {\n    int N, M, L;\n    int a,b;\n    int now;\n    cin >> N >> M >> L;\n    for(;N!=0;){\n        vector<vector<bool>> graph(N,vector<bool>(N,false));\n        vector<vector<int>> distance(N,vector<int>(N)),evect(N,vector<int>(N));\n        //vector<vector<int>> dp(N,vector<int>(L+1,1000000000));\n        vector<vector<int>> dp_old(N,vector<int>(L+1,1000000000));\n        queue<int> vertex;\n        for(int i=0; i< M; i++){\n            cin >> a >> b;\n            a--;b--;\n            graph[a][b] = true; graph[b][a] = true;\n            cin >> distance[a][b] >> evect[a][b];\n            distance[b][a] = distance[a][b];\n            evect[b][a] = evect[a][b];\n        }\n        for(int i=0;i<=L;i++){\n            dp_old[0][i] = 0;\n            //dp[0][i] = 0;\n        }\n        for(int itr=0;itr<1;itr++){\n            vector<bool> reached(N,false);\n            reached[0] = true;\n            if(itr==0){\n                for(int i=0; i<N; i++){\n                    if(graph[0][i]){\n                        vertex.push(i);\n                        //graph[0][i] = false;\n                        //graph[i][0] = false;\n                        dp_old[i][L] = evect[0][i];\n                        //dp[i][L] = evect[0][i];\n                        if(L>=distance[0][i]){\n                            dp_old[i][L-distance[0][i]] = 0;\n                            //dp[i][L-distance[0][i]] = 0;\n                        }\n                    }\n                }\n            }else{\n                for(int i=0 ; i< N ; i++){\n                    if(graph[0][i]){\n                        vertex.push(i);\n                    }\n                }\n            }\n            for(;!vertex.empty();){\n                now = vertex.front();\n                reached[now] = true;\n                vertex.pop();\n                for(int i=1; i<N; i++){\n                    if(graph[now][i]){\n                        if(!reached[i])vertex.push(i);\n                        for(int j=0;j<=L; j++){\n                            if(j+distance[now][i]<=L){\n                                dp_old[now][j] = min(dp_old[now][j],min(dp_old[i][j]+evect[now][i],dp_old[i][j+distance[now][i]]));\n                                //dp_old[i][j] = min(dp_old[i][j],min(dp_old[now][j]+evect[now][i],dp_old[now][j+distance[now][i]]));\n                                //dp_old[now][j] = dp[now][j];\n                                //dp_old[i][j] = dp[i][j];\n                            }else{\n                                dp_old[now][j] = min(dp_old[i][j]+evect[now][i],dp_old[now][j]);\n                                //dp_old[i][j] = min(dp_old[now][j]+evect[now][i],dp_old[i][j]);\n                                //dp_old[now][j] = dp[now][j];\n                                //dp_old[i][j] = dp[i][j];\n                            }\n                        }\n                    }\n                }\n                //swap(dp,dp_old);\n            }\n        }\n        //swap(dp,dp_old);\n        int ans=dp_old[N-1][L];\n        for(int i=0; i<L ; i++){\n            ans=min(ans,dp_old[N-1][i]);\n        }\n        cout << ans << endl;\n\n        cin >> N >> M >>L;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<tuple>\n#include<functional>\n\nusing namespace std;\ntypedef tuple<int, int, int> T3i;\n\nstruct edge {\n\tint to, cost, dis;\n\tedge(int a, int b, int c) { to = a, cost = b, dis = c; }\n};\n\nint N, M, L;\nvector<vector<edge>> E;\nint d[100][101];\n\nvoid djkstra(int start) {\n\tpriority_queue<T3i, vector<T3i>, greater<T3i>> pq;\n\td[0][0] = 0;\n\tpq.push(make_tuple(0, 0, 0));\n\twhile (pq.size()) {\n\t\tauto now = pq.top(); pq.pop();\n\t\tif (d[get<2>(now)][get<1>(now)] < get<0>(now))continue;\n\n\t\tfor (int i = 0; i < E[get<2>(now)].size(); i++) {\n\t\t\tauto next = E[get<2>(now)][i];\n\t\t\tint budget = get<1>(now);\n\n\t\t\tif (budget + next.dis <= L && d[next.to][budget + next.dis] > get<0>(now)) {\n\t\t\t\t//予算を使う\n\t\t\t\td[next.to][budget + next.dis] = get<0>(now);\n\t\t\t\tpq.push(make_tuple(get<0>(now), budget + next.dis, next.to));\n\t\t\t}\n\n\t\t\tif (d[next.to][budget] > get<0>(now) + next.cost) {\n\t\t\t\t//予算を使わない\n\t\t\t\td[next.to][budget] = get<0>(now) + next.cost;\n\t\t\t\tpq.push(make_tuple(get<0>(now) + next.cost, budget, next.to));\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nint main() {\n\n\twhile (1) {\n\n\t\tfor (int i = 0; i < 100; i++)for (int j = 0; j <= 100; j++)d[i][j] = 999999999;\n\n\t\tcin >> N >> M >> L;\n\t\tif (N + M + L == 0)break;\n\t\tE.resize(N);\n\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--, b--;\n\t\t\tE[a].push_back(edge(b, d, c));\n\t\t\tE[b].push_back(edge(a, d, c));\n\t\t}\n\n\t\tdjkstra(0);\n\n\t\tint ans = 999999999;\n\t\tfor (int i = 0; i <= L; i++)ans = min(ans, d[N - 1][i]);\n\n\t\tcout << ans << endl;\n\n\t\tE.clear();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nusing tup = tuple<ll, int, int>;\nvector<tuple<int, int, int>> G[110]; // G[i] := i->j dist enemy\n//dist[i][j] := ??????0????????????i??? ????????????L??§????????¨????????????????¨????????°????\nint dist[110][110];\n\nint N, M, L;\n\nvoid dijkstra(int start){\n\trep(i, 110)rep(j, 110) dist[i][j] = INF;\n    priority_queue<tup, vector<tup>, greater<tup>> que; // ????????? ?????? ??????\n    dist[start][L] = 0;\n    que.push(make_tuple(0, start, L));\n    while(!que.empty()){\n        int cost, u, money;\n        tie(cost, u, money) = que.top(); que.pop();\n        // printf(\"cost %d u %d moeny %d\\n\", cost, u, money);\n        // if(dist[u][money] < cost) continue;\n        if(u == N - 1) break;\n        for(auto tm : G[u]){\n            int v, len, enemy;\n            tie(v, len, enemy) = tm;\n            // printf(\"v %d len %d enemy %d\\n\", v, len, enemy);\n            if(len > money){\n            \tif(cost + enemy < dist[v][money]){\n            \t\tdist[v][money] = cost + enemy;\n            \t\tque.push(make_tuple(dist[v][money], v, money));\n            \t}\n            }else{ //?????????\n            \tif(cost < dist[v][money - len]){\n            \t\t// printf(\"k\\n\");\n            \t\tdist[v][money - len] = cost;\n            \t\tque.push(make_tuple(dist[v][money - len], v, money - len));\n            \t}\n            \tif(cost + enemy < dist[v][money]){\n            \t\tdist[v][money] = cost + enemy;\n            \t\tque.push(make_tuple(dist[v][money], v, money));\n            \t}\n            }\n        }\n    }\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\", &N, &M, &L);\n\t\tif(N == 0) return 0;\n\t\trep(i, 110) G[i].clear();\n\n\t\trep(i, M){\n\t\t\tint a, b, d, e; scanf(\"%d %d %d %d\", &a, &b, &d, &e);\n\t\t\ta--, b--;\n\t\t\tG[a].pb(make_tuple(b, d, e)), G[b].pb(make_tuple(a, d, e));\n\t\t}\n\t\t// printf(\"dis\\n\");\n\t\tdijkstra(0);\n\t\tint ans = INF;\n\t\trep(i, L + 1) chmin(ans, dist[N - 1][i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\n\ntemplate<typename Edge>\nvector<Edge> make_v(size_t a, Edge b) {\n    return vector<Edge>(a, b);\n}\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\n#include <queue>\n#include <tuple>\nusing Edge = tuple<int, int, int>;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m, l;\n    while (cin >> n >> m >> l, n + m + l) {\n        vector<vector<Edge>> Graph(n);\n        REP(i, 0, m) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            Graph[a - 1].emplace_back(b - 1, d, e);\n            Graph[b - 1].emplace_back(a - 1, d, e);\n        }\n        const ll inf = 1LL << 60;\n        auto cost = make_v(n, l + 1, inf);\n        priority_queue<Edge, vector<Edge>, greater<Edge>> pq;\n        // cost, to, remains\n        pq.emplace(0, 0, l);\n        while (pq.size()) {\n            int c, to, pr;\n            tie(c, to, pr) = pq.top();\n            pq.pop();\n            if (cost[to][pr] < c) continue;\n            cost[to][pr] = c;\n            for (Edge &t : Graph[to]) {\n                int nto, dist, e;\n                tie(nto, dist, e) = t;\n                if (pr >= dist && cost[nto][pr - dist] > c) {\n                    cost[nto][pr - dist] = c;\n                    pq.emplace(c, nto, pr - dist);\n                }\n                if (cost[nto][pr] > c + e) {\n                    cost[nto][pr] = c + e;\n                    pq.emplace(c + e, nto, pr);\n                }\n            }\n        }\n        ll ans = inf;\n        REP(i, 0, l + 1) {\n            ans = min(ans, cost[n - 1][i]);\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\n#define NO_ROUTE 1000000\n\nusing namespace std;\n\nstruct edge {\n  //int n;\n  int tozoku;\n  int dist;\n};\n\nstruct node {\n  int n;\n  int money;\n\n  bool done;\n  int tozoku;\n  node (int n0 = 0, int money0 = 0, int done0 = false, int tozoku0 = 1000000) {\n    n = n0, money = money0, done = done0, tozoku = tozoku0;\n  }\n  bool operator<(const node &t)const {\n    return tozoku > t.tozoku;\n  }\n};\n\nint N, M, L;\nnode G[100][101];\nedge e[100][100];\n\nint search()\n{\n  priority_queue<node> que;\n  node start(0, L, true, 0);\n  G[0][L] = node(0, L, true, 0);\n  que.push(start);\n\n  while (!que.empty()) {\n    node n_node;\n    n_node = que.top();\n    G[n_node.n][n_node.money].done = true;\n    //cout << \"n \" << n_node.n << \" money \" << n_node.money << \" done \" << n_node.done << \" tozoku \" << n_node.tozoku << endl;\n    que.pop();\n    if (n_node.n == N - 1) return n_node.tozoku;\n    \n    for (int i = 0; i < N; i++) {\n      if (e[n_node.n][i].dist == NO_ROUTE) continue;\n      //////cout << \"dist \" << e[n_node.n][i].dist << endl;\n      if (!G[i][n_node.money].done) {\n\tif (n_node.tozoku + e[i][n_node.money].tozoku < G[i][n_node.money].tozoku) {\n\t  G[i][n_node.money] = node(i, n_node.money, false, n_node.tozoku + e[i][n_node.n].tozoku);\n\t  ////cout << n_node.tozoku << \" + \" << e[n_node.n][i].tozoku << endl;\n\t  node t_node = G[i][n_node.money];\n\t  que.push(t_node);\n\t}\n      }\n      if (n_node.money >= e[n_node.n][i].dist && !G[i][n_node.money - e[n_node.n][i].dist].done \n\t  && n_node.tozoku < G[i][n_node.money - e[n_node.n][i].dist].tozoku) {\n\tG[i][n_node.money - e[n_node.n][i].dist] = node(i, n_node.money - e[n_node.n][i].dist, false, n_node.tozoku);\n\tnode t_node = G[i][n_node.money - e[n_node.n][i].dist];\n\tque.push(t_node);\n      }\n    }\n  }\n  return -1;\n}\n\n\nint main()\n{\n  while (true) {\n    scanf(\"%d %d %d \", &N, &M, &L);\n    if (N == 0 && M == 0 && L == 0) break;\n    for (int i = 0; i < 100; i++) {\n      for (int j = 0; j < 100; j++) {\n\tG[i][j].n = i;\n\tG[i][j].money = j;\n\tG[i][j].tozoku = 1000000;\n\tG[i][j].done = false;\n\te[i][j].dist = NO_ROUTE;\n\te[i][j].tozoku = 0;\n      }\n    }\n    \n    for (int i = 0; i < 100; i++) {\n      G[i][100].tozoku = 1000000;\n      G[i][100].n = i;\n      G[i][100].done = false;\n      G[i][100].money = 100;\n    }\n    \n    for (int i = 0; i < M; i++) {\n      int x, y;\n      scanf(\"%d %d \", &x, &y);\n      x--, y--;\n      scanf(\"%d %d \", &e[x][y].dist, &e[x][y].tozoku);\n      e[y][x].dist = e[x][y].dist, e[y][x].tozoku = e[x][y].tozoku;\n    }\n    \n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n\t////cout << e[i][j].dist << \" \" << e[i][j].tozoku << \"   \";\n      }\n      ////cout << endl;\n    }\n\n    cout << search() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tvector<vector<pair<pair<int, int>,int>>> vvpii(n);\n\t\tREP(i, m) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tvvpii[a].push_back({ {c,d},b });\n\t\t\tvvpii[b].push_back({ { c,d },a });\n\t\t}\n\t\tpriority_queue<pair<pair<int, int>, int>> Q;\n\t\tQ.push({ {0,l},0 });\n\t\tvvi G(n,vi(l+1,1e9));\n\t\tG[0][l] = 0;\n\t\tint ans = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tpair<pair<int, int>, int> q = Q.top();Q.pop();\n\t\t\tq.first.first*=-1;\n\t\t\tif (q.second == n - 1) {\n\t\t\t\tans = q.first.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, vvpii[q.second].size()) {\n\t\t\t\t//used money\n\t\t\t\tif (q.first.second >= vvpii[q.second][i].first.first) {\n\t\t\t\t\tif (G[vvpii[q.second][i].second][q.first.second - vvpii[q.second][i].first.first]>q.first.first) {\n\t\t\t\t\t\tG[vvpii[q.second][i].second][q.first.second - vvpii[q.second][i].first.first] = q.first.first;\n\t\t\t\t\t\tQ.push({ {-q.first.first,q.first.second - vvpii[q.second][i].first.first },vvpii[q.second][i].second });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (G[vvpii[q.second][i].second][q.first.second]>q.first.first+ vvpii[q.second][i].first.second) {\n\t\t\t\t\tG[vvpii[q.second][i].second][q.first.second] = q.first.first + vvpii[q.second][i].first.second;\n\t\t\t\t\tQ.push({ { -q.first.first - vvpii[q.second][i].first.second,q.first.second},vvpii[q.second][i].second });\n\t\t\t\t}\n\t\t\t\t//secoi\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Graph{\n\tprivate:\n\tint n;\n\tvvp g;\n\tpublic:\n\tint DIJ(int s,int t){\n\t\tpriority_queue<P> q;\n\t\tvi d(n,inf);\n\t\td[s]=0;\n\t\tq.push({0,s});\n\t\twhile(!q.empty()){\n\t\t\tP p=q.top();\n\t\t\tq.pop();\n\t\t\tint v=p.second;\n\t\t\tif(d[v]<-p.first) continue;\n\t\t\tfor(auto i:g[v]){\n\t\t\t\tint u=i.first,D=d[v]+i.second;\n\t\t\t\tif(d[u]>D){\n\t\t\t\t\td[u]=D;\n\t\t\t\t\tq.push({-D,u});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d[t];\n\t}\n\tGraph(int v){\n\t\tn=v;\n\t\tg=vvp(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tg[s].push_back({t,c});\n\t}\n};\n\nint n,m,t;\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m>>t;\n\t\tif(!n) break;\n\t\tt++;\n\t\tGraph g(n*t);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v,c,d;\n\t\t\tcin>>u>>v>>c>>d;\n\t\t\tu--;v--;\n\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\tg.add_edge(u*t+j,v*t+j,d);\n\t\t\t\tg.add_edge(v*t+j,u*t+j,d);\n\t\t\t\tif(j>=c){\n\t\t\t\t\tg.add_edge(u*t+j,v*t+j-c,0);\n\t\t\t\t\tg.add_edge(v*t+j,u*t+j-c,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) for(int j=t-1;j>0;j--) g.add_edge(i*t+j,i*t+j-1,0);\n\t\tcout<<g.DIJ(t-1,n*t-t)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 150\n\nint x[MAX_N][MAX_N][2];\nint n, m, l, minx;\nint dp[MAX_N][MAX_N];\n\nint DP(int p, int v) {\n\tmemset(dp, 127, sizeof(dp));\n\tdp[0][l] = 0;\n\tfor (int i = 0; i < p; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (x[j][k][0] < 1000000) {\n\t\t\t\t\tfor (int l = 0; l <= v; l++) {\n\t\t\t\t\t\tif (dp[j][l] < 10000000) {\n\t\t\t\t\t\t\tdp[k][l] = min(dp[k][l], dp[j][l] + x[j][k][1]);\n\t\t\t\t\t\t\tif(l>=x[j][k][0]){\n\t\t\t\t\t\t\t\tdp[j][l - x[j][k][1]] = min(dp[k][l - x[j][k][1]], dp[j][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tminx = 1145141919;\n\tfor (int i = 0; i <= v; i++) {\n\t\tminx = min(minx, dp[p - 1][i]);\n\t}\n\treturn minx;\n}\n\nint a, b, c, d;\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m >> l;\n\t\tif (n == 0 && m == 0 && l == 0) { break; }\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tx[a][b][0] = c;\n\t\t\tx[a][b][1] = d;\n\t\t\tx[b][a][0] = c;\n\t\t\tx[b][a][1] = d;\n\t\t}\n\t\tcout << DP(n, l) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint cases = INF;\n\tREP(_, cases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tif (!N) { break; }\n\t\tstruct route { int to, dist, cost; };\n\t\tvevector<route> routes(N);\n\t\tREP(_, M)\n\t\t{ \n\t\t\tREAD(int, a, b, d, e);\n\t\t\troutes[a - 1].push_back({ b - 1, d, e });\n\t\t\troutes[b - 1].push_back({ a - 1, d, e });\n\t\t}\n\t\tstruct status { int cur, coin, cost; };\n\t\tpriority_queue<status, vector<status>, COMPARISON_T(status)> q(COMPARISON(status, a, b, a.cost > b.cost));\n\t\tq.push({ 0, L, 0 });\n\t\tint result = INF;\n\t\tvevector<bool> visited(N, L + 1);\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tstatus s = q.top(); q.pop();\n\t\t\tif (visited[s.cur][s.coin]) continue;\n\t\t\tvisited[s.cur][s.coin] = true;\n\t\t\tif (s.cur == N - 1) { result = s.cost; break; }\n\t\t\tfor (auto r : routes[s.cur])\n\t\t\t{\n\t\t\t\tif (s.coin >= r.dist) q.push({ r.to, s.coin - r.dist, s.cost });\n\t\t\t\tq.push({ r.to, s.coin, s.cost + r.cost });\n\t\t\t}\n\t\t}\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n    int a, b, dist, atk;\n    P(){}\n    ~P(){}\n    P(const P& r) : a(r.a), b(r.b), dist(r.dist), atk(r.atk) {}\n    P(int a, int b, int c, int d) : a(a), b(b), dist(c), atk(d) {}\n};\n\nconst int INF = 1<<29;\n\nvector<P> G;\nint dp[100][101];\n\nvoid append_edge(int& a, int& b, int& c, int& d){\n    G.push_back(P(a, b, c, d));\n}\n\nint N, M, L;\n\nint main(){\n    while(scanf(\"%d%d%d\", &N, &M, &L) && (N||M||L)){\n        int a, b, c, d;\n        G.clear();\n        for(int x = 0; x < N; x++){\n            fill(dp[x], dp[x]+L+1, INF);\n        }\n        for(int x = 0; x < M; x++){\n            scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n            append_edge(--a, --b, c, d); }\n        dp[0][0] = 0;\n        for(int x = 0; x < N; x++){\n            bool updated = false;\n            for(int v = 0; v < G.size(); v++){\n                int a = G[v].a, b = G[v].b,\n                    dist = G[v].dist, atk = G[v].atk;\n                for(int w = 0; w <= L; w++){\n                    if(dp[b][w] + atk < dp[a][w]){\n                        updated = true;\n                        dp[a][w] = dp[b][w] + atk;\n                    }\n                    if(dp[a][w] + atk < dp[b][w]){\n                        updated = true;\n                        dp[b][w] = dp[a][w] + atk;\n                    }\n                    if(w >= dist){\n                        if(dp[b][w-dist] < dp[a][w]){\n                            updated = true;\n                            dp[a][w] = dp[b][w-dist];\n                        }\n                        if(dp[a][w-dist] < dp[b][w]){\n                            updated = true;\n                            dp[b][w] = dp[a][w-dist];\n                        }\n                    }\n                }\n            }\n            if(!updated) break;\n        }\n        int min_atk = INF;\n        for(int x = 0; x <= L; x++){\n            min_atk = min(min_atk, dp[N-1][x]);\n        }\n        printf(\"%d\\n\", min_atk);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint map[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\n/*\nclass sState {\n\tint where\n*/\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\nbool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy < b.enemy;\n}\n\nbool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\t\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\nbool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\nvoid add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tchar tab = '\\t';\n\t\tcin >> n >> m >> l;\n\t\t//cout << \"Prob: \" << n << tab << m << tab << l << endl;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<=n; i++ ) {\n\t\t\tfor ( int j=0; j<=n; j++ ) {\n\t\t\t\tmap[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmap[a-1][b-1] = map[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\twhile( !status.empty() ) {\n\t\t\tstatus.pop() ;\n\t\t}\t\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//cout << \"E: \" << now.enemy << endl;\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<=n; i++ ) {\n\t\t\t\tif ( map[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\t//cout << \"PASSED\" << endl;\n\t\t\t\t\t\t//cout << now.where+1 << tab << i+1 << endl;\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\tstatus.push(State(i,now.enemy,now.budget));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - map[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\tstatus.push(State(i,now.enemy, now.budget - map[now.where][i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstatus.push(State(i,now.enemy+off[now.where][i], now.budget));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"C: \" << count << endl;\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<pair<int,pair<int,int> > > g[110];\nint ijk[110][110];\nint v[110][110];\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tfor(int i=0;i<110;i++)g[i].clear();\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tp--;q--;\n\t\t\tg[p].push_back(make_pair(q,make_pair(r,s)));\n\t\t\tg[q].push_back(make_pair(p,make_pair(r,s)));\n\t\t}\n\t\tfor(int i=0;i<110;i++){\n\t\t\tfor(int j=0;j<110;j++){\n\t\t\t\tv[i][j]=0;\n\t\t\t\tijk[i][j]=999999999;\n\t\t\t}\n\t\t}\n\t\tijk[0][c]=0;\n\t\tpriority_queue<pair<int,pair<int,int> > >Q;\n\t\tQ.push(make_pair(0,make_pair(0,c)));\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first;\n\t\t\tint at=Q.top().second.first;\n\t\t\tint has=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[at][has])continue;\n\t\t\tv[at][has]=1;\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(has>=g[at][i].second.first){\n\t\t\t\t\tif(!v[g[at][i].first][has-g[at][i].second.first]&&ijk[g[at][i].first][has-g[at][i].second.first]>cost){\n\t\t\t\t\t\tijk[g[at][i].first][has-g[at][i].second.first]=cost;\n\t\t\t\t\t\tQ.push(make_pair(-cost,make_pair(g[at][i].first,has-g[at][i].second.first)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!v[g[at][i].first][has]&&ijk[g[at][i].first][has]>cost+g[at][i].second.second){\n\t\t\t\t\tijk[g[at][i].first][has]=cost+g[at][i].second.second;\n\t\t\t\t\tQ.push(make_pair(-ijk[g[at][i].first][has],make_pair(g[at][i].first,has)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<=c;i++){\n\t\t\tret=min(ret,ijk[a-1][i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110][110];\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(memo[nokori][now]<=sum)return;\n  memo[nokori][now]=sum;\n  if(now==n){\n    ans=min(ans,sum);\n  }\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      used[E[now][i].to]=true;\n      if(nokori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n      for(int j=0;j<l+5;j++)\n\tmemo[j][i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\n#define NO_ROUTE 1000000\n\nusing namespace std;\n\nstruct edge {\n  //int n;\n  int tozoku;\n  int dist;\n};\n\nstruct node {\n  int n;\n  int money;\n\n  bool done;\n  int tozoku;\n  node (int n0 = 0, int money0 = 0, int done0 = false, int tozoku0 = 1000000) {\n    n = n0, money = money0, done = done0, tozoku = tozoku0;\n  }\n  bool operator<(const node &t)const {\n    return tozoku > t.tozoku;\n  }\n};\n\nint N, M, L;\nnode G[100][101];\nedge e[100][100];\n\nint search()\n{\n  priority_queue<node> que;\n  node start(0, L, true, 0);\n  G[0][L] = node(0, L, true, 0);\n  que.push(start);\n\n  while (!que.empty()) {\n    node n_node;\n    n_node = que.top();\n    G[n_node.n][n_node.money].done = true;\n    //cout << \"n \" << n_node.n << \" money \" << n_node.money << \" done \" << n_node.done << \" tozoku \" << n_node.tozoku << endl;\n    que.pop();\n    if (n_node.n == N - 1) return n_node.tozoku;\n    \n    for (int i = 0; i < N; i++) {\n      if (e[n_node.n][i].dist == NO_ROUTE) continue;\n      //////cout << \"dist \" << e[n_node.n][i].dist << endl;\n      if (!G[i][n_node.money].done) {\n\tif (n_node.tozoku + e[i][n_node.money].tozoku < G[i][n_node.money].tozoku) {\n\t  G[i][n_node.money] = node(i, n_node.money, false, n_node.tozoku + e[i][n_node.n].tozoku);\n\t  ////cout << n_node.tozoku << \" + \" << e[n_node.n][i].tozoku << endl;\n\t  node t_node = G[i][n_node.money];\n\t  que.push(t_node);\n\t}\n      }\n      if (n_node.money >= e[n_node.n][i].dist && !G[i][n_node.money - e[n_node.n][i].dist].done \n\t  && n_node.tozoku < G[i][n_node.money - e[n_node.n][i].dist].tozoku) {\n\tG[i][n_node.money - e[n_node.n][i].dist] = node(i, n_node.money - e[n_node.n][i].dist, false, n_node.tozoku);\n\tnode t_node = G[i][n_node.money - e[n_node.n][i].dist];\n\tque.push(t_node);\n      }\n    }\n  }\n  return -1;\n}\n\n\nint main()\n{\n  while (true) {\n    scanf(\"%d %d %d \", &N, &M, &L);\n    if (N == 0 && M == 0 && L == 0) break;\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n\tG[i][j].n = i;\n\tG[i][j].money = j;\n\t\n\te[i][j].dist = NO_ROUTE;\n\te[i][j].tozoku = 0;\n      }\n    }\n    for (int i = 0; i < 100; i++) {\n      G[i][100].n = i;\n      G[i][100].money = 100;\n    }\n    \n    for (int i = 0; i < M; i++) {\n      int x, y;\n      scanf(\"%d %d \", &x, &y);\n      x--, y--;\n      scanf(\"%d %d \", &e[x][y].dist, &e[x][y].tozoku);\n      e[y][x].dist = e[x][y].dist, e[y][x].tozoku = e[x][y].tozoku;\n    }\n    \n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n\t////cout << e[i][j].dist << \" \" << e[i][j].tozoku << \"   \";\n      }\n      ////cout << endl;\n    }\n\n    cout << search() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing T = tuple<int, int>;\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tstatic int dp[110][110];\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\tstatic int D[110][110], E[110][110];\n\t\tmemset(D, 0x3f, sizeof(D));\n\t\tmemset(E, 0x3f, sizeof(E));\n\t\trep(i, 0, M) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e;\n\t\t\ta--, b--;\n\t\t\tD[a][b] = D[b][a] = d;\n\t\t\tE[a][b] = E[b][a] = e;\n\t\t}\n\t\tqueue<T> q;\n\t\tq.emplace(0, L);\n\t\tdp[0][L] = 0;\n\t\twhile (q.size()) {\n\t\t\tint u, l; tie(u, l) = q.front(); q.pop();\n\t\t\trep(v, 0, N) {\n\t\t\t\tif (D[u][v] == INF)continue;\n\t\t\t\tif (D[u][v] <= l) {\n\t\t\t\t\tif (chmin(dp[v][l - D[u][v]], dp[u][l])) {\n\t\t\t\t\t\tq.emplace(v, l - D[u][v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (chmin(dp[v][l], dp[u][l] + E[u][v])) {\n\t\t\t\t\tq.emplace(v, l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 0, L + 1) {\n\t\t\tchmin(ans, dp[N - 1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151&lang=jp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\n\n\nstruct Edge{\n\tEdge(int f, int s, int w, int c){first = f; second = s; weight = w; cost=c;};\n\tint first;\n\tint second;\n\tint weight;\n\tint cost;\n};\n\nstruct NodeP{\n\tNodeP(){};\n\tNodeP(int i, int p, int w, int r){id = i; prev = p; weight = w; remain=r;}\n\tint id;\n\tint prev;\n\tint weight;\n\tint remain;\n\tbool operator<(const NodeP & inRhs) const{ return weight < inRhs.weight; }\n\tbool operator>(const NodeP & inRhs) const{ return weight > inRhs.weight; }\n};\n\n#define INF (1<<30)\nclass Graph{\npublic:\n\tGraph(int numnodes);\n\t//~Graph();\n\tvoid addEdge(Edge a);\n\tvoid addEdge_nonDirect(Edge e);\n\tstd::vector<NodeP> dijkstra(int start, int costLimit);\n\tint numNodes;\n\t//Edge *adj;\n\tstd::vector < std::vector<Edge> > adj;\n};\nGraph::Graph(int n){\n\tnumNodes = n;\n\t//adj = (Edge *)malloc(sizeof(Edge)*n*n);\n\tadj.resize(n);\n}\nvoid Graph::addEdge(Edge e){\n\t//adj[ e.first * numNodes + e.second ] = e;\n\tadj[e.first].push_back(e);\n}\nvoid Graph::addEdge_nonDirect(Edge e){\n\tadj[e.first].push_back(e);\n\tEdge e2 = e;\n\te2.first = e.second;\n\te2.second = e.first;\n\tadj[e2.first].push_back(e2);\n}\nstd::vector<NodeP> Graph::dijkstra(int start, int costLimit){\n\t//using P = pair<int , int>;\n\tint *cost = (int *)malloc(sizeof(int)*numNodes);\n\tchar *flag = (char *)malloc(sizeof(char)*numNodes);\n\tfor(int i=0;i<numNodes;i++) flag[i] = 0;\n\tfor(int i=0;i<numNodes;i++) cost[i] = INF;\n\tcost[start]=0;\n\tstd::priority_queue < NodeP ,std::vector<NodeP>, std::greater<NodeP> > Q;\n\tQ.push(NodeP(start,-1, 0, costLimit));\n\tstd::vector <NodeP> nodeps(numNodes,NodeP(-1,-1,-1,-1));\n\n\twhile( !Q.empty() ){\n\t\tNodeP node = Q.top();\n\t\tQ.pop();\n\t\tif( flag[node.id] == 1 ) continue;\n\t\tflag[node.id] = 1;\n\t\tcost[node.id] = node.weight;\n\t/*\tif(node.prev >= numNodes/2) printf(\"--- %3d'->\",node.prev-numNodes/2);\n\t\telse printf(\"--- %3d ->\",node.prev);\n\t\tif(node.id >= numNodes/2) printf(\"%3d'\",node.id-numNodes/2);\n\t\telse printf(\"%3d \",node.id);\n\t*/\n\t//\tprintf(\"%d->%d\\n\",node.prev,node.id);\n\t//\tprintf(\"thief:%d remain:%d\\n\",node.weight,node.remain);\n\t\tnodeps[node.id] = node;\n\n\t\ttypedef std::vector<Edge>::iterator ITR;\n\t\tfor( ITR itr = adj[node.id].begin(); itr !=adj[node.id].end(); itr++ ){\n\t\t\tint dis = node.weight + itr->weight;\n\t\t\tint remain = node.remain - itr->cost;\n\t\t\tif( cost[itr->second] > dis && remain >= 0){\n\t\t\t\tQ.push(NodeP(itr->second, node.id, dis, remain));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfree(cost);\n\tfree(flag);\n\n\treturn nodeps;\n}\n\n\n\nusing namespace std;\n\n\nint main(int argc ,char **argv){\n\n\tint numNode, numEdge, limitCost;\n\n\tcin >> numNode >>  numEdge >> limitCost;\n\n\twhile( numNode!=0 && numEdge!=0 &&  limitCost!=0 ){\n\t\t//cout << numNode <<\",\"<< numEdge <<\",\"<< limitCost<<endl;\n\t\tint *nodeS = (int *)malloc(sizeof(int) * numEdge);\n\t\tint *nodeE = (int *)malloc(sizeof(int) * numEdge);\n\t\tint *cost  = (int *)malloc(sizeof(int) * numEdge);\n\t\tint *thief = (int *)malloc(sizeof(int) * numEdge);\n\t\tfor(int i=0;i< numEdge ;i++){\n\t\t\tcin >> nodeS[i] >> nodeE[i] >> cost[i] >> thief[i];\n\t\t}\n\n\t\tGraph g((numNode+1)*2);\n\n\t\tfor(int i=0;i<numEdge;i++){\n\t\t\tg.addEdge_nonDirect(Edge( nodeS[i]          , nodeE[i]           , thief[i] , 0 ));\n\t\t\tg.addEdge_nonDirect(Edge( nodeS[i]          , nodeE[i]+numNode+1 , 0        , cost[i] ));\n\t\t\tg.addEdge_nonDirect(Edge( nodeS[i]+numNode+1, nodeE[i]           , thief[i] , 0  ));\n\t\t\tg.addEdge_nonDirect(Edge( nodeS[i]+numNode+1, nodeE[i]+numNode+1 , 0        , cost[i] ));\n\t\t\t//g.addEdge_nonDirect(Edge( nodeS[i], nodeS[i]+numNode+1 , 0 , 0 ));\n\t\t\t//g.addEdge_nonDirect(Edge( nodeE[i], nodeE[i]+numNode+1 , 0 , 0 ));\n\t\t}\n\n\t\tvector<NodeP> nodeps = g.dijkstra(1, limitCost);\n\t\ttypedef std::vector<NodeP>::iterator ITR;\n\t\tint min_thief=INF;\n\t\tfor( int i=0;i<(numNode+1)*2;i++ ){\n\t\t\t//printf(\"1:%d -> %d thief:%d remain:%d\\n\",nodeps[i].prev,nodeps[i].id,nodeps[i].weight,nodeps[i].remain);\n\t\t\tif( nodeps[i].id == numNode || nodeps[i].id == numNode*2+1 ) min_thief = min(min_thief , nodeps[i].weight);\n\t\t}\n\t\t//min_thief =  min( nodeps[numNode].weight , nodeps[numNode*2+1].weight );\n\t\tnodeps = g.dijkstra(1+numNode+1, limitCost);\n\t\ttypedef std::vector<NodeP>::iterator ITR;\n\n\t\tfor( int i=0;i<(numNode+1)*2;i++ ){\n\t\t//\tprintf(\"2:%d -> %d thief:%d remain:%d\\n\",nodeps[i].prev,nodeps[i].id,nodeps[i].weight,nodeps[i].remain);\n\t\t\tif( nodeps[i].id == numNode || nodeps[i].id == numNode*2+1 ) min_thief = min(min_thief , nodeps[i].weight);\n\t\t}\n\t\t//min_thief =  min( min_thief , min( nodeps[numNode].weight , nodeps[numNode*2+1].weight ) );\n\t\tprintf(\"%d\\n\",min_thief);\n\n\t\tfree( nodeS );\n\t\tfree( nodeE );\n\t\tfree( cost  );\n\t\tfree( thief );\n\t\tcin >> numNode >> numEdge >>  limitCost;\n\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#define MD 150\n#define P pair<int,int> // 人数, 予算*MD+ノード\nusing namespace std;\n\nstruct Path{\n  int to,d,n;\n  Path(int to=0,int d=0,int n=0):to(to),d(d),n(n){};\n};\n\n\nint main(){\n  int N,m,l;\n  int a,b,d,e;\n\n  while( cin>>N>>m>>l && (N|m|l) ){\n    vector<Path> v[110];\n    for( int i=0;i<m;i++ ){\n      cin>>a>>b>>d>>e;\n      a--; b--;\n      v[a].push_back( Path(b,d,e) );\n      v[b].push_back( Path(a,d,e) );\n    }\n    /*\n    for( int i=0;i<N;i++ ){\n      for( unsigned int j=0;j<v[i].size();j++ )\n\tcout << \" \" << v[i][j].to+1;\n      cout << endl;\n    }\n    */\n\n    priority_queue<P,vector<P>,greater<P> > q;\n    \n    int dL = 110*MD+100 +100;\n    int d[ dL  ]; // [ノード*MD+予算]での最小人数\n    const int iniC = 100*10000 * 10;\n    for( int i=0,len=dL;i<len;i++ )\n      d[i] = iniC;\n    \n    // 人数、残り予算*MD+ノード\n    q.push( P(0,l*MD+0) );\n    int ans=-1;\n    while( !q.empty() ){\n      P p=q.top(); q.pop();\n      int n=p.first; // 人数\n      int l=p.second/MD; //残り予算\n      int s=p.second%MD; // 現在のノード\n\n      if( s==N-1 ){\n\tans = n; break;\n      }\n\n      for( unsigned int i=0;i<v[s].size();i++ ){\n\tint ns=v[s][i].to;\n\tif( l>=v[s][i].d ){ // 護衛を雇う場合\n\t  int nl = l-v[s][i].d;\n\t  int state = nl*MD+ns;\n\n\t  if( n<d[state] )\n\t    q.push( P(d[state]=n,state) );\n\t}\n\t// 護衛を雇わない場合\n\tint nn = n + v[s][i].n;\n\tint state = l*MD+ns;\n\tif( nn< d[state] )\n\t  q.push( P(d[state]=nn,state) );\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n\n#include<iomanip>\n#include<vector>\n#include<string>\n#include<queue>\n#include<stack>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntypedef long long LL;\ntemplate<typename T>\nbool chmin(T &l, T r){\n\tbool f = l>r; if (f)l = r; return f;\n}\ntemplate<typename T>\nbool chmax(T &l, T r){\n\tbool f = l<r; if (f)l = r; return f;\n}\ntypedef vector<LL> V;\ntypedef vector<V> VV;\n\n\nint a[11234];\nint b[11234];\nint d[11234];\nLL e[11234];\ntypedef tuple<LL, int, int> TT;\n#define DCtt(v,l,c,x) LL c;int v,l;tie(c,v,l)=x;c*=-1;\nconst LL INF = 1e15;\nLL dijkstra(int s, int t,int L, VV &g){\n\tint N = g.size();\n\tVV dist(N, V(L + 1, INF));\n\tpriority_queue<TT> que;\n\tque.push(TT(0, s, L));\n\tdist[s][L] = 0;\n\twhile (que.size()){\n\t\tDCtt(v, l, cost, que.top()); que.pop();\n\t\tif (v == t){\n\t\t\twhile (que.size())que.pop();\n\t\t\treturn cost;\n\t\t}\n\t\tif (dist[v][l] < cost)continue;\n\t\tfor (auto &ee : g[v]){\n\t\t\tint u = v^a[ee] ^ b[ee];\n\t\t\tif (d[ee] <= l){\n\t\t\t\tint nxt_l = l - d[ee];\n\t\t\t\tLL nxt_cost = cost;\n\t\t\t\tif (chmin(dist[u][nxt_l], nxt_cost)){\n\t\t\t\t\tque.push(TT(-nxt_cost, u, nxt_l));\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint nxt_l = l;\n\t\t\t\tLL nxt_cost = cost+e[ee];\n\t\t\t\tif (chmin(dist[u][nxt_l], nxt_cost)){\n\t\t\t\t\tque.push(TT(-nxt_cost, u, nxt_l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint N,M,L;\n\twhile (cin>>N>>M>>L,N+M+L){\n\t\tVV g(N);\n\t\tREP(i, M){\n\t\t\tcin >> a[i] >> b[i] >> d[i] >> e[i];\n\t\t\ta[i]--; b[i]--;\n\t\t\tg[a[i]].push_back(i);\n\t\t\tg[b[i]].push_back(i);\n\n\t\t}\n\t\tcout << dijkstra(0, N - 1, L, g) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct road\n{\n\tint to, cost, k;//???????????????????????????\n};\nvector<road>rinsetu[100];\nint mincost[100][101];//i??°??????j????????£?????????\nstruct A\n{\n\tint x, y, z;//??´????????????????????????\n};\nbool operator <(A b, A c) {\n\tif (b.z != c.z)return b.z > c.z;\n\treturn b.x * 1000 + b.y > c.x * 1000 + c.y;\n}\nsigned main() {\n\tint a, b, c;\n\twhile (scanf(\"%d%d%d\", &a, &b, &c), a || b || c) {\n\t\tfor (int d = 0; d < a; d++) {\n\t\t\trinsetu[d].clear();\n\t\t}\n\t\tfor (int d = 0; d < b; d++) {\n\t\t\tint e, f, g, h; scanf(\"%d%d%d%d\", &e, &f, &g, &h);\n\t\t\te--; f--;\n\t\t\trinsetu[e].push_back({ f,g,h });\n\t\t\trinsetu[f].push_back({ e,g,h });\n\t\t}\n\t\tmemset(mincost, 0x3f, sizeof(mincost));\n\t\tmincost[0][c] = 0;\n\t\tpriority_queue<A>Q;\n\t\tQ.push({0,c,0});\n\t\twhile (Q.size()) {\n\t\t\tA d = Q.top(); Q.pop();\n\t\t\tcout << d.x << \" \" << d.y << \" \" << d.z << endl;\n\t\t\tif (d.z > mincost[d.x][d.y])continue;\n\t\t\tfor (road i : rinsetu[d.x]) {\n\t\t\t\t//?????????????????????\n\t\t\t\tif (mincost[i.to][d.y] > d.z + i.k) {\n\t\t\t\t\tmincost[i.to][d.y] = d.z + i.k;\n\t\t\t\t\tQ.push({i.to,d.y,d.z + i.k });\n\t\t\t\t}\n\t\t\t\t//???????????????\n\t\t\t\tif (d.y >= i.cost) {\n\t\t\t\t\tif (mincost[i.to][d.y - i.cost] > d.z) {\n\t\t\t\t\t\tmincost[i.to][d.y - i.cost] = d.z;\n\t\t\t\t\t\tQ.push({ i.to, d.y - i.cost, d.z });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint MIN = 1 << 29;\n\t\tfor (int i = 0; i <= c; i++) {\n\t\t\tMIN = min(MIN, mincost[a-1][i]);\n\t\t}\n\t\tprintf(\"%d\\n\", MIN);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define INF 1e9\n\nstruct edge{int to, dist, enem;};\n\nint main() {\n    int n, m, l;\n    while (cin >> n >> m >> l && n){\n        vector<vector<edge> > es(n);\n        while (m--){\n            int a, b, d, e;\n            scanf(\"%d %d %d %d\", &a, &b, &d, &e);\n            a--;\n            b--;\n            edge eg;\n            eg.to = b;\n            eg.dist = d;\n            eg.enem = e;\n            es[a].push_back(eg);\n            eg.to = a;\n            es[b].push_back(eg);\n        }\n        VVI d(n,VI(l+1,INF));\n        d[0][l] = 0;\n        priority_queue<pair<int,P>, vector<pair<int,P> >, greater<pair<int,P> > > q;\n        q.push(make_pair(0, P(0, l)));\n        while (!q.empty()){\n            pair<int,P> a = q.top();\n            q.pop();\n            int now = a.second.first, mon = a.second.second;\n            if(d[now][mon] < a.first) continue;\n            REP(i,es[now].size()){\n                edge e = es[now][i];\n                int next = e.to, dist = e.dist;\n                if (mon >= dist && d[next][mon-dist] > d[now][mon]){\n                    d[next][mon-dist] = d[now][mon];\n                    q.push(make_pair(d[next][mon-dist], P(next, mon-dist)));\n                }\n                if (d[next][mon] > d[now][mon] + e.enem){\n                    d[next][mon] = d[now][mon] + e.enem;\n                    q.push(make_pair(d[next][mon], P(next, mon)));\n                }\n            }\n        }\n        int ans = INF;\n        REP(i,l+1) ans = min(ans, d[n-1][i]);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <map>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(v) (v).rbegin(), (v).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nstruct edge{\n\tint to;\n\tint money;\n\tint enemy;\n\tedge(int t, int m, int e):to(t),money(m),enemy(e){}\n\tbool operator<(const edge &r) const{\n\t\treturn enemy > r.enemy;\n\t}\n};\n\nint main(){\n\tint n, m, l;\n\twhile(cin >> n >> m >> l, n|m|l){\n\t\tvector<vector<edge> > G(n);\n\t\trep(i, m){\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--, b--;\n\t\t\tG[a].push_back(edge(b, d, e));\n\t\t\tG[b].push_back(edge(a, d, e));\n\t\t}\n\n\t\tpriority_queue<edge> q;\n\t\tq.push(edge(0, l, 0));\n\n\t\tvector<vi> visit(n, vi(l+1, 0)); // visit[pos][money]\n\n\t\twhile(!q.empty()){\n\t\t\tedge s = q.top();\n\t\t\tq.pop();\n\n\t\t\t//cout << \"pos=\" << s.to << \", money=\" << s.money << \", enemy=\" << s.enemy << endl;\n\n\t\t\tif(visit[s.to][s.money]) continue;\n\t\t\tvisit[s.to][s.money] = 1;\n\n\t\t\tif(s.to == n-1){\n\t\t\t\tcout << s.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, G[s.to].size()){\n\t\t\t\tif(G[s.to][i].money <= s.money){\n\t\t\t\t\tedge next = s;\n\t\t\t\t\tnext.money -= G[s.to][i].money;\n\t\t\t\t\tnext.to = G[s.to][i].to;\n\t\t\t\t\tif(!visit[next.to][next.money]){\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedge next = s;\n\t\t\t\tnext.enemy += G[s.to][i].enemy;\n\t\t\t\tnext.to = G[s.to][i].to;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<vector>\n\n#define pb push_back\n#define fs first\n#define sc second\n#define INF 500000000\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P > P2;\n\nint n,m,l;\nint num[110][110];\n\nint main(){\n  while(scanf(\"%d %d %d\",&n,&m,&l) && (n||m||l)){\n    vector<int> to[110],d[110],e[110];\n\n    for(int i=0;i<m;i++){\n      int a,b,dis,en;\n      scanf(\"%d %d %d %d\",&a,&b,&dis,&en);\n      to[a].pb(b);\n      d[a].pb(dis);\n      e[a].pb(en);\n      to[b].pb(a);\n      d[b].pb(dis);\n      e[b].pb(en);\n    }\n\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<=l;j++){\n\tnum[i][j] = INF;\n      }\n    }\n\n    num[1][l] = 0;\n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    q.push(P2(0,P(1,l)));\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int en = p.fs, pos = p.sc.fs, mon = p.sc.sc;\n\n      for(int i=0;i<(int)to[pos].size();i++){\n\tint next = to[pos][i];\n\tif(d[pos][i] <= mon){\n\t  int rem = mon - d[pos][i];\n\t  if(num[next][rem] > en){\n\t    num[next][rem] = en;\n\t    q.push(P2(num[next][rem],P(next,rem)));\n\t  }\n\t}\n\tint enemy = en + e[pos][i];\n\tif(num[next][mon] > enemy){\n\t  num[next][mon] = enemy;\n\t  q.push(P2(enemy,P(next,mon)));\n\t}\n      }\n    }\n  \n    int ans = INF;\n    for(int i=0;i<=l;i++)ans = min(ans,num[n][i]);\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nclass Edge {\npublic:\n    int next;\n    int dist;\n    int weight;\n    Edge() {}\n    Edge(int n, int d, int w) {\n\tnext = n;\n\tdist = d;\n\tweight = w;\n    }\n};\n\nclass Info {\npublic:\n    int node;\n    int dist;\n    int left;\n    Info(int n, int d, int l) {\n\tnode = n;\n\tdist = d;\n\tleft = l;\n    }\n    bool operator< (const Info &a) const {\n\tif (dist == a.dist && node == a.node) return left < a.left;\n\treturn dist > a.dist;\n    }\n};\n\nint dist[100][110];\nvector<vector<Edge>> nexts;\n\nsigned main() {\n    int N, M, L;\n    while (cin >> N >> M >> L) {\n\tif (N == 0) break;\n\n\tnexts.clear();\n\tnexts.resize(N);\n\trep(i, 100) rep(j, 101) dist[i][j] = INT_MAX;\n\n\tint A, B, D, E;\n\trep(i, M) {\n\t    cin >> A >> B >> D >> E;\n\t    A--; B--;\n\t    nexts[A].push_back(Edge(B, D, E));\n\t    nexts[B].push_back(Edge(A, D, E));\n\t}\n\n\tpriority_queue<Info> q;\n\tq.push(Info(0, 0, L));\n\trep(i, 101) dist[0][i] = 0;\n\twhile (!q.empty()) {\n\t    Info info = q.top(); q.pop();\n\t    if (info.dist > dist[info.node][info.left]) continue;\n\t    if (info.node == N - 1) {\n\t\tcout << info.dist << endl;\n\t\tbreak;\n\t    }\n\t    for (Edge &edge : nexts[info.node]) {\n\t\tif (info.left >= edge.dist && edge.weight > 0) {\n\t\t    if (dist[edge.next][info.left - edge.dist] > info.dist) {\n\t\t\tREP(i, 0, info.left - edge.dist) {\n\t\t\t    if (info.dist >= dist[edge.next][i]) break;\n\t\t\t    dist[edge.next][i] = info.dist;\n\t\t\t}\n\t\t\tq.push(Info(edge.next, info.dist, info.left - edge.dist));\n\t\t    }\n\t\t}\n\t\tint ndist = info.dist + edge.weight;\n\t\tif (dist[edge.next][info.left] > ndist) {\n\t\t    REP(i, 0, info.left) {\n\t\t\tif (dist[edge.next][i] >= ndist) break;\n\t\t\tdist[edge.next][i] = ndist;\n\t\t    }\n\t\t    q.push(Info(edge.next, ndist, info.left));\n\t\t}\n\t    }\n\t}\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nbool operator==(const State& lhs, const State& rhs)\n{\n    return lhs.loc == rhs.loc && lhs.money == rhs.money && lhs.damage == rhs.damage;\n}\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<int> memo(101, INT_MAX);\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (memo[current.loc] == current.money) {\n                continue;\n            }\n            memo[current.loc] = current.money;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (e.dist <= current.money) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint N, M, L;\n\nstruct edge {\n\tint to, distance, enemy;\n};\n\nstruct P {\n\tint from, money, enemy;\n\t\n\tbool operator >(const P& p) const {\n\t\treturn enemy > p.enemy;\n\t}\n};\n\nstruct city {\n\tint money, enemy;\n};\n\nint main() {\n\twhile (cin >> N >> M >> L, N|M|L) {\n\t\tvector<vector<edge> > E(N);\n\t\tint a, b, d, e;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tE[a-1].push_back({b, d, e});\n\t\t\tE[b-1].push_back({a, d, e});\n\t\t}\n\t\t\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tcity arr[N];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tarr[i].money = 0;\n\t\t\t// arr[i].enemy = ;\n\t\t}\n\t\tq.push((P){0, L, 0});\n\t\t\twhile(!q.empty()) {\n\t\t\tP p = q.top(); q.pop();\n\t\t\t// goal\n\t\t\tif (p.from == N-1) {\n\t\t\t\tcout << p.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < E[p.from].size(); i++) {\n\t\t\t\tif (p.money >= arr[p.from].money) {\n\t\t\t\t\tarr[p.from].money = p.money;\n\t\t\t\t\tarr[p.from].enemy = p.enemy;\n\t\t\t\t} else if (p.enemy <= arr[p.from].enemy) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tedge e = E[p.from][i];\n\t\t\t\tq.push((P){e.to-1, p.money, p.enemy+e.enemy});\n\t\t\t\tif (p.money-e.distance >= 0) {\n\t\t\t\t\tq.push((P){e.to-1, p.money-e.distance, p.enemy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  for(;;){\n    int n,m,l;\n    cin >> n >> m >> l;\n    if(!n) return 0;\n    vector<vector<tuple<int,int,int> > > ed(n+1);\n    REP(i,m){\n      int a,b,d,e;\n      cin >> a >> b >> d >> e;\n      ed[a].push_back(make_tuple(b,d,e));\n      ed[b].push_back(make_tuple(a,d,e));\n    }\n    vector<map<int,int> > cost(n+1);\n    //cost[pos][left]=e;\n    priority_queue<tuple<int,int,int> > dijk;\n    //nege,pos,left\n    dijk.push(make_tuple(0,1,l));\n    while(!dijk.empty()){\n      int nege,pos,left;\n      tie(nege,pos,left)=dijk.top();\n      dijk.pop();\n      if(cost[pos].count(left)) continue;\n      cost[pos][left]=-nege;\n      REP(i,ed[pos].size()){\n\tint to,d,e;\n\ttie(to,d,e)=ed[pos][i];\n\tdijk.push(make_tuple(nege-e,to,left));\n\tif(left>=d) dijk.push(make_tuple(nege,to,left-d));\n      }\n    }\n    int answer=33554432;\n    REP(i,l+1) if(cost[n].count(i)) answer=min(answer,cost[n][i]);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n/*\nN M L\nA1 B1 D1 E1\nA2 B2 D2 E2\n...\nAN BN DN EN\n*/\n\nconst int size = 101;\nint A[size][size]; // adjacent\nint AC[size];\nint D[size][size]; // distance\nint E[size][size]; // enemy\n\nint n, m, l;\n\nvoid init() {\n    for ( int i = 0; i < size; i++ ) {\n        AC[i] = 0;\n    }\n}\n\ntypedef pair <int, int> PII;\ntypedef pair <PII, int> Node;\ntypedef priority_queue <Node, vector <Node>, greater <Node> > Queue;\nint MD[size];\n\nint solve() {\n    Queue Q;\n    Node start( Node( PII( 0, 0 ), 0 ) );\n    Q.push( start );\n    for ( int i = 0; i < size; i++ ) MD[i] = 1<<24;\n    MD[0] = 0;\n\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        int dam = node.first.first;\n        int mon = node.first.second;\n        int pos = node.second;\n\n        if ( pos == n-1 ) {\n            return dam;\n        }\n\n        for ( int i = 0; i < AC[pos]; i++ ) {\n            int next_pos = A[pos][i];\n            {\n                int next_dam = dam + E[pos][next_pos];\n                if ( next_dam < MD[next_pos] ) {\n                    MD[next_pos] = next_dam;\n                    int next_mon = mon;\n                    Node next_node( PII( next_dam, next_mon ), next_pos );\n                    Q.push( next_node );\n                }\n            }\n            if ( mon + D[pos][next_pos] <= l ) {\n                int next_dam = dam;\n                if ( next_dam < MD[next_pos] ) {\n                    MD[next_pos] = next_dam;\n                    int next_mon = mon + D[pos][next_pos];\n                    Node next_node( PII( next_dam, next_mon ), next_pos );\n                    Q.push( next_node );\n                }\n            }\n        }\n    }\n\n    return 1<<28;\n}\n\nint main() {\n    while ( cin >> n >> m >> l ) {\n        if ( n == 0 && m == 0 && l == 0 ) break;\n\n        init();\n\n        for ( int i = 0; i < m; i++ ) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            A[a][AC[a]++] = b;\n            A[b][AC[b]++] = a;\n            D[a][b] = D[b][a] = d;\n            E[a][b] = E[b][a] = e;\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct State {\n  int pos, money, cost;\n  State(int pos,int money,int cost) : pos(pos), money(money), cost(cost) {;}\n  State() {;}\n  bool operator<(const State s) const {\n    return cost > s.cost;\n  }\n};\n\n\nconst int INF = 1000000000;\nint n,m,l,a,b,d,e;\n\nint main() {\n  while(cin>>n>>m>>l, n|m|l) {\n    l++;\n    int cost[n][l], d[n][n], e[n][n];\n    bool visited[n][l];\n    for(int i=0; i<n; ++i) {\n      for(int j=0; j<n; ++j)\n\td[i][j] = e[i][j] = INF;\n\n      for(int j=0; j<l; ++j) {\n\tcost[i][j] = INF;\n\tvisited[i][j] = false;\n      }\n    }\n\n    for(int i=0; i<m; ++i) {\n      int f,to;\n      cin>>f>>to;\n      f--,to--;\n      cin>>d[f][to]>>e[f][to];\n      d[to][f] = d[f][to];\n      e[to][f] = e[f][to];\n    }\n\n    cost[0][l-1] = 0;\n    State s(0,l-1,0);\n\n    priority_queue<State> Q;\n    Q.push(s);\n\n    while(!Q.empty()) {\n      s = Q.top(); Q.pop();\n      int nc = s.cost, pos = s.pos, mo = s.money;\n      if(visited[pos][mo]) continue;\n      visited[pos][mo] = true;\n\n      for(int i=0; i<n; ++i) {\n\tif(d[pos][i] <= mo && nc < cost[i][mo-d[pos][i]]) {\n\t  State next(i, mo-d[pos][i], nc);\n\t  cost[i][mo-d[pos][i]] = nc;\n\t  Q.push(next);\n\t}\n\tif(nc + e[pos][i] < cost[i][mo]) {\n\t  cost[i][mo] = nc + e[pos][i];\n\t  State next(i, mo, cost[i][mo]);\n\t  Q.push(next);\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0; i<l; ++i) {\n      ans = min(ans, cost[n-1][i]);\n    }\n\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 150\n\nint x[MAX_N][MAX_N][2];\nint n, m, l, minx;\nint dp[MAX_N][MAX_N];\n\nint DP(int p, int v) {\n\tmemset(dp, 127, sizeof(dp));\n\tdp[0][v] = 0;\n\tfor (int i = 0; i < p; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (x[j][k][0] < 1000000) {\n\t\t\t\t\tfor (int l = 0; l <= v; l++) {\n\t\t\t\t\t\tif (dp[j][l] < 10000000) {\n\t\t\t\t\t\t\tdp[k][l] = min(dp[k][l], dp[j][l] + x[j][k][1]);\n\t\t\t\t\t\t\tif(l>=x[j][k][0]){\n\t\t\t\t\t\t\t\tdp[k][l - x[j][k][0]] = min(dp[k][l - x[j][k][0]], dp[j][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tminx = 1145141919;\n\tfor (int i = 0; i <= v; i++) {\n\t\tminx = min(minx, dp[p - 1][i]);\n\t}\n\treturn minx;\n}\n\nint a, b, c, d;\n\nint main() {\n\twhile (true) {\n\t\tmemset(x, 127, sizeof(x));\n\t\tcin >> n >> m >> l;\n\t\tif (n == 0 && m == 0 && l == 0) { break; }\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tx[a][b][0] = c;\n\t\t\tx[a][b][1] = d;\n\t\t\tx[b][a][0] = c;\n\t\t\tx[b][a][1] = d;\n\t\t}\n\t\tcout << DP(n, l) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX 100\n#define INFTY (1<<21)\n#define rep(i, n) for ( int i = 0; i < n; i++)\nint N, M, L, D[MAX][MAX], E[MAX][MAX];\n\nint dijkstra(){\n    int cost[MAX][MAX+1];\n    bool visited[MAX][MAX+1];\n    rep(i, N) rep(j, L+1){\n\tcost[i][j] = INFTY;\n\tvisited[i][j] = false;\n    }\n    cost[0][L] = 0;\n    \n    while(1){\n\tpair<int, int> u;\n\tint minv = INFTY;\n\trep(i, N) rep(j, L+1){\n\t    if ( !visited[i][j] && minv > cost[i][j] ){\n\t\tu = make_pair(i, j);\n\t\tminv = cost[i][j];\n\t    }\n\t}\n\tif ( minv == INFTY ) break;\n\t//\tcout << u.first << \" \" << u.second << \" \" << minv << endl;\n\tvisited[u.first][u.second] = true;\n\n\tfor ( int v = 0; v < N; v++ ){\n\t    if ( D[u.first][v] == INFTY ) continue;\n\t    // not take\n\t    if ( !visited[v][u.second] ){\n\t\tcost[v][u.second] = min(cost[v][u.second], cost[u.first][u.second] + E[u.first][v]);\n\t    }\n\t    // take\n\t    if ( u.second < D[u.first][v] ) continue;\n\t    int l = u.second - D[u.first][v];\n\t    if ( visited[v][l] ) continue;\n\t    cost[v][l] = min(cost[v][l], cost[u.first][u.second]);\n\t}\n    }\n    int minv = INFTY;\n    rep(i, L+1){\n\tminv = min(minv, cost[N-1][i]);\n    }\n    return minv;\n}\n\nmain(){\n    int s, t, d, e;\n    while( cin >> N >> M >> L && N ){\n\trep(i, N) rep(j, N){ D[i][j] = INFTY; E[i][j] = 0; }\n\trep(i, M){\n\t    cin >> s >> t >> d >> e; s--; t--;\n\t    D[s][t] = D[t][s] = d;\n\t    E[s][t] = E[t][s] = e;\n\t}\n\tcout << dijkstra() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nstruct E {\n    int to, d, e;\n    E(int to, int d, int e) : to(to), d(d), e(e) {}\n};\n\nstruct S {\n    int a, h, m;\n    S(int a, int h, int m) : a(a), h(h), m(m) {}\n    bool operator>(const S& s) const {\n        return a > s.a;\n    }\n};\n\nint n, m, l;\nint inf = 1<<29;\n\nint main() {\n    while (cin >> n >> m >> l, n or m or l) {\n        vector<vector<E>> g(n);\n        rep(i, m) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            g[a].emplace_back(b, d, e);\n            g[b].emplace_back(a, d, e);\n        }\n        vector<vector<int>> dist(n, vector<int>(l+1, inf));\n        dist[0][l] = 0;\n        priority_queue<S, vector<S>, greater<S>> que;\n        que.push(S(0, 0, l));\n        while (que.size()) {\n            S s = que.top(); que.pop();\n            int d = s.a, v = s.h, m = s.m;\n            if (dist[v][m] < d) continue;\n            for (auto tmp : g[v]) {\n                int u = tmp.to;\n                int ud = tmp.d;\n                if (m - ud >= 0) {\n                    if (dist[u][m-ud] > d) {\n                        dist[u][m-ud] = d;\n                        que.push(S(dist[u][m-ud], u, m-ud));\n                    }\n                }\n                if (dist[u][m] > d + tmp.e) {\n                    dist[u][m] = d + tmp.e;\n                    que.push(S(dist[u][m], u, m));\n                }\n            }\n        }\n        int ans = inf;\n        rep(i, l+1) ans = min(ans, dist[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110][110];\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(now==n){\n    ans=min(ans,sum);\n    return;\n  }\n  if(memo[nokori][now]<=sum)return;\n  for(int i=0;i<nokori;i++)\n    memo[i][now]=min(sum,memo[i][now]);\n\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      used[E[now][i].to]=true;\n      if(nokori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n      for(int j=0;j<l+5;j++)\n      memo[j][i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nbool operator==(const State& lhs, const State& rhs)\n{\n    return lhs.loc == rhs.loc && lhs.money == rhs.money && lhs.damage == rhs.damage;\n}\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<int> memo(101, -1);\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (memo[current.loc] <= current.money) {\n                continue;\n            }\n            memo[current.loc] = current.money;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (e.dist <= current.money) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nstruct State {\n  int v, c, rest;\n};\n\nbool operator<(const State &a, const State &b) {\n  return a.c > b.c;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n, m, l;\n  while(cin >> n >> m >> l, n) {\n    P cost[n][n];\n    rep(i, n)rep(j, n) cost[i][j] = P(INF, INF);\n    rep(i, m) {\n      int u, v, len, num;\n      cin >> u >> v >> len >> num; u--, v--;\n      cost[u][v] = cost[v][u] = P(len, num);\n    }\n\n    priority_queue<State> q;\n    q.push(State{0, 0, l});\n    bool visited[n][l] = {};\n    int ans = 0;\n    while(!q.empty()) {\n      State s = q.top(); q.pop();\n\n      if (s.v == n - 1) {\n        ans = s.c;\n        break;\n      }\n\n      if (visited[s.v][s.rest]) continue;\n      else visited[s.v][s.rest] = true;\n\n      rep(i, n) {\n        if (cost[s.v][i] != P(INF, INF)) {\n          q.push(State{i, s.c + cost[s.v][i].se, s.rest});\n          if (cost[s.v][i].fi <= s.rest) q.push(State{i, s.c, s.rest - cost[s.v][i].fi});\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct NODE{\n  vector<int> to_node;\n  vector<int> to_cost;\n  vector<int> to_man;\n  bool done_c;\n  bool done_m;\n  bool start;\n  int cost;\n  int man;\n  int nom;\n};\nint main(){\n  int n,m,l;\n  while(cin >>n>>m>>l,n|m|l){\n    NODE inn[100];\n    vector<int> ans;\n    while(m--){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      inn[a-1].to_node.push_back(b-1);\n      inn[a-1].to_cost.push_back(c);\n      inn[a-1].to_man.push_back(d);\n      inn[b-1].to_node.push_back(a-1);\n      inn[b-1].to_cost.push_back(c);\n      inn[b-1].to_man.push_back(d);\n    }\n    for(int i=0; i<n; i++){\n      inn[i].start = false;\n      inn[i].nom = 10000000;\n    }\n    inn[0].nom = 0;\n    for(int i=0; i<n; i++){\n      int at = 0,pom = 10000000;\n      for(int j=0; j<n; j++){\n\tif((!(inn[j].start)) && pom>inn[j].nom){at = j; pom = inn[j].nom;}\n      }\n      inn[at].start = true;\n      for(int j=0; j<inn[at].to_node.size(); j++){\n\tint togo = inn[at].to_node[j];\n\tif(!inn[togo].start){inn[togo].nom = min(inn[at].to_man[j] + inn[at].nom,inn[togo].nom);}\n      }\n    }\n    for(int k=0; k<n; k++){\n      for(int i=0; i<n; i++){\n\tinn[i].cost = 10000000;\n\tinn[i].done_c = false;\n      }\n      inn[k].cost = 0;\n      for(int i=0; i<n; i++){\n\tint at = 0,pom = 10000000;\n\tfor(int j=0; j<n; j++){\n\t  if((!(inn[j].done_c)) && pom>inn[j].cost){at = j; pom = inn[j].cost;}\n\t}\n\tinn[at].done_c = true;\n\tfor(int j=0; j<inn[at].to_node.size(); j++){\n\t  int togo = inn[at].to_node[j];\n\t  if(!inn[togo].done_c){inn[togo].cost = min(inn[at].to_cost[j] + inn[at].cost,inn[togo].cost);}\n\t}\n      }\n      for(int i=0; i<n; i++){\n\tinn[i].man = 10000000;\n\tinn[i].done_m = false;\n      }\n      inn[k].cost = 0;\n      for(int i=0; i<n; i++){\n\tint at = 0,pom = 10000000;\n\tfor(int j=0; j<n; j++){\n\t  if((!(inn[j].done_m)) && pom>inn[j].man){at = j; pom = inn[j].man;}\n\t}\n\tinn[at].done_m = true;\n\tfor(int j=0; j<inn[at].to_node.size(); j++){\n\t  int togo = inn[at].to_node[j];\n\t  if(!inn[togo].done_m){inn[togo].man = min(inn[at].to_man[j] + inn[at].man,inn[togo].man);if(inn[togo].cost<=l){inn[togo].man = 0;}}\n\t}\n      }\n      ans.push_back(inn[k].nom + inn[n-1].man);\n    }\n    sort(ans.begin(),ans.end());\n    cout <<ans[0]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ALL(x) (x).begin(), (x).end()\n#define EB emplace_back\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int, int> PII;\n\nconst int INF = 0x3f3f3f3f;\n\nstruct Edge {\n    Edge () {}\n    Edge (int t, int d, int e) : to(t), dist(d), enemy(e){}\n    int to, dist, enemy;\n};\n\ntypedef vector<Edge> VE;\ntypedef vector<VE> VVE;\n\nstruct State {\n    State () {}\n    State (int v_, int d, int c) : v(v_), dist(d), cost(c) {}\n    int v, dist, cost;\n    bool operator > (const State &s) const {\n        return cost > s.cost;\n    }\n};\n\nint N, M, L;\n\nVVE es;\n\nint solve() {\n    // dist[v][dist] = min_enemy;\n    VVI dist(N, VI(L + 1, INF));\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0, 0, 0));\n\n    while (q.size()) {\n        State c = q.top();\n        q.pop();\n\n        // ????°??????????????????????\n        if (c.cost > dist[c.v][c.dist]) continue;\n\n        // ?¬?\n        for (auto e : es[c.v]) {\n            for (int i = 0; i < 2; i++) { // use\n                State n;\n                n.v = e.to;\n                n.dist = c.dist + (i ? e.dist : 0);\n                n.cost = c.cost + (i ? 0 : e.enemy);\n\n                // ???????????????????????????\n                if (n.dist > L) continue;\n\n                if (dist[n.v][n.dist] > n.cost) {\n                    dist[n.v][n.dist] = n.cost;\n                    q.push(State(n.v, n.dist, n.cost));\n                }\n            }\n        }\n    }\n\n    return *min_element(ALL(dist[N - 1]));\n}\n\nint main(void) {\n    while (cin >> N >> M >> L, N) {\n        es.clear();\n        es.resize(N);\n\n        for (int i = 0; i < M; i++) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            --a; --b;\n            es[a].EB(b, d, e);\n            es[b].EB(a, d, e);\n        }\n\n        cout << solve() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nint n;\nint dist[101][101];\nint atk[101][101];\nint memo[101][101]; //memo[i][j] : ??????j??§?????????i???????????¨??????????°??\\???\\?????°\nbool used[101][101];\nconst int INF = 1000000000;\n\nstruct V{\n  int p,m;\n  V(int p,int m):p(p),m(m){}\n};\n\nbool operator < (const V& a,const V& b){\n  return memo[a.p][a.m] > memo[b.p][b.m];\n}\n\nint solve(int s,int l){\n  for(int i=0;i<=100;++i)\n    for(int j=0;j<=100;++j){\n      used[i][j]=false;\n      memo[i][j]=INF;\n    }\n  \n  memo[s][l] = 0;\n  priority_queue<V> Q;\n  Q.push(V(s,l));\n\n  while(!Q.empty()){\n    V x=Q.top(); Q.pop();\n    int cur = x.p, mon = x.m, cst=memo[cur][mon];\n    if(used[cur][mon]) continue;\n    used[cur][mon] = true;\n    for(int i=0;i<n;++i){\n      if(dist[cur][i]){\n\tif(cst+atk[cur][i] < memo[i][mon]){\n\t  memo[i][mon] = cst+atk[cur][i];\n\t  Q.push(V(i,mon));\n\t}\n\tif(mon-dist[cur][i]>=0){\n\t  if(memo[i][mon-dist[cur][i]] > cst){\n\t    memo[i][mon-dist[cur][i]] = cst;\n\t    Q.push(V(i,mon-dist[cur][i]));\n\t  }\n\t}\n      }\n    }\n  }\n\n  int ret = INF;\n  for(int i=0;i<=l;++i) ret = min(ret, memo[n-1][i]);\n  return ret;\n}\nint main(){\n  int m,l;\n  while(cin>>n>>m>>l,n||m||l){\n    memset(dist,0,sizeof(dist));\n    memset(atk,0,sizeof(atk));\n    while(m--){\n      int a,b,d,e;\n      cin >> a >> b >> d >> e;\n      a--;b--;\n      dist[a][b] = dist[b][a] = d;\n      atk[a][b] = atk[b][a] = e;\n    }\n    cout<<solve(0,l)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\n\ntemplate<typename T>\nstruct Dijkstra{\n  typedef pair<int,T> pit;\n  typedef pair<T,int> pti;  \n  const T INFT;\n  vector<vector<pit> > G;\n  vector<T> dist;\n  int n;\n  Dijkstra( T INFT ) : INFT(INFT) {}\n  void init( int arg_n ){\n    n = arg_n;\n    G = vector<vector<pit> >( n , vector<pit>(0) );\n  }\n  void add_biedge( int fr , int to , T co ){\n    G[fr].pb( to , co );\n    G[to].pb( fr , co );\n  }\n  void add_edge( int fr , int to , T co ){\n    G[fr].pb( to , co );\n  }\n  T dijkstra( int s , int t = -1 ){\n    dist = vector<T>( n , INFT );\n    dist[s] = 0;\n    priority_queue<pti,vector<pti>,greater<pti> > que;\n    que.emplace( 0 , s );\n    while( !que.empty() ){\n      T d = que.top().fi;\n      int p = que.top().se;\n      que.pop();\n      if( d > dist[p] ){\n\tcontinue;\n      }\n      if( p == t ){\n\treturn d;\n      }\n      YYS( w , G[p] ){\n\tint to = w.fi;\n\tT co = w.se;\n\tif( d + co < dist[to] ){\n\t  dist[to] = d + co;\n\t  que.emplace( dist[to] , to );\n\t}\n      }\n    }\n    return INFT;\n  }\n};\n\nDijkstra<int> dij(INF);\n\nint n, m, l;\n\nint p( int pos , int mon ){\n  assert( 0 <= mon && mon <= l );\n  return pos * ( l + 1 ) + mon;\n}\n\nint main(){\n\n  while( 1 ){\n    n = in();\n    m = in();\n    l = in();\n    if( n == 0 && m == 0 && l == 0 ){\n      break;\n    }\n    dij.init( n * ( l + 1 ) );\n    REP( cnt , m ){\n      int a = in() - 1;\n      int b = in() - 1;\n      int d = in();\n      int e = in();\n      REP( i , l+1 ){\n        dij.add_edge( p( a , i ) , p( b , i ) , e );\n        dij.add_edge( p( b , i ) , p( a , i ) , e );\n        if( i - d >= 0 ){\n          dij.add_edge( p( a , i ) , p( b , i-d ) , 0 );\n          dij.add_edge( p( b , i ) , p( a , i-d ) , 0 );\n        }\n      }\n    }\n    REP( i , n ){\n      REP( j , l ){\n        dij.add_edge( p( i , j+1 ) , p( i , j ) , 0 );\n      }\n    }\n    printf( \"%d\\n\" , dij.dijkstra( p( 0 , l ) , p( n-1 , 0 ) ) );\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\n//-----------------------------------------------------------------------------\n\nstruct Edge {\n\tint to,dist,danger;\n\tEdge(int to,int dist,int danger):to(to),dist(dist),danger(danger) {}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true) {\n\t\tint hotel,road,money,d[100][110];\n\t\tvector<Edge> G[100];\n\t\tcin>>hotel>>road>>money;\n\t\tif(hotel==0) break;\n\t\tREP(i,road) {\n\t\t\tint u,v,dist,danger;\n\t\t\tcin>>u>>v>>dist>>danger;\n\t\t\tu--,v--;\n\t\t\tG[u].pb(Edge(v,dist,danger));\n\t\t\tG[v].pb(Edge(u,dist,danger));\n\t\t}\n\t\tREP(i,100) REP(j,110) d[i][j]=INF;\n\t\tpriority_queue<PP,vector<PP>,greater<PP> > pq;\n\t\tpq.push(PP(0,P(0,money)));\n\t\td[0][money]=0;\n\t\twhile(!pq.empty()) {\n\t\t\tPP p=pq.top();pq.pop();\n\t\t\tint v=p.fi,danger_sum=p.se.fi,rest=p.se.se;\n\t\t\tif(d[v][rest]<danger_sum) continue;\n\t\t\tfor(auto e:G[v]) {\n\t\t\t\tif(d[e.to][rest]>danger_sum+e.danger) {\n\t\t\t\t\td[e.to][rest]=danger_sum+e.danger;\n\t\t\t\t\tpq.push(PP(e.to,P(d[e.to][rest],rest)));\n\t\t\t\t}\n\t\t\t\tif(rest-e.dist<0) continue;\n\t\t\t\tif(d[e.to][rest-e.dist]>danger_sum) {\n\t\t\t\t\td[e.to][rest-e.dist]=danger_sum;\n\t\t\t\t\tpq.push(PP(e.to,P(d[e.to][rest-e.dist],rest-e.dist)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tREP(i,110) ans=min(ans,d[hotel-1][i]);\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) if((x)>(y))(x)=(y)\n#define chmax(x,y) if((x)<(y))(x)=(y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// d[i][j]: 街iに総コストjかけて到着する際に遭遇する盗賊の数の最小値\nint n, m, s, a, b, l, x, d[101][101];\nvector<pair<int,pii> > e[101];\n\nvoid rec(int id, int cs) {\n\tif (id==n-1) return;\n\trep(i,e[id].size()) {\n\t\tint to = e[id][i].fi, dis = e[id][i].se.fi, num = e[id][i].se.se;\n\t\tif (cs+dis<=s && d[to][cs+dis]>d[id][cs]) d[to][cs+dis] = d[id][cs], rec(to,cs+dis); // 護衛を雇う場合\n\t\tif (d[to][cs]>d[id][cs]+num) d[to][cs] = d[id][cs]+num, rec(to,cs); // 雇わない場合\n\t}\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n >> m >> s;\n\t\tif (n==0) break;\n\t\trep(i,n) rept(j,s) d[i][j] = inf;\n\t\td[0][0] = 0;\n\t\trep(i,n) e[i].clear();\n\t\trep(i,m) {\n\t\t\tcin >> a >> b >> l >> x;\n\t\t\ta--, b--;\n\t\t\te[a].pb({b,{l,x}}), e[b].pb({a,{l,x}});\n\t\t}\n\t\trec(0,0);\n\t\tint res = inf;\n\t\trept(i,s) chmin(res,d[n-1][i]);\n\t\tcout << res << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nlong long slv(int, int,int);\n\nvector<vector<pair<int, int>>> s(101, vector<pair<int, int>>(101));\nvector<vector< int>> sflag(101, vector<int>(101, 0));\nint n, m, l;\n\nvector<vector<long long>> dp(101, vector<long long>(101, 0));\nvector<vector<int>> dpflag(101, vector<int>(101, 0));\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m >> l;\n\t\tif (n == 0)return 0;\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ts[b][a] = make_pair(d, e);\n\t\t\tsflag[b][a] = 1;\n\t\t\ts[a][b] = make_pair(d, e);\n\t\t\tsflag[a][b] = 1;\n\t\t}\n\t\tlong long answer = 100000000000;\n\t\tfor (int i = 0; i <= l; ++i) {\n\t\t\tif (answer > slv(n, i,0)) answer = slv(n, i,0);\n\n\t\t}\n\t\tcout  << answer << endl;\n\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tdpflag[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\n\n\t}\n}\n\n\n\n\n\nlong long slv(int N, int L,int count) {\n\tif (count > 200)return 100000000000;\n\tcount++;\n\tfor (int j = 0; j <= l;j++) dpflag[1][j] = 1;\n\n\tif (dpflag[N][L] == 1) return dp[N][L];\n\tlong long min =   1000000000000;\n\tfor (int a = 1; a <= n; ++a) {\n\t\tlong long x = 2000000000000;\n\t\tlong long y = 3000000000000;\n\t\tif (sflag[N][a] == 1) {\n\t\t\tint LL = L - s[N][a].first;\n\t\t\tif (LL >= 0) {\n\t\t\t\tx = slv(a, LL,count);\n\t\t\t}\n\t\t\ty = slv(a, L,count) + s[N][a].second;\n\n\n\t\t}\n\t\tif (min>x) min = x;\n\t\tif (min>y) min = y;\n\t}\n\tdpflag[N][L] = 1;\n\tdp[N][L] = min;\n\n\treturn min;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\n#define INF 0x7fffffff\n\nusing namespace std;\n\nstruct edge{\n\tint to, D, E;\n\tedge(int t, int d, int e){\n\t\tto = t;\n\t\tD = d;\n\t\tE = e;\n\t}\n};\n\n\nint main(){\n\tint N, M, L, A, B, D, E;\n\n\twhile( cin>>N>>M>>L, N|M|L ){\n\t\tpriority_queue<pair<int, pair<int,int> >,vector<pair<int, pair<int, int> > >,greater<pair<int,pair<int,int> > > > que;\n\t\tvector<edge> v[105];\n\t\tint dh[105][105];\n\t\tfor(int i=0; i<M; i++){\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tv[A].push_back( edge(B, D, E) );\n\t\t\tv[B].push_back( edge(A, D, E) );\n\t\t}\n\t\tfill(dh[0], dh[0]+105*105, INF);\n\t\t\n\t\tque.push( make_pair(0, make_pair(1,L)) );\n\t\twhile( !que.empty() ){\n\t\t\tpair<int, pair<int,int> > P = que.top();\n\t\t\tque.pop();\n\t\t\tint Psf = P.second.first, Pss = P.second.second;\n\t\t\tif( P.first < dh[Psf][Pss] ){\n\t\t\t\tdh[Psf][Pss] = P.first;\n\t\t\t\tfor(int i=0; i<v[Psf].size(); i++){\n\t\t\t\t\tedge e = v[Psf][i];\n\t\t\t\t\tque.push( make_pair(P.first + e.E, make_pair(e.to, Pss)) );\n\t\t\t\t\tif( e.D <= Pss ){\n\t\t\t\t\t\tque.push( make_pair(P.first, make_pair(e.to, Pss-e.D)) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int i=0; i<=L; i++)\n\t\t\tans = min(ans, dh[N][i]);\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#define INFTY 1000000000 \nusing namespace std;\n \nint main() {\n    int N, M, L;\n    int a,b;\n    int now,dist;\n    int tmp;\n    cin >> N >> M >> L;\n    for(;N!=0;){\n        vector<vector<bool>> graph(N,vector<bool>(N,false));\n        vector<vector<int>> distance(N,vector<int>(N)),evect(N,vector<int>(N));\n        vector<vector<int>> dp(N,vector<int>(L+1,INFTY));\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\n        for(int i=0; i< M; i++){\n            cin >> a >> b;\n            a--;b--;\n            graph[a][b] = true; graph[b][a] = true;\n            cin >> distance[a][b] >> evect[a][b];\n            distance[b][a] = distance[a][b];\n            evect[b][a] = evect[a][b];\n        }\n        for(int j=L; j>=0 ; j--){\n            q.push(pair<int,int>(0,0));\n            vector<bool> used(N,false);\n            for(;!q.empty();){\n                tie(dist,now) = q.top();\n                q.pop();\n                if(used[now]) continue;\n                used[now] = true;\n                dp[now][j] = dist;\n                for(int i=0; i< N; i++){\n                    if(graph[now][i]){\n                        if(j+distance[now][i]<=L){\n                            tmp = min(dist+evect[now][i],dp[now][j+distance[now][i]]);\n                        }else{ \n                            tmp = dist+evect[now][i];\n                        }\n                        if(dp[i][j] <= tmp) continue;\n                        q.push(pair<int,int>(tmp,i)); \n                    }\n                }\n            }\n        }\n\n        int ans=dp[N-1][L];\n        for(int i=0; i<L ; i++){\n            ans=min(ans,dp[N-1][i]);\n        }\n        cout << ans << endl;\n \n        cin >> N >> M >> L;\n    }\n \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct edge{int to,fee,cost;};\nstruct state{\n  int cost,pos,cash;\n  bool operator < (const state &s)const{\n    return cost>s.cost;\n  }\n};\n\n#define MAX_V 100\n#define INF (1<<24)\nvector<edge> G[MAX_V];\nint V,E,L;\n\nvoid init();\nint dijkstra(int,int);\n\nint main(){\n  int a,b,c,d;\n  while(1){\n    cin>>V>>E>>L;\n    if(V==0&&E==0&&L==0)break;\n    init();\n    for(int i=0;i<E;i++){\n      cin>>a>>b>>c>>d;\n      a--;b--;\n      G[a].push_back( (edge){b,c,d} );\n      G[b].push_back( (edge){a,c,d} );\n    }\n    cout<<dijkstra(0,V-1)<<endl;\n  }\n  return 0;\n}\n\nint dijkstra(int si,int ti){\n  int d[MAX_V][200];\n  fill(d[0],d[0]+MAX_V*200,INF);\n  d[si][L]=0;\n  priority_queue<state> Q;\n  Q.push( (state){0,si,L} );\n\n  while(!Q.empty()){\n    state now=Q.top();Q.pop();\n    if(now.cost>d[now.pos][now.cash])continue;\n    for(int i=0;i<(int)G[now.pos].size();i++){\n      edge e=G[now.pos][i];\n      if(now.cost+e.cost < d[e.to][now.cash]){\n\td[e.to][now.cash]=now.cost+e.cost;\n\tQ.push( (state){now.cost+e.cost,e.to,now.cash} );\n      }\n      if(now.cash-e.fee<0)continue;\n      int ncash=now.cash-e.fee;\n      if(now.cost < d[e.to][ncash]){\n\td[e.to][ncash]=now.cost;\n\tQ.push( (state){now.cost,e.to,ncash} );\n      }\n    }\n  }\n\n  int res=INF;\n  for(int i=0;i<200;i++)\n    res=min(res,d[ti][i]);\n  return res;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++)G[i].clear();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int n, m, l;\n    while(1){\n        cin >> n >> m >> l;\n        if(n == 0 && m == 0 && l == 0) break;\n        int touzoku[101][101];\n        int money[101][101];\n        int result[101];\n        memset(touzoku, -1, sizeof(touzoku));\n        memset(money, -1, sizeof(money));\n        memset(result, 1000000, sizeof(result));\n        for(int i = 0; i < m; i++){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            touzoku[a][b] = e;\n            touzoku[b][a] = e;\n            money[a][b] = d;\n            money[b][a] = d;\n        }\n        priority_queue<pair<int, pair<int, int> > > qu;\n        qu.push(make_pair(0, make_pair(0, 0)));\n        while(!qu.empty()){\n            int t = (qu.top()).first;\n            int nowtown = ((qu.top()).second).second;\n            int usedmoney = ((qu.top()).second).first;\n            // cout << t << \" \" << nowtown << \" \" << usedmoney << endl;\n            qu.pop();\n            // cout << result[nowtown] << \" \" << t << endl;\n            if(result[nowtown] <= t) continue;\n            // cout << \"hoge\" << endl;\n            result[nowtown] = t;\n            if(nowtown == n - 1) continue;\n            for(int i = 0; i < n; i++){\n                // cout << touzoku[nowtown][i] << endl;\n                if(touzoku[nowtown][i] != -1){\n                    if(usedmoney + money[nowtown][i] <= l){\n                        qu.push(make_pair(t, make_pair(usedmoney + money[nowtown][i], i)));\n                    }\n                    qu.push(make_pair(t + touzoku[nowtown][i], make_pair(usedmoney, i)));\n                }\n            }\n        }\n        cout << result[n - 1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\ninline bool operator< ( const State& a, const State& b) {\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\nconst int inf = 1e9;\n\nstruct info{\n\tint n,d,e;\n\tinfo(int n, int d, int e):n(n),d(d),e(e){}\n};\nnamespace std{\n\tbool operator < (const info &a, const info &b){\n\t\treturn b.e < a.e;\n\t}\n}\nint main(){\n\twhile(1){\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<vector<info> > adj(n+1);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tadj[a].push_back(info(b,d,e));\n\t\t\tadj[b].push_back(info(a,d,e));\n\t\t}\n\t\t\n\t\tpriority_queue<info> wait;\n\t\twait.push(info(1,l,0));\n\t\tvector<vector<int> > mincost(n+1, vector<int>(l+1, inf));\n\t\tmincost[1][l] = 0;\n\t\twhile(!wait.empty()){\n\t\t\tint cur = wait.top().n;\n\t\t\tint money = wait.top().d;\n\t\t\tint cost = wait.top().e;\n\t\t\twait.pop();\n\t\t\tif(cost > mincost[cur][money]) continue;\n\t\t\tfor(int i=0; i<(int)adj[cur].size(); i++){\n\t\t\t\tinfo next = adj[cur][i];\n\t\t\t\tif(cost + next.e < mincost[next.n][money]){\n\t\t\t\t\tmincost[next.n][money] = cost+next.e;\n\t\t\t\t\twait.push(info(next.n, money, cost+next.e));\n\t\t\t\t}\n\t\t\t\tif(money >= next.d && cost < mincost[next.n][money-next.d]){\n\t\t\t\t\tmincost[next.n][money-next.d] = cost;\n\t\t\t\t\twait.push(info(next.n, money-next.d, cost));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = inf;\n\t\tfor(int i=0; i<=l; i++){\n\t\t\tans = min(ans, mincost[n][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <unordered_set>\n#include <unordered_map>\n#include <limits>\n#include <map>\n\nstruct Edge{\n  int from, to, d, e;\n};\n\nstruct Solver{\n  static std::map<std::pair<int, int>, int> costs;\n  static std::vector<std::vector<Edge>> adj_list;\n  int S, N, L;\n\n  Solver(int S, int N, int L) : S(S), N(N), L(L) {\n    //std::cout << \"S:\" << S << \" N:\" << N << \" L:\" << L << std::endl;\n  }\n\n  int solve(std::unordered_set<int> &visited) {\n    if (visited.find(S) != visited.end()) {\n      return std::numeric_limits<int>::max() / 2;\n    }\n    if (S == N) {\n      return 0;\n    }\n    if (costs.find(std::make_pair(S, L)) != costs.end()) {\n      return costs[std::make_pair(S, L)];\n    }\n    visited.insert(S);\n    int cost = std::numeric_limits<int>::max() / 2;\n    for (auto const& edge : adj_list[S]) {\n      if (edge.d <= L) {\n        auto new_visited = visited;\n        int new_cost = Solver{edge.to, N, L - edge.d}.solve(new_visited);\n        if (new_cost < cost) {\n          cost = new_cost;\n        }\n      }\n      auto new_visited = visited;\n      int new_cost = Solver{edge.to, N, L}.solve(new_visited) + edge.e;\n      if (new_cost < cost) {\n        cost = new_cost;\n      }\n    }\n    //std::cout << \"from: \" << S << \" to: \" << N << \" money: \" << L << \" -> cost: \" << cost << std::endl;\n    return cost;\n  }\n};\n\nstd::map<std::pair<int, int>, int> Solver::costs;\nstd::vector<std::vector<Edge>> Solver::adj_list;\n\nint solve(int N, int M, int L) {\n  std::vector<std::vector<Edge>> adj_list(N);\n  for (int i = 0; i < M; i++) {\n    int f, t, d, e;\n    std::cin >> f >> t >> d >> e;\n    adj_list[f - 1].push_back(Edge{f - 1, t - 1, d, e});\n    adj_list[t - 1].push_back(Edge{t - 1, f - 1, d, e});\n  }\n  Solver::adj_list = std::move(adj_list);\n  std::unordered_set<int> visited;\n  return Solver{0, N - 1, L}.solve(visited);\n}\n\nint main() {\n  int N, M, L;\n  while (std::cin >> N >> M >> L) {\n    if (N == 0 && M == 0 && L == 0) {\n      break;\n    }\n    std::cout << solve(N, M, L) << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<vector>\n\n#define pb push_back\n#define fs first\n#define sc second\n#define INF 500000000\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P > P2;\n\nint main(){\n  int n,m,l;\n  int num[110][110];\n  vector<int> to[100],d[100],e[100];\n\n  while(scanf(\"%d %d %d\",&n,&m,&l) && (n||m||l)){\n\n    for(int i=1;i<=n;i++){\n      to[i].clear();\n      d[i].clear();\n      e[i].clear();\n    }\n\n    for(int i=0;i<m;i++){\n      int a,b,dis,en;\n      scanf(\"%d %d %d %d\",&a,&b,&dis,&en);\n      to[a].pb(b);\n      d[a].pb(dis);\n      e[a].pb(en);\n      to[b].pb(a);\n      d[b].pb(dis);\n      e[b].pb(en);\n    }\n\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<=l;j++){\n\tnum[i][j] = INF;\n      }\n    }\n\n    num[1][l] = 0;\n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    q.push(P2(0,P(1,l)));\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int en = p.fs, pos = p.sc.fs, mon = p.sc.sc;\n\n      for(int i=0;i<(int)to[pos].size();i++){\n\tint next = to[pos][i];\n\tif(d[pos][i] <= mon){\n\t  int rem = mon - d[pos][i];\n\t  if(num[next][rem] > en){\n\t    num[next][rem] = en;\n\t    q.push(P2(num[next][rem],P(next,rem)));\n\t  }\n\t}\n\tint enemy = en + e[pos][i];\n\tif(num[next][mon] > enemy){\n\t  num[next][mon] = enemy;\n\t  q.push(P2(enemy,P(next,mon)));\n\t}\n      }\n    }\n  \n    int ans = INF;\n    for(int i=0;i<=l;i++)ans = min(ans,num[n][i]);\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct NODE{\n\tint to , cost , number;\n\tNODE(int a,int b,int c){ to = a , cost = b , number = c ; }\n};\nbool operator < (const NODE &a, const NODE &b){\n\treturn a.number > b.number;\n}\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\nint main(){\n\tint n,m,l;\n\twhile(cin >> n >> m >> l && n){\n\t\tvector< vector<NODE> > v(n);\n\t\trep(i,m){\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--,b--;\n\t\t\tv[a].push_back(NODE(b,d,e));\n\t\t\tv[b].push_back(NODE(a,d,e));\n\t\t}\n\t\tpriority_queue<NODE> Q;\n\t\tbool done[100][101] = {0};\n\t\tQ.push(NODE(0,l,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(done[q.to][q.cost]) continue;\n\t\t\telse done[q.to][q.cost] = true;\n\t\t\tif(q.to == n-1){\n\t\t\t\tcout << q.number << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,v[q.to].size()){\n\t\t\t\tif(q.cost >= v[q.to][i].cost) Q.push(NODE(v[q.to][i].to,q.cost-v[q.to][i].cost,q.number));\n\t\t\t\tQ.push(NODE(v[q.to][i].to,q.cost,q.number+v[q.to][i].number));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< pii >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define in(x, a, b) ((a) <= (x) && (x) < (b))\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// 01Trie BIT CHT DFT FFT avl cmd cusum dijkstra dinic geo2 gin graph kruskal lca lcm matrix ncm next_combination ppuf segtree st tmp topcoder uf vi \n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int s, d; Weight w; Flow c;\n    Edge() {};\n    Edge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n    g[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n    addArc(g, a, b, w);\n    addArc(g, b, a, w);\n}\n\n//単一始点最短経路(負閉路なし)\n//Dijkstra O((|E|+|V|)log|V|)\n//dist: 始点から各頂点までの最短距離\n//戻り値: 最短経路木の親頂点(根は-1)\nvector<int> dijkstra(const Graph &g, int s, Array &dist) {\n    int n = g.size();\n    assert(s < n);\n    enum { WHITE, GRAY, BLACK };\n    vector<int> color(n, WHITE); color[s] = GRAY;\n    vector<int> prev(n, -1);\n    dist.assign(n, INF); dist[s] = 0;\n    using State = tuple<Weight, int, int>; //始点からの最短距離 子 親\n    priority_queue<State, vector<State>, greater<State>> pq; pq.emplace(0, s, -1);\n    while (pq.size()) {\n        Weight d; int v, u; tie(d, v, u) = pq.top(); pq.pop();\n        if (dist[v] < d)continue;\n        color[v] = BLACK; prev[v] = u;\n        for (auto &e : g[v]) {\n            if (color[e.d] == BLACK)continue;\n            if (dist[e.d] > dist[v] + e.w) {\n                dist[e.d] = dist[v] + e.w;\n                pq.emplace(dist[e.d], e.d, v);\n                color[e.d] = GRAY;\n            }\n        }\n    }\n    return prev;\n}\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m, l;\n    while (cin >> n >> m >> l) {\n        if (!n) break;\n        Graph g(n * (l+1));\n        for (int i = 0; i < m; i++) {\n            int2(tmpx, tmpy);\n            tmpx--; tmpy--;\n            int2(cost, danger);\n            for (int i = 0; i + cost <= l; i++) {\n                addArc(g, tmpx * (l+1) + i, tmpy * (l+1) + i + cost, 0);\n                addArc(g, tmpy * (l+1) + i, tmpx * (l+1) + i + cost, 0);\n            }\n            for (int i = 0; i <= l; i++) {\n                addEdge(g, tmpx * (l+1) + i, tmpy * (l+1) + i, danger);\n            }\n        }\n        vi ans(g.size(), 0);\n        dijkstra(g, 0, ans);\n        cout << *min_element(&ans[(n-1)*(l+1)], &ans[n*(l+1)]) << endl;\n    }\n\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 101;\nconst int MAX_V = 3000;\nconst int INF = 1e+8;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to, d, e;\n\tedge(int v_, int d_, int e_){ \n\t\tto = v_; d = d_; e = e_; \n\t};\n};\n\n// g[u] := ノード u と隣接するエッジのvectorを返す\nvector<edge> g[MAX_N];\n// G[u] := ノード u と隣接するエッジのvectorを返す (解を求めるために使うグラフ)\nvector<edge> G[MAX_V];\n// p = (頂点,持っているお金)をひとつの頂点とみなし, h[p] で対応する頂点番号を返す\nmap<P,int> h;\n// N : 宿の数, id: 生成する頂点番号の管理に使う\nint N, id;\n// d[v] := 始点から頂点 v までの最短距離\nint d[MAX_V];\n// 直前の頂点\n//int prev[MAX_V];\n// 最短の頂点番号\n//int goal;\n//\n//map<int,bool> hoge;\n//\n//int cnt;\n\n// デバッグ用\nvoid debug( vector<int> path ){\n\tfor(map<P,int>::iterator it = h.begin() ; it != h.end() ; ++it ){\n\t\tcout << \"<\" << (it->first).first << \",\" << (it->first).second << \">\";\n\t\tcout << \" = \" << it->second << endl;\n\t}\n\tfor(int i=0 ; i < path.size() ; i++ ){\n\t\tcout << path[i];\n\t\tif( i != path.size()-1 )\n\t\t\tcout << \" => \";\n\t}\n\tcout << endl;\n}\n\nvoid debug_2(){\n\tcout << \"[debug]\" << endl;\n\tfor(int v=0 ; v < id ; v++ ){\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tedge ed = G[v][i];\n\t\t\tcout << \"(\" << v << \",\" << ed.to << \") = \" << ed.e << endl;\n\t\t}\n\t}\n\tcout << endl;\n}\n\n// 初期化\nvoid init(){\n\tfor(int i=0 ; i < MAX_N ; i++ ){\n\t\tg[i].clear();\n\t}\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t}\n\th.clear();\n\t//hoge.clear();\n\t//cnt = INF;\n}\n\n// 辺の追加\nvoid add_edge(int u, int v, int d, int e){\n\tedge ed( v , d , e );\n\tg[u].push_back( ed );\n\ted.to = u;\n\tg[v].push_back( ed );\n}\n\n// 辺の追加2\nvoid add_edge2(int u, int v, int cost){\n\tedge ed( v , 0 , cost );\n\tG[u].push_back( ed );\n}\n\n// <頂点番号,持っているお金>を頂点, 襲われる人数をエッジのコストとしたグラフをつくる\nvoid dfs(int v, int L, map<int,bool> memo){\n\tif( v == N-1 ) return;\n\t\n\tP from( v , L );\n\tif( !h.count( from ) ){\n\t\th[from] = id;\n\t\tid++;\n\t}\n\tint a = h[from];\n\t//if( from.first == N-1 ) hoge[a] = true;\n\t\n\tfor(int i=0 ; i < g[v].size() ; i++ ){\n\t\tedge ed = g[v][i];\n\t\tif( memo.count(ed.to) && memo[ed.to] ) continue;\n\t\tmemo[ed.to] = true;\n\t\t\n\t\tP next_1( ed.to , L );\n\t\tif( !h.count( next_1 ) ){\n\t\t\th[next_1] = id;\n\t\t\tid++;\n\t\t}\n\t\tint b = h[next_1];\n\t\t//if( next_1.first == N-1 ) hoge[b] = true;\n\t\tadd_edge2( a , b , ed.e );\n\t\tdfs( ed.to , L , memo );\n\t\t\n\t\tif( L >= ed.d ){\n\t\t\tP next_2( ed.to , L - ed.d );\n\t\t\tif( !h.count( next_2 ) ){\n\t\t\t\th[next_2] = id;\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tint c = h[next_2];\n\t\t\t//if( next_2.first == N-1 ) hoge[c] = true;\n\t\t\tadd_edge2( a , c , 0 );\n\t\t\tdfs( ed.to , L - ed.d , memo );\n\t\t}\n\t\tmemo[ed.to] = false;\n\t}\n}\n\n// ダイクストラ法\nvoid dijkstra(){\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tfill( d , d + MAX_V , INF );\n\t//fill( prev , prev + MAX_V , -1 );\n\td[0] = 0;\n\tq.push( P(0,0) );\n\twhile( !q.empty() ){\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\t/*if( hoge.count(v) ){\n\t\t\tcnt = min( cnt , p.first );\n\t\t}*/\n\t\t\n\t\tif( d[v] < p.first ) continue;\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tedge ed = G[v][i];\n\t\t\tif( d[ed.to] > d[v] + ed.e ){\n\t\t\t\td[ed.to] = d[v] + ed.e;\n\t\t\t\tq.push( P( d[ed.to] , ed.to ) );\n\t\t\t\t//prev[ed.to] = v;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 最小値を求める\nint solve(){\n\tint ans = INF;\n\tfor(map<P,int>::iterator it = h.begin() ; it != h.end() ; ++it ){\n\t\tif( (it->first).first == N-1 ){\n\t\t\tint v = h[ it->first ];\n\t\t\tans = min( ans , d[v] );\n\t\t}\n\t}\n\treturn ans;\n}\n\n// 経路復元\n/*vector<int> get_path(int t){\n\tvector<int> path;\n\tfor( ; t != -1 ; t = prev[t] )\n\t\tpath.push_back( t );\n\treverse( path.begin() , path.end() );\n\treturn path;\n}*/\n\nint main(){\n\tint M, L;\n\twhile( cin >> N >> M >> L, N || M || L ){\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < M ; i++ ){\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--; b--;\n\t\t\tadd_edge( a , b , d , e );\n\t\t}\n\t\t\n\t\t// グラフの生成\n\t\tid = 0;\n\t\tmap<int,bool> memo;\n\t\tmemo[0] = true;\n\t\tdfs( 0 , L , memo );\n\t\t// ダイクストラ法\n\t\tdijkstra();\n\t\t// 最小コストを求める\n\t\tint ans = solve();\n\t\t// デバッグ\n\t\t//vector<int> path = get_path( goal );\n\t\t//debug_2();\n\t\t//debug( path );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair((a),(b))\n#define list3(a,b,c) mp((a),mp((b),(c)))\n#define list4(a,b,c,d) mp((a),list3((b),(c),(d)))\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint vis[200][200];\nvector<pair<int,PI> > G[200];\nint m,n,l;\n\nvoid solve(){\n  rep(i,n) G[i].clear();\n  CLR(vis);\n  rep(i,m){\n    int a,b,d,e;\n    cin >> a >> b >> d >> e;\n    --a,--b;\n    G[a].pb(mp(b,mp(d,e)));\n    G[b].pb(mp(a,mp(d,e)));\n  }\n  priority_queue<pair<int,PI > > q;\n  q.push(mp(0,mp(0,0)));\n  while(!q.empty()){\n    int cc=-q.top().F;\n    int cv=q.top().S.F;\n    int us=q.top().S.S;\n    q.pop();\n    if(us>l) continue;    \n    if(vis[cv][us]) continue;\n    vis[cv][us]=true;\n\n    if(cv==n-1){\n      cout << cc << endl;\n      return;\n    }\n    FOR(it,G[cv]){\n      q.push(mp(-cc-it->S.S,mp(it->F,us)));\n      q.push(mp(-cc,mp(it->F,us+it->S.F)));\n    }\n  }\n}\n\nint main(){\n  while(cin >> n >> m >> l && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n    int src,dst;\n    Weight cost;\n    Edge(int s,int d,Weight c) : src(s), dst(d), cost(c) {}\n};\nbool operator<(const Edge &e,const Edge &f) {\n    return (e.cost != f.cost) ? e.cost > f.cost : e.src < f.src;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nconst Weight inf = 1<<29;\n\nvoid dijkstra(const Graph &g,int s,vector<Weight> &dist,vector<int> &prev) {\n    const int n = g.size();\n    dist.resize(n);\n    prev.resize(n);\n    for(int i=0; i<n; ++i)\n        dist[i] = inf, prev[i] = -1;\n\n    priority_queue<Edge> q;\n    q.push(Edge(-2,s,0));\n    dist[s] = 0;\n    while(!q.empty()) {\n        Edge e = q.top(); q.pop();\n        if(prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n\n        for(int i=0; i<g[e.dst].size(); ++i) {\n            int w = g[e.dst][i].dst;\n            if(dist[w] > dist[e.dst] + g[e.dst][i].cost) {\n                dist[w] = dist[e.dst] + g[e.dst][i].cost;\n                q.push(Edge(e.dst,w,dist[w]));\n            }\n        }\n    }\n}\n\nint L;\ninline int idx(int a,int l) { return a*L+l; }\n\nint main() {\n    int n,m,l;\n    int a,b,e,d;\n    while(cin>>n>>m>>l, n|m) {\n        L = l+1;\n        Graph g(n*L);\n        for(int i=0; i<m; ++i) {\n            cin>>a>>b>>d>>e; a--,b--;\n            for(int j=0; j<L; ++j) {\n                g[idx(a,j)].push_back(Edge(idx(a,j),idx(b,j),e));\n                g[idx(b,j)].push_back(Edge(idx(b,j),idx(a,j),e));\n                if(j>=d) {\n                    g[idx(a,j)].push_back(Edge(idx(a,j),idx(b,j-d),0));\n                    g[idx(b,j)].push_back(Edge(idx(b,j),idx(a,j-d),0));\n                }\n            }\n        }\n\n        vector<int> dist(n*L,0), prev(n*L,0);\n        dijkstra(g,l,dist,prev);\n\n        int ans = 1<<29;\n        for(int i=0; i<=l; ++i)\n            ans = min(ans, dist[idx(n-1,i)]);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nvoid dijkstra(Graph &g, vector<weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tweight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n)\n\t{\n\t\tGraph g(n*l+n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--; b--;\n\t\t\tREP(j, l + 1)\n\t\t\t{\n\t\t\t\tint ta = j*n + a;\n\t\t\t\tint tb = j*n + b;\n\t\t\t\tg[ta].push_back(edge{ tb, e });\n\t\t\t\tg[tb].push_back(edge{ ta, e });\n\t\t\t}\n\t\t\tFOR(j, d, l + 1)\n\t\t\t{\n\t\t\t\tint ta = j*n + a;\n\t\t\t\tint tb = (j-d)*n + b;\n\t\t\t\tg[ta].push_back(edge{ tb, 0 });\n\t\t\t\tta = (j - d)*n + a;\n\t\t\t\ttb = j*n + b;\n\t\t\t\tg[tb].push_back(edge{ ta, 0 });\n\t\t\t}\n\t\t}\n\t\tvector<weight> d(n*l + n);\n\t\tdijkstra(g, d, l*n);\n\t\tint ans = INF;\n\t\tREP(i, l + 1)\n\t\t{\n\t\t\tchmin(ans, (int)d[i*n + n - 1]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(int n, int m, int l) {\n    vector<vector<int>> dp(n, vector<int>(l + 1, 1e9));\n    dp[0][l] = 0;\n    vector<vector<tuple<int, int, int>>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int a, b, d, e;\n        cin >> a >> b >> d >> e;\n        a--, b--;\n        adj[a].emplace_back(b, d, e);\n        adj[b].emplace_back(a, d, e);\n    }\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> que;\n    que.emplace(0, l);\n    while (!que.empty()) {\n        auto top = que.top();\n        que.pop();\n        int v = top.first, k = top.second;\n        for (auto &t : adj[v]) {\n            int u = get<0>(t), d = get<1>(t), e = get<2>(t);\n            // 何も守らない\n            if (dp[v][k] + e < dp[u][k]) {\n                dp[u][k] = dp[v][k] + e;\n                que.emplace(u, k);\n            }\n            if (d <= k && dp[v][k] < dp[u][k - d]) {\n                dp[u][k - d] = dp[v][k];\n                que.emplace(u, k - d);\n            }\n        }\n    }\n    int ret = 1e9;\n    for (int i = 0; i <= l; i++) {\n        ret = min(ret, dp.back()[i]);\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (1) {\n        int n, m, l;\n        cin >> n >> m >> l;\n        if (n == 0) break;\n        cout << solve(n, m, l) << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<functional>\n#include<map>\n#include<fstream>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = (LL)1e9*(LL)1e5;\n\ntypedef vector<LL> VLL;\ntypedef pair<LL, int> E;\ntypedef vector<list<E>> ADJ;\n#define mp(a,b) make_pair(a,b)\n#define cost(_v) _v.first\n#define to(_v) _v.second\nstruct edge{\n\tLL cost;\n\tLL enemy;\n};\nedge inf = { INF, INF };\ninline VLL dijkstra(int s, ADJ adj){\n\tint n = (int)adj.size();\n\tVLL res(n, -1);\n\tpriority_queue<E, vector<E>, greater<E>> que;\n\tque.push(mp(0ll, s));\n\twhile (que.empty() == false){\n\t\tauto tmp = que.top(); que.pop();\n\t\tauto c = cost(tmp);\n\t\tauto v = to(tmp);\n\t\tif (res[v] >= 0)continue;\n\t\tres[v] = c;\n\t\tfor (auto &i : adj[v]){\n\t\t\tauto d = cost(i);\n\t\t\tauto u = to(i);\n\t\t\tif (res[u] >= 0)continue;\n\t\t\tque.push(mp(c + d, u));\n\t\t}\n\t}\n\n\treturn res;\n};\n\n\nint main(){\n\n\tofstream cout(\"out.txt\");\n\twhile (1){\n\t\tint N, M, L;\n\t\tcin >> N >> M >> L;\n\t\tif (N + M + L == 0)return 0;\n\t\tvector<vector<LL>> dp(N + 1, vector<LL>(L + 1, INF));\n\t\tvector<vector<edge>> d(N + 1,vector<edge>(N + 1, inf));\n\t\tADJ adj(N + 1);\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint A, B ;\n\t\t\tLL D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\td[A][B].cost = d[B][A].cost = D;\n\t\t\td[A][B].enemy = d[B][A].enemy = E;\n\t\t\tadj[A].push_back(mp(E, B));\n\t\t\tadj[B].push_back(mp(E, A));\n\t\t}\n\t\tfor (int i = 1; i < N+1; i++){\n\t\t\td[i][i].cost =d[i][i].enemy = 0;\n\t\t}\n\t\tdp[1][0] = 0;\n\n\t\t\n\n\t\tfor (int l = 0; l < L; l++){\n\t\t\tif(l)for (int i = 1; i <= N; i++){\n\t\t\t\tdp[i][l] = min(dp[i][l], dp[i][l - 1]);\n\t\t\t}\n\t\t\tadj[1].clear();\n\t\t\tfor (int i = 2; i < N+1; i++){\n\t\t\t\tadj[1].push_back(mp(min(d[1][i].enemy,dp[i][l]), i));\n\t\t\t}\n\t\t\tauto ddd=dijkstra(1, adj);\n\t\t\tfor (int i = 1; i < N+1; i++){\n\t\t\t\tdp[i][l] = ddd[i];\n\t\t\t}\n\t\t\tfor (int i = 1; i <= N; i++){\n\t\t\t\tfor (int j = 1; j <= N; j++){\n\t\t\t\t\tif (l + d[i][j].cost>L)continue;\n\t\t\t\t\tdp[j][l + d[i][j].cost] = min(dp[i][l], dp[j][l + d[i][j].cost]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; i++){\n\t\t\tdp[i][L] = min(dp[i][L], dp[i][L - 1]);\n\t\t}\n\t\tadj[1].clear();\n\t\tfor (int i = 2; i < N + 1; i++){\n\t\t\tadj[1].push_back(mp(min(d[1][i].enemy, dp[i][L]), i));\n\t\t}\n\t\tauto ddd = dijkstra(1, adj);\n\t\tfor (int i = 1; i < N + 1; i++){\n\t\t\tdp[i][L] = ddd[i];\n\t\t}\n\t\tLL res = INF;\n\t\tfor (int i = 1; i < L+1; i++){\n\t\t\tres = min(res, dp[N][i]);\n\t\t}\n\t\t//cout << \"res:\";\n\t\tcout << res << endl;\n\n\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, L;\n\nstruct State {\n    int v, sum, dist;\n    State(int v, int sum, int dist) : v(v), sum(sum), dist(dist) {}\n    bool operator<(const State& a) const {\n        return dist > a.dist;\n    }\n};\n\nstruct edge {\n    int to, money, enemy;\n    edge(int to, int money, int enemy):to(to),money(money),enemy(enemy){}\n};\n\nvector<edge> G[101];\nint d[101][101];\n\nvoid dijkstra(int s)\n{\n    for (int i = 0; i <= 100; ++i) for (int j = 0; j < N; ++j) d[i][j] = inf;\n\n    priority_queue<State> q;\n    q.push(State(s, 0, 0));\n\n    d[0][s] = 0;\n\n    while (q.size()) {\n        State st = q.top(); q.pop();\n\n        if (d[st.sum][st.v] < st.dist) continue;\n\n        for (int i = 0; i < G[st.v].size(); ++i) {\n            edge e = G[st.v][i];\n\n            if (st.sum + e.money <= L) {\n                if (d[st.sum + e.money][e.to] < st.dist) continue;\n                d[st.sum + e.money][e.to] = st.dist;\n                q.push(State(e.to, st.sum + e.money, d[st.sum + e.money][e.to]));\n            }\n\n            if (d[st.sum][e.to] > st.dist + e.enemy) {\n                d[st.sum][e.to] = st.dist + e.enemy;\n                q.push(State(e.to, st.sum, d[st.sum][e.to]));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    while (scanf(\"%d%d%d\", &N, &M, &L), N) {\n        for (int i = 0; i < N; ++i) G[i].clear();\n\n        for (int i = 0; i < M; ++i) {\n            int A, B, D, E;\n            scanf(\"%d%d%d%d\", &A, &B, &D, &E);\n            A--, B--;\n            G[A].push_back(edge(B, D, E));\n            G[B].push_back(edge(A, D, E));\n        }\n\n        dijkstra(0);\n\n        int mi = inf;\n\n        for (int i = 0; i <= 100; ++i) {\n            chmin(mi, d[i][N - 1]);\n        }\n\n        printf(\"%d\\n\", mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\ntemplate <typename T>\nbool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\ntypedef pair<int, i_i> iii;\nint N, M, L;\nvector<iii> paths[100];\nint dist[100][101];\n\nvoid solve() {\n    for(int i = 0; i < N; i++) paths[i].clear();\n    for(int i = 0; i < M; i++) {\n        int a, b,d, e;\n        cin >> a >> b >> d >> e;\n        a--;\n        b--;\n        paths[a].push_back({b, {d, e}});\n        paths[b].push_back({a, {d, e}});\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j <= L; j++) {\n            dist[i][j] = 1e9;\n        }\n    }\n    dist[0][L] = 0;\n    priority_queue<iii, vector<iii>, greater<iii>> que;\n    que.push({0, {0, L}});\n    while(!que.empty()) {\n        auto tmp = que.top();\n        que.pop();\n        int pos = tmp.second.first;\n        int l = tmp.second.second;\n        for(auto tmp : paths[pos]) {\n            int to = tmp.first;\n            if(chmin(dist[to][l], dist[pos][l] + tmp.second.second)) {\n                que.push({dist[to][l], {to, l}});\n            }\n            if(l >= tmp.second.first) {\n                if(chmin(dist[to][l-tmp.second.first], dist[pos][l])) {\n                    que.push({dist[to][l-tmp.second.first], {to, l - tmp.second.first}});\n                }\n            }\n        }\n    }\n    int ans = 1e9;\n    for(int l = 0; l <= L; l++) {\n        chmin(ans, dist[N-1][l]);\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N >> M >> L) {\n        if(N == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lld;\n\n#define INF (1<<30)\ntypedef pair< int , int > P;\ntypedef pair< int , P > Pi;\nstruct Edge { int to,cost,des; };\nvector< vector< Edge > > Graph;\nint V,E,L;\n\nint Dijkstra(int s,int g) {\n  int min_cost[111][111];\n  fill_n(*min_cost,111*111,INF);\n  priority_queue < Pi ,vector< Pi >,greater< Pi > > que;\n  que.push(Pi(0,P(L,s)));\n  min_cost[s][L] = 0;\n  while(!que.empty()){\n    int cost = que.top().first;\n    int des = que.top().second.first;\n    int now = que.top().second.second;\n    que.pop();\n    if(now == g) return cost;\n    if(cost > min_cost[now][des]) continue;\n    for(int i=0;i<Graph[now].size();i++){\n      Edge e = Graph[now][i];\n      if(des - e.des >= 0 && min_cost[e.to][des-e.des] > cost){\n\tque.push(Pi(cost,P(des-e.des,e.to)));\n      }\n      if(min_cost[e.to][des] > cost + e.cost){\n\tmin_cost[e.to][des] = cost + e.cost;\n\tque.push(Pi(min_cost[e.to][des],P(des,e.to)));\n      }\n    }\n  }\n  return (-1);\n}\n\nint main(){\n  while(cin >> V >> E >> L , V){\n    Graph.clear();\n    Graph.resize(V);\n    for(int i=0;i<E;i++){\n      int a,b,c,d;\n      cin >> a >> b >> c >> d;\n      a--; b--;\n      Edge e; e.to = b; e.cost = d; e.des = c;\n      Graph[a].push_back(e);\n      e.to = a;\n      Graph[b].push_back(e);\n    }\n    cout << Dijkstra(0,V-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <array>\n#include <algorithm>\nusing namespace std;\ntypedef array<int,3> T;\nvector<T> G[100];//to,dist,enemy;\nint memo[100][101];//town,money\npriority_queue<T,vector<T>,greater<T>> que;//attack,town,money\n\nint main(){\n    int N,M,L;\n    while(cin>>N>>M>>L,N){\n        for(int i=0;i<100;i++) G[i].clear();\n        fill(memo[0],memo[100],1e8);\n        for(int i=0;i<M;i++){\n            int A,B,D,E;\n            cin>>A>>B>>D>>E;\n            A--;B--;\n            G[A].push_back({B,D,E});\n            G[B].push_back({A,D,E});\n        }\n        while(!que.empty())que.pop();\n        que.push({0,0,L});\n        memo[0][L]=0;\n        while(!que.empty()){\n            auto t=que.top(); que.pop();\n            int attack=t[0], town=t[1], money=t[2];\n            if(town==N-1){\n                cout<<attack<<endl;\n                break;\n            }\n            for(auto e:G[town]){\n                int to=e[0], dist=e[1], enemy=e[2];\n                if(money>=dist){\n                    if(memo[to][money-dist]>attack){\n                        memo[to][money-dist]=attack;\n                        que.push({attack,to,money-dist});\n                    }\n                }\n                if(memo[to][money]>attack+enemy){\n                    memo[to][money]=attack+enemy;\n                    que.push({attack+enemy,to,money});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n \nusing namespace std;\n \n#define REP(i, n) for(int i=0; i<n; i++)\n \nstruct edge{\n    int to, dist, t;\n};\n \ntypedef pair<int, pair<int, int> > pii; // thief, edge, money\n \nint INF = 10e8;\nint n, m, l;\n\nint thief[101][101];\n \nint main(){\n    while(1){\n        cin >> n >> m >> l;\n\n        if(n==0) break;\n \n        vector<edge> g[101];\n        REP(i, m){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            edge ae;\n            ae.to = b;\n            ae.dist = d;\n            ae.t = e;\n            g[a].push_back(ae);\n            edge be;\n            be.to = a;\n            be.dist = d;\n            be.t = e;\n            g[b].push_back(be);\n        }\n \n        priority_queue<pii, vector<pii>, greater<pii> > que;\n        REP(i, n+1){\n            REP(j, l+1){\n                thief[i][j] = INF;\n            }\n        }\n        thief[1][l] = 0;\n        pii init = make_pair(0, make_pair(1, l));\n        que.push(init);\n \n        while(!que.empty()){\n            pii p = que.top();\n            que.pop();\n \n            int v = p.second.first;\n            int m = p.second.second;\n            if(thief[v][m]<p.first) continue;\n            REP(i, g[v].size()){\n                edge e = g[v][i];\n                if(thief[e.to][m] > thief[v][m] + e.t){\n                    thief[e.to][m] = thief[v][m] + e.t;\n                    que.push(pii(make_pair(thief[e.to][m], make_pair(e.to, m))));\n                }\n                if(m >= e.dist && thief[e.to][m-e.dist] > thief[v][m]){\n                    thief[e.to][m-e.dist] = thief[v][m];\n                    que.push(pii(make_pair(thief[e.to][m-e.dist], make_pair(e.to, m-e.dist))));\n                }\n            }\n        }\n        /*\n        REP(i, n+1){\n            REP(j, c+1){\n                cout << dis[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n        int output = INF;\n        REP(i, l+1){\n            output = min(output, thief[n][i]);\n        }\n        cout << output << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n\nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n\nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push({0, s});\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        int cost = st.first;\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push({d[to], to});\n            }\n        }\n    }\n    return d;\n}\n\nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back({e, vv(b, j)});\n                edge[vv(b, j)].push_back({e, vv(a, j)});\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back({0, vv(b, j - d)});\n                    edge[vv(b, j)].push_back({0, vv(a, j - d)});\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n\n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n            \n            res = min(res,val);\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nbool operator==(const State& lhs, const State& rhs)\n{\n    return lhs.loc == rhs.loc && lhs.money == rhs.money && lhs.damage == rhs.damage;\n}\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<int> memo(101, -1);\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (current.money <= memo[current.loc]) {\n                continue;\n            }\n            memo[current.loc] = current.money;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (0 <= current.money - e.dist) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v);\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream&, const tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream& os, const tuple<T...>& t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream& operator<<(ostream& os, const tuple<T...>& t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream&, tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream& is, tuple<T...>& t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream& operator>>(istream& is, tuple<T...>& t){ _it<0>(is, t); return is; }\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\n\n// グラフ用ヘッダ\n\nstruct Edge {\n    int src, dst;\n    int weight, money;\n    Edge(int src, int dst, int weight, int money) :\n        src(src), dst(dst), weight(weight), money(money) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef tuple<int,int,int> State;\nint dp[111][111];\n\nll encode(ll a, ll b, ll c){\n    return a<<32 | b<<16 | c;\n}\n\ntuple<int,int,int> decode(ll x){\n    return mt(x>>32, x>>16 & 0xFFFF, x & 0xFFFF);\n}\n\nint main(){\n    int N,M,L;\n    while(cin>>N>>M>>L && N){\n        Graph g(N);\n        rep(i,M){\n            int a,b,d,e;\n            cin>>a>>b>>d>>e; a--; b--;\n            swap(d,e);\n            g[a].eb(a,b,d,e);\n            g[b].eb(b,a,d,e);\n        }\n        rep(i,111)rep(j,111) dp[i][j] = 1<<29;\n        dp[0][L] = 0;\n        priority_queue<ll> q;\n        q.emplace(encode(0,0,L));\n        while(q.size()){\n            int c,v,money;\n            tie(c,v,money) = decode(q.top()); q.pop();\n            c = -c;\n            if(dp[v][money] < c) continue;\n            for(auto & e : g[v]){\n                if(dp[v][money] + e.weight < dp[e.dst][money]){\n                    dp[e.dst][money] = dp[v][money] + e.weight;\n                    q.emplace(encode(-dp[v][money]+e.weight, e.dst, money));\n                }\n                if(money >= e.money && dp[v][money] < dp[e.dst][money-e.money]){\n                    dp[e.dst][money-e.money] = dp[v][money];\n                    q.emplace(encode(-dp[v][money], e.dst, money-e.money));\n                }\n            }\n        }\n        int ans = dp[N-1][0];\n        rep(i,111) ans = min(ans, dp[N-1][i]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n\nstd::pair<int, int> road[101][101]; //first?????¢ second???\nint dp[101][101];//[??????][??´???] = ??¢????\\????????????°\n\nstruct Node {\n\tint pos, money, attacked;\n};\n\nint main() {\n\tint n, m, l;\n\twhile (std::cin >> n >> m >> l && (n || m || l)) {\n\t\tstd::memset(dp, 0, sizeof(dp));\n\t\tfor (int i = 0; i < 101; i++) for (int j = 0; j < 101; j++) road[i][j] = std::make_pair(0, 0);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, e;\n\t\t\tstd::cin >> x >> y >> d >> e;\n\t\t\troad[x][y] = std::make_pair(d, e);\n\t\t\troad[y][x] = std::make_pair(d, e);\n\t\t}\n\n\t\tstd::stack<Node> s;\n\t\ts.push({1, l, 0});\n\n\t\tint min = 1919810;\n\t\twhile (!s.empty()) {\n\t\t\tauto node = s.top(); s.pop();\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (!road[node.pos][i].first) continue;\n\t\t\t\tauto next = node;\n\t\t\t\tnext.pos = i;\n\n\t\t\t\t//????????????\n\t\t\t\t{\n\t\t\t\t\tauto n2 = next;\n\t\t\t\t\tn2.attacked += road[node.pos][i].second;\n\t\t\t\t\tif (!dp[n2.money][i] || dp[n2.money][i] > next.attacked) {\n\t\t\t\t\t\tif (i == n) min = std::min(min, n2.attacked); //????????????\n\t\t\t\t\t\telse s.push(n2);\n\t\t\t\t\t\tdp[n2.money][i] = n2.attacked;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\tif (next.money >= road[node.pos][i].first) {\n\t\t\t\t\tnext.money -= road[node.pos][i].first;\n\t\t\t\t\tif (!dp[next.money][i] || dp[next.money][i] > next.attacked) {\n\t\t\t\t\t\tif (i == n) min = std::min(min, next.attacked); //????????????\n\t\t\t\t\t\telse s.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << min << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<vector>\n\n#define pb push_back\n#define fs first\n#define sc second\n#define INF 500000000\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P > P2;\n\nint n,m,l;\nint num[110][110];\nvector<int> to[110],d[110],e[110];\n\nint main(){\n  while(scanf(\"%d %d %d\",&n,&m,&l) && (n||m||l)){\n\n    for(int i=1;i<=n;i++){\n      to[i].clear();\n      d[i].clear();\n      e[i].clear();\n    }\n\n    for(int i=0;i<m;i++){\n      int a,b,dis,en;\n      scanf(\"%d %d %d %d\",&a,&b,&dis,&en);\n      to[a].pb(b);\n      d[a].pb(dis);\n      e[a].pb(en);\n      to[b].pb(a);\n      d[b].pb(dis);\n      e[b].pb(en);\n    }\n\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<=l;j++){\n\tnum[i][j] = INF;\n      }\n    }\n\n    num[1][l] = 0;\n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    q.push(P2(0,P(1,l)));\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int en = p.fs, pos = p.sc.fs, mon = p.sc.sc;\n\n      for(int i=0;i<(int)to[pos].size();i++){\n\tint next = to[pos][i];\n\tif(d[pos][i] <= mon){\n\t  int rem = mon - d[pos][i];\n\t  if(num[next][rem] > en){\n\t    num[next][rem] = en;\n\t    q.push(P2(num[next][rem],P(next,rem)));\n\t  }\n\t}\n\tint enemy = en + e[pos][i];\n\tif(num[next][mon] > enemy){\n\t  num[next][mon] = enemy;\n\t  q.push(P2(enemy,P(next,mon)));\n\t}\n      }\n    }\n  \n    int ans = INF;\n    for(int i=0;i<=l;i++)ans = min(ans,num[n][i]);\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint N, M, L;\n\nstruct Edge {\n\tint to, cost, enemy;\n\tEdge(int _t, int _c, int _e) : to(_t), cost(_c), enemy(_e) {}\n};\nbool operator > (const Edge& e1, const Edge& e2) {\n\tif (e1.enemy > e2.enemy) return true;\n\telse if (e1.to > e2.to) return true;\n\treturn e1.cost > e2.cost;\n}\nbool operator == (const Edge& e1, const Edge& e2) {\n\tif (e1.enemy == e2.enemy && e1.to==e2.to && e1.cost == e2.cost) return true;\n\treturn false;\n}\nbool operator != (const Edge& e1, const Edge& e2) { return !(e1 == e2); }\nbool operator < (const Edge& e1, const Edge& e2) { return !(e1 > e2) && (e1 != e2); }\nbool operator >= (const Edge& e1, const Edge& e2) { return (e1 > e2) || (e1 == e2); }\nbool operator <= (const Edge& e1, const Edge& e2) { return (e1 < e2) || (e1 == e2); }\n\nconst int INF = 1e9;\nint d[110][110];\n\nint main() {\n\twhile (1) {\n\t\tcin >> N >> M >> L; if (N==0 && M==0 && L==0) break;\n\t\tvector< vector<Edge> > G(N+1, vector<Edge>());\n\t\t\n\t\tfor (int i=0; i<M; i++) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e;\n\t\t\tG[a].push_back(Edge(b, d, e));\n\t\t\tG[b].push_back(Edge(a, d, e));\n\t\t}\n\t\t\n\t\tfor (int i=0; i<=N; i++) fill(d[i], d[i] + L + 1, INF);\n\t\t\n\t\td[1][0] = 0;\n\t\t\n\t\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\t\tq.push( Edge(1, 0, 0) );\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\t\n\t\t\tfor (int i=0; i<(int)G[e.to].size(); i++) {\n\t\t\t\tEdge ne = G[e.to][i];\n\t\t\t\t\n\t\t\t\tif (e.cost + ne.cost <= L) {\n\t\t\t\t\tif (d[ne.to][e.cost + ne.cost] > e.enemy) {\n\t\t\t\t\t\td[ne.to][e.cost + ne.cost] = e.enemy;\n\t\t\t\t\t\tq.push(Edge(ne.to, e.cost + ne.cost, e.enemy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (d[ne.to][e.cost] > e.enemy + ne.enemy) {\n\t\t\t\t\td[ne.to][e.cost] = e.enemy + ne.enemy;\n\t\t\t\t\tq.push(Edge(ne.to, e.cost, e.enemy + ne.enemy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tfor (int i=0; i<=L; i++) ans = min(ans, d[N][i]);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\nint m;\nint l;\n\nstruct edge{\n\tint to;\n\tint cost;\n\tint damage;\n};\n\nint main(){\n\twhile(cin >> n >> m >> l,n || m || l){\n\t\tvector<vector<int>> dist(n,vector<int>(l + 1,1e9));\n\t\tint s = 0;\n\t\tint t = n - 1;\n\t\tdist[s][l] = 0;\n\n\t\tvector<vector<edge>> edges(n);\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedges[a].push_back({b,d,e});\n\t\t\tedges[b].push_back({a,d,e});\n\t\t}\n\t\tusing P2 = pair<int,P>;\n\t\tpriority_queue<P2,vector<P2>,greater<P2>> que;\n\t\tque.push({0,{s,l}});\n\n\t\twhile(!que.empty()){\n\t\t\tint d = que.top().first;\n\t\t\tint v = que.top().second.first;\n\t\t\tint c = que.top().second.second;\n\t\t\tque.pop();\n\t\t\tif(dist[v][c] < d) continue;\n\n\t\t\tfor(auto& e : edges[v]){\n\t\t\t\t//can use?\n\t\t\t\tif(c - e.cost >= 0 && dist[e.to][c - e.cost] > d){\n\t\t\t\t\tdist[e.to][c - e.cost] = d;\n\t\t\t\t\tque.push({dist[e.to][c - e.cost] , {e.to,c - e.cost}});\n\t\t\t\t}\n\t\t\t\t//dont use?\n\t\t\t\tif(dist[e.to][c] > d + e.damage){\n\t\t\t\t\tdist[e.to][c] = d + e.damage;\n\t\t\t\t\tque.push({dist[e.to][c] , {e.to,c}});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result = 1e9;\n\n\t\tfor(int i = 0;i <= l;i++){\n\t\t\tresult = min(result , dist[t][i]);\n\t\t}\n\n\t\tcout << result << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#define inf 1000000000\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint toi, toj, cost;\n\tedge(int a, int b, int c){\n\t\ttoi = a, toj = b, cost = c;\n\t}\n};\n\nint N, M, L;\nvector<edge> G[105][105];\nint dist[105][105];\npriority_queue< P, vector<P>, greater<P> > Q;\n\nvoid dijkstra()\n{\n\tfor(int i = 0; i <= L; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tdist[i][j] = inf;\n\t\t}\n\t}\n\tdist[0][1] = 0;\n\tQ.push( make_pair(0, 1) );\n\t\n\tint ui, uj, vi, vj, d;\n\twhile(Q.size()){\n\t\tui = Q.top().second / 1000;\n\t\tuj = Q.top().second % 1000;\n\t\td = Q.top().first;\n\t\tQ.pop();\n\t\tif(d > dist[ui][uj]) continue;\n\t\tfor(int i = 0; i < G[ui][uj].size(); i++){\n\t\t\tvi = G[ui][uj][i].toi;\n\t\t\tvj = G[ui][uj][i].toj;\n\t\t\tif(dist[vi][vj] > dist[ui][uj] + G[ui][uj][i].cost){\n\t\t\t\tdist[vi][vj] = dist[ui][uj] + G[ui][uj][i].cost;\n\t\t\t\tQ.push(make_pair(dist[vi][vj], vi * 1000 + vj));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\t\n\t\tint a, b, d, e;\n\t\tif(N == 0 && M == 0 && L == 0) break;\n\t\t\n\t\tfor(int i = 0; i <= L; i++){\n\t\t\tfor(int j = 1; j <= N; j++){\n\t\t\t\tG[i][j].clear();\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int m = 0; m < M; m++){\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tfor(int i = 0; i <= L; i++){\n\t\t\t\tG[i][a].push_back(edge(i, b, e));\n\t\t\t\tG[i][b].push_back(edge(i, a, e));\n\t\t\t\tif(i + d <= L){\n\t\t\t\t\tG[i][a].push_back(edge(i+d, b, 0));\n\t\t\t\t\tG[i][b].push_back(edge(i+d, a, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdijkstra();\n\t\t\n\t\tint ans = inf;\n\t\tfor(int i = 0; i <= L; i++) ans = min(ans, dist[i][N]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=105;\nconst ll INF=1LL<<60;\n\nvector<pair<int,pair<int,int>>> G[MAX];\nll dis[MAX][MAX];\nint L;\n\nvoid dijkstra(int u){\n    priority_queue<pair<ll,pair<int,int>>,vector<pair<ll,pair<int,int>>>,greater<pair<ll,pair<int,int>>>> PQ;\n    \n    dis[u][L]=0;\n\n    PQ.push(make_pair(0,make_pair(u,L)));\n    while(!PQ.empty()){\n        int a=PQ.top().first;\n        int b=PQ.top().second.first;\n        int c=PQ.top().second.second;\n        PQ.pop();\n        if(dis[b][c]<a) continue;\n        for(int i=0;i<G[b].size();i++){\n            int d=G[b][i].first;\n            int e=G[b][i].second.first;\n            int f=G[b][i].second.second;\n            \n            if(c>=e){\n                if(dis[d][c-e]>dis[b][c]){\n                    dis[d][c-e]=dis[b][c];\n                    PQ.push(make_pair(dis[d][c-e],make_pair(d,c-e)));\n                }\n            }\n            \n            if(dis[d][c]>dis[b][c]+f){\n                dis[d][c]=dis[b][c]+f;\n                PQ.push(make_pair(dis[d][c],make_pair(d,c)));\n            }\n        }\n    }\n    return;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N,M;cin>>N>>M>>L;\n        if(N+M+L==0) break;\n        \n        for(int i=0;i<=N;i++){\n            for(int j=0;j<=L;j++){\n                dis[i][j]=INF;\n            }\n            G[i].clear();\n        }\n        \n        for(int i=0;i<M;i++){\n            int a,b,c,d;cin>>a>>b>>c>>d;\n            a--;b--;\n            G[a].push_back({b,{c,d}});\n            G[b].push_back({a,{c,d}});\n            \n            //cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n        }\n        \n        dijkstra(0);\n        \n        ll ans=INF;\n        \n        for(int i=0;i<=L;i++){\n            ans=min(ans,dis[N-1][i]);\n        }\n        \n        cout<<ans<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = i64(1e9) + 7;\nconst i64 INF = i64(1e18) + 7;\n\nbool solve(){\n    int n, m, l;\n    cin >> n >> m >> l;\n    if(n == 0)\n        return false;\n\n    vector<int> a(m), b(m), d(m), e(m);\n\n    for(int i = 0; i < m; ++i)\n        cin >> a[i] >> b[i] >> d[i] >> e[i];\n\n    struct Edge{\n        int to, dist, enemy;\n    };\n\n    vector<vector<Edge>> edges(n);\n\n    for(int i = 0; i < m; ++i){\n        --a[i], --b[i];\n        Edge ed{b[i], d[i], e[i]};\n        Edge rev{a[i], d[i], e[i]};\n        edges[a[i]].push_back(ed);\n        edges[b[i]].push_back(rev);\n    }\n\n    vector<vector<i64>> dp(n, vector<i64>(l + 1, INF));\n    dp[0][l] = 0;\n    priority_queue<tuple<i64,int,int>, vector<tuple<i64,int,int>>, greater<tuple<i64,int,int>>> que;\n    que.emplace(0, 0, l);\n\n    auto chmin = [&](auto& x, auto y){\n        if(x > y){\n            x = y;\n            return true;\n        }\n        return false;\n    };\n\n    while(!que.empty()){\n        i64 val, pos, money;\n        tie(val, pos, money) = que.top();\n        que.pop();\n        if(dp[pos][money] != val)\n            continue;\n        for(auto& ed : edges[pos]){\n            if(chmin(dp[ed.to][money], dp[pos][money] + ed.enemy))\n                que.emplace(dp[ed.to][money], ed.to, money);\n\n            if(money >= ed.dist && chmin(dp[ed.to][money - ed.dist], dp[pos][money]))\n                que.emplace(dp[ed.to][money - ed.dist], ed.to, money - ed.dist);\n        }\n    }\n    i64 ans = *min_element(dp.back().begin(), dp.back().end());\n    cout << (ans == INF ? -1 : ans) << endl;\n\n\n    return true;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nstruct edge\n{\n    int to, dist, cnt;\n    edge(int to, int dist, int cnt) : to(to), dist(dist), cnt(cnt) {}\n    bool operator<(const edge &e) const { return cnt > e.cnt; }\n};\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, l;\n    while(cin >> n >> m >> l, n | m | l)\n    {\n        vector<edge> G[n];\n        for(int i = 0; i < m; i++)\n        {\n            int a, b, d, e; cin >> a >> b >> d >> e;\n            a--, b--;\n            G[a].push_back(edge(b, d, e));\n            G[b].push_back(edge(a, d, e));\n        }\n        vector<vector<int>> cost(n, vector<int>(l + 1, INF));\n        priority_queue<edge> que;\n        que.push(edge(0, l, 0));\n        cost[0][l] = 0;\n        while(que.size())\n        {\n            edge p = que.top(); que.pop();\n            int money = p.dist;\n            //cout << p.to << \" \" << p.dist << \" \" << p.cnt << endl;\n            for(int u = 0; u < G[p.to].size(); u++)\n            {\n                edge e = G[p.to][u];\n                if(money - e.dist >= 0)\n                {\n                    if(cost[p.to][money] < cost[e.to][money - e.dist])\n                    {\n                        cost[e.to][money - e.dist] = cost[p.to][money];\n                        que.push(edge(e.to, money - e.dist, p.cnt));\n                    }\n                }\n                if(cost[p.to][money] + e.cnt < cost[e.to][money])\n                {\n                    cost[e.to][money] = cost[p.to][money] + e.cnt;\n                    que.push(edge(e.to, money, p.cnt + e.cnt));\n                }\n            }\n        }\n        int ans = INF;\n        for(int i = 0; i <= l; i++) ans = min(ans, cost[n - 1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nvoid dijkstra(int n, vector< vector<edge> >& G, int s, vector<ll>& d) {\n\tfill(d.begin(), d.end(), LLONG_MAX); d[s] = 0;\n\tpriority_queue<ll_i, vector<ll_i>, greater<ll_i> > q;\n\tq.push(ll_i(0, s));\n\twhile (!q.empty()) {\n\t\tll_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(ll_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tfor (;;) {\n\t\tint N, M, L; cin >> N >> M >> L;\n\t\tif (N == 0) break;\n\t\tint n = N * (L + 1);\n\t\tvector< vector<edge> > G(n);\n\t\twhile (M--) {\n\t\t\tint A, B, D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tA--; B--;\n\t\t\tfor (int l = 0; l <= L; l++) {\n\t\t\t\tint u = A * (L + 1) + l, v = B * (L + 1) + l;\n\t\t\t\tedge e = {u, v, E};\n\t\t\t\tG[u].push_back(e);\n\t\t\t}\n\t\t\tfor (int l = 0; l <= L; l++) {\n\t\t\t\tint u = B * (L + 1) + l, v = A * (L + 1) + l;\n\t\t\t\tedge e = {u, v, E};\n\t\t\t\tG[u].push_back(e);\n\t\t\t}\n\t\t\tfor (int l = 0; l + D <= L; l++) {\n\t\t\t\tint u = A * (L + 1) + (l + D), v = B * (L + 1) + l;\n\t\t\t\tedge e = {u, v, 0};\n\t\t\t\tG[u].push_back(e);\n\t\t\t}\n\t\t\tfor (int l = 0; l + D <= L; l++) {\n\t\t\t\tint u = B * (L + 1) + (l + D), v = A * (L + 1) + l;\n\t\t\t\tedge e = {u, v, 0};\n\t\t\t\tG[u].push_back(e);\n\t\t\t}\n\t\t}\n\t\tvector<ll> d(n);\n\t\tdijkstra(n, G, L, d);\n\t\tll mini = LLONG_MAX;\n\t\tfor (int l = 0; l <= L; l++)\n\t\t\tmini = min(mini, d[(N - 1) * (L + 1) + l]);\n\t\tcout << mini << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int from;\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    if(a.enemy==b.enemy){\n        return a.money < b.money;\n    }else {\n        return a.enemy > b.enemy;\n    }\n}\n\nstruct node maps[(int)1e8];\n\nint main()\n{\n    int n,m,l;\n\n    cin.tie();\n    ios::sync_with_stdio(false);\n    while (scanf(\"%d%d%d\",&n,&m,&l)==3 && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            a--;\n            b--;\n            maps[a].data.push_back((struct data){b,d,e});\n            maps[b].data.push_back((struct data){a,d,e});\n        }\n        queue.push((struct state){0,0,l,0});\n        while (!queue.empty()){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                printf(\"%d\\n\",s.enemy);\n                while (!queue.empty()){\n                    queue.pop();\n                }\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.to!=s.from) {\n                        if (d.dis <= s.money) {\n                            queue.push((struct state) {s.number, d.to, s.money - d.dis, s.enemy});\n                        }\n                        queue.push((struct state) {s.number, d.to, s.money, s.enemy + d.ene});\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef pair <int,pair <int,int> > P;\n#define dis first\n#define node second.first\n#define mo second.second\n#define INF 1000000000;\nint N,M,L;\npair <int,int> mp[101][101];\n\nP mk(int a,int b, int c){\n  P res;\n  res.dis = a, res.node = b; res.mo = c;\n  return res;\n}\n\nint dijkstra(){\n  priority_queue < P, vector<P>, greater<P> > Q;\n  int D[101][101],visited[101][101]={};\n  for(int i=0;i<=L;i++)\n    for(int j=0;j<=N;j++) D[i][j] = INF;\n  Q.push(mk(0,1,0)),  D[0][1] = 0;\n\n  while(!Q.empty()) {\n    P t = Q.top(); Q.pop();\n    if(visited[t.mo][t.node] != 0) continue;\n    visited[t.mo][t.node] = 1;\n    if(t.node == N) return t.dis;\n\n    for(int i=1;i<=N;i++){\n      if(mp[t.node][i].first == -1) continue;\n      int nmo = t.mo+mp[t.node][i].first;\n      int ndis = t.dis + mp[t.node][i].second;\n      if(nmo <=L && D[nmo][i] > t.dis )Q.push(mk(t.dis,i,nmo));\n      if(D[t.mo][i] > ndis ) Q.push(mk(ndis,i,t.mo));\n    }\n  }\n  return -1;   \n}\n\nint main() {\n\n  while(1) {\n  cin >> N >> M >> L;\n  if(N==0 && M==0 && L==0) break;\n  for(int i=0;i<=N;i++)\n    for(int j=0;j<=N;j++) mp[i][j].first= -1;\n\n  for(int i=0;i<M;i++){\n    int x,y,z,w;\n    cin >> x >> y >> z >> w;\n    mp[x][y].first = z,mp[x][y].second = w;\n    mp[y][x].first = z,mp[y][x].second = w;\n  }\n  cout << dijkstra() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int from;\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    if(a.enemy==b.enemy){\n        return a.money < b.money;\n    }else {\n        return a.enemy > b.enemy;\n    }\n}\n\nstruct node maps[200];\n\nint main()\n{\n    int n,m,l;\n\n    cin.tie();\n    ios::sync_with_stdio(false);\n    while (scanf(\"%d%d%d\",&n,&m,&l)==3 && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            a--;\n            b--;\n            maps[a].data.push_back((struct data){b,d,e});\n            maps[b].data.push_back((struct data){a,d,e});\n        }\n        queue.push((struct state){0,0,l,0});\n        while (!queue.empty()){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                printf(\"%d\\n\",s.enemy);\n                while (!queue.empty()){\n                    queue.pop();\n                }\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.to!=s.from) {\n                        if (d.dis <= s.money) {\n                            queue.push((struct state) {s.number, d.to, s.money - d.dis, s.enemy});\n                        }\n                        queue.push((struct state) {s.number, d.to, s.money, s.enemy + d.ene});\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define ISEQ(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1000000000;\n\nint main() {\n  while (true) {\n    int n ,m, l;\n    scanf(\"%d%d%d\", &n, &m, &l);\n    if (n == 0) break;\n    int dp[n][n][l+1];\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < n; j++) {\n\tint s = (i == j) ? 0 : INF;\n\tfor (int k = 0; k <= l; k++)\n\t  dp[i][j][k] = s;\n      }\n\n    for (int i = 0; i < m; i++) {\n      int a, b, d, e;\n      scanf(\"%d%d%d%d\", &a, &b, &d, &e);\n      a--; b--;\n      for (int j = 0; j <= l; j++) {\n\tif (j < d)\n\t  dp[a][b][j] = dp[b][a][j] = e;\n\telse\n\t  dp[a][b][j] = dp[b][a][j] = 0;\n      }\n    }\n\n    for (int k = 0; k < n; k++) {\n      for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t  for (int a = 0; a <= l; a++) {\n\t    int mini = INF;\n\t    for (int b = 0; b <= a; b++) {\n\t      mini = min(dp[i][k][a-b] + dp[k][j][b], mini);\n\t      if (mini == 0) break;\n\t    }\n\t    dp[i][j][a] = min(mini, dp[i][j][a]);\n\t    if (mini == 0) {\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\", dp[0][n-1][l]);\n  }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct inn{\n\tint n,c,r;\n\tinn(int n,int c,int r):n(n),c(c),r(r){}\n\tbool operator<(const inn& other)const{\n\t\treturn r>other.r;\n\t}\n};\nconst int MAX=INT_MAX/10;\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n){\n\t\tvvi dist(n,vi(n,-1));\n\t\tvvi risk(n,vi(n,MAX));\n\t\tREP(i,m){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\tdist[a-1][b-1]=d;\n\t\t\tdist[b-1][a-1]=d;\n\t\t\trisk[a-1][b-1]=e;\n\t\t\trisk[b-1][a-1]=e;\n\t\t}\n\t\t\n\t\tpriority_queue<inn> q;\n\t\tq.push(inn(0,0,0));\n\t\tvvi cost(n,vi(l+1,MAX));\n\t\tcost[0][0]=0;\n\t\twhile(!q.empty()){\n\t\t\tinn in=q.top();q.pop();\n\t\t\tif(cost[in.n][in.c]<in.r){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(i,n){\n\t\t\t\tif(i!=in.n&&dist[in.n][i]!=-1){\n\t\t\t\t\tREP(j,2){\n\t\t\t\t\t\tint nr=in.r+(j==1?0:risk[in.n][i]);\n\t\t\t\t\t\tint nc=in.c+(j==0?0:dist[in.n][i]);\n\t\t\t\t\t\tif(nc<=l&&cost[i][nc]>nr){\n\t\t\t\t\t\t\tcost[i][nc]=nr;\n\t\t\t\t\t\t\tq.push(inn(i,nc,nr));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint best=INT_MAX;\n\t\tREP(i,l+1){\n\t\t\tbest=min(best,cost[n-1][i]);\n\t\t}\n\t\tcout<<best<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct edge\n {\n \tint to,cost,enemy;\n }; \n\n struct P\n {\n \tint from, money, enemy;\n \tbool operator >(const P &p) const{\n \t\treturn enemy>p.enemy;\n \t}\n };\n\nint main() {\n\tint N,M,L;\n\twhile(cin >> N >> M >> L, N|M|L){\n\t\tvector<vector<edge> > E=vector<vector<edge> >(N+1);\n\t\tREP(i, M){\n\t\t\tint from, to, cost, enemy;\n\t\t\tcin >> from >> to >> cost >> enemy;\n\t\t\tE[from].push_back((edge){to, cost, enemy});\n\t\t\tE[to].push_back((edge){from, cost, enemy});\n\t\t}\n\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tvector<int> costs=vector<int>(N+1);\n\t\tREP(i, costs.size()){\n\t\t\tcosts[i]=INT_MAX;\n\t\t}\n\n\t\tque.push((P){1, L, 0});\n\t\tint res=-1;\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.from==N){\n\t\t\t\tres=p.enemy;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(p.enemy>costs[p.from])continue;\n\t\t\tcosts[p.from]=p.enemy;\n\t\t\tREP(i, E[p.from].size()){\n\t\t\t\tedge e=E[p.from][i];\n\t\t\t\tif(p.money>=e.cost){\n\t\t\t\t\tque.push((P){e.to, p.money-e.cost,p.enemy});\n\t\t\t\t}\n\t\t\t\tque.push((P){e.to, p.money, p.enemy+e.enemy});\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N || M || L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (e.dist <= current.money) {\n                    pq.push({e.to, current.money - e.dist, current.damage});\n                }\n                // 護衛を雇わない\n                pq.push({e.to, current.money, current.damage + e.enemy});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct edge{\n    int to, dist, attack;\n};\n\nstruct P {\n    int from, money, enemy;\n\n    bool operator >(const P& p) const {\n        return enemy > p.enemy;\n    }\n};\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nint N, M, L;\n\nint main() {\n    while (cin >> N >> M >> L, N|M|L) {\n        vector<vector<edge>> E(N+1);\n        REP(i, M) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            E[from].push_back((edge){to, dist, enemy});\n            E[to].push_back((edge){from, dist, enemy});\n        }\n\n        //bool G[N+1][L+1];\n        //fill_n((bool *)G, (N+1)*(L+1), false);\n\n        priority_queue<P, vector<P>, greater<P>> q;\n        // start\n        q.push((P){1, L, 0});\n        int enemy = 0;\n        while (!q.empty()) {\n            P p = q.top(); q.pop();\n            // goal\n            if (p.from == N) {\n                enemy = p.enemy;\n                break;\n            }\n            //if (G[p.from][p.money]) continue;\n            //G[p.from][p.money] = true;\n            for (edge e : E[p.from]) {\n                if (p.money >= e.dist) {\n                    q.push((P){e.to, p.money - e.dist, p.enemy});\n                }\n                q.push((P){e.to, p.money, p.enemy + e.attack});\n            }\n        }\n\n        cout << enemy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nint main(){\n\tfor(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n;){\n\t\tint s=0,g=n-1;\n\n\t\tstatic int dis[100][100],cost[100][100];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\tdis[i][j]=(i==j?0:-1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\tscanf(\"%d%d%d%d\",&a,&b,&d,&e);\n\t\t\ta--,b--;\n\t\t\tdis[a][b]=dis[b][a]=d;\n\t\t\tcost[a][b]=cost[b][a]=e;\n\t\t}\n\n\t\tstatic int cmin[100][101];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<=l;j++)\tcmin[i][j]=1<<30;\n\n\t\tint ans;\n\t\tpriority_queue< pair<int,pii> > pq;\tpq.push(mp(0,mp(s,l)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\tint nowcost=-a.first,u=a.second.first,bud=a.second.second;\n\t\t\tif(u==g){ ans=nowcost; break; }\n\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(~dis[u][v]){\n\t\t\t\t\tint nextcost=nowcost+cost[u][v];\n\t\t\t\t\tint nextbud=bud;\n\t\t\t\t\tif(nextcost<cmin[v][nextbud]){\n\t\t\t\t\t\tpq.push(mp(-nextcost,mp(v,nextbud)));\n\t\t\t\t\t\tcmin[v][nextbud]=nextcost;\n\t\t\t\t\t}\n\n\t\t\t\t\tnextcost=nowcost;\n\t\t\t\t\tnextbud=bud-dis[u][v];\n\t\t\t\t\tif(nextbud<0)\tcontinue;\n\t\t\t\t\tif(nextcost<cmin[v][nextbud]){\n\t\t\t\t\t\tpq.push(mp(-nextcost,mp(v,nextbud)));\n\t\t\t\t\t\tcmin[v][nextbud]=nextcost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nint main() {\n    int N, M, L;\n    int a,b;\n    int now;\n    cin >> N >> M >> L;\n    for(;N!=0;){\n        vector<vector<bool>> graph(N,vector<bool>(N,false));\n        vector<vector<int>> distance(N,vector<int>(N)),evect(N,vector<int>(N));\n        vector<vector<int>> dp(N,vector<int>(L+1,1000000000));\n        vector<vector<int>> dp_old(N,vector<int>(L+1,1000000000));\n        queue<int> vertex;\n        for(int i=0; i< M; i++){\n            cin >> a >> b;\n            a--;b--;\n            graph[a][b] = true; graph[b][a] = true;\n            cin >> distance[a][b] >> evect[a][b];\n            distance[b][a] = distance[a][b];\n            evect[b][a] = evect[a][b];\n        }\n        for(int i=0;i<=L;i++){\n            dp_old[0][i] = 0;\n            dp[0][i] = 0;\n        }\n        for(int itr=0;itr<N;itr++){\n        vector<bool> reached(N,false);\n        reached[0] = true;\n        if(itr==0){\n        for(int i=0; i<N; i++){\n            if(graph[0][i]){\n                vertex.push(i);\n                reached[i]=true;\n                //graph[0][i] = false;\n                //graph[i][0] = false;\n                dp_old[i][L] = evect[0][i];\n                dp[i][L] = evect[0][i];\n                if(L>=distance[0][i]){\n                    dp_old[i][L-distance[0][i]] = 0;\n                    dp[i][L-distance[0][i]] = 0;\n                }\n            }\n        }\n        }else{\n            for(int i=0 ; i< N ; i++){\n                if(graph[0][i]){\n                    vertex.push(i);\n                    reached[i]=true;\n                }\n            }\n        }\n        for(;!vertex.empty();){\n            now = vertex.front();\n            reached[now] = true;\n            vertex.pop();\n            for(int i=0; i<N; i++){\n                if(graph[now][i]){\n                    if(!reached[i])vertex.push(i);\n                    for(int j=0;j<=L; j++){\n                        if(j+distance[now][i]<=L){\n                            dp[now][j] = min(dp_old[now][j],min(dp_old[i][j]+evect[now][i],dp_old[i][j+distance[now][i]]));\n                            dp[i][j] = min(dp_old[i][j],min(dp_old[now][j]+evect[now][i],dp_old[now][j+distance[now][i]]));\n                        }else{\n                            dp[now][j] = min(dp_old[i][j]+evect[now][i],dp_old[now][j]);\n                            dp[i][j] = min(dp_old[now][j]+evect[now][i],dp_old[i][j]);\n                        }\n                    }\n                    swap(dp,dp_old);\n                }\n            }\n        }\n        }\n        int ans=dp[N-1][L];\n        for(int i=0; i<L ; i++){\n            ans=min(ans,dp[N-1][i]);\n        }\n        cout << ans << endl;\n\n        cin >> N >> M >>L;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    return a.enemy>b.enemy;\n}\n\nstruct node maps[100];\n\nint main()\n{\n    int n,m,l;\n\n    while ((cin>>n>>m>>l) && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            maps[a-1].data.push_back((struct data){b-1,d,e});\n            maps[b-1].data.push_back((struct data){a-1,d,e});\n        }\n        queue.push((struct state){0,l,0});\n        bool flag=true;\n        while (!queue.empty() && flag){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                cout<<s.enemy<<endl;\n                flag= false;\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.dis<=s.money){\n                        queue.push((struct state){d.to,s.money-d.dis,s.enemy});\n                    }\n                    queue.push((struct state){d.to,s.money,s.enemy+d.ene});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define MAX 100000000\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<int,p> P;\n//G@ê@à\nstruct edge{\n\tint to,cost,enem;\n};\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n||m||l){\n\t\tvector<edge> tab[110];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedge pre;\n\t\t\tpre.cost=d;\n\t\t\tpre.enem=e;\n\t\t\tpre.to=b;\n\t\t\ttab[a].push_back(pre);\n\t\t\tpre.to=a;\n\t\t\ttab[b].push_back(pre);\n\t\t}\n\t\tint d[110][110];\n\t\t//d[ê][à]=G;\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<100;j++){\n\t\t\td[i][j]=MAX;\n\t\t}\n\t\td[0][l]=0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,p(0,l)));\n\t\twhile(!que.empty()){\n\t\t\tP now=que.top();\n\t\t\tque.pop();\n\t\t\tint nowplace=now.second.first;\n\t\t\tint nowenem=now.first;\n\t\t\tint nowmoney=now.second.second;\n\t\t\tif(d[nowplace][nowmoney]<nowenem)\n\t\t\t\tcontinue;\n\t\t\td[nowplace][nowmoney]=nowenem;\n\t\t\tfor(int i=0;i<(int)tab[nowplace].size();i++){\n\t\t\t\tedge e=tab[nowplace][i];\n\t\t\t\tif(e.cost<=nowmoney){\n\t\t\t\t\tque.push(P(nowenem,p(e.to,nowmoney-e.cost)));\n\t\t\t\t}\n\t\t\t\tque.push(P(nowenem+e.enem,p(e.to,nowmoney)));\n\t\t\t}\n\t\t}\n\t\tint ans=MAX;\n\t\tfor(int i=0;i<=l;i++)\n\t\tans=min(ans,d[n-1][i]);\n\t\tcout<<ans<<endl;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v);\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream&, const tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream& os, const tuple<T...>& t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream& operator<<(ostream& os, const tuple<T...>& t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream&, tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream& is, tuple<T...>& t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream& operator>>(istream& is, tuple<T...>& t){ _it<0>(is, t); return is; }\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\n\n// グラフ用ヘッダ\n\nstruct Edge {\n    int src, dst;\n    int weight, money;\n    Edge(int src, int dst, int weight, int money) :\n        src(src), dst(dst), weight(weight), money(money) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint dp[111][111];\n\nint main(){\n    int N,M,L;\n    while(cin>>N>>M>>L && N){\n        Graph g(N);\n        rep(i,M){\n            int a,b,d,e;\n            cin>>a>>b>>d>>e; a--; b--;\n            swap(d,e);\n            g[a].eb(a,b,d,e);\n            g[b].eb(b,a,d,e);\n        }\n        rep(i,111)rep(j,111) dp[i][j] = 1<<29;\n        dp[0][L] = 0;\n        typedef tuple<int,int,int> State;\n        priority_queue<State> q;\n        q.emplace(0,0,L);\n        while(q.size()){\n            int c,v,money;\n            tie(c,v,money) = q.top(); q.pop();\n            c = -c;\n            if(dp[v][money] < c) continue;\n            for(auto & e : g[v]){\n                if(dp[v][money] + e.weight < dp[e.dst][money]){\n                    dp[e.dst][money] = dp[v][money] + e.weight;\n                    q.emplace(dp[v][money]+e.weight, e.dst, money);\n                }\n                if(money >= e.money && dp[v][money] < dp[e.dst][money-e.money]){\n                    dp[e.dst][money-e.money] = dp[v][money];\n                    q.emplace(dp[v][money], e.dst, money-e.money);\n                }\n            }\n        }\n        int ans = dp[N-1][0];\n        rep(i,111) ans = min(ans, dp[N-1][i]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\n//int checker[4];\n//int ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\t//int check[4];\n\tState() {}\n\t//\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\t/*\n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t\t*/\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n/*\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n*/\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min = b;\n\t\twhile ( itr != points[i].end() ) {\n\t\t\tif ( (*itr).second > min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t} else if ( (*itr).second <= min ) {\n\t\t\t\t(*itr).second = min;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t/*\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\t*/\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\t//ncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//copy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t/*\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n//\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint n, m, l;\nvector<vector<pair<int, pair<int, int> > > > graph(101);\n\nint solve()\n{\n\tvector<vector<int> > result(101, vector<int>(101, mod));\n\t// result[i][j] : 1??????i?????§??§?§???????????????????????????????j????????????????????´????\\??????????????????¢?????°\n\tint ans = mod;\n\tpriority_queue<pair<int, pair<int, int> > > qu;\n\t// ????????£????????¢?????° / ???????????´??? / ??????\n\tqu.push(make_pair(0, make_pair(1, l)));\n\twhile(!qu.empty()){\n\t\tint enemnum = -(qu.top()).first;\n\t\tint now = ((qu.top()).second).first;\n\t\tint restmoney = ((qu.top()).second).second;\n\t\tqu.pop();\n\t\tif(result[now][restmoney] <= enemnum) continue;\n\t\tresult[now][restmoney] = enemnum;\n\t\tif(now == n) ans = min(ans, enemnum);\n\t\tfor(int i = 0; i < graph[now].size(); i++){\n\t\t\tint next = graph[now][i].first;\n\t\t\tint d = (graph[now][i].second).first;\n\t\t\tint e = (graph[now][i].second).second;\n\t\t\tif(restmoney >= d) qu.push(make_pair(-enemnum, make_pair(next, restmoney - d)));\n\t\t\tqu.push(make_pair(-(enemnum + e), make_pair(next, restmoney)));\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile(1){\n\t\tcin >> n >> m >> l;\n\t\tif(n == 0 && m == 0 && l == 0) break;\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tgraph[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tgraph[a].push_back(make_pair(b, make_pair(d, e)));\n\t\t\tgraph[b].push_back(make_pair(a, make_pair(d, e)));\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nstruct edge { int to, dist, cost; };\nbool operator<(const edge& e1, const edge& e2) { return e1.cost < e2.cost; }\nint N, M, L, a1, a2, a3, a4;\nint main() {\n\twhile (cin >> N >> M >> L, N | M | L) {\n\t\tvector<vector<edge> > G(N);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a1 >> a2 >> a3 >> a4; a1--, a2--;\n\t\t\tG[a1].push_back(edge{ a2, a3, a4 });\n\t\t\tG[a2].push_back(edge{ a1, a3, a4 });\n\t\t}\n\t\tvector<vector<int> > d(N, vector<int>(L + 1, 999999999)); d[0][L] = 0;\n\t\tpriority_queue<edge> que; que.push(edge{ 0, L, 0 });\n\t\twhile (!que.empty()) {\n\t\t\tedge u = que.top(); que.pop();\n\t\t\tfor (edge e : G[u.to]) {\n\t\t\t\tif (u.dist >= e.dist) {\n\t\t\t\t\tint dist1 = u.dist - e.dist;\n\t\t\t\t\tint cost1 = -u.cost;\n\t\t\t\t\tif (d[e.to][dist1] > cost1) {\n\t\t\t\t\t\td[e.to][dist1] = cost1;\n\t\t\t\t\t\tque.push(edge{ e.to, dist1, -cost1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint dist2 = u.dist;\n\t\t\t\tint cost2 = -u.cost + e.cost;\n\t\t\t\tif (d[e.to][dist2] > cost2) {\n\t\t\t\t\td[e.to][dist2] = cost2;\n\t\t\t\t\tque.push(edge{ e.to, dist2, -cost2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = *min_element(d[N - 1].begin(), d[N - 1].end());\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint cost[111][111];\n\nint main() {\n  int n, m, l;\n  while (true) {\n    cin >> n >> m >> l;\n    if (n == 0 && m == 0 && l == 0) break;\n    vector<pair<int, pair<int, int> > > edge[n];\n    rep (i, m) {\n      int a, b, d, e;\n      cin >> a >> b >> d >> e;\n      --a; --b;\n      edge[a].push_back(make_pair(b, make_pair(d, e)));\n      edge[b].push_back(make_pair(a, make_pair(d, e)));\n    }\n    rep (i, 111) rep (j, 111) cost[i][j] = 1000000000;\n    priority_queue<pair<int, pair<int, int> >, vector<pair<int, pair<int, int> > >, greater<pair<int, pair<int, int> > > > que;\n    que.push(make_pair(0, make_pair(0, l)));\n    while (!que.empty()) {\n      pair<int, pair<int, int> > now = que.top();\n      que.pop();\n      if (cost[now.second.first][now.second.second] <= now.first) continue;\n      cost[now.second.first][now.second.second] = now.first;\n      rep (i, edge[now.second.first].size()) {\n\tque.push(make_pair(now.first + edge[now.second.first][i].second.second, make_pair(edge[now.second.first][i].first, now.second.second)));\n\tif (now.second.second >= edge[now.second.first][i].second.first) {\n\t  que.push(make_pair(now.first, make_pair(edge[now.second.first][i].first, now.second.second - edge[now.second.first][i].second.first)));\n\t}\n      }\n    }\n    int res = 1000000000;\n    rep (i, 111) res = min(res, cost[n - 1][i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nclass Edge{\npublic:\n    int to, dis, e;\n    \n    Edge(int to, int dis, int e): to(to), dis(dis), e(e){};\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, M, L;\n    while(cin>>N>>M>>L, N|M|L){\n        vector<vector<Edge>> edges(N);\n        for(int i=0; i<M; i++){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--; b--;\n            edges[a].push_back(Edge(b, d, e));\n            edges[b].push_back(Edge(a, d, e));\n        }\n        \n        vector<vector<int>> dp(N, vector<int>(L+1, INF));\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> q;\n        \n        dp[0][L] = 0;\n        q.push(make_pair(dp[0][L], make_pair(0, L)));\n        \n        while (!q.empty()) {\n            auto p = q.top(); q.pop();\n            int e = p.first;\n            int v = p.second.first;\n            int l = p.second.second;\n            if(dp[v][l] < e)\n                continue;\n            \n            for(auto edge: edges[v]){\n                if(edge.dis <= l && dp[edge.to][l-edge.dis] > e){\n                    dp[edge.to][l-edge.dis] = e;\n                    q.push(make_pair(e, make_pair(edge.to, l-edge.dis)));\n                }\n                if(dp[edge.to][l] > e+edge.e){\n                    dp[edge.to][l] = e+edge.e;\n                    q.push(make_pair(e+edge.e, make_pair(edge.to, l)));\n                }\n            }\n        }\n        int ans = INF;\n        for(int i=0; i<=L; i++)\n            ans = min(ans, dp[N-1][i]);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110][110];\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(memo[nokori][now]<=sum)return;\n  memo[nokori][now]=sum;\n  if(now==n){\n    ans=min(ans,sum);\n    return;\n  }\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      used[E[now][i].to]=true;\n      if(nokori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n      for(int j=0;j<l+5;j++)\n\tmemo[j][i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n\nconst int INF = 1e9;\nint D[101][101];\nint E[101][101];\nint memo[101][101];\n\nint main() {\n\n\tint n, m, l;\n\n\twhile (cin >> n >> m >> l && n) {\n\n\t\trep(i, 101)rep(j, 101) {\n\t\t\tD[i][j] = INF;\n\t\t\tE[i][j] = 0;\n\t\t\tmemo[i][j] = INF;\n\t\t}\n\t\trep(i, m) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tD[a][b] = D[b][a] = d;\n\t\t\tE[a][b] = E[b][a] = e;\n\t\t}\n\t\tqueue<pair<int, int>> q;\n\t\tq.push(make_pair(1, l));\n\t\tmemo[1][l] = 0;\n\t\twhile (q.size()) {\n\t\t\tint now = q.front().first;\n\t\t\tint res = q.front().second;\n\t\t\tq.pop();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (D[now][i] != INF) {\n\t\t\t\t\tif (res - D[now][i] >= 0) {\n\t\t\t\t\t\tif (memo[i][res - D[now][i]] > memo[now][res]) {\n\t\t\t\t\t\t\tmemo[i][res - D[now][i]] = memo[now][res];\n\t\t\t\t\t\t\tq.push(make_pair(i, res - D[now][i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (memo[i][res] > memo[now][res] + E[now][i]) {\n\t\t\t\t\t\tmemo[i][res] = memo[now][res] + E[now][i];\n\t\t\t\t\t\tq.push(make_pair(i, res));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i <= l; i++) {\n\t\t\tans = min(ans, memo[n][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n// int n_dir = 4;\n// int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; [> CSS order <]\n// enum direction {\n\t// UP, RIGHT, DOWN, LEFT\n// };\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// };\n// #define FORDIR(d) REP (d, n_dir)\n\ntypedef complex<int> P;\n#define Y real()\n#define X imag()\nP dyx[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\n// P dyx[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\n\nint g_height, g_width;\nbool in_field(P p) {\n\treturn (0 <= p.Y && p.Y < g_height) && (0 <= p.X && p.X < g_width);\n}\n\n/*}}}*/\n\n// My version of (Extended) Dijkstra\n// Pros: easy to access `costs` -- just `costs(node)`\n//       vector with many parameters is confusing e.g. `costs[param1][param2][param3]...`\n\n// Node should have only parameters with which Node can be distinguished\nclass Node {\npublic:\n\t// Parameters to distinguish Nodes\n\tint id;\n\tint budget;\n\n\tNode(int _id, int _budget): id(_id), budget(_budget) {\n\t}\n};\n\n// for priority_queue\ntypedef pair<int, Node> Qtype; // cost and Node\nclass Comp {\npublic:\n\tbool operator() (const Qtype& l, const Qtype& r) const {\n\t\t// compair costs for each Node\n\t\treturn (l.F > r.F);\n\t}\n};\n\n// easy access to saved costs\n// #define MAX_N 100\n// #define MAX_L 100\n// VVI g_saved_costs(MAX_N, VI(MAX_L));\n// void init_saved_costs()\n// {\n\t// REP (i, MAX_N) {\n\t\t// REP (j, MAX_L) {\n\t\t\t// g_saved_costs[i][j] = INF;\n\t\t// }\n\t// }\n// }\nVVI g_saved_costs;\nint saved_cost(Node n)\n{\n\treturn g_saved_costs[n.id][n.budget];\n}\nvoid save_cost(Node n, int cost)\n{\n\tg_saved_costs[n.id][n.budget] = cost;\n}\n\nint main()\n{\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N) {\n\t\tVVI dist(N, VI(N, INF));\n\t\tVVI gang(N, VI(N, INF));\n\t\tREP (_, M) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e; --a, --b;\n\t\t\tdist[a][b] = dist[b][a] = d;\n\t\t\tgang[a][b] = gang[b][a] = e;\n\t\t}\n\n\t\t// Initialize g_saved_costs\n\t\t// init_saved_costs();\n\t\tg_saved_costs = VVI(N, VI(L+1, INF));\n\t\tpriority_queue< Qtype, vector<Qtype>, Comp > q;\n\n\t\tq.push( MP(0, Node(0, L)) );\n\t\twhile (!q.empty()) {\n\t\t\tQtype t = q.top(); q.pop();\n\t\t\tint cost_here = t.F; Node node = t.S;\n\n\t\t\t// Skip if already visited\n\t\t\tif (cost_here > saved_cost(node)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsave_cost(node, cost_here);\n\n\t\t\tREP (i, N) {\n\t\t\t\tif (dist[node.id][i] != INF) {\n\t\t\t\t\t// without guard\n\t\t\t\t\tq.push(MP(cost_here + gang[node.id][i], Node(i, node.budget)));\n\t\t\t\t\tif (dist[node.id][i] <= node.budget) {\n\t\t\t\t\t\t// with guard\n\t\t\t\t\t\tbool vain = false;\n\t\t\t\t\t\tfor (int b = node.budget; b >= node.budget - dist[node.id][i]; --b) {\n\t\t\t\t\t\t\tif (saved_cost(Node(i, b)) <= cost_here) {\n\t\t\t\t\t\t\t\tvain = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tIFC(vain);\n\t\t\t\t\t\tq.push(MP(cost_here, Node(i, node.budget - dist[node.id][i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tREP (i, L+1) {\n\t\t\tans = min(ans, saved_cost(Node(N-1, i)));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\n#define rep(X,Y) for(int (X)=0;(X)<(Y);++(X))\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define pb push_back\n\nusing namespace std;\n\nstruct edge {int to, cost, pp;};\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PIP;\n\n#define MAX_V 101\n#define MAX_L 101\n#define INF 1000000000\n\nvector<edge> G[MAX_V];\nint d[MAX_L][MAX_V];\n\nint l,n,m;\n\n\nvoid dij(){\n\tpriority_queue<PIP, vector<PIP>, greater<PIP> > q;\n\t\n\td[l][1] = 0;\n\tq.push(PIP(0,P(l,1)));\n\twhile(!q.empty()){\n\t\tPIP p = q.top();q.pop();\n\t\tcout << p.first << \",\" << p.second.first << \",\" << p.second.second << endl;\n\t\tint ll = p.second.first;\n\t\tint v = p.second.second;\n\t\tif(ll < 0)continue;\n\t\tif(d[ll][v] < p.first)continue;\n\t\trep(i,G[v].size()){\n\t\t\tcout << G[v][i].to << \",\" << G[v][i].cost << \",\" << G[v][i].pp << endl;\n\t\t\tedge e = G[v][i];\n\t\t\tif( ll-e.cost < 0)continue;\n\t\t\tif(d[ll][e.to] > d[ll][v] + e.pp ){\n\t\t\t\td[ll][e.to] = d[ll][v] + e.pp;\n\t\t\t\tq.push(PIP(d[ll][e.to],P(ll,e.to)));\n\t\t\t}\n\t\t\tif(d[ll-e.cost][e.to] > d[ll][v]){\n\t\t\t\td[ll-e.cost][e.to] = d[ll][v];\n\t\t\t\tq.push(PIP(d[ll-e.cost][e.to],P(ll-e.cost,e.to)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid init(){\n\tl = n = m = 0;\n\trep(i,101)G[i].clear();\n\trep(i,101)rep(j,101)d[i][j] = INF;\n}\n\n\t\n\n\nint main(){\n\twhile(1){\n\t\tint ans = INF;\n\t\tinit();\n\t\tcin >> n >> m >> l;\n\t\tif(!l)break;\n\t\trep(i,m){\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tG[a].push_back((edge){b,d,e});\n\t\t\tG[b].push_back((edge){a,d,e});\n\t\t}\n\t\tdij();\n\t\trep(i,l+1){\n\t\t\tcout << d[i][n] << endl;\n\t\t\tans = min(ans, d[i][n]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n}\n\n\n/*\n3 2 10\n1 2 8 6\n2 3 10 3\n0,10,1\n2,8,6\n0,2,2\n1,8,6\n3,10,3\n6,10,2\n1,8,6\n3,10,3\n6,0,3\n2,10,3\n6,2,1\n2,8,6\n9,10,3\n2,10,3\n9,0,2\n1,8,6\n3,10,3\n6\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n9\n6\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\ntypedef pair<int, pair<int, int> > E; //(dest, (dist, cost))\ntypedef pair<int, pair<int, int> > Elem; //(-cost, (pos, money))\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n\nint main() {\n    int n,m,l;\n    while(cin >> n >> m >> l, n) {\n        vector<E> G[n];\n        rep(i,m) {\n            int a,b,d,e;\n            cin >> a >> b >> d >> e;\n            a--,b--;\n            G[a].push_back(make_pair(b, make_pair(d,e)));\n            G[b].push_back(make_pair(a, make_pair(d,e)));\n        }\n        \n        set<pair<int, int> > vis;\n        priority_queue<Elem> q;\n        q.push(make_pair(0, make_pair(0, l)));\n        while (!q.empty()) {\n            Elem e = q.top();\n            int cost = -e.first;\n            int pos = e.second.first;\n            int money = e.second.second;\n            q.pop();\n            if (vis.find(make_pair(pos, money)) != vis.end()) continue;\n            vis.insert(make_pair(pos, money));\n            if (money < 0) continue;\n            if (pos == n - 1) {\n                cout << cost << endl;\n                break;\n            }\n            rep(i, G[pos].size()) {\n                E edge = G[pos][i];\n                int dest = edge.first;\n                int dist = edge.second.first;\n                int num = edge.second.second;\n                q.push(make_pair(-cost, make_pair(dest, money - dist)));\n                q.push(make_pair(-(cost + num), make_pair(dest, money)));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct road\n{\n\tint to, cost, k;//???????????????????????????\n};\nvector<road>rinsetu[100];\nint mincost[100][101];//i??°??????j????????£?????????\nstruct A\n{\n\tint x, y, z;//??´????????????????????????\n};\nbool operator <(A b, A c) {\n\tif (b.z != c.z)return b.z > c.z;\n\treturn b.x * 1000 + b.y > c.x * 1000 + c.y;\n}\nsigned main() {\n\tint a, b, c;\n\twhile (scanf(\"%d%d%d\", &a, &b, &c), a || b || c) {\n\t\tfor (int d = 0; d < a; d++) {\n\t\t\trinsetu[d].clear();\n\t\t}\n\t\tfor (int d = 0; d < b; d++) {\n\t\t\tint e, f, g, h; scanf(\"%d%d%d%d\", &e, &f, &g, &h);\n\t\t\te--; f--;\n\t\t\trinsetu[e].push_back({ f,g,h });\n\t\t\trinsetu[f].push_back({ e,g,h });\n\t\t}\n\t\tmemset(mincost, 0x3f, sizeof(mincost));\n\t\tmincost[0][c] = 0;\n\t\tpriority_queue<A>Q;\n\t\tQ.push({0,c,0});\n\t\twhile (Q.size()) {\n\t\t\tA d = Q.top(); Q.pop();\n\t\t\tif (d.z > mincost[d.x][d.y])continue;\n\t\t\tfor (road i : rinsetu[d.x]) {\n\t\t\t\t//?????????????????????\n\t\t\t\tif (mincost[i.to][d.y] > d.z + i.k) {\n\t\t\t\t\tmincost[i.to][d.y] = d.z + i.k;\n\t\t\t\t\tQ.push({i.to,d.y,d.z + i.k });\n\t\t\t\t}\n\t\t\t\t//???????????????\n\t\t\t\tif (d.y >= i.cost) {\n\t\t\t\t\tif (mincost[i.to][d.y - i.cost] > d.z) {\n\t\t\t\t\t\tmincost[i.to][d.y - i.cost] = d.z;\n\t\t\t\t\t\tQ.push({ i.to, d.y - i.cost, d.z });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint MIN = 1 << 29;\n\t\tfor (int i = 0; i <= c; i++) {\n\t\t\tMIN = min(MIN, mincost[a-1][i]);\n\t\t}\n\t\tprintf(\"%d\\n\", MIN);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define dbg(x) cout<<#x<<\":\"<<x<<endl\n#define int long long\n#define MOD 1e9+7\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nstruct edge{\n  int v,l,e;\n};\n\nsigned main(){\n  while(1){\n    int n,m,L;\n    cin>>n>>m>>L;\n    if(n+m+L==0)break;\n    vector<vector<edge> > g(n);\n    for(int i=0;i<m;i++){\n\t int a,b,d,e;\n\t cin>>a>>b>>d>>e;\n\t a--,b--;\n\t if(e==0)d=0;\n\t g[a].pb({b,d,e});\n\t g[b].pb({a,d,e});\n    }\n    int INF=1LL<<60;\n    int d[101][101];\n    fill_n(*d,101*101,INF);\n    d[0][0]=0;\n    priority_queue<PP,vector<PP>,greater<PP> > que;\n    que.push(PP(0,P(0,0)));\n    while(que.size()){\n\t PP p=que.top();\n\t que.pop();\n\t int e=p.fi;\n\t int l=p.se.fi;\n\t int v=p.se.se;\n\t if(e>d[v][l])continue;\n\t for(int i=0;i<g[v].size();i++){\n\t   edge to=g[v][i];\n\t   if(d[to.v][l]>d[v][l]+to.e){\n\t\td[to.v][l]=d[v][l]+to.e;\n\t\tque.push(PP(d[to.v][l],P(l,to.v)));\n\t   }\n\t   if(l+to.l>L)continue;\n\t   if(d[to.v][l+to.l]>d[v][l]){\n\t\td[to.v][l+to.l]=d[v][l];\n\t\tque.push(PP(d[to.v][l+to.l],P(l+to.l,to.v)));\n\t   }\n\t }\n    }\n    int mi=1LL<<60;\n    for(int i=0;i<101;i++){\n\t mi=min(mi,d[n-1][i]);\n    }\n    cout<<mi<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nstruct edge{\n\tint to;\n\tint enm;\n\tint dist;\n};\nint N,M,L;\nvector<edge> G[201];\nint d[201][201];\ntypedef pair<int,pii> ppi;\nconst int INF=1000000000;\n\nint dijkstra(){\n\tfor(int i=0;i<200;i++)\n\t\tfor(int j=0;j<200;j++)\n\t\t\td[i][j]=INF;\n\td[0][L]=0;\n\tpriority_queue<ppi,vector<ppi>,greater<ppi> > pq;\n\tpq.push(make_pair(0,pii(0,L)));\n\twhile(pq.size()){\n\t\tppi p=pq.top();pq.pop();\n\t\tint ccost=p.first;\n\t\tint cnode=p.second.first;\n\t\tint cmoney=p.second.second;\n\t\tif(d[cnode][cmoney]<ccost)continue;\n\t\tfor(int i=0;i<G[cnode].size();i++){\n\t\t\tedge &e=G[cnode][i];\n\t\t\tint nnode=e.to;\n\t\t\t// ツづ「ツづ?つ、\n\t\t\tif(e.dist<=cmoney){\n\t\t\t\tint ncost=ccost;\n\t\t\t\tint nmoney=cmoney-e.dist;\n\t\t\t\tif(d[nnode][nmoney]>ncost){\n\t\t\t\t\td[nnode][nmoney]=ncost;\n\t\t\t\t\tpq.push(make_pair(ncost,pii(nnode,nmoney)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ツづ「ツづ?づュツづ按つ「\n\t\t\t{\n\t\t\t\tint ncost=ccost+e.enm;\n\t\t\t\tint nmoney=cmoney;\n\t\t\t\tif(d[nnode][nmoney]>ncost){\n\t\t\t\t\td[nnode][nmoney]=ncost;\n\t\t\t\t\tpq.push(make_pair(ncost,pii(nnode,nmoney)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res=INF;\n\tfor(int i=0;i<=L;i++){\n\t\tres=min(res,d[N-1][i]);\n\t}\n\treturn res;\n}\n\nvoid solve(){\n\twhile(cin>>N>>M>>L&&(N|M|L)){\n\t\tfor(int i=0;i<201;i++)G[i].clear();\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint from,to,enm,dist;\n\t\t\tcin>>from>>to>>dist>>enm;\n\t\t\tfrom--;to--;\n\t\t\tedge e;\n\t\t\te.dist=dist;\n\t\t\te.to=to;\n\t\t\te.enm=enm;\n\t\t\tG[from].push_back(e);\n\t\t\te.to=from;\n\t\t\tG[to].push_back(e);\n\t\t}\n\t\tint res=dijkstra();\n\t\tcout<<res<<endl;\n\t}\n}\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \"\\n\"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nvoid solve(int N,int M,int L) {\n    struct edge{\n        int to;\n        int left;\n        int dist;\n        int thief;\n    };\n    vector<vector<vector<edge>>> g(N,vector<vector<edge>>(110));\n    REP(i,M) {\n        int a,b,d,e;\n        cin>>a>>b>>d>>e;\n        REP(j,110) {\n            g[a-1][j].push_back(edge{b-1,j,d,e});  // ????????????\n            if(j-d>=0) g[a-1][j].push_back(edge{b-1,j-d,d,e});  // ??????\n        }\n        REP(j,110) {\n            g[b-1][j].push_back(edge{a-1,j,d,e});  // ????????????\n            if(j-d>=0) g[b-1][j].push_back(edge{a-1,j-d,d,e});  // ??????\n        }\n    }\n    vector<vector<int>> dp(N,vector<int>(110,INF));\n    dp[0][L]=0;\n    priority_queue<pair<int,pii>> pq;\n    pq.push({0,{0,L}});\n    while(!pq.empty()) {\n        int y=pq.top().second.first;\n        int z=pq.top().second.second;\n        pq.pop();\n        FORE(e,g[y][z]) {\n            if(z==e.left) {\n                if(dp[e.to][e.left]>dp[y][z]+e.thief) {\n                    dp[e.to][e.left]=dp[y][z]+e.thief;\n                    pq.push({dp[e.to][e.left],{e.to,e.left}});\n                }\n            }\n            else {\n                if(dp[e.to][e.left]>dp[y][z]) {\n                    dp[e.to][e.left]=dp[y][z];\n                    pq.push({dp[e.to][e.left],{e.to,e.left}});\n                }\n            }\n        }\n    }\n    int ans=INF;\n    REP(i,110) chmin(ans,dp[N-1][i]);\n    cout<<ans<<endl;\n}\nsigned main() {\n    while(1) {\n        int N,M,L;\n        cin>>N>>M>>L;\n        if(N+M+L==0) break;\n        solve(N,M,L);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstruct st {\n\tint p, d, e;\n};\nbool operator<(st a, st b) {\n\treturn a.e > b.e;\n}\nint d[100][101];\nint main() {\n\tint n, m, l;\n\twhile (scanf(\"%d%d%d\", &n, &m, &l), n) {\n\t\tvector<st>E[100];\n\t\trep(i, m) {\n\t\t\tint a, b, d, e; scanf(\"%d%d%d%d\", &a, &b, &d, &e); a--; b--;\n\t\t\tE[a].push_back({ b,d,e }); E[b].push_back({ a,d,e });\n\t\t}\n\t\tpriority_queue<st>que;\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\td[0][l] = 0; que.push({ 0,l,0 });\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.p][p.d] != p.e)continue;\n\t\t\tfor (st u : E[p.p]) {\n\t\t\t\tif (p.d >= u.d&&d[u.p][p.d - u.d] > p.e) {\n\t\t\t\t\td[u.p][p.d - u.d] = p.e;\n\t\t\t\t\tque.push({ u.p,p.d - u.d,p.e });\n\t\t\t\t}\n\t\t\t\tif (d[u.p][p.d] > p.e + u.e) {\n\t\t\t\t\td[u.p][p.d] = p.e + u.e;\n\t\t\t\t\tque.push({ u.p,p.d,p.e + u.e });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INT_MAX;\n\t\trep(i, l + 1)Min = min(Min, d[n - 1][i]);\n\t\tprintf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nstruct edge { \n\tint to, cost, money;\n};\nvector<edge> G[100];\nint d[100][101];\nvoid init() {\n\trep(i, 100) {\n\t    G[i].clear();\n\t}\n\trep(i, 100) {\n\t\trep(j, 101) {\n\t\t\td[i][j] = (int)mod;\n\t\t}\n\t}\n\td[0][0] = 0;\n}\nstruct point {\n\tint v, m, d; \n\tbool operator>(const point &s) const {\n\t\treturn d > s.d;\n\t}\n};\nint main() {\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tinit();\n\t\trep(i, m) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e; a--; b--;\n\t\t\tG[a].push_back(edge{ b,e,d });\n\t\t\tG[b].push_back(edge{ a,e,d });\n\t\t}\n\t\tpriority_queue<point,vector<point>,greater<point>> q;\n\t\tq.push({ 0,0,0 });\n\t\twhile (!q.empty()) {\n\t\t\tpoint x = q.top(); q.pop();\n\t\t\tif (x.d > d[x.v][x.m])continue;\n\t\t\tint len = G[x.v].size();\n\t\t\trep(j, len) {\n\t\t\t\tint v = G[x.v][j].to;\n\t\t\t\tint c = G[x.v][j].cost;\n\t\t\t\tint mon = G[x.v][j].money;\n\t\t\t\tif (d[v][x.m] > x.d + c) {\n\t\t\t\t\td[v][x.m] = x.d + c;\n\t\t\t\t\tq.push({ v,x.m,x.d+c });\n\t\t\t\t}\n\t\t\t\tif (mon + x.m > l)continue;\n\t\t\t\tif (d[v][x.m + mon] > x.d) {\n\t\t\t\t\td[v][x.m + mon] = x.d;\n\t\t\t\t\tq.push({ v,x.m + mon,d[v][x.m + mon] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out = (int)mod;\n\t\trep(j, l + 1) {\n\t\t\tout = min(out, d[n - 1][j]);\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct {\n\tint to;\n\tint D;\n\tint E;\n} Edge;\n\nclass State {\npublic:\n\n\tint now;\n\tint money;\n\tint damaged;\n\n\tState(int now, int money, int damaged) {\n\t\tthis->now = now;\n\t\tthis->money = money;\n\t\tthis->damaged = damaged;\n\t}\n\n};\n\nconst int INF  = 999999;\n\nvector<Edge> G[101];\n\nint d[101][101];\n\nint N, M, L;\n\nint toV(int n, int l) {\n\treturn n * L + l;\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N + M + L != 0) {\n\t\tqueue<State> q;\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tG[i].clear();\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint A, B, D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tEdge e { B, D, E };\n\t\t\tEdge e2 { A, D, E };\n\t\t\tG[A].push_back(e);\n\t\t\tG[B].push_back(e2);\n\t\t}\n\t\tq.push(State(1, L, 0));\n\t\twhile (!q.empty()){\n\t\t\tState s = q.front();\n\t\t\tq.pop();\n\t\t\tif (s.damaged > d[s.now][s.money]) continue;\n\t\t\td[s.now][s.money] = s.damaged;\n\t\t\t\n\t\t\tfor (Edge e : G[s.now])\n\t\t\t{\n\t\t\t\tq.push(State(e.to, s.money, s.damaged + e.E));\n\t\t\t\tif (s.money - e.D >= 0) {\n\t\t\t\t\tq.push(State(e.to, s.money - e.D, s.damaged));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = INF;\n\t\tfor (int i = 0; i <= L; i++) {\n\t\t\tm = min(m, d[N][i]);\n\t\t}\n\t\tcout << m << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nclass Dijkstra {\npublic:\n    struct edge {\n        ll to, cost;\n    };\n    typedef pair<ll, ll> P;//firstは最短距離、secondは頂点の番号\n\n    int V;//超点数\n    vector<vector<edge> > G;//グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<ll> d; //最短距離\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge> >(N);\n        d = vector<ll>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            ll v = p.second;\n            if (d[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, int cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\nvoid solve(int N, int M, int L) {\n    auto conv = [&](int i, int j) {\n        //場所, 予算\n        return i + j * N;\n\n    };\n    Dijkstra dij(L * N + N);\n\n    rep(i, 0, M) {\n        int a, b, d, e;\n        cin >> a >> b >> d >> e;\n        a--;\n        b--;\n        for (int l = d; l <= L; l++) {\n            dij.addEdge(conv(a, l), conv(b, l - d), 0ll);\n            dij.addEdge(conv(b, l), conv(a, l - d), 0ll);\n        }\n        for(int l = 0; l <= L; l++){\n            dij.addEdge(conv(a, l), conv(b, l), e);\n            dij.addEdge(conv(b, l), conv(a, l), e);\n        }\n    }\n    dij.dijkstra(conv(0, L));\n    ll ans = INFl;\n    for (int i = 0; i <= L; i++) {\n        ans = min(ans, dij.d[conv(N - 1, i)]);\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m, l;\n        cin >> n >> m >> l;\n        if (n == 0) break;\n        solve(n, m, l);\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\n//int checker[4];\n//int ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\t//int check[4];\n\tState() {}\n\t//\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\t/*\n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t\t*/\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n/*\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n*/\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min = b;\n\t\twhile ( itr != points[i].end() ) {\n\t\t\tif ( (*itr).second > min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t} else if ( (*itr).second <= min ) {\n\t\t\t\t(*itr).second = min;\n\t\t\t}\n\t\t\tmin++;\n\t\t\titr++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t/*\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\t*/\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\t//ncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//copy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t/*\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n//\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\nconst int inf=1e9;\nint bprdp[110][110];//node,budget = enemy\npair<int,int> bpredge[110][110];//cost,enemy\nint main(){\n\tint N,M,L;\n\twhile(cin>>N>>M>>L,N){\n\t\tREP(i,0,N) REP(j,0,L+1) bprdp[i][j]=inf;\n\t\tbprdp[0][L]=0;\n\t\tREP(i,0,M){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--;b--;\n\t\t\tbpredge[a][b]=bpredge[b][a]={d,e};\n\t\t}\n\t\tqueue<int> q;\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint i=q.front();q.pop();\n\t\t\tif(i==N-1) continue;\n\t\t\tREP(j,1,N){\n\t\t\t\tif(bpredge[i][j]!=make_pair(0,0)){\n\t\t\t\t\tREP(k,0,L+1){\n\t\t\t\t\t\tif(bprdp[i][k]==inf) continue;\n\t\t\t\t\t\tbprdp[j][k]=min(bprdp[j][k],bprdp[i][k]+bpredge[i][j].second);\n\t\t\t\t\t\tif(k>=bpredge[i][j].first){\n\t\t\t\t\t\t\tbprdp[j][k-bpredge[i][j].first] = min(bprdp[j][k-bpredge[i][j].first],bprdp[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbpredge[i][j]={0,0};\n\t\t\t\t\tq.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\tREP(i,0,L+1){\n\t\t\tans=min(bprdp[N-1][i],ans);\n\t\t}\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max()/2;\n\nstruct Edge{\n    int to,d,cost;\n    Edge(int to,int d,int cost): to(to),d(d), cost(cost){}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct State{\n    int node,money,damage;\n    State(int node,int money,int damage):node(node),money(money),damage(damage){} \n};\n\nbool operator < (const State &e, const State &f){\n    return e.damage > f.damage;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m,l;\n    while(cin>>n>>m>>l,n||m||l){\n        Graph g(n);\n        for(int i=0;i<m;i++){\n            int a,b,d,e;cin>>a>>b>>d>>e;\n            a--;b--;\n            g[a].push_back(Edge(b,d,e));\n            g[b].push_back(Edge(a,d,e));\n        }\n        vector<vector<int>> dp(111,vector<int>(111,INF));\n        // dp[i][j] := node i, damage j\n        dp[l][0]=0;\n        priority_queue<State> que;\n        que.push(State(0,l,0)); // State(node, money,damage)\n        int res=INF;\n        while(!que.empty()){\n            State s=que.top();que.pop();\n            int node=s.node,money=s.money,damage=s.damage;\n            if(node==n-1){\n                res=min(res,damage);\n            }\n            if(dp[node][money]<damage) continue;\n            for(const auto &e: g[node]){\n                // Edge(to,d,cost)\n                int next=e.to, d=e.d, cost=e.cost;\n                if(money>=d){\n                    if(dp[next][money-d]>damage){\n                        dp[next][money-d]=damage;\n                        que.push(State(next,money-d,damage));\n                    }\n                }\n                if(dp[next][money]<=damage+cost) continue;\n                dp[next][money] = damage + cost;\n                que.push(State(next, money, damage+cost));\n            }\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator < (const struct state &a,const state &b)\n{\n    return a.enemy<b.enemy;\n}\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    return a.enemy>b.enemy;\n}\n\nstruct node maps[(int)1e8];\n\nint main()\n{\n    int n,m,l;\n\n    while ((cin>>n>>m>>l) && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            maps[a-1].data.push_back((struct data){b-1,d,e});\n            maps[b-1].data.push_back((struct data){a-1,d,e});\n        }\n        queue.push((struct state){0,l,0});\n        bool flag=true;\n        while (flag){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                cout<<s.enemy<<endl;\n                flag= false;\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.dis<=s.money){\n                        queue.push((struct state){d.to,s.money-d.dis,s.enemy});\n                    }\n                    queue.push((struct state){d.to,s.money,s.enemy+d.ene});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint N,M,L;\nstruct edge{\n    ll to,cost,num;\n    edge(){};\n    edge(ll a,ll b,ll c):to(a),cost(b),num(c){};\n};\nll solve(){\n    ll res = 0;\n    vector<vector<edge>> G(N);\n    for(int i = 0; i < M;i++){\n        ll u,v,cost,num; cin >> u >> v >> cost >> num;\n        u--; v--;\n        G[u].emplace_back(v,cost,num);\n        G[v].emplace_back(u,cost,num);\n    }\n    vector<vector<ll>> dist(N,vector<ll>(L+1,LINF));\n    dist[0][0] = 0;\n    queue<pll> q; q.push({0,0});\n    while(q.size()){\n        ll n,len; tie(n,len) = q.front(); q.pop();\n        for(auto& e:G[n]){\n            if(dist[e.to][len] > dist[n][len] + e.num){\n                dist[e.to][len] = dist[n][len] + e.num;\n                q.push({e.to,len});\n            }\n            if(len + e.cost > L) continue;\n            if(dist[e.to][len+e.cost] > dist[n][len]){\n                dist[e.to][len+e.cost] = dist[n][len];\n                q.push({e.to,len+e.cost});\n            }\n        }\n    }\n    res = *min_element(dist[N-1].begin(), dist[N-1].end());\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N >> M >> L,N|M|L){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\ntypedef tuple<int, int, int> tup;\nint N, M, L;\nint solve(const vector<vector<tup>>& edges) {\n    const int S = 0, G = N - 1;\n    vector<vector<int>> dist(N, vector<int>(L + 1, INF));\n    priority_queue<tup, vector<tup>, greater<tup>> que;\n    que.push(tup(0, S, L)); dist[S][L] = 0;\n    while(!que.empty()) {\n        int cos, ver, money;\n        tie(cos, ver, money) = que.top(); que.pop();\n        if(dist[ver][money] < cos) continue;\n        for(const auto& e : edges[ver]) {\n            int to, dis, ene; tie(to, dis, ene) = e;\n            //not hire\n            if(dist[to][money] > cos + ene) {\n                dist[to][money] = cos + ene;\n                que.push(tup(dist[to][money], to, money));\n            }\n            //hire\n            int nm = money - dis;\n            if(nm < 0) continue;\n            if(dist[to][nm] > cos) {\n                dist[to][nm] = cos;\n                que.push(tup(dist[to][nm], to, nm));\n            }\n        }\n    }\n    int ans = INF;\n    rep(i, L + 1) ans = min(ans, dist[G][i]);\n    return ans;\n}\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    vector<vector<tup>> edges;\n    while(cin >> N >> M >> L && N) {\n        int a, b, d, e;\n        edges.assign(N, vector<tup>());\n        rep(___, M) {\n            cin >> a >> b >> d >> e;\n            --a; --b;\n            edges[a].push_back(tup(b, d, e));\n            edges[b].push_back(tup(a, d, e));\n        }\n        cout << solve(edges) << endl;;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\ntemplate <class T>\nusing greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\nconst int INF = 1 << 30;\n\nbool solve() {\n    int N, M, L;\n    cin >> N >> M >> L;\n    if (N == 0) return false;\n\n    auto encode = [&](int v, int l) {\n        return v + l * N;\n    };\n\n    vector<vector<pair<int, int>>> graph(N * (L + 1));\n    for (int i = 0; i < M; ++i) {\n        int u, v, d, e;\n        cin >> u >> v >> d >> e;\n        --u, --v;\n\n        for (int l = 0; l + d <= L; ++l) {\n            graph[encode(u, l + d)].emplace_back(encode(v, l), 0);\n            graph[encode(v, l + d)].emplace_back(encode(u, l), 0);\n        }\n\n        for (int l = 0; l <= L; ++l) {\n            graph[encode(u, l)].emplace_back(encode(v, l), e);\n            graph[encode(v, l)].emplace_back(encode(u, l), e);\n        }\n    }\n\n    greater_priority_queue<pair<int, int>> que;\n    que.emplace(0, encode(0, L));\n\n    vector<int> dist(N * (L + 1), INF);\n    dist[encode(0, L)] = 0;\n\n    while (!que.empty()) {\n        int d, v;\n        tie(d, v) = que.top();\n        que.pop();\n\n        if (d > dist[v]) continue;\n\n        for (auto p : graph[v]) {\n            int sv, sd;\n            tie(sv, sd) = p;\n            if (dist[sv] <= dist[v] + sd) continue;\n            dist[sv] = dist[v] + sd;\n            que.emplace(dist[sv], sv);\n        }\n    }\n\n    int ans = INF;\n    for (int l = 0; l <= L; ++l) {\n        ans = min(ans, dist[encode(N - 1, l)]);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1 << 30;\n\nstruct edge{\n\tint to;\n\tint cost;\n\tint enemy;\n};\n\nvector<edge> G[200];\nint dis[200][200];\n\nint main(){\n\tint n, m, l;\n\twhile(cin >> n >> m >> l && (n || m || l)){\n\t\tmemset(dis, -1, sizeof(dis));\n\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tedge e;\n\t\t\tint from;\n\t\t\tint to;\n\t\t\tcin >> from >> e.to >> e.cost >> e.enemy;\n\t\t\tG[from].push_back(e);\n\t\t\tto = from;\n\t\t\tfrom = e.to;\n\t\t\te.to = to;\n\t\t\tG[from].push_back(e);\n\t\t}\n\t\tdis[1][l] = 0;\n\t\tque.push(PP(0, P(1, l)));\n\t\twhile(!que.empty()){\n\t\t\tPP pp = que.top(); que.pop();\n\t\t\tP p = pp.second;\n\t\t\tif(dis[p.first][p.second] < pp.first) continue;\n\t\t\tfor(int i = 0; i < G[p.first].size(); i++){\n\t\t\t\tedge e = G[p.first][i];\n\t\t\t\tif(dis[e.to][p.second] < 0 || dis[e.to][p.second] > dis[p.first][p.second] + e.enemy){\n\t\t\t\t\tdis[e.to][p.second] = dis[p.first][p.second] + e.enemy;\n\t\t\t\t\tque.push(PP(dis[e.to][p.second], P(e.to, p.second)));\n\t\t\t\t}\n\t\t\t\tif(p.second >= e.cost){\n\t\t\t\t\tif(dis[e.to][p.second - e.cost] < 0 || dis[e.to - e.cost][p.second] < dis[p.first][p.second]){\n\t\t\t\t\t\tdis[e.to][p.second - e.cost] = dis[p.first][p.second];\n\t\t\t\t\t\tque.push(PP(dis[e.to][p.second - e.cost], P(e.to, p.second - e.cost)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min_dis = INF;\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tif(dis[n][i] >= 0) min_dis = min(min_dis, dis[n][i]);\n\t\t}\n\t\tcout << min_dis << endl;\n\t\tfor(int i = 0; i < 200; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define REP(i,n) for(int i = 0;i < n; i++)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e18;\n \n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n \ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>vector<T>\nmake_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n\tfor(auto &e:t) fill_v(e,v);\n}\n\n#define P2 pair<int,pair<int,int>>\nint N,M,L;\n \nsigned main(){\n\tIOS();\n\tvector<int>ans;\n\twhile(cin>>N>>M>>L,N||M||L){\n\t\tvector<pair<int,pair<int,int>>>g[N];\n\t\trep(i,0,M){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\ta--;b--;\n\t\t\tg[a].push_back({b,{c,d}});\n\t\t\tg[b].push_back({a,{c,d}});\n\t\t}\n\t\tint kiken[N][L+1];\n\t\trep(i,0,N)rep(j,0,L+1)kiken[i][j] = INF;\n\t\tkiken[0][0] = 0;  //dist(now,cost);\n\t\tpriority_queue<P2,vector<P2>,greater<P2>>que;\n\t\tque.push({0,{0,0}});\n\t\twhile(!que.empty()){\n\t\t\tint now = que.top().se.fi;\n\t\t\tint usedMoney = que.top().se.se;\n\t\t\tint osoware = que.top().fi;\n\t\t\tque.pop();\n\t\t\tif(kiken[now][usedMoney]!=osoware)continue;\n\t\t\tfor(auto e:g[now]){\n\t\t\t\tif(e.se.fi+usedMoney<=L){\n\t\t\t\t\tif(osoware<kiken[e.fi][usedMoney+e.se.fi]){\n\t\t\t\t\t\tkiken[e.fi][usedMoney+e.se.fi] = osoware;\n\t\t\t\t\t\tque.push({kiken[e.fi][usedMoney+e.se.fi],{e.fi,usedMoney+e.se.fi}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(osoware+e.se.se<kiken[e.fi][usedMoney]){\n\t\t\t\t\tkiken[e.fi][usedMoney] = osoware+e.se.se;\n\t\t\t\t\tque.push({kiken[e.fi][usedMoney],{e.fi,usedMoney}});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\trep(i,0,L+1)chmin(mi,kiken[N-1][i]);\n\t\tans.push_back(mi);\n\t}\n\t\t\n\tfor(auto e:ans){\n\t\tcout<<e<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int c,v,d;\n  bool operator<(S a)const{\n    return d>a.d;\n  }\n};\n\nstruct E{\n  int t,d,e;\n};\n\nint main(){\n  for(int n,m,l;cin>>n>>m>>l,n|m|l;){\n    vector<E> e[101];\n    while(m--){\n      int a,b,d,ee;\n      cin>>a>>b>>d>>ee;\n      E x={b,d,ee};\n      e[a].push_back(x);\n      x.t=a;\n      e[b].push_back(x);\n    }\n    priority_queue<S> que;\n    S is={l,1,0};\n    que.push(is);\n    bool p[101][101]={{}};\n    for(;;){\n      S c=que.top();\n      if(c.v==n)break;\n      que.pop();\n      if(p[c.v][c.c]++)continue;\n      for(int i=0;i<e[c.v].size();i++){\n\tS n={c.c,e[c.v][i].t,c.d+e[c.v][i].e};\n\tque.push(n);\n\tif(c.c>=e[c.v][i].d){\n\t  S n={c.c-e[c.v][i].d,e[c.v][i].t,c.d};\n\t  que.push(n);\n\t}\n      }\n    }\n    cout<<que.top().d<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXN = 101, MAXL = 101, INF = 110000 ;\nlong long d[MAXN][MAXL];\n\nstruct edge{int to, dist, enemy;};\n\nint n, m, l, a, b, dist, e;\n\ntypedef pair<int, int> pp;\ntypedef pair<int, pp> ppp;\n\nint main()\n{\n    while(cin >> n >> m >> l && n)\n    {\n        rep(i,n)rep(j,l + 1)d[i][j] = 1100000 ;\n        vector<edge> g[MAXN];\n        REP(m)\n        {\n            cin >> a >> b >> dist >> e;\n            a--; b--;\n            g[a].push_back((edge){b, dist, e});\n            g[b].push_back((edge){a, dist, e});\n        }\n\n        priority_queue<ppp, vector<ppp>, greater<ppp> > que;\n        que.push(ppp(0, pp( -l , 0)));\n        d[0][l] = 0;\n        int ans = 1000;\n\n        //cout << d[1][l] << endl;\n\n        while(!que.empty())\n        {\n            ppp p = que.top(); que.pop();\n            int nowe = p.first, nowl = -p.second.first, now = p.second.second;\n            //cout << \"e:\" << nowe << \"  l:\" << nowl << \"  now:\" << now << endl;\n            if(now == n -1 ){ans = nowe; break;}\n            \n            REP(g[now].size())\n            {\n                edge ed = g[now][i];\n                //cout << \"to:\" << ed.to << \" dist:\" << ed.dist << \" enemy:\" << ed.enemy << endl;\n                //cout << \"d[ed.to]:\"<< d[ed.to][nowl] << endl;\n                if(nowl - ed.dist >= 0 && nowe < d[ed.to][nowl - ed.dist] )\n                {\n                    d[ed.to][nowl - ed.dist] = nowe;\n                    que.push(ppp(nowe, pp(ed.dist - nowl, ed.to)));\n                }\n                if(nowe + ed.enemy < d[ed.to][nowl])\n                {\n                    d[ed.to][nowl] = nowe + ed.enemy;\n                    que.push(ppp(nowe + ed.enemy, pp(-nowl, ed.to)));\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\n\nstruct Edge {\n    int to, cost, nm;\n    Edge(int to, int cost, int nm): to(to), cost(cost), nm(nm) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nconst int INF = 100000000;\n\nint GCD(int a, int b){\n    if(a < b) swap(a, b);\n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\nbool cmp(const pii& a, const pii& b){\n    if(a.first == b.first){\n        return a.second < b.second;\n    }\n    return a.first < b.first;\n}\n\nint main() {\n    //cout << fixed << setprecision(15);\n\n    int N, M, L;\n    while(cin >> N >> M >> L){\n        if(N==0 && M==0 && L==0) break;\n\n        vector<vector<Edge>> G(110);\n        REP(i, M){\n            int A, B, D, E; cin >> A >> B >> D >> E;\n            A--;\n            B--;\n            Edge e(B, D, E);\n            G[A].push_back(e);\n            Edge e2(A, D, E);\n            G[B].push_back(e2);\n        }\n\n        int dist[110][110]; // i番目の場所におり, かつ予算がjのときの最小被害\n        for(int i=0; i<110; ++i) for(int j=0; j<110; ++j) dist[i][j] = INT_MAX;\n\n        dist[0][L]=0;\n\n        queue<pii> q;\n        q.push({0, L});\n\n        while(q.size()){\n            pii p = q.front();\n            q.pop();\n\n            int v = p.first;\n            int nokori = p.second;\n\n            for(int i=0; i<G[v].size(); ++i){\n                Edge e = G[v][i];\n\n                int u = e.to;\n                if(dist[u][nokori]> dist[v][nokori]+e.nm){\n                    dist[u][nokori] = dist[v][nokori] + e.nm;\n                    q.push({u, nokori});\n                }\n\n                if(nokori - e.cost >= 0 &&  dist[u][nokori-e.cost] > dist[v][nokori]){\n                    dist[u][nokori-e.cost] = dist[v][nokori];\n                    q.push({u, nokori-e.cost});\n                }\n            }\n        }\n\n        int minV = 10000000;\n        for(int i=0; i<=L; ++i){\n            minV = min(minV, dist[N-1][i]);\n        }\n        cout << minV << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0 ;i < int(n); ++i)\n\nstruct edge{int to, len, den;};\nvector<edge> ed[111];\nint ee[111][111];\n\nint main() {\n  int n, m, l;\n  for (;;) {\n    cin >> n >> m >> l;\n    if (n == 0  && m == 0 && l == 0) break;\n    rep (i, 111) ed[i].clear();\n    rep (i, m) {\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      --a;--b;\n      edge e;\n      e.to = b;\n      e.len = c;\n      e.den = d;\n      ed[a].push_back(e);\n      e.to = a;\n      ed[b].push_back(e);\n    }\n    rep (i, 111) rep(j, 111) ee[i][j] = 1000000000;\n    priority_queue<pair<int, pair<int,int> >, vector<pair<int, pair<int,int> > >, greater<pair<int, pair<int,int> > > > que;\n    que.push(make_pair(0,make_pair(0,l)));\n    while(!que.empty()){\n      pair<int, pair<int,int> > now = que.top();\n      que.pop();\n      int den = now.first;\n      int x = now.second.first;\n      int money = now.second.second;\n      if (ee[x][money] <= den) continue;\n      //cout << den << \" \" << x <<\" \"<< money << endl;\n      rep (i, money + 1) ee[x][i] = min(den, ee[x][i]);\n      rep (i, ed[x].size()) {\n\tque.push(make_pair(den + ed[x][i].den, make_pair(ed[x][i].to, money)));\n\tif (money >= ed[x][i].len) \n\t  que.push(make_pair(den, make_pair(ed[x][i].to, money - ed[x][i].len)));\n      }\n    }\n    cout << ee[n-1][0] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint N, M, L;\n\nstruct edge {\n\tint to, distance, enemy;\n};\n\nstruct P {\n\tint from, money, enemy;\n\t\n\tbool operator >(const P& p) const {\n\t\treturn enemy > p.enemy;\n\t}\n};\n\nstruct city {\n\tint money, enemy;\n};\n\nint main() {\n\twhile (cin >> N >> M >> L, N|M|L) {\n\t\tvector<vector<edge> > E(N);\n\t\tint a, b, d, e;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tE[a-1].push_back({b, d, e});\n\t\t\tE[b-1].push_back({a, d, e});\n\t\t}\n\t\t\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tcity arr[N];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tarr[i].money = 0;\n\t\t\t// arr[i].enemy = ;\n\t\t}\n\t\tq.push((P){0, L, 0});\n\t\t\twhile(!q.empty()) {\n\t\t\tP p = q.top(); q.pop();\n\t\t\t// goal\n\t\t\tif (p.from == N-1) {\n\t\t\t\tcout << p.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p.money > arr[p.from].money) {\n\t\t\t\tarr[p.from].money = p.money;\n\t\t\t\tarr[p.from].enemy = p.enemy;\n\t\t\t} else if (p.enemy >= arr[p.from].enemy) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < E[p.from].size(); i++) {\n\t\t\t\tedge e = E[p.from][i];\n\t\t\t\tq.push((P){e.to-1, p.money, p.enemy+e.enemy});\n\t\t\t\tif (p.money-e.distance >= 0) {\n\t\t\t\t\tq.push((P){e.to-1, p.money-e.distance, p.enemy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_L = 100;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\nstruct Edge {\n  int i, d, e;\n  Edge() {}\n  Edge(int _i, int _d, int _e): i(_i), d(_d), e(_e) {}\n};\n\ntypedef vector<Edge> ve;\n\nstruct Stat {\n  int d, i, l;\n  Stat() {}\n  Stat(int _d, int _i, int _l): d(_d), i(_i), l(_l) {}\n\n  bool operator>(const Stat& s0) const { return d > s0.d; }\n  void print() { printf(\"Stat: d=%d, i=%d, l=%d\\n\", d, i, l); }\n};\n\n/* global variables */\n\nint n, m, l;\nve nbrs[MAX_N];\nint dists[MAX_N][MAX_L + 1];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n >> m >> l;\n    if (n == 0) break;\n\n    for (int i = 0; i < n; i++) nbrs[i].clear();\n\n    for (int i = 0; i < m; i++) {\n      int a, b, d, e;\n      cin >> a >> b >> d >> e;\n      a--, b--;\n      nbrs[a].push_back(Edge(b, d, e));\n      nbrs[b].push_back(Edge(a, d, e));\n    }\n\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j <= l; j++) dists[i][j] = INF;\n    dists[0][l] = 0;\n\n    priority_queue<Stat,vector<Stat>,greater<Stat> > q;\n    q.push(Stat(0, 0, l));\n\n    while (! q.empty()) {\n      Stat u = q.top(); q.pop();\n      //u.print();\n      \n      if (u.d != dists[u.i][u.l] || u.i == n - 1) continue;\n\n      ve& nbru = nbrs[u.i];\n      for (ve::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n\tint vi = vit->i;\n\tint vd = u.d + vit->e;\n\t\n\tif (dists[vi][u.l] > vd) {\n\t  dists[vi][u.l] = vd;\n\t  q.push(Stat(vd, vi, u.l));\n\t}\n\n\tint vl = u.l - vit->d;\n\tif (vl >= 0 && dists[vi][vl] > u.d) {\n\t  dists[vi][vl] = u.d;\n\t  q.push(Stat(u.d, vi, vl));\n\t}\n      }\n    }\n\n    int min_d = INF;\n\n    for (int i = 0; i <= l; i++) {\n      //printf(\"dists[n-1][%d]=%d\\n\", i, dists[n - 1][i]);\n      if (min_d > dists[n - 1][i]) min_d = dists[n - 1][i];\n    }\n\n    cout << min_d << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<functional>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> V;\nconst int MOD = 1000000007;\nconst ll INF=2e18;\nstruct Edge{\n    P to;\n    ll cost;\n};\nll N,M,L;\nmap<P,vector<Edge>> edges;\nmap<P,ll> minCost;\nint main(){\n    while(cin>>N>>M>>L,N!=0){\n        for(ll i=1;i<=N;i++){\n            for(ll j=0;j<=L;j++){\n                minCost[P(i,j)]=INF;\n            }\n        }\n        edges.clear();\n        for(ll i=0;i<M;i++){\n            ll a,b,d,e;\n            cin>>a>>b>>d>>e;\n            for(ll j=0;j<=L;j++){\n                Edge edge;\n                if(j>=d){\n                    edge.to=P(b,j-d);\n                    edge.cost=0;\n                    edges[P(a,j)].push_back(edge);\n                    edge.to=P(a,j-d);\n                    edges[P(b,j)].push_back(edge);\n                }\n                edge.to=P(b,j);\n                edge.cost=e;\n                edges[P(a,j)].push_back(edge);\n                edge.to=P(a,j);                \n                edges[P(b,j)].push_back(edge);\n            }\n        }\n        priority_queue<V,vector<V>,greater<V> > pq;\n        pq.push(V(0,P(1,L)));\n        minCost[P(1,L)]=0;\n        while(!pq.empty()){\n            P now=pq.top().second;\n            ll cost=pq.top().first;\n            pq.pop();\n            if(cost>minCost[now])continue;\n            /*cout<<\"nowPlace:\"<<now.first<<endl;\n            cout<<\"now money:\"<<now.second<<endl;\n            cout<<\"now cost:\"<<cost<<endl;*/\n            for(auto edge:edges[now]){\n                P to=edge.to;\n                ll ncost=cost+edge.cost;\n                if(minCost[to]>ncost){\n                    minCost[to]=ncost;\n                    pq.push(V(ncost,to));\n                }\n            }\n        }\n        ll ans=INF;\n        for(ll i=0;i<=L;i++){\n            ans=min(ans,minCost[P(N,i)]);\n        }\n        cout<<ans <<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\nvector<pa3> G[133];\nbool sumi[133][124];\npriority_queue<pa3,vector<pa3>,greater<pa3>> pq; \nvoid solve(){\n\tint n,m,l;\n\tcin>>n>>m>>l;\n\tif(n==0 && m==0) exit(0);\n\tfor(int i=1;i<=n;i++){\n\t\tG[i].clear();\n\t\tfor(int ii=0;ii<120;ii++)sumi[i][ii]=0;\n\t}\n\t\n\tfor(int i=0;i<m;i++){\n\t\tint y,yy,dd,ee;\n\t\t\n\t\tcin>>y>>yy>>dd>>ee;\n\t\t\tG[y].pb({yy,dd,ee});\n\t\t\tG[yy].pb({y,dd,ee});\n\t}\n\twhile(pq.size()){\n\t\tpq.pop();\n\t}\n\t\t\tpq.push({0,1,l});\n\twhile(pq.size()){\n\t\tauto z=pq.top();\n\t\tpq.pop();\n\t\tif(sumi[z.y][z.z])continue;\n\t\tsumi[z.y][z.z]=1;\n\t\t//cout<<z.y<<\" \"<<z.z<<\"   \"<<z.x<<endl;\n\t\tif(z.y==n){\n\t\t\tcout<<z.x<<endl;\n\t\t\treturn;\n\t\t}\n\t\tfor(auto v:G[z.y]){\n\t\t//\tcout<<\"  \"<<z.x<<\" \"<<v.z<<endl;\n\t\t\t\tpq.push({z.x+v.z,v.x,z.z});\n\t\t\tif(z.z>=v.y){\n\t\t\t\tpq.push({z.x,v.x,z.z-v.y});\n\t\t\t}\n\t\t}\n\t\n\t}\n\tprintf(\"Impossible\\n\");\n//\tcout<<\"Impossible\"<<endl;\n\treturn ;\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \n \twhile(1){\n \t\tsolve();\n \t}\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<array>\n\n#define fin cin\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nclass Input{\npublic:\n\tint a;\n\tint b;\n\tint d;\n\tint e;\n\tInput(int _a, int _b, int _d, int _e){\n\t\ta = _a;\n\t\tb = _b;\n\t\td = _d;\n\t\te = _e;\n\t}\n\toperator < (Input& other)\n\t{\n\t\treturn this->a < other.a;\n\t}\n\toperator > (Input& other)\n\t{\n\t\treturn this->a > other.a;\n\t}\n\n};\n\nconst int initnum = 10000000;\n\nstd::vector<Input> in_v{};\nstd::array<std::array<int, 100>, 100> cost;\n\nint main()\n{\n\t//std::ifstream fin(\"in.txt\");\n\t//cost[0].fill(0);\n\t//for(int i = 1; i < 100; i++)cost[i].fill(10000000);\n\n\twhile(true)\n\t{\n\t\tcost[0].fill(0);\n\t\t//cost[1].fill(0);\n\t\tfor(int i = 1; i < 100; i++)cost[i].fill(initnum);\n\t\n\t\tint n, m, l;\n\t\tfin >> n >> m >> l;\n\t\tif((n | m | l) == 0)break;\n\t\t//cout << n << \" \" << m << \" \" << l << endl;\n\t\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b, d, e;\n\t\t\tfin >> a >> b >> d >> e;\n\t\t\tin_v.push_back(Input(a-1, b-1, d, e));\n\t\t\tin_v.push_back(Input(b-1, a-1, d, e));\n\t\t}\n\t\tsort(in_v.begin(), in_v.end());\n\n\t\tstd::queue<Input> in_q;\n\t\tfor(auto in : in_v)in_q.push(in);\n\n\t\tin_v.clear();\n\t\tin_v.shrink_to_fit();\n\n\t\twhile(!in_q.empty())\n\t\t{\n\t\t\tInput tmp = in_q.front();\n\t\t\tin_q.pop();\n\n\t\t\tfor(int _cost = 0; _cost <= l; _cost++)\n\t\t\t{\n\n\t\t\t\tif(cost[tmp.a][_cost] == initnum)\n\t\t\t\t{\n\t\t\t\t\tin_q.push(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcost[tmp.b][_cost] = std::min(\n\t\t\t\t\tcost[tmp.b][_cost],\n\t\t\t\t\tstd::min(\n\t\t\t\t\t\t(_cost + tmp.d <= l ? (cost[tmp.a][_cost + tmp.d]) : initnum / 10),\n\t\t\t\t\t\tcost[tmp.a][_cost] + tmp.e\n\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\t\t\tfor(int i = 0; i <= l + 2; i++){\n\t\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\n\t\t}\n\t\tint min_cost = 10000000;\n\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tif(cost[n - 1][i] < min_cost)min_cost = cost[n - 1][i];\n\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t}\n\t\tcout << min_cost << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint cost;\n\tint enemy;\n};\n\nclass Situation{\npublic:\n\tint cost;\n\tint node;\n\tint money;\n\n\tSituation(int cost_,int node_,int money_){\n\t\tcost=cost_;\n\t\tnode=node_;\n\t\tmoney=money_;\n\t}\n\tSituation();\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\n\nint V;\n\nconst int MAX_V = 101;\n\nvector<edge> G[MAX_V][MAX_V];\n//  éêÉ écèàzÅ½Çè­Å¬RXg\nint d[MAX_V][MAX_V];\nconst int INF = 100000000;\n\n//int prevv[MAX_V];\nint L;\nint N;\nint M;\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n\tfor(int i = 0; i < MAX_V; i++)\n\t\tfill(d[i],d[i]+MAX_V,INF);\n\td[s][L] = 0;\n\tque.push(Situation(0,s,L));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint node = p.node;\n\t\tint money=p.money;\n\t\tif(d[node][money] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[node][money].size(); i++){\n\t\t\tedge e = G[node][money][i];\n\t\t\t// ¨àðgÁÄìµÄàç¤ê\n\t\t\tif(money-e.cost>=0){\n\t\t\t\tif(d[e.to][money-e.cost] > d[node][money]){\n\t\t\t\t\td[e.to][money-e.cost] = d[node][money];\n\t\t\t\t\tque.push(Situation(d[e.to][money-e.cost],e.to,money-e.cost));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ìÈµÌê\n\t\t\tif(d[e.to][money]>d[node][money]+e.enemy){\n\t\t\t\td[e.to][money]=d[node][money]+e.enemy;\n\t\t\t\tque.push(Situation(d[e.to][money],e.to,money));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>N>>M>>L&&!(N==0&&M==0&&L==0)){\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tfor(int j = 0; j < MAX_V; j++)\n\t\t\t\tG[i][j].clear();\n\t\tint from,to,cost,enemy;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin>>from>>to>>cost>>enemy;\n\t\t\tfrom--;\n\t\t\tto--;\n\t\t\tedge e;\n\t\t\te.cost=cost;\n\t\t\te.to=to;\n\t\t\te.enemy=enemy;\n\t\t\t\n\t\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\t\tG[from][i].push_back(e);\n\t\t\te.to=from;\n\t\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\t\tG[to][i].push_back(e);\n\t\t}\n\t\tdijkstra(0);\n\t\tint minCost=INF;\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tminCost=min(minCost,d[N-1][i]);\n\t\tcout<<minCost<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct {\n\tint to;\n\tint D;\n\tint E;\n} Edge;\n\nclass State {\npublic:\n\n\tint now;\n\tint money;\n\tint damaged;\n\n\tState(int now, int money, int damaged) {\n\t\tthis->now = now;\n\t\tthis->money = money;\n\t\tthis->damaged = damaged;\n\t}\n\n};\n\nconst int INF  = 999999;\n\nvector<Edge> G[101];\n\nint d[101][101];\n\nint N, M, L;\n\nint toV(int n, int l) {\n\treturn n * L + l;\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N + M + L != 0) {\n\t\tqueue<State> q;\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tG[i].clear();\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint A, B, D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tEdge e { B, D, E };\n\t\t\tEdge e2 { A, D, E };\n\t\t\tG[A].push_back(e);\n\t\t\tG[B].push_back(e2);\n\t\t}\n\t\tq.push(State(1, L, 0));\n\t\twhile (!q.empty()){\n\t\t\tState s = q.front();\n\t\t\tq.pop();\n\t\t\tif (s.damaged > d[s.now][s.money]) continue;\n\t\t\td[s.now][s.money] = s.damaged;\n\t\t\t\n\t\t\tfor (Edge e : G[s.now])\n\t\t\t{\n\t\t\t\tq.push(State(e.to, s.money, s.damaged + e.E));\n\t\t\t\tif (s.money - e.D >= 0) {\n\t\t\t\t\tq.push(State(e.to, s.money - e.D, s.damaged));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = INF;\n\t\tfor (int i = 0; i <= L; i++) {\n\t\t\tm = min(m, d[N][i]);\n\t\t}\n\t\tcout << m << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reps(i,j,k) for(int i = j;i < k; i++)\n#define rep(i,j) reps(i,0,j)\n#define INF 1<<30\nstruct edge\n{\n\tint to;\n\tint cost;\n\tint enemy;\n\tedge(){}\n\tedge(int _to,int _cost,int _enemy){\n\t\tto = _to;\n\t\tcost = _cost;\n\t\tenemy = _enemy;\n\t}\n\tbool operator<(const edge &a)const{\n\t\treturn enemy>a.enemy;\n\t}\n};\nvector < edge > Graph[101];\nint d[101][101];\nint main(){\n\tint N,M,L;\n\twhile(scanf(\"%d%d%d\",&N,&M,&L),N|M|L){\n\t\trep(i,101){\n\t\t\tGraph[i].clear();\n\t\t}\n\t\trep(i,M){\n\t\t\tint a,b,d,e;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&d,&e);\n\t\t\t--a;--b;\n\t\t\tGraph[a].push_back(edge(b,d,e));\n\t\t\tGraph[b].push_back(edge(a,d,e));\n\t\t}\n\t\tpriority_queue < edge > Q;\n\t\tQ.push(edge(0,L,0));\n\t\trep(i,101){\n\t\t\trep(j,101){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\twhile(!Q.empty()){\n\t\t\tedge e = Q.top();Q.pop();\n\t\t\tif(d[e.to][e.cost] != INF)continue;\n\t\t\td[e.to][e.cost] = e.enemy;\n\t\t\tif(e.to == N-1){\n\t\t\t\tans = e.enemy;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,Graph[e.to].size()){\n\t\t\t\tif(Graph[e.to][i].cost > e.cost){\n\t\t\t\t\tQ.push(edge(Graph[e.to][i].to,e.cost,e.enemy+Graph[e.to][i].enemy));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tQ.push(edge(Graph[e.to][i].to,e.cost,e.enemy+Graph[e.to][i].enemy));\n\t\t\t\t\tQ.push(edge(Graph[e.to][i].to,e.cost-Graph[e.to][i].cost,e.enemy));\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <tuple>\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n) - 1; i >= k; i--)\n\n#define debug(x) cerr <<#x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pi pair<int,int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n#define tup tuple<long long,int,int>\n#define mt make_tuple\n\ntypedef long long ll;\nconst ll inf = 900900900100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int MID = 255;\nusing namespace std;\n#define MAX_N 110\n\nint dp[110][100100] = {};\nint main(){\n    int n,m,l;\n    while(cin >> n >> m >> l,n) {\n        rep(i,110) rep(j,100100) dp[i][j] = 0;\n        vector<tup> E[MAX_N];\n        rep(i,m){\n            int a,b,d;\n            long long e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            E[a].pb(mt(e,b,d));\n            E[b].pb(mt(e,a,d));\n        }\n        priority_queue<tup,vector<tup>,greater<tup> > que;\n\n        ll d[MAX_N][110];\n        rep(i,MAX_N) rep(j,110) d[i][j] = inf;\n\n        rep(i,110) d[0][i] = 0;\n        que.push(mt(0,0,l));\n        while(!que.empty()) {\n            tup p = que.top();\n            que.pop();\n            ll cost = get<0>(p);\n            int v = get<1>(p);\n            int money = get<2>(p);\n            if (d[v][money] < cost) continue;\n            rep(i, E[v].size()) {\n                tup e = E[v][i];\n                //普通に動く\n                if (d[get<1>(e)][money] > d[v][money] + get<0>(e)) {\n                    d[get<1>(e)][money] = d[v][money] + get<0>(e);\n                    que.push(mt(d[get<1>(e)][money], get<1>(e),money));\n                }\n                //お金をはらう\n                if(get<2>(e) <= money) {\n                    if (d[get<1>(e)][money - get<2>(e)] > d[v][money]) {\n                        d[get<1>(e)][money - get<2>(e)] = d[v][money];\n                        que.push(mt(d[get<1>(e)][money - get<2>(e)], get<1>(e),money - get<2>(e)));\n                    }\n                }\n            }\n        }\n        ll ma = inf;\n        rep(i,l + 1){\n            ma = min(ma,d[n - 1][i]);\n        }\n        cout << ma << endl;\n        // cout << \"d[n-1] : \" << d[n - 1] << endl;\n        // int tt = n - 1;\n        // vector<int> WW;\n        // vector<int> VV;\n        // while(true) {\n        //     for(auto e : E[tt]) {\n        //         if(get<1>(e) == bv[tt]) {\n        //             WW.pb(get<2>(e));\n        //             VV.pb(get<0>(e));\n        //             break;\n        //         }\n        //     }\n        //     if(tt == 0) break;\n        //     tt = bv[tt];\n        // }\n\n\n        // REP(i, 1, l + 1) {\n        //     REP(j, 1, WW.size() + 1) {\n        //         dp[i][j] = dp[i][j - 1];\n        //         if( >= WW[j - 1]) {\n        //             dp[i][j] = max(dp[i][j - 1], dp[i - WW[j - 1]][j - 1] + VV[j - 1]);\n        //         }\n        //     }\n        // }\n        // cout << d[n - 1] - dp[l][WW.size()] << endl;\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nstruct edge {\n    int to;\n    int cost;\n    int numOfTheaf;\n};\n\nstruct info {\n    int now;\n    int sumOfCost;\n    int sumOfTheaf;\n    bool operator < (const info &o) const {\n        return  sumOfTheaf > o.sumOfTheaf;\n    }\n};\n\nint main() {\n    int n, m, l;\n    while (cin >> n >> m >> l, n) {\n        vector <vector <edge> > G(n);\n        rep (i, m) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--; b--;\n            G[a].push_back({b, d, e});\n            G[b].push_back({a, d, e});\n        }\n        //       to, sumOfCost -> sumOfTheaf\n        int dist[110][110] = {};\n        rep (i, 110) rep (j, 110) dist[i][j] = 1e9;\n//        bool used[110][110][110] = {};\n        //bool used[110][110] = {};\n\n        //info -> now, sumOfCost, sumOfTheaf\n        priority_queue <info> que;\n        que.push({0, 0, 0});\n\n        dist[0][0] = 0;\n\n        while (!que.empty()) {\n            info tmp = que.top(); que.pop();\n            //cout << tmp.now << endl;\n//            if ( used[tmp.now][tmp.sumOfCost][tmp.sumOfTheaf] ) continue;\n //           used[tmp.now][tmp.sumOfCost][tmp.sumOfTheaf] = true;\n            rep (i, G[tmp.now].size()) {\n                //護衛を雇わない場合\n                {\n                    if ( dist[G[tmp.now][i].to][tmp.sumOfCost] > dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf ) {\n                         dist[G[tmp.now][i].to][tmp.sumOfCost] = dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf;\n                         que.push({G[tmp.now][i].to, tmp.sumOfCost, dist[G[tmp.now][i].to][tmp.sumOfCost]});\n                    }\n                }\n                //護衛を雇う場合\n                {\n                //お金こえちゃだめ\n                    if ( G[tmp.now][i].cost + tmp.sumOfCost > l ) continue;\n                    if ( dist[G[tmp.now][i].to][tmp.sumOfCost + G[tmp.now][i].cost] > dist[tmp.now][tmp.sumOfCost] ) {\n                         dist[G[tmp.now][i].to][tmp.sumOfCost] = dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf;\n                        dist[G[tmp.now][i].to][tmp.sumOfCost + G[tmp.now][i].cost] = dist[tmp.now][tmp.sumOfCost];\n                        que.push({G[tmp.now][i].to, tmp.sumOfCost + G[tmp.now][i].cost, tmp.sumOfTheaf});\n                    }\n                }\n            }\n        }\n        int ans = 1e9;\n        rep (i, l + 1) ans = min(ans, dist[n - 1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nlong long slv(int, int,int);\n\nvector<vector<pair<int, int>>> s(101, vector<pair<int, int>>(101));\nvector<vector< int>> sflag(101, vector<int>(101, 0));\nint n, m, l;\n\nvector<vector<long long>> dp(101, vector<long long>(101, 0));\nvector<vector<int>> dpflag(101, vector<int>(101, 0));\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m >> l;\n\t\tif (n == 0)return 0;\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ts[b][a] = make_pair(d, e);\n\t\t\tsflag[b][a] = 1;\n\t\t\ts[a][b] = make_pair(d, e);\n\t\t\tsflag[a][b] = 1;\n\t\t}\n\t\t\n\t\tcout  << slv(n, l, 0) << endl;\n\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tdpflag[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\n\n\t}\n}\n\n\n\n\n\nlong long slv(int N, int L,int count) {\n\tif (count > 200)return 100000000000;\n\tcount++;\n\tfor (int j = 0; j <= l;j++) dpflag[1][j] = 1;\n\n\tif (dpflag[N][L] == 1) return dp[N][L];\n\tlong long min =   1000000000000;\n\tfor (int a = 1; a <= n; ++a) {\n\t\tlong long x = 2000000000000;\n\t\tlong long y = 3000000000000;\n\t\tif (sflag[N][a] == 1) {\n\t\t\tint LL = L - s[N][a].first;\n\t\t\tif (LL >= 0) {\n\t\t\t\tx = slv(a, LL,count);\n\t\t\t}\n\t\t\ty = slv(a, L,count) + s[N][a].second;\n\n\n\t\t}\n\t\tif (min>x) min = x;\n\t\tif (min>y) min = y;\n\t}\n\tdpflag[N][L] = 1;\n\tdp[N][L] = min;\n\n\treturn min;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nint N, M, L;\n\nstatic const int INF = 1e7;\n\nstruct Edge {\n  int B, D, E;\n  Edge(int B, int D, int E) : B(B), D(D), E(E) {}\n};\n\nstruct State {\n  int cur;\n  int cost;\n  int money;\n  State(int cur, int cost, int money) : cur(cur), cost(cost), money(money) {}\n  bool operator<(const State & rhs) const {\n    return cost > rhs.cost;\n  }\n  void print() {\n    printf(\"%d %d %d\\n\", cur, cost, money);\n  }\n};\n\nvector<Edge> Graph[200];\n\nint mini[200][200];\n\nvoid init() {\n  for (int i = 0; i < 200; i++) {\n    Graph[i].clear();\n  }\n\n  for (int i = 0; i < 200; i++) {\n    for (int j = 0; j < 200; j++) {\n      mini[i][j] = INF;\n    }\n  }\n}\n\nvoid solve() {\n  priority_queue<State> Q;\n\n  Q.push(State(0, 0, L));\n\n  \n  while (!Q.empty()) {\n    State cur = Q.top();\n    Q.pop();\n    //cur.print();\n\n    int c = cur.cur;\n    int cost = cur.cost;\n    int money = cur.money;\n\n    if (mini[c][money] < cost) {\n      continue;\n    }\n    mini[c][money] = cost;  \n    for (int i = 0; i < Graph[c].size(); i++) {\n      int dst = Graph[c][i].B;\n      int dis = Graph[c][i].D;\n      int enm = Graph[c][i].E;\n      //      cout << \"Edge\" << endl;\n      //      cout << dst << \" \" << dis << \" \" << enm << endl;\n      if (money - dis >= 0 && mini[dst][money - dis] > cost) {\n        Q.push(State(dst, cost, money - dis));\n      }\n      if (mini[dst][money] > cost + enm) {\n        Q.push(State(dst, cost + enm, money));\n      }\n    }\n  }\n\n  int mn = INF;\n  //cout << \"N = \" << N << endl;\n  for (int i = 0; i <= L; i++) {\n    //cout << mini[N - 1][i] << \" \" ;\n    mn = min((double)mini[N - 1][i], (double)mn);\n  }\n  //cout << endl;\n\n  cout << mn << endl;\n}\n\nint main() {\n  while (true) {\n    cin >> N >> M >> L;\n    if (N == 0 && M == 0 && L == 0) {\n      return 0;\n    }\n    init();\n    for (int i = 0; i < M; i++) {\n      int a, b, d, e;\n      cin >> a >> b >> d >> e;\n      a--, b--;\n      Graph[a].push_back(Edge(b, d, e));\n      Graph[b].push_back(Edge(a, d, e));\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n,m,l;\n\nll solve() {\n\tvector<vector<P>> adj(n);\n\tvector<vector<ll>> atk(n,vector<ll>(n,-1));\n\tREP(i,m) {\n\t\tll a,b,d,e;\n\t\tcin>>a>>b>>d>>e;\n\t\ta--;\n\t\tb--;\n\t\tadj[a].pb(P(b,d));\n\t\tadj[b].pb(P(a,d));\n\t\tatk[a][b]=e;\n\t\tatk[b][a]=e;\n\t}\n\tvector<vector<ll>> cost(n,vector<ll>(l+1,INF*INF));\n\tcost[0][l]=0;\n\tpriority_queue<pair<ll,P>,vector<pair<ll,P>>,greater<pair<ll,P>>> q;\n\tq.push(make_pair(cost[0][l],P(0,l)));\n\twhile(!q.empty()) {\n\t\tll c=q.top().first;\n\t\tll p=q.top().second.first;\n\t\tll mon=q.top().second.second;\n\t\tq.pop();\n\t\tif(cost[p][mon]!=c) continue;\n\t\tREP(i,(ll)adj[p].size()) {\n\t\t\tll d=adj[p][i].second;\n\t\t\tll np=adj[p][i].first;\n\t\t\tll e=atk[p][np];\n\t\t\tif(cost[np][mon]>c+e) {\n\t\t\t\tcost[np][mon]=c+e;\n\t\t\t\tq.push(make_pair(cost[np][mon],P(np,mon)));\n\t\t\t}\n\t\t\tif(mon>=d&&cost[np][mon-d]>c) {\n\t\t\t\tcost[np][mon-d]=c;\n\t\t\t\tq.push(make_pair(cost[np][mon-d],P(np,mon-d)));\n\t\t\t}\n\t\t}\n\t}\n\tll ret=INF*INF;\n\tREP(i,l+1) ret=min(ret,cost[n-1][i]);\n\treturn ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n>>m>>l;\n\t\tif(n==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\ntypedef pair<int, int> state; // 頂点、残金\ntypedef pair<state, int> pass; // 状態、悪党\ntypedef tuple<int, int, int> cand; // -1 * cost, point, money\n\nvector<pass> V[110][110];\n\nint main() {\n  int N, M, L;\n  while(cin >> N >> M >> L && N) {\n    N--;\n    // 初期化\n    for (auto i=0; i<110; i++) {\n      for (auto j=0; j<110; j++) {\n\tV[i][j].clear();\n      }\n    }\n    // 入力受け取り\n    int AA[110], BB[110], DD[110], EE[110];\n    for (auto i=0; i<M; i++) {\n      cin >> AA[i] >> BB[i] >> DD[i] >> EE[i];\n      AA[i]--;\n      BB[i]--;\n    }\n    // 隣接リスト作成\n    for (auto i=0; i<M; i++) {\n      for (auto j=0; j<=L; j++) {\n\tV[AA[i]][j].push_back(make_pair(make_pair(BB[i], j), EE[i]));\n\tV[BB[i]][j].push_back(make_pair(make_pair(AA[i], j), EE[i]));\n\tint t = j - DD[i];\n\tif (t >= 0) {\n\t  V[AA[i]][j].push_back(make_pair(make_pair(BB[i], t), 0));\n\t  V[BB[i]][j].push_back(make_pair(make_pair(AA[i], t), 0));\n\t}\n      }\n    }\n    // Dijkstra法\n    priority_queue<cand> Q;\n    Q.push(make_tuple(0, 0, L));\n    bool visited[110][110];\n    fill(&visited[0][0], &visited[0][0]+110*110, false);\n    int ans = 0;\n    while (!Q.empty()) {\n      int np = get<1>(Q.top());\n      int nl = get<2>(Q.top());\n      int nc = -1 * get<0>(Q.top());\n      Q.pop();\n      if (!visited[np][nl]) {\n\tvisited[np][nl] = true;\n\t// cerr << \"visiting \" << np << \" at \" << nl << endl;\n\tif (np == N) {\n\t  ans = nc;\n\t  break;\n\t}\n\tfor (auto i=0; i<V[np][nl].size(); i++) {\n\t  int dp = V[np][nl][i].first.first;\n\t  int dl = V[np][nl][i].first.second;\n\t  int dc = V[np][nl][i].second;\n\t  if (!visited[dp][dl]) {\n\t    Q.push(make_tuple(-1* (dc+nc), dp, dl));\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\n#define NO_ROUTE 1000000\n\nusing namespace std;\n\nstruct edge {\n  //int n;\n  int tozoku;\n  int dist;\n};\n\nstruct node {\n  int n;\n  int money;\n\n  bool done;\n  int tozoku;\n  node (int n0 = 0, int money0 = 0, int done0 = false, int tozoku0 = 1000000) {\n    n = n0, money = money0, done = done0, tozoku = tozoku0;\n  }\n  bool operator<(const node &t)const {\n    return tozoku > t.tozoku;\n  }\n};\n\nint N, M, L;\nnode G[100][100];\nedge e[100][100];\n\nint search()\n{\n  priority_queue<node> que;\n  node start(0, L, true, 0);\n  G[0][L] = node(0, L, true, 0);\n  que.push(start);\n\n  while (!que.empty()) {\n    node n_node;\n    n_node = que.top();\n    G[n_node.n][n_node.money].done = true;\n    //cout << \"n \" << n_node.n << \" money \" << n_node.money << \" done \" << n_node.done << \" tozoku \" << n_node.tozoku << endl;\n    que.pop();\n    if (n_node.n == N - 1) return n_node.tozoku;\n    \n    for (int i = 0; i < N; i++) {\n      if (e[n_node.n][i].dist == NO_ROUTE) continue;\n      ////cout << \"dist \" << e[n_node.n][i].dist << endl;\n      if (!G[i][n_node.money].done) {\n\tif (n_node.tozoku + e[i][n_node.money].tozoku < G[i][n_node.money].tozoku) {\n\t  G[i][n_node.money] = node(i, n_node.money, false, n_node.tozoku + e[i][n_node.n].tozoku);\n\t  //cout << n_node.tozoku << \" + \" << e[n_node.n][i].tozoku << endl;\n\t  node t_node = G[i][n_node.money];\n\t  que.push(t_node);\n\t}\n      }\n      if (n_node.money >= e[n_node.n][i].dist && !G[i][n_node.money - e[n_node.n][i].dist].done \n\t  && n_node.tozoku < G[i][n_node.money - e[n_node.n][i].dist].tozoku) {\n\tG[i][n_node.money - e[n_node.n][i].dist] = node(i, n_node.money - e[n_node.n][i].dist, false, n_node.tozoku);\n\tnode t_node = G[i][n_node.money - e[n_node.n][i].dist];\n\tque.push(t_node);\n      }\n    }\n  }\n  return -1;\n}\n\n\nint main()\n{\n  while (true) {\n    scanf(\"%d %d %d \", &N, &M, &L);\n    if (N == 0 && M == 0 && L == 0) break;\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n\tG[i][j].n = i;\n\tG[i][j].money = j;\n\t\n\te[i][j].dist = NO_ROUTE;\n\te[i][j].tozoku = 0;\n      }\n    }\n    \n    for (int i = 0; i < M; i++) {\n      int x, y;\n      scanf(\"%d %d \", &x, &y);\n      x--, y--;\n      scanf(\"%d %d \", &e[x][y].dist, &e[x][y].tozoku);\n      e[y][x].dist = e[x][y].dist, e[y][x].tozoku = e[x][y].tozoku;\n    }\n    \n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n\t//cout << e[i][j].dist << \" \" << e[i][j].tozoku << \"   \";\n      }\n      //cout << endl;\n    }\n\n    cout << search() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define rforeach(t,p) for(t::reverse_iterator it=p.rbegin();it!=p.rend();++it)\n#define all(p) p.begin(),p.end()\nusing namespace std;\n\nstruct hoge{\nhoge(int a,int b,int c,int d):enemy(a),money(b),position(c),old(d){}\n    int enemy;\n    int money;\n    int position;\n    int old;\n};\n\nbool operator<(const hoge& left, const hoge& right)\n{\n  return left.enemy < right.enemy ;\n}\n\n#define LOAD 110\n\nint main()\n{\n    int n,m,l;\n    while(cin >> n >> m >> l && (n || m|| l))\n    {\n        int len[LOAD][LOAD],thi[LOAD][LOAD];\n        for(int i=0;i<LOAD;i++)for(int j=0;j<LOAD;j++)\n        {\n            len[i][j]=len[j][i]=thi[i][j]=thi[j][i]=-1;   \n        }\n        for(int i=0;i<m;i++)\n        {\n            int a,b,c,d;\n            cin >> a>>b>>c>>d;\n            len[a][b]=len[b][a]=c;\n            thi[a][b]=thi[b][a]=d;\n        }\n        set<hoge> in;\n        in.insert(hoge(0,l,1,0));\n        \n        while(true)\n        {\n            hoge a=(*in.begin());\n            in.erase(in.begin());\n            //int e=a.enemy;\n            //int mon=a.money;\n            //int pos=a.position;\n            if(a.position==n){cout << a.enemy << endl;break;}\n            for(int i=2;i<n+1;i++)if((len[a.position][i] != -1 )&&(a.old!=i))\n            {\n                in.insert(hoge(a.enemy+thi[a.position][i],a.money,i,a.position));\n                if(a.money+1 >len[a.position][i])\n                    in.insert(hoge(a.enemy,a.money-len[a.position][i],i,a.position));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nbool operator==(const State& lhs, const State& rhs)\n{\n    return lhs.loc == rhs.loc && lhs.money == rhs.money && lhs.damage == rhs.damage;\n}\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<int> memo(101, INT_MAX);\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (memo[current.loc] <= current.money) {\n                continue;\n            }\n            memo[current.loc] = current.money;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (e.dist <= current.money) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> P;\nstruct edge{int to;double cost;};\n\nint N,M,L,d[10100];\nvector<edge> g[10100];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tfill(d,d+10000,INF);\n\td[s]=0;\n\tq.push(P(0,s));\n\twhile(!q.empty()){\n\t\tP p=q.top();q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\trep(i,g[v].size()){\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>N>>M>>L&&N){\n\t\trep(i,10100)g[i].clear();\n\t\trep(i,M){\n\t\t\tint A,B,D,E;\n\t\t\tcin>>A>>B>>D>>E;\n\t\t\tA--;B--;\n\t\t\tedge e;\n\t\t\trep(m,L+1){\n\t\t\t\te.to=100*m+B;\n\t\t\t\te.cost=E;\n\t\t\t\tg[100*m+A].push_back(e);\n\t\t\t\te.to=100*m+A;\n\t\t\t\tg[100*m+B].push_back(e);\n\t\t\t\tif(m>=D){\n\t\t\t\t\te.to=100*(m-D)+B;\n\t\t\t\t\te.cost=0;\n\t\t\t\t\tg[100*m+A].push_back(e);\n\t\t\t\t\te.to=100*(m-D)+A;\n\t\t\t\t\tg[100*m+B].push_back(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(100*L);\n\t\tint ans=INF;\n\t\trep(m,L+1)ans=min(ans,d[100*m+N-1]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\npii cost[101][101];\n\nstruct node {\n\tint cost, money, pos;\n\tnode(int c, int m, int p) {\n\t\tcost = c;\n\t\tmoney = m;\n\t\tpos = p;\n\t}\n};\nbool operator<( const node& l, const node& r ) {\n\tif( l.cost == r.cost ) {\n\t\treturn l.money < r.money;\n\t}\n\treturn l.cost > r.cost;\n}\n\nint main() {\n\tint n, m, l;\n\twhile( cin >> n >> m >> l, n||m||l ) {\n\t\trep(i,101) rep(j,101) cost[i][j].first = cost[i][j].second = -1;\n\t\trep(i, m) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tcost[a][b].first = cost[b][a].first = d;\n\t\t\tcost[a][b].second = cost[b][a].second = e;\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tque.push( node(0, l, 1) );\n\t\twhile( !que.empty() ) {\n\t\t\tnode nd = que.top();\n\t\t\tque.pop();\n\t\t\tif( nd.pos == n ) {\n\t\t\t\tcout << nd.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\tif( cost[nd.pos][i].second != -1 ) {\n\t\t\t\t\tque.push( node(nd.cost+cost[nd.pos][i].second, nd.money, i) );\n\t\t\t\t\tif( nd.money >= cost[nd.pos][i].first ) {\n\t\t\t\t\t\tque.push( node(nd.cost, nd.money-cost[nd.pos][i].first, i) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct NODE{\n  vector<int> to_node;\n  vector<int> to_cost;\n  vector<int> to_man;\n  bool done_c;\n  bool done_m;\n  bool start;\n  int cost;\n  int man;\n  int nom;\n};\nint main(){\n  int n,m,l;\n  while(cin >>n>>m>>l,n|m|l){\n    NODE inn[100];\n    vector<int> ans;\n    while(m--){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      inn[a-1].to_node.push_back(b-1);\n      inn[a-1].to_cost.push_back(c);\n      inn[a-1].to_man.push_back(d);\n      inn[b-1].to_node.push_back(a-1);\n      inn[b-1].to_cost.push_back(c);\n      inn[b-1].to_man.push_back(d);\n    }\n    for(int i=0; i<n; i++){\n      inn[i].start = false;\n      inn[i].nom = 100000;\n    }\n    inn[0].nom = 0;\n    for(int i=0; i<n; i++){\n      int at = 0,pom = 1000000;\n      for(int j=0; j<n; j++){\n\tif((!(inn[j].start)) && pom>inn[j].nom){at = j; pom = inn[j].nom;}\n      }\n      inn[at].start = true;\n      for(int j=0; j<inn[at].to_node.size(); j++){\n\tint togo = inn[at].to_node[j];\n\tif(!inn[togo].start){inn[togo].nom = min(inn[at].to_man[j] + inn[at].nom,inn[togo].nom);}\n      }\n    }\n    for(int k=0; k<n; k++){\n      for(int i=0; i<n; i++){\n\tinn[i].cost = 100000;\n\tinn[i].done_c = false;\n      }\n      inn[k].cost = 0;\n      for(int i=0; i<n; i++){\n\tint at = 0,pom = 1000000;\n\tfor(int j=0; j<n; j++){\n\t  if((!(inn[j].done_c)) && pom>inn[j].cost){at = j; pom = inn[j].cost;}\n\t}\n\tinn[at].done_c = true;\n\tfor(int j=0; j<inn[at].to_node.size(); j++){\n\t  int togo = inn[at].to_node[j];\n\t  if(!inn[togo].done_c){inn[togo].cost = min(inn[at].to_cost[j] + inn[at].cost,inn[togo].cost);}\n\t}\n      }\n      for(int i=0; i<n; i++){\n\tinn[i].man = 100000;\n\tinn[i].done_m = false;\n\tif(inn[i].cost<=l){\n\t  inn[i].man = 0;\n\t}\n      }\n      inn[k].cost = 0;\n      for(int i=0; i<n; i++){\n\tint at = 0,pom = 1000000;\n\tfor(int j=0; j<n; j++){\n\t  if((!(inn[j].done_m)) && pom>inn[j].man){at = j; pom = inn[j].man;}\n\t}\n\tinn[at].done_m = true;\n\tfor(int j=0; j<inn[at].to_node.size(); j++){\n\t  int togo = inn[at].to_node[j];\n\t  if(!inn[togo].done_m){inn[togo].man = min(inn[at].to_man[j] + inn[at].man,inn[togo].man);}\n\t}\n      }\n      ans.push_back(inn[k].nom + inn[n-1].man);\n    }\n    sort(ans.begin(),ans.end());\n    cout <<ans[0]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int to,d,e;\n  Edge(int to,int d,int e):to(to),d(d),e(e){}\n};\n\nint N,M,L;\nvector<Edge>G[128];\nint dist[128][128];\n\nvoid dijkstra(){\n  rep(i,128) fill(dist[i], dist[i]+N, INF);\n  dist[L][0] = 0;\n  priority_queue<P, vector<P>, greater<P> >q;\n  q.push(P(L, 0));\n\n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    int v = p.second, m = p.first;\n    rep(i,G[v].size()){\n      Edge e = G[v][i];\n      if(e.d <= m){\n\tif(dist[m-e.d][e.to] > dist[m][v]){\n\t  dist[m-e.d][e.to] = dist[m][v];\n\t  q.push(P(m-e.d, e.to));\n\t}\n      }\n      if(dist[m][e.to] > dist[m][v] + e.e){\n\tdist[m][e.to] = dist[m][v] + e.e;\n\tq.push(P(m, e.to));\n      }\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d%d%d\", &N,&M,&L) && N+M+L){\n    rep(i,128) G[i].clear();\n    rep(i,M){\n      int a,b,d,e;\n      scanf(\"%d%d%d%d\",&a,&b,&d,&e); a--; b--;\n      G[a].push_back(Edge(b,d,e));\n      G[b].push_back(Edge(a,d,e));\n    }\n\n    dijkstra();\n    int res = INF;\n    rep(i,L+1){\n      //      cout << dist[i][N-1] <<endl;;\n      //      rep(j,N) cout << dist[i][j] << \" \"; cout << endl;\n    }\n    rep(i,L+1) res = min(res, dist[i][N-1]);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\nbool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy < b.enemy;\n}\n\nbool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\t\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\twhile( !status.empty() ) {\n\t\t\tstatus.pop() ;\n\t\t}\t\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint N, M, L;\n\nstruct edge {\n    int to, distance, enemy;\n};\n\nstruct P {\n    int from, money, enemy;\n\n    bool operator >(const P& p) const {\n        return enemy > p.enemy;\n    }\n};\n\nint main() {\n    while (cin >> N >> M >> L, N|M|L) {\n        vector<vector<edge> > E(N);\n        int a, b, d, e;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> d >> e;\n            E[a-1].push_back({b, d, e});\n            E[b-1].push_back({a, d, e});\n        }\n\n        priority_queue<P, vector<P>, greater<P>> q;\n        q.push((P){0, L, 0});\n            while(!q.empty()) {\n            P p = q.top(); q.pop();\n            // goal\n            if (p.from == N-1) {\n                cout << p.enemy << endl;\n                break;\n            }\n            for (int i = 0; i < E[p.from].size() ; i++) {\n                edge e = E[p.from][i];\n                q.push((P){e.to-1, p.money, p.enemy+e.enemy});\n                if (p.money-e.distance >= 0) {\n                    q.push((P){e.to-1, p.money-e.distance, p.enemy});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\npii cost[101][101];\nint visit[101];\n\nstruct node {\n\tint cost, money, pos;\n\tnode(int c, int m, int p) {\n\t\tcost = c;\n\t\tmoney = m;\n\t\tpos = p;\n\t}\n};\nbool operator<( const node& l, const node& r ) {\n\tif( l.cost == r.cost ) {\n\t\treturn l.money < r.money;\n\t}\n\treturn l.cost > r.cost;\n}\n\nint main() {\n\tint n, m, l;\n\twhile( cin >> n >> m >> l, n||m||l ) {\n\t\trep(i,101) rep(j,101) cost[i][j].first = cost[i][j].second = -1;\n\t\trep(i, m) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tcost[a][b].first = cost[b][a].first = d;\n\t\t\tcost[a][b].second = cost[b][a].second = e;\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tmemset( visit, -1, sizeof(visit) );\n\t\tque.push( node(0, l, 1) );\n\t\twhile( !que.empty() ) {\n\t\t\tnode nd = que.top();\n\t\t\tque.pop();\n\t\t\tif( nd.money <= visit[nd.pos] ) continue;\n\t\t\tvisit[nd.pos] = nd.money;\n\t\t\tif( nd.pos == n ) {\n\t\t\t\tcout << nd.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\tif( cost[nd.pos][i].second != -1 ) {\n\t\t\t\t\tif( visit[i] < nd.money ) {\n\t\t\t\t\t\tque.push( node(nd.cost+cost[nd.pos][i].second, nd.money, i) );\n\t\t\t\t\t}\n\t\t\t\t\tif( nd.money >= cost[nd.pos][i].first && visit[i] < nd.money-cost[nd.pos][i].first ) {\n\t\t\t\t\t\tque.push( node(nd.cost, nd.money-cost[nd.pos][i].first, i) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n\n#include<iomanip>\n#include<vector>\n#include<string>\n#include<queue>\n#include<stack>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntypedef long long LL;\ntemplate<typename T>\nbool chmin(T &l, T& r){\n\tbool f = l>r; if (f)l = r; return f;\n}\ntemplate<typename T>\nbool chmax(T &l, T& r){\n\tbool f = l<r; if (f)l = r; return f;\n}\ntypedef vector<LL> V;\ntypedef vector<V> VV;\n\n\nint a[11234];\nint b[11234];\nint d[11234];\nLL e[11234];\ntypedef tuple<LL, int, int> TT;\n#define DCtt(v,l,c,x) LL c;int v,l;tie(c,v,l)=x;cost*=-1;\nconst LL INF = 1e15;\nLL dijkstra(int s, int t,int L, VV &g){\n\tint N = g.size();\n\tVV dist(N, V(L + 1, INF));\n\tpriority_queue<TT> que;\n\tque.push(TT(0, s, L));\n\tdist[s][L] = 0;\n\twhile (que.size()){\n\t\tDCtt(v, l, cost, que.top()); que.pop();\n\t\tif (v == t)return cost;\n\t\tif (dist[v][t] < cost)continue;\n\t\tfor (auto &ee : g[v]){\n\t\t\tint u = v^a[ee] ^ b[ee];\n\t\t\tif (d[ee] <= l){\n\t\t\t\tint nxt_l = l - d[ee];\n\t\t\t\tLL nxt_cost = cost;\n\t\t\t\tif (chmin(dist[u][nxt_l], nxt_cost)){\n\t\t\t\t\tque.push(TT(-nxt_cost, u, nxt_l));\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint nxt_l = l;\n\t\t\t\tLL nxt_cost = cost+e[ee];\n\t\t\t\tif (chmin(dist[u][nxt_l], nxt_cost)){\n\t\t\t\t\tque.push(TT(-nxt_cost, u, nxt_l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint main(){\n\tint N,M,L;\n\twhile (cin>>N>>M>>L,N+M+L){\n\t\tVV g(N);\n\t\tREP(i, M){\n\t\t\tcin >> a[i] >> b[i] >> d[i] >> e[i];\n\t\t\ta[i]--; b[i]--;\n\t\t\tg[a[i]].push_back(i);\n\t\t\tg[b[i]].push_back(i);\n\n\t\t}\n\t\tcout << dijkstra(0, N - 1, L, g) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nstatic const int INF = 1E8;\nstruct Edge{int A, B, D, E;};\nint N, M, L;\nint A, B, D, E;\nvector<Edge> g[111];\nint d[111][111];\nvector<int> tmp(3);\n\nint main()\n{\n  while(cin >> N >> M >> L, N){\n    rep(i, 111) g[i].clear();\n    rep(i, M){\n      cin >> A >> B >> D >> E;\n      g[A - 1].push_back((Edge){A - 1, B - 1, D, E});\n      g[B - 1].push_back((Edge){B - 1, A - 1, D, E});\n    }\n\n    rep(i, 111) rep(j, 111) d[i][j] = INF;\n    d[0][0] = 0;\n    priority_queue<vector<int>, vector<vector<int> >, greater<vector<int> > > que;\n    tmp[0] = 0,  tmp[1] = 0,  tmp[2] = 0;\n    que.push(tmp);\n    while(!que.empty()){\n      vector<int> top = que.top();  que.pop();\n      int cnt = top[0];\n      int cost = top[1];\n      int h = top[2];\n      if(d[h][cost] < cnt) continue;\n      rep(i, g[h].size()){\n        Edge e = g[h][i];\n        tmp[2] = e.B;\n        if(cost <= L && d[e.B][cost] > cnt + e.E) {\n          d[e.B][cost] = cnt + e.E;\n          tmp[0] = cnt + e.E;\n          tmp[1] = cost;\n          que.push(tmp);\n        }\n        if(cost + e.D <= L && d[e.B][cost + e.D] > cnt){\n          d[e.B][cost + e.D] = cnt;\n          tmp[0] = cnt;\n          tmp[1] = cost + e.D;\n          que.push(tmp);\n        }\n      }\n    }\n    int res = INF;\n    rep(i, 111) res = min(res, d[N - 1][i]);\n    printf(\"%d\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N, M, L;\nstruct edge{\n  int to, d, n;\n  edge() {}\n  edge(int to, int d, int n) :\n    to(to), d(d), n(n) {}\n};\nvector<edge> edges[101];\nint memo[101][101];\nint dfs(int p, int l, int sum){\n  //printf(\"%d %d -> %d\\n\", p, l, sum);\n  if(p == N - 1) return sum;\n  memo[p][l] = min((memo[p][l]!=-1)?memo[p][l]:INF, sum);\n  int res = INF;\n  FORIT(it, edges[p]){\n    edge e = *it;\n    if(memo[e.to][l] == -1 || memo[e.to][l] > sum + e.n && res > sum + e.n)res = min(res, dfs(e.to, l, sum + e.n));\n    if(l - e.d >= 0 && (memo[e.to][l-e.d] == -1 || memo[e.to][l-e.d] > sum && res > sum)) res = min(res, dfs(e.to, l - e.d, sum));\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>N>>M>>L && N){\n    REP(i, 101)edges[i].clear();\n    memset(memo, -1, sizeof(memo));\n    REP(i, M){\n      int A,B,D,E;\n      cin>>A>>B>>D>>E;\n      A--; B--;\n      edges[A].push_back(edge(B, D, E));\n      edges[B].push_back(edge(A, D, E));\n    }\n    int ans = dfs(0, L, 0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\n\ntemplate<typename T>\nvoid dijkstra(\n        const WeightedGraph<T> &g,\n        vector<T> &dist,\n        int s)\n{\n    const auto INF = numeric_limits<T>::max();\n    dist.assign(g.size(), INF);\n\n    using Pi = pair< T, int >;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    dist[s] = 0;\n    que.emplace(dist[s], s);\n    while(!que.empty()) {\n        T cost;\n        int idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(dist[idx] < cost) continue;\n        for(auto &e : g[idx]) {\n            auto next_cost = cost + e.cost;\n            if(dist[e.to] <= next_cost) continue;\n            dist[e.to] = next_cost;\n            que.emplace(dist[e.to], e.to);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, m, L; cin >> n >> m >> L;\n        if (n == 0) {\n            break;\n        }\n        vector<int> a(m), b(m), d(m), e(m);\n        for (int i = 0; i < m; ++i) {\n            cin >> a[i] >> b[i] >> d[i] >> e[i];\n            --a[i], --b[i];\n        }\n\n        WeightedGraph<int> G(n*(L+1));\n        for (int i = 0; i < m; ++i) {\n            for (int l = 0; l <= L; ++l) {\n                G[a[i]+n*l].emplace_back(b[i]+n*l, e[i]);\n                G[b[i]+n*l].emplace_back(a[i]+n*l, e[i]);\n                if (l >= d[i]) {\n                    G[a[i]+n*l].emplace_back(b[i]+n*(l-d[i]), 0);\n                    G[b[i]+n*l].emplace_back(a[i]+n*(l-d[i]), 0);\n                }\n            }\n        }\n\n        vector<int> dist(n*(L+1));\n        dijkstra(G, dist, n*L);\n        int ans = numeric_limits<int>::max();\n        for (int l = 0; l <= L; ++l) {\n            chmin(ans, dist[n-1 + n*l]);\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\nvector<pa3> G[133];\nbool sumi[133][124];\npriority_queue<pa3,vector<pa3>,greater<pa3>> pq; \nvoid solve(){\n\tint n,m,l;\n\tcin>>n>>m>>l;\n\tif(n==0 && m==0) exit(0);\n\tfor(int i=1;i<=n;i++){\n\t\tG[i].clear();\n\t\tfor(int ii=0;ii<120;ii++)sumi[i][ii]=0;\n\t}\n\t\n\tfor(int i=0;i<m;i++){\n\t\tint y,yy,dd,ee;\n\t\t\n\t\tcin>>y>>yy>>dd>>ee;\n\t\t\tG[y].pb({yy,dd,ee});\n\t\t\tG[yy].pb({y,dd,ee});\n\t}\n\twhile(pq.size()){\n\t\tpq.pop();\n\t}\n\t\t\tpq.push({0,1,l});\n\twhile(pq.size()){\n\t\tauto z=pq.top();\n\t\tpq.pop();\n\t\tif(sumi[z.y][z.z])continue;\n\t\tsumi[z.y][z.z]=1;\n\t\t//cout<<z.y<<\" \"<<z.z<<\"   \"<<z.x<<endl;\n\t\tif(z.y==n){\n\t\t\tcout<<z.x<<endl;\n\t\t\treturn;\n\t\t}\n\t\tfor(auto v:G[z.y]){\n\t\t//\tcout<<\"  \"<<z.x<<\" \"<<v.z<<endl;\n\t\t\t\tpq.push({z.x+v.z,v.x,l});\n\t\t\tif(z.z>=v.y){\n\t\t\t\tpq.push({z.x,v.x,z.z-v.y});\n\t\t\t}\n\t\t}\n\t\n\t}\n\tprintf(\"Impossible\\n\");\n//\tcout<<\"Impossible\"<<endl;\n\treturn ;\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \n \twhile(1){\n \t\tsolve();\n \t}\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int infty = 1<<28;\nstruct Node{\n  vector<int> con;\n  vector<int> cost;\n  vector<int> dist;\n};\nstruct State{\n  int L;\n  int cost;\n  int now;\n  State():now(-1),cost(infty),L(-1){}\n  State(int pos,int cost, int L):now(pos),cost(cost),L(L){}\n  bool operator>(const State &t)const{return cost>t.cost;}\n};\ntypedef vector<Node> Graph;\nint dijkstra(int s, int g, int L, Graph &G){\n  int A[G.size()][L+1];\n  bool vis[G.size()][L+1];\n  for(int i = 0; i < G.size(); ++i){\n    for(int j = 0; j < L+1; ++j){\n      A[i][j]=infty;\n      vis[i][j]=false;\n    }\n  }\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push( State(s,0,L) );\n  if(s==g)return 0;\n  while(!Q.empty()){\n    State now = Q.top(); Q.pop();\n    if(vis[now.now][now.L])continue;\n    vis[now.now][now.L]=true;\n    for(int i = 0; i < G[now.now].con.size(); ++i){\n      int next_id = G[now.now].con[i];\n      for(int k = 0; k < 2; ++k){\n\tint next_L = now.L - G[now.now].dist[i];\n\tint costi = G[now.now].cost[i];\n\tif(k==1)next_L=now.L;\n\tif(k==0)costi=0;\n\tif(next_L>=0){\n\t  if( now.cost+costi<A[next_id][next_L] ){\n\t    A[next_id][next_L]=now.cost+costi;\n\t    if(!vis[next_id][next_L]){\n\t      Q.push(State(next_id,A[next_id][next_L],next_L));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  int ret=infty;\n  for(int i = 0; i < L+1; ++i){\n    ret=min(ret,A[g][i]);\n  }\n  return ret;\n}\n\n\nint main()\n{\n  int N,M,L;\n  while(cin>>N>>M>>L&&N){\n    Graph G(N);\n    for(int i = 0; i < M; ++i){\n      int A,B,D,E;\n      cin >> A >> B >> D >> E;\n      --A;--B;\n      G[A].con.push_back(B);\n      G[A].cost.push_back(E);\n      G[A].dist.push_back(D);\n      G[B].con.push_back(A);\n      G[B].cost.push_back(E);\n      G[B].dist.push_back(D);\n    }\n    cout << dijkstra(0,N-1,L,G) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> P;\nstruct edge{int to;double cost;};\n\nint N,M,L,d[10100];\nvector<edge> g[10100];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tfill(d,d+10100,INF);\n\td[s]=0;\n\tq.push(P(0,s));\n\twhile(!q.empty()){\n\t\tP p=q.top();q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\trep(i,g[v].size()){\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>N>>M>>L&&N){\n\t\trep(i,10100)g[i].clear();\n\t\trep(i,M){\n\t\t\tint A,B,D,E;\n\t\t\tcin>>A>>B>>D>>E;\n\t\t\tA--;B--;\n\t\t\tedge e;\n\t\t\trep(m,L+1){\n\t\t\t\te.to=100*m+B;\n\t\t\t\te.cost=E;\n\t\t\t\tg[100*m+A].push_back(e);\n\t\t\t\te.to=100*m+A;\n\t\t\t\tg[100*m+B].push_back(e);\n\t\t\t\tif(m>=D){\n\t\t\t\t\te.to=100*(m-D)+B;\n\t\t\t\t\te.cost=0;\n\t\t\t\t\tg[100*m+A].push_back(e);\n\t\t\t\t\te.to=100*(m-D)+A;\n\t\t\t\t\tg[100*m+B].push_back(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(100*L);\n\t\tint ans=INF;\n\t\trep(m,L+1)ans=min(ans,d[100*m+N-1]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, L;\n\nstruct State {\n    int v, sum, dist;\n    State(int v, int sum, int dist) : v(v), sum(sum), dist(dist) {}\n    bool operator<(const State& a) const {\n        return dist > a.dist;\n    }\n};\n\nstruct edge {\n    int to, money, enemy;\n    edge(int to, int money, int enemy):to(to),money(money),enemy(enemy){}\n};\n\nvector<edge> G[101];\nint d[101][101];\n\nvoid dijkstra(int s)\n{\n    for (int i = 0; i <= 100; ++i) for (int j = 0; j < N; ++j) d[i][j] = inf;\n\n    priority_queue<State> q;\n    q.push(State(s, 0, 0));\n\n    d[0][s] = 0;\n\n    while (q.size()) {\n        State st = q.top(); q.pop();\n\n        if (d[st.sum][st.v] < st.dist) continue;\n\n        for (int i = 0; i < G[st.v].size(); ++i) {\n            edge e = G[st.v][i];\n\n            if (st.sum + e.money <= L && d[st.sum + e.money][e.to] > st.dist) {\n                d[st.sum + e.money][e.to] = st.dist;\n                q.push(State(e.to, st.sum + e.money, d[st.sum + e.money][e.to]));\n            }\n\n            if (d[st.sum][e.to] > st.dist + e.enemy) {\n                d[st.sum][e.to] = st.dist + e.enemy;\n                q.push(State(e.to, st.sum, d[st.sum][e.to]));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    while (scanf(\"%d%d%d\", &N, &M, &L), N) {\n        for (int i = 0; i < N; ++i) G[i].clear();\n\n        for (int i = 0; i < M; ++i) {\n            int A, B, D, E;\n            scanf(\"%d%d%d%d\", &A, &B, &D, &E);\n            A--, B--;\n            G[A].push_back(edge(B, D, E));\n            G[B].push_back(edge(A, D, E));\n        }\n\n        dijkstra(0);\n\n        int mi = inf;\n\n        for (int i = 0; i <= 100; ++i) {\n            chmin(mi, d[i][N - 1]);\n        }\n\n        printf(\"%d\\n\", mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<tuple>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ?2e18:1e9+10;\ntypedef tuple<int,int,int> tp;\n\nclass DIJ{\npublic:\n  struct edge{\n    Def to,cost,hu;\n  };\n  vector<vector<edge> >G;\n  Def n,L;\n  Def d[100][110];\n  DIJ(Def size,Def l){\n    n=size;\n    L=l;\n    G=vector<vector<edge> >(n);\n  }\n  void add_edge(Def a,Def b,Def c,Def d){\n    edge e={b,c,d},ee={a,c,d};\n    G[a].pb(e);\n    G[b].pb(ee);\n  }\n  void dij(){\n    rep(i,100)rep(j,110)d[i][j]=inf;\n    d[0][0]=0;\n    priority_queue<tp> q;\n    q.push(tp(0,0,0));\n    while(!q.empty()){\n      Def pos,cost,t;\n      tie(cost,pos,t)=q.top();\n      q.pop();\n      cost*=-1;\n      if(cost>d[pos][t])continue;\n      rep(i,G[pos].size()){\n\tedge e=G[pos][i];\n\tDef to=e.to;\n\tDef ncost=cost;//ninz\n\tDef nt=t;//yosan\n\tif(ncost+e.hu<d[to][nt]){\n\t  d[to][nt]=ncost+e.hu;\n\t  q.push(tp(-ncost-e.hu,to,nt));\n\t}\n\t//\tcout<<to<<\" \"<<ncost<<\" \"<<nt<<\" \"<<e.cost<<endl;\n\tif(nt+e.cost<=L&&ncost<d[to][nt+e.cost]){\n\t  d[to][nt+e.cost]=ncost;\n\t  q.push(tp(-ncost,to,nt+e.cost));\n\t}\n\t\n      }\n    }\n    int out = inf;\n    rep(i,L+1)out=min((ll)out,(ll)d[n-1][i]);\n    cout<<out<<endl;\n  }\n  \n};\n\n\n\nint main(){\n\n  int n,m,l;\n  while(cin>>n>>m>>l,n){\n    DIJ dij(n,l);\n    rep(i,m){\n      int a,b,c,d;cin>>a>>b>>c>>d;\n      a--;b--;\n      dij.add_edge(a,b,c,d);\n    }\n    dij.dij();\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<array>\n\n#define fin cin\n\nusing std::cout;\nusing std::endl;\n\nclass Input{\npublic:\n\tint a;\n\tint b;\n\tint d;\n\tint e;\n\tInput(int _a, int _b, int _d, int _e){\n\t\ta = _a;\n\t\tb = _b;\n\t\td = _d;\n\t\te = _e;\n\t}\n\toperator < (Input& other)\n\t{\n\t\treturn this->a < other.a;\n\t}\n\toperator > (Input& other)\n\t{\n\t\treturn this->a > other.a;\n\t}\n\n};\n\nconst int initnum = 10000000;\n\nstd::vector<Input> in_v{};\nstd::array<std::array<int, 100>, 100> cost;\n\nint main()\n{\n\t//std::ifstream fin(\"in.txt\");\n\t//cost[0].fill(0);\n\t//for(int i = 1; i < 100; i++)cost[i].fill(10000000);\n\n\twhile(true)\n\t{\n\t\tcost[0].fill(0);\n\t\t//cost[1].fill(0);\n\t\tfor(int i = 1; i < 100; i++)cost[i].fill(initnum);\n\t\n\t\tint n, m, l;\n\t\tfin >> n >> m >> l;\n\t\tif((n | m | l) == 0)break;\n\t\t//cout << n << \" \" << m << \" \" << l << endl;\n\t\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b, d, e;\n\t\t\tfin >> a >> b >> d >> e;\n\t\t\tin_v.push_back(Input(a-1, b-1, d, e));\n\t\t\tin_v.push_back(Input(b-1, a-1, d, e));\n\t\t}\n\t\tsort(in_v.begin(), in_v.end());\n\n\t\tstd::queue<Input> in_q;\n\t\tfor(auto in : in_v)in_q.push(in);\n\n\t\tin_v.clear();\n\t\tin_v.shrink_to_fit();\n\n\t\twhile(!in_q.empty())\n\t\t{\n\t\t\tInput tmp = in_q.front();\n\t\t\tin_q.pop();\n\n\t\t\tfor(int _cost = 0; _cost <= l; _cost++)\n\t\t\t{\n\n\t\t\t\tif(cost[tmp.a][_cost] == initnum)\n\t\t\t\t{\n\t\t\t\t\tin_q.push(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcost[tmp.b][_cost] = std::min(\n\t\t\t\t\tcost[tmp.b][_cost],\n\t\t\t\t\tstd::min(\n\t\t\t\t\t\t(_cost + tmp.d <= l ? (cost[tmp.a][_cost + tmp.d]) : initnum / 10),\n\t\t\t\t\t\tcost[tmp.a][_cost] + tmp.e\n\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\t\t\tfor(int i = 0; i <= l + 2; i++){\n\t\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\n\t\t}\n\t\tint min_cost = 10000000;\n\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tif(cost[n - 1][i] < min_cost)min_cost = cost[n - 1][i];\n\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t}\n\t\tcout << min_cost << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nstruct edge {\n    int to, cost, num;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nstruct state {\n    int v, rest, num;\n    bool operator>(state const& other) const {\n        return num > other.num;\n    }\n};\n\nint main() {\n    int N, M, L;\n    while(cin >> N >> M >> L, N) {\n        graph g(N);\n        vector<vector<int>> res(N, vector<int>(L+1, INF));\n        for(int i=0; i<M; ++i) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--; b--;\n            g[a].push_back((edge){b, d, e});\n            g[b].push_back((edge){a, d, e});\n        }\n        priority_queue<state, vector<state>, greater<state>> que;\n        que.push(state{0, L, 0});\n        res[0][L] = 0;\n        while(!que.empty()) {\n            state s = que.top(); que.pop();\n            int v = s.v;\n            int rest = s.rest;\n            if(res[v][rest] < s.num) {\n                continue;\n            }\n            for(auto& e : g[v]) {\n                if(rest - e.cost >= 0 && res[e.to][rest - e.cost] > res[v][rest]) {\n                    res[e.to][rest - e.cost] = res[v][rest];\n                    que.push(state{e.to, rest-e.cost, res[e.to][rest-e.cost]});\n                }\n                if(res[e.to][rest] > res[v][rest] + e.num) {\n                    res[e.to][rest] = res[v][rest] + e.num;\n                    que.push(state{e.to, rest, res[e.to][rest]});\n                }\n            }\n        }\n        cout << *min_element(res[N-1].begin(), res[N-1].end()) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<int, pair<int, int> > edge;\n\nint n, m, l;\nint vtx[256][256];\n\t\nint solve(vector< vector<edge> > e){\n\t\n\tfor(int i=0; i<=n; ++i){\n\t\tfor(int j=0; j<=l; ++j){\n\t\t\tvtx[i][j]=INT_MAX;\n\t\t}\n\t}\n\t\n\tpriority_queue<edge, vector<edge>, greater<edge> > qu;\n\tqu.push(make_pair(0, make_pair(1,l)));//d, now, money\n\tvtx[1][l]=0;\n\t\n\twhile(!qu.empty()){\n\t\t\n\t\tedge t = qu.top();\n\t\tint now = t.second.first, money = t.second.second;\n\t\tqu.pop();\n\t\t\n\t\tfor(int i=0; i<e[now].size(); ++i){\n\t\t\t\n\t\t\tint nxt = e[now][i].first,\n\t\t\t\tdst = e[now][i].second.first,\n\t\t\t\tene = e[now][i].second.second;\n\t\t\t\t\n\t\t\tif( money-dst>=0 && vtx[nxt][money-dst] > vtx[now][money] ){\n\t\t\t\tvtx[nxt][money-dst] = vtx[now][money];\n\t\t\t\tqu.push(make_pair(vtx[nxt][money-dst], make_pair(nxt, money-dst)));\n\t\t\t}//employ guard\n\t\t\t\n\t\t\tif( vtx[nxt][money] > vtx[now][money] + ene ){\n\t\t\t\tvtx[nxt][money] = vtx[now][money] + ene;\n\t\t\t\tqu.push(make_pair(vtx[nxt][money], make_pair(nxt, money)));\n\t\t\t}//no guard\n\t\t}\n\t\t\n\t}\n\t\n\tint res = INT_MAX;\n\t\n\tfor(int i=0; i<=l; ++i){\n\t\tres = min(res, vtx[n][i]);\n\t}\n\t\n\treturn res;\n}\n\n\nint main(){\n\t\n\twhile(cin>>n>>m>>l, (n||m||l)){\n\t\n\t\tvector< vector<edge> > e(n+1);\n\t\t\n\t\tint a, b, c, d;\n\t\t\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\te[a].push_back(make_pair(b, make_pair(c, d)));//nxt, dst, ene\n\t\t\te[b].push_back(make_pair(a, make_pair(c, d)));\n\t\t}\n\t\t\n\t\tcout << solve(e) << endl;\n\t}\n\t\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second \n#define mp make_pair\n#define inf 1<<30\nusing namespace std;\n\nint main()\n{\n  int N,M,L,a,b,c,d;\n  int dis[101][101],th[101][101];\n  int dp[101][101];\n\n  while(1){\n    cin>>N>>M>>L;\n    if(N+M+L==0)break;\n    for(int i=0;i<101;i++){\n      for(int j=0;j<101;j++){\n\tdis[i][j]=th[i][j]=dp[i][j]=inf;\n      }\n    }\n    for(int i=0;i<M;i++){\n      cin>>a>>b>>c>>d;\n      a--;b--;\n      dis[a][b]=c;\n      dis[b][a]=c;\n      th[a][b]=d;\n      th[b][a]=d;\n    }\n    int ans=inf;\n    dp[0][L]=0;\n    priority_queue<pair<int,pair<int,int> > > pq;\n    pq.push(mp(0,mp(0,L)));\n    while(!pq.empty()){\n      pair<int,pair<int,int> > u=pq.top();\n      pq.pop();\n      u.f=(-1)*u.f;\n      if(dp[u.s.f][u.s.s]<u.f)continue;\n      if(u.s.f==N-1){\n\tans=min(ans,u.f);\n\tcontinue;\n      }\n      \n      for(int i=0;i<N;i++){\n\tif(dis[u.s.f][i]==inf)continue;\n\tint c=u.s.s-dis[u.s.f][i];\n\tif(0<=c){\n\t  if(u.f<dp[i][c]){\n\t    dp[i][c]=u.f;\n\t    pq.push(mp(u.f*(-1),mp(i,c)));\n\t  }\n\t}\n\tif(u.f+th[u.s.f][i]<dp[i][u.s.s]){\n\t  dp[i][u.s.s]=u.f+th[u.s.f][i];\n\t  pq.push(mp((u.f+th[u.s.f][i])*(-1),mp(i,u.s.s)));\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\n//aoj 2151\n\nint n, m, l;\nint d[110][110][110];\nint dist[110][110];\n\nint main(){\n\twhile(1){\n\t\tn = in.nextInt(); m = in.nextInt(); l = in.nextInt();\n\t\tif(n == 0 && m == 0 && l == 0) break;\n\t\trep(i, 110) rep(j, 110) rep(k, 110) d[i][j][k] = (i == j ? 0 : INF);\n\t\trep(i, 110) rep(j, 110) dist[i][j] = (i == j ? 0 : INF);\n\n\t\trep(i, m){\n\t\t\tint a = in.nextInt() - 1 , b = in.nextInt() - 1;\n\t\t\tdist[a][b] = dist[b][a] = in.nextInt();\n\t\t\td[a][b][l] = d[b][a][l] = in.nextInt();\n\t\t}\n\n\t\trep(k, n) rep(i, n) rep(j, n) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n\t\tfor(int money = l; money >= 0; money--){\n\t\t\trep(k, n){\n\t\t\t\trep(i, n){\n\t\t\t\t\trep(j, n){\n\t\t\t\t\t\td[i][j][money] = min({d[i][j][money + 1], d[i][j][money], d[i][k][l] + d[k][j][l]});\n\t\t\t\t\t\tif(dist[i][k] <= money) d[i][j][money-dist[i][k]] = min(d[i][j][money-dist[i][k]], d[k][j][l]);\n\t\t\t\t\t\tif(dist[k][j] <= money) d[i][j][money-dist[k][j]] = min(d[i][j][money-dist[k][j]], d[i][k][l]);\n\t\t\t\t\t\tif(dist[i][k] + dist[k][j] <= money) d[i][j][money-(dist[i][k]+dist[k][j])] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, l + 1) ans = min(ans, d[0][n-1][i]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v);\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream&, const tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream& os, const tuple<T...>& t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream& operator<<(ostream& os, const tuple<T...>& t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream&, tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream& is, tuple<T...>& t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream& operator>>(istream& is, tuple<T...>& t){ _it<0>(is, t); return is; }\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\n\n// グラフ用ヘッダ\n\nstruct Edge {\n    int src, dst;\n    int weight, money;\n    Edge(int src, int dst, int weight, int money) :\n        src(src), dst(dst), weight(weight), money(money) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef tuple<int,int,int> State;\nint dp[111][111];\n\n#define encode(a,b,c) (ll(a)<<32 | (b)<<16 | (c))\n#define decode(x,a,b,c) (a = x>>32, b = x>>16 & 0xFFFF, c = x & 0xFFFF)\n\nint main(){\n    int N,M,L;\n    while(cin>>N>>M>>L && N){\n        Graph g(N);\n        rep(i,M){\n            int a,b,d,e;\n            cin>>a>>b>>d>>e; a--; b--;\n            swap(d,e);\n            g[a].eb(a,b,d,e);\n            g[b].eb(b,a,d,e);\n        }\n        rep(i,111)rep(j,111) dp[i][j] = 1<<29;\n        dp[0][L] = 0;\n        priority_queue<ll> q;\n        q.emplace(encode(0,0,L));\n        while(q.size()){\n            int c,v,money;\n            decode(q.top(), c,v,money);\n            q.pop();\n            c = -c;\n            if(dp[v][money] < c) continue;\n            for(auto & e : g[v]){\n                if(dp[v][money] + e.weight < dp[e.dst][money]){\n                    dp[e.dst][money] = dp[v][money] + e.weight;\n                    q.emplace(encode(-dp[v][money]+e.weight, e.dst, money));\n                }\n                if(money >= e.money && dp[v][money] < dp[e.dst][money-e.money]){\n                    dp[e.dst][money-e.money] = dp[v][money];\n                    q.emplace(encode(-dp[v][money], e.dst, money-e.money));\n                }\n            }\n        }\n        int ans = dp[N-1][0];\n        rep(i,111) ans = min(ans, dp[N-1][i]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\npii cost[101][101];\nbool visit[101][101];\n\nstruct node {\n\tint cost, money, pos;\n\tnode(int c, int m, int p) {\n\t\tcost = c;\n\t\tmoney = m;\n\t\tpos = p;\n\t}\n};\nbool operator<( const node& l, const node& r ) {\n\tif( l.cost == r.cost ) {\n\t\treturn l.money < r.money;\n\t}\n\treturn l.cost > r.cost;\n}\n\nint main() {\n\tint n, m, l;\n\twhile( cin >> n >> m >> l, n||m||l ) {\n\t\trep(i,101) rep(j,101) cost[i][j].first = cost[i][j].second = -1;\n\t\trep(i, m) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tcost[a][b].first = cost[b][a].first = d;\n\t\t\tcost[a][b].second = cost[b][a].second = e;\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tmemset( visit, 0, sizeof(visit) );\n\t\tque.push( node(0, l, 1) );\n\t\twhile( !que.empty() ) {\n\t\t\tnode nd = que.top();\n\t\t\tque.pop();\n\t\t\tif( visit[nd.pos][nd.cost] ) continue;\n\t\t\tvisit[nd.pos][nd.cost] = true;\n\t\t\tif( nd.pos == n ) {\n\t\t\t\tcout << nd.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\tif( cost[nd.pos][i].second != -1 ) {\n\t\t\t\t\tif( !visit[i][nd.money] ) {\n\t\t\t\t\t\tque.push( node(nd.cost+cost[nd.pos][i].second, nd.money, i) );\n\t\t\t\t\t}\n\t\t\t\t\tif( nd.money >= cost[nd.pos][i].first && !visit[i][nd.money-cost[nd.pos][i].first] ) {\n\t\t\t\t\t\tque.push( node(nd.cost, nd.money-cost[nd.pos][i].first, i) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<functional>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define INF 1000000000\n\nstruct St {\n\tint node;\n\tint money;\n\tint attack;\n\tSt(int _node, int _money, int _attack) {\n\t\tnode = _node;\n\t\tmoney = _money;\n\t\tattack = _attack;\n\t}\n\n\tbool operator >(const St &e) const {\n\t\treturn attack > e.attack;\n\t}\n};\n\n\nint dp[101][101]; // i?????????????±???§??????????????????j????????????????\\???????????????°???????°????\nint main()\n{\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N || M || L) {\n\t\tpair<int, int> p[101][101];\n\t\tREP(i, 0, N) {\n\t\t\tREP(j, 0, N) {\n\t\t\t\tp[i][j].first = p[i][j].second = INF;\n\t\t\t}\n\t\t}\n\t\tREP(i, 0, M) {\n\t\t\tint A, B, D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tp[A - 1][B - 1].first = p[B - 1][A - 1].first = D;\n\t\t\tp[A - 1][B - 1].second = p[B - 1][A - 1].second = E;\n\t\t}\n\n\t\tREP(i, 0, N) {\n\t\t\tREP(j, 0, L + 1) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][L] = 0;\n\n\t\tpriority_queue<St, vector<St>, greater<St>> pq;\n\t\tSt st(0, L, 0);\n\t\tpq.push(st);\n\t\twhile (!pq.empty()) {\n\t\t\tSt now = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tint nowN = now.node;\n\t\t\tint nowM = now.money;\n\t\t\tint nowA = now.attack;\n\n\t\t\tif (dp[nowN][nowM] < nowA) continue;\n\t\t\tREP(i, 0, N) {\n\t\t\t\tif (p[nowN][i].first == INF) continue;\n\n\t\t\t\t/* ??????????????? */\n\t\t\t\tif (p[nowN][i].first <= nowM) {\n\t\t\t\t\tint nextM = nowM - p[nowN][i].first;\n\t\t\t\t\tint nextA = nowA;\n\n\t\t\t\t\tif (nextA < dp[i][nextM]) {\n\t\t\t\t\t\tdp[i][nextM] = nextA;\n\t\t\t\t\t\tSt nextS(i, nextM, nextA);\n\t\t\t\t\t\tpq.push(nextS);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\t/* ????????????????????? */\n\t\t\t\tint nextM = nowM;\n\t\t\t\tint nextA = nowA + p[nowN][i].second;\n\n\t\t\t\tif (nextA < dp[i][nextM]) {\n\t\t\t\t\tdp[i][nextM] = nextA;\n\t\t\t\t\tSt nextS(i, nextM, nextA);\n\t\t\t\t\tpq.push(nextS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tREP(i, 0, L + 1) {\n\t\t\tans = min(ans, dp[N - 1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;int x[150][150][2],n,m,l,a,b,c,d,i,j,k,o,minx,INF=1<<25,dp[150][150];int DP(int p,int v){memset(dp,127,sizeof(dp));dp[0][v]=0;for(i=0;i<p;i++){for(j=0;j<n;j++){for(k=0;k<n;k++){if(x[j][k][0]<INF){for(o=0;o<=v;o++){if(dp[j][o]<INF){dp[k][o]=min(dp[k][o],dp[j][o]+x[j][k][1]);if(o>=x[j][k][0]){dp[k][o-x[j][k][0]]=min(dp[k][o-x[j][k][0]],dp[j][o]);}}}}}}}minx=INF;for(i=0;i<=v;i++){minx=min(minx,dp[p-1][i]);}return minx;}main(){while(1){memset(x,127,sizeof(x));cin>>n>>m>>l;if(!n){break;}for(i=0;i<m;i++){cin>>a>>b>>c>>d;a--;b--;x[a][b][0]=c;x[a][b][1]=d;x[b][a][0]=c;x[b][a][1]=d;}cout<<DP(n,l)<<endl;}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110][110]={};\nbool used[110]={};\nint n,m,l;\nint ans=INF;ori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }else\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n      for(int j=0;j<l+5;j++)\n      memo[j][i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nconst int MAX_V = 101;\nconst int INF = 1<<28;\nconst int MONEY = 101;\nint n,m,l;\n\nstruct edge{\n\tint to, cost, dist;\n\tedge(int t_to,int t_cost,int t_dist){\n\t\tto=t_to;cost=t_cost;dist=t_dist;\n\t}\n};\n\nstruct state{\n\tint cost,v,money;//?????¨?????????????????????????????????\n\tstate(int t_cost,int t_v,int t_money){\n\t\tcost=t_cost;v=t_v;money=t_money;\t\t\n\t}\n\tbool operator>(const state& s)const{\n\t\treturn cost > s.cost;\n\t}\n};\n\nvector< vector<edge> > G(MAX_V);\nint d[MAX_V][MONEY];\n\nvoid dijkstra(int s){\n\tpriority_queue<state,vector<state>,greater<state> > que;\n\tfill_n((int *)d, sizeof(d)/sizeof(int),INF);\n\td[s][l] = 0;\n\tque.push(state(0,s,l));\n\n\twhile(!que.empty()){\n\t\tstate p = que.top(); que.pop();\n\t\tint v = p.v;\n\t\tint m = p.money;\n\t\tif(d[v][m]<p.cost) continue;\n\t\trep(i,G[v].size()){\n\t\t\tedge e = G[v][i];\n//\t\t\tcout << \"E:\" << e.to << endl;\n\t\t\tif(d[e.to][m] > d[v][m] + e.cost){//??????????????´???\n\t\t\t\td[e.to][m] = d[v][m] + e.cost;\n\t\t\t\tque.push(state(d[e.to][m],e.to,m));\n\t\t\t}\n\t\t\tif(e.dist <= m && d[e.to][m-e.dist] > d[v][m]){//????????´???\n\t\t\t\td[e.to][m-e.dist] = d[v][m];\t\n\t\t\t\tque.push(state(d[e.to][m-e.dist],e.to,m-e.dist));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\twhile(1){\n\t\tcin >> n >> m >> l;\n\n\t\tif(n==0&&m==0&&l==0) break;\n\t\tG.clear();\n\t\tG.resize(n);\n\n\t\trep(i,m){\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--;b--;\n\t\t\tedge tmp1(b,e,d);\n\t\t\tedge tmp2(a,e,d);\n\t\t\tG[a].push_back(tmp1);\n\t\t\tG[b].push_back(tmp2);\t\n\t\t}\n\n\t\tdijkstra(0);\n\t\tint ans=INF;\n\t\trep(i,MONEY+1){\n\t\t\tans = min(ans,d[n-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int from;\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    return a.enemy>b.enemy;\n}\n\nstruct node maps[(int)1e8];\n\nint main()\n{\n    int n,m,l;\n\n    while ((cin>>n>>m>>l) && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            a--;\n            b--;\n            maps[a].data.push_back((struct data){b,d,e});\n            maps[b].data.push_back((struct data){a,d,e});\n        }\n        queue.push((struct state){0,0,l,0});\n        while (!queue.empty()){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                cout<<s.enemy<<endl;\n                while (!queue.empty()){\n                    queue.pop();\n                }\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.to!=s.from) {\n                        if (d.dis <= s.money) {\n                            queue.push((struct state) {s.number, d.to, s.money - d.dis, s.enemy});\n                        }\n                        queue.push((struct state) {s.number, d.to, s.money, s.enemy + d.ene});\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <climits>\n\n#define UNDEF 900000000\n\nusing namespace std;\n\nint main()\n{\n\tlong int n, m, l, i;\n\tlong int len[101][101];\n\tlong int hos[101][101];\n\tlong int djk_money[2][101];\n\tlong int djk_enemy[2][101];\n\n\t//0...àgíÈ¢[g\n\t//1...àg¤[g\n\n\tqueue<int> que;\n\n\twhile(cin >> n >> m >> l, (n||m||l))\n\t{\n\t\tmemset(len, -1, sizeof(len));\n\t\tmemset(hos, -1, sizeof(hos));\n\t\tmemset(djk_money, -1, sizeof(djk_money));\n\t\tmemset(djk_enemy, -1, sizeof(djk_enemy));\n\t\tque.push(1);\n\t\tdjk_enemy[0][1] = 0;\n\t\tdjk_enemy[1][1] = 0;\n\t\tdjk_money[0][1] = l;\n\t\tdjk_money[1][1] = l;\n\n\t\tfor( i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a;\n\t\t\tcin >> b;\n\n\t\t\tcin >> len[a][b];\n\t\t\tcin >> hos[a][b];\n\n\t\t\tlen[b][a] = len[a][b];\n\t\t\thos[b][a] = hos[a][b];\n\t\t}\n\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tint st = que.front();\n\t\t\tque.pop();\n\n\t\t\tfor( i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif( len[st][i] > 0 && hos[st][i] > 0)\n\t\t\t\t{\n\t\t\t\t\tbool flg = 0;\n\n\t\t\t\t\tif( djk_enemy[0][i] < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdjk_enemy[0][i] = UNDEF;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( djk_enemy[1][i] < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdjk_enemy[1][i] = UNDEF;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor( int k = 0; k <= 1; k++)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tif( djk_enemy[0][i] > djk_enemy[k][st] + hos[st][i] )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdjk_enemy[0][i] = djk_enemy[k][st] + hos[st][i];\n\t\t\t\t\t\t\tdjk_money[0][i] = djk_money[k][st];\n\t\t\t\t\t\t\tflg = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( djk_enemy[1][i] > djk_enemy[k][st] && djk_money[k][st] - len[st][i] >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdjk_enemy[1][i] = djk_enemy[k][st];\n\t\t\t\t\t\t\tdjk_money[1][i] = djk_money[k][st] - len[st][i];\n\t\t\t\t\t\t\tflg = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg)\n\t\t\t\t\t\tque.push(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout <<  min(djk_enemy[0][n], djk_enemy[1][n]) <<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int MAX_N = 101;\nconst int MAX_L = 101;\n\nclass C{\n    public:\n        int p, dis, cost;\n        C(int _p, int _dis, int _cost);\n};\n\nC::C(int _p, int _dis, int _cost){\n    p = _p;\n    dis = _dis;\n    cost = _cost;\n}\n\nint main(){\n    int n, m, l;\n    while(cin >>n >>m >>l && (n || m || l)){\n        vector< vector<C> > v(n, vector<C>());\n        REP(i, m){\n            int a, b, c, d;\n            cin >>a >>b >>c >>d;\n            a--;\n            b--;\n            v[a].push_back( C(b, c, d) );\n            v[b].push_back( C(a, c, d) );\n        }\n        int closed[MAX_N][MAX_L];\n        REP(i, MAX_N){\n            REP(j, MAX_L){\n                closed[i][j] = INF;\n            }\n        }\n        queue<C> open;\n        open.push( C(0, l, 0) );\n\n        while(!open.empty()){\n            C now = open.front();\n            open.pop();\n\n            if(now.cost >= closed[now.p][now.dis]) continue;\n\n            closed[now.p][now.dis] = now.cost;\n            REP(i, v[now.p].size()){\n                C next = v[now.p][i];\n                if(now.dis >= next.dis){\n                    open.push( C(next.p, now.dis - next.dis, now.cost) );\n                }\n                open.push( C(next.p, now.dis, now.cost + next.cost) );\n            }\n        }\n\n        int ans = INF;\n        REP(i, MAX_L){\n            ans = min(ans, closed[n - 1][i]);\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXN = 110, MAXM = 5500, MAXL = 110, INF = 200000;\n\nint n,m,l,a,b,d,e;\nint enemy[MAXN][MAXN];\nint dist[MAXN][MAXN];\nbool used[MAXN][MAXL];\n\ntypedef pair<int,int> pp;\ntypedef pair<int,pp> ppp;\n\nint main()\n{\n    while(cin >> n >> m >> l && n )\n    {\n        memset(enemy, INF, sizeof(enemy));\n        memset(dist, INF, sizeof(dist));\n        memset(used, false, sizeof(used));\n        priority_queue<ppp, vector<ppp>, greater<ppp> > que;\n        que.push(ppp(0,pp(0,1)));\n\n        REP(m)\n        {\n            cin >> a >> b >> d >> e;\n            enemy[b][a] = e;\n            enemy[a][b] = e;\n            dist[b][a] = d;\n            dist[a][b] = dist[b][a];\n        }\n        int ans = 0;\n        while(!que.empty())\n        {\n            ppp q = que.top(); que.pop();\n            int nowe = q.first, cost = q.second.first, node = q.second.second;\n            if(node == n){ans = nowe; break;}\n            if(used[nowe][cost])continue;\n            used[nowe][cost] = 1;\n            for(int i=1;i<=n;i++)if(dist[node][i] != INF)\n            {\n                que.push(ppp(nowe + enemy[node][i], pp(nowe, i)));\n                if(cost + dist[node][i] <= l)\n                    que.push(ppp(nowe, pp(cost + dist[node][i], i)));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <limits.h>\n\n#define UNDEF 9999999\n\nusing namespace std;\n\nint main()\n{\n\tint n, m, l, i;\n\tint len[101][101];\n\tint hos[101][101];\n\tint djk_money[2][101];\n\tint djk_enemy[2][101];\n\n\t//0...àgíÈ¢[g\n\t//1...àg¤[g\n\n\tqueue<int> que;\n\n\twhile(cin >> n >> m >> l, (n||m||l))\n\t{\n\t\tmemset(len, -1, sizeof(len));\n\t\tmemset(hos, -1, sizeof(hos));\n\t\tmemset(djk_money, -1, sizeof(djk_money));\n\t\tmemset(djk_enemy, -1, sizeof(djk_enemy));\n\t\tque.push(1);\n\t\tdjk_enemy[0][1] = 0;\n\t\tdjk_enemy[1][1] = 0;\n\t\tdjk_money[0][1] = l;\n\t\tdjk_money[1][1] = l;\n\n\t\tfor( i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a;\n\t\t\tcin >> b;\n\n\t\t\tcin >> len[a][b];\n\t\t\tcin >> hos[a][b];\n\n\t\t\tlen[b][a] = len[a][b];\n\t\t\thos[b][a] = hos[a][b];\n\t\t}\n\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tint st = que.front();\n\t\t\tque.pop();\n\n\t\t\tfor( i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif( len[st][i] > 0 && hos[st][i] > 0)\n\t\t\t\t{\n\t\t\t\t\tbool flg = 0;\n\n\t\t\t\t\tif( djk_enemy[0][i] < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdjk_enemy[0][i] = UNDEF;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( djk_enemy[1][i] < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdjk_enemy[1][i] = UNDEF;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor( int k = 0; k <= 1; k++)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tif( djk_enemy[0][i] > djk_enemy[k][st] + hos[st][i] )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdjk_enemy[0][i] = djk_enemy[k][st] + hos[st][i];\n\t\t\t\t\t\t\tdjk_money[0][i] = djk_money[k][st];\n\t\t\t\t\t\t\tflg = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( djk_enemy[1][i] > djk_enemy[k][st] && djk_money[k][st] - len[st][i] >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdjk_enemy[1][i] = djk_enemy[k][st];\n\t\t\t\t\t\t\tdjk_money[1][i] = djk_money[k][st] - len[st][i];\n\t\t\t\t\t\t\tflg = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg)\n\t\t\t\t\t\tque.push(i);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout <<  min(djk_enemy[0][n], djk_enemy[1][n]) <<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include<set>\n#include <vector>\n\n#define F first\n#define S second\n#define MAX_V 110\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P3;\n\nstruct edge{int to,d,e;};\n\nvector<edge>g[MAX_V];\nint d[MAX_V][101],n,m,l;\n\nvoid dijkstra(int s){\n  priority_queue<P3,vector<P3>,greater<P3> >que;\n\n  fill(d[0],d[MAX_V],INF);\n  d[s][l]=0;\n  que.push(P3(0,P(l,s)));\n\n  while(!que.empty()){\n    P3 p=que.top();que.pop();\n    int v=p.S.S;\n    if(d[v][p.S.F]<p.F)continue;\n    if(v==n){\n      cout << p.F << endl;\n      return;\n    }\n\n    for(int i=0;i<g[v].size();i++){\n      edge e=g[v][i];\n      if(d[e.to][p.S.F]>d[v][p.S.F]+e.e){\n        d[e.to][p.S.F]=d[v][p.S.F]+e.e;\n        que.push(P3(d[e.to][p.S.F],P(p.S.F,e.to)));\n      }\n\n      if(p.S.F-e.d>=0 && d[e.to][p.S.F-e.d]>d[v][p.S.F]){\n        d[e.to][p.S.F-e.d]=d[v][p.S.F];\n        que.push(P3(d[e.to][p.S.F-e.d],P(p.S.F-e.d,e.to)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  while(cin >> n >> m >> l,n|m|l){\n    for(int i=0;i<MAX_V;i++)g[i].clear();\n    int a,b,d1,e;\n    for(int i=0;i<m;i++){\n      cin >> a >> b >> d1 >> e;\n      edge e1,e2;\n      e1.to=b,e1.d=d1,e1.e=e;\n      e2.to=a,e2.d=d1,e2.e=e;\n      g[a].push_back(e1);\n      g[b].push_back(e2);\n    }\n\n    dijkstra(1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<int> memo(101, INT_MAX);\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (memo[current.loc] == current.damage) {\n                continue;\n            }\n            memo[current.loc] = current.damage;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (e.dist <= current.money) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nstruct edge{int to,cost,teki;};\ntypedef pair<int,int> P;\nint n,m,l,inf=1e8;\nint d[10100];\nvector<edge> G[100];\nvoid dijkstra(int s){\n\trep(i,n*101) d[i]=inf;\n\td[s]=0;\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.sc,vn=v/101,vl=v%101;\n\t\tif(d[v]<p.fs) continue;\n\t\trep(i,G[vn].size()){\n\t\t\tedge e=G[vn][i];\n\t\t\tint nn=e.to;\n\t\t\tif(d[nn*101+vl]>d[v]+e.teki){\n\t\t\t\td[nn*101+vl]=d[v]+e.teki;\n\t\t\t\tque.push(P(d[nn*101+vl],nn*101+vl));\n\t\t\t}\n\t\t\tif(vl>=e.cost){\n\t\t\t\tint nl=vl-e.cost,to=nn*101+nl;\n\t\t\t\tif(d[to]>d[v]){\n\t\t\t\t\td[to]=d[v];\n\t\t\t\t\tque.push(P(d[to],to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>n>>m>>l;\n\t\tif(n==0) break;\n\t\trep(i,n) G[i].clear();\n\t\trep(i,m){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--,b--;\n\t\t\tG[a].pb({b,d,e});\n\t\t\tG[b].pb({a,d,e});\n\t\t}\n\t\tdijkstra(l);\n\t\tint ans=inf;\n\t\trep(i,l+1) ans=min(ans,d[(n-1)*101+i]);\n\t\tcout << ans <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint dijkstra(int s, int g, int l, vector<vector<T>> &G){\n    vector<vector<int>> num(110, vector<int>(110, 1e9));\n    queue<T> que;\n    num[s][l] = 0;\n    que.push(T(0, s, l));\n\n    while(!que.empty()){\n        int cnum, cv, crest;\n        tie(cnum, cv, crest) = que.front();\n        que.pop();\n\n        for(auto x : G[cv]){\n            int nv, ndist, nnum;\n            tie(nv, ndist, nnum) = x;\n            \n            if(num[cv][crest] < num[nv][crest - ndist] && ndist <= crest){\n                num[nv][crest - ndist] = num[cv][crest];\n                que.push(T(num[nv][crest - ndist], nv, crest - ndist));\n            }\n            \n            if(num[cv][crest] + nnum < num[nv][crest]){\n                num[nv][crest] = num[cv][crest] + nnum;\n                que.push(T(num[nv][crest], nv, crest));\n            }\n        }\n    }\n\n    int ans = 1e9;\n    for(int i=0; i<=100; i++){\n        ans = min(ans, num[g][i]);\n    }\n\n    return ans;\n}\n\nint main(){\n    while(1){\n        int n, m, l; cin>>n>>m>>l;\n        if(n == 0) return 0;\n        vector<vector<T>> G(n);\n        for(int i=0; i<m; i++){\n            int a, b, d, e; cin>>a>>b>>d>>e;\n            a--, b--;\n            G[a].eb(T(b, d, e));\n            G[b].eb(T(a, d, e));\n        }\n\n        cout << dijkstra(0, n-1, l, G) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);cout<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_const<decltype(l)>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline void assert_equal(T1 expected, T2 actual) { if (!(expected == actual)) { cerr << \"assertion fault: expected=\" << expected << \" actual=\" << actual << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_less(T1 actual, T2 threshold) { if (!(actual < threshold)) { cerr << \"assertion fault: \" << actual << \" < (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_eqless(T1 actual, T2 threshold) { if (!(actual <= threshold)) { cerr << \"assertion fault: \" << actual << \" <= (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream &o, const Vec& p) { o << '['; for (auto& e : p) o << e << ','; o << ']'; return o; }\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nclass GraphE {\npublic:\n    typedef int W_T;\n    struct Edge {\n        int u, v;\n        W_T value;\n        Edge(int from = 0, int to = 0, W_T value = 0) :u(from), v(to), value(value) {}\n        inline int to(int _v) const { return _v == v ? u : v; }\n    };\n    size_t n;\n    vector<vector<int>> vertex_to;\n    vector<Edge> edges;\n\n    GraphE(int n = 1) :n(n), vertex_to(n) { }\n\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n    void connect(int from, int to, W_T val = 0) {\n        vertex_to[(size_t)from].push_back((int)edges.size());\n        vertex_to[(size_t)to].push_back((int)edges.size());\n        edges.emplace_back(from, to, val);\n    }\n};\n\n\n//ll dp[101][101];\n\nvoid solve(int N, int M, int L) {\n\n    GraphE graph(N);\n    vector<pair<int, ll>> edgeval; // dist,nOfEnemy\n    edgeval.reserve(M);\n\n    repeat(i, M) {\n        int a, b, d, e;\n        scanner >> a >> b >> d >> e;\n        --a; --b;\n        graph.connect(a, b);\n        edgeval.emplace_back(d, ll(e));\n    }\n\n    //fill(dp[0], dp[101], ll(1e18));\n    vector<vector<ll>> dp(101);\n    repeat(i, N) dp[i].resize(L + 1, ll(1e18));\n\n    priority_queue<tuple<ll,ll,int>> pq;\n    dp[0][L] = 0;\n    pq.emplace(0,L,0);\n\n    ll best = 1e18;\n\n    while (!pq.empty()) {\n        ll enemy,money;\n        int idx;\n        tie(enemy,money,idx) = pq.top(); pq.pop();\n        enemy = -enemy;\n\n        if (idx == N - 1) {\n            minset(best, enemy);\n            continue;\n        }\n\n        if (enemy > dp[idx][money]) continue;\n        \n        for (int ei : graph.vertex_to[idx]) {\n            int d; ll e; int to;\n            tie(d, e) = edgeval[ei];\n            to = graph.edges[ei].to(idx);\n            if (money >= d && dp[to][money-d] > enemy + e) {\n                dp[to][money-d] = enemy;\n                pq.emplace(-(enemy), money - d, to);\n            }\n            if (dp[to][money] > enemy + e) {\n                dp[to][money] = enemy + e;\n                pq.emplace(-(enemy + e), money, to);\n            }\n        }\n    }\n    assert(best < ll(1e18));\n    printer << best << '\\n';\n}\n\n\nint main() {\n\n    int n, m, l;\n    while (scanner >> n >> m >> l, n != 0 || m != 0 || l != 0) {\n        solve(n, m, l);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXN = 110, MAXM = 5500, MAXL = 100, INF = 200000;\n\nint n,m,l,a,b,d,e;\nint enemy[MAXN][MAXN];\nint dist[MAXN][MAXN];\n\ntypedef pair<int,int> pp;\ntypedef pair<int,pp> ppp;\n\nint main()\n{\n    while(cin >> n >> m >> l && n && m && l)\n    {\n        memset(enemy, INF, sizeof(enemy));\n        memset(dist, INF, sizeof(dist));\n        priority_queue<ppp, vector<ppp>, greater<ppp> > que;\n        que.push(ppp(0,pp(0,1)));\n\n        REP(m)\n        {\n            cin >> a >> b >> d >> e;\n            enemy[a][b] = enemy[b][a] = e;\n            dist[a][b] = dist[b][a] = d;\n        }\n        int ans = 0;\n        while(!que.empty())\n        {\n            ppp q = que.top(); que.pop();\n            if(q.second.second == n){ans = q.first; break;}\n    \n            for(int i=1;i<=n;i++)if(dist[q.second.second][i] != INF)\n            {\n                //cout << \"push\"<< i << endl;\n                que.push(ppp(q.first + enemy[q.second.second][i], pp(q.first, i)));\n                if(q.second.first + dist[q.second.second][i] <= l)\n                    que.push(ppp(q.first, pp(q.second.first + dist[q.second.second][i], i)));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nint main() {\n    int N, M, L;\n    int a,b;\n    int now;\n    cin >> N >> M >> L;\n    for(;N!=0;){\n        vector<vector<bool>> graph(N,vector<bool>(N,false));\n        vector<vector<int>> distance(N,vector<int>(N)),evect(N,vector<int>(N));\n        //vector<vector<int>> dp(N,vector<int>(L+1,1000000000));\n        vector<vector<int>> dp_old(N,vector<int>(L+1,1000000000));\n        queue<int> vertex;\n        for(int i=0; i< M; i++){\n            cin >> a >> b;\n            a--;b--;\n            graph[a][b] = true; graph[b][a] = true;\n            cin >> distance[a][b] >> evect[a][b];\n            distance[b][a] = distance[a][b];\n            evect[b][a] = evect[a][b];\n        }\n        for(int i=0;i<=L;i++){\n            dp_old[0][i] = 0;\n            //dp[0][i] = 0;\n        }\n        for(int itr=0;itr<N;itr++){\n            vector<bool> reached(N,false);\n            reached[0] = true;\n            if(itr==0){\n                for(int i=0; i<N; i++){\n                    if(graph[0][i]){\n                        vertex.push(i);\n                        //graph[0][i] = false;\n                        //graph[i][0] = false;\n                        dp_old[i][L] = evect[0][i];\n                        //dp[i][L] = evect[0][i];\n                        if(L>=distance[0][i]){\n                            dp_old[i][L-distance[0][i]] = 0;\n                            //dp[i][L-distance[0][i]] = 0;\n                        }\n                    }\n                }\n            }else{\n                for(int i=0 ; i< N ; i++){\n                    if(graph[0][i]){\n                        vertex.push(i);\n                    }\n                }\n            }\n            for(;!vertex.empty();){\n                now = vertex.front();\n                reached[now] = true;\n                vertex.pop();\n                for(int i=1; i<N; i++){\n                    if(graph[now][i]){\n                        if(!reached[i])vertex.push(i);\n                        for(int j=0;j<=L; j++){\n                            if(j+distance[now][i]<=L){\n                                dp_old[now][j] = min(dp_old[now][j],min(dp_old[i][j]+evect[now][i],dp_old[i][j+distance[now][i]]));\n                                //dp_old[i][j] = min(dp_old[i][j],min(dp_old[now][j]+evect[now][i],dp_old[now][j+distance[now][i]]));\n                                //dp_old[now][j] = dp[now][j];\n                                //dp_old[i][j] = dp[i][j];\n                            }else{\n                                dp_old[now][j] = min(dp_old[i][j]+evect[now][i],dp_old[now][j]);\n                                //dp_old[i][j] = min(dp_old[now][j]+evect[now][i],dp_old[i][j]);\n                                //dp_old[now][j] = dp[now][j];\n                                //dp_old[i][j] = dp[i][j];\n                            }\n                        }\n                    }\n                }\n                //swap(dp,dp_old);\n            }\n        }\n        //swap(dp,dp_old);\n        int ans=dp_old[N-1][L];\n        for(int i=0; i<L ; i++){\n            ans=min(ans,dp_old[N-1][i]);\n        }\n        cout << ans << endl;\n\n        cin >> N >> M >>L;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110][110]={};\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(now==n){\n    ans=min(ans,sum);\n    return;\n  }\n  if(memo[nokori][now]<=sum)return;\n  for(int i=nokori;i<=l;i++)\n    memo[i][now]=sum;\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      used[E[now][i].to]=true;\n      if(nokori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n      for(int j=0;j<l+5;j++)\n      memo[j][i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\ntypedef struct E{\n  int to,cost,cost2;\n}edge;\nvector<vector<edge> >E(110);\nint memo[110][110];\nbool used[110]={};\nint n,m,l;\nint ans=INF;\nvoid dfs(int now,int nokori,int sum){\n  if(now==n){\n    ans=min(ans,sum);\n    return;\n  }\n  if(memo[now]<=sum)return;\n    memo[now]=sum;\n  for(int i=0;i<E[now].size();i++){\n    if(used[E[now][i].to]==false){\n      used[E[now][i].to]=true;\n      if(nokori-E[now][i].cost>=0){\n\tdfs(E[now][i].to,nokori-E[now][i].cost,sum);\n      }\n      dfs(E[now][i].to,nokori,sum+E[now][i].cost2);\n      used[E[now][i].to]=false;\n    }\n  }\n}\nint main(){\n  while(cin>>n>>m>>l,n){\n    n--;\n    ans=INF;\n    for(int i=0;i<n+5;i++){\n     \n      memo[i]=INF;\n      E[i].clear();\n      used[i]=false;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,d,e;cin>>a>>b>>d>>e;\n      a--;b--;\n      edge ee;ee.to=b;ee.cost=d;ee.cost2=e;\n      E[a].pb(ee);\n      ee.to=a;\n      E[b].pb(ee);\n    }\n    dfs(0,l,0);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include<set>\n#include <vector>\n\n#define F first\n#define S second\n#define MAX_V 110\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P3;\n\nstruct edge{int to,d,e;};\n\nvector<edge>g[MAX_V];\nint d[MAX_V][101],n,m,l;\n\nvoid dijkstra(int s){\n  priority_queue<P3>que;\n\n  fill(d[0],d[MAX_V],INF);\n  d[s][l]=0;\n  que.push(P3(0,P(l,s)));\n\n  while(!que.empty()){\n    P3 p=que.top();que.pop();\n    int v=p.S.S;\n    if(d[v][p.S.F]<p.F)continue;\n    if(d[v][p.S.F]==p.F && d[v][p.S.F]==0 && v!=1)continue;\n\n    for(int i=0;i<g[v].size();i++){\n      edge e=g[v][i];\n      if(d[e.to][p.S.F]>d[v][p.S.F]+e.e){\n        d[e.to][p.S.F]=d[v][p.S.F]+e.e;\n        que.push(P3(d[e.to][p.S.F],P(p.S.F,e.to)));\n      }\n\n      if(p.S.F-e.d>=0 && d[e.to][p.S.F-e.d]>d[v][p.S.F]){\n        d[e.to][p.S.F-e.d]=d[v][p.S.F];\n        que.push(P3(d[e.to][p.S.F-e.d],P(p.S.F-e.d,e.to)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  while(cin >> n >> m >> l,n|m|l){\n    for(int i=0;i<MAX_V;i++)g[i].clear();\n    int a,b,d1,e;\n    for(int i=0;i<m;i++){\n      cin >> a >> b >> d1 >> e;\n      edge e1,e2;\n      e1.to=b,e1.d=d1,e1.e=e;\n      e2.to=a,e2.d=d1,e2.e=e;\n      g[a].push_back(e1);\n      g[b].push_back(e2);\n    }\n\n    dijkstra(1);\n    int ans=INF;\n    for(int j=0;j<101;j++){\n      ans=min(ans,d[n][j]);\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> Pi;\ntypedef pair<int, Pi> Pii;\n\nstruct edge{\n  int to, dist, risk;\n  edge(){}\n  edge(int to, int dist, int risk):to(to), dist(dist), risk(risk){}\n};\n\nconst int inf = 1 << 30;\n\nvector< vector<edge> > G(110);\nint minDied[110][110];\n\nint N, M, L;\n\nint dijkstra()\n{\n  fill(minDied[0], minDied[110], inf);\n  priority_queue<Pii, vector<Pii>, greater<Pii> > que;\n  que.push(Pii(0, Pi(0, L)));\n  minDied[0][L] = 0;\n  while(!que.empty()){\n    Pii p = que.top(); que.pop();\n    int die = p.first, now = p.second.first, bdg = p.second.second;\n    if(now == N-1) return die;\n    for(int i = 0; i < G[now].size(); i++){\n      edge e = G[now][i];\n      if(bdg >= e.dist && minDied[e.to][bdg - e.dist] > die){\n\tque.push(Pii(die, Pi(e.to, bdg - e.dist)));\n\tminDied[e.to][bdg - e.dist] = die;\n      }\n      if(minDied[e.to][bdg] > die + e.risk){\n\tque.push(Pii(die + e.risk, Pi(e.to, bdg)));\n\tminDied[e.to][bdg] = die + e.risk;\n      }\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin >> N >> M >> L, N || M || L){\n    G.resize(N);\n    for(int i = 0; i < M; i++){\n      int A, B, D, E;\n      cin >> A >> B >> D >> E;\n      --A, --B;\n      G[A].push_back(edge(B, D, E));\n      G[B].push_back(edge(A, D, E));\n    }\n    cout << dijkstra() << endl;\n    G.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\n//int checker[4];\n//int ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\t//int check[4];\n\tState() {}\n\t//\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\t/*\n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t\t*/\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n/*\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n*/\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min = b;\n\t\twhile ( itr != points[i].end() ) {\n\t\t\tif ( (*itr).second > min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t} else if ( (*itr).second <= min ) {\n\t\t\t\t(*itr).second = min;\n\t\t\t}\n\t\t\tmin++\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t/*\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\t*/\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\t//ncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//copy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t/*\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n//\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n\n#define MAX_N 100\n#define MAX_L 100\n\nusing namespace std;\n\nstruct Edge {\n  int src, dest, dist, damage;\n  Edge(int src, int dest, int dist, int damage): src(src), dest(dest), dist(dist), damage(damage) {;}\n};\n\nstruct State {\n  int pos;\n  int rest;\n  int damage;\n  State(int pos, int rest, int damage): pos(pos), rest(rest), damage(damage) {;}\n  bool operator<(const State &rhs) const {\n    if (damage == rhs.damage) {\n      return rest > rhs.rest;\n    } else {\n      return damage > rhs.damage;\n    }\n  }\n};\n\nint N, M, L;\nvector<vector<Edge> > es;\n\nvoid Solve()\n{\n  bool visit[N + 1][L + 1];\n  memset(visit, false, sizeof(visit));\n\n  priority_queue<State> que;\n\n  que.push(State(1, L, 0));\n  \n  int ans = 1000001;\n  while (!que.empty()) {\n    State s = que.top(); que.pop();\n    int from = s.pos, l = s.rest;\n\n    if (visit[from][l])\n      continue;\n\n    visit[from][l] = true;\n    if (from == N)  {\n      ans = s.damage;\n      break;\n    }\n\n    for (int i = 0; i < es[from].size(); i++) {\n      int to = es[from][i].dest;\n\n      que.push(State(to, s.rest, s.damage + es[from][i].damage));\n\n      if (es[from][i].dist <= s.rest) {\n        que.push(State(to, s.rest - es[from][i].dist, s.damage));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main()\n{\n  int a, b, d, e;\n  while (cin >> N >> M >> L && !(N == 0 && M == 0 && L == 0 )) {\n    es.resize(0);\n    es.resize(N + 1);\n    for (int i = 0; i < M; i++) {\n      cin >> a >> b >> d >> e;\n      es[a].push_back(Edge(a, b, d, e));\n      es[b].push_back(Edge(b, a, d, e));\n    }\n\n    Solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<array>\n\n#define fin cin\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nclass Input {\npublic:\n\tint a;\n\tint b;\n\tint d;\n\tint e;\n\tInput(int _a, int _b, int _d, int _e) {\n\t\ta = _a;\n\t\tb = _b;\n\t\td = _d;\n\t\te = _e;\n\t}\n\tbool operator < (Input& other) const\n\t{\n\t\tif (this->a == other.a)return (this->b < other.b);\n\t\treturn (*this).a < other.a;\n\t}\n\tbool operator > (Input& other) const\n\t{\n\t\tif (this->a == other.a)return (this->b > other.b);\n\t\treturn (*this).a > other.a;\n\t}\n};\n\nconst int initnum = 10000000;\n\nstd::vector<Input> in_v{};\nstd::array<std::array<int, 101>, 101> cost;\n\nint main()\n{\n\t//std::ifstream fin(\"in.txt\");\n\t//cost[0].fill(0);\n\t//for(int i = 1; i < 100; i++)cost[i].fill(10000000);\n\n\twhile (true)\n\t{\n\t\tcost[0].fill(0);\n\t\t//cost[1].fill(0);\n\t\tfor (int i = 1; i < cost[1].size(); i++)cost[i].fill(initnum);\n\n\t\tint n, m, l;\n\t\tfin >> n >> m >> l;\n\t\tif ((n | m | l) == 0)break;\n\t\t//cout << n << \" \" << m << \" \" << l << endl;\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b, d, e;\n\t\t\tfin >> a >> b >> d >> e;\n\t\t\tin_v.push_back(Input(a - 1, b - 1, d, e));\n\t\t\tin_v.push_back(Input(b - 1, a - 1, d, e));\n\t\t}\n\t\tsort(in_v.begin(), in_v.end());\n\n\t\tstd::queue<Input> in_q;\n\t\tfor (auto in : in_v)in_q.push(in);\n\n\t\tin_v.clear();\n\t\tin_v.shrink_to_fit();\n\n\t\twhile (!in_q.empty())\n\t\t{\n\t\t\tInput tmp = in_q.front();\n\t\t\tin_q.pop();\n\n\t\t\tfor (int _cost = 0; _cost <= l; _cost++)\n\t\t\t{\n\n\t\t\t\tif (cost[tmp.a][_cost] >= initnum)\n\t\t\t\t{\n\t\t\t\t\tin_q.push(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcost[tmp.b][_cost] = std::min(\n\t\t\t\t\tcost[tmp.b][_cost],\n\t\t\t\t\tstd::min(\n\t\t\t\t\t(_cost + tmp.d <= l ? (cost[tmp.a][_cost + tmp.d]) : initnum / 10),\n\t\t\t\t\t\tcost[tmp.a][_cost] + tmp.e\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\t\t}\n\t\tint min_cost = 10000000;\n\n\t\tfor (int i = 0; i <= l; i++) {\n\t\t\tif (cost[n - 1][i] < min_cost)min_cost = cost[n - 1][i];\n\t\t}\n\t\tcout << min_cost << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define MAX 100000000\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<int,p> P;\n//G@ê@à\nstruct edge{\n\tint to,cost,enem;\n};\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n||m||l){\n\t\tvector<edge> tab[110];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedge pre;\n\t\t\tpre.cost=d;\n\t\t\tpre.enem=e;\n\t\t\tpre.to=b;\n\t\t\ttab[a].push_back(pre);\n\t\t\tpre.to=a;\n\t\t\ttab[b].push_back(pre);\n\t\t}\n\t\tint d[110][110];\n\t\t//d[ê][à]=G;\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<=l;j++){\n\t\t\td[i][j]=MAX;\n\t\t}\n\t\td[0][l]=0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,p(0,l)));\n\t\twhile(!que.empty()){\n\t\t\tP now=que.top();\n\t\t\tque.pop();\n\t\t\tint nowplace=now.second.first;\n\t\t\tint nowenem=now.first;\n\t\t\tint nowmoney=now.second.second;\n\t\t\tif(d[nowplace][nowmoney]<nowenem)\n\t\t\t\tcontinue;\n\t\t\td[nowplace][nowmoney]=nowenem;\n\t\t\tfor(int i=0;i<(int)tab[nowplace].size();i++){\n\t\t\t\tedge e=tab[nowplace][i];\n\t\t\t\tif(e.cost<=nowmoney&&d[e.to][nowmoney-e.cost]>nowenem){\n\t\t\t\t\td[e.to][nowmoney-e.cost]=nowenem;\n\t\t\t\t\tque.push(P(nowenem,p(e.to,nowmoney-e.cost)));\n\t\t\t\t}\n\t\t\t\tif(d[e.to][nowmoney]>nowenem+e.enem){\n\t\t\t\t\td[e.to][nowmoney]=nowenem+e.enem;\n\t\t\t\t\tque.push(P(nowenem+e.enem,p(e.to,nowmoney)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=MAX;\n\t\tfor(int i=0;i<=l;i++)\n\t\tans=min(ans,d[n-1][i]);\n\t\tcout<<ans<<endl;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 100;\nconst int INF = 1<<28;\n\nclass S{\npublic:\n  int p, m, c;\n  S(){};\n  S(int p, int m, int c) : p(p), m(m), c(c) {}\n  bool operator < (const S& s) const {\n    if(c == s.c) return m < s.m;\n    return c > s.c;\n  }\n};\n\nint n, m, L, d[N][N+1];\nvector<pair<int, P> > G[N];\n\nvoid dijkstra(int s){\n  priority_queue<S> que;\n  fill(d[0], d[N], INF);\n  d[s][L] = 0;\n  que.push(S(0, L, 0));\n  while(!que.empty()){\n    S u = que.top(); que.pop();\n    if(d[u.p][u.m] < u.c) continue;\n    for(int i=0;i<G[u.p].size();i++){\n      int v = G[u.p][i].first;\n      int cost = G[u.p][i].second.second;\n      if(d[v][u.m] > d[u.p][u.m] + cost){\n        d[v][u.m] = d[u.p][u.m] + cost;\n        que.push(S(v, u.m, d[v][u.m]));\n      }\n      int nm = u.m - G[u.p][i].second.first;\n      if(nm >= 0 && d[v][nm] > d[u.p][u.m]){\n        d[v][nm] = d[u.p][u.m];\n        que.push(S(v, nm, d[v][nm]));\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n >> m >> L && (n|m|L)){\n    for(int i=0;i<N;i++) G[i].clear();\n    for(int i=0;i<m;i++){\n      int a, b, d, e;\n      cin >> a >> b >> d >> e;\n      a--; b--;\n      G[a].push_back(make_pair(b, P(d, e)));\n      G[b].push_back(make_pair(a, P(d, e)));\n    }\n    dijkstra(0);\n    int ans = INF;\n    for(int i=0;i<=L;i++) ans = min(ans, d[n-1][i]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int to, cost, enemy;\n    Edge(int t, int c, int e) : to(t), cost(c), enemy(e) {}\n};\ntypedef vector< vector<Edge> > Graph;\n\nstruct Elem {\n    int pos, money, cost;\n    Elem(int p, int m, int c) : pos(p), money(m), cost(c) {}\n    bool operator<(const Elem &x) const {\n        return cost > x.cost;\n    }\n};\n\nconst int INF = 1 << 28;\nint N, M, L;\nint dist[110][110];\n\nint main() {\n    while(1) {\n        scanf(\"%d%d%d\", &N, &M, &L);\n        if(!N) break;\n\n        Graph G(N);\n        for(int i=0; i<M; i++) {\n            int a, b, d, e; scanf(\"%d%d%d%d\", &a, &b, &d, &e);\n            a--; b--;\n            G[a].push_back(Edge(b, d, e));\n            G[b].push_back(Edge(a, d, e));\n        }\n\n        for(int i=0; i<N; i++) {\n            fill(dist[i], dist[i]+L+1, INF);\n        }\n        dist[0][L] = 0;\n\n        // 出発地 0 で目的地 N-1\n        priority_queue<Elem> que;\n        que.push(Elem(0, L, 0));\n        while(que.size()) {\n            Elem cur = que.top(); que.pop();\n            for(size_t i=0; i<G[cur.pos].size(); i++) {\n                Edge e = G[cur.pos][i];\n                // 雇える\n                if(e.cost <= cur.money) {\n                    int n_money = cur.money - e.cost;\n                    int n_pos   = e.to;\n                    int n_cost  = cur.cost;\n                    if(dist[n_pos][n_money] > n_cost) {\n                        dist[n_pos][n_money] = n_cost;\n                        que.push(Elem(n_pos, n_money, n_cost));\n                    }\n                }\n                // 雇わない\n                int n_money = cur.money;\n                int n_pos   = e.to;\n                int n_cost  = cur.cost + e.enemy;\n                if(dist[n_pos][n_money] > n_cost) {\n                    dist[n_pos][n_money] = n_cost;\n                    que.push(Elem(n_pos, n_money, n_cost));\n                }\n            }\n        }\n        printf(\"%d\\n\", *min_element(dist[N-1], dist[N-1]+L+1));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<functional>\n#include<map>\n#include<fstream>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = (LL)1e9*(LL)1e5;\n\ntypedef vector<LL> VLL;\ntypedef pair<LL, int> E;\ntypedef vector<list<E>> ADJ;\n#define mp(a,b) make_pair(a,b)\n#define cost(_v) _v.first\n#define to(_v) _v.second\nstruct edge{\n\tLL cost;\n\tLL enemy;\n};\nedge inf = { INF, INF };\ninline VLL dijkstra(int s, ADJ adj){\n\tint n = (int)adj.size();\n\tVLL res(n, -1);\n\tpriority_queue<E, vector<E>, greater<E>> que;\n\tque.push(mp(0ll, s));\n\twhile (que.empty() == false){\n\t\tauto tmp = que.top(); que.pop();\n\t\tauto c = cost(tmp);\n\t\tauto v = to(tmp);\n\t\tif (res[v] >= 0)continue;\n\t\tres[v] = c;\n\t\tfor (auto &i : adj[v]){\n\t\t\tauto d = cost(i);\n\t\t\tauto u = to(i);\n\t\t\tif (res[u] >= 0)continue;\n\t\t\tque.push(mp(c + d, u));\n\t\t}\n\t}\n\n\treturn res;\n};\n\n\nint main(){\n\n\t//ofstream cout(\"out.txt\");\n\twhile (1){\n\t\tint N, M, L;\n\t\tcin >> N >> M >> L;\n\t\tif (N + M + L == 0)return 0;\n\t\tvector<vector<LL>> dp(N + 1, vector<LL>(L + 1, INF));\n\t\tvector<vector<edge>> d(N + 1,vector<edge>(N + 1, inf));\n\t\tADJ adj(N + 1);\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tint A, B ;\n\t\t\tLL D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\td[A][B].cost = d[B][A].cost = D;\n\t\t\td[A][B].enemy = d[B][A].enemy = E;\n\t\t\tadj[A].push_back(mp(E, B));\n\t\t\tadj[B].push_back(mp(E, A));\n\t\t}\n\t\tfor (int i = 1; i < N+1; i++){\n\t\t\td[i][i].cost =d[i][i].enemy = 0;\n\t\t}\n\t\tdp[1][0] = 0;\n\n\t\t\n\n\t\tfor (int l = 0; l < L; l++){\n\t\t\tif(l)for (int i = 1; i <= N; i++){\n\t\t\t\tdp[i][l] = min(dp[i][l], dp[i][l - 1]);\n\t\t\t}\n\t\t\tadj[1].clear();\n\t\t\tfor (int i = 2; i < N+1; i++){\n\t\t\t\tadj[1].push_back(mp(min(d[1][i].enemy,dp[i][l]), i));\n\t\t\t}\n\t\t\tauto ddd=dijkstra(1, adj);\n\t\t\tfor (int i = 1; i < N+1; i++){\n\t\t\t\tdp[i][l] = ddd[i];\n\t\t\t}\n\t\t\tfor (int i = 1; i <= N; i++){\n\t\t\t\tfor (int j = 1; j <= N; j++){\n\t\t\t\t\tif (l + d[i][j].cost>L)continue;\n\t\t\t\t\tdp[j][l + d[i][j].cost] = min(dp[i][l], dp[j][l + d[i][j].cost]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; i++){\n\t\t\tdp[i][L] = min(dp[i][L], dp[i][L - 1]);\n\t\t}\n\t\tadj[1].clear();\n\t\tfor (int i = 2; i < N + 1; i++){\n\t\t\tadj[1].push_back(mp(min(d[1][i].enemy, dp[i][L]), i));\n\t\t}\n\t\tauto ddd = dijkstra(1, adj);\n\t\tfor (int i = 1; i < N + 1; i++){\n\t\t\tdp[i][L] = ddd[i];\n\t\t}\n\t\tLL res = INF;\n\t\tfor (int i = 1; i < L+1; i++){\n\t\t\tres = min(res, dp[N][i]);\n\t\t}\n\t\t//cout << \"res:\";\n\t\tcout << res << endl;\n\n\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct edge{\n    int to,cost,num;\n    edge(int to,int cost,int num):to(to),cost(cost),num(num){}\n};\n\nstruct state{\n    int vertex,sum,money;\n    state(int vertex,int sum,int money):vertex(vertex),sum(sum),money(money){}\n    bool operator>(const state& other)const{\n        return sum>other.sum;\n    }\n};\n\nvoid solve(){\n    while(true){\n        int n,m,l;\n        cin >> n >> m >> l;\n        if(n==0 and m==0 and l==0) break;\n\n        vector<vector<edge>> graph(n);\n        rep(i,0,m){\n            int a,b,d,e;\n            cin >> a >> b >> d >> e;\n            --a; --b;\n            graph[a].emplace_back(edge(b,d,e));\n            graph[b].emplace_back(edge(a,d,e));\n        }\n\n        vector<vector<int>> dist(n,vector<int>(l+1,inf));\n        priority_queue<state,vector<state>,greater<state>> que;\n        dist[0][l]=0;\n        que.push(state(0,0,l));\n        int ans=inf;\n        while(!que.empty()){\n            state st=que.top();\n            que.pop();\n            int v=st.vertex,s=st.sum,m=st.money;\n            if(s>dist[v][m]) continue;\n            if(v==n-1) ans=min(ans,s);\n            for(const auto& e:graph[v]){\n                if(s+e.num<dist[e.to][m]){\n                    dist[e.to][m]=s+e.num;\n                    que.push(state(e.to,dist[e.to][m],m));\n                }\n                if(m>=e.cost and s<dist[e.to][m-e.cost]){\n                    dist[e.to][m-e.cost]=s;\n                    que.push(state(e.to,dist[e.to][m-e.cost],m-e.cost));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n \nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint n,m,l;\nvector<vector<PP> > edge;\n\n\nint solve()\n{\n\t\n\t//??????i??§?????????j????????????????????°\n\tvector<vector<int> > memo(n,vector<int>(l+1,1000));\n\t\n\tfor(int i=0;i<=l;i++) memo[0][i]=0;\n\t\n\tpriority_queue<PP,vector<PP>,greater<PP> > q;\n\t\n\t//?????¨??°0,??????0,?????????l\n\tq.push(PP(0,P(0,l)));\n\t\n\twhile(!q.empty()){\n\t\tPP tmp=q.top(); q.pop();\n\t\t\n\t\tint now_v=tmp.first;\n\t\tint now_e=tmp.second.first;\n\t\tint now_l=tmp.second.second;\n\n\t\t//if(now_e>=memo[now_v][now_l]) continue;\n\t\t\t\t\t\t\n\t\tfor(int i=0;i<edge[now_v].size();i++){\n\t\t\tint to=edge[now_v][i].first;\n\t\t\tint e_num=edge[now_v][i].second.second;\n\t\t\tint cost=edge[now_v][i].second.first;\n\n\t\t\t//???????????????\n\t\t\tif(now_l>=cost){\n\t\t\t\tif(memo[to][now_l-cost]>memo[now_v][now_l]){\n\t\t\t\t\tmemo[to][now_l-cost]=memo[now_v][now_l];\n\t\t\t\t\tq.push(PP(to,P(now_e,now_l-cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//?????????????????????\n\t\t\tif(memo[to][now_l]>memo[now_v][now_l]+e_num){\n\t\t\t\tmemo[to][now_l]=memo[now_v][now_l]+e_num;\n\t\t\t\tq.push(PP(to,P(now_e+e_num,now_l)));\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tint ans=memo[n-1][0];\n\tfor(int i=1;i<=l;i++) ans=min(ans,memo[n-1][i]);\n\t\n\treturn ans;\n\t\n}\n\nint main()\n{\n\t\n\twhile(cin>>n>>m>>l,n){\t\t\n\t\t\t\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--; b--;\n\t\t\t\n\t\t\tedge[a].push_back(PP(b,P(d,e)));\n\t\t\tedge[b].push_back(PP(a,P(d,e)));\n\t\t\t\n\t\t}\n\t\tcout<<solve()<<endl;\n\t\t\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Edge {\n    int src,dst,cost;\n};\nbool operator<(const Edge &e,const Edge &f) {\n    return (e.cost != f.cost)?e.cost>f.cost:e.src<f.src;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint L;\ninline int idx(int a,int l) { return a*L+l; }\n\nvoid dijkstra(const Graph &g,int s,vector<int> &dist) {\n    const int n = g.size();\n    for(int i=0; i<dist.size(); ++i)\n        dist[i] = 1<<29;\n\n    vector<int> prev(n, -1);\n\n    priority_queue<Edge> q;\n    q.push((Edge){-2,s,0});\n    dist[s] = 0;\n\n    while(!q.empty()) {\n        Edge e = q.top(); q.pop();\n\n        if(prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        //cout<<(e.dst/L)<<\",\"<<(e.dst%L)<<\" : \"<<e.cost<<endl;\n\n        for(int i=0; i<g[e.dst].size(); ++i) {\n            int w = g[e.dst][i].dst;\n            if(dist[w] > dist[e.dst]+g[e.dst][i].cost) {\n                dist[w] = dist[e.dst]+g[e.dst][i].cost;\n                q.push((Edge){e.dst,w,dist[w]});\n            }\n        }\n    }\n}\n\nint main() {\n    int n,m,l;\n    int a,b,d,e;\n    while(cin>>n>>m>>l, n|m|l) {\n        L = l+1;\n        Graph g(n*L);\n        for(int i=0; i<m; ++i) {\n            cin>>a>>b>>d>>e; a--,b--;\n            for(int j=0; j<=l; ++j) {\n                g[idx(a,j)].push_back((Edge){idx(a,j),idx(b,j),e});\n                g[idx(b,j)].push_back((Edge){idx(b,j),idx(a,j),e});\n                if(j >= d) {\n                    g[idx(a,j)].push_back((Edge){idx(a,j),idx(b,j-d),0});\n                    g[idx(b,j)].push_back((Edge){idx(b,j),idx(a,j-d),0});\n                }\n            }\n        }\n\n        vector<int> dist(n*L, 0);\n        dijkstra(g,l,dist);\n\n        int ans = 1<<29;\n        for(int i=0; i<=l; ++i) {\n            ans = min(ans, dist[idx(n-1,i)]);\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nstruct Edge{\n    int d, e;\n};\n\nconst int N = 105;\nEdge M[N][N];\nbool can_use[N][N];\nint n, m, l;\n\nvoid bfs(int n){\n    int dis[N]; //?????¢\n    queue<int> q; //?¨??????????????????\\??????\n    rep(i,N) dis[i] = 0;\n\n    dis[0] = l;\n    q.push(0);\n\n    int u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(v,n){\n            if(dis[v] <= dis[u] - M[u][v].d && dis[u] - M[u][v].d >= 0){\n                dis[v] = dis[u] - M[u][v].d; //??°???????????±??? \n                can_use[u][v] = true;\n                cout << u << ' ' << v << endl;\n                q.push(v);\n            }\n        }\n    }\n}\n\nint bfs_(int n){\n    int dis[N];\n    queue<int> q;\n    rep(i,N) dis[i] = INF;\n\n    dis[0] = 0;\n    q.push(0);\n\n    int u;\n    while(not q.empty()){\n        u = q.front(); q.pop();\n        rep(v,n){\n            if(dis[v] > dis[u] + (can_use[u][v] ? 0 : M[u][v].e)){\n                dis[v] = dis[u] + (can_use[u][v] ? 0 : M[u][v].e);\n                q.push(v);\n            }\n        }\n    }\n    return dis[n - 1];\n}\n\nconst int MAX_V = 105;\n\nvoid init(int m[MAX_V][MAX_V]){\n    rep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n    rep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(){\n    int node[105][MAX_V];\n    rep(i,105) rep(j,MAX_V) node[i][j] = INF;\n    node[l][0] = 0;\n\n    for(int o = l; o >= 0; o--){\n        bool loop = true;\n        while(loop){\n            loop = false;\n            rep(i,n){\n                rep(j,n){\n                    int tmp = o - M[i][j].d;\n                    if(tmp >= 0){\n                        if(node[tmp][j] > node[o][i]){\n                            node[tmp][j] = node[o][i];\n                            loop = true;\n                        }\n                    }\n                    if(node[o][j] > node[o][i] + M[i][j].e){\n                        node[o][j] = node[o][i] + M[i][j].e;\n                        loop = true;\n                    }\n                }\n            }\n        }\n        //rep(i,n){ show(node[o][i]) } cout << endl;\n    }\n    //cout << endl;\n\n    int mini = INF;\n    rep(i,l + 1){\n        mini = min(mini, node[i][n - 1]);\n    }\n    cout << mini << endl;\n    return;\n}\n\nint main(){\n    while(cin >> n >> m >> l,n){\n        rep(i,N) rep(j,N) M[i][j] = Edge{INF,INF};\n        memset(can_use, 0, sizeof(can_use));\n        rep(i,m){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--; b--;\n            M[a][b] = Edge{d,e};\n            M[b][a] = Edge{d,e};\n        }\n        warshallFloyd();\n        //bfs(n);\n        //cout << bfs_(n) << endl;\n    }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n \nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint n,m,l;\nvector<vector<PP> > edge;\n\n\nint solve()\n{\n\t\n\t//??????i??§?????????j????????????????????°\n\tvector<vector<int> > memo(n,vector<int>(l+1,1000));\n\t\n\tfor(int i=0;i<=l;i++) memo[0][i]=0;\n\t\n\tpriority_queue<PP,vector<PP>,greater<PP> > q;\n\t\n\t//?????¨??°0,??????0,?????????l\n\tq.push(PP(0,P(0,l)));\n\t\n\twhile(!q.empty()){\n\t\tPP tmp=q.top(); q.pop();\n\t\t\n\t\tint now_v=tmp.first;\n\t\tint now_e=tmp.second.first;\n\t\tint now_l=tmp.second.second;\n\t\t\t\n\t\t\n\t\tif(now_e>memo[now_v][now_l]) continue;\t\n\t\t\t\t\t\n\t\tfor(int i=0;i<edge[now_v].size();i++){\n\t\t\tint to=edge[now_v][i].first;\n\t\t\tint e_num=edge[now_v][i].second.second;\n\t\t\tint cost=edge[now_v][i].second.first;\n\n\t\t\t//???????????????\n\t\t\tif(now_l>=cost){\n\t\t\t\tif(memo[to][now_l-cost]>=memo[now_v][now_l]){\n\t\t\t\t\tmemo[to][now_l-cost]=memo[now_v][now_l];\n\t\t\t\t\tq.push(PP(to,P(now_e,now_l-cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//?????????????????????\n\t\t\tif(memo[to][now_l]>=memo[now_v][now_l]+e_num){\n\t\t\t\tmemo[to][now_l]=memo[now_v][now_l]+e_num;\n\t\t\t\tq.push(PP(to,P(now_e+e_num,now_l)));\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tint ans=memo[n-1][0];\n\tfor(int i=1;i<=l;i++) ans=min(ans,memo[n-1][i]);\n\t\n\treturn ans;\n\t\n}\n\nint main()\n{\n\t\n\twhile(cin>>n>>m>>l,n){\t\t\n\t\t\t\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--; b--;\n\t\t\t\n\t\t\tedge[a].push_back(PP(b,P(d,e)));\n\t\t\tedge[b].push_back(PP(a,P(d,e)));\n\t\t\t\n\t\t}\n\t\tcout<<solve()<<endl;\n\t\t\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\n#define UNDEF 90000000\n\nusing namespace std;\n\nint main()\n{\n\tint n, m, l, i;\n\tint len[101][101];\n\tint hos[101][101];\n\tint djk_money[2][101];\n\tint djk_enemy[2][101];\n\n\t//0...àgíÈ¢[g\n\t//1...àg¤[g\n\n\tqueue<int> que;\n\n\twhile(cin >> n >> m >> l, (n||m||l))\n\t{\n\t\tmemset(len, -1, sizeof(len));\n\t\tmemset(hos, -1, sizeof(hos));\n\t\tmemset(djk_money, -1, sizeof(djk_money));\n\t\tmemset(djk_enemy, -1, sizeof(djk_enemy));\n\t\tque.push(1);\n\t\tdjk_enemy[0][1] = 0;\n\t\tdjk_enemy[1][1] = 0;\n\t\tdjk_money[0][1] = l;\n\t\tdjk_money[1][1] = l;\n\n\t\tfor( i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a;\n\t\t\tcin >> b;\n\n\t\t\tcin >> len[a][b];\n\t\t\tcin >> hos[a][b];\n\n\t\t\tlen[b][a] = len[a][b];\n\t\t\thos[b][a] = hos[a][b];\n\t\t}\n\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tint st = que.front();\n\t\t\tque.pop();\n\n\t\t\tfor( i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif( len[st][i] > 0 && hos[st][i] > 0)\n\t\t\t\t{\n\t\t\t\t\tbool flg = 0;\n\n\t\t\t\t\tif( djk_enemy[0][i] < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdjk_enemy[0][i] = UNDEF;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( djk_enemy[1][i] < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdjk_enemy[1][i] = UNDEF;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor( int k = 0; k <= 1; k++)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tif( djk_enemy[0][i] > djk_enemy[k][st] + hos[st][i] )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdjk_enemy[0][i] = djk_enemy[k][st] + hos[st][i];\n\t\t\t\t\t\t\tdjk_money[0][i] = djk_money[k][st];\n\t\t\t\t\t\t\tflg = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( djk_enemy[1][i] > djk_enemy[k][st] && djk_money[k][st] - len[st][i] >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdjk_enemy[1][i] = djk_enemy[k][st];\n\t\t\t\t\t\t\tdjk_money[1][i] = djk_money[k][st] - len[st][i];\n\t\t\t\t\t\t\tflg = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg)\n\t\t\t\t\t\tque.push(i);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout <<  min(djk_enemy[0][n], djk_enemy[1][n]) <<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\n#include <functional>\n#include<vector>\n#include<math.h>\n#include<bitset>\n#include<string>\n#include <deque>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include <random>\n#include<type_traits>\n#include<stack>\n#include <sstream> \n#include <limits>\n#include <numeric>\n#include<string.h>\nusing namespace std;\n#define ll long long int\n#define all(v) begin(v), end(v)\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n//typedef vector<int> V;\n//typedef vector<VV> VVV;\n\ntemplate<typename T>\nvoid remove(std::vector<T>& vector, unsigned int index)\n{\n\tvector.erase(vector.begin() + index);\n}\n\nstruct edge { int to, cost,theef; };\ntypedef pair<int, int > P;\nstruct pp { int point, now, money;};\n\n//V頂点数\nint V;\nvector<edge>G[100000];//max頂点数\nint d[105][105];//n,予算\n\nvoid dijktra(int s,int l) {\n\tqueue<pp> que;\n\tfor (int i = 0; i <V+3; i++) {\n\t\tfill(d[i], d[i] + l + 3, 100000000);\n\t}\n\n\td[s][l] = 0;\n\tpp ppp = { 0, s, l };\n\tque.push(ppp);\n\n\twhile (!que.empty()) {\n\t\tpp p = que.front(); que.pop();\n\t\tint v = p.now;\n\t\tif (d[v][p.money] < p.point)continue;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to][p.money] > d[v][p.money] + e.theef) {\n\t\t\t\td[e.to][p.money] = d[v][p.money] + e.theef;\n\t\t\t\tppp = { d[e.to][p.money], e.to,p.money };\n\t\t\t\tque.push(ppp);\n\t\t\t}\n\t\t\tif ((p.money - e.cost) < 0)continue;\n\t\t\tif (d[e.to][p.money - e.cost] > d[v][p.money]) {\n\t\t\t\td[e.to][p.money - e.cost] = d[v][p.money];\n\t\t\t\tppp = { d[e.to][p.money - e.cost], e.to,p.money-e.cost };\n\t\t\t\tque.push(ppp);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main() {\n\tint n, m, l, a, b, d2, e;\n\tcin >> n >> m >> l;\n\twhile (n != 0) {\n\t\tV = n;//頂点数\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> d2 >> e;\n\t\t\tedge e1 = { b,d2 ,e };\n\t\t\tedge e2 = { a,d2,e };\n\t\t\tG[a].push_back(e1);//aからbへコストcの辺\n\t\t\tG[b].push_back(e2);\n\t\t}\n\t\tint min = 1000000;\n\t\tdijktra(1, l);//頂点aからの最短距離配列生成\n\t\tfor (int i = 0; i <= l; i++) {\n\t\t\tif (min > d[V][i])min = d[V][i];\n\t\t}\n\t\tcout << min << endl;\n\t\tcin >> n >> m >> l;\n\t\tfor (int i = 1; i <= V; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1e+8;\nint N, M, L;\n\nstruct edge{\n\tint to, d, cost;\n\tedge(int to_, int d_, int cost_){\n\t\tto = to_; d = d_; cost = cost_;\n\t}\n};\nstruct State{\n\tint cost, l, v;\n\tState(int cost_, int l_, int v_){\n\t\tcost = cost_; l = l_; v = v_;\n\t}\n};\nbool operator<(const State &a, const State &b){\n\treturn a.cost > b.cost;\n}\nvector<edge> G[101];\n\nvoid add_edge(int u, int v, int d, int cost){\n\tG[u].push_back( edge(v, d, cost) );\n\tG[v].push_back( edge(u, d, cost) );\n}\n\n// dp[l][v] := 使った予算が l で頂点が v のときの襲われた敵の数\nint dp[101][101];\n\nint dijkstra(){\n\tfor(int i=0 ; i < 101 ; i++ ){\n\t\tfor(int j=0 ; j < 101 ; j++ ){\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tpriority_queue<State> q;\n\tq.push( State(0, 0, 0) );\n\tdp[0][0] = 0;\n\t\n\tint res = INF;\n\twhile( !q.empty() ){\n\t\tint cost = q.top().cost, l = q.top().l, v = q.top().v;\n\t\tq.pop();\n\t\tif( v == N-1 ){\n\t\t\tres = min(res, cost);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tint to = G[v][i].to, d = G[v][i].d;\n\t\t\t\n\t\t\t// お金を使う\n\t\t\tif( l + d <= L ){\n\t\t\t\tint next_l = l + d;\n\t\t\t\tint next_cost = cost;\n\t\t\t\tif( next_cost < dp[next_l][to] ){\n\t\t\t\t\tdp[next_l][to] = next_cost;\n\t\t\t\t\tq.push( State(next_cost, next_l, to) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// お金を使わない\n\t\t\tint next_cost = cost + G[v][i].cost;\n\t\t\tif( next_cost < dp[l][to] ){\n\t\t\t\tdp[l][to] = next_cost;\n\t\t\t\tq.push( State(next_cost, l, to) );\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> N >> M >> L , N || M || L ){\n\t\tfor(int i=0 ; i < 101 ; i++ ) G[i].clear();\n\t\t\n\t\tfor(int i=0 ; i < M ; i++ ){\n\t\t\tint A, B, C, D;\n\t\t\tcin >> A >> B >> C >> D;\n\t\t\tA--; B--;\n\t\t\tadd_edge(A, B, C, D);\n\t\t}\n\t\tcout << dijkstra() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXN = 101, MAXL = 101, INF = 110000 ;\nint d[MAXN][MAXL];\n\nstruct edge{int to, dist, enemy;};\n\nint n, m, l, a, b, dist, e;\n\ntypedef pair<int, int> pp;\ntypedef pair<int, pp> ppp;\n\nint main()\n{\n    while(cin >> n >> m >> l && n)\n    {\n        //memset(d , INF, sizeof(int) * MAXN * MAXL);\n        rep(i,n)rep(j,l + 1)d[i][j] = 110000 ;\n        vector<edge> g[MAXN];\n        REP(m)\n        {\n            cin >> a >> b >> dist >> e;\n            a--; b--;\n            g[a].push_back((edge){b, dist, e});\n            g[b].push_back((edge){a, dist, e});\n        }\n\n        priority_queue<ppp, vector<ppp>, greater<ppp> > que;\n        que.push(ppp(0, pp( -l , 0)));\n        d[0][l] = 0;\n        int ans = 1000;\n\n        //cout << d[1][l] << endl;\n\n        while(!que.empty())\n        {\n            ppp p = que.top(); que.pop();\n            int nowe = p.first, nowl = -p.second.first, now = p.second.second;\n            //cout << \"e:\" << nowe << \"  l:\" << nowl << \"  now:\" << now << endl;\n            if(now =="
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n \n\nint n,m,l;\nstruct edge{int to;int dd;int ee;};\n\nint main(){\n    while(cin >> n >> m >> l,n){\n        vector<int> a(m),b(m),d(m),e(m);\n        vector<vector<edge>> G(n+1);\n        for (int i = 0; i < m; i++) {\n            cin >> a[i] >> b[i] >> d[i] >> e[i];\n            a[i]--,b[i]--;\n            G[a[i]].pb({b[i],d[i],e[i]});\n            G[b[i]].pb({a[i],d[i],e[i]});\n        }\n        vector<vector<int>> dp(n+1,vector<int> (l+1,INF));\n        dp[0][0]=0;\n        priority_queue<pair<int,P>,vector<pair<int,P>>,greater<pair<int,P>>> pq;\n        pq.push({0,{0,0}});\n        while(!pq.empty()){\n            int v=pq.top().second.second;\n            int ll=pq.top().second.first;\n            int c=pq.top().first;\n            pq.pop();\n            if(dp[v][ll]<c) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e=G[v][i];\n                int to=e.to;\n                int dd=e.dd;\n                int ee=e.ee;\n                if(dp[to][ll]>dp[v][ll]+ee){\n                    dp[to][ll]=dp[v][ll]+ee;\n                    pq.push({dp[to][ll],{ll,to}});\n                }\n                if(ll+dd<=l&&dp[to][ll+dd]>dp[v][ll]){\n                    dp[to][ll+dd]=dp[v][ll];\n                    pq.push({dp[to][ll+dd],{ll+dd,to}});\n                }\n            }\n        }\n        int ans = INF;\n        for (int i = 0; i <= l; i++) {\n            ans = min(ans,dp[n-1][i]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nint n, m, l;\n\nstruct edge {\n\tint to;\n\tll cost;\n\tll enemy;\n};\n\nll d[110][110];\nvector<edge> G[110];\n\nvoid dijkstra() {\n\trep(i, 110)rep(j, 110)d[i][j] = INF;\n\td[0][l] = 0;\n\n\ttypedef pair<P, ll> Pi;\n\n\tpriority_queue<Pi, vector<Pi>, greater<Pi>> que;\n\tque.push({ P(0, l), 0 });\n\n\twhile (!que.empty()) {\n\t\tPi p = que.top();\n\t\tque.pop();\n\t\tll v = p.second;\n\t\tll ln = p.first.second;\n\t\tll en = p.first.first;\n\t\tif (d[v][ln] < p.first.first || v == n - 1)continue;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (ln >= e.cost) {\n\t\t\t\tif (d[e.to][ln - e.cost] > d[v][ln]) {\n\t\t\t\t\td[e.to][ln - e.cost] = d[v][ln];\n\t\t\t\t\tque.push({ P(d[e.to][ln - e.cost], ln - e.cost),e.to });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d[e.to][ln] > d[v][ln] + e.enemy) {\n\t\t\t\td[e.to][ln] = d[v][ln] + e.enemy;\n\t\t\t\tque.push({ P(d[e.to][ln], ln),e.to });\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main() {\n\twhile (cin >> n >> m >> l&&n + m + l) {\n\t\trep(i, 110)G[i].clear();\n\t\trep(i, m) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tG[a].push_back({ b,c,d });\n\t\t\tG[b].push_back({ a,c,d });\n\t\t}\n\t\tdijkstra();\n\t\tll ans = INF;\n\t\trep(i, l + 1) {\n\t\t\tans = min(ans, d[n - 1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\ntypedef pair<int, int> state; // 頂点、残金\ntypedef pair<state, int> pass; // 状態、悪党\ntypedef tuple<int, int, int> cand; // -1 * cost, point, money\n\nvector<pass> V[110][110];\n\nint main() {\n  int N, M, L;\n  while(cin >> N >> M >> L && N) {\n    N--;\n    // 初期化\n    for (auto i=0; i<110; i++) {\n      for (auto j=0; j<110; j++) {\n\tV[i][j].clear();\n      }\n    }\n    // 入力受け取り\n    int AA[10000], BB[10000], DD[10000], EE[10000];\n    for (auto i=0; i<M; i++) {\n      cin >> AA[i] >> BB[i] >> DD[i] >> EE[i];\n      AA[i]--;\n      BB[i]--;\n    }\n    // 隣接リスト作成\n    for (auto i=0; i<M; i++) {\n      for (auto j=0; j<=L; j++) {\n\tV[AA[i]][j].push_back(make_pair(make_pair(BB[i], j), EE[i]));\n\tV[BB[i]][j].push_back(make_pair(make_pair(AA[i], j), EE[i]));\n\tint t = j - DD[i];\n\tif (t >= 0) {\n\t  V[AA[i]][j].push_back(make_pair(make_pair(BB[i], t), 0));\n\t  V[BB[i]][j].push_back(make_pair(make_pair(AA[i], t), 0));\n\t}\n      }\n    }\n    // Dijkstra法\n    priority_queue<cand> Q;\n    Q.push(make_tuple(0, 0, L));\n    bool visited[110][110];\n    fill(&visited[0][0], &visited[0][0]+110*110, false);\n    int ans = 0;\n    while (!Q.empty()) {\n      int np = get<1>(Q.top());\n      int nl = get<2>(Q.top());\n      int nc = -1 * get<0>(Q.top());\n      Q.pop();\n      if (!visited[np][nl]) {\n\tvisited[np][nl] = true;\n\t// cerr << \"visiting \" << np << \" at \" << nl << endl;\n\tif (np == N) {\n\t  ans = nc;\n\t  break;\n\t}\n\tfor (auto i=0; i<V[np][nl].size(); i++) {\n\t  int dp = V[np][nl][i].first.first;\n\t  int dl = V[np][nl][i].first.second;\n\t  int dc = V[np][nl][i].second;\n\t  if (!visited[dp][dl]) {\n\t    Q.push(make_tuple(-1* (dc+nc), dp, dl));\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define D double\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nint n,m,l;\n\nvector<int> dijkstra(int s, Graph &G){\n  priority_queue<P,vector<P>,greater<P>> que;\n  int n = G.size();\n  //debug(n);\n  vector<int> dist(n);\n  dist.assign(n,INF);\n  dist[s] = 0;\n  que.push(P(0,s));\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.sc;\n    REP(i,G[v].size()){\n      if(dist[G[v][i].fs] > dist[v]+G[v][i].sc){\n        dist[G[v][i].fs] = dist[v]+G[v][i].sc;\n        que.push(P(dist[G[v][i].fs],G[v][i].fs));\n      }\n    }\n  }\n  return dist;\n}\n\nvoid solve() {\n\tGraph edge(n*111);\n  REP(_,m){\n    int x,y,d,e;\n    cin >> x >> y >> d >> e;\n    x--; y--;\n    REP(i,111){\n      edge[x*111+i].push_back(P(y*111+i,e));\n      edge[y*111+i].push_back(P(x*111+i,e));\n    }\n    REP(i,111){\n      if(i-d < 0) continue;\n      edge[x*111+i].push_back(P(y*111+i-d,0));\n      edge[y*111+i].push_back(P(x*111+i-d,0));      \n    }\n  }\n  vec dist = dijkstra(l,edge);\n  //cout << dist.size() << endl;\n\n  int ans = INF;\n  REP(i,l+1) ans = min(ans,dist[(n-1)*111+i]);\n\n  cout << ans << endl;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  while(cin >> n >> m >> l, n) solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nbool operator==(const State& lhs, const State& rhs)\n{\n    return lhs.loc == rhs.loc && lhs.money == rhs.money && lhs.damage == rhs.damage;\n}\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<int> memo(101, -1);\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (current.money <= memo[current.loc]) {\n                continue;\n            }\n            memo[current.loc] = current.money;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (e.dist <= current.money) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#define fr first\n#define sc second\n#define INF (1 << 25)\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> iP;\nstruct edge{\n  int to,dis,enemy; edge(){}\n  edge(int to,int dis,int enemy):to(to),dis(dis),enemy(enemy){}\n};\n\nint n,m,money;\nint costed[128][128];\nvector<vector<edge> >info(128);\n\nvoid init(){\n  for(int i=0;i<128;i++){\n    for(int j=0;j<128;j++) costed[i][j] = INF;\n  }\n  info.resize(0); info.resize(128);\n}\n\nvoid add_info(){\n  int a,b,c,d;\n  cin >> a >> b >> c >> d;\n  info[a].push_back(edge(b,c,d));\n  info[b].push_back(edge(a,c,d));\n}\n\nint Dijkstra(){\n  priority_queue<iP,vector<iP>,greater<iP> > que;\n  que.push(iP(P(0,1),money));\n  costed[money][1] = 0;\n  while(!que.empty()){\n    iP p = que.top(); que.pop();\n    int now =  p.fr.sc,att = p.fr.fr,mo = p.sc;\n    if(now == n) return att;\n    for(int i=0;i<info[now].size();i++){\n      edge e = info[now][i];\n      if(e.enemy + att < costed[mo][e.to]){\n\tque.push(iP(P(att + e.enemy,e.to),mo));\n\tcosted[mo][e.to] = e.enemy + att;\n      }\n      if(mo >= e.dis && att < costed[mo-e.dis][e.to]){\n\tque.push(iP(P(att,e.to),mo-e.dis));\n\tcosted[mo-e.dis][e.to] = att;\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> n >> m >> money,n||m||money){\n    init();\n    while(m--) add_info();\n    cout << Dijkstra() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,s,e) for(int i=(s); i<(e);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n)\n#define repe(i,n) for(auto &&i:n)\n#define all(v) (v).begin(),(v).end()\n#define decimal fixed<<setprecision(20)\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\nusing namespace std;\nusing LL = long long;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst int INF = 1e9;\nconst LL LLINF = 1e16;\n\nstruct edge{\n    int to, cost, enemy;\n};\nusing Edges = vector<edge>;\nusing WeightedGraph = vector<Edges>;\n\nint N, M, L;\nWeightedGraph G;\n\nint dijkstra(WeightedGraph &G, int st){\n    // dmg[i][j] := iまでコストjでいくときの最小ダメージ\n    vector<vector<int>> dmg(G.size(), vector<int>(L+1, INF));\n    using pi = tuple<int, int, int>;\n    priority_queue<pi, vector<pi>, greater<pi>> q;\n    dmg[st][0] = 0;\n    q.push(pi(0, 0, st));\n    while(!q.empty()){\n        int damage, cost, idx;\n        tie(damage, cost, idx) = q.top(); q.pop();\n        if(dmg[idx][cost] < damage) continue;\n        // cout << damage << \" \" << cost << \" \" << idx << endl;\n        // rep(i, N){\n        //     rep(j, L+1){\n        //         cout << dmg[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << endl;\n        for(auto &e: G[idx]){\n            // 守る\n            int nxt_cost = cost + e.cost;\n            if(nxt_cost <= L && dmg[e.to][nxt_cost] > damage){\n                dmg[e.to][nxt_cost] = damage;\n                q.push(tie(dmg[e.to][nxt_cost], nxt_cost, e.to));\n            }\n            // 襲われる\n            if(dmg[e.to][cost] > damage + e.enemy){\n                dmg[e.to][cost] = damage + e.enemy;\n                q.push(tie(dmg[e.to][cost], cost, e.to));\n            }\n        }\n    }\n    int ans = INF;\n    rep(i, L+1) chmin(ans, dmg[N-1][i]);\n    return ans;\n}\n\nint main(){\n    cin >> N >> M >> L;\n    while(N > 0){\n        G = WeightedGraph(N);\n        rep(i, M){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--; b--;\n            G[a].push_back(edge{b, d, e});\n            G[b].push_back(edge{a, d, e});\n        }\n        cout << dijkstra(G, 0) << endl;\n        cin >> N >> M >> L;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int MAXN = 110, MAXM = 5500, MAXL = 110, INF = 200000;\n\nint n,m,l,a,b,d,e;\nint enemy[MAXN][MAXN];\nint dist[MAXN][MAXN];\nint minenemy[MAXN][MAXL];\nbool used[MAXN][MAXL];\n\ntypedef pair<int,int> pp;\ntypedef pair<int,pp> ppp;\n\nint main()\n{\n    while(cin >> n >> m >> l && n )\n    {\n        memset(enemy, INF, sizeof(enemy));\n        memset(dist, INF, sizeof(dist));\n        memset(used, false, sizeof(used));\n        priority_queue<ppp, vector<ppp>, greater<ppp> > que;\n        que.push(ppp(0,pp(0,1)));\n\n        REP(m)\n        {\n            cin >> a >> b >> d >> e;\n            enemy[b][a] = e;\n            enemy[a][b] = e;\n            dist[b][a] = d;\n            dist[a][b] = dist[b][a];\n        }\n        int ans = 0;\n        while(!que.empty())\n        {\n            ppp q = que.top(); que.pop();\n            int nowe = q.first, cost = q.second.first, node = q.second.second;\n            if(node == n){ans = nowe; break;}\n            if(used[nowe][cost])continue;\n            used[nowe][cost] = 1;\n            int minv = 0;\n            for(int i=1;i<=n;i++)\n             /*   if( dist[node][minv] > dist[node][i]) minv = i;*/\n            {\n                que.push(ppp(nowe + enemy[node][i], pp(nowe, i)));\n                if(cost + dist[node][i] <= l)\n                    que.push(ppp(nowe, pp(cost + dist[node][i], i)));\n            }\n            /*\n            //cout << \"push\"<< minv << endl;\n            que.push(ppp(nowe + enemy[node][minv], pp(nowe, minv)));\n            if(cost + dist[node][minv] <= l)\n                que.push(ppp(nowe, pp(cost + dist[node][minv], minv)));\n            */\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) if((x)>(y))(x)=(y)\n#define chmax(x,y) if((x)<(y))(x)=(y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// d[i][j]: 街iに総コストjかけて到着する際に遭遇する盗賊の数の最小値\nint n, m, s, a, b, l, x, d[101][101];\nvector<pair<int,pii> > e[101];\n\nvoid rec(int id, int cs) {\n\trep(i,e[id].size()) {\n\t\tint to = e[id][i].fi, dis = e[id][i].se.fi, num = e[id][i].se.se;\n\t\tif (cs+dis<=s && d[to][cs+dis]>d[id][cs]) d[to][cs+dis] = d[id][cs], rec(to,cs+dis); // 護衛を雇う場合\n\t\tif (d[to][cs]>d[id][cs]+num) d[to][cs] = d[id][cs]+num, rec(to,cs); // 雇わない場合\n\t}\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n >> m >> s;\n\t\tif (n==0) break;\n\t\trep(i,n) rept(j,s) d[i][j] = inf;\n\t\td[0][0] = 0;\n\t\trep(i,n) e[i].clear();\n\t\trep(i,m) {\n\t\t\tcin >> a >> b >> l >> x;\n\t\t\ta--, b--;\n\t\t\te[a].pb({b,{l,x}}), e[b].pb({a,{l,x}});\n\t\t}\n\t\trec(0,0);\n\t\tint res = inf;\n\t\trept(i,s) chmin(res,d[n-1][i]);\n\t\tcout << res << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n#define MAX_V 100\n#define MAX_B 100\n\nstruct edge{pii to;int cost;};\nvector<edge> G[MAX_V][MAX_B+1];\nint d[MAX_V][MAX_B+1];\n\nvoid dijkstra(pii s){\n    priority_queue< pair<int,pii>,vector<pair<int,pii>>,greater<pair<int,pii>> > que;\n    rep(i,MAX_V)rep(j,MAX_B+1)d[i][j]=INF;\n    d[s.first][s.second]=0;\n    que.push(make_pair(0,s));\n    \n    while(que.size()){\n        pair<int,pii> p=que.top();\n        que.pop();\n        \n        int v=p.second.first;\n        int b=p.second.second;\n        if(d[v][b]<p.first)continue;\n        \n        rep(i,G[v][b].size()){\n            edge e=G[v][b][i];\n            if(d[e.to.first][e.to.second]>d[v][b]+e.cost){\n                d[e.to.first][e.to.second]=d[v][b]+e.cost;\n                que.push(make_pair(d[e.to.first][e.to.second],e.to));\n            }\n        }\n    }\n}\n\nint main(){\n    int v,e,l;\n    while(cin>>v>>e>>l&&(v||e||l)){\n        rep(i,MAX_V)rep(j, MAX_B+1)G[i][j].clear();\n        rep(i,e){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            a--,b--;\n            rep(i,l+1){\n                G[a][i].pb(edge{pii(b,i),d});\n                if(i+c<=l)G[a][i].pb(edge{pii(b,i+c),0});\n            }\n            rep(i,l+1){\n                G[b][i].pb(edge{pii(a,i),d});\n                if(i+c<=l)G[b][i].pb(edge{pii(a,i+c),0});\n            }\n        }\n        \n        dijkstra(pii(0,0));\n        int ans = INF;\n        rep(i,l+1)ans = min(ans,d[v-1][i]);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip;\n\nint dp[105][105];\n\nint main(void) {\n    int i,j;\n    int n, m, l;\n    while(cin >> n >> m >> l){\n        vector<vector<pip> > v(n);\n        rep(i,m){\n            int a,b,d,e;\n            cin >> a >> b >> d >> e;\n            a--,b--;\n            v[a].push_back(pip(b,pii(d,e)));//to,cost,num\n            v[b].push_back(pip(a,pii(d,e)));\n        }\n        priority_queue<pip,vector<pip>,greater<pip> > q;\n\n        rep(i,100)rep(j,105)dp[i][j] = INF;\n        dp[0][0] = 0;\n        q.push(pip(0,pii(0,0)));//num,v,cost\n        while(q.size()){\n\n            int now_v = q.top().second.first;\n            int now_cost = q.top().second.second;\n            int now_num = q.top().first;\n            q.pop();\n\n            if(dp[now_v][now_cost] < now_num)continue;\n\n            rep(i,v[now_v].size()){\n                int next_v = v[now_v][i].first;\n\n                //護衛するときは、お金がかかるが襲われる人数は増えない\n                int next_cost1 = now_cost + v[now_v][i].second.first;\n                int next_num1 = now_num;\n\n                if(next_cost1 <= l && dp[next_v][next_cost1] > next_num1){\n                    dp[next_v][next_cost1] = next_num1;\n                    q.push(pip(next_num1,pii(next_v,next_cost1)));\n                }\n\n                //護衛しないときは、お金はかからないが襲われる人数が増える\n                int next_cost2 = now_cost;\n                int next_num2 = now_num + v[now_v][i].second.second;\n\n                if(next_cost2 <= l && dp[next_v][next_cost2] > next_num2){\n                    dp[next_v][next_cost2] = next_num2;\n                    q.push(pip(next_num2,pii(next_v,next_cost2)));\n                }\n\n            }\n        }\n        int ans = INF;\n        rep(i,l+1){\n            ans = min(ans, dp[n-1][i]);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n \nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint n,m,l;\nvector<vector<PP> > edge;\n\n\nint solve()\n{\n\t\n\t//??????i??§?????????j????????????????????°\n\tvector<vector<int> > memo(n,vector<int>(l+1,1000));\n\t\n\tfor(int i=0;i<=l;i++) memo[0][i]=0;\n\t\n\tpriority_queue<PP,vector<PP>,greater<PP> > q;\n\t\n\t//?????¨??°0,??????0,?????????l\n\tq.push(PP(0,P(0,l)));\n\t\n\twhile(!q.empty()){\n\t\tPP tmp=q.top(); q.pop();\n\t\t\n\t\tint now_v=tmp.first;\n\t\tint now_e=tmp.second.first;\n\t\tint now_l=tmp.second.second;\n\t\t\t\t\t\t\n\t\tfor(int i=0;i<edge[now_v].size();i++){\n\t\t\tint to=edge[now_v][i].first;\n\t\t\tint e_num=edge[now_v][i].second.second;\n\t\t\tint cost=edge[now_v][i].second.first;\n\n\t\t\t//???????????????\n\t\t\tif(now_l>=cost){\n\t\t\t\tif(memo[to][now_l-cost]>=memo[now_v][now_l]){\n\t\t\t\t\tmemo[to][now_l-cost]=memo[now_v][now_l];\n\t\t\t\t\tq.push(PP(to,P(now_e,now_l-cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//?????????????????????\n\t\t\tif(memo[to][now_l]>=memo[now_v][now_l]+e_num){\n\t\t\t\tmemo[to][now_l]=memo[now_v][now_l]+e_num;\n\t\t\t\tq.push(PP(to,P(now_e+e_num,now_l)));\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tint ans=memo[n-1][0];\n\tfor(int i=1;i<=l;i++) ans=min(ans,memo[n-1][i]);\n\t\n\treturn ans;\n\t\n}\n\nint main()\n{\n\t\n\twhile(cin>>n>>m>>l,n){\t\t\n\t\t\t\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--; b--;\n\t\t\t\n\t\t\tedge[a].push_back(PP(b,P(d,e)));\n\t\t\tedge[b].push_back(PP(a,P(d,e)));\n\t\t\t\n\t\t}\n\t\tcout<<solve()<<endl;\n\t\t\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n\nstruct Edge {\n\tint to, cost, e;\n\tEdge(){}\n\tEdge(int to, int cost, int e): to(to), cost(cost), e(e){}\n};\n\nstruct State {\n\tint pos, l, sum;\n\tState(){}\n\tState(int pos, int l, int sum): pos(pos), l(l), sum(sum){}\n\tbool operator < (const State &t) const {\n\t\treturn sum > t.sum;\n\t}\n};\n\nvector<Edge> g[100];\nint dist[100][101];\n\nint n, m, L;\n\nint solve()\n{\n\tfill_n(*dist, 100 * 101, INF);\n\tdist[0][L] = 0;\n\t\n\tpriority_queue<State> pq;\n\tpq.push(State(0, L, 0));\n\twhile (pq.size()){\n\t\tState st = pq.top(); pq.pop();\n\t\tif (dist[st.pos][st.l] < st.sum) continue;\n\t\tfor (auto &e : g[st.pos]){\n\t\t\tif (dist[e.to][st.l] > st.sum + e.e){\n\t\t\t\tdist[e.to][st.l] = st.sum + e.e;\n\t\t\t\tpq.push(State(e.to, st.l, st.sum + e.e));\n\t\t\t}\n\t\t\tif (st.l >= e.cost && \n\t\t\t    dist[e.to][st.l - e.cost] > st.sum){\n\t\t\t\tdist[e.to][st.l - e.cost] = st.sum;\n\t\t\t\tpq.push(State(e.to, st.l - e.cost, st.sum));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint res = INF;\n\tfor (int i = 0; i <= 100; i++){\n\t\tres = min(res, dist[n - 1][i]);\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d %d\", &n, &m, &L), n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tg[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint a, b, d, e;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &d, &e);\n\t\t\ta--; b--;\n\t\t\tg[a].push_back(Edge(b, d, e));\n\t\t\tg[b].push_back(Edge(a, d, e));\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct edge\n {\n \tint to,cost,enemy;\n }; \n\n struct P\n {\n \tint from, money, enemy;\n \tbool operator >(const P &p) const{\n \t\treturn enemy>p.enemy;\n \t}\n };\n\nint main() {\n\tint N,M,L;\n\twhile(cin >> N >> M >> L, N|M|L){\n\t\tvector<vector<edge> > E=vector<vector<edge> >(N+1);\n\t\tREP(i, M){\n\t\t\tint from, to, cost, enemy;\n\t\t\tcin >> from >> to >> cost >> enemy;\n\t\t\tE[from].push_back((edge){to, cost, enemy});\n\t\t\tE[to].push_back((edge){from, cost, enemy});\n\t\t}\n\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tvector<int> costs=vector<int>(N+1);\n\t\tREP(i, costs.size()){\n\t\t\tcosts[i]=-1;\n\t\t}\n\n\t\tque.push((P){1, L, 0});\n\t\tint res=-1;\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.money<=costs[p.from])continue;\n\t\t\tcosts[p.from]=p.money;\n\t\t\tif(p.from==N){\n\t\t\t\tres=p.enemy;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcout << p.enemy<<\" \" << p.from<<\" \" << p.money << endl;\n\t\t\tREP(i, E[p.from].size()){\n\t\t\t\tedge e=E[p.from][i];\n\t\t\t\tif(p.money>=e.cost){\n\t\t\t\t\tque.push((P){e.to, p.money-e.cost,p.enemy});\n\t\t\t\t}\n\t\t\t\tque.push((P){e.to, p.money, p.enemy+e.enemy});\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int from;\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    return a.enemy>b.enemy;\n}\n\nstruct node maps[(int)1e8];\n\nint main()\n{\n    int n,m,l;\n\n    while ((cin>>n>>m>>l) && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            maps[a-1].data.push_back((struct data){b-1,d,e});\n            maps[b-1].data.push_back((struct data){a-1,d,e});\n        }\n        queue.push((struct state){0,0,l,0});\n        bool flag=true;\n        while (flag){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                cout<<s.enemy<<endl;\n                flag= false;\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.to!=s.from) {\n                        if (d.dis <= s.money) {\n                            queue.push((struct state) {s.number, d.to, s.money - d.dis, s.enemy});\n                        }\n                        queue.push((struct state) {s.number, d.to, s.money, s.enemy + d.ene});\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <set>\n#include <unordered_map>\n#include <limits>\n#include <map>\n#include <cassert>\n\nstruct Edge {\n  int from, to, distance, attack;\n};\n\nstruct Info {\n  int attacks, place, money;\n\n  friend bool operator >(Info const& lhs, Info const& rhs) {\n    if (lhs.attacks != rhs.attacks) {\n      return lhs.attacks > rhs.attacks;\n    }\n    if (lhs.money != rhs.money) {\n      return lhs.money < rhs.money;\n    }\n    return lhs.place > rhs.place;\n  }\n\n  friend bool operator <(Info const& lhs, Info const& rhs) {\n    return !(lhs > rhs);\n  }\n};\n\nint solve(int N, int M, int L) {\n  std::vector<std::vector<Edge>> adj_list(N);\n  for (int i = 0; i < M; i++) {\n    int f, t, d, e;\n    std::cin >> f >> t >> d >> e;\n    adj_list[f - 1].push_back(Edge{f - 1, t - 1, d, e});\n    adj_list[t - 1].push_back(Edge{t - 1, f - 1, d, e});\n  }\n\n  std::priority_queue<Info, std::vector<Info>, std::greater<Info>> queue;\n  std::set<Info> visited;\n  queue.push(Info{0, 0, L});\n  while (!queue.empty()) {\n    auto info = queue.top();\n    queue.pop();\n    if (visited.find(info) != visited.end()) {\n      continue;\n    }\n    visited.insert(info);\n    //std::cout << \"info: \" << info.attacks << \" \" << info.place << \" \" << info.money << std::endl;\n    if (info.place == N - 1) {\n      return info.attacks;\n    }\n    for (auto const& edge : adj_list[info.place]) {\n     if (edge.distance <= info.money) {\n       //std::cout << \"pushing: \" << info.attacks << \" \" << edge.to << \" \" << info.money - edge.distance << std::endl;\n       queue.push(Info{info.attacks, edge.to, info.money - edge.distance});\n     }\n     //std::cout << \"pushing: \" << info.attacks + edge.attack << \" \" << edge.to << \" \" << info.money << std::endl;\n     queue.push(Info{info.attacks + edge.attack, edge.to, info.money});\n    }\n  }\n  assert(false);\n}\n\nint main() {\n  int N, M, L;\n  while (std::cin >> N >> M >> L) {\n    if (N == 0 && M == 0 && L == 0) {\n      break;\n    }\n    std::cout << solve(N, M, L) << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n\nclass E{\npublic:\n  int to,dist,value;\n  E(int to,int dist,int value):to(to),dist(dist),value(value){}\n};\n\nconst int N = 111;\n\nint n,m,r;\nvector<E> edge[N];\n\nbool input(){\n  cin>>n>>m>>r;\n  if(n==0)return false;\n\n  rep(i,N)edge[i].clear();\n\n  rep(i,m){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    edge[a].push_back(E(b,c,d));\n    edge[b].push_back(E(a,c,d));\n  }\n\n  \n  return true;\n}\n\n\n\nclass Q{\npublic:\n  int pos;\n  int life;\n  int val;\n  Q(int a,int b,int c):pos(a),life(b),val(c){}\n  bool operator<(const Q& a)const{\n    if(val!=a.val) return val>a.val;\n    return life<a.life;\n  }\n};\n\nint visit[N][N];\n\nint solve(){\n  rep(i,N)rep(j,N)visit[i][j]=0;\n  //puts(\"hello\");\n\n  priority_queue<Q> que;\n  que.push(Q(1,r,0));\n\n  int ans = -1;\n  while(!que.empty()){\n    priority_queue<Q> cp = que;\n\n\n    Q u = que.top();\n    que.pop();\n\n    //printf(\"@@ %d %d %d   %d\\n\",u.pos,u.life,u.val, que.size());\n\n    if(visit[u.pos][u.life]==1)continue;\n    visit[u.pos][u.life]=1;\n\n    //printf(\"** %d %d %d\\n\",u.pos,u.life,u.val);\n\n    if(u.pos==n){\n      if(ans==-1 || ans>u.val)ans=u.val;\n      //return u.val;\n    }\n\n    rep(i,edge[u.pos].size()){\n      E e = edge[u.pos][i];\n      if(u.life-e.dist>=0)que.push(Q(e.to, u.life-e.dist, u.val));\n      que.push(Q(e.to, u.life, u.val+e.value));\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(input())cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct {\n\tint to;\n\tint D;\n\tint E;\n} Edge;\n\nclass State {\npublic:\n\n\tint now;\n\tint money;\n\tint damaged;\n\n\tState(int now, int money, int damaged) {\n\t\tthis->now = now;\n\t\tthis->money = money;\n\t\tthis->damaged = damaged;\n\t}\n\n};\n\nconst int INF  = 999999;\n\nvector<Edge> G[101];\n\nint d[101][101];\n\nint N, M, L;\n\nint toV(int n, int l) {\n\treturn n * L + l;\n}\n\nint main() {\n\twhile (cin >> N >> M >> L, N + M + L != 0) {\n\t\tqueue<State> q;\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tG[i].clear();\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint A, B, D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tEdge e { B, D, E };\n\t\t\tEdge e2 { A, D, E };\n\t\t\tG[A].push_back(e);\n\t\t\tG[B].push_back(e2);\n\t\t}\n\t\tq.push(State(1, L, 0));\n\t\twhile (!q.empty()){\n\t\t\tState s = q.front();\n\t\t\tq.pop();\n\t\t\tif (s.damaged > d[s.now][s.money]) continue;\n\t\t\td[s.now][s.money] = s.damaged;\n\t\t\t\n\t\t\tfor each (Edge e in G[s.now])\n\t\t\t{\n\t\t\t\tq.push(State(e.to, s.money, s.damaged + e.E));\n\t\t\t\tif (s.money - e.D >= 0) {\n\t\t\t\t\tq.push(State(e.to, s.money - e.D, s.damaged));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = INF;\n\t\tfor (int i = 0; i <= L; i++) {\n\t\t\tm = min(m, d[N][i]);\n\t\t}\n\t\tcout << m << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint x[150][150][2],n,m,l,a,b,c,d,i,j,k,o,minx,INF=1<<25,dp[150][150];\nint DP(int p,int v){\n    memset(dp,127,sizeof(dp));\n    dp[0][v]=0;\n    for(i=0;i<p;i++){\n        for(j=0;j<n;j++){\n            for(k=0;k<n;k++){\n                if(x[j][k][0]<INF){\n                    for(o=0;o<=v;o++){\n                        if(dp[j][o]<INF){\n                            dp[k][o]=min(dp[k][o],dp[j][o]+x[j][k][1]);\n                            if(o>=x[j][k][0]){\n                                dp[k][o-x[j][k][0]]=min(dp[k][o-x[j][k][0]],dp[j][o]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    minx=INF;\n    for(i=0;i<=v;i++){\n        minx=min(minx,dp[p-1][i]);\n    }\n    return minx;\n}\nmain(){\n    while(1){\n        memset(x,127,sizeof(x));\n        cin>>n>>m>>l;\n        if(!n){break;}\n        for(i=0;i<m;i++){\n            cin>>a>>b>>c>>d;\n            a--;\n            b--;\n            x[a][b][0]=c;\n            x[a][b][1]=d;\n            x[b][a][0]=c;\n            x[b][a][1]=d;\n        }\n        cout<<DP(n,l)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lld;\n\n#define INF (1<<20)\ntypedef pair< int , int > P;\ntypedef pair< int , P > Pi;\nstruct Edge {\n  int to,cost,des;\n  Edge(){}\n  Edge(int to,int cost,int des):to(to),cost(cost),des(des){};\n};\nvector< vector< Edge > > Graph;\nint V,E,L;\n\nint Dijkstra(int s,int g) {\n  int min_cost[111][111];\n  fill_n(*min_cost,111*111,INF);\n  priority_queue < Pi ,vector< Pi >,greater< Pi > > que;\n  que.push(Pi(0,P(L,s)));\n  min_cost[s][L] = 0;\n  while(!que.empty()){\n    int cost = que.top().first;\n    int des = que.top().second.first;\n    int now = que.top().second.second;\n    que.pop();\n    if(now == g) return cost;\n    if(cost > min_cost[now][des]) continue;\n    for(int i=0;i<Graph[now].size();i++){\n      Edge e = Graph[now][i];\n      if(des >= e.des && min_cost[e.to][des-e.des] > cost){\n\tmin_cost[e.to][des-e.des] = cost;\n\tque.push(Pi(cost,P(des-e.des,e.to)));\n      }\n      if(min_cost[e.to][des] > cost + e.cost){\n\tmin_cost[e.to][des] = cost + e.cost;\n\tque.push(Pi(min_cost[e.to][des],P(des,e.to)));\n      }\n    }\n  }\n  return (-1);\n}\n\nint main(){\n  while(cin >> V >> E >> L , (V||E||L)){\n    Graph.resize(V+1);\n    for(int i=0;i<E;i++){\n      int a,b,c,d;\n      cin >> a >> b >> c >> d;\n      a--; b--;\n      Graph[a].push_back(Edge(b,d,c));\n      Graph[b].push_back(Edge(a,d,c));\n    }\n    cout << Dijkstra(0,V-1) << endl;\n    Graph.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct edge {\n\tint to, dist, num;\n\tedge(int t, int d, int n):to(t), dist(d), num(n){}\n};\n\nstruct state {\n\tint pos, num, money;\n\tstate(int p, int n, int m):pos(p), num(n), money(m){}\n\tbool operator>(const state& s) const {\n\t\treturn num > s.num;\n\t}\n};\n\nvector<vector<edge> > es;\n\nint dijkstra(int s, int t, int l) {\n\tpriority_queue<state, vector<state>, greater<state> > que;\n\tvector<vector<int> > nums(es.size(), vector<int>(l + 1, INT_MAX));\n\tque.push(state(s, 0, l));\n\tnums[s][l] = 0;\n\t\n\twhile(!que.empty()) {\n\t\tstate s = que.top();\n\t\tque.pop();\n\t\tif(nums[s.pos][s.money] < s.num)\n\t\t\tcontinue;\n\n\t\tif(s.pos == t)\n\t\t\treturn s.num;\n\n\t\tfor(int i = 0; i < es[s.pos].size(); ++i) {\n\t\t\tconst edge& e = es[s.pos][i];\n\t\t\tif(nums[e.to][s.money] > nums[s.pos][s.money] + e.num) {\n\t\t\t\tnums[e.to][s.money] = nums[s.pos][s.money] + e.num;\n\t\t\t\tque.push(state(e.to, nums[e.to][s.money], s.money));\n\t\t\t}\n\n\t\t\tif(s.money >= e.dist && nums[e.to][s.money - e.dist] > nums[s.pos][s.money]) {\n\t\t\t\tnums[e.to][s.money - e.dist] = nums[s.pos][s.money];\n\t\t\t\tque.push(state(e.to, nums[e.to][s.money - e.dist], s.money - e.dist));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m, l; cin >> n >> m >> l, n;) {\n\t\tes.clear();\n\t\tes.resize(n);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\t--a;\n\t\t\t--b;\n\t\t\tes[a].push_back(edge(b, d, e));\n\t\t\tes[b].push_back(edge(a, d, e));\n\t\t}\n\n\t\tcout << dijkstra(0, n - 1, l) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n \nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n \nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push(make_pair(0, s));\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        int cost = st.first;\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push(make_pair[to], to));\n            }\n        }\n    }\n    return d;\n}\n \nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back(make_pair(e, vv(b, j)));\n                edge[vv(b, j)].push_back(make_pair(e, vv(a, j)));\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back(make_pair(0, vv(b, j - d)));\n                    edge[vv(b, j)].push_back(make_pair(0, vv(a, j - d)));\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n \n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n             \n            res = min(res,val);\n        }\n \n        cout << res << endl;\n    }\n    return 0;\n}\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    return a.enemy>b.enemy;\n}\n\nstruct node maps[100];\n\nint main()\n{\n    int n,m,l;\n\n    while ((cin>>n>>m>>l) && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n\n        for (int j = 0; j < 100; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            maps[a-1].data.push_back((struct data){b-1,d,e});\n            maps[b-1].data.push_back((struct data){a-1,d,e});\n        }\n        queue.push((struct state){0,l,0});\n        bool flag=true;\n        while (flag){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                cout<<s.enemy<<endl;\n                flag= false;\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.dis<=s.money){\n                        queue.push((struct state){d.to,s.money-d.dis,s.enemy});\n                    }\n                    queue.push((struct state){d.to,s.money,s.enemy+d.ene});\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// テ、ツクツ?ヲツ卍づ、ツソツ敕・ツュツ佚ァツ板ィ\n\n#include <iostream>\n#include <map>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n \n#define INF 1<<20\n#define MAX_V 101\n#define MAX_L 101\n \nstruct Edge{ int to, d, e; };\n\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> P;\n \nint V, M, L;\nint d[MAX_V][MAX_L];\nvector<Edge> G[MAX_V];\n \nint dijkstra(int s, int t) {\n  priority_queue<P> Q;\n  fill(d[0], d[MAX_V]+MAX_L, INF);\n  d[s][L] = 0;\n  Q.push( P( 0, Pii(-L, s) ) );\n \n  while(!Q.empty()) {\n    P p = Q.top(); Q.pop();\n    int c = p.first;\n    int l = -p.second.first;\n    int v = p.second.second;\n    \n    if( v == t ) return c;\n    \n    for(int i=0; i<G[v].size(); i++) {\n      Edge e = G[v][i];\n      if( l+e.d < 0 ) continue;\n      if(d[e.to][e.d+l] < d[v][l]) {\n\td[e.to][e.d+l] = d[v][l];\n\tQ.push(P(d[e.to][l+e.d], Pii(-(e.d+l), e.to)));\n      }\n    }\n  }\n \n  return -1;\n}\n \nint main() {\n   \n  cin >> V >> M >> L;\n  char dd;\n \n  for(int i=0; i<M; i++) {\n    int a, b, d, e;\n    cin >> a >> dd >> b >> dd >> d >> dd >> e;\n    a--, b--;\n    G[a].push_back( (Edge){b, d, e} );\n    G[b].push_back( (Edge){a, d, e} );\n  }\n   \n  cout << dijkstra(0, V-1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int n, m, l;\n    while(1){\n        cin >> n >> m >> l;\n        if(n == 0 && m == 0 && l == 0) break;\n        int touzoku[101][101] = {};\n        int money[101][101] = {};\n        int result[101];\n        memset(result, 1000000, sizeof(result));\n        for(int i = 0; i < m; i++){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            touzoku[a][b] = e;\n            touzoku[b][a] = e;\n            money[a][b] = d;\n            money[b][a] = d;\n        }\n        priority_queue<pair<int, pair<int, int> > > qu;\n        qu.push(make_pair(0, make_pair(0, 0)));\n        while(!qu.empty()){\n            int t = (qu.top()).first;\n            int nowtown = ((qu.top()).second).second;\n            int usedmoney = ((qu.top()).second).first;\n            // cout << t << \" \" << nowtown << \" \" << usedmoney << endl;\n            qu.pop();\n            // cout << result[nowtown] << \" \" << t << endl;\n            if(result[nowtown] <= t) continue;\n            // cout << \"hoge\" << endl;\n            result[nowtown] = t;\n            if(nowtown == n - 1) continue;\n            for(int i = 0; i < n; i++){\n                // cout << touzoku[nowtown][i] << endl;\n                if(touzoku[nowtown][i] != 0){\n                    if(usedmoney + money[nowtown][i] <= l){\n                        qu.push(make_pair(t, make_pair(usedmoney + money[nowtown][i], i)));\n                    }\n                    qu.push(make_pair(t + touzoku[nowtown][i], make_pair(usedmoney, i)));\n                }\n            }\n        }\n        cout << result[n - 1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct NODE{\n  vector<int> to_node;\n  vector<int> to_cost;\n  vector<int> to_man;\n  bool done_c;\n  bool done_m;\n  bool start;\n  int cost;\n  int man;\n  int nom;\n};\nint main(){\n  int n,m,l;\n  while(cin >>n>>m>>l,n|m|l){\n    NODE inn[100];\n    vector<int> ans;\n    while(m--){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      inn[a-1].to_node.push_back(b-1);\n      inn[a-1].to_cost.push_back(c);\n      inn[a-1].to_man.push_back(d);\n      inn[b-1].to_node.push_back(a-1);\n      inn[b-1].to_cost.push_back(c);\n      inn[b-1].to_man.push_back(d);\n    }\n    for(int i=0; i<n; i++){\n      inn[i].start = false;\n      inn[i].nom = 100000;\n    }\n    inn[0].nom = 0;\n    for(int i=0; i<n; i++){\n      int at = 0,pom = 1000000;\n      for(int j=0; j<n; j++){\n\tif((!(inn[j].start)) && pom>inn[j].nom){at = j; pom = inn[j].nom;}\n      }\n      inn[at].start = true;\n      for(int j=0; j<inn[at].to_node.size(); j++){\n\tint togo = inn[at].to_node[j];\n\tif(!inn[togo].start){inn[togo].nom = min(inn[at].to_man[j] + inn[at].nom,inn[togo].nom);}\n      }\n    }\n    for(int k=0; k<n; k++){\n      for(int i=0; i<n; i++){\n\tinn[i].cost = 100000;\n\tinn[i].done_c = false;\n      }\n      inn[k].cost = 0;\n      for(int i=0; i<n; i++){\n\tint at = 0,pom = 1000000;\n\tfor(int j=0; j<n; j++){\n\t  if((!(inn[j].done_c)) && pom>inn[j].cost){at = j; pom = inn[j].cost;}\n\t}\n\tinn[at].done_c = true;\n\tfor(int j=0; j<inn[at].to_node.size(); j++){\n\t  int togo = inn[at].to_node[j];\n\t  if(!inn[togo].done_c){inn[togo].cost = min(inn[at].to_cost[j] + inn[at].cost,inn[togo].cost);}\n\t}\n      }\n      for(int i=0; i<n; i++){\n\tinn[i].man = 100000;\n\tinn[i].done_m = false;\n      }\n      inn[k].cost = 0;\n      for(int i=0; i<n; i++){\n\tint at = 0,pom = 1000000;\n\tfor(int j=0; j<n; j++){\n\t  if((!(inn[j].done_m)) && pom>inn[j].man){at = j; pom = inn[j].man;}\n\t}\n\tinn[at].done_m = true;\n\tfor(int j=0; j<inn[at].to_node.size(); j++){\n\t  int togo = inn[at].to_node[j];\n\t  if(!inn[togo].done_m){inn[togo].man = min(inn[at].to_man[j] + inn[at].man,inn[togo].man);if(inn[togo].cost<=l){inn[togo].man = 0;}}\n\t}\n      }\n      ans.push_back(inn[k].nom + inn[n-1].man);\n    }\n    sort(ans.begin(),ans.end());\n    cout <<ans[0]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF (1<<9)\n\nstruct P {\n    int from, money, damage;\n\n    bool operator >(const P& p) const {\n        return damage > p.damage;\n    }\n};\n\nstruct edge {\n    int from, cost, damage;\n};\n\nint main() {\n    int town_n, road_n, money;\n    while (cin >> town_n >> road_n >> money, town_n|road_n|money) {\n        vector<vector<edge>> E(town_n+1);\n        REP(i, road_n) {\n            int to, from, cost, damage;\n            cin >> to >> from >> cost >> damage;\n            E[to].push_back({from, cost, damage});\n            E[from].push_back({to, cost, damage});\n        }\n\n        bool G[town_n+1][money+1];\n        fill_n((bool *)G, (town_n+1)*(money+1), false);\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({1, money, 0});\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            if (p.from == town_n) {\n                cout << p.damage << endl;\n                break;\n            }\n\n            if (!G[p.from][p.money]) {\n                G[p.from][p.money] = true;\n                for (edge e : E[p.from]) {\n                    if (p.money >= e.cost) {\n                        que.push({e.from, p.money - e.cost, p.damage});\n                    }\n                    que.push({e.from, p.money, p.damage + e.damage});\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\n//adjlist[A].first ===== コスト！\n\nvector<int> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\n\nint main(){\n\n    while(1){\n        int n, m, l; cin >> n >> m >> l;\n        if(!n) break;\n        vector<vector<pair<int, int> > > adjlist(10001);\n\n        for(int i = 0; i < m; i++){\n            int a, b, d, e; cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            //護衛を雇わないとき\n            for(int j = 0; j <= l; j++){\n                int A = a + j * 100;\n                int B = b + j * 100;\n                adjlist[A].push_back({e, B});\n                adjlist[B].push_back({e, A});\n                //cout << A << \" \" << B << \" \" << e << endl;            \n            }\n\n            //護衛を雇うとき\n            for(int j = l; j - d >= 0; j--){\n                int A = a + j * 100;\n                int B = b + (j - d) * 100;\n                adjlist[A].push_back({0, B});\n                //cout << A << \" \" << B << \" \" << 0 << endl;                            \n                A = b + j * 100;\n                B = a + (j - d) * 100;\n                adjlist[A].push_back({0, B});     \n                //cout << A << \" \" << B << \" \" << 0 << endl;                                       \n            }\n        }\n\n        vector<int> result(10001);\n        result = dijk(100 * l, 10001, adjlist);\n        //cout << result[G] << endl;\n\n        /*for(int i = 0; i < 10001; i++){\n            cout << i << \": \" << result[i] << endl;\n        }*/\n        int ans = INF;\n        for(int i = 0; i <= l; i++){\n            //cout << n - 1 + 100 * i << \" \" << result[n - 1 + 100 * i] << endl;\n            ans = min(ans, result[n - 1 + i * 100]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nint n;\nint dist[101][101];\nint atk[101][101];\nint memo[101][101]; //memo[i][j] : ??????j??§?????????i???????????¨??????????°??\\???\\?????°\nbool used[101][101];\nconst int INF = 1000000000;\n\nstruct V{\n  int p,m;\n  V(int p,int m):p(p),m(m){}\n};\n\nbool operator < (const V& a,const V& b){\n  return memo[a.p][a.m] > memo[b.p][b.m];\n}\n\nint solve(int s,int l){\n  for(int i=0;i<=100;++i)\n    for(int j=0;j<=100;++j){\n      used[i][j]=false;\n      memo[i][j]=INF;\n    }\n  \n  memo[s][l] = 0;\n  priority_queue<V> Q;\n  Q.push(V(s,l));\n\n  while(!Q.empty()){\n    V x=Q.top(); Q.pop();\n    int cur = x.p, mon = x.m, cst=memo[cur][mon];\n    //    if(used[cur][mon]) continue;\n    //    used[cur][mon] = true;\n    for(int i=0;i<n;++i){\n      if(dist[cur][i]){\n\tif(cst+atk[cur][i] < memo[i][mon]){\n\t  memo[i][mon] = cst+atk[cur][i];\n\t  Q.push(V(i,mon));\n\t}\n\tif(mon-dist[cur][i]>=0){\n\t  if(memo[i][mon-dist[cur][i]] > cst){\n\t    memo[i][mon-dist[cur][i]] = cst;\n\t    Q.push(V(i,mon-dist[cur][i]));\n\t  }\n\t}\n      }\n    }\n  }\n\n  int ret = INF;\n  for(int i=0;i<=l;++i) ret = min(ret, memo[n-1][i]);\n  return ret;\n}\nint main(){\n  int m,l;\n  while(cin>>n>>m>>l,n||m||l){\n    memset(dist,0,sizeof(dist));\n    memset(atk,0,sizeof(atk));\n    while(m--){\n      int a,b,d,e;\n      cin >> a >> b >> d >> e;\n      a--;b--;\n      dist[a][b] = dist[b][a] = d;\n      atk[a][b] = atk[b][a] = e;\n    }\n    cout<<solve(0,l)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#define INF 10000000\n#define MN 101\nusing namespace std;\ntypedef long long ll;\n\ntypedef struct P\n{\n\tint pos,mon,eve;\n\tbool operator <(const P &a)const{ return eve<a.eve;};\n}P;\ntypedef struct E{int to,cost,eve;}E;\n\nint N,M,L;\nint amb[MN][MN];\nvector<E> G[MN];\n\nint bfs(int s,int t,int y)\n{\n\tint r=INF;\n\tpriority_queue<P>Q;\n\tmemset(amb,0x7f,sizeof(amb));\n\tamb[s][y]=0;\n\tP p={s,y,0};\n\tQ.push(p);\n\tfor(;!Q.empty();)\n\t{\n\t\tp=Q.top();Q.pop();\n\t\tif(p.pos==t)\n\t\t{\n\t\t\tr=min(r,p.eve);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<G[p.pos].size();i++)\n\t\t{\n\t\t\tE np=G[p.pos][i];\n\t\t\tif(amb[np.to][p.mon]>p.eve+np.eve)//not gard\n\t\t\t{\n\t\t\t\tamb[np.to][p.mon]=p.eve+np.eve;\n\t\t\t\tP ins={np.to,p.mon,amb[np.to][p.mon]};\n\t\t\t\tQ.push(ins);\n\t\t\t}\n\t\t\tif(p.mon>=np.cost&&amb[np.to][p.mon-np.cost]>p.eve)//hire gard\n\t\t\t{\n\t\t\t\tamb[np.to][p.mon-np.cost]=p.eve;\n\t\t\t\tP ins={np.to,p.mon-np.cost,amb[np.to][p.mon-np.cost]};\n\t\t\t\tQ.push(ins);\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d%d\",&N,&M,&L),N+M+L;)\n\t{\n\t\tfor(int i=0;i<MN;i++)G[i].clear();\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tint s,t,l,e;\n\t\t\tscanf(\"%d%d%d%d\",&s,&t,&l,&e);\n\t\t\ts--;t--;\n\t\t\tE tmp={t,l,e};\n\t\t\tG[s].push_back(tmp);\n\t\t\ttmp.to=s;\n\t\t\tG[t].push_back(tmp);\n\t\t}\n\t\tprintf(\"%d\\n\",bfs(0,N-1,L));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, L;\n\nstruct State {\n    int v, sum, dist;\n    State(int v, int sum, int dist) : v(v), sum(sum), dist(dist) {}\n    bool operator<(const State& a) const {\n        return dist > a.dist;\n    }\n};\n\nstruct edge {\n    int to, money, enemy;\n    edge(int to, int money, int enemy):to(to),money(money),enemy(enemy){}\n};\n\nvector<edge> G[101];\nint d[101][101];\n\nvoid dijkstra(int s)\n{\n    for (int i = 0; i <= 100; ++i) for (int j = 0; j < N; ++j) d[i][j] = inf;\n\n    priority_queue<State> q;\n    q.push(State(s, 0, 0));\n\n    d[0][s] = 0;\n\n    while (q.size()) {\n        State st = q.top(); q.pop();\n\n        if (d[st.sum][st.v] < st.dist) continue;\n\n        for (int i = 0; i < G[st.v].size(); ++i) {\n            edge e = G[st.v][i];\n\n            if (st.sum + e.money <= L && d[st.sum + e.money][e.to] > st.dist) {\n                d[st.sum + e.money][e.to] = st.dist;\n                q.push(State(e.to, st.sum + e.money, d[st.sum + e.money][e.to]));\n            }\n\n            if (d[st.sum][e.to] > st.dist + e.enemy) {\n                d[st.sum][e.to] = st.dist + e.enemy;\n                q.push(State(e.to, st.sum, d[st.sum][e.to]));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    while (scanf(\"%d%d%d\", &N, &M, &L), N) {\n        for (int i = 0; i < N; ++i) G[i].clear();\n\n        for (int i = 0; i < M; ++i) {\n            int A, B, D, E;\n            scanf(\"%d%d%d%d\", &A, &B, &D, &E);\n            A--, B--;\n            G[A].push_back(edge(B, D, E));\n            G[B].push_back(edge(A, D, E));\n        }\n\n        dijkstra(0);\n\n        int mi = inf;\n\n        for (int i = 0; i <= 100; ++i) {\n            chmin(mi, d[i][N - 1]);\n        }\n\n        printf(\"%d\\n\", mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\nusing P = pair<int, int>;\nusing Pip = pair<int, P>;\n\nstruct edge {\n  int to, d, e;\n  edge(int to, int d, int e): to(to), d(d), e(e) {}\n};\n\nint N, M, L;\nvector<edge> G[101];\n\nint dij() {\n  bool used[101][101];\n  fill_n(*used, 101*101, false);\n  priority_queue<Pip, vector<Pip>, greater<Pip> > Q;\n  Q.push(Pip(0, P(0, L)));\n  while ( !Q.empty() ) {\n    Pip p = Q.top(); Q.pop();\n    int cost = p.first, v = p.second.first, l = p.second.second;\n\n    if ( v == N-1 ) return cost;\n\n    if ( used[v][l] ) continue;\n    used[v][l] = true;\n\n    for ( edge e: G[v] ) {\n      if ( e.d <= l ) {\n\tQ.push(Pip(cost, P(e.to, l-e.d)));\n      }\n      Q.push(Pip(cost+e.e, P(e.to, l)));\n    }\n  }\n\n  assert(0);\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while ( cin >> N >> M >> L, N ) {\n    for ( int i = 0; i < 101; i++ ) G[i].clear();\n    for ( int i = 0; i < M; i++ ) {\n      int a, b, d, e;\n      cin >> a >> b >> d >> e;\n      a--; b--;\n      G[a].push_back(edge(b, d, e));\n      G[b].push_back(edge(a, d, e));\n    }\n    \n    cout << dij() << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151*/\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct data{\n    int to;\n    int dis;\n    int ene;\n};\n\nstruct node{\n    vector<struct data> data;\n    bool goal;\n};\n\nstruct state{\n    int from;\n    int number;\n    int money;\n    int enemy;\n};\n\ninline bool operator > (const struct state &a,const state &b)\n{\n    if(a.enemy==b.enemy){\n        return a.money < b.money;\n    }else {\n        return a.enemy > b.enemy;\n    }\n}\n\nstruct node maps[200];\n\nint main()\n{\n    int n,m,l;\n\n    cin.tie();\n    ios::sync_with_stdio(false);\n    while (scanf(\"%d%d%d\",&n,&m,&l)==3 && (n>0 || m>0 || l>0)){\n        priority_queue< struct state , vector<struct state> , greater<struct state> > queue;\n\n        for (int j = 0; j < 200; ++j) {\n            maps[j].data.clear();\n            if(j==n-1) {\n                maps[j].goal = true;\n            }else{\n                maps[j].goal = false;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int a,b,d,e;\n\n            cin>>a>>b>>d>>e;\n            a--;\n            b--;\n            maps[a].data.push_back((struct data){b,d,e});\n            maps[b].data.push_back((struct data){a,d,e});\n        }\n        queue.push((struct state){0,0,l,0});\n        while (!queue.empty()){\n            struct state s=queue.top();\n            queue.pop();\n            if(maps[s.number].goal){\n                printf(\"%d\\n\",s.enemy);\n                while (!queue.empty()){\n                    queue.pop();\n                }\n            }else{\n                for(struct data d: maps[s.number].data){\n                    if(d.to!=s.from) {\n                        if (d.dis <= s.money) {\n                            queue.push((struct state) {s.number, d.to, s.money - d.dis, s.enemy});\n                        }\n                        queue.push((struct state) {s.number, d.to, s.money, s.enemy + d.ene});\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n\nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n\nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push(make_pair(0, s));\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        int cost = st.first;\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push(make_paird[to], to));\n            }\n        }\n    }\n    return d;\n}\n\nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back(make_pair(e, vv(b, j)));\n                edge[vv(b, j)].push_back(make_piar(e, vv(a, j)));\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back(make_pair(0, vv(b, j - d)));\n                    edge[vv(b, j)].push_back(make_pair(0, vv(a, j - d)));\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n\n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n            \n            res = min(res,val);\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, deque<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t}\n\t\n\titr++;\n\tint min = b+1;\n\t\n\twhile( itr != points[i].end() ) {\t\t\t\t\t\t\t\t\t\n\t\tif ((*itr).second > min) {\n\t\t\t(*itr).second = min;\n\t\t} else {\n\t\t\tmin = (*itr).second+1;\n\t\t}\n\t\titr++;\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, deque<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\nstruct edge{\n  int to, cost, num;\n};\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;//num, cost, vertex\nint main(){\n  int n, m, l;\n  while(cin >> n >> m >> l, n){\n    priority_queue<piii, vector<piii>, greater<piii> > que;\n    vector<vector<edge> >G(n + 1);\n    int dp[n + 1][l + 1];\n    for(int i = 0; i <= n; i++){\n      for(int j = 0; j <= l; j++){\n\tdp[i][j] = 1e9;\n      }\n    }\n    for(int i = 0; i < m; i++){\n      edge e;\n      int from;\n      cin >> from >> e.to >> e.cost >> e.num;\n      G[e.to].push_back((edge){from, e.cost, e.num});\n      G[from].push_back(e);\n    }\n    dp[1][l] = 0;\n    que.push(mp(0, mp(l, 1)));\n    while(!que.empty()){\n      piii tmp = que.top();que.pop();\n      int num = tmp.first;\n      int c = tmp.second.first;\n      int v = tmp.second.second;\n      for(int i = 0; i < G[v].size(); i++){\n\tint nv = G[v][i].to;\n\tif(dp[nv][c] > num + G[v][i].num){\n\t  dp[nv][c] = num + G[v][i].num;\n\t  que.push(mp(dp[nv][c], mp(c, nv)));\n\t}\n\tif(c - G[v][i].cost >= 0 &&\n\t   dp[nv][c - G[v][i].cost] > num){\n\t  dp[nv][c - G[v][i].cost] = num;\n\t  que.push(mp(num, mp(c - G[v][i].cost, nv)));\n\t}\n      }\n    }\n    int ans = 1e9;\n    for(int i = 0; i <= l; i++){\n      ans = min(ans, dp[n][i]);\n    }\n    // for(int i = 0; i <=n; i++){\n    //   for(int j = 0; j <=l; j++){\n    // \tif(dp[i][j] == 1e9){\n    // \t  printf(\"INF \");\n    // \t  continue;\n    // \t}\n    // \tprintf(\"%3d \", dp[i][j]);\n    //   }\n    //   cout << endl;\n    // }\n    // cout << endl;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n \nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint n,m,l;\nvector<vector<PP> > edge;\n\n\nint solve()\n{\n\t\n\t//??????i??§?????????j????????????????????°\n\tvector<vector<int> > memo(n,vector<int>(l+1,1000));\n\t\n\tfor(int i=0;i<=l;i++) memo[0][i]=0;\n\t\n\tpriority_queue<PP,vector<PP>,greater<PP> > q;\n\t\n\t//?????¨??°0,??????0,?????????l\n\tq.push(PP(0,P(0,l)));\n\t\n\twhile(!q.empty()){\n\t\tPP tmp=q.top(); q.pop();\n\t\t\n\t\tint now_v=tmp.first;\n\t\tint now_e=tmp.second.first;\n\t\tint now_l=tmp.second.second;\n\t\t\t\t\t\t\t\t\n\t\tfor(int i=0;i<edge[now_v].size();i++){\n\t\t\tint to=edge[now_v][i].first;\n\t\t\tint e_num=edge[now_v][i].second.second;\n\t\t\tint cost=edge[now_v][i].second.first;\n\n\t\t\t//???????????????\n\t\t\tif(now_l>=cost){\n\t\t\t\tif(memo[to][now_l-cost]>memo[now_v][now_l]){\n\t\t\t\t\tmemo[to][now_l-cost]=memo[now_v][now_l];\n\t\t\t\t\tq.push(PP(to,P(now_e,now_l-cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//?????????????????????\n\t\t\tif(memo[to][now_l]>memo[now_v][now_l]+e_num){\n\t\t\t\tmemo[to][now_l]=memo[now_v][now_l]+e_num;\n\t\t\t\tq.push(PP(to,P(now_e+e_num,now_l)));\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tint ans=memo[n-1][0];\n\tfor(int i=1;i<=l;i++) ans=min(ans,memo[n-1][i]);\n\t\n\treturn ans;\n\t\n}\n\nint main()\n{\n\t\n\twhile(cin>>n>>m>>l,n){\t\t\n\t\t\t\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\ta--; b--;\n\t\t\t\n\t\t\tedge[a].push_back(PP(b,P(d,e)));\n\t\t\tedge[b].push_back(PP(a,P(d,e)));\n\t\t\t\n\t\t}\n\t\tcout<<solve()<<endl;\n\t\t\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<string.h>\nstruct S{int i,c,m;S(int i,int c,int m):i(i),c(c),m(m){}bool operator<(const S&r)const{return c>r.c;}};\n#define C(d) memset(d,X,sizeof(d))\nint main()\n{\n\tint N,M,L,A,B,D,E,X=0x7f7f7f7f;\n\tint d[100][100],e[100][100],x[100][101],i;\n\twhile(scanf(\"%d%d%d\",&N,&M,&L),N)\n\t{\n\t\tC(d),C(e),C(x);\n\t\twhile(M--)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&A,&B,&D,&E);\n\t\t\tA--,B--;\n\t\t\td[A][B]=d[B][A]=D;\n\t\t\te[A][B]=e[B][A]=E;\n\t\t}\n\t\tstd::priority_queue<S>q;\n\t\tq.push(S(0,0,L));\n\t\tfor(;;)\n\t\t{\n\t\t\tS p(q.top());q.pop();\n\t\t\tif(x[p.i][p.m]<=p.c)continue;\n\t\t\tif(p.i==N-1){printf(\"%d\\n\",p.c);break;}\n\t\t\tx[p.i][p.m]=p.c;\n\t\t\tfor(i=0;i<N;++i)\n\t\t\t{\n\t\t\t\tif(d[p.i][i]==X)continue;\n\t\t\t\tif(d[p.i][i]<=p.m)q.push(S(i,p.c,p.m-d[p.i][i]));\n\t\t\t\tq.push(S(i,p.c+e[p.i][i],p.m));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define INF 1111111111\n#define F first\n#define S second\n\nstruct edge {\n  int to, cost, thief;\n  edge(int _to, int _cost, int _thief) {to=_to; cost=_cost; thief=_thief;}\n};\ntypedef pair<int, int> PI;\ntypedef pair<int, PI> P;\n\nint n, m, l;\nvector<edge> G[128];\nint d[128][128];\n\nvoid dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[0], d[0] + 128 * 128, INF);\n  d[l][s] = 0;\n  que.push(P(l, PI(0, s)));\n\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int v = p.S.S, w = p.F;\n    if(d[w][v] < p.S.F) continue;\n    for(int i = 0;i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[w][e.to] > d[w][v] + e.thief){\n\td[w][e.to] = d[w][v] + e.thief;\n\tque.push(P(w, PI(d[w][e.to],e.to)));\n      }\n      if(w >= e.cost && d[w-e.cost][e.to] > d[w][v]){\n\td[w-e.cost][e.to] = d[w][v];\n\tque.push(P(w-e.cost, PI(d[w-e.cost][e.to],e.to)));\n      }\n    }\n  }\n}\n\nint main(void){\n  int A, B, D, E;\n  for( ; ; ){\n    scanf(\"%d %d %d\", &n, &m, &l);\n    if(!(n + m + l)) break;\n    for(int i = 0;i <= n; i++) G[i].clear();\n    for(int i = 0;i < m; i++){\n      scanf(\"%d %d %d %d\", &A, &B, &D, &E);\n      G[A].push_back(edge(B,D,E));\n      G[B].push_back(edge(A,D,E));\n    }\n\n    dijkstra(1);\n    int ans = INF;\n    for(int i = 0;i <= l; i++) ans = min(ans, d[i][n]);\n    printf(\"%d\\n\", ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to, length, num;\n};\n\nint main(){\n    int n, m, l;\n    while(cin >> n >> m >> l, n+m+l){\n        vector<vector<int>> dp(n, vector<int>(l+1, 1<<30));\n        vector<Edge> v[n];\n        for(int i = 0; i < m; i++){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            v[a].push_back(Edge({b, d, e}));\n            v[b].push_back(Edge({a, d, e}));\n        }\n        dp[0][l] = 0;\n        priority_queue<pair<int, pii>> pq;\n        pq.push({-0, {0, l}});\n        while(!pq.empty()){\n            auto p = pq.top();  pq.pop();\n            int cost = -p.first, now = p.second.first, res = p.second.second;\n            if(dp[now][res] != cost)    continue;\n            if(now == n-1){\n                cout << dp[now][res] << endl;\n                break;\n            }\n            for(Edge e : v[now]){\n                if(dp[e.to][res] > cost+e.num){\n                    dp[e.to][res] = cost+e.num;\n                    pq.push({-dp[e.to][res], {e.to, res}});\n                }\n                int nres = res-e.length;\n                if(nres < 0)  continue;\n                if(dp[e.to][nres] > cost){\n                    dp[e.to][nres] = cost;\n                    pq.push({-dp[e.to][nres], {e.to, nres}});\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<numeric>\n#include<vector>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define rforeach(t,p) for(t::reverse_iterator it=p.rbegin();it!=p.rend();++it)\n#define all(p) p.begin(),p.end()\nusing namespace std;\n\nstruct hoge{\nhoge(int a,int b,int c,int d):enemy(a),money(b),position(c),old(d){}\n    int enemy;\n    int money;\n    int position;\n    int old;\n\n\n};\n\nbool operator<(const hoge& left, const hoge& right)\n{\n  return left.enemy < right.enemy ;\n}\n\n\n\n#define LOAD 110\n\n\nint main()\n{\n    int n,m,l;\n    while(cin >> n >> m >> l && (n || m|| l))\n    {\n        int len[LOAD][LOAD],thi[LOAD][LOAD];\n        for(int i=0;i<LOAD;i++)for(int j=0;j<LOAD;j++)\n        {\n            len[i][j]=len[j][i]=thi[i][j]=thi[j][i]=-1;   \n        }\n        for(int i=0;i<m;i++)\n        {\n            int a,b,c,d;\n            cin >> a>>b>>c>>d;\n            len[a][b]=len[b][a]=c;\n            thi[a][b]=thi[b][a]=d;\n        }\n        set<hoge> in;\n        in.insert(hoge(0,l,1,1));\n        \n        while(true)\n        {\n            hoge a=(*in.begin());\n            in.erase(in.begin());\n            int e=a.enemy;\n            int mon=a.money;\n            int pos=a.position;\n            if(pos==n){cout << e << endl;break;}\n            for(int i=2;i<n+1;i++)if((len[pos][i] != -1 )&&(a.old!=i))\n            {\n                in.insert(hoge(e+thi[pos][i],mon,i,pos));\n                if(mon+1 >len[pos][i])\n                    in.insert(hoge(e,mon-len[pos][i],i,pos));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint main(void){\n\tint n, m, l, a, b, d[100][100], e[100][100], f[100][101], i, j, k, x, y, z, mn;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&l);\n\t\tif(n + m + l == 0) break;\n\t\tmemset(d,-1,sizeof(d));\n\t\tmemset(e,-1,sizeof(e));\n\t\tfor(i = 0;i < m;i++){\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&j,&k);\n\t\t\td[a - 1][b - 1] = j;\n\t\t\td[b - 1][a - 1] = j;\n\t\t\te[a - 1][b - 1] = k;\n\t\t\te[b - 1][a - 1] = k;\n\t\t}\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[0][l] = 0;\n\t\tque.push(PP(0,P(l,0))); // 敵との合流回数 お金 町の番号\n\t\twhile(que.size()){\n\t\t\tx = que.top().first, y = que.top().second.first, z = que.top().second.second;\n\t\t\tque.pop();\n\t\t\tfor(i = 0;i < n;i++){\n\t\t\t\tif(d[z][i] != -1){\n\t\t\t\t\tif(y >= d[z][i] && (f[i][y - d[z][i]] == -1 || f[i][y - d[z][i]] > f[z][y])){\n\t\t\t\t\t\tque.push(PP(x,P(y - d[z][i],i)));\n\t\t\t\t\t\tf[i][y - d[z][i]] = x;\n\t\t\t\t\t}\n\t\t\t\t\tif(f[i][y] == -1 || f[i][y] > x + e[z][i]){\n\t\t\t\t\t\tque.push(PP(x + e[z][i],P(y,i)));\n\t\t\t\t\t\tf[i][y] = x + e[z][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmn = 0x7FFFFFFF;\n\t\tfor(i = 0;i <= l;i++)\n\t\t\tif(f[n - 1][i] != -1) mn = min(mn,f[n - 1][i]);\n\t\tprintf(\"%d\\n\",mn);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<int> loc_smallest_damages(N+1, INT_MAX);\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n            if (loc_smallest_damages[current.loc] <= current.damage) {\n                continue;\n            }\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (e.dist <= current.money) {\n                    pq.push({e.to, current.money - e.dist, current.damage});\n                }\n                // 護衛を雇わない\n                pq.push({e.to, current.money, current.damage + e.enemy});\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define MAX 110\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nstruct Node{\n  int p, dist, cost;\n  Node(int _p, int _dist, int _cost){\n    p = _p;\n    dist = _dist;\n    cost = _cost;\n  }\n};\n\nint N, M, L;\nvector<Node> v[MAX];\n\nint bfs(){\n  int used[MAX][MAX];\n  rep(i, MAX){\n    rep(j, MAX){\n      used[i][j] = (1<<29);\n    }\n  }\n  queue<Node> q;\n  q.push( Node(0, L, 0) );\n  \n  while(!q.empty()){\n    Node t = q.front(); q.pop();\n    \n    if(t.cost >= used[t.p][t.dist]) continue;\n    \n    used[t.p][t.dist] = t.cost;\n    \n    rep(i, v[t.p].size()){\n      Node next = v[t.p][i];\n      if(t.dist >= next.dist){\n\tq.push( Node(next.p, t.dist - next.dist, t.cost) );\n      }\n      q.push( Node(next.p, t.dist, t.cost + next.cost) );\n    }\n  }\n  \n  int ans = (1<<29);\n  rep(i, MAX){\n    ans = min(ans, used[N-1][i]);\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> N >> M >> L, N|M|L){\n    rep(i, MAX) v[i].clear();\n    int a, b, c, d;\n    for(int i = 0 ; i < M ; i++){\n      cin >> a >> b >> c >> d;\n      a--, b--;\n      v[a].push_back( Node(b, c, d) );\n      v[b].push_back( Node(a, c, d) );\n    }\n    \n    cout << bfs() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, pair<int, int> > E; //(dest, (dist, cost))\ntypedef pair<int, pair<int, int> > Elem; //(-cost, (pos, money))\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n\nint main() {\n    int n,m,l;\n    while(cin >> n >> m >> l, n) {\n        vector<E> G[n];\n        rep(i,m) {\n            int a,b,d,e;\n            cin >> a >> b >> d >> e;\n            a--,b--;\n            G[a].push_back(make_pair(b, make_pair(d,e)));\n            G[b].push_back(make_pair(a, make_pair(d,e)));\n        }\n\n        priority_queue<Elem> q;\n        q.push(make_pair(0, make_pair(0, l)));\n        while (!q.empty()) {\n            Elem e = q.top();\n            int cost = -e.first;\n            int pos = e.second.first;\n            int money = e.second.second;\n            q.pop();\n            \n            if (money < 0)continue;\n            if (pos == n - 1) {\n                cout << cost << endl;\n                break;\n            }\n            rep(i, G[pos].size()) {\n                E edge = G[pos][i];\n                int dest = edge.first;\n                int dist = edge.second.first;\n                int num = edge.second.second;\n                q.push(make_pair(-cost, make_pair(dest, money - dist)));\n                q.push(make_pair(-(cost + num), make_pair(dest, money)));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {}\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min = b;\n\t\twhile ( itr != points[i].end() ) {\n\t\t\tif ( (*itr).second > min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t} else if ( (*itr).second <= min ) {\n\t\t\t\t(*itr).second = min;\n\t\t\t}\n\t\t\tmin++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t\t\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct inn{\n\tint n,c,r;\n\tinn(int n,int c,int r):n(n),c(c),r(r){}\n\tbool operator<(const inn& other)const{\n\t\treturn r<other.r;\n\t}\n};\nconst int MAX=INT_MAX/10;\nint main(){\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n){\n\t\tvvi dist(n,vi(n,-1));\n\t\tvvi risk(n,vi(n,MAX));\n\t\tREP(i,m){\n\t\t\tint a,b,d,e;\n\t\t\tcin>>a>>b>>d>>e;\n\t\t\tdist[a-1][b-1]=d;\n\t\t\tdist[b-1][a-1]=d;\n\t\t\trisk[a-1][b-1]=e;\n\t\t\trisk[b-1][a-1]=e;\n\t\t}\n\t\t\n\t\tqueue<inn> q;\n\t\tq.push(inn(0,0,0));\n\t\tvvi cost(n,vi(l+1,MAX));\n\t\tcost[0][0]=0;\n\t\twhile(!q.empty()){\n\t\t\tinn in=q.front();q.pop();\n\t\t\tif(cost[in.n][in.c]<in.r){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(i,n){\n\t\t\t\tif(i!=in.n&&dist[in.n][i]!=-1){\n\t\t\t\t\tREP(j,2){\n\t\t\t\t\t\tint nr=in.r+(j==1?0:risk[in.n][i]);\n\t\t\t\t\t\tint nc=in.c+(j==0?0:dist[in.n][i]);\n\t\t\t\t\t\tif(nc<=l&&cost[i][nc]>nr){\n\t\t\t\t\t\t\tcost[i][nc]=nr;\n\t\t\t\t\t\t\tq.push(inn(i,nc,nr));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint best=INT_MAX;\n\t\tREP(i,l+1){\n\t\t\tbest=min(best,cost[n-1][i]);\n\t\t}\n\t\tcout<<best<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const int INF=1<<24;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\n\n\n\n\n\nstruct E{\n\tint v,l,thief;\n};\n\nint N,M,L;\nvector<vector<E> > a;\npriority_queue<E> pq;\nint dp[110][110];\n\nbool operator < (E a,E b){\n\treturn a.thief>b.thief;\n}\n\n\nint dij(){\n\trep(i,110) rep(j,110) dp[i][j]=INF;\n\tE tmp;\n\ttmp.v=0;\n\ttmp.l=0;\n\ttmp.thief=0;\n\tpq.push(tmp);\n\tdp[0][0]=0;\n\tint ans=INF;\n\twhile(!pq.empty()){\n\t\tE now = pq.top();\n\t\t//cout<<now.v<<\" \"<<now.l<<\" \"<<now.thief<<endl;\n\t\tpq.pop();\n\t\tif(now.v==N-1){\n\t\t\tif(now.l<=L) ans=min(ans,now.thief);\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,a[now.v].size()){\n\t\t\tE next = a[now.v][i];\n\t\t\t//雇う\n\t\t\tif(next.l+now.l<=105){\n\t\t\t\tif(now.thief<dp[next.l+now.l][next.v]){\n\t\t\t\t\t// if(next.l+now.l>110) cout<<\"hoge \"<<dp[next.l+now.l][next.v]<<\" \"<<next.l+now.l<<endl; \n\t\t\t\t\tdp[next.l+now.l][next.v]=now.thief;\n\t\t\t\t\t// cout<<\"dp \"<<dp[next.l+now.l][next.v]<<\" \"<<next.l+now.l<<\" \"<<next.v<<endl;\n\t\t\t\t\tE t1=next;\n\t\t\t\t\tt1.l+=now.l;\n\t\t\t\t\tt1.thief=now.thief;\n\t\t\t\t\tpq.push(t1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//雇わない\n\t\t\tif(now.thief+next.thief<dp[now.l][next.v]){\n\t\t\t\tdp[now.l][next.v]=now.thief+next.thief;\n\t\t\t\t// cout<<\"dp \"<<dp[now.l][next.v]<<\" \"<<now.l<<\" \"<<next.v<<endl;\n\t\t\t\tE t1=next;\n\t\t\t\tt1.l=now.l;\n\t\t\t\tt1.thief+=now.thief;\n\t\t\t\tpq.push(t1);\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\twhile(cin>>N>>M>>L,N||M||L){\n\t\ta.resize(N);\n\t\trep(i,N) a.clear();\n\t\trep(i,M){\n\t\t\tint b,c,l,thi;\n\t\t\tcin>>b>>c>>l>>thi;\n\t\t\tb--;\n\t\t\tc--;\n\t\t\tE t1,t2;\n\t\t\tt1.v=b;\n\t\t\tt1.l=l;\n\t\t\tt1.thief=thi;\n\t\t\tt2.v=c;\n\t\t\tt2.l=l;\n\t\t\tt2.thief=thi;\n\t\t\ta[c].PB(t1);\n\t\t\ta[b].PB(t2);\n\t\t}\n\t\tcout<<dij()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define c first\n#define p second.first\n#define k second.second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> NP;\nint n,m,l,a,b,d,e;\nint E[101][101],D[101][101],an[101][101];\n\nNP MP(int A,int B,int C){return NP(A,P(B,C));}\n\nint main(){\n  while(cin>>n>>m>>l,n){\n    memset(D,-1,sizeof(D));\n    for(int i=0;i<m;i++)\n      cin>>a>>b>>d>>e, E[a][b]=E[b][a]=e, D[a][b]=D[b][a]=d;\n    for(int i=0;i<=l;i++)\n      for(int j=1;j<=n;j++)an[i][j]=100000000;\n\n    priority_queue<NP, vector<NP>,greater<NP> > q;\n    q.push(MP(0,1,l));\n    while(!q.empty()){\n      NP w=q.top();q.pop();\n      if(an[w.k][w.p]<=w.c)continue;\n      an[w.k][w.p]=w.c;\n      for(int i=1;i<=n;i++){\n\tif(D[i][w.p]==-1)continue;\n\tif(w.k>=D[i][w.p])q.push(MP(w.c,i,w.k-D[i][w.p]));\n\tq.push(MP(w.c+E[i][w.p],i,w.k));\n      }\n    }\n    int ans=1e9;\n    for(int i=0;i<=l;i++)ans=min(ans,an[i][n]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <unordered_map>\n#include <limits>\n#include <map>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nstruct Edge {\n  int from, to, distance, attack;\n};\n\nstruct Info {\n  int attacks, place, money;\n\n  friend bool operator >(Info const& lhs, Info const& rhs) {\n    if (lhs.attacks != rhs.attacks) {\n      return lhs.attacks > rhs.attacks;\n    }\n    if (lhs.money != rhs.money) {\n      return lhs.money < rhs.money;\n    }\n    return lhs.place > rhs.place;\n  }\n};\n\nint solve(int N, int M, int L) {\n  std::vector<std::vector<Edge>> adj_list(N);\n  for (int i = 0; i < M; i++) {\n    int f, t, d, e;\n    std::cin >> f >> t >> d >> e;\n    adj_list[f - 1].push_back(Edge{f - 1, t - 1, d, e});\n    adj_list[t - 1].push_back(Edge{t - 1, f - 1, d, e});\n  }\n  \n  std::priority_queue<Info, std::vector<Info>, std::greater<Info>> queue;\n  // ??°???n??????????????????????°?attack\n  std::vector<std::vector<int>> min_attacks(N, std::vector<int>(L + 1, 2 << 14));\n  min_attacks[0][L] = 0;\n  queue.push(Info{0, 0, L});\n  while (!queue.empty()) {\n    auto info = queue.top();\n    queue.pop();\n    //std::cout << \"info \" << info.attacks << \" \" << info.place << \" \" << info.money << std::endl;\n    if (min_attacks[info.place][info.money] < info.attacks) {\n      continue;\n    }\n    for (auto const& edge : adj_list[info.place]) {\n     if (edge.distance <= info.money) {\n       if (info.attacks < min_attacks[edge.to][info.money - edge.distance]) {\n         min_attacks[edge.to][info.money - edge.distance] = info.attacks;\n         queue.push(Info{info.attacks, edge.to, info.money - edge.distance});\n       }\n     }\n     if (info.attacks + edge.attack < min_attacks[edge.to][info.money]) {\n       min_attacks[edge.to][info.money] = info.attacks + edge.attack;\n       queue.push(Info{info.attacks + edge.attack, edge.to, info.money});\n     }\n    }\n  }\n  int min_attack = 1 << 14;\n  for (auto const& attacks : min_attacks[N - 1]) {\n    if (min_attack > attacks) {\n      min_attack = attacks;\n    }\n  }\n  return min_attack;\n}\n\nint main() {\n  int N, M, L;\n  while (std::cin >> N >> M >> L) {\n    if (N == 0 && M == 0 && L == 0) {\n      break;\n    }\n    std::cout << solve(N, M, L) << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, L;\n\nstruct State {\n    int v, sum, dist;\n    State(int v, int sum, int dist) : v(v), sum(sum), dist(dist) {}\n    bool operator<(const State& a) const {\n        return dist > a.dist;\n    }\n};\n\nstruct edge {\n    int to, money, enemy;\n    edge(int to, int money, int enemy):to(to),money(money),enemy(enemy){}\n};\n\nvector<edge> G[101];\nint d[101][101];\n\nvoid dijkstra(int s)\n{\n    for (int i = 0; i <= 100; ++i) for (int j = 0; j < N; ++j) d[i][j] = inf;\n\n    priority_queue<State> q;\n    q.push(State(s, 0, 0));\n\n    d[0][s] = 0;\n\n    while (q.size()) {\n        State st = q.top(); q.pop();\n\n        if (d[st.sum][st.v] < st.dist) continue;\n\n        for (int i = 0; i < G[st.v].size(); ++i) {\n            edge e = G[st.v][i];\n\n            if (st.sum + e.money <= L) {\n                if (d[st.sum + e.money][e.to] < d[st.sum][st.v]) continue;\n                d[st.sum + e.money][e.to] = d[st.sum][st.v];\n                q.push(State(e.to, st.sum + e.money, d[st.sum + e.money][e.to]));\n            }\n\n            if (d[st.sum][e.to] < d[st.sum][st.v] + e.enemy) continue;\n            d[st.sum][e.to] = d[st.sum][st.v] + e.enemy;\n            q.push(State(e.to, st.sum, d[st.sum][e.to]));\n        }\n    }\n}\n\nsigned main()\n{\n    while (scanf(\"%d%d%d\", &N, &M, &L), N) {\n        for (int i = 0; i < N; ++i) G[i].clear();\n        for (int i = 0; i < M; ++i) {\n            int A, B, D, E;\n            scanf(\"%d%d%d%d\", &A, &B, &D, &E);\n            A--, B--;\n            G[A].push_back(edge(B, D, E));\n            G[B].push_back(edge(A, D, E));\n        }\n\n        dijkstra(0);\n\n        int mi = inf;\n\n        for (int i = 0; i <= 100; ++i) {\n            chmin(mi, d[i][N - 1]);\n        }\n\n        printf(\"%d\\n\", mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nbool operator==(const State& lhs, const State& rhs)\n{\n    return lhs.loc == rhs.loc && lhs.money == rhs.money && lhs.damage == rhs.damage;\n}\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N && M && L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        vector<int> memo(101, -1);\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (current.money <= memo[current.loc]) {\n                continue;\n            }\n            memo[current.loc] = current.money;\n\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (e.dist <= current.money) {\n                    int damage = current.damage;\n                    pq.push({e.to, current.money - e.dist, damage});\n                }\n                // 護衛を雇わない\n                int damage = current.damage + e.enemy;\n                pq.push({e.to, current.money, damage});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int from, int to, T cost) {\n        this->from = from;\n        this->to = to;\n        this->cost = cost;\n    }\n};\nbool operator == (Edge<int> e1, Edge<int> e2) {\n    return e1.from == e2.from &&\n            e1.to == e2.to &&\n            e1.cost == e2.cost;\n}\nbool operator > (Edge<int> e1, Edge<int> e2) {\n    return e1.cost < e2.cost;\n}\ntemplate<typename T>\nusing Edges = std::vector<Edge<T>>;\ntemplate<typename T>\nusing Graph = std::vector<Edges<T>>;\ntemplate <typename T>\nstd::vector<T> dijkstra(const Graph<T> &g, int s) {\n    int sz = (int)(g.size());\n    std::vector<T> dist(sz, std::numeric_limits<T>::max());\n    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> pq;\n    dist[s] = 0;\n    pq.push({0, s});\n    while(!pq.empty()) {\n        T d = pq.top().first;\n        int now = pq.top().second;\n        pq.pop();\n        if(d > dist[now]) continue;\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int next = g[now][i].to;\n            T cost = g[now][i].cost;\n            if(dist[next] > dist[now] + cost) {\n                dist[next] = dist[now] + cost;\n                pq.push({cost, next});\n            }\n        }\n    }\n    return dist;\n}\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n, m, l; cin >> n >> m >> l;\n    if(n == 0) break;\n    Graph<int> g(n*(l+1));\n    for(int i=0;i<m;++i) {\n      int a, b, d, e; cin >> a >> b >> d >> e;\n      a--; b--;\n      for(int i=0;i<=l;++i) {\n        g[a*(l+1) + i].push_back(Edge<int>(a*(l+1) + i, b*(l+1) + i, e));\n        g[b*(l+1) + i].push_back(Edge<int>(b*(l+1) + i, a*(l+1) + i, e));\n        if(i >= d) g[a*(l+1) + i].push_back(Edge<int>(a*(l+1) + i, b*(l+1) + i - d, 0));\n        if(i >= d) g[b*(l+1) + i].push_back(Edge<int>(b*(l+1) + i, a*(l+1) + i - d, 0));\n      }\n    }\n    vector<int> dist = dijkstra(g, l);\n    int mi = INF;\n    for(int i=0;i<=l;++i) {\n      mi = min(mi, dist[(n-1) * (l+1) + i]);\n    }\n    cout << mi << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<array>\n\n#define fin cin\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nclass Input{\npublic:\n\tint a;\n\tint b;\n\tint d;\n\tint e;\n\tInput(int _a, int _b, int _d, int _e){\n\t\ta = _a;\n\t\tb = _b;\n\t\td = _d;\n\t\te = _e;\n\t}\n\toperator < (Input& other){\n\t\treturn (this->a < other.a);\n\t}\n\toperator > (Input& other){\n\t\treturn (this->a > other.a);\n\t}\n\n};\n\nconst int initnum = 10000000;\n\nstd::vector<Input> in_v{};\nstd::array<std::array<int, 100>, 100> cost;\n\nint main()\n{\n\t//std::ifstream fin(\"in.txt\");\n\t//cost[0].fill(0);\n\t//for(int i = 1; i < 100; i++)cost[i].fill(10000000);\n\n\twhile(true)\n\t{\n\t\tcost[0].fill(0);\n\t\t//cost[1].fill(0);\n\t\tfor(int i = 1; i < 100; i++)cost[i].fill(initnum);\n\t\n\t\tint n, m, l;\n\t\tfin >> n >> m >> l;\n\t\tif((n | m | l) == 0)break;\n\t\t//cout << n << \" \" << m << \" \" << l << endl;\n\t\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b, d, e;\n\t\t\tfin >> a >> b >> d >> e;\n\t\t\tin_v.push_back(Input(a-1, b-1, d, e));\n\t\t\tin_v.push_back(Input(b-1, a-1, d, e));\n\t\t}\n\t\tsort(in_v.begin(), in_v.end());\n\n\t\tstd::queue<Input> in_q;\n\t\tfor(auto in : in_v)in_q.push(in);\n\n\t\tin_v.clear();\n\t\tin_v.shrink_to_fit();\n\n\t\twhile(!in_q.empty())\n\t\t{\n\t\t\tInput tmp = in_q.front();\n\t\t\tin_q.pop();\n\n\t\t\tfor(int _cost = 0; _cost <= l; _cost++)\n\t\t\t{\n\n\t\t\t\tif(cost[tmp.a][_cost] == initnum)\n\t\t\t\t{\n\t\t\t\t\tin_q.push(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcost[tmp.b][_cost] = std::min(\n\t\t\t\t\tcost[tmp.b][_cost],\n\t\t\t\t\tstd::min(\n\t\t\t\t\t\t(_cost + tmp.d <= l ? (cost[tmp.a][_cost + tmp.d]) : initnum / 10),\n\t\t\t\t\t\tcost[tmp.a][_cost] + tmp.e\n\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\t\t\tfor(int i = 0; i <= l + 2; i++){\n\t\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\n\t\t}\n\t\tint min_cost = 10000000;\n\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tif(cost[n - 1][i] < min_cost)min_cost = cost[n - 1][i];\n\t\t//\tcout << cost[n - 1][i] << \" \";\n\t\t}\n\t\tcout << min_cost << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int n, m, l;\n    while(1){\n        cin >> n >> m >> l;\n        if(n == 0 && m == 0 && l == 0) break;\n        vector<vector<pair<int, int> > > touzoku(101);\n        vector<vector<pair<int, int> > > money(101);\n        int result[101][101];\n        // result[i][j]???j????????£???i????????????????????§?????£??????????????°\n        memset(result, 1000000, sizeof(result));\n        for(int i = 0; i < m; i++){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--;\n            b--;\n            touzoku[a].push_back(make_pair(b, e));\n            touzoku[b].push_back(make_pair(a, e));\n            money[a].push_back(make_pair(b, d));\n            money[b].push_back(make_pair(a, d));\n        }\n        result[0][l] = 0;\n        priority_queue<pair<int, pair<int, int> > > qu;\n        qu.push(make_pair(0, make_pair(0, 0)));\n        while(!qu.empty()){\n            int t = (qu.top()).first;\n            int nowtown = ((qu.top()).second).second;\n            int usedmoney = ((qu.top()).second).first;\n            // cout << t << \" \" << nowtown << \" \" << usedmoney << endl;\n            qu.pop();\n            // cout << result[nowtown] << \" \" << t << endl;\n            if(result[nowtown][usedmoney] <= t) continue;\n            // cout << \"hoge\" << endl;\n            result[nowtown][usedmoney] = t;\n            if(nowtown == n - 1) continue;\n            for(int i = 0; i < money[nowtown].size(); i++){\n                // cout << touzoku[nowtown][i] << endl;\n                if(usedmoney + money[nowtown][i].second <= l){\n                    qu.push(make_pair(t, make_pair(usedmoney + money[nowtown][i].second, money[nowtown][i].first)));\n                }\n                qu.push(make_pair(t + touzoku[nowtown][i].second, make_pair(usedmoney, money[nowtown][i].first)));\n            }\n        }\n        int ans = 10000000;\n        for(int i = 0; i < l + 1; i++) ans = min(ans, result[n - 1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, L;\n\nstruct State {\n    int v, sum, dist;\n    State(int v, int sum, int dist) : v(v), sum(sum), dist(dist) {}\n    bool operator<(const State& a) const {\n        return dist > a.dist;\n    }\n};\n\nstruct edge {\n    int to, money, enemy;\n    edge(int to, int money, int enemy):to(to),money(money),enemy(enemy){}\n};\n\nvector<edge> G[101];\nint d[101][101];\n\nvoid dijkstra(int s)\n{\n    for (int i = 0; i <= 100; ++i) for (int j = 0; j < N; ++j) d[i][j] = inf;\n\n    priority_queue<State> q;\n    q.push(State(s, 0, 0));\n\n    d[0][s] = 0;\n\n    while (q.size()) {\n        State st = q.top(); q.pop();\n\n        if (d[st.sum][st.v] < st.dist) continue;\n\n        for (int i = 0; i < G[st.v].size(); ++i) {\n            edge e = G[st.v][i];\n\n            do {\n            if (st.sum + e.money <= L) {\n                if (d[st.sum + e.money][e.to] < st.dist) continue;\n                d[st.sum + e.money][e.to] = st.dist;\n                q.push(State(e.to, st.sum + e.money, d[st.sum + e.money][e.to]));\n            }\n            } while(0);\n\n            if (d[st.sum][e.to] < st.dist + e.enemy) continue;\n            d[st.sum][e.to] = st.dist + e.enemy;\n            q.push(State(e.to, st.sum, d[st.sum][e.to]));\n        }\n    }\n}\n\nsigned main()\n{\n    while (scanf(\"%d%d%d\", &N, &M, &L), N) {\n        for (int i = 0; i < N; ++i) G[i].clear();\n\n        for (int i = 0; i < M; ++i) {\n            int A, B, D, E;\n            scanf(\"%d%d%d%d\", &A, &B, &D, &E);\n            A--, B--;\n            G[A].push_back(edge(B, D, E));\n            G[B].push_back(edge(A, D, E));\n        }\n\n        dijkstra(0);\n\n        int mi = inf;\n\n        for (int i = 0; i <= 100; ++i) {\n            chmin(mi, d[i][N - 1]);\n        }\n\n        printf(\"%d\\n\", mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\n#define NO_ROUTE 1000000\n\nusing namespace std;\n\nstruct edge {\n  //int n;\n  int tozoku;\n  int dist;\n};\n\nstruct node {\n  int n;\n  int money;\n  vector<int> visit;\n  bool done;\n  int tozoku;\n  node (int n0 = 0, int money0 = 0, int done0 = false, int tozoku0 = 1000000) {\n    n = n0, money = money0, done = done0, tozoku = tozoku0;\n  }\n  /*push_back(int n) {\n    vector.push_back(n);\n    } */\n  bool operator<(const node &t)const {\n    return tozoku > t.tozoku;\n  }\n};\n\nint N, M, L;\nnode G[100][101];\nedge e[100][100];\n\nint search()\n{\n  priority_queue<node> que;\n  node start(0, L, true, 0);\n  //start.push_back(0);\n  G[0][L] = node(0, L, true, 0);\n  //G[0][L].push_back(0);\n  que.push(start);\n\n  while (!que.empty()) {\n    node n_node;\n    n_node = que.top();\n    G[n_node.n][n_node.money].done;\n    //cout << \"n \" << n_node.n << \" money \" << n_node.money << \" done \" << n_node.done << \" tozoku \" << n_node.tozoku << endl;\n    que.pop();\n    if (n_node.n == N - 1) return n_node.tozoku;\n    \n    for (int i = 0; i < N; i++) {\n      if (e[n_node.n][i].dist == NO_ROUTE) continue;\n      //////cout << \"dist \" << e[n_node.n][i].dist << endl;\n      if (!G[i][n_node.money].done) {\n\t//printf(\"(%d, %d) : %d %d\\n\", n_node.n, i, n_node.tozoku + e[i][n_node.money].tozoku, )\n\tif (n_node.tozoku + e[i][n_node.n].tozoku < G[i][n_node.money].tozoku) {\n\t  G[i][n_node.money] = node(i, n_node.money, false, n_node.tozoku + e[i][n_node.n].tozoku);\n\t  ////cout << n_node.tozoku << \" + \" << e[n_node.n][i].tozoku << endl;\n\t  node t_node = G[i][n_node.money];\n\t  //cout << \"::n \" << t_node.n << \" money \" << t_node.money << \" done \" << t_node.done << \" tozoku \" << t_node.tozoku << endl;\n\t  que.push(t_node);\n\t}\n      }\n      if (n_node.money >= e[n_node.n][i].dist && !G[i][n_node.money - e[n_node.n][i].dist].done \n\t  && n_node.tozoku < G[i][n_node.money - e[n_node.n][i].dist].tozoku) {\n\tG[i][n_node.money - e[n_node.n][i].dist] = node(i, n_node.money - e[n_node.n][i].dist, false, n_node.tozoku);\n\tnode t_node = G[i][n_node.money - e[n_node.n][i].dist];\n\t//cout << \"::n \" << t_node.n << \" money \" << t_node.money << \" done \" << t_node.done << \" tozoku \" << t_node.tozoku << endl;\n\tque.push(t_node);\n      }\n    }\n  }\n  return -1;\n}\n\n\nint main()\n{\n  while (true) {\n    scanf(\"%d %d %d \", &N, &M, &L);\n    if (N == 0 && M == 0 && L == 0) break;\n    for (int i = 0; i < 100; i++) {\n      for (int j = 0; j < 100; j++) {\n\tG[i][j].n = i;\n\tG[i][j].money = j;\n\tG[i][j].tozoku = 1000000;\n\tG[i][j].done = false;\n\te[i][j].dist = NO_ROUTE;\n\te[i][j].tozoku = 0;\n      }\n    }\n    \n    for (int i = 0; i < 100; i++) {\n      G[i][100].tozoku = 1000000;\n      G[i][100].n = i;\n      G[i][100].done = false;\n      G[i][100].money = 100;\n    }\n    \n    for (int i = 0; i < M; i++) {\n      int x, y;\n      scanf(\"%d %d \", &x, &y);\n      x--, y--;\n      scanf(\"%d %d \", &e[x][y].dist, &e[x][y].tozoku);\n      e[y][x].dist = e[x][y].dist, e[y][x].tozoku = e[x][y].tozoku;\n    }\n    \n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n\t////cout << e[i][j].dist << \" \" << e[i][j].tozoku << \"   \";\n      }\n      ////cout << endl;\n    }\n\n    cout << search() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\n#define UNDEF 500000\n\nusing namespace std;\n\nint main()\n{\n\tint n, m, l, i;\n\tint len[101][101];\n\tint hos[101][101];\n\tint djk_money[2][101];\n\tint djk_enemy[2][101];\n\n\t//0...àgíÈ¢[g\n\t//1...àg¤[g\n\n\tqueue<int> que;\n\n\twhile(cin >> n >> m >> l, (n||m||l))\n\t{\n\t\tmemset(len, -1, sizeof(len));\n\t\tmemset(hos, -1, sizeof(hos));\n\t\tmemset(djk_money, -1, sizeof(djk_money));\n\t\tmemset(djk_enemy, -1, sizeof(djk_enemy));\n\t\tque.push(1);\n\t\tdjk_enemy[0][1] = 0;\n\t\tdjk_enemy[1][1] = 0;\n\t\tdjk_money[0][1] = l;\n\t\tdjk_money[1][1] = l;\n\n\t\tfor( i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a;\n\t\t\tcin >> b;\n\n\t\t\tcin >> len[a][b];\n\t\t\tcin >> hos[a][b];\n\n\t\t\tlen[b][a] = len[a][b];\n\t\t\thos[b][a] = hos[a][b];\n\t\t}\n\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tint st = que.front();\n\t\t\tque.pop();\n\n\t\t\tfor( i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif( len[st][i] > 0 && hos[st][i] > 0)\n\t\t\t\t{\n\t\t\t\t\tbool flg = 0;\n\n\t\t\t\t\tif( djk_enemy[0][i] < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdjk_enemy[0][i] = UNDEF;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( djk_enemy[1][i] < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdjk_enemy[1][i] = UNDEF;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor( int k = 0; k <= 1; k++)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tif( djk_enemy[0][i] > djk_enemy[k][st] + hos[st][i] )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdjk_enemy[0][i] = djk_enemy[k][st] + hos[st][i];\n\t\t\t\t\t\t\tdjk_money[0][i] = djk_money[k][st];\n\t\t\t\t\t\t\tflg = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( djk_enemy[1][i] > djk_enemy[k][st] && djk_money[k][st] - len[st][i] >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdjk_enemy[1][i] = djk_enemy[k][st];\n\t\t\t\t\t\t\tdjk_money[1][i] = djk_money[k][st] - len[st][i];\n\t\t\t\t\t\t\tflg = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg)\n\t\t\t\t\t\tque.push(i);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout << min(djk_enemy[0][n], djk_enemy[1][n]) << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\n#define NO_ROUTE 1000000\n\nusing namespace std;\n\nstruct edge {\n  //int n;\n  int tozoku;\n  int dist;\n};\n\nstruct node {\n  int n;\n  int money;\n\n  bool done;\n  int tozoku;\n  node (int n0 = 0, int money0 = 0, int done0 = false, int tozoku0 = 1000000) {\n    n = n0, money = money0, done = done0, tozoku = tozoku0;\n  }\n  bool operator<(const node &t)const {\n    return tozoku > t.tozoku;\n  }\n};\n\nint N, M, L;\nnode G[100][101];\nedge e[100][100];\n\nint search()\n{\n  priority_queue<node> que;\n  node start(0, L, true, 0);\n  G[0][L] = node(0, L, true, 0);\n  que.push(start);\n\n  while (!que.empty()) {\n    node n_node;\n    n_node = que.top();\n    G[n_node.n][n_node.money].done = true;\n    //cout << \"n \" << n_node.n << \" money \" << n_node.money << \" done \" << n_node.done << \" tozoku \" << n_node.tozoku << endl;\n    que.pop();\n    if (n_node.n == N - 1) return n_node.tozoku;\n    \n    for (int i = 0; i < N; i++) {\n      if (e[n_node.n][i].dist == NO_ROUTE) continue;\n      ////cout << \"dist \" << e[n_node.n][i].dist << endl;\n      if (!G[i][n_node.money].done) {\n\tif (n_node.tozoku + e[i][n_node.money].tozoku < G[i][n_node.money].tozoku) {\n\t  G[i][n_node.money] = node(i, n_node.money, false, n_node.tozoku + e[i][n_node.n].tozoku);\n\t  //cout << n_node.tozoku << \" + \" << e[n_node.n][i].tozoku << endl;\n\t  node t_node = G[i][n_node.money];\n\t  que.push(t_node);\n\t}\n      }\n      if (n_node.money >= e[n_node.n][i].dist && !G[i][n_node.money - e[n_node.n][i].dist].done \n\t  && n_node.tozoku < G[i][n_node.money - e[n_node.n][i].dist].tozoku) {\n\tG[i][n_node.money - e[n_node.n][i].dist] = node(i, n_node.money - e[n_node.n][i].dist, false, n_node.tozoku);\n\tnode t_node = G[i][n_node.money - e[n_node.n][i].dist];\n\tque.push(t_node);\n      }\n    }\n  }\n  return -1;\n}\n\n\nint main()\n{\n  while (true) {\n    scanf(\"%d %d %d \", &N, &M, &L);\n    if (N == 0 && M == 0 && L == 0) break;\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n\tG[i][j].n = i;\n\tG[i][j].money = j;\n\t\n\te[i][j].dist = NO_ROUTE;\n\te[i][j].tozoku = 0;\n      }\n    }\n    \n    for (int i = 0; i < M; i++) {\n      int x, y;\n      scanf(\"%d %d \", &x, &y);\n      x--, y--;\n      scanf(\"%d %d \", &e[x][y].dist, &e[x][y].tozoku);\n      e[y][x].dist = e[x][y].dist, e[y][x].tozoku = e[x][y].tozoku;\n    }\n    \n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n\t//cout << e[i][j].dist << \" \" << e[i][j].tozoku << \"   \";\n      }\n      //cout << endl;\n    }\n\n    cout << search() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint V,E,L;\n \nint const INF = 1<<28;\n \nstruct Edge {\n  int src, dst, dist, ene;\n};\n \ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n \nGraph G;\n \nstruct State {\n  int money, attacked, pos;\n  bool operator < ( const State& s ) const {\n    return attacked > s.attacked;\n  }\n};\n \n \nint dijkstra(int st) {\n   \n  int dist[110][110]; // [node][money]\n   \n  fill(dist[0], dist[0]+110*110, INF);\n  dist[st][L] = 0;\n   \n  priority_queue<State> pq;\n  pq.push((State){L, 0, st});\n  while(!pq.empty()) {\n    const State stt = pq.top(); pq.pop();\n    if(stt.attacked>dist[stt.pos][stt.money])continue;\n \n    for(int i=0; i<G[stt.pos].size(); i++) {\n      int next = G[stt.pos][i].dst;\n      int nmoney = stt.money-G[stt.pos][i].dist;\n       \n      if(nmoney < 0) continue;\n      if(dist[next][nmoney] > stt.attacked) {\n\tdist[next][nmoney] = stt.attacked;\n\tpq.push((State){nmoney, stt.attacked, next});\n      }\n    }\n \n    for(int i=0; i<G[stt.pos].size(); i++) {\n      int next = G[stt.pos][i].dst;\n      int nattacked = stt.attacked + G[stt.pos][i].ene;\n      if(dist[next][stt.money] > nattacked) {\n\tdist[next][stt.money] = nattacked;\n\tpq.push((State){stt.money, nattacked, next});\n      }\n    }\n  }\n   \n  int mn = INF;\n  for(int i=0; i<=L; i++) {\n    mn = min(mn, dist[V-1][i]);\n  }\n   \n  return mn;\n}\n \nint main(){\n   \n  while(cin >> V >> E >> L && (V|E|L)) {\n    G.resize(V);\n    for(int i=0; i<V; i++) {\n      G[i].clear();\n    }\n    for(int i=0; i<E; i++) {\n      int a, b, d, e;\n      cin >> a >> b >> d >> e; a--, b--;\n      G[a].push_back((Edge){a, b, d, e});\n      G[b].push_back((Edge){b, a, d, e});\n    }\n     \n    cout << dijkstra(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef pair<int, int> P;\n#define REP(i, x, n) for(int i = x ; i < n ; ++i)\n#define rep(i, n) for(int i = 0 ; i < n ; ++i)\n#define repr(i, n) for(int i = n - 1 ; i >= 0 ; --i)\n#define ALL(x) (x).begin(), (x).end()\n#define SORT(x) sort((x).begin(), (x).end())\n\nconst int IINF = 1e9 + 10;\nconst long long LLINF = (long long)1e18 + 10;\nconst long long MOD = (long long)1e9 + 7;\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\nconst double EPS = 1e-8;\n\nstruct edge{\n    int from, to;\n    lint dist, enemy;\n};\n\nstruct node{\n    int id;\n    lint cost, enemy;\n\n    bool operator<(const node &right) const {\n        return enemy > right.enemy;\n    }\n};\n\nint main(){\n    int n, m, l;\n    while(cin >> n >> m >> l, n){\n        vector< vector<edge> > g(n);\n        rep(i, m){\n            int a, b;\n            lint d, e;\n            cin >> a >> b >> d >> e;\n            --a;\n            --b;\n            g[a].push_back({a, b, d, e});\n            g[b].push_back({b, a, d, e});\n        }\n        vector< vector<lint> > v(n);\n        rep(i, n){\n            v[i].resize(l + 1, LLINF);\n        }\n        priority_queue<node> que;\n        que.push({0, 0, 0});\n        while(!que.empty()){\n            node now = que.top();\n            que.pop();\n            if(v[now.id][l - now.cost] <= now.enemy){\n                continue;\n            }\n            v[now.id][l - now.cost] = now.enemy;\n            for(auto x : g[now.id]){\n                if(now.cost + x.dist <= l && v[x.to][l - now.cost - x.dist] > now.enemy){\n                    que.push({x.to, now.cost + x.dist, now.enemy});\n                }\n                if(v[x.to][l - now.cost] > now.enemy + x.enemy){\n                    que.push({x.to, now.cost, now.enemy + x.enemy});\n                }\n            }\n        }\n        lint ans = LLINF;\n        rep(j, l + 1){\n            ans = min(ans, v[n - 1][j]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\n\nconst int INF = 1 << 28;\n\nint main () {\n    int n, m, l;\n    while (cin >> n >> m >> l, n + m + l) {\n        vector<vector<PP> > Path(n + 1);\n        for (int i = 0; i < m; i++) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            Path[a].push_back(PP(b, P(d, e)));\n            Path[b].push_back(PP(a, P(d, e)));\n        }\n\n        priority_queue<PP, vector<PP>, greater<PP> > pq;\n        vector<vector<int> > dp(n + 1, vector<int>(l + 1, INF));\n\n        dp[1][l] = 0;\n        pq.push(PP(0, P(l, 1)) );\n\n        int res = INF;\n        \n        while (pq.size()) {\n            PP pp = pq.top(); pq.pop();\n            int attack = pp.first;\n            int money = pp.second.first;\n            int now = pp.second.second;\n\n            if (dp[now][money] < attack) continue;\n\n            for (int i = 0; i < Path[now].size(); i++) {\n                int next = Path[now][i].first;\n                int M = Path[now][i].second.first;\n                int A = Path[now][i].second.second;\n                if (money >= M && dp[next][money - M] > attack) {\n                    dp[next][money - M] = attack;\n                    pq.push(PP(attack, P(money - M, next)));\n                    if (next == n) {\n                        res = min(res, attack);\n                    }\n                }\n\n                if (money >= 0 && dp[next][money] > attack + A) {\n                    dp[next][money] = attack + A;\n                    pq.push(PP(attack + A, P(money, next)));\n                    if (next == n) {\n                        res = min(res, attack + A);\n                    }\n                }\n            }\n        }\n\n        cout << res << endl;\n        \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct P\n{\n    int p, money, damage;\n\n    bool operator >(const P& p ) const  {\n        return damage > p.damage;\n    }\n};\n\nstruct edge\n{\n    int to, cost, enemy;\n};\n\nint main() {\n    int town_n, road_n, money;\n\n    while(cin >> town_n >> road_n >> money, town_n|road_n|money){\n        vector<edge> E[town_n + 1];\n\n        REP(i, road_n){\n            int from ,to, cost, enemy;\n            cin >> from >> to >> cost >> enemy;\n\n            E[from].push_back({to, cost, enemy});\n            E[to].push_back({from, cost, enemy});\n        }\n\n        int G[town_n + 1][money + 1];\n        fill_n((int*)G, (town_n + 1)*(money + 1), 1<<11);\n        G[1][money] = 0;\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({1, money, 0});\n        int result = -1;\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n//            printf(\"now town :%d, money:%d, damage: %d\\n\", p.p, p.money, p.damage);\n            if(p.p == town_n){\n                result = p.damage;\n                break;\n            }\n\n            for(edge e:E[p.p]){\n                int to = e.to;\n                int usedmoney = p.money - e.cost;\n                int damaged = p.damage + e.enemy;\n\n                //お金を使う\n                if(usedmoney >= 0 && G[e.to][usedmoney] > p.damage){\n                    que.push({to, usedmoney, p.damage});\n                    G[e.to][usedmoney] = p.damage;\n                }\n                //お金を使わない\n                if(G[e.to][p.money] > damaged){\n                    que.push({to, p.money, damaged});\n                    G[e.to][p.money] = damaged;\n                }\n            }\n        }\n\n        cout << result << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nstruct Edge {\n    int to, dist, enemy;\n};\n\nstruct State {\n    int loc, money, damage;\n\n    bool operator >(const State& p) const {\n        return damage > p.damage;\n    }\n};\n\nint main()\n{\n    int N, M, L;\n    while (cin >> N >> M >> L, N || M || L) {\n        vector<vector<Edge>> edges(N+1);\n        for (int i = 0; i < M; ++i) {\n            int from, to, dist, enemy;\n            cin >> from >> to >> dist >> enemy;\n            edges[from].push_back({to, dist, enemy});\n            edges[to].push_back({from, dist, enemy});\n        }\n\n        priority_queue<State, vector<State>, greater<State>> pq;\n        pq.push({1, L, 0});\n        while(!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n            if (current.loc == N) {\n                cout << current.damage << endl;\n                break;\n            }\n\n            for (Edge e : edges[current.loc]) {\n                // 護衛を雇う\n                if (e.dist <= current.money) {\n                    pq.push({e.to, current.money - e.dist, current.damage});\n                }\n                // 護衛を雇わない\n                pq.push({e.to, current.money, current.damage + e.enemy});\n\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\n\nclass DP{\npublic:\n\tint cost, x, rest;\n\t\n\tDP(){}\n\tDP(int xx, int rr, int cc){\n\t\tcost = cc;x=xx;rest=rr;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\n\nstruct Edge{\n\tint to, dist, risk;\n};\nunsigned int visit[200][200];\nint N, M, L;\nmain(){\n\tint i,j;\n\twhile(cin >> N >> M >> L, N){\n\t\tmemset(visit, -1, sizeof(visit));\n\t\tvector<Edge> E[200];\n\t\tfor(i=0;i<M;i++){\n\t\t\tint a;\n\t\t\tEdge e;\n\t\t\tcin >> a >> e.to >> e.dist >> e.risk;\n\t\t\tE[a].push_back(e);\n\t\t\tswap(a, e.to);\n\t\t\tE[a].push_back(e);\n\t\t}\n\t\tpriority_queue<DP> dp;\n\t\tDP S;\n\t\tdp.push(DP(1, L, 0));\n\t\twhile(!dp.empty()){\n\t\t\tS = dp.top();\n\t\t\tdp.pop();\n\t\t\tif(S.x == N) break;\n\t\t\tfor(i=0;i<E[S.x].size();i++){\n\t\t\t\tDP T=S;\n\t\t\t\tT.x = E[S.x][i].to;\n\t\t\t\tT.cost += E[S.x][i].risk;\n\t\t\t\t\n\t\t\t\tif(visit[T.x][T.rest] > T.cost){\n\t\t\t\t\tvisit[T.x][T.rest] = T.cost;\n\t\t\t\t\tdp.push(T);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tT.cost = S.cost;\n\t\t\t\tT.rest -= E[S.x][i].dist;\n\t\t\t\tif(T.rest >= 0 && visit[T.x][T.rest] > T.cost){\n\t\t\t\t\tvisit[T.x][T.rest] = T.cost;\n\t\t\t\t\tdp.push(T);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << S.cost << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, deque<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\twhile( itr != points[i].end() ) {\n\t\t\t\t\t\t\t\t\t\n\t\t\tif ((*itr).second>min) {\n\t\t\t\t(*itr).second = min;\n\t\t\t} else if ( (*itr).second<min ) {\n\t\t\t\tmin = (*itr).second+1;\n\t\t\t}\n\t\t\titr++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, deque<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1000000000\n#define INF 1000000000000000\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\nvoid init(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\n\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WG = vector< Edges< T > >;\nusing UG = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\n\n\ntemplate< typename T >\nvector<T> dijkstra(WG<T> &g,int s){\n  const auto lim = numeric_limits<T>::max();\n  vector<T> dist(g.size(),lim);\n  using Pi = pair<T,int>;\n  priority_queue<Pi,vector<Pi>,greater<Pi>> q;\n  dist[s] = 0;\n  q.emplace(dist[s],s);\n  while(!q.empty()){\n    T cost;\n    int idx;\n    tie(cost,idx) = q.top();\n    q.pop();\n    if(dist[idx] < cost) continue;\n    for( auto &e : g[idx]){\n      auto next_cost = cost + e.cost;\n      if(dist[e.to] <= next_cost) continue;\n      dist[e.to] = next_cost;\n      q.emplace(dist[e.to],e.to);\n    }\n  }\n  return dist;\n}\n\n\nvoid f(int n,int m,int l){\n  WG<int> es(n*(l+1));\n\n  rep(i,m){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;\n    FOR(j,c,l+1){\n      es[a*(l+1)+j].PB(edge<int>(b*(l+1)+j-c,0));\n      es[b*(l+1)+j].PB(edge<int>(a*(l+1)+j-c,0));\n    }\n    rep(j,l+1){\n      es[a*(l+1)+j].PB(edge<int>(b*(l+1)+j,d));\n      es[b*(l+1)+j].PB(edge<int>(a*(l+1)+j,d));\n    }\n  }\n\n  vector<int> res=dijkstra(es,l);\n\n  int ans=INF;\n  rep(i,l+1){\n    //cout<<' '<<res[(n-1)*(l+1)+i]<<endl;\n    ans=min(ans,res[(n-1)*(l+1)+i]);\n  }\n\n  cout<<ans<<endl;\n}\n\n\n\nmain(){\n  int n,m,l;\n  while(true){\n    cin>>n>>m>>l;\n    if(n==0) break;\n    f(n,m,l);\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct edge{int to,fee,cost;};\nstruct state{\n  int cost,pos,cash;\n  bool operator < (const state &s)const{\n    return cost>s.cost;\n  }\n};\n\n#define MAX_V 100\n#define INF (1<<24)\nvector<edge> G[MAX_V];\nint V,E,L;\n\nvoid init();\nint dijkstra(int,int);\n\nint main(){\n  int a,b,c,d;\n  while(1){\n    cin>>V>>E>>L;\n    if(V==0&&E==0&&L==0)break;\n    init();\n    for(int i=0;i<E;i++){\n      cin>>a>>b>>c>>d;\n      a--;b--;\n      G[a].push_back( (edge){b,c,d} );\n      G[b].push_back( (edge){a,c,d} );\n    }\n    cout<<dijkstra(0,V-1)<<endl;\n  }\n  return 0;\n}\n\nint dijkstra(int si,int ti){\n  int d[MAX_V][200];\n  fill(d[0],d[0]+MAX_V*200,INF);\n  d[si][L]=0;\n  priority_queue<state> Q;\n  Q.push( (state){0,si,L} );\n\n  while(!Q.empty()){\n    state now=Q.top();Q.pop();\n    for(int i=0;i<(int)G[now.pos].size();i++){\n      edge e=G[now.pos][i];\n      if(now.cost+e.cost < d[e.to][now.cash]){\n\td[e.to][now.cash]=now.cost+e.cost;\n\tQ.push( (state){now.cost+e.cost,e.to,now.cash} );\n      }\n      if(now.cash-e.fee<0)continue;\n      int ncash=now.cash-e.fee;\n      if(now.cost < d[e.to][ncash]){\n\td[e.to][ncash]=now.cost;\n\tQ.push( (state){now.cost,e.to,ncash} );\n      }\n    }\n  }\n\n  int res=INF;\n  for(int i=0;i<200;i++)\n    res=min(res,d[ti][i]);\n  return res;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++)G[i].clear();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 101;\nconst int INF = 1e+8;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to, d, cost;\n\tedge(int to_, int d_, int cost_){ \n\t\tto = to_; d = d_; cost = cost_; \n\t};\n};\n\n// 宿の数\nint N;\n// G[u] := ノード u と隣接するエッジのvectorを返す\nvector<edge> G[MAX_N];\n// 頂点 v := <宿の番号,持っているお金>, memo[v] := v の最小コスト\nmap<P,int> memo;\n\n// 初期化\nvoid init(){\n\tfor(int i=0 ; i < MAX_N ; i++ ){\n\t\tG[i].clear();\n\t}\n\tfor(int i=0 ; i < MAX_N ; i++ ){\n\t\tfor(int j=0 ; j < MAX_N ; j++ ){\n\t\t\tmemo[P(i,j)] = INF;\n\t\t}\n\t}\n}\n\n// 辺の追加\nvoid add_edge(int u, int v, int d, int cost){\n\tedge e( v , d , cost );\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// 探索\nint bfs(int s, int L){\n\t// (今まで襲われた数,宿の番号,今持っているお金) の状態を持つ優先度付きキュー\n\tpriority_queue< pair<int,P>, vector<pair<int,P> >, greater<pair<int,P> > > q;\n\t// 襲われた数 0, 宿 s から お金 L の状態でスタートする\n\tP sp(s,L);\n\tpair<int,P> start(0,sp);\n\tq.push( start );\n\tmemo[sp] = 0;\n\t\n\tint ans = INF;\n\twhile( !q.empty() ){\n\t\t// now_cost := 今まで襲われた数\n\t\tint now_cost = q.top().first;\n\t\tP now = q.top().second;\n\t\tq.pop();\n\t\t// v := 今いる宿\n\t\tint v = now.first;\n\t\t// l := 今持っているお金\n\t\tint l = now.second;\n\t\t\n\t\t// ゴールにいるとき\n\t\tif( v == N-1 ){\n\t\t\tans = min( ans , now_cost );\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tint to = G[v][i].to;\n\t\t\tint d = G[v][i].d;\n\t\t\t\n\t\t\t// 距離以上のお金があるとき\n\t\t\tif( d <= l ){\n\t\t\t\t// to : 次の宿, l-d : 持っているお金\n\t\t\t\tP next( to , l - d );\n\t\t\t\tint next_cost = now_cost + 0 ;\n\t\t\t\tif( next_cost < memo[next] ){\n\t\t\t\t\tmemo[next] = next_cost;\n\t\t\t\t\tpair<int,P> p( next_cost , next );\n\t\t\t\t\tq.push( p );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// お金を払わず進むとき\n\t\t\t{\n\t\t\t\t// to : 次の宿, l : 持っているお金\n\t\t\t\tP next( to , l );\n\t\t\t\tint next_cost = now_cost + G[v][i].cost;\n\t\t\t\tif( next_cost < memo[next] ){\n\t\t\t\t\tmemo[next] = next_cost;\n\t\t\t\t\tpair<int,P> p( next_cost , next );\n\t\t\t\t\tq.push( p );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint M, L;\n\twhile( cin >> N >> M >> L, N || M || L ){\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < M ; i++ ){\n\t\t\tint a, b, d, e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--; b--;\n\t\t\tadd_edge( a , b , d , e );\n\t\t}\n\t\tint ans = bfs( 0 , L );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\n#define NO_ROUTE 1000000\nusing namespace std;\n\nstruct node {\n  int n;\n  int money;\n  int tozoku;\n  bool operator<(const node& t)const{\n    return tozoku > t.tozoku;\n  }\n  node(int n0 = 0, int money0 = 0, int tozoku0 = 0){\n    n = n0, money = money0, tozoku = tozoku0;\n  }\n};\n\nstruct edge {\n  int dist;\n  int tozoku;\n};\n\nnode G[100][101];\nedge e[100][100];\nint N, M, L;\n\nint search()\n{\n  priority_queue<node> que;\n  node start;\n  start.n = 0, start.money = L, start.tozoku = 0;\n  G[0][L] = node(0, L, 0);\n  que.push(start);\n  while (!que.empty()) {\n    node n_node = que.top();\n    que.pop();\n    //cout << \"n \" << n_node.n << \" money \" << n_node.money << \" tozoku \" << n_node.tozoku << endl;\n    if (n_node.n == N - 1) return n_node.tozoku;\n    for (int i = 0; i < N; i++) {\n      node t_node;\n      if (e[n_node.n][i].dist == NO_ROUTE) {\n\t//cout << n_node.n << \"-\" << i << \"is NO_ROUTE!\" << endl;\n\tcontinue;\n      }\n      if (n_node.tozoku + e[n_node.n][i].tozoku < G[i][n_node.money].tozoku) {\n\tt_node = node(i, n_node.money, n_node.tozoku + e[n_node.n][i].tozoku);\n\tG[i][n_node.money] = node(i, n_node.money, n_node.tozoku + e[n_node.n][i].tozoku);\n\tque.push(t_node);\n      }\n      \n      if (n_node.money >= e[n_node.n][i].dist && n_node.tozoku < G[i][n_node.money - e[n_node.n][i].dist].tozoku) {\n\tt_node = node(i, n_node.money - e[n_node.n][i].dist, n_node.tozoku);\n\tG[i][n_node.money - e[n_node.n][i].dist] = node(i, n_node.money - e[n_node.n][i].dist, n_node.tozoku);\n\tque.push(t_node);\n      }\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while (true) {\n    for (int i = 0; i < 100; i++) {\n      for (int j = 0; j < 100; j++) {\n\tG[i][j] = node(i, j, 1000000);\n\te[i][j].dist = NO_ROUTE;\n\te[i][j].tozoku = 0;\n      }\n    }\n    scanf(\"%d %d %d \", &N, &M, &L);\n    if (N == 0 && M == 0 && L == 0) break;\n    for (int i = 0; i < M; i++) {\n      int x, y;\n      scanf(\"%d %d \", &x, &y);\n      x--, y--;\n      scanf(\"%d %d \", &e[x][y].dist, &e[x][y].tozoku);\n      e[y][x].dist = e[x][y].dist,e[y][x].tozoku = e[x][y].tozoku;\n    }\n    \n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n\t//cout << e[i][j].dist << \" \" << e[i][j].tozoku << \" \";\n      }\n      //cout << endl;\n    }\n    \n    cout << search() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define INF 1e9\n\nstruct Node {\n\tint n, rest, cost;\n};\nstruct Edge {\n\tint to, dist, enemy;\n};\n\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\n\nint main() {\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N || M || L) {\n//\t\tint dist[100][100], enemy[100][100];\n//\t\tfill(&dist[0][0], &dist[0][0]+100*100, INF);\n//\t\tfill(&enemy[0][0], &enemy[0][0]+100*100, INF);\n\t\tvector< vector<Edge> > edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, d, e; cin >> a >> b >> d >> e; --a, --b;\n\t\t\tedges[a].push_back( (Edge){b, d, e} );\n\t\t\tedges[b].push_back( (Edge){a, d, e} );\n//\t\t\tdist[a][b] = dist[b][a] = d;\n//\t\t\tenemy[a][b] = enemy[b][a] = e;\n\t\t}\n//\t\tfor (int i = 0; i < N; ++i) dist[i][i] = enemy[i][i] = 0;\n\t\tint dp[100][101]; // dp[to][rest] = min enemy;\n\t\tfill(&dp[0][0], &dp[0][0]+100*101, INF);\n\t\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push( (Node){0, L, 0} );\n\t\twhile ( !Q.empty() ) {\n\t\t\tNode node = Q.top(); Q.pop();\n\t\t\tint n = node.n, rest = node.rest, cost = node.cost;\n\n\t\t\tif (cost >= dp[n][rest]) continue;\n\t\t\tdp[n][rest] = cost;\n\n\t\t\tfor (int i = 0; i < edges[n].size(); ++i) {\n\t\t\t\tEdge& e = edges[n][i];\n\t\t\t\tif (rest >= e.dist) {\n\t\t\t\t\tQ.push( (Node){e.to, rest-e.dist, cost} );\n\t\t\t\t}\n\t\t\t\tQ.push( (Node){e.to, rest, cost+e.enemy} );\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i <= L; ++i) {\n\t\t\tans = min(ans, dp[N-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 6/14 8:54 ~@13:01\n * Accepted\n */\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#define INF 1000000\n\nusing namespace std;\n\nstruct edge {\n  int to, cost, dis;\n};\ntypedef pair<int, int> P;\n\nvector<edge> G[101];\n\n// init\n\n// input\nint iN; // 0 <= N <= 100,000\nint iM; // 1 <= P <= 100\nint iL; // 1 <= P <= 100\n\n// manage\nint d[101][101];\n\n// ú»\nvoid init() {\n}\n\n// üÍ\nbool input() {\n  int i;\n  edge e;\n  int a, b, d, c;\n\n  scanf(\"%d %d %d\", &iN, &iM, &iL);\n  if (iN == 0 && iM == 0 && iL == 0) return false;\n\n  for (i = 0; i < iN; i++) {\n    G[i].clear();\n  }\n  for (i = 0; i < iM; i++) {\n    scanf(\"%d %d %d %d\", &a, &b, &d, &c);\n    e.cost = c;\n    e.dis = d;\n    e.to = b;\n    G[a].push_back(e);\n    e.to = a;\n    G[b].push_back(e);\n  }\n\n  return true;\n}\n\n// \nvoid manage(){\n  priority_queue<P, vector<P> , greater<P> > que;\n\n  fill(d[0], d[0] + 101 * 101, INF);\n  d[1][iL] = 0;\n  que.push(P(0, 1 * 101 + iL));\n\n  while (!que.empty()) {\n    P p = que.top();\n    que.pop();\n    int v = p.second / 101;\n    int c = p.second % 101;\n    if (d[v][c] < p.first)\n      continue;\n    for (int i = 0; i < (int) G[v].size(); i++) {\n      edge e = G[v][i];\n      if (e.dis <= c && d[e.to][c - e.dis] > d[v][c]) {\n        d[e.to][c - e.dis] = d[v][c];\n        que.push(P(d[e.to][c - e.dis], e.to * 101 + (c - e.dis)));\n      }\n      if (d[e.to][c] > d[v][c] + e.cost) {\n        d[e.to][c] = d[v][c] + e.cost;\n        que.push(P(d[e.to][c], e.to * 101 + c));\n      }\n    }\n  }\n}\n\n// oÍ\nvoid output(){\n  int i, out;\n  out = d[iN][0];\n  for (i = 1; i <= iL; i++) {\n    out = min(out, d[iN][i]);\n  }\n  printf(\"%d\\n\", out);\n}\n\n// mizoSâ¤Ê\nint main() {\n  init(); // ú»\n  while(1) {\n    if (!input()) break; // üÍ + I¹»è\n    manage(); // \n    output(); // oÍ\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\nusing namespace std;\n\nclass State {\npublic:\n\tint budget;\n\tint people;\n\tint wheres;\n\tState() {};\n\tState( int b, int p, int n ) { budget = b; people = p; wheres = n; };\n};\n\npriority_queue<State, vector<State>, greater<State> > status;\n//priority_queue<State> status;\nset<State> have;\n\nint map[101][101];\nint off[101][101];\nint check[101];\n\nbool operator< (const State& a, const State& b)\n{\n\tif ( a.people == b.people )\n\t\treturn a.budget > b.budget;\n\treturn a.people < b.people;\n}\n\nbool operator> (const State& a, const State& b)\n{\n\tif ( a.people == b.people )\n\t\treturn a.budget < b.budget;\n\treturn a.people > b.people;\t\n}\n\nint main () {\n\n\twhile ( true ) {\n\t\tint  N,M,L;\n\n\t\tcin >> N >> M >> L;\n\n\t\tif ( N == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<=N; i++ ) {\n\t\t\tfor ( int j=0; j<=N; j++ ) {\n\t\t\t\tmap[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tcheck[i] = 1000000;\n\t\t}\n\n\t\tint a, b, d, e;\n\n\t\tfor ( int i=0; i<M; i++ ) {\n\t\t\tcin >> a >> b >> d>> e;\n\n\t\t\tmap[a][b] = d;\n\t\t\toff[a][b] = e;\n\t\t\tmap[b][a] = d;\n\t\t\toff[b][a] = e;\n\t\t}\n\n\n\t\tstatus.push(State(L, 0, 1));\n\t\tint ans;\n\t\tans = 10000000;\n\t\t//bool have = false;\n\t\twhile( !status.empty() ) {\n\t\t\tState now;\n\t\t\tnow = status.top();\n\t\t\tstatus.pop();\n\t\t\t\n\t\t\tif ( now.people >= ans ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << now.budget<< \"\\t\";\n\t\t\tcout << now.people<< \"\\t\";\n\t\t\tcout << now.wheres<< endl;\n\t\t\t*/\n\t\t\tif ( now.wheres == N ) {\n\t\t\t\tif ( ans > now.people) {\n\t\t\t\t\t//have = true;\n\t\t\t\t\tans = now.people;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !have.insert(now).second )\n\t\t\t\tcontinue;\n\n\t\t\tfor ( int i=1; i<=N; i++ ) {\n\t\t\t\t\tif ( i != now.wheres ) {\n\t\t\t\t\t\tif ( map[now.wheres][i] > 0 ) {\n\t\t\t\t\t\t\tif ( off[now.wheres][i] != 0 ) {\n\t\t\t\t\t\t\t\tif ( now.budget - map[now.wheres][i] >= 0 ) {\n\t\t\t\t\t\t\t\t\tstatus.push(State(now.budget-map[now.wheres][i],now.people,i));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstatus.push(State(now.budget,now.people+off[now.wheres][i],i));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstatus.push(State(now.budget,now.people,i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( ans == -1 )\n\t\t\tcout << \"No\" << endl;\n\t\telse\n\t\t\tcout <<ans << endl;\n\t}\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\ntemplate <typename T>\nstruct edge {\n    int from, to; T cost;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n};\n\ntemplate <typename T>\nvector<T> dijkstra(int s,vector<vector<edge<T>>> &G){\n    size_t n=G.size();\n    vector<T> d(n, INF<T>);\n    priority_queue<pair<T, int>,vector<pair<T, int>>,greater<>> Q;\n    d[s]=0;\n    Q.emplace(0,s);\n    while(!Q.empty()){\n        T cost; int i;\n        tie(cost, i) = Q.top(); Q.pop();\n        if(d[i] < cost) continue;\n        for (auto &&e : G[i]) {\n            auto cost2 = cost + e.cost;\n            if(d[e.to] <= cost2) continue;\n            d[e.to] = cost2;\n            Q.emplace(d[e.to], e.to);\n        }\n    }\n    return d;\n}\n\nint main() {\n    int n, m, l;\n    while(cin >> n >> m >> l, n){\n        vector<vector<edge<int>>> G(n*(l+1));\n        auto f = [&n, &l](int i, int j){return i*(l+1)+j; };\n        for (int i = 0; i < m; ++i) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--; b--;\n            for (int j = 0; j <= l; ++j) {\n                G[f(a, j)].emplace_back(f(b, j), e);\n                G[f(b, j)].emplace_back(f(a, j), e);\n                if(j >= d){\n                    G[f(a, j)].emplace_back(f(b, j-d), 0);\n                    G[f(b, j)].emplace_back(f(a, j-d), 0);\n                }\n            }\n        }\n        int ans = INF<int>;\n        auto d = dijkstra(f(0, l), G);\n        for (int i = 0; i <= l; ++i) {\n            ans = min(ans, d[f(n-1, i)]);\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<numeric>\n#include<vector>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define rforeach(t,p) for(t::reverse_iterator it=p.rbegin();it!=p.rend();++it)\n#define all(p) p.begin(),p.end()\nusing namespace std;\ntypedef pair<int,int> pp;\ntypedef pair<int,pp> ppp;\n#define LOAD 110\n\n\nint main()\n{\n    int n,m,l;\n    //cin >> n>>m>>l;\n    while(cin >> n >> m >> l && (n || m|| l))\n    {\n        int len[LOAD][LOAD],thi[LOAD][LOAD];\n        for(int i=0;i<LOAD;i++)for(int j=0;j<LOAD;j++)\n        {\n            len[i][j]=len[j][i]=thi[i][j]=thi[j][i]=-1;   \n        }\n        for(int i=0;i<m;i++)\n        {\n            int a,b,c,d;\n            cin >> a>>b>>c>>d;\n            len[a][b]=len[b][a]=c;\n            thi[a][b]=thi[b][a]=d;\n        }\n        set<ppp> in;\n        //set<int> visit;\n        in.insert(ppp(0,pp(l,1)));\n        //bool pass[LOAD][LOAD];\n        \n        while(true)\n        {\n            ppp a=(*in.begin());\n            in.erase(in.begin());\n            int e=a.first;\n            int mon=a.second.first;\n            int pos=a.second.second;\n            if(pos==n){cout << e << endl;break;}\n            for(int i=2;i<n+1;i++)if((len[pos][i] != -1 ))\n            {\n                //cout << i << endl;\n                in.insert(ppp(e+thi[pos][i],pp(mon,i)));\n                if(mon+1 >len[pos][i])\n                    in.insert(ppp(e,pp(mon-len[pos][i],i)));\n                //pass[pos][i]=true;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\n//int checker[4];\n//int ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\t//int check[4];\n\tState() {}\n\t//\tState() {check[0]=0;check[1]=0;check[2]=0;check[3]=0;}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\t/*\n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t\t*/\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n/*\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n*/\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min = b;\n\t\twhile ( itr != points[i].end() ) {\n\t\t\tif ( (*itr).second > min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t} else if ( (*itr).second <= min ) {\n\t\t\t\t(*itr).second = min;\n\t\t\t}\n\t\t\titr++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t/*\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\t*/\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\t//ncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\tint count = 0;\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//copy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\t\t\t\t/*\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n//\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct edge{\n  int to, d, n;\n  edge() {}\n  edge(int to, int d, int n) :\n    to(to), d(d), n(n) {}\n};\nstruct S{\n  int n, p, l;\n  S(int n, int p, int l) :\n    n(n), p(p), l(l) {}\n};\nbool operator < (const S& s, const S& t){\n  return s.n > t.n;\n}\nint main(){\n  int N, M, L;\n  while(cin>>N>>M>>L && N){\n    vector<edge> edges[101];\n    REP(i, M){\n      int A,B,D,E;\n      cin>>A>>B>>D>>E;\n      A--; B--;\n      edges[A].push_back(edge(B, D, E));\n      edges[B].push_back(edge(A, D, E));\n    }\n    priority_queue<S> que;\n    que.push(S(0, 0, L));\n    int memo[102][102];\n    REP(i, N)REP(j, L + 1)memo[i][j] = INF;\n    int ans = INF;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(s.p == N - 1) {\n        ans = s.n;\n        break;\n      }\n      if(memo[s.p][s.l] <= s.n) continue;\n      memo[s.p][s.l] = s.n;\n      REP(i, edges[s.p].size()){\n        edge e = edges[s.p][i];\n        que.push(S(s.n + e.n, e.to, s.l));\n        if(s.l >= e.d) que.push(S(s.n, e.to, s.l - e.d));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1 << 30;\n\nstruct edge{\n\tint to;\n\tint cost;\n\tint enemy;\n};\n\nvector<edge> G[200];\nint dis[200][200];\n\nint main(){\n\tint n, m, l;\n\twhile(cin >> n >> m >> l && (n || m || l)){\n\t\tmemset(dis, -1, sizeof(dis));\n\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tedge e;\n\t\t\tint from;\n\t\t\tint to;\n\t\t\tcin >> from >> e.to >> e.cost >> e.enemy;\n\t\t\tG[from].push_back(e);\n\t\t\tto = from;\n\t\t\tfrom = e.to;\n\t\t\te.to = to;\n\t\t\tG[from].push_back(e);\n\t\t}\n\t\tdis[1][l] = 0;\n\t\tque.push(PP(0, P(1, l)));\n/*\t\twhile(!que.empty()){\n\t\t\tPP pp = que.top(); que.pop();\n\t\t\tP p = pp.second;\n\t\t\tif(dis[p.first][p.second] < pp.first) continue;\n\t\t\tfor(int i = 0; i < G[p.first].size(); i++){\n\t\t\t\tedge e = G[p.first][i];\n\t\t\t\tif(dis[e.to][p.second] < 0 || dis[e.to][p.second] > dis[p.first][p.second] + e.enemy){\n\t\t\t\t\tdis[e.to][p.second] = dis[p.first][p.second] + e.enemy;\n\t\t\t\t\tque.push(PP(dis[e.to][p.second], P(e.to, p.second)));\n\t\t\t\t}\n\t\t\t\tif(p.second >= e.cost){\n\t\t\t\t\tif(dis[e.to][p.second - e.cost] < 0 || dis[e.to - e.cost][p.second] < dis[p.first][p.second]){\n\t\t\t\t\t\tdis[e.to][p.second - e.cost] = dis[p.first][p.second];\n\t\t\t\t\t\tque.push(PP(dis[e.to][p.second - e.cost], P(e.to, p.second - e.cost)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tint min_dis = INF;\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tif(dis[n][i] >= 0) min_dis = min(min_dis, dis[n][i]);\n\t\t}\n\t\tcout << min_dis << endl;\n\t\tfor(int i = 0; i < 200; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define INF 1 << 28\n\nstruct edge_t {\n    int from, to, enemy, distance;\n    edge_t(int from=0, int to=0, int distance=0, int enemy=0) :\n        from(from), to(to), distance(distance), enemy(enemy){}\n};\n\nstruct state_t {\n    int min_enemy;\n    int money;\n    int city;\n    state_t(int city=0, int min_enemy=0, int money=0) :\n        city(city), min_enemy(min_enemy), money(money) {}\n    bool operator<(const state_t &o) const {\n        return min_enemy == o.min_enemy ? \n                    money < o.money :\n                    min_enemy < o.min_enemy;\n    }\n    bool operator>(const state_t &o) const {\n        return min_enemy == o.min_enemy ?\n                    money > o.money :\n                    min_enemy > o.min_enemy;\n    }\n};\n\n#define MAX_V 101\n#define MAX_L 101\n\nint V;\nvector<edge_t> graph[MAX_V];\n//int enemy[MAX_V][MAX_L];\n\nint N, M, L;\n\nint dijkstra(int s, int g) {\n    int enemy[MAX_V][MAX_L];\n    priority_queue< state_t, vector<state_t>, greater<state_t> > q;\n    for (int i = 0; i < MAX_V; i++) \n        for (int j = 0; j < MAX_L; j++) \n            enemy[i][j] = INF;\n    enemy[s][L] = 0;\n    q.push(state_t(s, 0, L));\n\n    while (!q.empty()) {\n        state_t p = q.top(); q.pop();\n        if (enemy[p.city][p.money] < p.min_enemy) continue;\n        for (int i = 0; i < graph[p.city].size(); i++) {\n            edge_t e = graph[p.city][i];\n\n            // 護衛を雇わなかったとき\n            if (enemy[e.to][p.money] > enemy[p.city][p.money] + e.enemy) {\n                enemy[e.to][p.money] = enemy[p.city][p.money] + e.enemy;\n                q.push(state_t(e.to, enemy[e.to][p.money], p.money));\n            }\n            \n            // 護衛を雇ったとき\n            // そもそも護衛を雇う予算があるか\n            if (p.money - e.distance < 0) continue;\n            // あるなら\n            if (enemy[e.to][p.money - e.distance] > enemy[p.city][p.money]) {\n                enemy[e.to][p.money - e.distance] = enemy[p.city][p.money];\n                q.push(state_t(e.to, enemy[e.to][p.money - e.distance], p.money - e.distance));\n            }\n        }\n    }\n\n    int min_enemy = INF;\n    for (int i = 0; i < MAX_L; i++)  {\n        min_enemy = min(min_enemy, enemy[g][i]);\n    }\n    return min_enemy;\n}\n\nint main() {\n    while (cin >> N >> M >> L) {\n        if (N == 0 && M == 0 && L == 0) break;\n        for (int i = 0; i < N; i++) graph[i].clear();\n        for (int i = 0; i < M; i++) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            graph[a].push_back(edge_t(a, b, d, e));\n            graph[b].push_back(edge_t(b, a, d, e));\n        }\n        cout << dijkstra(1, N) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\nint n, m, l;\n\nint d[110][110][110];\n\nint dist[110][110];\n\nint main(){\n\twhile(1){\n\t\tn = in.nextInt(); m = in.nextInt(); l = in.nextInt();\n\t\tif(n == 0 && m == 0 && l == 0) break;\n\t\trep(i, 110) rep(j, 110) rep(k, 110) d[i][j][k] = (i == j ? 0 : INF);\n\t\trep(i, 110) rep(j, 110) dist[i][j] = INF;\n\n\t\trep(i, m){\n\t\t\tint a = in.nextInt() - 1 , b = in.nextInt() - 1, c = in.nextInt(), e = in.nextInt();\n\t\t\td[a][b][l] = d[b][a][l] = e;\n\t\t\tdist[a][b] = dist[b][a] = c;\n\t\t}\n\n\t\tfor(int money = l; money >= 0; money--){\n\t\t\trep(k, 110){\n\t\t\t\trep(i, 110){\n\t\t\t\t\trep(j, 110){\n\t\t\t\t\t\td[i][j][money] = min({d[i][j][money + 1], d[i][j][money], d[i][k][l] + d[k][j][l]});\n\t\t\t\t\t\tif(dist[i][k] <= money) d[i][j][money-dist[i][k]] = min(d[i][j][money-dist[i][k]], d[k][j][l]);\n\t\t\t\t\t\tif(dist[k][j] <= money) d[i][j][money-dist[j][k]] = min(d[i][j][money-dist[j][k]], d[i][k][l]);\n\t\t\t\t\t\tif(dist[i][k] + dist[k][j] <= money) d[i][j][money-(dist[i][k]+dist[k][j])] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, l + 1) ans = min(ans, d[0][n-1][i]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nstruct edge {\n    int to;\n    int cost;\n    int numOfTheaf;\n};\n\nstruct info {\n    int now;\n    int sumOfCost;\n    int sumOfTheaf;\n    bool operator < (const info &o) const {\n        return  sumOfTheaf > o.sumOfTheaf;\n    }\n};\n\nint main() {\n    int n, m, l;\n    while (cin >> n >> m >> l, n) {\n        vector <vector <edge> > G(n);\n        rep (i, m) {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--; b--;\n            G[a].push_back({b, d, e});\n            G[b].push_back({a, d, e});\n        }\n        //       to, sumOfCost -> sumOfTheaf\n        int dist[110][110] = {}; rep (i, 110) rep (j, 110) dist[i][j] = 1e9;\n        bool used[110][110] = {};\n\n        //info -> now, sumOfCost, sumOfTheaf\n        priority_queue <info> que;\n        que.push({0, 0, 0});\n\n        dist[0][0] = 0;\n\n        while (!que.empty()) {\n            info tmp = que.top(); que.pop();\n            rep (i, G[tmp.now].size()) {\n                //護衛を雇わない場合\n                {\n                    if ( dist[G[tmp.now][i].to][tmp.sumOfCost] > dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf ) {\n                        dist[G[tmp.now][i].to][tmp.sumOfCost] = dist[tmp.now][tmp.sumOfCost] + G[tmp.now][i].numOfTheaf;\n                        que.push({G[tmp.now][i].to, tmp.sumOfCost, dist[G[tmp.now][i].to][tmp.sumOfCost]});\n                    }\n                }\n                //護衛を雇う場合\n                {\n                //お金こえちゃだめ\n                    if ( G[tmp.now][i].cost + tmp.sumOfCost > l ) continue;\n                    if ( dist[G[tmp.now][i].to][tmp.sumOfCost + G[tmp.now][i].cost] > dist[tmp.now][tmp.sumOfCost] ) {\n                        dist[G[tmp.now][i].to][tmp.sumOfCost + G[tmp.now][i].cost] = dist[tmp.now][tmp.sumOfCost];\n                        que.push({G[tmp.now][i].to, tmp.sumOfCost + G[tmp.now][i].cost, tmp.sumOfTheaf});\n                    }\n                }\n            }\n        }\n        int ans = 1e9;\n        rep (i, l + 1) ans = min(ans, dist[n - 1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#define N1 101\n#define INF (1e9)\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P > P1;\nvoid dijkstra();\nint d[N1][N1],N,M,L,A,B,D,E;\nP cost[N1][N1];\nint main(){\n  while(1){\n    cin >> N >> M >> L;\n    if(N==0&&M==0&&L==0) break;\n    for(int i=0;i<N1;i++)\n      for(int j=0;j<N1;j++) d[i][j]=INF,cost[i][j].f=cost[i][j].s=-1;\n    for(int i=0;i<M;i++) cin >> A >> B >> D >> E,cost[A][B]=cost[B][A]=make_pair(D,E);\n    dijkstra();\n    int ans=INF;\n    for(int i=0;i<=L;i++) ans=min(ans,d[i][N]);\n    cout << ans << endl;\n  }\n  return 0;\n}\nvoid dijkstra(){\n  priority_queue<P1,vector<P1>,greater<P1> > PQ;\n  PQ.push(make_pair(0,make_pair(0,1)));\n  d[0][1]=0;\n  while(!PQ.empty()){\n    P1 t=PQ.top();\n    PQ.pop();\n    int u=t.s.s,l=t.s.f,cos=t.f;\n    if(cos<d[l][u]) continue;\n    for(int i=1;i<=N;i++){\n      int dd=cost[u][i].f,ee=cost[u][i].s;\n      if(dd!=-1&&ee!=-1&&i!=u){\n\tif(d[l][i]>d[l][u]+ee){\n\t  d[l][i]=d[l][u]+ee;\n\t  PQ.push(make_pair(d[l][i],make_pair(l,i)));\n\t}\n\tif(L-l>=dd&&d[l+dd][i]>d[l][u]){\n\t  d[l+dd][i]=d[l][u];\n\t  PQ.push(make_pair(d[l+dd][i],make_pair(l+dd,i)));\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAXN = 101;\nconst int MAXL = 101;\n\nstruct Edge {\n  int to, d, e;\n};\nstruct State {\n  int v, l, c;\n  bool operator <(const State &s) const {\n    if(c != s.c) return c > s.c;\n    if(l != s.l) return l < s.l;\n    return v < s.v;\n  }\n};\nconst int INF = 1<<28;\n\nint N, M, L;\nint cost[MAXN][MAXL];\nvector<Edge> E[MAXN];\n\nint dijkstra(int start, int goal) {\n  priority_queue<State> que;\n  State s = {start, L, 0};\n  fill(cost[0], cost[MAXN], INF);\n  cost[s.v][s.l] = 0;\n  que.push(s);\n  while(!que.empty()) {\n    s = que.top();\n    que.pop();\n    if(cost[s.v][s.l] < s.c) continue;\n    for(int i = 0; i < E[s.v].size(); ++i) {\n      const Edge &e = E[s.v][i];\n      do {\n        State t = {e.to,\n                   s.l - e.d,\n                   s.c};\n        if(t.l < 0) break;\n        if(cost[t.v][t.l] <= t.c) break;\n        cost[t.v][t.l] = t.c;\n        que.push(t);\n      }while(0);\n      do {\n        State t = {e.to,\n                   s.l,\n                   s.c + e.e};\n        if(cost[t.v][t.l] <= t.c) break;\n        cost[t.v][t.l] = t.c;\n        que.push(t);\n      }while(0);\n    }\n  }\n  int res = INF;\n  for(int j = 0; j <= L; ++j) {\n    res = min(res, cost[N-1][j]);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> N >> M >> L && (N|M|L)) {\n    fill(E,E+MAXN,vector<Edge>());\n    for(int i = 0; i < M; ++i) {\n      int a, b, d, e;\n      cin >> a >> b >> d >> e;\n      --a; --b;\n      E[a].push_back((Edge){b,d,e});\n      E[b].push_back((Edge){a,d,e});\n    }\n    cout << dijkstra(0,N-1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstatic const ll MAX = 1e10;\n\nenum Data {Space, File};\n\nstruct Range {\n  Data d;\n  int id;\n  ll start;\n  ll end;\n  ll size() const {\n    return end - start;\n  }\n  bool operator<(const Range& rhs) const {\n    return start < rhs.start;\n  }\n  void print() const {\n    printf(\"%c %d %lld %lld\\n\", (d == Space) ? 'S' : 'F', id, start, end);\n  }\n  Range(Data d, int id, ll start, ll end) : d(d), id(id), start(start), end(end) {}\n};\n\nint N;\nlist<Range> sector;\ntypedef list<Range> L;\n\nvoid solve() {\n  for (int i = 0; i < N; i++) {\n    char cmd;\n    cin >> cmd;\n    switch (cmd) {\n    case 'W': {\n      ll id, size;\n      cin >> id >> size;\n      for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n        if (it->d == Space) {\n          if (it->size() >= size) {\n            Range file(File, id, it->start, it->start + size);\n            sector.insert(it, file);\n            it->start += size;\n          } else {\n            it->d = File;\n            it->id = id;\n            size -= it->size();\n          }\n        }\n      }\n      break;\n    }\n    case 'D': {\n      ll id;\n      cin >> id;\n      for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n        if (it->d == File && it->id == id) {\n          L::iterator prev_it = it;\n          prev_it--;\n          \n          if (it != sector.begin() &&\n              prev_it->end == it->start && prev_it->d == Space) {\n            prev_it->end += it->size();\n            sector.erase(it);\n            break;\n          } else {\n            L::iterator next_it = it;\n            next_it++;\n            if (it != sector.end() && \n                next_it->start == it->end && next_it->d == Space) {\n              next_it->start -= it->size();\n              sector.erase(it);\n              break;\n            }\n          }\n          it->d = Space;\n        }\n      }\n      break;\n    }\n    case 'R': {\n      ll sec;\n      cin >> sec;\n      for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n        if (it->start <= sec && sec < it-> end) {\n          if (it->d == Space) {\n            cout << -1 << endl;\n          } else {\n            cout << it->id << endl;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    }\n    /*\n    cout << \"debug\" << endl;\n    for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n      it->print();\n    }\n    cout << endl;\n    */\n  }\n}\n\nvoid init() {\n  sector.clear();\n  sector.push_back(Range(Space, -1, 0, MAX));\n}\n\nint main() {\n  while (true) {\n    cin >> N;\n    if (N == 0) {\n      return 0;\n    }\n    init();\n    solve();\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <unordered_set>\n#include <vector>\n#include <functional>\n#include <iostream>\n\nusing namespace std;\n\ntemplate <typename S, typename GS>\nstruct Dijkstra2D\n{\n    Dijkstra2D(GS f, size_t r, size_t c) : fn(f), R(r), C(c) {}\n    GS fn;\n    size_t R, C;\n\n    S solve(S init)\n    {\n        std::priority_queue<S, std::vector<S>, std::greater<S>> q;\n        std::vector<std::vector<bool>> m(R, std::vector<bool>(C, false));\n\n        q.push(init);\n        while(!q.empty()){\n            S s = q.top(); q.pop();\n            if(m[s.i][s.j]) continue;\n            if(s.isEnd()) return s;\n            m[s.i][s.j] = 1;\n            fn.iterP(s, [&](S const & t){ if(!m[t.i][t.j]) { q.push(t); } });\n        }\n\n        S s{};\n        return s;\n    }\n};\n\n\n// ??¶????????¨??????\nstruct S {\n    int i; int j; int total; int N;\n    bool operator>(S const & e) const { return total > e.total; }\n    bool isEnd() const { return i == N-1; }\n};\n\n// ??????(???)?????¨??????\nstruct P {\n    int i, d, e;\n    bool b;\n    int N;\n    S apply(S const & s) const { return {i, b ? s.j - d : s.j, b ? s.total : s.total + e, N}; }\n};\n\n// ??¨????????¶???\nstruct GS\n{\n    // ????????¶????????????????????¨?????§???????????????????????????\n    template <typename Fn>\n    void iterP(S & s, Fn fn)\n    {\n        for(auto& p: paths[s.i]){\n            fn({p.i, s.j, s.total + p.e, N});\n            if(p.d <= s.j) fn({p.i, s.j - p.d, s.total, N});\n        }\n    }\n\n    int N, M, L;\n    std::vector<std::vector<P>> paths;\n};\n\n\nint main()\n{\n    int N, M, L;\n    while(cin >> N >> M >> L, N){\n        GS gs;\n        gs.N = N; gs.M = M; gs.L = L;\n        vector<vector<P>> ps(N);\n        for(auto& e: ps) e = vector<P>();\n\n        for(int i = 0; i < M; ++i){\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            ps[a-1].push_back({b-1, d, e, false});\n            ps[b-1].push_back({a-1, d, e, false});\n        }\n        gs.paths = ps;\n        Dijkstra2D<S, GS> dijkstra(gs, N, L);\n        S res = dijkstra.solve({0, L, 0, N});\n        cout << res.total << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nvoid Main() {\n  int n,m,l;\n  while(cin >> n >> m >> l&&n) {\n    vector<PP> v[n];\n    rep(i,m) {\n      int x,y,e,d;\n      cin >> x >> y >> e >> d;\n      x--,y--;\n      v[x].pb(PP(y,P(e,d)));\n      v[y].pb(PP(x,P(e,d)));\n    }\n    int d[n][l+1];\n    rep(i,n)rep(j,l+1)d[i][j]=MAX;\n    d[0][l]=0;\n    priority_queue<PP,vector<PP>,greater<PP> > que;\n    que.push(PP(0,P(0,l)));\n    while(!que.empty()) {\n      PP p=que.top();que.pop();\n      int x=p.S.F,r=p.S.S,c=p.F;\n      if(d[x][r]<c) continue;\n      rep(i,v[x].size()) {\n        PP q=v[x][i];\n        int y=q.F,cc=q.S.S,e=q.S.F;\n        if(d[y][r]>c+cc) {\n          d[y][r]=c+cc;\n          que.push(PP(c+cc,P(y,r)));\n        }\n        if(r-e>=0&&d[y][r-e]>c) {\n          d[y][r-e]=c;\n          que.push(PP(c,P(y,r-e)));\n        }\n      }\n    }\n    int ans=MAX;\n    rep(i,l+1) ans=min(ans,d[n-1][i]);\n    pr(ans);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> Node;\ntypedef pair<Node, int> pni;\n\nstruct Comp {\n\tbool operator() (pni a, pni b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nint solve(int N, int M, int L)\n{\n\tvvi D(N, vi(N, -1));\n\tvvi E(N, vi(N, -1));\n\n\trep(i, 0, M)\n\t{\n\t\tint a, b, d, e;\n\t\tcin >> a >> b >> d >> e;\n\t\ta--; b--;\n\t\t\n\t\tD[a][b] = d; D[b][a] = d;\n\t\tE[a][b] = e; E[b][a] = e;\n\t}\n\n\tpriority_queue<pni, vector<pni>, Comp> que;\n\tmap<Node, int> dist;\n\tset<Node> done;\n\n\tque.push(pni(Node(0, L), 0));\n\twhile (!que.empty())\n\t{\n\t\tNode n = que.top().first;\n\t\tint c = que.top().second;\n\t\tque.pop();\n\n\t\tif (done.find(n) != done.end()) continue;\n\t\tdone.insert(n);\n\n\t\tif (n.first == N - 1) return c;\n\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tif (D[n.first][i] < 0) continue;\n\n\t\t\tint newcost;\n\t\t\tNode newnode;\n\n\t\t\t// ????????????\n\t\t\tnewcost = c + E[n.first][i];\n\t\t\tnewnode = Node(i, n.second);\n\t\t\tif (dist.find(newnode) == dist.end()) dist[newnode] = INF;\n\t\t\tif (newcost < dist[newnode])\n\t\t\t{\n\t\t\t\tdist[newnode] = newcost;\n\t\t\t\tque.push(pni(newnode, newcost));\n\t\t\t}\n\n\t\t\t// ?????????????????????\n\t\t\tif (n.second < D[n.first][i]) continue;\n\t\t\tnewcost = c;\n\t\t\tnewnode = Node(i, n.second - D[n.first][i]);\n\t\t\tif (dist.find(newnode) == dist.end()) dist[newnode] = INF;\n\t\t\tif (newcost < dist[newnode])\n\t\t\t{\n\t\t\t\tdist[newnode] = newcost;\n\t\t\t\tque.push(pni(newnode, newcost));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint N, M, L;\n\t\tcin >> N >> M >> L;\n\t\tif (N == 0) return 0;\n\n\t\tcout << solve(N, M, L) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nstruct edge{\n    int to;\n    int fee;\n    int cost;\n};\nstruct state{\n    int cost;\n    int pos;\n    int cash;\n    bool operator < (const state &s)const{\n        return cost > s.cost;\n    }\n};\n \nconst int  MAX_V = 100;\nconst int  INF = 1e9;\nvector<edge> G[MAX_V];\nint V,E,L;\n \nvoid init();\nint dijkstra(int, int);\n \nint main(){\n  int a,b,c,d;\n  while(1){\n    cin >> V >> E >> L;\n    if(V == 0 && E == 0 && L == 0)break;\n    init();\n    for(int i = 0; i < E; i++){\n        cin >> a >> b >> c >> d;\n        a--;\n        b--;\n        G[a].push_back( (edge){b,c,d} );\n        G[b].push_back( (edge){a,c,d} );\n    }\n    cout << dijkstra(0,V-1) << endl;\n  }\n  return 0;\n}\n \nint dijkstra(int si, int ti){\n    int d[MAX_V][200];\n    fill(d[0], d[0] + MAX_V*200, INF);\n    d[si][L] = 0;\n    priority_queue<state> Q;\n    Q.push( (state){0, si, L} );\n    \n    while(!Q.empty()){\n        state now = Q.top();\n        Q.pop();\n        if(now.cost > d[now.pos][now.cash]) continue;\n\n        for(int i = 0; i < G[now.pos].size(); i++){\n            edge e = G[now.pos][i];\n            // 護衛を雇わない場合\n            if(now.cost + e.cost < d[e.to][now.cash]){\n                d[e.to][now.cash] = now.cost + e.cost;\n                Q.push( (state){now.cost + e.cost, e.to, now.cash} );\n            }\n            // この道で護衛を雇えない場合\n            if(now.cash - e.fee < 0) continue;\n            // 護衛を雇う場合\n            int ncash = now.cash - e.fee;\n            if(now.cost < d[e.to][ncash]){\n                d[e.to][ncash] = now.cost;\n                Q.push( (state){now.cost, e.to, ncash} );\n            }\n        }\n    }\n \n    int res = INF;\n        // 刺客の最小値をとる\n        for(int i = 0; i < 200; i++)\n            res = min(res,d[ti][i]);\n    return res;\n}\n \nvoid init(){\n    for(int i = 0; i < MAX_V; i++) G[i].clear();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 10000000\n\ntypedef pair<int, int> P;\n\nint main() {\n\tint n, m;\n\tlong long int l;\n\twhile (cin >> n >> m >> l) {\n\t\tif (n == 0 && m == 0 && l == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< vector<long long int> > dp(n, vector<long long int>(l+1, INF));\n\t\tvector< vector<P> > mp(n, vector<P>(n, P(-1, -1)));\n\t\tint a, b, d, e;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tmp[a][b] = mp[b][a] = P(d, e);\n\t\t}\n\t\tbool h = true;\n\t\tfor (int i = 0; i <= l; i++) {\n\t\t\tdp[0][i] = 0;\n\t\t}\n\t\twhile (h) {\n\t\t\th = false;\n\t\t\tvector< vector<long long int> > dp2;\n\t\t\tdp2 = dp;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif ((mp[i][j]).first != -1) {\n\t\t\t\t\t\tfor (int k = l; k >= 0; k--) {\n\t\t\t\t\t\t\tif (dp2[j][k] > dp[i][k] + (mp[i][j]).second) {\n\t\t\t\t\t\t\t\th = true;\n\t\t\t\t\t\t\t\tdp2[j][k] = dp[i][k] + (long long int)(mp[i][j]).second;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k - (mp[i][j]).first >= 0) {\n\t\t\t\t\t\t\t\tif (dp2[j][k - (mp[i][j]).first] > dp[i][k]) {\n\t\t\t\t\t\t\t\t\th = true;\n\t\t\t\t\t\t\t\t\tdp2[j][k - (mp[i][j]).first] = dp[i][k];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = dp2;\n\t\t}\n\t\tlong long int ans = INF;\n\t\tfor (int i = 0; i <= l; i++) {\n\t\t\tans = min(ans, dp[n - 1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\n#define INF (1 << 28)\n#define MAX_V 12000\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\ntypedef pair<int, int> P; // first??????????????¢???second??????????????????\n\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\n// ?????????O(|E|log|V|)\n\nvoid shortest_path(int s, int V){ // V???????????°\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor(int i = 0; i < V; i++){\n\t\td[i] = INF;\n\t}\n\td[s] = 0;\n\t\n\tque.push(P(0, s));\n\t\n\twhile(!que.empty()){\n\t\t\n\t\tP p = que.top();\n\t\tque.pop();\n\t\t\n\t\tint v = p.second;\n\t\t\n\t\tif(d[v] < p.first){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > e.cost + d[v]){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t} // ????????????????°???????????????´??°\n\t}\n}\n\nint main(){\n\t\n\tint N, M, L;\n\t\n\twhile(true){\n\t\t\n\t\tcin >> N >> M >> L;\n\t\t\n\t\tif(N == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N * (L + 1); i++){\n\t\t\tG[i].erase(G[i].begin(), G[i].end());\n\t\t}\n\t\t\n\t\tfor(int loop = 0; loop < M; loop++){\n\t\t\tint A, B, D, E;\n\t\t\tcin >> A >> B >> D >> E;\n\t\t\tA--;\n\t\t\tB--;\n\t\t\tfor(int i = D; i <= L; i++){\n\t\t\t\tedge e1;\n\t\t\t\te1.cost = 0;\n\t\t\t\te1.to = A + (i - D) * N;\n\t\t\t\tG[B + i * N].push_back(e1);\n\t\t\t\te1.to = B + (i - D) * N;\n\t\t\t\tG[A + i * N].push_back(e1);\n\t\t\t}\n\t\t\tfor(int i = 0; i <= L; i++){\n\t\t\t\tedge e1;\n\t\t\t\te1.cost = E;\n\t\t\t\te1.to = A + i * N;\n\t\t\t\tG[B + i * N].push_back(e1);\n\t\t\t\te1.to = B + i * N;\n\t\t\t\tG[A + i * N].push_back(e1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tedge e1;\n\t\t\te1.cost = 0;\n\t\t\tfor(int j = 0; j < L; j++){\n\t\t\t\te1.to = i + j * N;\n\t\t\t\tG[i + (j + 1) * N].push_back(e1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tshortest_path(L * N, (L + 1) * N);\n\t\t\n\t\t/*\n\t\tfor(int i = 0; i <= L; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tcout << d[j + i * N] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\t\n\t\tcout << d[N - 1] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define ISEQ(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1000000000;\n\ntypedef struct {\n  int to, cost;\n} edge;\nvector<edge> G[100*101];\nint d[100*101];\nbool used[100*101];\n\nvoid dijkstra(int s, int n) {\n  for (int i = 0; i < n; i++) {\n    d[i] = INF;\n    used[i] = false;\n  }\n  d[s] = 0;\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if (d[v] < p.first) continue;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n      edge e = G[v][i];\n      if (!used[e.to] and d[e.to] > d[v] + e.cost) {\n\td[e.to] = d[v] + e.cost;\n\tque.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\n\nint main() {\n  while (true) {\n    int n ,m, l;\n    scanf(\"%d%d%d\", &n, &m, &l);\n    if (n == 0) break;\n    \n    l++;\n    for (int i = 0; i < n*l; i++)\n      G[i].clear();\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < l-1; j++)\n\tG[i+n*j].push_back(edge{i+n*(j+1), 0});\n    }\n\n    for (int i = 0; i < m; i++) {\n      int a, b, d, e;\n      scanf(\"%d%d%d%d\", &a, &b, &d, &e);\n      a--; b--;\n      for (int j = 0; j < l; j++) {\n\tG[a+n*j].push_back(edge{b+n*j, e});\n\tG[b+n*j].push_back(edge{a+n*j, e});\n      }\n      for (int j = 0; j+d < l; j++) {\n\tG[a+n*j].push_back(edge{b+n*(j+d), 0});\n\tG[b+n*j].push_back(edge{a+n*(j+d), 0});\n      }\n    }\n    \n    dijkstra(0, n*l);\n\n    printf(\"%d\\n\", d[n*l-1]);\n  }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include<set>\n#include <vector>\n\n#define F first\n#define S second\n#define MAX_V 510\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P3;\n\nstruct edge{int to,d,e;};\n\nvector<edge>g[MAX_V];\nint d[MAX_V][101],n,m,l;\n\nvoid dijkstra(int s){\n  priority_queue<P3>que;\n\n  fill(d[0],d[MAX_V],INF);\n  d[s][l]=0;\n  que.push(P3(0,P(l,s)));\n\n  while(!que.empty()){\n    P3 p=que.top();que.pop();\n    int v=p.S.S;\n    if(d[v][p.S.F]<p.F)continue;\n\n    for(int i=0;i<g[v].size();i++){\n      edge e=g[v][i];\n      if(d[e.to][p.S.F]>d[v][p.S.F]+e.e){\n        d[e.to][p.S.F]=d[v][p.S.F]+e.e;\n        que.push(P3(d[e.to][p.S.F],P(p.S.F,e.to)));\n      }\n\n      if(p.S.F-e.d>=0 && d[e.to][p.S.F-e.d]>d[v][p.S.F]){\n        d[e.to][p.S.F-e.d]=d[v][p.S.F];\n        que.push(P3(d[e.to][p.S.F-e.d],P(p.S.F-e.d,e.to)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  while(cin >> n >> m >> l,n|m|l){\n    for(int i=0;i<MAX_V;i++)g[i].clear();\n    int a,b,d1,e;\n    for(int i=0;i<m;i++){\n      cin >> a >> b >> d1 >> e;\n      edge e1,e2;\n      e1.to=b,e1.d=d1,e1.e=e;\n      e2.to=a,e2.d=d1,e2.e=e;\n      g[a].push_back(e1);\n      g[b].push_back(e2);\n    }\n\n    dijkstra(1);\n    int ans=INF;\n    for(int j=0;j<101;j++){\n      ans=min(ans,d[n][j]);\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n \nusing namespace std;\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\nconst int MAX_N = 101, MAX_L = 101;\nint dp[MAX_N][MAX_L];\nstruct Edge{\n  int to, cost, num;\n  Edge(int t, int c, int n):\n\tto(t), cost(c), num(n){}  \n};\ntypedef vector<vector<Edge>> G;\ntypedef pair<int,PII> PPII;\n\nint N, M, L;\nint dijkstra(G& edges){\n  fill((int*)dp, (int*)dp+MAX_N*MAX_L, INF);\n  priority_queue<PPII, vector<PPII>, greater<PPII>> pq;\n  // num,node,cost\n  pq.push(MP(0,MP(0,L)));\n  dp[0][L] = 0;\n  \n  int ans = INF;\n  while(!pq.empty()){\n\tint num, node, cost;\n\tPPII ppii = pq.top(); pq.pop();\n\tnum = ppii.first, node = ppii.second.first, cost = ppii.second.second;\n\t\n\tif(node == N-1) ans = min(ans, num);\n\tif(dp[node][cost] < num) continue;\n\tfor(auto& e: edges[node]){\n\t  int n_ = num + e.num;\n\t  if(dp[e.to][cost] > n_){\n\t\tdp[e.to][cost] = n_;\n\t\tpq.push(MP(n_, MP(e.to, cost)));\n\t  }\n\t\t\n\t  int c_ = cost - e.cost;\n\t  if(c_ < 0 || dp[e.to][c_] <= num) continue;\n\t  dp[e.to][c_] = num;\n\t  pq.push(MP(num, MP(e.to, c_)));\n\t}\n  }\n\n  return ans;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N>>M>>L, N){\n\tG g(N);\n\tREP(i,M){\n\t  int a, b, d, e; cin >> a >> b >> d >> e;\n\t  --a, --b;\n\t  g[a].PB(Edge(b,d,e));\n\t  g[b].PB(Edge(a,d,e));\n\t}\n\n\tcout << dijkstra(g) << endl;;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define tr(it,container) for(typeof(container.begin()) it = container.begin(); \\\n                                                  it != container.end(); ++it)\n#define mp(a,b) make_pair((a),(b))\n\ntypedef long long ll;\ntypedef complex<double> point;\n\n// up right down left\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\nconst double EPS = 1e-9;\nconst int days[]     = {31,28,31,30,31,30,31,31,30,31,30,31};\nconst int daysleap[] = {31,29,31,30,31,30,31,31,30,31,30,31};\n\nconst int INF = 500000000;\n\nstruct Edge{\n    int from,to,cost,danger;\n    Edge(int from,int to,int cost,int danger)\n        : from(from),to(to),cost(cost),danger(danger) {}\n};\n\nint solve(vector<vector<Edge> > graph,int L){\n    int n = graph.size();\n    vector<vector<int> > dp(n,vector<int>(L+1,INF));\n    dp[0][0] = 0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            for(int k=0;k<graph[j].size();k++){\n                const Edge& edge = graph[j][k];\n                for(int l=0;l<=L;l++){\n                    if(dp[j][l] >= INF) continue;\n                    if(l+edge.cost <= L){\n                        int new_cost = l+edge.cost;\n                        int to = edge.to;\n                        int here = dp[j][l];\n                        dp[to][new_cost] = min(dp[to][new_cost],dp[j][l]);\n                    }\n                    dp[edge.to][l] = min(dp[edge.to][l],dp[j][l]+edge.danger);\n                }\n            }\n        }\n    }\n    int ret = INF;\n    for(int i=0;i<=L;i++){\n        ret = min(ret,dp.back()[i]);\n    }\n    return ret;\n}\n\nint main(){\n    while(true){\n        int n,m,l;\n        cin >> n >> m >> l;\n        if(n == 0) break;\n        vector<vector<Edge> > edges(n);\n        for(int i=0;i<m;i++){\n            int a,b,d,e;\n            cin >> a >> b >> d >> e;\n            a--;b--;\n            edges[a].push_back(Edge(a,b,d,e));\n            edges[b].push_back(Edge(b,a,d,e));\n        }\n        cout << solve(edges,l) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<numeric>\n#include<vector>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define rforeach(t,p) for(t::reverse_iterator it=p.rbegin();it!=p.rend();++it)\n#define all(p) p.begin(),p.end()\nusing namespace std;\ntypedef pair<int,int> pp;\ntypedef pair<int,pp> ppp;\n#define LOAD 110\n\n\nint main()\n{\n    int n,m,l;\n    //cin >> n>>m>>l;\n    while(cin >> n >> m >> l && (n || m|| l))\n    {\n        int len[LOAD][LOAD],thi[LOAD][LOAD];\n        for(int i=0;i<LOAD;i++)for(int j=0;j<LOAD;j++)\n        {\n            len[i][j]=len[j][i]=thi[i][j]=thi[j][i]=-1;   \n        }\n        for(int i=0;i<m;i++)\n        {\n            int a,b,c,d;\n            cin >> a>>b>>c>>d;\n            len[a][b]=len[b][a]=c;\n            thi[a][b]=thi[b][a]=d;\n\n        }\n        set<ppp> in;\n        //set<int> visit;\n        in.insert(ppp(0,pp(l,1)));\n        bool pass[LOAD][LOAD];\n        \n        while(!in.empty())\n        {\n            ppp a=(*in.begin());\n            in.erase(in.begin());\n            int e=a.first;\n            int mon=a.second.first;\n            int pos=a.second.second;\n            if(pos==n){cout << e << endl;break;}\n            for(int i=2;i<=n;i++)if((len[pos][i] != -1 ))\n            {\n                //cout << i << endl;\n                in.insert(ppp(e+thi[pos][i],pp(mon,i)));\n                if(mon>=len[pos][i])\n                    in.insert(ppp(e,pp(mon-len[pos][i],i)));\n                //pass[pos][i]=true;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define LEN 100\n#define BASE 25\n\nusing namespace std;\n\nint maps[LEN][LEN];\nint off[LEN][LEN];\n\nint checker[4];\nint ncheck[4];\n\nmap<int, int> points[LEN];\n\nclass State {\npublic:\n\tchar where;\n\tint enemy;\n\tint budget;\n\tint check[4];\n\tState() {}\n\tState(char w, int e, int b ) {\n\t\twhere = w;\n\t\tenemy = e;\n\t\tbudget = b; \n\t\tcheck[0] = ncheck[0];\n\t\tcheck[1] = ncheck[1];\n\t\tcheck[2] = ncheck[2];\n\t\tcheck[3] = ncheck[3];\n\t}\n};\n\n\ninline bool operator< ( const State& a, const State& b) {\n\tif( a.enemy == b.enemy )\n\t\treturn a.budget > b.budget;\n\treturn a.enemy < b.enemy;\n}\n\ninline bool operator> ( const State& a, const State& b) {\n\tif ( a.enemy == b.enemy )\n\t\treturn a.budget < b.budget;\n\treturn a.enemy > b.enemy;\n}\n\npriority_queue<State, vector<State>, greater<State> > status;\n\ninline void copy ( State now ) {\n\tchecker[0] = now.check[0];\n\tchecker[1] = now.check[1];\n\tchecker[2] = now.check[2];\n\tchecker[3] = now.check[3];\n}\n\ninline void ncopy ( ) {\n\tncheck[0] = checker[0];\n\tncheck[1] = checker[1];\n\tncheck[2] = checker[2];\n\tncheck[3] = checker[3];\n}\n\ninline bool check ( int i ) {\n\treturn 0 == ((1<<(i%25)) & checker[i/BASE]);\n}\n\ninline void add ( int i ) {\n\tncheck[i/BASE] = ((1<<(i%25)) | checker[i/BASE]);\n}\n\ninline void insert ( int i, int e, int b ) {\n\t\n\tmap<int,int>::iterator itr = points[i].find(e);\n\tif ( itr == points[i].end() ) {\n\t\tpoints[i][e] = b;\n\t\tstatus.push(State(i,e,b));\n\t} else if ( (*itr).second < b ) {\n\t\t(*itr).second = b;\n\t\tstatus.push(State(i,e,b));\n\t\tint min = b;\n\t\twhile ( itr != points[i].end() ) {\n\t\t\tif ( (*itr).second > min ) {\n\t\t\t\tmin = (*itr).second;\n\t\t\t} else {\n\t\t\t\t(*itr).second = min;\n\t\t\t}\n\t\t\titr++;\n\t\t}\n\t}\n}\n\nint main () {\n\n\n\twhile ( true ) {\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tmaps[i][j] = -1;\n\t\t\t\toff[i][j] = 0;\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\n\t\t\tmaps[a-1][b-1] = maps[b-1][a-1] = d;\n\t\t\toff[a-1][b-1] = off[b-1][a-1] = e;\n\t\t}\n\t\t\n\t\tfor ( int i=0; i<4; i++ ) {\n\t\t\tncheck[i] = 0;\n\t\t\tchecker[i] = 0;\n\t\t}\n\n\t\tpriority_queue<State, vector<State>, greater<State> > empty;\n\t\tstatus = empty;\n\n\t\tncheck[0] = 1;\n\t\tstatus.push(State(0,0,l));\n\t\t\n\t\twhile(!status.empty()) {\n\t\t\tState now = status.top();\n\t\t\tstatus.pop();\n\t\t\tif ( now.where == n-1 ) {\n\t\t\t\tcout << now.enemy << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy(now);\n\n\t\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\t\tif ( maps[now.where][i] > 0 ) {\n\n\t\t\t\t\tif ( check( i ) ) {\n\t\t\t\t\t\tncopy();\n\t\t\t\t\t\tadd(i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tint e, b;\n\t\t\t\t\t\tif ( off[now.where][i] == 0 ) {\n\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( now.budget - maps[now.where][i] >= 0 ) {\n\t\t\t\t\t\t\t\te = now.enemy;\n\t\t\t\t\t\t\t\tb = now.budget - maps[now.where][i];\n\t\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te = now.enemy + off[now.where][i];\n\t\t\t\t\t\t\tb = now.budget;\n\t\t\t\t\t\t\tinsert(i,e,b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nint V;\n \nint vv(int v, int mon)\n{\n    return v * (l + 1) + mon;\n}\n \nvector<int> dijkstra(int s, vector<vector<pair<int, int>>> &edge)\n{\n    const int INF = 1e9;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    priority_queue<pair<int, int>> que; //cost v\n    que.push(make_pair(0, s));\n    while (!que.empty())\n    {\n        auto st = que.top();\n        que.pop();\n        int v = st.second;\n        int cost = st.first;\n        if (d[v] < cost)\n            continue;\n        for (int i = 0; i < edge[v].size(); i++)\n        {\n            int to = edge[v][i].second;\n            if (cost + edge[v][i].first < d[to])\n            {\n                d[to] = cost + edge[v][i].first;\n                que.push(make_pair([to], to));\n            }\n        }\n    }\n    return d;\n}\n \nint main()\n{\n    while (true)\n    {\n        cin >> n >> m >> l;\n        if (n == 0)\n            break;\n        V = n * (l + 1);\n        vector<vector<pair<int, int>>> edge(V); //cost,to\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d, e;\n            cin >> a >> b >> d >> e;\n            a--, b--;\n            for (int j = 0; j <= l; j++)\n            {\n                edge[vv(a, j)].push_back(make_pair(e, vv(b, j)));\n                edge[vv(b, j)].push_back(make_pair(e, vv(a, j)));\n                if (j - d >= 0)\n                {\n                    edge[vv(a, j)].push_back(make_pair(0, vv(b, j - d)));\n                    edge[vv(b, j)].push_back(make_pair(0, vv(a, j - d)));\n                }\n            }\n        }\n        vector<int> d = dijkstra(vv(0, l), edge);\n        int res = 1e9;\n \n        for (int i = 0; i <= l; i++)\n        {\n            int val=d[vv(n-1,i)];\n             \n            res = min(res,val);\n        }\n \n        cout << res << endl;\n    }\n    return 0;\n}\n "
  },
  {
    "language": "C",
    "code": "// AOJ 2151: Brave Princess Revisited\n// 2017.11.11 bal4u\n// 2018.2.6\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int t, n, m; } QUE;\nQUE que[20001]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\t\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i]; que[i] = que[min]; que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].n, *m = que[0].m;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int t, int n, int m)\n{\n\tint i, min;\n\tQUE qt;\n\t\n\ti = qsize++;\n\tque[i].t = t, que[i].n = n, que[i].m = m;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i]; que[i] = que[min]; que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint to[101][101], d[101][101], e[101][101], hi[101];\nint node[101][101];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint dijkstra(int start, int goal, int l)\n{\n\tint s, m, i, k, t, p, ans;\n\n\tmemset(node, 0x33, sizeof(node));\n\tans = 0x7fffff;\n\tqsize = 0;\n\tnode[start][l] = 0; enq(0, start, l);\n\n\twhile (qsize) {\n\t\ts = que[0].n, m = que[0].m, p = que[0].t, deq();\n\n\t\tif (p > node[s][m]) continue; \n\t\tif (s == goal) { ans = p; break; }\n\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\tt = to[s][i];\n\n\t\t\tk = p + e[s][i];\n\t\t\tif (k < node[t][m]) node[t][m] = k, enq(k, t, m);\n\n\t\t\tk = m - d[s][i];\n\t\t\tif (d[s][i] <= m && p < node[t][k]) node[t][k] = p, enq(p, t, k);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n, m, l, k, a, b, _d, _e, i;\n\n\twhile (n = in()) {\n\t\tm = in(), l = in();\n\t\tmemset(hi, 0, n << 2);\n\t\tfor (i = 0; i < m; i++) {\n\t\t\ta = in()-1, b = in()-1, _d = in(), _e = in();\n\t\t\tk = hi[a]++;\n\t\t\tto[a][k] = b, d[a][k] = _d, e[a][k] = _e;\n\t\t\tk = hi[b]++;\n\t\t\tto[b][k] = a, d[b][k] = _d, e[b][k] = _e;\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra(0, n-1, l));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2151: Brave Princess Revisited\n// 2017.11.11 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int t, n, m; } QUE;\nQUE que[20001]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tQUE t = que[i]; que[i] = que[min]; que[min] = t;\n\t\tmin_heapify(min);\n\t}\n}\n\nint deq(int *n, int *m)\n{\n\tif (qsize == 0) return 0;\n\t*n = que[0].n, *m = que[0].m;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n\treturn 1;\n}\n\nvoid enq(int t, int n, int m)\n{\n\tint i, min;\n\n\ti = qsize++;\n\tque[i].t = t, que[i].n = n, que[i].m = m;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tQUE tt = que[i]; que[i] = que[min]; que[min] = tt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { int len, to[101], d[101], e[101]; } TBL;\nTBL tbl[101];\nint node[101][101]; int size;\n\nint search(int start, int goal, int l)\n{\n\tint s, m, i, k, e, p, ans;\n\tTBL *tp;\n\n\tqsize = 0;\n\tmemset(node, 0x55, sizeof(node));\n\tnode[start][l] = 0; enq(0, start, l);\n\tans = 0x7ffffff;\n\twhile(deq(&s, &m)) {\n\t\tp = node[s][m];\n\t\tif (s == goal) {\n\t\t\tif (p < ans) ans = p;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (tp = tbl + s, i = 0; i < tp->len; i++) {\n\t\t\te = tp->to[i];\n\n\t\t\tk = p + tp->e[i];\n\t\t\tif (k < node[e][m]) node[e][m] = k, enq(node[e][m], e, m);\n\n\t\t\tk = m - tp->d[i];\n\t\t\tif (tp->d[i] <= m && p < node[e][k]) node[e][k] = p, enq(node[e][k], e, k);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n, m, l, a, b, d, e, i;\n\n\twhile (scanf(\"%d%d%d\", &n, &m, &l) && n > 0) {\n\t\tmemset(tbl, 0, sizeof(tbl));\n\t\twhile (m--) {\n\t\t\tscanf(\"%d%d%d%d\", &a, &b, &d, &e);\n\t\t\ta--, b--;\n\t\t\ti = tbl[a].len, tbl[a].to[i] = b, tbl[a].d[i] = d, tbl[a].e[i] = e, tbl[a].len++;\n\t\t\ti = tbl[b].len, tbl[b].to[i] = a, tbl[b].d[i] = d, tbl[b].e[i] = e, tbl[b].len++;\n\t\t}\n\t\tsize = n;\n\t\tprintf(\"%d\\n\", search(0, n-1, l));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DIJKSTRA_MAX_NODE 11000\n#define DIJKSTRA_MAX_EDGE 44000\n\ntypedef struct {\n\tint from,to;\n\tint cost;\n} dijkstra_edge_t;\n\ntypedef struct {\n\tint node;\n\tint cost;\n} dijkstra_node_t;\n\nint dijkstra_edge_num;\ndijkstra_edge_t dijkstra_edge[DIJKSTRA_MAX_EDGE];\nint dijkstra_node_edge[DIJKSTRA_MAX_NODE][2];\nint dijkstra_queue_num;\ndijkstra_node_t dijkstra_queue[DIJKSTRA_MAX_EDGE+1];\nint dijkstra_cost[DIJKSTRA_MAX_NODE];\nchar dijkstra_visited[DIJKSTRA_MAX_NODE];\n\nint dijkstra_comp(const void* x,const void* y) {\n\tconst dijkstra_edge_t* a=(const dijkstra_edge_t*)x;\n\tconst dijkstra_edge_t* b=(const dijkstra_edge_t*)y;\n\tif((a->from)>(b->from))return 1;\n\tif((a->from)<(b->from))return -1;\n\tif((a->to)>(b->to))return 1;\n\tif((a->to)<(b->to))return -1;\n\treturn 0;\n}\n\nvoid dijkstra_queue_adjust(int pos) {\n\tint min=pos;\n\tif(pos*2+1<dijkstra_queue_num &&\n\t\tdijkstra_queue[min].cost>dijkstra_queue[pos*2+1].cost)\n\t\t\tmin=pos*2+1;\n\tif(pos*2+2<dijkstra_queue_num &&\n\t\tdijkstra_queue[min].cost>dijkstra_queue[pos*2+2].cost)\n\t\t\tmin=pos*2+2;\n\tif(min!=pos) {\n\t\tdijkstra_node_t temp;\n\t\ttemp=dijkstra_queue[min];\n\t\tdijkstra_queue[min]=dijkstra_queue[pos];\n\t\tdijkstra_queue[pos]=temp;\n\t\tdijkstra_queue_adjust(min);\n\t} else if(pos>0)dijkstra_queue_adjust((pos-1)/2);\n}\n\nvoid dijkstra_queue_push(int node,int cost) {\n\tdijkstra_node_t topush;\n\ttopush.node=node;topush.cost=cost;\n\tdijkstra_queue[dijkstra_queue_num++]=topush;\n\tdijkstra_queue_adjust(dijkstra_queue_num-1);\n}\n\ndijkstra_node_t dijkstra_queue_pop(void) {\n\tdijkstra_node_t result=dijkstra_queue[0];\n\tif(dijkstra_queue_num>0) {\n\t\tdijkstra_queue[0]=dijkstra_queue[--dijkstra_queue_num];\n\t\tdijkstra_queue_adjust(0);\n\t}\n\treturn result;\n}\n\nvoid dijkstra_init(void) {\n\tdijkstra_edge_num=0;\n}\n\nvoid dijkstra_addedge(int from,int to,int cost) {\n\tdijkstra_edge[dijkstra_edge_num].from=from;\n\tdijkstra_edge[dijkstra_edge_num].to=to;\n\tdijkstra_edge[dijkstra_edge_num].cost=cost;\n\tdijkstra_edge_num++;\n}\n\nvoid dijkstra_setup(void) {\n\tint i;\n\tint prev;\n\tqsort(dijkstra_edge,dijkstra_edge_num,\n\t\tsizeof(dijkstra_edge_t),dijkstra_comp);\n\tprev=0;\n\tmemset(dijkstra_node_edge,0,sizeof(dijkstra_node_edge));\n\tdijkstra_node_edge[0][0]=0;\n\tfor(i=0;i<dijkstra_edge_num;i++) {\n\t\tif(dijkstra_edge[i].from!=dijkstra_edge[prev].from) {\n\t\t\tdijkstra_node_edge[dijkstra_edge[prev].from][1]=i;\n\t\t\tdijkstra_node_edge[dijkstra_edge[i].from][0]=i;\n\t\t\tprev=i;\n\t\t}\n\t}\n\tdijkstra_node_edge[dijkstra_edge[prev].from][1]=i;\n}\n\nint dijkstra_search(int from,int to) {\n\tint i;\n\tmemset(dijkstra_cost,0xFF,sizeof(dijkstra_cost));\n\tmemset(dijkstra_visited,0,sizeof(dijkstra_visited));\n\tdijkstra_queue_num=0;\n\tdijkstra_queue_push(from,0);\n\twhile(dijkstra_queue_num>0) {\n\t\tdijkstra_node_t nownode=dijkstra_queue_pop();\n\t\tif(!dijkstra_visited[nownode.node]) {\n\t\t\tdijkstra_visited[nownode.node]=1;\n\t\t\tdijkstra_cost[nownode.node]=nownode.cost;\n\t\t\tfor(i=dijkstra_node_edge[nownode.node][0];\n\t\t\t\t\ti<dijkstra_node_edge[nownode.node][1];i++) {\n\t\t\t\tif(!dijkstra_visited[dijkstra_edge[i].to] &&\n\t\t\t\t\t\t(dijkstra_cost[dijkstra_edge[i].to]<0 ||\n\t\t\t\t\t\tdijkstra_cost[dijkstra_edge[i].to]>nownode.cost+dijkstra_edge[i].cost)) {\n\t\t\t\t\tdijkstra_queue_push(\n\t\t\t\t\t\tdijkstra_edge[i].to,\n\t\t\t\t\t\tnownode.cost+dijkstra_edge[i].cost\n\t\t\t\t\t);\n\t\t\t\t\tdijkstra_cost[dijkstra_edge[i].to]=nownode.cost+dijkstra_edge[i].cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dijkstra_cost[to];\n}\n\nint get_id(int node, int syozikin) {\n\treturn syozikin*100+node;\n}\n\nint main(void) {\n\tint N,M,L;\n\twhile(scanf(\"%d%d%d\",&N,&M,&L)==3 && (N|M|L)!=0) {\n\t\tint i,j;\n\t\tdijkstra_init();\n\t\tfor(i=0;i<M;i++) {\n\t\t\tint A,B,D,E;\n\t\t\tscanf(\"%d%d%d%d\",&A,&B,&D,&E);\n\t\t\tA--;B--;\n\t\t\tfor(j=0;j<=100;j++) {\n\t\t\t\t/* mukakin (osowareru) */\n\t\t\t\tdijkstra_addedge(get_id(A,j),get_id(B,j),E);\n\t\t\t\tdijkstra_addedge(get_id(B,j),get_id(A,j),E);\n\t\t\t\t/* kakin (osowarenai) */\n\t\t\t\tif(j>=D) {\n\t\t\t\t\tdijkstra_addedge(get_id(A,j),get_id(B,j-D),0);\n\t\t\t\t\tdijkstra_addedge(get_id(B,j),get_id(A,j-D),0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* goal */\n\t\tfor(i=1;i<=100;i++) {\n\t\t\tdijkstra_addedge(get_id(N-1,i),get_id(N-1,i-1),0);\n\t\t}\n\t\tdijkstra_setup();\n\t\tprintf(\"%d\\n\",dijkstra_search(get_id(0,L),get_id(N-1,0)));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2151: Brave Princess Revisited\n// 2017.11.11 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#define TM 0\n#if TM\n#include <time.h>\n#endif\n\ntypedef struct { int t, n, m; } QUE;\nQUE que[20001]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tQUE t = que[i]; que[i] = que[min]; que[min] = t;\n\t\tmin_heapify(min);\n\t}\n}\n\nint deq(int *n, int *m)\n{\n\tif (qsize == 0) return 0;\n\t*n = que[0].n, *m = que[0].m;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n\treturn 1;\n}\n\nvoid enq(int t, int n, int m)\n{\n\tint i, min;\n\n\ti = qsize++;\n\tque[i].t = t, que[i].n = n, que[i].m = m;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tQUE tt = que[i]; que[i] = que[min]; que[min] = tt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { int len, to[101], d[101], e[101]; } TBL;\nTBL tbl[101];\nint node[101][101]; int size;\n\nint search(int start, int goal, int l)\n{\n\tint s, m, i, k, e, p, ans;\n\tTBL *tp;\n\n\tqsize = 0;\n\tmemset(node, 0x33, sizeof(node));\n\tnode[start][l] = 0; enq(0, start, l);\n\tans = 0x7fffff;\n\twhile(deq(&s, &m)) {\n\t\tp = node[s][m];\n\t\tif (s == goal) {\n\t\t\tif (p < ans) ans = p;\n\t\t\tif (ans == 0) break;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (tp = tbl + s, i = 0; i < tp->len; i++) {\n\t\t\te = tp->to[i];\n\n\t\t\tk = p + tp->e[i];\n\t\t\tif (k < node[e][m]) node[e][m] = k, enq(node[e][m], e, m);\n\n\t\t\tk = m - tp->d[i];\n\t\t\tif (tp->d[i] <= m && p < node[e][k]) node[e][k] = p, enq(node[e][k], e, k);\n\t\t}\n\t}\n\treturn ans;\n}\n\nchar buf[30], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, l, a, b, d, e, i;\n\tTBL *tp;\n#if TM\n\tclock_t start, end;\n\tstart = clock();\n#endif\n\n\twhile (fgets(p=buf, 30, stdin) && *p != '0') {\n\t\tn = getint(), p++, m = getint(), p++, l = getint();\n\t\tmemset(tbl, 0, sizeof(tbl));\n\t\twhile (m--) {\n\t\t\tfgets(p=buf, 30, stdin);\n\t\t\ta = getint()-1, p++, b = getint()-1, p++, d = getint(), p++, e = getint();\n\t\t\ttp = tbl+a, i = tp->len;\n\t\t\ttp->to[i] = b, tp->d[i] = d, tp->e[i] = e, tp->len++;\n\t\t\ttp = tbl+b, i = tp->len;\n\t\t\ttp->to[i] = a, tp->d[i] = d, tp->e[i] = e, tp->len++;\n\t\t}\n\t\tsize = n;\n\t\tprintf(\"%d\\n\", search(0, n-1, l));\n\t}\n#if TM\n\tend = clock();\n\tprintf(\"time %lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2151: Brave Princess Revisited\n// 2017.11.11 bal4u\n// 2018.2.6\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int t, n, m; } QUE;\nQUE que[20001]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\t\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i]; que[i] = que[min]; que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].n, *m = que[0].m;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int t, int n, int m)\n{\n\tint i, min;\n\tQUE qt;\n\t\n\ti = qsize++;\n\tque[i].t = t, que[i].n = n, que[i].m = m;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i]; que[i] = que[min]; que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint to[101][101], d[101][101], e[101][101], hi[101];\nint node[101][101];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint dijkstra(int start, int goal, int l)\n{\n\tint s, m, i, k, t, p, ans;\n\n\tmemset(node, 0x33, sizeof(node));\n\tans = 0x7fffff;\n\tqsize = 0;\n\tnode[start][l] = 0; enq(0, start, l);\n\n\twhile (qsize) {\n\t\ts = que[0].n, m = que[0].m, deq();\n\t\tp = node[s][m];\n\n\t\tif (s == goal) {\n\t\t\tif (p < ans) ans = p;\n\t\t\tif (ans == 0) break;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\tt = to[s][i];\n\n\t\t\tk = p + e[s][i];\n\t\t\tif (k < node[t][m]) node[t][m] = k, enq(node[t][m], t, m);\n\n\t\t\tk = m - d[s][i];\n\t\t\tif (d[s][i] <= m && p < node[t][k]) node[t][k] = p, enq(node[t][k], t, k);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n, m, l, k, a, b, _d, _e, i;\n\n\twhile (n = in()) {\n\t\tm = in(), l = in();\n\t\tmemset(hi, 0, n << 2);\n\t\tfor (i = 0; i < m; i++) {\n\t\t\ta = in()-1, b = in()-1, _d = in(), _e = in();\n\t\t\tk = hi[a]++;\n\t\t\tto[a][k] = b, d[a][k] = _d, e[a][k] = _e;\n\t\t\tk = hi[b]++;\n\t\t\tto[b][k] = a, d[b][k] = _d, e[b][k] = _e;\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra(0, n-1, l));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DIJKSTRA_MAX_NODE 11000\n#define DIJKSTRA_MAX_EDGE 22000\n\ntypedef struct {\n\tint from,to;\n\tint cost;\n} dijkstra_edge_t;\n\ntypedef struct {\n\tint node;\n\tint cost;\n} dijkstra_node_t;\n\nint dijkstra_edge_num;\ndijkstra_edge_t dijkstra_edge[DIJKSTRA_MAX_EDGE];\nint dijkstra_node_edge[DIJKSTRA_MAX_NODE][2];\nint dijkstra_queue_num;\ndijkstra_node_t dijkstra_queue[DIJKSTRA_MAX_EDGE+1];\nint dijkstra_cost[DIJKSTRA_MAX_NODE];\nchar dijkstra_visited[DIJKSTRA_MAX_NODE];\n\nint dijkstra_comp(const void* x,const void* y) {\n\tconst dijkstra_edge_t* a=(const dijkstra_edge_t*)x;\n\tconst dijkstra_edge_t* b=(const dijkstra_edge_t*)y;\n\tif((a->from)>(b->from))return 1;\n\tif((a->from)<(b->from))return -1;\n\tif((a->to)>(b->to))return 1;\n\tif((a->to)<(b->to))return -1;\n\treturn 0;\n}\n\nvoid dijkstra_queue_adjust(int pos) {\n\tint min=pos;\n\tif(pos*2+1<dijkstra_queue_num &&\n\t\tdijkstra_queue[min].cost>dijkstra_queue[pos*2+1].cost)\n\t\t\tmin=pos*2+1;\n\tif(pos*2+2<dijkstra_queue_num &&\n\t\tdijkstra_queue[min].cost>dijkstra_queue[pos*2+2].cost)\n\t\t\tmin=pos*2+2;\n\tif(min!=pos) {\n\t\tdijkstra_node_t temp;\n\t\ttemp=dijkstra_queue[min];\n\t\tdijkstra_queue[min]=dijkstra_queue[pos];\n\t\tdijkstra_queue[pos]=temp;\n\t\tdijkstra_queue_adjust(min);\n\t} else if(pos>0)dijkstra_queue_adjust((pos-1)/2);\n}\n\nvoid dijkstra_queue_push(int node,int cost) {\n\tdijkstra_node_t topush;\n\ttopush.node=node;topush.cost=cost;\n\tdijkstra_queue[dijkstra_queue_num++]=topush;\n\tdijkstra_queue_adjust(dijkstra_queue_num-1);\n}\n\ndijkstra_node_t dijkstra_queue_pop(void) {\n\tdijkstra_node_t result=dijkstra_queue[0];\n\tif(dijkstra_queue_num>0) {\n\t\tdijkstra_queue[0]=dijkstra_queue[--dijkstra_queue_num];\n\t\tdijkstra_queue_adjust(0);\n\t}\n\treturn result;\n}\n\nvoid dijkstra_init(void) {\n\tdijkstra_edge_num=0;\n}\n\nvoid dijkstra_addedge(int from,int to,int cost) {\n\tdijkstra_edge[dijkstra_edge_num].from=from;\n\tdijkstra_edge[dijkstra_edge_num].to=to;\n\tdijkstra_edge[dijkstra_edge_num].cost=cost;\n\tdijkstra_edge_num++;\n}\n\nvoid dijkstra_setup(void) {\n\tint i;\n\tint prev;\n\tqsort(dijkstra_edge,dijkstra_edge_num,\n\t\tsizeof(dijkstra_edge_t),dijkstra_comp);\n\tprev=0;\n\tmemset(dijkstra_node_edge,0,sizeof(dijkstra_node_edge));\n\tdijkstra_node_edge[0][0]=0;\n\tfor(i=0;i<dijkstra_edge_num;i++) {\n\t\tif(dijkstra_edge[i].from!=dijkstra_edge[prev].from) {\n\t\t\tdijkstra_node_edge[dijkstra_edge[prev].from][1]=i;\n\t\t\tdijkstra_node_edge[dijkstra_edge[i].from][0]=i;\n\t\t\tprev=i;\n\t\t}\n\t}\n\tdijkstra_node_edge[dijkstra_edge[prev].from][1]=i;\n}\n\nint dijkstra_search(int from,int to) {\n\tint i;\n\tmemset(dijkstra_cost,0xFF,sizeof(dijkstra_cost));\n\tmemset(dijkstra_visited,0,sizeof(dijkstra_visited));\n\tdijkstra_queue_num=0;\n\tdijkstra_queue_push(from,0);\n\twhile(dijkstra_queue_num>0) {\n\t\tdijkstra_node_t nownode=dijkstra_queue_pop();\n\t\tif(!dijkstra_visited[nownode.node]) {\n\t\t\tdijkstra_visited[nownode.node]=1;\n\t\t\tdijkstra_cost[nownode.node]=nownode.cost;\n\t\t\tfor(i=dijkstra_node_edge[nownode.node][0];\n\t\t\t\t\ti<dijkstra_node_edge[nownode.node][1];i++) {\n\t\t\t\tif(!dijkstra_visited[dijkstra_edge[i].to] &&\n\t\t\t\t\t\t(dijkstra_cost[dijkstra_edge[i].to]<0 ||\n\t\t\t\t\t\tdijkstra_cost[dijkstra_edge[i].to]>nownode.cost+dijkstra_edge[i].cost)) {\n\t\t\t\t\tdijkstra_queue_push(\n\t\t\t\t\t\tdijkstra_edge[i].to,\n\t\t\t\t\t\tnownode.cost+dijkstra_edge[i].cost\n\t\t\t\t\t);\n\t\t\t\t\tdijkstra_cost[dijkstra_edge[i].to]=nownode.cost+dijkstra_edge[i].cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dijkstra_cost[to];\n}\n\nint get_id(int node, int syozikin) {\n\treturn syozikin*100+node;\n}\n\nint main(void) {\n\tint N,M,L;\n\twhile(scanf(\"%d%d%d\",&N,&M,&L)==3 && (N|M|L)!=0) {\n\t\tint i,j;\n\t\tdijkstra_init();\n\t\tfor(i=0;i<M;i++) {\n\t\t\tint A,B,D,E;\n\t\t\tscanf(\"%d%d%d%d\",&A,&B,&D,&E);\n\t\t\tA--;B--;\n\t\t\tfor(j=0;j<=100;j++) {\n\t\t\t\t/* mukakin (osowareru) */\n\t\t\t\tdijkstra_addedge(get_id(A,j),get_id(B,j),E);\n\t\t\t\tdijkstra_addedge(get_id(B,j),get_id(A,j),E);\n\t\t\t\t/* kakin (osowarenai) */\n\t\t\t\tif(j>=D) {\n\t\t\t\t\tdijkstra_addedge(get_id(A,j),get_id(B,j-D),0);\n\t\t\t\t\tdijkstra_addedge(get_id(B,j),get_id(A,j-D),0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* goal */\n\t\tfor(i=1;i<=100;i++) {\n\t\t\tdijkstra_addedge(get_id(N-1,i),get_id(N-1,i-1),0);\n\t\t}\n\t\tdijkstra_setup();\n\t\tprintf(\"%d\\n\",dijkstra_search(get_id(0,L),get_id(N-1,0)));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2151: Brave Princess Revisited\n// 2017.11.11 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int n, m; } QUE;\nQUE que[20001]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nint node[101][101];\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && node[que[l].n][que[l].m] < node[que[i].n][que[i].m])\n\t\tmin = l; else min = i;\n\tif (r < qsize && node[que[r].n][que[r].m] < node[que[min].m][que[min].m])\n\t\tmin = r;\n\tif (min != i) {\n\t\tQUE t = que[i]; que[i] = que[min]; que[min] = t;\n\t\tmin_heapify(min);\n\t}\n}\n\nint deq(int *n, int *m)\n{\n\tif (qsize == 0) return 0;\n\t*n = que[0].n, *m = que[0].m;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n\treturn 1;\n}\n\nvoid enq(int n, int m)\n{\n\tint i, min;\n\n\ti = qsize++;\n\tque[i].n = n, que[i].m = m;\n\twhile (i > 0 && node[que[min = PARENT(i)].n][que[min].m]\n\t         > node[que[i].n][que[i].m]) {\n\t\tQUE tt = que[i]; que[i] = que[min]; que[min] = tt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { int len, to[101], d[101], e[101]; } TBL;\nTBL tbl[101];\nint node[101][101]; int size;\n\nint search(int start, int goal, int l)\n{\n\tint s, m, i, k, e, ans;\n\tTBL *tp;\n\n\tqsize = 0;\n\tmemset(node, 0x55, sizeof(node));\n\tnode[start][l] = 0; enq(start, l);\n\tans = 0x7ffffff;\n\twhile(deq(&s, &m)) {\n\t\tif (s == goal) {\n\t\t\tif (node[s][m] < ans) ans = node[s][m];\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (tp = tbl + s, i = 0; i < tp->len; i++) {\n\t\t\te = tp->to[i];\n\n\t\t\tk = node[s][m] + tp->e[i];\n\t\t\tif (k < node[e][m]) node[e][m] = k, enq(e, m);\n\n\t\t\tk = m - tp->d[i];\n\t\t\tif (tp->d[i] <= m && node[s][m] < node[e][k])\n\t\t\t\tnode[e][k] = node[s][m], enq(e, k);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n, m, l, a, b, d, e, i;\n\n\twhile (scanf(\"%d%d%d\", &n, &m, &l) && n > 0) {\n\t\tmemset(tbl, 0, sizeof(tbl));\n\t\twhile (m--) {\n\t\t\tscanf(\"%d%d%d%d\", &a, &b, &d, &e);\n\t\t\ta--, b--;\n\t\t\ti = tbl[a].len, tbl[a].to[i] = b, tbl[a].d[i] = d, tbl[a].e[i] = e, tbl[a].len++;\n\t\t\ti = tbl[b].len, tbl[b].to[i] = a, tbl[b].d[i] = d, tbl[b].e[i] = e, tbl[b].len++;\n\t\t}\n\t\tsize = n;\n\t\tprintf(\"%d\\n\", search(0, n-1, l));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,l,min,mi,i,j,k,f[110]={0};\n  int a,b,d[110][110],t[110][110],c[110][110]={0};\n  while(scanf(\"%d %d %d\",&n,&m,&l),n){\n    for(i=0;i<110;i++){\n      for(j=0;j<110;j++)d[i][j]=c[i][j]=M;\n      f[i]=-1;\n    }\n    d[0][1]=0;\n    while(m--){\n      scanf(\"%d %d %d %d\",&a,&b,&i,&j);\n      c[b][a]=c[a][b]=i;\n      t[b][a]=t[a][b]=j;\n    }\n    for(i=0;i<=l;i++){\n      for(j=1;j<=n;j++){\n\tmin=M;\n\tfor(k=1;k<=n;k++){\n\t  if(f[k]==i)continue;\n\t  if(min>d[i][k])min=d[i][mi=k];\n\t}\n\tf[mi]=i;\n\tfor(k=1;k<=n;k++){\n\t  if(c[mi][k]==M)continue;\n\t  d[i  ][k]=MIN(d[i][k],d[i  ][mi]+t[mi][k]);\n\t  d[i+1][k]=MIN(d[i][k],d[i+1][k]);\n\t  if(i+c[mi][k]<=l)d[i+c[mi][k]][k]=MIN(d[i+c[mi][k]][k],d[i][mi]);\n\t}\n      }\n    }\n    /*for(i=0;i<=l;i++){printf(\"%2d:\",i);\n      for(j=0;j<n;j++)printf(\"%d \",d[i][j+1]);printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",d[l][n]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2151: Brave Princess Revisited\n// 2017.11.11 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#define TM 0\n#if TM\n#include <time.h>\n#endif\n\ntypedef struct { int t, n, m; } QUE;\nQUE que[20001]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tQUE t = que[i]; que[i] = que[min]; que[min] = t;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].n, *m = que[0].m;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n//\treturn 1;\n}\n\nvoid enq(int t, int n, int m)\n{\n\tint i, min;\n\n\ti = qsize++;\n\tque[i].t = t, que[i].n = n, que[i].m = m;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tQUE tt = que[i]; que[i] = que[min]; que[min] = tt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { int to[101], d[101], e[101]; } TBL;\nTBL tbl[101];\nint len[101];\nint node[101][101]; int size;\n\nint search(int start, int goal, int l)\n{\n\tint s, m, i, k, e, p, ans;\n\tTBL *tp;\n\n\tqsize = 0;\n\tmemset(node, 0x33, sizeof(node));\n\tnode[start][l] = 0; enq(0, start, l);\n\tans = 0x7fffff;\n\twhile (qsize) {\n\t\ts = que[0].n, m = que[0].m, deq();\n\t\tp = node[s][m];\n\t\tif (s == goal) {\n\t\t\tif (p < ans) ans = p;\n\t\t\tif (ans == 0) break;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (tp = tbl + s, i = 0; i < len[s]; i++) {\n\t\t\te = tp->to[i];\n\n\t\t\tk = p + tp->e[i];\n\t\t\tif (k < node[e][m]) node[e][m] = k, enq(node[e][m], e, m);\n\n\t\t\tk = m - tp->d[i];\n\t\t\tif (tp->d[i] <= m && p < node[e][k]) node[e][k] = p, enq(node[e][k], e, k);\n\t\t}\n\t}\n\treturn ans;\n}\n\nchar buf[30], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, l, a, b, d, e, i;\n\tTBL *tp;\n#if TM\n\tclock_t start, end;\n\tstart = clock();\n#endif\n\n\twhile (fgets(p=buf, 30, stdin) && *p != '0') {\n\t\tn = getint(), p++, m = getint(), p++, l = getint();\n\t\tmemset(len, 0, sizeof(len));\n\t\twhile (m--) {\n\t\t\tfgets(p=buf, 30, stdin);\n\t\t\ta = getint()-1, p++, b = getint()-1, p++, d = getint(), p++, e = getint();\n\t\t\ti = len[a], tp = tbl+a;\n\t\t\ttp->to[i] = b, tp->d[i] = d, tp->e[i] = e, len[a]++;\n\t\t\ti = len[b], tp = tbl+b;\n\t\t\ttp->to[i] = a, tp->d[i] = d, tp->e[i] = e, len[b]++;\n\t\t}\n\t\tsize = n;\n\t\tprintf(\"%d\\n\", search(0, n-1, l));\n\t}\n#if TM\n\tend = clock();\n\tprintf(\"time %lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define rep(i,n) for(int i=0;(i)<(n);(i)++)\n#define N 10000000\n#define INF 9999999\ntypedef struct{\n    int dis;\n    int e;\n}Load;\ntypedef struct{\n    int pos;\n    int rest;\n}Data;\nData queue[N];\nint head,num;\nvoid enqueue(int pos,int rest){\n    if(num<N){\n        queue[(head+num)%N].pos=pos;\n        queue[(head+num)%N].rest=rest;\n        num++;\n    }else{\n        printf(\"エラー\");\n        exit(1);\n    }\n}\nData dequeue(int cost[100][101]){\n    int index=head;\n    int min=cost[queue[head].pos][queue[head].rest];\n    for(int i=head+1;i<head+num;i++){\n        if(min>cost[queue[i%N].pos][queue[i%N].rest]){\n            min=cost[queue[i%N].pos][queue[i%N].rest];\n            index=i%N;\n        }\n    }\n    Data tmp=queue[head]; queue[head]=queue[index]; queue[index]=tmp;\n    Data d={-1,-1};\n    if(num>0){\n        d=queue[head];\n        head=(head+1)%N;\n        num--;\n    }\n    return d;\n}\nint main(void){\n    while(1){\n        int n,m,L;\n        scanf(\"%d%d%d\",&n,&m,&L);\n        if(n+m+L==0) break;\n        Load dist[100][100]={0};\n        int cost[100][101];\n        rep(i,100) rep(j,101) cost[i][j]=INF;\n        rep(i,m){\n            int a,b,d,e;\n            scanf(\"%d%d%d%d\",&a,&b,&d,&e);\n            a--; b--;\n            dist[a][b].dis=dist[b][a].dis=d;\n            dist[a][b].e=dist[b][a].e=e;\n        }\n        head=num=0;\n        cost[0][L]=0;\n        enqueue(0,L);\n        while(1){\n            Data tmp=dequeue(cost);\n            int pos=tmp.pos,rest=tmp.rest;\n            if(pos==n-1) continue;\n            if(pos==-1) break;\n            for(int i=0;i<n;i++){\n                if(pos==i||dist[pos][i].dis==0) continue;\n                if(rest<dist[pos][i].dis){\n                    if(cost[i][rest]>cost[pos][rest]+dist[pos][i].e){\n                        cost[i][rest]=\n                        cost[pos][rest]+dist[pos][i].e;\n                        enqueue(i,rest);\n                    }\n                }\n                else{\n                    if(cost[i][rest-dist[pos][i].dis]>\n                       cost[pos][rest]){\n                        cost[i][rest-dist[pos][i].dis]=\n                        cost[pos][rest];\n                        enqueue(i,rest-dist[pos][i].dis);\n                    }\n                    if(cost[i][rest]>cost[pos][rest]+dist[pos][i].e){\n                        cost[i][rest]=\n                        cost[pos][rest]+dist[pos][i].e;\n                        enqueue(i,rest);\n                    }\n                }\n            }\n        }\n        /*for(int i=0;i<n;i++){\n            for(int j=0;j<=L;j++){\n                printf(\"%5d \",cost[i][j]);\n            }puts(\"\");\n        }puts(\"\");*/\n        int min=INF;\n        for(int i=0;i<=L;i++){\n            if(min>cost[n-1][i]) min=cost[n-1][i];\n        }\n        printf(\"%d\\n\",min);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DIJKSTRA_MAX_NODE 11000\n#define DIJKSTRA_MAX_EDGE 2000000\n\ntypedef struct {\n\tshort from,to;\n\tint cost;\n} dijkstra_edge_t;\n\ntypedef struct {\n\tshort node;\n\tint cost;\n} dijkstra_node_t;\n\nint dijkstra_edge_num;\ndijkstra_edge_t dijkstra_edge[DIJKSTRA_MAX_EDGE];\nint dijkstra_node_edge[DIJKSTRA_MAX_NODE][2];\nint dijkstra_queue_num;\ndijkstra_node_t dijkstra_queue[DIJKSTRA_MAX_EDGE+1];\nint dijkstra_cost[DIJKSTRA_MAX_NODE];\nchar dijkstra_visited[DIJKSTRA_MAX_NODE];\n\nint dijkstra_comp(const void* x,const void* y) {\n\tconst dijkstra_edge_t* a=(const dijkstra_edge_t*)x;\n\tconst dijkstra_edge_t* b=(const dijkstra_edge_t*)y;\n\tif((a->from)>(b->from))return 1;\n\tif((a->from)<(b->from))return -1;\n\tif((a->to)>(b->to))return 1;\n\tif((a->to)<(b->to))return -1;\n\treturn 0;\n}\n\nvoid dijkstra_queue_adjust(int pos) {\n\tint min=pos;\n\tif(pos*2+1<dijkstra_queue_num &&\n\t\tdijkstra_queue[min].cost>dijkstra_queue[pos*2+1].cost)\n\t\t\tmin=pos*2+1;\n\tif(pos*2+2<dijkstra_queue_num &&\n\t\tdijkstra_queue[min].cost>dijkstra_queue[pos*2+2].cost)\n\t\t\tmin=pos*2+2;\n\tif(min!=pos) {\n\t\tdijkstra_node_t temp;\n\t\ttemp=dijkstra_queue[min];\n\t\tdijkstra_queue[min]=dijkstra_queue[pos];\n\t\tdijkstra_queue[pos]=temp;\n\t\tdijkstra_queue_adjust(min);\n\t} else if(pos>0)dijkstra_queue_adjust((pos-1)/2);\n}\n\nvoid dijkstra_queue_push(short node,int cost) {\n\tdijkstra_node_t topush;\n\ttopush.node=node;topush.cost=cost;\n\tdijkstra_queue[dijkstra_queue_num++]=topush;\n\tdijkstra_queue_adjust(dijkstra_queue_num-1);\n}\n\ndijkstra_node_t dijkstra_queue_pop(void) {\n\tdijkstra_node_t result=dijkstra_queue[0];\n\tif(dijkstra_queue_num>0) {\n\t\tdijkstra_queue[0]=dijkstra_queue[--dijkstra_queue_num];\n\t\tdijkstra_queue_adjust(0);\n\t}\n\treturn result;\n}\n\nvoid dijkstra_init(void) {\n\tdijkstra_edge_num=0;\n}\n\nvoid dijkstra_addedge(short from,short to,int cost) {\n\tdijkstra_edge[dijkstra_edge_num].from=from;\n\tdijkstra_edge[dijkstra_edge_num].to=to;\n\tdijkstra_edge[dijkstra_edge_num].cost=cost;\n\tdijkstra_edge_num++;\n}\n\nvoid dijkstra_setup(void) {\n\tint i;\n\tint prev;\n\tqsort(dijkstra_edge,dijkstra_edge_num,\n\t\tsizeof(dijkstra_edge_t),dijkstra_comp);\n\tprev=0;\n\tmemset(dijkstra_node_edge,0,sizeof(dijkstra_node_edge));\n\tdijkstra_node_edge[0][0]=0;\n\tfor(i=0;i<dijkstra_edge_num;i++) {\n\t\tif(dijkstra_edge[i].from!=dijkstra_edge[prev].from) {\n\t\t\tdijkstra_node_edge[dijkstra_edge[prev].from][1]=i;\n\t\t\tdijkstra_node_edge[dijkstra_edge[i].from][0]=i;\n\t\t\tprev=i;\n\t\t}\n\t}\n\tdijkstra_node_edge[dijkstra_edge[prev].from][1]=i;\n}\n\nint dijkstra_search(short from,short to) {\n\tint i;\n\tmemset(dijkstra_cost,0xFF,sizeof(dijkstra_cost));\n\tmemset(dijkstra_visited,0,sizeof(dijkstra_visited));\n\tdijkstra_queue_num=0;\n\tdijkstra_queue_push(from,0);\n\twhile(dijkstra_queue_num>0) {\n\t\tdijkstra_node_t nownode=dijkstra_queue_pop();\n\t\tif(!dijkstra_visited[nownode.node]) {\n\t\t\tdijkstra_visited[nownode.node]=1;\n\t\t\tdijkstra_cost[nownode.node]=nownode.cost;\n\t\t\tfor(i=dijkstra_node_edge[nownode.node][0];\n\t\t\t\t\ti<dijkstra_node_edge[nownode.node][1];i++) {\n\t\t\t\tif(!dijkstra_visited[dijkstra_edge[i].to] &&\n\t\t\t\t\t\t(dijkstra_cost[dijkstra_edge[i].to]<0 ||\n\t\t\t\t\t\tdijkstra_cost[dijkstra_edge[i].to]>nownode.cost+dijkstra_edge[i].cost)) {\n\t\t\t\t\tdijkstra_queue_push(\n\t\t\t\t\t\tdijkstra_edge[i].to,\n\t\t\t\t\t\tnownode.cost+dijkstra_edge[i].cost\n\t\t\t\t\t);\n\t\t\t\t\tdijkstra_cost[dijkstra_edge[i].to]=nownode.cost+dijkstra_edge[i].cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dijkstra_cost[to];\n}\n\nint get_id(int node, int syozikin) {\n\treturn syozikin*100+node;\n}\n\nint main(void) {\n\tint N,M,L;\n\twhile(scanf(\"%d%d%d\",&N,&M,&L)==3 && (N|M|L)!=0) {\n\t\tint i,j;\n\t\tdijkstra_init();\n\t\tfor(i=0;i<M;i++) {\n\t\t\tint A,B,D,E;\n\t\t\tscanf(\"%d%d%d%d\",&A,&B,&D,&E);\n\t\t\tA--;B--;\n\t\t\tfor(j=0;j<=100;j++) {\n\t\t\t\t/* mukakin (osowareru) */\n\t\t\t\tdijkstra_addedge(get_id(A,j),get_id(B,j),E);\n\t\t\t\tdijkstra_addedge(get_id(B,j),get_id(A,j),E);\n\t\t\t\t/* kakin (osowarenai) */\n\t\t\t\tif(j>=D) {\n\t\t\t\t\tdijkstra_addedge(get_id(A,j),get_id(B,j-D),0);\n\t\t\t\t\tdijkstra_addedge(get_id(B,j),get_id(A,j-D),0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* goal */\n\t\tfor(i=1;i<=100;i++) {\n\t\t\tdijkstra_addedge(get_id(N-1,i),get_id(N-1,i-1),0);\n\t\t}\n\t\tdijkstra_setup();\n\t\tprintf(\"%d\\n\",dijkstra_search(get_id(0,L),get_id(N-1,0)));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2151: Brave Princess Revisited\n// 2017.11.11 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int t, n, m; } QUE;\nQUE que[20001]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tQUE t = que[i]; que[i] = que[min]; que[min] = t;\n\t\tmin_heapify(min);\n\t}\n}\n\nint deq(int *n, int *m)\n{\n\tif (qsize == 0) return 0;\n\t*n = que[0].n, *m = que[0].m;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n\treturn 1;\n}\n\nvoid enq(int t, int n, int m)\n{\n\tint i, min;\n\n\ti = qsize++;\n\tque[i].t = t, que[i].n = n, que[i].m = m;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tQUE tt = que[i]; que[i] = que[min]; que[min] = tt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { int len, to[101], d[101], e[101]; } TBL;\nTBL tbl[101];\nint node[101][101]; int size;\n\nint search(int start, int goal, int l)\n{\n\tint s, m, i, k, e, p, ans;\n\tTBL *tp;\n\n\tqsize = 0;\n\tmemset(node, 0x33, sizeof(node));\n\tnode[start][l] = 0; enq(0, start, l);\n\tans = 0x7fffff;\n\twhile(deq(&s, &m)) {\n\t\tp = node[s][m];\n\t\tif (s == goal) {\n\t\t\tif (p < ans) ans = p;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (tp = tbl + s, i = 0; i < tp->len; i++) {\n\t\t\te = tp->to[i];\n\n\t\t\tk = p + tp->e[i];\n\t\t\tif (k < node[e][m]) node[e][m] = k, enq(node[e][m], e, m);\n\n\t\t\tk = m - tp->d[i];\n\t\t\tif (tp->d[i] <= m && p < node[e][k]) node[e][k] = p, enq(node[e][k], e, k);\n\t\t}\n\t}\n\treturn ans;\n}\n\nchar buf[30], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, l, a, b, d, e, i;\n\tTBL *tp;\n\n\twhile (fgets(p=buf, 30, stdin) && *p != '0') {\n\t\tn = getint(), p++, m = getint(), p++, l = getint();\n\t\tmemset(tbl, 0, sizeof(tbl));\n\t\twhile (m--) {\n\t\t\tfgets(p=buf, 30, stdin);\n\t\t\ta = getint()-1, p++, b = getint()-1, p++, d = getint(), p++, e = getint();\n\t\t\ttp = tbl+a, i = tp->len;\n\t\t\ttp->to[i] = b, tp->d[i] = d, tp->e[i] = e, tp->len++;\n\t\t\ttp = tbl+b, i = tp->len;\n\t\t\ttp->to[i] = a, tp->d[i] = d, tp->e[i] = e, tp->len++;\n\t\t}\n\t\tsize = n;\n\t\tprintf(\"%d\\n\", search(0, n-1, l));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args:Array<String>?): Unit {\n    while(true){\n        val (n, m, l) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (n == 0) return\n        val town = Array(n){ Stack <Triple<Int, Int, Int>>()}\n        val memo = Array(n){IntArray(l + 1){Int.MAX_VALUE}}\n        repeat(m){\n            val (a, b, d, e) = readLine()!!.trim().split(' ').map(String::toInt)\n            town[a - 1].push(Triple(b - 1, d, e))\n            town[b - 1].push(Triple(a - 1, d, e))\n        }\n        memo[0][l] = 0\n        val queue = PriorityQueue<Triple<Int, Int, Int>>(compareBy(Triple<*, *, Int>::third))\n        queue.add(Triple(0, l, 0))\n        while(queue.isNotEmpty() && queue.peek().first != n - 1){\n            val (current, money, enemy) = queue.poll()\n            if (memo[current][money] == enemy){\n                for ((to, distance, danger) in town[current]) {\n                    if (money >= distance && memo[to][money - distance] > enemy) {\n                        memo[to][money - distance] = enemy\n                        queue.add(Triple(to, money - distance, enemy))\n                    }\n                    if (memo[to][money] > enemy + danger) {\n                        memo[to][money] = enemy + danger\n                        queue.add(Triple(to, money, enemy + danger))\n                    }\n                }\n            }\n        }\n        println(memo.last().min())\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tint money = in.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tint[][] e = new int[n][n];\n\t\t\tint[][] d = new int[n][n];\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint a = in.nextInt()-1;\n\t\t\t\tint b = in.nextInt()-1;\n\t\t\t\tint dist = in.nextInt();\n\t\t\t\tint enemy = in.nextInt();\n\t\t\t\td[a][b] = d[b][a] = dist;\n\t\t\t\te[a][b] = e[b][a] = enemy;\n\t\t\t\tnode[a].createEdge(node[b]);\n\t\t\t\tnode[b].createEdge(node[a]);\n\t\t\t}\n\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\tqu.add(new Pos(0, 0, money, 0, 1));\n\t\t\tint[][] used = new int[n][money+1];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<money+1; j++){\n\t\t\t\t\tused[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinal int INF = 100000000;\n\t\t\tint res = INF;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(used[p.id][p.m] != -1 && used[p.id][p.m] <= p.e) continue;\n\t\t\t\tif(p.id == n-1){\n\t\t\t\t\tres = Math.min(p.e, res);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[p.id][p.m] = p.e;\n\t\t\t\tfor(Node v: node[p.id].edge){\n\t\t\t\t\tif((p.state&1<<v.id)>0) continue;\n\t\t\t\t\tqu.add(new Pos(v.id, p.d+d[p.id][v.id], p.m, p.e+e[p.id][v.id], p.state|1<<v.id));\n\t\t\t\t\tif(p.m - d[p.id][v.id] < 0) continue;\n\t\t\t\t\tqu.add(new Pos(v.id, p.d+d[p.id][v.id], p.m-d[p.id][v.id], p.e, p.state|1<<v.id));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint id;\n\tint d, m, e;\n\tint state;\n\tpublic Pos(int id, int d, int m, int e, int state){\n\t\tthis.id = id;\n\t\tthis.d = d;\n\t\tthis.m = m;\n\t\tthis.e = e;\n\t\tthis.state = state;\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn e-o.e;\n\t}\n}\n\nclass Node{\n\tint id;\n\tArrayList<Node> edge = new ArrayList<Node>();\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t}\n\tpublic void createEdge(Node nd){\n\t\tedge.add(nd);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport static java.lang.Math.min;\n\n/**\n * Problem C: Brave Princess Revisited\n */\npublic class Main {\n\n\tstatic final int INF = 1 << 29;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (sc.hasNext()) {\n\n\t\t\tint N, M, L;\n\t\t\tN = sc.nextInt();\n\t\t\tM = sc.nextInt();\n\t\t\tL = sc.nextInt();\n\t\t\tif ((N | M | L) == 0) break;\n\n\t\t\tMap<Integer, List<Edge>> G = new HashMap<>();\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint A, B, D, E;\n\t\t\t\tA = sc.nextInt();\n\t\t\t\tB = sc.nextInt();\n\t\t\t\tD = sc.nextInt();\n\t\t\t\tE = sc.nextInt();\n\t\t\t\tG.putIfAbsent(A, new ArrayList<>());\n\t\t\t\tG.putIfAbsent(B, new ArrayList<>());\n\t\t\t\tG.get(A).add(new Edge(B, D, E));\n\t\t\t\tG.get(B).add(new Edge(A, D, E));\n\t\t\t}\n\n\t\t\t//???????????¨ -> [?????´][????????????]\n\t\t\tint[][] D = new int[N + 1][L + 1];\n\t\t\tboolean[] V = new boolean[N + 1];\n\n\t\t\tfor (int i = 0; i < D.length; i++) Arrays.fill(D[i], INF);\n\t\t\tD[1][L] = 0;\n\n\t\t\twhile (true) {\n\n\t\t\t\tint s = -1, l = -1, min = INF;\n\n\t\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\t\tfor (int j = 0; j <= L; j++) {\n\t\t\t\t\t\tif (!V[i] && D[i][j] < min) {\n\t\t\t\t\t\t\tmin = D[i][j]; s = i; l = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (min == INF) break;\n\t\t\t\tV[s] = true;\n\n\t\t\t\tfor (Edge e : G.get(s)) {\n\t\t\t\t\tfor (int i = 0; i <= L; i++) {\n\t\t\t\t\t\tD[e.to][i] = min(D[e.to][i], D[s][i] + e.enemy);\n\t\t\t\t\t\tif (i >= e.distance) {\n\t\t\t\t\t\t\tD[e.to][i - e.distance] = min(D[e.to][i - e.distance], D[s][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = INF;\n\n\t\t\tfor (int i = 0; i <= L; i++) {\n\t\t\t\tmin = Math.min(min, D[N][i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\nclass Edge {\n\n\tint to, distance, enemy;\n\n\tpublic Edge(int to, int distance, int enemy) {\n\t\tthis.to = to;\n\t\tthis.distance = distance;\n\t\tthis.enemy = enemy;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder sb = new StringBuilder();\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) {\n                break;\n            }\n            int m = sc.nextInt();\n            int l = sc.nextInt();\n            ArrayList<HashMap<Integer, Cost>> graph = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                graph.add(new HashMap<>());\n            }\n            for (int i = 0; i < m; i++) {\n                int a = sc.nextInt() - 1;\n                int b = sc.nextInt() - 1; \n                Cost cost = new Cost(sc.nextInt(), sc.nextInt());\n                graph.get(a).put(b, cost);\n                graph.get(b).put(a, cost);\n            }\n            int[][] dp = new int[n][l + 1];\n            for (int i = 0; i < n; i++) {\n                Arrays.fill(dp[i], Integer.MAX_VALUE);\n            }\n            search(0, 0, l, dp, graph);\n            int min = Integer.MAX_VALUE;\n            for (int i = 0; i <= l; i++) {\n                min = Math.min(min, dp[n - 1][i]);\n            }\n            sb.append(min).append(\"\\n\");\n        }\n        System.out.print(sb);\n    }\n    \n    static void search(int idx, int count, int remain, int[][] dp, ArrayList<HashMap<Integer, Cost>> graph) {\n        if (remain < 0) {\n            return;\n        }\n        if (dp[idx][remain] <= count) {\n            return;\n        }\n        for (int i = remain; i >= 0 && dp[idx][i] > count; i--) {\n            dp[idx][i] = count;\n        }\n        for (Map.Entry<Integer, Cost> entry : graph.get(idx).entrySet()) {\n            int next = entry.getKey();\n            Cost cost = entry.getValue();\n            search(next, count, remain - cost.value, dp, graph);\n            search(next, count + cost.count, remain, dp, graph);\n        }\n    }\n    \n    static class Cost {\n        int count;\n        int value;\n        \n        public Cost(int value, int count) {\n            this.count = count;\n            this.value = value;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif(n == 0 && m == 0 && l == 0) break;\n\t\t\tint [][] pass = new int[n][n];\n\t\t\tint [][] money = new int[n][n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tArrays.fill(money[i], INF);\n\t\t\t}\n\t\t\tfor(int i = 0;i < m; i++){\n\t\t\t\tint from = sc.nextInt() - 1;\n\t\t\t\tint to = sc.nextInt() -1 ;\n\t\t\t\tint dis = sc.nextInt();\n\t\t\t\tint num = sc.nextInt();\n\t\t\t\tpass[from][to] = num;\n\t\t\t\tpass[to][from] = num;\n\t\t\t\tmoney[from][to] = dis;\n\t\t\t\tmoney[to][from] = dis;\n\t\t\t}\n\t\t\tPriorityQueue<C> open = new PriorityQueue<C>();\n\t\t\topen.add(new C(0,l,0));\n\t\t\tint [][] close = new int[n][l+1];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < l + 1; j++){\n\t\t\t\t\tclose[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(close[0],INF);\n\t\t\tint ans = INF;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\tint from = now.now;\n\t\t\t\t//goal\n\t\t\t\tif(from == n-1){\n\t\t\t\t\tans = Math.min(ans, now.num);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i= 0; i < n; i++){\n\t\t\t\t\tif(pass[from][i] == INF){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//use\n\t\t\t\t\tint nextnum = now.num;\n\t\t\t\t\tint nextmoney = now.money - money[from][i];\n\t\t\t\t\tif(now.money >= money[from][i]){\n\t\t\t\t\t\tif(close[i][nextmoney] > nextnum){\n\t\t\t\t\t\t\topen.add(new C(i, nextmoney, nextnum));\n\t\t\t\t\t\t\tclose[i][nextmoney] = nextnum;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//not use\n\t\t\t\t\tnextnum = now.num + pass[from][i];\n\t\t\t\t\tnextmoney = now.money;\n\t\t\t\t\tif(close[i][nextmoney] > nextnum){\n\t\t\t\t\t\topen.add(new C(i, nextmoney, nextnum));\n\t\t\t\t\t\tclose[i][nextmoney] = nextnum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate class C implements Comparable<C>{\n\t\tint now,money,num;\n\t\tpublic C(int now, int money, int num) {\n\t\t\tthis.now = now;\tthis.money = money;\tthis.num = num;\n\t\t}\n\t\tpublic int compareTo(C o) {\n\t\t\tif(num < o.num) return -1;\n\t\t\tif(num > o.num) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final long INF = Long.MAX_VALUE;\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\t}\n\t\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\twhile(n + m + l > 0){\n\t\t\tint[][] road = new int[m][4];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\troad[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t//宿場nに予算lでたどり着く時の盗賊の最小値\n\t\t\tlong[][] place = new long[n][l + 1];\n\t\t\tfor(long[] a : place){\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\t//place[0][0] = 0;\n\t\t\tArrays.fill(place[0],0);\n\t\t\tboolean bContinue = true;\n\t\t\twhile(bContinue){\n\t\t\t\tbContinue = false;\n\t\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\t\tint from = road[i][0] - 1;\n\t\t\t\t\tint to = road[i][1] - 1;\n\t\t\t\t\tint dist = road[i][2];\n\t\t\t\t\tint enemy = road[i][3];\n\t\t\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\t\t\t//金を払っていく場合\n\t\t\t\t\t\tif(j + dist <= l && place[from][j] != INF && (place[from][j] < place[to][j + dist])){\n\t\t\t\t\t\t\tplace[to][j + dist] = place[from][j];\n\t\t\t\t\t\t\tbContinue = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//金を払わない場合\n\t\t\t\t\t\tif(place[from][j] != INF && (place[from][j] + enemy <  place[to][j])){\n\t\t\t\t\t\t\tplace[to][j] = place[from][j] + enemy;\n\t\t\t\t\t\t\tbContinue = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfrom = road[i][1] - 1;\n\t\t\t\t\tto = road[i][0] - 1;\n\t\t\t\t\t\n\t\t\t\t\tfor(int j = 0; j < l; j++){\n\t\t\t\t\t\t//金を払っていく場合\n\t\t\t\t\t\tif(j + dist <= l && place[from][j] != INF && (place[from][j] < place[to][j + dist])){\n\t\t\t\t\t\t\tplace[to][j + dist] = place[from][j];\n\t\t\t\t\t\t\tbContinue = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//金を払わない場合\n\t\t\t\t\t\tif(place[from][j] != INF && (place[from][j] + enemy <  place[to][j])){\n\t\t\t\t\t\t\tplace[to][j] = place[from][j] + enemy;\n\t\t\t\t\t\t\tbContinue = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong[] dest = place[n - 1];\n\t\t\tArrays.sort(dest);\n\t\t\t//print(dest);\n\t\t\tSystem.out.println(dest[0]);\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tl = sc.nextInt();\n\t\t}\n\t}\n\t\n\tpublic static void print(int[] a){\n\t\tfor(int b : a){\n\t\t\tSystem.out.print(b + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tint money = in.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tint[][] e = new int[n][n];\n\t\t\tint[][] d = new int[n][n];\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint a = in.nextInt()-1;\n\t\t\t\tint b = in.nextInt()-1;\n\t\t\t\tint dist = in.nextInt();\n\t\t\t\tint enemy = in.nextInt();\n\t\t\t\td[a][b] = d[b][a] = dist;\n\t\t\t\te[a][b] = e[b][a] = enemy;\n\t\t\t\tnode[a].createEdge(node[b]);\n\t\t\t\tnode[b].createEdge(node[a]);\n\t\t\t}\n\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\tBitSet bs = new BitSet(n);\n\t\t\tbs.set(0);\n\t\t\tqu.add(new Pos(0, 0, money, 0, bs));\n\t\t\tboolean[][] used = new boolean[n][money+1];\n\t\t\tfinal int INF = 100000000;\n\t\t\tint res = INF;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(used[p.id][p.m]) continue;\n\t\t\t\tif(p.id == n-1){\n\t\t\t\t\tres = Math.min(p.e, res);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[p.id][p.m] = true;\n\t\t\t\tfor(Node v: node[p.id].edge){\n\t\t\t\t\tif(p.state.get(v.id)) continue;\n\t\t\t\t\tBitSet bs1 = (BitSet) p.state.clone();\n\t\t\t\t\tbs1.set(v.id);\n\t\t\t\t\tBitSet bs2 = (BitSet) bs1.clone();\n\t\t\t\t\tqu.add(new Pos(v.id, p.d+d[p.id][v.id], p.m, p.e+e[p.id][v.id], bs1));\n\t\t\t\t\tif(p.m - d[p.id][v.id] < 0) continue;\n\t\t\t\t\tqu.add(new Pos(v.id, p.d+d[p.id][v.id], p.m-d[p.id][v.id], p.e, bs2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint id;\n\tint d, m, e;\n\tBitSet state;\n\tpublic Pos(int id, int d, int m, int e, BitSet state){\n\t\tthis.id = id;\n\t\tthis.d = d;\n\t\tthis.m = m;\n\t\tthis.e = e;\n\t\tthis.state = state;\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn e-o.e;\n\t}\n}\n\nclass Node{\n\tint id;\n\tArrayList<Node> edge = new ArrayList<Node>();\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t}\n\tpublic void createEdge(Node nd){\n\t\tedge.add(nd);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tNode[] inn = new Node[101];\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif(n == 0 && m == 0 & l == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tinn[i] = new Node(i);\n\t\t\t}\n\t\t\tNode start = inn[1];\n\t\t\tNode goal = inn[n];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\t\n\t\t\t\tinn[a].edges.add(new Edge(e, d, inn[b]));\n\t\t\t\tinn[b].edges.add(new Edge(e, d, inn[a]));\n\t\t\t}\n\t\t\tboolean[][] flg = new boolean[n + 1][n + 1];\n\t\t\tfor(int i = 0; i <= n; i++){\n\t\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\t\tflg[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart.flg = true;\n\t\t\tSystem.out.println(func(start, l, goal, flg));\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tsc.close();\n\t}\n\tstatic int func(Node node, int cap, Node goal, boolean[][] flg){\n\t\tint res = 1000000000;\n\t\tif(node.equals(goal)){\n\t\t\treturn 0;\n\t\t}\t\t\n\t\tfor(Edge e : node.edges){\n\t\t\tif(!flg[node.n][e.t.n]){\n\t\t\t\tflg[e.t.n][node.n] = true;\n\t\t\t\tif(e.d > cap){\n\t\t\t\t\tres = Math.min(res, func(e.t, cap, goal, flg) + e.e);\n\t\t\t\t}else{\n\t\t\t\t\tres = Math.min(res, Math.min(func(e.t, cap - e.d, goal, flg), func(e.t, cap, goal, flg) + e.e));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n}\nclass Node{\n\tint n;\n\tboolean flg;\n\tLinkedList<Edge> edges;\n\tNode(int number){\n\t\tedges = new LinkedList<Edge>();\n\t\tn = number;\n\t\tflg = false;\n\t}\n}\nclass Edge{\n\tint e;\n\tint d;\n\tNode t;\n\tEdge(int enemy, int dist, Node to){\n\t\te = enemy;\n\t\td = dist;\n\t\tt = to;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport static java.lang.Math.min;\n\n/**\n * Problem C: Brave Princess Revisited\n */\npublic class Main {\n\n\tstatic final int INF = 1 << 29;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (sc.hasNext()) {\n\n\t\t\tint N, M, L;\n\t\t\tN = sc.nextInt();\n\t\t\tM = sc.nextInt();\n\t\t\tL = sc.nextInt();\n\t\t\tif ((N | M | L) == 0) break;\n\n\t\t\tMap<Integer, List<Edge>> G = new HashMap<>();\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint A, B, D, E;\n\t\t\t\tA = sc.nextInt();\n\t\t\t\tB = sc.nextInt();\n\t\t\t\tD = sc.nextInt();\n\t\t\t\tE = sc.nextInt();\n\t\t\t\tG.putIfAbsent(A, new ArrayList<>());\n\t\t\t\tG.putIfAbsent(B, new ArrayList<>());\n\t\t\t\tG.get(A).add(new Edge(B, D, E));\n\t\t\t\tG.get(B).add(new Edge(A, D, E));\n\t\t\t}\n\n\t\t\tint[][] D = new int[N + 1][L + 1];\n\t\t\tboolean[][] V = new boolean[N + 1][L + 1];\n\n\t\t\tfor (int i = 0; i < D.length; i++) Arrays.fill(D[i], INF);\n\t\t\tD[1][L] = 0;\n\n\t\t\twhile (true) {\n\n\t\t\t\tint s = -1, l = -1, min = INF;\n\n\t\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\t\tfor (int j = 0; j <= L; j++) {\n\t\t\t\t\t\tif (!V[i][j] && D[i][j] < min) {\n\t\t\t\t\t\t\tmin = D[i][j]; s = i; l = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (min == INF) break;\n\t\t\t\tV[s][l] = true;\n\n\t\t\t\tfor (Edge e : G.get(s)) {\n\t\t\t\t\tfor (int i = 0; i <= L; i++) {\n\t\t\t\t\t\tD[e.to][i] = min(D[e.to][i], D[s][i] + e.enemy);\n\t\t\t\t\t\tif (i >= e.distance) {\n\t\t\t\t\t\t\tD[e.to][i - e.distance] = min(D[e.to][i - e.distance], D[s][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = INF;\n\n\t\t\tfor (int i = 0; i <= L; i++) {\n\t\t\t\tmin = Math.min(min, D[N][i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\nclass Edge {\n\n\tint to, distance, enemy;\n\n\tpublic Edge(int to, int distance, int enemy) {\n\t\tthis.to = to;\n\t\tthis.distance = distance;\n\t\tthis.enemy = enemy;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2151();\n\t}\n\tclass AOJ2151{\n\t\tint N,M,L;\n\t\tfinal int INF=1<<28;\n\t\tAOJ2151(){\n\t\t\twhile(true){\n\t\t\t\tN=sc.nextInt(); M=sc.nextInt(); L=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tArrayList<ArrayList<Edge>> map=new ArrayList<ArrayList<Edge>>(N);\n\t\t\tfor(int i=0; i<N; ++i)\tmap.add(new ArrayList<Edge>());\n\t\t\tfor(int i=0; i<M; ++i){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),d=sc.nextInt(),e=sc.nextInt();\n\t\t\t\t--a; --b;\n\t\t\t\tmap.get(a).add(new Edge(b,d,e));\n\t\t\t\tmap.get(b).add(new Edge(a,d,e));\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<State> open=new PriorityQueue<State>();\n\t\t\topen.add(new State(0,L,0));\n\t\t\tint[][] closed=new int[N][L+1];\n\t\t\tfor(int i=0; i<N; ++i)for(int j=0; j<=L; ++j)\tclosed[i][j]=INF;\n\t\t\tclosed[0][L]=0;\n\t\t\tint ans=-1;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState now=open.poll();\n\t\t\t\tif(now.p==N-1){\n\t\t\t\t\tans=now.e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(Edge to: map.get(now.p)){\n\t\t\t\t\tif(now.m>=to.d && closed[to.p][now.m-to.d]>now.e){\n\t\t\t\t\t\topen.add(new State(to.p, now.m-to.d, now.e));\n\t\t\t\t\t\tclosed[to.p][now.m-to.d]=now.e;\n\t\t\t\t\t}\n\t\t\t\t\tif(closed[to.p][now.m]>now.e+to.e){\n\t\t\t\t\t\topen.add(new State(to.p, now.m, now.e+to.e));\n\t\t\t\t\t\tclosed[to.p][now.m]=now.e+to.e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tclass Edge{\n\t\t\tint p,d,e;\n\t\t\tEdge(int p,int d,int e){\n\t\t\t\tthis.p=p;\tthis.d=d;\tthis.e=e;\n\t\t\t}\n\t\t}\n\t\tclass State implements Comparable<State>{\n\t\t\tint p,m,e;\n\t\t\tState(int p,int m,int e){\n\t\t\t\tthis.p=p;\tthis.m=m;\tthis.e=e;\n\t\t\t}\n\t\t\t@Override public int compareTo(State o){\n\t\t\t\treturn this.e-o.e;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass State implements Comparable<State> {\n\t\tint L, N;\n\t\t\n\t\tState(int N, int L) {\n\t\t\tthis.N = N;\n\t\t\tthis.L = L;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\tint c1 = minCost[L][N], c2 = minCost[o.L][o.N];\n\t\t\treturn c1 - c2;\n\t\t}\n\t}\n\t\n\tint[][] minCost;\n\tint[][] dEdge;\n\tint[][] eEdge;\n\t\n\tint INF = 100000000;\n\t\n\tPriorityQueue<State> pq;\n\t\n\tvoid dijkstra(int n) {\n\t\twhile (!pq.isEmpty()) {\n//\t\t\tmapDebug(minCost);\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (dEdge[s.N][i] != INF && s.L - dEdge[s.N][i] >= 0) {\n\t\t\t\t\tif (minCost[s.L - dEdge[s.N][i]][i] > minCost[s.L][s.N]) {\n\t\t\t\t\t\tminCost[s.L - dEdge[s.N][i]][i] = minCost[s.L][s.N];\n\t\t\t\t\t\tpq.add(new State(i, s.L - dEdge[s.N][i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (minCost[s.L][i] > minCost[s.L][s.N] + eEdge[s.N][i]) {\n\t\t\t\t\tminCost[s.L][i] = minCost[s.L][s.N] + eEdge[s.N][i];\n\t\t\t\t\tpq.add(new State(i, s.L));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt(), l = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tdEdge = new int[n][n];\n\t\t\teEdge = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(dEdge[i], INF);\n\t\t\t\tArrays.fill(eEdge[i], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = in.nextInt() - 1, b = in.nextInt() - 1, d = in.nextInt(), e = in.nextInt();\n\t\t\t\tdEdge[a][b] = dEdge[b][a] = d;\n\t\t\t\teEdge[a][b] = eEdge[b][a] = e;\n\t\t\t}\n\t\t\t\n\n\t\t\tminCost = new int[l+1][n];\n\t\t\tfor (int i = 0; i <= l; i++)\n\t\t\t\tArrays.fill(minCost[i], INF);\n\t\t\tminCost[l][0] = 0;\n\t\t\t\n\t\t\tpq = new PriorityQueue<State>();\n\t\t\tpq.add(new State(0, l));\n\t\t\t\n\t\t\tdijkstra(n);\n\t\t\t\n//\t\t\tmapDebug(minCost);\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i <= l; i++) {\n\t\t\t\tres = Math.min(res, minCost[i][n-1]);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int n,m,l;\n    int[][] dist,assa;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt();\n            m = sc.nextInt();\n            l = sc.nextInt();\n            if(n==0 && m==0 && l==0) break;\n\n            dist = new int[n][n];\n            assa = new int[n][n];\n            for(int i=0; i<n; i++) Arrays.fill(dist[i],-1);\n            for(int i=0; i<m; i++){\n                int a = sc.nextInt()-1, b = sc.nextInt()-1;\n                int d = sc.nextInt(), e = sc.nextInt();\n                dist[a][b] = d; dist[b][a] = d;\n                assa[a][b] = e; assa[b][a] = e;\n            } \n\n            System.out.println(dijkstra());\n        }\n    }\n\n    int dijkstra(){\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>(n,new Comparator<int[]>(){\n                public int compare(int[] a, int[] b){\n                    return a[2]-b[2];\n                }\n            });\n        q.add(new int[]{0,l,0});\n        boolean[][] v = new boolean[n][l+1];\n\n        while(q.size()>0){\n            int[] qp = q.poll();\n            int pos = qp[0], money = qp[1], assas = qp[2];\n\n            if(pos==n-1) return assas;\n            if(v[pos][money]) continue;\n            v[pos][money] = true;\n\n            for(int i=0; i<n; i++){\n                if(dist[pos][i]==-1) continue;\n                if(dist[pos][i]<=money){\n                    q.add(new int[]{i,money-dist[pos][i],assas});\n                }\n                q.add(new int[]{i,money,assas+assa[pos][i]});\n            }\n        }\n\n        return -1;\n    }\n\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Brave Princess Revisited\n// 2013/05/12\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\n\tint n, m, bMax;\n\tint[] us, vs, ws, xs;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tm=sc.nextInt();\n\t\t\tbMax=sc.nextInt();\n\t\t\tif(n==0&&m==0&&bMax==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tus=new int[m];\n\t\t\tvs=new int[m];\n\t\t\tws=new int[m];\n\t\t\txs=new int[m];\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tus[i]=sc.nextInt()-1;\n\t\t\t\tvs[i]=sc.nextInt()-1;\n\t\t\t\tws[i]=sc.nextInt();\n\t\t\t\txs[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<E>[] es=new ArrayList[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tes[i]=new ArrayList<E>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tes[us[i]].add(new E(vs[i], ws[i], xs[i]));\n\t\t\tes[vs[i]].add(new E(us[i], ws[i], xs[i]));\n\t\t}\n\n\t\tPriorityQueue<P> que=new PriorityQueue<P>();\n\t\tque.offer(new P(0, bMax, 0));\n\t\tint[][] d=new int[n][bMax+1];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfill(d[i], INF);\n\t\t}\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tif(p.cost>d[p.v][p.b]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(E e : es[p.v]){\n\t\t\t\tif(p.b-e.w>=0){\n\t\t\t\t\tP q=new P(e.to, p.b-e.w, p.cost);\n\t\t\t\t\tif(q.cost<d[q.v][q.b]){\n\t\t\t\t\t\tque.offer(q);\n\t\t\t\t\t\td[q.v][q.b]=q.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tP q=new P(e.to, p.b, p.cost+e.x);\n\t\t\t\t\tif(q.cost<d[q.v][q.b]){\n\t\t\t\t\t\tque.offer(q);\n\t\t\t\t\t\td[q.v][q.b]=q.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min=INF;\n\t\tfor(int i=0; i<=bMax; i++){\n\t\t\tmin=min(min, d[n-1][i]);\n\t\t}\n\t\tprintln(min+\"\");\n\t}\n\n\tclass E{\n\t\tint to, w, x;\n\n\t\tE(int to, int w, int x){\n\t\t\tthis.to=to;\n\t\t\tthis.w=w;\n\t\t\tthis.x=x;\n\t\t}\n\t}\n\n\tclass P implements Comparable<P>{\n\t\tint v, b, cost;\n\n\t\tP(int v, int b, int cost){\n\t\t\tthis.v=v;\n\t\t\tthis.b=b;\n\t\t\tthis.cost=cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P p){\n\t\t\treturn cost-p.cost;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\n\tint n, m, bMax;\n\tint[] us, vs, ws, xs;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tbMax = sc.nextInt();\n\t\t\tif (n == 0 && m == 0 && bMax == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tus = new int[m];\n\t\t\tvs = new int[m];\n\t\t\tws = new int[m];\n\t\t\txs = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tus[i] = sc.nextInt() - 1;\n\t\t\t\tvs[i] = sc.nextInt() - 1;\n\t\t\t\tws[i] = sc.nextInt();\n\t\t\t\txs[i] = sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<E>[] es = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tes[i] = new ArrayList<E>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tes[us[i]].add(new E(vs[i], ws[i], xs[i]));\n\t\t\tes[vs[i]].add(new E(us[i], ws[i], xs[i]));\n\t\t}\n\n\t\tPriorityQueue<P> que = new PriorityQueue<P>();\n\t\tque.offer(new P(0, bMax, 0));\n\t\tint[][] d = new int[n][bMax + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfill(d[i], INF);\n\t\t}\n\n\t\tfor (; !que.isEmpty();) {\t\t\t\n\t\t\tP p = que.poll();\n\t\t\tif (p.cost > d[p.v][p.b]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// debug(p.v,p.b,p.cost);\n\t\t\tfor (E e : es[p.v]) {\n\t\t\t\tif (p.b - e.w >= 0) {\n\t\t\t\t\tP q = new P(e.to, p.b - e.w, p.cost);\n\t\t\t\t\tif (q.cost < d[q.v][q.b]) {\n\t\t\t\t\t\tque.offer(q);\n\t\t\t\t\t\td[q.v][q.b]=q.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tP q = new P(e.to, p.b, p.cost + e.x);\n\t\t\t\t\tif (q.cost < d[q.v][q.b]) {\n\t\t\t\t\t\tque.offer(q);\n\t\t\t\t\t\td[q.v][q.b]=q.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// debug(i, d[i]);\n\t\t}\n\t\tint min = INF;\n\t\tfor (int i = 0; i <= bMax; i++) {\n\t\t\tmin = min(min, d[n - 1][i]);\n\t\t}\n//\t\tdebug(min);\n\t\tprintln(min+\"\");\n\t}\n\n\tclass E {\n\t\tint to, w, x;\n\n\t\tE(int to, int w, int x) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t\tthis.x = x;\n\t\t}\n\t}\n\n\tclass P implements Comparable<P> {\n\t\tint v, b, cost;\n\n\t\tP(int v, int b, int cost) {\n\t\t\tthis.v = v;\n\t\t\tthis.b = b;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P p) {\n\t\t\treturn cost - p.cost;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Brave Princess Revisited\npublic class Main{\n\n\tint[][] dist;\n\tvoid run(){\n\t\tScanner sc =new Scanner(System.in);\n\t\tint INF = 1<<29;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), L = sc.nextInt();\n\t\t\tif((n|m|L)==0)break;\n\t\t\tint[][] d = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:d)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, D = sc.nextInt(), E = sc.nextInt();\n\t\t\t\td[s][t] = d[t][s] = D; e[s][t] = e[t][s] = E;\n\t\t\t}\n\t\t\tdist = new int[n][L+1];\n\t\t\tfor(int[]a:dist)Arrays.fill(a, INF);\n\t\t\tdist[0][L] = 0;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(n, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn dist[o1[0]][o1[1]]-dist[o2[0]][o2[1]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(new int[]{0, L});\n\t\t\tint res = INF;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tint v = a[0], c = a[1];\n\t\t\t\tif(v==n-1){\n\t\t\t\t\tres = Math.min(res, dist[v][c]); continue;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(d[v][i]==INF)continue;\n\t\t\t\t\tint w = dist[v][c] + e[v][i];\n\t\t\t\t\tif(w<dist[i][c]){\n\t\t\t\t\t\tdist[i][c] = w; q.add(new int[]{i, c});\n\t\t\t\t\t}\n\t\t\t\t\tif(d[v][i]<=c&&dist[v][c]<dist[i][c-d[v][i]]){\n\t\t\t\t\t\tdist[i][c-d[v][i]] = dist[v][c]; q.add(new int[]{i, c-d[v][i]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\npublic class Main {\n\tstatic int[][][] map;\n\tstatic int n, l, min = 1000000;\n\tstatic Node[] mapscopy;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tl = sc.nextInt();\n\t\t\tif(n==0&&m==0&&l==0)break;\n\t\t\tmin=1000000;\n\t\t\t\n\t\t\tNode[] maps = new Node[n + 1];\n\t\t\tmapscopy = new Node[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tmaps[i] = new Node(i);\n\t\t\t\tmapscopy[i] = new Node(i);\n\t\t\t\tmapscopy[i].frag=true;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\n\t\t\t\tmaps[a].list.add(maps[b]);\n\t\t\t\tmaps[a].length.add(d);\n\t\t\t\tmaps[a].enemy.add(e);\n\n\t\t\t\tmaps[b].list.add(maps[a]);\n\t\t\t\tmaps[b].length.add(d);\n\t\t\t\tmaps[b].enemy.add(e);\n\n\t\t\t\tmapscopy[a].list.add(maps[b]);\t\n\t\t\t\tmapscopy[a].length.add(d);\n\t\t\t\tmapscopy[a].enemy.add(e);\n\n\t\t\t\tmapscopy[b].list.add(maps[a]);\n\t\t\t\tmapscopy[b].length.add(d);\n\t\t\t\tmapscopy[b].enemy.add(e);\n\n\t\t\t}\n\t\t\tArrayList<Integer> sublist=new ArrayList<Integer>();\n\t\t\tsublist.add(1);\n\t\t\trec(maps[1], l, 0,sublist);\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tpublic static void rec(Node mmm, int lll, int enemy,ArrayList<Integer> lists) {\n\t\tSystem.out.println(\"my\"+mmm.my+\" \"+lll+\" \"+enemy);\n\t\tif (mmm.my == n) {\n//\t\t\tSystem.out.println(\"result\"+enemy);\n\t\t\tmin = Math.min(min, enemy);\n\t\t\tlists.remove(lists.size()-1);\n\t\t\treturn;\n\t\t}\n//\t\tSystem.out.println(\"lists\"+mmm.my);\n//\t\tfor(int i:lists)System.out.print(i+\" \");\n//\t\tSystem.out.println(\"size \"+mmm.list.size());\n\n\t\t\n\t\t\n\t\tfor(int i=0;i<mmm.list.size();i++) {\n\t\t\tNode sub = mmm.list.get(i);\n\t\t\tint len = mmm.length.get(i);\n\t\t\tint ene = mmm.enemy.get(i);\n\t\t\t\n\t\t\t//mapscopy[sub.my].list.remove(0);\n\t\t\t//mapscopy[sub.my].length.remove(0);\n\t\t\t//mapscopy[sub.my].enemy.remove(0);\n\t\t\t\n\t\t\tif(lists.contains(sub.my))continue;\n\t\t\t//\tlists.remove(lists.size()-1);\n\t\t\t//\treturn;\n\t\t\t\n\t//\t\tint hh=enemy+ene;\n\t//\t\tSystem.out.println(\" \"+lll+\" \"+hh);\n\t\t\tlists.add(sub.my);\n\t\t\trec(sub, lll, enemy + ene,lists);\n\t\t\n\t\t\tif (lll-len>=0){\n\t//\t\t\tint h=lll-len;\n\t//\t\t\tSystem.out.println(\",\"+h+\" \"+enemy);\n\t\t\t\tlists.add(sub.my);\n\t\t\t\trec(mapscopy[sub.my], lll - len, enemy,lists);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tlists.remove(lists.size()-1);\n\t}\n\t\n\tpublic static ArrayList<Integer> cplist(ArrayList<Integer> jl){\n\t\tArrayList<Integer> sss=new ArrayList<Integer>();\n\t\tfor(int i:jl)sss.add(i);\n\t\treturn sss;\n\t}\n\n}\n\nclass Node {\n\n\tint my;\n\tboolean frag;\n\tint ene;\n\tint result;\n\tArrayList<Node> list = new ArrayList<Node>();\n\tArrayList<Integer> length = new ArrayList<Integer>();\n\tArrayList<Integer> enemy = new ArrayList<Integer>();\n\n\tpublic Node(int my) {\n\t\tthis.my = my;\n\t\tthis.frag = false;\n\t\tthis.result = 10001;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-10;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tint L = sc.nextInt();\n\t\t\tif ((N | M | L) == 0)\n\t\t\t\tbreak;\n\t\t\tint es[][][] = new int[N][N][2];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tArrays.fill(es[i][j], INF);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\tes[a][b][0] = d;\n\t\t\t\tes[a][b][1] = e;\n\t\t\t\tes[b][a][0] = d;\n\t\t\t\tes[b][a][1] = e;\n\t\t\t}\n\t\t\tQueue<Node> q = new PriorityQueue<Node>();\n\t\t\tq.add(new Node(0, L, 0));\n\t\t\t// boolean visited[] = new boolean[N];\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode n = q.poll();\n\t\t\t\tint v = n.v;\n\t\t\t\tint d = n.money;\n\t\t\t\tint enemy = n.enemy;\n\t\t\t\tif (v == N - 1) {\n\t\t\t\t\tSystem.out.println(enemy);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\tif (es[v][i][0] >= INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (d >= es[v][i][0]) {\n\t\t\t\t\t\tq.add(new Node(i, d - es[v][i][0], enemy));\n\t\t\t\t\t}\n\t\t\t\t\tq.add(new Node(i, d, enemy + es[v][i][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Node implements Comparable<Node> {\n\tint v;\n\tint money;\n\tint enemy;\n\n\tpublic Node(int v, int money, int enemy) {\n\t\tthis.v = v;\n\t\tthis.money = money;\n\t\tthis.enemy = enemy;\n\t}\n\n\t@Override\n\tpublic int compareTo(Node o) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\treturn this.enemy - o.enemy;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tint money = in.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tint[][] e = new int[n][n];\n\t\t\tint[][] d = new int[n][n];\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint a = in.nextInt()-1;\n\t\t\t\tint b = in.nextInt()-1;\n\t\t\t\tint dist = in.nextInt();\n\t\t\t\tint enemy = in.nextInt();\n\t\t\t\td[a][b] = d[b][a] = dist;\n\t\t\t\te[a][b] = e[b][a] = enemy;\n\t\t\t\tnode[a].createEdge(node[b]);\n\t\t\t\tnode[b].createEdge(node[a]);\n\t\t\t}\n\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\tqu.add(new Pos(0, 0, money, 0, 1));\n\t\t\tint[][] used = new int[n][money+1];\n\t\t\tfinal int INF = 100000000;\n\t\t\tint res = INF;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(used[p.id][p.m] != 0 && used[p.id][p.m] <= p.e) continue;\n\t\t\t\tif(p.id == n-1){\n\t\t\t\t\tres = Math.min(p.e, res);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[p.id][p.m] = p.e;\n\t\t\t\tfor(Node v: node[p.id].edge){\n\t\t\t\t\tif((p.state&1<<v.id)>0) continue;\n\t\t\t\t\tqu.add(new Pos(v.id, p.d+d[p.id][v.id], p.m, p.e+e[p.id][v.id], p.state|1<<v.id));\n\t\t\t\t\tif(p.m - d[p.id][v.id] < 0) continue;\n\t\t\t\t\tqu.add(new Pos(v.id, p.d+d[p.id][v.id], p.m-d[p.id][v.id], p.e, p.state|1<<v.id));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint id;\n\tint d, m, e;\n\tint state;\n\tpublic Pos(int id, int d, int m, int e, int state){\n\t\tthis.id = id;\n\t\tthis.d = d;\n\t\tthis.m = m;\n\t\tthis.e = e;\n\t\tthis.state = state;\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn e-o.e;\n\t}\n}\n\nclass Node{\n\tint id;\n\tArrayList<Node> edge = new ArrayList<Node>();\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t}\n\tpublic void createEdge(Node nd){\n\t\tedge.add(nd);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\npublic class Main {\n\tstatic int[][][] map;\n\tstatic int n, l, min = 1000000;\n\tstatic Node[] mapscopy;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tl = sc.nextInt();\n\t\t\tif(n==0&&m==0&&l==0)break;\n\t\t\tmin=1000000;\n\t\t\t\n\t\t//\tmap = new int[n + 1][n + 1][2];\n\n\t\t\tNode[] maps = new Node[n + 1];\n\t\t\tmapscopy = new Node[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tmaps[i] = new Node(i);\n\t\t\t\tmapscopy[i] = new Node(i);\n\t\t\t\tmapscopy[i].frag=true;\n\t\t//\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t//\t\tmap[i][j][0] = 101;\n\t\t\t//\t\tmap[i][j][1] = 10001;\n\t\t\t//}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\n\t\t//\t\tmap[a][b][0] = d;\n\t\t//\t\tmap[b][a][1] = e;\n\n\t\t\t\tmaps[a].list.add(maps[b]);\n\t\t\t\t// maps[a].list.add(mapscopy[b]);\n\t\t\t\tmaps[a].length.add(d);\n\t\t\t\tmaps[a].enemy.add(e);\n\n\t\t\t\tmaps[b].list.add(maps[a]);\n\t\t\t\t// maps[b].list.add(mapscopy[a]);\n\t\t\t\tmaps[b].length.add(d);\n\t\t\t\tmaps[b].enemy.add(e);\n\n\t\t\t\tmapscopy[a].list.add(maps[b]);\n\t\t\t\t// mapscopy[a].list.add(mapscopy[b]);\n\t\t\t\tmapscopy[a].length.add(d);\n\t\t\t\tmapscopy[a].enemy.add(e);\n\n\t\t\t\tmapscopy[b].list.add(maps[a]);\n\t\t\t\t// mapscopy[b].list.add(mapscopy[a]);\n\t\t\t\tmapscopy[b].length.add(d);\n\t\t\t\tmapscopy[b].enemy.add(e);\n\n\t\t\t}\n\t\t\tArrayList<Integer> sublist=new ArrayList<Integer>();\n\t\t\tsublist.add(1);\n\t\t\trec(maps[1], l, 0,sublist);\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tpublic static void rec(Node mmm, int lll, int enemy,ArrayList<Integer> lists) {\n//\t\tSystem.out.println(\"my\"+mmm.my+\" \"+lll+\" \"+enemy);\n\t\tif (mmm.my == n) {\n//\t\t\tSystem.out.println(\"result\"+enemy);\n\t\t\tmin = Math.min(min, enemy);\n\t\t\tlists.remove(lists.size()-1);\n\t\t\treturn;\n\t\t}\n//\t\tSystem.out.println(\"lists\"+mmm.my);\n//\t\tfor(int i:lists)System.out.print(i+\" \");\n//\t\tSystem.out.println(\"size \"+mmm.list.size());\n\n\t\t\n\t\t\n\t\twhile (!mmm.list.isEmpty()) {\n\t\t\tNode sub = mmm.list.remove(0);\n\t\t\tint len = mmm.length.remove(0);\n\t\t\tint ene = mmm.enemy.remove(0);\n\t\t\t\n\t\t\t//mapscopy[sub.my].list.remove(0);\n\t\t\t//mapscopy[sub.my].length.remove(0);\n\t\t\t//mapscopy[sub.my].enemy.remove(0);\n\t\t\t\n\t\t\tif(lists.contains(sub.my)){\n\t\t\t\tcontinue;\n\t\t\t//\tlists.remove(lists.size()-1);\n\t\t\t//\treturn;\n\t\t\t}\n\t//\t\tint hh=enemy+ene;\n\t//\t\tSystem.out.println(\" \"+lll+\" \"+hh);\n\t\t\tlists.add(sub.my);\n\t\t\trec(sub, lll, enemy + ene,lists);\n\t\t\n\t\t\tif (lll-len>=0){\n\t//\t\t\tint h=lll-len;\n\t//\t\t\tSystem.out.println(\",\"+h+\" \"+enemy);\n\t\t\t\tlists.add(sub.my);\n\t\t\t\trec(mapscopy[sub.my], lll - len, enemy,lists);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tlists.remove(lists.size()-1);\n\t}\n\t\n\tpublic static ArrayList<Integer> cplist(ArrayList<Integer> jl){\n\t\tArrayList<Integer> sss=new ArrayList<Integer>();\n\t\tfor(int i:jl)sss.add(i);\n\t\treturn sss;\n\t}\n\n}\n\nclass Node {\n\n\tint my;\n\tboolean frag;\n\tint ene;\n\tint result;\n\tArrayList<Node> list = new ArrayList<Node>();\n\tArrayList<Integer> length = new ArrayList<Integer>();\n\tArrayList<Integer> enemy = new ArrayList<Integer>();\n\n\tpublic Node(int my) {\n\t\tthis.my = my;\n\t\tthis.frag = false;\n\t\tthis.result = 10001;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n, m, l;\n\tLinkedList<E>[] Edge;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tl = sc.nextInt();\n\t\t\tif( (n|m|l) == 0 ) break;\n\t\t\t\n\t\t\tEdge = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++) Edge[i] = new LinkedList<E>();\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1;\n\t\t\t\tint b = sc.nextInt()-1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\tEdge[a].add(new E(b, d, e));\n\t\t\t\tEdge[b].add(new E(a, d, e));\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\t\n\tint solve() {\n\t\tPriorityQueue<Node> que = new PriorityQueue<Node>();\n\t\tque.add(new Node(0, l, 0));\n\t\tint vis[][] = new int[n][l+1];\n\t\tfor(int[] a: vis) fill(a, INF);\n\t\tvis[0][l] = 0;\n\t\t\n\t\tfor(;;) {\n\t\t\tNode now = que.remove();\n\t\t\tif(now.n == n-1 ) return now.e;\n\t\t\tif( vis[now.n][now.l] != now.e ) continue;\n\t\t\t\n\t\t\tfor(E e: Edge[now.n]) {\n\t\t\t\tque.add( new Node(e.t, now.l, now.e + e.e) );\n\t\t\t\tvis[e.t][now.l] = min(vis[e.t][now.l], now.e + e.e);\n\t\t\t\tif( now.l >= e.d ) {\n\t\t\t\t\tque.add( new Node(e.t, now.l-e.d, now.e) );\n\t\t\t\t\tvis[e.t][now.l-e.d] = min(vis[e.t][now.l-e.d], now.e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass Node implements Comparable<Node>{\n\t\tint n, l, e;\n\t\t\n\t\tNode(int n, int l, int e) {\n\t\t\tthis.n = n;\n\t\t\tthis.l = l;\n\t\t\tthis.e = e;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Node o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn e - o.e;\n\t\t}\n\t}\n\t\n\tclass E {\n\t\tint t, d, e;\n\t\tE(int t, int d, int e) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic final int INF = 1000000000;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tNode[] inn = new Node[101];\n\t\tint[][] dp = new int[101][101];\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif(n == 0 && m == 0 & l == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tinn[i] = new Node(i);\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\t\n\t\t\t\tinn[a].edges.add(new Edge(e, d, inn[b]));\n\t\t\t\tinn[b].edges.add(new Edge(e, d, inn[a]));\n\t\t\t}\n\t\t\tboolean[] flg = new boolean[n + 1];\n\t\t\tfor(int i = 0; i <= n; i++){\n\t\t\t\tflg[i] = false;\n\t\t\t}\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\t\tdp[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\t\tint len = 0;\n\t\t\tdp[1][0] = 0;\n\t\t\tq.add(inn[1]);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tNode node = q.poll();\n\t\t\t\tlen = node.c;\n\t\t\t\tfor(Edge e : node.edges){\n\t\t\t\t\t// ???????????£????????????\n\t\t\t\t\tif(len + e.d <= l){ // ?????¨??????????????????\n\t\t\t\t\t\t// ?????¨?????£?????´???????\\???????????????°????°???????????????????\n\t\t\t\t\t\tif(dp[e.t.n][len + e.d] > dp[node.n][len]){\n\t\t\t\t\t\t\tNode nnode = new Node(e.t.n);\n\t\t\t\t\t\t\tnnode.edges = e.t.edges;\n\t\t\t\t\t\t\tnnode.c = len + e.d;\n\t\t\t\t\t\t\tq.add(nnode);\n\t\t\t\t\t\t\tdp[e.t.n][len + e.d] = dp[node.n][len] ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ????????£???????????????\n\t\t\t\t\t// ?????¨??????????????´???????\\???????????????°????????????\n\t\t\t\t\tif(dp[e.t.n][len] > dp[node.n][len] + e.e){\n\t\t\t\t\t\tNode nnode = new Node(e.t.n);\n\t\t\t\t\t\tnnode.edges = e.t.edges;\n\t\t\t\t\t\tnnode.c = len;\n\t\t\t\t\t\tq.add(nnode);\n\t\t\t\t\t\tdp[e.t.n][len] = dp[node.n][len] + e.e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = INF;\n\t\t\tfor(int i = 0; i <= l; i++){\n\t\t\t\tmin = Math.min(min, dp[n][i]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t\tSystem.gc();\n\t\t}\n\t\t\n\t\t\n\t\tsc.close();\n\t}\n}\nclass Node implements Comparable<Node>{\n\tint n;\n\tint c;\n\tLinkedList<Edge> edges;\n\tNode(int number){\n\t\tedges = new LinkedList<Edge>();\n\t\tn = number;\n\t\tc = 0;\n\t}\n\tpublic int compareTo(Node o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn n - o.n;\n\t}\n}\nclass Edge{\n\tboolean flg;\n\tint e;\n\tint d;\n\tNode t;\n\tEdge(int enemy, int dist, Node to){\n\t\te = enemy;\n\t\td = dist;\n\t\tt = to;\n\t\tflg = false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint m=sc.nextInt();\n\t\tint l=sc.nextInt();\n\t\t\n//\t\tint[][][] map=new int[n+1][n+1][2];\n\t\tMaps[][] map=new Maps[n+1][n+1];\n\t\tint[][][] mapmap=new int[n+1][n+1][2];\n//\t\tboolean[][] sw=new boolean[n+1][n+1];\n\t\t\n\t\tfor(int i=1;i<n+1;i++){\n\t\t\tfor(int j=1;j<n+1;j++)map[i][j]=new Maps();\n\t\t}\n\t\n\t\t\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x=sc.nextInt();\n\t\t\tint y=sc.nextInt();\n\t\t\tSystem.out.println(x+\" \"+y);\n\t\t\t\n\t\t\tint sub=sc.nextInt();\n\t\t\tmap[x][y].length=sub;\n\t\t\tmap[y][x].length=sub;\n\t\t\tmapmap[x][y][0]=sub;\n\t\t\t\n\t\t\tint sub2=sc.nextInt();\n\t\t\tmap[x][y].enemy=sub2;\n\t\t\tmap[y][x].enemy=sub2;\n\t\t\tmapmap[x][y][1]=sub2;\n\t\t\t\n\t\t\tif(map[x][y].length<l){\n\t\t\t\tmap[x][y].frag=true;\n\t\t\t\tmap[y][x].frag=true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=1;i<n+1;i++){\n\t\t\tfor(int j=1;j<n+1;j++){\n\t\t\t\tfor(int k=1;k<n+1;k++){\n\t\t\t\t\tif(i==j||i==k||j==k)continue;\n\t\t\t\t\t//if(map[i][j].length>map[i][k].length+map[k][j].length)map[i][j].length=map[i][k].length+map[k][j].length;\n\t\t\t\t\tif(map[i][j].enemy>map[i][k].enemy+map[k][j].enemy){\n\t\t\t\t\t\tmap[i][j].enemy=map[i][k].enemy+map[k][j].enemy;\n\t\t\t\t\t\t\n\t\t\t\t\t\tmap[j][i].enemy=map[i][k].enemy+map[k][j].enemy;\n\t\t\t\t\t\t\n\t\t\t\t\t\tmap[i][j].length=map[i][k].length+map[k][j].length;\n\t\t\t\t\t\tmap[j][i].length=map[i][k].length+map[k][j].length;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(map[1][n].enemy);\n\t\t\t\n\t\t\n/*\t\tfor(int i=1;i<n+1;i++){\n\t\t\tfor(int j=1;j<n+1;j++){\n\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+map[i][j].length+\" \"+map[i][j].enemy);\n\t\t\t}\n\t\t}*/\n\t}\n\n}\n\n\nclass Maps{\n\tint length=10001;\n\tint enemy=10001;\n\tArrayList<Integer> listl=new ArrayList<Integer>();\n\tArrayList<Integer> liste=new ArrayList<Integer>();\n\tboolean frag=false;\n\tint risk=101;\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\tpublic static Random rand=new Random();\n\n\n\tstatic final int INF =1<<30;\n\tstatic class Node{\n\t\tint id,l;\n\t\tList<Edge> link=new LinkedList<Edge>();\n\t\tNode(int _id,int _l){\n\t\t\tid=_id;l=_l;\n\t\t}\n\t}\n\tstatic class Edge{\n\t\tNode from,to;\n\t\tint cost;\n\t\tEdge(Node _from,Node _to,int _cost){\n\t\t\tfrom=_from;to=_to;\n\t\t\tcost=_cost;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn from+\"→\"+to;\n\t\t}\n\t}\n\tstatic class Task implements Comparable<Task>{\n\t\tNode pos;\n\t\tint cost;\n\t\tTask(Node _pos,int _cost){\n\t\t\tpos=_pos;cost=_cost;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Task T) {\n\t\t\treturn cost-T.cost;\n\t\t}\n\t}\n\n\tpublic static int[][] dijkstra(Node[][] graph,int s){\n\t\tfinal int V=graph.length, L=graph[0].length-1;\n\t\tint[][] d=new int[V][L+1];\n\t\tfor(int i=0;i<V;i++)Arrays.fill(d[i],INF);d[s][L]=0;\n\n\t\tPriorityQueue<Task> que=new PriorityQueue<Task>();\n\t\tque.add(new Task(graph[s][L],0));\n\t\twhile(!que.isEmpty()){\n\t\t\tTask task=que.poll();\n\t\t\t//if(d[task.pos]<task.cost)continue;\n\t\t\tfor(Edge e:graph[task.pos.id][task.pos.l].link){\n\t\t\t\tif(d[e.to.id][e.to.l]>d[e.from.id][e.from.l]+e.cost){\n\t\t\t\t\td[e.to.id][e.to.l]=d[e.from.id][e.from.l]+e.cost;\n\t\t\t\t\tque.add(new Task(e.to,d[e.to.id][e.to.l]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tpublic void run() {\n\n\t\tTCase:while(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt(),L=sc.nextInt();\n\t\t\tif(N==0)return;\n\t\t\tNode[][] graph=new Node[N][L+1];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<=L;j++)\n\t\t\t\tgraph[i][j]=new Node(i,j);\n\n\t\t\t//edge\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tint f=sc.nextInt()-1,t=sc.nextInt()-1;\n\t\t\t\tint d=sc.nextInt(),c=sc.nextInt();\n\n\t\t\t\tfor(int l=0;l<=L;l++)if(l-d>=0){\n\t\t\t\t\tgraph[f][l].link.add(new Edge(graph[f][l],graph[t][l-d],0));\n\t\t\t\t\tgraph[t][l].link.add(new Edge(graph[t][l],graph[f][l-d],0));\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<=L;l++){\n\t\t\t\t\tgraph[f][l].link.add(new Edge(graph[f][l],graph[t][l],c));\n\t\t\t\t\tgraph[t][l].link.add(new Edge(graph[t][l],graph[f][l],c));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] d=dijkstra(graph,0);\n\n\t\t\tint mv=INF;\n\t\t\tfor(int l=0;l<=L;l++){\n\t\t\t\tmv=min(mv,d[N-1][l]);\n\t\t\t}\n\t\t\tln(mv);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj2151().doIt();\n    }\n    class aoj2151{\n    \tEe d_e[][] = new Ee[101][101];\n    \tint dist[][] = new int[101][101];\n    \tint INF = Integer.MAX_VALUE/2;\n    \tPriorityQueue<Pos> q = new PriorityQueue<Pos>();\n    \tint dikstra(int N,int L){\n    \t\tint result = Integer.MAX_VALUE;\n    \t\tfor(int i = 0;i < N;i++)Arrays.fill(dist[i], INF);\n    \t\tdist[0][L] = 0;\n    \t\twhile(q.size() > 0){\n    \t\t\tPos p = q.remove();\n//    \t\t\tSystem.out.println(p.v+\" \"+p.money+\" \"+p.enemy);\n    \t\t\tif(p.v == N-1)result = Math.min(result, p.enemy);\n    \t\t\tfor(int i = 0;i < N;i++){\n    \t\t\t\tif(d_e[i][p.v].money == 0)continue;\n    \t\t\t\tif(p.v == i)continue;\n    \t\t\t\tif(p.money < d_e[i][p.v].money){\n    \t\t\t\t\tif(dist[i][p.money] <= p.enemy + d_e[i][p.v].enemy)continue;\n    \t\t\t\t\tdist[i][p.money] = p.enemy + d_e[i][p.v].enemy;\n    \t\t\t\t\tq.add(new Pos(i,p.money,p.enemy + d_e[i][p.v].enemy));\n    \t\t\t\t}else{\n    \t\t\t\t\tint mo = p.money - d_e[i][p.v].money;\n    \t\t\t\t\tif(dist[i][mo] > p.enemy){\n    \t\t\t\t\t\tdist[i][mo] = p.enemy;\n    \t\t\t\t\t\tq.add(new Pos(i,mo,p.enemy));\n    \t\t\t\t\t}\n    \t\t\t\t\tif(dist[i][p.money] > p.enemy + d_e[i][p.v].enemy){\n    \t\t\t\t\t\tdist[i][p.money] = p.enemy + d_e[i][p.v].enemy;\n    \t\t\t\t\t\tq.add(new Pos(i,p.money,p.enemy + d_e[i][p.v].enemy));\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\treturn result;\n    \t}\n    \tvoid set(){\n    \t\tfor(int i = 0;i < 101;i++){\n    \t\t\tfor(int j = 0;j < 101;j++){\n    \t\t\t\td_e[i][j] = new Ee(0,0);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tint N = sc.nextInt();\n    \t\t\tint M = sc.nextInt();\n    \t\t\tint L = sc.nextInt();\n    \t\t\tif(N+M+L == 0)break;\n    \t\t\tset();\n    \t\t\tq.add(new Pos(0,L,0));\n    \t\t\tfor(int i = 0;i < M;i++){\n    \t\t\t\tint s = sc.nextInt()-1;\n    \t\t\t\tint e = sc.nextInt()-1;\n    \t\t\t\tEe E = new Ee(sc.nextInt(),sc.nextInt());\n    \t\t\t\td_e[s][e] = E;\n    \t\t\t\td_e[e][s] = E;\n    \t\t\t}\n    \t\t\tSystem.out.println(dikstra(N,L));\n    \t\t}\n        }\n    \tclass Ee{\n    \t\tint money,enemy;\n    \t\tpublic Ee(int money,int enemy){\n    \t\t\tthis.money = money;\n    \t\t\tthis.enemy = enemy;\n    \t\t}\n    \t}\n    \tclass Pos implements Comparable<Pos>{\n    \t\tint v,money,enemy;\n    \t\tpublic Pos(int v,int money,int enemy){\n    \t\t\tthis.v = v;\n    \t\t\tthis.money = money;\n    \t\t\tthis.enemy = enemy;\n    \t\t}\n    \t\tpublic int compareTo(Pos o){\n    \t\t\treturn this.enemy - o.enemy;\n    \t\t}\n    \t}\n     }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int N, M, L;\n    static Edge[] E;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n\n        while(true) {\n            N = sc.nextInt();\n            M = sc.nextInt();\n            L = sc.nextInt();\n            if( N == 0 ) break;\n\n            E = new Edge[M];\n            for (int i = 0; i < M; i++) {\n                E[i] = new Edge(sc.nextInt()-1, sc.nextInt()-1, sc.nextInt(), sc.nextInt());\n            }\n\n            System.out.println(solve());\n        }\n    }\n\n    static class Edge {\n        int a, b, d, e;\n\n        public Edge(int a, int b, int d, int e) {\n            this.a = a;\n            this.b = b;\n            this.d = d;\n            this.e = e;\n        }\n    }\n\n    static int solve() {\n        Edge[][] G = adjB(N, E);\n\n        int[][] dist = new int[N][L+1];\n        for (int[] row : dist) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n        PriorityQueue<State> q = new PriorityQueue<>(Comparator.comparingInt(s -> s.e));\n        dist[0][0] = 0;\n        q.add( new State(0, 0, 0) );\n        while(!q.isEmpty()) {\n            State s = q.poll();\n            if( dist[s.a][s.used] != s.e) continue;\n\n            for (Edge edge : G[s.a]) {\n                int b = edge.a == s.a ? edge.b : edge.a;\n\n                // 金を使う\n                int nextUsed = s.used + edge.d;\n                if( nextUsed <= L && dist[b][nextUsed] > s.e) {\n                    dist[b][nextUsed] = s.e;\n                    q.add( new State(b, nextUsed, s.e) );\n                }\n\n                // 金を使わない\n                if( dist[b][s.used] > s.e + edge.e ) {\n                    dist[b][s.used] = s.e + edge.e;\n                    q.add( new State(b, s.used, dist[b][s.used]) );\n                }\n            }\n        }\n\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i <= L; i++) {\n            ans = Math.min(ans, dist[N-1][i] );\n        }\n        return ans;\n    }\n\n    static class State {\n        int a, used, e;\n\n        public State(int a, int used, int e) {\n            this.a = a;\n            this.used = used;\n            this.e = e;\n        }\n    }\n\n    static Edge[][] adjB(int n, Edge[] E) {\n        Edge[][] adj = new Edge[n][];\n        int[] cnt = new int[n];\n        for (Edge e : E) {\n            cnt[e.a]++;\n            cnt[e.b]++;\n        }\n        for (int i = 0; i < n; i++) {\n            adj[i] = new Edge[cnt[i]];\n        }\n        for (Edge e : E) {\n            adj[e.a][--cnt[e.a]] = e;\n            adj[e.b][--cnt[e.b]] = e;\n        }\n        return adj;\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic final int INF = 1000000000;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tNode[] inn = new Node[101];\n\t\tint[][] dp = new int[101][101];\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif(n == 0 && m == 0 & l == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tinn[i] = new Node(i);\n\t\t\t}\n\t\t\tNode start = inn[1];\n\t\t\tNode goal = inn[n];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\t\n\t\t\t\tinn[a].edges.add(new Edge(e, d, inn[b]));\n\t\t\t\tinn[b].edges.add(new Edge(e, d, inn[a]));\n\t\t\t}\n\t\t\tboolean[] flg = new boolean[n + 1];\n\t\t\tfor(int i = 0; i <= n; i++){\n\t\t\t\tflg[i] = false;\n\t\t\t}\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\t\tdp[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\t\tint len = 0;\n\t\t\tdp[1][0] = 0;\n\t\t\tq.add(inn[1]);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tNode node = q.poll();\n\t\t\t\tlen = node.c;\n\t\t\t\tfor(Edge e : node.edges){\n\t\t\t\t\t// ???????????£????????????\n\t\t\t\t\tif(len + e.d <= l){ // ?????¨??????????????????\n\t\t\t\t\t\t// ?????¨?????£?????´???????\\???????????????°????°???????????????????\n\t\t\t\t\t\tif(dp[e.t.n][len + e.d] > dp[node.n][len]){\n\t\t\t\t\t\t\tNode nnode = new Node(e.t.n);\n\t\t\t\t\t\t\tnnode.edges = e.t.edges;\n\t\t\t\t\t\t\tnnode.c = len + e.d;\n\t\t\t\t\t\t\tq.add(nnode);\n\t\t\t\t\t\t\tdp[e.t.n][len + e.d] = dp[node.n][len] ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ????????£???????????????\n\t\t\t\t\t// ?????¨??????????????´???????\\???????????????°????????????\n\t\t\t\t\tif(dp[e.t.n][len] > dp[node.n][len] + e.e){\n\t\t\t\t\t\tNode nnode = new Node(e.t.n);\n\t\t\t\t\t\tnnode.edges = e.t.edges;\n\t\t\t\t\t\tnnode.c = len;\n\t\t\t\t\t\tq.add(nnode);\n\t\t\t\t\t\tdp[e.t.n][len] = dp[node.n][len] + e.e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = INF;\n\t\t\tfor(int i = 0; i <= l; i++){\n\t\t\t\tmin = Math.min(min, dp[n][i]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n//\t\t\tSystem.out.println(func(start, l, goal, flg));\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tsc.close();\n\t}\n\tstatic int func(Node node, int cap, Node goal, boolean[] flg){\n\t\tint res = 1000000000;\n\t\tif(node.equals(goal)){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(Edge e : node.edges){\n\t\t\tif(!flg[e.t.n]){\n\t\t\t\tif(e.d > cap){\n\t\t\t\t\tflg[node.n] = true;\n\t\t\t\t\tres = Math.min(res, func(e.t, cap, goal, flg) + e.e);\n\t\t\t\t\tflg[node.n] = false;\n\t\t\t\t}else{\n\t\t\t\t\tflg[node.n] = true;\n\t\t\t\t\tres = Math.min(res, Math.min(func(e.t, cap - e.d, goal, flg), func(e.t, cap, goal, flg) + e.e));\n\t\t\t\t\tflg[node.n] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n}\nclass Node implements Comparable<Node>{\n\tint n;\n\tint c;\n\tLinkedList<Edge> edges;\n\tNode(int number){\n\t\tedges = new LinkedList<Edge>();\n\t\tn = number;\n\t\tc = 0;\n\t}\n\t@Override\n\tpublic int compareTo(Node o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn n - o.n;\n\t}\n}\nclass Edge{\n\tboolean flg;\n\tint e;\n\tint d;\n\tNode t;\n\tEdge(int enemy, int dist, Node to){\n\t\te = enemy;\n\t\td = dist;\n\t\tt = to;\n\t\tflg = false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n, m, l;\n\tLinkedList<E>[] Edge;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tl = sc.nextInt();\n\t\t\tif( (n|m|l) == 0 ) break;\n\t\t\t\n\t\t\tEdge = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++) Edge[i] = new LinkedList<E>();\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1;\n\t\t\t\tint b = sc.nextInt()-1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\tEdge[a].add(new E(b, d, e));\n\t\t\t\tEdge[b].add(new E(a, d, e));\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\t\n\tint solve() {\n\t\tPriorityQueue<Node> que = new PriorityQueue<Node>();\n\t\tque.add(new Node(0, l, 0));\n\t\tint vis[][] = new int[n][l+1];\n\t\tfor(int[] a: vis) fill(a, INF);\n\t\tfill(vis[0], 0);\n\t\t\n\t\tfor(;;) {\n\t\t\tNode now = que.remove();\n//\t\t\tfor(Node node: que) debug(node.n, node.l, node.e);\n//\t\t\tdebug(\" \", now.n, now.l, now.e);\n\t\t\tif(now.n == n-1 ) return now.e;\n\t\t\tif( vis[now.n][now.l] != now.e ) continue;\n\t\t\t\n\t\t\tfor(E e: Edge[now.n]) {\n//\t\t\t\tdebug(now.l, e.d);\n\t\t\t\tif( vis[e.t][now.l] > now.e + e.e ) {\n\t\t\t\t\tque.add( new Node(e.t, now.l, now.e + e.e) );\n\t\t\t\t\tvis[e.t][now.l] = now.e + e.e;\n\t\t\t\t}\n\t\t\t\tif( now.l >= e.d ) {\n//\t\t\t\t\tdebug(\"a\");\n\t\t\t\t\tif( vis[e.t][now.l-e.d] <= now.e ) continue;\n\t\t\t\t\tque.add( new Node(e.t, now.l-e.d, now.e) );\n\t\t\t\t\tvis[e.t][now.l-e.d] = now.e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass Node implements Comparable<Node>{\n\t\tint n, l, e;\n\t\t\n\t\tNode(int n, int l, int e) {\n\t\t\tthis.n = n;\n\t\t\tthis.l = l;\n\t\t\tthis.e = e;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Node o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn e - o.e;\n\t\t}\n\t}\n\t\n\tclass E {\n\t\tint t, d, e;\n\t\tE(int t, int d, int e) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-10;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tint L = sc.nextInt();\n\t\t\tif ((N | M | L) == 0)\n\t\t\t\tbreak;\n\t\t\tint es[][][] = new int[N][N][2];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tArrays.fill(es[i][j], INF);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\tes[a][b][0] = d;\n\t\t\t\tes[a][b][1] = e;\n\t\t\t\tes[b][a][0] = d;\n\t\t\t\tes[b][a][1] = e;\n\t\t\t}\n\t\t\tQueue<Node> q = new PriorityQueue<Node>();\n\t\t\tq.add(new Node(0, L, 0));\n\t\t\tboolean visited[][] = new boolean[N][L + 1];\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode n = q.poll();\n\t\t\t\tint v = n.v;\n\t\t\t\tint d = n.money;\n\t\t\t\tint enemy = n.enemy;\n\t\t\t\tif (v == N - 1) {\n\t\t\t\t\tSystem.out.println(enemy);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (visited[v][d])\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited[v][d] = true;\n\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\tif (es[v][i][0] >= INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (d >= es[v][i][0]) {\n\t\t\t\t\t\tq.add(new Node(i, d - es[v][i][0], enemy));\n\t\t\t\t\t}\n\t\t\t\t\tq.add(new Node(i, d, enemy + es[v][i][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Node implements Comparable<Node> {\n\tint v;\n\tint money;\n\tint enemy;\n\n\tpublic Node(int v, int money, int enemy) {\n\t\tthis.v = v;\n\t\tthis.money = money;\n\t\tthis.enemy = enemy;\n\t}\n\n\t@Override\n\tpublic int compareTo(Node o) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\treturn this.enemy - o.enemy;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif(n == 0 && m == 0 && l == 0) break;\n\t\t\tint [][] pass = new int[n][n];\n\t\t\tint [][] money = new int[n][n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tArrays.fill(money[i], INF);\n\t\t\t}\n\t\t\tfor(int i = 0;i < m; i++){\n\t\t\t\tint from = sc.nextInt() - 1;\n\t\t\t\tint to = sc.nextInt() -1 ;\n\t\t\t\tint dis = sc.nextInt();\n\t\t\t\tint num = sc.nextInt();\n\t\t\t\tpass[from][to] = num;\n\t\t\t\tpass[to][from] = num;\n\t\t\t\tmoney[from][to] = dis;\n\t\t\t\tmoney[to][from] = dis;\n\t\t\t}\n\t\t\tPriorityQueue<C> open = new PriorityQueue<C>();\n\t\t\topen.add(new C(0,l,0));\n\t\t\tint [][] close = new int[n][l+1];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < l + 1; j++){\n\t\t\t\t\tclose[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(close[0],INF);\n\t\t\tint ans = INF;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\tint from = now.now;\n\t\t\t\t//goal\n\t\t\t\tif(from == n-1){\n\t\t\t\t\tans = Math.min(ans, now.num);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i= 0; i < n; i++){\n\t\t\t\t\tif(pass[from][i] == INF){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//use\n\t\t\t\t\tint nextnum = now.num + pass[from][i];\n\t\t\t\t\tif(now.money >= money[from][i]){\n\t\t\t\t\t\tint nextmoney = now.money - money[from][i];\n\t\t\t\t\t\tif(close[i][nextmoney] <= now.num) continue;\n\t\t\t\t\t\topen.add(new C(i, nextmoney, now.num));\n\t\t\t\t\t\tclose[i][nextmoney] = now.num;\n\t\t\t\t\t}\n\t\t\t\t\t//not use\n\t\t\t\t\tif(close[i][now.money] <= nextnum) continue;\n\t\t\t\t\topen.add(new C(i, now.money, nextnum));\n\t\t\t\t\tclose[i][now.money] = nextnum; \n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate class C implements Comparable<C>{\n\t\tint now,money,num;\n\t\t\n\t\tpublic C(int now, int money, int num) {\n\t\t\tthis.now = now;\n\t\t\tthis.money = money;\n\t\t\tthis.num = num;\n\t\t}\n\n\t\tpublic int compareTo(C o) {\n\t\t\tif(num < o.num) return -1;\n\t\t\tif(num > o.num) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  void run() {\n    for ( ;; ) {\n      int n = ni();\n      int m = ni();\n      int l = ni();\n      if ( ( n | m | l ) == 0 ) {\n        break;\n      }\n\n      int[][] dm = new int[n + 1][n + 1];\n      int[][] em = new int[n + 1][n + 1];\n      boolean[][] lk = new boolean[n + 1][n + 1];\n\n      for ( int i = 0; i < m; ++i ) {\n        int a = ni();\n        int b = ni();\n        int d = ni();\n        int e = ni();\n        dm[ a ][ b ] = dm[ b ][ a ] = d;\n        em[ a ][ b ] = em[ b ][ a ] = e;\n        lk[ a ][ b ] = lk[ b ][ a ] = true;\n      }\n\n      boolean[][] ok = new boolean[n + 1][l + 1];\n      int[][] dp = new int[n + 1][l + 1];\n      for ( int[] v : dp )\n        Arrays.fill( v, 1 << 28 );\n      dp[ 1 ][ l ] = 0;\n      ok[ 1 ][ l ] = true;\n      for ( int h = 0; h < n; ++h ) {\n        for ( int i = 1; i <= n; ++i ) {\n          for ( int j = 1; j <= n; ++j ) {\n            if ( lk[ i ][ j ] ) {\n              for ( int k = 0; k <= l; ++k ) {\n                if ( ok[ i ][ k ] ) {\n                  if ( k - dm[ i ][ j ] >= 0 ) {\n                    dp[ j ][ k - dm[ i ][ j ] ] = Math.min( dp[ j ][ k\n                        - dm[ i ][ j ] ], dp[ i ][ k ] );\n                    ok[ j ][ k - dm[ i ][ j ] ] = true;\n//                    debug( i, j, k - dm[ i ][ j ], dp[ j ][ k - dm[ i ][ j ] ] );\n                  }\n                  dp[ j ][ k ] = Math.min( dp[ j ][ k ], dp[ i ][ k ]\n                      + em[ i ][ j ] );\n                  ok[ j ][ k ] = true;\n//                  debug( \"a\", i, j, k, dp[ j ][ k ] );\n                }\n              }\n            }\n          }\n        }\n      }\n\n      int min = 1 << 28;\n      for ( int k = 0; k <= l; ++k ) {\n        min = Math.min( min, dp[ n ][ k ] );\n      }\n\n      System.out.println( min );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tint n, m, l;\n\tList<Integer>[] e;\n\tint[][] dist, ene;\n\n\tclass D implements Comparable<D> {\n\t\tint pos;\n\t\tint rem;\n\t\tint min;\n\n\t\tpublic D(int pos, int rem, int min) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.rem = rem;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min) {\n\t\t\t\treturn this.min - o.min;\n\t\t\t}\n\t\t\tif (this.pos != o.pos) {\n\t\t\t\treturn this.pos - o.pos;\n\t\t\t}\n\t\t\tif (this.rem != o.rem) {\n\t\t\t\treturn this.rem - o.rem;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tint dijkstra() {\n\t\tPriorityQueue<D> queue = new PriorityQueue<D>();\n\t\tqueue.add(new D(0, l, 0));\n\t\tboolean[][] vis = new boolean[n][l + 1];\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD d = queue.poll();\n\t\t\tint pos = d.pos;\n\t\t\tint rem = d.rem;\n\t\t\tint min = d.min;\n\n\t\t\tif (vis[pos][rem]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[pos][rem] = true;\n\n\t\t\tif (pos == n - 1) {\n\t\t\t\treturn min;\n\t\t\t}\n\n\t\t\tfor (Integer to : e[pos]) {\n\t\t\t\tint npos = to;\n\t\t\t\tint nrem = rem;\n\t\t\t\tint nmin = min + ene[pos][npos];\n\t\t\t\tif (!vis[npos][nrem]) {\n\t\t\t\t\tqueue.add(new D(npos, nrem, nmin));\n\t\t\t\t}\n\n\t\t\t\tnrem = rem - dist[pos][npos];\n\t\t\t\tnmin = min;\n\t\t\t\tif (nrem < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!vis[npos][nrem]) {\n\t\t\t\t\tqueue.add(new D(npos, nrem, nmin));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tl = sc.nextInt();\n\t\t\tif ((n | m | l) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = new LinkedList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\te[i] = new LinkedList<Integer>();\n\t\t\t}\n\t\t\tdist = new int[n][n];\n\t\t\tene = new int[n][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint f = sc.nextInt();\n\t\t\t\te[a].add(b);\n\t\t\t\te[b].add(a);\n\t\t\t\tdist[a][b] = dist[b][a] = d;\n\t\t\t\tene[a][b] = ene[b][a] = f;\n\t\t\t}\n\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\t\n\tint inns, roads, money;\n\tint[][] charge, enemy;\n\t\n\tboolean[][] v;\n\t\n\tint dijkstra() {\n\t\tv = new boolean[inns + 1][money + 1];\n\t\t// {from, distance, enemy}\n\t\tQueue<int[]> que = new PriorityQueue<int[]>(1, new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] arg0, int[] arg1) {\n\t\t\t\treturn arg0[2] - arg1[2];\n\t\t\t}\n\t\t});\n\t\tque.offer(new int[]{1, money, 0});\n\t\twhile (!que.isEmpty()) {\n\t\t\tint[] p = que.poll();\n\t\t\tint from = p[0], currentMoney = p[1], attacks = p[2];\n\t\t\t\n\t\t\t// ゴールに到達した場合、それが最小の襲われる人数になっている。\n\t\t\tif (from == inns) {\n\t\t\t\treturn attacks;\n\t\t\t}\n\t\t\t\n\t\t\t// PriorityQueueなので最初に見たものが最小の襲われる人数になっている。だから読み飛ばして良い。\n\t\t\tif (v[from][currentMoney]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv[from][currentMoney] = true;\n\t\t\t\n\t\t\tfor (int to = 1; to <= inns; to++) {\n\t\t\t\tif (charge[from][to] == 0) continue;\n\t\t\t\tif (charge[from][to] <= currentMoney) {\n\t\t\t\t\t// お金が足りたら襲われなくて済むね。しかもこいつは優先順位が高い。\n                    que.offer(new int[]{to, currentMoney - charge[from][to], attacks});\n                }\n                que.offer(new int[]{to, currentMoney, enemy[from][to] + attacks});\t\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint solve() {\n\t\treturn dijkstra();\n\t}\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString output = \"\";\n\t\twhile (sc.hasNext()) {\n\t\t\tinns = sc.nextInt();\n\t\t\troads = sc.nextInt();\n\t\t\tmoney = sc.nextInt();\n\t\t\tif (inns == 0 && roads == 0 && money == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tcharge = new int[inns + 1][inns + 1];\n\t\t\t\tenemy = new int[inns + 1][inns + 1];\n\t\t\t\tfor (int i = 0; i < roads; i++) {\n\t\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\t\tint d = sc.nextInt(), e = sc.nextInt();\n\t\t\t\t\tcharge[a][b] = d;\n\t\t\t\t\tcharge[b][a] = d;\n\t\t\t\t\tenemy[a][b] = e;\n\t\t\t\t\tenemy[b][a] = e;\n\t\t\t\t}\n\t\t\t\toutput += solve() + \"\\n\";\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t\tSystem.out.print(output);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint[] vx = {-1, 0, 1, 0};\n\tint[] vy = {0, -1, 0, 1};\n\t\n\tQueue<Integer> q = new LinkedList<Integer>();\n\tboolean[][][][] vis = new boolean[50][50][50][50];\n\tint getKey(int rx, int ry, int lx, int ly) {\n\t\treturn 1000000 * rx + 10000 * ry + 100 * lx + ly;\n\t}\n\t\n\tboolean inside(int x, int y, int n, int m) {\n\t\treturn 0 <= x && x < m && 0 <= y && y < n;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint m = in.nextInt(), n = in.nextInt();\n\t\t\tif (n == 0 && m == 0) break;\n\t\t\t\n\t\t\tfor (int i = 0; i < 50; i++) for (int j = 0; j < 50; j++) for (int k = 0; k < 50; k++) {\n\t\t\t\tArrays.fill(vis[i][j][k], false);\n\t\t\t}\n\t\t\tq.clear();\n\t\t\tchar[][] rin = new char[n][];\n\t\t\tchar[][] len = new char[n][];\n\t\t\tint rsx = -1, rsy = -1, lsx = -1, lsy = -1;\n\t\t\tint rgx = -1, rgy = -1, lgx = -1, lgy = -1;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlen[i] = in.next().toCharArray();\n\t\t\t\trin[i] = in.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (rin[i][j] == '%') {\n\t\t\t\t\t\trgx = j; rgy = i;\n\t\t\t\t\t} else if (rin[i][j] == 'R') {\n\t\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (len[i][j] == '%') {\n\t\t\t\t\t\tlgx = j; lgy = i;\n\t\t\t\t\t} else if (len[i][j] == 'L') {\n\t\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvis[rsx][rsy][lsx][lsy] = true;\n\t\t\tq.add(getKey(rsx, rsy, lsx, lsy));\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint next = q.poll();\n\t\t\t\tint ly = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint lx = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint ry = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint rx = next % 100;\n\t\t\t\t\t\t\t\t\n\t\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\t\tint nrx = rx + vx[d], nry = ry + vy[d];\n\t\t\t\t\tint nlx = lx - vx[d], nly = ly + vy[d];\n\t\t\t\t\t\n\t\t\t\t\tif (inside(nlx, nly, n, m) && inside(nrx, nry, n, m)) {\n\t\t\t\t\t\tif (rin[nry][nrx] == '#') {\n\t\t\t\t\t\t\tif (len[nly][nlx] == '#') {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnry = ry;\n\t\t\t\t\t\t\t\tnrx = rx;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (len[nly][nlx] == '#') {\n\t\t\t\t\t\t\t\tnly = ly;\n\t\t\t\t\t\t\t\tnlx = lx;\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vis[nrx][nry][nlx][nly]) continue;\n\t\t\t\t\t\tvis[nrx][nry][nlx][nly] = true;\n\t\t\t\t\t\tif (!((nrx == rgx && nry == rgy) || (nlx == lgx && nly == lgy))) {\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tq.add(getKey(nrx, nry, nlx, nly));\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(vis[rgx][rgy][lgx][lgy] ? \"Yes\" : \"No\");\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<26;\n\tfinal double EPS=1.0e-08;\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ2151();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\tvoid AOJ2151(){\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt(),L=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[][] cost=new int[N+1][N+1],robber=new int[N+1][N+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tcost[i][j]=INF;\trobber[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tcost[a][b]=c;\tcost[b][a]=c;\n\t\t\t\trobber[a][b]=d;\trobber[b][a]=d;\n\t\t\t}\n\t\t\tPriorityQueue<C2151> open=new PriorityQueue<C2151>();\n\t\t\topen.add(new C2151(1,L,0));\n\t\t\tint[][] close=new int[N+1][L+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=L; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tclose[1][L]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2151 now=open.poll();\n\t\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\t\tif(now.now==i)\tcontinue;\n\t\t\t\t\tif(cost[now.now][i]>=INF)\tcontinue;\n\t\t\t\t\tif(now.remains>=cost[now.now][i]){\n\t\t\t\t\t\tint re2=now.remains-cost[now.now][i];\n\t\t\t\t\t\tif(close[i][re2]>now.robbers){\n\t\t\t\t\t\t\tif(i==N){\n\t\t\t\t\t\t\t\tans=min(ans,now.robbers);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\topen.add(new C2151(i,re2,now.robbers));\n\t\t\t\t\t\t\t\tclose[i][re2]=now.robbers;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint rob2=now.robbers+robber[i][now.now];\n\t\t\t\t\tif(close[i][now.remains]<=rob2)\tcontinue;\n\t\t\t\t\tif(i==N)\tans=min(ans,rob2);\n\t\t\t\t\telse{\n\t\t\t\t\t\topen.add(new C2151(i,now.remains,rob2));\n\t\t\t\t\t\tclose[i][now.remains]=rob2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tclass C2151 implements Comparable<C2151>{\n\t\tint now,remains,robbers;\n\t\tC2151(int n,int r,int r2){this.now=n; this.remains=r; this.robbers=r2;}\n\t\t@Override public int compareTo(C2151 o) {\n\t\t\tif(this.robbers<o.robbers)\treturn -1;\n\t\t\tif(this.robbers>o.robbers)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ1144(){\n\t\twhile(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint[][] b=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tb[x][y]=sc.nextInt();\n\t\t\t\t\tif(b[x][y]==2){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<C1144> open=new PriorityQueue<C1144>();\n\t\t\tint[] temp=new int[10];\n\t\t\tArrays.fill(temp, -1);\n\t\t\topen.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tTreeSet<C1144> close=new TreeSet<C1144>();\n\t\t\tclose.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1144 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x,yy=now.y;\n\t\t\t\t\tif((0<=xx+vx[i] && xx+vx[i]<W && 0<=yy+vy[i] && yy+vy[i]<H) && b[xx+vx[i]][yy+vy[i]]==1 && !now.stone(xx+vx[i], yy+vy[i]))\tcontinue;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\n\t\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H))\tbreak;\n\t\t\t\t\t\tif(b[xx][yy]==3){\n\t\t\t\t\t\t\tans=min(ans,now.step+1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b[xx][yy]==1 && !now.stone(xx, yy)){\n\t\t\t\t\t\t\tif(now.step==9)\tbreak;\n\t\t\t\t\t\t\tint[] tx=now.x2.clone(),ty=now.y2.clone();\n\t\t\t\t\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\t\t\t\t\tif(tx[j]<0 && ty[j]<0){\n\t\t\t\t\t\t\t\t\ttx[j]=xx;\tty[j]=yy;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\txx-=vx[i];\tyy-=vy[i];\n\t\t\t\t\t\t\tC1144 next=new C1144(xx,yy,now.step+1,tx,ty);\n\t\t\t\t\t\t\tif(close.contains(next))\tbreak;\n\t\t\t\t\t\t\topen.add(next);\n\t\t\t\t\t\t\tclose.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?\"-1\":ans));\n\t\t}\n\t}\n\tclass C1144 implements Comparable<C1144>{\n\t\tint x,y,step;\n\t\tint[] x2,y2;\n\t\tC1144(int x,int y,int step,int[] x2,int[] y2){this.x=x; this.y=y; this.step=step; this.x2=x2; this.y2=y2;}\n\t\t@Override public int compareTo(C1144 o) {\n\t\t\tif(this.step<o.step)\treturn -1;\n\t\t\tif(this.step>o.step)\treturn 1;\n\t\t\tif(Arrays.equals(this.x2, o.x2) && Arrays.equals(this.y2, o.y2))\treturn 0;\n\t\t\treturn -1;\n\t\t}\n\t\tboolean stone(int x,int y){\n\t\t\tfor(int i=0; i<10; i++){\n\t\t\t\tif(x2[i]<0 && y2[i]<0)\treturn false;\n\t\t\t\tif(x2[i]==x && y2[i]==y)\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t// TLE ゲノム\n\tvoid AOJ1145(){\n\t\twhile(true){\n\t\t\tStringBuilder line=new StringBuilder(sc.next());\n\t\t\tint n=sc.nextInt();\n\t\t\tif(line.toString().equals(\"0\"))\tbreak;\n\t\t\tchar last=line.charAt(0);\n\t\t\tfor(int i=1; i<line.length(); i++){\n\t\t\t\tif(Character.isDigit(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '*');\n\t\t\t\t\telse if(line.charAt(i)=='(')\tline.insert(i++, '*');\n\t\t\t\t}else if(Character.isUpperCase(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t\telse if(Character.isDigit(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t}else if(last==')' && line.charAt(i)!=')')\tline.insert(i++, '+');\n\t\t\t\tlast=line.charAt(i);\n\t\t\t}\n\t\t\tline.append(\"#\");\n\t\t\tSystem.out.println(\"L: \"+line);\n\t\t\tSystem.out.println(new parsed1145(line.toString(), n).toString());\n\t\t}\n\t}\n\tclass parsed1145{\n\t\tString line,ans=\"\",ans2;\n\t\tint pos=0,n;\n\t\tpublic parsed1145(String line, int n) { this.line=line; this.n=n; ans2=expr();}\n\t\tprivate String expr(){\n\t\t\tif(n<0)\treturn \"\";\n\t\t\tString res=term();\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='+'){\n\t\t\t\t\tpos++;\n\t\t\t\t\tres+=term();\n\t\t\t\t}else\tbreak;\n\t\t\t}\n//\t\t\tSystem.out.println(\"E: \"+res+\" N\"+n);\n//\t\t\tif(res.length()<=n){\n//\t\t\t\tn-=res.length();\n//\t\t\t\tres=\"\";\n//\t\t\t}else{\n//\t\t\t\ttry{\n//\t\t\t\t\tans=\"\"+res.charAt(n);\n//\t\t\t\t}catch(Exception e){}\n//\t\t\t\tres=\"\";\n//\t\t\t\tn=-1;\n//\t\t\t\tpos=line.length()-1;\n//\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String term(){\n\t\t\tif(n<0)\treturn \"\";\n\t\t\tString res=fact();\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='*'){\n\t\t\t\t\tint t=Integer.parseInt(res);\n\t\t\t\t\tpos++;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\t\t\twhile(--t>=0)\tsb.append(res);\n\t\t\t\t\tres=sb.toString();\n//\t\t\t\t\tSystem.out.println(\"T: \"+res+\" N\"+n);\n//\t\t\t\t\tif(res.length()<=n){\n//\t\t\t\t\t\tn-=res.length();\n//\t\t\t\t\t\tres=\"\";\n//\t\t\t\t\t}else{\n//\t\t\t\t\t\ttry{\n//\t\t\t\t\t\t\tans=\"\"+res.charAt(n);\n//\t\t\t\t\t\t\tSystem.out.println(\"* \"+res+\" N\"+n);\n//\t\t\t\t\t\t}catch(Exception e){}\n//\t\t\t\t\t\tres=\"\";\n//\t\t\t\t\t\tn=-1;\n//\t\t\t\t\t\tpos=line.length()-1;\n//\t\t\t\t\t}\n\t\t\t\t}else\tbreak;\n\t\t\t}\n//\t\t\tSystem.out.println(\"T: \"+res+\" N\"+n);\n//\t\t\tif(res.length()<=n){\n//\t\t\t\tn-=res.length();\n//\t\t\t\tres=\"\";\n//\t\t\t}else{\n//\t\t\t\ttry{\n//\t\t\t\t\tans=\"\"+res.charAt(n);\n//\t\t\t\t\tSystem.out.println(\"* \"+res+\" N\"+n);\n//\t\t\t\t}catch(Exception e){}\n//\t\t\t\tres=\"\";\n//\t\t\t\tn=-1;\n//\t\t\t\tpos=line.length()-1;\n//\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String fact(){\n\t\t\tif(n<0)\treturn \"\";\n\t\t\tif(Character.isDigit(line.charAt(pos))){\n\t\t\t\tString t=\"\"+(line.charAt(pos)-'0');\n\t\t\t\tpos++;\n\t\t\t\twhile(Character.isDigit(line.charAt(pos))){\n\t\t\t\t\tt+=(line.charAt(pos)-'0');\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\treturn t;\n\t\t\t}else if(line.charAt(pos)=='('){\n\t\t\t\tpos++;\n\t\t\t\tString res=expr();\n\t\t\t\tpos++;\n\t\t\t\t//System.out.println(res+\" N\"+n);\n//\t\t\t\tif(res.length()<=n){\n//\t\t\t\t\tn-=res.length();\n//\t\t\t\t}else{\n//\t\t\t\t\ttry{\n//\t\t\t\t\t\tans=\"\"+res.charAt(n);\n//\t\t\t\t\t}catch(Exception e){}\n//\t\t\t\t\tres=\"\";\n//\t\t\t\t\tn=-1;\n//\t\t\t\t\tpos=line.length()-1;\n//\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}else if(Character.isUpperCase(line.charAt(pos))){\n\t\t\t\treturn \"\"+line.charAt(pos++);\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\t\t@Override public String toString() {\treturn ans.length()==0?\"0\":ans;}\n\t}\n\t\n\tvoid AOJ1165(){\n\t\tfinal int[] vx2={-1,0,1,0}, vy2={0,-1,0,1};\n\t\twhile(true){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=1; i<N; i++){\n\t\t\t\tint n=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tx[i]=x[n]+vx2[d];\ty[i]=y[n]+vy2[d];\n\t\t\t}\n\t\t\tArrays.sort(x);\tArrays.sort(y);\n\t\t\tSystem.out.println((x[N-1]-x[0]+1)+\" \"+(y[N-1]-y[0]+1));\n\t\t}\n\t}\n\t\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\tpublic static Random rand=new Random();\n\n\n\tstatic final int INF =1<<30;\n\n\tstatic class Node{\n\t\tint id;\n\t\tList<Edge> link=new LinkedList<Edge>();\n\t\tNode(int _id){\n\t\t\tid=_id;\n\t\t}\n\t}\n\tstatic class Edge{\n\t\tint from,to,cost;\n\t\tEdge(int _from,int _to,int _cost){\n\t\t\tfrom=_from;to=_to;cost=_cost;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn from+\"->\"+to;\n\t\t}\n\t}\n\tstatic class Task implements Comparable<Task>{\n\t\tint prev,pos,cost;\n\t\tTask(int _prev,int _pos,int _cost){\n\t\t\tprev=_prev;pos=_pos;cost=_cost;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Task T) {\n\t\t\treturn cost-T.cost;\n\t\t}\n\t}\n\tpublic static int[] dijkstra(Node[] graph,int s,int[] prev){\n\t\tfinal int V=graph.length;\n\t\tint[] d=new int[V];Arrays.fill(d,INF);d[s]=0;\n\t\tArrays.fill(prev,-2);\n\t\tPriorityQueue<Task> que=new PriorityQueue<Task>();\n\t\tque.add(new Task(-1,s,0));\n\t\twhile(!que.isEmpty()){\n\t\t\tTask task=que.poll();\n\t\t\tif(prev[task.pos]!=-2)continue;\n\t\t\t//if(d[task.pos]<task.cost)continue;\n\t\t\tprev[task.pos]=task.prev;\n\t\t\tfor(Edge e:graph[task.pos].link){\n\t\t\t\tif(d[e.to]>d[e.from]+e.cost){\n\t\t\t\t\td[e.to]=d[e.from]+e.cost;\n\t\t\t\t\tque.add(new Task(e.from,e.to,d[e.to]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tpublic int enc(int v,int l){\n\t\treturn (L+1)*v+l;\n\t}\n\tpublic int decL(int id){\n\t\treturn id%(L+1);\n\t}\n\tpublic int decV(int id){\n\t\treturn id/(L+1);\n\t}\n\tint N,M,L;\n\tpublic void run() {\n\n\t\tTCase:while(true){\n\t\t\tN=sc.nextInt();M=sc.nextInt();L=sc.nextInt();\n\t\t\tif(N==0)return;\n\t\t\tNode[] graph=new Node[N*(L+1)];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<=L;j++)\n\t\t\t\tgraph[enc(i,j)]=new Node(enc(i,j));\n\n\t\t\t//edge\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tint f=sc.nextInt()-1,t=sc.nextInt()-1;\n\t\t\t\tint d=sc.nextInt(),c=sc.nextInt();\n\t\t\t\tfor(int l=0;l<=L;l++)if(l-d>=0){\n\t\t\t\t\tgraph[enc(f,l)].link.add(new Edge(enc(f,l),enc(t,l-d),0));\n\t\t\t\t\tgraph[enc(t,l)].link.add(new Edge(enc(t,l),enc(f,l-d),0));\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<=L;l++){\n\t\t\t\t\tgraph[enc(f,l)].link.add(new Edge(enc(f,l),enc(t,l),c));\n\t\t\t\t\tgraph[enc(t,l)].link.add(new Edge(enc(t,l),enc(f,l),c));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] prev=new int[N*(L+1)];\n\t\t\tint[] d=dijkstra(graph,enc(0,L),prev);\n\n\t\t\tint mv=INF;\n\t\t\tfor(int l=0;l<=L;l++)\n\t\t\t\tmv=min(mv,d[enc(N-1,l)]);\n\n\t\t\t//ln(strPath(path(prev,enc(N-1,0))));\n\t\t\tln(mv);\n\t\t}\n\t}\n\n\tpublic String strPath(List<Integer> path){\n\t\tString res=\"\";\n\t\tfor(Integer v:path){\n\t\t\tres+=\"(\"+decV(v)+\",\"+decL(v)+\")--\";\n\t\t}\n\t\treturn res;\n\t}\n\t//パスの出力\n\tpublic static List<Integer> path(int[] prev,int e){\n\t\tList<Integer> path=new ArrayList<Integer>();\n\t\tfor (int u = e; u >= 0; u = prev[u])\n\t\t\tpath.add(u);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n      \n      \npublic class Main {\t\n\tstatic char[] tank = new char[] {'^','>','v','<'};\n\tstatic int[] vx = new int[] {0,1,0,-1};\n\tstatic int[] vy = new int[] {-1,0,1,0};\n\tstatic final int INF = 2 << 28;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tint L = sc.nextInt();\n\t\t\tif(N == 0 && M == 0 && L == 0) break;\n\t\t\tint[] A = new int[M];\n\t\t\tint[] B = new int[M];\n\t\t\tint[] D = new int[M];\n\t\t\tint[] E = new int[M];\n\t\t\tNode[] node = new Node[N];\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tnode[i] = new Node(i+1);\n\t\t\t}\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tA[i] = sc.nextInt();\n\t\t\t\tB[i] = sc.nextInt();\n\t\t\t\tD[i] = sc.nextInt();\n\t\t\t\tE[i] = sc.nextInt();\n\t\t\t\tnode[A[i]-1].to.add(new Edge(node[B[i]-1],D[i],E[i]));\n\t\t\t\tnode[B[i]-1].to.add(new Edge(node[A[i]-1],D[i],E[i]));\n\t\t\t}\n\t\t\tint[][] dp = new int[N][L+1];\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tPriorityQueue<Data> queue = new PriorityQueue<Data>();\n\t\t\tqueue.add(new Data(node[0],0,L));\n\t\t\tint MIN = INF;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tData tmp = queue.poll();\n\t\t\t\tNode now = tmp.now;\n\t\t\t\tif(dp[now.id-1][tmp.l] <= tmp.cost) continue;\n\t\t\t\tdp[now.id-1][tmp.l] = tmp.cost;\n\t\t\t\tif(now.id == N) {\n\t\t\t\t\tMIN = Math.min(MIN, tmp.cost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < now.to.size(); i++) {\n\t\t\t\t\tEdge next = now.to.get(i);\n\t\t\t\t\tqueue.add(new Data(next.to,tmp.cost + next.e,tmp.l));\n\t\t\t\t\tif(tmp.l - next.d >= 0) {\n\t\t\t\t\t\tqueue.add(new Data(next.to,tmp.cost,tmp.l - next.d));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(MIN);\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tNode now;\n\t\tint cost;\n\t\tint l;\n\t\tData(Node a, int b, int c) {\n\t\t\tnow = a;\n\t\t\tcost = b;\n\t\t\tl = c;\n\t\t}\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t}\n\t\n\tstatic class Node {\n\t\tint id;\n\t\tArrayList<Edge> to = new ArrayList<Edge>();\n\t\tNode(int a) {\n\t\t\tid = a;\n\t\t}\n\t}\n\tstatic class Edge {\n\t\tNode to;\n\t\tint  d;\n\t\tint  e;\n\t\tEdge(Node a,int b, int c) {\n\t\t\tto = a;\n\t\t\td = b;\n\t\t\te = c;\n\t\t}\n\t}\n\t\n }"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tint n, m, l;\n\tList<Integer>[] e;\n\tint[][] dist, ene;\n\n\tclass D implements Comparable<D> {\n\t\tint pos;\n\t\tint rem;\n\t\tint min;\n\n\t\tpublic D(int pos, int rem, int min) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.rem = rem;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min) {\n\t\t\t\treturn this.min - o.min;\n\t\t\t}\n\t\t\tif (this.pos != o.pos) {\n\t\t\t\treturn this.pos - o.pos;\n\t\t\t}\n\t\t\tif (this.rem != o.rem) {\n\t\t\t\treturn this.rem - o.rem;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tint dijkstra() {\n\t\tPriorityQueue<D> queue = new PriorityQueue<D>();\n\t\tqueue.add(new D(0, l, 0));\n\t\tboolean[][] vis = new boolean[n][l + 1];\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD d = queue.poll();\n\t\t\tint pos = d.pos;\n\t\t\tint rem = d.rem;\n\t\t\tint min = d.min;\n\n\t\t\tif (vis[pos][rem]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[pos][rem] = true;\n\n\t\t\tif (pos == n - 1) {\n\t\t\t\treturn min;\n\t\t\t}\n\n\t\t\tfor (Integer to : e[pos]) {\n\t\t\t\tint npos = to;\n\t\t\t\tint nrem = rem;\n\t\t\t\tint nmin = min + ene[pos][npos];\n\t\t\t\tif (!vis[npos][nrem]) {\n\t\t\t\t\tqueue.add(new D(npos, nrem, nmin));\n\t\t\t\t}\n\n\t\t\t\tnrem = rem - dist[pos][npos];\n\t\t\t\tnmin = min;\n\t\t\t\tif (nrem < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!vis[npos][nrem]) {\n\t\t\t\t\tqueue.add(new D(npos, nrem, nmin));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tl = sc.nextInt();\n\t\t\tif ((n | m | l) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = new LinkedList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\te[i] = new LinkedList<Integer>();\n\t\t\t}\n\t\t\tdist = new int[n][n];\n\t\t\tene = new int[n][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint f = sc.nextInt();\n\t\t\t\te[a].add(b);\n\t\t\t\te[b].add(a);\n\t\t\t\tdist[a][b] = dist[b][a] = d;\n\t\t\t\tene[a][b] = ene[b][a] = f;\n\t\t\t}\n\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<26;\n\tfinal double EPS=1.0e-08;\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ2151();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\tvoid AOJ2151(){\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt(),L=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[][] cost=new int[N+1][N+1],robber=new int[N+1][N+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tcost[i][j]=INF;\trobber[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tcost[a][b]=c;\tcost[b][a]=c;\n\t\t\t\trobber[a][b]=d;\trobber[b][a]=d;\n\t\t\t}\n\t\t\tPriorityQueue<C2151> open=new PriorityQueue<C2151>();\n\t\t\topen.add(new C2151(1,L,0));\n\t\t\tint[][] close=new int[N+1][L+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=L; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tclose[1][L]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2151 now=open.poll();\n\t\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\t\tif(now.now==i)\tcontinue;\n\t\t\t\t\tif(cost[now.now][i]>=INF)\tcontinue;\n\t\t\t\t\tif(now.remains>=cost[now.now][i]){\n\t\t\t\t\t\tint re2=now.remains-cost[now.now][i];\n\t\t\t\t\t\tif(close[i][re2]>now.robbers){\n\t\t\t\t\t\t\tif(i==N){\n\t\t\t\t\t\t\t\tans=min(ans,now.robbers);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\topen.add(new C2151(i,re2,now.robbers));\n\t\t\t\t\t\t\t\tclose[i][re2]=now.robbers;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint rob2=now.robbers+robber[i][now.now];\n\t\t\t\t\tif(close[i][now.remains]<=rob2)\tcontinue;\n\t\t\t\t\tif(i==N)\tans=min(ans,rob2);\n\t\t\t\t\telse{\n\t\t\t\t\t\topen.add(new C2151(i,now.remains,rob2));\n\t\t\t\t\t\tclose[i][now.remains]=rob2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tclass C2151 implements Comparable<C2151>{\n\t\tint now,remains,robbers;\n\t\tC2151(int n,int r,int r2){this.now=n; this.remains=r; this.robbers=r2;}\n\t\t@Override public int compareTo(C2151 o) {\n\t\t\tif(this.robbers<o.robbers)\treturn -1;\n\t\t\tif(this.robbers>o.robbers)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ1144(){\n\t\twhile(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint[][] b=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tb[x][y]=sc.nextInt();\n\t\t\t\t\tif(b[x][y]==2){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<C1144> open=new PriorityQueue<C1144>();\n\t\t\tint[] temp=new int[10];\n\t\t\tArrays.fill(temp, -1);\n\t\t\topen.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tTreeSet<C1144> close=new TreeSet<C1144>();\n\t\t\tclose.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1144 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x,yy=now.y;\n\t\t\t\t\tif((0<=xx+vx[i] && xx+vx[i]<W && 0<=yy+vy[i] && yy+vy[i]<H) && b[xx+vx[i]][yy+vy[i]]==1 && !now.stone(xx+vx[i], yy+vy[i]))\tcontinue;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\n\t\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H))\tbreak;\n\t\t\t\t\t\tif(b[xx][yy]==3){\n\t\t\t\t\t\t\tans=min(ans,now.step+1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b[xx][yy]==1 && !now.stone(xx, yy)){\n\t\t\t\t\t\t\tif(now.step==9)\tbreak;\n\t\t\t\t\t\t\tint[] tx=now.x2.clone(),ty=now.y2.clone();\n\t\t\t\t\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\t\t\t\t\tif(tx[j]<0 && ty[j]<0){\n\t\t\t\t\t\t\t\t\ttx[j]=xx;\tty[j]=yy;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\txx-=vx[i];\tyy-=vy[i];\n\t\t\t\t\t\t\tC1144 next=new C1144(xx,yy,now.step+1,tx,ty);\n\t\t\t\t\t\t\tif(close.contains(next))\tbreak;\n\t\t\t\t\t\t\topen.add(next);\n\t\t\t\t\t\t\tclose.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?\"-1\":ans));\n\t\t}\n\t}\n\tclass C1144 implements Comparable<C1144>{\n\t\tint x,y,step;\n\t\tint[] x2,y2;\n\t\tC1144(int x,int y,int step,int[] x2,int[] y2){this.x=x; this.y=y; this.step=step; this.x2=x2; this.y2=y2;}\n\t\t@Override public int compareTo(C1144 o) {\n\t\t\tif(this.step<o.step)\treturn -1;\n\t\t\tif(this.step>o.step)\treturn 1;\n\t\t\tif(Arrays.equals(this.x2, o.x2) && Arrays.equals(this.y2, o.y2))\treturn 0;\n\t\t\treturn -1;\n\t\t}\n\t\tboolean stone(int x,int y){\n\t\t\tfor(int i=0; i<10; i++){\n\t\t\t\tif(x2[i]<0 && y2[i]<0)\treturn false;\n\t\t\t\tif(x2[i]==x && y2[i]==y)\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t// TLE ゲノム\n\tvoid AOJ1145(){\n\t\twhile(true){\n\t\t\tStringBuilder line=new StringBuilder(sc.next());\n\t\t\tint n=sc.nextInt();\n\t\t\tif(line.toString().equals(\"0\"))\tbreak;\n\t\t\tchar last=line.charAt(0);\n\t\t\tfor(int i=1; i<line.length(); i++){\n\t\t\t\tif(Character.isDigit(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '*');\n\t\t\t\t\telse if(line.charAt(i)=='(')\tline.insert(i++, '*');\n\t\t\t\t}else if(Character.isUpperCase(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t\telse if(Character.isDigit(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t}else if(last==')' && line.charAt(i)!=')')\tline.insert(i++, '+');\n\t\t\t\tlast=line.charAt(i);\n\t\t\t}\n\t\t\tline.append(\"#\");\n\t\t\tSystem.out.println(\"L: \"+line);\n\t\t\tSystem.out.println(new parsed1145(line.toString(), n).toString());\n\t\t}\n\t}\n\tclass parsed1145{\n\t\tString line,ans=\"\",ans2;\n\t\tint pos=0,n;\n\t\tpublic parsed1145(String line, int n) { this.line=line; this.n=n; ans2=expr();}\n\t\tprivate String expr(){\n\t\t\tif(n<0)\treturn \"\";\n\t\t\tString res=term();\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='+'){\n\t\t\t\t\tpos++;\n\t\t\t\t\tres+=term();\n\t\t\t\t}else\tbreak;\n\t\t\t}\n//\t\t\tSystem.out.println(\"E: \"+res+\" N\"+n);\n//\t\t\tif(res.length()<=n){\n//\t\t\t\tn-=res.length();\n//\t\t\t\tres=\"\";\n//\t\t\t}else{\n//\t\t\t\ttry{\n//\t\t\t\t\tans=\"\"+res.charAt(n);\n//\t\t\t\t}catch(Exception e){}\n//\t\t\t\tres=\"\";\n//\t\t\t\tn=-1;\n//\t\t\t\tpos=line.length()-1;\n//\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String term(){\n\t\t\tif(n<0)\treturn \"\";\n\t\t\tString res=fact();\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='*'){\n\t\t\t\t\tint t=Integer.parseInt(res);\n\t\t\t\t\tpos++;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\t\t\twhile(--t>=0)\tsb.append(res);\n\t\t\t\t\tres=sb.toString();\n//\t\t\t\t\tSystem.out.println(\"T: \"+res+\" N\"+n);\n//\t\t\t\t\tif(res.length()<=n){\n//\t\t\t\t\t\tn-=res.length();\n//\t\t\t\t\t\tres=\"\";\n//\t\t\t\t\t}else{\n//\t\t\t\t\t\ttry{\n//\t\t\t\t\t\t\tans=\"\"+res.charAt(n);\n//\t\t\t\t\t\t\tSystem.out.println(\"* \"+res+\" N\"+n);\n//\t\t\t\t\t\t}catch(Exception e){}\n//\t\t\t\t\t\tres=\"\";\n//\t\t\t\t\t\tn=-1;\n//\t\t\t\t\t\tpos=line.length()-1;\n//\t\t\t\t\t}\n\t\t\t\t}else\tbreak;\n\t\t\t}\n//\t\t\tSystem.out.println(\"T: \"+res+\" N\"+n);\n//\t\t\tif(res.length()<=n){\n//\t\t\t\tn-=res.length();\n//\t\t\t\tres=\"\";\n//\t\t\t}else{\n//\t\t\t\ttry{\n//\t\t\t\t\tans=\"\"+res.charAt(n);\n//\t\t\t\t\tSystem.out.println(\"* \"+res+\" N\"+n);\n//\t\t\t\t}catch(Exception e){}\n//\t\t\t\tres=\"\";\n//\t\t\t\tn=-1;\n//\t\t\t\tpos=line.length()-1;\n//\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String fact(){\n\t\t\tif(n<0)\treturn \"\";\n\t\t\tif(Character.isDigit(line.charAt(pos))){\n\t\t\t\tString t=\"\"+(line.charAt(pos)-'0');\n\t\t\t\tpos++;\n\t\t\t\twhile(Character.isDigit(line.charAt(pos))){\n\t\t\t\t\tt+=(line.charAt(pos)-'0');\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\treturn t;\n\t\t\t}else if(line.charAt(pos)=='('){\n\t\t\t\tpos++;\n\t\t\t\tString res=expr();\n\t\t\t\tpos++;\n\t\t\t\t//System.out.println(res+\" N\"+n);\n//\t\t\t\tif(res.length()<=n){\n//\t\t\t\t\tn-=res.length();\n//\t\t\t\t}else{\n//\t\t\t\t\ttry{\n//\t\t\t\t\t\tans=\"\"+res.charAt(n);\n//\t\t\t\t\t}catch(Exception e){}\n//\t\t\t\t\tres=\"\";\n//\t\t\t\t\tn=-1;\n//\t\t\t\t\tpos=line.length()-1;\n//\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}else if(Character.isUpperCase(line.charAt(pos))){\n\t\t\t\treturn \"\"+line.charAt(pos++);\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\t\t@Override public String toString() {\treturn ans.length()==0?\"0\":ans;}\n\t}\n\t\n\tvoid AOJ1165(){\n\t\tfinal int[] vx2={-1,0,1,0}, vy2={0,-1,0,1};\n\t\twhile(true){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=1; i<N; i++){\n\t\t\t\tint n=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tx[i]=x[n]+vx2[d];\ty[i]=y[n]+vy2[d];\n\t\t\t}\n\t\t\tArrays.sort(x);\tArrays.sort(y);\n\t\t\tSystem.out.println((x[N-1]-x[0]+1)+\" \"+(y[N-1]-y[0]+1));\n\t\t}\n\t}\n\t\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n}import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<26;\n\tfinal double EPS=1.0e-08;\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ2151();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\tvoid AOJ2151(){\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt(),L=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[][] cost=new int[N+1][N+1],robber=new int[N+1][N+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tcost[i][j]=INF;\trobber[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tcost[a][b]=c;\tcost[b][a]=c;\n\t\t\t\trobber[a][b]=d;\trobber[b][a]=d;\n\t\t\t}\n\t\t\tPriorityQueue<C2151> open=new PriorityQueue<C2151>();\n\t\t\topen.add(new C2151(1,L,0));\n\t\t\tint[][] close=new int[N+1][L+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=L; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tclose[1][L]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2151 now=open.poll();\n\t\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\t\tif(now.now==i)\tcontinue;\n\t\t\t\t\tif(cost[now.now][i]>=INF)\tcontinue;\n\t\t\t\t\tif(now.remains>=cost[now.now][i]){\n\t\t\t\t\t\tint re2=now.remains-cost[now.now][i];\n\t\t\t\t\t\tif(close[i][re2]>now.robbers){\n\t\t\t\t\t\t\tif(i==N){\n\t\t\t\t\t\t\t\tans=min(ans,now.robbers);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\topen.add(new C2151(i,re2,now.robbers));\n\t\t\t\t\t\t\t\tclose[i][re2]=now.robbers;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint rob2=now.robbers+robber[i][now.now];\n\t\t\t\t\tif(close[i][now.remains]<=rob2)\tcontinue;\n\t\t\t\t\tif(i==N)\tans=min(ans,rob2);\n\t\t\t\t\telse{\n\t\t\t\t\t\topen.add(new C2151(i,now.remains,rob2));\n\t\t\t\t\t\tclose[i][now.remains]=rob2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tclass C2151 implements Comparable<C2151>{\n\t\tint now,remains,robbers;\n\t\tC2151(int n,int r,int r2){this.now=n; this.remains=r; this.robbers=r2;}\n\t\t@Override public int compareTo(C2151 o) {\n\t\t\tif(this.robbers<o.robbers)\treturn -1;\n\t\t\tif(this.robbers>o.robbers)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ1144(){\n\t\twhile(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint[][] b=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tb[x][y]=sc.nextInt();\n\t\t\t\t\tif(b[x][y]==2){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<C1144> open=new PriorityQueue<C1144>();\n\t\t\tint[] temp=new int[10];\n\t\t\tArrays.fill(temp, -1);\n\t\t\topen.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tTreeSet<C1144> close=new TreeSet<C1144>();\n\t\t\tclose.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1144 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x,yy=now.y;\n\t\t\t\t\tif((0<=xx+vx[i] && xx+vx[i]<W && 0<=yy+vy[i] && yy+vy[i]<H) && b[xx+vx[i]][yy+vy[i]]==1 && !now.stone(xx+vx[i], yy+vy[i]))\tcontinue;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\n\t\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H))\tbreak;\n\t\t\t\t\t\tif(b[xx][yy]==3){\n\t\t\t\t\t\t\tans=min(ans,now.step+1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b[xx][yy]==1 && !now.stone(xx, yy)){\n\t\t\t\t\t\t\tif(now.step==9)\tbreak;\n\t\t\t\t\t\t\tint[] tx=now.x2.clone(),ty=now.y2.clone();\n\t\t\t\t\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\t\t\t\t\tif(tx[j]<0 && ty[j]<0){\n\t\t\t\t\t\t\t\t\ttx[j]=xx;\tty[j]=yy;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\txx-=vx[i];\tyy-=vy[i];\n\t\t\t\t\t\t\tC1144 next=new C1144(xx,yy,now.step+1,tx,ty);\n\t\t\t\t\t\t\tif(close.contains(next))\tbreak;\n\t\t\t\t\t\t\topen.add(next);\n\t\t\t\t\t\t\tclose.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?\"-1\":ans));\n\t\t}\n\t}\n\tclass C1144 implements Comparable<C1144>{\n\t\tint x,y,step;\n\t\tint[] x2,y2;\n\t\tC1144(int x,int y,int step,int[] x2,int[] y2){this.x=x; this.y=y; this.step=step; this.x2=x2; this.y2=y2;}\n\t\t@Override public int compareTo(C1144 o) {\n\t\t\tif(this.step<o.step)\treturn -1;\n\t\t\tif(this.step>o.step)\treturn 1;\n\t\t\tif(Arrays.equals(this.x2, o.x2) && Arrays.equals(this.y2, o.y2))\treturn 0;\n\t\t\treturn -1;\n\t\t}\n\t\tboolean stone(int x,int y){\n\t\t\tfor(int i=0; i<10; i++){\n\t\t\t\tif(x2[i]<0 && y2[i]<0)\treturn false;\n\t\t\t\tif(x2[i]==x && y2[i]==y)\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t// TLE ゲノム\n\tvoid AOJ1145(){\n\t\twhile(true){\n\t\t\tStringBuilder line=new StringBuilder(sc.next());\n\t\t\tint n=sc.nextInt();\n\t\t\tif(line.toString().equals(\"0\"))\tbreak;\n\t\t\tchar last=line.charAt(0);\n\t\t\tfor(int i=1; i<line.length(); i++){\n\t\t\t\tif(Character.isDigit(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '*');\n\t\t\t\t\telse if(line.charAt(i)=='(')\tline.insert(i++, '*');\n\t\t\t\t}else if(Character.isUpperCase(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t\telse if(Character.isDigit(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t}else if(last==')' && line.charAt(i)!=')')\tline.insert(i++, '+');\n\t\t\t\tlast=line.charAt(i);\n\t\t\t}\n\t\t\tline.append(\"#\");\n\t\t\tSystem.out.println(\"L: \"+line);\n\t\t\tSystem.out.println(new parsed1145(line.toString(), n).toString());\n\t\t}\n\t}\n\tclass parsed1145{\n\t\tString line,ans=\"\",ans2;\n\t\tint pos=0,n;\n\t\tpublic parsed1145(String line, int n) { this.line=line; this.n=n; ans2=expr();}\n\t\tprivate String expr(){\n\t\t\tif(n<0)\treturn \"\";\n\t\t\tString res=term();\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='+'){\n\t\t\t\t\tpos++;\n\t\t\t\t\tres+=term();\n\t\t\t\t}else\tbreak;\n\t\t\t}\n//\t\t\tSystem.out.println(\"E: \"+res+\" N\"+n);\n//\t\t\tif(res.length()<=n){\n//\t\t\t\tn-=res.length();\n//\t\t\t\tres=\"\";\n//\t\t\t}else{\n//\t\t\t\ttry{\n//\t\t\t\t\tans=\"\"+res.charAt(n);\n//\t\t\t\t}catch(Exception e){}\n//\t\t\t\tres=\"\";\n//\t\t\t\tn=-1;\n//\t\t\t\tpos=line.length()-1;\n//\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String term(){\n\t\t\tif(n<0)\treturn \"\";\n\t\t\tString res=fact();\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='*'){\n\t\t\t\t\tint t=Integer.parseInt(res);\n\t\t\t\t\tpos++;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\t\t\twhile(--t>=0)\tsb.append(res);\n\t\t\t\t\tres=sb.toString();\n//\t\t\t\t\tSystem.out.println(\"T: \"+res+\" N\"+n);\n//\t\t\t\t\tif(res.length()<=n){\n//\t\t\t\t\t\tn-=res.length();\n//\t\t\t\t\t\tres=\"\";\n//\t\t\t\t\t}else{\n//\t\t\t\t\t\ttry{\n//\t\t\t\t\t\t\tans=\"\"+res.charAt(n);\n//\t\t\t\t\t\t\tSystem.out.println(\"* \"+res+\" N\"+n);\n//\t\t\t\t\t\t}catch(Exception e){}\n//\t\t\t\t\t\tres=\"\";\n//\t\t\t\t\t\tn=-1;\n//\t\t\t\t\t\tpos=line.length()-1;\n//\t\t\t\t\t}\n\t\t\t\t}else\tbreak;\n\t\t\t}\n//\t\t\tSystem.out.println(\"T: \"+res+\" N\"+n);\n//\t\t\tif(res.length()<=n){\n//\t\t\t\tn-=res.length();\n//\t\t\t\tres=\"\";\n//\t\t\t}else{\n//\t\t\t\ttry{\n//\t\t\t\t\tans=\"\"+res.charAt(n);\n//\t\t\t\t\tSystem.out.println(\"* \"+res+\" N\"+n);\n//\t\t\t\t}catch(Exception e){}\n//\t\t\t\tres=\"\";\n//\t\t\t\tn=-1;\n//\t\t\t\tpos=line.length()-1;\n//\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String fact(){\n\t\t\tif(n<0)\treturn \"\";\n\t\t\tif(Character.isDigit(line.charAt(pos))){\n\t\t\t\tString t=\"\"+(line.charAt(pos)-'0');\n\t\t\t\tpos++;\n\t\t\t\twhile(Character.isDigit(line.charAt(pos))){\n\t\t\t\t\tt+=(line.charAt(pos)-'0');\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\treturn t;\n\t\t\t}else if(line.charAt(pos)=='('){\n\t\t\t\tpos++;\n\t\t\t\tString res=expr();\n\t\t\t\tpos++;\n\t\t\t\t//System.out.println(res+\" N\"+n);\n//\t\t\t\tif(res.length()<=n){\n//\t\t\t\t\tn-=res.length();\n//\t\t\t\t}else{\n//\t\t\t\t\ttry{\n//\t\t\t\t\t\tans=\"\"+res.charAt(n);\n//\t\t\t\t\t}catch(Exception e){}\n//\t\t\t\t\tres=\"\";\n//\t\t\t\t\tn=-1;\n//\t\t\t\t\tpos=line.length()-1;\n//\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}else if(Character.isUpperCase(line.charAt(pos))){\n\t\t\t\treturn \"\"+line.charAt(pos++);\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\t\t@Override public String toString() {\treturn ans.length()==0?\"0\":ans;}\n\t}\n\t\n\tvoid AOJ1165(){\n\t\tfinal int[] vx2={-1,0,1,0}, vy2={0,-1,0,1};\n\t\twhile(true){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=1; i<N; i++){\n\t\t\t\tint n=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tx[i]=x[n]+vx2[d];\ty[i]=y[n]+vy2[d];\n\t\t\t}\n\t\t\tArrays.sort(x);\tArrays.sort(y);\n\t\t\tSystem.out.println((x[N-1]-x[0]+1)+\" \"+(y[N-1]-y[0]+1));\n\t\t}\n\t}\n\t\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n \nclass Main{\n \n    private static int[][] used;\n    private static int N,M,L;\n    private static List<Pox>[] list;\n    private static final int INF = 100000000;\n \n    private static class Pox{\n    public int B,D,E;\n    Pox(){\n        B = D = E = 0;\n    }\n \n    Pox(int b,int d,int e){\n        B = b;\n        D = d;\n        E = e;\n    }\n    }\n \n    private static class Eleac implements Comparable<Eleac>{\n    public int id,L,num;\n \n    Eleac(){\n        id = L = num = 0;\n    }\n \n    Eleac(int a,int b,int c){\n        id = a;\n        L = b;\n        num = c;\n    }\n \n    @Override\n    public int compareTo(Eleac a){\n        return 1;\n    }\n \n    }\n \n     @SuppressWarnings(\"unchecked\")\n      public static void main(String args[])throws IOException{\n      BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n       \n      while(true)\n          {\n          String[] elements = in.readLine().split(\" \");\n          N = Integer.parseInt(elements[0]);\n          M = Integer.parseInt(elements[1]);\n          L = Integer.parseInt(elements[2]);\n          if(N == 0 && M == 0 && L == 0)\n              break;\n \n           \n \n          used = new int[N+1][L+1];\n          list = new ArrayList[N+2];\n \n          for(int i=0;i<N+1;i++)\n              for(int j=0;j<L+1;j++)\n              used[i][j] = INF;\n \n          for(int i=0;i<N+1;i++)\n              list[i] = new ArrayList<Pox>();\n           \n          for(int i=0;i<M;i++)\n              {\n             elements = in.readLine().split(\" \");\n             int A,B,D,E;\n              A = Integer.parseInt(elements[0]);\n              B = Integer.parseInt(elements[1]);\n              D = Integer.parseInt(elements[2]);\n              E = Integer.parseInt(elements[3]);\n \n              list[A].add(new Pox(B,D,E));  \n              list[B].add(new Pox(A,D,E));\n              }\n \n          Queue<Eleac> que = new PriorityQueue<Eleac>();\n \n          que.offer(new Eleac(1,L,0)); //Eleac(id,money,the number of eemy)\n          used[1][L] = 0;       \n \n          int men = INF;\n          while(que.size() > 0)\n              {\n              Eleac p = que.poll(); \n              int now = p.id;\n              int money = p.L;\n              int val = p.num;\n               \n              if(now == N)\n                  {\n                  used[now][money] = Math.min(used[now][money],val);    \n                  continue;\n                  }\n               \n              \n              for(int i=0;i<list[now].size();i++)\n                  {\n                  int need = list[now].get(i).D;\n \n                  int new_pos = list[now].get(i).B;\n                  int the_number = list[now].get(i).E;\n                   \n                  if(money-need >= 0 && used[new_pos][money-need] > val)\n                      {\n                      used[new_pos][money-need] = val;\n                      que.add(new Eleac(new_pos,money-need,val));\n                      }                 \n                  if(used[new_pos][money] > val+the_number)\n                      {\n                      used[new_pos][money] = val+the_number;\n                      que.add(new Eleac(new_pos,money,val+the_number));\n                      }\n \n                  }\n \n               \n              }\n \n          for(int i=0;i<=L;i++)\n              {\n              men = Math.min(men,used[N][i]);\n              }\n          System.out.println(men);\n          }\n      }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n/**\n * Problem C: Brave Princess Revisited\n */\npublic class Main {\n\n\tstatic final int INF = 1 << 29;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (sc.hasNext()) {\n\n\t\t\tint N, M, L;\n\t\t\tN = sc.nextInt();\n\t\t\tM = sc.nextInt();\n\t\t\tL = sc.nextInt();\n\t\t\tif ((N | M | L) == 0) break;\n\n\t\t\tMap<Integer, List<Edge>> G = new HashMap<>();\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint A, B, D, E;\n\t\t\t\tA = sc.nextInt();\n\t\t\t\tB = sc.nextInt();\n\t\t\t\tD = sc.nextInt();\n\t\t\t\tE = sc.nextInt();\n\t\t\t\tG.putIfAbsent(A, new ArrayList<>());\n\t\t\t\tG.putIfAbsent(B, new ArrayList<>());\n\t\t\t\tG.get(A).add(new Edge(B, D, E));\n\t\t\t\tG.get(B).add(new Edge(A, D, E));\n\t\t\t}\n\n\t\t\t//???????????¨ -> [?????´][????????????]\n\t\t\tint[][] D = new int[N + 1][L + 1];\n\t\t\tQueue<int[]> pq = new PriorityQueue<>((x, y) -> Integer.compare(x[2], y[2]));\n\n\t\t\tfor (int i = 0; i < D.length; i++) Arrays.fill(D[i], INF);\n\t\t\tD[1][L] = 0;\n\t\t\tpq.offer(new int[]{1, L, 0});\n\n\t\t\twhile (!pq.isEmpty()) {\n\n\t\t\t\tint s, l, min;\n\t\t\t\ts = pq.peek()[0];\n\t\t\t\tl = pq.peek()[1];\n\t\t\t\tmin = pq.peek()[2];\n\t\t\t\tpq.poll();\n\n\t\t\t\tif (D[s][l] < min) continue;\n\n\t\t\t\touter:\n\t\t\t\tfor (Edge e : G.get(s)) {\n\t\t\t\t\tfor (int i = 0; i <= L; i++) {\n\t\t\t\t\t\tif (D[e.to][i] > D[s][i] + e.enemy) {\n\t\t\t\t\t\t\tD[e.to][i] = D[s][i] + e.enemy;\n\t\t\t\t\t\t\tpq.offer(new int[]{e.to, i, D[e.to][i]});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i >= e.distance) {\n\t\t\t\t\t\t\tif (D[e.to][i - e.distance] > D[s][i]) {\n\t\t\t\t\t\t\t\tD[e.to][i - e.distance] = D[s][i];\n\t\t\t\t\t\t\t\tpq.offer(new int[]{e.to, i - e.distance, D[e.to][i - e.distance]});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = INF;\n\n\t\t\tfor (int i = 0; i <= L; i++) {\n\t\t\t\tmin = Math.min(min, D[N][i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\nclass Edge {\n\n\tint to, distance, enemy;\n\n\tpublic Edge(int to, int distance, int enemy) {\n\t\tthis.to = to;\n\t\tthis.distance = distance;\n\t\tthis.enemy = enemy;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tNode[] inn = new Node[101];\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif(n == 0 && m == 0 & l == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tinn[i] = new Node(i);\n\t\t\t}\n\t\t\tNode start = inn[1];\n\t\t\tNode goal = inn[n];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\t\n\t\t\t\tinn[a].edges.add(new Edge(e, d, inn[b]));\n\t\t\t\tinn[b].edges.add(new Edge(e, d, inn[a]));\n\t\t\t}\n\t\t\tboolean[] flg = new boolean[n + 1];\n\t\t\tfor(int i = 0; i <= n; i++){\n\t\t\t\tflg[i] = false;\n\t\t\t}\n\t\t\tSystem.out.println(func(start, l, goal, flg));\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tsc.close();\n\t}\n\tstatic int func(Node node, int cap, Node goal, boolean[] flg){\n\t\tint res = 1000000000;\n\t\tif(node.equals(goal)){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(Edge e : node.edges){\n\t\t\tif(!flg[e.t.n]){\n\t\t\t\tif(e.d > cap){\n\t\t\t\t\tflg[node.n] = true;\n\t\t\t\t\tres = Math.min(res, func(e.t, cap, goal, flg) + e.e);\n\t\t\t\t\tflg[node.n] = false;\n\t\t\t\t}else{\n\t\t\t\t\tflg[node.n] = true;\n\t\t\t\t\tres = Math.min(res, Math.min(func(e.t, cap - e.d, goal, flg), func(e.t, cap, goal, flg) + e.e));\n\t\t\t\t\tflg[node.n] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n}\nclass Node{\n\tint n;\n\tLinkedList<Edge> edges;\n\tNode(int number){\n\t\tedges = new LinkedList<Edge>();\n\t\tn = number;\n\t}\n}\nclass Edge{\n\tboolean flg;\n\tint e;\n\tint d;\n\tNode t;\n\tEdge(int enemy, int dist, Node to){\n\t\te = enemy;\n\t\td = dist;\n\t\tt = to;\n\t\tflg = false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\n    private static long ans = 0, low = 0;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt(), m = in.nextInt(), l = in.nextInt();\n        while (n > 0) {\n            Node[][] nodes = new Node[n][l + 1];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j <= l; j++) {\n                    nodes[i][j] = new Node(i, j);\n                }\n            }\n            for (int i = 0; i < m; i++) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1;\n                int d = in.nextInt(), e = in.nextInt();\n                for (int j = 0; j <= l; j++) {\n                    nodes[a][j].edges.add(new Edge(e, nodes[b][j]));\n                    nodes[b][j].edges.add(new Edge(e, nodes[a][j]));\n                }\n                for (int j = 0; j <= l - d; j++) {\n                    nodes[a][j].edges.add(new Edge(0, nodes[b][j + d]));\n                    nodes[b][j].edges.add(new Edge(0, nodes[a][j + d]));\n                }\n            }\n\n            PriorityQueue<Node> q = new PriorityQueue<>(Comparator.comparing(node -> node.distance));\n            nodes[0][0].distance = 0;\n            q.offer(nodes[0][0]);\n            while (!q.isEmpty()) {\n                Node node = q.poll();\n                if (node.distance == Integer.MAX_VALUE) break;\n                for (Edge edge : node.edges) {\n                    Node next = edge.to;\n                    long d = node.distance + edge.dist;\n                    if (d < edge.to.distance) {\n                        next.distance = d;\n                        q.offer(next);\n                    }\n                }\n            }\n            long ans = Integer.MAX_VALUE;\n            for (int i = 0; i <= l; i++) {\n                ans = Math.min(ans, nodes[n - 1][i].distance);\n            }\n            out.println(ans);\n\n            n = in.nextInt();\n            m = in.nextInt();\n            l = in.nextInt();\n        }\n\n        out.flush();\n    }\n\n    static class Node {\n        long distance = Integer.MAX_VALUE;\n        int index;\n        int cost;\n        List<Edge> edges = new ArrayList<>();\n\n        Node(int index, int cost) {\n            this.index = index;\n            this.cost = cost;\n        }\n    }\n\n    static class Edge {\n        int dist;\n        Node to;\n\n        Edge(int dist, Node to) {\n            this.dist = dist;\n            this.to = to;\n        }\n    }\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\twhile(true) {\n\t\t\tint n = io.nextInt();\n\t\t\tint m = io.nextInt();\n\t\t\tint l = io.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tGraph g = new Graph(n*(l+1));\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = io.nextInt()-1;\n\t\t\t\tint b = io.nextInt()-1;\n\t\t\t\tint d = io.nextInt();\n\t\t\t\tint e = io.nextInt();\n\t\t\t\tfor(int j=l;j>=0;j--) {\n\t\t\t\t\tif (j - d >= 0) {\n\t\t\t\t\t\tg.addEdge(a*(l+1)+j, b*(l+1)+(j-d), 0);\n\t\t\t\t\t\tg.addEdge(b*(l+1)+j, a*(l+1)+(j-d), 0);\n\t\t\t\t\t}\n\t\t\t\t\tg.addBidirectionalEdge(a*(l+1)+j, b*(l+1)+j, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] dist = g.minDistDijkstra(l);\n\t\t\tint ans = Graph.INF;\n\t\t\tfor(int i=0;i<=l;i++) {\n\t\t\t\tans = Math.min(ans, dist[(n-1)*(l+1)+i]);\n\t\t\t}\n\t\t\tio.println(ans);\n\t\t\tSystem.gc();\n\t\t}\n\t\tio.flush();\n\t}\n\n}\nclass IO {\n\tBufferedReader bi = new BufferedReader(new InputStreamReader(System.in));\n\tStringBuilder out = new StringBuilder();\n\tint index = 0;\n\tString bfl = null;\n\tString[] bf = new String[0];\n\tprivate boolean read() {\n\t\ttry {\n\t\t\tbfl = bi.readLine();\n\t\t\tif (bfl == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbf = bfl.split(\"\\\\s\");\n\t\t\tindex = 0;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn true;\n\t}\n\tpublic boolean hasNext() { return index < bf.length ? true : read(); }\n\tpublic boolean hasNextLine() { return read(); }\n\tpublic String next() { return hasNext() ? bf[index++] : null; }\n\tpublic String nextLine() { if (hasNextLine()) {index = bf.length; return bfl; }else return null; }\n\tpublic int nextInt() { return Integer.parseInt(next()); }\n\tpublic long nextLong() { return Long.parseLong(next()); }\n\tpublic double nextDouble() { return Double.parseDouble(next()); };\n\tpublic char nextChar() { return next().charAt(0); }\n\tpublic void println(long x) { out.append(x); out.append(\"\\n\"); }\n\tpublic void println(double x) { out.append(x); out.append(\"\\n\"); }\n\tpublic void println(String s) { out.append(s); out.append(\"\\n\"); }\n\tpublic void println() { out.append(\"\\n\"); }\n\tpublic void print(long x) { out.append(x); }\n\tpublic void print(double x) { out.append(x); }\n\tpublic void print(String s) { out.append(s); }\n\tpublic void print(char c) {out.append(c);}\n\tpublic void flush() {System.out.print(out); out = new StringBuilder(); }\n\tpublic int[] arrayInt(int n) {\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] arrayLong(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double[] arrayDouble(int n) {\n\t\tdouble[] a = new double[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextDouble();\n\t\t}\n\t\treturn a;\n\t}\n}\n\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint dist;\n\t\tint id;\n\t\tpublic Node(int dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n \n \npublic class Main{\n\t\n\tpublic static class Walk implements Comparable<Walk> {\n\t\tint pos;\n\t\tint money;\n\t\tint danger;\n\t\t\n\t\tpublic Walk(int pos, int money, int danger) {\n\t\t\tsuper();\n\t\t\tthis.pos = pos;\n\t\t\tthis.money = money;\n\t\t\tthis.danger = danger;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.danger == arg0.danger ? arg0.money - this.money : this.danger - arg0.danger;\n\t\t}\n\t\t\n\t}\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \twhile(true){\n    \t\tfinal int N = sc.nextInt();\n    \t\tfinal int M = sc.nextInt();\n    \t\tfinal int L = sc.nextInt();\n    \t\t\n    \t\tif(N == 0 && M == 0 && L == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tint[][] adj = new int[N][N];\n    \t\tint[][] warn = new int[N][N];\n    \t\t\n    \t\tfor(int i = 0; i < N; i++){\n    \t\t\tfor(int j = 0; j < N; j++){\n    \t\t\t\tadj[i][j] = -1;\n    \t\t\t\twarn[i][j] = -1;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < M; i++){\n    \t\t\tfinal int A = sc.nextInt() - 1;\n    \t\t\tfinal int B = sc.nextInt() - 1;\n    \t\t\tfinal int D = sc.nextInt();\n    \t\t\tfinal int E = sc.nextInt();\n    \t\t\t\n    \t\t\tadj[A][B] = adj[B][A] = D;\n    \t\t\twarn[A][B] = warn[B][A] = E;\n    \t\t}\n    \t\t\n    \t\tboolean[][] is_visited = new boolean[N][L + 1];\n    \t\t\n    \t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n    \t\tqueue.add(new Walk(0, L, 0));\n    \t\t\n    \t\twhile(!queue.isEmpty()){\n    \t\t\tWalk walk = queue.poll();\n    \t\t\t\n    \t\t\tif(is_visited[walk.pos][walk.money]){\n    \t\t\t\tcontinue;\n    \t\t\t}else{\n    \t\t\t\tis_visited[walk.pos][walk.money] = true;\n    \t\t\t}\n    \t\t\t\n    \t\t\tif(walk.pos == N - 1){\n    \t\t\t\tSystem.out.println(walk.danger);\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\t\n    \t\t\tfor(int to = 0; to < N; to++){\n    \t\t\t\tif(adj[walk.pos][to] < 0){\n    \t\t\t\t\tcontinue;\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(walk.money >= adj[walk.pos][to]){\n    \t\t\t\t\tfinal int new_money = walk.money - adj[walk.pos][to];\n    \t\t\t\t\tfinal int new_pos   = to;\n    \t\t\t\t\t\n    \t\t\t\t\tif(!is_visited[new_pos][new_money]){\n    \t\t\t\t\t\tqueue.add(new Walk(new_pos, new_money, walk.danger));\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(!is_visited[to][walk.money]){\n    \t\t\t\t\tqueue.add(new Walk(to, walk.money, walk.danger + warn[walk.pos][to]));\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t}\n    \t\n    \t\n    \t\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif(n == 0 && m == 0 && l == 0) break;\n\t\t\tint [][] pass = new int[n][n];\n\t\t\tint [][] money = new int[n][n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tArrays.fill(money[i], INF);\n\t\t\t}\n\t\t\tfor(int i = 0;i < m; i++){\n\t\t\t\tint from = sc.nextInt() - 1;\n\t\t\t\tint to = sc.nextInt() -1 ;\n\t\t\t\tint dis = sc.nextInt();\n\t\t\t\tint num = sc.nextInt();\n\t\t\t\tpass[from][to] = num;\n\t\t\t\tpass[to][from] = num;\n\t\t\t\tmoney[from][to] = dis;\n\t\t\t\tmoney[to][from] = dis;\n\t\t\t}\n\t\t\tPriorityQueue<C> open = new PriorityQueue<C>();\n\t\t\topen.add(new C(0,l,0));\n\t\t\tint [][] close = new int[n][l+1];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < l + 1; j++){\n\t\t\t\t\tclose[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose[0][l] = 0;\n\t\t\tint ans = INF;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\tint from = now.now;\n\t\t\t\t//goal\n\t\t\t\tif(from == n-1){\n\t\t\t\t\tans = Math.min(ans, now.num);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i= 0; i < n; i++){\n\t\t\t\t\tif(pass[from][i] == INF){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//use\n\t\t\t\t\tint nextnum = now.num + pass[from][i];\n\t\t\t\t\tif(now.money >= money[from][i]){\n\t\t\t\t\t\tint nextmoney = now.money - money[from][i];\n\t\t\t\t\t\tif(close[i][nextmoney] <= now.num) continue;\n\t\t\t\t\t\topen.add(new C(i, nextmoney, now.num));\n\t\t\t\t\t\tclose[i][nextmoney] = now.num;\n\t\t\t\t\t}\n\t\t\t\t\t//not use\n\t\t\t\t\tif(close[i][now.money] <= nextnum) continue;\n\t\t\t\t\topen.add(new C(i, now.money, nextnum));\n\t\t\t\t\tclose[i][now.money] = nextnum; \n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate class C implements Comparable<C>{\n\t\tint now,money,num;\n\t\t\n\t\tpublic C(int now, int money, int num) {\n\t\t\tthis.now = now;\n\t\t\tthis.money = money;\n\t\t\tthis.num = num;\n\t\t}\n\n\t\tpublic int compareTo(C o) {\n\t\t\tif(num < o.num) return -1;\n\t\t\tif(num > o.num) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint[][] dist, enemy;\n\tint n, m, l;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tl = sc.nextInt();\n\t\t\tif( (n|m|l) == 0 ) break;\n\t\t\t\n\t\t\tdist = new int[n][n]; enemy = new int[n][n];\n\t\t\tfor(int[] a: dist) fill(a, INF);\n\t\t\tfor(int[] a: enemy) fill(a, INF);\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1, b = sc.nextInt()-1, d = sc.nextInt(), e = sc.nextInt();\n\t\t\t\tdist[a][b] = dist[b][a] = d;\n\t\t\t\tenemy[a][b] = enemy[b][a] = e;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\t\n\tint dijkstra() {\n\t\tint[][] cost = new int[n][l+1];\n\t\tfor(int[] a: cost) fill(a, INF);\n\t\t\n\t\tPriorityQueue<E> que = new PriorityQueue<E>();\n\t\tque.add(new E(0, l, 0));\n\t\tcost[0][l] = 0;\n\t\tfor(;!que.isEmpty();) {\n\t\t\tE cur = que.remove();\n\t\t\tif(cost[cur.p][cur.l] != cur.c) continue;\n\t\t\tif(cur.p == n-1) return cur.c;\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif(cost[i][cur.l] > cur.c + enemy[cur.p][i]) {\n\t\t\t\t\tcost[i][cur.l] = cur.c + enemy[cur.p][i];\n\t\t\t\t\tque.add(new E(i, cur.l, cur.c + enemy[cur.p][i]));\n\t\t\t\t}\n\t\t\t\tif(cur.l-dist[cur.p][i]>=0 && cost[i][cur.l-dist[cur.p][i]] > cur.c) {\n\t\t\t\t\tcost[i][cur.l - dist[cur.p][i]] = cur.c;\n\t\t\t\t\tque.add(new E(i, cur.l-dist[cur.p][i], cur.c));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tclass E implements Comparable<E> {\n\t\tint p, l, c;\n\t\t\n\t\tE(int p, int l, int c) {\n\t\t\tthis.p = p;\n\t\t\tthis.l = l;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t\tpublic int compareTo(E o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn c-o.c;\n\t\t}\n\t\t\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass Main{\n\n    private static int[][] used;\n    private static int N,M,L;\n    private static List<Pox>[] list;\n    private static final int INF = 100000000;\n\n    private static class Pox{\n\tpublic int B,D,E;\n\tPox(){\n\t    B = D = E = 0;\n\t}\n\n\tPox(int b,int d,int e){\n\t    B = b;\n\t    D = d;\n\t    E = e;\n\t}\n    }\n\n    private static class Eleac implements Comparable<Eleac>{\n\tpublic int id,L,num;\n\n\tEleac(){\n\t    id = L = num = 0;\n\t}\n\n\tEleac(int a,int b,int c){\n\t    id = a;\n\t    L = b;\n\t    num = c;\n\t}\n\n\t@Override\n\tpublic int compareTo(Eleac a){\n\t    return 1;\n\t}\n\n    }\n\n     @SuppressWarnings(\"unchecked\")\n      public static void main(String args[])throws IOException{\n\t  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t  \n\t  while(true)\n\t      {\n\t\t  String[] elements = in.readLine().split(\" \");\n\t\t  N = Integer.parseInt(elements[0]);\n\t\t  M = Integer.parseInt(elements[1]);\n\t\t  L = Integer.parseInt(elements[2]);\n\t\t  if(N == 0 && M == 0 && L == 0)\n\t\t      break;\n\n\t\t  \n\n\t\t  used = new int[N+1][L+1];\n\t\t  list = new ArrayList[N+2];\n\n\t\t  for(int i=0;i<N+1;i++)\n\t\t      for(int j=0;j<L+1;j++)\n\t\t\t  used[i][j] = INF;\n\n\t\t  for(int i=0;i<N+1;i++)\n\t\t      list[i] = new ArrayList<Pox>();\n\t\t  \n\t\t  for(int i=0;i<M;i++)\n\t\t      {\n\t\t\t elements = in.readLine().split(\" \");\n\t\t\t int A,B,D,E;\n\t\t\t  A = Integer.parseInt(elements[0]);\n\t\t\t  B = Integer.parseInt(elements[1]);\n\t\t\t  D = Integer.parseInt(elements[2]);\n\t\t\t  E = Integer.parseInt(elements[3]);\n\n\t\t\t  list[A].add(new Pox(B,D,E));  \n\t\t\t  list[B].add(new Pox(A,D,E));\n\t\t      }\n\n\t\t  Queue<Eleac> que = new PriorityQueue<Eleac>();\n\n\t\t  que.offer(new Eleac(1,L,0)); //Eleac(id,money,the number of eemy)\n\t\t  used[1][L] = 0;\t\t\n\n\t\t  int men = INF;\n\t\t  while(que.size() > 0)\n\t\t      {\n\t\t\t  Eleac p = que.poll(); \n\t\t\t  int now = p.id;\n\t\t\t  int money = p.L;\n\t\t\t  int val = p.num;\n\t\t\t  \n\t\t\t  if(now == N)\n\t\t\t      {\n\t\t\t\t  used[now][money] = Math.min(used[now][money],val);\t\n\t\t\t\t  continue;\n\t\t\t      }\n\t\t      \n\t\t\t \n\t\t\t  for(int i=0;i<list[now].size();i++)\n\t\t\t      {\n\t\t\t\t  int need = list[now].get(i).D;\n\n\t\t\t\t  int new_pos = list[now].get(i).B;\n\t\t\t\t  int the_number = list[now].get(i).E;\n\t\t\t\t  \n\t\t\t\t  if(money-need >= 0 && used[new_pos][money-need] > val)\n\t\t\t\t      {\n\t\t\t\t\t  used[new_pos][money-need] = val;\n\t\t\t\t\t  que.add(new Eleac(new_pos,money-need,val));\n\t\t\t\t      }\t\t\t\t  \t\n\t\t\t\t  if(used[new_pos][money] > val+the_number)\n\t\t\t\t      {\n\t\t\t\t\t  used[new_pos][money] = val+the_number;\n\t\t\t\t\t  que.add(new Eleac(new_pos,money,val+the_number));\n\t\t\t\t      }\n\n\t\t\t      }\n\n\t\t      \n\t\t      }\n\n\t\t  for(int i=0;i<=L;i++)\n\t\t      {\n\t\t\t  men = Math.min(men,used[N][i]);\n\t\t      }\n\t\t  System.out.println(men);\n\t      }\n      }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Brave Princess Revisited\npublic class Main{\n\n\tint[][] dist;\n\tvoid run(){\n\t\tScanner sc =new Scanner(System.in);\n\t\tint INF = 1<<29;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), L = sc.nextInt();\n\t\t\tif((n|m|L)==0)break;\n\t\t\tint[][] d = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:d)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, D = sc.nextInt(), E = sc.nextInt();\n\t\t\t\td[s][t] = d[t][s] = D; e[s][t] = e[t][s] = E;\n\t\t\t}\n\t\t\tdist = new int[n][L+1];\n\t\t\tfor(int[]a:dist)Arrays.fill(a, INF);\n\t\t\tdist[0][L] = 0;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(n, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn dist[o1[0]][o1[1]]-dist[o2[0]][o2[1]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(new int[]{0, L});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tint v = a[0], c = a[1];\n\t\t\t\tif(v==n-1){\n\t\t\t\t\tSystem.out.println(dist[v][c]); break;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(d[v][i]==INF)continue;\n\t\t\t\t\tint w = dist[v][c] + e[v][i];\n\t\t\t\t\tif(w<dist[i][c]){\n\t\t\t\t\t\tdist[i][c] = w; q.add(new int[]{i, c});\n\t\t\t\t\t}\n\t\t\t\t\tif(d[v][i]<=c&&dist[v][c]<dist[i][c-d[v][i]]){\n\t\t\t\t\t\tdist[i][c-d[v][i]] = dist[v][c]; q.add(new int[]{i, c-d[v][i]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  void run() {\n    for ( ;; ) {\n      int n = ni();\n      int m = ni();\n      int l = ni();\n      if ( ( n | m | l ) == 0 ) {\n        break;\n      }\n\n      int[][] dm = new int[n + 1][n + 1];\n      int[][] em = new int[n + 1][n + 1];\n      boolean[][] lk = new boolean[n + 1][n + 1];\n\n      for ( int i = 0; i < m; ++i ) {\n        int a = ni();\n        int b = ni();\n        int d = ni();\n        int e = ni();\n        dm[ a ][ b ] = dm[ b ][ a ] = d;\n        em[ a ][ b ] = em[ b ][ a ] = e;\n        lk[ a ][ b ] = lk[ b ][ a ] = true;\n      }\n\n      boolean[][] ok = new boolean[n + 1][l + 1];\n      int[][] dp = new int[n + 1][l + 1];\n      for ( int[] v : dp )\n        Arrays.fill( v, 1 << 28 );\n      dp[ 1 ][ l ] = 0;\n      ok[ 1 ][ l ] = true;\n      for ( int h = 0; h < n; ++h ) {\n        for ( int i = 1; i <= n; ++i ) {\n          for ( int j = 1; j <= n; ++j ) {\n            if ( lk[ i ][ j ] ) {\n              for ( int k = 1; k <= l; ++k ) {\n                if ( ok[ i ][ k ] ) {\n                  if ( k - dm[ i ][ j ] >= 0 ) {\n                    dp[ j ][ k - dm[ i ][ j ] ] = Math.min( dp[ j ][ k\n                        - dm[ i ][ j ] ], dp[ i ][ k ] );\n                    ok[ j ][ k - dm[ i ][ j ] ] = true;\n//                    debug( i, j, k - dm[ i ][ j ], dp[ j ][ k - dm[ i ][ j ] ] );\n                  }\n                  dp[ j ][ k ] = Math.min( dp[ j ][ k ], dp[ i ][ k ]\n                      + em[ i ][ j ] );\n                  ok[ j ][ k ] = true;\n//                  debug( i, j, k, dp[ j ][ k ] );\n                }\n              }\n            }\n          }\n        }\n      }\n\n      int min = 1 << 28;\n      for ( int k = 0; k <= l; ++k ) {\n        min = Math.min( min, dp[ n ][ k ] );\n      }\n\n      System.out.println( min );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final int INF = Integer.MAX_VALUE;\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\t}\n\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\twhile(n + m + l > 0){\n\t\t\tint[][] road = new int[m][4];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\troad[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t//宿場nに予算lでたどり着く時の盗賊の最小値\n\t\t\tint[][] place = new int[n][l + 1];\n\t\t\tfor(int[] a : place){\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tplace[0][0] = 0;\n\t\t\t//Arrays.fill(place[0],0);\n\t\t\tboolean bContinue = true;\n\t\t\twhile(bContinue){\n\t\t\t\tbContinue = false;\n\t\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\t\tint from = road[i][0] - 1;\n\t\t\t\t\tint to = road[i][1] - 1;\n\t\t\t\t\tint dist = road[i][2];\n\t\t\t\t\tint enemy = road[i][3];\n\t\t\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\t\t\t//金を払っていく場合\n\t\t\t\t\t\tif(j + dist <= l && place[from][j] != INF && (place[from][j] < place[to][j + dist])){\n\t\t\t\t\t\t\tplace[to][j + dist] = place[from][j];\n\t\t\t\t\t\t\tbContinue = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//金を払わない場合\n\t\t\t\t\t\tif(place[from][j] != INF && (place[from][j] + enemy <  place[to][j])){\n\t\t\t\t\t\t\tplace[to][j] = place[from][j] + enemy;\n\t\t\t\t\t\t\tbContinue = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfrom = road[i][1] - 1;\n\t\t\t\t\tto = road[i][0] - 1;\n\n\t\t\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\t\t\t//金を払っていく場合\n\t\t\t\t\t\tif(j + dist <= l && place[from][j] != INF && (place[from][j] < place[to][j + dist])){\n\t\t\t\t\t\t\tplace[to][j + dist] = place[from][j];\n\t\t\t\t\t\t\tbContinue = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//金を払わない場合\n\t\t\t\t\t\tif(place[from][j] != INF && (place[from][j] + enemy <  place[to][j])){\n\t\t\t\t\t\t\tplace[to][j] = place[from][j] + enemy;\n\t\t\t\t\t\t\tbContinue = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] dest = place[n - 1];\n\t\t\tArrays.sort(dest);\n\t\t\t//print(dest);\n\t\t\tSystem.out.println(dest[0]);\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tl = sc.nextInt();\n\t\t}\n\t}\n\n\tpublic static void print(int[] a){\n\t\tfor(int b : a){\n\t\t\tSystem.out.print(b + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final int INF = Integer.MAX_VALUE;\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\t}\n\t\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\twhile(n + m + l > 0){\n\t\t\tint[][] road = new int[m][4];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\troad[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t//宿場nに予算lでたどり着く時の盗賊の最小値\n\t\t\tint[][] place = new int[n][l + 1];\n\t\t\tfor(int[] a : place){\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tplace[0][0] = 0;\n\t\t\tboolean bContinue = true;\n\t\t\twhile(bContinue){\n\t\t\t\tbContinue = false;\n\t\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\t\tint from = road[i][0] - 1;\n\t\t\t\t\tint to = road[i][1] - 1;\n\t\t\t\t\tint dist = road[i][2];\n\t\t\t\t\tint enemy = road[i][3];\n\t\t\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\t\t\t//金を払っていく場合\n\t\t\t\t\t\tif(j + dist <= l && place[from][j] != INF && (place[from][j] < place[to][j + dist])){\n\t\t\t\t\t\t\tplace[to][j + dist] = place[from][j];\n\t\t\t\t\t\t\tbContinue = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//金を払わない場合\n\t\t\t\t\t\tif(place[from][j] != INF && (place[from][j] + enemy <  place[to][j])){\n\t\t\t\t\t\t\tplace[to][j] = place[from][j] + enemy;\n\t\t\t\t\t\t\tbContinue = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfrom = road[i][1] - 1;\n\t\t\t\t\tto = road[i][0] - 1;\n\t\t\t\t\t\n\t\t\t\t\tfor(int j = 0; j < l; j++){\n\t\t\t\t\t\t//金を払っていく場合\n\t\t\t\t\t\tif(j + dist <= l && place[from][j] != INF && (place[from][j] < place[to][j + dist])){\n\t\t\t\t\t\t\tplace[to][j + dist] = place[from][j];\n\t\t\t\t\t\t\tbContinue = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//金を払わない場合\n\t\t\t\t\t\tif(place[from][j] != INF && (place[from][j] + enemy <  place[to][j])){\n\t\t\t\t\t\t\tplace[to][j] = place[from][j] + enemy;\n\t\t\t\t\t\t\tbContinue = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] dest = place[n - 1];\n\t\t\tArrays.sort(dest);\n\t\t\t//print(dest);\n\t\t\tSystem.out.println(dest[0]);\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tl = sc.nextInt();\n\t\t}\n\t}\n\t\n\tpublic static void print(int[] a){\n\t\tfor(int b : a){\n\t\t\tSystem.out.print(b + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tint money = in.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tint[][] e = new int[n][n];\n\t\t\tint[][] d = new int[n][n];\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint a = in.nextInt()-1;\n\t\t\t\tint b = in.nextInt()-1;\n\t\t\t\tint dist = in.nextInt();\n\t\t\t\tint enemy = in.nextInt();\n\t\t\t\td[a][b] = d[b][a] = dist;\n\t\t\t\te[a][b] = e[b][a] = enemy;\n\t\t\t\tnode[a].createEdge(node[b]);\n\t\t\t\tnode[b].createEdge(node[a]);\n\t\t\t}\n\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\tqu.add(new Pos(0, 0, money, 0, 1));\n\t\t\tboolean[][] used = new boolean[n][money+1];\n\t\t\tfinal int INF = 100000000;\n\t\t\tint res = INF;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(used[p.id][p.m]) continue;\n\t\t\t\tif(p.id == n-1){\n\t\t\t\t\tres = Math.min(p.e, res);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[p.id][p.m] = true;\n\t\t\t\tfor(Node v: node[p.id].edge){\n\t\t\t\t\tif((p.state&1<<v.id)>0) continue;\n\t\t\t\t\tqu.add(new Pos(v.id, p.d+d[p.id][v.id], p.m, p.e+e[p.id][v.id], p.state|1<<v.id));\n\t\t\t\t\tif(p.m - d[p.id][v.id] < 0) continue;\n\t\t\t\t\tqu.add(new Pos(v.id, p.d+d[p.id][v.id], p.m-d[p.id][v.id], p.e, p.state|1<<v.id));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint id;\n\tint d, m, e;\n\tint state;\n\tpublic Pos(int id, int d, int m, int e, int state){\n\t\tthis.id = id;\n\t\tthis.d = d;\n\t\tthis.m = m;\n\t\tthis.e = e;\n\t\tthis.state = state;\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn d-o.d;\n\t}\n}\n\nclass Node{\n\tint id;\n\tArrayList<Node> edge = new ArrayList<Node>();\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t}\n\tpublic void createEdge(Node nd){\n\t\tedge.add(nd);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tint money = in.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tint[][] e = new int[n][n];\n\t\t\tint[][] d = new int[n][n];\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint a = in.nextInt()-1;\n\t\t\t\tint b = in.nextInt()-1;\n\t\t\t\tint dist = in.nextInt();\n\t\t\t\tint enemy = in.nextInt();\n\t\t\t\td[a][b] = d[b][a] = dist;\n\t\t\t\te[a][b] = e[b][a] = enemy;\n\t\t\t\tnode[a].createEdge(node[b]);\n\t\t\t\tnode[b].createEdge(node[a]);\n\t\t\t}\n\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\tqu.add(new Pos(0, 0, money, 0, 1));\n\t\t\tboolean[][] used = new boolean[n][money+1];\n\t\t\tfinal int INF = 100000000;\n\t\t\tint res = INF;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(used[p.id][p.m]) continue;\n\t\t\t\tif(p.id == n-1){\n\t\t\t\t\tres = Math.min(p.e, res);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[p.id][p.m] = true;\n\t\t\t\tfor(Node v: node[p.id].edge){\n\t\t\t\t\tif((p.state&1<<v.id)>0) continue;\n\t\t\t\t\tqu.add(new Pos(v.id, p.d+d[p.id][v.id], p.m, p.e+e[p.id][v.id], p.state|1<<v.id));\n\t\t\t\t\tif(p.m - d[p.id][v.id] < 0) continue;\n\t\t\t\t\tqu.add(new Pos(v.id, p.d+d[p.id][v.id], p.m-d[p.id][v.id], p.e, p.state|1<<v.id));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint id;\n\tint d, m, e;\n\tint state;\n\tpublic Pos(int id, int d, int m, int e, int state){\n\t\tthis.id = id;\n\t\tthis.d = d;\n\t\tthis.m = m;\n\t\tthis.e = e;\n\t\tthis.state = state;\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn e-o.e;\n\t}\n}\n\nclass Node{\n\tint id;\n\tArrayList<Node> edge = new ArrayList<Node>();\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t}\n\tpublic void createEdge(Node nd){\n\t\tedge.add(nd);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.Point;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n=sc.nextInt(),m=sc.nextInt(),l=sc.nextInt();\n\t\t\tif(n==0 && m==0 && l==0) break;\n\t\t\tPoint[][] map = new Point[n+1][n+1];\n\n\t\t\twhile(m-- > 0){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),d=sc.nextInt(),e=sc.nextInt();\n\t\t\t\tmap[a][b] = new Point(d,e);\n\t\t\t\tmap[b][a] = new Point(d,e);\n\t\t\t}\n\n\t\t\tQueue<State> open = new PriorityQueue<State>();\n\t\t\tSet<State> closed = new HashSet<State>();\n\n\t\t\tState st = new State(0,l,1);\n\t\t\topen.add(st);\n\n\t\t\tState ans = null;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tst = open.poll();\n\t\t\t\tif(closed.contains(st)) continue;\n\t\t\t\tclosed.add(st);\n\t\t\t\tif(st.id == n){\n\t\t\t\t\tans = st;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\topen.addAll(st.nexts(map));\n\t\t\t}\n\t\t\tSystem.out.println(st.cost);\n\t\t}\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint cost;\n\tint money;\n\tint id;\n\n\tState(int cost, int money, int id){\n\t\tthis.cost = cost;\n\t\tthis.money = money;\n\t\tthis.id = id;\n\t}\n\n\tList<State> nexts(Point[][] map){\n\t\tList<State> sts = new ArrayList<State>();\n\t\tint n = map.length;\n\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(i == id) continue;\n\t\t\tif(map[id][i] == null) continue;\n\t\t\tsts.add(new State(cost+map[id][i].y, money, i));\n\t\t\tif(money >= map[id][i].x)\n\t\t\t\tsts.add(new State(cost, money-map[id][i].x, i));\n\t\t}\n\n\t\treturn sts;\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn cost - st.cost;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tState st = (State)o;\n\t\treturn this.money==st.money && this.id==st.id;\n\t}\n\n\tpublic int hashCode(){\n\t\treturn money + id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-10;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tint L = sc.nextInt();\n\t\t\tif ((N | M | L) == 0)\n\t\t\t\tbreak;\n\t\t\tint es[][][] = new int[N][N][2];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tArrays.fill(es[i][j], INF);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\tes[a][b][0] = d;\n\t\t\t\tes[a][b][1] = e;\n\t\t\t\tes[b][a][0] = d;\n\t\t\t\tes[b][a][1] = e;\n\t\t\t}\n\t\t\tQueue<Node> q = new PriorityQueue<Node>();\n\t\t\tq.add(new Node(0, L, 0));\n\t\t\tboolean visited[] = new boolean[N];\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode n = q.poll();\n\t\t\t\tint v = n.v;\n\t\t\t\tint d = n.money;\n\t\t\t\tint enemy = n.enemy;\n\t\t\t\tif (v == N - 1) {\n\t\t\t\t\tSystem.out.println(enemy);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (visited[v])\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited[v] = true;\n\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\tif (es[v][i][0] >= INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (d >= es[v][i][0]) {\n\t\t\t\t\t\tq.add(new Node(i, d - es[v][i][0], enemy));\n\t\t\t\t\t}\n\t\t\t\t\tq.add(new Node(i, d, enemy + es[v][i][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Node implements Comparable<Node> {\n\tint v;\n\tint money;\n\tint enemy;\n\n\tpublic Node(int v, int money, int enemy) {\n\t\tthis.v = v;\n\t\tthis.money = money;\n\t\tthis.enemy = enemy;\n\t}\n\n\t@Override\n\tpublic int compareTo(Node o) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\treturn this.enemy - o.enemy;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic final int INF = 1000000000;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tNode[] inn = new Node[101];\n\t\tint[][] dp = new int[101][101];\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif(n == 0 && m == 0 & l == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tinn[i] = new Node(i);\n\t\t\t}\n\t\t\tNode start = inn[1];\n\t\t\tNode goal = inn[n];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\t\n\t\t\t\tinn[a].edges.add(new Edge(e, d, inn[b]));\n\t\t\t\tinn[b].edges.add(new Edge(e, d, inn[a]));\n\t\t\t}\n\t\t\tboolean[] flg = new boolean[n + 1];\n\t\t\tfor(int i = 0; i <= n; i++){\n\t\t\t\tflg[i] = false;\n\t\t\t}\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\t\tdp[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\t\tint len = 0;\n\t\t\tdp[1][0] = 0;\n\t\t\tq.add(inn[1]);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tNode node = q.poll();\n\t\t\t\tlen = node.c;\n\t\t\t\tfor(Edge e : node.edges){\n\t\t\t\t\t// ???????????£????????????\n\t\t\t\t\tif(len + e.d <= l){ // ?????¨??????????????????\n\t\t\t\t\t\t// ?????¨?????£?????´???????\\???????????????°????°???????????????????\n\t\t\t\t\t\tif(dp[e.t.n][len + e.d] > dp[node.n][len]){\n\t\t\t\t\t\t\tNode nnode = new Node(e.t.n);\n\t\t\t\t\t\t\tnnode.edges = e.t.edges;\n\t\t\t\t\t\t\tnnode.c = len + e.d;\n\t\t\t\t\t\t\tq.add(nnode);\n\t\t\t\t\t\t\tdp[e.t.n][len + e.d] = dp[node.n][len] ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ????????£???????????????\n\t\t\t\t\t// ?????¨??????????????´???????\\???????????????°????????????\n\t\t\t\t\tif(dp[e.t.n][len] > dp[node.n][len] + e.e){\n\t\t\t\t\t\tNode nnode = new Node(e.t.n);\n\t\t\t\t\t\tnnode.edges = e.t.edges;\n\t\t\t\t\t\tnnode.c = len;\n\t\t\t\t\t\tq.add(nnode);\n\t\t\t\t\t\tdp[e.t.n][len] = dp[node.n][len] + e.e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = INF;\n\t\t\tfor(int i = 0; i <= l; i++){\n\t\t\t\tmin = Math.min(min, dp[n][i]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n//\t\t\tSystem.out.println(func(start, l, goal, flg));\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tsc.close();\n\t}\n\tstatic int func(Node node, int cap, Node goal, boolean[] flg){\n\t\tint res = 1000000000;\n\t\tif(node.equals(goal)){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(Edge e : node.edges){\n\t\t\tif(!flg[e.t.n]){\n\t\t\t\tif(e.d > cap){\n\t\t\t\t\tflg[node.n] = true;\n\t\t\t\t\tres = Math.min(res, func(e.t, cap, goal, flg) + e.e);\n\t\t\t\t\tflg[node.n] = false;\n\t\t\t\t}else{\n\t\t\t\t\tflg[node.n] = true;\n\t\t\t\t\tres = Math.min(res, Math.min(func(e.t, cap - e.d, goal, flg), func(e.t, cap, goal, flg) + e.e));\n\t\t\t\t\tflg[node.n] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n}\nclass Node implements Comparable<Node>{\n\tint n;\n\tint c;\n\tLinkedList<Edge> edges;\n\tNode(int number){\n\t\tedges = new LinkedList<Edge>();\n\t\tn = number;\n\t\tc = 0;\n\t}\n\t@Override\n\tpublic int compareTo(Node o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn n - o.n;\n\t}\n}\nclass Edge{\n\tboolean flg;\n\tint e;\n\tint d;\n\tNode t;\n\tEdge(int enemy, int dist, Node to){\n\t\te = enemy;\n\t\td = dist;\n\t\tt = to;\n\t\tflg = false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Problem C: Brave Princess Revisited\n */\npublic class Main {\n\n\tstatic final int INF = 1 << 29;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tStringTokenizer st = new StringTokenizer(line);\n\n\t\t\tint N, M, L;\n\t\t\tN = parseInt(st.nextToken());\n\t\t\tM = parseInt(st.nextToken());\n\t\t\tL = parseInt(st.nextToken());\n\t\t\tif ((N | M | L) == 0) break;\n\n\t\t\tMap<Integer, List<Edge>> G = new HashMap<>();\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tint A, B, D, E;\n\t\t\t\tA = parseInt(st.nextToken());\n\t\t\t\tB = parseInt(st.nextToken());\n\t\t\t\tD = parseInt(st.nextToken());\n\t\t\t\tE = parseInt(st.nextToken());\n\t\t\t\tG.putIfAbsent(A, new ArrayList<>());\n\t\t\t\tG.putIfAbsent(B, new ArrayList<>());\n\t\t\t\tG.get(A).add(new Edge(B, D, E));\n\t\t\t\tG.get(B).add(new Edge(A, D, E));\n\t\t\t}\n\n\t\t\t//???????????¨ -> [?????´][????????????]\n\t\t\tint[][] D = new int[N + 1][L + 1];\n\t\t\tQueue<int[]> pq = new PriorityQueue<>((x, y) -> Integer.compare(x[2], y[2]));\n\n\t\t\tfor (int i = 0; i < D.length; i++) Arrays.fill(D[i], INF);\n\t\t\tD[1][L] = 0;\n\t\t\tpq.offer(new int[]{1, L, 0});\n\n\t\t\twhile (!pq.isEmpty()) {\n\n\t\t\t\tint s, l, min;\n\t\t\t\ts = pq.peek()[0];\n\t\t\t\tl = pq.peek()[1];\n\t\t\t\tmin = pq.peek()[2];\n\t\t\t\tpq.poll();\n\n\t\t\t\tif (D[s][l] < min) continue;\n\n\t\t\t\touter:\n\t\t\t\tfor (Edge e : G.get(s)) {\n\t\t\t\t\tfor (int i = 0; i <= L; i++) {\n\t\t\t\t\t\tif (D[e.to][i] > D[s][i] + e.enemy) {\n\t\t\t\t\t\t\tD[e.to][i] = D[s][i] + e.enemy;\n\t\t\t\t\t\t\tpq.offer(new int[]{e.to, i, D[e.to][i]});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i >= e.distance) {\n\t\t\t\t\t\t\tif (D[e.to][i - e.distance] > D[s][i]) {\n\t\t\t\t\t\t\t\tD[e.to][i - e.distance] = D[s][i];\n\t\t\t\t\t\t\t\tpq.offer(new int[]{e.to, i - e.distance, D[e.to][i - e.distance]});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = INF;\n\n\t\t\tfor (int i = 0; i <= L; i++) {\n\t\t\t\tmin = Math.min(min, D[N][i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\nclass Edge {\n\n\tint to, distance, enemy;\n\n\tpublic Edge(int to, int distance, int enemy) {\n\t\tthis.to = to;\n\t\tthis.distance = distance;\n\t\tthis.enemy = enemy;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.awt.Point;\n\nclass Main{\n\n    private static int[][] used;\n    private static int N,M,L;\n    private static List<Pox>[] list;\n    private static final int INF = 100000000;\n\n    private static class Pox{\n\tpublic int B,D,E;\n\tPox(){\n\t    B = D = E = 0;\n\t}\n\n\tPox(int b,int d,int e){\n\t    B = b;\n\t    D = d;\n\t    E = e;\n\t}\n    }\n\n    private static class Eleac implements Comparable<Eleac>{\n\tpublic int id,L,num;\n\n\tEleac(){\n\t    id = L = num = 0;\n\t}\n\n\tEleac(int a,int b,int c){\n\t    id = a;\n\t    L = b;\n\t    num = c;\n\t}\n\n\t@Override\n\tpublic int compareTo(Eleac a){\n\t    return 1;\n\t}\n\n    }\n\n     @SuppressWarnings(\"unchecked\")\n      public static void main(String args[])throws IOException{\n\t  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t  //PrintWriter out = new PrintWriter(System.out);\n\t  \n\t  while(true)\n\t      {\n\t\t  String[] elements = in.readLine().split(\" \");\n\t\t  N = Integer.parseInt(elements[0]);\n\t\t  M = Integer.parseInt(elements[1]);\n\t\t  L = Integer.parseInt(elements[2]);\n\t\t  if(N == 0 && M == 0 && L == 0)\n\t\t      break;\n\n\t\t  \n\n\t\t  used = new int[N+1][L+1];\n\t\t  list = new ArrayList[N+2];\n\n\t\t  for(int i=0;i<N+1;i++)\n\t\t      for(int j=0;j<L+1;j++)\n\t\t\t  used[i][j] = INF;\n\n\t\t  for(int i=0;i<N+1;i++)\n\t\t      list[i] = new ArrayList<Pox>();\n\t\t  \n\t\t  for(int i=0;i<M;i++)\n\t\t      {\n\t\t\t elements = in.readLine().split(\" \");\n\t\t\t int A,B,D,E;\n\t\t\t  A = Integer.parseInt(elements[0]);\n\t\t\t  B = Integer.parseInt(elements[1]);\n\t\t\t  D = Integer.parseInt(elements[2]);\n\t\t\t  E = Integer.parseInt(elements[3]);\n\t\t\t  //System.out.println(\"A : \" + A  + \" B : \" + B + \" D : \" + D + \" E : \" + E);\n\t\t\t  list[A].add(new Pox(B,D,E));  \n\t\t\t  list[B].add(new Pox(A,D,E));\n\t\t      }\n\n\t\t  Queue<Eleac> que = new PriorityQueue<Eleac>();\n\n\t\t  que.offer(new Eleac(1,L,0)); //Eleac(id,money,the number of eemy)\n\t\t  used[1][L] = 0;\t\t\n\n\t\t  int men = INF;\n\t\t  while(que.size() > 0)\n\t\t      {\n\t\t\t  Eleac p = que.poll(); \n\t\t\t  int now = p.id;\n\t\t\t  int money = p.L;\n\t\t\t  int val = p.num;\n\t\t\t  // System.out.println(\"poll : now -> \" + now + \" money -> \" + money + \" val -> \" + val );\n\t\t\t  if(now == N)\n\t\t\t      {\n\t\t\t\t  used[now][money] = Math.min(used[now][money],val);\t\n\t\t\t\t  continue;\n\t\t\t      }\n\t\t      \n\t\t\t \n\t\t\t  for(int i=0;i<list[now].size();i++)\n\t\t\t      {\n\t\t\t\t  int need = list[now].get(i).D;\n\n\t\t\t\t  int new_pos = list[now].get(i).B;\n\t\t\t\t  int the_number = list[now].get(i).E;\n\t\t\t\t  \n\t\t\t\t  if(money-need >= 0 && used[new_pos][money-need] > val)\n\t\t\t\t      {\n\t\t\t\t\t  used[new_pos][money-need] = val;\n\t\t\t\t\t  que.add(new Eleac(new_pos,money-need,val));\n\t\t\t\t      }\t\t\t\t  \t\n\t\t\t\t  if(used[new_pos][money] > val+the_number)\n\t\t\t\t      {\n\t\t\t\t\t  used[new_pos][money] = val+the_number;\n\t\t\t\t\t  que.add(new Eleac(new_pos,money,val+the_number));\n\t\t\t\t      }\n\n\t\t\t      }\n\n\t\t      \n\t\t      }\n\n\t\t  for(int i=0;i<=L;i++)\n\t\t      {\n\t\t\t  men = Math.min(men,used[N][i]);\n\t\t      }\n\t\t  System.out.println(men);\n\t      }\n      }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tint L = sc.nextInt();\n\t\t\t\n\t\t\tif (N + M + L == 0)\n\t\t\t\tbreak;\n\t\t\n\t\t\tint[][] D = new int[N+1][N+1];\n\t\t\tint[][] P = new int[N+1][N+1];\n\t\t\tfor (int i = 0; i <= N; i++) {\n\t\t\t\tArrays.fill(D[i], Integer.MAX_VALUE);\n\t\t\t\tArrays.fill(P[i], Integer.MAX_VALUE);\n\t\t\t}\n\t\t\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tD[a][b] = sc.nextInt();\n\t\t\t\tD[b][a] = D[a][b];\n\t\t\t\tP[a][b] = sc.nextInt();\n\t\t\t\tP[b][a] = P[a][b];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(solve(N, M, L, D, P));\n\t\t}\n\t}\n\t\n\tpublic static int solve(int N, int M, int L, int[][] D, int[][] P) {\n\t\tboolean[][] visit = new boolean[N+1][L+1];\n\t\tPriorityQueue<Node> que = new PriorityQueue<Node>(11, new Comparator<Node>() {\n\t\t\tpublic int compare(Node n1, Node n2) {\n\t\t\t\treturn n1.enemy - n2.enemy;\n\t\t\t}\n\t\t});\n\t\tque.add(new Node(1, L, 0));\n\t\twhile(que.isEmpty() == false) {\n\t\t\tNode node = que.poll();\n\t\t\tif (visit[node.pos][node.money])\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisit[node.pos][node.money] = true;\n\t\t\tif (node.pos == N)\n\t\t\t\treturn node.enemy;\n\t\t\t\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (D[node.pos][i] == Integer.MAX_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tque.add(new Node(i, node.money, node.enemy + P[node.pos][i]));\n\t\t\t\tif (node.money >= D[node.pos][i]) {\n\t\t\t\t\tque.add(new Node(i, node.money - D[node.pos][i], node.enemy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nclass Node {\n\tint pos;\n\tint money;\n\tint enemy;\n\tpublic Node(int p, int m, int e) {\n\t\tthis.pos = p;\n\t\tthis.money = m;\n\t\tthis.enemy = e;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass Main{\n\n    private static int[][] used;\n    private static int N,M,L;\n    private static List<Pox>[] list;\n    private static final int INF = 100000000;\n\n    private static class Pox{\n\tpublic int B,D,E;\n\tPox(){\n\t    B = D = E = 0;\n\t}\n\n\tPox(int b,int d,int e){\n\t    B = b;\n\t    D = d;\n\t    E = e;\n\t}\n    }\n\n    private static class Eleac implements Comparable<Eleac>{\n\tpublic int id,L,num;\n\n\tEleac(){\n\t    id = L = num = 0;\n\t}\n\n\tEleac(int a,int b,int c){\n\t    id = a;\n\t    L = b;\n\t    num = c;\n\t}\n\n\t@Override\n\tpublic int compareTo(Eleac a){\n\t    return 1;\n\t}\n\n    }\n\n     @SuppressWarnings(\"unchecked\")\n      public static void main(String args[])throws IOException{\n\t  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t  \n\t  while(true)\n\t      {\n\t\t  String[] elements = in.readLine().split(\" \");\n\t\t  N = Integer.parseInt(elements[0]);\n\t\t  M = Integer.parseInt(elements[1]);\n\t\t  L = Integer.parseInt(elements[2]);\n\t\t  if(N == 0 && M == 0 && L == 0)\n\t\t      break;\n\n\t\t  \n\n\t\t  used = new int[N+1][L+1];\n\t\t  list = new ArrayList[N+2];\n\n\t\t  for(int i=0;i<N+1;i++)\n\t\t      for(int j=0;j<L+1;j++)\n\t\t\t  used[i][j] = INF;\n\n\t\t  for(int i=0;i<N+1;i++)\n\t\t      list[i] = new ArrayList<Pox>();\n\t\t  \n\t\t  for(int i=0;i<M;i++)\n\t\t      {\n\t\t\t elements = in.readLine().split(\" \");\n\t\t\t int A,B,D,E;\n\t\t\t  A = Integer.parseInt(elements[0]);\n\t\t\t  B = Integer.parseInt(elements[1]);\n\t\t\t  D = Integer.parseInt(elements[2]);\n\t\t\t  E = Integer.parseInt(elements[3]);\n\n\t\t\t  list[A].add(new Pox(B,D,E));  \n\t\t\t  list[B].add(new Pox(A,D,E));\n\t\t      }\n\n\t\t  Queue<Eleac> que = new PriorityQueue<Eleac>();\n\n\t\t  que.offer(new Eleac(1,L,0)); //Eleac(id,money,the number of eemy)\n\t\t  used[1][L] = 0;\t\t\n\n\t\t  int men = INF;\n\t\t  while(que.size() > 0)\n\t\t      {\n\t\t\t  Eleac p = que.poll(); \n\t\t\t  int now = p.id;\n\t\t\t  int money = p.L;\n\t\t\t  int val = p.num;\n\t\t\t  \n\t\t\t  if(now == N)\n\t\t\t      {\n\t\t\t\t  used[now][money] = Math.min(used[now][money],val);\t\n\t\t\t\t  continue;\n\t\t\t      }\n\t\t      \n\t\t\t \n\t\t\t  for(int i=0;i<list[now].size();i++)\n\t\t\t      {\n\t\t\t\t  int need = list[now].get(i).D;\n\n\t\t\t\t  int new_pos = list[now].get(i).B;\n\t\t\t\t  int the_number = list[now].get(i).E;\n\t\t\t\t  \n\t\t\t\t  if(money-need >= 0 && used[new_pos][money-need] > val)\n\t\t\t\t      {\n\t\t\t\t\t  used[new_pos][money-need] = val;\n\t\t\t\t\t  que.add(new Eleac(new_pos,money-need,val));\n\t\t\t\t      }\t\t\t\t  \t\n\t\t\t\t  if(used[new_pos][money] > val+the_number)\n\t\t\t\t      {\n\t\t\t\t\t  used[new_pos][money] = val+the_number;\n\t\t\t\t\t  que.add(new Eleac(new_pos,money,val+the_number));\n\t\t\t\t      }\n\n\t\t\t      }\n\n\t\t      \n\t\t      }\n\n\t\t  for(int i=0;i<=L;i++)\n\t\t      {\n\t\t\t  men = Math.min(men,used[N][i]);\n\t\t      }\n\t\t  System.out.println(men);\n\t      }\n      }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tAOJ2151 obj = new AOJ2151();\n\t\twhile(true){\n\t\t\tint n = in.nextInt(),m = in.nextInt(),l = in.nextInt();\n\t\t\tif(n+m+l==0)break;\n\t\t\tnew AOJ2151().doIt(n, m, l);\n\t\t}\n\t}\n\tclass AOJ2151{\n\t\tint n,m,l;\n\t\tint cost[][];\n\t\tint teki[][];\n\t\tint result;\n\t\tvoid dikstra(int s){\n\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\t\tint[][] kyori = new int[n][l+1];\n\t\t\tint INF = Integer.MAX_VALUE/2;\n\t\t\tfor(int i=0;i<n;i++)Arrays.fill(kyori[i], INF);\n\t\t\tkyori[s][l] = 0;\n\t\t\tq.add(new State(s, l, 0));\n\t\t\twhile(q.size()>0){\n//\t\t\t\tif(q.size()>1000000){\n//\t\t\t\t\tSystem.out.println(\"*\");return;\n//\t\t\t\t}\n\t\t\t\tState now = q.remove();\n//\t\t\t\tSystem.out.println(now);\n\t\t\t\tint v = now.v;\n\t\t\t\tif(v==n-1){\n\t\t\t\t\tresult = now.teki;return;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<n;i++)if(cost[i][v]>0){\n\t\t\t\t\tif(i==v)continue;\n\t\t\t\t\tint t = teki[i][v];\n\t\t\t\t\tif(now.kin < cost[i][v]){//敵の数が超えるとき\n\t\t\t\t\t\tif(kyori[i][now.kin] <= now.teki + t){\n\t\t\t\t\t\t\t//                          System.out.println(i+\" \"+kyori[i][now.kin] +\" \"+ (now.teki+t));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkyori[i][now.kin] = now.teki + t;\n\t\t\t\t\t\tq.add(new State(i, now.kin, now.teki+t));\n\t\t\t\t\t}else{//敵の数が超えない。 どっちもやる。\n\t\t\t\t\t\tint nkin = now.kin - cost[i][v];\n\t\t\t\t\t\tif(kyori[i][nkin] > now.teki){\n\t\t\t\t\t\t\tkyori[i][nkin] = now.teki;\n\t\t\t\t\t\t\tq.add(new State(i, nkin, now.teki));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(kyori[i][now.kin] > now.teki + teki[i][v]){\n\t\t\t\t\t\t\tkyori[i][now.kin] = now.teki + teki[i][v];\n\t\t\t\t\t\t\tq.add(new State(i, now.kin, now.teki+teki[i][v]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//                  System.out.println(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid doIt(int n,int m,int l){//宿場 道の数 護衛予算(距離1で1円)\n\t\t\tthis.n = n;this.m = m;this.l = l;\n\t\t\tcost = new int[n][n];\n\t\t\tteki = new int[n][n];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint a = in.nextInt()-1;\n\t\t\t\tint b = in.nextInt()-1;\n\t\t\t\tcost[a][b] = cost[b][a] = in.nextInt();\n\t\t\t\tteki[a][b] = teki[b][a] = in.nextInt();\n\t\t\t}\n\t\t\t//          for(int i=0;i<n;i++){\n\t\t\t\t//              for(int s=0;s<n;s++)System.out.print(cost[i][s]+\" \");\n\t\t\t//              System.out.println();\n\t\t\t//          }\n\t\t\tdikstra(0);\n//\t\t\tSystem.out.print(\"ans=\");\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tclass State implements Comparable<State>{\n\t\t\tint kin,v,teki;\n\t\t\tpublic State(int v,int kin,int teki) {\n\t\t\t\tthis.v = v;\n\t\t\t\tthis.kin = kin;\n\t\t\t\tthis.teki = teki;\n\t\t\t}\n\t\t\tpublic int compareTo(State o){\n\t\t\t\tif(this.teki<o.teki)return -1;\n\t\t\t\telse if(this.teki > o.teki)return 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpublic String toString(){\n\t\t\t\treturn v+\" \"+kin+\" \"+teki;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\t\n\tint inns, roads, money;\n\tint[][] charge, enemy;\n\t\n\tboolean[][] v;\n\t\n\tint dijkstra() {\n\t\tv = new boolean[inns + 1][money + 1];\n\t\t// {from, distance, enemy}\n\t\tQueue<int[]> que = new PriorityQueue<int[]>(1, new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] arg0, int[] arg1) {\n\t\t\t\treturn arg0[2] - arg1[2];\n\t\t\t}\n\t\t});\n\t\tque.offer(new int[]{1, money, 0});\n\t\twhile (!que.isEmpty()) {\n\t\t\tint[] p = que.poll();\n\t\t\tint from = p[0], currentMoney = p[1], attacks = p[2];\n\t\t\t\n\t\t\t// ゴールに到達した場合、それが最小の襲われる人数になっている。\n\t\t\tif (from == inns) {\n\t\t\t\treturn attacks;\n\t\t\t}\n\t\t\t\n\t\t\t// PriorityQueueなので最初に見たものが最小の襲われる人数になっている。だから読み飛ばして良い。\n\t\t\tif (v[from][currentMoney]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv[from][currentMoney] = true;\n\t\t\t\n\t\t\tfor (int to = 1; to <= inns; to++) {\n\t\t\t\tif (charge[from][to] == 0) continue;\n\t\t\t\tif (charge[from][to] <= currentMoney) {\n\t\t\t\t\t// お金が足りたら襲われなくて済むね。しかもこいつは優先順位が高い。\n                    que.offer(new int[]{to, currentMoney - charge[from][to], attacks});\n                }\n                que.offer(new int[]{to, currentMoney, enemy[from][to] + attacks});\t\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint solve() {\n\t\treturn dijkstra();\n\t}\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString output = \"\";\n\t\twhile (sc.hasNext()) {\n\t\t\tinns = sc.nextInt();\n\t\t\troads = sc.nextInt();\n\t\t\tmoney = sc.nextInt();\n\t\t\tif (inns == 0 && roads == 0 && money == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tcharge = new int[inns + 1][inns + 1];\n\t\t\t\tenemy = new int[inns + 1][inns + 1];\n\t\t\t\tfor (int i = 0; i < roads; i++) {\n\t\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\t\tint d = sc.nextInt(), e = sc.nextInt();\n\t\t\t\t\tcharge[a][b] = d;\n\t\t\t\t\tcharge[b][a] = d;\n\t\t\t\t\tenemy[a][b] = e;\n\t\t\t\t\tenemy[b][a] = e;\n\t\t\t\t}\n\t\t\t\toutput += solve() + \"\\n\";\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t\tSystem.out.println(output);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] arg) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tint L = sc.nextInt();\n\t\t\tint[][] d = new int[N][N];\n\t\t\tint[][] e = new int[N][N];\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tint A = sc.nextInt() - 1;\n\t\t\t\tint B = sc.nextInt() - 1;\n\t\t\t\tint D = sc.nextInt();\n\t\t\t\td[A][B] = d[B][A] = D;\n\t\t\t\tint E = sc.nextInt();\n\t\t\t\te[A][B] = e[B][A] = E;\n\t\t\t}\n\t\t\tboolean[][] visited = new boolean[N][L + 1];\n\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\t\tq.add(new State(0, L, 0));\n\t\t\twhile (true) {\n\t\t\t\tState cur = q.poll();\n\t\t\t\tif (visited[cur.p][cur.m]) continue;\n\t\t\t\tvisited[cur.p][cur.m] = true;\n\t\t\t\tif (cur.p == N - 1) {\n\t\t\t\t\tSystem.out.println(cur.e);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tif (d[cur.p][i] == 0) continue;\n\t\t\t\t\tif (!visited[i][cur.m]) {\n\t\t\t\t\t\tq.add(new State(i, cur.m, cur.e + e[cur.p][i]));\n\t\t\t\t\t}\n\t\t\t\t\tif (d[cur.p][i] <= cur.m && !visited[i][cur.m - d[cur.p][i]]) {\n\t\t\t\t\t\tq.add(new State(i, cur.m - d[cur.p][i], cur.e));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class State implements Comparable<State> {\n\t\tint p, m, e;\n\n\t\tpublic State(int p, int m, int e) {\n\t\t\tthis.p = p;\n\t\t\tthis.m = m;\n\t\t\tthis.e = e;\n\t\t}\n\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.e - o.e;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = Integer.MAX_VALUE;\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif(n == 0 && m == 0 && l == 0) break;\n\t\t\tint [][] pass = new int[n][n];\n\t\t\tint [][] money = new int[n][n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tArrays.fill(money[i], INF);\n\t\t\t}\n\t\t\tfor(int i = 0;i < m; i++){\n\t\t\t\tint from = sc.nextInt() - 1;\n\t\t\t\tint to = sc.nextInt() -1 ;\n\t\t\t\tint dis = sc.nextInt();\n\t\t\t\tint num = sc.nextInt();\n\t\t\t\tpass[from][to] = num;\n\t\t\t\tpass[to][from] = num;\n\t\t\t\tmoney[from][to] = dis;\n\t\t\t\tmoney[to][from] = dis;\n\t\t\t}\n\t\t\tPriorityQueue<C> open = new PriorityQueue<C>();\n\t\t\topen.add(new C(0,l,0));\n\t\t\tint [][] close = new int[n][l+1];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < l + 1; j++){\n\t\t\t\t\tclose[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose[0][l] = 0;\n\t\t\tint ans = INF;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\tint from = now.now;\n\t\t\t\t//goal\n\t\t\t\tif(from == n-1){\n\t\t\t\t\tans = Math.min(ans, now.num);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i= 0; i < n; i++){\n\t\t\t\t\tif(pass[from][i] == INF){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//use\n\t\t\t\t\tint nextnum = now.num + pass[from][i];\n\t\t\t\t\tif(now.money >= money[from][i]){\n\t\t\t\t\t\tint nextmoney = now.money - money[from][i];\n\t\t\t\t\t\tif(close[i][nextmoney] <= now.num) continue;\n\t\t\t\t\t\topen.add(new C(i, nextmoney, now.num));\n\t\t\t\t\t\tclose[i][nextmoney] = now.num;\n\t\t\t\t\t}\n\t\t\t\t\t//not use\n\t\t\t\t\tif(close[i][now.money] <= nextnum) continue;\n\t\t\t\t\topen.add(new C(i, now.money, nextnum));\n\t\t\t\t\tclose[i][now.money] = nextnum; \n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate class C implements Comparable<C>{\n\t\tint now,money,num;\n\t\t\n\t\tpublic C(int now, int money, int num) {\n\t\t\tthis.now = now;\n\t\t\tthis.money = money;\n\t\t\tthis.num = num;\n\t\t}\n\n\t\tpublic int compareTo(C o) {\n\t\t\tif(num < o.num) return -1;\n\t\t\tif(num > o.num) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t{\n\t\t\tarray[i++] = r;\n\t\t}\n\t\treturn array;\n\t}\n}\n\npublic class Edge\n{\n\tpublic int to1 { get; set; }\n\tpublic int to2 { get; set; }\n\tpublic int d { get; set; }\n}\npublic class Node : IComparable\n{\n\tpublic int id1 { get; set; }\n\tpublic int id2 { get; set; }\n\tpublic int d { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (Node)obj;\n\t\tif (this.d > x.d) return 1;\n\t\telse if (this.d == x.d) return 0;\n\t\telse return -1;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void goDijk(List<Edge>[,] aa, int r1, int r2, int[,] mind)\n\t{\n\t\tvar pq = new PriorityQueue<Node>(20000, 0);\n\t\tpq.Push(new Node { id1 = r1, id2 = r2, d = 0 });\n\t\twhile (pq.Count() > 0)\n\t\t{\n\t\t\tvar targ = pq.Pop();\n\t\t\tvar nowd = targ.d;\n\t\t\tvar nowid1 = targ.id1;\n\t\t\tvar nowid2 = targ.id2;\n\t\t\tif (mind[nowid1, nowid2] < nowd) continue;\n\t\t\tmind[nowid1, nowid2] = nowd;\n\t\t\tforeach (var x in aa[nowid1, nowid2])\n\t\t\t\tif (nowd + x.d < mind[x.to1, x.to2])\n\t\t\t\t{\n\t\t\t\t\tmind[x.to1, x.to2] = nowd + x.d;\n\t\t\t\t\tpq.Push(new Node { id1 = x.to1, id2 = x.to2, d = nowd + x.d });\n\t\t\t\t}\n\t\t}\n\t}\n\n\tpublic const int BIG = 9999999;\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tvar n = int.Parse(line[0]);\n\t\t\tvar m = int.Parse(line[1]);\n\t\t\tvar L = int.Parse(line[2]);\n\t\t\tif (n == 0 && m == 0 && L == 0) break;\n\t\t\tvar aa = setEdge(n, m, L);\n\t\t\tvar mind = new int[n, L + 1];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < L + 1; j++) mind[i, j] = BIG;\n\t\t\tgoDijk(aa, 0, L, mind);\n\t\t\tprint(mind, n, L);\n\t\t}\n\t}\n\tstatic void print(int[,] mind, int n, int L)\n\t{\n\t\tvar ans = int.MaxValue;\n\t\tfor (int i = 0; i < L + 1; i++)\n\t\t\tans = Min(ans, mind[n - 1, i]);\n\t\tConsole.WriteLine(ans);\n\t}\n\tstatic List<Edge>[,] setEdge(int n, int m, int L)\n\t{\n\t\tvar aa = new List<Edge>[n, L + 1];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < L + 1; j++) aa[i, j] = new List<Edge>();\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tvar a = int.Parse(line[0]) - 1;\n\t\t\tvar b = int.Parse(line[1]) - 1;\n\t\t\tvar d = int.Parse(line[2]);\n\t\t\tvar e = int.Parse(line[3]);\n\t\t\tfor (int j = 0; j <= L; j++)\n\t\t\t{\n\t\t\t\taa[a, j].Add(new Edge { to1 = b, to2 = j, d = e });\n\t\t\t\taa[b, j].Add(new Edge { to1 = a, to2 = j, d = e });\n\t\t\t}\n\t\t\tfor (int j = d; j <= L; j++)\n\t\t\t{\n\t\t\t\taa[a, j].Add(new Edge { to1 = b, to2 = j - d, d = 0 });\n\t\t\t\taa[b, j].Add(new Edge { to1 = a, to2 = j - d, d = 0 });\n\t\t\t}\n\t\t}\n\t\treturn aa;\n\t}\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "def dijkstra(n, l, pos, route, cost_e, cost_d)\n  visit = (n+1).times.map{ [0] * (n+1) }\n\n  q = []\n  q << [pos, l, 0]\n  until q.empty?\n    p = q.min{ |x, y| x[2] <=> y[2] }\n    q.delete(p)\n    s, r, e = p\n    return e if s == n\n    route[s].each do |t|\n      next if visit[s][t] >= 2\n      visit[s][t] += 1\n      q << [t, r, e + cost_e[s][t]]\n      if r >= cost_d[s][t]\n        q << [t, r - cost_d[s][t], e]\n      end\n    end\n  end\nend\nloop do\n  n, m, l = gets.split.map(&:to_i)\n  break if n == 0\n  route = (n+1).times.map{ [] }\n  cost_d = (n+1).times.map{ [0] * (n+1) }\n  cost_e = (n+1).times.map{ [0] * (n+1) }\n  m.times.map do\n    s, t, d, e = gets.split.map(&:to_i)\n    route[s] << t\n    route[t] << s\n    cost_d[s][t] = cost_d[t][s] = d\n    cost_e[s][t] = cost_e[t][s] = e\n  end\n  p dijkstra(n, l, 1, route, cost_e, cost_d)\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\ndef dijkstra(n, l, pos, route, cost_e, cost_d)\n  q = []\n  q << [pos, l, 0]\n  e_min = [INF]*(n+1)\n  e_min[pos] = 0\n  until q.empty?\n    p = q.min{ |x, y| e_min[x[0]] <=> e_min[y[0]] }\n    q.delete(p)\n    s, r, e = p\n    route[s].each do |t|\n      enemy = e + cost_e[s][t] \n      if e_min[t] > e\n        e_min[t] = enemy if e_min[t] > enemy\n        if r >= cost_d[s][t]\n          q << [t, r - cost_d[s][t], e]\n          e_min[t] = e\n        end\n        q << [t, r, enemy]\n      end\n    end\n  end\n  e_min[n]\nend\nloop do\n  n, m, l = gets.split.map(&:to_i)\n  break if n == 0\n  route = (n+1).times.map{ [] }\n  cost_d = (n+1).times.map{ [0] * (n+1) }\n  cost_e = (n+1).times.map{ [0] * (n+1) }\n  m.times.map do\n    s, t, d, e = gets.split.map(&:to_i)\n    route[s] << t\n    route[t] << s\n    cost_e[s][t] = cost_e[t][s] = e\n    cost_d[s][t] = cost_d[t][s] = d\n  end\n  p dijkstra(n, l, 1, route, cost_e, cost_d)\nend"
  },
  {
    "language": "Ruby",
    "code": "def dijkstra(n, l, pos, route, cost_e, cost_d)\n  done = (n+1).times.map{ [false] * (l+1) }\n  q = []\n  q << [pos, l, 0]\n  until q.empty?\n    p = q.min{ |x, y| x[2] <=> y[2] }\n    q.delete(p)\n    s, r, e = p\n    return e if s == n\n    unless done[s][r]\n      done[s][r] = true\n      route[s].each do |t|\n        q << [t, r, e + cost_e[s][t]]\n        if r >= cost_d[s][t]\n          q << [t, r - cost_d[s][t], e]\n        end\n      end\n    end\n  end\nend\nloop do\n  n, m, l = gets.split.map(&:to_i)\n  break if n == 0\n  route = (n+1).times.map{ [] }\n  cost_d = (n+1).times.map{ [0] * (n+1) }\n  cost_e = (n+1).times.map{ [0] * (n+1) }\n  m.times.map do\n    s, t, d, e = gets.split.map(&:to_i)\n    route[s] << t\n    route[t] << s\n    cost_d[s][t] = cost_d[t][s] = d\n    cost_e[s][t] = cost_e[t][s] = e\n  end\n  p dijkstra(n, l, 1, route, cost_e, cost_d)\nend"
  },
  {
    "language": "Ruby",
    "code": "def minHeapify(x)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    minHeapify(minimum)\n  end\nend\n \ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  minHeapify(1)\n  key\nend\n \ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef dijkstra(n, l, route, cost_d, cost_e)\n  done = (n+1).times.map{ [false] * (l+1) }\n  while true\n    e, s, r = extract\n    return e if s == n\n    next if done[s][r]\n    done[s][r] = true\n    route[s].each do |t|\n      insert([e + cost_e[s][t], t, r])\n      insert([e, t, r - cost_d[s][t]]) if r >= cost_d[s][t]\n    end\n  end\nend\n\nloop do\n  n, m, l = gets.split.map(&:to_i)\n  break if n == 0\n  $heap = []\n  $n = 0\n  route = (n+1).times.map{ [] }\n  cost_d = (n+1).times.map{ [0] * (n+1) }\n  cost_e = (n+1).times.map{ [0] * (n+1) }\n  m.times.map do\n    s, t, d, e = gets.split.map(&:to_i)\n    route[s] << t\n    route[t] << s\n    cost_d[s][t] = cost_d[t][s] = d\n    cost_e[s][t] = cost_e[t][s] = e\n  end\n  insert([0, 1, l])\n  p dijkstra(n, l, route, cost_d, cost_e)\nend"
  },
  {
    "language": "Ruby",
    "code": "def dijkstra(n, l, pos, route, cost_e, cost_d)\n  visit = (n+1).times.map{ [0] * (n+1) }\n  done = (n+1).times.map{ [false] * (l+1) }\n  q = []\n  q << [pos, l, 0]\n  until q.empty?\n    p = q.min{ |x, y| x[2] <=> y[2] }\n    q.delete(p)\n    s, r, e = p\n    return e if s == n\n    next if done[s][r]\n    done[s][r] = true\n    route[s].each do |t|\n      next if visit[s][t] >= 2\n      visit[s][t] += 1\n      q << [t, r, e + cost_e[s][t]]\n      if r >= cost_d[s][t]\n        q << [t, r - cost_d[s][t], e]\n      end\n    end\n  end\nend\nloop do\n  n, m, l = gets.split.map(&:to_i)\n  break if n == 0\n  route = (n+1).times.map{ [] }\n  cost_d = (n+1).times.map{ [0] * (n+1) }\n  cost_e = (n+1).times.map{ [0] * (n+1) }\n  m.times.map do\n    s, t, d, e = gets.split.map(&:to_i)\n    route[s] << t\n    route[t] << s\n    cost_d[s][t] = cost_d[t][s] = d\n    cost_e[s][t] = cost_e[t][s] = e\n  end\n  p dijkstra(n, l, 1, route, cost_e, cost_d)\nend"
  },
  {
    "language": "Ruby",
    "code": "def minHeapify x\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    minHeapify(minimum)\n  end\nend\n \ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  minHeapify(1)\n  key\nend\n \ndef insert key\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef dijkstra(n, l, pos, route, cost_d, cost_e)\n  done = (n+1).times.map{ [false] * (l+1) }\n  while true\n    p = extract\n    e, s, r = p\n    return e if s == n\n    next if done[s][r]\n    done[s][r] = true\n    route[s].each do |t|\n      insert [e + cost_e[s][t], t, r]\n      if r >= cost_d[s][t]\n        insert [e, t, r - cost_d[s][t]]\n      end\n    end\n  end\nend\n\nloop do\n  n, m, l = gets.split.map(&:to_i)\n  break if n == 0\n  $heap = []\n  $n = 0\n  route = (n+1).times.map{ [] }\n  cost_d = (n+1).times.map{ [0] * (n+1) }\n  cost_e = (n+1).times.map{ [0] * (n+1) }\n  m.times.map do\n    s, t, d, e = gets.split.map(&:to_i)\n    route[s] << t\n    route[t] << s\n    cost_d[s][t] = cost_d[t][s] = d\n    cost_e[s][t] = cost_e[t][s] = e\n  end\n  insert [0, 1, l]\n  p dijkstra(n, l, 1, route, cost_d, cost_e)\nend"
  },
  {
    "language": "Ruby",
    "code": "def minHeapify(x)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    minHeapify(minimum)\n  end\nend\n \ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  minHeapify(1)\n  key\nend\n \ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef dijkstra(n, l)\n  done = (n+1).times.map{ [false] * (l+1) }\n  while true\n    e, s, r = extract\n    return e if s == n\n    next if done[s][r]\n    done[s][r] = true\n    $route[s].each do |t|\n      insert([e + $enemy[s][t], t, r])\n      insert([e, t, r - $dist[s][t]]) if r >= $dist[s][t]\n    end\n  end\nend\n\nloop do\n  n, m, l = gets.split.map(&:to_i)\n  break if n == 0\n  $heap = []\n  $n = 0\n  $route = (n+1).times.map{ [] }\n  $dist = (n+1).times.map{ [0] * (n+1) }\n  $enemy = (n+1).times.map{ [0] * (n+1) }\n  m.times.map do\n    s, t, d, e = gets.split.map(&:to_i)\n    $route[s] << t\n    $route[t] << s\n    $dist[s][t] = $dist[t][s] = d\n    $enemy[s][t] = $enemy[t][s] = e\n  end\n  insert([0, 1, l])\n  p dijkstra(n, l)\nend"
  },
  {
    "language": "Ruby",
    "code": "def minHeapify x\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    minHeapify(minimum)\n  end\nend\n \ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  minHeapify(1)\n  key\nend\n \ndef insert key\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef dijkstra(n, l, route, cost_d, cost_e)\n  done = (n+1).times.map{ [false] * (l+1) }\n  while true\n    p = extract\n    e, s, r = p\n    return e if s == n\n    next if done[s][r]\n    done[s][r] = true\n    route[s].each do |t|\n      insert [e + cost_e[s][t], t, r]\n      if r >= cost_d[s][t]\n        insert [e, t, r - cost_d[s][t]]\n      end\n    end\n  end\nend\n\nloop do\n  n, m, l = gets.split.map(&:to_i)\n  break if n == 0\n  $heap = []\n  $n = 0\n  route = (n+1).times.map{ [] }\n  cost_d = (n+1).times.map{ [0] * (n+1) }\n  cost_e = (n+1).times.map{ [0] * (n+1) }\n  m.times.map do\n    s, t, d, e = gets.split.map(&:to_i)\n    route[s] << t\n    route[t] << s\n    cost_d[s][t] = cost_d[t][s] = d\n    cost_e[s][t] = cost_e[t][s] = e\n  end\n  insert [0, 1, l]\n  p dijkstra(n, l, route, cost_d, cost_e)\nend"
  },
  {
    "language": "Ruby",
    "code": "def minHeapify(x)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    minHeapify(minimum)\n  end\nend\n \ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  minHeapify(1)\n  key\nend\n \ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef dijkstra(n, l, route, cost_d, cost_e)\n  done = (n+1).times.map{ [false] * (l+1) }\n  while true\n    e, s, r = extract\n    return e if s == n\n    next if done[s][r]\n    done[s][r] = true\n    route[s].each do |t|\n      insert([e + cost_e[s][t], t, r])\n      if r >= cost_d[s][t]\n        insert([e, t, r - cost_d[s][t]])\n      end\n    end\n  end\nend\n\nloop do\n  n, m, l = gets.split.map(&:to_i)\n  break if n == 0\n  $heap = []\n  $n = 0\n  route = (n+1).times.map{ [] }\n  cost_d = (n+1).times.map{ [0] * (n+1) }\n  cost_e = (n+1).times.map{ [0] * (n+1) }\n  m.times.map do\n    s, t, d, e = gets.split.map(&:to_i)\n    route[s] << t\n    route[t] << s\n    cost_d[s][t] = cost_d[t][s] = d\n    cost_e[s][t] = cost_e[t][s] = e\n  end\n  insert([0, 1, l])\n  p dijkstra(n, l, route, cost_d, cost_e)\nend"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nloop {\n\tn, m, l = gets.split.map &:to_i\n\tbreak if n == 0\n\n\tg = Graph.new\n\tnodes = (0..n).map{ g.add_node }\n\n\tm.times {\n\t\ta, b, d, e = gets.split.map &:to_i\n\t\tg.add_edge(nodes[a], nodes[b], {:length => d, :enemy => e})\n\t}\n\n\textend Graphical\n\tdef each_out_connection_of(node)\n\t\tu, budget = node\n\t\tu.each_edge{|e|\n\t\t\tv = e.opposite[u]\n\t\t\tcost = e.property[:length]\n\t\t\tyield([v, budget - cost], 0) if budget >= cost\n\t\t\tyield([v, budget], e.property[:enemy])\t\n\t\t}\n\tend\n\n\tp dijkstra([[nodes[1], l]]){|node, _|\n\t\tv, budget = node\n\t\tv == nodes[n]\n\t}\n}"
  },
  {
    "language": "PHP",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\n#define rep(X,Y) for(int (X)=0;(X)<(Y);++(X))\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define pb push_back\n\nusing namespace std;\n\nstruct edge {int to, cost, pp;};\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PIP;\n\n#define MAX_V 101\n#define MAX_L 101\n#define INF 1000000000\n\nvector<edge> G[MAX_V];\nint d[MAX_L][MAX_V];\n\nint l,n,m;\n\n\nvoid dij(){\n\tpriority_queue<PIP, vector<PIP>, greater<PIP> > q;\n\t\n\td[l][0] = 0;\n\tq.push(PIP(0,P(l,0)));\n\twhile(!q.empty()){\n\t\tPIP p = q.top();q.pop();\n\t\tint ll = p.second.first;\n\t\tint v = p.second.second;\n\t\tif(ll < 0)continue;\n\t\tif(d[ll][v] < p.first)continue;\n\t\t\n\t\trep(i,G[v].size()){\n\t\t\tedge e = G[v][i];\n\t\t\tif( ll-e.cost < 0)continue;\n\t\t\tif(d[ll-e.cost][e.to] > d[ll][v] + e.pp ){\n\t\t\t\td[ll-e.cost][e.to] = d[ll][v] + e.pp;\n\t\t\t\tq.push(PIP(d[ll-e.cost][e.to],P(ll-e.cost,e.to)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid init(){\n\tl = n = m = 0;\n\trep(i,101)G[i].clear();\n\trep(i,101)rep(j,101)d[i][j] = INF;\n}\n\n\t\n\n\nint main(){\n\twhile(1){\n\t\tint ans = INF;\n\t\tinit();\n\t\tcin >> n >> m >> l;\n\t\tif(!l)break;\n\t\trep(i,m){\n\t\tint a,b,d,e;\n\t\t\tcin >> a >> b >> d >> e;\n\t\t\tG[a].push_back((edge){a,d,e});\n\t\t\tG[b].push_back((edge){a,d,e});\n\t\t}\n\t\tdij();\n\t\trep(i,l+1){\n\t\t\tcout << d[i][n] << endl;\n\t\t\tans = min(ans, d[i][n]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef inpl(): return list(map(int, input().split()))\nN, M, L = inpl()\n\nwhile N:\n    G = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b, d, e = inpl()\n        G[a].append([b, d, e])\n        G[b].append([a, d, e])\n\n    Q = [[0, 0, 1]] # bandits, distance, where\n    visited = defaultdict(lambda : False)\n    visited[(0, 0, 1)] = True\n    \n    while Q:\n        e, d, p = heappop(Q)\n        if p == N:\n            print(e)\n            break\n        for q, dd, de in G[p]:\n            if d + dd <= L and not visited[(e, d+dd, q)]:\n                heappush(Q, (e, d+dd, q))\n                visited[(e, d+dd, q)] = True\n            if not visited[(e+de, d, q)]:\n                heappush(Q, (e+de, d, q))\n                visited[(e+de, d, q)] = True\n    N, M, L = inpl()\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nwhile True:\n  n,m,l=map(int,raw_input().split())\n  if n==0: break\n  v={}\n  for i in xrange(n):\n    v[i] = []                                                                                                                                    # count attacked\n  cost=[[10**9]*(l+1) for _ in xrange(n)]\n  cost[0][l] = 0\n  for _ in xrange(m):\n    a,b,d,e=map(int,raw_input().split())\n    a-=1\n    b-=1\n    v[a].append((b,d,e))\n    v[b].append((a,d,e))\n  q=[]\n  heapq.heappush(q,(0,l))\n  while len(q)>0:\n    t = heapq.heappop(q)\n    for x in v[t[0]]:\n      # hit\n      if cost[x[0]][t[1]] > cost[t[0]][t[1]]+x[2]:\n        cost[x[0]][t[1]] = cost[t[0]][t[1]]+x[2]\n        q.append((x[0], t[1]))\n      # guard\n      if t[1]-x[1]>=0 and cost[x[0]][t[1]-x[1]] > cost[t[0]][t[1]]:\n        cost[x[0]][t[1]-x[1]] = cost[t[0]][t[1]]\n        q.append((x[0], t[1]-x[1]))\n  print min(cost[n-1])"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nINF = 10 ** 20\n\nwhile True:\n  n, m, l = map(int, input().split())\n  if n == 0:\n    break\n  edges = [[] for _ in range(n * (l + 1))]\n  for _ in range(m):\n    a, b, d, e = map(int, input().split())\n    a -= 1\n    b -= 1\n    for i in range(d, l + 1):\n      edges[i * n + a].append((0, (i - d) * n + b))\n      edges[i * n + b].append((0, (i - d) * n + a))\n    for i in range(l + 1):\n      edges[i * n + a].append((e, i * n + b))\n      edges[i * n + b].append((e, i * n + a))\n  \n  que = []\n  heappush(que, (0, l * n))\n  costs = [INF] * (n * (l + 1))\n  costs[l * n] = 0\n  while que:\n    total, node = heappop(que)\n    for enemy, to in edges[node]:\n      if costs[to] > total + enemy:\n        costs[to] = total + enemy\n        heappush(que, (total + enemy, to))\n\n  ans = min(costs[i * n + n - 1] for i in range(l + 1))\n  print(ans)\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef inpl(): return list(map(int, input().split()))\nN, M, L = inpl()\n\nwhile N:\n    G = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b, d, e = inpl()\n        G[a].append([b, d, e])\n        G[b].append([a, d, e])\n\n    Q = [[0, 0, 1]] # bandits, distance, where\n    cost = [[10**6]*(L+1) for _ in range(N+1)]\n    cost[1][0] = 0\n    while Q:\n        e, d, p = heappop(Q)\n        if cost[p][d] < e:\n            continue\n        if p == N:\n            print(e)\n            break\n        for q, dd, de in G[p]:\n            if d + dd <= L and e < cost[q][d+dd]:\n                heappush(Q, (e, d+dd, q))\n                cost[q][d+dd] = e\n            if e + de < cost[q][d]:\n                heappush(Q, (e+de, d, q))\n                cost[q][d] = e+de\n    N, M, L = inpl()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport heapq\n\nwhile True:\n    N, M, L = map(int, input().split())\n    if N==M==L==0:\n        break\n    E = defaultdict(lambda: defaultdict(lambda: float(\"inf\")))\n    for _ in range(M):\n        A, B, D, E_ = map(int, input().split())\n        E[A][B] = (D, E_)  # 金、コスト\n        E[B][A] = (D, E_)  # 金、コスト\n\n    start = (1, 0)\n\n    dist = defaultdict(lambda: float(\"inf\"))  # 始点から各頂点までの(仮の)最短距離を格納する\n    dist[start] = 0\n    q = []  # 各要素は，(startからある頂点vまでの仮の距離, 頂点vのID)からなるタプル\n    heapq.heappush(q, (0, start))  # 始点をpush\n    while len(q) != 0:\n        prov_cost, v_m = heapq.heappop(q)  # pop  # 一度取り出された時点でコストは確定\n        v, m_v = v_m\n\n        # プライオリティキューに格納されている最短距離が\n        # 現在計算できている最短距離より大きければ，distの更新をする必要はない\n        if dist[v] < prov_cost:\n            continue\n\n        if v==N:\n            print(prov_cost)\n            break\n\n        # 辺を探索\n        Us = {}\n        for u, (m, c) in E[v].items():\n            Us[(u, m_v)] = c\n            if m_v+m <= L:\n                Us[(u, m_v+m)] = 0\n\n        for u_m, c in Us.items():\n            if dist[u_m] > dist[v_m] + c:\n                dist[u_m] = dist[v_m] + c  # distの更新\n                heapq.heappush(q, (dist[u_m], u_m))  # キューに新たな仮の距離の情報をpush\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nimport sys\ndef solve(readline=sys.stdin.readline, write=sys.stdout.write):\n    N, M, L = map(int, readline().split())\n    if N == 0:\n        return 0\n    G = [[] for i in range(N)]\n    for i in range(M):\n        a, b, d, e = map(int, readline().split())\n        a -= 1; b -= 1\n        G[a].append((b, d, e))\n        G[b].append((a, d, e))\n\n    INF = 10**9\n    cost = [[INF]*(L+1) for i in range(N)]\n    que = [(0, 0, 0)]\n    cost[0][0] = 0\n    while que:\n        c, v, l = heappop(que)\n        dv = cost[v][l]\n        if c < dv:\n            continue\n        if v == N-1:\n            break\n        for w, d, e in G[v]:\n            cw = cost[w]\n            if l + d <= L and dv < cw[l + d]:\n                cw[l + d] = dv\n                heappush(que, (dv, w, l+d))\n            if dv + e < cw[l]:\n                cw[l] = dv + e\n                heappush(que, (dv + e, w, l))\n    write(\"%d\\n\" % min(cost[N-1]))\n    return 1\n\nwhile solve():\n    ...\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n\n    def f(n,m,l):\n        e = collections.defaultdict(list)\n        for _ in range(m):\n            a,b,x,y = LI()\n            e[a].append((b,x,y))\n            e[b].append((a,x,y))\n\n        d = collections.defaultdict(lambda: inf)\n        d[(1, 0)] = 0\n        q = []\n        heapq.heappush(q, (0, 0, 1))\n        v = collections.defaultdict(bool)\n        mi = inf\n        while len(q):\n            c, k, u = heapq.heappop(q)\n            if v[(u,k)]:\n                continue\n            v[(u,k)] = True\n            if u == n and mi > c:\n                mi = c\n\n            for uv, ud, ue in e[u]:\n                vk = k + ud\n                vv = (uv, vk)\n                if not v[vv] and vk <= l:\n                    vd = c\n                    if d[vv] > vd:\n                        d[vv] = vd\n                        heapq.heappush(q, (vd, vk, uv))\n                vv = (uv, k)\n                if not v[vv]:\n                    vd = c + ue\n                    if d[vv] > vd:\n                        d[vv] = vd\n                        heapq.heappush(q, (vd, k, uv))\n\n\n        return mi\n\n    while True:\n        n,m,l = LI()\n        if n == 0 and m == 0:\n            break\n        rr.append(f(n,m,l))\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\nimport heapq\nclass DijkstraList():\n\t#隣接リスト版\n\t#同一頂点の複数回探索を防ぐため訪問した頂点数を変数cntで持つ\n\tdef __init__(self, adj, start):\n\t\tself.list = adj\n\t\tself.start = start\n\t\tself.size = len(adj)\n\n\tdef solve(self):\n\t\tself.dist = [10**30 for _ in range(self.size)]\n\t\tself.dist[self.start] = 0\n\t\tself.q = []\n\t\tself.cnt = 0\n\n\t\theapq.heappush(self.q, (0, self.start))\n\n\t\twhile self.q and self.cnt < self.size:\n\t\t\tu_dist, u = heapq.heappop(self.q)\n\t\t\tif self.dist[u] < u_dist:\n\t\t\t\tcontinue\n\t\t\tfor v, w in self.list[u]:\n\t\t\t\tif self.dist[v] > u_dist + w:\n\t\t\t\t\tself.dist[v] = u_dist + w\n\t\t\t\t\theapq.heappush(self.q, (self.dist[v], v))\n\t\t\tself.cnt += 1\n\t\treturn\n\n\tdef distance(self, goal):\n\t\treturn self.dist[goal]\n\nwhile True:\n\tn, m, l = map(int, input().split())\n\tif n == 0:\n\t\tbreak\n\tadj = [[] for _ in range(n*(l+1))]\n\tfor _ in range(m):\n\t\ta, b, d, e = map(int, input().split())\n\t\ta, b = a-1, b-1\n\t\tfor i in range(l+1):\n\t\t\tadj[i*n + a].append((i*n + b, e))\n\t\t\tadj[i*n + b].append((i*n + a, e))\n\t\t\tif i >= d:\n\t\t\t\tadj[i*n + a].append(((i-d)*n + b, 0))\n\t\t\t\tadj[i*n + b].append(((i-d)*n + a, 0))\n\n\tdijk = DijkstraList(adj, l*n)\n\tdijk.solve()\n\tans = 10**7\n\tfor i in range(l+1):\n\t\tans = min(ans, dijk.dist[i*n + n-1])\n\tprint(ans)\n"
  }
]