[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n\n#define MOD 998244353\n#define MAX_N 20\n\ntypedef struct {\n    int x, y;\n} Point;\n\nPoint points[MAX_N];\nint n;\n\nint cross_product(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nbool is_convex_polygon(Point* subset, int subset_size) {\n    if (subset_size < 3) return false;\n    \n    for (int i = 0; i < subset_size; i++) {\n        int j = (i + 1) % subset_size;\n        int k = (i + 2) % subset_size;\n        if (cross_product(subset[i], subset[j], subset[k]) < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint points_in_convex_hull(Point* subset, int subset_size) {\n    bool inside[MAX_N] = {false};\n    int hull_points = 0;\n    \n    for (int i = 0; i < n; i++) {\n        bool point_inside = true;\n        for (int j = 0; j < subset_size; j++) {\n            int k = (j + 1) % subset_size;\n            if (cross_product(subset[j], subset[k], points[i]) > 0) {\n                point_inside = false;\n                break;\n            }\n        }\n        if (point_inside) {\n            inside[i] = true;\n            hull_points++;\n        }\n    }\n    \n    for (int i = 0; i < subset_size; i++) {\n        int idx = -1;\n        for (int j = 0; j < n; j++) {\n            if (points[j].x == subset[i].x && points[j].y == subset[i].y) {\n                idx = j;\n                break;\n            }\n        }\n        if (!inside[idx]) {\n            inside[idx] = true;\n            hull_points++;\n        }\n    }\n    \n    return hull_points;\n}\n\nlong long solve() {\n    long long total_score = 0;\n    \n    for (int mask = 0; mask < (1 << n); mask++) {\n        Point subset[MAX_N];\n        int subset_size = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                subset[subset_size++] = points[i];\n            }\n        }\n        \n        if (is_convex_polygon(subset, subset_size)) {\n            int hull_points = points_in_convex_hull(subset, subset_size);\n            total_score += (1LL << (hull_points - subset_size)) % MOD;\n            total_score %= MOD;\n        }\n    }\n    \n    return total_score;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n    \n    printf(\"%lld\\n\", solve());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MOD 998244353\n#define MAXN 200\n\ntypedef struct {\n    int x, y;\n} Point;\n\nPoint points[MAXN];\nint N;\nlong long pow2[MAXN * MAXN];\nlong long dp[MAXN][MAXN];\n\nint cross(const Point *o, const Point *a, const Point *b) {\n    return (a->x - o->x) * (b->y - o->y) - (a->y - o->y) * (b->x - o->x);\n}\n\nint compare(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    int c = cross(&points[0], p1, p2);\n    if (c != 0) return -c;\n    int dx1 = p1->x - points[0].x;\n    int dy1 = p1->y - points[0].y;\n    int dx2 = p2->x - points[0].x;\n    int dy2 = p2->y - points[0].y;\n    return (dx1 * dx1 + dy1 * dy1) - (dx2 * dx2 + dy2 * dy2);\n}\n\nvoid precompute_pow2() {\n    pow2[0] = 1;\n    for (int i = 1; i < MAXN * MAXN; ++i) {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n}\n\nlong long solve() {\n    precompute_pow2();\n    long long total = 0;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            int cnt = 0;\n            for (int k = 0; k < N; ++k) {\n                if (k == i || k == j) continue;\n                if (cross(&points[i], &points[j], &points[k]) == 0) {\n                    cnt++;\n                }\n            }\n            total = (total + pow2[cnt]) % MOD;\n        }\n    }\n\n    total = (pow2[N] - 1 - N - total + MOD) % MOD;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = 0;\n        }\n    }\n\n    Point temp = points[0];\n    for (int i = 1; i < N; ++i) {\n        if (points[i].y < temp.y || (points[i].y == temp.y && points[i].x < temp.x)) {\n            temp = points[i];\n        }\n    }\n    points[0] = temp;\n    qsort(points + 1, N - 1, sizeof(Point), compare);\n\n    for (int i = 1; i < N; ++i) {\n        dp[0][i] = 1;\n    }\n\n    for (int i = 1; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            for (int k = 0; k < i; ++k) {\n                if (cross(&points[k], &points[i], &points[j]) > 0) {\n                    dp[i][j] = (dp[i][j] + dp[k][i]) % MOD;\n                }\n            }\n        }\n    }\n\n    long long convex = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            convex = (convex + dp[i][j]) % MOD;\n        }\n    }\n\n    total = (total - convex + MOD) % MOD;\n    return total;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n    printf(\"%lld\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 23:15:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nstruct Point {\n    int x, y;\n    Point() {}\n    Point(int x, int y) : x(x), y(y) {}\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    long long cross(const Point& p) const { return (long long)x * p.y - (long long)y * p.x; }\n    bool operator<(const Point& p) const { return x < p.x || (x == p.x && y < p.y); }\n};\n\nint mod_pow(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b & 1) res = (long long)res * a % MOD;\n        a = (long long)a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvector<Point> convex_hull(vector<Point> pts) {\n    sort(pts.begin(), pts.end());\n    vector<Point> hull;\n    for (int phase = 0; phase < 2; ++phase) {\n        auto start = hull.size();\n        for (auto& p : pts) {\n            while (hull.size() >= start + 2) {\n                auto a = hull.back() - hull[hull.size() - 2];\n                auto b = p - hull[hull.size() - 2];\n                if (a.cross(b) > 0) break;\n                hull.pop_back();\n            }\n            hull.push_back(p);\n        }\n        hull.pop_back();\n        reverse(pts.begin(), pts.end());\n    }\n    return hull;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    vector<Point> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n\n    vector<vector<Point>> all_subsets;\n    for (int mask = 1; mask < (1 << N); ++mask) {\n        vector<Point> subset;\n        for (int i = 0; i < N; ++i) {\n            if (mask & (1 << i)) {\n                subset.push_back(points[i]);\n            }\n        }\n        if (subset.size() < 3) continue;\n        auto hull = convex_hull(subset);\n        if (hull.size() < 3) continue;\n        all_subsets.push_back(subset);\n    }\n\n    int ans = 0;\n    for (auto& subset : all_subsets) {\n        auto hull = convex_hull(subset);\n        int k = hull.size();\n        int m = subset.size();\n        int inside = 0;\n        for (auto& p : points) {\n            bool on_boundary = false;\n            for (int i = 0; i < k; ++i) {\n                Point a = hull[i];\n                Point b = hull[(i + 1) % k];\n                Point v1 = b - a;\n                Point v2 = p - a;\n                if (v1.cross(v2) == 0) {\n                    if (min(a.x, b.x) <= p.x && p.x <= max(a.x, b.x) &&\n                        min(a.y, b.y) <= p.y && p.y <= max(a.y, b.y)) {\n                        on_boundary = true;\n                        break;\n                    }\n                }\n            }\n            if (on_boundary) continue;\n            bool inside_ch = true;\n            for (int i = 0; i < k; ++i) {\n                Point a = hull[i];\n                Point b = hull[(i + 1) % k];\n                Point v1 = b - a;\n                Point v2 = p - a;\n                if (v1.cross(v2) < 0) {\n                    inside_ch = false;\n                    break;\n                }\n            }\n            if (inside_ch) ++inside;\n        }\n        int n = k + inside;\n        int score = mod_pow(2, n - m);\n        ans = (ans + score) % MOD;\n    }\n\n    cout << ans << '\\n';\n    return 0;\n}",
    "timestamp": "2025-08-05 23:16:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.Point2D;\n\npublic class ConvexPolygonSubsets {\n    static final int MOD = 998244353;\n\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static int cross(Point a, Point b, Point c) {\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    }\n\n    static boolean isConvex(List<Point> points) {\n        int n = points.size();\n        if (n < 3) return false;\n        boolean neg = false, pos = false;\n        for (int i = 0; i < n; i++) {\n            int o = cross(points.get(i), points.get((i+1)%n), points.get((i+2)%n));\n            if (o < 0) neg = true;\n            if (o > 0) pos = true;\n            if (neg && pos) return false;\n        }\n        return true;\n    }\n\n    static int countPointsInConvexHull(List<Point> points, Point[] allPoints) {\n        List<Point> hull = convexHull(points);\n        int count = 0;\n        for (Point p : allPoints) {\n            if (isPointInConvexPolygon(p, hull)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    static List<Point> convexHull(List<Point> points) {\n        if (points.isEmpty()) return new ArrayList<>();\n        points.sort((a, b) -> a.x != b.x ? a.x - b.x : a.y - b.y);\n        List<Point> lower = new ArrayList<>();\n        for (Point p : points) {\n            while (lower.size() >= 2 && cross(lower.get(lower.size()-2), lower.get(lower.size()-1), p) <= 0) {\n                lower.remove(lower.size()-1);\n            }\n            lower.add(p);\n        }\n        List<Point> upper = new ArrayList<>();\n        for (int i = points.size() - 1; i >= 0; i--) {\n            Point p = points.get(i);\n            while (upper.size() >= 2 && cross(upper.get(upper.size()-2), upper.get(upper.size()-1), p) <= 0) {\n                upper.remove(upper.size()-1);\n            }\n            upper.add(p);\n        }\n        lower.remove(lower.size() - 1);\n        lower.addAll(upper);\n        return lower;\n    }\n\n    static boolean isPointInConvexPolygon(Point p, List<Point> polygon) {\n        if (polygon.size() < 3) return false;\n        boolean hasNeg = false, hasPos = false;\n        for (int i = 0; i < polygon.size(); i++) {\n            int o = cross(polygon.get(i), polygon.get((i+1)%polygon.size()), p);\n            if (o < 0) hasNeg = true;\n            if (o > 0) hasPos = true;\n            if (hasNeg && hasPos) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        Point[] points = new Point[N];\n        for (int i = 0; i < N; i++) {\n            points[i] = new Point(sc.nextInt(), sc.nextInt());\n        }\n\n        long total = 0;\n        for (int mask = 1; mask < (1 << N); mask++) {\n            List<Point> subset = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    subset.add(points[i]);\n                }\n            }\n            if (isConvex(subset)) {\n                int n = countPointsInConvexHull(subset, points);\n                int k = subset.size();\n                long score = pow(2, n - k);\n                total = (total + score) % MOD;\n            }\n        }\n        System.out.println(total);\n    }\n\n    static long pow(long a, long b) {\n        long res = 1;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = res * a % MOD;\n            }\n            a = a * a % MOD;\n            b >>= 1;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 23:17:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ConvexPolygonScore {\n    private static final int MOD = 998244353;\n\n    static class Point {\n        long x, y;\n        Point(long x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static long crossProduct(Point p1, Point p2, Point p3) {\n        return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n    }\n\n    static boolean isConvex(List<Point> points) {\n        int n = points.size();\n        if (n < 3) return false;\n\n        int sign = 0;\n        for (int i = 0; i < n; i++) {\n            long cross = crossProduct(points.get(i), points.get((i + 1) % n), points.get((i + 2) % n));\n            if (cross == 0) return false;\n            if (sign == 0) sign = cross > 0 ? 1 : -1;\n            else if ((cross > 0 && sign < 0) || (cross < 0 && sign > 0)) return false;\n        }\n        return true;\n    }\n\n    static List<Point> getConvexHull(List<Point> points) {\n        int n = points.size();\n        if (n <= 3) return points;\n\n        int lowest = 0;\n        for (int i = 1; i < n; i++) {\n            if (points.get(i).y < points.get(lowest).y || \n                (points.get(i).y == points.get(lowest).y && points.get(i).x < points.get(lowest).x)) {\n                lowest = i;\n            }\n        }\n\n        Point start = points.get(lowest);\n        List<Point> hull = new ArrayList<>();\n        hull.add(start);\n\n        while (true) {\n            Point current = hull.get(hull.size() - 1);\n            Point next = points.get(0);\n            for (Point p : points) {\n                long cross = crossProduct(current, next, p);\n                if (cross < 0 || (cross == 0 && distance(current, p) > distance(current, next))) {\n                    next = p;\n                }\n            }\n\n            if (next == start) break;\n            hull.add(next);\n        }\n\n        return hull;\n    }\n\n    static long distance(Point p1, Point p2) {\n        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n    }\n\n    public static int solve(List<Point> points) {\n        int n = points.size();\n        long totalScore = 0;\n\n        for (int mask = 3; mask < (1 << n); mask++) {\n            List<Point> subset = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    subset.add(points.get(i));\n                }\n            }\n\n            if (subset.size() >= 3 && isConvex(subset)) {\n                List<Point> convexHull = getConvexHull(points);\n                int score = pow(2, n - subset.size()) % MOD;\n                totalScore = (totalScore + score) % MOD;\n            }\n        }\n\n        return (int) totalScore;\n    }\n\n    static int pow(int base, int exp) {\n        int result = 1;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = (int)((long)result * base % MOD);\n            }\n            base = (int)((long)base * base % MOD);\n            exp >>= 1;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        List<Point> points = Arrays.asList(\n            new Point(0, 0),\n            new Point(1, 0),\n            new Point(0, 1),\n            new Point(1, 1)\n        );\n        System.out.println(solve(points));\n    }\n}",
    "timestamp": "2025-08-05 23:17:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int MAXN = 20;\n\nstruct Point {\n    long long x, y;\n    Point(long long x = 0, long long y = 0) : x(x), y(y) {}\n    \n    Point operator-(const Point& other) const {\n        return Point(x - other.x, y - other.y);\n    }\n};\n\nlong long cross(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool is_convex_polygon(const vector<Point>& points) {\n    int n = points.size();\n    if (n < 3) return false;\n    \n    bool sign = cross(points[1] - points[0], points[2] - points[1]) > 0;\n    for (int i = 1; i < n; i++) {\n        if (cross(points[(i+1)%n] - points[i], points[(i+2)%n] - points[(i+1)%n]) > 0 != sign) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<Point> compute_convex_hull(vector<Point>& points) {\n    int n = points.size();\n    if (n <= 1) return points;\n    \n    sort(points.begin(), points.end(), [](const Point& a, const Point& b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n    \n    vector<Point> lower, upper;\n    \n    for (const Point& p : points) {\n        while (lower.size() >= 2 && \n               cross(lower.back() - lower[lower.size()-2], p - lower.back()) <= 0) {\n            lower.pop_back();\n        }\n        lower.push_back(p);\n    }\n    \n    for (int i = points.size() - 1; i >= 0; i--) {\n        const Point& p = points[i];\n        while (upper.size() >= 2 && \n               cross(upper.back() - upper[upper.size()-2], p - upper.back()) <= 0) {\n            upper.pop_back();\n        }\n        upper.push_back(p);\n    }\n    \n    lower.pop_back();\n    upper.pop_back();\n    \n    lower.insert(lower.end(), upper.begin(), upper.end());\n    return lower;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<Point> points(N);\n    for (int i = 0; i < N; i++) {\n        cin >> points[i].x >> points[i].y;\n    }\n    \n    long long total_score = 0;\n    \n    for (int mask = 1; mask < (1 << N); mask++) {\n        vector<Point> subset;\n        for (int j = 0; j < N; j++) {\n            if (mask & (1 << j)) {\n                subset.push_back(points[j]);\n            }\n        }\n        \n        if (is_convex_polygon(subset)) {\n            vector<Point> hull = compute_convex_hull(subset);\n            int hull_size = hull.size();\n            \n            set<Point> hull_set(hull.begin(), hull.end());\n            int enclosed_points = 0;\n            \n            for (const Point& p : points) {\n                if (hull_set.count(p)) continue;\n                \n                bool inside = true;\n                for (int i = 0; i < hull_size; i++) {\n                    Point a = hull[i], b = hull[(i+1)%hull_size];\n                    if (cross(b - a, p - a) <= 0) {\n                        inside = false;\n                        break;\n                    }\n                }\n                \n                if (inside) enclosed_points++;\n            }\n            \n            int n = hull_size + enclosed_points;\n            long long score = 1LL << (n - subset.size());\n            total_score = (total_score + score) % MOD;\n        }\n    }\n    \n    cout << total_score << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\nfrom scipy.spatial import ConvexHull\n\nMODULO = 998244353\n\ndef is_convex(points):\n    try:\n        hull = ConvexHull(points)\n        return len(hull.vertices) == len(points)\n    except Exception:\n        return False\n\ndef score(points, n):\n    try:\n        hull = ConvexHull(points)\n        vertices = hull.vertices\n        boundary_points = set(vertices)\n        for simplex in hull.simplices:\n            boundary_points.update(simplex)\n        return 2 ** (n - len(boundary_points))\n    except Exception:\n        return 0\n\ndef sum_scores_for_convex_polygons(points):\n    n = len(points)\n    total_score = 0\n    \n    for r in range(3, n + 1):\n        for subset in combinations(points, r):\n            if is_convex(subset):\n                total_score = (total_score + score(subset, n)) % MODULO\n                \n    return total_score\n\n# Example usage\nN = [[0, 0], [1, 0], [0, 1], [1, 1], [1, 2]]\nresult = sum_scores_for_convex_polygons(N)\nprint(result)",
    "timestamp": "2025-08-13 14:20:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class ConvexPolygonSubsets {\n    static final int MOD = 998244353;\n\n    public static int sumOfScores(Point2D[] points) {\n        int n = points.length;\n        int totalScore = 0;\n\n        for (int mask = 1; mask < (1 << n); mask++) {\n            List<Point2D> subset = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    subset.add(points[i]);\n                }\n            }\n            if (isConvex(subset)) {\n                int hullSize = subset.size(); // Convex hull size assumption\n                int score = modPow(2, n - hullSize, MOD);\n                totalScore = (totalScore + score) % MOD;\n            }\n        }\n\n        return totalScore;\n    }\n\n    private static boolean isConvex(List<Point2D> points) {\n        int n = points.size();\n        if (n < 3) return false;\n\n        int sign = 0;\n        for (int i = 0; i < n; i++) {\n            Point2D p = points.get(i);\n            Point2D q = points.get((i + 1) % n);\n            Point2D r = points.get((i + 2) % n);\n\n            double crossProduct = cross(p, q, r);\n            int currentSign = (crossProduct > 0) ? 1 : (crossProduct < 0) ? -1 : 0;\n            if (sign == 0) {\n                sign = currentSign;\n            } else if (currentSign != 0 && sign != currentSign) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private static double cross(Point2D p, Point2D q, Point2D r) {\n        return (q.getX() - p.getX()) * (r.getY() - p.getY()) - (q.getY() - p.getY()) * (r.getX() - p.getX());\n    }\n\n    private static int modPow(int base, int exp, int mod) {\n        long result = 1;\n        long power = base;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = (result * power) % mod;\n            }\n            power = (power * power) % mod;\n            exp >>= 1;\n        }\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Point2D[] points = {\n            new Point2D.Double(0, 0),\n            new Point2D.Double(1, 0),\n            new Point2D.Double(1, 1),\n            new Point2D.Double(0, 1)\n        };\n        System.out.println(sumOfScores(points));\n    }\n}",
    "timestamp": "2025-08-13 14:21:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint comparator(const void *a, const void *b){\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    if (p1->x != p2->x) return p1->x - p2->x;\n    return p1->y - p2->y;\n}\n\nint ccw(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nvoid convexHull(Point points[], int n, Point hull[], int *k) {\n    qsort(points, n, sizeof(Point), comparator);\n    *k = 0;\n    for (int i = 0; i < n; i++) {\n        while (*k >= 2 && ccw(hull[*k - 2], hull[*k - 1], points[i]) <= 0) (*k)--;\n        hull[(*k)++] = points[i];\n    }\n    for (int i = n - 2, t = *k + 1; i >= 0; i--) {\n        while (*k >= t && ccw(hull[*k - 2], hull[*k - 1], points[i]) <= 0) (*k)--;\n        hull[(*k)++] = points[i];\n    }\n    (*k)--;\n}\n\nint insideConvexHull(Point hull[], int hullSize, Point p) {\n    for (int i = 0; i < hullSize; i++) {\n        if (ccw(hull[i], hull[(i+1) % hullSize], p) < 0)\n            return 0;\n    }\n    return 1;\n}\n\nunsigned long long power(unsigned long long base, unsigned long long exp) {\n    unsigned long long result = 1;\n    while (exp) {\n        if (exp % 2) result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nint countInteriorPoints(Point points[], int n, Point hull[], int hullSize) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (insideConvexHull(hull, hullSize, points[i]))\n            count++;\n    }\n    return count;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Point points[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n    unsigned long long sumScores = 0;\n    for (int mask = 1; mask < (1 << N); mask++) {\n        Point subset[N];\n        int subsetSize = 0;\n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                subset[subsetSize++] = points[i];\n            }\n        }\n        if (subsetSize < 3) continue;\n\n        Point hull[N];\n        int hullSize;\n        convexHull(subset, subsetSize, hull, &hullSize);\n\n        int n = countInteriorPoints(points, N, hull, hullSize);\n        unsigned long long score = power(2, n - subsetSize);\n        sumScores = (sumScores + score) % MOD;\n    }\n\n    printf(\"%llu\\n\", sumScores);\n    return 0;\n}",
    "timestamp": "2025-08-13 14:21:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function calculateConvexPolygonScore(points) {\n  const MOD = 998244353;\n  \n  // Helper function to compute cross product for convex check\n  function cross(o, a, b) {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n  }\n  \n  // Helper function to compute convex hull using Andrew's monotone chain algorithm\n  function convexHull(points) {\n    points.sort((a, b) => a.x - b.x || a.y - b.y);\n    \n    let lower = [];\n    for (let p of points) {\n      while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {\n        lower.pop();\n      }\n      lower.push(p);\n    }\n    \n    let upper = [];\n    for (let i = points.length - 1; i >= 0; i--) {\n      let p = points[i];\n      while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {\n        upper.pop();\n      }\n      upper.push(p);\n    }\n    \n    upper.pop();\n    lower.pop();\n    \n    return lower.concat(upper);\n  }\n  \n  // Helper function to check if point is inside a polygon\n  function isPointInsidePolygon(poly, point) {\n    let isInside = false;\n    let n = poly.length;\n    for (let i = 0, j = n - 1; i < n; j = i++) {\n      if (((poly[i].y > point.y) !== (poly[j].y > point.y)) &&\n          (point.x < (poly[j].x - poly[i].x) * (point.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)) {\n        isInside = !isInside;\n      }\n    }\n    return isInside;\n  }\n  \n  // Helper function: calculate score for a given set\n  function scoreOfSet(hullPoints, allPoints) {\n    let n = hullPoints.length;\n    for (let p of allPoints) {\n      if (isPointInsidePolygon(hullPoints, p)) {\n        n++;\n      }\n    }\n    return (1 << (n - hullPoints.length)) % MOD;\n  }\n  \n  // Compute all subsets of points\n  function generateSubsets(points) {\n    let subsets = [];\n    let total = Math.pow(2, points.length);\n    for (let mask = 1; mask < total; mask++) {\n      let subset = [];\n      for (let i = 0; i < points.length; i++) {\n        if (mask & (1 << i)) {\n          subset.push(points[i]);\n        }\n      }\n      subsets.push(subset);\n    }\n    return subsets;\n  }\n  \n  let subsets = generateSubsets(points);\n  let totalScore = 0;\n  \n  for (let subset of subsets) {\n    if (subset.length < 3) continue; // can't form a polygon\n    let hull = convexHull(subset);\n    if (hull.length === subset.length) { // valid convex polygon\n      totalScore = (totalScore + scoreOfSet(hull, points)) % MOD;\n    }\n  }\n  \n  return totalScore;\n}\n\n// Example usage:\nconst points = [\n { x: 0, y: 0 }, \n { x: 1, y: 1 }, \n { x: 2, y: 2 },\n { x: 0, y: 1 }\n];\nconsole.log(calculateConvexPolygonScore(points));",
    "timestamp": "2025-08-13 14:21:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\nfrom math import log2\n\ndef orientation(p, q, r):\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\ndef is_convex(points):\n    n = len(points)\n    if n < 3:\n        return False\n    sign = 0\n    for i in range(n):\n        curr_orient = orientation(points[i], points[(i+1)%n], points[(i+2)%n])\n        if curr_orient == 0:\n            return False\n        if sign == 0:\n            sign = 1 if curr_orient > 0 else -1\n        elif (curr_orient > 0 and sign < 0) or (curr_orient < 0 and sign > 0):\n            return False\n    return True\n\ndef convex_hull(points):\n    points = sorted(set(points))\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and orientation(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and orientation(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    return list(set(lower[:-1] + upper[:-1]))\n\ndef solve(points):\n    MOD = 998244353\n    total_score = 0\n    n = len(points)\n\n    for k in range(3, n+1):\n        for subset in combinations(points, k):\n            if is_convex(subset):\n                hull = convex_hull(subset)\n                score = pow(2, len(hull) - len(subset), MOD)\n                total_score = (total_score + score) % MOD\n\n    return total_score\n\n# Example usage\nN = int(input())\npoints = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\nprint(solve(points))",
    "timestamp": "2025-08-13 14:21:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solveConvexPolygonScore(points) {\n    const n = points.length;\n    const MOD = 998244353;\n    \n    function cross(p1, p2, p3) {\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0]);\n    }\n    \n    function isConvex(subset) {\n        const m = subset.length;\n        if (m < 3) return false;\n        \n        for (let i = 0; i < m; i++) {\n            if (cross(subset[i], subset[(i+1)%m], subset[(i+2)%m]) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    function convexHullSize(subset) {\n        const hull = new Set();\n        for (let p of subset) {\n            let outside = true;\n            for (let i = 0; i < subset.length; i++) {\n                for (let j = i+1; j < subset.length; j++) {\n                    const a = subset[i], b = subset[j];\n                    let allOnSameSide = true;\n                    for (let k = 0; k < subset.length; k++) {\n                        if (k === i || k === j) continue;\n                        const side = cross(a, b, subset[k]);\n                        if (side !== 0) {\n                            allOnSameSide = false;\n                            break;\n                        }\n                    }\n                    if (allOnSameSide) {\n                        hull.add(p);\n                        outside = false;\n                        break;\n                    }\n                }\n                if (!outside) break;\n            }\n        }\n        return hull.size;\n    }\n    \n    let totalScore = 0;\n    \n    for (let mask = 0; mask < (1 << n); mask++) {\n        const subset = [];\n        for (let i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                subset.push(points[i]);\n            }\n        }\n        \n        if (subset.length >= 3 && isConvex(subset)) {\n            const hullSize = convexHullSize(subset);\n            const score = Math.pow(2, hullSize - subset.length);\n            totalScore = (totalScore + score) % MOD;\n        }\n    }\n    \n    return totalScore;\n}",
    "timestamp": "2025-08-13 14:21:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 998244353\n\ndef solve():\n    N = int(sys.stdin.readline())\n    points = []\n    for _ in range(N):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x, y))\n    \n    # Precompute all possible subsets and their convex hull properties\n    total = 0\n    # Precompute the cross product for all triplets to check collinearity\n    # We'll process subsets of size >=3\n    pow2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        pow2[i] = pow2[i-1] * 2 % MOD\n    \n    from itertools import combinations\n    \n    for k in range(1, N + 1):\n        for subset in combinations(points, k):\n            if k >= 3:\n                # Check if the subset forms a convex polygon\n                # First, compute the convex hull\n                hull = convex_hull(subset)\n                if len(hull) < 3:\n                    continue\n                # Now, count the number of points inside or on the hull\n                m = len(hull)\n                # The convex hull is the set of points in the subset that form the convex polygon\n                # The remaining points in the subset must be inside the hull\n                # So the total points in the hull is m (vertices) plus any points inside\n                # But the subset is exactly the points forming the hull and possibly some inside\n                # So n is the number of points in the original set that lie inside or on the hull\n                # So we need to count all points in 'points' that are inside or on the hull of 'subset'\n                n = count_points_in_or_on_hull(points, hull)\n                # The score is 2^{n - |S|}, where |S| is k\n                score = pow(2, n - k, MOD)\n                total = (total + score) % MOD\n            else:\n                pass  # subsets of size <3 don't form convex polygons\n    \n    # Also, subsets of size 1 and 2 contribute 1 each (as per problem statement?)\n    # The problem says subsets forming convex polygons, which for |S| >=3 is convex hull\n    # For |S| =1 or 2, the convex hull is the set itself, and n = |S|\n    # So score is 2^{n - |S|} = 2^0 = 1\n    # So total += (number of subsets of size 1 and 2)\n    total = (total + N + (N * (N - 1) // 2)) % MOD\n    print(total)\n\ndef cross(o, a, b):\n    return (a[0] - o[0])*(b[1] - o[1]) - (a[1] - o[1])*(b[0] - o[0])\n\ndef convex_hull(points):\n    points = sorted(points)\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    return lower[:-1] + upper[:-1]\n\ndef count_points_in_or_on_hull(points, hull):\n    if len(hull) == 0:\n        return 0\n    if len(hull) == 1:\n        return sum(1 for p in points if p == hull[0])\n    if len(hull) == 2:\n        a, b = hull\n        return sum(1 for p in points if is_collinear_and_on_segment(a, b, p))\n    \n    count = 0\n    for p in points:\n        inside = True\n        # Check if p is on the hull\n        on_hull = False\n        for i in range(len(hull)):\n            a = hull[i]\n            b = hull[(i+1)%len(hull)]\n            c = cross(a, b, p)\n            if c < 0:\n                inside = False\n                break\n            if c == 0 and is_on_segment(a, b, p):\n                on_hull = True\n        if inside or on_hull:\n            count += 1\n    return count\n\ndef is_on_segment(a, b, c):\n    # Check if c lies on segment ab\n    cross_product = cross(a, b, c)\n    if abs(cross_product) != 0:\n        return False\n    min_x = min(a[0], b[0])\n    max_x = max(a[0], b[0])\n    min_y = min(a[1], b[1])\n    max_y = max(a[1], b[1])\n    return (c[0] >= min_x - 1e-12 and c[0] <= max_x + 1e-12 and\n            c[1] >= min_y - 1e-12 and c[1] <= max_y + 1e-12)\n\ndef is_collinear_and_on_segment(a, b, c):\n    return cross(a, b, c) == 0 and is_on_segment(a, b, c)\n\nsolve()",
    "timestamp": "2025-08-13 14:22:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 998244353;\n\nfunction solve() {\n    const N = parseInt(readline());\n    const points = [];\n    for (let i = 0; i < N; i++) {\n        const [x, y] = readline().split(' ').map(Number);\n        points.push({ x, y });\n    }\n\n    const pow2 = new Array(N + 1).fill(0);\n    pow2[0] = 1;\n    for (let i = 1; i <= N; i++) {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n\n    let total = 0;\n\n    for (let mask = 1; mask < (1 << N); mask++) {\n        const subset = [];\n        for (let i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                subset.push(points[i]);\n            }\n        }\n\n        if (subset.length < 3) continue;\n\n        const hull = convexHull(subset);\n        if (hull.length < 3) continue;\n\n        const m = subset.length;\n        const n = countPointsInConvexHull(points, hull);\n        const score = pow2[n - m];\n        total = (total + score) % MOD;\n    }\n\n    console.log(total);\n}\n\nfunction cross(o, a, b) {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\n\nfunction convexHull(points) {\n    if (points.length <= 1) return points.slice();\n\n    points.sort((a, b) => a.x - b.x || a.y - b.y);\n\n    const lower = [];\n    for (const p of points) {\n        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {\n            lower.pop();\n        }\n        lower.push(p);\n    }\n\n    const upper = [];\n    for (let i = points.length - 1; i >= 0; i--) {\n        const p = points[i];\n        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {\n            upper.pop();\n        }\n        upper.push(p);\n    }\n\n    lower.pop();\n    upper.pop();\n    return lower.concat(upper);\n}\n\nfunction countPointsInConvexHull(points, hull) {\n    if (hull.length < 3) return 0;\n\n    let count = hull.length;\n    const hullSet = new Set();\n    for (const p of hull) {\n        hullSet.add(`${p.x},${p.y}`);\n    }\n\n    for (const p of points) {\n        const key = `${p.x},${p.y}`;\n        if (!hullSet.has(key) && isPointInConvexHull(p, hull)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\nfunction isPointInConvexHull(p, hull) {\n    const n = hull.length;\n    if (n < 3) return false;\n\n    let left = 1;\n    let right = n - 1;\n\n    const cross1 = cross(hull[0], hull[left], p);\n    const cross2 = cross(hull[0], hull[right], p);\n\n    if (cross1 < 0 || cross2 > 0) return false;\n\n    while (right - left > 1) {\n        const mid = Math.floor((left + right) / 2);\n        const crossMid = cross(hull[0], hull[mid], p);\n        if (crossMid >= 0) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n\n    const crossFinal = cross(hull[left], hull[right], p);\n    return crossFinal <= 0;\n}\n\nfunction readline() {\n    // Replace this with actual input reading function\n    return '';\n}\n\nsolve();",
    "timestamp": "2025-08-13 14:22:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n// Cross product of vector AB and vector AC\nll cross(const pii &A, const pii &B, const pii &C) {\n    return (ll)(B.first - A.first) * (C.second - A.second) - (ll)(B.second - A.second) * (C.first - A.first);\n}\n\n// Compute the convex hull using the monotone chain algorithm\nvector<pii> convexHull(vector<pii> &points) {\n    sort(points.begin(), points.end());\n    vector<pii> hull;\n\n    // Lower hull\n    for (auto &p : points) {\n        while (hull.size() >= 2 && cross(hull[hull.size() - 2], hull.back(), p) <= 0)\n            hull.pop_back();\n        hull.push_back(p);\n    }\n    \n    // Upper hull\n    size_t t = hull.size() + 1;\n    for (int i = points.size() - 1; i >= 0; i--) {\n        while (hull.size() >= t && cross(hull[hull.size() - 2], hull.back(), points[i]) <= 0)\n            hull.pop_back();\n        hull.push_back(points[i]);\n    }\n    \n    hull.pop_back();\n    return hull;\n}\n\n// Calculates 2^exp % MOD\nll modExp(ll base, ll exp, ll mod) {\n    ll res = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            res = (res * base) % mod;\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pii> points(N);\n\n    for (int i = 0; i < N; ++i)\n        cin >> points[i].first >> points[i].second;\n\n    ll totalScore = 0;\n\n    // Generating subsets using bit manipulation\n    int totalSubsets = 1 << N;\n\n    for (int mask = 1; mask < totalSubsets; ++mask) {\n        vector<pii> subset;\n        for (int i = 0; i < N; ++i) {\n            if (mask & (1 << i))\n                subset.push_back(points[i]);\n        }\n\n        if (subset.size() < 3)\n            continue;  // At least 3 points are needed to form a polygon\n\n        vector<pii> hull = convexHull(subset);\n        int convexPoints = hull.size();\n        int n = subset.size();\n\n        // Check for total points inside the convex hull\n        vector<bool> insideHull(N, false);\n        for (auto &p : hull) {\n            auto it = find(subset.begin(), subset.end(), p);\n            if (it != subset.end()) {\n                int idx = it - subset.begin();\n                insideHull[idx] = true;\n            }\n        }\n        \n        // n counts number of points inside or on the hull\n        n = count(insideHull.begin(), insideHull.end(), true);\n        ll score = modExp(2, n - subset.size(), MOD);\n        totalScore = (totalScore + score) % MOD;\n    }\n\n    cout << totalScore << '\\n';\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:43:22"
  }
]