[
  {
    "language": "Fortran",
    "code": "module mod_convex_score\n  implicit none\n  integer(8), parameter :: md = 998244353_8\ncontains\n  integer(8) function score(k)\n    implicit none\n    integer, intent(in) :: k\n    score = mod(pow(2_8,k)+md-mod(int(k+1,8),md),md)\n    return\n  end function score\n  recursive function pow(a,b) result(p)\n    implicit none\n    integer(8), intent(in) :: a\n    integer, intent(in) :: b\n    integer(8) :: p\n    p = 1_8\n    if (b.eq.0) return\n    if (mod(b,2).eq.0) then\n      p = pow(a,b/2)\n      p = mod(p*p,md)\n      return\n    end if\n    p = mod(a*pow(a,b-1),md)\n    return\n  end function pow\n  function inv(n) result(y)\n    implicit none\n    integer(8), intent(in) :: n\n    integer(8) :: a, b, x, y, t, q\n    a = mod(n,md)\n    b = md\n    x = 0\n    y = 1\n    do while(b.ne.0_8)\n      q = a/b\n      t = b\n      b = mod(a,b)\n      a = t\n      t = y\n      y = x\n      x = t-q*x\n    end do\n    do while (y.lt.0_8)\n      y = y+md\n    end do\n    y = mod(y,md)\n    return\n  end function inv\nend module mod_convex_score\nprogram convex_score\n  use mod_convex_score\n  implicit none\n  integer :: n, x(200), y(200), a, b, c, i, j, k, s\n  integer(8) :: m, p\n  x = 0\n  y = 0\n  read(*,*) n\n  do i = 1, n\n    read(*,*) x(i), y(i)\n  end do\n  m = score(n)\n  do i = 1, n-1\n    do j = i+1, n\n      a = y(j)-y(i)\n      b = -x(j)+x(i)\n      c = x(j)*y(i)-x(i)*y(j)\n      s = 0\n      do k = 1, n\n        if (a*x(k)+b*y(k)+c.eq.0) s = s+1\n      end do\n      p = score(s)\n      p = mod(p*inv(int(s,8)*int(s-1,8)/2_8),md)\n      m = mod(m+md-p,md)\n    end do\n  end do\n  write(*,'(i0)') m\n  stop\nend program convex_score"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i = (int)(a); i <= (int)(b); i++)\n#define NFOR(i,a,b) for(int i = (int)(a); i >= (int)(b); --i)\n#define endl \"\\n\"\n#define mp make_pair\n#define X first\n#define Y second\n#define inf 1e9\n#define mod 1000000007\n#define mod1 998244353\n#define pb push_back\n#define Case cout<<\"Case #\"<<++cas<<\": \";\n#define fastio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define all(v) v.begin(),v.end()\n#define sz(x) int(x.size())\n// #define lli int\ntypedef long long int lli;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\ntypedef pair<lli,lli> pll;\ntypedef vector<lli> vl;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef complex <long double> complex_t;\nconst long double PI = acos((long double)-1.0);\n\n#define pr(...) dbs(#__VA_ARGS__, __VA_ARGS__)\ntemplate <class T> void dbs(string str, T t) {cerr << str << \" : \" << t << \"\\n\";}\ntemplate <class T, class... S> void dbs(string str, T t, S... s) {int idx = str.find(','); cerr << str.substr(0, idx) << \" : \" << t << \",\"; dbs(str.substr(idx + 1), s...);}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const pair<S, T>& p) {return os << \"(\" << p.first << \", \" << p.second << \")\";}\ntemplate <class T>ostream& operator <<(ostream& os, const vector<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T>ostream& operator <<(ostream& os, const set<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const map<S, T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T> void prc(T a, T b) {cerr << \"[\"; for (T i = a; i != b; ++i) {if (i != a) cerr << \", \"; cerr << *i;} cerr << \"]\\n\";}\n\nvector<pair<ll,ll>> points;\n\nll power(ll b, ll e) {\n    if (e == 0) return 1LL;\n    if (e == 1) return b%mod1;\n    ll p = power(b, e/2);\n    p = (p*p)%mod1;\n    if (e%2 == 1) p = (p * b)%mod1;\n    return p;\n}\n\nint main() {\n    int n; cin >> n;\n    FOR(i, 1, n) {\n        ll x1, y1; cin >> x1 >> y1;\n        points.pb(mp(x1, y1));\n    }\n    ll totAnswer = power(2, n);\n    ((totAnswer -= (n+1)) += mod1) %= mod1;\n    FOR(i, 0, n-2) {\n        FOR(j, i+1, n-1) {\n            int count1 = 0;\n            FOR(k, j+1, n-1) {\n                if ((points[i].second - points[k].second)*(points[j].first - points[k].first) == (points[j].second - points[k].second)*(points[i].first - points[k].first)) {\n                    count1 ++;\n                }\n            }\n            totAnswer = ((totAnswer - power(2, count1)) + mod1)%mod1;\n        }\n    }\n    cout << totAnswer << endl;\nreturn 0;}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <list>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <ctime>\n#include <cassert>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\nconst int MOD = 998244353;\n\nint power(long long x, int p) {\n    if (p == 0)\n        return 1;\n\n    long long half = power(x, p / 2);\n    half = half*half%MOD;\n\n    if (p % 2)\n        half = half * x % MOD;\n\n    return half;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> x(n), y(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n    long long res = 1;\n    for (int i = 0; i < n; i++) {\n        res = res * 2 % MOD;\n    }\n\n    set<pair<int, int>> lr;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int dx = x[j] - x[i], dy = y[j] - y[i];\n\n            int left = i, right = j;\n\n            int cnt = 2;\n            for (int k = 0; k < n; k++) {\n                if (k == i || k == j)\n                    continue;\n                int dx2 = x[k] - x[i], dy2 = y[k] - y[i];\n                if (dx*dy2 == dy*dx2) {\n                    left = min(left, k);\n                    right = max(right, k);\n                    cnt++;\n                }\n            }\n            if (left != i || right != j)\n                continue;\n            res = (res + MOD - power(2, cnt) + cnt + 1) % MOD;\n        }\n    }\n    res = (res + MOD - n - 1) % MOD;\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\nconst int maxn=210;\nconst int mod=998244353;\nint n,x[maxn],y[maxn],pw[maxn];\nint check(int i,int j,int k) {\n\treturn (x[k]-x[i])*(y[i]-y[j])==(y[k]-y[i])*(x[i]-x[j]);\n}\nint main() {\n\tn=read();\n\trep(i,1,n) x[i]=read(),y[i]=read();\n\tpw[0]=1;\n\trep(i,1,n) pw[i]=pw[i-1]*2%mod;\n\tint ans=pw[n];\n\t(ans+=mod-(n+1))%=mod;\n\trep(i,1,n) rep(j,i+1,n) {\n\t\tint x=i,y=j,cnt=0;\n\t\trep(k,1,n) if(check(i,j,k)) {\n\t\t\tcnt++;x=min(x,k);\n\t\t\ty=max(y,k);\n\t\t}\n\t\tif(x==i&&y==j) {\n\t\t\t(ans+=mod-pw[cnt])%=mod;\n\t\t\t(ans+=(cnt+1))%=mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define maxn 205\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\nint n;\nint x[maxn],y[maxn];\nll mypow[maxn];\nint main()\n{\n\tscanf(\"%d\",&n);\n\n\tmypow[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]),mypow[i]=(mypow[i-1]<<1)%mod;\n\n\tll ans=(mypow[n]-n-1+mod)%mod;\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\t{\n\t\t\t\tif((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tans=(ans-mypow[cnt]+mod)%mod;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nconst int N = 11111;\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= mod) x -= mod;\n}\nint pw(int a, int b) {\n\tint an = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) an = 1ll * an * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t}\n\treturn an;\n}\nint ans, x[N], y[N], n;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d%d\", &x[i], &y[i]);\n\tadd(ans, pw(2, n));\n\tadd(ans, mod - 1);\n\tadd(ans, mod - n);\n\tadd(ans, mod - n * (n - 1) / 2);\n\tfor (int i = 1; i <= n; ++i) \n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tint dx = x[j] - x[i], dy = y[j] - y[i];\n\t\t\tint cnt = 2;\n\t\t\tfor (int k = 1; k <= n; ++k) {\n\t\t\t\tif (i == k || j == k) continue;\n\t\t\t\tint dx2 = x[k] - x[j], dy2 = y[k] - y[j];\n\t\t\t\tif (dx2 * dy != dy2 * dx) continue;\n\t\t\t\tif (k < j) break;\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tadd(ans, mod - pw(2, cnt));\n\t\t\tadd(ans, 1);\n\t\t\tadd(ans, cnt);\n\t\t\tadd(ans, cnt * (cnt - 1) / 2);\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define MOD 998244353\n\nLL powmod(LL a, LL n){\n\tif(n == 0) return 1;\n\tif(n % 2) return (a * powmod(a, n-1)) % MOD;\n\tLL c = powmod(a, n/2);\n\treturn (c*c) % MOD;\n}\n\nstruct UF{\n\tint n;\n\tvector<int> par;\n\tUF(int n) : n(n) {\n\t\tfor(int i = 0; i < n; i++) par.push_back(i);\n\t}\n\tint find(int a){\n\t\tif(a != par[a]) par[a] = find(par[a]);\n\t\treturn par[a];\n\t}\n\tvoid join(int a, int b){\n\t\tpar[find(a)] = find(b);\n\t}\n};\n\n\nint main(){\n\tLL n = 0;\n\tcin >> n;\n\tpair<LL,LL> d[n];\n\tfor(LL i = 0; i < n; i++){\n\t\tcin >> d[i].first >> d[i].second;\n\t}\n\tLL ans = powmod(2, n);\n\t//ans -= 1;\n\t//ans -= n;\n\n\tfor(LL i = 0; i < n; i++){\n\t\tmap<pair<LL,LL>, LL> f;\n\t\tfor(LL j = i+1; j < n; j++){\n\t\t\tLL a1 = d[i].first - d[j].first;\n\t\t\tLL a2 = d[i].second - d[j].second;\n\t\t\tLL gc = __gcd(a1,a2);\n\t\t\ta1 /= gc; a2 /=gc;\n\t\t\tif(a1 < 0 || (a1 == 0 && a2 < 0)){\n\t\t\t\ta1 = -a1; a2 = -a2;\n\t\t\t}\n\t\t\tf[make_pair(a1,a2)] ++;\n\t\t}\n\t\tfor(auto it = f.begin(); it != f.end(); it++){\n\t\t\tLL t = it->second;\n\t\t\tans -= powmod(2,t);\n\t\t\tans++;\n\t\t}\n\t}\n\n\tans -= n;\n\tans -= 1;\n\tans %= MOD;\n\twhile(ans < 0) ans += MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ld = long double;\nconstexpr ld eps = 1e-9;\n\nbool eq(ld a, ld b)\n{\n    return (abs(a - b) < eps);\n}\n\nstruct Point\n{\n    ld x, y, z;\n\n    Point() : x(0), y(0), z(0) {}\n    Point(ld x, ld y, ld z) : x(x), y(y), z(z) {}\n\n    Point operator+(Point p)\n    {\n        return Point{x + p.x, y + p.y, z + p.z};\n    }\n\n    Point operator-(Point p)\n    {\n        return Point{x - p.x, y - p.y, z - p.z};\n    }\n\n    Point operator*(ld k)\n    {\n        return Point{k * x, k * y, k * z};\n    }\n\n    bool operator<(const Point &p) const\n    {\n        return (eq(x, p.x) ? (eq(y, p.y) ? z < p.z : y < p.y) : x < p.x);\n    }\n\n    bool operator==(const Point &p) const\n    {\n        return eq(x, p.x) && eq(y, p.y) && eq(z, p.z);\n    }\n};\n\nusing Vector = Point;\n\nbool eq(Point a, Point b)\n{\n    return (eq(a.x, b.x) && eq(a.y, b.y) && eq(a.z, b.z));\n}\n\nld norm(Point p)\n{\n    return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\nld abs(Point p)\n{\n    return sqrt(norm(p));\n}\n\nld dot(Point a, Point b)\n{\n    return (a.x * b.x + a.y * b.y + a.z + b.z);\n}\n\nPoint cross(Point a, Point b)\n{\n    ld nx = a.y * b.z - b.y * a.z;\n    ld ny = a.z * b.x - b.z * a.x;\n    ld nz = a.x * b.y - b.x * a.y;\n    return Point(nx, ny, nz);\n}\n\nld cross2D(Point a, Point b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\nstruct Line\n{\n    Point a, b;\n    Line() : a(Point(0, 0, 0)), b(Point(0, 0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n\n    bool operator==(const Line &l) const\n    {\n        return (a == l.a && b == l.b) || (a == l.b && b == l.a);\n    }\n};\n\nbool isis_lp(Line l, Point p)\n{\n    return (abs(cross(p - l.a, l.b - l.a)) < eps);\n}\n\nusing ll = long long;\nconstexpr ll MOD = 998244353;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\ntemplate <typename T>\nT mypow(T a, T b)\n{\n    if (b == 0)\n        return 1;\n    T tmp = mypow(a, b / 2);\n    if (b % 2)\n        return (((tmp * tmp) % MOD) * a) % MOD;\n    else\n        return (tmp * tmp) % MOD;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n    ll ret = mypow(2LL, n);\n    ret = (ret + MOD - 1) % MOD;\n    ret = (ret + MOD - n) % MOD;\n    vector<Point> ps;\n    for (int i = 0; i < n; i++)\n    {\n        ld x, y;\n        cin >> x >> y;\n        ps.emplace_back(Point(x, y, 0));\n    }\n    set<vector<Point>> lines;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            vector<Point> cand;\n            cand.emplace_back(ps[i]);\n            cand.emplace_back(ps[j]);\n            for (int k = 0; k < n; k++)\n            {\n                if (k == i || k == j)\n                    continue;\n                if (isis_lp(Line(ps[i], ps[j]), ps[k]))\n                {\n                    cand.emplace_back(ps[k]);\n                }\n            }\n            sort(cand.begin(), cand.end());\n            lines.emplace(cand);\n        }\n    }\n    for (const auto &l : lines)\n    {\n        ll k = l.size();\n        ll tmp = mypow(2LL, k);\n        tmp = (tmp + MOD - 1) % MOD;\n        tmp = (tmp + MOD - k) % MOD;\n        ret = (ret + MOD - tmp) % MOD;\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-12;\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<pair<int,int> >se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\tif(se.find({i,j})!=se.end())continue;\n\t\tL l(v[i],v[j]);\n\t\tvector<int>x={i,j};\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectLP(l,v[k]))x.push_back(k);\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\tint n=b-a-1;\n\t\t\tr=(r-pow_binary_mod(2,n,M))%M;\n\t\t\tse.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<functional>\n#include<vector>\n#include<map>\n#include<string>\n#include<set>\n#include<unordered_set>\n#include<math.h>\n#include<stack>\n#define int long long\n#define mod 998244353\n#define P pair<int,int>\nusing namespace std;\n\nP a[200];\nsigned main() {\n\tint ans = 1;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = ans * 2 % mod;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t}\n\tans -= n + 1;\n\tans %= mod;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tvector<int>V;\n\t\t\tif (a[i].first == a[j].first) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].first == a[i].first) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (a[i].second == a[j].second) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].second == a[i].second) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble x = double(a[j].second - a[i].second) / (a[j].first - a[i].first);\n\t\t\t\tdouble y = double(a[i].second) - a[i].first*x;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (abs(a[i].first*x + y - a[i].second) <= 1e-10) {\n\t\t\t\t\t\tV.push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(V.begin(), V.end());\n\t\t\tif (V.size()>=2&&V[0] == i&&V[1]==j) {\n\t\t\t\tint k = 1;\n\t\t\t\tfor (int j : V) {\n\t\t\t\t\tk = k * 2 % mod;\n\t\t\t\t}\n\t\t\t\tk -= V.size(); k--;\n\t\t\t\tans -= k;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tans += mod * 5;\n\tans %= mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n// MAGRANT - GNC20 - TEMPLATE 3.3\n// 2017/9/2 - AtCoder Regular Contest 082 - Gamma\n\n// FOR COMPATIBILITY:\n#define _CRT_SECURE_NO_WARNINGS\n\n// UNIVERSAL DEFINITIONS:\n#define N (207)\n#define MODULO (998244353)\n#define HA1 (2420609)\n#define HA2 (19260817)\n#define EPS (0.00000001)\n\n// FREQUENT HEADER FILES:\n#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <complex>\nusing namespace std;\n\n// TEMPLATE BEGINS HERE.\n#define MAGRANT_ALLOWS_CTMP\n// IMPORTANT: DO NOT OPEN UNLESS AS CONTESTANT.\n// CAUTION: BEWARE OF CONFLICT.\n#ifdef MAGRANT_ALLOWS_CTMP\nnamespace CTMP\n{\n\t// ELEMENTARY MATHEMATICAL COMPUTATIONS:\n\tlong long fact[N], inv[N];\n\tlong long KissMe(long long xx, long long yy)\n\t{\n\t\tif (yy == 0LL)\n\t\t{\n\t\t\treturn 1LL;\n\t\t}\n\t\tlong long Res = KissMe((xx*xx) % (long long)MODULO, yy >> 1);\n\t\tif (yy % 2LL == 1LL)\n\t\t{\n\t\t\tRes *= xx;\n\t\t\tRes %= (long long)MODULO;\n\t\t}\n\t\treturn Res;\n\t}\n\tinline void InitFactInv()\n\t{\n\t\tfact[0] = 1LL;\n\t\tfor (int i = 1;i < N - 4;i++)\n\t\t{\n\t\t\tfact[i] = fact[i - 1] * (long long)i;\n\t\t\tfact[i] %= (long long)MODULO;\n\t\t}\n\t\tinv[N - 5] = KissMe(fact[N - 5], (long long)(MODULO - 2));\n\t\tfor (int i = N - 6;i >= 0;i--)\n\t\t{\n\t\t\tinv[i] = inv[i + 1] * (long long)(i + 1);\n\t\t\tinv[i] %= (long long)MODULO;\n\t\t}\n\t}\n\tinline long long Choose(int xx, int yy)\n\t{\n\t\tif (xx < yy)\n\t\t{\n\t\t\treturn 0LL;\n\t\t}\n\t\telse if (xx == yy)\n\t\t{\n\t\t\treturn 1LL;\n\t\t}\n\t\tlong long Res = fact[xx];\n\t\tRes *= inv[yy];\n\t\tRes %= (long long)MODULO;\n\t\tRes *= inv[xx - yy];\n\t\tRes %= (long long)MODULO;\n\t\treturn Res;\n\t}\n\tinline long long GridWays(int fx, int fy, int sx = 0, int sy = 0)\n\t{\n\t\tfx -= sx, fy -= sy;\n\t\tif (fx < 0 || fy < 0)\n\t\t{\n\t\t\treturn 0LL;\n\t\t}\n\t\tlong long Res = fact[fx + fy];\n\t\tRes *= inv[fx];\n\t\tRes %= (long long)MODULO;\n\t\tRes *= inv[fy];\n\t\tRes %= (long long)MODULO;\n\t\treturn Res;\n\t}\n}\n#endif\n// TEMPLATE FINISHES HERE.\n\n#define VERTICAL (123456789.0)\n\nclass LINES\n{\npublic:\n\tdouble kk, bb;\n\tLINES()\n\t{\n\t\tkk = VERTICAL;\n\t\tbb = VERTICAL;\n\t}\n\tLINES(pair<int, int> &xx, pair<int, int> &yy)\n\t{\n\t\tint ddx = yy.first - xx.first;\n\t\tint ddy = yy.second - xx.second;\n\t\tif (ddx == 0)\n\t\t{\n\t\t\tkk = VERTICAL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tkk = ddy / ddx;\n\t\t}\n\t\tif (kk == VERTICAL)\n\t\t{\n\t\t\tbb = (double)yy.first;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbb = yy.second - kk*yy.first;\n\t\t}\n\t}\n\tbool operator< (const LINES& lns)const\n\t{\n\t\tif (abs(kk - lns.kk) > EPS)\n\t\t{\n\t\t\treturn kk < lns.kk;\n\t\t}\n\t\telse if (abs(bb - lns.bb) > EPS)\n\t\t{\n\t\t\treturn bb < lns.bb;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n};\n\nint n;\npair<int, int> pos[N];\nmap<LINES, set<int> > mp;\n\nint main()\n{\n\t// IMPORTANT: DO NOT OPEN UNLESS AS CONTESTANT.\n\t// CAUTION: BEWARE OF CONFLICT.\n\tusing namespace CTMP;\n\n\t// REAFFIRM THE FOLLOWING BEFORE CODING.\n\t// 1. THE ALGORITHM IS CORRECT.\n\t// 2. THE COMPLEXITY IS PROPER.\n\t// 3. THE ALGORITHM CANNOT BE SIMPLER.\n\t// 4. CODING DETAILS WERE CONSIDERED.\n\n\tInitFactInv();\n\tscanf(\"%d\", &n);\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].first, &pos[i].second);\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tfor (int j = 0;j < n;j++)\n\t\t{\n\t\t\tLINES lns(pos[i], pos[j]);\n\t\t\tmp[lns].insert(i);\n\t\t\tmp[lns].insert(j);\n\t\t}\n\t}\n\tlong long Ans = KissMe(2LL, (long long)n);\n\tAns -= Choose((long long)n, 2LL);\n\tif (Ans < 0LL)\n\t{\n\t\tAns += (long long)MODULO;\n\t}\n\tAns -= (long long)n + 1LL;\n\tif (Ans < 0LL)\n\t{\n\t\tAns += (long long)MODULO;\n\t}\n\tfor (map<LINES, set<int> > ::iterator\n\t\tit = mp.begin();\n\t\tit != mp.end();it++)\n\t{\n\t\tint tt = it->second.size();\n\t\tlong long Res = 0LL;\n\t\tfor (int i = 3;i <= tt;i++)\n\t\t{\n\t\t\tRes += Choose(tt, i);\n\t\t\tif (Res >= (long long)MODULO)\n\t\t\t{\n\t\t\t\tRes -= (long long)MODULO;\n\t\t\t}\n\t\t}\n\t\tAns -= Res;\n\t\tif (Ans < 0LL)\n\t\t{\n\t\t\tAns += (long long)MODULO;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\n\t// REAFFIRM THE FOLLOWING BEFORE SUBMITTING.\n\t// 1. THE ARRAYS ARE IN PROPER SIZE.\n\t// 2. THE CORNER CASES WILL NOT LEAD TO VIOLATION.\n\t// 3. NO TYPO LIKE N->M EXISTS.\n\t// 4. THE INPUT/OUTPUT IS IN THE SPECIFIED FORMAT.\n\t// 5. ALL CATEGORIES DO NOT INTERSECT.\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\n#define pb push_back\n#define w1 first\n#define w2 second\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=205,mod=998244353;\nconst db pi=acos(-1.0);\nint n,ans;\nint x[maxn],y[maxn],bin[maxn];\nmap<db,int>cnt;\nint main(){\n\tread(n);\n\tbin[0]=1;rep(i,1,n)bin[i]=2ll*bin[i-1]%mod;\n\tans=bin[n];\n\trep(i,1,n)read(x[i]),read(y[i]);\n\trep(i,1,n){\n\t\tcnt.clear();\n\t\trep(j,1,n)if(i!=j)cnt[atan2(y[j]-y[i],x[j]-x[i])]++;\n\t\tfor(map<db,int>::iterator it=cnt.begin();it!=cnt.end();it++){\n\t\t\tif(it->w1<=0)continue;\n\t\t\tif(cnt[it->w1-pi]>0)continue;\n\t\t\tans-=bin[it->w2+1]-(it->w2+1+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans-n-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-14;\ntypedef complex<long double> P;\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<L>se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\t//if(se.find({i,j})!=se.end())continue;\n\t\tL l(v[i],v[j]);\n\t\tvector<int>x={i,j};\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectSP(l,v[k]))x.push_back(k);\n\t\tr=(r-pow_binary_mod(2,x.size()-2,M))%M;\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\t//se.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "// Crt. 2020-01-07  0946\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define PII pair<int, int>\n#define mk make_pair\n#define N 204\nusing namespace std;\nconst int Mod = 998244353;\n\ninline int fsp(int x, int p = Mod - 2) {\n    int res = 1;\n    while (p) {\n        if (p & 1) res = 1ll * res * x % Mod;\n        x = 1ll * x * x % Mod, p >>= 1;\n    } return res;\n}\n\ninline int getp(int x) {\n    return x < 0 ? -1 : 1;\n}\n\ninline int Abs(int x) {\n    return x < 0 ? -x : x;\n}\n\ninline int gcd(int x, int y) {\n    while (y ^= x ^= y ^= x %= y);\n    return x;\n}\n\nint n, x[N], y[N], m, z[N];\nPII k[N * N];\n\nint main(){\n#ifdef LOCAL_JUDGE\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i)\n        scanf(\"%d%d\", x + i, y + i);\n\n    for (int i = 1; i <= n; ++i)\n        z[i] = 1ll * i * (i - 1) / 2;\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n; ++j) {\n            int a = y[j] - y[i], b = x[j] - x[i];\n            //cout << i << \" \" << j << \" \" << a << \" \" << b << endl;\n            if (!a) { k[++m] = mk(-100000, y[i]); continue; }\n            if (!b) { k[++m] = mk(x[i], -100000); continue; } \n            int pa = getp(a), pb = getp(b);\n            if (pa < 0) pa = -pa, pb = -pb;\n            a = Abs(a), b = Abs(b);\n            int g = gcd(a, b);\n            a /= g, b /= g;\n            a *= pa, b = pb;\n            k[++m] = mk(a, b);\n        }\n\n    sort(k + 1, k + m + 1);\n\n    long long ans = fsp(2, n) - 1 - n;\n\n//    for (int i = 1; i <= m; ++i)\n//        cout << k[i].first << \" \" << k[i].second << endl;\n\n    for (int i = 1, j; i <= m; i = j + 1) {\n        for (j = i; j < m && k[j + 1] == k[i]; ++j);\n        int pos = lower_bound(z + 1, z + n + 1, j - i + 1) - z;\n        ans -= fsp(2, pos) - 1 - pos, ans %= Mod;\n    }\n        \n    if (ans < 0) ans += Mod;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:https://beta.atcoder.jp/contests/arc082/tasks/arc082_c>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nconst ll MOD = 998244353;\nvector<ll> fact;\nll N;\nll solve(){\n    ll res = 0;\n    cin >> N;\n    vector<pll> ps(N); for(auto& in:ps) cin >> in.first >> in.second;\n    fact.resize(N+1);\n    fact[0] = 1;\n    for(int i = 1; i <= N;i++) fact[i] = fact[i-1]*2%MOD;\n\n    res = (fact[N] + MOD - 1 - N - N*(N-1)/2)%MOD;\n    \n    vector<vector<int>> checked(N,vector<int>(N,0));\n    for(int i = 0; i < N;i++){\n        for(int j = 0; j < i;j++){\n            if(checked[i][j]) continue;\n            vector<int> idx{i,j};\n            for(int k = 0; k < N;k++){\n                if(k == i || k == j) continue;\n                if((ps[i].first-ps[j].first)*(ps[i].second-ps[k].second)-(ps[i].first-ps[k].first)*(ps[i].second-ps[j].second) == 0){\n                    idx.push_back(k);\n                }\n            }\n            for(auto v:idx){\n                for(auto vv:idx){\n                    checked[v][vv] = 1;\n                }\n            }\n            int sz = (int)idx.size();\n            if(sz >= 3){\n                res = (res + MOD - fact[sz] + sz + sz*(sz-1)/2 + 1)%MOD;\n            }\n        }\n    }\n    (res += MOD)%=MOD;\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//no convex hull ans=0.\n//S:convex polygon counted:2^(n-|S|)\n//number of subsets.\n//U:inside S(\\S) \n//S union U: convex hull is S\n//number of pair:(S,U),where the convex hull of S union U is S\n//S union U corresponds to a unique S,thus a unique U\n//bijection (S,U)<->S union U\n//for each subset of set,it is valid if the convex hull exists.(has postive area)\n//the only case is colinear!\n//ans=2^n-1-C(n,1)-C(n,2)-sigma(2^ai-ai-C(ai,2)-1)(ai>=3)\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nbool vis[210][210];\nstruct kk\n{\n\tint id;\n\tdouble num;\n}c[210];\nint n,i,j,k,l,x[210],y[210];\nlong long pow2[210],ans;\nconst long long P=998244353;\nbool cmp(kk A,kk B)\n{\n\treturn A.num<B.num;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%d%d\",&x[i],&y[i]);\n\tpow2[0]=1;\n\tfor (i=1;i<=n;i++) pow2[i]=pow2[i-1]*2%P;\n\tans=pow2[n];\n\tans-=1+n+n*(n-1)/2;\n\tans=(ans%P+P)%P;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tint tot=0;\n\t\tfor (j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif (vis[i][j]) continue;\n\t\t\tint dx=x[j]-x[i],dy=y[j]-y[i];\n\t\t\tif (dx==0) \n\t\t\t{\n\t\t\t\tc[++tot].id=j;\n\t\t\t\tc[tot].num=100000;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc[++tot].id=j;\n\t\t\t\tc[tot].num=(double)dy/(double)dx;\n\t\t\t}\n\t\t}\n\t\tif (tot==0) continue;\n\t\tsort(c+1,c+tot+1,cmp);\n\t\tc[0].num=c[1].num-1;\n\t\tlong long now=0;\n\t\tfor (int j=1;j<=tot;j++)\n\t\t{\n\t\t\tif (c[j].num-c[j-1].num<1e-8) now++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (k=j-now;k<j;k++)\n\t\t\t\t  for (l=k+1;l<j;l++)\n\t\t\t\t  {\n\t\t\t\t  \tvis[c[k].id][c[l].id]=1;\n\t\t\t\t  \tvis[c[l].id][c[k].id]=1;\n\t\t\t\t  }\n\t\t\t\tnow++;//itself;\n\t\t\t\tif (now>=3) ans-=pow2[now]-now-now*(now-1)/2-1;\n\t\t\t\tnow=1;\n\t\t\t\tans=(ans%P+P)%P;\n\t\t\t}\n\t\t}\n\t\tfor (k=tot-now+1;k<=tot;k++)\n\t\t\tfor (l=k+1;l<=tot;l++)\n\t\t\t\t{\n\t\t\t\t  \tvis[c[k].id][c[l].id]=1;\n\t\t\t\t  \tvis[c[l].id][c[k].id]=1;\n\t\t\t\t}\n\t\tnow++;\n\t\tif (now>=3) ans-=pow2[now]-now-now*(now-1)/2-1;\n\t\tans=(ans%P+P)%P;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n//O(n^2 logn)"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint n;\nstd::pair<int, int> p[201];\nstd::map<std::pair<std::pair<int, int>, int>, int> l;\nstd::set<std::pair<std::pair<int, int>, int>> s;\n\ntypedef long long ll;\nconst ll mo = 998244353ll;\n\nll mpow(ll t, ll k, const ll &m) {\n\tll ans = 1 % m;\n\tfor(; k > 0; k >>= 1, t = t * t % m)\n\tif(k & 1)\n\t\tans = ans * t % m;\n\treturn ans;\n}\n\nll calc(const ll &cnt) {\n\treturn ((mpow(2ll, cnt, mo) - cnt - cnt * (cnt - 1ll) / 2ll % mo - 1ll) % mo + mo) % mo;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i)\n\t\tscanf(\"%d%d\", &p[i].first, &p[i].second);\n\tstd::sort(p, p + n);\n\tfor(int i = 0, dx, dy, d, c; i < n; ++i) {\n\t\ts.clear();\n\t\tfor(int j = 0; j < n; ++j)\n\t\tif(i != j) {\n\t\t\tif(p[i].first == p[j].first) {\n\t\t\t\tc = p[i].first;\n\t\t\t\tif(s.find({{1, 0}, c}) == s.end()) {\n\t\t\t\t\t++l[{{1, 0}, c}];\n\t\t\t\t\ts.insert({{1, 0}, c});\n\t\t\t\t}\n\t\t\t} else if(p[i].second == p[j].second) {\n\t\t\t\tc = p[i].second;\n\t\t\t\tif(s.find({{0, 1}, c}) == s.end()) {\n\t\t\t\t\t++l[{{0, 1}, c}];\n\t\t\t\t\ts.insert({{0, 1}, c});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = p[j].first - p[i].first;\n\t\t\t\tdy = p[j].second - p[i].second;\n\t\t\t\td = std::__gcd(dx, dy);\n\t\t\t\tdx /= d;\n\t\t\t\tdy /= d;\n\t\t\t\tc = dy * p[i].first - dx * p[i].second;\n\t\t\t\tif(s.find({{dy, dx}, c}) == s.end()) {\n\t\t\t\t\t++l[{{dy, dx}, c}];\n\t\t\t\t\ts.insert({{dy, dx}, c});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans = calc(n);\n\tfor(auto it = l.begin(); it != l.end(); ++it)\n\t\tans = (ans - calc(it->second) + mo) % mo;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b)    for (int i = (a); i < (b); i++)\n#define F0R(i, a)       for (int i = 0; i < (a); i++)\n#define FORd(i, a, b)   for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a)      for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x)      for (auto& a : x)\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\nusing mn = modnum<int(998244353)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\ntemplate<typename T> struct point {\n    T x, y;\n    point() : x(0), y(0) {}\n    point(T _x, T _y) : x(_x), y(_y) {}\n    friend istream& operator >> (istream& i, point& p) { return i >> p.x >> p.y; }\n    friend ostream& operator << (ostream& o, const point& p) {\n        return o << \"(\" << p.x << \", \" << p.y << \")\";\n    }\n\n    T norm() const { return x * x + y * y; }\n    double len() const { return sqrt(norm()); }\n    double ang() const { return atan2(y, x); }\n    point<T> conj() const { return { x, -y }; }\n\n    point& operator += (const point& o) { x += o.x; y += o.y; return *this; }\n    point& operator -= (const point& o) { x -= o.x; y -= o.y; return *this; }\n    point& operator *= (const T& c) { x *= c; y *= c; return *this; }\n    point& operator /= (const T& c) { x /= c; y /= c; return *this; }\n    friend point operator + (const point& a, const point& b) { return point(a) += b; }\n    friend point operator - (const point& a, const point& b) { return point(a) -= b; }\n    friend point operator * (const point& a, const T& c) { return point(a) *= c; }\n    friend point operator * (const T& c, const point& a) { return point(a) *= c; }\n    friend point operator / (const point& a, const T& c) { return point(a) /= c; }\n\n    bool operator == (const point& o) const { return x == o.x && y == o.y; }\n    bool operator != (const point& o) const { return x != o.x || y != o.y; }\n    bool operator < (const point& o) const { return (x != o.x) ? x < o.x : y < o.y; }\n    bool operator > (const point& o) const { return (x != o.x) ? x > o.x : y > o.y; }\n    bool operator <= (const point& o) const { return !(*this > o); }\n\n    friend T dot(const point& a, const point& b) { return a.x * b.x + a.y * b.y; }\n    friend T cross(const point& a, const point& b) { return a.x * b.y - a.y * b.x; }\n    friend T cross(const point& p, const point& a, const point& b) { return cross(a - p, b - p); }\n\n    friend point<T> operator * (const point& a, const point& b) {\n        return { a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x };\n    }\n    friend point<T> operator / (const point& a, const point& b) {\n        return a * b.conj() / b.norm();\n    }\n\n    point dir() const { return point(*this) / len(); }\n    point rotate(const double& ang) const { return *this * point(cos(ang), sin(ang)); }\n\n    T dist(const point& a) const { return (a - *this).len(); }\n    T dist(const point& a, const point& b) {\n        return abs(cross(*this, a, b)) / a.dist(b);\n    }\n    point reflect(const point& a, const point& b) const {\n        return a + ((*this - a) / (b - a)).conj() * (b - a);\n    }\n    point foot(const point& a, const point& b) const {\n        return (*this + this->reflect(a, b)) / 2;\n    }\n    friend point extension(const point& a, const point& b, const point& c, const point& d) {\n        T x = cross(a, b, c), y = cross(a, b, d);\n        return (d * x - c * y) / (x - y);\n    }\n\n    friend vector<point> seg_intersect(point a, point b, point c, point d) {\n        if (a > b) swap(a, b);\n        if (c > d) swap(c, d);\n\n        T a1 = cross(a, b, c), a2 = cross(a, b, d);\n        if (a1 > a2) swap(a1, a2);\n        if (!(a1 <= 0 && a2 >= 0)) return {};\n\n        if (a1 == 0 && a2 == 0) {\n            if (cross(a, c, d) != 0) return {};\n            point<T> x1 = max(a, c), x2 = min(b, d);\n            if (x1 > x2) return {};\n            if (x1 == x2) return { x1 };\n            return { x1, x2 };\n        }\n\n        point<T> z = extension(a, b, c, d);\n        if (a <= z && z <= b) return { z };\n        return {};\n    }\n\n    using polygon = vector<point<T>>;\n    friend ostream& operator << (ostream& o, const polygon& poly) {\n        o << \"{\";\n        for (auto pt : poly) o << \" \" << pt;\n        return o << \" }\";\n    }\n\n    string classify(const polygon& p) const {\n        bool ans = 0;\n        for (int i = 0; i < p.size(); i++) {\n            point<T> a = p[i], b = p[(i + 1) % p.size()];\n            if (cross(a, b, *this) == 0 && min(a, b) <= *this && *this <= max(a, b))\n                return \"on\";\n            if (a.y > b.y) swap(a, b);\n            if (a.y <= y && y < b.y && cross(*this, a, b) > 0) ans ^= 1;\n        }\n        return ans ? \"in\" : \"out\";\n    }\n\n    friend polygon convex_hull(const vector<point>& pts) {\n        point pivot = *min_element(all(pts));\n        auto sorted = pts;\n        sort(all(sorted), [&pivot](const point& p, const point& q) {\n            T cp = cross(pivot, p, q);\n            if (cp != 0) return cp > 0;\n            return pivot.dist(p) < pivot.dist(q);\n        });\n\n        int j = 0;\n        polygon res(pts.size());\n        for (const point& p : sorted) {\n            while (j > 1 && cross(res[j - 2], res[j - 1], p) <= 0)\n                j--;\n            res[j++] = p;\n        }\n        res.erase(res.begin() + j, res.end());\n        return res;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N; re(N);\n    vector<point<int>> pts(N); re(pts);\n\n    mn ans = mn(2).pow(N) - 1 - N;\n    F0R (i, N) {\n        FOR (j, i + 1, N) {\n            int ct = 0;\n            F0R (k, N) {\n                if (pts[k].classify({ pts[i], pts[j] }) == \"on\") ct++;\n            }\n            ans -= mn(2).pow(ct - 2);\n        }\n    }\n    ps(ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 200\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,b[MN+5][MN+5],x[MN+5],y[MN+5],ans,pw[MN+5],q[MN+5],top;\nint main()\n{\n    n=read();pw[0]=1;\n    for(int j=1;j<=n;++j) pw[j]=2*pw[j-1]%mod;ans=(pw[n]-n-1+mod)%mod;\n    for(int i=1;i<=n;++i) x[i]=read(),y[i]=read();\n    for(int i=1;i<=n;++i) for(int j=i+1;j<=n;++j) if(!b[i][j])\n    {\n        q[top=1]=i;q[top=2]=j;\n        for(int k=j+1;k<=n;++k) if((x[j]-x[i])*(y[k]-y[i])-(x[k]-x[i])*(y[j]-y[i])==0) q[++top]=k;\n        for(int l=1;l<=top;++l) for(int r=l+1;r<=top;++r) b[q[l]][q[r]]=1;\n        ans=((ans-pw[top]+top+1)%mod+mod)%mod;\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nbool usededge[200][200];\nll x[200], y[200];\nbool online(int i, int j, int k) {\n\tif ((x[j] - x[i])*(y[k] - y[i]) - (x[k] - x[i])*(y[j] - y[i]))return false;\n\telse return true;\n}\nint main(){\n\tll n; cin >> n;\n\tll out = mod_pow(2, n);\n\tout = ((out - 1 - n - n * (n - 1) / 2) % mod + mod) % mod;\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\trep(i, n) {\n\t\tRep(j,i+1, n) {\n\t\t\tif (usededge[i][j])continue;\n\t\t\tll cnt = 2;\n\t\t\tvector<int> v; v.push_back(i); v.push_back(j);\n\t\t\tRep(k, j + 1, n) {\n\t\t\t\tif (usededge[i][k])continue;\n\t\t\t\tif (online(i, j, k)) {\n\t\t\t\t\trep(l, (int)v.size()) {\n\t\t\t\t\t\tusededge[v[l]][k] = true;\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(k);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout = ((out - mod_pow(2, cnt) + 1 + cnt + cnt * (cnt - 1) / 2) % mod + mod) % mod;\n\t\t}\n\t}\n\tcout << out << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Crt. 2020-01-07  0946\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define PII pair<int, int>\n#define mk make_pair\n#define N 204\nusing namespace std;\nconst int Mod = 998244353;\n\ninline int fsp(int x, int p = Mod - 2) {\n    int res = 1;\n    while (p) {\n        if (p & 1) res = 1ll * res * x % Mod;\n        x = 1ll * x * x % Mod, p >>= 1;\n    } return res;\n}\n\ninline int getp(int x) {\n    return x < 0 ? -1 : 1;\n}\n\ninline int Abs(int x) {\n    return x < 0 ? -x : x;\n}\n\ninline int gcd(int x, int y) {\n    while (y ^= x ^= y ^= x %= y);\n    return x;\n}\n\nint n, x[N], y[N], m, z[N];\n\ninline PII getk(int i, int j) {\n    int a = y[j] - y[i], b = x[j] - x[i];\n    //cout << i << \" \" << j << \" \" << a << \" \" << b << endl;\n    if (!a) { return mk(-100000, y[i]); }\n    if (!b) { return mk(x[i], -100000); } \n    int pa = getp(a), pb = getp(b);\n    if (pa < 0) pa = -pa, pb = -pb;\n    a = Abs(a), b = Abs(b);\n    int g = gcd(a, b);\n    a /= g, b /= g;\n    a *= pa, b *= pb;\n    return mk(a, b);\n}\n\nint main(){\n#ifdef LOCAL_JUDGE\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i)\n        scanf(\"%d%d\", x + i, y + i);\n\n    long long ans = fsp(2, n) - 1 - n;\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n; ++j) {\n            int cnt = 0;\n            for (int k = j + 1; k <= n; ++k) {\n                if (getk(i, j) != getk(i, k)) continue; \n                ++cnt;\n            }\n            ans -= fsp(2, cnt);\n        }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0;});\n\t\tint m = pts.size();\n\t\tint dp[m][m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 205\n#define mod 998244353\nint x[maxn],y[maxn];\ninline int mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\ninline int pow(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\nvoid add(int &a,int b)\n{\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nmain()\n{\n    int n;scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n    int ans=pow(2,n);\n    add(ans,mod-1);\n    add(ans,mod-n);\n    add(ans,mod-n*(n-1)/2);\n    for(int i=0;i<n;i++)for(int j=i+1;j<n;j++)\n    {\n        int a=y[j]-y[i];\n        int b=x[i]-x[j];\n        int c=-a*x[i]-b*y[i];\n        int cnt=2;\n        for(int k=0;k<n;k++)\n        {\n            if (k==i || k==j)continue;\n            int z=a*x[k]+b*y[k]+c;\n            if(z!=0)continue;\n            if(k<j)break;\n            cnt++;\n        }\n        add(ans,mod-pow(2,cnt));\n        add(ans,1);\n        add(ans,cnt);\n        add(ans,cnt*(cnt-1)/2);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef pair<pll, lint> ppl;\n\nconst lint mod = 998244353;\n\nlint powmod(lint x, lint n){\n  lint ret = 1;\n  while(n > 0){\n    if(n&1) ret *= x, ret %= mod, n -= 1;\n    else x *= x, x %= mod, n >>= 1;\n  }\n  return ret;\n}\n\nlint gcd(lint p, lint q){\n    if(p < q) swap(p, q);\n    while(q){\n        lint r = p % q;\n        p = q;\n        q = r;\n    }\n    return p;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    lint x[n], y[n];\n    rep(i, n) scanf(\"%lld%lld\", &x[i], &y[i]);\n    \n    vector<ppl> L;\n    rep(i, n)For(j, i+1, n){\n        lint a = y[j] - y[i];\n        lint b = x[i] - x[j];\n        lint c = x[i]*(y[j]-y[i]) - y[i]*(x[j]-x[i]);\n        lint g = gcd(gcd(abs(a), abs(b)), abs(c));\n        L.push_back(ppl(pll(a/g, b/g), c/g));\n    }\n    sort(L.begin(), L.end());\n    L.erase(unique(L.begin(), L.end()), L.end());\n    \n    lint ans = (powmod(2, n)-(n+1)+mod) % mod;\n    for(auto l: L){\n        lint a = l.fi.fi;\n        lint b = l.fi.se;\n        lint c = l.se;\n        int cnt = 0;\n        rep(i, n)if(a*x[i]+b*y[i] == c) ++cnt;\n        ans = (ans - powmod(2, cnt)+cnt+1 + mod) % mod;\n    }\n    \n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n#include \"ext/pb_ds/tree_policy.hpp\"\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define all(x) x.begin(), x.end()\n#define IO ios :: sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define pii pair<int,int>\n#define sz(x) (int)x.size()\nconst int mod = 1e9 + 7;\nconst int mod1 = 998244353;\ntypedef long double f80;\n\n#ifndef LOCAL\n#pragma GCC optimize (\"O2\")\n#define endl '\\n'\n#endif\n\ntemplate<typename T>\nusing ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rand(int l, int r){\n    uniform_int_distribution<int> uid(l, r);\n    return uid(rng);\n}\n\nll pwr(ll a,ll b, ll mod){\n    a %= mod;\n    int ans = 1;\n    while(b){\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nconst int N = 205;\npii p[N];\nset<pair<int,pii>> m;\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tfr(i ,1, n){\n\t\tcin >> p[i].fi >> p[i].se;\n\t}\n\tint ans = pwr(2, n, mod1);\n\tfr(i, 1, n){\n\t\tfr(j, i + 1, n){\n\t\t\tint c = 0;\n\t\t\tpii lol = {p[j].fi - p[i].fi, p[j].se - p[i].se};\n\t\t\tint g = abs(__gcd(lol.fi, lol.se));\n\t\t\tif(lol.fi < 0)\n\t\t\t\tg *= -1;\n\t\t\tlol.fi /= g, lol.se /= g;\n\t\t\tif(m.count({i, lol}))\n\t\t\t\tcontinue;\n\t\t\tfr(k, 1, n){\n\t\t\t\tif((p[k].se - p[i].se) * (p[j].fi - p[i].fi) == (p[j].se - p[i].se) * (p[k].fi - p[i].fi))\n\t\t\t\t\t{ c++; m.insert({k, lol}); }\n\t\t\t}\n\t\t\tint val = (pwr(2, c, mod1) - c - 1 + mod1) % mod1;\n\t\t\tans = (ans + mod1 - val) % mod1;\n\t\t}\n\t}\n\tans -= n + 1;\n\tans = (ans + mod1) % mod1;\n\tcout << ans;\n}\nsigned main(){\n    IO;\n    #ifdef LOCAL\n        freopen(\"inp.txt\",\"r\", stdin);\n        freopen(\"out.txt\", \"w\", stdout);\n    #endif\n    cout << setprecision(10) << fixed;\n    int t = 1;\n    // cin >> t;\n    fr(tt, 1, t){\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// fest\n#include <bits/stdc++.h>\t\n\n#define pb push_back\n#define F first\n#define S second\n#define y1 dasdasfasfas\n#define x1 wqdadfasfasfas\n#define All(c) c.begin(), c.end()\n#define SZ(A) (int((A).size()))\n#define umap unordered_map\n#define __ fflush(stdout)\n#define FILENAME \"\"\n\ntypedef long long ll;\ntypedef long double ld;    \n\nusing namespace std;\n\nvoid FREOPEN() {\n\t#ifdef LOCAL\n\t\tfreopen(\".in\", \"r\", stdin);\n\t\tfreopen(\"1.out\", \"w\", stdout);\n\t#else\n\t\t//freopen(FILENAME\".in\", \"r\", stdin);\n\t\t//freopen(FILENAME\".out\", \"w\", stdout);\n\t#endif\n}\n\ninline double Time() {return (clock() * 1.0) / CLOCKS_PER_SEC; }             \n\nconst int N = 201, inf = 1e9 * 2;\n\nconst ll MOD = 998244353, INF = 1e18;\n\nconst int dx[] = {1, -1, 0, 0, -1, 1, -1, 1};\nconst int dy[] = {0, 0, 1, -1, -1, 1, 1, -1};\n\nstruct Point {\n\tint x, y;\n};\n\nPoint a[N];\nPoint root;\n\nint tri[N][N], dp[N][N];\n\nPoint make(int _x, int _y) {\n\tPoint ret;\n\tret.x = _x;\n\tret.y = _y;\n\treturn ret;\n}\n\nPoint vec(Point p1, Point p2) {\n\treturn make(p2.x - p1.x, p2.y - p1.y);\n}\n\nint crossp(Point p1, Point p2) {\n\treturn p1.x * p2.y - p1.y * p2.x; \n} \n\nint dist(Point p1, Point p2) {\n\treturn (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n}\n\nbool canbe(int i, int j) {\n\tif (i == j) return 0;\n\tif (a[i].x > a[j].x) return 0;\n\tif (a[i].x < a[j].x) return 1;\n\tif (a[i].y > a[j].y) return 0;\n\treturn 1;\n}\n\nbool cmp(Point p1, Point p2) {\n\tPoint v1 = vec(root, p1);\n\tPoint v2 = vec(root, p2);\n\tif (crossp(v1, v2) < 0) return 1;\n\tif (crossp(v1, v2) > 0) return 0;\n\tif (dist(root, p1) < dist(root, p2)) return 1;\n\treturn 0;\n}\n\nint power(int x) {\n\tint ret = 1;\n\tint num = 2;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tx--;\n\t\t\tret = (ret * 1ll * num) % MOD;\n\t\t}\n\t\telse {\n\t\t\tx /= 2;\n\t\t\tnum = (num * 1ll * num) % MOD;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid add(int &x, int y) {\n\tx += y;\n\twhile (x >= MOD) x -= MOD;\n}\n\nvoid out (Point p) {\n\tcerr << \"(\" << p.x << \" \" << p.y << \") \";\n}\n\nint main() {\n\tFREOPEN();\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _x, _y;\n\t\tscanf(\"%d %d\", &_x, &_y);\n\t\ta[i] = make(_x, _y);\n\t}\n\tint ans = 0;\n\tfor (int start = 1; start <= n; start++) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(tri, 0, sizeof(tri));\n\t\troot = a[start];\n\t\tvector<Point> ps;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (canbe(start, i)) ps.pb(a[i]); \n\t\t}\n\t\tsort(All(ps), cmp);\n\t\tint m = SZ(ps);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint on_line = 0;\n\t\t\tfor (int k = i - 1; k >= 0; k--) {\n\t\t\t\tif (crossp(vec(root, ps[i]), vec(root, ps[k])) == 0) on_line++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tfor (int k = i + 1; k < j; k++) {\n\t\t\t\t\tif (crossp(vec(ps[i], ps[j]), vec(ps[i], ps[k])) <= 0) tri[i][j]++;\n\t\t\t\t}\n\t\t\t\ttri[i][j] += on_line;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tassert(crossp(vec(root, ps[i]), vec(root, ps[j])) <= 0);\n\t\t\t\tif (crossp(vec(root, ps[i]), vec(root, ps[j])) == 0) continue;\n\t\t\t\tdp[i][j] += power(tri[i][j]);\n\t\t\t\tfor (int k = j + 1; k < m; k++) {\n\t\t\t\t\tif (crossp(vec(ps[i], ps[j]), vec(ps[i], ps[k])) >= 0) continue;\n\t\t\t\t\tdp[j][k] += (power(tri[j][k]) * 1ll * dp[i][j]) % MOD;\n\t\t\t\t}\n\t\t\t\tadd(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d \", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n \nconst double EPS = 1e-12;\ntypedef complex<long double> P;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n \nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n \nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<L>se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\tL l(v[i],v[j]);\n\t\tint n=0;\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectSP(l,v[k]))n++;\n\t\tr=(r-pow_binary_mod(2,n,M))%M;\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\n// ベクトル v からみて点 p が右側にあれば 1, 左なら -1, 境界なら 0\nint dir(int vx, int vy, int px, int py) {\n\tif(vx < 0) {\n\t\tvx *= -1;\n\t\tvy *= -1;\n\t\tpx *= -1;\n\t\tpy *= -1;\n\t}\n\t\n\tint flag = 1;\n\tif(px < 0) {\n\t\tpx *= -1;\n\t\tpy *= -1;\n\t\tflag = -1;\n\t}\n\t\n\tint r = 0;\n\tif(vx * py <  vy * px) { r =  1; }\n\tif(vx * py == vy * px) { r =  0; }\n\tif(vx * py >  vy * px) { r = -1; }\n\t\n\treturn r * flag;\n}\n\n// 点 p が三角形 ABC の内側にあれば 1, 外側なら -1, 境界なら 0\n// （延長線上の境界にある場合も 0 になってしまっているので注意）\nint inTri(int ax, int ay, int bx, int by, int cx, int cy, int px, int py) {\n\tint ab = dir(bx - ax, by - ay, px - ax, py - ay);\n\tint bc = dir(cx - bx, cy - by, px - bx, py - by);\n\tint ac = dir(cx - ax, cy - ay, px - ax, py - ay);\n\tif(ab == 0 || bc == 0 || ac == 0) { return 0; }\n\treturn (ab != ac && bc != ac ? 1 : -1);\n}\n\n\nint n, x[200], y[200];\nLL MOD = 998244353;\n\nint main() {\n\tcin >> n;\n\tinc(i, n) { cin >> x[i] >> y[i]; }\n\t\n\tint c = 0;\n\tinc(i, n) {\n\tinc(j, i) {\n\tinc(k, j) {\n\t\tif(dir(x[j] - x[i], y[j] - y[i], x[k] - x[i], y[k] - y[i]) == 0) { c++; }\n\t}\n\t}\n\t}\n\t\n\t// サンプル通ってない……\n\tLL ans = 1;\n\tinc(i, n) { (ans *= 2) %= MOD; }\n\t(ans += MOD - (1 + n + n * (n - 1) / 2 + c)) %= MOD;\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3,\"Ofast\",\"inline\")\n#include<bits/stdc++.h>\n#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\n#define ms(a,b) memset(a,b,sizeof(a))\n#define msn(a,n,b) for(int i=0;i<=n;i++)a[i]=b\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define fi first\n#define se second\nusing namespace std;\nmt19937 rng_32(chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef double db;\nconst int mod=998244353;\nconst int seed=233;\nconst double PI=acos(-1.0);\nconst double eps=1e-7;\nconst int inf=0x3f3f3f3f;\nconst int max_n=100005;\nll ceil(ll x,ll y){if(x==0)return 0;if(y<0)x=-x,y=-y;bool sign=x>0;x=abs(x);return sign?(x+y-1)/y:-x/y;}\nll floor(ll x,ll y){if(x==0)return 0;if(y<0)x=-x,y=-y;bool sign=x>0;x=abs(x);return sign?x/y:-(x+y-1)/y;}\nnamespace {\n    inline int Add(int x,int y){return (x+=y)>=mod?x-mod:x;}\n    inline int Sub(int x,int y){return (x-=y)<0?x+mod:x;}\n    inline int Mul(int x,int y) {return 1ll*x*y%mod;}\n    inline int Pow(int x,int y=mod-2){if(y==0)return 1;int res=1;while(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}return res;}\n}\n/**********************head************************/\nint n;\nint p2[max_n];\nP p[max_n];\nint main(){\n    scanf(\"%d\",&n);\n    p2[0]=1;\n    for(int i=1;i<=n;i++)p2[i]=Mul(p2[i-1],2);\n    for(int i=1;i<=n;i++)scanf(\"%d%d\",&p[i].fi,&p[i].se);\n    int ans=n+1;\n    map<P,int> mp;\n    for(int i=1;i<=n;i++){\n        mp.clear();\n        for(int j=i+1;j<=n;j++){\n            int x=p[j].fi-p[i].fi,y=p[j].se-p[i].se;\n            int d=__gcd(x,y);\n            x/=d,y/=d;\n            if(x<0)x=-x,y=-y;\n            else if(x==0&&y<0)y=-y;\n            mp[P(x,y)]++;\n        }\n        for(int j=1;j<i;j++){\n            int x=p[j].fi-p[i].fi,y=p[j].se-p[i].se;\n            int d=__gcd(x,y);\n            x/=d,y/=d;\n            if(x<0)x=-x,y=-y;\n            else if(x==0&&y<0)y=-y;\n            mp[P(x,y)]=0;\n        }\n        for(auto p:mp){\n            if(p.se){\n                int c=p.se+1;\n                ans=Add(ans,Sub(p2[c],c+1));\n            }\n        }\n    }\n    ans=Sub(p2[n],ans);\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegment_base(){};\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize<<1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T& L,T& R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T& val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\n//aのmod mにおける逆元を返す。\n//aとmは互いに素であることが要請される。\nlong long invMod(long long a,long long m){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n/*\nLL powMod(LL x,LL e,LL mod){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}\n*/\n///////////////////\nbool check(LL x1,LL y1,LL x2,LL y2,LL x3,LL y3){\n\tif( x2 != x1 ){\n\t\tif( x1==x3 ){\n\t\t\treturn false;\n\t\t}\n\t\tLL res1,res2;\n\t\tres1 = (y2-y1)*(x3-x1);\n\t\tres2 = (y3-y1)*(x2-x1);\n\t\treturn res1==res2;\n\t}else{\n\t\treturn x1==x3;\n\t}\n}\nvoid solve(){\n\tconst LL mod = 998244353;\n\t\n\tint N;\n\tcin >> N;\n\tvector<LL> X(N),Y(N);\n\tfor(int i=0;i<N;++i){\n\t\tcin>>X[i]>>Y[i];\n\t}\n\tLL ans = powMod(2,N,mod);\n\tans = (ans-N-1+mod) % mod;\n\tans = (ans-N*(N-1)/2) % mod;\n\tans = (ans + mod) % mod;\n\tLL res = 0;\n\tfor(int a=0;a<N;++a){\n\t\tfor(int b=a+1;b<N;++b){\n\t\t\tLL count = 2;\n\t\t\tfor(int c=0;c<N;++c){\n\t\t\t\tif(c==a||c==b){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif( check(X[a],Y[a],X[b],Y[b],X[c],Y[c]) ){\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLL local = powMod(2,count,mod);\n\t\t\tlocal = (local -count-1) % mod;\n\t\t\tlocal = (local -count*(count-1)/2 ) % mod;\n\t\t\tlocal = (local + mod) % mod;\n\t\t\tLL div = (count*(count-1)/2) % mod;\n\t\t\tdiv = invMod(div,mod);\n\t\t\tlocal = (local*div) % mod;\n\t\t\tres = (res + local ) % mod;\n\t\t}\n\t}\n\tans = (ans-res+mod) % mod;\n\tcout << ans << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint cnt[201][201] = {};\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nlong long moving[1000] = {};\nint main() {\n#define int long long\n\tvector<pair<int, int>> inputs;\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tinputs.push_back(make_pair(a, b));\n\t}\n\tmoving[0] = 1;\n\tfor (int i = 1; i < 1000; ++i) {\n\t\tmoving[i] = moving[i - 1] * 2;\n\t\tmoving[i] %= MOD;\n\t}\n\tlong long ans = moving[n];\n\tlong long tmp = n + 1;\n\tmap<tuple<long long, long long, long long>, int> edges;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int q = i + 1; q < n; ++q) {\n\t\t\tif (cnt[i][q] == 1) break;\n\t\t\tlong long A = inputs[q].second - inputs[i].second;\n\t\t\tlong long B = inputs[q].first - inputs[i].first;\n\t\t\tlong long C = (inputs[q].second - inputs[i].second) * inputs[i].first - (inputs[q].first - inputs[i].first) * inputs[i].second;\n\t\t\tlong long geko = 0;\n\t\t\tif (A == 0) {\n\t\t\t\tgeko = llabs(B);\n\t\t\t}\n\t\t\telse if (B == 0) {\n\t\t\t\tgeko = llabs(A);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeko = gcd(llabs(A), llabs(B));\n\t\t\t}\n\t\t\tif (geko == 0) {\n\t\t\t\tgeko = llabs(C);\n\t\t\t}\n\t\t\telse if (C == 0) {\n\t\t\t\tgeko = llabs(geko);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeko = gcd(llabs(C), llabs(geko));\n\t\t\t}\n\t\t\tif (geko != 0) {\n\t\t\t\tA /= geko;\n\t\t\t\tB /= geko;\n\t\t\t\tC /= geko;\n\t\t\t}\n\t\t\tif (A < 0) {\n\t\t\t\tA = -A;\n\t\t\t\tB = -B;\n\t\t\t\tC = -C;\n\t\t\t}\n\t\t\tedges[make_tuple(A, B, C)]++;\n\t\t}\n\t}\n\tfor (auto i = edges.begin(); i != edges.end(); ++i) {\n\t\tint cnt = 0;\n\t\tfor (int q = 1;; ++q) {\n\t\t\tcnt += q;\n\t\t\tif (i->second == cnt) {\n\t\t\t\ttmp += moving[q + 1] - (q + 1) - 1;\n\t\t\t\ttmp += MOD;\n\t\t\t\ttmp %= MOD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans + (MOD - tmp)) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ Templates\n#include <bits/stdc++.h>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 998244353LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\n// }}}\n\ninline bool on(ll x0, ll y0, ll x1, ll y1, ll x, ll y)\n{\n    const ll DX = x1 - x0;\n    const ll DY = y1 - y0;\n    const ll dx = x - x0;\n    const ll dy = y - y0;\n    return dx * DY == dy * DX;\n}\n\nll power(const ll p, const ll n)\n{\n    if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 1) {\n        return (power(p, n - 1) * p) % MOD;\n    } else {\n        const ll pp = power(p, n / 2);\n        return (pp * pp) % MOD;\n    }\n}\n\ninline ll calc(const ll n)\n{\n    if (n < 2) {\n        return 0;\n    }\n    return (((power(2, n) - n - 1) % MOD) + MOD) % MOD;\n}\n\nstruct Line {\n    ll ind;\n    ll dx;\n    ll dy;\n    bool operator==(const Line& l) const\n    {\n        return (ind == l.ind) and (dx * l.dy == dy * l.dx);\n    }\n    bool operator<(const Line& l) const\n    {\n        return (ind != l.ind) ? ind < l.ind : dx * l.dy < dy * l.dx;\n    }\n};\n\nostream& operator<<(ostream& os, const Line& l)\n{\n    os << \"ind: \" << l.ind << \"\\ndx: \" << l.dx << \"\\ndy:\" << l.dy << endl;\n    return os;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    vector<ll> x(N);\n    vector<ll> y(N);\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    map<Line, ll> lines;\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = i + 1; j < N; j++) {\n            bool flag = false;\n            for (int k = 0; k < N; k++) {\n                if (k == i or k == j) {\n                    continue;\n                }\n                if (on(x[i], y[i], x[j], y[j], x[k], y[k])) {\n                    const Line ln = Line{min({i, j, k}), x[j] - x[i], y[j] - y[i]};\n                    if (lines.find(ln) == lines.end()) {\n                        lines[ln] = 3;\n                        for (int l = 0; l < N; l++) {\n                            if (l == i or l == j or l == k) {\n                                continue;\n                            }\n                            if (on(x[i], y[i], x[j], y[j], x[l], y[l])) {\n                                lines[ln]++;\n                            }\n                        }\n                    }\n                    flag = true;\n                    break;\n                }\n            }\n            if (not flag) {\n                lines[Line{i, x[j] - x[i], y[j] - y[i]}] = 2;\n            }\n        }\n    }\n    ll sum = N + 1;\n    for (const auto& e : lines) {\n        sum += calc(e.second);\n        sum = sum % MOD;\n    }\n    cout << (((power(2, N) - sum) % MOD) + MOD) % MOD << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n\ntypedef std::pair<int, int> point;\ntypedef std::tuple<int, int, int> line;\nconst int N = 205, mod = 998244353;\n\nint a[N], ans, n, tot, sum[N * N];\npoint p[N]; line l[N * N];\n\nint operator * (point a, point b) {return a.x * b.y - a.y * b.x;}\nbool in_line(point a, line b) {return std::get<0>(b) * a.x + std::get<1>(b) * a.y + std::get<2>(b) == 0;}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 0; i < n; ++i) std::cin >> p[i].x >> p[i].y;\n\ta[0] = 1; for (int i = 1; i <= n; ++i) a[i] = a[i - 1] * 2 % mod;\n\tfor (int i = 0; i <= n; ++i) a[i] = (a[i] - i - 1 + mod) % mod;\n\tans = a[n];\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tint a = p[i].y - p[j].y, b = p[j].x - p[i].x, c = p[i] * p[j];\n\t\t\tint g = std::__gcd(a, std::__gcd(b, c));\n\t\t\ta /= g, b /= g, c /= g;\n\t\t\tif (a < 0) a = -a, b = -b, c = -c;\n\t\t\tl[tot++] = line(a, b, c);\n\t\t}\n\tstd::sort(l, l + tot), tot = std::unique(l, l + tot) - l;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < tot; ++j)\n\t\t\tif (in_line(p[i], l[j])) ++sum[j];\n\tfor (int i = 0; i < tot; ++i) ans = (ans + mod - a[sum[i]]) % mod;\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 998244353;\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\ntemplate<typename T>\nT preback (const vector<T> &v) {\n  return *next(v.rbegin());\n}\n\ntypedef pair<int, int> point;\n#define x first\n#define y second\n\npoint operator+ (point p, point q) {\n  return {p.x + q.x, p.y + q.y};\n}\n\npoint operator- (point p) {\n  return {-p.x, -p.y};\n}\n\npoint operator- (point p, point q) {\n  return p + (-q);\n}\n\nint dot (point p, point q) {\n  return p.x * q.x + p.y * q.y;\n}\n\nint cross (point p, point q) {\n  return p.x * q.y - p.y * q.x;\n}\n\nint orient (point p, point q, point r) {\n  return cross(q - p, r - p);\n}\n\nint cw (point p, point q, point r) {\n  return cross(q - p, r - p) < 0;\n}\n\nostream& operator<< (ostream &out, point p) {\n  out << \"(\" << p.x << \" \" << p.y << \")\";\n  return out;\n}\n\nstruct basecomp {\n  point base;\n  basecomp (point _base) : base(_base) {}\n\n  bool operator() (point p, point q) {\n    if (orient(base, p, q) == 0) {\n      return dot(p - base, p - base) < dot(q - base, q - base);\n    } else {\n      return orient(base, p, q) < 0;\n    }\n  }\n};\n\nconst int MAX_N = 205;\n\nModint ans;\nModint dp [MAX_N][MAX_N];\n\nvoid solve (vector<point> &pts) {\n  sort(pts.begin(), pts.end());\n  point base = pts[0];\n  sort(pts.begin(), pts.end(), basecomp(base));\n\n  int n = pts.size();\n  for (int i = 1; i < n; i++) {\n    dp[0][i] = 1; // # of points on the line 0..i\n    for (int j = 1; j < i; j++) {\n      if (orient(base, pts[i], pts[j]) == 0) {\n        dp[0][i] *= 2;\n      }\n    }\n  }\n\n  for (int u = 1; u < n; u++) {\n    for (int v = u + 1; v < n; v++) {\n      dp[u][v] = 0;\n      for (int w = 0; w < u; w++) {\n        if (cw(pts[w], pts[u], pts[v])) {\n          dp[u][v] += dp[w][u];\n        }\n      }\n\n      // count the # of points in the triangle\n      for (int w = u + 1; w < v; w++) {\n        if (cw(base, pts[u], pts[w]) &&\n            orient(pts[u], pts[v], pts[w]) >= 0 &&\n            orient(pts[v], base, pts[w]) >= 0) {\n          dp[u][v] *= 2;\n        }\n      }\n\n      ans += dp[u][v];\n    }\n  }\n  \n  reverse(pts.begin(), pts.end());\n  pts.pop_back();\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  vector<point> pts (n);\n  for (int i = 0; i < n; i++) {\n    cin >> pts[i].x >> pts[i].y;\n  }\n\n  while ((int) pts.size() >= 3) {\n    solve(pts);\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) < 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\nint adds[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<point> ns;\n        for (int j = 0; j < n; j++) {\n            if (j == i) {\n                continue;\n            }\n            if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {\n                need[j] = true;\n                ns.push_back(p[j]);\n            } else {\n                need[j] = false;\n            }\n        }\n        cur = p[i];\n        sort(all(ns), comp);\n        for (int j = 0; j < sz(ns); j++) {\n            adds[j] = 0;\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (vec(ns[k] - p[i], ns[j] - p[i]) == 0) {\n                    adds[j]++;\n                }\n            }\n            for (int k = j + 1; k < sz(ns); k++) {\n                goods[j][k] = false;\n                cnt[j][k] = 0;\n                dp[j][k] = 0;\n                if (good(p[i], ns[j], ns[k])) {\n                    goods[j][k] = true;\n                    for (int g = 0; g < sz(ns); g++) {\n                        if (g == j || g == k) {\n                            continue;\n                        }\n                        if (inside(p[i], ns[j], ns[k], ns[g])) {\n                            cnt[j][k]++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (goods[j][k]) {\n                    dp[j][k] += st[cnt[j][k]];\n                    dp[j][k] %= Mod;\n                    ans += dp[j][k];\n                    ans %= Mod;\n                    for (int nxt = k + 1; nxt < sz(ns); nxt++) {\n                        if (vec(ns[nxt] - ns[j], ns[k] - ns[j]) > 0 && goods[k][nxt] && vec(ns[nxt] - p[i], ns[k] - p[i]) != 0) {\n                            dp[k][nxt] += (1LL * dp[j][k] * st[cnt[k][nxt] - adds[k]]) % Mod;\n                            dp[k][nxt] %= Mod;\n                        }\n                    }\n                }   \n            }\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\nusing namespace std;\nconst int mod=998244353;\nstruct point{\n    int x,y;\n    point(int _x=0,int _y=0):x(_x),y(_y){}\n}p[203];\ninline point operator -(const point& a,const point& b){\n    return point(a.x-b.x,a.y-b.y);\n}\ninline int cross(const point& a,const point& b){\n    return a.x*b.y-a.y*b.x;\n}\ninline int dot(const point& a,const point& b){\n    return a.x*b.x+a.y*b.y;\n}\ninline long long qpow(long long x,long long n){\n    long long res=1;\n    while(n>0){\n        if(n&1) res=res*x%mod;\n        x=x*x%mod;\n        n>>=1;\n    }\n    return res;\n}\nint main(){\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n       \tcin>>p[i].x>>p[i].y;\n\t}\n    long long ans=qpow(2,n);\n    ans=(ans-1+mod)%mod;\n    ans=(ans-n+mod)%mod;\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<=n;j++){\n            long long cnt=0;\n            for(int k=1;k<=n;k++){\n                if(cross(p[k]-p[i],p[k]-p[j])==0&&dot(p[k]-p[i],p[k]-p[j])<0)\n                    ++cnt;\n            }\n            ans=(ans-qpow(2,cnt)+mod)%mod;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n/*\n\nin:\n5\n0 0\n0 1\n0 2\n0 3\n1 1\n\nout:\n11\n\n*/ "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\nint n, cnt, X[210], Y[210];\nbool done[210][210];\nint pw(int e){\n\tif(e==0) return 1;\n\tint t=pw(e/2); t=1LL*(t*t)%MOD;\n\treturn e%2==1 ? t*2%MOD : t;\n}\nint norm(int x){\n\treturn (x+MOD)%MOD;\n}\nbool linear(int a, int b, int c){\n\treturn (X[a]-X[c])*(Y[b]-Y[c])-(Y[a]-Y[c])*(X[b]-X[c])==0;\n}\nvoid count(int v, int u){\n\tif(done[v][u]) return;\n\tvector<int> V;\n\tfor(int i=1; i<=n; i++)\n\t\tif(linear(u,v,i))\n\t\t\tV.push_back(i);\n\tint m=V.size();\n\tfor(int i=0; i<m; i++)\n\t\tfor(int j=0; j<m; j++)\n\t\t\tdone[V[i]][V[j]]=true;\n\tcnt=(norm(pw(m)-m-1)+cnt)%MOD;\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<=n; i++)\n\t\tscanf(\"%d%d\", X+i, Y+i);\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=i+1; j<=n; j++)\n\t\t\tcount(i, j);\n\tint ans=norm(pw(n)-n-1);\n\tans=(ans+norm(-cnt))%MOD;\n\tprintf(\"%d\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 998244353;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n  unsigned get() const { return x; }\n\n  // 逆数\n  ModInt inv() const {\n    ll a = 1, p = x, e = MOD-2;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // e乗\n  ModInt pow(ll e) {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // 2のx乗\n  ModInt pow2() {\n    ll a = 1, p = 2, e = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // 代入\n  void operator=(ll b) { x = b; }\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  ModInt &operator+=(ModInt that) {\n    x = ((ll)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((ll)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (ll)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (ll)x * that.inv() % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (ll)x % that.x;\n    return *this;\n  }\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP p[205];\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) {\n    double x, y;\n    cin >> x >> y;\n    p[i] = {x, y};\n  }\n\n  mint ret = mint(n).pow2() - n - 1;\n  REP(i, n) FOR(j, i+1, n) {\n    mint cnt = 0;\n    REP(k, n) if(k!=i && k!=j && intersectSP(L(p[i], p[j]), p[k])) ++cnt;\n    ret -= cnt.pow2();\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int N = 211;\nconst int mod = 998244353;\nint n;\nLL base[N];\nstruct ddd{\n    int x, y;\n}nd[N];\nint sq(int x){return x * x;}\nbool check(int x1, int y1, int x2, int y2){\n    LL a = x1 * x2 + y1 * y2;\n    LL b = (sq(x1) + sq(y1)) * (sq(x2) + sq(y2));\n    return a > 0 && b == sq(a);\n}\nint main(){\n    cin>>n;\n    for(int i = 1;i <= n; i++){\n        scanf(\"%d%d\", &nd[i].x, &nd[i].y);\n    }\n    base[0] = 1;\n    for(int i = 1;i <= 200; i++)base[i] = base[i-1] * 2 % mod;\n    LL ans = (base[n] - 1 - n + mod) % mod;\n    for(int i = 2;i <= n; i++){\n        for(int j = 1;j < i; j++){\n            int tot = 0;\n            for(int k = 1;k <= n; k++){\n                if(i == k || j == k)continue;\n                if(check(nd[i].x - nd[k].x, nd[i].y - nd[k].y, nd[k].x - nd[j].x, nd[k].y - nd[j].y))tot++;\n            }\n            ans = (ans + mod - base[tot]) % mod;\n            //printf(\"i=%d j=%d tot=%d\\n\", i, j, tot);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n    vec d, root;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n        d = vec(V);\n        root = vec(V);\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void erase_edge(int from, int to){\n        vec e(0);\n        REP(i, G[from].size()){\n            if(G[from][i].to == to) e.push_back(i);\n        }\n        IREP(i, e.size()) G[from].erase(G[from].begin() + e[i]);\n    }\n\n    void erase_edge2(int v1, int v2){\n        erase_edge(v1, v2);\n        erase_edge(v2, v1);\n    }\n\n    void dfs(int v, vector<bool> &used, int &n){\n        REP(k, G[v].size()){\n            if(!used[G[v][k].to]){\n                n++;\n                used[G[v][k].to] = true;\n                dfs(G[v][k].to, used, n);\n            }\n        }\n    }\n\n};\n\nint fastpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = fastpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int comb(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nbool on_line(int x1, int y1, int x2, int y2, int x3, int y3){\n    int X1 = x1 - x3;\n    int Y1 = y1 - y3;\n    int X2 = x2 - x3;\n    int Y2 = y2 - y3;\n    if(X1 * Y2 == Y1 * X2){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    vec x(N), y(N);\n    REP(i, N) cin >> x[i] >> y[i];\n\n    Graph line(N);\n    REP(i, N){\n        FOR(j, i + 1, N){\n            FOR(k, j + 1, N){\n                if(on_line(x[i], y[i], x[j], y[j], x[k], y[k])){\n                    line.add_edge2(i, j, 0);\n                    line.add_edge2(i, k, 0);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    int mod = 998244353;\n    Combination C(N, mod);\n    \n    FOR(k, 3, N + 1) ans = (ans + C.comb(N, k)) % mod;\n\n    vector<bool> used(N, false);\n    REP(i, N){\n        if(!used[i]){\n            int n = 1;\n            used[i] = true;\n            line.dfs(i, used, n);\n            FOR(k, 3, n + 1) ans = (ans + mod - C.comb(n, k)) % mod;\n        }\n    }\n\n    cout << ans;\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\ntypedef long long ll;\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define mod 998244353\n#define mad(a,b) a=(a+b)%mod;\n#define mul(a,b) a=a*b%mod;\n#define N 100010\nll fac[N],inv[N],ivf[N];\nll C(ll n,ll k){\n    if(n<k)return 0;\n    return fac[n]*ivf[n-k]%mod*ivf[k]%mod;\n}\nll po(ll x,ll y){\n    ll res=1;\n    for(;y;y>>=1){\n\tif(y&1)res=res*x%mod;\n\tx=x*x%mod;\n    }\n    return res;\n}\nll n,x[210],y[210];\nint main(){\n    fac[0]=ivf[0]=inv[1]=1;\n    for(int i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\tfac[i]=fac[i-1]*i%mod;\n\tivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n  cin>>n;\n  for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i];\n  }\n  ll ans=po(2,n)-C(n,0)-C(n,1)-C(n,2);\n  for(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n      bool th=0;\n      for(int k=0;k<j;k++){\n\t  if(k!=i&&(y[k]-y[i])*(x[j]-x[i])==(x[k]-x[i])*(y[j]-y[i]))th=1;\n      }\n      if(th)continue;\n      ll cnt=2;\n      for(int k=j+1;k<n;k++){\n\t  if((y[k]-y[i])*(x[j]-x[i])==(x[k]-x[i])*(y[j]-y[i]))cnt++;\n      }\n      ll res=po(2,cnt)-C(cnt,0)-C(cnt,1)-C(cnt,2);\n      mad(ans,-res);\n  }\n  ans%=mod;\n  if(ans<0)ans+=mod;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint cnt[201][201] = {};\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nlong long moving[1000] = {};\nint main() {\n#define int long long\n\tvector<pair<int, int>> inputs;\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tinputs.push_back(make_pair(a, b));\n\t}\n\tmoving[0] = 1;\n\tfor (int i = 1; i < 1000; ++i) {\n\t\tmoving[i] = moving[i - 1] * 2;\n\t\tmoving[i] %= MOD;\n\t}\n\tlong long ans = moving[n];\n\tlong long tmp = n + 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tvector<pair<tuple<long long, long long, long long>, int>> edges;\n\t\tfor (int q = i+1; q < n; ++q) {\n\t\t\tif (cnt[i][q] == 1) break;\n\t\t\tlong long A = inputs[q].second - inputs[i].second;\n\t\t\tlong long B = -(inputs[q].first - inputs[i].first);\n\t\t\tlong long C = (inputs[q].second - inputs[i].second) * inputs[i].first - (inputs[q].first - inputs[i].first) * inputs[i].second;\n\t\t\tlong long geko = gcd(llabs(A), llabs(B));\n\t\t\tgeko = gcd(geko, llabs(C));\n\t\t\tA /= geko;\n\t\t\tB /= geko;\n\t\t\tC /= geko;\n\t\t\tif (A < 0) {\n\t\t\t\tA = -A;\n\t\t\t\tB = -B;\n\t\t\t\tC = -C;\n\t\t\t}\n\t\t\tedges.push_back(make_pair(make_tuple(A, B, C), q));\n\t\t}\n\t\tsort(edges.begin(), edges.end());\n\t\tint back = 0;\n\t\tedges.push_back(make_pair(make_tuple(-1, 0, 0), -1));\n\t\tfor (int i = 1; i < edges.size(); ++i) {\n\t\t\tif (edges[i].first != edges[i - 1].first) {\n\t\t\t\tfor (int q = back; q < i; ++q) {\n\t\t\t\t\tfor (int j = q + 1; j < i; ++j) {\n\t\t\t\t\t\tcnt[q][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += moving[i - back + 1] - (i - back + 1) - 1;\n\t\t\t\ttmp += 2LL*MOD;\n\t\t\t\ttmp %= MOD;\n\t\t\t\tback = i;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans + (MOD - tmp))%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef double lld;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<double> vdl;\ntypedef vector<vector<lli>> mat;\ntypedef vector<vdl> mad;\ntypedef unordered_map<lli,unordered_map<lli,lli>> graph;\ntypedef complex<double> cmp;\ntypedef vector<cmp> vcl;\n\nconst lli mod = 998244353;\n\nlli n;\nvector<vdl> p;\nmat c;\nmat bl;\nlli ans = 0;\n\nlld deg(vdl a,vdl from){\n  return fmod(atan2(a[1]-from[1],a[0]-from[0])+2*M_PI,2*M_PI);\n}\n\nlld deg(vdl a,vdl b,vdl from){\n  return fmod(deg(b,from)-deg(a,from)+2*M_PI,2*M_PI);\n}\n\nlli pow(lli x,lli r,lli mod = 998244353){\n  lli ret = 1;\n  for(;r != 0;r >>= 1){\n    if(r&1 != 0) ret *= x,ret %= mod;\n    x *= x,x %= mod;\n  }\n  return ret;\n}\n\nclass union_find {\nprivate:\n  unordered_map<lli,lli> par;\n  unordered_map<lli,lli> rnk;\npublic:\n  // union_find (lli n){\n  //   par = new vll(n);\n  //   iota(par->begin(),par->end(),0);\n  //   rnk = new vll(n,0);\n  // }\n  lli parent(lli x){\n    if(par[x]) return par[x];\n    else return par[x] = x;\n  }\n  lli find(lli x){\n    if(parent(x) == x) return x;\n    else return par[x] = find(parent(x));\n  }\n  void unite(lli x,lli y){\n    x = find(x);y = find(y);\n    if(x == y)return;\n    if(rnk[x] < rnk[y]) par[x] = y;\n    else {\n      par[y] = x;\n      if(rnk[x] == rnk[y]) rnk[x]++;\n    }\n  }\n  bool same(lli x,lli y){\n    return find(x) == find(y);\n  }\n};\n\nunion_find uf;\nmap<lli,set<lli>> m;\n\n\nint main(){\n  cin >> n;\n  p = vector<vdl>(n,vdl(2));\n  for(lli i = 0;i < n;i++) cin >> p[i][0] >> p[i][1];\n  c = mat(n,vll(n));\n  for(lli i = 0;i < n;i++){\n    for(lli j = i+1;j < n;j++){\n      for(lli k = j+1;k < n;k++){\n        lld d = deg(p[k],p[j],p[i]);\n        if(abs(d) < DBL_MIN*100 || abs(d-M_PI) < DBL_MIN*100){\n          uf.unite(i*n+j,i*n+k);\n          uf.unite(i*n+j,j*n+k);\n          uf.unite(i*n+k,j*n+k);\n        }\n      }\n    }\n  }\n  for(lli i = 0;i < n;i++){\n    for(lli j = i+1;j < n;j++){\n      m[uf.find(i*n+j)].insert(i);\n      m[uf.find(i*n+j)].insert(j);\n    }\n  }\n  for(auto x : m){\n    // cout << x.second.size() << endl;\n    ans += pow(2,x.second.size())-1-x.second.size();\n  }\n  ans += 1;\n  ans += n;\n  cout << ((pow(2ll,n)-ans+mod)%mod) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a),i##formax=(b);i<i##formax;i++)\n#define FORR(i,a,b) for(int i=(a),i##formax=(b);i>=i##formax;i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define pcnt __builtin_popcount\n#define sz(x) (int)(x).size()\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define all(a) (a.begin()),(a.end())\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define perm(c) sort(all(c));for(bool c##p=1;c##p;c##p=next_permutation(all(c)))\n#define bitComb(a,n,k) for(int a##x,a##y,a=(1<<k)-1;a<(1<<n);a##x=a&-a,a##y=a+a##x,a=(((a&~a##y)/a##x)>>1)|a##y)\n#define uniq(v) sort(all(v));v.erase(unique(all(v)), v.end())\n#define bit(n) (1LL<<(n))\n#define randInt(l,r) (uniform_int_distribution<ll>(l,r)(rnd))\n#define randDouble(l,r) (uniform_real_distribution<double>(l,r)(rnd))\n#define dout(d) printf(\"%.12f\\n\",d)\n\ntypedef long long ll;\ntypedef __int128_t lll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T>using V=vector<T>;\ntemplate<class T>using VV=V<V<T>>;\ntemplate<class T,class Y>ostream& operator<<(ostream& o,const pair<T,Y>& p){return o<<\"(\"<<p.fi<<\", \"<<p.se<<\")\";}\ntemplate<typename A,size_t N,typename T>void Fill(A (&array)[N],const T&v){fill((T*)array,(T*)(array+N),v);}\nlll gcd(lll a,lll b,lll &x,lll &y){if(!b){x=1;y=0;return a;}lll d=gcd(b,a%b,y,x);y-=a/b*x;return d;}\nll gcd(ll a,ll b){lll x=0,y=0;return gcd(a,b,x,y);}\nll modInv(ll a,ll m){lll x,y;gcd(a,m,x,y);return (x%m+m)%m;}\nll modPow(lll a,lll n,ll m){if(!a)return a;lll p=1;for(;n>0;n>>=1,a=a*a%m)if(n&1)p=p*a%m;return(ll)p;}\nbool isPrime(ll n){if(n<2||n%2==0)return n==2;lll t=n-1,d=t/(t&-t);for(lll a:{2,325,9375,28178,450775,9780504,1795265022})if(a%n){for(t=d,a=modPow(a,t,n);t!=n-1&&a!=1&&a!=n-1;a=a*a%n,t=t*2%n);if(a!=n-1&&t%2==0)return 0;}return 1;}\nconst int IINF = 1e9+6;\nconst ll LINF = 1e18;\nconst int MOD = 998244353;\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nstatic random_device rd;\nstatic mt19937 rnd(rd());\n\nconst int N = 2e2;\nbool comp(pii a, pii b) {\n    return a.se*b.fi < b.se*a.fi;\n}\nint n, x[N], y[N];\nmain(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n;\n  FOR(i, 0, n) cin >> x[i] >> y[i];\n  ll ans = modPow(2, n, MOD) - (n*n+n+2)/2;\n  FOR(i, 0, n){\n    V<pii> v;\n    FOR(j, 0, n){\n      if(i==j) continue;\n      int dx = x[j]-x[i], dy = y[j]-y[i];\n      if(dx < 0) dx *= -1, dy *= -1;\n      if(dx == 0) dy = abs(dy);\n      v.pb(mp(dx, dy));\n    }\n    sort(all(v), comp);\n    V<pii>::iterator l = v.begin();\n    while(l != v.end()){\n      V<pii>::iterator r = upper_bound(all(v), *l, comp);\n      int d = r-l+1;\n      ans -= (modPow(2, d, MOD)-(d*d+d+2)/2) * modInv(d, MOD) % MOD;\n      l = r;\n    }\n  }\n  cout << (ans%MOD+MOD)%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nvpint ps;\n\nconst int mod=998244353;\nint po[222];\n\nbool ok(pint d,pint dd){\n    if(d.fi==0)return dd.fi==0;\n    return d.fi*dd.se==d.se*dd.fi;\n}\n\nsigned main(){\n    po[0]=1;\n    for(int i=1;i<222;i++)po[i]=po[i-1]*2%mod;\n\n    cin>>N;\n    rep(i,N){\n        int x,y;\n        cin>>x>>y;\n        ps.pb({x,y});\n    }\n    sort(all(ps));\n\n\n    int ans=N+1;\n    rep(i,N){\n        for(int j=i+1;j<N;j++){\n            int num=0;\n            pint d={ps[j].fi-ps[i].fi,ps[j].se-ps[i].se};\n            for(int k=j+1;k<N;k++){\n                pint dd={ps[k].fi-ps[i].fi,ps[k].se-ps[i].se};\n                if(ok(d,dd))num++;\n            }\n            ans=(ans+po[num])%mod;\n        }\n    }\n\n    cout<<(po[N]-ans+mod)%mod<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define lf double\n#define E complex<lf>\n#define inf 0x3f3f3f3f\n#define eps 1e-8\n#define pa pair<int,int>\n#define pb push_back\n#define ms(x,y) memset(x,y,sizeof(x))\n#define l(x) (x<<1)\n#define r(x) (x<<1|1)\n#define mod 998244353\n#define N 210\nusing namespace std;\ninline ll read() {\n\tll x=0,f=1;char c=getchar();\n\twhile (c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n\twhile (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n\treturn x*f;\n}\nint n,bin[N];\nstruct hhh {\n\tint x,y;\n}p[N];\nint main() {\n\tn=read(),bin[0]=1;\n\tfor (int i=1; i<=n; i++) p[i].x=read(),p[i].y=read(),bin[i]=bin[i-1]*2%mod;\n\tint ans=bin[n]-n-1;\n\tfor (int i=1; i<n; i++) \n\t\tfor (int j=i+1; j<=n; j++) {\n\t\t\tint cnt=0;\n\t\t\tfor (int k=j+1; k<=n; k++) if ((p[i].y-p[k].y)*(p[j].x-p[k].x)==(p[j].y-p[k].y)*(p[i].x-p[k].x)) cnt++;\n//\t\t\tcout << cnt << endl;\n\t\t\t(ans-=bin[cnt])%=mod;\n\t\t}\n\tans=(ans+mod)%mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cerr << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int maxn = 210;\nconst ll MOD = 998244353;\nconst ll i2 = (MOD + 1) / 2;\n\nll p2[maxn];\nbool f[maxn][maxn];\n\nint main() {\n\tp2[0] = 1;\n\tfor (int i = 1; i < maxn; ++i) {\n\t\tp2[i] = p2[i-1] * 2 % MOD;\n\t}\n\n\tint N; cin >> N;\n\tV<pii> pt;\n\trep(i, N) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpt.eb(x, y);\n\t}\n\n\tll all = p2[N];\n\tll ng = 1 + N;\n\n\trep(i, N) {\n\t\trep(j, N) if (j != i) {\n\t\t\tif (f[i][j]) continue;\n\t\t\tV<int> vec{i, j};\n\n\t\t\trep(k, N) {\n\t\t\t\tif (k != i && k != j) {\n\t\t\t\t\tint a = pt[k].fi - pt[i].fi, b = pt[k].se - pt[i].se;\n\t\t\t\t\tint p = pt[j].fi - pt[i].fi, q = pt[j].se - pt[i].se;\n\t\t\t\t\tif (a * q - b * p == 0) {\n\t\t\t\t\t\tvec.pb(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint sz = vec.size();\n\t\t\trep(a, sz) {\n\t\t\t\trep(b, a) {\n\t\t\t\t\tf[vec[b]][vec[a]] = f[vec[a]][vec[b]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdump(sz);\n\n\t\t\tll u = (p2[sz] - sz - 1) % MOD;\n\t\t\tif (u < 0) u += MOD;\n\t\t\tng += u;\n\t\t\tng %= MOD;\n\t\t}\n\t}\n\n\tall -= ng;\n\tif (all < 0) all += MOD;\n\tcout << all << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//HEAD_OF_CONFIG_\n\nstatic const int MOD=998244353;\nstatic const long long MODL=1000000000000000003LL;\nstatic const double eps=1e-8;\n\n//TAIL_OF_CONFIG_\n\n//HEAD_OF_JKI'S_HEADER_\n\n    //TYPEDEF\n    typedef long long lld;\n    typedef unsigned long long u64;\n    typedef pair<int, int> pii;\n\n    //COMPARE\n    template<class T> inline T MIN(const T x, const T y){ return (x<y)?x:y; }\n    template<class T> inline T MAX(const T x, const T y){ return (x>y)?x:y; }\n\n    template<class T> inline void UPDMIN(T &x, const T y){ if(x>y)x=y; }\n    template<class T> inline void UPDMAX(T &x, const T y){ if(x<y)x=y; }\n\n    //STL\n    template<class T>  inline int SIZE(const T &x){ return (int)x.size(); }\n    template<class T>  inline int LENGTH(const T &x){ return (int)x.length(); }\n    template<class T1, class T2> inline pair<T1, T2> MP(const T1 &x, const T2 &y){ return make_pair(x, y); }\n\n    //BIT\n    inline int BINT(const int x){ return 1<<x; }\n    inline lld BLLD(const int x){ return 1LL<<x; }\n    inline int BINT_TEST(const int s, const int x){ return (s&BINT(x))!=0; }\n    inline int BLLD_TEST(const lld s, const int x){ return (s&BLLD(x))!=0LL; }\n\n    template<class T> inline T LOWBIT(const T x){ return (x^(x-1))&x; }\n    template<class T> inline int BITCOUNT(const T x){ return (!x)?x:(1+BITCOUNT(x&(x-1))); }\n\n    //CONST VALUE\n    const double PI=acos(-1.0);\n    const double EPS=1e-5;\n\n    //CALCULATE\n    template<class T> inline T SQR(const T x){ return x*x; }\n    template<class T1, class T2> inline T1 POW(const T1 x, const T2 y){\n        if(!y)return 1;else if((y&1)==0){\n            return SQR(POW(x, y>>1));\n        }else return POW(x, y^1)*x;\n    }\n\n    //NUMBERIC\n    template<class T> inline T GCD(const T x, const T y){\n        if(x<0)return GCD(-x, y);\n        if(y<0)return GCD(x, -y);\n        return (!y)?x:GCD(y, x%y);\n    }\n    template<class T> inline T LCM(const T x, const T y){\n        if(x<0)return LCM(-x, y);\n        if(y<0)return LCM(x, -y);\n        return x*(y/GCD(x, y));\n    }\n    template<class T> inline T EEA(const T a, const T b, T &x, T &y){\n        /* a*x+b*y == GCD(a, b) == EEA(a, b, x, y) */\n        if(a<0){ T d=EEA(-a, b, x, y); x=-x; return d; }\n        if(b<0){ T d=EEA(a, -b, x, y); y=-y; return d; }\n        if(!b){\n            x=1; y=0; return a;\n        }else{\n            T d=EEA(b, a%b, x, y);\n            T t=x; x=y; y=t-(a/b)*y;\n            return d;\n        }\n    }\n    template<class T> inline vector<pair<T, int> > FACTORIZE(T x){\n        vector<pair<T, int> > ret;\n        if(x<0)x=-x;\n        for (T i=2;x>1;){\n            if(x%i==0){\n                int count=0;\n                for(;x%i==0;x/=i)count++;\n                ret.push_back(MP(i, count));\n            }\n            i++;if(i>x/i)i=x;\n        }\n        return ret;\n    }\n    template<class T> inline int ISPRIME(const T x){\n        if(x<=1)return 0;\n        for(T i=2; SQR(i)<=x; i++)if(x%i==0)return 0;\n        return 1;\n    }\n    template<class T> inline T EULARFUNCTION(T x){\n        vector<pair<T, int> > f=FACTORIZE(x);\n        for(typename vector<pair<T, int> >::iterator it=f.begin(); it!=f.end(); it++){\n            x=x/it->first*(it->first-1);\n        }\n        return x;\n    }\n    template<class T> inline T INVERSEE(const T a, const T b=MOD){\n        T x, y;\n        EEA(a, b, x, y);\n        return x?x:1;\n    }\n    int *PRIMELIST(const int til, int *length=NULL){\n        int *foo=(int*)malloc(sizeof(int)*(til+1));\n        int len=0;\n        memset(foo, 0, sizeof(int)*(til+1));\n        for(int i=2; i<=til; i++){\n            if(!foo[i])foo[len++]=i;\n            for(int j=0; j<len && foo[j]<=til/i; j++){\n                foo[foo[j]*i]=1;\n                if(i%foo[j]==0)break;\n            }\n        }\n        if(length!=NULL){\n            *length=len;\n        }\n        foo[len++]=0;\n        foo=(int*)realloc(foo, sizeof(int)*len);\n        return foo;\n    }\n\n    //REMINDER-LIZATION\n    template<class T> inline T MOD_STD(const T x, const T m=MOD){ return (x%m+m)%m; }\n    template<class T> inline void MOD_STD(T *x, const T m=MOD){ *x=(*x%m+m)%m; }\n    template<class T> inline T MOD_ADD(const T x, const T y, const T m=MOD){ return (x+y)%m; }\n    template<class T> inline void MOD_ADD(T *x, const T y, const T m=MOD){ *x=(*x+y)%m; }\n    template<class T> inline T MOD_MUL(const T x, const T y, const T m=MOD){ return (T)((1LL*x*y)%m); }\n    template<class T> inline void MOD_MUL(T *x, const T y, const T m=MOD){ *x=(T)((1LL*(*x)*y)%m); }\n    template<class T1, class T2> inline T1 MOD_POW(const T1 x, const T2 y, const T1 m=MOD){\n        if(y==0)return 1%m;else if((y&1)==0){\n            T1 z=MOD_POW(x, y>>1, m); return MOD_MUL(z, z, m);\n        }else return MOD_MUL(MOD_POW(x, y^1, m), x, m);\n    }\n    inline lld MODL_MUL(lld x, lld y, const lld m=MOD){\n        if(x<y)swap(x, y);\n        lld z=0LL;\n        while(y>0){\n            if(y&1){\n                MOD_ADD(&z, x, m);\n            }\n            MOD_ADD(&x, x, m);\n            y>>=1;\n        }\n        return z;\n    }\n    inline lld MODL_POW(const lld x, const lld y, const lld m=MOD){\n        if(y==0LL)return 1LL%m;else if((y&1)==0LL){\n            lld z=MODL_POW(x, y>>1, m); return MODL_MUL(z, z, m);\n        }else return MODL_MUL(MODL_POW(x, y^1, m), x, m);\n    }\n\n    //MATRIX\n    template<class T> class MATX{\n        private:\n            unsigned long hig, wid;\n            T *data;\n\n            void __init(){\n                this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                memset(this->data, 0, sizeof(T)*this->hig*this->wid);\n            }\n\n        public:\n            MATX(){ \n                this->hig=this->wid=1;\n                __init();\n            }\n            MATX(const unsigned long _len){\n                this->hig=this->wid=_len;\n                __init();\n            }\n            MATX(const unsigned long _hig, const unsigned long _wid){\n                this->hig=_hig;\n                this->wid=_wid;\n                __init();\n            }\n            MATX(const MATX &rhs){\n                this->hig=rhs.hig;\n                this->wid=rhs.wid;\n                this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=rhs.at(x, y);\n            }\n            ~MATX(){\n                free(this->data);\n            }\n\n            T & operator()(const unsigned long x, const unsigned long y){\n                if(x>=this->hig || y>=this->wid)return (*(T*)NULL);\n                return this->data[x*this->wid+y];\n            }\n\n            T * operator[](const unsigned long x){\n                if(x>=this->hig)return (T*)NULL;\n                return this->data+(x*this->wid);\n            }\n\n            MATX & operator=(const MATX &rhs){\n                if(this->hig!=rhs.hig || this->wid!=rhs.wid){\n                    free(this->data);\n                    this->hig=rhs.hig;\n                    this->wid=rhs.wid;\n                    this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                }\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=rhs.at(x, y);\n                return *this;\n            }\n\n            const MATX operator+(const MATX &opn) const{\n                MATX ret(*this);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        ret.data[x*ret.wid+y]+=opn.at(x, y);\n                return ret;\n            }\n            const MATX operator-(const MATX &opn) const{\n                MATX ret(*this);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        ret.data[x*ret.wid+y]-=opn.at(x, y);\n                return ret;\n            }\n            const MATX operator*(const MATX &opn) const{\n                MATX ret(this->hig, opn.wid);\n                const unsigned long len=MIN(this->wid, opn.hig);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        for(unsigned long z=0; z<len; z++)\n                            ret.data[x*ret.wid+y]+=this->at(x, z)*opn.at(z, y);\n                return ret;\n            }\n\n            const MATX mul(const MATX &opn) const{ return *this*opn; }\n            template<class T2> const MATX mul(const MATX &opn, const T2 m) const{\n                MATX ret(this->hig, opn.wid);\n                const unsigned long len=MIN(this->wid, opn.wid);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        for(unsigned long z=0; z<len; z++)\n                            MOD_ADD(&ret.data[x*ret.wid+y], MOD_MUL(this->at(x, z), opn.at(z, y), m), m);\n                return ret;\n            }\n\n            MATX & operator +=(const MATX &rhs){\n                *this=*this+rhs;\n                return *this;\n            }\n            MATX & operator -=(const MATX &rhs){\n                *this=*this-rhs;\n                return *this;\n            }\n            MATX & operator *=(const MATX &rhs){\n                *this=*this*rhs;\n                return *this;\n            }\n\n            const MATX pow(const unsigned long p) const{\n                MATX buff(*this), ret(this->hig, this->wid);\n                ret.set_one();\n                if(p>0)for(unsigned long i=1;;i<<=1){\n                    if(p&i)ret*=buff;\n                    buff*=buff;\n                    if(i>(p>>1))break;\n                }\n                return ret;\n            }\n            template<class T2> const MATX pow(const unsigned long p, const T2 m) const{\n                MATX buff(*this), ret(this->hig, this->wid);\n                ret.set_one();\n                if(p>0)for(unsigned long i=1;;i<<=1){\n                    if(p&i)ret=ret.mul(buff, m);\n                    buff=buff.mul(buff, m);\n                    if(i>(p>>1))break;\n                }\n                return ret;\n            }\n\n\n            const T at(const unsigned long x, const unsigned long y) const{\n                if(x>=this->hig || y>=this->wid)return 0;\n                return this->data[x*wid+y];\n            }\n\n            void show() const{\n                for(unsigned long x=0; x<this->hig; x++){\n                    for(unsigned long y=0; y<this->wid; y++)\n                        cout<<this->at(x, y)<<\" \";\n                    cout<<endl;\n                }\n            }\n\n            void set_one(){\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=(x==y)?1:0;\n            }\n\n    };\n\n    //Complex\n    template<class T> class complex_t{\n        public:\n        T r, i;//real part & imaginary part; x+yi\n        complex_t(T x=0.0, T y=0.0){ this->r=x; this->i=y; }\n        complex_t operator + (const complex_t &opn) const { return complex_t(this->r+opn.r, this->i+opn.i); }\n        complex_t operator - (const complex_t &opn) const { return complex_t(this->r-opn.r, this->i-opn.i); }\n        complex_t operator * (const complex_t &opn) const { return complex_t(this->r*opn.r-this->i*opn.i, this->r*opn.i+this->i*opn.r); }\n    };\n\n    template<class T> void fast_fourier_trans(complex_t<T> f[], const int len, const int is_dft){\n        for(int i=1, j=len>>1; i<len-1; i++){\n            if(i<j)swap(f[i], f[j]);\n            int k=len>>1;\n            while(j>=k){\n                j-=k;\n                k>>=1;\n            }\n            if(j<k)j+=k;\n        }\n        for(int h=2; h<=len; h<<=1){\n            complex_t<T> wn(cos(is_dft?(-2*PI/h):(2*PI/h)), sin(is_dft?(-2*PI/h):(2*PI/h)));\n            for(int i=0; i<len; i+=h){\n                complex_t<T> wm(1.0, 0.0);\n                for(int j=i; j<i+(h>>1); j++){\n                    complex_t<T> u = f[j];\n                    complex_t<T> t = wm*f[j+(h>>1)];\n                    f[j] = u+t;\n                    f[j+(h>>1)] = u-t;\n                    wm = wm*wn;\n                }\n            }\n        }\n        if(!is_dft){\n            for(int i=0; i<len; i++)\n                f[i].r/=len*1.0;\n        }\n    }\n\n    //MILLERRABIN\n    class MILLERRABIN{\n        private:\n        static const int prime_table[12];\n        int witness(lld a, lld d, lld s, lld n){\n            lld r=MODL_POW(a, d, n);\n            if(r==1 || r==n-1)return 0;\n            for(int i=0; i<s-1; i++){\n                r = MODL_MUL(r, r, n);\n                if(r==1)return 1;\n                if(r==n-1)return 0;\n            }\n            return 1;\n        }\n        public:\n        int test(const lld n){\n            if(n<=2LL) return 0;\n            lld p=n-1LL, s=0LL;\n            while(!(p&1)){ p>>=1;s++; }\n            for(int i=0; i<12 && this->prime_table[i]<n; i++){\n                if(witness(this->prime_table[i], p, s, n))return 0;\n            }\n            return 1;\n        }\n    };\n    const int MILLERRABIN::prime_table[12] = { 2, 3, 5, 7, 11, 13 ,17, 19, 23, 29, 31, 37 };\n\n    //Computational Geometry\n\n    template<class T> inline int fsign(const T x){\n        if(x>-eps && x<eps)return 0;\n        return (x<0.0)?-1:1;\n    }\n\n    template<class T> class point_t{\n        public:\n        T x, y;\n        int idx;\n        point_t (){\n            this->x=0.0;\n            this->y=0.0;\n        }\n        point_t (const T _x, const T _y){\n            this->x=_x;\n            this->y=_y;\n        }\n        point_t operator - (const point_t &rhs) const{\n            return point_t(this->x-rhs.x, this->y-rhs.y);\n        }\n        T operator ^ (const point_t &rhs) const{\n            return this->x*rhs.y - this->y*rhs.x;\n        }\n        T operator * (const point_t &rhs) const{\n            return this->x*rhs.x + this->y*rhs.y;\n        }\n        bool operator < (const point_t &rhs) const{\n            if(fsign(this->y-rhs.y)!=0)\n                return fsign(this->y-rhs.y)<0;\n            return fsign(this->x-rhs.x)<0;\n        }\n        T cross(const point_t &p, const point_t &q) const{\n            return (p-*this)^(q-*this);\n        }\n        void rotate(const double radian){\n            T x0=x, y0=y;\n            T sinr=sin(radian);\n            T cosr=cos(radian);\n            x=x0*cosr-y0*sinr;\n            y=x0*sinr+y0*cosr;\n        }\n        void rotate(const point_t &p, const double radian){\n            T x0=x-p.x, y0=y-p.y;\n            T sinr=sin(radian);\n            T cosr=cos(radian);\n            x=x0*cosr-y0*sinr+p.x;\n            y=x0*sinr+y0*cosr+p.y;\n        }\n        T dist2(const point_t &lhs, const point_t &rhs) const{\n            return (lhs-rhs)*(lhs-rhs);\n        }\n        T dist2(const point_t &rhs) const{\n            return (*this-rhs)*(*this-rhs);\n        }\n        T dist(const point_t &lhs, const point_t &rhs) const{\n            return sqrt((lhs-rhs)*(lhs-rhs));\n        }\n        T dist(const point_t &rhs) const{\n            return sqrt((*this-rhs)*(*this-rhs));\n        }\n    };\n\n    template<class T> class segment_t{\n        public:\n        point_t<T> p, q;\n        segment_t (){\n            this->p.x=this->p.y=0.0;\n            this->q.x=this->q.y=0.0;\n        }\n        template<class T2> segment_t (const point_t<T2> &_p, const point_t<T2> &_q){\n            this->p.x=_p.x;\n            this->p.y=_p.y;\n            this->q.x=_q.x;\n            this->q.y=_q.y;\n        }\n        segment_t (const T px, const T py, const T qx, const T qy){\n            this->p.x=px;\n            this->p.y=py;\n            this->q.x=qx;\n            this->q.y=qy;\n        }\n        T length() const{\n            return this->p.dist(this->q);\n        }\n        T length2() const{\n            return this->p.dist2(this->q);\n        }\n        int contain(const point_t<T> &pnt, const int ignore_endpoint=0) const{\n            if(ignore_endpoint){\n                return fsign((this->p-pnt)^(this->q-pnt))==0\n                    && fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <0\n                    && fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <0;\n            }else{\n                return fsign((this->p-pnt)^(this->q-pnt))==0\n                    && fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <=0\n                    && fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <=0;\n            }\n        }\n        int intersection(const segment_t &sa, const segment_t &sb, const int ignore_endpoint=0) const{\n            if(!ignore_endpoint){\n                if(sa.contain(sb.p) || sa.contain(sb.q) || sb.contain(sa.p) || sb.contain(sa.q))\n                    return 1;\n            }\n            return fsign(sa.p.cross(sa.q, sb.p))*fsign(sa.p.cross(sa.q, sb.q))<0\n                && fsign(sb.p.cross(sb.q, sa.p))*fsign(sb.p.cross(sb.q, sa.q))<0;\n        }\n        int intersection(const segment_t &rhs, const int ignore_endpoint=0) const{\n            return this->intersection(*this, rhs, ignore_endpoint);\n        }\n    };\n\n    #ifndef __APPLE__\n    template<class T> static int compare_pas(const void *x, const void *y, void *z){\n    #else\n    template<class T> static int compare_pas(void *z, const void *x, const void *y){\n    #endif\n        const point_t<T> *p1 = (point_t<T>*)x;\n        const point_t<T> *p2 = (point_t<T>*)y;\n        const point_t<T> *p0 = (point_t<T>*)z;\n        int sgn = fsign(((*p1)-(*p0))^((*p2)-(*p0)));\n        if(sgn!=0)return -sgn;\n        return fsign(p0->dist2(*p1)-p0->dist2(*p2));\n    }\n    template<class T> void polar_angle_sort(point_t<T> *pnts, const int n){\n        int p=0;\n        for(int i=1; i<n; i++){\n            if(pnts[p]<pnts[i])p=i;\n        }\n        swap(pnts[0], pnts[p]);\n        #ifndef __APPLE__\n        qsort_r(pnts+1, n-1, sizeof(point_t<T>), compare_pas<T>, pnts);\n        #else\n        qsort_r(pnts+1, n-1, sizeof(point_t<T>), pnts, compare_pas<T>);\n        #endif\n    }\n\n    template<class T> void graham(point_t<T> *pnts, const int n, int *idx, int &m){\n        polar_angle_sort(pnts, n);\n        m=0;\n        if(n<3)return;\n        idx[m++]=0;\n        idx[m++]=1;\n        for(int i=2; i<n; i++){\n            while(m>1 && fsign(pnts[idx[m-2]].cross(pnts[idx[m-1]], pnts[i]))<=0)m--;\n            idx[m++]=i;\n        }\n    }\n\n\n//TAIL_OF_JKI'S_HEADER\n\nint n, ans;\npoint_t<double> a[210];\n\nint vst[41000], pow2[210];\n\nint sub2(const int k){\n    return MOD_ADD(pow2[k], -k-1);\n}\n\nint main(){\n    pow2[0]=1;\n    for(int i=1; i<210; i++){\n        pow2[i]=MOD_MUL(pow2[i-1], 2);\n    }\n    while(scanf(\"%d\", &n)!=EOF){\n        for(int i=0; i<n; i++){\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            a[i].x=x*1.0;\n            a[i].y=y*1.0;\n            a[i].idx=i;\n        }\n        memset(vst, 0, sizeof(vst));\n        ans=sub2(n);\n        for(int s=0; s<n; s++){\n            polar_angle_sort(a+s, n-s);\n            for(int i=s+1; i<n; i++){\n                int j=i;\n                while(j+1<n && fsign((a[j+1]-a[s])^(a[i]-a[s]))==0)j++;\n                int mask=a[s].idx*n+a[i].idx;\n                if(!vst[mask]){\n                    for(int k=i; k<=j; k++){\n                        int curr=a[s].idx*n+a[k].idx;\n                        vst[curr]=1;\n                    }\n                    for(int x=i; x<=j; x++){\n                        for(int y=x+1; y<=j; y++){\n                            int curr=a[x].idx*n+a[y].idx;\n                            vst[curr]=1;\n                        }\n                    }\n                    MOD_ADD(&ans, -sub2(j-i+2));\n                }\n                i=j;\n            }\n        }\n        MOD_STD(&ans);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<ctime>\n#include<random>\nusing namespace std;\n\nint n;\nvector<pair<int, int> > v;\n\nbool use[202];\nlong long int p2[202];\n#define MOD 998244353\nint main(){\n\tp2[0] = 1;\n\tfor (int i = 1; i < 202; i++){\n\t\tp2[i] = p2[i - 1];\n\t\tp2[i] *= 2;\n\t\tif (p2[i] >= MOD){\n\t\t\tp2[i] %= MOD;\n\t\t}\n\t}\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tv.push_back(make_pair(a, b));\n\t}\n\tlong long int ng = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tng++;\n\t\tmemset(use, false, sizeof(use));\n\t\tfor (int j = i + 1; j < n; j++){\n\t\t\tint cnt = 1;\n\t\t\tif (use[j])continue;\n\t\t\tuse[j] = true;\n\t\t\tpair<long long int, long long int> vec = make_pair(v[j].first - v[i].first, v[j].second - v[i].second);\n\t\t\tfor (int k = j+1; k < n; k++){\n\t\t\t\tpair<long long int, long long int> vec2 = make_pair(v[k].first - v[i].first, v[k].second - v[i].first);\n\t\t\t\tif (vec.first*vec2.second == vec.second*vec2.first){\n\t\t\t\t\tuse[k] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long int way = p2[cnt];\n\t\t\tway += MOD - 1;\n\t\t\tif (way >= MOD)way %= MOD;\n\t\t\tng += way;\n\t\t\tif (ng >= MOD)ng %= MOD;\n\t\t}\n\t}\n\tlong long int ALL = p2[n] + MOD - 1 + MOD - ng;\n\tALL %= MOD;\n\tprintf(\"%lld\\n\", ALL);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<L>se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\t//if(se.find({i,j})!=se.end())continue;\n\t\tL l(v[i],v[j]);\n\t\tvector<int>x={i,j};\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectSP(l,v[k]))x.push_back(k);\n\t\tr=(r-pow_binary_mod(2,x.size()-2,M))%M;\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\t//se.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iostream>\n#include <ios>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) < norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[201][201] = {0};\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "include <bits/stdc++.h>\n#define maxn 100010\ntypedef long long LL;\nconst LL mod = 998244353;\nLL x[maxn], y[maxn], P[maxn];\nint main() {\n    LL n;\n    scanf(\"%lld\", &n);\n    for (int i = 0; i < n; ++i) scanf(\"%lld%lld\", &x[i], &y[i]);\n    P[0] = 1;\n    for (int i = 1; i <= n; ++i) (P[i] = P[i-1] << 1) %= mod;\n    LL ans = P[n] - 1 - n - n*(n-1)/2;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            int cnt = 0;\n            for (int k = j+1; k < n; ++k) {\n                if ((x[j]-x[i]) * (y[k]-y[j]) == (x[k]-x[j]) * (y[j]-y[i])) ++cnt;\n            }\n            ((ans -= P[cnt]-1) += mod) %= mod;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n#include \"ext/pb_ds/tree_policy.hpp\"\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define all(x) x.begin(), x.end()\n#define IO ios :: sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define pii pair<int,int>\n#define sz(x) (int)x.size()\nconst int mod = 1e9 + 7;\nconst int mod1 = 998244353;\ntypedef long double f80;\n\n#ifndef LOCAL\n#pragma GCC optimize (\"O2\")\n#define endl '\\n'\n#endif\n\ntemplate<typename T>\nusing ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rand(int l, int r){\n    uniform_int_distribution<int> uid(l, r);\n    return uid(rng);\n}\n\nll pwr(ll a,ll b, ll mod){\n    a %= mod;\n    int ans = 1;\n    while(b){\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nconst int N = 205;\npii p[N];\nmap<pair<int,pii>,int> m;\nint g[N * N];\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tfr(i ,1, n){\n\t\tcin >> p[i].fi >> p[i].se;\n\t}\n\tint ans = pwr(2, n, mod1);\n\tfr(i, 1, n){\n\t\tfr(j, i + 1, n){\n\t\t\tint a = (p[j].se - p[i].se);\n\t\t\tint b = (p[i].fi - p[j].fi);\n\t\t\tint c = (p[i].se * (p[j].fi - p[i].fi) - p[i].fi * (p[j].se - p[i].se));\n\t\t\tint g = abs(__gcd(a, __gcd(b, c)));\n\t\t\tif((a == 0 && b < 0) || a < 0)\n\t\t\t\tg *= -1;\n\t\t\ta /= g, b /= g, c /= g;\n\t\t\tm[{a, {b, c}}]++;\n\t\t}\n\t}\n\tfr(i, 1, N - 1){\n\t\tg[(i * (i - 1)) / 2] = i;\n\t}\n\tfor(auto it : m){\n\t\tint c = it.se;\n\t\tc = g[c];\n\t\tint val = (pwr(2, c,mod1) - c - 1 + mod1) % mod1;\n\t\tans = (ans - val + mod1) % mod1;\n\t}\n\tans -= n + 1;\n\tans = (ans + mod1) % mod1;\n\tcout << ans;\n}\nsigned main(){\n    IO;\n    #ifdef LOCAL\n        freopen(\"inp.txt\",\"r\", stdin);\n        freopen(\"out.txt\", \"w\", stdout);\n    #endif\n    cout << setprecision(10) << fixed;\n    int t = 1;\n    // cin >> t;\n    fr(tt, 1, t){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n对于凸包点集 S ，其贡献为 2^k ，其中 k 是该凸包包含的点数除去顶点。\n设 T 表示这 k 个点组成的集合，那么 2^k 就是 T 的子集数量。\n\n那么每个 (S, U) 二元组对答案的贡献为 1 ，其中 U 是 T 的子集。\n而事实上 (S, U) 与 S 并 U 是一一对应的，\n因为一个点集的凸包是唯一的，也就是说已知 S 并 U 可以求出唯一的 S ，进而求出唯一的 U 。\n那么答案就是合法的 S 并 U 的点集数量。\n\n合法指的是什么？指的就是存在凸包。\n那么什么样的点集不合法呢？一个点集 X 不合法当且仅当 X 的点共线或者 |X| < 3 。\n\n那么可以简单容斥，用满足 |X| >= 3 的 X 的数量减去不合法的 X 数量。\n也就是统计共线的点集数，n 很小，枚举两个点，它们唯一确定一条直线，\n然后再暴力统计该直线上有多少点即可，这样一个 X 会被算多次，除掉算重次数即可。\n\n另外也可以枚举共线 X 的两个端点，然后暴力统计端点构成的线段之间有多少点，设为 k ，\n那么这两个端点对不合法点集的贡献就是 2^k ，这样的好处是不会算重，更好理解。\n\n总复杂度 O(n^3) ，事实上统计一条直线上的点数有更优秀的做法，可以做到 O(n^2logn) ，\n但本题中 O(n^3) 已经足够了。\n#endif\n#include <cstdio>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 205, mod = 998244353;\n\ninline ll sq(ll x) { return x * x; }\ninline bool in_line(ll x1, ll y1, ll x2, ll y2) {\n\tll a = x1 * x2 + y1 * y2;\n\tll b = (sq(x1) + sq(y1)) * (sq(x2) + sq(y2));\n\t/* debug(\"chk %lld %lld\\n\", sq(a), b); */\n\treturn a >= 0 and sq(a) == b;\n}\n\nint x[maxn], y[maxn];\nll p2[maxn];\n\nint main() {\n\tint n = read;\n\tfor(int i = 1; i <= n; i ++)\n\t\tread(x[i], y[i]);\n\n\tp2[0] = 1;\n\tfor(int i = 1; i <= n; i ++)\n\t\tp2[i] = (p2[i - 1] << 1) % mod;\n\n\tll ans = p2[n] - n - 1;\n\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j < i; j ++) {\n\t\t\tint tot = 0;\n\t\t\tfor(int k = 1; k <= n; k ++)\n\t\t\t\tif(k != i and k != j and\n\t\t\t\t\t\tin_line(x[i] - x[k], y[i] - y[k], x[k] - x[j], y[k] - y[j]))\n\t\t\t\t\tdebug(\"%d %d %d\\n\", i, k, j),\n\t\t\t\t\t++ tot;\n\t\t\tans -= p2[tot];\n\t\t}\n\n\tprintf(\"%lld\\n\", (ans % mod + mod) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\n#define ZERO(a) memset(a,0,sizeof(a))\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n#define exists find_if\n#define forall all_of\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\n\ninline void input(int &v){ v=0;char c=0;int p=1; while(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();} while(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();} v*=p; }\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\nstring bits_to_string(ll input, ll n=64) { string s; rep(i, n) s += '0' + !!(input & (1ll << i)); reverse(all(s)); return s; }\ntemplate <typename T> ostream &operator<<(ostream &o, const priority_queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} o << endl; return o; }\n\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\n\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nnamespace myhash{ const int Bsizes[]={3,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81}; const int xor_nums[]={0x100007d1,0x5ff049c9,0x14560859,0x07087fef,0x3e277d49,0x4dba1f17,0x709c5988,0x05904258,0x1aa71872,0x238819b3,0x7b002bb7,0x1cf91302,0x0012290a,0x1083576b,0x76473e49,0x3d86295b,0x20536814,0x08634f4d,0x115405e8,0x0e6359f2}; const int hash_key=xor_nums[rand()%20]; const int mod_key=xor_nums[rand()%20]; template <typename T> struct myhash{ std::size_t operator()(const T& val) const { return (hash<T>{}(val)%mod_key)^hash_key; } }; };\ntemplate <typename T> class uset:public std::unordered_set<T,myhash::myhash<T>> { using SET=std::unordered_set<T,myhash::myhash<T>>; public: uset():SET(){SET::rehash(myhash::Bsizes[rand()%20]);} };\nuint32_t randxor() { static uint32_t x=1+(uint32_t)random_seed,y=362436069,z=521288629,w=88675123; uint32_t t; t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) ); }\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ gettimeofday(&start, NULL); ios::sync_with_stdio(false); cin.tie(0); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define rand randxor\n\nstatic const long long mo = 998244353;\nclass Mod {\n    public:\n        int num;\n        Mod() : Mod(0) {}\n        Mod(long long int n) : num(n) { }\n        Mod(const string &s){ long long int tmp = 0; for(auto &c:s) tmp = (c-'0'+tmp*10) % mo; num = tmp; }\n        Mod(int n) : Mod(static_cast<long long int>(n)) {}\n        operator int() { return num; }\n};\nistream &operator>>(istream &is, Mod &x) { long long int n; is >> n; x = n; return is; }\nostream &operator<<(ostream &o, const Mod &x) { o << x.num; return o; }\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mo); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mo + a.num - b.num) % mo); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mo); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod factorial(const long long n) {\n    if (n < 0) return 0;\n    Mod ret = 1;\n    for (int i = 1; i <= n; i++) {\n        ret *= i;\n    }\n    return ret;\n}\nMod operator^(const Mod a, const long long n) {\n    if (n == 0) return Mod(1);\n    Mod res = (a * a) ^ (n / 2);\n    if (n % 2) res = res * a;\n    return res;\n}\n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\n#define ldout fixed << setprecision(40) \nmap<tuple<ll, ll, ll>, set<ll>> lines;\nint main(void) {\n    ll n; cin >> n;\n\n    vll x(n), y(n);\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n    }\n    rep(i, n) rep(j, n) if (i < j) {\n        ll x1 = x[i], y1 = y[i], x2 = x[j], y2 = y[j];\n        ll a = y2 - y1, b = -(x2 - x1), c = (y2-y1)*x1-(x2-x1)*y1;\n        ll g = -1;\n        if (a) {\n            g = a; g = __gcd(g, b); g = __gcd(g, c);\n            a /= g, b /= g, c /= g;\n            if (a < 0) a *= -1, b *= -1, c *= -1;\n        } else {\n            g = b; g = __gcd(g, a); g = __gcd(g, c);\n            a /= g, b /= g, c /= g;\n            if (b < 0) a *= -1, b *= -1, c *= -1;\n        }\n        lines[mt(a, b, c)].insert(i);\n        lines[mt(a, b, c)].insert(j);\n    }\n\n    Mod ret = (Mod(2)^(n)) - Mod(1 + n);\n    for (auto&& line : lines) {\n//        cout << line.se << endl;\n        ret -= ((Mod(2)^((ll)line.se.size())) - Mod(1 + (ll)line.se.size()));\n    }\n    cout << ret  << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef pair<pi,pi> ppi;\n\nconst int N=205,P=998244353;\n\nmap<ppi,int>D;\nint n,x[N],y[N],p2[N],m;\n\ninline int gcd(int x,int y){return y?gcd(y,x%y):x;}\ninline pi mk(pi x){\n\tll g=gcd(x.fi,x.se);\n\tif(g)x.fi/=g,x.se/=g;\n\tif(x.fi<0)x.fi=-x.fi,x.se=-x.se;\n\telse if(x.fi==0&&x.se<0)x.se=-x.se;\n\treturn x;\n}\ninline ppi mp(ll u1,ll v1,ll u2,ll v2){\n\tpi l=mk({u2-u1,v2-v1});\n\tpi s=mk({v1*l.fi-u1*l.se,l.fi});\n\treturn {l,s};\n}\nint get(int s){\n\ts*=2;\n\tint v=sqrt(1+4*s+0.5);\n\treturn (1+v)/2;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tp2[0]=1;\n\tfor(int i=1;i<=n;i++)p2[i]=(p2[i-1]<<1)%P,scanf(\"%d%d\",&x[i],&y[i]);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<i;j++)D[mp(x[i],y[i],x[j],y[j])]++;\n\tm=p2[n];\n\tfor(auto&i:D){int t=get(i.se);m=(m-p2[t]+t+1+P)%P;}\n\tm=(m-n-1+P)%P;\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\nconst int MOD = 998244353;\nconst int INF = INT_MAX / 2;\nstruct edge { int v, w; };\n\ndouble d(int x1, int y1, int x2, int y2) {\n\tdouble dx = x1 - x2, dy = y1 - y2;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\trep(i, N) cin >> x[i] >> y[i];\n\tint ans = 1;\n\trep(t, N) ans = ans * 2 % MOD;\n\trep(i, N) rep(j, i) {\n\t\tint n = 0;\n\t\trep(k, N) if (k != i && k != j) {\n\t\t\tdouble d1 = d(x[k], y[k], x[i], y[i]);\n\t\t\tdouble d2 = d(x[k], y[k], x[j], y[j]);\n\t\t\tdouble d3 = d(x[i], y[i], x[j], y[j]);\n\t\t\tif (abs(d1 + d2 - d3) < 1e-10) n++;\n\t\t}\n\t\tint x = 1;\n\t\trep(t, n) x = x * 2 % MOD;\n\t\tans = (ans - x) % MOD;\n\t}\n\tans = (ans - N - 1) % MOD;\n\tcout << (ans + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 210;\nconst int mod = 998244353;\n\nint x[N], y[N];\nbool vis[N];\n\nLL qpow(LL a, LL b)\n{\n\tLL ret = 1, base = a;\n\twhile (b) {\n\t\tif (b & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, b >>= 1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n)scanf(\"%d%d\", &x[i], &y[i]);\n\t\n\tLL ans = qpow(2, n);\n\tRep(i, n) Rep(j, n) if (i != j){\n\t\tint cnt = 2;\n\t\tRep(k, n) if (k != i && k != j)\n\t\t\tif ((y[j] - y[i]) * (x[k] - x[i]) == (y[k] - y[i]) * (x[j] - x[i])) cnt ++;\n\t\tLL tmp = (qpow(2, cnt) - 1 - cnt + mod) % mod;\n\t\tans = (ans - tmp * qpow(cnt * (cnt - 1), mod - 2) % mod + mod) % mod;\n\t\t//printf(\"%lld %d\\n\", tmp, cnt * (cnt - 1));\n\t}\n\t\n\tans = (ans - n - 1 + mod) % mod;\n\tprintf(\"%lld\\n\", ans);\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 998244353;\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\ntemplate<typename T>\nT preback (const vector<T> &v) {\n  return *next(v.rbegin());\n}\n\ntypedef pair<int, int> point;\n#define x first\n#define y second\n\npoint operator+ (point p, point q) {\n  return {p.x + q.x, p.y + q.y};\n}\n\npoint operator- (point p) {\n  return {-p.x, -p.y};\n}\n\npoint operator- (point p, point q) {\n  return p + (-q);\n}\n\nint dot (point p, point q) {\n  return p.x * q.x + p.y * q.y;\n}\n\nint cross (point p, point q) {\n  return p.x * q.y - p.y * q.x;\n}\n\nint orient (point p, point q, point r) {\n  return cross(q - p, r - p);\n}\n\nint cw (point p, point q, point r) {\n  return cross(q - p, r - p) < 0;\n}\n\nostream& operator<< (ostream &out, point p) {\n  out << \"(\" << p.x << \" \" << p.y << \")\";\n  return out;\n}\n\nstruct basecomp {\n  point base;\n  basecomp (point _base) : base(_base) {}\n\n  bool operator() (point p, point q) {\n    if (orient(base, p, q) == 0) {\n      return dot(p - base, p - base) < dot(q - base, q - base);\n    } else {\n      return orient(base, p, q) < 0;\n    }\n  }\n};\n\nconst int MAX_N = 205;\n\nModint ans;\nModint dp [MAX_N][MAX_N];\n\nvoid solve (vector<point> &pts) {\n  sort(pts.begin(), pts.end());\n  point base = pts[0];\n  sort(pts.begin(), pts.end(), basecomp(base));\n\n  int n = pts.size();\n  for (int i = 1; i < n; i++) {\n    dp[0][i] = 1; // # of points on the line 0..i\n    for (int j = 1; j < i; j++) {\n      if (orient(base, pts[i], pts[j]) == 0) {\n        dp[0][i] *= 2;\n      }\n    }\n  }\n\n  for (int u = 1; u < n; u++) {\n    for (int v = u + 1; v < n; v++) {\n      dp[u][v] = 0;\n      for (int w = 0; w < u; w++) {\n        if (cw(pts[w], pts[u], pts[v])) {\n          dp[u][v] += dp[w][u];\n        }\n      }\n\n      // count the # of points in the triangle\n      for (int w = u + 1; w < v; w++) {\n        if (cw(base, pts[u], pts[w]) &&\n            orient(pts[u], pts[v], pts[w]) <= 0 &&\n            orient(pts[v], base, pts[w]) <= 0) {\n          dp[u][v] *= 2;\n        }\n      }\n\n      ans += dp[u][v];\n    }\n  }\n\n  /*\n  for (int u = 0; u < n; u++) {\n    for (int v = 0; v < n; v++) {\n      cout << dp[u][v] << \" \";\n    }\n    cout << endl;\n  }\n\n  for (point p : pts) {\n    cout << p << \" \";\n  }\n  cout << endl << \"  \" << ans << endl;\n  */\n  \n  reverse(pts.begin(), pts.end());\n  pts.pop_back();\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  vector<point> pts (n);\n  for (int i = 0; i < n; i++) {\n    cin >> pts[i].x >> pts[i].y;\n  }\n\n  while ((int) pts.size() >= 3) {\n    solve(pts);\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 998244353;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nll A[MAX_N], B[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) cin >> A[i] >> B[i];\n\tll ans = 1;\n\trep(i, 0, N) MUL(ans, 2);\n\tADD(ans, mod - N);\n\tADD(ans, mod - 1);\n\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tll tmp = 1;\n\t\t\trep(k, j + 1, N) {\n\t\t\t\t// B[k] = (B[j] - B[i]) / (A[j] - A[i]) (A[k] - A[i]) + B[i];\n\t\t\t\tif((B[k] - B[i]) * (A[j] - A[i]) == (B[j] - B[i]) * (A[k] - A[i])) {\n\t\t\t\t\tMUL(tmp, 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tADD(ans, mod - tmp);\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T>\nT gcd(T x,T y)\n{\n\twhile(y)swap(x%=y,y);\n\treturn x;\n}\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n\nconst int N=200+5,U=1e4+5,D=998244353;\nint mi_2[N];\nstruct point\n{\n\tint x,y;\n};\npoint operator -(const point &a)\n{\n\treturn (point){-a.x,-a.y};\n}\npoint operator -(const point &a,const point &b)\n{\n\treturn (point){a.x-b.x,a.y-b.y};\n}\npoint operator /(const point &a,int k)\n{\n\treturn (point){a.x/k,a.y/k};\n}\npoint standard(point p)\n{\n\tif(p.x==0)return (point){0,1};\n\tif(p.x<0)p=-p;\n\treturn p/gcd(p.x,abs(p.y));\n}\nint dy(const point &p)\n{\n\treturn p.x*U+p.y;\n}\npoint p[N],a[N];\nint F2(int n)\n{\n\treturn mi_2[n]-1-n;\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\trep(i,1,n)cin>>p[i].x>>p[i].y;\n\tmi_2[0]=1;\n\trep(i,1,n)mi_2[i]=mi_2[i-1]*2%D;\n\tll ans=mi_2[n]-1-n-n*(n-1)/2;\n\trep(i,1,n)\n\t{\n\t\tunordered_map<int,int>mp;\n\t\trep(j,i+1,n)++mp[dy(standard(p[j]-p[i]))];\n\t\tfor(auto pr:mp)ans-=F2(pr.second);\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=205,M=998244353;\nint n,ans,x[N],y[N],fac[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor (int i=1;i<=n;i++)fac[i]=fac[i-1]*2%M;\n\tfor (int i=1;i<=n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n\tans=(fac[n]-n-1-n*(n-1)/2+M)%M;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tint num=0;\n\t\t\tfor (int k=j+1;k<=n;k++)\n\t\t\t\tif ((y[j]-y[i])*(x[k]-x[j])==(y[k]-y[j])*(x[j]-x[i]))num++;\n\t\t\t(ans+=M+1-fac[num])%=M;\n\t\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 205\nusing namespace std;\n\n#define db double\n#define eps 1e-8\nstruct point{db x,y;};\npoint operator +(point a,point b){return (point){a.x+b.x,a.y+b.y};}\npoint operator -(point a,point b){return (point){a.x-b.x,a.y-b.y};}\ndb operator *(point a,point b){return a.x*b.y-b.x*a.y;}\npoint operator *(point a,db x){return (point){a.x*x,a.y*x};}\npoint operator /(point a,db x){return (point){a.x/x,a.y/x};}\nbool a_onleft(point a,point b){return a*b<-eps;}\ndb area(point a,point b,point c){return abs((a-c)*(b-c)/2.0);}\npoint inter(point a1,point a2,point b1,point b2){\n\tdouble s1=area(b1,b2,a1),s2=area(b1,b2,a2);\n\treturn (a1-a2)/(s1+s2)*s2+a2;\n}\n#undef db\n#undef eps\nconst int mod=998244353;\npoint p[N];\nint n,pw[N];\nint main(){\n\tscanf(\"%d\",&n);pw[0]=1;\n\tfor(int i=1;i<=n;i++) scanf(\"%lf%lf\",&p[i].x,&p[i].y),pw[i]=pw[i-1]*2%mod;\n\tlong long ans=pw[n]-1-n;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint cnt=0;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\t\tif(area(p[i],p[j],p[k])<1e-8) cnt++;\n\t\t\tans-=pw[cnt];\n\t\t}\n\tcout<<(ans%mod+mod)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int P=998244353;\nconst int N=205;\n\nint x[N],y[N];\nint C[N][N];\nint n,ans,pw;\n\nint main()\n{\n\t//freopen(\"cvxscr.in\",\"r\",stdin),freopen(\"cvxscr.out\",\"w\",stdout);\n\tscanf(\"%d\",&n),pw=1;\n\tfor (int i=1;i<=n;++i) scanf(\"%d%d\",&x[i],&y[i]),(pw<<=1)%=P;\n\tC[0][0]=1;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;++j) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;\n\t}\n\tans=n+1;\n\tfor (int i=1;i<n;++i)\n\t\tfor (int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tint cnt=2,vx=x[i]-x[j],vy=y[i]-y[j];\n\t\t\tfor (int k=1,vx_,vy_;~cnt&&k<i;++k)\n\t\t\t{\n\t\t\t\tvx_=x[i]-x[k],vy_=y[i]-y[k];\n\t\t\t\tif (!(vx*vy_-vy*vx_)) cnt=-1;\n\t\t\t}\n\t\t\tfor (int k=i+1,vx_,vy_;~cnt&&k<j;++k)\n\t\t\t{\n\t\t\t\tvx_=x[i]-x[k],vy_=y[i]-y[k];\n\t\t\t\tif (!(vx*vy_-vy*vx_)) cnt=-1;\n\t\t\t}\n\t\t\tif (!~cnt) continue;\n\t\t\tfor (int k=j+1,vx_,vy_;k<=n;++k) vx_=x[i]-x[k],vy_=y[i]-y[k],cnt+=!(vx*vy_-vy*vx_);\n\t\t\tfor (int k=2;k<=cnt;++k) (ans+=C[cnt][k])%=P;\n\t\t}\n\tans=(P-ans+pw)%P,printf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) >  EPS)   return +1;      // counter clockwise\n\tif(cross(b, c) < -EPS)   return -1;      // clockwise\n\tif(dot(b, c)   < -EPS)   return +2;      // c--a--b on line\n\tif(norm(b)+EPS <norm(c)) return -2;      // a--b--c on line\n\treturn 0;                                   // c is between a and b (inclusive)\n}\nint n;\nint on[200][200];\nbool can[200][200][200];\n\nint dp[200][200];\nll pw[201];\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tconst int mod = 998244353;\n\tpw[0] = 1;\n\trep(i, 200) pw[i + 1] = pw[i] * 2 % mod;\n\t\n\tcin >> n;\n\tG g;\n\trep(i, n){\n\t\tint x, y; cin >> x >> y;\n\t\tg.emplace_back(x, y);\n\t}\n\trep(i, n) rep(j, n) rep(k, n) if(ccw(g[i], g[j], g[k]) == 1) can[i][j][k] = 1;\n\trep(i, n) rep(j, i) rep(k, n) if(k != i && k != j){\n\t\tif(ccw(g[k], g[i], g[j]) != 2) continue;\n\t\ton[i][j]++;\n\t\ton[j][i]++;\n\t}\n\tll ans = 0;\n\trep(s, n){\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tvi idx;\n\t\trep(i, n) if(g[s] < g[i]) idx.pb(i);\n\t\tsort(all(idx), [&](int a, int b){\n\t\t\treturn arg(g[a] - g[s]) < arg(g[b] - g[s]);\n\t\t});\n\t\tidx.insert(idx.begin(), s);\n\t\t\n\t\tfor(int i : idx) if(i != s) (dp[s][i] += pw[on[s][i]]) %= mod;\n\t\tfor(int i : idx) for(int j : idx) if(dp[i][j]){\n\t\t\tif(can[i][j][s]) ans += dp[i][j] * pw[on[j][s]] % mod;\n\t\t\tfor(int k : idx) if(k != s && can[i][j][k]) (dp[j][k] += dp[i][j] * pw[on[j][k]] % mod) %= mod;\n\t\t}\n\t}\n\tcout << ans % mod << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 998244353;\nll N;\nvector<pair<ll, ll>> Points;\nmap<tuple<ll, ll, ll>, ll> Count;\nmap<ll, ll> InvNC2;\nvector<ll> Pow;\nll R;\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll pow_multi(ll n) { return (Pow[n] + MOD - n - 1) % MOD; }\nint main() {\n  cin >> N;\n  for (ll i = 0; i < N; ++i) {\n    ll x, y;\n    cin >> x >> y;\n    Points.push_back(make_pair(x, y));\n  }\n  for (ll i = 0; i < N; ++i)\n    for (ll j = i + 1; j < N; ++j) {\n      ll x, y, x2, y2;\n      tie(x, y) = Points[i];\n      tie(x2, y2) = Points[j];\n      ll dx = x2 - x, dy = y2 - y;\n      // line ax+by=c, a+b>=0, a and b are coprime\n      ll a = dy, b = -dx;\n      if (a + b < 0) {\n        a *= -1;\n        b *= -1;\n      }\n      ll g = gcd(abs(a), abs(b));\n      a /= g;\n      b /= g;\n      ll c = a * x + b * y;\n      ++Count[make_tuple(a, b, c)];\n    }\n  for (ll i = 2; i <= N; ++i) InvNC2[i * (i - 1) / 2] = i;\n  Pow.resize(N + 1);\n  Pow[0] = 1;\n  for (ll i = 1; i <= N; ++i) Pow[i] = 2 * Pow[i - 1] % MOD;\n  R = pow_multi(N);\n  for (const auto &linecount : Count) {\n    ll k = InvNC2.at(linecount.second);\n    (R += MOD - pow_multi(k)) %= MOD;\n  }\n  cout << R << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\ninline int rnd(int x){\n\treturn rand()%x;\n}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=205,mod=998244353;\nint n,ans,ycl[N],x[N],y[N];\nint main(){\n\tn=read(); ycl[0]=1;\n\tfor(int i=1;i<=n;i++)ycl[i]=(ycl[i-1]<<1)%mod;\n\tfor(int i=1;i<=n;i++){\n\t\tx[i]=read(); y[i]=read();\n\t}\n\tans=ycl[n]-n-1;\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++){\n\t\tint sum=0;\n\t\tfor(int k=j+1;k<=n;k++)if((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))sum++;\n\t\tans=(ans-ycl[sum])%mod;\n\t}\n\tcout<<(ans+mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll powLL(ll a, ll n){\n    ll res = 1;\n    while(n>0){\n        if(n&1){\n            res *= a;\n            res %= mod;\n        }\n        a = a*a;\n        a %= mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll N;\n    cin >> N;\n    vector<ll> x(N), y(N);\n    REP(i, N){\n    \tcin >> x[i] >> y[i];\n    }\n\n    ll res = 0;\n\n    res += powLL(2, N);\n    res -= N;\n    res -= 1;\n    res += mod;\n    res %= mod;\n\n    ll check[N][N] = {};\n\n\n    REP(i, N){\n    \tREP(j, N){\n    \t\tif(i==j) continue;\n    \t\tif(check[i][j]) continue;\n    \t\tvector<ll> cand;\n    \t\tREP(k, N){\n    \t\t\tif(check[i][k]) continue;\n    \t\t\tif(check[j][k]) continue;\n    \t\t\tif(i==k) continue;\n    \t\t\tif(j==k) continue;\n    \t\t\tll dx1 = x[j] - x[i];\n    \t\t\tll dx2 = x[k] - x[i];\n    \t\t\tll dy1 = y[j] - y[i];\n    \t\t\tll dy2 = y[k] - y[i];\n    \t\t\tif(dx1 * dy2 == dx2 * dy1){\n    \t\t\t\tcand.push_back(k);\n    \t\t\t}\n    \t\t}\n    \t\tcand.push_back(i);\n\t\t\tcand.push_back(j);\n\n    \t\tll q = cand.size();\n\t\t\tll tmp = 0;\n\n\t\t\ttmp += powLL(2, q);\n\t\t\ttmp -= 1;\n\t\t\ttmp -= q;\n\t\t\ttmp += mod;\n\t\t\ttmp %= mod;\n\n\t\t\tres -= tmp;\n\t\t\tres += mod;\n\t\t\tres %= mod;\n\n\t\t\tREP(k, q)REP(l, q) check[cand[k]][cand[l]] = 1;\n    \t}\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF = 0x3c3c3c3c;\nconst ll INFL = 0x3c3c3c3c3c3c3c3c;\nconst int MOD = 998244353;\n\nstruct p{\n\tint x, y;\n\tbool operator <(p &o){\n\t\tif(x != o.x) return x < o.x;\n\t\treturn y < o.y;\n\t}\n};\n\np point[209];\nint OLCount[209][209];\nint power[209];\n\nint isLine(int x1, int y1, int x2, int y2, int x3, int y3){\n\treturn x1 * y2 + x2 * y3 + x3 * y1 - x2 * y1 - x3 * y2 - x1 * y3;\n}\n\nbool isPossible(vector<p> &v){\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = i + 1; j < 4; j++){\n\t\t\tfor(int k = j + 1; k < 4; k++){\n\t\t\t\tbool f = isLine(v[i].x, v[i].y, v[j].x, v[j].y, v[k].x, v[k].y);\n\t\t\t\tif(!f) return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint N;\n\tcin >> N;\n\tpower[0] = 1;\n\tfor(int i = 1; i < 209; i++){\n\t\tpower[i] = (power[i - 1] * 2) % MOD;\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpoint[i] = {x, y};\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tvector<p> v;\n\t\tv.push_back(point[i]);\n\t\tfor(int j = i + 1; j < N; j++){\n\t\t\tv.push_back(point[j]);\n\t\t\tint lx = min(point[i].x, point[j].y), rx = max(point[i].x, point[j].y);\n\t\t\tfor(int k = j + 1; k < N; k++){\n\t\t\t\tif(point[k].x < lx) continue;\n\t\t\t\tif(point[k].x > rx) continue;\n\t\t\t\tv.push_back(point[k]);\n\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\tbool f = isLine(v[0].x, v[0].y, v[1].x, v[1].y, v[2].x, v[2].y);\n\t\t\t\tif(!f){\n\t\t\t\t\tOLCount[i][j]++;\n\t\t\t\t\tOLCount[j][i]++;\n\t\t\t\t}\n\t\t\t\tv.pop_back();\n\t\t\t}\n\t\t\tv.pop_back();\n\t\t}\n\t\tv.pop_back();\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tvector<p> v;\n\t\tv.push_back(point[i]);\n\t\tfor(int j = i + 1; j < N; j++){\n\t\t\tv.push_back(point[j]);\n\t\t\tfor(int k = j + 1; k < N; k++){\n\t\t\t\tv.push_back(point[k]);\n\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\tbool f = isLine(v[0].x, v[0].y, v[1].x, v[1].y, v[2].x, v[2].y);\n\t\t\t\tv.pop_back();\n\t\t\t\tif(!f) continue;\n\t\t\t\tans += power[OLCount[i][j] + OLCount[j][k] + OLCount[k][i]];\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t\tv.pop_back();\n\t\t}\n\t\tv.pop_back();\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tvector<p> v;\n\t\tv.push_back(point[i]);\n\t\tfor(int j = i + 1; j < N; j++){\n\t\t\tv.push_back(point[j]);\n\t\t\tfor(int k = j + 1; k < N; k++){\n\t\t\t\tv.push_back(point[k]);\n\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\tbool f = isLine(v[0].x, v[0].y, v[1].x, v[1].y, v[2].x, v[2].y);\n\t\t\t\tif(!f){\n\t\t\t\t\tv.pop_back();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int l = k + 1; l < N; l++){\n\t\t\t\t\tv.push_back(point[l]);\n\t\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\t\tif(!isPossible(v)){\n\t\t\t\t\t\tv.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans += power[OLCount[i][j] + OLCount[j][k] + OLCount[k][l] + OLCount[l][i]];\n\t\t\t\t\tans %= MOD;\n\t\t\t\t\tv.pop_back();\n\t\t\t\t}\n\t\t\t\tv.pop_back();\n\t\t\t}\n\t\t\tv.pop_back();\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 998244353\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\ntypedef pair<P,P> PP;\n\nconst int MAX_N = 205;\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\ninline void make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - (ll)inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = (ll)fac[i-1] * i % MOD;\n\t\tfinv[i] = (ll)finv[i-1] * inv[i] % MOD;\n\t}\n}\n\ninline int comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn (ll)fac[a] * ((ll)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\ninline int add(int x,int y)\n{\n    return (x+y)%MOD;\n}\n\ninline int sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\ninline int mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\nint sm[MAX_N];\nvector<PP> line;\n\nll gcd(ll a, ll b)\n{\n    if(!b) return a;\n    if(a % b == 0){\n        return b;\n    }else{\n        return gcd(b,a%b);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vi x(n), y(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n    }\n    make();\n    srep(i,3,n+1){\n        srep(j,3,i+1){\n            sm[i] = add(sm[i], comb(i, j));\n        }\n    }\n    int ans = sm[n];\n    rep(i,n){\n        srep(j,i+1,n){\n            if(x[i] == x[j]){\n                line.pb(PP(P(INF, 0), P(x[i], 1)));\n            }else if(y[i] == y[j]){\n                line.pb(PP(P(0, 0), P(y[i], 1)));\n            }else{\n                int dx = x[j] - x[i], dy = y[j] - y[i];\n                int g = gcd(abs(dx), abs(dy));\n                P a;\n                if(dx * dy < 0){\n                    a = P(abs(dx)/g,-abs(dy)/g);\n                }else{\n                    a = P(abs(dx)/g,abs(dy)/g);\n                }\n                int ddx = a.fi, ddy = y[i]*a.fi-a.se*x[i];\n                line.pb(PP(a, P(ddx, ddy)));\n            }\n        }\n    }\n    zip(line);\n    // show(ans);\n    each(it, line){\n        P a = it.fi, b = it.se;\n        // spair(a), spair(b);\n        int res = 0;\n        if(a.fi == INF){\n            rep(i,n){\n                res += (x[i] == b.fi);\n            }\n        }else if(a.fi == 0){\n            rep(i,n){\n                res += (y[i] == b.fi);\n            }\n        }else{\n            rep(i,n){\n                int p = a.fi, q = a.se*x[i]+b.se;\n                int g = gcd(p, q);\n                p /= g, q /= g;\n                res += (p == 1 && q == y[i]);\n            }\n        }\n        // show(res);\n        ans = sub(ans, sm[res]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//copied\n#include<cstdio>\nint n,d,ans,x[210],y[210],p[210];\nint main(){\n\tscanf(\"%d\",&n);\n\tint M=998244353;\n\tp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tp[i]=1ll*p[i-1]*2%M;\n\t}\n\tans=p[n]-n-1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\td=0;\n\t\t\tfor(int k=j+1;k<=n;k++)d+=(y[i]-y[j])*(x[i]-x[k])==(y[i]-y[k])*(x[i]-x[j]);\n\t\t\tans=(ans+M-p[d])%M;\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 998244353\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll ruijo(ll x,ll n){\n\tlong long p,ans;\n\tif(n==0)return 1;\n\tif(n==1)return x;\n\tif(n%2){\n\t\tp = ruijo(x,n/2);\n\t\tans = (x*p)%mod;\n\t\tans = (ans*p)%mod;\n\t\treturn ans;\n\t}else{\n\t\tp = ruijo(x,n/2);\n\t\tans = (p*p)%mod;\n\t\treturn ans;\n\t}\n}\n\nint main(){\n    int n;\n    cin >> n;\n    if(n<=2){\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<int> x(n),y(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n    }\n    bool flag[210][210]={};\n    vector<int> c;\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            vector<int> p;\n            if(flag[i][j])continue;\n            p.push_back(i);\n            p.push_back(j);\n            for(int k=j+1;k<n;k++){\n                if((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j])){\n                    p.push_back(k);\n                }\n            }\n            for(int s=0;s<p.size();s++){\n                for(int t = s+1;t<p.size();t++){\n                    flag[p[s]][p[t]] = 1;\n                }\n            }\n            c.push_back(p.size());\n        }\n    }\n    ll res = ruijo(2,n);\n    res += mod-1-n;\n    res %= mod;\n    for(int x:c){\n        res += 2*mod - (ruijo(2,x)-x-1);\n        res %= mod;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(ll (i)=(s);(i)<(ll)(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) reps(i,0,n+1)\n#define repst(i,s,n) reps(i,s,n+1)\n#define reprt(i,n,t) for(ll (i)=(n);(i)>=t;--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<n;++i){cout<<x[i]<<(i==n-1?'\\n':' ');}}\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = 998244353ll;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// n-|S|というのは \"Sの凸包に含まれる点からS自体を除いた集合Ts\" の要素数に等しい\n// つまり \"2^(n-|S|)の総和\" は \"Tsの部分集合の個数の総和\" に等しい\n// 凸包の内部(境界を含まない)の点は選んでも選ばなくても凸包の形状は変わらないが、その凸包を生成する選び方の組み合わせを倍にすることができる\n// このことから求めるものは \"凸包の面積が正の部分集合の個数\" と等しい(というかスコアがこれに対応してる)ことがわかる\n// 全部分集合2^n個から面積が0の集合の個数を引けばいい\n\nint n, x[200], y[200], f[234], r;\nbool us[200][200];\n\n// (3点の面積)*2\nint area(int i, int j, int k) {\n\treturn (x[i]-x[k])*(y[j]-y[k]) - (y[i]-y[k])*(x[j]-x[k]);\n}\n\nsigned main() {\n\tcin >> n;\n\trep(i,n) cin >> x[i] >> y[i];\n\t\n\tf[0] = 1;\n\trepst(i,1,n) f[i] = f[i-1]*2 %mod;\n\t// 頂点数0or1or2の集合はとりあえず除く\n\tr = (f[n] + mod - (1 + n + n*(n-1)/2))%mod;\n\t// 同一直線状の点を3個以上選んでできる部分集合も除く必要がある\n\trep(i,n) reps(j,i+1,n) if (!us[i][j]) {\n\t\tvi v;\n\t\tv.pb(i), v.pb(j);\n\t\trep(k,n) if (i!=k && j!=k && area(i,j,k)==0) v.pb(k);\n\t\teach(k,v) each(l,v) us[k][l] = true;\n\t\tint t = v.size();\n\t\tif (t>=3) r = (r + mod - f[t] + 1 + t + t*(t-1)/2) %mod;\n\t}\n\tcout << r << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i*i <= N; ++i)\n\t{\n\t\tif (N%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD> &other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<998244353> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\ntemplate<typename RET = mint, typename Integral>\nRET combination(Integral all, Integral get)\n{\n\tassert(all >= get);\n\tget = std::min(all - get, get);\n#if 1\n\t//時間計算量O(logMOD)\n\tstatic const auto fact_v = fact_set_c<100001>();\n\treturn fact_v[all] / (fact_v[get] * fact_v[all - get]);\n#elif 0\n\t//時間計算量O(1)\n\t//空間計算量、初期化時間計算量O(N^2)\n\tconstexpr int32_t ALL_MAX = 10'000;\n\tstatic std::vector<RET> DP_comb[ALL_MAX + 1];\n\tif (!DP_comb[all].empty())\n\t{\n\t\treturn DP_comb[all][get];\n\t}\n\n\tif (DP_comb[0].empty())\n\t{\n\t\tDP_comb[0].resize(1);\n\t\tDP_comb[0][0] = (RET)1;\n\t\tDP_comb[1].resize(1);\n\t\tDP_comb[1][0] = (RET)1;\n\t}\n\tfor (int32_t i = 2; i <= all; i++)\n\t{\n\t\tif (DP_comb[i].empty())\n\t\t{\n\t\t\tint32_t size = i / 2 + 1;\n\t\t\tDP_comb[i].resize(size);\n\t\t\tDP_comb[i][0] = (RET)1;\n\t\t\tfor (int32_t j = 1; j < size - 1; j++)\n\t\t\t{\n\t\t\t\tDP_comb[i][j] = DP_comb[i - 1][j - 1] + DP_comb[i - 1][j];\n\t\t\t}\n\t\t\tDP_comb[i][size - 1] = DP_comb[i - 1][size - 2] + DP_comb[i - 1][(i & 1) ? (size - 1) : (size - 2)];\n\t\t}\n\t}\n\treturn DP_comb[all][get];\n#else\n\t//時間計算量O(get * logMOD)\n\tRET ret = (RET)1;\n\tfor (Integral i = 1; i <= get; ++i)\n\t{\n\t\tret *= all + 1 - i;\n\t\tret /= i;\n\t}\n\treturn ret;\n#endif\n}\n\n\n\nint32_t N;\nusing std::vector;\nstruct P {\n\tint32_t x, y;\n\tint32_t dot(P o) {\n\t\treturn x*o.x + y*o.y;\n\t}\n\tint32_t det(P o) {\n\t\treturn x*o.y - y*o.x;\n\t}\n};\nP operator-(P a, P b) {\n\treturn P{ a.x - b.x, a.y - b.y };\n}\n// 辞書順で比較\ninline bool cmp_x(const P& p, const P& q) {\n\tif (p.x != q.x) return p.x < q.x;\n\treturn p.y < q.y;\n}\n// 凸包を求める\nvector<P> convex_hull(P* ps, int n) {\n\tstd::sort(ps, ps + n, cmp_x);\n\tint k = 0; // 凸包の頂点数\n\tvector<P> qs(n * 2); // 構築中の凸包\n\t\t// 下側凸包の作成\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\t\tqs[k++] = ps[i];\n\t\t}\n\t// 上側凸包の作成\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n// 距離の二乗\ndouble dist(P p, P q) {\n\treturn (p - q).dot(p - q);\n}\n// 入力\nP ps[200];\nmint powpow[500];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tin >> ps[i].x >> ps[i].y;\n\t}\n\tpowpow[0] = 1;\n\tfor (size_t i = 1; i < 500; i++)\n\t{\n\t\tpowpow[i] = powpow[i - 1] * 2;\n\t}\n\n\n\tmint res = 0;\n\tvector<P> qs = convex_hull(ps, N);\n\tres += powpow[N - qs.size()];\n\tfor (int32_t i = qs.size(); i >= 0 ; i--)\n\t{\n\t\tres += powpow[std::max<long long>(0,N - qs.size()-i)]*i;\n\t}\n\tout << res << endl;\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <cmath>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\ntypedef tuple<int, int, int> line;\n\nint gcd(int a, int b){\n    if(a == 0) return b;\n    if(b == 0) return a;\n    if(a < 0) a *= -1;\n    if(b < 0) b *= -1;\n    if(a < b) swap(a, b);\n    while(b != 0){\n        int tmp = b;\n        b = a%b;\n        a = tmp;\n    }\n    return a;\n}\n\nline norm(line l){\n    int a = get<0>(l);\n    int b = get<1>(l);\n    int c = get<2>(l);\n    if(a < 0){\n        a *= -1;\n        b *= -1;\n        c *= -1;\n    }\n    if(a == 0 && b < 0){\n        b *= -1;\n        c *= -1;\n    }\n    int m = gcd(a, b);\n    m = gcd(m, c);\n    return make_tuple(a/m, b/m, c/m);\n}\n\nline calc_line(int x1, int y1, int x2, int y2){\n    line ans = make_tuple(y2-y1, -(x2-x1), y1*x2-x1*y2);\n    ans = norm(ans);\n    return ans;\n}\n\nlong pow2[201];\n\nvoid init(){\n    pow2[0] = 1;\n    for(int i = 1; i <= 200; i++){\n        pow2[i] = 2*pow2[i-1];\n        pow2[i] %= MOD;\n    }\n}\n\nvoid print_line(line l){\n    cout << get<0>(l) << ' ' << get<1>(l) << ' ' << get<2>(l) << endl;\n}\n\nint main(){\n    init();\n    map<line, int> mp;\n    int N;\n    cin >> N;\n    int x[200], y[200];\n    for(int i = 0; i < N; i++) cin >> x[i] >> y[i];\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < i; j++){\n            line l = calc_line(x[i], y[i], x[j], y[j]);\n            if(mp.count(l) == 0){\n                mp[l] = 1;\n            }else{\n                mp[l]++;\n            }\n        }\n    }\n    long ans = pow2[N];\n    ans -= (1+N);\n    for(auto iter = mp.begin(); iter != mp.end(); iter++){\n        int m = iter-> second;\n        m = ((int)sqrt(2*m))+1;\n        //cout << m << endl;\n        ans -= (pow2[m]-m-1);\n        ans %= MOD;\n        ans += MOD;\n        ans %= MOD;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <cstdio> \n#include <iostream> \n#include <cmath> \n#include <string> \n#include <list> \n#include <vector> \n#include <algorithm> \n#include <functional> \n#include <utility> \n#include <set> \n#include <map> \n#include <complex> \n#include <queue> \n#include <stack> \n#include <cstdlib> \n#include <ctime> \n#include <cstring> \n#include <string.h> \n#include <unordered_set>\n#include <unordered_map>\n#include <cassert>\n\nusing namespace std; \n\ntypedef unsigned int uint; \ntypedef long long int64; \ntypedef unsigned long long uint64; \ntypedef unsigned short ushort; \ntypedef unsigned char uchar; \ntypedef pair<int,int> ipair; \ntypedef vector<int> VI; \ntypedef vector<string> VS; \ntypedef vector<double> VD; \n#define SIZE(A) ((int)(A.size()))\n#define LENGTH(A) ((int)(A.length()))\n#define MP(A,B) make_pair(A,B)\nconst double pi=acos(-1.0); \nconst double eps=1e-11; \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(a) (a).begin(),(a).end()\n\ntemplate<class T> T sqr(const T &x) { return x*x; } \ntemplate<class T> T lowbit(const T &x) { return (x^(x-1))&x; } \ntemplate<class T> int countbit(const T &n) { return (n==0)?0:(1+countbit(n&(n-1))); } \ntemplate<class T> void ckmin(T &a,const T &b) { if (b<a) a=b; } \ntemplate<class T> void ckmax(T &a,const T &b) { if (b>a) a=b; } \n\nconst int maxn=256;\nconst int MOD=998244353;\n\ninline int multiply(int a,int b)\n{\n\treturn ((int64)a*(int64)b)%MOD;\n}\ninline void addto(int &a,int b)\n{\n\ta+=b;\n\tif (a>=MOD) a-=MOD;\n}\ninline void delto(int &a,int b)\n{\n\ta-=b;\n\tif (a<0) a+=MOD;\n}\n\nint n;\nint x[maxn],y[maxn];\nint c[maxn][maxn][maxn];\nint s[maxn][maxn][maxn];\nint f[maxn][maxn];\nint p2[maxn];\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios_base::sync_with_stdio(false);\n\tcin>>n;\n\tREP(i,n) cin>>x[i]>>y[i];\n\tREP(i,n) REP(j,n) REP(k,n)\n\t{\n\t\tint t=(x[j]-x[i])*(y[k]-y[i])-(x[k]-x[i])*(y[j]-y[i]);\n\t\tc[i][j][k]=((t==0)?0:(t<0?-1:1));\n\t}\n\tREP(i,n+1) p2[i]=(i==0?1:multiply(p2[i-1],2));\n\tmemset(s,0,sizeof(s));\n\tREP(i,n) REP(j,n) REP(k,n) if (c[i][j][k]>0)\n\t{\n\t\tif (j<i) { s[i][j][k]=s[j][k][i]; continue; }\n\t\tif (k<i) { s[i][j][k]=s[k][i][j]; continue; }\n\t\tint w=0;\n\t\tREP(p,n) if (c[i][j][p]>=0 && c[j][k][p]>=0 && c[k][i][p]>=0) ++w;\n\t\ts[i][j][k]=w-3;\n\t}\n\tint ret=0;\n\tREP(key,n)\n\t{\n\t\tint size=0;\n\t\tint p[maxn];\n\t\tREP(i,n) if (x[i]>x[key] || x[i]==x[key] && y[i]>y[key]) p[size++]=i;\n\t\tsort(p,p+size,[&](int a,int b) { return c[a][b][key]>0; });\n\t\tREP(s1,size) FOR(s2,s1+1,size) if (c[key][p[s1]][p[s2]]>0)\n\t\t{\n\t\t\tf[s1][s2]=1;\n\t\t\tREP(s0,s1) if (c[key][p[s0]][p[s1]]>0) addto(f[s1][s2],f[s0][s1]);\n\t\t\tf[s1][s2]=multiply(f[s1][s2],p2[s[key][p[s1]][p[s2]]]);\n\t\t\taddto(ret,f[s1][s2]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef struct pair<int,int> P;\ntypedef struct pair<int,P> P2;\n\nll n;\n\nconst int INF=1000000007;\nint main() {\n\tcin>>n;\n\tll x[201]={};\n\tll y[201]={};\n\tll t=0;\n\tfor(ll i=3;i<=n;++i){\n\t\tll t2=1;\n\t\tfor(ll j=1;j<=i;++j)t2=((t2*(n-i+j))/j)%998244353;\n\t\tt+=t2;\n\t\tt%=998244353;\n\t}\n//\tcout<<t<<endl;\n\tfor(int i=1;i<n+1;++i)cin>>x[i]>>y[i];\n\n\tfor(int i=1;i<n+1;++i){\n\t\tfor(int j=i+1;j<n+1;++j){\n\t\t\tll s=0;\n\t\t\tt+=998244353;\n\t\t\tfor(int k=j+1;k<n+1;++k){\n\t\t\t\tif((x[i]-x[j])*(y[i]-y[k])-(x[i]-x[k]*(y[i]-y[j]))==0)s++;\n\t\t\t}\n\t\t\tll t2=0;\n\t\t\tfor(ll k=1;k<=s;++k)t2+=k;\n\t\t\tt-=t2;\n\t\t\tt%=998244353;\n//\t\t\tcout<<i<<\" \"<<j<<\" \"<<t2<<endl;\n\t\t}\n\t}\n\tcout<<t<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2000;\ntypedef long long ll;\nconst ll mod=998244353;\nll x[maxn],y[maxn],power[maxn];\n/*ll power(ll a,ll b)\n{\n    ll ret;\n    if (b==0) return 1LL;\n    ret=pow(a,b/2);\n    ret=ret*ret%mod;\n    if (b%2) ret=ret*a%mod;\n    return ret;\n}*/\nint main()\n{\n  //  freopen(\"text.in\",\"r\",stdin);\n    ll i,ans,tmp,j,k,n;\n    scanf(\"%lld\",&n);\n    power[0]=1LL;\n    for (i=1;i<=n;i++) {\n        power[i]=power[i-1]*2LL%mod;\n        scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    ans=((power[n]-n-1)%mod+mod)%mod;\n    ans=((ans-(n-1)*n/2)%mod+mod)%mod;\n    for (i=1;i<=n;i++) {\n        for (j=i+1;j<=n;j++) {\n            tmp=0;\n            for (k=j+1;k<=n;k++) {\n                if ((y[j]-y[i])*(x[k]-x[j])==(y[k]-y[j])*(x[j]-x[i])) tmp++;\n                //if ((y[k]-y[i])*(x[j]-x[i])==(x[k]-x[i])*(y[j]-y[i])) tmp++;\n            }\n            //ans=((ans-/*power(2LL,tmp)*/power[tmp])%mod+mod)%mod;\n            ans=((ans-/*power(2LL,tmp)*/power[tmp]+1)%mod+mod)%mod;\n        }\n    }\n    printf(\"%lld\\n\",(ans%mod+mod)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Crt. 2020-01-07  0946\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define PII pair<int, int>\n#define mk make_pair\n#define N 204\nusing namespace std;\nconst int Mod = 998244353;\n\ninline int fsp(int x, int p = Mod - 2) {\n    int res = 1;\n    while (p) {\n        if (p & 1) res = 1ll * res * x % Mod;\n        x = 1ll * x * x % Mod, p >>= 1;\n    } return res;\n}\n\ninline int getp(int x) {\n    return x < 0 ? -1 : 1;\n}\n\ninline int Abs(int x) {\n    return x < 0 ? -x : x;\n}\n\ninline int gcd(int x, int y) {\n    while (y ^= x ^= y ^= x %= y);\n    return x;\n}\n\nint n, x[N], y[N], m, z[N];\nPII k[N * N];\n\nint main(){\n#ifdef LOCAL_JUDGE\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i)\n        scanf(\"%d%d\", x + i, y + i);\n\n    for (int i = 1; i <= n; ++i)\n        z[i] = 1ll * i * (i - 1) / 2;\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n; ++j) {\n            int a = y[j] - y[i], b = x[j] - x[i];\n            //cout << i << \" \" << j << \" \" << a << \" \" << b << endl;\n            if (!a) { k[++m] = mk(-100000, y[i]); continue; }\n            if (!b) { k[++m] = mk(x[i], -100000); continue; } \n            int pa = getp(a), pb = getp(b);\n            if (pa < 0) pa = -pa, pb = -pb;\n            a = Abs(a), b = Abs(b);\n            int g = gcd(a, b);\n            a /= g, b /= g;\n            a *= pa, b = pb;\n            k[++m] = mk(a, b);\n        }\n\n    sort(k + 1, k + m + 1);\n\n    long long ans = fsp(2, n) - 1 - n - n * (n - 1) / 2;\n\n//    for (int i = 1; i <= m; ++i)\n//        cout << k[i].first << \" \" << k[i].second << endl;\n\n    for (int i = 1, j; i <= m; i = j + 1) {\n        for (j = i; j < m && k[j + 1] == k[i]; ++j);\n        int pos = lower_bound(z + 1, z + n + 1, j - i + 1) - z;\n        ans -= fsp(2, pos) - 1 - pos - pos * (pos - 1) / 2, ans %= Mod;\n    }\n        \n    if (ans < 0) ans += Mod;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T>\nT gcd(T x,T y)\n{\n\twhile(y)swap(x%=y,y);\n\treturn x;\n}\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n\nconst int N=200+5,U=1e4+5,D=998244353;\nint mi_2[N];\nstruct point\n{\n\tint x,y;\n};\npoint operator -(const point &a)\n{\n\treturn (point){-a.x,-a.y};\n}\npoint operator -(const point &a,const point &b)\n{\n\treturn (point){a.x-b.x,a.y-b.y};\n}\npoint operator /(const point &a,int k)\n{\n\treturn (point){a.x/k,a.y/k};\n}\npoint standard(point p)\n{\n\tif(p.x==0)return (point){0,1};\n\tif(p.x<0)p=-p;\n\treturn p/gcd(p.x,abs(p.y));\n}\nint dy(const point &p)\n{\n\treturn p.x*U+p.y;\n}\npoint p[N],a[N];\nint F2(int n)\n{\n\treturn mi_2[n]-1-n;\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\trep(i,1,n)cin>>p[i].x>>p[i].y;\n\tmi_2[0]=1;\n\trep(i,1,n)mi_2[i]=mi_2[i-1]*2%D;\n\tll ans=mi_2[n]-1-n-n*(n-1)/2;\n\trep(i,1,n)\n\t{\n\t\tunordered_map<int,int>mp;\n\t\trep(j,i+1,n)++mp[dy(standard(p[j]-p[i]))];\n\t\tfor(auto pr:mp)ans-=F2(pr.second);\n\t}\n\tcout<<(ans%D+D)%D<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n \nusing tpl = tuple<int, int, int>;\ntypedef pair<int,int> pii;\n\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\n\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\n\n// 外積\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが直線ab上にあるかないか\nint is_point_on_line(const P &a, const P &b, const P &c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n\n\nconst int mod = 998244353;\n\nint N;\nint X[210];\nint Y[210];\nll powtwo[210];\n\nint main(){\n\n    powtwo[0] = 1;\n    for(int i = 1; i < 210; i++){\n        powtwo[i] = (powtwo[i-1] * 2) % mod;\n    }\n\n    fastStream();\n    cin >> N;\n    for(int i = 0; i < N; i++)\n        cin >> X[i] >> Y[i];\n\n    set<pair<pii, pii> > used;\n\n    ll tot = 0;\n    for(int i = 0; i < N; i++){\n        for(int j = i + 1; j < N; j++){\n            pii min_p = pii(X[i], Y[i]);\n            pii max_p = pii(X[i], Y[i]);\n            int cnt = 0;\n            for(int k = 0; k < N; k++){\n                if(is_point_on_line(P(X[i], Y[i]), P(X[j], Y[j]), P(X[k], Y[k]))){\n                    cnt++;\n                    min_p = min(min_p, pii(X[k], Y[k]));\n                    max_p = max(max_p, pii(X[k], Y[k]));\n                }\n            }\n            if(!used.count(make_pair(min_p, max_p))){\n                used.insert(make_pair(min_p, max_p));\n                tot += powtwo[cnt] - cnt - 1;\n            }\n        }\n    }\n    \n    tot = (powtwo[N] - tot + mod) % mod;\n    tot = (tot - N - 1 + mod) % mod;\n    cout << tot << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=210,O=998244353;\ntemplate<class T>inline T sqr(T x){return x*x;}\nstruct Pt{\n\tint x,y;\n}pt[N],pt2[N],base;\ninline bool ycmp(const Pt &a,const Pt &b){\n\treturn a.y!=b.y?a.y<b.y:a.x<b.x;\n}\ninline int cross(const Pt &a,const Pt &b){\n\treturn (a.x-base.x)*(b.y-base.y)-(a.y-base.y)*(b.x-base.x);\n}\ninline bool polarcmp(const Pt &a,const Pt &b){\n\tint crs=cross(a,b);\n\treturn crs?crs>0:sqr(a.x-base.x)<sqr(b.x-base.x);\n}\nint pw2[N];\ninline void gmath(int n){\n\tpw2[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tpw2[i]=(lint)pw2[i-1]*2%O;\n\t}\n}\nint main(){\n\tint n=ni;\n\tgmath(n);\n\tfor(int i=1;i<=n;i++){\n\t\tpt[i]=(Pt){ni,ni};\n\t}\n\tsort(pt+1,pt+n+1,ycmp);\n\tlint sum=1;\n\tfor(int i=1;i<=n;i++){\n\t\tbase=pt[i];\n\t\tmemcpy(pt2+i+1,pt+i+1,(n-i)*sizeof(Pt));\n\t\tsort(pt2+i+1,pt2+n+1,polarcmp);\n\t\tfor(int j=i+1,k=j;j<=n;j=k){\n\t\t\tfor(;k<=n&&cross(pt2[j],pt2[k])==0;k++);\n\t\t\tsum+=pw2[k-j]-1;\n\t\t}\n\t\tsum++;//single\n\t}\n\tprintf(\"%lld\\n\",((pw2[n]-sum%O)%O+O)%O);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define mod 998244353\nusing namespace std;\nint x[500],y[500],k[500];\nint ans,n;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\tk[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tk[i]=(k[i-1]<<1)%mod;\n\tans=k[n]-1-n;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tint num=0;\n\t\t\tfor(int ki=1;ki<j;ki++)\n\t\t\t\tif((x[i]-x[j])*(y[i]-y[ki])==(x[i]-x[ki])*(y[i]-y[j])) num++;\n\t\t\tans=(ans-k[num]+mod)%mod;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//pragma\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define YOU using\n#define DONT namespace\n#define SAY std\n\nYOU DONT SAY;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n\n#define REPP(i,a,b,d) for(int i=a;i<=b;i+=d)\n#define REP(i,a,b) REPP(i,a,b,1)\n#define REVV(i,a,b,d) for(int i=a;i>=b;i-=d)\n#define REV(i,a,b) REVV(i,a,b,1)\n\n#define FOR(i,a) for(int i=0; i<a; i++)\n#define FORD(i,a) for(int i=(int)a-1; i>=0; i--)\n\n#define pb push_back\n#define F first\n#define S second\n\nconst int OO = 1e9;\nconst ll INF = 1e18;\n\nconst int irand(int lo,int hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\nconst ll lrand(ll lo,ll hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\n#define getc getchar\ntemplate<typename T>\nT getnum(){\n\tint sign = 1;\n\tT ret = 0;\n\tchar c;\n\n\tdo{\n\t\tc = getc();\n\t}while(c == ' ' || c == '\\n');\n\tif(c == '-')sign = -1;\n\telse ret = c-'0';\n\twhile(1){\n\t\tc = getc();\n\t\tif(c < '0' || c > '9')break;\n\t\tret = 10*ret + c-'0';\n\t}\n\treturn sign * ret;\n}\n\ninline void ini(int& x){\n\tx = getnum<int>();\n}\n\ninline void scani(int& x){\n\tscanf(\"%d\",&x);\n}\n\n//end of macro\n\nconst ll MOD = 998244353;\n\ninline ll addmod(ll a, ll b){\n    if(a+b < MOD)return a+b;\n    return a+b-MOD;\n}\ninline ll submod(ll a, ll b){\n\treturn addmod(a, MOD-b);\n}\ninline ll mulmod(ll a, ll b){\n    return (a*b)%MOD;\n}\ninline ll expmod(ll a, ll e){\n    ll ret = 1;\n    while(e){\n        if(e&1)ret = mulmod(ret, a);\n        a = mulmod(a, a);\n        e >>= 1;\n    }\n    return ret;\n}\n\nconst int N = 205;\n\nint n;\nint x[N], y[N];\nbool used[N];\n\nint piv;\nvi pts;\nint cross(int a, int b, int c){\n    return (x[b]-x[a]) * (y[c]-y[a]) - (y[b]-y[a]) * (x[c]-x[a]);\n}\nint dist2(int a, int b){\n    return (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]);\n}\nbool cmp(int a, int b){\n    if(cross(piv, a, b) == 0)return dist2(piv, a) < dist2(piv, b);\n    return cross(piv, a, b) > 0;\n}\n\nint bitt[N];\nvoid update(int x, int v){\n    REPP(i,x,N-1,i&-i)bitt[i] += v;\n}\nint query(int x){\n    int ret = 0;\n    REVV(i,x,1,i&-i)ret += bitt[i];\n    return ret;\n}\n\nint arr[N];\nint dp[N];\nint receive[N][N]; // receive[i][j] means the current value received by i from j\nint tidx[N];\nvi pts2;\nint solve(int sz){\n//    printf(\"-------------  solve %d  ------------------\\n\",sz);\n    arr[1] = piv;\n    REP(i,2,sz)arr[i] = pts[i-2];\n    \n//    printf(\"points\\n\");\n//    REP(i,1,sz)printf(\"%d %d\\n\",x[arr[i]], y[arr[i]]);\n    \n    int ret = 0;\n    REP(i,2,sz){\n//    \tprintf(\">>> processing %d\\n\",i);\n        dp[i] = 0;\n        receive[arr[i]][arr[1]] = 1; // start new\n        \n        // extend : j --- i\n        piv = arr[i];\n        pts.clear(); pts2.clear();\n        REV(j,i-1,1){\n            pts.pb(arr[j]);\n        }\n        REP(j,i+1,sz){\n        \tpts2.pb(arr[j]);\n\t\t}\n        sort(pts.begin(), pts.end(), cmp);\n        sort(pts2.begin(), pts2.end(), cmp);\n        FOR(i,pts.size()){\n            tidx[pts[i]] = i+1;\n        }\n        memset(bitt, 0, sizeof bitt);\n        // add the points to receive[i][j]\n        REV(j,i-1,1){\n            int inside = query(tidx[arr[j]]);\n            update(tidx[arr[j]], 1);\n            //if(cross(arr[1], arr[i], arr[j]) == 0)continue; // cannot extend from co-linear\n            //dp[i] = addmod(dp[i], mulmod(dp[j], expmod(2, inside)));\n            receive[arr[i]][arr[j]] = mulmod(receive[arr[i]][arr[j]], expmod(2, inside));\n        }\n        \n        // fill dp and the receive of the next points\n        int p = 0; // pointer for pts\n\t\tFOR(j,pts2.size()){\n        \twhile(p < pts.size() && cross(pts[p], arr[i], pts2[j]) > 0){\n        \t\tdp[i] = addmod(dp[i], receive[arr[i]][pts[p]]);\n//        \t\tprintf(\"received %d %d <- %d %d, %d\\n\",x[arr[i]],y[arr[i]],x[pts[p]],y[pts[p]],receive[arr[i]][pts[p]]);\n        \t\tp++;\n\t\t\t}\n\t\t\treceive[pts2[j]][arr[i]] = dp[i];\n//\t\t\tprintf(\"push value %d %d -> %d %d, %d\\n\",x[arr[i]],y[arr[i]],x[pts2[j]],y[pts2[j]],dp[i]);\n\t\t}\n\t\twhile(p < pts.size()){\n\t\t\tdp[i] = addmod(dp[i], receive[arr[i]][pts[p]]);\n//        \tprintf(\"received %d %d <- %d %d, %d\\n\",x[arr[i]],y[arr[i]],x[pts[p]],y[pts[p]],receive[arr[i]][pts[p]]);\n        \tp++;\n\t\t}\n        \n        // close polygon : i --- 1\n        ret = addmod(ret, submod(dp[i], receive[arr[i]][arr[1]]));\n        \n//        printf(\"dp %d = %d\\n\",i,dp[i]);\n    }\n//    printf(\"ret %d = %d\\n\",sz,ret);\n    return ret;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    #define endl '\\n'\n    cout.setf(ios::fixed);\n    cout.setf(ios::showpoint);\n    cout.precision(10);\n    \n    cin>>n;\n    REP(i,1,n){\n        cin>>x[i]>>y[i];\n    }\n    \n    int ans = 0;\n    REV(sz,n,3){\n        piv = -1;\n        REP(i,1,n){\n            if(used[i])continue;\n            if(piv == -1 || (y[i] < y[piv]) || (y[i] == y[piv] && x[i] < x[piv]))piv = i;\n        }\n        \n        used[piv] = true;\n        \n        pts.clear();\n        REP(i,1,n){\n            if(used[i])continue;\n            pts.pb(i);\n        }\n        sort(pts.begin(), pts.end(), cmp);\n        \n//        printf(\"pivot %d\\n\",piv);\n//        FOR(i,pts.size())printf(\"%d\\n\",pts[i]);\n        \n        ans = addmod(ans, solve(sz));\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 998244353\n\nclass Mod{\n    //static const int MOD = 1000000007;\n    long long a;\npublic:\n    Mod(){a = 0;}\n    Mod(long long x){a = (x % MOD + MOD) % MOD;}\n    const Mod operator+(const Mod& x) const{return Mod(a + x.a);}\n    const Mod operator-(const Mod& x) const{return Mod(a - x.a);}\n    const Mod operator*(const Mod& x) const{return Mod(a * x.a);}\n    const Mod operator/(const Mod& x) const{ //フェルマーの小定理、aとMODが互いに素の時のみ\n        if(x.a == 0)return 0;\n\t\tif(a % x.a == 0)return Mod(a/x.a);\n\t\tint b = MOD - 2;long long c = x.a;long long ret = 1;\n        while(b > 0){if(b & 1){ret *= c;ret %= MOD;}\n            c *= c;c %= MOD;b >>= 1;\n        }\n        return Mod(a * ret);\n    }\n    long long getValue(){return a;}\n};\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll seica[2222];\nint main()\n{\n\tseica[0] = 1;\n\tREP(i,2221)seica[i+1] = seica[i] * 2 % MOD;\n\tint n;cin >> n;\n\tvector<pair<ll,ll>> v;\n\tREP(i,n){\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(a,b));\n\t}\n\tll ans = (seica[n] - n - 1 + MOD) % MOD; \n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = i+1;j < n;j++){\n\t\t\tvector<int> tmp;\n\t\t\tint cou = 0;\n\t\t\tll a = v[i].FI - v[j].FI;\n\t\t\tll b = v[i].SE - v[j].SE;\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tll c = v[i].FI - v[k].FI;\n\t\t\t\tll d = v[i].SE - v[k].SE;\n\t\t\t\tif(a * d == b * c){\n\t\t\t\t\tcou++;\n\t\t\t\t\ttmp.PB(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tDBG(cout << \"ij \" << i << ' ' << j << endl;);\n\t\t\tDBG(cout << \"cou \" << cou << endl;SHOW1d(tmp,tmp.size()););\n\t\t\tans = (ans - Mod(Mod(seica[cou] - cou - 1)/(cou*(cou-1)/2)).getValue() + MOD) % MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\nconst int mod=998244353;\nstruct P{\n\tint x,y;\n}a[205];\nint n,bin[205],ans=0;\nint add(int a,int b){return a+b>=mod?a+b-mod:a+b;}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\tbin[0]=1;\n\tfor(int i=1;i<=n;i++) bin[i]=add(bin[i-1],bin[i-1]);\n\tans=add(bin[n],mod-1-n-n*(n-1)/2);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=i+1;p<=n;p++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=p+1;j<=n;j++){\n\t\t\t\tif((a[p].x-a[i].x)*(a[j].y-a[p].y)==(a[j].x-a[p].x)*(a[p].y-a[i].y)) sum++;\n\t\t\t}\n\t\t\tans=add(ans,mod-bin[sum]+1);\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 100010\ntypedef long long LL;\nconst LL mod = 998244353;\nLL x[maxn], y[maxn], P[maxn];\nint main() {\n    LL n;\n    scanf(\"%lld\", &n);\n    for (int i = 0; i < n; ++i) scanf(\"%lld%lld\", &x[i], &y[i]);\n    P[0] = 1;\n    for (int i = 1; i <= n; ++i) (P[i] = P[i-1] << 1) %= mod;\n    LL ans = P[n] - 1 - n - n*(n-1)/2;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            int cnt = 0;\n            for (int k = j+1; k < n; ++k) {\n                if ((x[j]-x[i]) * (y[k]-y[j]) == (x[k]-x[j]) * (y[j]-y[i])) ++cnt;\n            }\n            ((ans -= P[cnt]-1) += mod) %= mod;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <random>\n#include <cassert>\n#include <cstring>\nusing namespace std;\n\n#define GET_ARG(a,b,c,F,...) F\n#define REP3(i,s,e) for (i = s; i <= e; i++)\n#define REP2(i,n) REP3 (i,0,(int)(n)-1)\n#define REP(...) GET_ARG (__VA_ARGS__,REP3,REP2) (__VA_ARGS__)\n#define RREP3(i,s,e) for (i = s; i >= e; i--)\n#define RREP2(i,n) RREP3 (i,(int)(n)-1,0)\n#define RREP(...) GET_ARG (__VA_ARGS__,RREP3,RREP2) (__VA_ARGS__)\n#define DEBUG(x) cerr << #x \": \" << x << endl\n\ntypedef long long ll;\n\nconst int MOD = 998244353;\n\nint x[200], y[200];\n\nint modpow(ll x, int n) {\n    int ret = 1;\n    while (n) {\n        if (n % 2) ret = ret * x % MOD;\n        x = x * x % MOD;\n        n /= 2;\n    }\n    return ret;\n}\n\nint main(void) {\n    int i, j, k, n;\n    cin >> n;\n    REP (i,n) cin >> x[i] >> y[i];\n\n    int ans = modpow(2,n) - n - 1;\n    REP (i,n) REP (j,i) {\n        int cnt = 2;\n        REP (k,n) if (k != i && k != j && (x[k] - x[i]) * (y[j] - y[i]) == (y[k] - y[i]) * (x[j] - x[i])) {\n            if (k < i) {\n                cnt = 0;\n                break;\n            }\n            cnt++;\n        }\n        ans = (ans - (modpow(2,cnt) - cnt - 1) + MOD) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nusing namespace std;\ntypedef int64_t ll;\ntypedef vector<ll> vll;\nstruct Solution {\n    void solve(std::istream& in, std::ostream& out) {\n        ll N;\n        in >> N;\n        vll x(N), y(N);\n        rep(i, N) {\n            in >> x[i] >> y[i];\n        }\n        ll ans = 0;\n        ll mod = 998244353;\n        reu(i, 0, N) {\n            reu(j, i + 1, N) {\n                ll cnt1 = 0;\n                ll cnt2 = 0;\n                reu(k, j + 1, N) {\n                    cnt1 = (cnt1 * 2 + 1) % mod;\n                    if (triangle(x[i] - x[k], y[i] - y[k], x[j] - x[k], y[j] - y[k]) == 0) {\n                        cnt2 = (cnt2 * 2 + 1) % mod;\n                    }\n                }\n                ans += cnt1;\n                ans -= cnt2;\n                ans %= mod;\n                ans %= mod;\n            }\n        }\n        out << ans << '\\n';\n    }\n    ll triangle(ll ax, ll ay, ll bx, ll by) {\n        return (ax*by) - (bx*ay);\n    }\n};\nvoid solve(std::istream& in, std::ostream& out) {\n    out << std::setprecision(12);\n    Solution solution;\n    solution.solve(in, out);\n}\n#include <fstream>\n#include <iostream>\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    istream& in = cin;\n    ostream& out = cout;\n    solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iomanip>\nusing namespace std;\n \n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\ntypedef long long ll;\n\nstruct ConvexHull {\n    \n    struct Point {\n        double x,y;\n        Point () {}\n        Point (double _x, double _y) : x(_x), y(_y) {}\n        bool operator < (const Point &a) const {\n            return (x == a.x) ? (y < a.y) : (x < a.x);\n        }\n    };\n    \n    double dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }\n    double cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }\n    double norm(Point a) { return sqrt(dot(a, a) * dot(a, a)); }\n    Point sub(Point a, Point b) { return Point(a.x - b.x, a.y - b.y); }\n    \n    vector< Point > Pos;\n    vector< Point > CHPos;\n    \n    int counter_clockwise(Point p0, Point p1, Point p2) {\n        Point a = sub(p1, p0);\n        Point b = sub(p2, p0);\n        if (cross(a,b) > 1.0e-8) return 1;\n        if (cross(a,b) < -1.0e-8) return -1;\n        if (dot(a,b) < -1.0e-8) return 2;\n        if (norm(a) < norm(b)) return -2;\n        return 0;\n    }\n    \n    void add_point(double x, double y) {\n        Pos.push_back(Point(x, y));\n    }\n    \n    void build() {\n        int n = (int) Pos.size(), k = 0;\n        sort(Pos.begin(),Pos.end());\n        vector< Point > ch(2 * n);\n        for (int i = 0; i < n; ch[k++] = Pos[i++]) {\n            while (k >= 2 && counter_clockwise(ch[k-2], ch[k-1], Pos[i]) <= 0) --k;\n        }\n        for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = Pos[i--]) {\n            while (k >= t && counter_clockwise(ch[k-2], ch[k-1], Pos[i]) <= 0) --k;\n        }\n        copy(ch.begin(), ch.begin() + k - 1, back_inserter(CHPos));\n    }\n    \n    double diameter() {\n        int n = (int) CHPos.size();\n        int is = 0, js = 0;\n        for (int i = 1; i < n; i++) {\n            if (CHPos[i].y > CHPos[is].y) is = i;\n            if (CHPos[i].y < CHPos[js].y) js = i;\n        }\n        double maxd = norm(sub(CHPos[is], CHPos[js]));\n        int i = is, maxi = is;\n        int j = js, maxj = js;\n        do{\n            if (cross(sub(CHPos[(i + 1) % n], CHPos[i]), sub(CHPos[(j + 1) % n], CHPos[j])) >= 0) {\n                j = (j + 1) % n;\n            } else {\n                i = (i + 1) % n;\n            }\n            if(norm(sub(CHPos[i], CHPos[j])) > maxd) {\n                maxd = norm(sub(CHPos[i], CHPos[j]));\n                maxi = i, maxj = j;\n            }\n        } while (i != is || j != js);\n        return sqrt(maxd);\n    }\n    \n    int size() {\n        return (int) CHPos.size();\n    }\n    \n    Point operator [] (int n) {\n        return CHPos[n];\n    }\n    \n};\n\nlong long pow_mod(long long n, long long k, long long mod) {\n    long long ret = 1, a = n % mod;\n    while (k > 0) {\n        if (k & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        k >>= 1;\n    }\n    return ret;\n}\n\n#define MOD 998244353\n\nint idx(int i, int j) {\n\treturn i * 10010 + j;\n}\n\nll N;\nll ans;\nll p_mod[300];\nvector<int> x, y;\nunordered_set< vector<bool> > used;\nunordered_map< int, int> table;\n\nvoid dfs(vector<bool> ver, int cnt) {\n\tif (cnt <= 2) return;\n\tif (used.find(ver) != used.end()) {\n\t\treturn;\n\t}\n\tConvexHull inst;\n\tvector< pair<double, double> > vs;\n\tREP(i,ver.size()) {\n\t\tif (ver[i]) vs.push_back(make_pair((double) x[i], (double) y[i]));\n\t}\n\tsort(vs.begin(), vs.end());\n\tREP(i,vs.size()) inst.add_point(vs[i].first, vs[i].second);\n\tinst.build();\n\tif (inst.size() < 3) return;\n\tif (inst.size() == 3 && cnt == 3) {\n\t\tans += p_mod[0];\n\t\tans %= MOD;\n\t\tused.insert(ver);\n\t\treturn;\n\t}\n\tans += p_mod[cnt - inst.size()];\n\tans %= MOD;\n\tREP(i,inst.size()) {\n\t\tint p = idx((int)inst[i].x, (int)inst[i].y);\n\t\tint v = table[p];\n\t\tvector<bool> ver_t = ver;\n\t\tver_t[v] = false;\n\t\tdfs(ver_t, cnt - 1);\n\t}\n}\n\nint main() {\n\n\tcin >> N;\n\tx.resize(N);\n\ty.resize(N);\n\tREP(i,N) cin >> x[i] >> y[i];\n\tREP(i,N) table[idx(x[i], y[i])] = i;\n\n\tans = 0;\n\tREP(i,300) p_mod[i] = pow_mod(2, (ll)i, MOD);\n\tvector<bool> ver(N);\n\tREP(i,N) ver[i] = true;\n\tdfs(ver, N);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <cstdio> \n#include <iostream> \n#include <cmath> \n#include <string> \n#include <list> \n#include <vector> \n#include <algorithm> \n#include <functional> \n#include <utility> \n#include <set> \n#include <map> \n#include <complex> \n#include <queue> \n#include <stack> \n#include <cstdlib> \n#include <ctime> \n#include <cstring> \n#include <string.h> \n#include <unordered_set>\n#include <unordered_map>\n#include <cassert>\n\nusing namespace std; \n\ntypedef unsigned int uint; \ntypedef long long int64; \ntypedef unsigned long long uint64; \ntypedef unsigned short ushort; \ntypedef unsigned char uchar; \ntypedef pair<int,int> ipair; \ntypedef vector<int> VI; \ntypedef vector<string> VS; \ntypedef vector<double> VD; \n#define SIZE(A) ((int)(A.size()))\n#define LENGTH(A) ((int)(A.length()))\n#define MP(A,B) make_pair(A,B)\nconst double pi=acos(-1.0); \nconst double eps=1e-11; \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(a) (a).begin(),(a).end()\n\ntemplate<class T> T sqr(const T &x) { return x*x; } \ntemplate<class T> T lowbit(const T &x) { return (x^(x-1))&x; } \ntemplate<class T> int countbit(const T &n) { return (n==0)?0:(1+countbit(n&(n-1))); } \ntemplate<class T> void ckmin(T &a,const T &b) { if (b<a) a=b; } \ntemplate<class T> void ckmax(T &a,const T &b) { if (b>a) a=b; } \n\nconst int maxn=256;\nconst int MOD=998244353;\n\ninline int multiply(int a,int b)\n{\n\treturn ((int64)a*(int64)b)%MOD;\n}\ninline void addto(int &a,int b)\n{\n\ta+=b;\n\tif (a>=MOD) a-=MOD;\n}\ninline void delto(int &a,int b)\n{\n\ta-=b;\n\tif (a<0) a+=MOD;\n}\n\nint n;\nint x[maxn],y[maxn];\nint c[maxn][maxn][maxn];\nint s[maxn][maxn][maxn];\nint l[maxn][maxn];\nint f[maxn][maxn];\nint p2[maxn];\n\nbool is_middle(int a,int b,int c)\n{\n\treturn a==b || c==b || (a<b)!=(c<b);\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios_base::sync_with_stdio(false);\n\tcin>>n;\n\tREP(i,n) cin>>x[i]>>y[i];\n\tREP(i,n) REP(j,n) REP(k,n)\n\t{\n\t\tint t=(x[j]-x[i])*(y[k]-y[i])-(x[k]-x[i])*(y[j]-y[i]);\n\t\tc[i][j][k]=((t==0)?0:(t<0?-1:1));\n\t}\n\tREP(i,n+1) p2[i]=(i==0?1:multiply(p2[i-1],2));\n\tmemset(l,0,sizeof(l));\n\tREP(i,n) REP(j,n)\n\t{\n\t\tint w=0;\n\t\tREP(p,n) if (c[i][j][p]==0 && is_middle(x[i],x[p],x[j]) && is_middle(y[i],y[p],y[j])) ++w;\n\t\tl[i][j]=w-2;\n\t}\n\tmemset(s,0,sizeof(s));\n\tREP(i,n) REP(j,n) REP(k,n) if (c[i][j][k]>0)\n\t{\n\t\tif (j<i) { s[i][j][k]=s[j][k][i]; continue; }\n\t\tif (k<i) { s[i][j][k]=s[k][i][j]; continue; }\n\t\tint w=0;\n\t\tREP(p,n) if (c[i][j][p]>=0 && c[j][k][p]>=0 && c[k][i][p]>=0) ++w;\n\t\ts[i][j][k]=w-3;\n\t}\n\tint ret=0;\n\tREP(key,n)\n\t{\n\t\tint size=0,p[maxn];\n\t\tREP(i,n) if (x[i]>x[key] || x[i]==x[key] && y[i]>y[key]) p[size++]=i;\n\t\tsort(p,p+size,[&](int a,int b) { return c[key][a][b]>0; });\n\t\tmemset(f,0,sizeof(f));\n\t\tREP(s1,size) FOR(s2,s1+1,size) if (c[key][p[s1]][p[s2]]>0)\n\t\t{\n\t\t\tint e=s[key][p[s1]][p[s2]];\n\t\t\tf[s1][s2]=p2[e];\n\t\t\tREP(s0,s1) if (c[key][p[s0]][p[s1]]>0 && c[p[s0]][p[s1]][p[s2]]>0) \n\t\t\t\taddto(f[s1][s2],multiply(f[s0][s1],p2[e-l[key][p[s1]]]));\n\t\t\taddto(ret,f[s1][s2]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\nusing ll = long long;\n\nconst ll MOD = 998244353;\nll mod(ll x) {\n    return x % MOD;\n}\nll pow_mod(ll x, ll p) {\n    ll v = 1;\n    while (p) {\n        if (p & 1) {\n            v = mod(v * x);\n        }\n        x = mod(x * x);\n        p >>= 1;\n    }\n    return v;\n}\n\nll N;\n\nstruct Point {\n    ll x, y;\n    friend Point operator-(const Point& a, const Point& b) {\n        return {a.x - b.x, a.y - b.y};\n    }\n    friend ll operator*(const Point& a, const Point& b) {\n        return a.x*b.y - a.y*b.x;\n    }\n    friend bool are_aligned(const Point& a, const Point& b, const Point& c) {\n        return (a-c)*(b-c) == 0;\n    }\n    friend bool in(const Point& a, const Point& b, const Point& c) {\n        auto s = a-c, t = b-c;\n        return s.x * t.x <= 0 and s.y * t.y <= 0;\n    }\n};\nvector<Point> points;\n\nvoid input() {\n    cin >> N;\n    points.resize(N);\n    for (auto& p : points)\n        cin >> p.x >> p.y;\n}\n\nvoid solve() {\n    ll sum = 0;\n    for (ll i = 0; i < N; i++) {\n        for (ll j = i + 1; j < N; j++) {\n            ll num_aligned_points = 2;\n            bool skip = false;\n            for (ll k = 0; k < N; k++) {\n                if (k == i or k == j) continue;\n                if (are_aligned(points[i], points[j], points[k])) {\n                    if (not in(points[i], points[j], points[k])) {\n                        skip = true;\n                        break;\n                    }\n                    ++num_aligned_points;\n                }\n            }\n            if (skip) continue;\n            sum = mod(sum + (pow_mod(2, num_aligned_points) - num_aligned_points - 1));\n        }\n    }\n    ll ans = mod(pow_mod(2, N) - sum - N - 1);\n    cout << ans << endl;\n}\n\n\nint main() {\n    input();\n    solve();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <int MOD> struct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tModInt(signed long long sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = (unsigned long long)x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n\tModInt inverse() const {\n\t\tsigned a = x, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tsigned t = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\tif (u < 0)\n\t\t\tu += MOD;\n\t\tModInt res;\n\t\tres.x = (unsigned)u;\n\t\treturn res;\n\t}\n};\ntemplate <int MOD> ostream &operator<<(ostream &os, const ModInt<MOD> &m) {\n\treturn os << m.x;\n}\ntemplate <int MOD> istream &operator>>(istream &is, ModInt<MOD> &m) {\n\tsigned long long s;\n\tis >> s;\n\tm = ModInt<MOD>(s);\n\treturn is;\n};\n// pow(mint(2), 1000) のように\ntemplate <int MOD> ModInt<MOD> pow(ModInt<MOD> a, unsigned long long k) {\n\tModInt<MOD> r = 1;\n\twhile (k) {\n\t\tif (k & 1)\n\t\t\tr *= a;\n\t\ta *= a;\n\t\tk >>= 1;\n\t}\n\treturn r;\n}\n\n//#define int long long を使っても大丈夫\nusing mint = ModInt<998244353>;\n\n// nCrで用いる\nvector<mint> fact, factinv;\n// nCrで用いる 予め計算しておく\nvoid nCr_compute_factinv(int N) {\n\tN = min(N, mint::Mod - 1);\n\tfact.resize(N + 1);\n\tfactinv.resize(N + 1);\n\tfact[0] = 1;\n\trep(i, 1, N + 1) fact[i] = fact[i - 1] * i;\n\tfactinv[N] = fact[N].inverse();\n\tfor (int i = N; i >= 1; i--)\n\t\tfactinv[i - 1] = factinv[i] * i;\n}\nmint nCr(int n, int r) {\n\tif (n >= mint::Mod)\n\t\treturn nCr(n % mint::Mod, r % mint::Mod) *\n\t\tnCr(n / mint::Mod, r / mint::Mod);\n\treturn r > n ? 0 : fact[n] * factinv[n - r] * factinv[r];\n}\n\nmint nHr(int n, int r) { return r == 0 ? 1 : nCr(n + r - 1, r); }\n\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N; cin >> N;\n\tvector<int>x(N), y(N); rep(i, 0, N) { cin >> x[i] >> y[i]; }\n\tmint ans = pow(mint(2), N) - 1 - N;\n\tset<tuple<int, int, int>>st;\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tint dy = y[j] - y[i];\n\t\t\tint dx = x[j] - x[i];\n\t\t\ttuple<int, int, int>t;\n\t\t\tif (dx == 0) {\n\t\t\t\tt = { x[i],0,0 };\n\t\t\t}\n\t\t\telse t = make_tuple(dy, -dx, -dy * x[i] + dx * y[i]);\n\t\t\tdump(t);\n\t\t\tif (st.count(t))continue;\n\t\t\tst.insert(t);\n\t\t\tint cnt = 0;\n\t\t\trep(k, 0, N) {\n\t\t\t\tif (dx!=0 and y[k] * dx == dy * (x[k] - x[i]) + y[i] * dx) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\telse if (dx == 0 and x[i] == x[k]) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdump(cnt);\n\t\t\tans -= pow(mint(2), cnt) - cnt - 1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define mod 998244353ll\n#define P pair<int,int>\nusing namespace std;\n\nP a[200];\nsigned main() {\n\tint ans = 1;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = ans * 2 % mod;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t}\n\tans -= n + 1;\n\tans %= mod;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tvector<int>V;\n\t\t\tif (a[i].first == a[j].first) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].first == a[i].first) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (a[i].second == a[j].second) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].second == a[i].second) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble x = double(a[j].second - a[i].second) / (a[j].first - a[i].first);\n\t\t\t\tdouble y = double(a[i].second) - a[i].first*x;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (abs(a[i].first*x + y - a[i].second) <= 1e-5) {\n\t\t\t\t\t\tV.push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(V.begin(), V.end());\n\t\t\tif (V.size()>=2&&V[0] == i&&V[1]==j) {\n\t\t\t\tint k = 1;\n\t\t\t\tfor (int j : V) {\n\t\t\t\t\tk = k * 2 % mod;\n\t\t\t\t}\n\t\t\t\tk -= V.size(); k--;\n\t\t\t\tans -= k;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tans += mod * 5;\n\tans %= mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: CNYALI_LK\nLANG: C++\nPROG: E.cpp\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconst double eps=1e-8;\nconst double PI=acos(-1.0);\ntypedef long long ll;\ntemplate<class T>void chkmin(T &a,T b){a=a<b?a:b;}\ntemplate<class T>void chkmax(T &a,T b){a=a>b?a:b;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\n#define min mmin\n#define max mmax\n#define abs aabs\nconst ll mod=998244353;\nll p[233];\nstruct zb{\n\tll x,y;\n};\nzb a[233];\nll cmp(zb a,zb b){return a.x<b.x||a.x==b.x&&a.y<b.y;}\nint main(){\n#ifdef cnyali_lk\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n\tll n,ans;\n\tscanf(\"%lld\",&n);\n\tp[0]=1;\n\tfor(ll i=1;i<=n;++i){p[i]=p[i-1]<<1;if(p[i]>=mod)p[i]-=mod;scanf(\"%lld%lld\",&a[i].x,&a[i].y);}\n\tsort(a+1,a+n+1,cmp);\n\tans=p[n]-n-1;\n\tfor(ll i=1;i<=n;++i)for(ll j=i+1;j<=n;++j){\n\t\tll no=0;\n\t\tfor(ll k=1;k<j;++k)if(k!=i&&(a[j].x-a[i].x)*(a[i].y-a[k].y)==(a[j].y-a[i].y)*(a[i].x-a[k].x)){no=1;break;}\n\t\tif(!no){\n///\t\t\tdebug(\"(%lld,%lld) (%lld,%lld)\",a[i].x,a[i].y,a[j].x,a[j].y);\n\t\t\tll tot=2;\n\t\t\tfor(ll k=j+1;k<=n;++k){\n\t\t\t\tif((a[j].x-a[i].x)*(a[i].y-a[k].y)==(a[j].y-a[i].y)*(a[i].x-a[k].x)){++tot;/*debug(\" (%lld,%lld)\",a[k].x,a[k].y);*/}\n\t\t\t}\n//\t\t\tdebug(\"\\n\");\n\t\t\tans-=p[tot]-tot-1;\n\t\t}\n\t}\t\n\tprintf(\"%lld\\n\",(ans%mod+mod)%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-12;\ntypedef complex<double> P;\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<pair<int,int>>se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\tif(se.find({i,j})!=se.end())continue;\n\t\tL l(v[i],v[j]);\n\t\tvector<int>x={i,j};\n\t\tfor(int k=j+1;k<N;k++)if(abs(imag(conj(v[j]-v[k])*(v[i]-v[k])))<1e-12)x.push_back(k);\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\tr=(r-pow_binary_mod(2,b+~a,M))%M;\n\t\t\tse.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <tuple>\n \nusing namespace std;\n \nstruct pos\n{\n    int x, y;\n};\n \npos arr[200];\nbool chk[200][200];\n \nconst int mod = 998244353;\nint exp(int a, int x)\n{\n    if(x == 0)\n        return 1;\n    if(x%2)\n        return 1LL * exp(a, x-1) * a % mod;\n    int t = exp(a, x/2);\n    return 1LL * t * t % mod;\n}\n \nint fac[201];\nint caf[201];\ninline int ncr(int n, int r)\n{\n    return 1LL * fac[n] * caf[r] % mod * caf[n-r] % mod;\n}\n \nvector<int> tmp;\n \nint main()\n{\n    //freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n \n    int n, x, y, r, t, i, j, k;\n    scanf(\"%d\", &n);\n    for(i = 0; i<n; i++)\n    {\n        scanf(\"%d%d\", &x, &y);\n        arr[i] = { x, y };\n    }\n \n    fac[0] = 1;\n    for(i = 1; i<=200; i++)\n        fac[i] = 1LL * fac[i-1] * i % mod;\n \n    for(i = 0; i<=200; i++)\n        caf[i] = exp(fac[i], mod-2);\n \n    r = 0;\n    for(i = 2; i<=n; i++)\n    {\n        r += ncr(n, i);\n        r %= mod;\n    }\n \n    for(i = 0; i<n-1; i++)\n    {\n        for(j = i+1; j<n; j++)\n        {\n            if(chk[i][j] || chk[j][i])\n                continue;\n \n            tmp.clear();\n \n            tmp.push_back(i);\n            tmp.push_back(j);\n \n            t = 2;\n            for(k = 0; k<n; k++)\n            {\n                if(k == i || k == j)\n                    continue;\n \n                if(1LL * (arr[i].y - arr[j].y) * (arr[i].x - arr[k].x) != 1LL * (arr[i].x - arr[j].x) * (arr[i].y - arr[k].y))\n                    continue;\n \n                tmp.push_back(k);\n                t++;\n            }\n \n            for(int ii = 0; ii<t-1; ii++)\n                for(int jj = ii+1; jj<t; jj++)\n                    chk[ii][jj] = 1;\n \n            for(k = 2; k<=t; k++)\n            {\n                r -= ncr(t, k);\n                r += mod;\n                r %= mod;\n            }\n        }\n    }\n \n    printf(\"%d\\n\", r);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 100005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;T f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nconst int MOD = 998244353;\nint N,ans;\nstruct Point {\n\tint x,y;\n\tPoint(int _x = 0,int _y = 0) {\n\t\tx = _x;y = _y;\n\t}\n\tfriend Point operator + (const Point &a,const Point &b) {\n\t\treturn Point(a.x + b.x,a.y + b.y);\n\t}\n\tfriend Point operator - (const Point &a,const Point &b) {\n\t\treturn Point(a.x - b.x,a.y - b.y);\n\t}\n\tfriend int operator * (const Point &a,const Point &b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\tfriend int dot(const Point &a,const Point &b) {\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n}P[205];\nint inc(int a,int b) {\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n\treturn 1LL * a * b % MOD;\n}\nint fpow(int x,int c) {\n\tint res = 1,t = x;\n\twhile(c) {\n\t\tif(c & 1) res = mul(res,t);\n\t\tt = mul(t,t);\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\nvoid Solve() {\n\tread(N);\n\tans = fpow(2,N);ans = inc(ans,MOD - N - 1);\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tread(P[i].x);read(P[i].y);\n\t}\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tfor(int j = 1 ; j <= N ; ++j) {\n\t\t\tif(i == j || P[i].x > P[j].x || (P[i].x == P[j].x && P[i].y > P[j].y)) continue;\n\t\t\tint cnt = 2;\n\t\t\tfor(int k = 1 ; k <= N ; ++k) {\n\t\t\t\tif(k == i || k == j) continue;\n\t\t\t\tif((P[k] - P[i]) * (P[k] - P[j]) == 0) {\n\t\t\t\t\tif(P[k].x < P[j].x || (P[k].x == P[j].x && P[k].y < P[j].y)) goto fail;\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = inc(ans,MOD - inc(fpow(2,cnt),MOD - cnt - 1));\n\t\t\tfail:;\n\t\t}\n\t}\n\tout(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint m[200][200];\nint x[200], y[200];\ntypedef long long ll;\nll p2[1000];\nll mod = 998244353;\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)scanf(\"%d%d\", &x[i], &y[i]);\n\tp2[0] = 1;\n\tfor (int i = 1; i < 1000; i++)p2[i] = p2[i - 1] * 2 % mod;\n\tll s = p2[num];\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = i + 1; j < num; j++)\n\t\t{\n\t\t\tif (m[i][j])continue;\n\t\t\tvector<int>v;\n\t\t\tfor (int k = 0; k < num; k++)\n\t\t\t{\n\t\t\t\tif ((x[k] - x[i])*(y[j] - y[i]) == (y[k] - y[i])*(x[j] - x[i]))v.push_back(k);\n\t\t\t}\n\t\t\ts = (s + mod - p2[v.size()] + v.size() + 1) % mod;\n\t\t\tfor (int k = 0; k < v.size(); k++)for (int l = 0; l < v.size(); l++)m[v[k]][v[l]] = 1;\n\t\t}\n\t}\n\ts = (s + mod - num - 1)%mod;\n\tprintf(\"%lld\\n\", s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t205\n#define P\t998244353\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nstruct point {int x, y; };\npoint operator + (point a, point b) {return (point) {a.x + b.x, a.y + b.y}; }\npoint operator - (point a, point b) {return (point) {a.x - b.x, a.y - b.y}; }\nint operator * (point a, point b) {return a.x * b.y - a.y * b.x; }\npoint a[MAXN];\nlong long fac[MAXN], inv[MAXN];\nlong long power(long long x, long long y) {\n\tif (y == 0) return 1;\n\tlong long tmp = power(x, y / 2);\n\tif (y % 2 == 0) return tmp * tmp % P;\n\telse return tmp * tmp % P * x % P;\n}\nlong long getc(int x, int y) {\n\tif (x < y) return 0;\n\telse return fac[x] * inv[y] % P * inv[x - y] % P;\n}\nbool online(point a, point b, point c) {\n\treturn (c - a) * (b - a) == 0;\n}\nvoid update(long long &a, long long b) {\n\ta = (a - b + P) % P;\n}\nint main() {\n\tint n; read(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i].x), read(a[i].y);\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = fac[i - 1] * i % P;\n\tinv[n] = power(fac[n], P - 2);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1) % P;\n\tlong long ans = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tans = ans * 2 % P;\n\tupdate(ans, n + 1); update(ans, getc(n, 2));\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = i + 1; j <= n; j++) {\n\t\tbool halted = false;\n\t\tfor (int k = 1; k < j; k++)\n\t\t\tif (k != i && online(a[i], a[j], a[k])) {\n\t\t\t\thalted = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (halted) continue;\n\t\tint cnt = 2;\n\t\tfor (int k = j + 1; k <= n; k++)\n\t\t\tif (online(a[i], a[j], a[k])) cnt++;\n\t\tfor (int k = 3; k <= cnt; k++)\n\t\t\tupdate(ans, getc(cnt, k));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n对于凸包点集 S ，其贡献为 2^k ，其中 k 是该凸包包含的点数除去顶点。\n设 T 表示这 k 个点组成的集合，那么 2^k 就是 T 的子集数量。\n\n那么每个 (S, U) 二元组对答案的贡献为 1 ，其中 U 是 T 的子集。\n而事实上 (S, U) 与 S 并 U 是一一对应的，\n因为一个点集的凸包是唯一的，也就是说已知 S 并 U 可以求出唯一的 S ，进而求出唯一的 U 。\n那么答案就是合法的 S 并 U 的点集数量。\n\n合法指的是什么？指的就是存在凸包。\n那么什么样的点集不合法呢？一个点集 X 不合法当且仅当 X 的点共线或者 |X| < 3 。\n\n那么可以简单容斥，用满足 |X| >= 3 的 X 的数量减去不合法的 X 数量。\n也就是统计共线的点集数，n 很小，枚举两个点，它们唯一确定一条直线，\n然后再暴力统计该直线上有多少点即可，这样一个 X 会被算多次，除掉算重次数即可。\n\n另外也可以枚举共线 X 的两个端点，然后暴力统计端点构成的线段之间有多少点，设为 k ，\n那么这两个端点对不合法点集的贡献就是 2^k ，这样的好处是不会算重，更好理解。\n\n总复杂度 O(n^3) ，事实上统计一条直线上的点数有更优秀的做法，可以做到 O(n^2logn) ，\n但本题中 O(n^3) 已经足够了。\n#endif\n#include <cstdio>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 205, mod = 998244353;\n\ninline ll sq(ll x) { return x * x; }\ninline bool in_line(ll x1, ll y1, ll x2, ll y2) {\n\tll a = x1 * x2 + y1 * y2;\n\tll b = (sq(x1) + sq(y1)) * (sq(x2) + sq(y2));\n\t/* debug(\"chk %lld %lld\\n\", sq(a), b); */\n\treturn a >= 0 and sq(a) == b;\n}\n\nint x[maxn], y[maxn];\nll p2[maxn];\n\nint main() {\n\tint n = read;\n\tfor(int i = 1; i <= n; i ++)\n\t\tread(x[i], y[i]);\n\n\tp2[0] = 1;\n\tfor(int i = 1; i <= n; i ++)\n\t\tp2[i] = (p2[i - 1] << 1) % mod;\n\n\tll ans = p2[n] - n - 1;\n\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j < i; j ++) {\n\t\t\tint tot = 0;\n\t\t\tfor(int k = 1; k <= n; k ++)\n\t\t\t\tif(k != i and k != j and\n\t\t\t\t\t\tin_line(x[i] - x[k], y[i] - y[k], x[k] - x[j], y[k] - y[j]))\n\t\t\t\t\tdebug(\"%d %d %d\\n\", i, k, j),\n\t\t\t\t\t++ tot;\n\t\t\tans -= p2[tot];\n\t\t}\n\n\tprintf(\"%lld\\n\", (ans % mod + mod) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<ll> pt;\n\nstruct rational {\n  ll n, d;\n};\n\nll gcd(ll a, ll b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n  return a * (b / gcd(a, b));\n}\n\nrational operator*(const rational &a, const rational &b) {\n  rational res = rational {a.n * b.n, a.d * b.d};\n  ll g = gcd(res.n, res.d);\n  res.n /= g;\n  res.d /= g;\n  return res;\n}\n\nrational operator/(const rational &a, const rational &b) {\n  rational res = rational {a.n * b.d, a.d * b.n};\n  ll g = gcd(res.n, res.d);\n  res.n /= g;\n  res.d /= g;\n  return res;\n}\n\nrational operator-(const rational &a, const rational &b) {\n  ll l = lcm(a.d, b.d);\n  ll f1 = l / a.d;\n  ll f2 = l / b.d;\n  return rational {a.n * f1 - b.n * f2, l};\n}\n\nbool operator<(const rational &a, const rational &b)  {\n  if (a.n != b.n) return a.n < b.n;\n  return a.d < b.d;\n}\n\nbool operator!=(const rational &a, const rational &b) {\n  return a < b || b < a;\n}\n\nbool operator==(const rational &a, const rational &b) {\n  return !(a != b);\n}\n\nstruct line {\n  rational a, b, c;\n};\n\nline pointsToLine(pt p1, pt p2) {\n  line l;\n  if (p1.real() == p2.real()) {\n    l.a = rational {1, 1};\n    l.b = rational {0, 1};\n    l.c = rational {-p1.real(), 1};\n  } else {\n    l.a = rational {-p1.imag() + p2.imag(), 1} / rational {p1.real() - p2.real(), 1};\n    l.b = rational {1, 1};\n    l.c = l.a * rational {p1.real(), 1} - rational {p1.imag(), 1};\n  }\n  return l;\n}\n\nbool areParallel(line l1, line l2) {\n  return l1.a == l2.a && l1.b == l2.b;\n}\n\nbool operator==(const line &l1, const line &l2) {\n  return areParallel(l1, l2) && l1.c == l2.c;\n}\n\nbool operator<(const line &l1, const line &l2) {\n  if (l1.a != l2.a) return l1.a < l2.a;\n  if (l1.b != l2.b) return l1.b < l2.b;\n  return l1.c < l2.c;\n}\n\nmap<line, ll> counter;\nmap<ll, ll> invTri;\nll powers2[201];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pt> points(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    points[i] = pt(x, y);\n  }\n  sort(points.begin(), points.end(), [](const pt &a, const pt &b) {\n    if (a.real() == b.real()) return a.imag() < b.imag();\n    return a.real() < b.real();\n  });\n\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      counter[pointsToLine(points[i], points[j])]++;\n    }\n  }\n\n  powers2[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    powers2[i] = (2 * powers2[i - 1]) % MOD;\n  }\n\n  for (int i = 1; i <= n; i++) {\n    invTri[i * (i - 1) / 2] = i;\n  }\n\n  ll colSubs = n;\n  for (auto slope : counter) {\n    ll onLine = invTri[slope.second];\n    colSubs += powers2[onLine] - onLine - 1;\n    colSubs %= MOD;\n    colSubs += MOD;\n    colSubs %= MOD;\n  }\n\n  printf(\"%lld\\n\", (powers2[n] - colSubs - 1LL + 2 * MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#define ll long long\n#define MN 1100\nusing namespace std;\n\nstruct na{int x,y;}P[MN];\nint num=0,f[MN],si[MN];\nint gf(int x){return x==f[x]?x:f[x]==gf(f[x]);}\nstruct ma{\n\tint a,b,v;\n\tvoid cal(){\n\t\tint x=gf(a),y=gf(b);\n\t\tif(x!=y)f[x]=y,si[y]+=si[x];\n\t}\n}bi[MN*MN];\nbool operator < (ma a,ma b){return a.v<b.v;}\nint read_p,read_ca;\ninline int read(){\n    read_p=0;read_ca=getchar();\n    while(read_ca<'0'||read_ca>'9') read_ca=getchar();\n    while(read_ca>='0'&&read_ca<='9') read_p=read_p*10+read_ca-48,read_ca=getchar();\n    return read_p;\n}\nint n,a;\nint gcd(int x,int y){return y?gcd(y,x%y):x;}\nint two[MN],mmh;\nconst int MOD=998244353;\nint main(){\n\tint i,j,k;\n\tn=read();\n\ttwo[0]=1;\n\tfor(i=1;i<=n;i++)two[i]=(two[i-1]<<1)%MOD;\n\tfor(i=0;i<n;i++) P[i].x=read(),P[i].y=read();\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<i;j++){\n\t\t\tint x=P[i].x-P[j].x,y=P[i].y-P[j].y;\n\t\t\tif (!x) y=1;else\n\t\t\tif (!y) x=1;else{\n\t\t\t\tint g=gcd(x,y);\n\t\t\t\tx/=g,y/=g;\n\t\t\t\tif(x<0)x=-x,y=-y;\n\t\t\t}\n\t\t\tbi[num++]=ma{i,j,x*30000+y};\n\t\t}\n\t}\n\tmmh=(two[n]-n-1)%MOD;\n\tsort(bi,bi+num);\n\tfor(i=0,j=0;i<num;i=j){\n\t\tfor(a=0;a<n;a++)si[f[a]=a]=1;\n\t\tfor(;j<num&&bi[i].v==bi[j].v;bi[j++].cal());\n\t\tfor(a=0;a<n;a++)\n\t\tif(f[a]==a&&si[a]>1)mmh=(mmh-two[si[a]]+si[a]+1)%MOD;\n\t}\n\tprintf(\"%d\\n\",(mmh%MOD+MOD)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\nint gcd(int a, int b) { return a ? gcd(b%a, a) : b; }\ntypedef long long ll;\nll mod = 998244353LL;\nll add(ll x, ll y) { return (x += y) >= mod ? x - mod : x; }\nll sub(ll x, ll y) { return add(x, mod - y); }\nll modpow(ll a, ll b) {\n    ll ret = 1; while (b > 0) {\n        if (b & 1) ret = ret * a % mod; a = a * a % mod; b >>= 1;\n    } return ret;\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\nint N, X[202], Y[202];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) cin >> X[i] >> Y[i];\n\n    ll ans = modpow(2, N);\n\n    // no point\n    ans = sub(ans, 1);\n\n    // one point\n    ans = sub(ans, N);\n\n    // line points\n    map<pair<int, int>, vector<pair<int,int>>> m;\n    rep(i, 0, N) rep(j, 0, N) if(i != j){\n        int dx = X[j] - X[i];\n        int dy = Y[j] - Y[i];\n        if (dx < 0) {\n            dx *= -1;\n            dy *= -1;\n        }\n\n        if (dx == 0) m[{101010, X[i]}].push_back({ i, j });\n        else if (dy == 0) m[{Y[i], 101010}].push_back({ i, j });\n        else {\n            int g = gcd(dx, abs(dy));\n            dx /= g;\n            dy /= g;\n            m[{dy, dx}].push_back({ i, j });\n        }\n    }\n\n    fore(p, m) {\n        auto v = p.second;\n        set<int> s;\n        fore(q, v) {\n            s.insert(q.first);\n            s.insert(q.second);\n        }\n\n        int n = s.size();\n        ll delta = sub(modpow(2, n), add(1, n));\n        //cout << delta << endl;\n        ans = sub(ans, delta);\n    }\n\n    cout << ans << endl;\n    //cout << (mint(2) ^ 2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lsk 998244353\nint n;\nint x[205],y[205];\nint vd[205][205];\nint main(){\n\tscanf(\"%d\",&n);\n\tint ans=1;\n\tfor(int i=1;i<=n;++i)scanf(\"%d%d\",x+i,y+i),ans=(ans<<1)%lsk;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=i+1;j<=n;++j){int a=1;\n\t\t\tfor(int k=j+1;k<=n;++k){\n\t\t\t\tif((x[j]-x[i])*(y[k]-y[i])==(x[k]-x[i])*(y[j]-y[i]))a=(a<<1)%lsk;\n\t\t\t}ans-=a;ans%=lsk;\n\t\t}\n\t}\n\tcout<<((ans-n-1)%lsk+lsk)%lsk;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define ll long long\n#define ld long double\n#define inf 1000000000\nusing namespace std;\n#define N 205\n#define mod 998244353\nint n,pw[N],ans;\nstruct node{ int x,y; }a[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tpw[0]=1; rep (i,1,n) pw[i]=2ll*pw[i-1]%mod;\n\tans=(pw[n]+mod-1-n)%mod;\n\trep (i,1,n) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\trep (i,1,n) rep (j,i+1,n){\n\t\tint sum=0;\n\t\trep (k,j+1,n)\n\t\t\tif ((a[i].y-a[j].y)*(a[j].x-a[k].x)==(a[i].x-a[j].x)*(a[j].y-a[k].y)) sum++;\n\t\tans=(ans+mod-pw[sum])%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) > 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\nint adds[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<point> ns;\n        for (int j = 0; j < n; j++) {\n            if (j == i) {\n                continue;\n            }\n            if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {\n                need[j] = true;\n                ns.push_back(p[j]);\n            } else {\n                need[j] = false;\n            }\n        }\n        cur = p[i];\n        sort(all(ns), comp);\n        for (int j = 0; j < sz(ns); j++) {\n            adds[j] = 0;\n            for (int k = 0; k < sz(ns); k++) {\n                if (j == k) {\n                    continue;\n                }\n                if (vec(ns[k] - p[i], ns[j] - p[i]) == 0 && (ns[k].x - cur.x) * (ns[k].x - cur.x) + (ns[k].y - cur.y) * (ns[k].y - cur.y) < (ns[j].x - cur.x) * (ns[j].x - cur.x) + (ns[j].y - cur.y) * (ns[j].y - cur.y)) {\n                    adds[j]++;\n                }\n            }\n            for (int k = j + 1; k < sz(ns); k++) {\n                goods[j][k] = false;\n                cnt[j][k] = 0;\n                dp[j][k] = 0;\n                if (good(cur, ns[j], ns[k])) {\n                    goods[j][k] = true;\n                    for (int g = j + 1; g < k; g++) {\n                        if (vec(ns[k] - cur, ns[g] - cur) != 0 && vec(ns[j] - cur, ns[g] - cur) != 0 && inside(cur, ns[j], ns[k], ns[g])) {\n                            cnt[j][k]++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (goods[j][k]) {\n                    dp[j][k] += st[cnt[j][k] + adds[j] + adds[k]];\n                    dp[j][k] %= Mod;\n                    ans += dp[j][k];\n                    ans %= Mod;\n                    for (int nxt = k + 1; nxt < sz(ns); nxt++) {\n                        if (vec(ns[nxt] - ns[j], ns[k] - ns[j]) < 0 && goods[k][nxt] && vec(ns[nxt] - cur, ns[k] - cur) != 0) {\n                            dp[k][nxt] += (1LL * dp[j][k] * st[cnt[k][nxt] - adds[k] + adds[nxt]]) % Mod;\n                            dp[k][nxt] %= Mod;\n                        }\n                    }\n                }   \n            }\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF = 0x3c3c3c3c;\nconst ll INFL = 0x3c3c3c3c3c3c3c3c;\nconst int MOD = 998244353;\n\nstruct p{\n\tint x, y;\n\tbool operator <(p &o){\n\t\tif(x != o.x) return x < o.x;\n\t\treturn y < o.y;\n\t}\n};\n\np point[209];\nint OLCount[209][209];\nint power[209];\n\nint isLine(int x1, int y1, int x2, int y2, int x3, int y3){\n\treturn x1 * y2 + x2 * y3 + x3 * y1 - x2 * y1 - x3 * y2 - x1 * y3;\n}\n\nbool isPossible(vector<p> &v){\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = i + 1; j < 4; j++){\n\t\t\tfor(int k = j + 1; k < 4; k++){\n\t\t\t\tbool f = isLine(v[i].x, v[i].y, v[j].x, v[j].y, v[k].x, v[k].y);\n\t\t\t\tif(!f) return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint N;\n\tcin >> N;\n\tpower[0] = 1;\n\tfor(int i = 1; i < 209; i++){\n\t\tpower[i] = (power[i - 1] * 2) % MOD;\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpoint[i] = {x, y};\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tvector<p> v;\n\t\tv.push_back(point[i]);\n\t\tfor(int j = i + 1; j < N; j++){\n\t\t\tv.push_back(point[j]);\n\t\t\tint lx = min(point[i].x, point[j].y), rx = max(point[i].x, point[j].y);\n\t\t\tfor(int k = j + 1; k < N; k++){\n\t\t\t\tif(point[k].x < lx) continue;\n\t\t\t\tif(point[k].x > rx) continue;\n\t\t\t\tv.push_back(point[k]);\n\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\tbool f = isLine(v[0].x, v[0].y, v[1].x, v[1].y, v[2].x, v[2].y);\n\t\t\t\tif(!f){\n\t\t\t\t\tOLCount[i][j]++;\n\t\t\t\t\tOLCount[j][i]++;\n\t\t\t\t}\n\t\t\t\tv.pop_back();\n\t\t\t}\n\t\t\tv.pop_back();\n\t\t}\n\t\tv.pop_back();\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tvector<p> v;\n\t\tv.push_back(point[i]);\n\t\tfor(int j = i + 1; j < N; j++){\n\t\t\tv.push_back(point[j]);\n\t\t\tfor(int k = j + 1; k < N; k++){\n\t\t\t\tv.push_back(point[k]);\n\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\tbool f = isLine(v[0].x, v[0].y, v[1].x, v[1].y, v[2].x, v[2].y);\n\t\t\t\tv.pop_back();\n\t\t\t\tif(!f) continue;\n\t\t\t\tans += power[OLCount[i][j] + OLCount[j][k] + OLCount[k][i]];\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t\tv.pop_back();\n\t\t}\n\t\tv.pop_back();\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tvector<p> v;\n\t\tv.push_back(point[i]);\n\t\tfor(int j = i + 1; j < N; j++){\n\t\t\tv.push_back(point[j]);\n\t\t\tfor(int k = j + 1; k < N; k++){\n\t\t\t\tv.push_back(point[k]);\n\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\tbool f = isLine(v[0].x, v[0].y, v[1].x, v[1].y, v[2].x, v[2].y);\n\t\t\t\tv.pop_back();\n\t\t\t\tif(!f) continue;\n\t\t\t\tfor(int l = k + 1; l < N; l++){\n\t\t\t\t\tv.push_back(point[l]);\n\t\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\t\tif(!isPossible(v)){\n\t\t\t\t\t\tv.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans += power[OLCount[i][j] + OLCount[j][k] + OLCount[k][l] + OLCount[l][i]];\n\t\t\t\t\tans %= MOD;\n\t\t\t\t\tv.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\tv.pop_back();\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PII pair<int,int>\n#define fi first\n#define se second\n#define lowbit(x) ((x)&(-(x)))\n#define FOR(i,a,b) for (int i=(a);i<=(b);++i)\n#define ROF(i,b,a) for (int i=(b);i>=(a);--i)\ntypedef long long LL;\ninline int read(){\n\tint x=0,f=1; char ch=getchar();\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\twhile (ch>='0'&&ch<='9') { x=x*10+ch-'0'; ch=getchar(); }\n\treturn x*f;\n}\n\nconst int MAXN=300005,Mo=998244353;\nstruct list{\n\tint l,lt[MAXN],nt[MAXN*2],x[MAXN*2],y[MAXN*2];\n\tvoid clear(){ l=0; memset(lt,0,sizeof(lt)); }\n\tvoid addedge(int a,int b){ l++; nt[l]=lt[a]; lt[a]=l; x[l]=b; }\n}E;\nstruct P{\n\tint x,y;\n\tP(int xx=0,int yy=0):x(xx),y(yy){}\n\tP operator +(const P &E)const{ return P(x+E.x,y+E.y); }\n\tP operator -(const P &E)const{ return P(x-E.x,y-E.y); }\n\tint operator *(const P &E)const{ return x*E.y-E.x*y; }\n\tint operator ^(const P &E)const{ return x*E.x+y*E.y; }\n}A[MAXN],B[MAXN];\nint n,m,a[MAXN],b[MAXN];\nint power(int a,int b){\n\tint c=1; a%=Mo;\n\twhile (b) {\n\t\tif (b&1) c=1LL*c*a%Mo;\n\t\ta=1LL*a*a%Mo; b>>=1;\n\t}\n\treturn c;\n}\nint cmp(P i,P j){ return i*j<0; }\nint main(){\n\tn=read();\n\tFOR(i,1,n) a[i]=power(i,Mo-2);\n\tFOR(i,1,n) { A[i].x=read(); A[i].y=read(); }\n\tLL tmp,ans=power(2,n)-n-1;\n\tif (ans<0) ans+=Mo; else if (ans>=Mo) ans-=Mo;\n\t//cout<<ans<<endl;\n\tFOR(i,1,n) {\n\t\tFOR(j,1,i-1) B[j]=A[j]-A[i];\n\t\tFOR(j,i+1,n) B[j-1]=A[j]-A[i];\n\t\tFOR(j,1,n-1) if (B[j].x<0) B[j].x=-B[j].x,B[j].y=-B[j].y;\n\t\tsort(B+1,B+n,cmp);\n\t\t//cout<<i<<':';\n\t\tfor (int j=1,k,tot;j<n;j=k+1) {\n\t\t\tfor (k=j;k<n-1&&B[k+1]*B[j]==0;++k);\n\t\t\ttot=k-j+2;\n\t\t\ttmp=1LL*(power(2,tot)-tot-1)*a[tot]%Mo;\n\t\t\tif (tmp<0) tmp+=Mo; else if (tmp>=Mo) tmp-=Mo;\n\t\t\t//cout<<tmp<<',';\n\t\t\tans-=tmp;\n\t\t\tif (ans<0) ans+=Mo; else if (ans>=Mo) ans-=Mo;\n\t\t}\n\t\t//cout<<endl;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n/*\n4\n0 0\n0 1\n1 0\n1 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define mod 998244353\n\nlong long X[300], Y[300], P[300];\nint N;\n\nint main() {\n    // freopen(\"input.in\",\"r\",stdin);\n    // freopen(\"output.out\",\"w\",stdout);\n\n    cin>>N;\n    for(int i = 0;i < N;i++) cin>>X[i]>>Y[i];\n    P[0] = 1;\n    for(int i = 1;i <= N;i++) P[i] = (2*P[i-1]) % mod;\n\n    long long answer = (P[N]-1-N+mod) % mod;\n    // cout << answer << endl;\n\n    for(int i = 0;i < N;i++) {\n        for(int j = i+1;j < N;j++) {\n            int counter = 0;\n            for(int k = j+1;k < N;k++) {\n                if((Y[j]-Y[i])*(X[k]-X[i]) == (Y[k]-Y[i])*(X[j]-X[i])) {\n                    counter += 1;\n                }\n            }\n\n            answer = (answer - P[counter] + mod) % mod;\n        }\n    }\n\n    cout << answer << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\n#define REP(i,n) for(long long i = 0; i < (n); i++)\n#define FOR(i, m, n) for(long long i = (m);i < (n); ++i)\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n\nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433;\n\ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\nint main() {\n\tint N; cin >> N;\n\tvector<double> x(N),y(N);\n\tvector<vector<int>> c(N,vector<int>(N,0));\n\tfor(int i = 0; i < N; ++i) cin >> x[i] >> y[i];\n\n\tvector<ll> pow2(N+1,1);\n\tfor(int i = 1; i <= N; ++i) pow2[i] = (2*pow2[i-1]) % MOD2;\n\tdouble eps = 0.0001;\n\tll sum = N+1;\n\tfor(int i = 0; i < N; ++i) {\n\t\tfor(int j = i+1; j < N; ++j) {\n\t\t\tif(c[i][j] || c[j][i]) continue;\n\t\t\tvector<int> v;\n\t\t\tfor(int k = 0; k < N; ++k) \tif(abs((x[j]-x[i])*(y[k]-y[i]) - (x[k]-x[i])*(y[j]-y[i])) < eps) v.push_back(k);\n\t\t\tfor(auto l:v) for(auto r:v) c[l][r] = 1;\n\t\t\tll n = v.size();\n\t\t\t(sum += (pow2[n] - n - 1 + MOD2) % MOD2 ) %= MOD2;\n\t\t}\n\t}\n\tll ans = pow2[N] - sum + MOD2;\n\tans %= MOD2;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 205\n#define mod 998244353\nint x[maxn],y[maxn];\nint pow(int a,int n)\n{\n    if(n==0)return 1;\n    int res=pow(a,n/2);\n    res=(long long)(res*res)%mod;\n    if(n&1)res=(long long)(res*a)%mod;\n    return res;\n}\nvoid add(int &a,int b)\n{\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nmain()\n{\n    int n;scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n    int ans=pow(2,n);\n    add(ans,mod-1);\n    add(ans,mod-n);\n    add(ans,mod-n*(n-1)/2);\n    for(int i=0;i<n;i++)for(int j=i+1;j<n;j++)\n    {\n        int a=y[j]-y[i];\n        int b=x[i]-x[j];\n        int c=-a*x[i]-b*y[i];\n        int cnt=2;\n        for(int k=0;k<n;k++)\n        {\n            if (k==i || k==j)continue;\n            int z=a*x[k]+b*y[k]+c;\n            if(z!=0)continue;\n            if(k<j)break;\n            cnt++;\n        }\n        add(ans,mod-pow(2,cnt));\n        add(ans,1);\n        add(ans,cnt);\n        add(ans,cnt*(cnt-1)/2);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stdio.h>\nusing namespace std;\n#define ll long long\ntypedef pair<ll,ll> pi;\nint n;\npi arr[205];\nll mod = 998244353;\nll answer = 0;\nll factorial[205];\nll ifactorial[205];\nvector<ll> v;\nbool collinear[205][205];\n\nll power(ll a, ll b){\n\ta %= mod;\n\tif (b == 0) return 1;\n\tif (b == 1) return a;\n\tll half = power(a, b/2);\n\thalf*=half;\n\thalf%=mod;\n\tif (b % 2 == 1){\n\t\thalf *= a;\n\t\thalf %= mod;\n\t}\n\treturn half;\n}\n\nvoid init(){\n\tfactorial[0] = 1;\n\tfor (int i = 1; i < 205; i++){\n\t\tfactorial[i] = factorial[i - 1]*i;\n\t\tfactorial[i] %= mod;\n\t}\n\tfor (int i = 1; i < 205; i++){\n\t\tifactorial[i] = power(factorial[i], mod - 2);\n\t}\n\t\n}\n\nll choose(ll n, ll k){\n\tif (n == k) return (long long)1;\n\treturn (((factorial[n]*ifactorial[k])%mod)*ifactorial[n - k])%mod;\n}\n\nll adjust(ll x){\n\tx %= mod;\n\tif (x < 0){\n\t\tx += mod;\n\t}\n\treturn x;\n}\n\nint main(){\n\tinit();\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lld%lld\", &arr[i].first, &arr[i].second);\n\t}\n\tsort(arr, arr + n);\n\tll answer = 0;\n\tfor (int i = 3; i <= n; i++){\n\t\tanswer += choose(n, i);\n\t\tanswer = adjust(answer);\n\t\t//cout << \"choose (\" << n << \", \" << i << \") = \" << choose(n, i) << endl;\n\t}\n\tanswer = adjust(answer);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = i + 1; j < n; j++){\n\t\t\tif (collinear[i][j]) continue;\n\t\t\tv.clear();\n\t\t\tv.push_back(i);\n\t\t\tv.push_back(j);\n\t\t\tfor (int k = j + 1; k < n; k++){\n\t\t\t\tif ((arr[i].second - arr[j].second)*(arr[i].first - arr[k].first) == (arr[i].second - arr[k].second)*(arr[i].first - arr[j].first)){\n\t\t\t\t\tv.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < (int)v.size(); k++){\n\t\t\t\tfor (int l = 0; l < (int)v.size(); l++){\n\t\t\t\t\tcollinear[v[k]][v[l]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 3; k <= (int)v.size(); k++){\n\t\t\t\tanswer -= choose((long long)v.size(), (long long)k);\n\t\t\t\tanswer = adjust(answer);\n\t\t\t}\n\t\t}\n\t}\n\tanswer = adjust(answer);\n\tprintf(\"%lld\\n\", answer);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/range/irange.hpp>\n\nusing namespace std;\nusing namespace boost;\n\nconstexpr auto M = 998244353L;\n\nint64_t pow2(int64_t p) {\n  if (p == 0) {\n    return 1;\n  }\n  auto pp = pow2(p / 2);\n  return ((p%2)?2:1) * pp * pp % M;\n}\n\nmain() {\n  int64_t n;\n  cin >> n;\n  \n  vector<int64_t> x(n), y(n);\n  for (auto i : irange(0L, n)) {\n    cin >> x[i] >> y[i];\n  }\n  \n  vector<vector<unordered_set<int64_t>>> lines(n, vector<unordered_set<int64_t>>(n));\n  for (auto i : irange(0L, n)) {\n    for (auto j : irange(i + 1, n)) {\n      lines[i][j].insert(i);\n      lines[i][j].insert(j);\n      // y = (y2 - y1) / (x2 - x1) * (x - x1) + y1\n      // (y - y1) * (x2 - x1) = (y2 - y1) * (x - x1)\n      for (auto k : irange(0L, n)) {\n        if (k == i || k == j) continue;\n        if ((y[k] - y[i]) * (x[j] - x[i]) != (y[j] - y[i]) * (x[k] - x[i])) {\n          continue;\n        }\n        if (k < j) {\n          lines[i][j].clear();\n          break;\n        }\n        lines[i][j].insert(k);\n      }\n    }\n  }\n  \n  uint64_t ans = pow2(n);\n  ans += M - 1; // empty set\n  ans += n * (M - 1); // one size set\n  ans %= M;\n  // cerr << ans << endl;\n  for (auto i : irange(0L, n)) {\n    for (auto j : irange(0L, n)) {\n      if (lines[i][j].empty()) {\n        continue;\n      }\n      auto m = lines[i][j].size();\n      ans += (pow2(m) - 1 - m) * (M - 1);\n      ans %= M;\n      // cerr << i << \",\" << j << \" \" << m << \" \" << pow2(m) - 1 - m << \" \" << ans << endl;\n    }\n  }\n  \n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 205;\nconst int mod = 1e9 + 7;\n\nstruct Point {\n\tint x; int y;\n} a[N];\n\nlong long cross(Point O, Point A, Point B) {\n\tA.x -= O.x; A.y -= O.y; B.x -= O.x; B.y -= O.y;\n\treturn 1LL * A.x * B.y - 1LL * A.y * B.x;\n}\n\nvoid add(int &x, int y) {\n\tx += y; while(x >= mod) x -= mod; while(x < 0) x += mod;\n}\n\nint n;\nint ans;\nint pow2[N];\nint cnt[10005];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d%d\", &a[i].x, &a[i].y);\n\t}\n\n\tpow2[0] = 1; for (int i = 1; i <= n; ++i) pow2[i] = 2LL * pow2[i - 1] % mod;\n\n\t// line y = a\n\tfor (int i = 1; i <= n; ++i) cnt[a[i].y]++;\n\tfor (int y = 0; y < 1e4; ++y) add(ans, pow2[cnt[y]] - 1);\n\n\t// line: ax + b = y with a != 0\n\tfor (int pivot = 1; pivot <= n; ++pivot) {\n\t\tvector<Point> v;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (a[i].y > a[pivot].y) v.push_back(a[i]);\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](Point p, Point q) {\n\t\t\treturn cross(a[pivot], p, q) > 0;\n\t\t});\n\n\t\tfor (int i = 0; i < v.size(); ) {\n\t\t\tint j = i + 1;\n\t\t\twhile(j < v.size() && cross(a[pivot], v[i], v[j]) == 0) ++j;\n\n\t\t\tadd(ans, pow2[j - i] - 1);\n\t\t\ti = j;\n\t\t}\n\t}\n\n\tans = pow2[n] - 1 - ans;\n\twhile (ans < 0) ans += mod;\n\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 998244353;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nll A[MAX_N], B[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) cin >> A[i] >> B[i];\n\tll ans = 1;\n\trep(i, 0, N) MUL(ans, 2);\n\tADD(ans, mod - N);\n\tADD(ans, mod - 1);\n\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tll tmp = 1;\n\t\t\trep(k, j + 1, N) {\n\t\t\t\t// B[k] = (B[j] - B[i]) / (A[j] - A[i]) (A[k] - A[i]) + B[j];\n\t\t\t\tif((B[k] - B[j]) * (A[j] - A[i]) == (B[j] - B[i]) * (A[k] - A[i])) {\n\t\t\t\t\tMUL(tmp, 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tADD(ans, mod - tmp);\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//I hate signal 11!!\n#include<bits/stdc++.h>\n#define MAX_N 215\n#define MOD 998244353LL\n#define LL long long\n#define ccw(x,y,z,p,q,r) (((x)-(z))*(q)+((y)-(x))*(r)+((z)-(y))*(p))\nusing namespace std;\nstruct node{\n\tLL x,y;\n}arr[MAX_N],b[MAX_N];\nLL n,m,I,ans,t[MAX_N][MAX_N],cost[MAX_N],temp,z;\n// I need angle sort stl...\n//inline LL ccw(node x,node y,node z){return (x.x-z.x)*y.y+(y.x-x.x)*z.y+(z.x-y.x)*x.y;}\nbool angle_sort(node x,node y){\n\tz=ccw(x.x,arr[I].x,y.x,x.y,arr[I].y,y.y);\n\tif(z<0)\treturn true;\n\tif(z>0)\treturn false;\n\treturn true;\n}\nvoid make_b(){\n\tLL i;\n\tm=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(arr[I].y>arr[i].y || (arr[I].y==arr[i].y && arr[I].x>=arr[i].x))\tcontinue;\n\t\tb[++m]=arr[i];\n\t}\n\tsort(b+1,b+m+1,angle_sort);\n}\nint main(){\n\tLL i=1,prev,curr,next,cnt,scnt;\n\tcost[0]=1;\n\twhile(i<=203){cost[i]=(cost[i-1]*2)%MOD;i++;}\n\tscanf(\"%lld\",&n);\n\tfor(i=1;i<=n;i++)\tscanf(\"%lld %lld\",&arr[i].x,&arr[i].y);\n\t//t[curr][next] : dp table, start i, curr and next node!!\n\tfor(I=1;I<=n;I++){\n\t\tmake_b();\n\t\t//first point : I(arr[I])...\n\t\tfor(curr=1;curr<=m;curr++){\n\t\t\tfor(next=curr+1;next<=m;next++){\n\t\t\t\tt[curr][next]=0;\n\t\t\t\tif(ccw(arr[I].x,b[curr].x,b[next].x,arr[I].y,b[curr].y,b[next].y)==0)\tcontinue;\n\t\t\t\tcnt=scnt=0;\n\t\t\t\tfor(i=curr+1;i<next;i++){\n\t\t\t\t\tif(ccw(b[curr].x,b[next].x,b[i].x,b[curr].y,b[next].y,b[i].y)>=0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(ccw(arr[I].x,b[i].x,b[curr].x,arr[I].y,b[i].y,b[curr].y)==0)\tscnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(i=curr-1;i>0;i--){\n\t\t\t\t\tif(ccw(arr[I].x,b[curr].x,b[i].x,arr[I].y,b[curr].y,b[i].y)!=0)\tbreak;\n\t\t\t\t\tif(ccw(b[curr].x,b[next].x,b[i].x,b[curr].y,b[next].y,b[i].y)>=0){cnt++;scnt++;}\n\t\t\t\t}\n\t\t\t\tfor(i=next+1;i<=m;i++){\n\t\t\t\t\tif(ccw(arr[I].x,b[next].x,b[i].x,arr[I].y,b[next].y,b[i].y)!=0)\tbreak;\n\t\t\t\t\tif(ccw(b[curr].x,b[next].x,b[i].x,b[curr].y,b[next].y,b[i].y)>=0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tfor(prev=curr-1;prev>0;prev--){\n\t\t\t\t\tif(ccw(b[prev].x,b[curr].x,b[next].x,b[prev].y,b[curr].y,b[next].y)>0)\tt[curr][next]=(t[curr][next]+t[prev][curr])%MOD;\n\t\t\t\t}\n\t\t\t\tt[curr][next]=((t[curr][next]*cost[cnt-scnt])%MOD+cost[cnt])%MOD;\n\t\t\t\tans=(t[curr][next]+ans)%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\n\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\n\nint X[210];\nint Y[210];\nPt p[210];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i=0;i<a;i++)p[i]=Pt(X[i],Y[i]);\n\tlong long ret=(pw(2,a)-1-a+mod)%mod;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=i+1;j<a;j++){\n\t\t\tint has=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(k==j||k==i){has++;}\n\t\t\t\telse if(ABS(iSP(p[i],p[j],p[k]))==2||ABS(iSP(p[i],p[k],p[j]))==2){has++;}\n\t\t\t}\n\t\t\tlong long tmp=pw(2,has)-1-has;\n\t//\t\tprintf(\"%d\\n\",has);\n\t\t\tret=(ret+mod-tmp*pw(has*(has-1)/2,mod-2)%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int uli;\nconst int mx=222;\nconst uli mod=998244353;\nuli pwr[mx];\nint x[mx],y[mx];\nint gcd(int a,int b){ \n  if(b==0)return a;\n  return gcd(b,a%b);\n}\nbool inside(int k,int i,int j){\n  if(k==i || k==j)return false;\n  int a=x[k]-x[i],b=y[k]-y[i];\n  int g=gcd(abs(a),abs(b));\n  a/=g,b/=g;\n  int c=x[j]-x[k],d=y[j]-y[k];\n  g=gcd(abs(c),abs(d));\n  c/=g,d/=g;\n  return a==c && b==d;\n}\nint main(){\n  pwr[0]=1;\n  for(int i=1;i<mx;i++)pwr[i]=pwr[i-1]*2ll%mod;\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=0;i<n;i++)\n    scanf(\"%d %d\",x+i,y+i);\n  uli ans=pwr[n];\n  for(int i=0;i<n;i++){ \n    for(int j=i+1;j<n;j++){\n      int cnt=0;\n      for(int k=0;k<n;k++)\n        if(inside(k,i,j))\n          cnt++;\n      ans=(ans-pwr[cnt]+mod)%mod;\n    }\n  }\n  ans=(ans-n-1+mod)%mod;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define X first\n#define Y second\n#define pii pair<ll,ll>\n#define x1 dlfjl\n#define x2 dkfj\n#define MOD 998244353\n#define y1 dskgj\n#define y2 dskfj\n#define N 310\ntypedef long long ll;\nusing namespace std;\nll n,i,j,k,x,y,z,m,q,w,h;\nll a[100500], b[100500], pre[1005000], C[205][205];\nmap<pair<pii,pii>,ll> f;\nll gcd(ll a, ll b)\n{\n    return (b==0?a:gcd(b,a%b));\n}\nll Abs(ll x)\n{\n    return (x>0?x:-x);\n}\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    for (i = 0; i <= 1000; i++)\n        pre[i*(i+1)/2] = i+1;\n    for (i = 0; i <= 200; i++)\n        C[i][0] = 1;\n    for (i = 1; i <= 200; i++)\n        for (j = i; j <= 200; j++)\n            C[j][i] = (C[j-1][i-1] + C[j-1][i])%MOD;\n    ll ans = 1;\n    cin >> n;\n    if (n < 3)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    for (i = 1; i <= n; i++)\n        ans = (ans*2)%MOD;\n    ans -= n+1;\n    ans -= n*(n-1)/2;\n    ans += MOD;\n    ans %= MOD;\n    for (i = 0; i < n; i++)\n        cin >> a[i] >> b[i];\n    for (i = 0; i < n; i++)\n        for (j = i+1; j < n; j++)\n        {\n            if (a[i] == a[j])\n            {\n                f[mp(mp(0,a[i]),mp(MOD,MOD))]++;\n                continue;\n            }\n            if (b[i] == b[j])\n            {\n                f[mp(mp(b[i],0),mp(MOD,MOD))]++;\n                continue;\n            }\n            int p = a[i]-a[j];\n            int q = b[i]-b[j];\n            int g = gcd(Abs(p), Abs(q));\n            p /= g;\n            q /= g;\n            if ( p < 0)\n                p = -p, q = -q;\n            int x1 = a[i], y1 = b[i], x2 = a[j], y2 = b[j];\n            int xx = y1*(x2-x1)-x1*(y2-y1);\n            int yy = x2-x1;\n            int gg = gcd(Abs(xx), Abs(yy));\n            xx /= gg;\n            yy /= gg;\n            if ( xx < 0)\n                xx = -xx, yy = -yy;\n            f[mp(mp(p,q),mp(xx,yy))]++;\n        }\n    for (auto itr = f.begin(); itr != f.end(); itr++)\n    {\n        int val = (*itr).Y;\n        val = pre[val];\n        for (j = 3; j <= val; j++)\n        {\n            ans -= C[val][j];\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include<bitset>\n#include <utility>\nusing namespace std;\n#define rank rankk\n#define mp make_pair\n#define pb push_back\n#define xo(a,b) ((b)&1?(a):0)\n//#define LL ll\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef pair<ll,int> pli;\nconst int INF=0x3f3f3f3f;\nconst ll INFF=0x3f3f3f3f3f3f3f3fll;\nconst int MAX=1e5+5;\nconst int MAX_N=MAX;\nconst ll MOD=998244353;\nconst long double pi=acos(-1.0);\n//const double eps=0.00000001;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntemplate<typename T>inline T abs(T a) {return a>0?a:-a;}\ntemplate<class T> inline\nvoid read(T& num) {\n    bool start=false,neg=false;\n    char c;\n    num=0;\n    while((c=getchar())!=EOF) {\n        if(c=='-') start=neg=true;\n        else if(c>='0' && c<='9') {\n            start=true;\n            num=num*10+c-'0';\n        } else if(start) break;\n    }\n    if(neg) num=-num;\n}\ninline ll powMM(ll a,ll b,ll M){\n    ll ret=1;\n    a%=M;\n//    b%=M;\n    while (b){\n        if (b&1) ret=ret*a%M;\n        b>>=1;\n        a=a*a%M;\n    }\n    return ret;\n}\nvoid open()\n{\n    freopen(\"1009.in\",\"r\",stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n}\nint n,cnt;\nll mi[205];\nint x[205],y[205];\nll an;\ninline bool check(int i,int j,int k)\n{\n    return ((x[i]-x[j])*(y[k]-y[j])-(x[k]-x[j])*(y[i]-y[j]))==0;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    mi[0]=1;for(int i=1;i<=n;i++)mi[i]=2*mi[i-1]%MOD;\n    for(int i=1;i<=n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n    an=(mi[n]-1-n+MOD)%MOD;\n    for(int i=1;i<=n-1;i++)\n        for(int j=i+1;j<=n;j++,an=(an-mi[cnt]+MOD)%MOD,cnt=0)\n            for(int k=j+1;k<=n;k++)\n                if(check(i,j,k))++cnt;\n    printf(\"%lld\\n\",an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n\nusing namespace std;\n\nconst int Mod = 998244353;\n\nconst int N = 310;\n\nstruct Point{\n\tint x, y;\n}P[N];\n\nint n, Pow[N];\ndouble s[N];\n\nint main(){\n\tscanf(\"%d\", &n);\n\tPow[0] = 1;\n\tFor(i, 1, n) scanf(\"%d%d\", &P[i].x, &P[i].y), Pow[i] = Pow[i - 1] * 2 % Mod;\n\tint ans = Pow[n] - n;\n\tFor(i, 1, n){\n\t\tint c = 0;\n\t\tFor(j, i + 1, n) s[++c] = P[i].x == P[j].x ? 1e10 : double(P[j].y - P[i].y) / double(P[j].x - P[i].x);\n\t\tsort(s + 1, s + c + 1);\n\t\tFor(j, 1, c){\n\t\t\tint r = j;\n\t\t\twhile(r < c && fabs(s[r + 1] - s[j]) < 1e-10) ++r;\n\t\t\tans = (Mod + ans - Pow[r - j + 1] + 1) % Mod;\n\t\t\tj = r;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (ans + Mod - 1) % Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define up(i,j,n)\t\tfor (int i = j; i <= n; i++)\n#define down(i,j,n)\tfor (int i = j; i >= n; i--)\n#define cmax(a,b)\t\ta = max (a, b)\n#define cmin(a,b)\t\ta = min (a, b)\n#define cadd(a,b)\t\ta = add (a, b)\n#define cpop(a,b)\t\ta = pop (a, b)\n#define cmul(a,b)\t\ta = mul (a, b)\n#define pii\t\t\tpair<int, int>\n#define fi\t\t\tfirst\n#define se\t\t\tsecond\n\nconst int MAXN = 205;\nconst int oo = 0x3f3f3f3f;\nconst int mod = 998244353;\n\npii operator + (const pii &a, const pii &b) {return make_pair(a.fi + b.fi, a.se + b.se);}\npii operator - (const pii &a, const pii &b) {return make_pair(a.fi - b.fi, a.se - b.se);}\nint operator ^ (const pii &a, const pii &b) {return a.fi * b.se - a.se * b.fi;}\n\ninline int add(int a, int b){a += b; return a >= mod ? a - mod : a;}\ninline int pop(int a, int b){a -= b; return a < 0 ? a + mod : a;}\ninline int mul(int a, int b){return 1LL * a * b % mod;}\n\nint N, f[MAXN], C[MAXN][MAXN], nodes[MAXN], top = 0, ans = 0;\npii a[MAXN];\nbool vaild[MAXN][MAXN];\n\nvoid calc(int x, int y) {\n\ttop = 0; nodes[++top] = x; nodes[++top] = y;\n\tup (i, 1, N) if (i != x && i != y) {\n\t\tif (((a[i] - a[x]) ^ (a[i] - a[y])) == 0) nodes[++top] = i;\t\n\t}\n\tcpop(ans, f[top]);\n\tup (i, 1, top) up (j, 1, top) vaild[nodes[i]][nodes[j]] = vaild[nodes[j]][nodes[i]] = 0;\n}\n\nint main(){\n\tscanf(\"%d\", &N);\n\tup (i, 1, N) scanf(\"%d%d\", &a[i].fi, &a[i].se);\n\tC[0][0] = 1;\n\tup (i, 1, N) {\n\t\tC[i][0] = 1;\n\t\tup (j, 1, i) C[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);\n\t} \n\tup (i, 3, N) up (j, 3, i) cadd(f[i], C[i][j]);\n\tup (i, 1, N) up (j, i + 1, N) vaild[i][j] = 1;\n\tans = f[N];\n\tup (i, 1, N) up (j, i + 1, N) if (vaild[i][j])\n\t\tcalc(i, j);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=998244353;\n\nint n,x[222],y[222],pw[222],all[222];\nint main()\n{\n\tpw[0]=1;for(int i=1;i<222;i++)pw[i]=pw[i-1]*2%mod;\n\tget1(n);\n\tfor(int i=1;i<=n;i++)get2(x[i],y[i]);\n\tint ans=(pw[n]+mod-1)%mod;\n\tans=(ans+mod-n)%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int k=1;k<=n;k++)if((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))cnt++;\n\t\t\tall[cnt]++;\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tall[i]=all[i]*2/i/(i-1);\n//\t\tprintf(\"i = %d %d\\n\",i,all[i]);\n\t\tans=(ans+mod-1ll*all[i]*(pw[i]+mod-i-1))%mod;\n\t}\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\nstruct point\n{\n    int x,y;\n};\ninline bool sameline(point a,point b,point c)\n{\n    if(a.x==b.x&&b.x==c.x)\n        return true;\n    if((a.x-b.x)*(b.y-c.y)==(b.x-c.x)*(a.y-b.y))\n        return true;\n    return false;\n}\nint n;\npoint a[205];\nlong long ans=1;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n        ans=(ans*2)%MOD;\n    ans-=n+1;\n    ans%=MOD;\n    while(ans<0)\n        ans+=MOD;\n    for(int i=0;i<n;i++)\n        scanf(\"%d %d\",&a[i].x,&a[i].y);\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            ans=(ans-1)%MOD;\n            while(ans<0)\n                ans+=MOD;\n            for(int k=j+1;k<n;k++){\n                if(sameline(a[i],a[j],a[k])){\n                    ans=(ans-1)%MOD;\n                    while(ans<0)\n                        ans+=MOD;\n                }\n            }\n        }\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\nconst int MOD = 998244353;\nconst int INF = INT_MAX / 2;\nstruct edge { int v, w; };\n#define double long double\n\ndouble d(int x1, int y1, int x2, int y2) {\n\tdouble dx = x1 - x2, dy = y1 - y2;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\trep(i, N) cin >> x[i] >> y[i];\n\tint ans = 1;\n\trep(t, N) ans = ans * 2 % MOD;\n\trep(i, N) rep(j, i) {\n\t\tint n = 0;\n\t\trep(k, N) if (k != i && k != j) {\n\t\t\tdouble d1 = d(x[k], y[k], x[i], y[i]);\n\t\t\tdouble d2 = d(x[k], y[k], x[j], y[j]);\n\t\t\tdouble d3 = d(x[i], y[i], x[j], y[j]);\n\t\t\tif (abs(d1 + d2 - d3) < 1e-12) n++;\n\t\t}\n\t\tint x = 1;\n\t\trep(t, n) x = x * 2 % MOD;\n\t\tans = (ans - x) % MOD;\n\t}\n\tans = (ans - N - 1) % MOD;\n\tcout << (ans + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n,x[205],y[205],mod=998244353,ans,two[205]={1};\n\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) two[i]=two[i-1]*2%mod;\n\tans=(two[n]-1-n-(n-1)*n/2+mod)%mod;\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",x+i,y+i);\n\tfor(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++){\n\t\tint tot=0;\n\t\tfor(int k=j+1;k<=n;k++) if((y[i]-y[j])*(x[j]-x[k])==(x[i]-x[j])*(y[j]-y[k])) tot++;\n\t\tans=(ans-two[tot]+mod+1)%mod;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-12;\ntypedef complex<double> P;\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<L>se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\t//if(se.find({i,j})!=se.end())continue;\n\t\tL l(v[i],v[j]);\n\t\tvector<int>x={i,j};\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectSP(l,v[k]))x.push_back(k);\n\t\tr=(r-pow_binary_mod(2,x.size()-2,M))%M;\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\t//se.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define mod 998244353ll\n#define P pair<int,int>\nusing namespace std;\n\nP a[200];\nsigned main() {\n\tint ans = 1;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = ans * 2 % mod;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t}\n\tans -= n + 1;\n\tans %= mod;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tvector<int>V;\n\t\t\tif (a[i].first == a[j].first) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].first == a[i].first) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (a[i].second == a[j].second) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].second == a[i].second) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble x = double(a[j].second - a[i].second) / (a[j].first - a[i].first);\n\t\t\t\tdouble y = double(a[i].second) - a[i].first*x;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (abs(a[i].first*x + y - a[i].second) <= 1e-5) {\n\t\t\t\t\t\tV.push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(V.begin(), V.end());\n\t\t\tif (V.size()>=2&&V[0] == i&&V[1]==j) {\n\t\t\t\tint k = 1;\n\t\t\t\tfor (int j : V) {\n\t\t\t\t\tk = k * 2 % mod;\n\t\t\t\t}\n\t\t\t\tk -= V.size(); k--;\n\t\t\t\tans -= k;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tans += mod * 5;\n\tans %= mod;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst long long MOD = 998244353;\nconst long long MAXN = 300;\npair<long long,long long> arr[MAXN];\nlong long pw[MAXN];\nint main(){\n    long long n;\n    cin>>n;\n    pw[0] = 1;\n    for(long long i=1;i<=n;i++){\n        pw[i] = pw[i-1]*2;\n        pw[i]%=MOD;\n        cin>>arr[i].first>>arr[i].second;\n    }\n    long long ans = (pw[n]-n-1+MOD)%MOD;\n    \n    for(long long i=1;i<=n;i++){\n        for(long long j=i+1;j<=n;j++){\n            long long cnt = 0;\n            for(long long k=j+1;k<=n;k++){\n                if((arr[k].second-arr[i].second)*(arr[j].first-arr[i].first) == (arr[j].second-arr[i].second)*(arr[k].first-arr[i].first)){\n                    cnt++;\n                }\n            }\n            ans-=(pw[cnt]-MOD);\n            ans%=MOD;\n        }\n    }\n    cout<<ans<<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 205\nusing namespace std;\nconst int mo=998244353;\nint n,m,pw[N],ans,cnt;\nstruct dot{\n\tint x,y;\n\tdot(int _x=0,int _y=0){ x=_x,y=_y;}\n}a[N];\ndot operator +(const dot &p,const dot &q){ return dot(p.x+q.x,p.y+q.y);}\ndot operator -(const dot &p,const dot &q){ return dot(p.x-q.x,p.y-q.y);}\nint C(int n,int m){ if(m==0) return 1; if(m==1) return n; return n*(n-1)/2;}\nint cj(dot p,dot q){ return p.x*q.y-p.y*q.x;}\nvoid inc(int &x,int y){ x=x+y>=mo ? x+y-mo : x+y;}\nvoid dec(int &x,int y){ x=x-y<0 ? x-y+mo : x-y;}\nint main()\n{\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor(i=1;i<=n;i++) pw[i]=pw[i-1]*2%mo;\n\tans=pw[n];\n\tdec(ans,C(n,2));\n\tdec(ans,C(n,1));\n\tdec(ans,C(n,0));\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d %d\",&a[i].x,&a[i].y);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tfor(k=1;k<=j;k++)\n\t\t\t\tif(k!=i&&k!=j&&cj(a[k]-a[i],a[j]-a[i])==0) break;\n\t\t\tif(k<j) continue;\n\t\t\tcnt=2;\n\t\t\tfor(k=j+1;k<=n;k++)\n\t\t\t\tif(cj(a[k]-a[i],a[j]-a[i])==0) cnt++;\n\t\t\tdec(ans,pw[cnt]);\n\t\t\tinc(ans,C(cnt,0));\n\t\t\tinc(ans,C(cnt,1));\n\t\t\tinc(ans,C(cnt,2));\n\t\t  }\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef struct pair<int,int> P;\ntypedef struct pair<int,P> P2;\n\nll n;\n\nconst int INF=1000000007;\nint main() {\n\tcin>>n;\n\tll x[201]={};\n\tll y[201]={};\n\tll t=0;\n\tll ss[201]={};\n\tfor(ll i=3;i<=n;++i){\n\t\tll t2=1;\n\t\tfor(ll j=1;j<=i;++j)t2=((t2*(n-i+j))/j)%998244353;\n\t\tt+=t2;\n\t\tt%=998244353;\n\t}\n//\tcout<<t<<endl;\n\tfor(int i=1;i<n+1;++i)cin>>x[i]>>y[i];\n\n\tfor(int i=1;i<n+1;++i){\n\t\tfor(int j=i+1;j<n+1;++j){\n\t\t\tll s=0;\n\t\t\tfor(int k=1;k<n+1;++k){\n\t\t\t\tif((x[i]-x[j])*(y[i]-y[k])-(x[i]-x[k]*(y[i]-y[j]))==0)s++;\n\t\t\t}\n\t\t\tss[s]++;\n\t\t}\n\t}\n\tfor(int k=3;k<=n;++k){\n\t\tt+=998244353;\n\t\tll t2=(ss[k]*6)/(k*(k-1)*(k-2));\n\t\tll t4=0;\n\t\tfor(ll i=3;i<=k;++i){\n\t\t\tll t3=1;\n\t\t\tfor(ll j=1;j<=i;++j)t3=((t3*(k-i+j))/j)%998244353;\n\t\t\tt4+=t3;\n\t\t\tt4%=998244353;\n\t\t}\n\t\tt-=(t2*t4);\n\t\tt%=998244353;\n//\t\t\tcout<<t2<<\" \"<<t4<<endl;\n\t}\n\n\tcout<<t<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 200 + 10;\nconst int Mod = 998244353;\nint N;\nint stk[MAXN], top;\nbool vis[MAXN][MAXN];\nint fc[MAXN];\nint ans;\n#define x first\n#define y second\npair<int, int> A[MAXN];\n\ninline bool check(int i, int j, int k) {\n\treturn (A[i].y - A[j].y) * (A[i].x - A[k].x) == (A[i].y - A[k].y) * (A[i].x - A[j].x);\n}\n\nint main() {\n\tregister int i, j, k;\n\tscanf(\"%d\", &N);\n\tfor(i = 1; i <= N; ++i)\n\t\tscanf(\"%d%d\", &A[i].x, &A[i].y);\n\tfor(*fc = i = 1; i <= N; ++i)\n\t\tfc[i] = 1ll * fc[i - 1] * 2 % Mod;\n\tans = fc[N] - N - 1;\n\tfor(i = 1; i <= N; ++i)\n\t\tfor(j = i + 1; j <= N; ++j) {\n\t\t\tint res = 0;\n\t\t\tfor(k = j + 1; k <= N; ++k)\n\t\t\t\tres += check(i, j, k);\n\t\t\tans = (ans - fc[res] + Mod) % Mod;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2000;\nconst int mod=998244353;\nint x[maxn],y[maxn];\nint pow(int a,int b)\n{\n    int ret;\n    if (b==0) return 1;\n    ret=pow(a,b/2);\n    ret=ret*ret%mod;\n    if (b%2) ret=ret*2%mod;\n    return ret;\n}\nint main()\n{\n    //freopen(\"text.in\",\"r\",stdin);\n    int i,ans,tmp,j,k,n;\n    scanf(\"%d\",&n);\n    for (i=1;i<=n;i++) {\n        scanf(\"%d%d\",&x[i],&y[i]);\n    }\n    ans=((pow(2,n)-n-1)%mod+mod)%mod;\n    ans=((ans-(n-1)*n/2)%mod+mod)%mod;\n    for (i=1;i<=n;i++) {\n        for (j=i+1;j<=n;j++) {\n            tmp=0;\n            for (k=j+1;k<=n;k++) {\n                if ((y[k]-y[i])*(x[j]-x[i])==(x[k]-x[i])*(y[j]-y[i])) tmp++;\n            }\n            ans=((ans-pow(2,tmp)+1)%mod+mod)%mod;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ld = long double;\nconst int maxn = 303, mod = 119<<23|1;\nint n, pw[maxn];\nvector<array<int, 2>> v;\nbool onl(array<int, 2> a, array<int, 2> b, array<int, 2> c) {\n\tif(a[1] == b[1] || b[1] == c[1]) return a[1] == b[1] && b[1] == c[1];\n\tld r1 = ld(a[0]-b[0])/ld(a[1]-b[1]);\n\tld r2 = ld(c[0]-b[0])/ld(c[1]-b[1]);\n\tld r3 = ld(a[0]-c[0])/ld(a[1]-c[1]);\n\treturn fabs(r1-r2) < 1e-8 && fabs(r3-r2) < 1e-8;\n}\nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tpw[0] = 1;\n\tfor(int i = 1; i < maxn; i++) pw[i] = (pw[i-1]+pw[i-1])%mod;\n\tcin >> n;\n\tv.resize(n);\n\tfor(auto &i : v) cin >> i[0] >> i[1];\n\tsort(all(v));\n\tint ans = pw[n];\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tint c = 0;\n\t\t\tarray<int, 2> mn = v[j];\n\t\t\tarray<int, 2> mx = v[i];\n\t\t\tfor(auto &[x, y] : v) if(v[i] == array<int, 2>{x, y} || v[j] == array<int, 2>{x, y} || onl(v[i], v[j], {x, y})) {\n\t\t\t\tc++;\n\t\t\t\tmn = min(mn, {x, y});\n\t\t\t\tmx = max(mx, {x, y});\n\t\t\t}\n\t\t\tif(v[j] != mn || v[i] != mx) continue;\n\t\t\t//cout << v[i][0] << \" \" << v[i][1] << \" | \" << v[j][0] << \" \" << v[j][1] << \" | \" << pw[c] - c - 1 << endl;\n\t\t\tans = (mod + ans - (pw[c] - c - 1))%mod;\t\n\t\t}\n\tans = (mod + ans - n - 1)%mod;\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<functional>\n#include<vector>\n#include<map>\n#include<string>\n#include<set>\n#include<unordered_set>\n#include<stack>\n#define int long long\n#define mod 998244353\n#define P pair<int,int>\nusing namespace std;\n\nP a[200];\nsigned main() {\n\tint ans = 1;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = ans * 2 % mod;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t}\n\tans -= n + 1;\n\tans %= mod;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tvector<int>V;\n\t\t\tif (a[i].first == a[j].first) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].first == a[i].first) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (a[i].second == a[j].second) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].second == a[i].second) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble x = double(a[j].second - a[i].second) / (a[j].first - a[i].first);\n\t\t\t\tdouble y = double(a[i].second) - a[i].first*x;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (abs(a[i].first*x + y - a[i].second) <= 1e-10) {\n\t\t\t\t\t\tV.push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(V.begin(), V.end());\n\t\t\tif (V.size()>=2&&V[0] == i&&V[1]==j) {\n\t\t\t\tint k = 1;\n\t\t\t\tfor (int j : V) {\n\t\t\t\t\tk = k * 2 % mod;\n\t\t\t\t}\n\t\t\t\tk -= V.size(); k--;\n\t\t\t\tans -= k;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tans += mod;\n\tans %= mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\n\nconst ll MOD = 998244353;\n\nll two[100000];\n\nll gcd(ll a, ll b) {\n  return b == 0 ? a : gcd(b, a%b);\n}\n\n// (x1, y1) と (x2, y2) を通る直線の方程式 ax + by + c == 0 の {a,b,c} を返す\nvector<ll> line(ll x1, ll y1, ll x2, ll y2) {\n  if (x1 == x2) { return {1, 0, -x1}; }\n  if (y1 == y2) { return {0, 1, -y1}; }\n  ll a = (y2 - y1);\n  ll b = (x1 - x2);\n  ll c = y1*x2 - x1*y2;\n  if (a < 0) { a *= -1; b *= -1; c *= -1; }\n  ll g = gcd(a, gcd(abs(b), abs(c)));\n  return {a/g, b/g, c/g};\n}\n\nint main2() {\n  int N = nextInt();\n  vector<ll> x(N), y(N);\n  REP(i, N) {\n    x[i] = nextInt();\n    y[i] = nextInt();\n  }\n\n  map< vector<ll>, set<int> > mp;\n\n  REP(i, N) {\n    REP(j, N) if (i < j) {\n      auto l = line(x[i], y[i], x[j], y[j]);\n      mp[l].insert(i);\n      mp[l].insert(j);\n    }\n  }\n\n  ll dis = 0;\n  for (auto it = mp.begin(); it != mp.end(); ++it) {\n    int m = (it->second).size();\n    if (m >= 3) {\n      dis += (two[m] - 1 - m - m*(m-1)/2);\n      dis = (dis % MOD + MOD) % MOD;\n    }\n  }\n\n  ll ans = two[N];\n  ans = ((ans - 1) % MOD + MOD) % MOD;\n  ans = ((ans - N) % MOD + MOD) % MOD;\n  ans = ((ans - N*(N-1)/2) % MOD + MOD) % MOD;\n  ans = ((ans - dis) % MOD + MOD) % MOD;\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n\n  two[0] = 1;\n  REP(i, 100000 - 1) two[i+1] = two[i] * 2 % MOD;\n\n#ifdef LOCAL\n  for (;!cin.eof();cin>>ws)\n#endif\n    main2();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo {(t*=10)+=ch-'0';ch=getchar();} while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst ll mod=998244353;\nconst int maxn=210;\nint n,x[maxn],y[maxn];\nll ans,mi[maxn];\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n);\n\tfor (int i=1;i<=n;i++)\n\t\tread(x[i]),read(y[i]);\n\tmi[0]=1;\n\tfor (int i=1;i<=n;i++) mi[i]=mi[i-1]*2%mod;\n\tans=mi[n]-n-1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<i;j++) {\n\t\tint cnt=0;\n\t\tfor (int k=1;k<j;k++)\n\t\t\tif ((x[i]-x[k])*(y[i]-y[j])==(x[i]-x[j])*(y[i]-y[k]))\n\t\t\t\tcnt++;\n\t\tans-=mi[cnt]; ans=(ans+mod)%mod;\n\t}\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 20000;\nconst int MOD = 998244353;\nint powi(int a, int b)\n{\n    int c = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % MOD)\n        if (b & 1) c = 1ll * c * a % MOD;\n    return c;\n}\nmap <int, int> M;\nint xi[N], yi[N];\nint ans;\nint main()\n{\n    cin >> n;\n    for (int i = 1; i <= n; ++ i)\n        cin >> xi[i] >> yi[i];\n    ans = powi(2, n) - n - 1;\n    for (int i = 1; i <= n; ++ i)\n    {\n        M.clear();\n        for (int j = i + 1; j <= n; ++ j)\n        {\n            int d = (1ll * (yi[j] - yi[i]) * powi(xi[j] - xi[i], MOD - 2) % MOD + MOD) % MOD;\n            if (xi[j] - xi[i] == 0) d = -1;\n            M[d] ++;\n        }\n        for (map <int, int> :: iterator it = M.begin(); it != M.end(); ++ it)\n            ans = (ans - (powi(2, it -> second) - 1)) % MOD;\n    }\n    ans = (ans + MOD) % MOD;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define pw(x) (1LL<<(x))\nstatic const int fast_io = [](){ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);return 0;}();\nstatic const int precise_doubles = [](){cout<<fixed<<setprecision(20);return 0;}();\ntypedef pair<int, int> PII;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n// find_by_order(k) - iterator to kth largest, order_of_key(k) - #things < k\ntypedef long double LD;\ntypedef long long LL;\n#define EVAL(x) x\n#define SPA(x) EVAL({cout << #x\" = \" << x << ' ';})\n#define NEWL EVAL({cout << '\\n';})\n#define SPAR(a, b) EVAL({cout<<#a\" = \";for(auto it=a;it!=b;)cout<<*(it++)<<\" \";cout<<'\\n';})\n#define SPAV(v) EVAL({cout<<#v\" = \";for(auto it=v.begin();it!=v.end();)cout<<*(it++)<<\" \";cout<<'\\n';})\nconst int INF = 0x3f3f3f3f; // 1.0e9\nconst LL LINF = 0x3f3f3f3f3f3f3f3fll; // 4.5e18\nconst LD eps = 1e-20;\nconst int mod = 998244353;\ninline int msum(int x, int y) {return (x+y<mod ? x+y : x+y-mod);}\ninline int mdif(int x, int y) {return (x>=y ? x-y : x-y+mod);}\ninline int mprod(int x, int y) { return (1ll*x*y) % mod; }\ninline int mpow(int x, LL y) {LL r=1;while(y){if(y&1)r=mprod(r,x);x=mprod(x,x);y>>=1;}return r;}\ninline int minv(int x) { return mpow(x, mod-2); }\n//------------------------------------------------------------------------------------------------------\n\nconst int N = 205;\nconst int MAX = 1e4 + 10;\n\nLL n, x[N], y[N];\n\nbool collinear(int i, int j, int k) {\n    return (y[j] - y[i]) * (x[k] - x[j]) == (y[k] - y[j]) * (x[j] - x[i]);\n}\n\nint main() {\n    cin >> n;\n    REP(i, n) cin >> x[i] >> y[i];\n    LL ans = mpow(2, n);\n    ans = mdif(ans, n+1);\n    REP(i, n) {\n        FOR(j, i+1, n) {\n            int this_set = 2;\n            bool already_done = false;\n            REP(k, n) {\n                if(k == i or k == j) continue;\n                if(collinear(i, j, k)) {\n                    if(k < j) already_done = true;\n                    this_set++;\n                }\n            }\n            if(already_done) continue;\n            // subsets of this_set of size at least 2\n            int cur = mpow(2, this_set);\n            cur = mdif(cur, 1 + this_set);\n            ans = mdif(ans, cur);\n        }\n    }\n    cout << ans << '\\n';\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) < norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[m][m] = {0};\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=210,mod=998244353;\nint inc(int x,int y){x+=y;return x>=mod?x-mod:x;}\nint dec(int x,int y){x-=y;return x<0?x+mod:x;}\nint mul(int x,int y){return (ll)x*y%mod;}\nint power(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=mul(x,x))\n\t\tif (y&1) ans=mul(ans,x);\n\treturn ans;\n}\nint calc(int n){\n\treturn dec(power(2,n),n*(n+1)/2+1);\n}\ntypedef pair<int,int> pii;\npii operator - (pii a,pii b){\n\treturn pii(a.first-b.first,a.second-b.second);\n}\nint operator * (pii a,pii b){\n\treturn a.first*b.second-a.second*b.first;\n}\nint n,q[N],size;pii p[N];\nbool use[N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d%d\",&p[i].first,&p[i].second);\n\tint ans=calc(n);\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<i;j++)\n\tif (!use[i][j]){\n\t\tpii vec=p[i]-p[j];size=0;\n\t\tfor (int k=1;k<=n;k++)\n\t\t\tif ((p[k]-p[j])*vec==0) q[++size]=k;\n\t\tans=dec(ans,calc(size));\n\t\tfor (int a=1;a<=size;a++)\n\t\tfor (int b=1;b<=size;b++)\n\t\t\tuse[q[a]][q[b]]=1;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nstruct Point\n{\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n\n    int x, y;\n};\n\nPoint operator - (const Point& a, const Point& b)\n{\n    return Point(a.x - b.x, a.y - b.y);\n}\n\nint det(const Point& a, const Point& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nint dot(const Point& a, const Point& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\nconst int N = 200;\nconst int MOD = 998244353;\n\nint pw[N + 1];\nPoint p[N];\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"C.in\", \"r\", stdin);\n#endif\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        for (int i = 0; i < n; ++ i) {\n            scanf(\"%d%d\", &p[i].x, &p[i].y);\n        }\n        pw[0] = 1;\n        for (int i = 1; i <= n; ++ i) {\n            pw[i] = pw[i - 1] * 2 % MOD;\n        }\n        int result = pw[n];\n        (result += MOD - 1 - n) %= MOD;\n        for (int i = 0; i < n; ++ i) {\n            for (int j = i + 1; j < n; ++ j) {\n                int cnt = 0;\n                for (int k = 0; k < n; ++ k) {\n                    cnt += det(p[k] - p[i], p[k] - p[j]) == 0 && dot(p[k] - p[i], p[k] - p[j]) < 0;\n                }\n                result += MOD - pw[cnt];\n                if (result >= MOD) {\n                    result -= MOD;\n                }\n            }\n        }\n        printf(\"%d\\n\", result);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 210\n#define LL long long\n\nconst LL P=998244353;\n\nLL getPow(LL x,LL y){\n\tLL res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%P;\n\t\tx=x*x%P;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\nstruct vec2{\n\tint x,y;\n\tvec2(int _x=0,int _y=0):x(_x),y(_y){}\n\tfriend vec2 operator-(vec2 x,vec2 y){ return vec2(x.x-y.x,x.y-y.y); }\n\tfriend int dot(vec2 x,vec2 y){ return x.x*y.x+x.y*y.y; }\n\tfriend int cross(vec2 x,vec2 y){ return x.x*y.y-x.y*y.x; }\n}p[MAXN];\n\nint n;\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tLL inv2=getPow(2,P-2);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&p[i].x,&p[i].y);\n\tLL ans=getPow(2,n);\n\tLL res=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i^j){\n\t\t\t\tvec2 d=p[j]-p[i];\n\t\t\t\tint cnt=2;\n\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\tif(cross(p[k]-p[j],d)==0 && k!=i && k!=j){\n\t\t\t\t\t\tif(dot(p[k]-p[j],d)<0){\n\t\t\t\t\t\t\tcnt=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\tLL temp=getPow(2,cnt)-cnt-1;\n\t\t\t\tres=(res+temp)%P;\n\t\t\t}\n\tres=res*inv2%P;\n\tres=(res+n+1)%P;\n\tans-=res;\n\tans=(ans%P+P)%P;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\nstruct pos\n{\n    long long x, y;\n};\n\npos arr[200];\nbool chk[200][200];\n\nconst long long mod = 998244353;\nlong long exp(long long a, long long x)\n{\n    if(x == 0)\n        return 1;\n    if(x%2)\n        return 1LL * exp(a, x-1) * a % mod;\n    long long t = exp(a, x/2);\n    return 1LL * t * t % mod;\n}\n\nlong long fac[201];\nlong long caf[201];\ninline long long ncr(long long n, long long r)\n{\n    return 1LL * fac[n] * caf[r] % mod * caf[n-r] % mod;\n}\n\nvector<long long> tmp;\n\nint main()\n{\n    //freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n\n    long long n, x, y, r, t, i, j, k;\n    scanf(\"%lld\", &n);\n    for(i = 0; i<n; i++)\n    {\n        scanf(\"%lld%lld\", &x, &y);\n        arr[i] = { x, y };\n    }\n\n    fac[0] = 1;\n    for(i = 1; i<=200; i++)\n        fac[i] = 1LL * fac[i-1] * i % mod;\n\n    for(i = 0; i<=200; i++)\n        caf[i] = exp(fac[i], mod-2);\n\n    r = 0;\n    for(i = 3; i<=n; i++)\n        r = (r + ncr(n, i)) % mod;\n\n    for(i = 0; i<n-1; i++)\n    {\n        for(j = i+1; j<n; j++)\n        {\n            if(chk[i][j] || chk[j][i])\n                continue;\n\n            tmp.clear();\n\n            tmp.push_back(i);\n            tmp.push_back(j);\n\n            t = 2;\n            for(k = 0; k<n; k++)\n            {\n                if(k == i || k == j)\n                    continue;\n\n                if(1LL * (arr[i].y - arr[j].y) * (arr[i].x - arr[k].x) != 1LL * (arr[i].x - arr[j].x) * (arr[i].y - arr[k].y))\n                    continue;\n\n                tmp.push_back(k);\n                t++;\n            }\n\n            for(int ii = 0; ii<t-1; ii++)\n                for(int jj = ii+1; jj<t; jj++)\n                    chk[ii][jj] = 1;\n\n            for(k = 3; k<=t; k++)\n                r = (r + (mod - ncr(t, k))) % mod;\n        }\n    }\n\n    printf(\"%lld\\n\", r);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <memory>\n#include <utility>\n#include <limits>\n#include \"limits.h\"\n \n#define rep(i, a, b) for (long long (i) = (a); i < (b); i++)\n#define all(i) i.begin(), i.end()\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n\nvoid debug_out(){std::cerr<<std::endl;}\n\ntemplate<typename Head,typename... Tail>\nvoid debug_out(Head h,Tail... t){\n  std::cerr<<\" \"<<h;\n  debug_out(t...);\n}\n\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nlong long pow_mod(long long a, long long b, long long mod=-1) {\n  if(b==0)return 1;\n\n  if ((a == 0)||(mod!=-1&&(a+mod)%mod==0)) {\n    return 0;\n  }\n \n  long long x = 1;\n \n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n \nconst long long MOD = 998244353;\n// const long long MOD = 1e9 + 7;\n\nusing ll = long long;\nusing P = std::pair<long long, long long>;\n\nint main() {\n  std::cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  ll n;\n  std::cin>>n;\n\n  std::vector<P> a(n);\n  rep(i,0,n)std::cin>>a[i].first>>a[i].second;\n\n  ll ans=(pow_mod(2,n,MOD)+MOD-1-n)%MOD;\n\n  using Line=std::pair<std::pair<ll,ll>,ll>;\n\n  std::map<Line,std::set<ll>> line;\n\n  for(ll i=0;i<n;i++){\n    std::set<ll> newline;\n    rep(j,0,i)newline.insert(j);\n    for(auto e:line){\n      if(e.first.first.first*a[i].first+e.first.first.second*a[i].second==e.first.second){\n        for(ll era:e.second){\n          newline.erase(era);\n        }\n        e.second.insert(i);\n      }\n    }\n    for(ll nl:newline){\n      if(a[nl].first==a[i].first){\n        line[{{1,0},a[i].first}].insert(nl);\n        line[{{1,0},a[i].first}].insert(i);\n      }else if(a[nl].second==a[i].second){\n        line[{{0,1},a[i].second}].insert(nl);\n        line[{{0,1},a[i].second}].insert(i);\n      }else{\n        ll x=a[nl].second-a[i].second,y=a[i].first-a[nl].first;\n        line[{{x,y},x*a[i].first+y*a[i].second}].insert(nl);\n        line[{{x,y},x*a[i].first+y*a[i].second}].insert(i);\n      }\n    }\n  }\n\n  for(auto e:line){\n    ll k=e.second.size();\n    ans=(ans+MOD-pow_mod(2,k,MOD))%MOD;\n    ans=(ans+k+1)%MOD;\n  }\n\n  std::cout<<ans<<\"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1005,INF=1<<30;\nconst long double eps=0.000000000003;\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    int N;cin>>N;\n    vector<long double> X(N),Y(N);\n    for(int i=0;i<N;i++){\n        cin>>X[i]>>Y[i];\n    }\n    \n    ll ans=rui(2,N);\n    ans+=mod-(N+1);\n    ans%=mod;\n    \n    for(int a=0;a<N;a++){\n        for(int b=a+1;b<N;b++){\n            ll cnt=0;\n            for(int k=0;k<N;k++){\n                if(k==a||k==b) continue;\n                long double i=atan2(X[b]-X[k],Y[b]-Y[k]),j=atan2(X[a]-X[k],Y[a]-Y[k]);\n                if(i>=0&&j<=0) swap(i,j);\n                if(i*j<0||(i==0&&j<0)||(i<0&&j==0)){\n                    if(abs(abs(i)-j)<=eps) cnt++;\n                }\n            }\n            ans+=mod-rui(2,cnt);\n            ans%=mod;\n        }\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ull  unsigned long long\n#define pb push_back\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 110000;\nint p[N], x[N], y[N];\nconst int mod = 998244353;\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    //freopen(\"input.txt\",  \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    int n;\n    cin >> n;\n    p[0] = 1;\n    for (int i = 1; i <= n; i++){\n        p[i] = (p[i - 1] + p[i - 1]) % mod;\n    }\n    for (int i = 1; i <= n; i++){\n        cin >> x[i] >> y[i];\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++){\n        for (int j = i + 1; j <= n; j++){\n            int k = 0;\n            for (int l = j + 1; l <= n; l++){\n                if ((x[l] - x[j]) * (y[j] - y[i]) == (x[j] - x[i]) * (y[l] - y[j])) k++;\n            }\n            ans = (ans + p[k]) % mod;\n        }\n    }\n    ans = (p[n] - ans + mod - n - 1 + mod) % mod;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace IO {\n\tconst int SIZE = 1 << 20;\n\tchar buf[SIZE + 10], *iS, *iT;\n\tinline char Getc() {\n\t\treturn iS == iT && (iT = (iS = buf) + fread(buf, 1, SIZE, stdin), iS == iT) ? EOF : *iS++;\n\t}\n\ttemplate <class TT>\n\tinline void Read(TT &x) {\n\t\tx = 0; register char cc = '\\0'; TT fff = 1;\n\t\tfor (; cc < '0' || cc > '9'; cc = Getc())\n\t\t\tif (cc == '-') fff = -1;\n\t\tfor (; cc >= '0' && cc <= '9'; cc = Getc())\n\t\t\tx = (x << 1) + (x << 3) + (cc & 15);\n\t\tx *= fff;\n\t}\n}\nusing IO::Read;\n\ntypedef long long LL;\nconst int N = 256, Mod = 998244353;\n\nstruct node {\n\tint x, y;\n\tnode operator - (const node &Other) const { return (node){x - Other.x, y - Other.y}; }\n} a[N];\n\ninline int XJ(node ptp, node ptq) { return ptp.x * ptq.y - ptp.y * ptq.x; }\n\nint n, fans, inv_n[N + 10], twopw[N + 10];\n\ninline int Pow(int x, int y) {\n\tint res = 1;\n\tfor (; y; y >>= 1, x = (LL)x * x % Mod)\n\t\tif (y & 1) res = (LL)res * x % Mod;\n\treturn res % Mod;\n}\n\nint main()\n{\n\ttwopw[0] = 1LL;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tinv_n[i] = Pow(i * (i + 1), Mod - 2);\n\t\ttwopw[i] = (LL)twopw[i - 1] * 2LL % Mod;\n\t}\n\tfor (int i = 0; i <= N; ++i)\n\t\ttwopw[i] = ((twopw[i] - i - 1) % Mod + Mod) % Mod;\n\tRead(n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tRead(a[i].x), Read(a[i].y);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (i != j) {\n\t\t\t\tint res = 1;\n\t\t\t\tfor (int k = 1; k <= n; ++k)\n\t\t\t\t\tif (k != i && k != j && !XJ(a[k] - a[i], a[j] - a[i]))\n\t\t\t\t\t\t++res;\n\t\t\t\tfans = (fans + (LL)inv_n[res] * twopw[res + 1]) % Mod;\n\t\t\t}\n\t}\n\tfans = (fans + n + 1) % Mod;\n\tfans = ((Pow(2, n) - fans) % Mod + Mod) % Mod;\n\tprintf(\"%lld\\n\", fans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\ttemplate<typename T> bool IN(T x,T l,T r){if(l>r)swap(l,r);return l<=x and x<=r;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=998244353;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int MM=5e6+10;\n\tll fac[MM],facinv[MM],Inv[MM];ll Comb(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,MM-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[MM-1]=invm(fac[MM-1]);fd(i,MM-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,MM-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\n\tconst int N=1e6+10;\n\t//------------------FIXED------------------\n\tpii a[N];\n\tvoid main()\n\t{\n\t\tint n=qread();fo(i,1,n) a[i].FR=qread(),a[i].SE=qread();ll ans=mm(qpower(2,n)+MOD-1-n);\n\t\tfo(i,1,n) fo(j,1,n) if(a[i]<a[j])\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfo(k,1,n) if(k!=i and k!=j and IN(a[k].FR,a[i].FR,a[j].FR) and IN(a[k].SE,a[i].SE,a[j].SE) and\n\t\t\t\t(a[j].SE-a[i].SE)*(a[k].FR-a[i].FR)==(a[k].SE-a[i].SE)*(a[j].FR-a[i].FR) )\n\t\t\t\t\tcnt++,debug(\"%d on (%d,%d)\\n\",k,i,j);\n\t\t\tadd(ans,MOD-qpower(2,cnt));\n\t\t\tdebug(\"i=%d j=%d cnt=%d\\n\",i,j,cnt);\n\t\t}write(ans);\n \t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::main();\n\tdebug(\"\\n------------------------------------------\\nTime: %.2lf s\\n\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 205, MOD = 998244353;\n\nclass Point {\npublic:\n  int x, y;\n  Point(int _x = 0, int _y = 0) {\n    x = _x, y = _y;\n  }\n  inline friend Point operator + (const Point &a, const Point &b) {\n    return Point(a.x + b.x, a.y + b.y);\n  }\n  inline friend Point operator - (const Point &a, const Point &b) {\n    return Point(a.x - b.x, a.y - b.y);\n  }\n} P[MAX_N];\n\nint pw[MAX_N];\n\nint cross(Point a, Point b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nint vis[MAX_N][MAX_N], st[MAX_N];\n\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; ++i) scanf(\"%d%d\", &P[i].x, &P[i].y);\n  pw[0] = 1;\n  for (int i = 1; i <= N; ++i) pw[i] = (pw[i - 1] + pw[i - 1]) % MOD;\n\n  int result = pw[N] - 1;\n\n  for (int i = 1; i <= N; ++i)\n    for (int j = i + 1; j <= N; ++j) \n      if (!vis[i][j]) {\n\tint top = 0;\n\tfor (int k = 1; k <= N; ++k)\n\t  if (cross(P[k] - P[i], P[k] - P[j]) == 0) st[++top] = k;\n\tresult = (result - pw[top] + 1 + top) % MOD;\n\tfor (int k1 = 1; k1 <= top; ++k1)\n\t  for (int k2 = 1; k2 <= top; ++k2)\n\t    vis[st[k1]][st[k2]] = 1;\n      }\n  result = (result - N) % MOD;\n  printf(\"%d\\n\", (result + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nbool vis[1001][1001];\nint a[1001], b[1001];\nint stk[1001];\nint mul[1001];\nint ksm(int x, int y) { return mul[y]; }\nint main( ) {\n\tint n;\n\tint ans = 0;\n\tscanf(\"%d\", &n);\n\tmul[0] = 1;\n\tfor (int i = 1; i <= n; i ++) mul[i] = mul[i - 1] * 2 % mod;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tscanf(\"%d %d\", &a[i], &b[i]);\n\t}\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = i + 1; j <= n; j ++) {\n\t\t\tif (vis[i][j]) continue;\n\t\t\tint cnt = 2;\n\t\t\tstk[1] = i, stk[2] = j;\n\t\t\tfor (int k = 1; k <= n; k ++) {\n\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\tpair<int, int> tmpx = make_pair(a[k] - a[i], b[k] - b[i]),\n\t\t\t\t\t\t\t   tmpy = make_pair(a[k] - a[j], b[k] - b[j]);\n\t\t\t\tif (tmpx.first * tmpy.second == tmpx.second * tmpy.first)\n\t\t\t\t\tstk[++ cnt] = k;\n\t\t\t}\n\t\t\tfor (int k = 1; k <= cnt; k ++)\n\t\t\t\tfor (int l = k + 1; l <= cnt; ++ l)\n\t\t\t\t\tvis[stk[k]][stk[l]] = true;\n\t\t\tans += (0LL + ksm(2, cnt) - (cnt + 1) % mod + mod) % mod;\n\t\t\tans %= mod;\n\t\t}\n\tprintf(\"%d\\n\", ((1LL * ksm(2, n) - 1 - n - ans) % mod + mod) % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAX_N 201\n#define MOD 998244353\n\nint x[MAX_N], y[MAX_N], p[MAX_N];\n\nint main(void)\n{\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d%d\", &x[i], &y[i]);\n    p[0] = 1;\n    for (int i = 0; i < n; i++)\n        p[i + 1] = (p[i] << 1) % MOD;\n    int ans = p[n] - n - 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            int cnt = 0;\n            for (int k = 0; k < j; k++) {\n                if ((x[i] - x[j]) * (y[i] - y[k]) == (x[i] - x[k]) * (y[i] - y[j]))\n                    cnt++;\n            }\n            ans -= p[cnt];\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N=1e5+10,Mod=998244353;\n\nstruct Point{\n\tint x,y;\n\tPoint(int x=0,int y=0):x(x),y(y) {}\n\tPoint operator - ( const Point &A ) const { return Point(x-A.x,y-A.y); }\n\tPoint operator / ( const int &p ) const { return Point(x/p,y/p); }\n\tbool operator == ( const Point &A ) const { return x==A.x && y==A.y; }\n\tbool operator < ( const Point &A ) const { return x<A.x || ( x==A.x && y==A.y); }\n}p[N],q[N];\ntypedef Point Vector;\n\nint n,qp2[N];\n\nvoid Init() {\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i) scanf(\"%d%d\",&p[i].x,&p[i].y);\n}\n\nint gcd(int a,int b) { return (!b)?a:gcd(b,a%b); }\n\nVector C(const Vector &a) { return a/gcd(a.x,a.y); }\n\nvoid Solve() {\n\tint ans=1; \n\tqp2[0]=1; for (int i=1;i<=n;++i) qp2[i]=(qp2[i-1]<<1)%Mod,ans=(ans<<1)%Mod;\n\tans--; ans-=n;\n\tfor (int i=1;i<=n;++i) {\n\t\tint t=0;\n\t\tfor (int j=i+1;j<=n;++j) q[++t]=C(p[j]-p[i]);\n\t\tstd::sort(q+1,q+t+1);\n\t\tfor (int h=1;h<=t;) {\n\t\t\tint p=h; while (q[p]==q[h] && h<=t) ++h;\n\t\t\tans=(ans-(qp2[h-p]-1)+Mod)%Mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n#define MOD 998244353\n\nlong mod_pow(long x, long n, long p=MOD){\n  if(x==0) return 0;\n  long res=1;\n  x %= p;\n  while(n>0){\n    if(n&1) res=res*x%p;\n    x=x*x%p;\n    n>>=1;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vector<int> x(n),y(n);\n  rep(i,n) cin>>x[i]>>y[i];\n\n  long ans = mod_pow(2, n);\n  ans -= n+1; // size = 0,1\n\n  map<pair<pair<int,int>, int>, set<int>> ma;\n  rep(i,n) rep(j,i){\n    int dx = x[i] - x[j];\n    int dy = y[i] - y[j];\n    int g = __gcd(dx,dy);\n    dx /= g; dy /= g;\n    if(dx<0 || (dx==0 && dy<0)) dx*=-1, dy*=-1;\n    auto key = mp(mp(dx,dy), x[i]*dy - y[i]*dx);\n    ma[key].insert(i);\n    ma[key].insert(j);\n  }\n\n  for(auto &&p : ma){\n    int sz = p.se.size();\n    long rm = mod_pow(2, sz) - sz - 1;\n    ans -= rm;\n  }\n\n  ans %= MOD;\n  if(ans<0) ans += MOD;\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <set>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define repn(i, m, n) for(i = m; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef complex<double> P;\n\nint mod = 998244353;\nint pow2[201];\nint n;\nP p[100];\n\ndouble cross(P a, P b) { return a.real() * b.imag() - a.imag() * b.real(); }\nbool onLine(P a, P b, P p) { return cross(b - a, p - a) == 0; }\n\nsigned main() {\n\tint i, j, k;\n\t\n\tpow2[0] = 1;\n\trepn(i, 1, 201) pow2[i] = (pow2[i - 1] * 2) % mod;\n\t\n\tcin >> n;\n\trep(i, n) { double x, y; cin >> x >> y; p[i] = P(x, y); }\n\t\n\tint ans = pow2[n];\n\t\n\tset<vector<int>> dict;\n\trep(i, n) {\n\t\trepn(j, i + 1, n) {\n\t\t\tvector<int> vec;\n\t\t\trep(k, n) if (onLine(p[i], p[j], p[k])) vec.push_back(k);\n\t\t\tif (dict.find(vec) != dict.end()) continue;\n\t\t\tdict.insert(vec);\n\t\t\tans += mod - (pow2[vec.size()] - vec.size() - 1);\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tans += mod - n - 1; ans %= mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n\n//点集合Sについて、Sが凸多角形なら「2^(凸多角形Sの内部にある点の個数)」がスコアになる。それ以外なら0がスコアになる。スコアの和を求めたい。\n//2^nが何を表すか？例えば、{1,2,…,n}の部分集合は2^n個ある。つまり、Sが凸多角形のときのスコアは、{Sの内部にある点}の部分集合の個数と等しい。\n//そこで、「点集合Sについて、Sの凸法が存在するなら1点, 存在しないなら0点」というスコアリングを考える。実はこれの和が、そのまま答えになる。\n//なぜだろうか。Sの凸法が存在するとき、凸法の点集合をTとおいてみる。Sが与えられたとき、Tはちょうど1個に定まる。ここで、S->Tという写像fを\n//考える。すると、各Tについて「2^(凸多角形Tの内部にある点の個数)」だけ矢印が来ていることが分かる。\n//また、写像fによって得られるTの集合（値域）は、与えられたN個の点によって作ることのできる「凸多角形」の集合と一致する。\n//新しいスコアリングでは、矢印の個数の和が合計スコアとなるが、これは上述より本問の答えと一致した。\n//\n//したがって、「凸法が存在するような点集合S」の個数を求める問題になる。補問題として「凸法が存在しないような点集合S」を考えると、Sは\n//直線または点または空集合を表すことが分かる。したがって、まず「答え=2^N」を仮定し、\n//そのような直線を全部列挙し、2^(乗っている点の個数) - (乗っている点の個数) - 1\n//を答えから引いていき、最後に答えからN+1を引けば、正しい答えが求まる。\n//計算量はO(N^3)となる()\n//\n//直線の列挙法：\n//直線は「乗っている点の集合X」と一対一対応するので、Xが今までに出現していないときだけ、リストに追加すればOK.\n//既に現れた点集合Xを、ハッシュで管理するとO(N^3), setで管理するとO(N^3logN)となる。"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define mod(x) ((x % MOD) + MOD) % MOD\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define LB(c,x) (int)(lower_bound(ALL(c),x)-(c).begin())\n#define UB(c,x) (int)(upper_bound(ALL(c),x)-(c).begin())\n#define COUNT(c,x) (UB(c,x)-LB(c,x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DEL(v) decltype(v)().swap(v)\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\ntemplate<typename T1, typename T2> using P = pair<T1,T2>;\ntemplate<typename T> using V = vector<T>;\nstruct edge { int from, to; int cost; };\nbool operator< (const edge &edge1, const edge &edge2) { return edge1.cost < edge2.cost; };\nconst double INF = 1e18;\nconst int MOD = 998244353;\n\ntemplate<typename T> ostream& operator << (ostream& s, const V<T>& v) {\n   s << \"[\";\n   for (int i = 0; i < v.size(); i++) { s << v[i]; if (i < v.size() - 1) s << \" \"; }\n   s << \"]\";\n   return s;\n}\n\nbool check(int x0, int y0, int x1, int y1, int x, int y)\n{\n   return (x1-x0)*(y-y0) == (y1-y0)*(x-x0);\n}\nint powM(int x, int n) {\n   int res = 1;\n   while (n > 0) {\n      if ((n & 1) == 1) {\n         res = mod(res * x);\n      }\n      x = mod(x * x);\n      n >>= 1;\n   }\n   return res;\n}\n\nsigned main()\n{\n   int N; cin >> N;\n   V<double> x(N), y(N);\n   REP(i, N) {\n      cin >> x[i] >> y[i];\n   }\n\n   set<P<double,double>> s;\n   set<double> t;\n   FOR(i, 0, N) {\n      FOR(j, i+1, N) {\n         if (x[i] != x[j]) {\n            double a = (y[j]-y[i])/(x[j]-x[i]);\n            double b = y[i] - a*x[i];\n            s.insert(MP(a, b));\n         } else {\n            t.insert(x[i]);\n         }\n      }\n   }\n   int sum = 0;\n   EACH(i, s) {\n      int n = 0;\n      int a = i->first, b = i->second;\n      FOR(j, 0, N) if (a*x[j] + b == y[j]) n++;\n      sum = mod(sum + powM(2,n) - n - 1);\n   }\n   EACH(i, t) {\n      int n = 0;\n      FOR(j, 0, N) if (x[j] == *i) n++;\n      sum = mod(sum + powM(2,n) - n - 1);\n   }\n\n   int ans = mod(powM(2,N) - sum - N - 1);\n   cout << ans << endl;\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int P=998244353;\nstruct pos{\n\tint x,y;\n}ps[207];\nint n,pw2[207],ans;\nstruct dir{\n\tint a,b,z;\n\tbool operator<(const dir&w)const{return z<w.z;}\n}ds[40007];\nint dp=0,f[207],sz[207];\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint gf(int x){\n\twhile(x!=f[x])x=f[x]=f[f[x]];\n\treturn x;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=pw2[0]=1;i<=n;++i)pw2[i]=pw2[i-1]*2%P;\n\tfor(int i=0;i<=n;++i)pw2[i]=(pw2[i]-i-1)%P;\n\tans=pw2[n];\n\tfor(int i=0;i<n;++i)scanf(\"%d%d\",&ps[i].x,&ps[i].y);\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=0;j<i;++j){\n\t\t\tint xd=ps[i].x-ps[j].x,yd=ps[i].y-ps[j].y;\n\t\t\tint g=gcd(xd,yd);\n\t\t\txd/=g,yd/=g;\n\t\t\tif(!xd)yd=1;\n\t\t\tif(!yd)xd=1;\n\t\t\tif(xd<0)xd=-xd,yd=-yd;\n\t\t\tds[dp++]=(dir){i,j,xd*30000+yd};\n\t\t}\n\t}\n\tstd::sort(ds,ds+dp);\n\tfor(int i=0,j=0;i<dp;i=j){\n\t\tfor(;j<dp&&ds[i].z==ds[j].z;++j);\n\t\tfor(int k=0;k<n;++k)f[k]=k,sz[k]=1;\n\t\tfor(int k=i;k<j;++k){\n\t\t\tint x=gf(ds[k].a),y=gf(ds[k].b);\n\t\t\tif(x!=y)f[x]=y,sz[y]+=sz[x];\n\t\t}\n\t\tfor(int k=0;k<n;++k)if(f[k]==k)ans=(ans-pw2[sz[k]])%P;\n\t}\n\tprintf(\"%d\\n\",(ans%P+P)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\n#define MOD 998244353ll // prime\n// How to devide :\n// ModInt a(6ll);\n// ModInt b(2ll);\n// a *= b.exp(MOD-2ll);  -> a/=b;  result: a = 3\nstruct ModInt{\n\tll val;\n\tModInt():val(0ll){}\n\tModInt(ll v):val(((v%MOD)+MOD)%MOD){}\n\tModInt exp(ll y)const{\n\t\tif(!y)return ModInt(1ll);\n\t\tModInt a = exp(y/2ll);\n\t\ta *= a;\n\t\tif(y&1)a*=(*this);\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& x)const{return val==x.val;}\n\tinline bool operator!=(const ModInt& x)const{return !(*this==x);}\n\tbool operator<(const ModInt& x)const{return val<x.val;}\n\tbool operator>(const ModInt& x)const{return val>x.val;}\n\tinline bool operator>=(const ModInt& x)const{return !(*this<x);}\n\tinline bool operator<=(const ModInt& x)const{return !(*this>x);}\n\tModInt& operator+=(const ModInt& x){if((val+=x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator-=(const ModInt& x){if((val+=MOD-x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator*=(const ModInt& x){(val*=x.val)%=MOD;return *this;}\n\tModInt operator+(const ModInt& x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt& x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt& x)const{return ModInt(*this)*=x;}\n};\nistream& operator>>(istream&i,ModInt&x){i>>x.val;return i;}\nostream& operator<<(ostream&o,const ModInt&x){o<<x.val;return o;}\nconst int SIZE = 1000;\nModInt inv[SIZE+10],fac[SIZE+10],facinv[SIZE+10];\nModInt pow2[SIZE+10];\n// notice: 0C0 = 1 \nModInt nCr(int n,int r){\n\tassert(!(n<r));\n\tassert(!(n<0||r<0));\n\treturn fac[n]*facinv[r]*facinv[n-r];\n}\nvoid init(){\n\tfac[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)fac[i]=fac[i-1]*ModInt(i);\n\tinv[1]=ModInt(1ll);\n\tfor(int i=2;i<=SIZE;i++)inv[i]=ModInt(0ll)-ModInt(MOD/i)*inv[MOD%i];\n\tfacinv[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=facinv[i-1]*inv[i];\n\tpow2[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)pow2[i]=pow2[i-1]*ModInt(2);\n\treturn;\n}\ndouble add(double a,double b)\n{\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP() {}\n\tP(double x,double y) : x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tdouble norm(){\n\t\treturn sqrt(x*x+y*y);\n\t}\n\tdouble norm2(){\n\t\treturn x*x+y*y;\n\t}\n\tdouble dist2(P p){\n\t\treturn sq(x-p.x)+sq(y-p.y);\n\t}\n\tP vert(){\n\t\treturn P(y,-x);\n\t}\n\tvoid dump(){\n\t\tprintf(\"%.12f %.12f\\n\",x,y);\n\t\treturn;\n\t}\n};\nint N;\nvector<P> ps;\nint main(){\n\tinit();\n\tscanf(\"%d\",&N);\n\tps.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lf %lf\",&ps[i].x,&ps[i].y);\n\t}\n\tModInt ans = pow2[N];\n\tans -= ModInt(1);\n\tans -= ModInt(N);\n\tif(N>1)ans -= nCr(N,2);\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tint cnt = 2;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tif(i==k)continue;\n\t\t\t\tif(j==k)continue;\n\t\t\t\tP ij = ps[j]-ps[i];\n\t\t\t\tP jk = ps[k]-ps[j];\n\t\t\t\tif(abs(ij.det(jk))<eps){\n\t\t\t\t\tif(k<j){\n\t\t\t\t\t\tcnt==0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt>2){\n\t\t\t\tModInt add = pow2[cnt];\n\t\t\t\tadd -= nCr(cnt,2);\n\t\t\t\tadd -= ModInt(cnt);\n\t\t\t\tadd -= ModInt(1);\n\t\t\t\tans -= add;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=998244353;\nconstexpr double EPS=1e-9;\n\ntemplate<unsigned M>\nstruct modint{\n\tunsigned val;\n\tmodint(unsigned x):val((x%M+M)%M){}\n\tmodint pow(unsigned r)const{\n\t\tll a=val,x=1;\n\t\tfor(;r;r>>=1){\n\t\t\tif(r&1)\n\t\t\t\t(x*=a)%=M;\n\t\t\t(a*=a)%=M;\n\t\t}\n\t\treturn x;\n\t}\n\tmodint inv()const{\n\t\tunsigned x=1;\n\t\tfor(unsigned a=val,b=M,u=0;b;){\n\t\t\tll t=a/b;\n\t\t\tswap(a-=b*t,b);\n\t\t\tswap(x-=u*t,u);\n\t\t}\n\t\treturn x;\n\t}\n\tmodint& operator=(const modint& x)&{val=x.val; return *this;}\n\tmodint& operator+=(const modint& x)&{if((val+=x.val)>=M) val-=M; return *this;}\n\tmodint& operator-=(const modint& x)&{if((val+=M-x.val)>=M) val-=M; return *this;}\n\tmodint& operator*=(const modint& x)&{val=(ll)val*x.val%M; return *this;}\n\tmodint& operator/=(const modint& x)&{val=(ll)val*x.inv().val%M; return *this;}\n};\n\ntemplate<unsigned M> bool operator==(const modint<M>& a,const modint<M>& b){return a.val==b.val;}\ntemplate<unsigned M> bool operator!=(const modint<M>& a,const modint<M>& b){return a.val!=b.val;}\ntemplate<unsigned M> modint<M> operator+(modint<M> a,const modint<M>& b){a+=b; return a;}\ntemplate<unsigned M> modint<M> operator-(modint<M> a,const modint<M>& b){a-=b; return a;}\ntemplate<unsigned M> modint<M> operator*(modint<M> a,const modint<M>& b){a*=b; return a;}\ntemplate<unsigned M> modint<M> operator/(modint<M> a,const modint<M>& b){a/=b; return a;}\ntemplate<unsigned M> ostream& operator<<(ostream& os,const modint<M>& x){return os<<x.val;}\n\nusing mint=modint<MOD>;\n\nint det(int x1,int y1,int x2,int y2)\n{\n\treturn x1*y2-x2*y1;\n}\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tfor(int n;cin>>n&&n;){\n\t\tvi xs(n),ys(n);\n\t\trep(i,n) cin>>xs[i]>>ys[i];\n\n\t\tmint res=mint(2).pow(n)-mint(1+n);\n\n\t\trep(i,n) repi(j,i+1,n){\n\t\t\tint x=xs[j]-xs[i],y=ys[j]-ys[i];\n\t\t\tvi is;\n\t\t\trep(k,n) if(k!=i&&k!=j){\n\t\t\t\tint x2=xs[k]-xs[i],y2=ys[k]-ys[i];\n\t\t\t\tif(det(x,y,x2,y2)==0)\n\t\t\t\t\tis.push_back(k);\n\t\t\t}\n\t\t\tif(is.empty()||j<is[0]){\n\t\t\t\tint m=2+is.size();\n\t\t\t\tres-=mint(2).pow(m)-mint(1+m);\n\t\t\t}\n\t\t}\n\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2018\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\n\nnamespace mine\n{\n\ttypedef long long ll;\n\tconst int INF=0x3f3f3f3f;\n\t//#define pr pair<double,int>\n\t#define FR first\n\t#define SE second\n\t#define MP make_pair\n\n\tconst int MAX_N=210;\n\tstruct Nod{int x,y;}p[MAX_N];\n\tint cross(Nod a,Nod b) {return a.x*b.y-a.y*b.x;}\n\tconst int MOD=998244353;\n\tbool v[MAX_N][MAX_N];\n\tint bin[MAX_N];\n\tvoid main()\n\t{\n\t\tbin[0]=1;for(int i=1;i<MAX_N;i++) bin[i]=bin[i-1]*2%MOD;\n\n\t\tint n;scanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&p[i].x,&p[i].y);\n\n\t\tint ans=bin[n]-1-n;//printf(\"ans=%d\\n\",ans);\n\t\tfor(int a=1;a<=n;a++)\n\t\t\tfor(int b=a+1;b<=n;b++)\n\t\t\t{\n\t\t\t\tint mi,mx;\n\t\t\t\tif(p[a].x==p[b].x) {if(p[a].y<p[b].y) mi=a,mx=b; else mi=b,mx=a;}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(p[a].x<p[b].x) mi=a,mx=b;\n\t\t\t\t\telse mi=b,mx=a;\n\t\t\t\t}\n\n\t\t\t\tint tot=2;\n\t\t\t\tfor(int c=1;c<=n;c++) if(c!=a and c!=b)\n\t\t\t\t{\n\t\t\t\t\tif(cross(\n\t\t\t\t\t\t(Nod){p[a].x-p[b].x,p[a].y-p[b].y},\n\t\t\t\t\t\t(Nod){p[a].x-p[c].x,p[a].y-p[c].y})==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(p[a].x==p[b].x)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(p[c].y<p[mi].y) mi=c;\n\t\t\t\t\t\t\telse if(p[c].y>p[mx].y) mx=c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(p[c].x*p[c].y<p[mi].x*p[mi].y) mi=c;\n\t\t\t\t\t\t\telse if(p[c].x*p[c].y>p[mx].x*p[mx].y) mx=c;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttot++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(v[mi][mx]) continue;\n\t\t\t\tv[mi][mx]=1;\n\t\t\t\tans-=bin[tot]-tot-1;\n\t\t\t\tans%=MOD;\n\t\t\t\t//printf(\"(%d,%d,%d,%d)=%d\\n\",mi,mx,a,b,tot);\n\t\t\t}\n\t\tprintf(\"%d\",(ans+MOD)%MOD);\n\t}\n};\nint main()\n{\n\tsrand(time(0));\n\tmine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: CNYALI_LK\nLANG: C++\nPROG: E.cpp\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconst double eps=1e-8;\nconst double PI=acos(-1.0);\ntypedef long long ll;\ntemplate<class T>void chkmin(T &a,T b){a=a<b?a:b;}\ntemplate<class T>void chkmax(T &a,T b){a=a>b?a:b;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\n#define min mmin\n#define max mmax\n#define abs aabs\nconst ll mod=998244353;\nll p[233];\nstruct zb{\n\tll x,y;\n};\nzb a[233];\nll cmp(zb a,zb b){return a.x<b.x||a.x==b.x&&a.y<b.y;}\nint main(){\n#ifdef cnyali_lk\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n\tll n,ans;\n\tscanf(\"%lld\",&n);\n\tp[0]=1;\n\tfor(ll i=1;i<=n;++i){p[i]=p[i-1]<<1;if(p[i]>=mod)p[i]-=mod;scanf(\"%lld%lld\",&a[i].x,&a[i].y);}\n\tsort(a+1,a+n+1,cmp);\n\tans=p[n]-n-1;\n\tfor(ll i=1;i<=n;++i)for(ll j=i+1;j<=n;++j){\n\t\tll no=0;\n\t\tfor(ll k=1;k<j;++k)if(k!=i&&(a[j].x-a[i].x)*(a[i].y-a[k].y)==(a[j].y-a[i].y)*(a[i].x-a[k].x)){no=1;break;}\n\t\tif(!no){\n///\t\t\tdebug(\"(%lld,%lld) (%lld,%lld)\",a[i].x,a[i].y,a[j].x,a[j].y);\n\t\t\tll tot=2;\n\t\t\tfor(ll k=j+1;k<=n;++k){\n\t\t\t\tif((a[j].x-a[i].x)*(a[i].y-a[k].y)==(a[j].y-a[i].y)*(a[i].x-a[k].x)){++tot;/*debug(\" (%lld,%lld)\",a[k].x,a[k].y);*/}\n\t\t\t}\n//\t\t\tdebug(\"\\n\");\n\t\t\tans-=p[tot]-tot-1;\n\t\t}\n\t}\t\n\tprintf(\"%lld\\n\",(ans%mod+mod)%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mk make_pair\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nll pwr[210], mod=998244353;\nvoid pre(){\n  pwr[0]=1;\n  for(int i=1; i<=200; ++i){\n    pwr[i]=(pwr[i-1]*2)%mod;\n  }\n}\nll x[210], y[210];\nmap<ll, ll> mp;\nint main(){\n  int n;\n  pre();\n  while(cin>>n){\n    for(int i=0; i<n; ++i){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    ll ans=pwr[n]-n-1, tmp1, tmp2, tmp;\n    for(int i=0; i<n; ++i){\n      mp.clear();\n      for(int j=i+1; j<n; ++j){\n        tmp1=(y[i]-y[j]);\n        tmp2=(x[i]-x[j]);\n        tmp=__gcd(tmp1, tmp2);\n        tmp1/=tmp;\n        tmp2/=tmp;\n        ++mp[tmp];\n      }\n      for(map<ll, ll>::iterator it=mp.begin(); it!=mp.end(); ++it){\n        ans-=(pwr[it->second])-1;\n        ans%=mod;\n      }\n    }\n    ans%=mod;\n    if(ans<0)\n      ans+=mod;\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 998244353;\n\nLL powm(LL x, LL y){\n  if(y <= 0) return 1ll;\n  return powm(x*x%MOD, y/2) * (y%2?x:1ll) % MOD;\n}\n\nbool ison(PLL p1, PLL p2, PLL q){\n  p1.FF -= q.FF;\n  p1.SS -= q.SS;\n  p2.FF -= q.FF;\n  p2.SS -= q.SS;\n  return p1.FF * p2.SS - p1.SS * p2.FF == 0;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N;\n  cin >> N;\n  vector<PLL> xs(N);\n  cin >> xs;\n\n  LL ans = (powm(2, N) + MOD - N - 1) % MOD;\n  set<PLL> memo;\n  REP(i,N) REP(j,i){\n\tVI ps;\n\tREP(k,N){\n\t  if(ison(xs[i], xs[j], xs[k])){\n\t\tps.PB(k);\n\t  }\n\t}\n\tSORT(ps);\n\tauto p = MP(ps[0], ps[1]);\n\tif(memo.count(p)) continue;\n\tmemo.insert(p);\n\tans = (ans + MOD - (powm(2, SZ(ps)) - SZ(ps) - 1)) % MOD;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nconst int M=207,mod=998244353;\nint read(){\n\tint ans=0,f=1,c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-') f=-1; c=getchar();}\n\twhile(c>='0'&&c<='9'){ans=ans*10+(c-'0'); c=getchar();}\n\treturn ans*f; \n}\nint n,f[M],sz[M];\nint find(int x){while(f[x]!=x) x=f[x]=f[f[x]]; return x;}\nint gcd(int x,int y){return y?gcd(y,x%y):x;} \nstruct pos{int x,y;}q[M];\nint cnt;\nstruct node{\n\tint u,v,w;\n\tbool operator <(const node &x)const{return w<x.w;}\n\tvoid calc(){\n\t\tint p=find(u),q=find(v);\n\t\tif(p!=q) f[q]=p,sz[p]+=sz[q];\n\t}\n}e[M*M];\nint pw[M],ans;\nvoid prepare(){\n\tpw[0]=1; \n\tfor(int i=1;i<=n;i++) pw[i]=(pw[i-1]<<1)%mod;\n}\nint main(){\n\tn=read(); \n\tprepare(); ans=(pw[n]-n-1)%mod;\n\tfor(int i=1;i<=n;i++) q[i].x=read(),q[i].y=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++){\n\t\t\tint x=q[i].x-q[j].x,y=q[i].y-q[j].y,g=gcd(x,y);\n\t\t\tx/=g; y/=g;\n\t\t\tif(!x) y=1;\n\t\t\tif(!y) x=1;\n\t\t\tif(x<0) x=-x,y=-y;\n\t\t\te[++cnt]=(node){i,j,x*30000+y};\n\t\t}\n\tstd::sort(e+1,e+1+cnt);\n\tfor(int i=1,j=1;i<=cnt;i=j){\n\t\tfor(int k=1;k<=n;k++) sz[f[k]=k]=1;\n\t\twhile(j<=cnt&&e[j].w==e[i].w) e[j++].calc();\n\t\tfor(int k=1;k<=n;k++) if(f[k]==k&&sz[k]>=2) ans=(ans-pw[sz[k]]+sz[k]+1)%mod;\n\t}printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <math.h>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 100005;\nconst int inf = 1e9;\nconst int mod = 998244353;\n\nstruct Line {\n\tLL ka,kb,ya,yb; //y=ka/kb*x+ya/yb,ka,ya>0\n\tbool operator==(const Line &v) const {\n\t\treturn ka==v.ka&&kb==v.kb&&ya==v.ya&&yb==v.yb;\n\t}\n\tbool operator<(const Line &v) const {\n\t\tif (ka!=v.ka) return ka<v.ka;\n\t\tif (kb!=v.kb) return kb<v.kb;\n\t\tif (ya!=v.ya) return ya<v.ya;\n\t\treturn yb<v.yb;\n\t}\n}l[maxn];\nLL gcd(LL n,LL m) {\n\treturn m?gcd(m,n%m):n;\n}\nint n,tot,pw[maxn],ans,x[maxn],y[maxn];\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc082e.in\",\"r\",stdin);\n\t\tfreopen(\"arc082e.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d\",&n);pw[0]=1;\n\tfor (int i=1;i<=n;i++) pw[i]=(pw[i-1]<<1)%mod;\n\tfor (int i=1;i<=n;i++) scanf(\"%d %d\",&x[i],&y[i]);\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=i+1;j<=n;j++)\n\tif (x[i]==x[j]) {\n\t\tl[++tot]=(Line){inf,0,0,x[i]};\n\t}\n\telse {\n\t\tLL ka=y[i]-y[j],kb=x[i]-x[j];\n\t\tLL ya=((LL)y[i]*kb-ka*x[i]),yb=kb;\n\t\tLL kab=gcd(ka,kb);ka/=kab;kb/=kab;\n\t\tLL yab=gcd(ya,yb);ya/=yab;yb/=yab;\n\t\tif (ka<0) ka*=-1,kb*=-1;\n\t\tif (ya<0) ya*=-1,yb*=-1;\n\t\tl[++tot]=(Line){ka,kb,ya,yb};\n\t}\n\tsort(l+1,l+tot+1);\n\tfor (int i=1;i<=tot;) {\n\t\tint pos=i;while (pos<=tot&&l[i]==l[pos]) pos++;\n\t\tint num=sqrt((pos-i)<<1)+1;i=pos;\n\t\tans=((LL)ans-pw[num]+num+1)%mod;\n\t}\n\tans=((LL)ans+pw[n]-n-1)%mod;\n\tprintf(\"%d\",ans<0?ans+mod:ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define taskname \"A\"\n#define pb push_back\n#define mp make_pair\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> ii;\nconst int maxn = 2e3 +5;\nconst int mod =998244353;\nconst int inf = 1e9 + 1;\nconst ll llinf = 1e18 + 5;\nii a[maxn];\nint n,p[maxn];\nii operator - (ii a , ii b){\n    return mp(a.first - b.first , a.second - b.second);\n}\nbool operator * (ii a , ii b){\n    return a.first * b.second - a.second * b.first;\n}\nll ccw(ii a , ii b , ii c){\n    return (a - b) * (c - b);\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    if(fopen(taskname\".inp\", \"r\")) {\n        freopen(taskname\".inp\", \"r\", stdin);\n        freopen(taskname\".out\", \"w\", stdout);\n    }\n    cin >> n;\n    p[0] = 1;\n    for(int i = 1 ; i <= n ; ++i){\n        cin >> a[i].first >> a[i].second;\n        p[i] = p[i - 1] * 2 % mod;\n    }\n    int res = (p[n] - 1 - (ll)n * (n + 1) / 2) % mod;\n    for(int i = 1 ; i <= n ; ++i){\n        for(int j = i + 1 ; j <= n ; ++j){\n            int cnt = 0;\n            for(int t = j + 1 ; t <= n ; ++t){\n                cnt += (ccw(a[i],a[j],a[t]) == 0);\n            }\n            res = (res - (p[cnt] - 1)) % mod;\n        }\n    }\n    cout << (res + mod) % mod;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PII pair<LL,LL>\n#define fi first\n#define se second\n#define lowbit(x) ((x)&(-(x)))\n#define FOR(i,a,b) for (LL i=(a);i<=(b);++i)\n#define ROF(i,b,a) for (LL i=(b);i>=(a);--i)\ntypedef long long LL;\ninline LL read(){\n\tLL x=0,f=1; char ch=getchar();\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\twhile (ch>='0'&&ch<='9') { x=x*10+ch-'0'; ch=getchar(); }\n\treturn x*f;\n}\n\nconst LL MAXN=300005,Mo=998244353;\nstruct list{\n\tLL l,lt[MAXN],nt[MAXN*2],x[MAXN*2],y[MAXN*2];\n\tvoid clear(){ l=0; memset(lt,0,sizeof(lt)); }\n\tvoid addedge(LL a,LL b){ l++; nt[l]=lt[a]; lt[a]=l; x[l]=b; }\n}E;\nstruct P{\n\tLL x,y;\n\tP(LL xx=0,LL yy=0):x(xx),y(yy){}\n\tP operator +(const P &E)const{ return P(x+E.x,y+E.y); }\n\tP operator -(const P &E)const{ return P(x-E.x,y-E.y); }\n\tLL operator *(const P &E)const{ return x*E.y-E.x*y; }\n\tLL operator ^(const P &E)const{ return x*E.x+y*E.y; }\n}A[MAXN],B[MAXN];\nLL n,m,a[MAXN],b[MAXN];\nLL power(LL a,LL b){\n\tLL c=1; a%=Mo;\n\twhile (b) {\n\t\tif (b&1) c=c*a%Mo;\n\t\ta=a*a%Mo; b>>=1;\n\t}\n\treturn c;\n}\nLL cmp(P i,P j){ return i*j>0; }\nint main(){\n\tn=read();\n\tFOR(i,1,n) a[i]=power(i,Mo-2);\n\tFOR(i,1,n) { A[i].x=read(); A[i].y=read(); }\n\tLL tmp,ans=power(2,n)+Mo-n-1;\n\tif (ans>=Mo) ans-=Mo;\n\tFOR(i,1,n) {\n\t\tFOR(j,1,i-1) B[j]=A[j]-A[i];\n\t\tFOR(j,i+1,n) B[j-1]=A[j]-A[i];\n\t\tFOR(j,1,n-1) if (B[j].x<0) B[j].x=-B[j].x,B[j].y=-B[j].y;\n\t\tsort(B+1,B+n,cmp);\n\t\tfor (LL j=1,k,tot;j<n;j=k+1) {\n\t\t\tfor (k=j;k<n-1&&B[k+1]*B[j]==0;++k);\n\t\t\ttot=k-j+2;\n\t\t\ttmp=(power(2,tot)+Mo-tot-1)*a[tot]%Mo;\n\t\t\tans+=Mo-tmp; if (ans>=Mo) ans-=Mo;\n\t\t}\n\t}\n\tcout<<(ans%Mo+Mo)%Mo<<endl;\n\treturn 0;\n}\n\n/*\n4\n0 0\n0 1\n1 0\n1 1\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\nint n,x[210],y[210],p;\nconst int q=998244353;\ninline int power(int a,int b)\n{\n\tif(!b)\n\t  return 1;\n\tint c=power(a,b>>1);\n\tc=(L)c*c%q;\n\tif(b&1)\n\t  c=(L)c*a%q;\n\treturn c;\n}\ninline bool chk(int i,int j,int k)\n{\n\treturn (x[i]-x[k])*(y[j]-y[k])-(x[j]-x[k])*(y[i]-y[k])==0;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k,l,u;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d%d\",&x[i],&y[i]);\n\tp=power(2,n)-1-n;\n\tfor(i=1;i<=n;i++)\n\t  for(j=i+1;j<=n;j++)\n\t    {\n\t     for(k=1,l=4,u=3;k<=n;k++)\n\t       if(k!=i && k!=j && chk(i,j,k))\n\t         if(k<j)\n\t           {\n\t\t\t\tl=u=0;\n\t\t\t\tbreak;\n\t\t\t   }\n\t\t\t else\n\t\t\t   {\n\t\t\t    l=(l<<1)%q;\n\t\t\t    u++;\n\t\t\t   }\n\t\t p=(p-l+u)%q;\n\t\t}\n\tp=(p+q)%q;\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nconst int M=207,mod=998244353;\nint read(){\n\tint ans=0,f=1,c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-') f=-1; c=getchar();}\n\twhile(c>='0'&&c<='9'){ans=ans*10+(c-'0'); c=getchar();}\n\treturn ans*f; \n}\nint n,f[M],sz[M];\nint find(int x){while(f[x]!=x) x=f[x]=f[f[x]]; return x;}\nint gcd(int x,int y){return y?gcd(y,x%y):x;} \nstruct pos{int x,y;}q[M];\nint cnt;\nstruct node{\n\tint u,v,w;\n\tbool operator <(const node &x)const{return w<x.w;}\n\tvoid calc(){\n\t\tint p=find(u),q=find(v);\n\t\tif(p!=q) f[q]=p,sz[p]+=sz[q];\n\t}\n}e[M*M];\nint pw[M],ans;\nvoid prepare(){\n\tpw[0]=1; \n\tfor(int i=1;i<=n;i++) pw[i]=(pw[i-1]<<1)%mod;\n}\nint main(){\n\tn=read(); \n\tprepare(); ans=(pw[n]-n-1)%mod;\n\tfor(int i=1;i<=n;i++) q[i].x=read(),q[i].y=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++){\n\t\t\tint x=q[i].x-q[j].x,y=q[i].y-q[j].y,g=gcd(x,y);\n\t\t\tx/=g; y/=g;\n\t\t\tif(!x) y=1;\n\t\t\tif(!y) x=1;\n\t\t\tif(x<0) x=-x,y=-y;\n\t\t\te[++cnt]=(node){i,j,x*30000+y};\n\t\t}\n\tstd::sort(e+1,e+1+cnt);\n\tfor(int i=1,j=1;i<=cnt;i=j){\n\t\tfor(int k=1;k<=n;k++) sz[f[k]=k]=1;\n\t\twhile(j<=cnt&&e[j].w==e[i].w) e[j++].calc();\n\t\tfor(int k=1;k<=n;k++) if(f[k]==k&&sz[k]>=2) ans=(ans-pw[sz[k]]+sz[k]+1)%mod;\n\t}printf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define CIN_ONLY if(1)\nstruct cww{cww(){\n    CIN_ONLY{\n        ios::sync_with_stdio(false);cin.tie(0);\n    }\n}}star;\n#ifdef BTK\n#include <dvector.h>\n#define DEBUG if(1)\n#else\n#define DEBUG if(0)\n#endif\n\n#define fin \"\\n\"\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l,T r)\n{bool a=l>r;if(a)l=r;return a;}\ntemplate <typename T>inline bool chmax(T &l,T r)\n{bool a=l<r;if(a)l=r;return a;}\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\n\nint cross(int x1,int y1,int x2,int y2){\n    return x1*y2-y1*x2;\n}\nconst int mod=998244353;\nint main(){\n    int n;\n    cin>>n;\n    vector<int> x(n),y(n);\n    REP(i,n)cin>>x[i]>>y[i];\n    vector<int> line;\n    vector<vector<int>> used(n,vector<int>(n,0));\n    REP(i,n)used[i][i]=1;\n    REP(i,n)REP(j,n)if(used[i][j]==0){\n        vector<int> l;\n        REP(k,n)\n            if(cross(\n                     x[i]-x[j],\n                     y[i]-y[j],\n                     x[i]-x[k],\n                     y[i]-y[k]\n                     )==0)\n                l.pb(k);\n        for(auto a:l)\n            for(auto b:l)\n                used[a][b]=1;\n        line.pb(l.size());\n    }\n    LL ret=1;\n    REP(i,n)ret=(ret+ret)%mod;\n    ret+=mod-n-1;ret%=mod;\n    for(auto &it:line){\n        DEBUG cout<<it<<endl;\n        LL s=1;\n        REP(i,it)s=(s+s)%mod;\n        s+=mod-it-1;s%=mod;\n        ret+=mod-s;ret%=mod;   \n    }\n    cout<<ret<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n,x[205],y[205],mod=998244353,ans;\n\nsigned main(){\n\tscanf(\"%d\",&n);\n\tans=((1<<n)-1-n-(n-1)*n/2+mod)%mod;\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",x+i,y+i);\n\tfor(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++){\n\t\tint tot=0;\n\t\tfor(int k=j+1;k<=n;k++) if((y[i]-y[j])*(x[j]-x[k])==(x[i]-x[j])*(y[j]-y[k])) tot++;\n\t\tans=(ans-(1<<tot)+mod+1)%mod;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 998244353;\nconst int maxn = 200 + 50;\nint n;\nll p[maxn];\nll x[maxn], y[maxn];\nmap<pair<ll, ll>, ll> mp;\nvoid pre(){\n    p[0] = 1;\n    for(int i = 1; i < maxn; i++){\n        p[i] = (p[i-1] * 2) % mod;\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    pre();\n    while(cin >> n){\n        for(int i = 0; i < n; i++)\n            cin >> x[i] >> y[i];\n        ll ans = p[n] - n - 1;//减去空集和单点集\n        ll deltay, deltax, k;\n        for(int i = 0; i < n; i++){\n            mp.clear();\n            for(int j = i+1; j < n; j++){\n                deltay = y[j] - y[i];\n                deltax = x[j] - x[i];\n                k = __gcd(deltay, deltax);\n                deltay/=k;\n                deltax/=k;\n                ++mp[{deltay,deltax}];\n            }\n            for(map<pair<ll, ll>, ll>::iterator iter = mp.begin(); iter != mp.end(); iter++){\n                ll tmp = p[iter->second] - 1;//除i点以外共线集的个数，减去只有一个i点的情况\n                ans = (ans - tmp + mod) % mod;\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lld long long int\n#define ld long double\n#define mod 1000000007\n#define modd 998244353\n#define all(v) v.begin(),v.end()\n#define rep(i,a,b)\tfor(lld i=a;i<=b;i++)\n#define repr(i,a,b) for(lld i=a;i>=b;i--)\n#define ar array\n#define pb push_back\n#define mp make_pair\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nlld n,m;\nar<lld,2> arr[300000];\nmap<ar<lld,3>, lld> ma;\nlld fastpower(lld x, unsigned lld y, lld p)\n{\n    lld res = 1;\n    x = x % p;\n    while (y > 0)\n    {\n        if (y & 1)\n            res = (res*x) % p;\n        y = y>>1;\n        x = (x*x) % p;\n    }\n    return res;\n}\nint main()\n{\n     ios;\n     lld TESTS,q,a,s,b,l,r,c,k,p,h,w,d,x,y,z,xs,ys,t;\n     TESTS=1;\n     //cin>>TESTS;\n     while(TESTS--)\n     {\n         cin>>n;\n         rep(i,0,n-1)cin>>arr[i][0]>>arr[i][1];\n         lld cou=0;\n         rep(i,0,n-1) rep(j,i+1,n-1){\n            x=arr[i][0]-arr[j][0];\n            y=arr[i][1]-arr[j][1];\n            z=arr[i][1]*x-arr[i][0]*y;\n            lld g=__gcd(abs(x),abs(y));\n            g=__gcd(g,abs(z));\n            x/=g;y/=g;z/=g;\n            if (ma[{x,y,z}]) continue;\n            ma[{x,y,z}]=1;\n            lld now=2;\n            rep(k,0,n-1){\n                if(k==i||k==j)continue;\n                xs=arr[k][0]-arr[i][0];\n                ys=arr[k][1]-arr[i][1];\n                if (xs*y==ys*x)now++;\n            }\n            cou+=fastpower(2,now,modd);\n            cou%=modd;\n            cou+=modd-1;\n            cou%=modd;\n            cou+=modd-now;\n            cou%=modd;\n         }\n      //   cout<<cou<<\"\\n\";\n      lld ans=fastpower(2,n,modd);\n      ans+=modd-1;\n      ans%=modd;\n      ans+=modd-cou;\n      ans%=modd;\n      ans+=modd-n;\n      ans%=modd;\n         cout<<ans;\n     }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\nbool operator <(point a, point b) {\n    return a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) > 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\nint adds[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = st[n];\n    ans = (ans - 1 + Mod) % Mod;\n    ans = (ans - n + Mod) % Mod;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (!(p[i] < p[j])) {\n                continue;\n            }\n            int cnt = 0;\n            for (int k = 0; k < n; k++) {\n                if (k != i && k != j && vec(p[k] - p[i], p[j] - p[k]) == 0 && p[i] < p[k] && p[k] < p[j]) {\n                    cnt++;\n                }\n            }\n            ans = (ans - st[cnt] + Mod) % Mod;\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2000;\ntypedef long long ll;\nconst ll mod=998244353;\nll x[maxn],y[maxn];\nll power(ll a,ll b)\n{\n    ll ret;\n    if (b==0) return 1LL;\n    ret=pow(a,b/2);\n    ret=ret*ret%mod;\n    if (b%2) ret=ret*a%mod;\n    return ret;\n}\nint main()\n{\n    //freopen(\"text.in\",\"r\",stdin);\n    ll i,ans,tmp,j,k,n;\n    scanf(\"%lld\",&n);\n    for (i=1;i<=n;i++) {\n        scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    ans=((power(2LL,n)-n-1)%mod+mod)%mod;\n    ans=((ans-(n-1)*n/2)%mod+mod)%mod;\n    for (i=1;i<=n;i++) {\n        for (j=i+1;j<=n;j++) {\n            tmp=0;\n            for (k=j+1;k<=n;k++) {\n                if ((y[j]-y[i])*(x[k]-x[j])==(y[k]-y[j])*(x[j]-x[i])) tmp++;\n                //if ((y[k]-y[i])*(x[j]-x[i])==(x[k]-x[i])*(y[j]-y[i])) tmp++;\n            }\n            ans=((ans-power(2LL,tmp)+1)%mod+mod)%mod;\n        }\n    }\n    printf(\"%lld\\n\",(ans%mod+mod)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define MOD 998244353\n\nusing lint = long long int;\nusing pii = std::pair<int, int>;\n\nusing std::vector;\nvector<pii> ve;\nbool check[220][220];\nvector<int> cou[220][220];\n\nlint combi(lint n, lint r) {\n\tlint ret = 1;\n\tfor (int i = 1; i <= r; i++) {\n\t\tret *= (n - i + 1);\n\t}\n\tfor (int i = 1; i <= r; i++) {\n\t\tret /= i;\n\t}\n\treturn ret;\n}\nlint my_pow(lint a, lint b, lint mod) { //a^b % mod\n\tlint ret = 1;\n\ta %= mod;\n\twhile (b != 0) {\n\t\tif (b % 2 == 0) {\n\t\t\ta = (a * a) % mod;\n\t\t\tb /= 2;\n\t\t}\n\t\telse {\n\t\t\tret = (ret * a) % mod;\n\t\t\tb--;\n\t\t}\n\t}\n\treturn ret;\n}\nlint make(lint n) {\n\tlint ret = my_pow(2, n, MOD);\n\tfor (int i = 0; i < 3; i++) {\n\t\tret = (ret - combi(n, i) + MOD) % MOD;\n\t}\n\treturn ret;\n}\nbool is_in(pii x, pii y, pii z) {\n\tint xx = y.first - x.first;\n\tint yy = y.second - x.second;\n\n\tint t_x = (z.first - x.first);\n\tint t_y = (z.second - x.second);\n\n\tif (yy * t_x == t_y * xx) {\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main(void) {\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tint t1, t2;\n\t\tscanf(\"%d %d\", &t1, &t2);\n\t\tve.push_back(pii(t1, t2));\n\t}\n\tsort(ve.begin(), ve.end());\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tif (!check[i][j]) {\n\t\t\t\tcheck[i][j] = true;\n\t\t\t\tcheck[j][i] = true;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (is_in(ve[i], ve[j], ve[k])) {\n\t\t\t\t\t\tfor (int l = 0; l < cou[i][j].size(); l++) {\n\t\t\t\t\t\t\tcheck[k][cou[i][j][l]] = true;\n\t\t\t\t\t\t\tcheck[cou[i][j][l]][k] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcou[i][j].push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlint ans = make(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (cou[i][j].size() >= 3) {\n\t\t\t\tans = (ans - make(cou[i][j].size()) + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,x[205],y[205],mod=998244353;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tlong long ans=1ll*((1<<n)%mod-1-n-(n-1)*n/2%mod+mod)%mod;\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",x+i,y+i);\n\tfor(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++){\n\t\tint tot=0;\n\t\tfor(int k=j+1;k<=n;k++) if((y[i]-y[j])*(x[j]-x[k])==(x[i]-x[j])*(y[j]-y[k])) tot++;\n\t\tans=1ll*(ans-(1<<tot)%mod+mod+1)%mod;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NDEBUG\n#ifdef DEBUG\n#include \"../cout11.h\"\n#undef NDEBUG\n#endif\n#include <cassert>\n\ntypedef long long ll;\ntypedef long double Double;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> llll;\ntypedef pair<double,double> dd;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ii> vii;\ntypedef vector<vector<ii>> vvii;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<long double> vD;\n\n#define sz(a)  int((a).size())\n#define pb  push_back\n#define FOR(var,from,to) for(int var=(from);var<=(to);++var)\n#define rep(var,n)  for(int var=0;var<(n);++var)\n#define rep1(var,n)  for(int var=1;var<=(n);++var)\n#define repC2(vari,varj,n)  for(int vari=0;vari<(n)-1;++vari)for(int varj=vari+1;varj<(n);++varj)\n#define ALL(c)  (c).begin(),(c).end()\n#define RALL(c)  (c).rbegin(),(c).rend()\n#define tr(i,c)  for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define found(s,e)  ((s).find(e)!=(s).end())\n#define mset(arr,val)  memset(arr,val,sizeof(arr))\n#define mid(x,y) ((x)+((y)-(x))/2)\n#define IN(x,a,b) ((a)<=(x)&&(x)<=(b))\n#define cons make_pair\n\n\nll gcd(ll a, ll b) { while(a) swap(a, b%=a); return b; }\n\nconst ll MOD=998244353LL;\n\nll ADD(ll x, ll y) { return (x+y) % MOD; }\nll SUB(ll x, ll y) { return (x-y+MOD) % MOD; }\nll MUL(ll x, ll y) { return x*y % MOD; }\nll POW(ll x, ll e) { ll v=1; for(; e; x=MUL(x,x), e>>=1) if (e&1) v = MUL(v,x); return v; }\nll DIV(ll x, ll y) { /*assert(y%MOD!=0);*/ return MUL(x, POW(y, MOD-2)); }\n// ll comb(ll n, ll k) { ll v=1; for(ll i=1; i<=k; i++) v = DIV(MUL(v, n-i+1),i); return v; }\n//\n\ntypedef tuple<double,double,double> LINE;\n\nvoid render_fnum(FILE* fp, double x) {\n    if (x == 1) return;\n    fprintf(fp, \"%g\", x);\n}\nvoid render_line(FILE* fp, LINE& line) {\n    double a,b,c; tie(a,b,c) = line;\n    if (a != 0){\n        render_fnum(fp, a);\n        fprintf(fp, \"x\");\n    }\n\n    if (b != 0) {\n        if (b > 0) {\n            if (a != 0)\n                fprintf(fp, \" + \");\n            render_fnum(fp, b);\n        } else if (b < 0) {\n            fprintf(fp, \" - \");\n            render_fnum(fp, -b);\n        }\n        fprintf(fp, \"y\");\n    }\n\n    if (c != 0) {\n        if (c > 0) {\n            fprintf(fp, \" + %g\", c);\n        } else if (c < 0) {\n            fprintf(fp, \" - %g\", -c);\n        }\n    }\n\n    fprintf(fp, \" = 0\");\n}\n\nLINE get_line(ii& p0, ii& p1){\n    int x0 = p0.first, y0 = p0.second,\n        x1 = p1.first, y1 = p1.second;\n    int dx = x1 - x0, dy = y1 - y0;\n\n    assert(dx != 0 || dy != 0);\n\n    double a, b, c;\n\n    if (dx == 0) {\n        // 1x [+ 0y] - some = 0\n        // some = x\n        // double some = (double)x0;\n        a = 1.0;\n        b = 0.0;\n        c = (double)(-x0); // -some;\n    } else if (dy == 0) {\n        // [0x +] 1y - some = 0\n        // some = y\n        // double some = (double)y0;\n        a = 0.0;\n        b = 1.0;\n        c = (double)(-y0); // -some;\n    } else {\n        // m = dy/dx\n        // y = mx + b\n        // mx - y + b = 0\n        int g = gcd(dx, dy);\n        dx /= g; dy /= g;\n\n        double _m = (double)dx / dy;\n        assert(_m != 0.0);\n        // x - _my - some = 0\n        // double some = (double)x0 - _m * y0;\n        a = 1.0;\n        b = -_m;\n        c = (double)(_m * y0 - x0); // -some;\n    }\n\n    // fprintf(stderr, \"(a,b,c)=(%g,%g,%g)\\n\", a,b,c);\n\n    double z0 = a * x0 + b * y0 + c;\n    double z1 = a * x1 + b * y1 + c;\n#ifdef DEBUG\n    // fprintf(stderr, \"%g * %d + %g * %d + %g = %g\\n\", a,x0, b,y0, c, z0);\n    // fprintf(stderr, \"%g * %d + %g * %d + %g = %g\\n\", a,x1, b,y1, c, z1);\n#endif\n    assert(fabs(z0) < 1e-7);\n    assert(fabs(z1) < 1e-7);\n\n    return LINE(a, b, c);\n}\n\n\nll f(int n){\n    // return (1 << n) - n - 1;\n    return SUB(POW(2, n), ADD(n,1));\n}\n\nll solve(int N, vii& p){\n    // map<LINE, set<int>> by_line;\n    map<vector<ll>, set<int>> by_line;\n\n    repC2(i,j,N){\n#ifdef DEBUG\n        // cerr << \"---\" << endl;\n        // fprintf(stderr, \"[%d %d] \", i, j);\n        // cerr << p[i] << \" \" << p[j] << \" : \";\n#endif\n        LINE line = get_line(p[i], p[j]);\n#ifdef DEBUG\n        // render_line(stderr, line);\n        // cerr << endl;\n#endif\n\n        double a,b,c; tie(a,b,c) = line;\n        vector<ll> _line { (ll)round(1e7*a), (ll)round(1e7*b), (ll)round(1e7*c) };\n        by_line[_line].insert(i);\n        by_line[_line].insert(j);\n    }\n\n    ll ans = f(N); // (1 << N) - (N+1);\n    for(auto p: by_line){\n        // LINE line = p.first;\n        vector<ll> _line = p.first;\n        set<int> s = p.second;\n        int k = p.second.size();\n#ifdef DEBUG\n        render_line(stderr, line);\n        cerr << \" : \" << s << endl;\n#endif\n        ans = SUB(ans, f(k)); // (1 << k) - (k+1));\n    }\n    return ans;\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    vector<ii> p(N);\n    rep(i,N){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        p[i] = ii(x, y);\n    }\n\n    cout << solve(N,p) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#define re register\n#define maxn 3005\n#define mod 998244353\n#define ll long long\nusing namespace std;\nint n;\nint two[maxn];\nint x[maxn],y[maxn];\n\nvoid init(){\n    two[0]=1;\n    for(re int i=1;i<=3000;i++){\n        two[i]=(two[i-1]*2)%mod;\n    }\n}\n\nint main(){\n    init();\n    scanf(\"%d\",&n);\n    for(re int i=1;i<=n;i++){\n        scanf(\"%d%d\",&x[i],&y[i]);\n    }\n    ll ans=two[n]-n-1;\n    for(re int i=1;i<=n;i++){\n        for(re int j=i+1;j<=n;j++){\n            int sum=0;\n            for(re int k=j+1;k<=n;k++){\n                if((x[i]-x[j])*(y[j]-y[k])==(y[i]-y[j])*(x[j]-x[k])){\n                    sum++;\n                }\n            }\n            ans=((ans-two[sum])%mod+mod)%mod;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int mo=998244353;\nint ksm(int a,int b){\n  int ans=1;\n  while (b){\n\tif (b&1) ans=1ll*ans*a%mo;\n\tb>>=1;a=1ll*a*a%mo;\n  }\n  return ans;\n}\nstruct point {\n  int x,y;\n  point operator-(const point &a){\n   return (point){x-a.x,y-a.y};\n  }\n  bool operator==(const point &a){\n    return x==a.x && y==a.y;\n  }\n};\n\nint cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nvoid add(int &x,int y){\n  x+=y;\n  if (x>=mo) x-=mo;\n  if (x<0) x+=mo;\n}\n\nint dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\nbool cmp(point a,point b){\n   if (a.x==0 && b.x==0) return a.y<b.y;\n   if (a.x==0) return 0;\n   if (b.x==0) return 1;\n   if (cross(a,b)==0) {\n\t if (a.x*b.x<0) return a.x<b.x;\n\t else return dot(a,a)<dot(b,b);\n   }\n   if (a.x<0) {a.x*=-1;a.y*=-1;}\n   if (b.x<0) {b.x*=-1;b.y*=-1;}\n   return cross(a,b)>0;\n}\npoint p[210],t[210];\nint main()\n{\n    int i,j;\n    int n;\n    cin>>n;\n    for (i=1;i<=n;i++) scanf(\"%d %d\",&p[i].x,&p[i].y);\n    int ans=ksm(2,n);\n    add(ans,-1-n);\n    int cnt;\n    for (i=1;i<=n;i++){\n      cnt=0;\n      for (j=1;j<=n;j++){\n        if (j==i) continue;\n        t[cnt++]=p[j]-p[i];\n      }\n      sort(t,t+cnt,cmp);\n      int last=0;\n      for (j=1;j<cnt;j++){\n\t\tif (cross(t[j-1],t[j])){\n\t\t\tif (t[last].x<0 || (t[last].x==0 && t[last].y<0)) {last=j;continue;}\n\t\t\tadd(ans,-(ksm(2,j-last+1)-(j-last+1)-1));\n\t\t\tlast=j;\n\t\t}\n      }\n      if (cnt && !(t[last].x<0 || (t[last].x==0 && t[last].y<0))){\n\t\tadd(ans,-(ksm(2,j-last+1)-(j-last+1)-1));\n      }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[1101];\nint l[1111];\nint j[1];\n\nlong long x,y,z,mod=998244353;\n//string r;\nchar r[1];\n\nP u[1111];\nqueue<int> q;\nstack<P> s;\nvector<int> v[1111];\n\nbool as(P a,P b)\n{\n  return a.x<b.x;\n}\n\nint ccw(P a,P b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n\nint main()\n{\n  scanf(\"%d\",&a);\n  for(int t=1;t<=a;t++)\n  {\n    scanf(\"%d %d\",&n,&m);\n    u[t]={n,m};\n  }\n  o[0]=1;\n  for(int t=1;t<=333;t++)\n  o[t]=o[t-1]*2%mod;\n  x=(o[a]-a-1+mod)%mod;\n  for(int t=1;t<a;t++)\n    for(int w=t+1;w<=a;w++)\n    {\n      int k=0;\n      for(int h=w+1;h<=a;h++)\n        if(ccw({u[t].x-u[h].x,u[t].y-u[h].y},{u[t].x-u[w].x,u[t].y-u[w].y})==0) k++;\n      x-=(o[k]+mod)%mod;\n      x=(x+mod)%mod;\n      //printf(\"%lld\\n\",x);\n    }\n  printf(\"%lld\",x);\n}\n//3\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 202 , P = 998244353;\nint n,pw[N]={1};\npii p[N];\n\nint main(){\n    rep(i,1,N) pw[i]=pw[i-1]*2%P;\n    cin >> n;\n    rep(i,0,n) cin >> p[i].fi >> p[i].se;\n    sort(p , p + n);\n    int ans = (pw[n]+P-1)%P , del = 0;\n    rep(i,0,n) {\n        map<pii,int> vis;\n        rep(j,i+1,n){\n            int dx=p[j].fi-p[i].fi;\n            int dy=p[j].se-p[i].se;\n            if(dx==0) dy=1;\n            else if(dy==0) dx=1;\n            else {\n                int g=__gcd(dx,abs(dy));\n                dx/=g,dy/=g;\n            }\n            vis[mp(dx,dy)]++;\n        }\n        for(auto e : vis) (del += pw[e.se] - 1) %= P;\n        (del += 1) %= P;\n    }\n    (ans += P - del) %= P;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "解説読んだ\n難しい\n2^M→部分集合 の発想\n凸包の中の点の部分集合の個数を凸集合の個数と置き換える\n凸集合の個数は全体-直線集合"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 998244353;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n  unsigned get() const { return x; }\n\n  // 逆数\n  ModInt inv() const {\n    ll a = 1, p = x, e = MOD-2;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // e乗\n  ModInt pow(ll e) {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // 代入\n  void operator=(ll b) { x = b; }\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  // ModInt and ModInt\n  ModInt &operator+=(ModInt that) {\n    x = ((ll)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((ll)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (ll)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (ll)x * that.inv() % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (ll)x % that.x;\n    return *this;\n  }\n  // ModInt and long long\n  // ModInt &operator+=(ll that) {\n  //   x = ((ll)x+that)%MOD;\n  //   return *this;\n  // }\n  // ModInt &operator-=(ll that) {\n  //   x = ((((ll)x-that)%MOD)+MOD)%MOD;\n  //   return *this;\n  // }\n  // ModInt &operator*=(ll that) {\n  //   x = (ll)x * that % MOD;\n  //   return *this;\n  // }\n  // // O(log(mod))かかるので注意\n  // ModInt &operator/=(ll that) {\n  //   x = (ll)x * binpow(that, MOD-2).x % MOD;\n  //   return *this;\n  // }\n  // ModInt &operator%=(ll that) {\n  //   x = (ll)x % that;\n  //   return *this;\n  // }\n  // ModInt and ModInt\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n  // ModInt and ll\n  // ModInt operator+(ll that)const{return ModInt(*this) += that;}\n  // ModInt operator-(ll that)const{return ModInt(*this) -= that;}\n  // ModInt operator*(ll that)const{return ModInt(*this) *= that;}\n  // ModInt operator/(ll that)const{return ModInt(*this) /= that;}\n  // ModInt operator%(ll that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\n\nint x[205], y[205];\nll pw[205];\n\nbool check( int i, int j, int k ) {\n\tif( y[i] > y[j] ) swap(i, j);\n\tif( y[k] < y[i] || y[k] > y[j] ) return false;\n\tif( x[i] > x[j] ) swap(i, j);\n\tif( x[k] < x[i] || x[k] > x[j] ) return false;\n\tint vx = x[k] - x[i], vy = y[k] - y[i];\n\tint wx = x[k] - x[j], wy = y[k] - y[j];\n\treturn vx*wy - vy*wx == 0;\n}\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) cin >> x[i] >> y[i];\n\n  pw[0] = 1;\n  FOR(i, 1, n+1) pw[i] = pw[i-1] * 2 % MOD;\n  mint ret = pw[n] - n - 1;\n  REP(i, n) FOR(j, i+1, n) {\n    int cnt = 0;\n    REP(k, n) if(k!=i && k!=j && check(i,j,k)) ++cnt;\n    ret -= pw[cnt];\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<set>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define pb push_back\n#define fr first\n#define sc second\n\nconst ll M = 998244353;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k%2 == 1){\n\t\tret *= x;\n\t\tret %= M;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint N;\n\tint x[202],y[202];\n\tscanf(\"%d\",&N);\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t}\n\t\n\tll ret = modpow(2,N);\n\tret += M-N-1; if(ret>=M)ret -= M;\n\t\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tfor(int j = i+1 ; j <= N ; j ++){\n\t\t\tll cnt = 0;\n\t\t\tfor(int k = 1 ; k <= N ; k ++){\n\t\t\t\tif(k == i || k == j)continue;\n\t\t\t\tif(x[k] < min(x[i],x[j]))continue;\n\t\t\t\tif(x[k] > max(x[i],x[j]))continue;\n\t\t\t\tif(y[k] < min(y[i],y[j]))continue;\n\t\t\t\tif(y[k] > max(y[i],y[j]))continue;\n\t\t\t\tif((x[k]-x[i])*(y[j]-y[i])-(y[k]-y[i])*(x[j]-x[i]) == 0)cnt ++;\n\t\t\t}\n\t\t\tret += M-modpow(2,cnt); if(ret>=M)ret -= M;\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int mo=998244353;\nint ksm(int a,int b){\n  int ans=1;\n  while (b){\n\tif (b&1) ans=1ll*ans*a%mo;\n\tb>>=1;a=1ll*a*a%mo;\n  }\n  return ans;\n}\nstruct point {\n  int x,y;\n  point operator-(const point &a){\n   return (point){x-a.x,y-a.y};\n  }\n  bool operator==(const point &a){\n    return x==a.x && y==a.y;\n  }\n};\n\nint cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nvoid add(int &x,int y){\n  x+=y;\n  if (x>=mo) x-=mo;\n  if (x<0) x+=mo;\n}\n\nint dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\nbool cmp(point a,point b){\n   if (a.x==0 && b.x==0) return a.y<b.y;\n   if (a.x==0 && a.y<0) return 0;\n   if (b.x==0 && b.y<0) return 1;\n   if (cross(a,b)==0) {\n\t if (a.x*b.x<0) return a.x<b.x;\n\t else return dot(a,a)<dot(b,b);\n   }\n   if (a.x<0) {a.x*=-1;a.y*=-1;}\n   if (b.y<0) {b.x*=-1;b.y*=-1;}\n   return cross(a,b)>0;\n}\npoint p[210],t[210];\nint main()\n{\n    int i,j;\n    int n;\n    cin>>n;\n    for (i=1;i<=n;i++) scanf(\"%d %d\",&p[i].x,&p[i].y);\n    int ans=ksm(2,n);\n    add(ans,-1-n);\n    int cnt;\n    for (i=1;i<=n;i++){\n      cnt=0;\n      for (j=1;j<=n;j++){\n        if (j==i) continue;\n        t[cnt++]=p[j]-p[i];\n      }\n      sort(t,t+cnt,cmp);\n      int last=0;\n      for (j=1;j<cnt;j++){\n\t\tif (cross(t[j-1],t[j])){\n\t\t\tif (t[last].x<0 || (t[last].x==0 && t[last].y<0)) continue;\n\t\t\tadd(ans,-(ksm(2,j-last+1)-(j-last+1)-1));\n\t\t\tlast=j;\n\t\t}\n      }\n      if (cnt && !(t[last].x<0 || (t[last].x==0 && t[last].y<0))){\n\t\tadd(ans,-(ksm(2,j-last+1)-(j-last+1)-1));\n      }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=205;\nstruct Point{\n\tint x,y;\n\tinline Point(int _x,int _y){x=_x;y=_y;}\n\tinline Point(){}\n\tinline void init(){\n\t\tread(x);read(y);\n\t}\n}p[maxn];\ninline Point operator + (const Point &a,const Point &b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\ninline Point operator - (const Point &a,const Point &b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\ninline int cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\nint n;\nconst int mod=998244353;\nint main(){\n\tread(n);\n\trep(i,1,n)p[i].init();\n\ti64 ans=1;\n\trep(i,1,n)ans=2ll*ans%mod;\n\tans=(ans-n+mod)%mod;\n\tans=(ans-1+mod)%mod;\n\trep(i,1,n)rep(j,1,i-1){\n\t\tint sub=1;\n\t\trep(k,1,j-1){\n\t\t\tif(cross(p[k]-p[i],p[j]-p[i])==0)sub=2*sub%mod;\n\t\t}\n\t\tans=(ans-sub+mod)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\ntypedef int long long;\n\nstruct pos\n{\n    int x, y;\n};\n\npos arr[200];\nbool chk[200][200];\n\nconst int mod = 998244353;\nint exp(int a, int x)\n{\n    if(x == 0)\n        return 1;\n    if(x%2)\n        return 1LL * exp(a, x-1) * a % mod;\n    int t = exp(a, x/2);\n    return 1LL * t * t % mod;\n}\n\nint fac[201];\nint caf[201];\ninline int ncr(int n, int r)\n{\n    return 1LL * fac[n] * caf[r] % mod * caf[n-r] % mod;\n}\n\nvector<int> tmp;\n\nint main()\n{\n    //freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n\n    int n, x, y, r, t, i, j, k;\n    scanf(\"%d\", &n);\n    for(i = 0; i<n; i++)\n    {\n        scanf(\"%d%d\", &x, &y);\n        arr[i] = { x, y };\n    }\n\n    fac[0] = 1;\n    for(i = 1; i<=200; i++)\n        fac[i] = 1LL * fac[i-1] * i % mod;\n\n    for(i = 0; i<=200; i++)\n        caf[i] = exp(fac[i], mod-2);\n\n    r = 0;\n    for(i = 3; i<=n; i++)\n        r = (r + ncr(n, i)) % mod;\n\n    for(i = 0; i<n-1; i++)\n    {\n        for(j = i+1; j<n; j++)\n        {\n            if(chk[i][j] || chk[j][i])\n                continue;\n\n            tmp.clear();\n\n            tmp.push_back(i);\n            tmp.push_back(j);\n\n            t = 2;\n            for(k = 0; k<n; k++)\n            {\n                if(k == i || k == j)\n                    continue;\n\n                if(1LL * (arr[i].y - arr[j].y) * (arr[i].x - arr[k].x) != 1LL * (arr[i].x - arr[j].x) * (arr[i].y - arr[k].y))\n                    continue;\n\n                tmp.push_back(k);\n                t++;\n            }\n\n            for(int ii = 0; ii<t-1; ii++)\n                for(int jj = ii+1; jj<t; jj++)\n                    chk[ii][jj] = 1;\n\n            for(k = 3; k<=t; k++)\n                r = (r + (mod - ncr(t, k))) % mod;\n        }\n    }\n\n    printf(\"%d\\n\", r);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nint x[205],y[205],cnt[205][205][205],oncnt[205][205];;\nP p[205];\nbool cc[205][205][205],on[205][205][205];\nint ccw(int aa,int ab,int ac)\n{\n    P a=p[aa],b=p[ab],c=p[ac];\n\tll aaa =  1LL*(b.fi-a.fi)*(c.sc-a.sc)-1LL*(b.sc-a.sc)*(c.fi-a.fi);\n\tif(aaa==0) return -1;\n\tif(aaa>0) return 1;\n\telse return 0;\n}\nll dp[205][205][205],t[205];\nint main(){\n\tsrand((unsigned)time(NULL));\n\tcin>>n;\n\trepn(i,n){\n\t\tcin>>x[i]>>y[i];\n\t\tp[i]=mp(x[i],y[i]);\n\t}\n\tsort(p+1,p+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(i==j||j==k||k==i)continue;\n\t\t\t\tcc[i][j][k] = ccw(i,j,k)==1;\n\t\t\t\tif(ccw(i,j,k) == -1 && min(x[i],x[j])<=x[k] && min(y[i],y[j])<=y[k]  && max(x[i],x[j])>=x[k] && max(y[i],y[j])>=y[k]){\n\t\t\t\t\ton[i][j][k] = 1;\n\t\t\t\t\toncnt[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tvector<pair<double,int> >vi;\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint a = x[j]-x[i],b = y[j]-y[i];\n\t\t\tdouble A = (double)(a),B = (double)(b);\n\t\t\tvi.pb(mp(atan2(B,A),j));\n\t\t}\n\t\tSORT(vi);\n\t\tfor(int j=0;j<vi.size();j++){\n\t\t\tfor(int k=j+1;k<vi.size();k++){\n\t\t\t\tfor(int a=i+1;a<max(vi[j].sc,vi[k].sc);a++){\n\t\t\t\t    if(i==a||vi[j].sc==a||vi[k].sc==a)continue;\n\t\t\t\t\tbool add = 0;\n\t\t\t\t\tadd |= on[i][vi[j].sc][a];\n\t\t\t\t\tadd |= on[vi[k].sc][vi[j].sc][a];\n\t\t\t\t\tadd |= on[i][vi[k].sc][a];\n\t\t\t\t\tadd |= (cc[i][vi[j].sc][a]&&cc[vi[j].sc][vi[k].sc][a]&&cc[vi[k].sc][i][a]);\n\t\t\t\t\tadd |= (cc[vi[j].sc][i][a]&&cc[vi[k].sc][vi[j].sc][a]&&cc[i][vi[k].sc][a]);\n\t\t\t\t\tcnt[i][vi[j].sc][vi[k].sc]+=add;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tt[0]=1LL;\n\tfor(int i=1;i<205;i++) t[i]=t[i-1]*2LL%mod;\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tvector<pair<double,int> >vi;\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint a = x[j]-x[i],b = y[j]-y[i];\n\t\t\tdouble A = (double)(a),B = (double)(b);\n\t\t\tvi.pb(mp(atan2(B,A),j));\n\t\t}\n\t\tSORT(vi);//cout<<vi[0].sc<<vi[1].sc<<endl;\n\t\tfor(int j=1;j<vi.size();j++){\n\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\tint a = cnt[i][vi[k].sc][vi[j].sc]-oncnt[vi[k].sc][i];\n\t\t\t\tll A = t[a];\n\t\t\t\tfor(int x=0;x<k;x++){\n\t\t\t\t\tif(cc[vi[x].sc][vi[k].sc][vi[j].sc]) dp[i][k][j]+=dp[i][x][k]*A%mod;\n\t\t\t\t}\n\t\t\t\tif(cc[i][vi[k].sc][vi[j].sc]) dp[i][k][j]+=t[cnt[i][vi[k].sc][vi[j].sc]];\n\t\t\t\tdp[i][k][j]%=mod;\n\t\t\t\tif(cc[vi[k].sc][vi[j].sc][i]) {ans += dp[i][k][j];}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n#define MOD 998244353\n \nint x[205], y[205], p[205];\n \nint main(void)\n{\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d%d\", &x[i], &y[i]);\n    p[0] = 1;\n    for (int i = 0; i < n; i++)\n        p[i + 1] = (p[i] << 1) % MOD;\n    int ans = p[n] - n - 1;// 要组成凸多边形 所有情况减去取一个点的情况减去都不取的情况\n  //  cout<<p[n]<<endl;\n    for (int i = 0; i < n; i++) {//固定两个点枚举其他点\n        for (int j = 0; j < i; j++) {\n            int cnt = 0;\n            for (int k = 0; k < j; k++) {\n                if ((x[i] - x[j]) * (y[i] - y[k]) == (x[i] - x[k]) * (y[i] - y[j]))//斜率相等 共线\n                    cnt++;\n            }\n            ans =(ans-p[cnt]+MOD)%MOD;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int MAXN = 200 + 10;\nconst int MOD = 998244353;\n\nstruct TPoint\n{\n\tlong long x, y;\n};\n\nlong long CrossProduct(TPoint A, TPoint B, TPoint C)\n{\n\treturn (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);\n}\n\nint n;\nlong long twomod[MAXN];\nlong long C[MAXN][MAXN];\nlong long arr[MAXN];\nTPoint p[MAXN];\nint used[MAXN];\nint redu[MAXN];\n\nvoid Work()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i ++)\n\t\tscanf(\"%lld%lld\", &p[i].x, &p[i].y);\n\ttwomod[0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\ttwomod[i] = (twomod[i - 1] + twomod[i - 1]) % MOD;\n\tC[0][0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tC[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j ++)\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n\t}\n\n\tfor (int tt = 3; tt <= n; tt ++)\n\t{\n\t\tarr[tt] = 0;\n\t\tfor (int i = 3; i <= tt; i ++)\n\t\t\tarr[tt] = (arr[tt] + C[tt][i]) % MOD;\n\t}\n\n\tlong long ans = arr[n];\n\t\n\tfor (int i = 0; i < n; i ++)\n\t\tfor (int j = 0; j < n; j ++) if (i != j)\n\t\t{\n\t\t\tlong long c = 2;\n\t\t\tfor (int k = 0; k < n; k ++) if (i != k && j != k)\n\t\t\t\tif (CrossProduct(p[i], p[j], p[k]) == 0)\n\t\t\t\t\tc ++;\n\t\t\t//printf(\"%d %d %d\\n\", i, j, c);\n\t\t\tredu[c] ++;\n\t\t}\n\n\tfor (int c = 3; c <= n; c ++)\n\t{\n\t\tif (redu[c] == 0) continue;\n\t\tlong long times = redu[c] / (c * (c - 1));\n\t\tans -= (arr[c] * times) % MOD;\n\t\tans += MOD;\n\t\tans %= MOD;\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int, int>\n#define fir first\n#define sec second\nusing namespace std;\nconst int mod = 998244353;\ninline int mul(int x, int y) {return (ll)x * y % mod;}\ninline int add(int x, int y) {return x + y >= mod ? x + y - mod : x + y;}\ninline int sub(int x, int y) {return x >= y ? x - y : x - y + mod;}\nint mi[201];\ninline int cal(int x)\n{\n    if (x <= 2) return 0;\n    return sub(mi[x], add(1, add(x, x * (x - 1) / 2)));\n}\nint n, x[201], y[201];\npii get(int i, int j)\n{\n    int a = x[i] - x[j], b = y[i] - y[j];\n    int g = __gcd(a, b);\n    a /= g; b /= g;\n    return {a, b};\n}\nint main()\n{\n    scanf(\"%d\", &n); mi[0] = 1;\n    for (int i = 1; i <= n; i++) \n    {\n        scanf(\"%d%d\", &x[i], &y[i]);\n        mi[i] = mul(mi[i - 1], 2);\n    }\n    int ans = cal(n);\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++)\n        {\n            pii v1 = get(i, j);\n            int cnt = 0;\n            for (int k = j + 1; k <= n; k++) if (v1 == get(i, k)) cnt++;\n            ans = sub(ans, sub(mi[cnt], 1));\n        }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define LL long long\nconst int N = 211;\nconst int mod = 998244353;\nint n;\nLL base[N];\n\nstruct ddd {\n\tint x, y;\n}nd[N];\n\nLL sq(LL x) { return x * x; }\n\nbool check(LL x1, LL y1, LL x2, LL y2) {\n\tLL a = x1 * x2 + y1 * y2;\n\tLL b = (sq(x1) + sq(y1)) * (sq(x2) + sq(y2));\n\treturn a > 0 && b == sq(a);\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", &nd[i].x, &nd[i].y);\n\t}\n\tbase[0] = 1;\n\tfor (int i = 1; i <= 200; i++)base[i] = base[i - 1] * 2 % mod;\n\tLL ans = (base[n] - 1 - n + mod) % mod;\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tint tot = 0;\n\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\tif (i == k || j == k)continue;\n\t\t\t\tif (check(nd[i].x - nd[k].x, nd[i].y - nd[k].y, nd[k].x - nd[j].x, nd[k].y - nd[j].y))tot++;\n\t\t\t}\n\t\t\tans = (ans + mod - base[tot]) % mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 255;\nconst int mod = 998244353;\nstruct node\n{\n    int x,y;\n};\nnode a[maxn];\nint cf[maxn];\nint n;\nint ans;\nvoid init()\n{\n    cf[0]=1;\n    for(int i=0;i<n;i++)\n    {\n        cf[i+1]=(cf[i]*2)%mod;\n    }\n    ans=cf[n]-(n+1);\n}\nint main()\n{\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        cin>>a[i].x>>a[i].y;\n    }\n    init();\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<i;j++)\n        {\n            int tot=0;\n            for(int k=0;k<j;k++)\n            {\n                int l1=(a[i].x-a[j].x)*(a[i].y-a[k].y);\n                int l2=(a[i].x-a[k].x)*(a[i].y-a[j].y);\n                if(l1==l2)\n                    tot++;\n            }\n            ans-=cf[tot];\n            ans+=mod;\n            ans%=mod;\n        }\n\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ARC082\n// E - ConvexScore\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n\nconst int MAX_N = 200;\nconst int MOD = 998244353;\n\nint gcd(int a, int b) { return (b == 0) ? a : gcd(b, a % b); }\n\nint N;\nint x[MAX_N], y[MAX_N];\nint p2[MAX_N + 1], lc[MAX_N + 1];\n\nint main() {\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    p2[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        p2[i] = (2 * p2[i - 1]) % MOD;\n    }\n\n    memset(lc, 0, sizeof(lc));\n    for (int i = 0; i < N; i++) {\n        map<pii, int> slope;\n        for (int j = 0; j < N; j++) {\n            if (i == j) {\n                continue;\n            }\n            int dx = x[i] - x[j];\n            int dy = y[i] - y[j];\n            if (dx < 0) {\n                dx *= -1;\n                dy *= -1;\n            }\n            if (dx == 0) {\n                dy = 1;\n            } else if (dy == 0) {\n                dx = 1;\n            } else {\n                int d = gcd(dx, abs(dy));\n                dx /= d;\n                dy /= d;\n            }\n            slope[pii(dx, dy)]++;\n        }\n        for (auto &p : slope) {\n            lc[p.second + 1]++;\n        }\n    }\n\n    int ans = (p2[N] + MOD - (1 + N + N * (N - 1) / 2)) % MOD;\n    for (int i = 3; i <= N; i++) {\n        int sel =\n            1LL * (MOD - p2[i] + (1 + i + i * (i - 1) / 2)) * (lc[i] / i) % MOD;\n        (ans += sel) %= MOD;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 998244353\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,i,j,k,x[205],y[205],sum,ans;\nlong long ksm(long long u,long long v){\n\tlong long o=1;\n\twhile(v){\n\t\tif(v&1)\n\t\t\to=o*u%mo;\n\t\tu=u*u%mo;\n\t\tv>>=1;\n\t}\n\treturn o;\n}\nint main(){\n    //freopen(\"teleports.in\",\"r\",stdin);\n    //freopen(\"teleports.out\",\"w\",stdout);\n    n=read();\n    for(i=1;i<=n;i++){\n    \tx[i]=read();\n    \ty[i]=read();\n    }\n    for(i=1;i<=n;i++)\n    \tfor(j=i+1;j<=n;j++){\n    \t\tsum=0;\n    \t\tfor(k=1;k<=n;k++)\n\t\t\t\tif(x[i]==x[j]&&x[i]==x[k]||x[i]==x[k]&&y[i]==y[k]||x[j]==x[k]&&y[j]==y[k]){\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t\telse if(x[i]!=x[j]&&x[i]!=x[k]&&x[j]!=x[k]){\n\t\t\t\t\tif((y[j]-y[i])*(x[k]-x[i])==(y[k]-y[i])*(x[j]-x[i]))\n\t\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\tans=(ans+(ksm(2,sum)-sum-1+mo)%mo*ksm(sum*(sum-1)/2,mo-2))%mo;\n\t\t}\n\tans=((ksm(2,n)-ans-n-1)%mo+mo)%mo;\n\tpus(ans,2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define X first\n#define Y second\n#define pii pair<ll,ll>\n#define x1 dlfjl\n#define x2 dkfj\n#define MOD 998244353\n#define y1 dskgj\n#define y2 dskfj\n#define N 310\ntypedef long long ll;\nusing namespace std;\nll n,i,j,k,x,y,z,m,q,w,h;\nll a[100500], b[100500], pre[1005000], C[205][205];\nmap<pair<pii,pii>,ll> f;\nll gcd(ll a, ll b)\n{\n    return (b==0?a:gcd(b,a%b));\n}\nll Abs(ll x)\n{\n    return (x>0?x:-x);\n}\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    for (i = 0; i <= 1000; i++)\n        pre[i*(i+1)/2] = i+1;\n    for (i = 0; i <= 200; i++)\n        C[i][0] = 1;\n    for (i = 1; i <= 200; i++)\n        for (j = i; j <= 200; j++)\n            C[j][i] = (C[j-1][i-1] + C[j-1][i])%MOD;\n    ll ans = 1;\n    cin >> n;\n    if (n < 3)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    for (i = 1; i <= n; i++)\n        ans = (ans*2)%MOD;\n    ans -= n+1;\n    ans -= n*(n-1)/2;\n    ans += MOD;\n    ans %= MOD;\n    for (i = 0; i < n; i++)\n        cin >> a[i] >> b[i];\n    for (i = 0; i < n; i++)\n        for (j = i+1; j < n; j++)\n        {\n            if (a[i] == a[j])\n            {\n                f[mp(mp(0,a[i]),mp(MOD,MOD))]++;\n                continue;\n            }\n            int p = a[i]-a[j];\n            int q = b[i]-b[j];\n            int g = gcd(Abs(p), Abs(q));\n            p /= g;\n            q /= g;\n            if ( p < 0)\n                p = -p, q = -q;\n            int x1 = a[i], y1 = b[i], x2 = a[j], y2 = b[j];\n            int xx = y1*(x2-x1)-x1*(y2-y1);\n            int yy = x2-x1;\n            int gg = gcd(Abs(xx), Abs(yy));\n            xx /= gg;\n            yy /= gg;\n            if ( xx < 0)\n                xx = -xx, yy = -yy;\n            f[mp(mp(p,q),mp(xx,yy))]++;\n        }\n    for (auto itr = f.begin(); itr != f.end(); itr++)\n    {\n        int val = (*itr).Y;\n        val = pre[val];\n        for (j = 3; j <= val; j++)\n        {\n            ans -= C[val][j];\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 205\n#define mod 998244353\nint x[maxn],y[maxn];\nint pow(int a,int n)\n{\n    if(n==0)return 1;\n    int res=pow(a,n/2);\n    res=res*res%mod;\n    if(n&1)res=res*a%mod;\n    return res;\n}\nint add(int &a,int b)\n{\n    a+=b;\n    if(a>=mod)a%=mod;\n}\nmain()\n{\n    int n;scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n    int ans=pow(2,n);\n    add(ans,mod-1),add(ans,mod-n),add(ans,mod-n*(n-1)/2);\n    for(int i=1;i<n;i++)for(int j=i+1;j<=n;j++)\n    {\n        int cnt=2;\n        int a=y[j]-y[i],b=x[i]-x[j],c=-a*x[i]-b*y[i];\n        for(int k=1;k<=n;k++)\n        {\n            if(k==i || k==j)continue;\n            int s=a*x[k]+b*y[k]+c;\n            if(s!=0)continue;\n            if(k<j)break;\n            cnt++;\n        }\n        add(ans,mod-pow(2,cnt));\n        add(ans,1);\n        add(ans,cnt);\n        add(ans,cnt*(cnt-1)/2);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <string>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <random>\n#include <chrono>\nusing namespace std;\n\nint n;\nconst int maxn = 205;\n\nstruct P{\n    int x, y;\n    P(){}\n    P(int _x, int _y):x(_x), y(_y){}\n    P operator - (P p){return P(x-p.x, y-p.y);}\n    int det(P p){return x * p.y - y * p.x;}\n    void read(){\n        cin >> x >> y;\n    }\n}p[maxn], p1[maxn];\n\nconst int mod = 998244353;\n\nbool cmp(P a, P b){\n    return a.det(b) < 0; \n}\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nvoid sub(int &a, int b){\n    a -= b;\n    if(a < 0)\n        a += mod;\n}\n\nint qpow(int a, int n){\n    int ret = 1;\n    while(n > 0){\n        if(n & 1)\n            ret = 1LL * ret * a % mod;\n        a = 1LL * a * a % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint main(){\n    cin >> n;\n    for(int i = 1;i <= n;i++){\n        p[i].read();\n    }\n    int ans = qpow(2, n);\n    sub(ans, 1);\n    sub(ans, n);\n    sub(ans, n * (n - 1) / 2);\n    for(int i = 1;i <= n;i++){\n        for(int j = i + 1;j <= n;j++){\n            int num = 0;\n            for(int k = j + 1;k <= n;k++){\n                if((p[i] - p[j]).det(p[j] - p[k]) == 0){\n                    num++;\n                }\n            }\n            int tmp = qpow(2, num);\n            sub(tmp, 1);\n            sub(ans, tmp);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/** @Date    : 2017-09-02 20:30:47\n  * @FileName: C.cpp\n  * @Platform: Windows\n  * @Author  : Lweleth (SoungEarlf@gmail.com)\n  * @Link    : https://github.com/\n  * @Version : $Id$\n  */\n#include <bits/stdc++.h>\n#define LL long long\n#define PII pair<int ,int>\n#define MP(x, y) make_pair((x),(y))\n#define fi first\n#define se second\n#define PB(x) push_back((x))\n#define MMG(x) memset((x), -1,sizeof(x))\n#define MMF(x) memset((x),0,sizeof(x))\n#define MMI(x) memset((x), INF, sizeof(x))\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 210;\nconst double eps = 1e-8;\nconst LL mod = 998244353;\n\nLL fa[210], inv[210];\n\nLL fpow(LL a, int n)\n{\n    LL r = 1;\n    while(n > 0)\n    {\n        if(n & 1)\n            r = r * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return r;\n}\nvoid init()\n{\n    fa[0] = 1;\n    inv[0] = 1;\n    for(LL i = 1; i <= 200; i++)\n    {\n        fa[i] = fa[i-1] * i % mod;\n        inv[i] = fpow(fa[i], mod - 2);\n    }\n}\n\nLL C(LL n, LL m)\n{\n    if(n < 0)\n        return 0;\n    n >>= 1;\n    if(n == 0)\n    \treturn 1LL;\n    LL ans = 0;\n    ans = ((fa[n + m] * inv[m] % mod)* inv[n]) % mod;\n    return ans;\n}\n\n\nstruct point\n{\n\tdouble x, y;\n\tpoint(){}\n\tpoint(double _x, double _y){x = _x, y = _y;}\n\tpoint operator -(const point &b) const\n\t{\n\t\treturn point(x - b.x, y - b.y);\n\t}\n\tdouble operator *(const point &b) const \n\t{\n\t\treturn x * b.x + y * b.y;\n\t}\n\tdouble operator ^(const point &b) const\n\t{\n\t\treturn x * b.y - y * b.x;\n\t}\n};\n\ndouble xmult(point p1, point p2, point p0)  \n{  \n    return (p1 - p0) ^ (p2 - p0);  \n}  \n\ndouble distc(point a, point b)\n{\n\treturn sqrt((double)((b - a) * (b - a)));\n}\nint sign(double x)\n{\n\tif(fabs(x) < eps)\n\t\treturn 0;\n\tif(x < 0)\n\t\treturn -1;\n\telse \n\t\treturn 1;\n}\n\n////////\nint n;\npoint stk[N];\npoint p[N];\n\nint cmpC(point a, point b)//水平序排序\n{\n\treturn sign(a.x - b.x) < 0 || (sign(a.x - b.x) == 0 && sign(a.y - b.y) < 0);\n}\n\nint Graham()//水平序\n{\n\tsort(p, p + n, cmpC);\n\tint top = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\twhile(top >= 2 && sign(xmult(stk[top - 2], stk[top - 1], p[i])) < 0)\n\t\t\ttop--;\n\t\tstk[top++] = p[i];\n\t}\n\tint tmp = top;\n\tfor(int i = n - 2; i >= 0; i--)\n\t{\n\t\twhile(top > tmp && sign(xmult(stk[top - 2],stk[top - 1] ,p[i] )) < 0)\n\t\t\ttop--;\n\t\tstk[top++] = p[i];\n\t}\n\tif(n > 1)\n\t\ttop--;\n\treturn top;\n}\n\n\nint check(int m)\n{\n\t//cout << m << endl;\n\tLL c = 2;\n\tLL t = 0;\n\tfor(int i = 1; i < m; i++)\n\t{\n\t\tif(sign(xmult(stk[i - 1], stk[(i + 1)%(m)], stk[i])) == 0)\n\t\t\tc++;\n\t\telse if(c > 2) t = (t + fpow(2, c) - (1LL + c + c * (c - 1) / 2LL) + mod) % mod, c = 2;\n\t}\n\tif(c > 2)\n\t\t t = (t + fpow(2, c) - (1LL + c + c * (c - 1) / 2LL) + mod) % mod;\n\treturn t;\n}\n/////////\nint main()\n{\n\n\twhile(~scanf(\"%d\", &n))\n\t{\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tp[i] = point(x, y);\n\t\t}\n\t\tLL cnt = Graham();\n\t\t//cout << cnt;\n\t\tLL ans = (fpow(2, n) - check(cnt) - (1LL + n + (n - 1) * n / 2LL) + mod) % mod;\n\t\twhile(ans < 0)\n\t\t\tans += mod;\n\t\tif(cnt > 2)\n\t\t\tprintf(\"%lld\\n\", ans);\n\t\telse printf(\"0\\n\");\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<ll> pt;\n\nstruct rational {\n  ll n, d;\n};\n\nll gcd(ll a, ll b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n  return a * (b / gcd(a, b));\n}\n\nrational operator*(const rational &a, const rational &b) {\n  rational res = rational {a.n * b.n, a.d * b.d};\n  ll g = gcd(res.n, res.d);\n  res.n /= g;\n  res.d /= g;\n  return res;\n}\n\nrational operator/(const rational &a, const rational &b) {\n  rational res = rational {a.n * b.d, a.d * b.n};\n  ll g = gcd(res.n, res.d);\n  res.n /= g;\n  res.d /= g;\n  return res;\n}\n\nrational operator-(const rational &a, const rational &b) {\n  ll l = lcm(a.d, b.d);\n  ll f1 = l / a.d;\n  ll f2 = l / b.d;\n  return rational {a.n * f1 - b.n * f2, l};\n}\n\nbool operator<(const rational &a, const rational &b)  {\n  if (a.n != b.n) return a.n < b.n;\n  return a.d < b.d;\n}\n\nbool operator!=(const rational &a, const rational &b) {\n  return a < b || b < a;\n}\n\nbool operator==(const rational &a, const rational &b) {\n  return !(a != b);\n}\n\nstruct line {\n  rational a, b, c;\n};\n\nline pointsToLine(pt p1, pt p2) {\n  line l;\n  if (p1.real() == p2.real()) {\n    l.a = rational {1, 1};\n    l.b = rational {0, 1};\n    l.c = rational {-p1.real(), 1};\n  } else {\n    l.a = rational {-p1.imag() + p2.imag(), 1} / rational {p1.real() - p2.real(), 1};\n    l.b = rational {1, 1};\n    l.c = l.a * rational {p1.real(), 1} - rational {p1.imag(), 1};\n  }\n  return l;\n}\n\nbool areParallel(line l1, line l2) {\n  return l1.a == l2.a && l1.b == l2.b;\n}\n\nbool operator==(const line &l1, const line &l2) {\n  return areParallel(l1, l2) && l1.c == l2.c;\n}\n\nbool operator<(const line &l1, const line &l2) {\n  if (l1.a != l2.a) return l1.a < l2.a;\n  if (l1.b != l2.b) return l1.b < l2.b;\n  return l1.c < l2.c;\n}\n\nmap<line, int> counter;\nint powers2[201];\n\nint invTri(int x) {\n  return ((int)sqrt(8 * x + 1) + 1) / 2;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pt> points(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    points[i] = pt(x, y);\n  }\n  sort(points.begin(), points.end(), [](const pt &a, const pt &b) {\n    if (a.real() == b.real()) return a.imag() < b.imag();\n    return a.real() < b.real();\n  });\n\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      counter[pointsToLine(points[i], points[j])]++;\n    }\n  }\n\n  powers2[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    powers2[i] = (2 * powers2[i - 1]) % MOD;\n  }\n\n  int colSubs = n;\n  for (auto slope : counter) {\n    int onLine = invTri(slope.second);\n    colSubs += powers2[onLine] - onLine - 1;\n    colSubs %= MOD;\n  }\n\n  printf(\"%d\\n\", (powers2[n] - colSubs - 1 + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n\t\t//return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) >  EPS)   return +1;      // counter clockwise\n\tif(cross(b, c) < -EPS)   return -1;      // clockwise\n\tif(dot(b, c)   < -EPS)   return +2;      // c--a--b on line\n\tif(norm(b)+EPS <norm(c)) return -2;      // a--b--c on line\n\treturn 0;                                   // c is between a and b (inclusive)\n}\nint n;\nint on[200][200];\nbool can[200][200][200];\n\nint dp[200][200];\nll pw[201];\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tconst int mod = 998244353;\n\tpw[0] = 1;\n\trep(i, 200) pw[i + 1] = pw[i] * 2 % mod;\n\t\n\tcin >> n;\n\tG g;\n\trep(i, n){\n\t\tint x, y; cin >> x >> y;\n\t\tg.emplace_back(x, y);\n\t}\n\tif(n < 3){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\t\n\tll ans = pw[n] - n - 1 + 2 * mod;\n\trep(i, n) for(int j = i + 1; j < n; j++){\n\t\tvi v;\n\t\tint sz;\n\t\trep(k, n) if(k != i && k != j && abs(cross(g[k] - g[i], g[j] - g[i])) < EPS){\n\t\t\tif(k < j) goto SKIP;\n\t\t\tv.pb(k);\n\t\t}\n\t\t\n\t\tsz = v.size() + 2;\n\t\tans += mod - pw[sz] + sz + 1;\n\t\t\n\t\t//dbg(sz, pw[sz] - sz - 1, i, j, v);\n\t\tSKIP:;\n\t}\n\tcout << ans % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\ninline int qpow(int bas,int pw)\n{\n\tint ans=1; for(;pw;pw>>=1,bas=1ll*bas*bas%mod)\n\t\tif(pw&1) ans=1ll*ans*bas%mod; return ans;\n}\nint xx[300],yy[300],Ans;\nmap <int,int> M;\nint main()\n{\n\tint n=read(); for(int i=1;i<=n;i++)\n\t\txx[i]=read(), yy[i]=read();\n\tAns=qpow(2,n)-n-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tM.clear();\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint tx=(1ll*(yy[j]-yy[i])*qpow((xx[j]-xx[i]),mod-2)%mod+mod)%mod;\n\t\t\tif(xx[j]==xx[i]) tx=-1;\n\t\t\tM[tx]++;\n\t\t}\n\t\tfor(map<int,int> :: iterator it=M.begin();it!=M.end();it++)\n\t\t\t(Ans-=qpow(2,it -> second)-1)%=mod;\n\t}\n\tcout << (Ans%mod+mod)%mod << endl;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=205,mo=998244353;\nint n,x,i,dn,pw[N],ans;\nstruct arr{int x,y;}a[N],d[N];\nint cross(arr A,arr B){return A.x*B.y-B.x*A.y;}\nbool operator < (arr A,arr B){return cross(A,B)>0;}\nint main(){\n\tfor (scanf(\"%d\",&n),i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfor (pw[0]=1,i=1;i<=n;i++) pw[i]=pw[i-1]*2%mo;\n\tans=pw[n]-1-n;\n\tfor (int x=1;x<=n;x++){\n\t\tfor (dn=0,i=x+1;i<=n;i++) if (i!=x){\n\t\t\td[++dn]=(arr){a[i].x-a[x].x,a[i].y-a[x].y};\n\t\t\tif (d[dn].x<0) d[dn].x=-d[dn].x,d[dn].y=-d[dn].y;\n\t\t\tif (d[dn].x==0&&d[dn].y>0) d[dn].y=-d[dn].y;\n\t\t}\n\t\tsort(d+1,d+dn+1);int k=0;\n\t\tfor (i=1;i<=dn;i++){\n\t\t\tif (!cross(d[i-1],d[i])) k++;\n\t\t\telse ans=(ans-pw[k]+1)%mo,k=1;\n\t\t}\n\t\tans=(ans-pw[k]+1)%mo;\n\t}\n\tprintf(\"%d\",(ans+mo)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <cmath>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\ntypedef tuple<int, int, int> line;\n\nint gcd(int a, int b){\n    if(a == 0) return b;\n    if(b == 0) return a;\n    if(a < 0) a *= -1;\n    if(b < 0) b *= -1;\n    if(a < b) swap(a, b);\n    while(b != 0){\n        int tmp = b;\n        b = a%b;\n        a = tmp;\n    }\n    return a;\n}\n\nline norm(line l){\n    int a = get<0>(l);\n    int b = get<1>(l);\n    int c = get<2>(l);\n    if(a < 0){\n        a *= -1;\n        b *= -1;\n        c *= -1;\n    }\n    int m = gcd(a, b);\n    m = gcd(m, c);\n    return make_tuple(a/m, b/m, c/m);\n}\n\nline calc_line(int x1, int y1, int x2, int y2){\n    line ans = make_tuple(y2-y1, -(x2-x1), y1*x2-x1*y2);\n    ans = norm(ans);\n    return ans;\n}\n\nlong pow2[201];\n\nvoid init(){\n    pow2[0] = 1;\n    for(int i = 1; i <= 200; i++){\n        pow2[i] = 2*pow2[i-1];\n        pow2[i] %= MOD;\n    }\n}\n\nvoid print_line(line l){\n    cout << get<0>(l) << ' ' << get<1>(l) << ' ' << get<2>(l) << endl;\n}\n\nint main(){\n    init();\n    map<line, int> mp;\n    int N;\n    cin >> N;\n    int x[200], y[200];\n    for(int i = 0; i < N; i++) cin >> x[i] >> y[i];\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < i; j++){\n            line l = calc_line(x[i], y[i], x[j], y[j]);\n            if(mp.count(l) == 0){\n                mp[l] = 1;\n            }else{\n                mp[l]++;\n            }\n        }\n    }\n    long ans = pow2[N];\n    ans -= (1+N);\n    for(auto iter = mp.begin(); iter != mp.end(); iter++){\n        int m = iter-> second;\n        m = ((int)sqrt(2*m))+1;\n       // cout << m << endl;\n        ans -= (pow2[m]-m-1);\n        ans %= MOD;\n        ans += MOD;\n        ans %= MOD;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 205;\nconst int MOD = 998244353;\n\nint N;\nint x[MAXN], y[MAXN];\nint pot[MAXN];\n\nvoid load() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; i++)\n\t\tscanf(\"%d%d\", x + i, y + i);\n}\n\ninline int add(int x, int y) {\n\tx += y;\n\tif (x >= MOD)\t\n\t\tx -= MOD;\n\telse if (x < 0)\n\t\tx += MOD;\n\treturn x;\n}\n\nint ccw(int a, int b, int c) {\n\treturn x[a] * (y[b] - y[c]) + x[b] * (y[c] - y[a]) + x[c] * (y[a] - y[b]);\n}\n\nbool in_range(int a, int b, int c) {\n\treturn c >= min(a, b) && c <= max(a, b);\n}\n\nint solve() {\n\tpot[0] = 1;\n\tfor (int i = 1; i <= N; i++)\n\t\tpot[i] = add(pot[i - 1], pot[i - 1]);\t\n\t\n\tint sol = add(pot[N], -N - 1);\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\tcnt += k != i && k != j && !ccw(i, j, k) && in_range(x[i], x[j], x[k]) && in_range(y[i], y[j], y[k]);\n\t\t\tsol = add(sol, -pot[cnt]);\n\t\t}\n\t\n\treturn sol;\n}\n\nint main() {\n\tload();\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr size_t print_limit = 10;\n\ntemplate <typename It>\nvoid print(ostream& os, It begin, It end, size_t len) {\n    size_t count = 0;\n    os << \"{\";\n    while (begin != end && count < print_limit) {\n        os << \"(\" << *begin << \")\";\n        count++;\n        begin++;\n    }\n    if (print != end)\n        os << \"... \" << len << \" total\";\n    os << \"}\";\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& t) {\n    print(os, t.begin(), t.end(), t.size());\n    return os;\n}\n\nconstexpr size_t MAXX = 10000;\n\nstruct P {\n    int64_t x;\n    int64_t y;\n};\n\nnamespace std {\ntemplate<>\nstruct hash<P> {\n    size_t operator()(const P& p) const {\n        auto h = hash<int64_t>();\n        return 13 + h(p.x) ^ h(p.y);\n   }\n};\n} // std\n\nstruct L {\n    P a;\n    P b;\n};\n\nnamespace std {\ntemplate<>\nstruct hash<L> {\n    size_t operator()(const L& l) const {\n        auto h = hash<P>();\n        return 42 + h(l.a) ^ h(l.b); \n    }\n};\n} // std\n\nbool operator==(P p1, P p2) { return p1.x == p2.x && p1.y == p2.y; }\n\nbool operator==(L l1, L l2) { return l1.a == l2.a && l1.b == l2.b; }\n\nbool parallel_line(P p1, P p2, P p3, P p4) {\n    auto x1 = p2.x - p1.x, x2 = p4.x - p3.x, y1 = p2.y - p1.y, y2 = p4.y - p3.y;\n    return x1 * y2 == x2 * y1; \n}\n\nbool same_line(P p1, P p2, P p3) {\n    return parallel_line(p1, p2, p1, p3);\n}\n\n\nconstexpr int64_t MODP = 998244353;\n\nint main () {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    vector<P> v;\n    {\n        size_t n;\n        cin >> n;\n        while (n--) {\n            P p;\n            cin >> p.x >> p.y;\n            v.push_back(p);\n        }\n    }\n    \n    unordered_set<L> lines;\n\n    size_t ans = 1;\n    for (size_t i = 0; i < v.size(); i++)\n        ans = ans * 2 % MODP;\n    ans = (ans + MODP - v.size() - 1) % MODP; // 0 and 1-sized\n\n    for (size_t i = 0; i < v.size(); i++) {\n        for (size_t j = i + 1; j < v.size(); j++) {\n            if (lines.find(L{v[i], v[j]}) == lines.end()) {\n                vector<P> line = {v[i], v[j]};\n                for (size_t k = j + 1; k < v.size(); k++)\n                    if (same_line(v[i], v[j], v[k]))\n                        line.push_back(v[k]);\n                for (size_t k = 0; k < line.size(); k++)\n                    for (size_t l = k + 1; l < line.size(); l++)\n                        lines.insert(L{line[k], line[l]});\n//                cerr << \"line of size \" << line.size() << endl; \n                size_t pw = 1;\n                for (size_t k = 0; k < line.size(); k++)\n                    pw = pw * 2 % MODP;\n                ans = (ans + MODP - (pw - 1 - line.size())) % MODP;\n            }\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=205;\nconst int mod=998244353;\nstruct point{\n\tint x,y;\n}c[maxn];\nint n;\nLL _2[maxn],ans;\nint main(){\n\tscanf(\"%d\",&n);\n\t_2[0]=1;\n\tfor(int i=1;i<=n;i++) _2[i]=_2[i-1]*2%mod;\n\tans=_2[n]-n-1;\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&c[i].x,&c[i].y);\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tint cnt=0;\n\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\tif((c[i].x-c[k].x)*(c[j].y-c[k].y)==(c[j].x-c[k].x)*(c[i].y-c[k].y)) cnt++;\n\t\t\t}\n\t\t\tans=(ans-_2[cnt]+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/** @Date    : 2017-09-02 20:30:47\n  * @FileName: C.cpp\n  * @Platform: Windows\n  * @Author  : Lweleth (SoungEarlf@gmail.com)\n  * @Link    : https://github.com/\n  * @Version : $Id$\n  */\n#include <bits/stdc++.h>\n#define LL long long\n#define PII pair<int ,int>\n#define MP(x, y) make_pair((x),(y))\n#define fi first\n#define se second\n#define PB(x) push_back((x))\n#define MMG(x) memset((x), -1,sizeof(x))\n#define MMF(x) memset((x),0,sizeof(x))\n#define MMI(x) memset((x), INF, sizeof(x))\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 210;\nconst double eps = 1e-8;\nconst LL mod = 998244353;\n\nLL fa[210], inv[210];\n\nLL fpow(LL a, LL n)\n{\n    LL r = 1LL;\n    while(n > 0)\n    {\n        if(n & 1)\n            r = r * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return r;\n}\n\nvoid init()\n{\n    fa[0] = 1;\n    inv[0] = 1;\n    for(LL i = 1; i <= 200; i++)\n    {\n        fa[i] = fa[i-1] * i % mod;\n        inv[i] = fpow(fa[i], mod - 2);\n    }\n}\n\nLL C(LL n, LL m)\n{\n    if(n < 0)\n        return 0;\n    n >>= 1;\n    if(n == 0)\n    \treturn 1LL;\n    LL ans = 0;\n    ans = ((fa[n + m] * inv[m] % mod)* inv[n]) % mod;\n    return ans;\n}\n\n\nstruct point\n{\n\tdouble x, y;\n\tpoint(){}\n\tpoint(double _x, double _y){x = _x, y = _y;}\n\tpoint operator -(const point &b) const\n\t{\n\t\treturn point(x - b.x, y - b.y);\n\t}\n\tdouble operator *(const point &b) const \n\t{\n\t\treturn x * b.x + y * b.y;\n\t}\n\tdouble operator ^(const point &b) const\n\t{\n\t\treturn x * b.y - y * b.x;\n\t}\n};\n\ndouble xmult(point p1, point p2, point p0)  \n{  \n    return (p1 - p0) ^ (p2 - p0);  \n}  \n\ndouble distc(point a, point b)\n{\n\treturn sqrt((double)((b - a) * (b - a)));\n}\nint sign(double x)\n{\n\tif(fabs(x) < eps)\n\t\treturn 0;\n\tif(x < 0)\n\t\treturn -1;\n\telse \n\t\treturn 1;\n}\n\n////////\nint n;\npoint stk[N];\npoint p[N];\n\nint cmpC(point a, point b)//水平序排序\n{\n\treturn sign(a.x - b.x) < 0 || (sign(a.x - b.x) == 0 && sign(a.y - b.y) < 0);\n}\n\nint Graham()//水平序\n{\n\tsort(p, p + n, cmpC);\n\tint top = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\twhile(top >= 2 && sign(xmult(stk[top - 2], stk[top - 1], p[i])) < 0)\n\t\t\ttop--;\n\t\tstk[top++] = p[i];\n\t}\n\tint tmp = top;\n\tfor(int i = n - 2; i >= 0; i--)\n\t{\n\t\twhile(top > tmp && sign(xmult(stk[top - 2],stk[top - 1] ,p[i] )) < 0)\n\t\t\ttop--;\n\t\tstk[top++] = p[i];\n\t}\n\tif(n > 1)\n\t\ttop--;\n\treturn top;\n}\n\n\nint check(int m)\n{\n\t//cout << m << endl;\n\tLL c = 2;\n\tLL t = 0;\n\tfor(int i = 1; i < m; i++)\n\t{\n\t\tif(sign(xmult(stk[i - 1], stk[(i + 1)%(m)], stk[i])) == 0)\n\t\t\tc++;\n\t\telse t = (t + fpow(2, c) - (1LL + c + c * (c - 1) / 2LL) + mod) % mod, c = 2;\n\t\t//cout << c << endl;\n\t}\n\tif(c > 2)\n\t\t t = (t + fpow(2, c) - (1LL + c + c * (c - 1) / 2LL) + mod) % mod;\n\treturn t;\n}\n/////////\nint main()\n{\n\n\twhile(~scanf(\"%d\", &n))\n\t{\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tp[i] = point(x, y);\n\t\t}\n\t\tLL cnt = Graham();\n\t\t//cout << cnt;\n\t\tLL ans = (fpow(2, n) - check(cnt) - (1LL + n + (n - 1) * n / 2LL) + mod) % mod;\n\t\twhile(ans < 0)\n\t\t\tans += mod;\n\t\tif(cnt > 2)\n\t\t\tprintf(\"%lld\\n\", ans);\n\t\telse printf(\"0\\n\");\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) < 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\nint adds[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<point> ns;\n        for (int j = 0; j < n; j++) {\n            if (j == i) {\n                continue;\n            }\n            if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {\n                need[j] = true;\n                ns.push_back(p[j]);\n            } else {\n                need[j] = false;\n            }\n        }\n        cur = p[i];\n        sort(all(ns), comp);\n        for (int j = 0; j < sz(ns); j++) {\n            adds[j] = 0;\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (vec(ns[k] - p[i], ns[j] - p[i]) == 0) {\n                    adds[j]++;\n                }\n            }\n            for (int k = j + 1; k < sz(ns); k++) {\n                goods[j][k] = false;\n                cnt[j][k] = 0;\n                dp[j][k] = 0;\n                if (good(p[i], ns[j], ns[k])) {\n                    goods[j][k] = true;\n                    for (int g = j + 1; g < k; g++) {\n                        if (vec(ns[k] - p[i], ns[g] - p[i]) != 0 && vec(ns[j] - p[i], ns[g] - p[i]) != 0 && inside(p[i], ns[j], ns[k], ns[g])) {\n                            cnt[j][k]++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (goods[j][k]) {\n                    dp[j][k] += st[cnt[j][k] + adds[j] + adds[k]];\n                    dp[j][k] %= Mod;\n                    ans += dp[j][k];\n                    ans %= Mod;\n                    for (int nxt = k + 1; nxt < sz(ns); nxt++) {\n                        if (vec(ns[nxt] - ns[j], ns[k] - ns[j]) > 0 && goods[k][nxt] && vec(ns[nxt] - p[i], ns[k] - p[i]) != 0) {\n                            dp[k][nxt] += (1LL * dp[j][k] * st[cnt[k][nxt] - adds[k] + adds[nxt]]) % Mod;\n                            dp[k][nxt] %= Mod;\n                        }\n                    }\n                }   \n            }\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nll mod_pow(ll a,ll n) {\n    if(n==0) return 1;\n    if(n%2==0) {\n        ll t=mod_pow(a,n/2);\n        return (t*t)%MOD;\n    }\n    return (a*mod_pow(a,n-1))%MOD;\n}\nll fact[201],inv_fact[201];\nll comb(ll n,ll k) {\n    if(n<k) return 0;\n    ll ret=fact[n];\n    (ret*=inv_fact[k])%=MOD;\n    (ret*=inv_fact[n-k])%=MOD;\n    return ret;\n}\nint main() {\n    int N;\n    cin>>N;\n    fact[0]=inv_fact[0]=1;\n    for(int i=1;i<=N;i++) {\n        fact[i]=(fact[i-1]*i)%MOD;\n        inv_fact[i]=(inv_fact[i-1]*mod_pow(i,MOD-2))%MOD;\n    }\n    vector<ll> x(N);\n    vector<ll> y(N);\n    for(int i=0;i<N;i++) {\n        cin>>x[i]>>y[i];\n    }\n    ll ans=0;\n    for(int i=0;i<N;i++) {\n        for(int j=i+1;j<N;j++) {\n            int n=0;\n            for(int k=i+1;k<j;k++) {\n                int area = (x[j]-x[i])*(y[k]-y[i])-(x[k]-x[i])*(y[j]-y[i]);\n                if(area) n++;\n            }\n            for(int k=1;k<=n;k++) {\n                ll t = comb(n, k);\n                (t *= mod_pow(2, j - i - 1 - n)) %= MOD;\n                (ans+=t)%=MOD;\n            }\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n#define DEBUG_IS_VALID \n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){cout << \"{\"; for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\nvoid _main();\nint main(){ cin.tie(0); ios::sync_with_stdio(false); _main(); return 0;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-12,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntemplate<typename T, int FAC_MAX> struct Comb { vector<T> fac, ifac;\n    Comb(){fac.resize(FAC_MAX,1);ifac.resize(FAC_MAX,1); for(int i = 1; i < FAC_MAX; i++)fac[i]=fac[i-1]*i;\n        ifac[FAC_MAX-1]=T(1)/fac[FAC_MAX-1];for(int i = FAC_MAX-2; i >= 1; i--)ifac[i]=ifac[i+1]*T(i+1);}\n    T aPb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b]; }\n    T aCb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b] * ifac[b]; }\n    T nHk(int n, int k) { if (n == 0 && k == 0) return T(1); if (n <= 0 || k < 0) return 0;\n        return aCb(n + k - 1, k); }}; // nHk = (n+k-1)Ck : n is separator\n\nusing mint =  ModInt<998244353>;\n\nstruct nd{\n  double x;\n  nd(double x):x(x){};\n};\n\nbool operator<(const nd &lhs, const nd &rhs)\n{\n    return lhs.x < rhs.x - EPS;\n}\n\nvoid _main(){\n  int N; cin >> N ;\n  using vd = vector<double>;\n  using Pd = pair<double,double>;\n  vd x(N),y(N);\n  map<nd,map<nd,int>> mp;\n  rep(i,N) cin >> x[i] >> y[i] ;\n  rep(i,N) rep(j,N){\n    if(i==j) continue;\n    double a,b;\n    if(x[j]==x[i]){\n      a = 1e10; b = x[i];\n    }else{\n      a = (y[j]-y[i])/(x[j]-x[i]);\n      b = y[i] - a * x[i];\n    }\n    mp[a][b]++;\n  }\n  mint ans = mint(2)^N;\n  for(auto&& p:mp){\n    for(auto&& p2:p.second){\n      int cnt = 0;\n      auto a = p.first;\n      auto b = p2.first;\n      if(a.x!=1e10){ rep(i,N) if(abs(y[i]-a.x*x[i]-b.x)<EPS) cnt++; }\n      else rep(i,N) if(abs(x[i]-b.x)<EPS) cnt++;\n      ans -= (mint(2)^cnt) - mint(cnt+1);\n    }\n  }\n  ans -= mint(1+N);\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,n) for(int i=(a);i<=(n);++i)\n#define dep(i,a,n) for(int i=(a);i>=(n);--i)\n#define eps 1e-8\n#define pi 3.1415926535897\n#define sqr(x) ((x)*(x))\n#define MAX(a,b) a=max(a,b)\n#define MIN(a,b) a=min(a,b)\n#define SZ(x) ((int)(x).size())\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define CLR(a) memset(a,0,sizeof(a))\n#define POSIN(x,y) (1<=(x)&&(x)<=n&&1<=(y)&&(y)<=m)\n#define all(x) (x).begin(),(x).end()\n#define COUT(S,x) cout<<fixed<<setprecision(x)<<S<<endl\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#ifdef LOCAL\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...) \n#endif\ntypedef long long ll;\ntypedef double lf;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<lf,lf> pff;\ntypedef complex<double> CD;\nconst int inf=0x3f3f3f3f;\nconst int mo=998244353;\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ntemplate<class T1,class T2>inline void gn(T1&r,T2&s){gn(r),gn(s);}\ntemplate<class T1,class T2,class T3>inline void gn(T1&r,T2&s,T3&t){gn(r),gn(s),gn(t);}\ntemplate<class T1,class T2,class T3,class T4>inline void gn(T1&r,T2&s,T3&t,T4&u){gn(r),gn(s),gn(t),gn(u);}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\nconst int DX[]={1,0,-1,0},DY[]={0,1,0,-1};\nll powmod(ll a,ll b) {ll res=1;a%=mo;for(;b;b>>=1){if(b&1)res=res*a%mo;a=a*a%mo;}return res;}\nll powmod(ll a,ll b,ll mo) {ll res=1;a%=mo;for(;b;b>>=1){if(b&1)res=res*a%mo;a=a*a%mo;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n//*******************************************\n\nconst int N=111111,M=111111;\nint l,m,n,t,C;\npii a[N];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"E.in\",\"r\",stdin);//freopen(\"E.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&n);\n\trep(i,1,n)scanf(\"%d%d\",&a[i].X,&a[i].Y);\n\tll ans=powmod(2,n)-n-n*(n-1)/2-1;\n\trep(i,1,n)rep(j,i+1,n){\n\t\tint mn=n+1,cnt=2;\n\t\trep(k,1,n)if(i!=k&&j!=k&&(a[j].X-a[i].X)*(a[k].Y-a[i].Y)==(a[j].Y-a[i].Y)*(a[k].X-a[i].X))MIN(mn,k),++cnt;\n\t\tif(mn>j)ans-=powmod(2,cnt)-cnt-1-cnt*(cnt-1)/2;\n\t}\n\tans=(ans%mo+mo)%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 205;\nconst int mo = 998244353;\n\nint n;\nstruct point{\n\tint x,y;\n}a[N];\nLL ans;\nLL mi[N];\n\nLL cross(point a,point b,point c){\n\treturn 1ll*(c.x-a.x)*(b.y-a.y)-1ll*(b.x-a.x)*(c.y-a.y);\n}\n\nint main(){\n\tn=get();\n\tfo(i,1,n){a[i].x=get();a[i].y=get();}\n\tmi[0]=1;\n\tfo(i,1,n)mi[i]=mi[i-1]*2%mo;\n\tans=(mi[n]+mo-1-n)%mo;\n\tfo(i,1,n)\n\t\tfo(j,i+1,n){\n\t\t\tint cnt=-2;\n\t\t\tint x1=min(a[i].x,a[j].x),x2=max(a[i].x,a[j].x),y1=min(a[i].y,a[j].y),y2=max(a[i].y,a[j].y);\n\t\t\tfo(x,1,n)\n\t\t\tif (cross(a[i],a[j],a[x])==0&&a[x].x>=x1&&a[x].x<=x2&&a[x].y>=y1&&a[x].y<=y2)cnt++;\n\t\t\tans=(ans+mo-mi[cnt])%mo;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1005,INF=1<<30;\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    int N;cin>>N;\n    vector<int> X(N),Y(N);\n    for(int i=0;i<N;i++){\n        cin>>X[i]>>Y[i];\n    }\n    \n    ll ans=rui(2,N);\n    ans+=mod-(N+1);\n    ans%=mod;\n    \n    for(int a=0;a<N;a++){\n        for(int b=a+1;b<N;b++){\n            ll cnt=0;\n            int left=a,right=b;\n            for(int k=0;k<N;k++){\n                //if(k==a||k==b) continue;\n                if((X[k]-X[a])*(Y[b]-Y[a])-(X[b]-X[a])*(Y[k]-Y[a])==0){\n                    left=min(left,k);\n                    right=max(right,k);\n                    cnt++;\n                }\n            }\n            if(left==a&&right==b) ans+=mod-(rui(2,cnt)-cnt-1)%mod;\n            ans%=mod;\n        }\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\nconst ll mod = 998244353;\n\nll powmod(ll a, ll e) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\n\nint main(void) {\n  int n;\n  cin >> n;\n  vector<PL> pt(n);\n  REP(i, 0, n) {\n    int x, y;\n    cin >> x >> y;\n    pt[i] = PL(x, y);\n  }\n  ll tot = powmod(2, n);\n  tot += mod - 1 - n;\n  tot %= mod;\n  // Eliminate one-liners\n  REP(i, 0, n) {\n    REP(j, i + 1, n) {\n      int elim = 0;\n      REP(k, j + 1, n) {\n\t// i-j-k?\n\tPL v1(pt[j].first - pt[i].first, pt[j].second - pt[i].second);\n\tPL v2(pt[k].first - pt[i].first, pt[k].second - pt[i].second);\n\tll outer = v1.first * v2.second - v1.second * v2.first;\n\tif (outer == 0) {\n\t  elim += 1;\n\t}\n      }\n      tot += mod - powmod(2, elim);\n      tot %= mod;\n    }\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pl;\ntypedef pair<pl,ll> ln;\nmap<ln,ll> bs;\nconst ll M = 998244353;\nll mul(ll a, ll b) {return (a*b)%M;}\nll bp(ll b, ll p) {\n\tll ac = 1;\n\twhile(p) {\n\t\tif(p&1) {ac = mul(ac,b);}\n\t\tb = mul(b,b);\n\t\tp >>= 1;\n\t}\n\treturn ac;\n}\nll gcd(ll a, ll b) {\n\tif(!a) return b;\n\tif(!b) return a;\n\treturn gcd(b,a%b);\n}\nll rnf(ll v) {\n\tll s = 0,e = 220;\n\twhile(s <= e) {\n\t\tll m = (s+e)/2;\n\t\tif(m*(m-1) == v) {return m;}\n\t\tif(m*(m-1) > v) {\n\t\t\te = m-1;\n\t\t} else {\n\t\t\ts = m+1;\n\t\t}\n\t}\n\treturn -1;\n}\npl v[220];\nint main() {\n\tios::sync_with_stdio(0);\n\tll n;\n\tcin >> n;\n\tfor(int i=0;i<n;i++) {\n\t\tll a,b;\n\t\tcin >> a >> b;\n\t\tv[i] = {a,b};\n\t}\n\tfor(int i=0;i<n;i++) {\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tif(i == j) continue;\n\t\t\tpl f = v[i];\n\t\t\tpl s = v[j];\n\t\t\tll dx = f.first-s.first;\n\t\t\tll dy = f.second-s.second;\n\t\t\tll g = gcd(abs(dx),abs(dy));\n\t\t\tdx /= g;dy /= g;\n\t\t\tll a = dy,b = -dx;\n\t\t\tif(a < 0) {a *= -1;b *= -1;} else if(a == 0) {\n\t\t\t\tb = abs(b);\n\t\t\t}\n\t\t\tll c = -(a*f.first+b*f.second);\n\t\t\tln e = {{a,b},c};\n\t\t\tbs[e]++;\n\t\t}\n\t}\n\tll tot = bp(2,n);\n\tfor(auto& it: bs) {\n\t\tln sb = it.first;\n\t\t//cout << sb.first.first << \"*x + \" << sb.first.second << \"*y + \" << sb.second << \" = 0\\n\";\n\t\t//cout << \"ct \" << rnf(it.second) << '\\n';\n\t\tll tc = rnf(it.second);\n\t\tll ct = bp(2,tc);\n\t\tct -= tc+1;\n\t\ttot -= ct;\n\t}\n\ttot -= n+1;\n\ttot = ((tot%M)+M)%M;\n\tcout << tot << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=210,O=998244353;\ntemplate<class T>inline T sqr(T x){return x*x;}\nstruct Pt{\n\tint x,y;\n}pt[N],pt2[N],base;\ninline bool ycmp(const Pt &a,const Pt &b){\n\treturn a.y!=b.y?a.y<b.y:a.x<b.x;\n}\ninline int cross(const Pt &a,const Pt &b){\n\treturn (a.x-base.x)*(b.y-base.y)-(a.y-base.y)*(b.x-base.x);\n}\ninline bool polarcmp(const Pt &a,const Pt &b){\n\tint crs=cross(a,b);\n\treturn crs?crs>0:sqr(a.x-base.x)<sqr(b.x-base.x);\n}\nint pw2[N];\ninline void gmath(int n){\n\tpw2[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tpw2[i]=(lint)pw2[i-1]*2%O;\n\t}\n}\nint main(){\n\tint n=ni;\n\tgmath(n);\n\tfor(int i=1;i<=n;i++){\n\t\tpt[i]=(Pt){ni,ni};\n\t}\n\tsort(pt+1,pt+n+1,ycmp);\n\tlint sum=1;\n\tfor(int i=1;i<=n;i++){\n\t\tbase=pt[i];\n\t\tmemcpy(pt2+i+1,pt+i+1,(n-i)*sizeof(Pt));\n\t\tsort(pt2+i+1,pt2+n+1,polarcmp);\n\t\tfor(int j=i+1,k=j;j<=n;j=k){\n\t\t\tfor(;k<=n&&cross(pt2[j],pt2[k])==0;k++);\n\t\t\tsum+=pw2[k-j]-1;\n\t\t}\n\t\tsum++;//single\n\t}\n\tprintf(\"%lld\\n\",((pw2[n]-sum%O)%O+O)%O);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=222,mod=998244353;\n#define lson o<<1,l,mid\n#define rson o<<1|1,mid+1,r\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\twhile(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();\n\twhile(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\nstruct line{\n\tdouble k,b;\n\tbool operator<(const line &l)const{\n\t\tif(fabs(k-l.k)>1e-8) return k<l.k;\n\t\treturn b<l.b;\n\t}\n}l[25555];\nint n,ans,pt[maxn],x[maxn],y[maxn],llen,cnt[25555];\ninline int gcd(int x,int y){return y?gcd(y,x%y):x;}\nint main(){\n\tn=read();\n\tFOR(i,1,n) x[i]=read(),y[i]=read();\n\tpt[0]=1;\n\tFOR(i,1,n) pt[i]=2*pt[i-1]%mod;\n\tans=(pt[n]-(n+1)+mod)%mod;\n\tFOR(i,1,n) FOR(j,i+1,n){\n\t\tdouble k,b;\n\t\tif(x[i]==x[j]) k=1e9,b=x[i];\n\t\telse k=1.0*(y[j]-y[i])/(x[j]-x[i]),b=y[i]-k*x[i];\n\t\tl[++llen]=(line){k,b};\n\t}\n\tsort(l+1,l+llen+1);\n\tFOR(i,2,n) cnt[i*(i-1)/2]=i;\n\tFOR(i,1,llen){\n\t\tint j=i;\n\t\twhile(j<=llen && fabs(l[i].k-l[j].k)<1e-8 && fabs(l[i].b-l[j].b)<1e-8) j++;\n\t\tj--;\n\t\tint x=cnt[j-i+1];\n\t\tans=(ans-(pt[x]-(x+1)+mod)%mod+mod)%mod;\n\t\ti=j;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vdouble = vector<double>;\nusing vvdouble = vector<vdouble>;\nusing vvvdouble = vector<vvdouble>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\nconstexpr int mod2 = 998244353;\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) { return (a > b && (a = b, true)); }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) { return (a < b && (a = b, true)); }\ntemplate<typename T>\nbool isin(T y, T x, T h, T w) { return (0 <= y && 0 <= x && y < h && x < w); }\ntemplate<typename T>\nbool isin1(T y, T x, T h, T w) { return (0 < y && 0 < x && y <= h && x <= w); }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++) os << \" \" << v[i];\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nconstexpr double EPS = 1e-10;\nbool equals(double a, double b) { return (abs(a - b) < EPS); }\n\nstruct V2 {\n\tdouble x, y;\n\tV2(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tV2 operator + (V2 p) const { return (V2(x + p.x, y + p.y)); }\n\tV2 operator - (V2 p) const { return (V2(x - p.x, y - p.y)); }\n\tV2 operator * (double r) const { return (V2(x * r, y * r)); }\n\tV2 operator / (double r) const { return (V2(x / r, y / r)); }\n\n\tdouble norm() const { return (sqrt(sqrNorm())); }\n\tdouble sqrNorm() const { return (x*x + y*y); }\n\n\tbool operator < (const V2 &p) const { \n\t\treturn (x != p.x ? x < p.x : y < p.y); \n\t}\n\tbool operator == (const V2 &p) const {\n\t\treturn (equals(x, p.x) && equals(y, p.y));\n\t}\n\n\tV2 rotate90() const { return (V2(y, -x)); }\n\tV2 normalized() const { return (*this / norm()); }\n\n\tdouble dot(const V2 &p) const { return (x*p.x + y*p.y); }\n\tdouble cross(const V2 &p) const { return (x*p.y - y*p.x); }\n\tdouble arg() const { return (atan2(y, x)); }\n};\n\nvoid Main() {\n\tint N; cin >> N;\n\tvector<V2> ps(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> ps[i].x >> ps[i].y;\n\t}\n\n\tll sum = 0;\n\n\tsort(begin(ps), end(ps));\n\tfor (int a = 0; a < N; a++) {\n\t\tvector<pair<double, V2>> dats;\n\t\tint n = N-a-1;\n\t\tfor (int b = a+1; b < N; b++) {\n\t\t\tdats.emplace_back((ps[b]-ps[a]).arg(), ps[b]-ps[a]);\n\t\t}\n\t\tsort(begin(dats), end(dats));\n\t\tvector<V2> nps(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnps[i] = dats[i].second;\n\t\t}\n\n\t\tvvll contval(n, vll(n, 1));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (j == i || j == k) continue;\n\t\t\t\t\tdouble cr1 = nps[i].cross(nps[j]), cr2 = -nps[k].cross(nps[j]-nps[k]);\n\t\t\t\t\tdouble cr3 = (nps[k]-nps[i]).cross(nps[j]-nps[i]);\n\t\t\t\t\tif (cr1 > -EPS && cr2 > -EPS && cr3 > -EPS || cr1 < EPS && cr2 < EPS && cr3 < EPS) {\n\t\t\t\t\t\t(contval[i][k] *= 2) %= mod2;\n\t\t\t\t\t\t//cout << a << \" \" << nps[i].x << \" \" << nps[i].y << \" \" << nps[k].x << \" \" << nps[k].y << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tvvll dp(n, vll(n, 0));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tif (!equals(nps[i].cross(nps[j]), 0.0)) dp[i][j] = contval[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tV2 v1 = nps[j]-nps[i];\n\t\t\t\tfor (int k = j+1; k < n; k++) {\n\t\t\t\t\tV2 v2 = nps[k]-nps[i];\n\t\t\t\t\tif (v1.cross(v2) < EPS) continue;\n\t\t\t\t\t(dp[j][k] += contval[j][k] * dp[i][j]) %= mod2;\n\t\t\t\t}\n\t\t\t\t(sum += dp[i][j]) %= mod2;\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nstruct Point {\n    LL x, y;\n    bool operator<(const Point &o) const {\n\treturn x != o.x? x < o.x : y < o.y;\n    }\n} P[201];\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n    LL x0 = b.x - a.x;\n    LL y0 = b.y - a.y;\n    LL x1 = c.x - a.x;\n    LL y1 = c.y - a.y;\n    LL crs = x0 * y1 - x1 * y0;\n    if (crs > 0) return 1;\n    if (crs < 0) return -1;\n    return 0;\n}\n\nint B[201][201];\nint C[201][201];\nint N;\n\nMint pow2[211], pow_inv2[211];\nMint U[201][201], D[201][201];\nMint Ux[201], Dx[201];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%lld%lld\", &P[i].x, &P[i].y);\n\n    sort(P, P+N);\n\n    pow2[0] = pow_inv2[0] = 1;\n    pow2[1] = 2;\n    pow_inv2[1] = (MOD + 1) / 2;\n    for (int i=1; i<=N; i++) {\n\tpow2[i+1] = pow2[i] * pow2[1];\n\tpow_inv2[i+1] = pow_inv2[i] * pow_inv2[1];\n    }\n\n    REP (a, N) for (int i=a+1; i<N; i++) for (int b=i+1; b<N; b++) {\n\tint c = ccw(P[a], P[i], P[b]);\n\tif (c == 1 || c == 0) B[a][b]++;\n\tif (c == 1) C[a][b]++;\n    }\n\n//    REP (i, N) eprintf(\"(%lld %lld)\\n\", P[i].x, P[i].y);\n//    REP (a, N) for (int b=a+1; b<N; b++) {\n//\teprintf(\"%d %d : %d\\n\", a, b, B[a][b]);\n//    }\n\n    Mint ans = 0;\n    REP (s, N) {\n\tmemset(U, 0, sizeof U);\n\tmemset(D, 0, sizeof D);\n\tfor (int i=s+1; i<N; i++) {\n\t    U[s][i] += pow2[B[s][i]];\n\t    D[s][i] += pow_inv2[C[s][i]];\n\t    ans -= U[s][i] * D[s][i];\n\t}\n\t\n\tfor (int i=s; i<N; i++) for (int j=i+1; j<N; j++) for (int k=j+1; k<N; k++) {\n\t    int c = ccw(P[i], P[j], P[k]);\n\t    if (c == -1) U[j][k] += U[i][j] * pow2[B[j][k]];\n\t    if (c == 1) D[j][k] += D[i][j] * pow_inv2[C[j][k]+1];\n\t}\n\n\tmemset(Ux, 0, sizeof Ux);\n\tmemset(Dx, 0, sizeof Dx);\n\tfor (int i=s; i<N; i++) for (int j=i+1; j<N; j++) {\n\t    Ux[j] += U[i][j];\n\t    Dx[j] += D[i][j];\n\t}\n\tfor (int i=s+1; i<N; i++) {\n\t    ans += Ux[i] * Dx[i];\n\t}\n    }\n\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define MOD 998244353\nusing namespace std;\npair<int,int> P[205];\ndouble tmp[205];\nint pw2[205];\nint N;\nint rez;\nvoid fix(int &val)\n{\n    if(val<0)val+=MOD;\n}\nvoid baga(pair<int,int> a)\n{\n    int len=0;\n    for(int i=1;i<=N;i++)\n    {\n\n        if(a<P[i])\n        {\n            tmp[++len]=atan2(P[i].second-a.second,P[i].first-a.first);\n        }\n    }\n    sort(tmp+1,tmp+1+len);\n    int cnt=(len>0);\n    //printf(\"%d \",rez);\n    fix(rez=rez-1);\n    for(int i=2;i<=len;i++)\n    {\n        if(tmp[i]==tmp[i-1])\n        {\n            cnt++;\n        }\n        else\n        {\n            fix(rez-=(pw2[cnt]-1));\n            cnt=1;\n        }\n    }\n    fix(rez-=(pw2[cnt]-1));\n//    printf(\"%d\\n\",rez);\n}\nint main()\n{\n    pw2[0]=1;\n    for(int i=1;i<=200;i++)fix(pw2[i]=2*pw2[i-1]);\n    scanf(\"%d\",&N);rez=pw2[N]-1;\n    for(int i=1;i<=N;i++)scanf(\"%d %d\",&P[i].first,&P[i].second);\n    for(int i=1;i<=N;i++)\n    {\n        baga(P[i]);\n    }\n    printf(\"%d\",rez);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define MAXN 201\nconst int mod = 998244353;\n\npair<int, int> p[MAXN];\nint n, bio[MAXN][MAXN];\n\nint check(int i, int j) {\n  int ret = 1;\n  set<int> s;\n  s.insert(i);\n  s.insert(j);\n  pair<int, int> v = make_pair(p[j].first-p[i].first, p[j].second-p[i].second);\n  for (int k = 0; k < n; ++k) {\n    if (k==i || k==j) continue;\n    pair<int, int> v2 = make_pair(p[k].first-p[i].first, p[k].second-p[i].second);\n    if (v.first*v2.second-v.second*v2.first==0) {\n      s.insert(k);\n    }\n  }\n  for (auto si : s) {\n    for (auto sj : s) {\n      bio[si][sj] = 1;\n      bio[sj][si] = 1;\n    }\n  }\n  for (int i = 0; i < s.size(); ++i) {\n    ret *= 2;\n    ret %= mod;\n  }\n  ret--;\n  ret -= s.size();\n  return ret;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int ans = 1;\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i].first >> p[i].second;\n  }\n  for (int i = 0; i < n; ++i) {\n    ans *= 2;\n    ans %= mod;\n  }\n  ans--;\n  ans -= n;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i+1; j < n; ++j) {\n      if (bio[i][j]) continue;\n      ans -= check(i, j);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\n\nconst int MOD = 998244353;\n\nll pow2[11111];\n\nll add(ll a, ll b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\n\nll mult(ll a, ll b)\n{\n\treturn (a*b)%MOD;\n}\n\nll subt(ll a, ll b)\n{\n\ta-=b;\n\twhile(a<0) a+=MOD;\n\treturn a;\n}\n\nmap<pair<ll,ll>,ll> ma;\nbool vis[201][201];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tvector<ii> vec;\n\tpow2[0]=1;\n\tfor(int i=1;i<=10000;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tvec.pb(mp(x,y));\n\t}\n\tll ans = pow2[n];\n\tans = subt(ans,1); //subtract empty set\n\tans = subt(ans,n); //subtract set of size 1\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif(vis[i][j]||vis[j][i]) continue;\n\t\t\tll Y = vec[j].se-vec[i].se;\n\t\t\tll X = vec[j].fi-vec[i].fi;\n\t\t\tii gradient;\n\t\t\tif(X==0) \n\t\t\t{\n\t\t\t\tgradient = mp(1,0);\n\t\t\t}\n\t\t\telse if(Y==0)\n\t\t\t{\n\t\t\t\tgradient = mp(0,1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll g = __gcd(X,Y);\n\t\t\t\tY/=g; X/=g;\n\t\t\t\tif(X<0)\n\t\t\t\t{\n\t\t\t\t\tX*=-1;\n\t\t\t\t\tY*=-1;\n\t\t\t\t}\n\t\t\t\tgradient = mp(Y,X);\n\t\t\t}\n\t\t\tll cnt=2;\n\t\t\tvis[i][j]=vis[j][i]=1;\n\t\t\tvi V;\n\t\t\tV.pb(i); V.pb(j);\n\t\t\tfor(int k = 0; k < n; k++)\n\t\t\t{\n\t\t\t\tif(k!=i&&k!=j)\n\t\t\t\t{\n\t\t\t\t\tll Y2 = vec[k].se-vec[i].se;\n\t\t\t\t\tll X2 = vec[k].fi-vec[i].fi;\n\t\t\t\t\tii gradient2;\n\t\t\t\t\tif(X2==0) \n\t\t\t\t\t{\n\t\t\t\t\t\tgradient2 = mp(1,0);\n\t\t\t\t\t}\n\t\t\t\t\telse if(Y2==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tgradient2 = mp(0,1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tll g2 = __gcd(X2,Y2);\n\t\t\t\t\t\tY2/=g2; X2/=g2;\n\t\t\t\t\t\tif(X2<0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tX2*=-1;\n\t\t\t\t\t\t\tY2*=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgradient2 = mp(Y2,X2);\n\t\t\t\t\t}\n\t\t\t\t\tif(gradient==gradient2) \n\t\t\t\t\t{\n\t\t\t\t\t\tif(!vis[i][k]&&!vis[j][k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tV.pb(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int z=0;z<V.size();z++)\n\t\t\t{\n\t\t\t\tfor(int z2=0;z2<V.size();z2++)\n\t\t\t\t{\n\t\t\t\t\tvis[z][z2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cerr<<cnt<<'\\n';\n\t\t\tans = subt(ans, pow2[cnt]-cnt-1);\n\t\t}\n\t}\n\t\n\tans%=MOD;\n\tif(ans<0) ans+=MOD;\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <unordered_map>\n#include <iomanip>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst ll mod = 998244353;\n\nstruct point{\n    ll x,y;\n};\n\nll fpow(ll x, ll p){\n    ll r=1;\n    for (; p; p>>=1){\n        if (p&1) r=(r*x)%mod;\n        x=(x*x)%mod;\n    }\n    return r;\n}\n\nll ccw(point A, point B, point C){\n    return (A.x*B.y+B.x*C.y+C.x*A.y-B.y*C.x-C.y*A.x-A.y*B.x);\n}\n\nll N; point a[210];\nbool v[210][210];\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> N;\n\n    int i,j,k;\n    for (i=1; i<=N; i++) cin >> a[i].x >> a[i].y;\n\n    ll res=fpow(2,N)-1-N-N*(N-1)/2;\n\n    for (i=1; i<=N; i++)\n        for (j=i+1; j<=N; j++){\n            if (v[i][j]) continue;\n\n            int cnt=0;\n            vi ind;\n            for (k=1; k<=N; k++)\n                if (ccw(a[i],a[j],a[k])==0) cnt++,ind.pb(k);\n\n\n            for (int x=0; x<(int)ind.size(); x++)\n                for (int y=x+1; y<(int)ind.size(); y++)\n                    v[ind[x]][ind[y]]=v[ind[y]][ind[x]]=1;\n            res=(res-(fpow(2,cnt)-1-cnt-cnt*(cnt-1)/2))%mod;\n        }\n\n    res=(res+mod)%mod;\n    cout << res << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int mod=998244353;\nusing namespace std;\nint n,x[210],y[210];\nint ksm(int a,int k){\n\tint ans=1;\n\tfor(;k;k>>=1,a=1ll*a*a%mod) if(k&1) ans=1ll*a*ans%mod;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint ans=(ksm(2,n)-n-1-n*(n-1)/2+mod)%mod;\n\tfor(int i=1;i<=n;i++) scanf(\"%d %d\",&x[i],&y[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint tmp=0;\n\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\tif(1ll*(x[i]-x[j])*(y[k]-y[j])==1ll*(x[k]-x[j])*(y[i]-y[j])) tmp++;\n\t\t\t}\n\t\t\tans=(ans+mod+1-ksm(2,tmp))%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// start fold\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\nusing namespace std;\n#define ri register int\n#define il inline\n#define LL long long\n#define ull unsigned long long\n#define pb push_back\n#define mp make_pair\n#define pairint pair<int,int>\n#define fi first\n#define se second\n#define iv il void\n#define enter putchar('\\n')\n#define size(x) ((int)x.size())\n#define mem0(x) memset(x,0,sizeof(x))\ntemplate<class T>il void in(T &x)\n{\n    x=0; short f=1; char c=getchar();\n    while(c<'0'||c>'9')\n    {\n        if(c=='-') f=-1;\n        c=getchar();\n    }\n    while(c>='0'&&c<='9') x=x*10+(c^'0'),c=getchar();\n    x*=f;\n}\ntemplate<class T>il void out(T x,const char c='\\n')\n{\n    static short st[30];\n    short m=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++m]=x%10,x/=10; while(x);\n    while(m) putchar(st[m--]|'0');\n    putchar(c);\n}\nnamespace i207M\n{\n// end fold\n#define N 205\nconst int md=998244353;\nint n;\nstruct Node\n{\n    int x,y;\n    il void init()\n    {\n        in(x),in(y);\n    }\n    Node() {}\n    Node(const int xx,const int yy)\n    {\n        x=xx,y=yy;\n    }\n    friend Node operator-(const Node &a,const Node &b)\n    {\n        return Node(a.x-b.x,a.y-b.y);\n    }\n} p[N];\nbool line(const Node &a,const Node &b)\n{\n    return a.x*b.y-b.x*a.y==0;\n}\nbool del[N][N];\nint bit[N];\nsigned main()\n{\n#ifdef M207\n    freopen(\"in.in\",\"r\",stdin);\n    // freopen(\"out.out\",\"w\",stdout);\n#endif\n    in(n);\n    for(ri i=1; i<=n; ++i) p[i].init();\n    int ans=0; bit[0]=1;\n    for(ri i=1; i<=n; ++i) bit[i]=(bit[i-1]<<1)%md;\n    for(ri i=1; i<=n; ++i)\n    {\n        static Node tmp[N];\n        for(ri j=1; j<=n; ++j) tmp[j]=p[j]-p[i];\n        for(ri j=i+1; j<=n; ++j)\n            if(!del[i][j])\n            {\n                static int st[N]; int tp=0;\n                for(ri k=1; k<=n; ++k)\n                    if(line(tmp[j],tmp[k]))\n                        st[++tp]=k;\n                (ans+=bit[tp]-1-tp)%=md;\n                // printf(\"M %d %d: %d\\n\",i,j,tp);\n                for(ri k=1; k<=tp; ++k)\n                    for(ri h=k+1; h<=tp; ++h)\n                        del[st[k]][st[h]]=del[st[h]][st[k]]=1;\n            }\n    }\n    ans=((bit[n]-1-n-ans)%md+md)%md;\n    out(ans);\n    return 0;\n}\n// start fold\n}\nsigned main()\n{\n    i207M::main();\n    return 0;\n}\n// end fold"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int MAXN = 205;\nconst int mod = 998244353;\n\nint n, pwr[MAXN];\npi a[MAXN];\n\nint ccw(pi a, pi b, pi c){\n\tint dx1 = b.first - a.first;\n\tint dy1 = b.second - a.second;\n\tint dx2 = c.first - a.first;\n\tint dy2 = c.second - a.second;\n\treturn dx1 * dy2 - dy1 * dx2;\n}\n\nint main(){\n\tint n; cin >> n;\n\tpwr[0] = 1;\n\tfor(int i=0; i<n; i++){\n\t\tpwr[i+1] = pwr[i] * 2 % mod;\n\t\tcin >> a[i].first >> a[i].second;\n\t}\n\tsort(a, a + n);\n\tlint ret = 1;\n\tfor(int i=0; i<n; i++){\n\t\tsort(a + i + 1, a + n, [&](const pi &p, const pi &q){\n\t\t\treturn ccw(a[i], p, q) > 0;\n\t\t});\n\t\tret += 1;\n\t\tfor(int j=i+1; j<n; ){\n\t\t\tint e = j;\n\t\t\twhile(e < n && ccw(a[i], a[j], a[e]) == 0) e++;\n\t\t//\tprintf(\"%d %d\\n\", j, e);\n\t\t\tret += pwr[e - j] - 1;\n\t\t\tj = e;\n\t\t}\n\t\tsort(a + i + 1, a + n);\n\t}\n\tret %= mod;\n\tret = mod - ret + pwr[n];\n\tret %= mod;\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 210;\nconst int mod = 998244353;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nint n, xs[MAXN], ys[MAXN], vis[MAXN][MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) std::cin >> xs[i] >> ys[i];\n\tint ans = pow(2, n);\n\treduce(ans -= n + 1), reduce(ans -= n * (n - 1) / 2);\n\tstatic int li[MAXN];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tif (!vis[i][j]) {\n\t\t\t\tint bak = 0;\n\t\t\t\tfor (int k = 1; k <= n; ++k)\n\t\t\t\t\tif ((LL) (xs[k] - xs[i]) * (ys[k] - ys[j]) == (LL) (xs[k] - xs[j]) * (ys[k] - ys[i]))\n\t\t\t\t\t\tli[++bak] = k;\n\t\t\t\tfor (int k = 1; k <= n; ++k)\n\t\t\t\t\tfor (int l = 1; l <= n; ++l)\n\t\t\t\t\t\tvis[li[k]][li[l]] = true;\n\t\t\t\tint t = pow(2, bak);\n\t\t\t\treduce(t -= bak + 1); reduce(t -= bak * (bak - 1) / 2);\n\t\t\t\treduce(ans -= t);\n\t\t\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <cmath>\n#include <math.h>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <ctime>\n#define int long long\n#define double long double\nusing namespace std;\ndouble INF = 1e9;\nint MOD = 998244353;\nint32_t main(){\n    int n, x, y;\n    vector<pair<int, int> > pr;\n    cin >> n;\n    for (int i=0; i < n; i++){\n        cin >> x >> y;\n        pr.push_back(make_pair(x, y));\n    }\n    map<pair<double, double>, set<int> > mm;\n    int ans = 2;\n    for (int i=0; i < n-1; i++){\n        ans *= 2;\n        ans %= MOD;\n    }\n    ans--;\n    ans %= MOD;\n    for (int i=0; i < n; i++){\n        for (int j=i+1; j < n; j++){\n            if (i == j) continue;\n            double k, b;\n            if (pr[i].first == pr[j].first){\n                k = INF;\n                b = pr[i].first;\n            }\n            else{\n                k = (double) (pr[i].second - pr[j].second) / (double) (pr[i].first - pr[j].first);\n                b = (double) pr[i].second - k * (double) pr[i].first;\n            }\n            k *= 1e9;\n            k = round(k);\n            b *= 1e9;\n            b = round(b);\n            if (mm.count(make_pair(k, b))){\n                mm[make_pair(k, b)].insert(i);\n                mm[make_pair(k, b)].insert(j);\n            }\n            else{\n                set<int> ms;\n                ms.insert(j);\n                ms.insert(i);\n                mm[make_pair(k, b)] = ms;\n            }\n        }\n    }\n    while (!mm.empty()){\n        pair<double, double> p = (*mm.begin()).first;\n        int sz = mm[p].size();\n        mm.erase(p);\n        int mins = 2;\n        for (int i=0; i < sz-1; i++){\n            mins *= 2;\n            mins %= MOD;\n        }\n        mins -= sz+1;\n        mins %= MOD;\n        ans -= mins;\n        ans %= MOD;\n    }\n    ans -= n;\n    ans %= MOD;\n    if (ans < 0) ans += MOD;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n\n#define P 998244353\n#define N_MAX 10000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\nll perm(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (fac[n]*finv[n-k])%P;\n}\n\nvoid init(){\n  fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n  for(int i = 2; i <= N_MAX; i++){\n    fac[i] = (fac[i-1]*i)%P;\n    inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n    finv[i] = (finv[i-1]*inv[i])%P;\n  }\n}\nll pp(ll a, ll b){\n  return (a * b)%P;\n}\n//凸包Sのスコア = N個の点のうちSの内部に含まれる個数kに対し2^k\n// = N個のうちの部分集合Sについて内部の部分集合k個から任意個選ぶパターン\n// = 2^Nのうち、凸包を作ることのできる部分集合の選び方\n\nll gcd(ll a, ll b){\n  if(b<a) swap(a, b);\n  ll r = a % b;\n  if(r==0) return b;\n  while(r!=0) r = a % b, a = b, b = r;\n  return a;\n}\nll lcm(ll a, ll b){return (a*b)/gcd(a, b);}\nvll extgcd(ll a, ll b) {\n  ll x, y;\n  for (ll u = y = 1, v = x = 0; a;) {\n    ll q = b / a;\n    swap(x -= q * u, u);\n    swap(y -= q * v, v);\n    swap(b -= q * a, a);\n  }\n  return vll{x, y, b};\n}\n\ntypedef pair<ll, ll> p;\nint main(int argc, char const *argv[]) {\n  // sample1 2^4 - 1(0個) - 4C2(直線) - 4(1点)\n  // sample2 2^5 - 1 - 5C2 - 5 - 4C3 - 4C4\n  // = 32 - 1 - 10 - 5 - 4 - 1 = 11\n  // sample3 2^1 - 1 - 1\n\n  init();\n  ll n;std::cin >> n;\n  vll t(300, 1);// 2^k\n  for(int i=1;i<300;i++) t[i] = (t[i-1]*2)%P;\n  ll all = t[n];\n  ll sub = 1 + n; //条件を満たさないもの(0点, 1点, 直線)\n\n  vvl d = VV(n, 2, 0, ll);\n  for(int i=0;i<n;i++) scanf(\"%lld %lld\", &d[i][0], &d[i][1]);\n\n  // ある点からある別の点までの方向に他の頂点があるかを確認する\n  // 他の点に注目した時も含めK回カウントされる\n\n  vll f(201, 0);//点をK個含む線がいくつあるか\n\n  for(int i=0;i<n;i++){\n    //他の点への角度を求める\n    map<p, ll> mp;\n    for(int j=0;j<n;j++){\n      if(j==i) continue;\n      ll dx = d[i][0] - d[j][0];\n      ll dy = d[i][1] - d[j][1];\n      if(dx<0) dx*=-1, dy*=-1;\n\n      if(dx==0) dy = 1;\n      else if(dy==0) dx = 1;\n      else{\n        ll g = gcd(abs(dx), abs(dy));\n        dx /= g, dy /= g;\n      }\n      //std::cout << i << \" \" << j << \" \" << \"(\" << dx << \", \" << dy << \")\" << '\\n';\n      auto itr = mp.find(p(dx, dy));\n      if(itr==mp.end()) mp.emplace(p(dx, dy), 2);\n      else (*itr).second++;\n    }\n    for(auto itr:mp) f[itr.second]++;\n  }\n  for(ll i=2;i<=n;i++) f[i]/=i;\n  //for(ll i=2;i<=n;i++) std::cout << i << \" \" << f[i] << '\\n';\n\n  for(int i=2;i<=n;i++){\n    for(int j=2;j<=i;j++){\n      sub = (sub + pp(f[i], comb(i, j)))%P;\n    }\n  }\n  std::cout << (all - sub + P)%P << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 100010\n#define ll long long\nusing namespace std;\n\nconst ll mod=998244353;\n\nll n,R,B,G,RB,RG,BG,ans=1;\n\nchar s[maxn*3];\n\nint main(){\n\tscanf(\"%lld%s\",&n,s+1);\n\tfor(int i=1;i<=n;i++) ans*=i,ans%=mod;\n\tfor(int i=1;i<=n*3;i++){\n\t\tif(s[i]=='R'){\n\t\t\tif(BG) ans*=BG,BG--;\n\t\t\telse if(B) ans*=B,B--,RB++;\n\t\t\telse if(G) ans*=G,G--,RG++;\n\t\t\telse R++;\n\t\t}\n\t\telse if(s[i]=='B'){\n\t\t\tif(RG) ans*=RG,RG--;\n\t\t\telse if(R) ans*=R,R--,RB++;\n\t\t\telse if(G) ans*=G,G--,BG++;\n\t\t\telse B++;\n\t\t}\n\t\telse if(s[i]=='G'){\n\t\t\tif(RB) ans*=RB,RB--;\n\t\t\telse if(R) ans*=R,R--,RG++;\n\t\t\telse if(B) ans*=B,B--,BG++;\n\t\t\telse G++;\n\t\t}\n\t\tans%=mod;\n\t}\n\tprintf(\"%lld\",ans%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=205;\nconst int MOD=998244353;\n\nint n,bin[N],b[N];\nbool vis[N][N];\nstruct data{int x,y;}a[N];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nint cross(int k,int i,int j)\n{\n\treturn (a[i].x-a[k].x)*(a[j].y-a[k].y)-(a[i].y-a[k].y)*(a[j].x-a[k].x);\n}\n\nint main()\n{\n\tn=read();\n\tbin[0]=1;\n\tfor (int i=1;i<=n;i++) bin[i]=bin[i-1]*2%MOD;\n\tfor (int i=1;i<=n;i++) a[i].x=read(),a[i].y=read();\n\tint ans=bin[n];\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (!vis[i][j])\n\t\t\t{\n\t\t\t\tint tot=0;\n\t\t\t\tb[++tot]=i;b[++tot]=j;\n\t\t\t\tfor (int k=j+1;k<=n;k++) if (!cross(i,j,k)) b[++tot]=k;\n\t\t\t\tfor (int k=1;k<tot;k++)\n\t\t\t\t\tfor (int l=k+1;l<=tot;l++)\n\t\t\t\t\t\tvis[b[k]][b[l]]=1;\n\t\t\t\t(ans-=bin[tot]-tot-1)%=MOD;\n\t\t\t}\n\t(ans-=n+1)%=MOD;\n\tans+=ans<0?MOD:0;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/range/irange.hpp>\n\nusing namespace std;\nusing namespace boost;\n\nconstexpr auto M = 998244353L;\n\nint64_t pow2(int64_t p) {\n  if (p == 0) {\n    return 1;\n  }\n  auto pp = pow2(p / 2);\n  return ((p%2)?2:1) * pp * pp % M;\n}\n\nmain() {\n  int64_t n;\n  cin >> n;\n  \n  vector<int64_t> x(n), y(n);\n  for (auto i : irange(0L, n)) {\n    cin >> x[i] >> y[i];\n  }\n  \n  vector<vector<unordered_set<int64_t>>> lines(n, vector<unordered_set<int64_t>>(n));\n  vector<bitset<200>> used(n, bitset<200>());\n  for (auto i : irange(0L, n)) {\n    used[i][i] = true;\n    for (auto j : irange(i + 1, n)) {\n      if (used[i][j]) {\n        continue;\n      }\n      used[i][j] = true;\n      used[j][i] = true;\n      lines[i][j].insert(i);\n      lines[i][j].insert(j);\n      bitset<200> bs;\n      bs[i] = true;\n      bs[j] = true;\n      // y = (y2 - y1) / (x2 - x1) * (x - x1) + y1\n      // (y - y1) * (x2 - x1) = (y2 - y1) * (x - x1)\n      for (auto k : irange(0L, n)) {\n        if ((y[k] - y[i]) * (x[j] - x[i]) != (y[j] - y[i]) * (x[k] - x[i])) {\n          continue;\n        }\n        lines[i][j].insert(k);\n        bs[k] = true;\n      }\n      for (auto k : lines[i][j]) {\n        used[k] |= bs;\n      }\n    }\n  }\n  \n  uint64_t ans = pow2(n);\n  ans += M - 1; // empty set\n  ans += n * (M - 1); // one size set\n  ans %= M;\n  // cerr << ans << endl;\n  for (auto i : irange(0L, n)) {\n    for (auto j : irange(0L, n)) {\n      if (lines[i][j].empty()) {\n        continue;\n      }\n      auto m = lines[i][j].size();\n      ans += (pow2(m) - 1 - m) * (M - 1);\n      ans %= M;\n      // cerr << i << \",\" << j << \" \" << m << \" \" << pow2(m) - 1 - m << \" \" << ans << endl;\n    }\n  }\n  \n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\n#define pb push_back\n#define w1 first\n#define w2 second\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=205,mod=998244353;\nconst db pi=acos(-1.0);\nint n,ans;\nint x[maxn],y[maxn],bin[maxn];\nmap<db,int>cnt;\nint main(){\n\tread(n);\n\tbin[0]=1;rep(i,1,n)bin[i]=2ll*bin[i-1]%mod;\n\tans=bin[n];\n\trep(i,1,n)read(x[i]),read(y[i]);\n\trep(i,1,n){\n\t\tcnt.clear();\n\t\trep(j,i+1,n)cnt[atan2(y[j]-y[i],x[j]-x[i])]++;\n\t\tfor(map<db,int>::iterator it=cnt.begin();it!=cnt.end();it++)ans-=bin[it->w2]-1;\n\t}\n\tprintf(\"%d\\n\",ans-n-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct point {\n\tint x, y;\n\tbool operator<(const point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tpoint operator -(const point &p)const {\n\t\treturn { x - p.x,y - p.y };\n\t}\n\tint Mul(point p) const{\n\t\treturn x*p.x + y*p.y;\n\t}\n}P[210], OO;\n\nint ccw(point a, point b, point c) {\n\treturn (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);\n}\n\nstruct Vec {\n\tpoint p;\n\tbool operator<(const Vec &v)const {\n\t\treturn p.y * v.p.x != v.p.y * p.x ? p.y * v.p.x < v.p.y * p.x : p.Mul(p) < v.p.Mul(v.p);\n\t}\n}w[210];\n\nbool between(point a, point b, point c) {\n\treturn ccw(a, b, c) == 0 && (c - a).Mul(c - b) <= 0;\n}\n\nint CC[210], D[210][210], Mod = 998244353, po[210], res, C[210][210];\n\nvoid Do(int n) {\n\tint i, j, k;\n\tif (n <= 1)return;\n\tfor (i = 1; i <= n; i++) {\n\t\tCC[i] = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (i != j && between(OO, w[i].p, w[j].p))CC[i]++;\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)for (j = i + 2; j <= n; j++){\n\t\tC[i][j] = 0;\n\t\tfor (k = i + 1; k < j; k++) if (ccw(w[i].p, w[j].p, w[k].p) >= 0)C[i][j]++;\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = i+1; j <= n; j++) {\n\t\t\tD[i][j] = 0;\n\t\t\tif (between(OO, w[j].p, w[i].p)) continue;\n\t\t\tint c = C[i][j];\n\t\t\tfor (k = 1; k < i; k ++) {\n\t\t\t\tif (ccw(w[k].p, w[i].p, w[j].p) <= 0)continue;\n\t\t\t\tD[i][j] = (D[i][j] + 1ll * D[k][i] * po[c]) % Mod;\n\t\t\t}\n\t\t\tD[i][j] = (D[i][j] + po[c + CC[i]]) % Mod;\n\t\t\tres = (res + D[i][j]) % Mod;\n\t\t}\n\t}\n}\n\nint main() {\n\tint i, j, n;\n\tscanf(\"%d\", &n);\n\tpo[0] = 1;\n\tfor (i = 1; i <= n; i++)po[i] = po[i - 1] * 2 % Mod;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &P[i].x, &P[i].y);\n\t}\n\tsort(P, P + n);\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tw[j - i].p = P[j] - P[i];\n\t\t}\n\t\tsort(w + 1, w + n - i);\n\t\tDo(n - i - 1);\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n \n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\nconst int MOD = 998244353;\nconst int INF = INT_MAX / 2;\nstruct edge { int v, w; };\n\nconst double EPS = 1e-12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n \nint main() {\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\trep(i, N) cin >> x[i] >> y[i];\n\tint ans = 1;\n\trep(t, N) ans = ans * 2 % MOD;\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\tL l({x[i],y[i]},{x[j],y[j]});\n\t\tint n = 0;\n\t\trep(k, N) if (k != i && k != j) {\n\t\t\t/*double d1 = d(x[k], y[k], x[i], y[i]);\n\t\t\tdouble d2 = d(x[k], y[k], x[j], y[j]);\n\t\t\tdouble d3 = d(x[i], y[i], x[j], y[j]);\n\t\t\tif (abs(d1 + d2 - d3) < 1e-12)*/\n\t\t\tif(intersectSP(l,{x[k],y[k]})) n++;\n\t\t}\n\t\tint x = 1;\n\t\trep(t, n) x = x * 2 % MOD;\n\t\tans = (ans - x) % MOD;\n\t}\n\tans = (ans - N - 1) % MOD;\n\tcout << (ans + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 998244353ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n;\npii pts[252];\nll bin[252];\n\nint cross(pii a,pii b){\n  return a.first*b.second - a.second*b.first;\n}\nint sp(pii a,pii b,pii c){\n  pii x = pii(b.first-a.first, b.second-a.second);\n  pii y = pii(c.first-a.first, c.second-a.second);\n  return cross(x,y);\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n){\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    pts[i] = pii(x,y);\n  }\n\n  bin[0] = 1;\n  FOR(i,1,252)bin[i] = bin[i-1]*2%MOD;\n\n  ll ans = bin[n];\n  FOR(i,0,n)FOR(j,i+1,n){\n    int x = 0;\n    FOR(k,j+1,n){\n      if(sp(pts[i],pts[j],pts[k]) == 0){\n        x++;\n      }\n    }\n    ans -= bin[x];\n  }\n  ans -= n;\n  ans -= 1;\n  printf(\"%lld\\n\",FIX(ans));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\n#define pb push_back\n#define w1 first\n#define w2 second\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=205,mod=998244353;\nconst ld pi=acos(ld(-1.0));\nint n,ans;\nint x[maxn],y[maxn],bin[maxn];\nmap<ld,int>cnt;\nint main(){\n\tread(n);\n\tbin[0]=1;rep(i,1,n)bin[i]=2ll*bin[i-1]%mod;\n\tans=bin[n];\n\trep(i,1,n)read(x[i]),read(y[i]);\n\trep(i,1,n){\n\t\tcnt.clear();\n\t\trep(j,1,n)if(i!=j)cnt[atan2(y[j]-y[i],x[j]-x[i])]++;\n\t\tfor(map<ld,int>::iterator it=cnt.begin();it!=cnt.end();it++){\n\t\t\tif(it->w1<=0)continue;\n\t\t\tif(cnt[it->w1-pi]>0)continue;\n\t\t\tans-=bin[it->w2+1]-(it->w2+1+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans-n-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int mod=998244353;\nint x[205],y[205],tw[210],n,num,ans;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>x[i]>>y[i];\n\ttw[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\ttw[i]=((tw[i-1]<<1)+mod)%mod;\n\tans=tw[n];\n\t//cout<<tw[n]<<endl;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tnum=0;\n\t\t\tfor(int k=1;k<j;k++)\n\t\t\t\tif((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))\n\t\t\t\t\tnum++;\n\t\t\tans=(ans-tw[num]+mod)%mod;\n\t\t}\n\tans-=(n+1);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REP1(i,n) for(int i=1;i<=n;i++)\n#define SZ(i) int(i.size())\n#ifdef tmd\n#define IOS()\n#define debug(...) fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);_do(__VA_ARGS__);\ntemplate<typename T> void _do(T &&x){cerr<<x<<endl;}\ntemplate<typename T, typename ...S> void _do(T &&x, S &&...y){cerr<<x<<\", \";_do(y...);}\n#else\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n'\n#define debug(...)\n#endif\n\nconst int MAXN = 202;\nconst ll MOD = 998244353;\n\ntypedef complex<ll> point;\n\nll cross (const point &p1, const point &p2) {\n    return (conj(p1)*p2).imag();\n}\n\nll mpow (ll bs, ll ep) {\n    ll ret = 1;\n    while (ep) {\n        if (ep & 1) {\n            ret = ret * bs % MOD;\n        }\n        ep >>= 1;\n        bs = bs * bs % MOD;\n    }\n    return ret;\n}\n\nint n;\nll ans;\npoint p[MAXN];\n\nll md (ll x) {\n    return (x % MOD + MOD) % MOD;\n}\n/*********************GoodLuck***********************/\nint main () {\n    IOS();\n\n    cin >> n;\n    ans = mpow(2, n) - 1 - n;\n    REP (i, n) {\n        int x, y;\n        cin >> x >> y;\n        p[i] = {x, y};\n    }\n\n    REP (i, n) {\n        REP (j, i) {\n            ll c = 0;\n            REP (k, n) {\n                if (cross(p[i]-p[j], p[k]-p[j]) == 0) {\n                    c++;\n                }\n            }\n            ans -= md(mpow(2, c) - 1 - c) * mpow(c*(c-1)/2, MOD-2) % MOD;\n            ans = md(ans);\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n \nusing ll = long long;\nusing P = std::pair<ll, ll>;\n \n#define rep(i, a, b) for (ll(i) = (a); i < (b); i++)\n#define all(i) i.begin(), i.end()\n#define debug(i) std::cerr << \"debug \" << i << std::endl\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nll pow_mod(ll a, ll b, ll mod=-1) {\n  if ((a == 0)||(mod!=-1&&a%mod==0)) {\n    return 0;\n  }\n \n  ll x = 1;\n \n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n \n// const ll MOD = 998244353;\nconst ll MOD = 1e9 + 7;\n \n \n \nint main() {\n  std::cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  ll n;\n  std::cin>>n;\n\n  std::vector<P> p(n);\n  rep(i,0,n){\n    ll x,y;\n    std::cin>>x>>y;\n\n    p[i]={x,y};\n  }\n\n  std::sort(all(p));\n\n  ll ans=(1ll<<n)-n-1;\n\n  std::vector<std::vector<bool>> check(n,std::vector<bool>(n,false));\n\n  rep(i,0,n)check[i][i]=true;\n\n  rep(i,0,n-1){\n    rep(j,i+1,n){\n      if(!check[i][j]){\n\n        std::vector<ll> temp;\n        temp.push_back(i);\n        temp.push_back(j);\n        rep(k,j+1,n){\n          if((p[k].first-p[i].first)*(p[j].second-p[i].second)==(p[j].first-p[i].first)*(p[k].second-p[i].second)){\n            temp.push_back(k);\n          }\n        }\n\n        ll cnt=temp.size();\n        ans-=(1ll<<cnt)-cnt-1;\n\n        rep(k,0,cnt)rep(l,0,cnt)check[temp[k]][temp[l]]=true;\n      }\n    }\n  }\n\n  std::cout<<ans;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <queue>\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\n#include <set>\n\nusing namespace std;\n\nconst ll mod = 998244353;\n\nll pow2(int n){\n  ll r = 1;\n  REP(i,n) r = (r * 2) % mod;\n  return r;\n}\n\nint main(){\n  const int n = getInt();\n  vector<int> x(n);\n  vector<int> y(n);\n\n  REP(i,n){\n    x[i] = getInt();\n    y[i] = getInt();\n  }\n\n  if(n <= 2) {\n    puts(\"0\");\n    return 0;\n  }\n\n  ll ans = pow2(n) - 1 - n;\n\n  for(int i = 0; i < n; i++){\n    for(int j = i + 1; j < n; j++){\n      int cnt = 2;\n      for(int k = 0; k < n; k++){\n\tif(k == i || k == j) continue;\n\n\tif((x[j] - x[i]) * (y[k] - y[i]) == (y[j] - y[i]) * (x[k] - x[i])){\n\t  if(k < j) goto bad;\n\t  cnt++;\n\t}\n      }\n\n      ans = (ans - (pow2(cnt) - cnt - 1) + mod) % mod;\n    bad:;\n    }\n  }\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n;\npp d[210];\n\nconst ll M = 998244353;\nconst ll inv2 = (M+1)/2;\n\npp operator-(pp a, pp b){\n\treturn {a.x-b.x, a.y-b.y};\n}\nll gcd(ll a, ll b){ return b?gcd(b,a%b):a; }\npp regu(pp a, bool noneg=true){\n\tif((a.x<0 || (a.x==0 && a.y<0)) && noneg) a.x=-a.x, a.y=-a.y;\n\tll g=gcd(abs(a.x), abs(a.y));\n\tif(g) a.x/=g, a.y/=g;\n\treturn a;\n}\n\nint pow2[210];\n\nint main()\n{\n\tread(n);\n\tfor(int i=1; i<=n; ++i) read(d[i].x, d[i].y);\n\tpow2[0]=1;\n\tfor(int i=1; i<=n; ++i) (pow2[i]=pow2[i-1]*2)%=M;\n\tll ans=0;\n\tfor(int i=1; i<=n; ++i){\n\t\tmap<pp, vector<int>> v;\n\t\tfor(int j=1; j<=n; ++j){\n\t\t\tif(i==j) continue;\n\t\t\tv[regu(d[j]-d[i])].pb(j);\n\t\t}\n\t\tfor(auto& T:v){\n\t\t\tauto& v=T.second;\n\t\t\tbool flg=1;\n\t\t\tfor(int x:v){\n\t\t\t\tif(regu(d[x]-d[i],0) != regu(d[v[0]]-d[i], 0)){\n\t\t\t\t\tflg=0; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg){\n\t\t\t\tint k = v.size()+1;\n\t\t\t\t(ans += (pow2[k]-1-k+2*M)%M)%=M;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", (pow2[n]-1-n-inv2*ans%M+M)%M);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 998244353;\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\ntemplate<typename T>\nT preback (const vector<T> &v) {\n  return *next(v.rbegin());\n}\n\ntypedef pair<int, int> point;\n#define x first\n#define y second\n\npoint operator+ (point p, point q) {\n  return {p.x + q.x, p.y + q.y};\n}\n\npoint operator- (point p) {\n  return {-p.x, -p.y};\n}\n\npoint operator- (point p, point q) {\n  return p + (-q);\n}\n\nint dot (point p, point q) {\n  return p.x * q.x + p.y * q.y;\n}\n\nint cross (point p, point q) {\n  return p.x * q.y - p.y * q.x;\n}\n\nint orient (point p, point q, point r) {\n  return cross(q - p, r - p);\n}\n\nint cw (point p, point q, point r) {\n  return cross(q - p, r - p) < 0;\n}\n\nstruct basecomp {\n  point base;\n  basecomp (point _base) : base(_base) {}\n\n  bool operator() (point p, point q) {\n    if (orient(base, p, q) == 0) {\n      return dot(p - base, p - base) < dot(q - base, q - base);\n    } else {\n      return orient(base, p, q) < 0;\n    }\n  }\n};\n\nconst int MAX_N = 205;\n\nModint ans;\nModint dp [MAX_N][MAX_N];\n\nvoid solve (vector<point> &pts) {\n  sort(pts.begin(), pts.end());\n  point base = pts[0];\n  sort(pts.begin(), pts.end(), basecomp(base));\n\n  int n = pts.size();\n  for (int i = 1; i < n; i++) {\n    dp[0][i] = 1; // # of points on the line 0..i\n    for (int j = 1; j < i; j++) {\n      if (orient(base, pts[i], pts[j]) == 0) {\n        dp[0][i] *= 2;\n      }\n    }\n  }\n\n  for (int u = 1; u < n; u++) {\n    for (int v = u + 1; v < n; v++) {\n      dp[u][v] = 0;\n      for (int w = 0; w < u; w++) {\n        if (cw(pts[w], pts[u], pts[v])) {\n          dp[u][v] += dp[w][u];\n        }\n      }\n\n      // count the # of points in the triangle\n      for (int w = u + 1; w < v; w++) {\n        if (cw(base, pts[u], pts[w]) &&\n            cw(pts[u], pts[v], pts[w]) &&\n            orient(pts[v], base, pts[w]) >= 0) {\n          dp[u][v] *= 2;\n        }\n      }\n\n      ans += dp[u][v];\n    }\n  }\n\n  reverse(pts.begin(), pts.end());\n  pts.pop_back();\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  vector<point> pts (n);\n  for (int i = 0; i < n; i++) {\n    cin >> pts[i].x >> pts[i].y;\n  }\n\n  while ((int) pts.size() >= 3) {\n    solve(pts);\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing lint = long long;\nusing P = pair<int, int>;\nconstexpr lint MOD = 998244353;\n\ntemplate <typename T>\nT power(T x, T n, T mod)\n{\n    T ans = 1;\n    while (n>0)\n    {\n        if (n & 1) ans = ans * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return ans;\n}\n\nvector<P> ps;\n\nbool collinear(P p, P q, P r)\n{\n    return (q.second - p.second) * (r.first - p.first) == (q.first - p.first) * (r.second - p.second);\n}\n\nint N;\n\nint main()\n{\n    cin >> N;\n    ps.resize(N);\n    for (int i=0; i<N; i++) cin >> ps[i].first >> ps[i].second;\n\n    lint ans = (power(2LL, (lint)N, MOD) - 1 - N + MOD) % MOD;\n\n    vector<vector<bool> > edge(N, vector<bool>(N, false));\n\n    for (int i=0; i<N; i++)\n    {\n        for (int j=i+1; j<N; j++)\n        {\n            if (edge[i][j]) continue;\n            vector<int> kyosen = {i, j};\n            for (int k=j+1; k<N; k++)\n            {\n                if (collinear(ps[i], ps[j], ps[k])) kyosen.push_back(k);\n            }\n            ans = (ans - power(2LL, (lint)kyosen.size(), MOD) + 1 + kyosen.size() + MOD) % MOD;\n\n            for (int k=0; k<kyosen.size(); k++)\n            {\n                for (int l=k+1; l<kyosen.size(); l++) edge[k][l] = true;\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 205, mo = 998244353 ;\nusing namespace std ;\n\nint n, fac[N], G[N][N] ;\nstruct poi {\n\tint x, y ;\n} a[N] ;\n\nint cross(poi p0, poi p1, poi p2) {\n\treturn (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) ;\n}\n\nint main() {\n\tscanf(\"%d\", &n) ;\n\trep(i, 1, n) scanf(\"%d%d\", &a[i].x, &a[i].y) ;\n\tfac[0] = 1 ;\n\trep(i, 1, n) fac[i] = (ll) fac[i - 1] * 2 % mo ;\n\tint ans = fac[n] - 1 - n ; ans %= mo ;\n\trep(i, 1, n) {\n\t\trep(j, i + 1, n) {\n\t\t\tint cnt = 2, res = 0, w = 1 ;\n\t\t\trep(k, 1, n) if (!cross(a[i], a[j], a[k]) && k != i && k != j) {\n\t\t\t\tif (G[k][i] || G[k][j] || G[i][k] || G[j][k]) w = 0 ;\n\t\t\t\t++ cnt ;\n\t\t\t}\n\t\t\tres = fac[cnt] - 1 - cnt ;\n\t\t\tans -= res * w, ans %= mo ;\n\t\t\trep(k, 1, n) if (!cross(a[i], a[j], a[k]) && j != k && i != k) G[i][k] = G[k][i] = G[j][k] = G[k][j] = true ;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (ans + mo) % mo) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vdouble = vector<double>;\nusing vvdouble = vector<vdouble>;\nusing vvvdouble = vector<vvdouble>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\nconstexpr int mod2 = 998244353;\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) { return (a > b && (a = b, true)); }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) { return (a < b && (a = b, true)); }\ntemplate<typename T>\nbool isin(T y, T x, T h, T w) { return (0 <= y && 0 <= x && y < h && x < w); }\ntemplate<typename T>\nbool isin1(T y, T x, T h, T w) { return (0 < y && 0 < x && y <= h && x <= w); }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++) os << \" \" << v[i];\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nconstexpr double EPS = 1e-10;\nbool equals(double a, double b) { return (abs(a - b) < EPS); }\n\nstruct V2 {\n\tdouble x, y;\n\tV2(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tV2 operator + (V2 p) const { return (V2(x + p.x, y + p.y)); }\n\tV2 operator - (V2 p) const { return (V2(x - p.x, y - p.y)); }\n\tV2 operator * (double r) const { return (V2(x * r, y * r)); }\n\tV2 operator / (double r) const { return (V2(x / r, y / r)); }\n\n\tdouble norm() const { return (sqrt(sqrNorm())); }\n\tdouble sqrNorm() const { return (x*x + y*y); }\n\n\tbool operator < (const V2 &p) const { \n\t\treturn (x != p.x ? x < p.x : y < p.y); \n\t}\n\tbool operator == (const V2 &p) const {\n\t\treturn (equals(x, p.x) && equals(y, p.y));\n\t}\n\n\tV2 rotate90() const { return (V2(y, -x)); }\n\tV2 normalized() const { return (*this / norm()); }\n\n\tdouble dot(const V2 &p) const { return (x*p.x + y*p.y); }\n\tdouble cross(const V2 &p) const { return (x*p.y - y*p.x); }\n\tdouble arg() const { return (atan2(y, x)); }\n};\n\nvoid Main() {\n\tint N; cin >> N;\n\tvector<V2> ps(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> ps[i].x >> ps[i].y;\n\t}\n\n\tll sum = 0;\n\n\tsort(begin(ps), end(ps));\n\tfor (int a = 0; a < N; a++) {\n\t\tvector<pair<double, V2>> dats;\n\t\tint n = N-a-1;\n\t\tfor (int b = a+1; b < N; b++) {\n\t\t\tdats.emplace_back((ps[b]-ps[a]).arg(), ps[b]-ps[a]);\n\t\t}\n\t\tsort(begin(dats), end(dats));\n\t\tvector<V2> nps(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnps[i] = dats[i].second;\n\t\t}\n\n\t\tvvll contval(n, vll(n, 1));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tfor (int k = j+1; k < n; k++) {\n\t\t\t\t\tif ((nps[k]-nps[i]).cross(nps[j]-nps[i]) > -EPS) {\n\t\t\t\t\t\t(contval[i][k] *= 2) %= mod2;\n\t\t\t\t\t\t//cout << a << \" \" << nps[i].x << \" \" << nps[i].y << \" \" << nps[k].x << \" \" << nps[k].y << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tvvll dp(n, vll(n, 0));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tif (!equals(nps[i].cross(nps[j]), 0.0)) dp[i][j] = contval[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tV2 v1 = nps[j]-nps[i];\n\t\t\t\tfor (int k = j+1; k < n; k++) {\n\t\t\t\t\tV2 v2 = nps[k]-nps[j];\n\t\t\t\t\tif (v1.cross(v2) < EPS) continue;\n\t\t\t\t\tif (equals(nps[j].arg(), nps[k].arg())) continue;\n\t\t\t\t\t(dp[j][k] += contval[j][k] * dp[i][j]) %= mod2;\n\t\t\t\t}\n\t\t\t\t(sum += dp[i][j]) %= mod2;\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int mod=998244353;\nint n;\nint x[205],y[205],p[205];\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d%d\",&x[i],&y[i]);\n    p[0]=1;\n    for(int i=1;i<=n;i++)\n        p[i]=(p[i-1]*2)%mod;\n    int ans=p[n]-n-1;\n    for(int i=1;i<=n;i++)\n\t{\n        for(int j=1;j<i;j++)\n\t\t{\n            int cnt=0;\n            for(int k=1;k<j;k++)\n\t\t\t{\n                if((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))\n                    cnt++;\n            }\n            ans=(ans-p[cnt]+mod)%mod;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n\n\n//using namespace __gnu_pbds;\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n/*\ntypedef\ntree<\n  int, // Data type\n  null_type,\n  less<int>, // Comparator function for the data type\n  rb_tree_tag,\n  tree_order_statistics_node_update>\nordered_set;\n*/\n\nconst ll MOD_CONST = 1000000007ll;\n\n\nll modSum(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b, ll MOD = MOD_CONST) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e, ll MOD = MOD_CONST) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2, MOD);\n    return modProd(tmp, tmp, MOD);\n  } else {\n    ll tmp = getPowMod(x, e-1, MOD);\n    return modProd(tmp, x, MOD);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\n\nll getInverse(ll x, ll MOD = MOD_CONST) {\n  return getPowMod(x, MOD-2, MOD);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\nll gcd(ll a, ll b, ll & x, ll & y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\n\npair<ll, ll> getIntersectingRange(ll a1, ll b1, ll a2, ll b2) {\n  ll s = max(a1, a2);\n  ll e = min(b1, b2);\n\n  return {s, e};\n}\n\n\nbool isNonEmptyIntersection(ll a1, ll b1, ll a2, ll b2) {\n  auto p = getIntersectingRange(a1, b1, a2, b2);\n  return p.first <= p.second;\n}\n\n\ndouble getPointDistance(double x1, double y1, double x2, double y2) {\n  double dx = x1-x2;\n  double dy = y1-y2;\n  double d = (dx * dx) + (dy * dy);\n  return sqrt(d);\n}\n\n\nbool isPrime(ll x) {\n  if (x == 2 || x == 3 || x == 5 || x == 7) return true;\n  if (x < 10) return false;\n  ll till = min((ll)sqrt(x) + 1, x-1);\n  for (ll i = 2 ; i <= till ; i++) {\n    if (x % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nconst int TREE_SIZE = 1;\n\n\nll segTree[TREE_SIZE], lazyTree[TREE_SIZE];\n\n\nvoid updateRange(int node, int start, int end, int l, int r, ll val)\n{\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];    // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];                  // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];                // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                                  // Reset it\n    }\n    if(start > end or start > r or end < l)              // Current segment is not within range [l, r]\n        return;\n    if(start >= l and end <= r)\n    {\n        // Segment is fully within range\n        segTree[node] += (end - start + 1) * val;\n        if(start != end)\n        {\n            // Not leaf node\n            lazyTree[node*2] += val;\n            lazyTree[node*2+1] += val;\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    updateRange(node*2, start, mid, l, r, val);        // Updating left child\n    updateRange(node*2 + 1, mid + 1, end, l, r, val);   // Updating right child\n    segTree[node] = segTree[node*2] + segTree[node*2+1];        // Updating root with max value\n}\n\n\nll queryRange(int node, int start, int end, int l, int r)\n{\n    if(start > end or start > r or end < l)\n        return 0;         // Out of range\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];            // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];         // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];    // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                 // Reset it\n    }\n    if(start >= l and end <= r)             // Current segment is totally within range [l, r]\n        return segTree[node];\n    int mid = (start + end) / 2;\n    ll p1 = queryRange(node*2, start, mid, l, r);         // Query left child\n    ll p2 = queryRange(node*2 + 1, mid + 1, end, l, r); // Query right child\n    return (p1 + p2);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst int MAXN = 201;\nconst ll MOD = 998244353;\n\n\nint N;\nint ar_x[MAXN], ar_y[MAXN]; \n\n\nvoid input() {\n  cin >> N;\n  for (int i = 1 ; i <= N ; i++) {\n    cin >> ar_x[i] >> ar_y[i];\n  }\n}\n\n\nvoid preprocess() {\n}\n\n\nvoid solve() {\n  ll ans = getPowMod(2, N, MOD);\n  ans = modSubtract(ans, 1, MOD);\n  ans = modSubtract(ans, N, MOD);\n  ans = modSubtract(ans, (N * (N-1)) / 2, MOD);\n  //cerr << \"Ans = \" << ans << \"\\n\";\n  for (int i = 1 ; i <= N ; i++) {\n    for (int j = i+1 ; j <= N ; j++) {\n      int x_coeff = ar_y[j] - ar_y[i];\n      int y_coeff = ar_x[i] - ar_x[j];\n      int const_coeff = ((-ar_x[i]) * x_coeff) + ((-ar_y[i]) * y_coeff);\n      bool add = true;\n      int freq = 2;\n      for (int k = 1 ; k <= N ; k++) {\n        if (k == i || k == j) continue;\n        bool online = ((x_coeff * ar_x[k]) + (y_coeff * ar_y[k]) + const_coeff) == 0;\n        if (!online) continue;\n        if (k < i || k < j) { \n          add = false;\n          break;\n        }\n        freq++;\n      }\n      if (!add) continue;\n      //cerr << \"Freq = \" << freq << \"\\n\";\n      ans = modSubtract(ans, getPowMod(2, freq, MOD), MOD);\n      ans = modSum(ans, 1, MOD);\n      ans = modSum(ans, freq, MOD);\n      ans = modSum(ans, (freq * (freq-1)) / 2, MOD);\n    }\n  }\n  cout << ans;\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) FOR(i,0,n)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define PQ priority_queue\n#define UM unordered_map\n#define US unordered_set\n#define ALL(a) (a).begin(),(a).end()\ntypedef vector<ll> vi;\ntypedef vector<vector<ll>> vvi;\nconst ll INF = (1ll << 60);\ntypedef pair<ll,ll> pii;\ntypedef vector<vector<ll>> Graph;\nstruct Node {ll v,d,p,l,r;};\ntypedef vector<Node> Tree;\nstruct Point {ll x,y;};\nstruct Vector {ll x,y;};\ntypedef pair<Point,Point> Edge;\nVector operator-(Point a,Point b) {\n  Vector vec;\n  vec.x=a.x-b.x; vec.y=a.y-b.y;\n  return vec;\n}\nll operator*(Vector &a,Vector &b) {return a.x*b.x+a.y*b.y;}\nbool onLine(Point a,Point b,Point c) {\n  if(a.x==b.x&&b.x==c.x) return true;\n  if(a.y==b.y&&b.y==c.y) return true;\n  Vector v1=a-b,v2=c-b;\n  if((v1*v1)*(v2*v2)==(v1*v2)*(v1*v2)) return true;\n  return false;\n}\nbool operator<(Point a,Point b) {\n  if(a.x<b.x) return true;\n  if(a.x>b.x) return false;\n  return a.y<b.y;\n}\nbool operator==(Point a,Point b) {return a.x==b.x&&a.y==b.y;}\nbool operator==(Edge a,Edge b) {return a.first==b.first&&a.second==b.second;}\n\nnamespace std {\n  template<>\n  struct hash<Edge> {\n    size_t operator()(const Edge e) const{\n      return hash<ll>()(e.first.x)^hash<ll>()(e.first.y)^hash<ll>()(e.second.x)^hash<ll>()(e.second.y);\n    }\n  };\n}\n\nvoid print(Edge a){\n  printf(\"(%lld,%lld),(%lld,%lld)\\n\",a.first.x,a.first.y,a.second.x,a.second.y);\n}\nconst ll MOD = 998244353;\n\nll pw(ll a){\n  ll ret=1;\n  REP(i,a) ret=ret*2%MOD;\n  return ret;\n}\n\nll mod(ll a){\n  return ((a%MOD)+MOD)%MOD;\n}\n\nint main(){\n  ll N; cin>>N;\n  vector<Point> P(N); REP(i,N) cin>>P[i].x>>P[i].y;\n  UM<Edge,ll> um;\n  REP(i,N) FOR(j,i+1,N) {\n    Edge edge={P[i],P[j]};\n    if(!(edge.first<edge.second)) swap(edge.first,edge.second);\n    ll cnt=2;\n    REP(k,N) {\n      if(k==i||k==j) continue;\n      if(onLine(P[i],P[j],P[k])) {\n        if(P[k]<edge.first) edge.first=P[k];\n        if(edge.second<P[k]) edge.second=P[k];\n        cnt++;\n      }\n    }\n    um[edge]=cnt;\n  }\n\n  ll sum=0;\n  for(auto i:um) {sum+=pw(i.second)-(1+i.second); sum%=MOD;}\n  cout<<mod(pw(N)-sum-N-1)<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n#define DEBUG_IS_VALID \n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){cout << \"{\"; for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\nvoid _main();\nint main(){ cin.tie(0); ios::sync_with_stdio(false); _main(); return 0;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-5,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntemplate<typename T, int FAC_MAX> struct Comb { vector<T> fac, ifac;\n    Comb(){fac.resize(FAC_MAX,1);ifac.resize(FAC_MAX,1); for(int i = 1; i < FAC_MAX; i++)fac[i]=fac[i-1]*i;\n        ifac[FAC_MAX-1]=T(1)/fac[FAC_MAX-1];for(int i = FAC_MAX-2; i >= 1; i--)ifac[i]=ifac[i+1]*T(i+1);}\n    T aPb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b]; }\n    T aCb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b] * ifac[b]; }\n    T nHk(int n, int k) { if (n == 0 && k == 0) return T(1); if (n <= 0 || k < 0) return 0;\n        return aCb(n + k - 1, k); }}; // nHk = (n+k-1)Ck : n is separator\n\nusing mint =  ModInt<998244353>;\n\nstruct nd{\n  double x;\n  nd(double x):x(x){};\n};\n\nbool operator<(const nd &lhs, const nd &rhs)\n{\n    return lhs.x < rhs.x - EPS;\n}\n\nvoid _main(){\n  int N; cin >> N ;\n  using vd = vector<double>;\n  using Pd = pair<double,double>;\n  vd x(N),y(N);\n  map<nd,map<nd,int>> mp;\n  rep(i,N) cin >> x[i] >> y[i] ;\n  rep(i,N) rep(j,N){\n    if(i==j) continue;\n    double a,b;\n    if(x[j]==x[i]){\n      a = 1e10; b = x[i];\n    }else{\n      a = (y[j]-y[i])/(x[j]-x[i]);\n      b = y[i] - a * x[i];\n    }\n    mp[a][b]++;\n  }\n  mint ans = mint(2)^N;\n  for(auto&& p:mp){\n    for(auto&& p2:p.second){\n      int cnt = 0;\n      auto a = p.first;\n      auto b = p2.first;\n      if(a.x!=1e10){ rep(i,N) if(abs(y[i]-a.x*x[i]-b.x)<EPS) cnt++; }\n      else rep(i,N) if(abs(x[i]-b.x)<EPS) cnt++;\n      ans -= (mint(2)^cnt) - mint(cnt+1);\n    }\n  }\n  ans -= mint(1+N);\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a) for(int i=0;i<(a);i++)\nconst ll MOD=998244353;\n\nll beki[222];\nint used[222][222];\n\nint main(){\n  beki[0]=1;\n  rep(i,202) beki[i+1]=beki[i]*2%MOD;\n  ll N; cin>>N;\n  ll X[N],Y[N]; rep(i,N) cin>>X[i]>>Y[i];\n  ll ans=(beki[N]-1-N-N*(N-1)/2+MOD)%MOD;\n  rep(i,N) rep(j,i) if(used[i][j]==0){\n    vector<int> V;\n    V.push_back(i);\n    V.push_back(j);\n    rep(k,N) if(k!=i&&k!=j){\n      if((X[k]-X[j])*(Y[i]-Y[j])-(X[i]-X[j])*(Y[k]-Y[j])==0) V.push_back(k);\n    }\n    ll n=V.size();\n    rep(k,n) rep(l,n) used[V[k]][V[l]]=1;\n    if(n>=3) ans=(ans+MOD-beki[n]+1+n+n*(n-1)/2)%MOD;\n  }\n  cout<<ans%MOD<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <int MOD> struct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tModInt(signed long long sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = (unsigned long long)x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n\tModInt inverse() const {\n\t\tsigned a = x, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tsigned t = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\tif (u < 0)\n\t\t\tu += MOD;\n\t\tModInt res;\n\t\tres.x = (unsigned)u;\n\t\treturn res;\n\t}\n};\ntemplate <int MOD> ostream &operator<<(ostream &os, const ModInt<MOD> &m) {\n\treturn os << m.x;\n}\ntemplate <int MOD> istream &operator>>(istream &is, ModInt<MOD> &m) {\n\tsigned long long s;\n\tis >> s;\n\tm = ModInt<MOD>(s);\n\treturn is;\n};\n// pow(mint(2), 1000) のように\ntemplate <int MOD> ModInt<MOD> pow(ModInt<MOD> a, unsigned long long k) {\n\tModInt<MOD> r = 1;\n\twhile (k) {\n\t\tif (k & 1)\n\t\t\tr *= a;\n\t\ta *= a;\n\t\tk >>= 1;\n\t}\n\treturn r;\n}\n\n//#define int long long を使っても大丈夫\nusing mint = ModInt<998244353>;\n\n// nCrで用いる\nvector<mint> fact, factinv;\n// nCrで用いる 予め計算しておく\nvoid nCr_compute_factinv(int N) {\n\tN = min(N, mint::Mod - 1);\n\tfact.resize(N + 1);\n\tfactinv.resize(N + 1);\n\tfact[0] = 1;\n\trep(i, 1, N + 1) fact[i] = fact[i - 1] * i;\n\tfactinv[N] = fact[N].inverse();\n\tfor (int i = N; i >= 1; i--)\n\t\tfactinv[i - 1] = factinv[i] * i;\n}\nmint nCr(int n, int r) {\n\tif (n >= mint::Mod)\n\t\treturn nCr(n % mint::Mod, r % mint::Mod) *\n\t\tnCr(n / mint::Mod, r / mint::Mod);\n\treturn r > n ? 0 : fact[n] * factinv[n - r] * factinv[r];\n}\n\nmint nHr(int n, int r) { return r == 0 ? 1 : nCr(n + r - 1, r); }\n\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N; cin >> N;\n\tvector<int>x(N), y(N); rep(i, 0, N) { cin >> x[i] >> y[i]; }\n\tmint ans = pow(mint(2), N) - 1 - N;\n\tset<tuple<int, int, int>>st;\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tint dy = y[j] - y[i];\n\t\t\tint dx = x[j] - x[i];\n\t\t\ttuple<int, int, int>t;\n\t\t\tif (dx == 0) {\n\t\t\t\tt = make_tuple( x[i],0,0 );\n\t\t\t}\n\t\t\telse t = make_tuple(dy, -dx, -dy * x[i] + dx * y[i]);\n\t\t\tdump(t);\n\t\t\tif (st.count(t))continue;\n\t\t\tst.insert(t);\n\t\t\tint cnt = 0;\n\t\t\trep(k, 0, N) {\n\t\t\t\tif (dx!=0 and y[k] * dx == dy * (x[k] - x[i]) + y[i] * dx) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\telse if (dx == 0 and x[i] == x[k]) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdump(cnt);\n\t\t\tans -= pow(mint(2), cnt) - cnt - 1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <iterator>\n#define LL long long\n#define For(x) for (int i=1;i<=n;++i)\n#define rep(i,x) for (int i=1;i<=x;++i)\n#define repp(i,x,y) for (int i=x;i<=y;++i) \n#define F(x) for (int i=head[x];i;i=b[i].next)\n#define mk(x,y) make_pair(x,y)\n#define ft first\n#define sd second\n#define _ b[i].v;\n#define mod  998244353\nconst int maxn=2e2+10;\nusing namespace std;\n\nint n,x[maxn],y[maxn];\nLL tmp1,tmp2,tmp,ans;\nmap <pair<LL,LL>,int> a;\n\nLL qsm(LL a,LL b)\n{\n\tLL tmp=1;\n\twhile (b)\n\t{\n\t\tif (b&1) tmp=tmp*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn tmp;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tans=(qsm(2,n)-n-1+mod)%mod;\n\tFor (n) scanf(\"%d%d\",&x[i],&y[i]);\n\tFor (n)\n\t{\n\t\ta.clear();\n\t\trepp(j,i+1,n)\n\t\t{\n\t\t\ttmp1=y[i]-y[j];\n\t\t\ttmp2=x[i]-x[j];\n\t\t\ttmp=__gcd(tmp1,tmp2);\n\t\t\ttmp1/=tmp;\n\t\t\ttmp2/=tmp;\n\t\t\t++a[mk(tmp1,tmp2)];\n\t\t}\n\t\tfor (map <pair<LL,LL>,int>::iterator k=a.begin();k!=a.end();++k)\n\t\t  ans=(ans-qsm(2,k->sd)+1+mod)%mod;\n\t}\n\treturn 0*printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef array<int,3> A;\n// gcd\nLL gcd(LL a, LL b) {\n\twhile(b){\n\t\tauto t=a%b;\n\t\ta=b;\n\t\tb=t;\n\t}\n\treturn a;\n}\nconst LL M=998244353;\nLL C[201][201];\nLL ps[201];\nLL f(int i){\n\tif(i<3){\n\t\treturn 0;\n\t}\n\treturn (ps[i]-C[i][0]-C[i][1]-C[i][2]+3*M)%M;\n}\nP in[201];\nint main() {\n\tfor(int i=0;i<201;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t\t\tC[i][j]%=M;\n\t\t}\n\t}\n\tps[0]=1;\n\tfor(int i=1;i<201;i++){\n\t\tps[i]=ps[i-1]*2%M;\n\t}\n\t\n\tint N;\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tin[i]=P(a,b);\n\t}\n\tmap<A,vector<int> > ls;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tint x=in[j].first-in[i].first;\n\t\t\tint y=in[j].second-in[i].second;\n\t\t\tint g=gcd(x,y);\n\t\t\tx/=g;\n\t\t\ty/=g;\n\t\t\tif(x<0){\n\t\t\t\tx=-x;\n\t\t\t\ty=-y;\n\t\t\t}\n\t\t\tint v=in[i].first*y-in[i].second*x;\n\t\t\tA k={{x,y,v}};\n\t\t\tls[k].push_back(i);\n\t\t\tls[k].push_back(j);\n\t\t}\n\t}\n\tLL ret=f(N);\n\tfor(auto t:ls){\n\t\tauto& v=t.second;\n\t\tsort(v.begin(),v.end());\n\t\tauto s=unique(v.begin(),v.end())-v.begin();\n\t\tret+=M-f(s);\n\t\tret%=M;\n\t}\n\tprintf(\"%lld\\n\",ret);\n\n\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define x first\n#define y second\n\nusing namespace std;\n\nconst int p = 998244353;\n\ntypedef pair<int, int> pii;\n\npii a[202];\n\nint ccw(pii u, pii v, pii w) {\n\treturn (u.x - v.x) * (u.y - w.y) - (u.y - v.y) * (u.x - w.x);\n}\n\nint main() {\n\tint i, j, k, n, t, r = 0;\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &a[i].x, &a[i].y);\n\t}\n\tr = n + 1;\n\tfor (i = 0; i < n; i++) for (j = 0; j < i; j++) {\n\t\tt = 1;\n\t\tfor (k = 0; k < j; k++) if (ccw(a[i], a[j], a[k]) == 0) {\n\t\t\tt = (t << 1) % p;\n\t\t}\n\t\tr = (r + t) % p;\n\t}\n\tt = 1;\n\tfor (i = 0; i < n; i++) t = (t << 1) % p;\n\tprintf(\"%d\\n\", (t - r + p) % p);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=200;\nconst ll MOD=998244353;\nll mpw(ll n,ll m){\n\tll ret=1;\n\twhile(m){\n\t\tif (m&1){\n\t\t\tret*=n;\n\t\t\tret%=MOD;\n\t\t}\n\t\tn*=n;\n\t\tn%=MOD;\n\t\tm>>=1;\n\t}\n\treturn ret;\n}\nstruct vec{\n\tint x,y;\n\tvec(int x=0,int y=0):x(x),y(y){}\n};\nvec operator - (const vec &v1,const vec &v2){\n\treturn vec(v1.x-v2.x,v1.y-v2.y);\n}\nint crs(vec v1,vec v2){\n\treturn v1.x*v2.y-v1.y*v2.x;\n}\nint N;\nvec P[MAX_N];\nstruct lin{\n\tvec v1,v2;\n\tlin(vec v1=vec(),vec v2=vec()):v1(v1),v2(v2){}\n};\nbool isl(vec v1,vec v2,vec v3){\n\treturn crs(v2-v1,v3-v1)==0;\n}\nint main(){\n\tcin>>N;\n\tREP(i,N){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tP[i]=vec(x,y);\n\t}\n\tll ans=0;\n\tans=mpw(2,N)-1-N;\n\tans%=MOD;\n\tans+=MOD;\n\tans%=MOD;\n\tREP(i,N){\n\t\tFOR(j,i+1,N){\n\t\t\tlin l(P[i],P[j]);\n\t\t\tint cnt=2;\n\t\t\tbool f=true;\n\t\t\tREP(k,N){\n\t\t\t\tif (k==i || k==j) continue;\n\t\t\t\tif (isl(l.v1,l.v2,P[k])){\n\t\t\t\t\tif(k>j){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tf=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f){\n\t\t\t\tans-=((mpw(2,cnt)-cnt-1)%MOD+MOD)%MOD;\n\t\t\t\tans+=MOD;\n\t\t\t\tans%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1005,INF=1<<30;\nconst double eps=0.000000003;\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    int N;cin>>N;\n    vector<double> X(N),Y(N);\n    for(int i=0;i<N;i++){\n        cin>>X[i]>>Y[i];\n    }\n    \n    ll ans=rui(2,N);\n    ans+=mod-(N+1);\n    ans%=mod;\n    \n    for(int a=0;a<N;a++){\n        for(int b=a+1;b<N;b++){\n            ll cnt=0;\n            for(int k=0;k<N;k++){\n                if(k==a||k==b) continue;\n                double i=atan2(X[b]-X[k],Y[b]-Y[k]),j=atan2(X[a]-X[k],Y[a]-Y[k]);\n                if(i>=0&&j<0) swap(i,j);\n                if(i<=0&&j>0){\n                    if(abs(abs(i)-j)<eps) cnt++;\n                }\n            }\n            ans+=mod-rui(2,cnt);\n            ans%=mod;\n        }\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Math = ♥\n// Sometimes it is people that no one imagines anything of who do things that no one can imagine\n// After all this time? Always\n\n#include <bits/stdc++.h>                        // uncomment before submission\n//#include <ext/pb_ds/assoc_container.hpp>\t\t// uncomment before submission\n//#include <ext/pb_ds/tree_policy.hpp>\t\t\t// uncomment before submission\n//using namespace __gnu_pbds;\t\t\t\t\t// uncomment before submission\nusing namespace std;\n//<---------------------------------------------------Template----------------------------------------------------------->\n#define int long long\n#define ll long long\n#define ld long double\nint INF = 1e9 + 7;\ntypedef pair<ll, ll> ii;\ntypedef vector<ll> vi;                  // Vector of long long\ntypedef vector<vi> vvi;                 // Vector of vi\ntypedef vector<ii> vii;                 // Vector of pairs\ntypedef vector<vii> vvii;               // Vector of Vector of pairs\ntypedef vector<bool> vb;                // Vector of bool\n#define pq priority_queue               // Max heap (To convert to min heap, use negative sign before every value)\n#define ff first                        // For pairs\n#define ss second                       // For pairs\n#define pb push_back                    // Pushback to vector\n#define mp make_pair                    // Makes pairs to be stored as pair\n#define all(c) (c).begin(), (c).end()   // Mainly used by me in sorting\n// ordered_set adds two new functions to set - (set).find_by_order([kth element based on zero indexing]) and order_of_key()\n// order_of_key returns number of elements less that parameter. If element exists, that order is its index\n#define ordered_set tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>\n//<----------------------------------------------------------------------------------------------------------------------->\n\nint mod = 998244353;\n\nint binpow(int x, int n)\n{\n    int ans = 1;\n    if (n < 0) return 0;\n    while (n != 0)\n    {\n        if (n % 2 == 0)\n            ans = (ans * x) % mod;\n        x = (x * x) % mod;\n        n = n / 2;\n    }\n    return ans;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    ii a[n + 5];\n\n    for (int i = 0; i < n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        a[i].ff = x, a[i].ss = y;\n    }\n\n    int ans;\n    ans = binpow(2, n) - 1 - n;\n    ans = (ans + mod) % mod;\n\n    for (int i = 0; i < n - 1; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            int count = 0;\n            for (int k = j + 1; k < n; ++k)\n            {\n                int x1 = a[i].ff - a[j].ff, y1 = a[j].ff - a[k].ff;\n                int x2 = a[i].ss - a[j].ss, y2 = a[j].ss - a[k].ss;\n\n                if (x1 * y2 == y1 * x2)\n                    count++;\n            }\n            ans = ((int) (mod + ans - binpow(2, count))) % mod;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long modexp(int x, long long e, int m) {\n    long long ans = 1, p = x % m;\n    while (e > 0) {\n        if (e % 2 != 0) ans = (ans * p) % m;\n        p = (p * p) % m;\n        e >>= 1;\n    }\n    return ans;\n}\n\nconst int M = 998244353;\n\nstruct P { int x, y; };\n\nbool colinear(P a, P b, P c) {\n    int x1 = a.x - c.x, y1 = a.y - c.y,\n        x2 = b.x - c.x, y2 = b.y - c.y;\n    return x1 * y2 == x2 * y1;\n}\n\nint main() {\n    int n; cin >> n;\n    P p[n]; for (int i = 0; i < n; i++) cin >> p[i].x >> p[i].y;\n    long long ans = modexp(2, n, M) - 1 - n - n * (n - 1) / 2;\n    for (int i = 0; i < n; i++)\n        for (int j = i+1; j < n; j++) {\n            int count = 0;\n            for (int k = j+1; k < n; k++)\n                if (colinear(p[i], p[j], p[k])) count++;\n            if (count > 0)\n                ans -= modexp(2, count, M) - 1;\n        }\n    cout << (ans % M + M) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n  return a * (b / gcd(a, b));\n}\n\nstruct pt {\n  ll x, y;\n};\n\npt operator-(const pt &a, const pt &b) {\n  return pt {a.x - b.x, a.y - b.y};\n}\n\nstruct frac {\n  ll num, den;\n};\n\nvoid cancel(frac &a) {\n  ll d = gcd(a.num, a.den);\n  a.num /= d;\n  a.den /= d;\n  if (a.num <= 0 && a.den <= 0) {\n    a.num *= -1;\n    a.den *= -1;\n  }\n  if (a.num >= 0 && a.den <= 0) {\n    a.num *= -1;\n    a.den *= -1;\n  }\n}\n\nfrac operator*(const frac &a, ll b) {\n  frac res = frac {a.num * b, a.den};\n  cancel(res);\n  return res;\n}\n\nfrac operator-(const frac &a, const frac &b) {\n  ll m = lcm(a.den, b.den);\n  ll f1 = m / a.den;\n  ll f2 = m / b.den;\n  frac res = frac {a.num * f1 - b.num * f2, m};\n  cancel(res);\n  return res;\n}\n\nfrac operator/(const frac &a, const frac &b) {\n  frac res = frac {a.num * b.den, a.den * b.num};\n  cancel(res);\n  return res;\n}\n\nbool operator==(const frac &a, const frac &b) {\n  return a.num == b.num && a.den == b.den;\n}\n\nbool operator!=(const frac &a, const frac &b) {\n  return a.num != b.num || a.den != b.den;\n}\n\nbool operator<(const frac &a, const frac &b) {\n  return (double)a.num / (double)a.den < double(b.num) / (double)b.den;\n}\n\nstruct line {\n  frac a, b, c;\n};\n\nbool operator==(const line &a, const line &b) {\n  return a.a == b.a && a.b == b.b && a.c == b.c;\n}\n\nbool operator<(const line &a, const line &b) {\n  if (a.a != b.a) return a.a < b.a;\n  if (a.b != b.b) return a.b < b.b;\n  return a.c < b.c;\n}\n\nll powers2[201];\n\nll cross(pt a, pt b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nbool collinear(pt a, pt b, pt c) {\n  return !cross(b - a, c - a);\n}\n\nline pointsToLine(pt a, pt b) {\n  line l;\n  if (a.x == b.x) {\n    l.a = frac {1, 1};    \n    l.b = frac {0, 1};\n    l.c = frac {-a.x, 1};\n  } else {\n    l.a = frac {-a.y - b.y, 1} / frac {a.x - b.x, 1};\n    l.b = frac {1, 0};\n    l.c = (l.a * -a.x) - frac{a.y, 1};\n  }\n  return l;\n}\n\nint main() {\n  powers2[0] = 1;\n  for (int i = 1; i <= 200; i++) powers2[i] = powers2[i - 1] * 2LL % MOD;\n\n  ll sum = 0;\n  map<ll, int> invTri;\n  for (int i = 1; i <= 200; i++) {\n    sum += i;\n    invTri[sum] = i;\n  }\n\n  int n;\n  scanf(\"%d\", &n);\n  vector<pt> points(n);\n  for (int i = 0; i < n; i++) scanf(\"%lld %lld\", &points[i].x, &points[i].y);\n  \n  map<line, int> counter;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      line l = pointsToLine(points[i], points[j]);\n      counter[l]++;\n    }\n  }\n  ll res = powers2[n];\n  for (auto c : counter) {\n    int points = invTri[c.second] + 1;\n    res += MOD - powers2[points] + points + 1;\n    res %= MOD; \n  }\n  res += MOD - 1 - n;\n  res %= MOD;\n  printf(\"%lld\\n\", (res % MOD + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 210\n#define ll long long\n#define mod 998244353\nint n,ans;\nstruct poi\n{\n\tint x,y;\n\tpoi(){}\n\tpoi(int x,int y):x(x),y(y){}\n\tfriend poi operator - (const poi &r1,const poi &r2)\n\t{return poi(r1.x-r2.x,r1.y-r2.y);}\n\tfriend int operator ^ (const poi &r1,const poi &r2)\n\t{return r1.x*r2.y-r2.x*r1.y;}\n}a[N];\nint qpow(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=(ll)ret*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\nint ni(int x){return qpow(x,mod-2);}\nint main()\n{\n\t//freopen(\"tt.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\tans=(qpow(2,n)-1-n+mod)%mod;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint num=2;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\tif(k!=i&&k!=j&&((a[k]-a[i])^(a[k]-a[j]))==0)num++;\n\t\t\tint v1=(qpow(2,num)-num-1+mod)%mod,v2=num*(num-1)/2;\n\t\t\tv1=(ll)v1*ni(v2)%mod;\n\t\t\tans=(ans-v1+mod)%mod;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n\n\n//using namespace __gnu_pbds;\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n/*\ntypedef\ntree<\n  int, // Data type\n  null_type,\n  less<int>, // Comparator function for the data type\n  rb_tree_tag,\n  tree_order_statistics_node_update>\nordered_set;\n*/\n\nconst ll MOD_CONST = 1000000007ll;\n\n\nll modSum(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b, ll MOD = MOD_CONST) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e, ll MOD = MOD_CONST) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2, MOD);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1, MOD);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\n\nll getInverse(ll x, ll MOD = MOD_CONST) {\n  return getPowMod(x, MOD-2, MOD);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\nll gcd(ll a, ll b, ll & x, ll & y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\n\npair<ll, ll> getIntersectingRange(ll a1, ll b1, ll a2, ll b2) {\n  ll s = max(a1, a2);\n  ll e = min(b1, b2);\n\n  return {s, e};\n}\n\n\nbool isNonEmptyIntersection(ll a1, ll b1, ll a2, ll b2) {\n  auto p = getIntersectingRange(a1, b1, a2, b2);\n  return p.first <= p.second;\n}\n\n\ndouble getPointDistance(double x1, double y1, double x2, double y2) {\n  double dx = x1-x2;\n  double dy = y1-y2;\n  double d = (dx * dx) + (dy * dy);\n  return sqrt(d);\n}\n\n\nbool isPrime(ll x) {\n  if (x == 2 || x == 3 || x == 5 || x == 7) return true;\n  if (x < 10) return false;\n  ll till = min((ll)sqrt(x) + 1, x-1);\n  for (ll i = 2 ; i <= till ; i++) {\n    if (x % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nconst int TREE_SIZE = 1;\n\n\nll segTree[TREE_SIZE], lazyTree[TREE_SIZE];\n\n\nvoid updateRange(int node, int start, int end, int l, int r, ll val)\n{\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];    // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];                  // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];                // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                                  // Reset it\n    }\n    if(start > end or start > r or end < l)              // Current segment is not within range [l, r]\n        return;\n    if(start >= l and end <= r)\n    {\n        // Segment is fully within range\n        segTree[node] += (end - start + 1) * val;\n        if(start != end)\n        {\n            // Not leaf node\n            lazyTree[node*2] += val;\n            lazyTree[node*2+1] += val;\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    updateRange(node*2, start, mid, l, r, val);        // Updating left child\n    updateRange(node*2 + 1, mid + 1, end, l, r, val);   // Updating right child\n    segTree[node] = segTree[node*2] + segTree[node*2+1];        // Updating root with max value\n}\n\n\nll queryRange(int node, int start, int end, int l, int r)\n{\n    if(start > end or start > r or end < l)\n        return 0;         // Out of range\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];            // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];         // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];    // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                 // Reset it\n    }\n    if(start >= l and end <= r)             // Current segment is totally within range [l, r]\n        return segTree[node];\n    int mid = (start + end) / 2;\n    ll p1 = queryRange(node*2, start, mid, l, r);         // Query left child\n    ll p2 = queryRange(node*2 + 1, mid + 1, end, l, r); // Query right child\n    return (p1 + p2);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst int MAXN = 201;\nconst ll MOD = 998244353;\n\n\nint N;\nint ar_x[MAXN], ar_y[MAXN]; \n\n\nvoid input() {\n  cin >> N;\n  for (int i = 1 ; i <= N ; i++) {\n    cin >> ar_x[i] >> ar_y[i];\n  }\n}\n\n\nvoid preprocess() {\n}\n\n\nvoid solve() {\n  ll ans = getPowMod(2, N, MOD);\n  ans = modSubtract(ans, 1, MOD);\n  ans = modSubtract(ans, N, MOD);\n  ans = modSubtract(ans, (N * (N-1)) / 2, MOD);\n  //cerr << \"Ans = \" << ans << \"\\n\";\n  for (int i = 1 ; i <= N ; i++) {\n    for (int j = i+1 ; j <= N ; j++) {\n      int x_coeff = ar_y[j] - ar_y[i];\n      int y_coeff = ar_x[i] - ar_x[j];\n      int const_coeff = ((-ar_x[i]) * x_coeff) + ((-ar_y[i]) * y_coeff);\n      bool add = true;\n      int freq = 2;\n      for (int k = 1 ; k <= N ; k++) {\n        if (k == i || k == j) continue;\n        bool online = ((x_coeff * ar_x[k]) + (y_coeff * ar_y[k]) + const_coeff) == 0;\n        if (!online) continue;\n        if (k < i || k < j) { \n          add = false;\n          break;\n        }\n        freq++;\n      }\n      if (!add) continue;\n      //cerr << \"Freq = \" << freq << \"\\n\";\n      ans = modSubtract(ans, getPowMod(2, freq, MOD), MOD);\n      ans = modSum(ans, 1, MOD);\n      ans = modSum(ans, freq, MOD);\n      ans = modSum(ans, (freq * (freq-1)) / 2, MOD);\n    }\n  }\n  cout << ans;\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';\n\treturn !f?x:-x;\n}\n\nconst int N=200+19;\nconst int p=998244353;\n\nstruct Point{\n\tint x,y;\n\tbool operator < (const Point &B) const{\n\t\treturn x<B.x||x==B.x&&y<B.y;\n\t}\n} P[N],Pt;\ntypedef Point Vector;\n\nint dp[N][N],val[N][N],pw2[N];\nint n,ans;\n\nVector operator - (Point A,Point B){\n\treturn (Vector){\n\t\tA.x-B.x,A.y-B.y\n\t};\n}\nll cross(Vector A,Vector B){\n\treturn 1ll*A.x*B.y-1ll*A.y*B.x;\n}\nbool cmp(Point A,Point B){\n\treturn cross(A-Pt,B-Pt)>0;\n}\n\nvoid Work(vector<Point> V){\n\tint n=V.size();\n\tmemset(dp,0,sizeof(dp));\n\tmemset(val,0,sizeof(val));\n\tsort(V.begin()+1,V.end(),cmp);\n\tFor(i,1,n) For(j,i+1,n){\n\t\tFor(k,i+1,j) if (cross(V[j]-V[i],V[k]-V[i])>0) val[i][j]++;\n\t\tval[i][j]=pw2[val[i][j]];\n\t}\n\tFor(i,1,n) dp[0][i]=1;\n\tFor(i,0,n) For(j,i+1,n) if (dp[i][j]){\n\t\tFor(k,j+1,n) if (cross(V[j]-V[i],V[k]-V[j])>0){\n\t\t\tdp[j][k]=(dp[j][k]+1ll*val[j][k]*dp[i][j])%p;\n\t\t}\n\t}\n\tFor(i,1,n) For(j,i+1,n)\n\t\tif (cross(V[j]-V[i],V[0]-V[j])>0){\n\t\t\tans=(ans+dp[i][j])%p;\n\t\t}\n}\n\nint main(){\n\tpw2[0]=1;\n\tFor(i,1,N) pw2[i]=2ll*pw2[i-1]%p;\n\tn=IN();\n\tFor(i,1,n+1) P[i]=(Point){IN(),IN()};\n\tsort(P+1,P+n+1);\n\tFor(i,1,n+1){\n\t\tPt=P[i];\n\t\tvector<Point> V;\n\t\tFor(j,i,n+1) V.pb(P[j]);\n\t\tWork(V);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<stdio.h>\n#include<queue>\n#define x first\n#define y second\nusing namespace std;\nconst int mod=998244353;\nint N;\n\nint x[205],y[205],power[205];\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tint ans;\n\tpower[0]=1;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tpower[i+1]=(power[i]<<1)%mod;\n\t}\n\tans=power[N]-N-1;\n\n\tfor(int i=0;i<N;i++)\n\tfor(int j=0;j<i;j++)\n\t{\n\t\tint cnt=0;\n\t\tfor(int k=0;k<j;k++)\n\t\t{\n\t\t\tif((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))\n\t\t\tcnt++;\n\t\t}\n\t\tans=(ans-power[cnt]+mod)%mod;\n\t}\n\t\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 998244353\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\nll f[220];\nll comb[220][220];\n\nvoid fact() {\n    f[0] = 1;\n    rep(i, 1, 210){\n        f[i] = f[i - 1] * i;\n        f[i] %= mod;\n    }\n}\n\nll pow_mod(ll a, ll b, ll m){\n    ll ret = 1;\n    while (b > 0) {\n        if (b & 1) {\n            ret = ret * a % m;\n        }\n        a = a * a % m;\n        b >>= 1;\n    }\n    return ret;\n}\n\nll inv_mod(ll a, ll m){\n    return pow_mod(a, m - 2, m);\n}\n\nvoid calc() {\n    // i C j\n    rep(i, 210){\n        rep(j, i + 1) {\n            comb[i][j] = f[i];\n            ll tmp = inv_mod(f[j] * f[i - j] % mod, mod);\n            (comb[i][j] *= tmp) %= mod;\n        }\n    }\n}\n\n\nbool line(pair<ll, ll> p, pair<ll, ll> q, pair<ll, ll> r){\n    return (p.first - q.first) * (p.second - r.second) == (p.first - r.first) * (p.second - q.second);\n}\n\nbool vis[220][220];\n\n// union find\nclass union_find {\npublic:\n    int n;\n    vector<int> parent, rnk, num;\n    \n    union_find(int n) : n(n), parent(n), rnk(n, 0), num(n, 1) {rep(i, n) parent[i] = i; }\n    \n    int root(int x){ return (parent[x] == x) ? x : root(parent[x]); }\n    \n    void unite(int x, int y){\n        x = root(x);\n        y = root(y);\n        if (x == y) {\n            return;\n        }\n        if (rnk[x] < rnk[y]) {\n            parent[x] = y;\n            num[y] += num[x];\n        }\n        else{\n            parent[y] = x;\n            num[x] += num[y];\n            if (rnk[x] == rnk[y]) {\n                rnk[x]++;\n            }\n        }\n        n--;\n    }\n    \n    bool same(int x, int y) {return root(x) == root(y);}\n    \n    int count(int x){ return num[root(x)]; }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    fact();\n    calc();\n    int N;\n    cin >> N;\n    vector<pair<ll, ll>> A(N);\n    rep(i, N) cin >> A[i].first >> A[i].second;\n    \n    ll ans = 0;\n    rep(i, 3, N + 1){\n        ans += comb[N][i];\n        ans %= mod;\n    }\n    \n    ll sub = 0;\n    rep(i, N){\n        rep(j, i + 1, N){\n            int cnt = 2;\n            \n            rep(k, N){\n                if(k == i || k == j) continue;\n                if(line(A[i], A[j], A[k])){\n                    cnt++;\n                }\n            }\n//            cout << i << \",\" << j << \":\" << cnt << endl;\n            if(cnt > 2){\n                ll tmp = 0;\n                rep(l, 3, cnt + 1){\n                    tmp += comb[cnt][l];\n                    tmp %= mod;\n                }\n                tmp *= inv_mod(comb[cnt][2], mod);\n                tmp %= mod;\n                sub += tmp;\n                sub %= mod;\n                \n            }\n        }\n    }\n//    output(sub);\n    ans = ans - sub;\n    ans %= mod;\n    ans += mod;\n    ans %= mod;\n    output(ans);\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef double lld;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<double> vdl;\ntypedef vector<vector<lli>> mat;\ntypedef vector<vdl> mad;\ntypedef unordered_map<lli,unordered_map<lli,lli>> graph;\ntypedef complex<double> cmp;\ntypedef vector<cmp> vcl;\n\nconst lli mod = 998244353;\n\nlli n;\nvector<vdl> p;\nmat c;\nmat bl;\nlli ans = 0;\n\nlld deg(vdl a,vdl from){\n  return fmod(atan2(a[1]-from[1],a[0]-from[0])+2*M_PI,2*M_PI);\n}\n\nlld deg(vdl a,vdl b,vdl from){\n  return fmod(deg(b,from)-deg(a,from)+2*M_PI,2*M_PI);\n}\n\nlli pow(lli x,lli r,lli mod = 998244353){\n  lli ret = 1;\n  for(;r != 0;r >>= 1){\n    if(r&1 != 0) ret *= x,ret %= mod;\n    x *= x,x %= mod;\n  }\n  return ret;\n}\n\nclass union_find {\nprivate:\n  unordered_map<lli,lli> par;\n  unordered_map<lli,lli> rnk;\npublic:\n  // union_find (lli n){\n  //   par = new vll(n);\n  //   iota(par->begin(),par->end(),0);\n  //   rnk = new vll(n,0);\n  // }\n  lli parent(lli x){\n    if(par[x]) return par[x];\n    else return par[x] = x;\n  }\n  lli find(lli x){\n    if(parent(x) == x) return x;\n    else return par[x] = find(parent(x));\n  }\n  void unite(lli x,lli y){\n    x = find(x);y = find(y);\n    if(x == y)return;\n    if(rnk[x] < rnk[y]) par[x] = y;\n    else {\n      par[y] = x;\n      if(rnk[x] == rnk[y]) rnk[x]++;\n    }\n  }\n  bool same(lli x,lli y){\n    return find(x) == find(y);\n  }\n};\n\nunion_find uf;\nmap<lli,set<lli>> m;\n\n\nint main(){\n  cin >> n;\n  p = vector<vdl>(n,vdl(2));\n  for(lli i = 0;i < n;i++) cin >> p[i][0] >> p[i][1];\n  c = mat(n,vll(n));\n  for(lli i = 0;i < n;i++){\n    for(lli j = i+1;j < n;j++){\n      for(lli k = j+1;k < n;k++){\n        lld d = deg(p[k],p[j],p[i]);\n        if(d == 0.0 || d == M_PI){\n          uf.unite(i*n+j,i*n+k);\n          uf.unite(i*n+j,j*n+k);\n          uf.unite(i*n+k,j*n+k);\n        }\n      }\n    }\n  }\n  for(lli i = 0;i < n;i++){\n    for(lli j = i+1;j < n;j++){\n      m[uf.find(i*n+j)].insert(i);\n      m[uf.find(i*n+j)].insert(j);\n    }\n  }\n  for(auto x : m){\n    // cout << x.second.size() << endl;\n    ans += pow(2,x.second.size())-1-x.second.size();\n  }\n  ans += 1;\n  ans += n;\n  cout << ((pow(2ll,n)-ans+mod)%mod) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cfloat>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\n\n#define EPS 1e-12\n#define ull unsigned long long\n#define ll long long\n#define VI vector<ll>\n#define PII pair<ll, ll> \n#define VVI vector<vector<ll> >\n#define REP(i,n) for(int i=0,_n=(n);(i)<(int)_n;++i)\n#define RANGE(i,a,b) for(int i=(int)a,_b=(int)(b);(i)<_b;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define ALLR(c) (c).rbegin(), (c).rend()\n#define PB push_back\n#define MP(a, b) make_pair(a, b)\n#define POPCOUNT __builtin_popcount\n#define POPCOUNTLL __builtin_popcountll\n#define CLEAR(table, v) memset(table, v, sizeof(table));\n#define PRINT1(table, D0) REP(d0, D0) cout<<table[d0]<<\" \"; cout<<\"\\n\";\n#define PRINT2(table, D0, D1) REP(d0, D0) { REP(d1, D1) cout<<table[d0][d1]<<\" \"; cout<<\"\\n\"; }\n#define PRINT3(table, D0, D1, D2) REP(d0, D0) { REP(d1, D1) { REP(d2, D2) cout<<table[d0][d1][d2]<<\" \"; cout<<\"\\n\"; } cout<<\"\\n\"; }\n#define UNIFORM_DOUBLE(a, b) (((b-a)*(double)rand()/RAND_MAX)+a) // [a, b) \n#define UNIFORM_LL(a, b) (ll)UNIFORM_DOUBLE(a, b) // [a, b) \n#define IN(v, lo, hi) ((lo)<=(v) && (v)<(hi))\n#define DD(v) cout<<#v<<\": \"<<v<<endl\ntemplate <typename T0, typename T1> std::ostream& operator<<(std::ostream& os, const map<T0, T1>& v) { for( typename map<T0, T1>::const_iterator p = v.begin(); p!=v.end(); p++ ){os << p->first << \": \" << p->second << \" \";} return os; }\ntemplate <typename T0, typename T1> std::ostream& operator<<(std::ostream& os, const pair<T0, T1>& v) { os << v.first << \": \" << v.second << \" \"; return os; }\ntemplate <typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& v) { for( int i = 0; i < (int)v.size(); i++ ) { os << v[i] << \" \"; } return os; }\ntemplate <typename T> std::ostream& operator<<(std::ostream& os, const vector<vector<T> >& v) { for( int i = 0; i < (int)v.size(); i++ ) { os << v[i] << endl; } return os; }\ntemplate <typename T> std::ostream& operator<<(std::ostream& os, const set<T>& v) { vector<T> tmp(v.begin(), v.end()); os << tmp; return os; }\ntemplate <typename T> std::ostream& operator<<(std::ostream& os, const deque<T>& v) { vector<T> tmp(v.begin(), v.end()); os << tmp; return os; }\n\nstruct modll {\n\tstatic const ll MODVAL;\n\tll val;\n\tmodll() : val(0) {}\n\tmodll(ll v) : val(v) { normalize(); }\n\tvoid normalize() { val = (val+MODVAL) % MODVAL; }\n\tmodll  operator+ (ll v) { return modll(val+v); }\n\tmodll& operator+=(ll v) { val+=v; normalize(); return *this; }\n\tmodll  operator- (ll v) { return modll(val-v); }\n\tmodll& operator-=(ll v) { val-=v; normalize(); return *this; }\n\tmodll  operator* (ll v) { return modll(val*v); }\n\tmodll& operator*=(ll v) { val*=v; normalize(); return *this; }\n\tmodll  operator^ (ll e) { modll x(val); modll v(1); for(;e;x=x*x,e>>=1) if(e&1) v = v * x; return v; } // pow\n\tmodll inv() { modll x(val); return x^(MODVAL-2); } // MODVAL must be prime number when use this!\n\tstatic modll inv(ll v) { return modll(v).inv(); }\n\toperator ll() { return val; }\n};\nconst ll modll::MODVAL = 998244353;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll N;\n\twhile(cin>>N) {\n\t\tVI X(N), Y(N);\n\t\tREP(i, N) cin>>X[i]>>Y[i];\n\t\tmodll ans = (modll(2)^N) - (N*(N-1)/2 + N + 1);\n//\t\tDD(ans);\n\t\tVVI done(N, VI(N));\n\t\tREP(i, N) REP(j, i) if(!done[i][j]) {\n\t\t\tVI onLine = {i, j};\n\t\t\tREP(k, N) if(k!=i && k!=j && (X[k]-X[i])*(Y[j]-Y[i])-(Y[k]-Y[i])*(X[j]-X[i])==0) onLine.PB(k);\n\t\t\tll r = onLine.size();\n\t\t\tREP(a, r) REP(b, r) done[onLine[a]][onLine[b]]=1;\n//\t\t\tDD(onLine);\n\t\t\tif(r>=3) ans -= (modll(2)^r) - (1 + r + (r*(r-1)/2));\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int P=998244353;\nint n;\nstruct pos{\n\tint x,y;\n}ps[1007];\nint ep=0,f[1007],sz[1007];\nint gf(int x){while(x!=f[x])x=f[x]=x[f][f];return x;}\nstruct edge{\n\tint a,b;\n\tint v;\n\tbool operator<(const edge&e)const{return v<e.v;}\n\tvoid cal(){\n\t\tint x=gf(a),y=gf(b);\n\t\tif(x!=y)f[x]=y,sz[y]+=sz[x];\n\t}\n}es[207*207];\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\nint pw[1007],ans;\nint main(){\ncin >> n;\n\tpw[0]=1;\n\tfor(int i=1;i<=n;++i)pw[i]=pw[i-1]*2%P;\n\tans=(pw[n]-n-1)%P;\n\tfor(int i=0;i<n;++i)scanf(\"%d%d\",&ps[i].x,&ps[i].y);\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=0;j<i;++j){\n\t\t\tint x=ps[i].x-ps[j].x,y=ps[i].y-ps[j].y;\n\t\t\tint g=gcd(x,y);\n\t\t\tx/=g,y/=g;\n\t\t\tif(!x)y=1;\n\t\t\tif(!y)x=1;\n\t\t\tif(x<0)x=-x,y=-y;\n\t\t\tes[ep++]=(edge){i,j,x*30000+y};\n\t\t}\n\t}\n\tstd::sort(es,es+ep);\n\tfor(int i=0,j=0;i<ep;i=j){\n\t\tfor(int a=0;a<n;++a)sz[f[a]=a]=1;\n\t\tfor(;j<ep&&es[i].v==es[j].v;es[j++].cal());\n\t\tfor(int a=0;a<n;++a)if(f[a]==a&&sz[a]>1)ans=(ans-pw[sz[a]]+sz[a]+1)%P;\n\t}\n\tcout << (ans % P + P ) % P;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long LL;\nconst int MOD=998244353;\nconst int N=205;\nint n;\nstruct qq\n{\n\tint x,y;\n\tvoid print ()\t{printf(\"%d %d\\n\",x,y);}\n}a[N],b[N];\nint tot;\nint ans;\nqq tmp;\nint mul (qq x,qq y,qq z)\n{\n\tint x1=x.x-z.x,y1=x.y-z.y;\n    int x2=y.x-z.x,y2=y.y-z.y;\n    return x1*y2-x2*y1;\n}\nint dis (qq x,qq y)\t{return (x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y);}\nbool cmp (qq x,qq y)\n{\n\tif (mul(x,y,tmp)==0) return dis(x,tmp)<dis(y,tmp);\n\treturn mul(x,y,tmp)>0;\n}\nbool cmp1 (int x,int y)\n{\n\tif (mul(b[x],b[y],tmp)==0) return dis(b[x],tmp)<dis(b[y],tmp);\n\treturn mul(b[x],b[y],tmp)>0;\n}\nbool check (qq x,qq y,qq z)//z是否在 (tmp,x,y)\n{\n\tif (mul(z,x,tmp)==0) return false;\n\tif (mul(z,y,x)>0) return false;\n\treturn true;\n}\nint f[N][N];\nint g[N][N];\nint mul (int x,int y)\t{return (LL)x*y%MOD;}\nint add (int x,int y)\t{x=x+y;return x>=MOD?x-MOD:x;}\nint id[N],id1[N];\nint m,m1;\nint Pow[N];\nvoid solve (int x)\n{\n\t//printf(\"solve:%d\\n\",x);\n\ttot=0;tmp=a[x];\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\tif (a[u].y>a[x].y||(a[u].y>=a[x].y&&a[u].x>=a[x].x))\tb[++tot]=a[u];\n\t}\n\tsort(b+1,b+1+tot,cmp);\n\tfor (int u=1;u<=tot;u++)\t\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tg[u][i]=f[u][i]=0;\n\t/*for (int u=1;u<=tot;u++)\n\t\tfor (int i=u+1;i<=tot;i++)\n\t\t{\n\t\t\tint lalal=0;\n\t\t\tfor (int k=u+1;k<i;k++)\n\t\t\t{\n\t\t\t\tif (mul(b[k],b[u],tmp)==0) continue;\n\t\t\t\tif (mul(b[k],b[i],b[u])<=0) lalal++;\n\t\t\t}\n\t\t\tg[u][i]=Pow[lalal];\n\t\t}*/\n\tfor (int u=1;u<=tot;u++)\n\t\tfor (int i=u+1;i<=tot;i++)\n\t\t\tg[u][i]=1;\n\tfor (int u=1;u<=tot;u++)\n\t\tfor (int k=u+1;k<=tot;k++)\n\t\t{\n\t\t\tif (mul(b[k],b[u],tmp)==0) continue;\n\t\t\tfor (int i=k+1;i<=n;i++)\n\t\t\t{\n\t\t\t\tif (mul(b[k],b[i],b[u])<=0)\n\t\t\t\tg[u][i]=add(g[u][i],g[u][i]);\n\t\t\t}\n\t\t}\n\tfor (int u=2;u<=tot;u++)\n\t{\n\t\tf[1][u]=1;\n\t\tfor (int i=2;i<u;i++)\n\t\t\tif (mul(b[i],b[u],b[1])==0)\n\t\t\t\tf[1][u]=add(f[1][u],f[1][u]);\n\t}\n\tfor (int i=2;i<=tot;i++)\n\t{\n\t\t//printf(\"i:%d\\n\",i);\n\t\tm=0;m1=0;\n\t\tfor (int u=1;u<i;u++)\tid[++m]=u;\n\t\tfor (int u=i+1;u<=tot;u++) id1[++m1]=u;\n\t\ttmp=b[i];\n\t\tsort(id+1,id+1+m,cmp1);\n\t\tsort(id1+1,id1+1+m1,cmp1);\n\t\tint now=1,k=m1,sum=0;\n\t\tfor (int u=1;u<=m1;u++)\n\t\t{\n\t\t\twhile (now<=m&&mul(b[id1[u]],b[i],b[id[now]])<0)\n\t\t\t{\n\t\t\t\tsum=add(sum,f[id[now]][i]);\n\t\t\t\tnow++;\n\t\t\t}\n\t\t\tf[i][id1[u]]=add(f[i][id1[u]],mul(sum,g[i][id1[u]]));\n\t\t}\n\t}\n\tfor (int u=2;u<=tot;u++)\n\t\tfor (int i=u+1;i<=tot;i++)\n\t\t\tans=add(ans,f[u][i]);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tPow[0]=1;for (int u=1;u<=n;u++) Pow[u]=add(Pow[u-1],Pow[u-1]);\n\tfor (int u=1;u<=n;u++)\tscanf(\"%d%d\",&a[u].x,&a[u].y);\n\tfor (int u=1;u<=n;u++) solve(u);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define Point pair <int, int>\n#define x first\n#define y second\n#define MAXN 205\n#define mod 998244353\nusing namespace std;\n\nint n, pw2[MAXN];\nbool checked[MAXN][MAXN];\nPoint p[MAXN];\n\ninline int fmod (int x) {\n    return (x % mod + mod) % mod;\n}\n\ninline int f (int x) {\n    return fmod (pw2[x] - x - 1 - x * (x - 1) / 2);\n}\n\nbool collinear (Point A, Point B, Point C) {\n    B.x -= A.x, B.y -= A.y;\n    C.x -= A.x, C.y -= A.y;\n\n    return B.x * C.y == B.y * C.x;\n}\n\nint main () {\n    ios::sync_with_stdio (0);\n\n    cin >> n;\n    for (int i = 1; i <= n; ++i)\n        cin >> p[i].x >> p[i].y;\n\n    if (n <= 2) {\n        cout << \"0\\n\";\n        return 0;\n    }\n\n    pw2[0] = 1;\n    for (int i = 1; i <= n; ++i)\n        pw2[i] = pw2[i - 1] * 2 % mod;\n\n    int sol = f (n);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            if (checked[i][j])\n                continue;\n\n            vector <int> v {i, j};\n\n            for (int k = j + 1; k <= n; ++k) {\n                if (collinear (p[i], p[j], p[k]))\n                    v.push_back (k);\n            }\n\n            sol = fmod (sol - f (v.size ()));\n\n            for (int i = 0; i < (int) v.size (); ++i) {\n                for (int j = i + 1; j < (int) v.size (); ++j) {\n                    checked[v[i]][v[j]] = checked[v[j]][v[i]] = 1;\n                }\n            }\n        }\n    }\n\n    cout << sol << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int md = 998244353;\n \ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n \ninline int mul(int a, int b) {\n  return (long long) a * b % md;\n}\n \ninline int power(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n \ninline int inv(int x) {\n  return power(x, md - 2);\n}\n \nconst int N = 12345;\n \nint x[N], y[N];\n \nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", x + i, y + i);\n  }\n  int ans = power(2, n);\n  add(ans, md - 1);\n  add(ans, md - n);\n  add(ans, md - n * (n - 1) / 2);\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int a = y[j] - y[i];\n      int b = x[i] - x[j];\n      int c = -a * x[i] - b * y[i];\n      int cnt = 2;\n      for (int k = 0; k < n; k++) {\n        if (k == i || k == j) {\n          continue;\n        }\n        int z = a * x[k] + b * y[k] + c;\n        if (z != 0) {\n          continue;\n        }\n        if (k < j) {\n          break;\n        }\n        cnt++;\n      }\n      add(ans, md - power(2, cnt));\n      add(ans, 1);\n      add(ans, cnt);\n      add(ans, cnt * (cnt - 1) / 2);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<set>\n#define rep(i,l,r) for (int i=l;i<=r;i++)\n#define down(i,l,r) for (int i=l;i>=r;i--)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define maxn 100050\n#define ll long long\n#define low(x) (x&(-x))\n#define inf 1000000000\nusing namespace std;\nconst ll mm=998244353;\nll read(){\n    ll x=0,f=1; char ch=getchar();\n    while (!isdigit(ch)) {if (ch=='-') f=-1; ch=getchar();}\n    while (isdigit(ch)) {x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\nint n;\nstruct data{int x,y;}a[505];\nvoid add(int &x,int y){\n\tx+=y;\n\tif (x>=mm) x-=mm;\n}\nint Pow(int x,int y){\n\tint ans=1;\n\twhile (y) {\n\t\tif (y&1) ans=1ll*ans*x%mm;\n\t\tx=1ll*x*x%mm;\n\t\ty/=2;\n\t}\n\treturn ans;\n}\nbool jud(int i,int j,int k){\n\treturn (a[k].y-a[i].y)*(a[i].x-a[j].x)==(a[k].x-a[i].x)*(a[i].y-a[j].y);\n}\nint main(){\n//\tfreopen(\"in.txt\",\"r\",stdin);\n\tn=read();\n\trep(i,1,n) a[i].x=read(),a[i].y=read();\n\tint ans=Pow(2,n);\n\tadd(ans,mm-1-n-n*(n-1)/2);\n\trep(i,1,n-1) rep(j,i+1,n){\n\t\tint sum=2;\n\t\trep(k,1,n) {\n\t\t\tif (k==i||k==j||!jud(i,j,k)) continue;\n\t\t\tif (k<j) break;\n\t\t\tsum++;\n\t\t}\n\t//\tprintf(\"%d %d %d\\n\",i,j,sum);\n\t\tadd(ans,mm-Pow(2,sum));\n\t\tadd(ans,1+sum+sum*(sum-1)/2);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <utility>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <bitset>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define unique(x) x.erase(unique(x.begin(), x.end()), x.end())\n#define all(a) a.begin(), a.end()\n#define sqr(x) ((x) * (x)) \n#define y1 aksjdaskdjksjfksdjf\n#define left kdnvldvoiwejifejg\n#define right lkdsjflksdjfdjfk\n#define prev asdasfsadjkjsdfjs\n#define tm aklsjdasjdasjdkdjjf\n#define lcm hddalkwjeidjjhasda\n#define random_shuffle asdasdd\n\nconst int MAXN = 205;\nconst int mod = 998244353;\n\nint n;\nint x[MAXN], y[MAXN];\n\nint subMod(int a, int b) {\n  int res = a - b;\n  return res < 0 ? res + mod : res;\n}\n\nlong long binpow(long long x, long long p) {\n  long long res = 1;\n  while (p) {\n    if (p & 1) {\n      res = (res * x) % mod;\n      p--;\n    } else {\n      x = (x * x) % mod;\n      p /= 2;\n    }\n  }\n  return res % mod;\n}\n\nlong long inv(long long x) {\n  return binpow(x, mod - 2) % mod;\n}\n\nint main() { \n\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &x[i], &y[i]);\n  }\n\n  long long ans = binpow(2, n);\n  ans = subMod(ans, n + 1);\n  // cerr << ans << endl;\n\n  set < pair<int, int> > st;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int mnA = i, mnB = j;\n      int cnt = 2;\n      for (int k = 0; k < n; k++) {\n        if (i == k || j == k) {\n          continue;\n        }\n        if (1ll * (y[j] - y[i]) * (x[k] - x[i]) == 1ll * (x[j] - x[i]) * (y[k] - y[i])) {\n          cnt++;\n          if (k < mnA) {\n            mnB = mnA; mnA = k;\n          } else if (k < mnB) {\n            mnB = k;\n          }\n        }\n      }\n      if (st.count({mnA, mnB}) == 0) {\n        st.insert({mnA, mnB});\n        // cerr << cnt << endl;\n        long long rem = subMod(binpow(2, cnt), cnt);\n        rem = subMod(rem, 1);\n        ans = subMod(ans, rem);\n      }\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define maxn 1010\nusing namespace std;\n\nconst ll mod=998244353;\n\nint n;\n\nll fac[maxn],ans;\n\nstruct node{\n\tint x,y;\n}a[maxn];\n\nll qpow(ll base,ll K){\n\tll res=1;\n\twhile(K){\n\t\tif(K&1) res=(res*base)%mod;\n\t\tbase=(base*base)%mod;\n\t\tK>>=1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=(fac[i-1]*2)%mod;\n\tans=(fac[n]-n-1+mod)%mod;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<i;j++){\n\t\t\tint sum=0;\n\t\t\tfor(int k=1;k<j;k++) if(1ll*(a[i].x-a[j].x)*(a[j].y-a[k].y)==1ll*(a[i].y-a[j].y)*(a[j].x-a[k].x)) sum++;\n\t\t\tans=(ans-fac[sum]+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<bitset>\n#include<map>\nusing namespace std;\ntemplate<typename __T>\ninline void read(__T &x)\n{\n    x=0;\n    int f=1;char c=getchar();\n    while(!isdigit(c)){if(c=='-')\tf=-1;c=getchar();}\n    while(isdigit(c))\t{x=x*10+c-'0';c=getchar();}\n    x*=f;\n}\nconst int mod=998244353;\nint n;\nint x[205],y[205];\nlong long pow2[205];\nint main()\n{\n\tread(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tread(x[i]);\n\t\tread(y[i]);\n\t}\n\tpow2[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tpow2[i]=pow2[i-1]*2%mod;\n\tlong long ans=(pow2[n]-1-n+mod)%mod;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\t\tif((y[k]-y[j])*(x[j]-x[i])==(y[j]-y[i])*(x[k]-x[j]))\n\t\t\t\t\tcnt++;\n\t\t\tans=(ans+mod-pow2[cnt])%mod;\n\t\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define AwD 998244353\nusing namespace std;\nll mi(ll a, ll b) {\n\tll ret = 1;\n    for (; b; b >>= 1, a = a * a % AwD)\n\tif (b & 1) ret = ret * a % AwD;\n    return ret;\n}\nll x[250], y[250], ans;\nmap<ll, int> MAP;\nint main() {\n    ll n; cin >> n;\n    for (int i = 1; i <= n; i ++) cin >> x[i] >> y[i];\n\tans = mi(2, n) - n - 1;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tMAP.clear();\n\t\tfor (int j = i + 1; j <= n; j ++) {\n            ll k;\n            if (x[j] == x[i]) k = -1;\n\t\t\telse k = ((y[j] - y[i]) * mi(x[j] - x[i], AwD - 2) % AwD + AwD)% AwD;\n\t\t\tMAP[k] ++;\n\t\t}\n\t\tfor (auto it = MAP.begin(); it != MAP.end(); it ++) (ans -= mi(2, it -> second) - 1) %= AwD;\n\t}\n\tcout << ((ans) % AwD + AwD) % AwD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\n#define pb push_back\n#define w1 first\n#define w2 second\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=205,mod=998244353;\nint n,ans,ilg;\nint x[maxn],y[maxn],bin[maxn];\nmap<db,int>cnt;\nint power(int x,int k,int p){int res=1;for(;k;k>>=1,x=1ll*x*x%p)if(k&1)res=1ll*res*x%p;return res;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint sub(int x,int y){return x-y<0?x-y+mod:x-y;}\nint main(){\n\tread(n);\n\tbin[0]=1;rep(i,1,n)bin[i]=2ll*bin[i-1]%mod;\n\tans=bin[n];\n\trep(i,1,n)read(x[i]),read(y[i]);\n\trep(i,1,n){\n\t\tcnt.clear();\n\t\trep(j,1,n)if(i!=j)cnt[atan2(y[j]-y[i],x[j]-x[i])]++;\n\t\tfor(map<db,int>::iterator it=cnt.begin();it!=cnt.end();it++)ilg=add(ilg,sub(bin[it->w2],1));\n\t}\n\tilg=1ll*ilg*power(2,mod-2,mod)%mod;\n\tilg=add(ilg,n+1);\n\tprintf(\"%d\\n\",sub(ans,ilg));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ Templates\n#include <bits/stdc++.h>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 998244353LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\n// }}}\n\ninline bool on(ll x0, ll y0, ll x1, ll y1, ll x, ll y)\n{\n    const ll DX = x1 - x0;\n    const ll DY = y1 - y0;\n    const ll dx = x - x0;\n    const ll dy = y - y0;\n    return dx * DY == dy * DX;\n}\n\nll power(const ll p, const ll n)\n{\n    if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 1) {\n        return (power(p, n - 1) * p) % MOD;\n    } else {\n        const ll pp = power(p, n / 2);\n        return (pp * pp) % MOD;\n    }\n}\n\ninline ll calc(const ll n)\n{\n    if (n <= 2) {\n        return 0;\n    }\n    return (((power(2, n) - ((n * n + n + 2) / 2)) % MOD) + MOD) % MOD;\n}\n\nstruct Line {\n    ll ind;\n    ll dx;\n    ll dy;\n    bool operator==(const Line& l) const\n    {\n        return (ind == l.ind) and (dx * l.dy == dy * l.dx);\n    }\n    bool operator<(const Line& l) const\n    {\n        return (ind != l.ind) ? ind < l.ind : dx * l.dy < dy * l.dx;\n    }\n};\n\nostream& operator<<(ostream& os, const Line& l)\n{\n    os << \"ind: \" << l.ind << \"\\ndx: \" << l.dx << \"\\ndy:\" << l.dy << endl;\n    return os;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    vector<ll> x(N);\n    vector<ll> y(N);\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    map<Line, ll> lines;\n    for (int i = 0; i < N - 2; i++) {\n        for (int j = i + 1; j < N - 1; j++) {\n            bool flag = false;\n            for (int k = 0; k < N; k++) {\n                if (k == i or k == j) {\n                    continue;\n                }\n                if (on(x[i], y[i], x[j], y[j], x[k], y[k])) {\n                    const Line ln = Line{min({i, j, k}), x[j] - x[i], y[j] - y[i]};\n                    if (lines.find(ln) == lines.end()) {\n                        lines[ln] = 3;\n                        for (int l = 0; l < N; l++) {\n                            if (l == i or l == j or l == k) {\n                                continue;\n                            }\n                            if (on(x[i], y[i], x[j], y[j], x[l], y[l])) {\n                                lines[ln]++;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    ll calced = calc(N);\n    for (const auto& e : lines) {\n        const ll l = e.second;\n        calced -= calc(l);\n    }\n    cout << calced << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst int MAXN = 100500;\n\nstruct Point \n{\n\tint x, y;\n\n\tPoint () {}\n\n\tPoint (int _x, int _y): x(_x), y(_y) {}\n\n\tvoid Scan()\n\t{\n\t\tcin >> x >> y;\n\t}\n\n\tPoint operator-(Point b)\n\t{\n\t\treturn Point(x - b.x, y - b.y);\n\t}\n\n\tPoint operator+(Point b)\n\t{\n\t\treturn Point(x + b.x, y + b.y);\n\t}\n\n\tint operator%(Point b)\n\t{\n\t\treturn x * b.x + y * b.y;\n\t}\n\n\tint operator*(Point b)\n\t{\n\t\treturn x * b.y - y * b.x;\n\t}\n};\n\nPoint pt[MAXN];\nint n;\nint cnt[MAXN];\n\nll sum(ll a, ll b)\n{\n\treturn (a + b) % MOD;\n}\n\nll sub(ll a, ll b)\n{\n\treturn (a - b + MOD) % MOD;\n}\n\nll mul(ll a, ll b)\n{\n\treturn a * b % MOD;\n}\n\nlong long bin_pow(ll a, ll n)\n{\n\tll res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = mul(res, a);\n\t\ta = mul(a, a);\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\nint main()\n{                                                     \n\tios_base::sync_with_stdio(0);\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t\tpt[i].Scan();\n\t\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tint count = 0;\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif ((pt[i] - pt[j]) * (pt[i] - pt[k]) == 0)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tcnt[count]++;\n\t\t\t}\n\t\t}\n\n\n\tassert(cnt[0] == 0 && cnt[1] == 0);\n\n\n\tlong long dif = 1 + n;\n\t\n\tfor (int i = 2; i <= n; i++)\n\t{\n\t\tint kek = i * (i - 1);\n\t\tassert(cnt[i] % kek == 0);\n\t\tcnt[i] /= kek;\n\t\tcout << i << ' ' << cnt[i] << '\\n';\n\n\t\tdif = sum(dif, mul(cnt[i],sub(bin_pow(2, i), i + 1)));\n\t}\n\n\tlong long ans = sub(bin_pow(2, n), dif);\n\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vdouble = vector<double>;\nusing vvdouble = vector<vdouble>;\nusing vvvdouble = vector<vvdouble>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\nconstexpr int mod2 = 998244353;\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) { return (a > b && (a = b, true)); }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) { return (a < b && (a = b, true)); }\ntemplate<typename T>\nbool isin(T y, T x, T h, T w) { return (0 <= y && 0 <= x && y < h && x < w); }\ntemplate<typename T>\nbool isin1(T y, T x, T h, T w) { return (0 < y && 0 < x && y <= h && x <= w); }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++) os << \" \" << v[i];\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nconstexpr double EPS = 1e-10;\nbool equals(double a, double b) { return (abs(a - b) < EPS); }\n\nstruct V2 {\n\tdouble x, y;\n\tV2(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tV2 operator + (V2 p) const { return (V2(x + p.x, y + p.y)); }\n\tV2 operator - (V2 p) const { return (V2(x - p.x, y - p.y)); }\n\tV2 operator * (double r) const { return (V2(x * r, y * r)); }\n\tV2 operator / (double r) const { return (V2(x / r, y / r)); }\n\n\tdouble norm() const { return (sqrt(sqrNorm())); }\n\tdouble sqrNorm() const { return (x*x + y*y); }\n\n\tbool operator < (const V2 &p) const { \n\t\treturn (x != p.x ? x < p.x : y < p.y); \n\t}\n\tbool operator == (const V2 &p) const {\n\t\treturn (equals(x, p.x) && equals(y, p.y));\n\t}\n\n\tV2 rotate90() const { return (V2(y, -x)); }\n\tV2 normalized() const { return (*this / norm()); }\n\n\tdouble dot(const V2 &p) const { return (x*p.x + y*p.y); }\n\tdouble cross(const V2 &p) const { return (x*p.y - y*p.x); }\n\tdouble arg() const { return (atan2(y, x)); }\n};\n\nvoid Main() {\n\tint N; cin >> N;\n\tvector<V2> ps(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> ps[i].x >> ps[i].y;\n\t}\n\n\tll sum = 0;\n\n\tsort(begin(ps), end(ps));\n\tfor (int a = 0; a < N; a++) {\n\t\tvector<pair<double, V2>> dats;\n\t\tint n = N-a-1;\n\t\tfor (int b = a+1; b < N; b++) {\n\t\t\tdats.emplace_back((ps[b]-ps[a]).arg(), ps[b]-ps[a]);\n\t\t}\n\t\tsort(begin(dats), end(dats));\n\t\tvector<V2> nps(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnps[i] = dats[i].second;\n\t\t}\n\n\t\tvvll contval(n, vll(n, 1));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int k = i+1; k < n; k++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (j == i || j == k) continue;\n\t\t\t\t\tdouble cr1 = nps[i].cross(nps[j]), cr2 = -nps[k].cross(nps[j]-nps[k]);\n\t\t\t\t\tdouble cr3 = (nps[k]-nps[i]).cross(nps[j]-nps[i]);\n\t\t\t\t\tif (cr1 > -EPS && cr2 > -EPS && cr3 > -EPS || cr1 < EPS && cr2 < EPS && cr3 < EPS) {\n\t\t\t\t\t\t(contval[i][k] *= 2) %= mod2;\n\t\t\t\t\t\t//cout << a << \" \" << nps[i].x << \" \" << nps[i].y << \" \" << nps[k].x << \" \" << nps[k].y << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tvvll dp(n, vll(n, 0));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tif (!equals(nps[i].cross(nps[j]), 0.0)) dp[i][j] = contval[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tV2 v1 = nps[j]-nps[i];\n\t\t\t\tfor (int k = j+1; k < n; k++) {\n\t\t\t\t\tV2 v2 = nps[k]-nps[i];\n\t\t\t\t\tif (v1.cross(v2) < EPS) continue;\n\t\t\t\t\t(dp[j][k] += contval[j][k] * dp[i][j]) %= mod2;\n\t\t\t\t}\n\t\t\t\t(sum += dp[i][j]) %= mod2;\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mo=998244353;\nconst double pi=acos(-1),eps=1e-10;\nint n,x[205],y[205],s[205],ans;\ndouble a[205]; \n\nint qpow(int a,int b)\n{\n\tint x=a;  a=1;\n\twhile (b)\n\t\t{\n\t\t\tif (b&1)  a=1LL*a*x%mo;\n\t\t\tx=1LL*x*x%mo,b>>=1;\n\t\t}\n\treturn a;\n}\n\nint f(int x){return (qpow(2,x)+mo-(1+x+1LL*x*(x-1)/2)%mo)%mo;}\nint dcmp(double x){return (x>eps)-(x<-eps);}\n\nvoid work()\n{\n\tscanf(\"%d\",&n),ans=f(n);\n\tfor (int i=1; i<=n; i++)  scanf(\"%d %d\",&x[i],&y[i]);\n\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1,k=0; j<=n; j++)\n\t\t\t\tif (i!=j)  a[++k]=atan2(y[i]-y[j],x[i]-x[j]);\n\t\t\tfor (int j=1; j<n; j++)  a[j]+=pi*(dcmp(a[j])<=0);\n\t\t\tsort(a+1,a+n);\n\t\t\tfor (int l,r=1; r<n; )\n\t\t\t\t{\n\t\t\t\t\tl=r;\n\t\t\t\t\twhile ((r<n)&&(dcmp(a[r]-a[l])==0))  r++;\n\t\t\t\t\ts[r-l+1]++;\n\t\t\t\t}\n\t\t}\n\tfor (int i=1; i<=n; i++)  ans=(ans+mo-1LL*s[i]/i*f(i)%mo)%mo;\n\tprintf(\"%d\",ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nusing ld=long double;\nusing P=complex<ld>;\nconst ll MOD=998244353;\n\nld cross(P x,P y){\n    return x.real()*y.imag()-x.imag()*y.real();\n}\nbool onLine(P x,P y,P z){\n    return cross(x-y,z-x)==0;\n}\nint main(){\n    int n;\n    cin>>n;\n    vector<P> xy(n);\n    for(int i=0;i<n;i++){\n        ld x,y;\n        cin>>x>>y;\n        xy[i]={x,y};\n    }\n    \n    ll res=1;\n    for(int i=0;i<n;i++){\n        res*=2;\n        res%=MOD;\n    }\n    res--;\n    for(int i=0;i<n;i++){\n        vector<int> used(n,false);\n        res--;\n        for(int j=i+1;j<n;j++){\n            if(used[j]) continue;\n            ll cnt=2;\n            for(int k=j+1;k<n;k++){\n                if(onLine(xy[i],xy[j],xy[k])){\n                    used[k]=true;\n                    cnt*=2;\n                    cnt%=MOD;\n                }\n            }\n            res-=(cnt-1);\n            res%=MOD;\n        }\n    }\n    res=(res%MOD+MOD)%MOD;\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 210\n#define ll long long\n#define db double\n#define For(i,x,y) for(int i=(x);i<=(y);++i)\n#define Rof(i,x,y) for(int i=(x);i>=(y);--i)\n#define Edge(x) for(int i=head[x];i;i=e[i].nxt)\n#define lson l,mid,o<<1\n#define rson mid+1,r,o<<1|1\n#define mset(x,y) memset(x,y,sizeof(y))\n#define mcpy(x,y) memcpy(x,y,sizeof(x))\n#define p_b push_back\n#define mod 998233353\nusing namespace std;\nll _2[N];\nint x[N],y[N];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);_2[0]=1;\n\tFor(i,1,n) _2[i]=(_2[i-1]+_2[i-1])%mod;\n\tll ans=_2[n]-1-n-n*(n-1)/2;\n\twhile(ans<0) ans+=mod;\n\tFor(i,1,n) scanf(\"%d%d\",&x[i],&y[i]);\n\tFor(i,1,n) For(j,i+1,n){\n\t\tint tmp=0;\n\t\tFor(k,j+1,n) if(1ll*(1ll*y[j]-y[i])*(1ll*x[k]-x[j])==1ll*(1ll*y[k]-y[j])*(1ll*x[j]-x[i])) tmp++;\n\t\t(ans+=mod+1-_2[tmp])%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF = 0x3c3c3c3c;\nconst ll INFL = 0x3c3c3c3c3c3c3c3c;\nconst int MOD = 998244353;\n\nstruct p{\n\tint x, y;\n\tbool operator <(p &o){\n\t\tif(x != o.x) return x < o.x;\n\t\treturn y < o.y;\n\t}\n};\n\np point[209];\nint OLCount[209][209];\nint power[209];\n\nint isLine(int x1, int y1, int x2, int y2, int x3, int y3){\n\treturn x1 * y2 + x2 * y3 + x3 * y1 - x2 * y1 - x3 * y2 - x1 * y3;\n}\n\nbool isPossible(vector<p> &v){\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = i + 1; j < 4; j++){\n\t\t\tfor(int k = j + 1; k < 4; k++){\n\t\t\t\tbool f = isLine(v[i].x, v[i].y, v[j].x, v[j].y, v[k].x, v[k].y);\n\t\t\t\tif(!f) return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint N;\n\tcin >> N;\n\tpower[0] = 1;\n\tfor(int i = 1; i < 209; i++){\n\t\tpower[i] = (power[i - 1] * 2) % MOD;\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpoint[i] = {x, y};\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tvector<p> v;\n\t\tv.push_back(point[i]);\n\t\tfor(int j = i + 1; j < N; j++){\n\t\t\tv.push_back(point[j]);\n\t\t\tint lx = min(point[i].x, point[j].y), rx = max(point[i].x, point[j].y);\n\t\t\tfor(int k = j + 1; k < N; k++){\n\t\t\t\tif(point[k].x < lx) continue;\n\t\t\t\tif(point[k].x > rx) continue;\n\t\t\t\tv.push_back(point[k]);\n\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\tbool f = isLine(v[0].x, v[0].y, v[1].x, v[1].y, v[2].x, v[2].y);\n\t\t\t\tif(!f){\n\t\t\t\t\tOLCount[i][j]++;\n\t\t\t\t\tOLCount[j][i]++;\n\t\t\t\t}\n\t\t\t\tv.pop_back();\n\t\t\t}\n\t\t\tv.pop_back();\n\t\t}\n\t\tv.pop_back();\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tvector<p> v;\n\t\tv.push_back(point[i]);\n\t\tfor(int j = i + 1; j < N; j++){\n\t\t\tv.push_back(point[j]);\n\t\t\tfor(int k = j + 1; k < N; k++){\n\t\t\t\tv.push_back(point[k]);\n\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\tbool f = isLine(v[0].x, v[0].y, v[1].x, v[1].y, v[2].x, v[2].y);\n\t\t\t\tv.pop_back();\n\t\t\t\tif(!f) continue;\n\t\t\t\tans += power[OLCount[i][j] + OLCount[j][k] + OLCount[k][i]];\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t\tv.pop_back();\n\t\t}\n\t\tv.pop_back();\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tvector<p> v;\n\t\tv.push_back(point[i]);\n\t\tfor(int j = i + 1; j < N; j++){\n\t\t\tv.push_back(point[j]);\n\t\t\tfor(int k = j + 1; k < N; k++){\n\t\t\t\tv.push_back(point[k]);\n\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\tbool f = isLine(v[0].x, v[0].y, v[1].x, v[1].y, v[2].x, v[2].y);\n\t\t\t\tif(!f){\n\t\t\t\t\tv.pop_back();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int l = k + 1; l < N; l++){\n\t\t\t\t\tv.push_back(point[l]);\n\t\t\t\t\tsort(v.begin(), v.end());\n\t\t\t\t\tif(!isPossible(v)){\n\t\t\t\t\t\tv.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans += power[OLCount[i][j] + OLCount[j][k] + OLCount[k][l] + OLCount[l][i]];\n\t\t\t\t\tans %= MOD;\n\t\t\t\t\tv.pop_back();\n\t\t\t\t}\n\t\t\t\tv.pop_back();\n\t\t\t}\n\t\t\tv.pop_back();\n\t\t}\n\t\tv.pop_back();\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <string>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <random>\n#include <chrono>\nusing namespace std;\n\nint n;\nconst int maxn = 205;\n\nstruct P{\n    int x, y;\n    P(){}\n    P(int _x, int _y):x(_x), y(_y){}\n    P operator - (P p){return P(x-p.x, y-p.y);}\n    int det(P p){return x * p.y - y * p.x;}\n    void read(){\n        cin >> x >> y;\n    }\n}p[maxn], p1[maxn];\n\nconst int mod = 998244353;\n\nbool cmp(P a, P b){\n    return a.det(b) < 0; \n}\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nvoid sub(int &a, int b){\n    a -= b;\n    if(a < 0)\n        a += mod;\n}\n\nint qpow(int a, int n){\n    int ret = 1;\n    while(n > 0){\n        if(n & 1)\n            ret = 1LL * ret * a % mod;\n        a = 1LL * a * a % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint main(){\n    cin >> n;\n    for(int i = 1;i <= n;i++){\n        p[i].read();\n    }\n    int ans = qpow(2, n);\n    sub(ans, 1);\n    sub(ans, n);\n    sub(ans, n * (n - 1) / 2);\n    for(int i = 1;i <= n;i++){\n        int cnt = n - i;\n        for(int j = i + 1;j <= n;j++){\n            p1[j - i] = p[j] - p[i];\n            if(p1[j].x < 0){\n                p1[j].x = -p1[j].x;\n                p1[j].y = -p1[j].y;\n            }\n        }\n        sort(p1 + 1, p1 + 1 + cnt, cmp);\n        for(int j = 1, k = 1;j <= cnt;j = k + 1, k = j){\n            while(k < cnt and p1[j].det(p1[k + 1]) == 0){\n                k++;\n            }\n            for(int l = j;l < k;l++){\n                int len = k - l;\n                int tmp = qpow(2, len);\n                sub(tmp, 1);\n                sub(ans, tmp);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register int i=(a);i<=(b);i++)\n#define For(i,a,b) for (register int i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\n#define GO(u) for (register int j=f[u];j!=-1;j=nxt[j])\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define MP make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int N=205;\nconst int mod=998244353;\nint n,x[N],y[N],ans=0,er[N];\ninline int read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\ninline void write(int x)\n{\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>9) write(x/10);\n\tputchar(x%10+'0');\n\treturn;\n}\ninline double K(int i,int j) {return 1.0*(y[i]-y[j])/(1.0*(x[i]-x[j]));}\nint main()\n{\n\tn=read();\n\tFOR(i,1,n) x[i]=read(),y[i]=read();\n\ter[0]=1;\n\tFOR(i,1,n) er[i]=2LL*er[i-1]%mod;\n\tans=(1LL*er[n]-1-n+mod)%mod;\n\tFOR(i,1,n) FOR(j,1,i-1) \n\t{\n\t\tint cnt=0;\n\t\tFOR(k,1,j-1) if (K(i,j)==K(j,k)) cnt++;\n\t\tans=(1LL*ans-er[cnt]+mod)%mod;\n\t}\n\twrite(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define mk make_pair\nusing namespace std;\nconst int N = 2e2 + 5;\nconst int mod = 998244353;\nbool bo[N][N];\nint n, x[N], y[N];\nvector<int> V;\nll ans, p[N];\nbool line(int i, int j, int k) {\n\treturn (x[j] - x[i]) * (y[k] - y[i]) - (x[k] - x[i]) * (y[j] - y[i]) == 0; \n}\nint main() {\n\tp[0] = 1;\n\tfor (int i = 1; i < N; i++) p[i] = p[i - 1] * 2 % mod;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (bo[i][j]) continue;\n\t\t\tV.clear();\n\t\t\tV.push_back(i);\n\t\t\tV.push_back(j);\n\t\t\tfor (int k = j + 1; k <= n; k++) {\n\t\t\t\tif (line(i, j, k)) V.push_back(k);\n\t\t\t}\n\t\t\tfor (int k = 0; k < V.size(); k++)\n\t\t\t\tfor (int l = 0; l < V.size(); l++)\n\t\t\t\t\tbo[V[k]][V[l]] = 1;\n\t\t\tans += p[V.size()] - V.size() - 1;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tans = p[n] - ans - n - 1;\n\tans %= mod;\n\tans += mod;\n\tans %= mod;\n\tcout << ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,ans;\n\nint Es[maxn];\n\nll x[maxn],y[maxn];\n\nvoid Work(){\n\tEs[0]=1;REP(i,1,n)Es[i]=(Es[i-1]<<1)%mod;\n\tans=(1ll*Es[n]-1ll*n*(n+1)/2%mod-1+mod)%mod;\n\tREP(i,1,n)REP(j,i+1,n){\n\t\tint t=0;\n\t\tREP(k,j+1,n)if((x[j]-x[i])*(y[k]-y[i])-(x[k]-x[i])*(y[j]-y[i])==0)t++;\n\t\tans=(ans-Es[t]+1+mod)%mod;\n\t}\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n);\n\tREP(i,1,n)read(x[i],y[i]);\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n\n//#define DEBUG 1\n\n#define int long long\n#define for0(i,n) for (int i=0; i<n; i++)\n#define iter(c) for(auto it=c.begin(); it!=c.end(); it++)\n#define iter2(c) for(auto it2=c.begin(); it2!=c.end(); it2++)\n#define vec(x) vector< x >\n#define pb push_back\n#define ms(a,z) memset(a,z,sizeof(a));\n#define mp make_pair\n#define X first\n#define Y second\n#define sqr(x) 1LL*(x)*(x)\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define all(a) a.begin(),a.end()\n#define sz(x) (int)(x).size()\n#ifdef int\n#define read(x) scanf(\"%lld\",&x);\n#else\n#define read(x) scanf(\"%d\",&x);\n#endif\n\n#ifdef DEBUG\n#define nl cout<<\"\\n\";\n#define pr(x) cout<<(x)<<\" \";\n#define prl(x) cout<<#x \" = \"<<x<<endl;\n#define prp(x) cout<<\"(\"<<(x).first<<\" \"<<(x).second<<\") \";\n#define printv(v) {for(int _=0; _<sz(v); _++) cout<<v[_]<<\" \"; cout<<\"\\n\";}\n#define printa(a,s) {for (int _=0; _<s; _++) cout<<a[_]<<\" \"; cout<<\"\\n\";}\n#define print2D(a,m,n) {for (int _=0; _<m; _++) {for (int __=0; __<n; __++) cout<<a[_][__]<<\" \"; cout<<\"\\n\";} cout<<\"\\n\";}\n#define debug cout<<\"ok at line \"<<__LINE__<<endl;\n#else\n#define nl\n#define pr(x)\n#define prl(x)\n#define prp(x)\n#define printv(v)\n#define printa(a,s)\n#define print2D(a,m,n)\n#define debug\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<long long, long long> point;\n\nconst int INF = 2147483647;\nconst long long INFL = 9223372036854775807LL;\nconst double EPSILON = 0.00000001;\nconst long long MOD = 998244353;\n\nll pow2[205];\n\nbool colinear(point a, point b, point c){\n    return a.X*b.Y - a.Y*b.X + a.Y*c.X - a.X*c.Y + b.X*c.Y - c.X*b.Y == 0;    \n}\n\nll get_score(ll k)\n{\n    if (k < 3)\n        return 0;\n    ll ret = (pow2[k] - 1 - k - k*(k-1)/2) % MOD;\n    //ret = (ret + MOD) % MOD;\n    return ret;\n}\n\nbool done[205][205];\n\nint32_t main()\n{\n    #ifdef DEBUG\n    freopen(\"convex_score.txt\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    #endif\n\n    ms(done,false);\n    vector<point> points;\n    int n;\n    cin >> n;\n    for0(i,n) {\n        int x,y;\n        cin >> x >> y;\n        points.pb({x,y});\n    }\n    pow2[0] = 1;\n    for (int i=1; i<=n; i++)\n        pow2[i] = (pow2[i-1] * 2) %MOD;\n    \n    ll total = get_score(n);\n    prl(total)\n    \n    for (int i=0; i<n; i++) {\n        for (int j=i+1; j<n; j++) {\n            if (done[i][j]) continue;\n            \n            done[i][j] = done[j][i] = true;\n            vector<int> colinear_set = {i,j};\n            for (int k=j+1; k<n; k++) {\n                if (colinear(points[i], points[j], points[k])) {\n                    iter(colinear_set) {\n                        done[*it][k] = done[k][*it] = true;\n                    }\n                    colinear_set.pb(k);\n                }\n            }\n            if (sz(colinear_set) >= 3) {\n                pr(i) pr(j) nl\n                printv(colinear_set)\n                total = (total - get_score(sz(colinear_set))) % MOD;\n            }\n        }\n    }\n    \n    total = (total + MOD) % MOD;\n    cout<<total<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\nstruct point\n{\n    int x,y;\n};\ninline bool sameline(point a,point b,point c)\n{\n    if(a.x==b.x&&b.x==c.x)\n        return true;\n    if((a.x-b.x)*(b.y-c.y)==(b.x-c.x)*(a.y-b.y))\n        return true;\n    return false;\n}\nint n;\npoint a[205];\nlong long ans=1;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n        ans=ans*2%MOD;\n    ans-=n+1;\n    ans%=MOD;\n    while(ans<0)\n        ans+=MOD;\n    for(int i=0;i<n;i++)\n        scanf(\"%d %d\",&a[i].x,&a[i].y);\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            long long  d=4,amt=2;\n            bool vst=false;\n            for(int k=0;k<j;k++)\n                if(k!=i&&k!=j&&sameline(a[i],a[j],a[k]))\n                    vst=true;\n            if(vst)\n                continue;\n            for(int k=j+1;k<n;k++){\n                if(sameline(a[i],a[j],a[k])){\n                    d=d*2%MOD;\n                    amt++;\n                }\n            }\n            ans-=d-amt-1;\n            ans%=MOD;\n            while(ans<0)\n                ans+=MOD;\n        }\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mo=998244353;\nconst double pi=acos(-1);\nint n,x[205],y[205],s[205],ans;\ndouble a[205]; \n\nint qpow(int a,int b)\n{\n\tint x=a;  a=1;\n\twhile (b)\n\t\t{\n\t\t\tif (b&1)  a=1LL*a*x%mo;\n\t\t\tx=1LL*x*x%mo,b>>=1;\n\t\t}\n\treturn a;\n}\n\nint f(int x){return (qpow(2,x)+mo-(1+x+1LL*x*(x-1)/2)%mo)%mo;}\n\nvoid work()\n{\n\tscanf(\"%d\",&n),ans=f(n);\n\tfor (int i=1; i<=n; i++)  scanf(\"%d %d\",&x[i],&y[i]);\n\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1,k=0; j<=n; j++)\n\t\t\t\tif (i!=j)  a[++k]=atan2(y[i]-y[j],x[i]-x[j]);\n\t\t\tfor (int j=1; j<n; j++)  a[j]+=pi*(a[j]<0);\n\t\t\tsort(a+1,a+n);\n\t\t\tfor (int l,r=1; r<n; )\n\t\t\t\t{\n\t\t\t\t\tl=r;\n\t\t\t\t\twhile ((r<n)&&(a[r]==a[l]))  r++;\n\t\t\t\t\ts[r-l+1]++;\n\t\t\t\t}\n\t\t}\n\tfor (int i=1; i<=n; i++)  ans=(ans+mo-1LL*s[i]/i*f(i)%mo)%mo;\n\tprintf(\"%d\",ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 998244353;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll po[210];\n\nint main() {\n    ll N;\n    cin >> N;\n    plglg pt[N];\n    REP(i, 0, N) {\n        ll x, y;\n        cin >> x >> y;\n        pt[i] = plglg(x, y);\n    }\n    sort(pt, pt + N);\n    po[0] = 1;\n    REP(i, 1, 210) {\n        po[i] = multiply(po[i - 1], 2);\n    }\n    xy_t pt2[N];\n    REP(i, 0, N) {\n        pt2[i] = xy_t(pt[i].first, pt[i].second);\n    }\n    ll difnum = 0;\n    REP(k, 0, N) {\n        vector<pdlg> vec;\n        xy_t base = pt2[k];\n        REP(i, k + 1, N) {\n            xy_t tar = pt2[i];\n            double ab = abs(tar - base);\n            xy_t dif = (tar - base) / ab;\n            double d = dif.imag();\n            bool ok = false;\n            REP(j, 0, vec.size()) {\n                pdlg p = vec[j];\n                if (abs(d - p.first) < eps) {\n                    vec[j].second++;\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok) {\n                vec.push_back(pdlg(d, 1));\n            }\n        }\n        REP(i, 0, vec.size()) {\n            ll p = vec[i].second;\n            if (p > 1) {\n                ll zero = 1;\n                ll one = p;\n                ll sum = zero + one;\n                difnum = modadd(difnum, modadd(po[p], - sum));\n            }\n        }\n    }\n    ll anssum = 1 + N + N * (N - 1) / 2;\n    //cout << anssum << \" \" << difnum << endl;\n    ll ans = modadd(po[N], - modadd(anssum, difnum));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 998244353;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,ans;\n\nint Es[maxn];\n\nll x[maxn],y[maxn];\n\nvoid Work(){\n\tEs[0]=1;REP(i,1,n)Es[i]=(Es[i-1]<<1)%mod;\n\tans=(1ll*Es[n]-1ll*n*(n+1)/2%mod-1+mod)%mod;\n\tREP(i,1,n)REP(j,i+1,n){\n\t\tint t=0;\n\t\tREP(k,j+1,n)if((x[j]-x[i])*(y[k]-y[i])-(x[k]-x[i])*(y[j]-y[i])==0)t++;\n\t\tans=(ans-Es[t]+1+mod)%mod;\n\t}\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n);\n\tREP(i,1,n)read(x[i],y[i]);\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\n#define ri register int\n#define de double\n#define mod 998244353\n#define sid 205\n\nint n, ans;\nde x[sid], y[sid];\n\ninline int fp(int a, int k) {\n    int ret = 1;\n    for( ; k; k >>= 1, a = 1ll * a * a % mod)\n    if(k & 1) ret = 1ll * ret * a % mod;\n    return ret;\n}\n\ninline bool in(int a, int b, int o) {\n    de p1 = (y[o] - y[a]) * (x[o] - x[b]);\n    de p2 = (y[o] - y[b]) * (x[o] - x[a]);\n    return fabs(p1 - p2) < 1e-9;\n}\n\nint main() {\n    cin >> n;\n    for(ri i = 1; i <= n; i ++) cin >> x[i] >> y[i];\n    ans = fp(2, n);\n    ans = (ans - 1 + mod) % mod;\n    ans = (ans - n + mod) % mod;\n    for(ri i = 1; i <= n; i ++)\n    for(ri j = i + 1;  j <= n; j ++) {\n        int ret = 0;\n        for(ri k = j + 1; k <= n; k ++)\n        if(in(i, j, k)) ret ++;\n        ans = (ans - fp(2, ret) + mod) % mod;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353;\nstruct point{\n\tint x,y;\n\tpoint(){};\n}p[210];\n\nint n;\nll pw[210],ans;\npoint operator - (point a,point b){\n\tpoint ret;\n\tret.x=a.x-b.x;\n\tret.y=a.y-b.y;\n\treturn ret;\n}\nll cross(point a,point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nll cross(point a,point b,point c){\n\treturn abs(cross(a-c,b-c));\n}\nvoid solve(){\n\tcin>>n;pw[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>p[i].x>>p[i].y;\n\t\tpw[i]=pw[i-1]*2%mod;\n\t}\n\tans=pw[n]-1-n;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tint cnt=0;\n\t\t\tfor(int k=j+1;k<=n;++k)if(cross(p[i],p[j],p[k])<=0)++cnt;\n\t\t\t(ans+=mod-pw[cnt])%=mod;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\tsolve();\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 210;\nconst int moder = 998244353;\n\nint x[N], y[N];\nint n;\n\nint powermod(int a, int exp){\n\tint ret = 1;\n\tfor ( ; exp; exp >>= 1){\n\t\tif (exp & 1){\n\t\t\tret = 1ll * ret * a % moder;\n\t\t}\n\t\ta = 1ll * a * a % moder;\n\t}\n\treturn ret;\n}\n\nint det(int x1, int y1, int x2, int y2){\n\treturn x1 * y2 - y1 * x2;\n}\n\nbool onSeg(int x1, int y1, int x2, int y2, int x3, int y3){\n\treturn !det(x2 - x1, y2 - y1, x3 - x1, y3 - y1);\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i){\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++ i){\n\t\tfor (int j = i + 1; j < n; ++ j){\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = 0; k < n; ++ k){\n\t\t\t\tcnt += onSeg(x[i], y[i], x[j], y[j], x[k], y[k]);\n\t\t\t}\n\t\t\tans = (ans + 1ll * (powermod(2, cnt) - (cnt + 1) + moder) * powermod(cnt * (cnt - 1) >> 1, moder - 2)) % moder;\n\t\t}\n\t}\n\tans = (ans + n + 1) % moder;\n\treturn printf(\"%d\\n\", (powermod(2, n) - ans + moder) % moder), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\ni64 gcd(i64 a,i64 b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\ni64 lcm(i64 a,i64 b){\n\treturn a/gcd(a,b)*b;\n}\n\nvoid solve(){\n    i64 N;\n    cin >> N;\n\n    using point=pair<i64,i64>;\n    vector<point> xy(N);\n    rep(i,0,N) cin >> xy[i].first >> xy[i].second;\n\n    i64 ans=1,mod=998244353;\n    \n    rep(i,0,N) ans=ans*2%mod;\n    ans=((ans-(N+1))%mod+mod)%mod;\n\n    auto is_on_same_line=[&](point &p,point &q,point &r){\n        i64 dx1=q.first-p.first,dy1=q.second-p.second,\n            dx2=r.first-q.first,dy2=r.second-q.second;\n        if(dx1==0) return dx2==0;\n        if(dx2==0) return dx1==0;\n        \n        if(dx1<0){\n            dx1*=-1;\n            dy1*=-1;\n        }\n        if(dx2<0){\n            dx2*=-1;\n            dy2*=-1;\n        }\n        i64 dx_lcm=lcm(dx1,dx2);\n        return dx_lcm/dx1*dy1==dx_lcm/dx2*dy2;\n    };\n\n    set<pair<point,point>> normalized;\n    \n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<point> ps={xy[i],xy[j]};\n            \n            rep(k,0,N) if(k!=i and k!=j and is_on_same_line(xy[i],xy[j],xy[k])) ps.push_back(xy[k]);\n            \n            sort(ps.begin(),ps.end());\n            \n            if(normalized.find(make_pair(ps[0],ps[1]))!=normalized.end()) continue;\n            normalized.insert(make_pair(ps[0],ps[1]));\n\n            i64 s=1;\n            rep(k,0,ps.size()) s=s*2%mod;\n            s-=ps.size()+1;\n            \n            ans=((ans-s)%mod+mod)%mod;\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 205\nusing namespace std;\n\n#define db double\n#define eps 1e-8\nstruct point{db x,y;};\npoint operator +(point a,point b){return (point){a.x+b.x,a.y+b.y};}\npoint operator -(point a,point b){return (point){a.x-b.x,a.y-b.y};}\ndb operator *(point a,point b){return a.x*b.y-b.x*a.y;}\npoint operator *(point a,db x){return (point){a.x*x,a.y*x};}\npoint operator /(point a,db x){return (point){a.x/x,a.y/x};}\nbool a_onleft(point a,point b){return a*b<-eps;}\ndb area(point a,point b,point c){return abs((a-c)*(b-c)/2.0);}\npoint inter(point a1,point a2,point b1,point b2){\n\tdouble s1=area(b1,b2,a1),s2=area(b1,b2,a2);\n\treturn (a1-a2)/(s1+s2)*s2+a2;\n}\n#undef db\n#undef eps\nconst int mod=998244353;\npoint p[N];\nint n,pw[N];\nint main(){\n\tscanf(\"%d\",&n);pw[0]=1;\n\tfor(int i=1;i<=n;i++) scanf(\"%lfq%lf\",&p[i].x,&p[i].y),pw[i]=pw[i-1]*2%mod;\n\tlong long ans=pw[n]-1-n;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint cnt=0;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\t\tif(area(p[i],p[j],p[k])<1e-8) cnt++;\n\t\t\tans-=pw[cnt];\n\t\t}\n\tcout<<(ans%mod+mod)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAX_N 201\n#define MOD 998244353\n\nint x[MAX_N], y[MAX_N], p[MAX_N];\n\nint main(void)\n{\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d%d\", &x[i], &y[i]);\n    p[0] = 1;\n    for (int i = 0; i < n; i++)\n        p[i + 1] = (p[i] << 1) % MOD;\n    int ans = p[n] - n - 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            int cnt = 0;\n            for (int k = 0; k < j; k++) {\n                if ((x[i] - x[j]) * (y[i] - y[k]) == (x[i] - x[k]) * (y[i] - y[j]))\n                    cnt++;\n            }\n            ans -= p[cnt];\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\nconstexpr int MOD = 1000000007;\n\ntypedef std::pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nauto fraclt = [](const pii&a,const pii&b) { return (ll)a.x * b.y < (ll)b.x * a.y; };\nstruct cmpfrac { bool operator()(const pii&a,const pii&b)const { return (ll)a.x * b.y < (ll)b.x * a.y; }};\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) {ui b=0;while(x){x>>=1;++b;}return b;}\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector<vector<T>>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector<vector<T>>>(a,vector<vector<T>>(b,vector<T>(c,t))){}};\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { B = 0; for (auto &a: A) a = queue<T>(); }\nprivate:\n\tvector<queue<T>> A; ui B;\n};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if ((ll)v+o.v >= N) v = (ll)v+o.v-N; else v = v+o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v = N-o.v+v; else v=v-o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\tstatic int div(int p, int q, int N) {\n\t\tll t=0,nt=1,r=N,nr=q;\n\t\twhile(nr){ ll q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r) { return 0; }\n\t\treturn (int)(((ll)t*(ll)p/r)%N);\n\t}\n};\n#endif\n\n\n\ntypedef Field<998244353> F;\n\nclass E {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector<pii> P(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> P[i].x >> P[i].y;\n        }\n\n        vector2<bool> C(N,N,false);\n\n        F ans = F(2).pow(N) - F(N) - F(1) - F(N)*F(N-1)/2;\n        for (int i = 0; i < N; ++i) {\n            for (int j = i+1; j < N; ++j) {\n                if (C[i][j]) continue;\n                int totCol = 2;\n                for (int k = j+1; k < N; ++k) {\n                    if (C[i][k]) continue;\n                    bool col = false;\n                    if (P[i].x == P[j].x && P[i].x == P[k].x) col = true;\n                    else if (P[i].x == P[j].x || P[i].x == P[k].x) col = false;\n                    else if (P[i].y == P[j].y && P[i].y == P[k].y) col = true;\n                    else if (P[i].y == P[j].y || P[i].y == P[k].y) col = false;\n                    else if ((ll)(P[i].y-P[j].y) * (P[i].x-P[k].x) == (ll)(P[i].y-P[k].y) * (P[i].x-P[j].x)) col = true;\n                    if (col) {\n                        totCol++; C[i][k] = true; C[j][k] = true;\n                    }\n                }\n\n                if (totCol > 2) {\n                    ans -= F(2).pow(totCol) - F(totCol) - F(1) - F(totCol)*F(totCol-1)/2;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tE solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) < norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[m][m] = {0};\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<ctime>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++i)\nusing namespace std;\n\ntemplate <typename tn> void read (tn & a) {\n\ttn x = 0, f = 1; char c = getchar();\n\twhile (c < '0' || c > '9'){ if (c == '-') f = -1; c = getchar(); }\n\twhile (c >= '0' && c <= '9'){ x = x * 10 + c - '0'; c = getchar(); }\n\ta = f == 1 ? x : -x;\n}\n\nconst ll INF = 998244353;\nconst int MAXN = 2333;\nconst double EPS = 1e-9;\nll n, ans;\npair<int, int> a[MAXN];\nll f[MAXN];\n\n\nstruct point {\n\tdouble x, y;\n\tpoint (double x = 0, double y = 0) : x(x), y(y) {}\n}p[MAXN];\ninline bool operator < (const point & a, const point & b) {\n\treturn a.x == b.x ? a.y < b.y : a.x < b.x;\n}\ninline point operator + (const point & a, const point & b) {\n\treturn point(a.x + b.x, a.y + b.y);\n}\ninline point operator - (const point & a, const point & b) {\n\treturn point(a.x - b.x, a.y - b.y);\n}\ninline point operator * (const point & a, const double & b) {\n\treturn point(a.x * b, a.y * b);\n}\ninline point operator / (const point & a, const double & b) {\n\treturn point(a.x / b, a.y / b);\n}\ninline double det(const point &a, const point &b) { \n\treturn a.x * b.y - b.x * a.y;\n}\ninline double dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nstruct line {\n\tpoint s, t;\n\tline (point s = point(), point t = point()) : s(s), t(t) {}\n};\n\ninline bool check(line x, line y) {\n\tpoint i = x.s - x.t;\n\tpoint j = y.s - y.t;\n\tif (abs(det (i, j)) < EPS) return 1 ; else return 0 ; \n}\n\n\nint main() {\n\tread(n);\n\tf[0] = 1;\n\trep(i, 1, n) f[i] = f[i - 1] * 2 % INF;\n\trep(i, 1, n) {\n\t\tdouble x, y;\n\t\tread(x);\n\t\tread(y);\n\t\tp[i] = point(x, y);\n\t}\n\tans = f[n] - n - 1;\n\trep(i, 1, n) {\n\t\trep(j, 1, i - 1) {\n\t\t\tll s = 0;\n\t\t\trep(k, 1, j - 1) {\n\t\t\t\tif (check(line(p[i], p[j]), line(p[j], p[k]))) ++s;\n\t\t\t}\n\t\t\tans -= f[s];\n\t\t\tans %= INF;\n\t\t}\n\t}\n\tans += INF;\n\tans %= INF;\n\tcout << ans << \"\\n\";\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "//I hate signal 11!!\n#include<bits/stdc++.h>\n#define MAX_N 215\n#define MOD 998244353LL\n#define LL long long\n#define ccw(x,y,z,p,q,r) (((x)-(z))*(q)+((y)-(x))*(r)+((z)-(y))*(p))\nusing namespace std;\nstruct node{\n\tLL x,y;\n}arr[MAX_N],b[MAX_N];\nLL n,m,I,ans,t[MAX_N][MAX_N],cost[MAX_N],temp,z;\n// I need angle sort stl...\n//inline LL ccw(node x,node y,node z){return (x.x-z.x)*y.y+(y.x-x.x)*z.y+(z.x-y.x)*x.y;}\nbool angle_sort(node x,node y){\n\tz=ccw(x.x,arr[I].x,y.x,x.y,arr[I].y,y.y);\n\tif(z<0)\treturn true;\n\tif(z>0)\treturn false;\n}\nvoid make_b(){\n\tLL i;\n\tm=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(arr[I].y>arr[i].y || (arr[I].y==arr[i].y && arr[I].x>=arr[i].x))\tcontinue;\n\t\tb[++m]=arr[i];\n\t}\n\tsort(b+1,b+m+1,angle_sort);\n}\nint main(){\n\tLL i=1,prev,curr,next,cnt,scnt;\n\tcost[0]=1;\n\twhile(i<=203){cost[i]=(cost[i-1]*2)%MOD;i++;}\n\tscanf(\"%lld\",&n);\n\tfor(i=1;i<=n;i++)\tscanf(\"%lld %lld\",&arr[i].x,&arr[i].y);\n\t//t[curr][next] : dp table, start i, curr and next node!!\n\tfor(I=1;I<=n;I++){\n\t\tmake_b();\n\t\t//first point : I(arr[I])...\n\t\tfor(curr=1;curr<=m;curr++){\n\t\t\tfor(next=curr+1;next<=m;next++){\n\t\t\t\tt[curr][next]=0;\n\t\t\t\tif(ccw(arr[I].x,b[curr].x,b[next].x,arr[I].y,b[curr].y,b[next].y)==0)\tcontinue;\n\t\t\t\tcnt=scnt=0;\n\t\t\t\tfor(i=curr+1;i<next;i++){\n\t\t\t\t\tif(ccw(b[curr].x,b[next].x,b[i].x,b[curr].y,b[next].y,b[i].y)>=0){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(ccw(arr[I].x,b[i].x,b[curr].x,arr[I].y,b[i].y,b[curr].y)==0)\tscnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(i=curr-1;i>0;i--){\n\t\t\t\t\tif(ccw(arr[I].x,b[curr].x,b[i].x,arr[I].y,b[curr].y,b[i].y)!=0)\tbreak;\n\t\t\t\t\tif(ccw(b[curr].x,b[next].x,b[i].x,b[curr].y,b[next].y,b[i].y)>=0){cnt++;scnt++;}\n\t\t\t\t}\n\t\t\t\tfor(i=next+1;i<=m;i++){\n\t\t\t\t\tif(ccw(arr[I].x,b[next].x,b[i].x,arr[I].y,b[next].y,b[i].y)!=0)\tbreak;\n\t\t\t\t\tif(ccw(b[curr].x,b[next].x,b[i].x,b[curr].y,b[next].y,b[i].y)>=0)\tcnt++;\n\t\t\t\t}\n\t\t\t\tfor(prev=curr-1;prev>0;prev--){\n\t\t\t\t\tif(ccw(b[prev].x,b[curr].x,b[next].x,b[prev].y,b[curr].y,b[next].y)>0)\tt[curr][next]=(t[curr][next]+t[prev][curr])%MOD;\n\t\t\t\t}\n\t\t\t\tt[curr][next]=((t[curr][next]*cost[cnt-scnt])%MOD+cost[cnt])%MOD;\n\t\t\t\tans=(t[curr][next]+ans)%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\n\nconstexpr long long mod = 998244353;\n\nusing P = complex<int>;\n\nint dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\nint cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nnamespace std {\n  bool operator<(P a, P b) {\n    return atan2(a.imag(), a.real()) < atan2(b.imag(), b.real());\n  }\n}\n\nint gcd(int x, int y) {\n  x = abs(x);\n  y = abs(y);\n  if (y == 0) return x;\n  return gcd(y, x % y);\n}\n\nP unit(P a) {\n  int g = gcd(a.real(), a.imag());\n  return P(a.real() / g, a.imag() / g);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<P> ps(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    ps[i] = P(x, y);\n  }\n\n  vector<pair<int, int>> es;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      es.emplace_back(i, j);\n    }\n  }\n  sort(es.begin(), es.end(), [&](pair<int, int> a, pair<int, int> b) {\n    P d = ps[a.second] - ps[a.first];\n    P e = ps[b.second] - ps[b.first];\n    if (cross(d, e) == 0 && dot(d, e) >= 0) {\n      return dot(ps[a.second] - ps[a.first], ps[b.first] - ps[a.first]) < 0;\n    } else {\n      return d < e;\n    }\n  });\n\n  vector<vector<P>> qs(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      qs[i].push_back(ps[j] - ps[i]);\n    }\n    sort(qs[i].begin(), qs[i].end());\n    for (int j = 0; j < n - 1; j++) {\n      qs[i].push_back(qs[i][j]);\n    }\n  }\n\n  static int in[200][200][200];\n  static int on[200][200];\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      for (int k = 0; k < n; k++) {\n        if (i == k || j == k) continue;\n        for (int l = 0; l < n; l++) {\n          if (i == l || j == l || k == l) continue;\n          for (tuple<int, int, int> t : {make_tuple(i, j, k), make_tuple(k, i, j), make_tuple(i, j, k)}) {\n            int x, y, z;\n            tie(x, y, z) = t;\n            int L = lower_bound(qs[y].begin(), qs[y].begin() + (n - 1), unit(ps[y] - ps[x])) - qs[y].begin();\n            if (L == n - 1) continue;\n            int R = lower_bound(qs[y].begin() + L, qs[y].begin() + (L + n - 1), unit(ps[z] - ps[y])) - qs[y].begin();\n          }\n          //if (cross(ps[j] - ps[i], ps[l] - ps[i]) > 0 && cross(ps[k] - ps[j], ps[l] - ps[j]) > 0 && cross(ps[i] - ps[k], ps[l] - ps[k]) > 0) {\n          //  in[i][j][k]++;\n          //}\n        }\n        on[i][j] += cross(ps[k] - ps[i], ps[j] - ps[i]) == 0 && dot(ps[k] - ps[i], ps[j] - ps[i]) > 0 && dot(ps[k] - ps[j], ps[i] - ps[j]) > 0;\n      }\n    }\n  }\n\n  vector<long long> two(n + 1);\n  two[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two[i] = two[i - 1] * 2 % mod;\n  }\n\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    vector<long long> dp1(n);\n    vector<long long> dp2(n);\n    for (auto e : es) {\n      int u = e.first;\n      int v = e.second;\n\n      if (u == i) {\n        assert(dp1[v] == 0);\n        dp1[v] = two[on[u][v]];\n      } else if (v == i) {\n        dp2[v] += dp2[u];\n      } else {\n        int c = on[i][v] + on[u][v] + in[i][u][v];\n        dp2[v] += dp1[u] * two[c];\n        dp2[v] += dp2[u] * two[c];\n      }\n      dp2[v] %= mod;\n    }\n    ans += dp2[i];\n    ans %= mod;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\n#define pb push_back\n#define w1 first\n#define w2 second\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=205,mod=998244353;\nconst db pi=acos(-1.0);\nint n,ans;\nint x[maxn],y[maxn],bin[maxn];\nmap<db,int>cnt;\nint sub(int x,int y){return x-y<0?x-y+mod:x-y;}\nint main(){\n\tread(n);\n\tbin[0]=1;rep(i,1,n)bin[i]=2ll*bin[i-1]%mod;\n\tans=bin[n];\n\trep(i,1,n)read(x[i]),read(y[i]);\n\trep(i,1,n){\n\t\tcnt.clear();\n\t\trep(j,i+1,n)cnt[atan2(y[j]-y[i],x[j]-x[i])]++;\n\t\tfor(map<db,int>::iterator it=cnt.begin();it!=cnt.end();it++)ans=sub(ans,bin[it->w2]-1);\n\t}\n\tprintf(\"%d\\n\",sub(ans,n+1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int maxn = 2e2 + 10;\nconst long long mod = 998244353;\n\nint n;\nlong long x[maxn], y[maxn];\nlong long pot[maxn];\n\nstruct line {\n\tlong long dx, dy;\n\n\tline(long long DY, long long DX) {\n\t\tlong long GCD = __gcd(DX, DY);\n\n\t\tDY /= GCD;\n\t\tDX /= GCD;\n\n\t\tif(DY < 0)\n\t\t\tDX = -DX;\n\n\t\tdx = DX;\n\t\tdy = DY;\n\t}\n};\n\nbool operator < (line a, line b) {\n\treturn (a.dx < b.dx) || (a.dx == b.dx && a.dy < b.dy);\n}\n\nlong long solve() {\n\tpot[0] = 1LL;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tpot[i] = (pot[i - 1] * 2LL) % mod;\n\n\tlong long ans = (pot[n] - 1 + mod) % mod;\n\n\tfor(int i = 1; i <= n; ++i) {\n\t\tmap <line, int> angle;\n\t\tint hor = 0, ver = 0;\n\n\t\tfor(int j = i + 1; j <= n; ++j) {\n\t\t\tlong long dx = x[i] - x[j];\n\t\t\tlong long dy = y[i] - y[j];\n\n\t\t\tif(!dx)\n\t\t\t\t++ver;\n\t\t\telse\n\t\t\t\tif(!dy)\n\t\t\t\t\t++hor;\n\t\t\t\telse\n\t\t\t\t\t++angle[line(dy, dx)];\n\t\t}\n\n\t\tlong long add = 0;\n\n\t\tfor(auto it: angle) \n\t\t\tadd = (add + pot[it.second] - 1 + mod) % mod;\n\n\t\tadd = (add + 1) % mod;\n\t\tadd = (add + pot[ver] - 1 + mod) % mod;\n\t\tadd = (add + pot[hor] - 1 + mod) % mod;\n\n\t\tans = (ans - add + mod) % mod;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tcin >> x[i] >> y[i];\n\n\tcout << solve() << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 205;\nconst int mod = 998244353;\n\nstruct Point {\n\tint x; int y;\n} a[N];\n\nlong long cross(Point O, Point A, Point B) {\n\tA.x -= O.x; A.y -= O.y; B.x -= O.x; B.y -= O.y;\n\treturn 1LL * A.x * B.y - 1LL * A.y * B.x;\n}\n\nvoid add(int &x, int y) {\n\tx += y; while(x >= mod) x -= mod; while(x < 0) x += mod;\n}\n\nint n;\nint ans;\nint pow2[N];\nint cnt[10005];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d%d\", &a[i].x, &a[i].y);\n\t}\n\n\tpow2[0] = 1; for (int i = 1; i <= n; ++i) pow2[i] = 2LL * pow2[i - 1] % mod;\n\n\t// line y = a\n\tfor (int i = 1; i <= n; ++i) cnt[a[i].y]++;\n\tfor (int y = 0; y < 1e4; ++y) add(ans, pow2[cnt[y]] - 1);\n\n\t// line: ax + b = y with a != 0\n\tfor (int pivot = 1; pivot <= n; ++pivot) {\n\t\tvector<Point> v;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (a[i].y > a[pivot].y) v.push_back(a[i]);\n\t\t}\n\t\tsort(v.begin(), v.end(), [&](Point p, Point q) {\n\t\t\treturn cross(a[pivot], p, q) > 0;\n\t\t});\n\n\t\tfor (int i = 0; i < v.size(); ) {\n\t\t\tint j = i + 1;\n\t\t\twhile(j < v.size() && cross(a[pivot], v[i], v[j]) == 0) ++j;\n\n\t\t\tadd(ans, pow2[j - i] - 1);\n\t\t\ti = j;\n\t\t}\n\t}\n\n\tans = pow2[n] - 1 - ans;\n\twhile (ans < 0) ans += mod;\n\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "."
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint read()\n{\n  int x=0,f=1;\n  char ch=getchar();\n  while((ch<'0')||(ch>'9'))\n    {\n      if(ch=='-')\n        {\n          f=-f;\n        }\n      ch=getchar();\n    }\n  while((ch>='0')&&(ch<='9'))\n    {\n      x=x*10+ch-'0';\n      ch=getchar();\n    }\n  return x*f;\n}\n\nconst int maxn=200;\nconst int mod=998244353;\n\nstruct point\n{\n  int x,y;\n};\n\npoint p[maxn+10];\nint n,ans;\n\nint quickpow(int a,int b,int m)\n{\n  int res=1;\n  while(b)\n    {\n      if(b&1)\n        {\n          res=1ll*res*a%m;\n        }\n      a=1ll*a*a%m;\n      b>>=1;\n    }\n  return res;\n}\n\nint in_line(point a,point b,point c)\n{\n  return (b.y-a.y)*(c.x-a.x)==(c.y-a.y)*(b.x-a.x);\n}\n\nint main()\n{\n  n=read();\n  for(int i=1; i<=n; ++i)\n    {\n      p[i].x=read();\n      p[i].y=read();\n    }\n  for(int i=1; i<=n; ++i)\n    {\n      for(int j=i+1; j<=n; ++j)\n        {\n          int cnt=0;\n          for(int k=j+1; k<=n; ++k)\n            {\n              if(in_line(p[i],p[j],p[k]))\n                {\n                  ++cnt;\n                }\n            }\n          ans+=quickpow(2,cnt,mod);\n          if(ans>=mod)\n            {\n              ans-=mod;\n            }\n        }\n    }\n  ans+=n+1;\n  if(ans>=mod)\n    {\n      ans-=mod;\n    }\n  ans=quickpow(2,n,mod)-ans;\n  if(ans<0)\n    {\n      ans+=mod;\n    }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int P=998244353;\nint n;\nstruct pos{\n\tint x,y;\n}ps[1007];\nint ep=0,f[1007],sz[1007];\nint gf(int x){while(x!=f[x])x=f[x]=x[f][f];return x;}\nstruct edge{\n\tint a,b;\n\tint v;\n\tbool operator<(const edge&e)const{return v<e.v;}\n\tvoid cal(){\n\t\tint x=gf(a),y=gf(b);\n\t\tif(x!=y)f[x]=y,sz[y]+=sz[x];\n\t}\n}es[207*207];\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\nint pw[1007],ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor(int i=1;i<=n;++i)pw[i]=pw[i-1]*2%P;\n\tans=(pw[n]-n-1)%P;\n\tfor(int i=0;i<n;++i)scanf(\"%d%d\",&ps[i].x,&ps[i].y);\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=0;j<i;++j){\n\t\t\tint x=ps[i].x-ps[j].x,y=ps[i].y-ps[j].y;\n\t\t\tint g=gcd(x,y);\n\t\t\tx/=g,y/=g;\n\t\t\tif(!x)y=1;\n\t\t\tif(!y)x=1;\n\t\t\tif(x<0)x=-x,y=-y;\n\t\t\tes[ep++]=(edge){i,j,x*30000+y};\n\t\t}\n\t}\n\tstd::sort(es,es+ep);\n\tfor(int i=0,j=0;i<ep;i=j){\n\t\tfor(int a=0;a<n;++a)sz[f[a]=a]=1;\n\t\tfor(;j<ep&&es[i].v==es[j].v;es[j++].cal());\n\t\tfor(int a=0;a<n;++a)if(f[a]==a&&sz[a]>1)ans=(ans-pw[sz[a]]+sz[a]+1)%P;\n\t}\n\tprintf(\"%d\\n\",(ans%P+P)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\n\nconstexpr long long mod = 998244353;\nconst double pi = acos(-1);\n\nusing P = complex<long long>;\n\nlong long dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\nlong long cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nlong long gcd(long long a, long long b) {\n  a = abs(a);\n  b = abs(b);\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nP tomato(P a) {\n  long long g = gcd(a.real(), a.imag());\n  return P(a.real() / g, a.imag() / g);\n}\n\nbool argcomp(std::complex<long long> p1, std::complex<long long> p2) {\n  bool a = p1.imag() > 0 || (p1.imag() == 0 && p1.real() >= 0);\n  bool b = p2.imag() > 0 || (p2.imag() == 0 && p2.real() >= 0);\n  if (a != b) return a;\n  long long c = p2.real() * p1.imag();\n  long long d = p1.real() * p2.imag();\n  if (c != d) return c < d;\n  return std::norm(p1) < std::norm(p2);\n}\n\nnamespace std {\n  bool operator<(const P &a, const P &b) {\n    return argcomp(a, b);\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<P> ps(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    ps[i] = P(x, y);\n  }\n\n  vector<pair<int, int>> es;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      es.emplace_back(i, j);\n    }\n  }\n  sort(es.begin(), es.end(), [&](pair<int, int> a, pair<int, int> b) {\n    P d = ps[a.second] - ps[a.first];\n    P e = ps[b.second] - ps[b.first];\n    if (cross(d, e) == 0 && dot(d, e) >= 0) {\n      return dot(ps[a.second] - ps[a.first], ps[b.first] - ps[a.first]) < 0;\n    } else {\n      return d < e;\n    }\n  });\n\n  static int in[200][200][200];\n  for (int j = 0; j < n; j++) {\n    vector<pair<P, int>> qs;\n    for (int i = 0; i < n; i++) {\n      if (i == j) continue;\n      qs.emplace_back(ps[i] - ps[j], i);\n    }\n    sort(qs.begin(), qs.end());\n    for (int i = 0; i < n; i++) {\n      if (i == j) continue;\n      P s = tomato(ps[j] - ps[i]);\n      int f = lower_bound(qs.begin(), qs.end(), make_pair(s, 0)) - qs.begin();\n      for (int l = 0; l < n - 1; l++) {\n        int k = qs[(f + l) % (n - 1)].second;\n        in[i][j][k] -= l + 1;\n        in[j][k][i] -= l + 1;\n        in[k][i][j] -= l + 1;\n      }\n    }\n  }\n  static int on[200][200];\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      for (int k = 0; k < n; k++) {\n        if (i == k || j == k) continue;\n        on[i][j] += cross(ps[k] - ps[i], ps[j] - ps[i]) == 0 && dot(ps[k] - ps[i], ps[j] - ps[i]) > 0 && dot(ps[k] - ps[j], ps[i] - ps[j]) > 0;\n        in[i][j][k] = max(0, in[i][j][k] + n);\n      }\n    }\n  }\n\n  vector<long long> two(n + 1);\n  two[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two[i] = two[i - 1] * 2 % mod;\n  }\n\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    vector<long long> dp1(n);\n    vector<long long> dp2(n);\n    for (auto e : es) {\n      int u = e.first;\n      int v = e.second;\n\n      if (u == i) {\n        assert(dp1[v] == 0);\n        dp1[v] = two[on[u][v]];\n      } else if (v == i) {\n        dp2[v] += dp2[u];\n      } else {\n        int c = on[i][v] + on[u][v] + in[i][u][v];\n        dp2[v] += dp1[u] * two[c];\n        dp2[v] += dp2[u] * two[c];\n      }\n      dp2[v] %= mod;\n    }\n    ans += dp2[i];\n    ans %= mod;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\n/*Atcoder Regular Contest 082 E\n  For each convex polygon,we count it for 2^t times,\n  while t is the size of the subset of points inside the polygon.\n  So,it can be considered as,each subset of t is counted once.\n  And it can be tranformed to the number of subsets having a convex hull.\n  Then it's easy to calculate the number of it.\n*/\nint x[205],y[205],num[205];\nint ans,n,b[205];\nint gcd(int a,int b)\n{if (a==0||b==0) return 1;\nif (a%b==0) return b;\nreturn gcd(b,a%b);\n}\ninline int read()\n{int x=0;\nchar c=getchar();\nwhile (c<'0'||c>'9') c=getchar();\nwhile (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\nreturn x;\n}\nint main (){\n\tint i,j,k;\n\tn=read();\n\tb[0]=1;\n\tfor (i=1;i<=n;i++)\n\t{b[i]=b[i-1]*2;b[i]%=mod;}\n\tans=b[n]-1-n;\n\tfor (i=1;i<=n;i++)\n\t{x[i]=read();y[i]=read();}\n\tfor (i=1;i<=n;i++)\n\t{memset (num,0,sizeof(num));\n\tmap <int,int> d[2][10005];\n\tmap <int,int>::iterator it;\n\tfor (j=i+1;j<=n;j++)\n\t{int dx=x[i]-x[j],dy=y[i]-y[j],tag;\n\tif (dx*dy<0) {tag=0;}\n\telse {tag=1;}\n\tdx=abs(dx);dy=abs(dy);\n\tint t=gcd(dx,dy);\n\tdx/=t;dy/=t;\n\tif (d[tag][dx][dy])\n\t{num[d[tag][dx][dy]]--;}\n\td[tag][dx][dy]++;\n\tnum[d[tag][dx][dy]]++;\n\t}\n\t//printf (\"Case %d\\n\",i);\n\tfor (j=1;j<=n;j++)\n\t{if (num[j])\n\t{//printf (\"%d %d\\n\",j,num[j]);\n\tans-=num[j]*(b[j]-1);ans%=mod;\n\tif (ans<0) ans+=mod;\n\t}\n\t}\n\t}\n\tprintf (\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=1e3;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nstruct P{ int x,y; inline bool operator < (const P &b) const { return x==b.x?y<b.y:x<b.x; } }p[N];\ninline P operator - (const P &a,const P &b) { return (P){a.x-b.x,a.y-b.y}; }\ninline int operator * (const P &a,const P &b) { return a.x*b.y-a.y*b.x; }\nconst int mod=998244353;\ninline bool line(int a,int b,int c) { return !((p[b]-p[a])*(p[c]-p[a])); }\nint qp[N];\nint main()\n{\n\tint n=gi(),i,j,k,s,ans=n+1;\n\n\tfor (i=qp[0]=1;i<=n;i++) {\n\t\tp[i].x=gi(),p[i].y=gi();\n\t\tqp[i]=qp[i-1]*2%mod;\n\t}\n\t\n\tsort(p+1,p+1+n);\n\tfor (i=1;i<n;i++)\n\t\tfor (j=i+1;j<=n;j++) {\n\t\t\tfor (k=1;k<j;k++)\n\t\t\t\tif (k!=i&&line(i,j,k)) break;\n\t\t\tif (k<j) continue;\n\t\t\tfor (k=j+1,s=2;k<=n;k++) s+=line(i,j,k);\n\t\t\t(ans+=qp[s]-s-1)%=mod;\n\t\t}\n\n\tcout<<((LL)qp[n]-ans+mod)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#define re register\n#define maxn 3005\n#define mod 998244353\n#define ll long long\nusing namespace std;\nint n;\nint two[maxn];\nint x[maxn],y[maxn];\n\nvoid init(){\n    two[0]=1;\n    for(re int i=1;i<=3000;i++){\n        two[i]=(two[i-1]*2)%mod;\n    }\n}\n\nint main(){\n    init();\n    scanf(\"%d\",&n);\n    for(re int i=1;i<=n;i++){\n        scanf(\"%d%d\",&x[i],&y[i]);\n    }\n    ll ans=two[n]-n-1;\n    for(re int i=1;i<=n;i++){\n        for(re int j=i+1;j<=n;j++){\n            int sum=0;\n            for(re int k=j+1;k<=n;k++){\n                if((x[i]-x[j])*(y[j]-y[k])==(y[i]-y[j])*(x[j]-x[k])){\n                    sum++;\n                }\n            }\n            ans=((ans-two[sum])%mod+mod)%mod;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//no convex hull ans=0.\n//S:convex polygon counted:2^(n-|S|)\n//number of subsets.\n//U:inside S(\\S) \n//S union U: convex hull is S\n//number of pair:(S,U),where the convex hull of S union U is S\n//S union U corresponds to a unique S,thus a unique U\n//bijection (S,U)<->S union U\n//for each subset of set,it is valid if the convex hull exists.(has postive area)\n//the only case is colinear!\n//ans=2^n-1-C(n,1)-C(n,2)-sigma(2^ai-ai-C(ai,2)-1)(ai>=3)\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nbool vis[210][210];\nstruct kk\n{\n\tint id;\n\tdouble num;\n}c[210];\nint n,i,j,k,l,x[210],y[210];\nlong long pow2[210],ans;\nconst long long P=998244353;\nbool cmp(kk A,kk B)\n{\n\treturn A.num<B.num;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%d%d\",&x[i],&y[i]);\n\tpow2[0]=1;\n\tfor (i=1;i<=n;i++) pow2[i]=pow2[i-1]*2%P;\n\tans=pow2[n];\n\tans-=1+n+n*(n-1)/2;\n\tans=(ans%P+P)%P;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tint tot=0;\n\t\tfor (j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif (vis[i][j]) continue;\n\t\t\tint dx=x[j]-x[i],dy=y[j]-y[i];\n\t\t\tif (dx==0) \n\t\t\t{\n\t\t\t\tc[++tot].id=j;\n\t\t\t\tc[tot].num=100000;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc[++tot].id=j;\n\t\t\t\tc[tot].num=(double)dy/(double)dx;\n\t\t\t}\n\t\t}\n\t\tif (tot==0) continue;\n\t\tsort(c+1,c+tot+1,cmp);\n\t\tc[0].num=c[1].num-1;\n\t\tlong long now=1;\n\t\tfor (int j=1;j<=tot;j++)\n\t\t{\n\t\t\tif (c[j].num-c[j-1].num<1e-8) now++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (now>=3) ans-=pow2[now]-now-now*(now-1)/2-1;\n\t\t\t\tans=(ans%P+P)%P;\n\t\t\t\tfor (k=j-now;k<j;k++)\n\t\t\t\t  for (l=k+1;l<j;l++)\n\t\t\t\t  {\n\t\t\t\t  \tvis[c[k].id][c[l].id]=1;\n\t\t\t\t  \tvis[c[l].id][c[k].id]=1;\n\t\t\t\t  }\n\t\t\t\tnow=2;\n\t\t\t}\n\t\t}\n\t\tif (now>=3) ans-=pow2[now]-now-now*(now-1)/2-1;\n\t\tans=(ans%P+P)%P;\n\t\tfor (k=tot-now+1;k<=tot;k++)\n\t\t\tfor (l=k+1;l<=tot;l++)\n\t\t\t\t{\n\t\t\t\t  \tvis[c[k].id][c[l].id]=1;\n\t\t\t\t  \tvis[c[l].id][c[k].id]=1;\n\t\t\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n//O(n^2 logn)"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 100010\ntypedef long long LL;\nusing namespace std;\nconst LL mod = 998244353;\nLL x[maxn], y[maxn], P[maxn];\nint fa[maxn], sz[maxn];\nvoid unionn(int x, int y) {\n    x = fa[x], y = fa[y];\n    if (x == y) return;\n    if (sz[x] > sz[y]) swap(x, y);\n    printf(\"%d %d\\n\", sz[x], sz[y]);\n    fa[x] = y; sz[y] += sz[x];\n}\nstruct node {\n    int p, q; LL dx, dy;\n};\nbool cmp(node u, node v) {\n    return u.dx < v.dx || (u.dx == v.dx && u.dy < v.dy);\n}\nvector<node> seg;\nLL GCD(LL x, LL y) {\n    return y ? GCD(y, x % y) : x;\n}\nint main() {\n    LL n;\n    scanf(\"%lld\", &n);\n    for (int i = 0; i < n; ++i) scanf(\"%lld%lld\", &x[i], &y[i]);\n    P[0] = 1;\n    for (int i = 1; i <= n; ++i) (P[i] = P[i-1] << 1) %= mod;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            LL dx = x[i]-x[j], dy = y[i]-y[j];\n            LL gcd = GCD(dx, dy);\n            dx /= gcd, dy /= gcd;\n            if (dx < 0) dx = -dx, dy = -dy;\n            seg.push_back(node{i, j, dx, dy});\n        }\n    }\n    sort(seg.begin(), seg.end(), cmp);\n\n    LL ans = P[n] - 1 - n;\n    int i = 0, j = 0;\n    for (; i < seg.size(); i = j+1) {\n        for (int k = 0; k < n; ++k) fa[k] = k, sz[k] = 1;\n        for (j = i; ; ++j) {\n            unionn(seg[j].p, seg[j].q);\n            if (j+1 >= seg.size() || seg[i].dx != seg[j+1].dx || seg[i].dy != seg[j+1].dy) break;\n        }\n        for (int k = 0; k < n; ++k) {\n            if (fa[k] == k) ((ans -= (P[sz[k]] - sz[k] - 1)) += mod) %= mod;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Math = ♥\n// Sometimes it is people that no one imagines anything of who do things that no one can imagine\n// After all this time? Always\n\n#include <bits/stdc++.h>                        // uncomment before submission\n//#include <ext/pb_ds/assoc_container.hpp>\t\t// uncomment before submission\n//#include <ext/pb_ds/tree_policy.hpp>\t\t\t// uncomment before submission\n//using namespace __gnu_pbds;\t\t\t\t\t// uncomment before submission\nusing namespace std;\n//<---------------------------------------------------Template----------------------------------------------------------->\n#define int long long\n#define ll long long\n#define ld long double\nint INF = 1e9 + 7;\ntypedef pair<ll, ll> ii;\ntypedef vector<ll> vi;                  // Vector of long long\ntypedef vector<vi> vvi;                 // Vector of vi\ntypedef vector<ii> vii;                 // Vector of pairs\ntypedef vector<vii> vvii;               // Vector of Vector of pairs\ntypedef vector<bool> vb;                // Vector of bool\n#define pq priority_queue               // Max heap (To convert to min heap, use negative sign before every value)\n#define ff first                        // For pairs\n#define ss second                       // For pairs\n#define pb push_back                    // Pushback to vector\n#define mp make_pair                    // Makes pairs to be stored as pair\n#define all(c) (c).begin(), (c).end()   // Mainly used by me in sorting\n// ordered_set adds two new functions to set - (set).find_by_order([kth element based on zero indexing]) and order_of_key()\n// order_of_key returns number of elements less that parameter. If element exists, that order is its index\n#define ordered_set tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>\n//<----------------------------------------------------------------------------------------------------------------------->\n\nint mod = 998244353;\n\nint pow(int x, int n)\n{\n    int ans = 1;\n    if (n < 0) return 0;\n    while (n != 0)\n    {\n        if (n % 2 == 0)\n            ans = (ans * x) % mod;\n        x = (x * x) % mod;\n        n = n / 2;\n    }\n    return ans;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    ii a[n + 5];\n\n    for (int i = 0; i < n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        a[i].ff = x, a[i].ss = y;\n    }\n\n    int ans;\n    ans = pow(2, n) - 1 - n;\n    ans = ans + mod;\n    ans = ans % mod;\n\n    for (int i = 0; i < n - 1; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            int count = 0;\n            for (int k = j + 1; k < n; ++k)\n            {\n                int x1 = a[i].ff - a[j].ff, y1 = a[j].ff - a[k].ff;\n                int x2 = a[i].ss - a[j].ss, y2 = a[j].ss - a[k].ss;\n\n                if (x1 * y2 == y1 * x2)\n                    count++;\n            }\n            (ans = mod + ans - pow(2, count)) %= mod;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define mod 998244353\n#define MN 205\nusing namespace std;\ninline int in(){\n    int x=0;bool f=0; char c;\n    for (;(c=getchar())<'0'||c>'9';f=c=='-');\n    for (x=c-'0';(c=getchar())>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0');\n    return f?-x:x;\n}\nstruct st{\n\tint x,y;\n}a[MN];\nint pw[MN],n,sum,res;\ninline bool cmp(st a,st b){\n\treturn (a.x==b.x)?a.y<b.y:a.x<b.x; \n}\nint main()\n{\n\tn=in();pw[0]=1;\n\tfor (int i=1;i<=n;++i) pw[i]=(pw[i-1]<<1)%mod; \n\tfor (int i=1;i<=n;++i) a[i].x=in(),a[i].y=in();\n\tsort(a+1,a+n+1,cmp);\n\tfor (int i=1;i<=n;++i)\n\tfor (int j=i+1;j<=n;++j){\n\t\tint cnt=0,tmp;\n\t\tfor (int k=j+1;k<=n;++k)\n\t\tif ((1ll*(a[k].x-a[i].x)*(a[j].y-a[i].y))==(1ll*(a[j].x-a[i].x)*(a[k].y-a[i].y))) ++cnt;\n\t\tres=(res+pw[cnt])%mod;\n\t}\n\tsum=(pw[n]+mod-n-1)%mod;sum=(sum+mod-res)%mod;\n\tprintf(\"%d\",sum);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long LL;\nconst int MAXN = 200 + 10;\nconst int mod = 998244353;\npii points[MAXN];\nint n;\nbool check(int a, int b, int c) {\n    int x1 = points[a].first - points[b].first;\n    int x2 = points[a].first - points[c].first;\n    int y1 = points[a].second - points[b].second;\n    int y2 = points[a].second - points[c].second;\n    return x1*y2==x2*y1;\n}\nLL power(LL base, int n) {\n    LL ret = 1;\n    while (n) {\n        if (n & 1 == 1) {\n            ret *= base;\n            ret %= mod;\n        }\n        base *= base;\n        base %= mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\n\nint main() {\n//    freopen(\"test.txt\", \"r\", stdin);\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d\", &points[i].first, &points[i].second);\n    }\n    LL ret = power(2, n);\n    ret = ret - 1 - n - n*(n-1)/2;\n    if (ret < 0) ret += mod;\n    vector<pii> used;\n    for (int i = 0; i < n; i++) {\n        for(int j = i+1; j < n; j++) {\n            bool flag = true;\n            for (pii item : used) {\n                if (check(item.first, item.second, i) && check(item.first, item.second, j)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) used.push_back({i,j});\n            else continue;\n            int cnt = 2;\n            for (int k = 0; k < n; k++) {\n                if (k == i || k == j) continue;\n                if (check(i,j,k)) cnt++;\n            }\n            LL tmp = power(2, cnt) - 1 - cnt - cnt*(cnt-1)/2;\n            if (tmp < 0) tmp += mod;\n            ret -= tmp;\n            if (ret < 0) ret += mod;\n        }\n    }\n    ret = ret % mod;\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef double lld;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<double> vdl;\ntypedef vector<vector<lli>> mat;\ntypedef vector<vdl> mad;\ntypedef unordered_map<lli,unordered_map<lli,lli>> graph;\ntypedef complex<double> cmp;\ntypedef vector<cmp> vcl;\n\nconst lli mod = 998244353;\n\nlli n;\nvector<vdl> p;\nmat c;\nmat bl;\nvll m;\nlli ans = 0;\n\nlld deg(vdl a,vdl from){\n  return fmod(atan2(a[1]-from[1],a[0]-from[0])+2*M_PI,2*M_PI);\n}\n\nlld deg(vdl a,vdl b,vdl from){\n  return fmod(deg(b,from)-deg(a,from)+2*M_PI,2*M_PI);\n}\n\nlld abs(vdl to,vdl from){\n  lld x = to[0]-from[0];\n  lld y = to[1]-from[1];\n  return sqrt(x*x+y*y);\n}\n\nlld dot(vdl a,vdl b,vdl from){\n  lld x1 = a[0]-from[0];\n  lld y1 = a[1]-from[1];\n  lld x2 = b[0]-from[0];\n  lld y2 = b[1]-from[1];\n  return x1*x2+y1*y2;\n}\n\nlli pow(lli x,lli r,lli mod = 998244353){\n  lli ret = 1;\n  for(;r != 0;r >>= 1){\n    if(r&1 != 0) ret *= x,ret %= mod;\n    x *= x,x %= mod;\n  }\n  return ret;\n}\n\nbool check(lli i,lli j,lli k){\n  // lld d = deg(p[i],p[k],p[j]);\n  // if((d == M_PI || d == 0.0) != (abs((abs(p[i],p[k])*abs(p[j],p[k]) - abs(dot(p[i],p[j],p[k])))) < 0.0000000000001)){\n  //   cout << \"error\" << endl;\n  //   cout << \"deg=\" << (d == M_PI || d == 0.0) << endl;\n  //   cout << \"dot=\" << (abs((abs(p[i],p[k])*abs(p[j],p[k]) - abs(dot(p[i],p[j],p[k])))) < 0.0000000000001) << endl;\n  //   cout << abs(p[i],p[k])*abs(p[j],p[k]) << endl;\n  //   cout << abs(dot(p[i],p[j],p[k])) << endl;\n  //   cout << p[i][0] << \" \" << p[i][1] << endl;\n  //   cout << p[j][0] << \" \" << p[j][1] << endl;\n  //   cout << p[k][0] << \" \" << p[k][1] << endl;\n  //   cout << \"--\" << endl;\n  // }\n  return (abs((abs(p[i],p[k])*abs(p[j],p[k]) - abs(dot(p[i],p[j],p[k])))) < 0.0000000000001);\n}\n\nint main(){\n  cin >> n;\n  p = vector<vdl>(n,vdl(2));\n  for(lli i = 0;i < n;i++) cin >> p[i][0] >> p[i][1];\n  bl = mat(n,vll(n));\n  for(lli i = 0;i < n;i++) bl[i][i] = 1;\n  for(lli i = 0;i < n;i++){\n    for(lli j = 0;j < n;j++){\n      if(bl[i][j] == 0){\n        set<lli> s;\n        bl[i][j] = 1;\n        bl[j][i] = 1;\n        s.insert(i);\n        s.insert(j);\n        for(lli k = 0;k < n;k++){\n          if(i == k || j == k) continue;\n          if(check(i,j,k)){\n            for(lli x : s){\n              bl[x][k] = bl[k][x] = 1;\n            }\n            s.insert(k);\n          }\n        }\n        // cout << i << \" \" << j << \" \" << s.size() << endl;\n        ans += pow(2ll,s.size())-1-s.size();\n      }\n\n    }\n  }\n  // for(lli i = 0;i < n;i++){\n  //   for(lli j = 0;j < n;j++){\n  //     cout << bl[i][j];\n  //   }\n  //   cout << endl;\n  // }\n  ans += 1ll;\n  ans += n;\n  cout << ((pow(2ll,n)-ans+mod)%mod) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NDEBUG\n#ifdef DEBUG\n#include \"../cout11.h\"\n#undef NDEBUG\n#endif\n#include <cassert>\n\ntypedef long long ll;\ntypedef long double Double;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> llll;\ntypedef pair<double,double> dd;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ii> vii;\ntypedef vector<vector<ii>> vvii;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<long double> vD;\n\n#define sz(a)  int((a).size())\n#define pb  push_back\n#define FOR(var,from,to) for(int var=(from);var<=(to);++var)\n#define rep(var,n)  for(int var=0;var<(n);++var)\n#define rep1(var,n)  for(int var=1;var<=(n);++var)\n#define repC2(vari,varj,n)  for(int vari=0;vari<(n)-1;++vari)for(int varj=vari+1;varj<(n);++varj)\n#define ALL(c)  (c).begin(),(c).end()\n#define RALL(c)  (c).rbegin(),(c).rend()\n#define tr(i,c)  for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define found(s,e)  ((s).find(e)!=(s).end())\n#define mset(arr,val)  memset(arr,val,sizeof(arr))\n#define mid(x,y) ((x)+((y)-(x))/2)\n#define IN(x,a,b) ((a)<=(x)&&(x)<=(b))\n#define cons make_pair\n\n\nll gcd(ll a, ll b) { while(a) swap(a, b%=a); return b; }\n\nconst ll MOD=998244353LL;\n\nll ADD(ll x, ll y) { return (x+y) % MOD; }\nll SUB(ll x, ll y) { return (x-y+MOD) % MOD; }\nll MUL(ll x, ll y) { return x*y % MOD; }\nll POW(ll x, ll e) { ll v=1; for(; e; x=MUL(x,x), e>>=1) if (e&1) v = MUL(v,x); return v; }\nll DIV(ll x, ll y) { /*assert(y%MOD!=0);*/ return MUL(x, POW(y, MOD-2)); }\n// ll comb(ll n, ll k) { ll v=1; for(ll i=1; i<=k; i++) v = DIV(MUL(v, n-i+1),i); return v; }\n//\n\ntypedef tuple<double,double,double> LINE;\n\nvoid render_fnum(FILE* fp, double x) {\n    if (x == 1) return;\n    fprintf(fp, \"%g\", x);\n}\nvoid render_line(FILE* fp, LINE& line) {\n    double a,b,c; tie(a,b,c) = line;\n    if (a != 0){\n        render_fnum(fp, a);\n        fprintf(fp, \"x\");\n    }\n\n    if (b != 0) {\n        if (b > 0) {\n            if (a != 0)\n                fprintf(fp, \" + \");\n            render_fnum(fp, b);\n        } else if (b < 0) {\n            fprintf(fp, \" - \");\n            render_fnum(fp, -b);\n        }\n        fprintf(fp, \"y\");\n    }\n\n    if (c != 0) {\n        if (c > 0) {\n            fprintf(fp, \" + %g\", c);\n        } else if (c < 0) {\n            fprintf(fp, \" - %g\", -c);\n        }\n    }\n\n    fprintf(fp, \" = 0\");\n}\n\nLINE get_line(ii& p0, ii& p1){\n    int x0 = p0.first, y0 = p0.second,\n        x1 = p1.first, y1 = p1.second;\n    int dx = x1 - x0, dy = y1 - y0;\n\n    assert(dx != 0 || dy != 0);\n\n    double a, b, c;\n\n    if (dx == 0) {\n        // 1x [+ 0y] - some = 0\n        // some = x\n        // double some = (double)x0;\n        a = 1.0;\n        b = 0.0;\n        c = (double)(-x0); // -some;\n    } else if (dy == 0) {\n        // [0x +] 1y - some = 0\n        // some = y\n        // double some = (double)y0;\n        a = 0.0;\n        b = 1.0;\n        c = (double)(-y0); // -some;\n    } else {\n        // m = dy/dx\n        // y = mx + b\n        // mx - y + b = 0\n        int g = gcd(dx, dy);\n        dx /= g; dy /= g;\n\n        double _m = (double)dx / dy;\n        assert(_m != 0.0);\n        // x - _my - some = 0\n        // double some = (double)x0 - _m * y0;\n        a = 1.0;\n        b = -_m;\n        c = (double)(_m * y0 - x0); // -some;\n    }\n\n    // fprintf(stderr, \"(a,b,c)=(%g,%g,%g)\\n\", a,b,c);\n\n    double z0 = a * x0 + b * y0 + c;\n    double z1 = a * x1 + b * y1 + c;\n#ifdef DEBUG\n    // fprintf(stderr, \"%g * %d + %g * %d + %g = %g\\n\", a,x0, b,y0, c, z0);\n    // fprintf(stderr, \"%g * %d + %g * %d + %g = %g\\n\", a,x1, b,y1, c, z1);\n#endif\n    assert(fabs(z0) < 1e-7);\n    assert(fabs(z1) < 1e-7);\n\n    return LINE(a, b, c);\n}\n\n\nll f(int n){\n    // return (1 << n) - n - 1;\n    return SUB(POW(2, n), ADD(n,1));\n}\n\nll solve(int N, vii& p){\n    map<LINE, set<int>> by_line;\n\n    repC2(i,j,N){\n#ifdef DEBUG\n        // cerr << \"---\" << endl;\n        // fprintf(stderr, \"[%d %d] \", i, j);\n        // cerr << p[i] << \" \" << p[j] << \" : \";\n#endif\n        LINE line = get_line(p[i], p[j]);\n#ifdef DEBUG\n        // render_line(stderr, line);\n        // cerr << endl;\n#endif\n        by_line[line].insert(i);\n        by_line[line].insert(j);\n    }\n\n    ll ans = f(N); // (1 << N) - (N+1);\n    for(auto p: by_line){\n        LINE line = p.first;\n        set<int> s = p.second;\n        int k = p.second.size();\n#ifdef DEBUG\n        render_line(stderr, line);\n        cerr << \" : \" << s << endl;\n#endif\n        ans = SUB(ans, f(k)); // (1 << k) - (k+1));\n    }\n    return ans;\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    vector<ii> p(N);\n    rep(i,N){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        p[i] = ii(x, y);\n    }\n\n    cout << solve(N,p) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nbool online(int x1, int y1, int x2, int y2, int x3, int y3){\n    return (y2-y1)*(x3-x1) == (y3-y1)*(x2-x1);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<int> X(N), Y(N);\n    for(int i=0; i<N; i++) cin >> X[i] >> Y[i];\n\n    int64_t ans = power_mod(2, N);\n    add(ans, MOD - 1 - N);\n\n    for(int i=0; i<N; i++) for(int j=i+1; j<N; j++){\n        bool bef = false;\n        for(int k=0; k<j; k++) if(k!=i && online(X[i], Y[i], X[j], Y[j], X[k], Y[k])) bef = true;\n        if(bef) continue;\n        int num = 2;\n        for(int k=j+1; k<N; k++) num += online(X[i], Y[i], X[j], Y[j], X[k], Y[k]);\n        int64_t res = power_mod(2, num) - 1 - num;\n        add(ans, MOD - res);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nconst int mod = 998244353;\nint n, x[209], y[209], pw[209]; bool vis[209][209];\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tpw[0] = 1;\n\tfor (int i = 0; i < n; i++) pw[i + 1] = pw[i] * 2 % mod;\n\tint ret = (pw[n] - n - 1 + mod) % mod;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (!vis[i][j]) {\n\t\t\t\tvector<int> v;\n\t\t\t\tint dx = x[j] - x[i], dy = y[j] - y[i];\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tint ex = x[k] - x[i], ey = y[k] - y[i];\n\t\t\t\t\tif (dx * ey == ex * dy) v.push_back(k);\n\t\t\t\t}\n\t\t\t\tret = (ret - (pw[v.size()] - v.size() - 1 + mod) % mod + mod) % mod;\n\t\t\t\tfor (int k : v) {\n\t\t\t\t\tfor (int l : v) {\n\t\t\t\t\t\tvis[k][l] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Crt. 2020-01-07  0946\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define PII pair<int, int>\n#define mk make_pair\n#define N 204\nusing namespace std;\nconst int Mod = 998244353;\n\ninline int fsp(int x, int p = Mod - 2) {\n    int res = 1;\n    while (p) {\n        if (p & 1) res = 1ll * res * x % Mod;\n        x = 1ll * x * x % Mod, p >>= 1;\n    } return res;\n}\n\ninline int getp(int x) {\n    return x < 0 ? -1 : 1;\n}\n\ninline int Abs(int x) {\n    return x < 0 ? -x : x;\n}\n\ninline int gcd(int x, int y) {\n    while (y ^= x ^= y ^= x %= y);\n    return x;\n}\n\nint n, x[N], y[N], m, z[N];\nPII k[N * N];\n\nint main(){\n#ifdef LOCAL_JUDGE\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i)\n        scanf(\"%d%d\", x + i, y + i);\n\n    for (int i = 1; i <= n; ++i)\n        z[i] = 1ll * i * (i - 1) / 2;\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n; ++j) {\n            int a = y[j] - y[i], b = x[j] - x[i];\n            //cout << i << \" \" << j << \" \" << a << \" \" << b << endl;\n            if (!a) { k[++m] = mk(-100000, y[i]); continue; }\n            if (!b) { k[++m] = mk(x[i], -100000); continue; } \n            int pa = getp(a), pb = getp(b);\n            if (pa < 0) pa = -pa, pb = -pb;\n            a = Abs(a), b = Abs(b);\n            int g = gcd(a, b);\n            a /= g, b /= g;\n            a *= pa, b = pb;\n            k[++m] = mk(a, b);\n        }\n\n    sort(k + 1, k + m + 1);\n\n    long long ans = fsp(2, n) - 1 - n;\n\n//    for (int i = 1; i <= m; ++i)\n//        cout << k[i].first << \" \" << k[i].second << endl;\n\n    for (int i = 1, j; i <= m; i = j + 1) {\n        for (j = i; j < m && k[j + 1] == k[i]; ++j);\n        int pos = lower_bound(z + 1, z + n + 1, j - i + 1) - z;\n        if (z[pos] != j - i + 1) return 2;\n        ans -= fsp(2, pos) - 1 - pos, ans %= Mod;\n    }\n        \n    if (ans < 0) ans += Mod;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=205,mod=998244353;\nint n,x[N],y[N],Pow[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tPow[0]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]),Pow[i]=Pow[i-1]*2%mod;\n\tint ans=(Pow[n]-n-1+mod)%mod;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tint cnt=0;\n\t\t\tfor (int k=j+1;k<=n;k++)\n\t\t\t\tif ((x[i]-x[k])*(y[j]-y[k])==(x[j]-x[k])*(y[i]-y[k]))\n\t\t\t\t\tcnt++;\n\t\t\tans=(ans-Pow[cnt]+mod)%mod;\n\t\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-12;\ntypedef complex<double> P;\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<pair<int,int> >se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\tif(se.find({i,j})!=se.end())continue;\n\t\tL l(v[i],v[j]);\n\t\tvector<int>x={i,j};\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&abs(imag(conj(v[j]-v[k])*(v[i]-v[k]))) < EPS)x.push_back(k);\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\tint n=b-a-1;\n\t\t\tr=(r-pow_binary_mod(2,n,M))%M;\n\t\t\tse.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lld long long int\n#define ld long double\n#define mod 1000000007\n#define modd 998244353\n#define all(v) v.begin(),v.end()\n#define rep(i,a,b)\tfor(lld i=a;i<=b;i++)\n#define repr(i,a,b) for(lld i=a;i>=b;i--)\n#define ar array\n#define pb push_back\n#define mp make_pair\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nlld n,m;\nar<lld,2> arr[300000];\nmap<ar<lld,3>, lld> ma;\nlld fastpower(lld x, unsigned lld y, lld p)\n{\n    lld res = 1;\n    x = x % p;\n    while (y > 0)\n    {\n        if (y & 1)\n            res = (res*x) % p;\n        y = y>>1;\n        x = (x*x) % p;\n    }\n    return res;\n}\nint main()\n{\n     ios;\n     lld TESTS,q,a,s,b,l,r,c,k,p,h,w,d,x,y,z,xs,ys,t;\n     TESTS=1;\n     //cin>>TESTS;\n     while(TESTS--)\n     {\n         cin>>n;\n         rep(i,0,n-1)cin>>arr[i][0]>>arr[i][1];\n         lld cou=0;\n         rep(i,0,n-1) rep(j,i+1,n-1){\n            x=arr[i][0]-arr[j][0];\n            y=arr[i][1]-arr[j][1];\n            z=arr[i][1]*x-arr[i][0]*y;\n            lld g=__gcd(abs(x),abs(y));\n            g=__gcd(g,abs(z));\n            x/=g;y/=g;z/=g;\n            if (ma[{x,y,z}]) continue;\n            ma[{x,y,z}]=1;\n            ma[{-x,-y,-z}]=1;\n            lld now=2;\n            rep(k,0,n-1){\n                if(k==i||k==j)continue;\n                xs=arr[k][0]-arr[i][0];\n                ys=arr[k][1]-arr[i][1];\n                if (xs*y==ys*x)now++;\n            }\n            cou+=fastpower(2,now,modd);\n            cou%=modd;\n            cou+=modd-1;\n            cou%=modd;\n            cou+=modd-now;\n            cou%=modd;\n         }\n      //   cout<<cou<<\"\\n\";\n      lld ans=fastpower(2,n,modd);\n      ans+=modd-1;\n      ans%=modd;\n      ans+=modd-cou;\n      ans%=modd;\n      ans+=modd-n;\n      ans%=modd;\n         cout<<ans;\n     }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <climits>\nusing namespace std;\n#define MOD 998244353\n\nlong long powmod(int n){\n    long long ret = 1;\n    for(int i=0; i<n; i++){\n        ret *= 2;\n        ret %= MOD;\n    }\n    return ret;\n}\n\nbool isColinear(pair<int, int> xy1, pair<int, int> xy2, pair<int, int> xy3){\n    return (xy1.first-xy2.first)*(xy3.second-xy1.second)==(xy3.first-xy1.first)*(xy1.second-xy2.second);\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    vector<pair<int, int>> xy(N);\n    for(int i=0; i<N; i++) cin >> xy[i].first >> xy[i].second;\n\n    long long mns = 1 + N + N*(N-1)/2;\n    for(int i=0; i<N; i++){\n        for(int j=i+1; j<N; j++){\n            int cnt = 2;\n            for(int k=0; k<N; k++){\n                if(k == i || k == j) continue;\n                if(!isColinear(xy[i], xy[j], xy[k])) continue;\n                if(k < j) break;\n                cnt++;\n            }\n            if(cnt >= 3){\n                mns += powmod(cnt);\n                mns %= MOD;\n                mns += MOD - (1 + cnt + cnt*(cnt-1)/2);\n                mns %= MOD;\n            }\n        }\n    }\n    long long ans = powmod(N);\n    ans += MOD - mns;\n    ans %= MOD;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct pt {\n  ll x, y;\n};\n\npt operator-(const pt &a, const pt &b) {\n  return pt {a.x - b.x, a.y - b.y};\n}\n\nll powers2[201];\n\nll cross(pt a, pt b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nbool collinear(pt a, pt b, pt c) {\n  return !cross(b - a, c - a);\n}\n\nint main() {\n  powers2[0] = 1;\n  for (int i = 1; i <= 200; i++) powers2[i] = (powers2[i - 1] * 2LL) % MOD;\n\n  int n;\n  scanf(\"%d\", &n);\n  vector<pt> points(n);\n  for (int i = 0; i < n; i++) scanf(\"%lld %lld\", &points[i].x, &points[i].y);\n  \n  ll res = powers2[n];\n  res -= 1 + n + n * (n - 1) / 2;\n  res %= MOD;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int counter = 2;\n      for (int k = 0; k < n; k++) {\n        if (k == i || k == j) continue;\n        if (k < j) break;\n        if (collinear(points[i], points[j], points[k])) {\n          counter++;\n        }\n      }\n      res -= powers2[counter];\n      res += 1 + counter + counter * (counter - 1) / 2;\n      res %= MOD;\n    }\n  }\n  printf(\"%lld\\n\", (res % MOD + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define met(a) memset(a,0,sizeof(a))\nusing namespace std;\nconst int mod=998244353;\nconst int N=1e6+10;\nint x[300],y[300],a[300];\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int i,j,k,m,n,l,r;\n    ll ans=0,sum=0,cnt=0;\n    cin>>n;\n    for(i=0;i<n;i++)\n        cin>>x[i]>>y[i];\n    a[0]=1;\n    for(i=1;i<=n;i++)\n        a[i]=(a[i-1]*2)%mod;\n    ans=a[n]-1-n-n*(n-1)/2;\n    for(i=0;i<n;++i)\n    {\n        for(j=i+1;j<n;++j)\n        {\n            cnt=0;\n            for(k=j+1;k<n;++k)\n                if ((x[j]-x[i])*(y[k]-y[j])==(x[k]-x[j])*(y[j]-y[i]))\n                    cnt++;\n        }\n        ans=(ans-a[cnt]+1+mod)%mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 210;\nconst int mod = 998244353;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nint n, xs[MAXN], ys[MAXN], vis[MAXN][MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) std::cin >> xs[i] >> ys[i];\n\tint ans = pow(2, n);\n\treduce(ans -= n + 1), reduce(ans -= n * (n - 1) / 2);\n\tstatic int li[MAXN];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tif (!vis[i][j]) {\n\t\t\t\tint bak = 0;\n\t\t\t\tfor (int k = 1; k <= n; ++k)\n\t\t\t\t\tif ((xs[k] - xs[i]) * (ys[k] - ys[j]) == (xs[k] - xs[j]) * (ys[k] - ys[i]))\n\t\t\t\t\t\tli[++bak] = k;\n\t\t\t\tfor (int k = 1; k <= n; ++k)\n\t\t\t\t\tfor (int l = 1; l <= n; ++l)\n\t\t\t\t\t\tvis[li[k]][li[l]] = true;\n\t\t\t\tint t = pow(2, bak);\n\t\t\t\treduce(t -= bak + 1); reduce(t -= bak * (bak - 1) / 2);\n\t\t\t\treduce(ans -= t);\n\t\t\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nclass P2 {\npublic:\n\texplicit P2(int x = 0, int y = 0) : x(x), y(y) {}\n\tint x, y;\n};\n\nint cross(const P2& a, const P2& b, const P2& c){\n\tint dx1 = b.x - a.x;\n\tint dy1 = b.y - a.y;\n\tint dx2 = c.x - a.x;\n\tint dy2 = c.y - a.y;\n\treturn dx1 * dy2 - dx2 * dy1;\n}\n\nint main(){\n\tvector<int> pow2(300);\n\tpow2[0] = 1;\n\tfor(int i=1;i<pow2.size();i++) pow2[i] = 2 * pow2[i-1] % MOD;\n\tint N;\n\twhile(cin >> N){\n\t\tvector<P2> vp(N);\n\t\tfor(auto& p : vp) cin >> p.x >> p.y;\n\t\tint res = pow2[N];\n\t\tres = (res + MOD - (1+N)) % MOD;\n\t\tvector<vector<int>> checked(N, vector<int>(N, 0));\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\tif(checked[i][j]) continue;\n\t\t\t\tvector<int> idx;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(!cross(vp[i], vp[j], vp[k])) idx.push_back(k);\n\t\t\t\t}\n\t\t\t\tint sub = pow2[idx.size()] - idx.size() - 1;\n\t\t\t\tres = (res + MOD - sub) % MOD;\n\t\t\t\tfor(int k=0;k<idx.size();k++){\n\t\t\t\t\tfor(int l=k+1;l<idx.size();l++){\n\t\t\t\t\t\tchecked[idx[k]][idx[l]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(a, b, c) for(int a = (b); a <= (c); ++ a)\n#define per(a, b, c) for(int a = (b); a >= (c); -- a)\nusing namespace std;\ntemplate <class T> void rd(T &x){\n  x = 0; int f = 1; char ch = getchar();\n  while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }\n  while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();\n  x *= f;\n}\n\nconst int mod = 998244353;\nconst int maxn = 205;\nint n;\nint x[maxn], y[maxn], pw[maxn];\nint ans;\n\nint main(){\n  rd(n);\n  pw[0] = 1;\n  rep(i, 1, n) rd(x[i]), rd(y[i]), pw[i] = pw[i - 1] * 2 % mod;\n  int ans = pw[n] - n - 1;\n  rep(i, 1, n){\n\trep(j, i + 1, n){\n\t  int cnt = 0;\n\t  rep(k, j + 1, n){\n\t\tif((y[i] - y[k]) * (x[j] - x[k]) == (y[j] - y[k]) * (x[i] - x[k]))\n\t\t  cnt ++;\n\t  }\n\t  ans = (ans + mod - pw[cnt]) % mod;\n\t}\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int Q = 998244353;\nconst int N = 209;\nll x[N], y[N], p[N], f[N], size[N];\ninline int read() {\n    int s = 1, a = 0; char ch = getchar();\n    while (ch < '0' || ch > '9') {if (ch == '-') s = -1; ch = getchar();}\n    while (ch >= '0' && ch <= '9') {a = a * 10 + ch - '0'; ch = getchar();}\n    return s * a;\n}\ninline int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\ninline int findSet(int x) {\n    return f[x] == x ? x : f[x] = findSet(f[x]);\n}\ninline void unionSet(int x, int y) {\n    int fx = findSet(x), fy = findSet(y);\n    if (fx != fy) {\n        f[fy] = fx;\n        size[fx] += size[fy];\n    }\n}\nstruct Seg {\n    int p, q; ll hash;\n    bool operator < (const Seg &rhs) const {\n        return hash < rhs.hash;\n    }\n};\nvector<Seg> seg;\nint main() {\n    p[0] = 1;\n    for (int i = 1; i < N; i++) {\n        p[i] = p[i - 1] << 1, p[i] %= Q;\n    }\n    int n = read();\n    for (int i = 1; i <= n; i++) {\n        x[i] = read(), y[i] = read();\n    }\n    ll res = (p[n] - n - 1) % Q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            int dx = x[i] - x[j], dy = y[i] - y[j], g = gcd(dx, dy);\n            dx /= g, dy /= g;\n            if (dx == 0) dy = 1;\n            if (dy == 0) dx = 1;\n            if (dx < 0) dx *= -1, dy *= -1;\n            Seg s; s.p = i, s.q = j, s.hash = dx * 100000 + dy;\n            seg.push_back(s);\n        }\n    }\n    sort(seg.begin(), seg.end());\n    for (int i = 0, j = 0; i < seg.size(); i = j) {\n        for (int k = 1; k <= n; k++) {\n            f[k] = k, size[k] = 1;\n        }\n        for (; j < seg.size() && seg[i].hash == seg[j].hash; j++) {\n            unionSet(seg[j].p, seg[j].q);\n        }\n        for (int k = 1; k <= n; k++) {\n            if (f[k] == k && size[k] >= 2) {\n                res -= (p[ size[k] ] - size[k] - 1), res += Q, res %= Q;\n            }\n        }\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\n#define mod 998244353\nint n,x[205],y[205];\n\nint qpow(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1)ans=1LL*ans*x%mod;\n\t\ty>>=1,x=1LL*x*x%mod;\n\t}\n\treturn ans;\n}\n\nbool check(int i,int j,int k){\n\tint a=1LL*(y[j]-y[i])*(x[k]-x[j])%mod;\n\tint b=1LL*(y[k]-y[j])*(x[j]-x[i])%mod;\n\treturn a==b;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",x+i,y+i);\n\tint ans=((qpow(2,n)-(1LL*n*(n-1)>>1)%mod-n-1)%mod+mod)%mod;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint sum=0;\n\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\tif(k==i||k==j)continue;\n\t\t\t\tif(check(i,j,k))sum++;\n\t\t\t}\n\t\t\tans=(ans-qpow(2,sum)+1+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\t\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint main()\n{\n  int fact[501];\n  fact[0] = 1;\n  for(int i = 1; i < 501; i++) (fact[i] = fact[i - 1] * 2) %= mod;\n\n  int N, X[500], Y[500];\n  cin >> N;\n  for(int i = 0; i < N; i++) cin >> X[i] >> Y[i];\n\n  int ret = fact[N];\n\n  for(int i = 0; i < N; i++) {\n    for(int j = i + 1; j < N; j++) {\n      int sum = 0;\n      for(int k = j + 1; k < N; k++) {\n        sum += (X[j] - X[i]) * (Y[k] - Y[i]) == (X[k] - X[i]) * (Y[j] - Y[i]);\n      }\n      (ret += mod - fact[sum]) %= mod;\n    }\n  }\n\n  (ret += mod - 1) %= mod;\n  (ret += mod - N) %= mod;\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nconst int Mod=998244353;\ninline char tc(void){\n\tstatic char fl[10000],*A=fl,*B=fl;\n\treturn A==B&&(B=(A=fl)+fread(fl,1,10000,stdin),A==B)?EOF:*A++;\n}\ninline int read(void){\n\tint a=0;static char c;\n\twhile((c=tc())<'0'||c>'9');\n\twhile(c>='0'&&c<='9')a=a*10+c-'0',c=tc();\n\treturn a;\n}\nint n,x[201],y[201],o[201],cnt;\nll ans;\nint main(void){\n\tregister int i,j,k;\n\tn=read();\n\to[0]=1;\n\tfor(i=1;i<=n;++i)\n\t\tx[i]=read(),y[i]=read(),(o[i]=o[i-1]<<1)%=Mod;\n\tans=((o[n]-1-n-(n*(n-1)>>1))%Mod+Mod)%Mod;\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=i+1;j<=n;++j){\n\t\t\tcnt=0;\n\t\t\tfor(k=j+1;k<=n;++k)\n\t\t\t\tif((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))++cnt;\n\t\t\tans=(ans-o[cnt]+1+Mod)%Mod;\n\t\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=205;\nconst int MOD=998244353;\nint x[MAXN],y[MAXN];\n\nLL Q_pow(LL x,LL n)\n{\n    LL res=1;\n    while(n>0)\n    {\n        if(n&1) res=res*x%MOD;\n        x=x*x%MOD;\n        n>>=1;\n    }\n    return res;\n}\n\nint main()\n{\n    int n;\n    while(scanf(\"%lld\",&n)!=EOF)\n    {\n        for(int i=1;i<=n;i++)\n            scanf(\"%d%d\",&x[i],&y[i]);\n        LL ans=Q_pow(2,n);\n        ans=(ans-1+MOD)%MOD;//空集\n        ans=(ans-n+MOD)%MOD;//单元素\n        ans=(ans-n*(n-1)/2+MOD)%MOD;//双元素\n        int A,B,C;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=i+1;j<=n;j++)\n            {\n                A=y[j]-y[i];\n                B=x[i]-x[j];\n                C=-A*x[i]-B*y[i];\n                LL cnt=2;//i j\n                for(int k=1;k<=n;k++)\n                {\n                    if(k==i||k==j) continue;\n                    if(A*x[k]+B*y[k]+C!=0) continue;\n                    if(k<j) break;\n                    cnt++;\n                }\n                ans=(ans-Q_pow(2,cnt)+MOD)%MOD;\n                ans=(ans+1)%MOD;\n                ans=(ans+cnt)%MOD;\n                ans=(ans+cnt*(cnt-1)/2)%MOD;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 210;\nconst int mod = 998244353;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nint n, xs[MAXN], ys[MAXN], vis[MAXN][MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) std::cin >> xs[i] >> ys[i];\n\tint ans = pow(2, n);\n\treduce(ans -= n + 1), reduce(ans -= n * (n - 1) / 2);\n\tstatic int li[MAXN];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tif (!vis[i][j]) {\n\t\t\t\tint bak = 0;\n\t\t\t\tfor (int k = 1; k <= n; ++k)\n\t\t\t\t\tif ((xs[k] - xs[i]) * (ys[k] - ys[j]) == (xs[k] - xs[j]) * (ys[k] - ys[i]))\n\t\t\t\t\t\tli[++bak] = k;\n\t\t\t\tfor (int k = 1; k <= n; ++k)\n\t\t\t\t\tfor (int l = k + 1; l <= n; ++l)\n\t\t\t\t\t\tvis[li[k]][li[l]] = true;\n\t\t\t\tint t = pow(2, bak);\n\t\t\t\treduce(t -= bak + 1); reduce(t -= bak * (bak - 1) / 2);\n\t\t\t\treduce(ans -= t);\n\t\t\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS = 1e-10;\nconst bool debug = 0;\n//------------------------------//\n\nll mod = 998244353;\nint N;\nvector<pii> p;\nint cnt[11234];\n\nll mod_pow(ll x, ll n, ll mod) {\n\tif (n == 0) return 1;\n\tll res = mod_pow(x * x % mod, n / 2, mod);\n\tif (n & 1) res = res * x % mod;\n\treturn res;\n}\n\nint calcn(int x) { // a*(a-1)/2 = xを満たすxを求める\n\tint l = 1, r = INF;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) / 2;\n\t\tif ((ll)m * (m - 1) / 2 <= x) l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\n\nint main() {\n\tcin >> N;\n\tp.resize(N);\n\tREP(i, N) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tp[i] = pii(a, b);\n\t}\n\tsort(ALL(p));\n\t\n\tll ans = (mod_pow(2, N, mod) - 1 - N + mod) % mod;\n\t\n\tREP(i, N) cnt[p[i].fi]++;\n\tREP(i, 11234) { // x=iの線分\n\t\tll now = (mod_pow(2, cnt[i], mod) - 1 - cnt[i] + mod) % mod;\n\t\tans = (ans - now + mod) % mod;\n\t}\n\t\n\tmap<pll, int> m; // (傾き, x=0でのy)*1e8\n\tREP(i, N) {\n\t\tREP(j, i) {\n\t\t\tif (p[i].fi == p[j].fi) continue;\n\t\t\tlong double a = (long double)(p[i].se - p[j].se) / (p[i].fi - p[j].fi);\n\t\t\tlong double b = p[i].se - a * p[i].fi;\n\t\t\tm[make_pair((ll)round(a * 1e8), (ll)round(b * 1e8))]++;\n\t\t}\n\t}\n\t\n\tfor (map<pll, int>::iterator it = m.begin(); it != m.end(); ++it) {\n\t\tint c = calcn(it->se);\n\t\tll now = (mod_pow(2, c, mod) - 1 - c + mod) % mod;\n\t\tans = (ans - now + mod) % mod;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define SORT(c) sort((c).begin(), (c).end())\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> V;\ntypedef map<int, int> M;\n\nconstexpr ll INF = 1e18;\nconstexpr ll MOD = 998244353;\nconstexpr double PI = 3.14159265358979323846;\nconstexpr int di[] = {0, 0, 1, -1};\nconstexpr int dj[] = {1, -1, 0, 0};\n\nll fastPow(ll x, ll n)\n{\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return fastPow(x * x % MOD, n / 2);\n    else\n        return x * fastPow(x, n - 1) % MOD;\n}\n\nll fac[112346];\nvoid combInit(int mx)\n{\n    fac[0] = 0;\n    fac[1] = 1;\n    for (int i = 2; i <= mx; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n}\n\nll modDiv(ll a, ll b)\n{\n    return a * fastPow(b, MOD - 2) % MOD;\n}\n\nll comb(ll a, ll b)\n{\n    if (b == 0)\n        return 1;\n    if (a < b)\n        return 0;\n    if (a <= 0 || b < 0)\n        return 0;\n    if (a == b)\n        return 1;\n\n    ll p, c;\n\n    c = modDiv(fac[a], fac[a - b]);\n    p = fac[b];\n\n    ll res = modDiv(c, p);\n\n    return res;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    combInit(210);\n\n    int n, x[210], y[210];\n\n    cin >> n;\n    REP(i, n)\n    cin >> x[i] >> y[i];\n\n    ll res = 0;\n\n    V l;\n\n    map<P, bool> mp;\n\n    for (int i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++)\n        {\n            if (mp[{i, j}])\n                continue;\n\n            int cnt = 2;\n\n            int pre = j;\n\n            for (int k = j + 1; k < n; k++)\n            {\n                if (mp[{pre, k}])\n                {\n                    cnt = 0;\n                    break;\n                }\n\n                int a = (x[j] - x[i]) * (y[k] - y[j]);\n                int b = (y[j] - y[i]) * (x[k] - x[j]);\n\n                if (a == b)\n                {\n                    cnt++;\n                    mp[{pre, k}] = true;\n                }\n\n                pre = k;\n            }\n\n            if (cnt > 2)\n                l.push_back(cnt);\n        }\n\n    for (int i = 3; i <= n; i++)\n    {\n        ll tmp = 0;\n        tmp += comb(n, i);\n\n        for (int j : l)\n        {\n            if (i > j)\n                continue;\n\n            tmp += MOD - comb(j, i);\n\n            tmp %= MOD;\n        }\n\n        res += tmp;\n        res %= MOD;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct pt {\n  ll x, y;\n};\n\npt operator-(const pt &a, const pt &b) {\n  return pt {a.x - b.x, a.y - b.y};\n}\n\nll powers2[201];\n\nll cross(pt a, pt b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nbool collinear(pt a, pt b, pt c) {\n  return !cross(b - a, c - a);\n}\n\nint main() {\n  powers2[0] = 1;\n  for (int i = 1; i <= 200; i++) powers2[i] = (powers2[i - 1] * 2LL) % MOD;\n\n  int n;\n  scanf(\"%d\", &n);\n  vector<pt> points(n);\n  for (int i = 0; i < n; i++) scanf(\"%lld %lld\", &points[i].x, &points[i].y);\n  \n  ll res = powers2[n];\n  res -= 1 + n + n * (n - 1) / 2;\n  res %= MOD;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int counter = 2;\n      int a = points[j].y - points[i].y;\n      int b = points[i].x - points[j].x;\n      int c = -a * points[i].x - b * points[i].y;\n      for (int k = 0; k < n; k++) {\n        if (k == i || k == j) continue;\n        if (k < j) break;\n        if (a * points[k].x + b * points[k].y + c == 0) counter++;\n      }\n      res -= powers2[counter];\n      res += 1 + counter + counter * (counter - 1) / 2;\n      res %= MOD;\n    }\n  }\n  printf(\"%lld\\n\", (res % MOD + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 210, mod = 998244353;\nint n;\nint x[N], y[N];\nll ans;\nll p[N];\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d%d\", &x[i], &y[i]);\n\tp[0] = 1;\n\tfor(int i = 1; i <= n; ++i) p[i] = (p[i - 1] << 1) % mod;\n\tans = p[n] - n * (n - 1) / 2 - n - 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tfor(int k = j + 1; k <= n; ++k) if((y[k] - y[i]) * (x[k] - x[j]) == (y[k] - y[i]) * (x[k] - x[i]))\n\t\t\tans = ((ans - p[cnt] + 1) % mod + mod) % mod;\n\t\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nint n;\nstruct pos{\n\tint x,y;\n}pointset[1007];\nint edgenum=0,f[1007],sizex[1007];\nint gf(int x) {\n\twhile(x!=f[x])\n\t\tx=f[x]=x[f][f];\n\treturn x;\n}\nstruct edge{\n\tint a,b,v;\n\tbool operator<(const edge&e)const {\n\t\treturn v<e.v;\n\t}\n\tvoid unite() {\n\t\tint x=gf(a),y=gf(b);\n\t\tif(x!=y) {\n\t\t\tf[x]=y;\n\t\t\tsizex[y]+=sizex[x];\n\t\t}\n\t}\n}edgeset[207*207];\nint gcd(int a,int b) {\n\treturn b?gcd(b,a%b):a;\n}\nint pow2[1007],ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tpow2[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tpow2[i]=pow2[i-1]*2%mod;\n\tans=(pow2[n]-n-1)%mod;\n\tfor(int i=0;i<n;++i)\n\t\tscanf(\"%d%d\",&pointset[i].x,&pointset[i].y);\n\tfor(int i=0;i<n;++i) {\n\t\tfor(int j=0;j<i;++j) {\n\t\t\tint x=pointset[i].x-pointset[j].x,y=pointset[i].y-pointset[j].y;\n\t\t\tint g=gcd(x,y);\n\t\t\tx/=g,y/=g;\n\t\t\tif(!x)\n\t\t\t\ty=1;\n\t\t\tif(!y)\n\t\t\t\tx=1;\n\t\t\tif(x<0)\n\t\t\t\tx=-x,y=-y;\n\t\t\tedgeset[edgenum++]=(edge){i,j,x*30000+y};\n\t\t}\n\t}\n\tsort(edgeset,edgeset+edgenum);\n\tfor(int i=0,j=0;i<edgenum;i=j) {\n\t\tfor(int a=0;a<n;++a)\n\t\t\tsizex[f[a]=a]=1;\n\t\tfor(;j<edgenum&&edgeset[i].v==edgeset[j].v;edgeset[j++].unite());\n\t\tfor(int a=0;a<n;++a)\n\t\t\tif(f[a]==a&&sizex[a]>1)\n\t\t\t\tans=(ans-pow2[sizex[a]]+sizex[a]+1)%mod;\n\t}\n\tprintf(\"%d\\n\",(ans%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nconst int mod = 998244353;\nconst int maxn = 250;\nconst double eps = 1e-7;\nint n, cnt = 0, in[maxn];\nbool flag[maxn][maxn] = {0};\nstruct points\n{\n\tdouble x, y;\n\tpoints(double xx = 0, double yy = 0) : x(xx), y(yy) {}\n\tpoints operator-(const points &a) const {return points(x - a.x, y - a.y);}\n\tdouble cross(const points &a) const {return x * a.y - y * a.x;}\n}p[maxn];\nlong long power(long long x, long long k)\n{\n\tlong long ans = 1;\n\twhile(k)\n\t{\n\t\tif(k & 1)\n\t\t\t(ans *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i = 1; i <= n; i ++)\n\t\tcin >> p[i].x >> p[i].y;\n\tlong long sum = (power(2, n) - n - 1+ mod) % mod;\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = i + 1; j <= n; j ++)\n\t\t\tif(!flag[i][j])\n\t\t\t{\n\t\t\t\tcnt = 2;\n\t\t\t\tin[1] = i, in[2] = j;\n\t\t\t\tfor(int k = j + 1; k <= n; k ++)\n\t\t\t\t\tif(abs((p[i] - p[j]).cross(p[k] - p[i])) <= eps)\n\t\t\t\t\t\tin[++ cnt] = k;\n\t\t\t\tsum = (sum - power(2, cnt) + 1 + cnt + mod) % mod;\n\t\t\t\tfor(int k = 1; k <= cnt; k ++)\n\t\t\t\t\tfor(int t = k + 1; t <= cnt; t ++)\n\t\t\t\t\t\tflag[k][t] = 1;\n\t\t\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int mo=998244353;\nstruct point {\n  int x,y;\n  point operator-(const point &a){\n   return (point){x-a.x,y-a.y};\n  }\n  bool operator==(const point &a){\n    return x==a.x && y==a.y;\n  }\n};\n\nint cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nvoid add(int &x,int y){\n  x+=y;\n  if (x>=mo) x-=mo;\n  if (x<0) x+=mo;\n}\n\nint dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\nbool cmp(point a,point b){\n   if (a.x==0 && b.x==0) return a.y<b.y;\n   if (a.x==0) return 0;\n   if (b.x==0) return 1;\n   if (cross(a,b)==0) {\n\t if (a.x*b.x<0) return a.x<b.x;\n\t else return dot(a,a)<dot(b,b);\n   }\n   if (a.x<0) {a.x*=-1;a.y*=-1;}\n   if (b.x<0) {b.x*=-1;b.y*=-1;}\n   return cross(a,b)>0;\n}\npoint p[210],t[210];\nint p2[210];\nint main()\n{\n    int i,j;\n    int n;\n    cin>>n;\n    for (i=1;i<=n;i++) scanf(\"%d %d\",&p[i].x,&p[i].y);\n    p2[0]=1;\n    for(i=1;i<210;i++) p2[i]=1ll*p2[i-1]*2%mo;\n    int ans=p2[n];\n    add(ans,-1-n);\n    int cnt;\n    for (i=1;i<=n;i++){\n      cnt=0;\n      for (j=1;j<=n;j++){\n        if (j==i) continue;\n        t[cnt++]=p[j]-p[i];\n      }\n      sort(t,t+cnt,cmp);\n      int last=0;\n      for (j=1;j<cnt;j++){\n\t\tif (cross(t[j-1],t[j])){\n\t\t\tif (t[last].x<0 || (t[last].x==0 && t[last].y<0)) {last=j;continue;}\n\t\t\tadd(ans,-(p2[j-last+1]-(j-last+1)-1));\n\t\t\tlast=j;\n\t\t}\n      }\n      if (cnt && !(t[last].x<0 || (t[last].x==0 && t[last].y<0))){\n\t\tadd(ans,-(p2[j-last+1]-(j-last+1)-1));\n      }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MOD=998244353;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PI;\ntypedef pair<int,P> IP;\ntypedef pair<P,P> PP;\n\nint pw(int n,int k){\n  if(k<0)return pw(n,k+MOD-1);\n  int res=1;\n  while(k){\n    if(k&1)res*=n;res%=MOD;\n    n*=n;n%=MOD;\n    k>>=1;\n  }\n  return res;\n}\n\nint f(int a){\n  if(a<=2)return 0;\n  int res=pw(2,a);\n  res--;\n  res-=a;\n  res-=a*(a-1)/2;\n  res%=MOD;res+=MOD;res%=MOD;\n  //cout<<\"F\"<<a<<\" \"<<res<<endl;\n  return res;\n}\n\nsigned main(){\n  int n;cin>>n;\n  vector<P> a(n);\n  for(int i=0;i<n;i++){\n    int x,y;cin>>x>>y;\n    a[i]=P(x,y);\n  }\n  sort(a.begin(),a.end());\n  map<IP,int> m;\n  for(int i=0;i<n;i++){\n    map<int,PI> mp;\n    for(int j=i+1;j<n;j++){\n      int x=a[j].first-a[i].first,y=a[j].second-a[i].second;\n      int ka;\n      if(y)ka=x/y;\n      else ka=1e9;\n      mp[ka]=PI(a[j],mp[ka].second+1);\n    }\n    for(auto p:mp){\n      int ka=p.first,v=p.second.second;\n      P po=p.second.first;\n      if(m.count(IP(ka,po)))continue;\n      m[IP(ka,po)]=v+1;\n    }\n  }\n  //for(auto p:m)cout<<p.first.first<<\" \"<<p.first.second.first<<\" \"<<p.first.second.second<<\" \"<<p.second<<endl;\n  int ans=f(n);\n  for(auto p:m)ans-=f(p.second);\n  ans%=MOD;ans+=MOD;ans%=MOD;\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 998244353\n\nint dame[222][222];\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll seica[2222];\nint main()\n{\n\tseica[0] = 1;\n\tREP(i,2221)seica[i+1] = seica[i] * 2 % MOD;\n\tint n;cin >> n;\n\tvector<pair<ll,ll>> v;\n\tREP(i,n){\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(a,b));\n\t}\n\tll ans = (seica[n] - n - 1 + MOD) % MOD; \n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = i+1;j < n;j++){\n\t\t\tvector<int> tmp;\n\t\t\tint cou = 0;\n\t\t\tll a = v[i].FI - v[j].FI;\n\t\t\tll b = v[i].SE - v[j].SE;\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tll c = v[i].FI - v[k].FI;\n\t\t\t\tll d = v[i].SE - v[k].SE;\n\t\t\t\tDBG(cout << \"cd \" << c << ' ' << d << endl;);\n\t\t\t\tif(a * d == b * c){\n\t\t\t\t\tcou++;\n\t\t\t\t\ttmp.PB(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp.size() > 2){\n\t\t\t\tREP(ii,tmp.size()){\n\t\t\t\t\tREP(jj,tmp.size()){\n\t\t\t\t\t\tif(ii != jj && dame[ii][jj] > 0){\n\t\t\t\t\t\t\tcou = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tDBG(cout << \"cou \" << cou << endl;SHOW1d(tmp,tmp.size()););\n\t\t\tdame[i][j] = cou;\n\t\t\tans = (ans - (seica[cou] - cou - 1) + MOD) % MOD;\n\t\t}\n\t}\n\tDBG(SHOW2d(dame,n,n););\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iomanip>\nusing namespace std;\n \n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\ntypedef long long ll;\n\nstruct ConvexHull {\n    \n    struct Point {\n        double x,y;\n        Point () {}\n        Point (double _x, double _y) : x(_x), y(_y) {}\n        bool operator < (const Point &a) const {\n            return (x == a.x) ? (y < a.y) : (x < a.x);\n        }\n    };\n    \n    double dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }\n    double cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }\n    double norm(Point a) { return sqrt(dot(a, a) * dot(a, a)); }\n    Point sub(Point a, Point b) { return Point(a.x - b.x, a.y - b.y); }\n    \n    vector< Point > Pos;\n    vector< Point > CHPos;\n    \n    int counter_clockwise(Point p0, Point p1, Point p2) {\n        Point a = sub(p1, p0);\n        Point b = sub(p2, p0);\n        if (cross(a,b) > 1.0e-8) return 1;\n        if (cross(a,b) < -1.0e-8) return -1;\n        if (dot(a,b) < -1.0e-8) return 2;\n        if (norm(a) < norm(b)) return -2;\n        return 0;\n    }\n    \n    void add_point(double x, double y) {\n        Pos.push_back(Point(x, y));\n    }\n    \n    void build() {\n        int n = (int) Pos.size(), k = 0;\n        sort(Pos.begin(),Pos.end());\n        vector< Point > ch(2 * n);\n        for (int i = 0; i < n; ch[k++] = Pos[i++]) {\n            while (k >= 2 && counter_clockwise(ch[k-2], ch[k-1], Pos[i]) <= 0) --k;\n        }\n        for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = Pos[i--]) {\n            while (k >= t && counter_clockwise(ch[k-2], ch[k-1], Pos[i]) <= 0) --k;\n        }\n        copy(ch.begin(), ch.begin() + k - 1, back_inserter(CHPos));\n    }\n    \n    double diameter() {\n        int n = (int) CHPos.size();\n        int is = 0, js = 0;\n        for (int i = 1; i < n; i++) {\n            if (CHPos[i].y > CHPos[is].y) is = i;\n            if (CHPos[i].y < CHPos[js].y) js = i;\n        }\n        double maxd = norm(sub(CHPos[is], CHPos[js]));\n        int i = is, maxi = is;\n        int j = js, maxj = js;\n        do{\n            if (cross(sub(CHPos[(i + 1) % n], CHPos[i]), sub(CHPos[(j + 1) % n], CHPos[j])) >= 0) {\n                j = (j + 1) % n;\n            } else {\n                i = (i + 1) % n;\n            }\n            if(norm(sub(CHPos[i], CHPos[j])) > maxd) {\n                maxd = norm(sub(CHPos[i], CHPos[j]));\n                maxi = i, maxj = j;\n            }\n        } while (i != is || j != js);\n        return sqrt(maxd);\n    }\n    \n    int size() {\n        return (int) CHPos.size();\n    }\n    \n    Point operator [] (int n) {\n        return CHPos[n];\n    }\n    \n};\n\nlong long pow_mod(long long n, long long k, long long mod) {\n    long long ret = 1, a = n % mod;\n    while (k > 0) {\n        if (k & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        k >>= 1;\n    }\n    return ret;\n}\n\n#define MOD 998244353\n\nint idx(int i, int j) {\n\treturn i * 10010 + j;\n}\n\nll N;\nll ans;\nll p_mod[300];\nvector<int> x, y;\nunordered_set< vector<bool> > used;\nunordered_map< int, int> table;\n\nvoid dfs(vector<bool> ver, int cnt) {\n\tif (cnt <= 2) return;\n\tif (used.find(ver) != used.end()) {\n\t\treturn;\n\t}\n\tConvexHull inst;\n\tREP(i,ver.size()) {\n\t\tif (ver[i]) inst.add_point((double) x[i], (double) y[i]);\n\t}\n\tinst.build();\n\tif (inst.size() < 3) return;\n\tif (inst.size() == 3 && cnt == 3) {\n\t\tans += p_mod[0];\n\t\tans %= MOD;\n\t\tused.insert(ver);\n\t\treturn;\n\t}\n\tans += p_mod[cnt - inst.size()];\n\tans %= MOD;\n\tREP(i,inst.size()) {\n\t\tint p = idx((int)inst[i].x, (int)inst[i].y);\n\t\tint v = table[p];\n\t\tvector<bool> ver_t = ver;\n\t\tver_t[v] = false;\n\t\tdfs(ver_t, cnt - 1);\n\t}\n}\n\nint main() {\n\n\tcin >> N;\n\tx.resize(N);\n\ty.resize(N);\n\tREP(i,N) cin >> x[i] >> y[i];\n\tREP(i,N) table[idx(x[i], y[i])] = i;\n\n\tans = 0;\n\tREP(i,300) p_mod[i] = pow_mod(2, i, MOD);\n\tvector<bool> ver(N);\n\tREP(i,N) ver[i] = true;\n\tdfs(ver, N);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst long double EPS = 1e-9;\n\nstruct Line {\n\tlong double x, y;\n};\nbool operator< (const Line &a1, const Line &a2) {\n\tif (fabs(a1.x - a2.x) > EPS && a1.x < a2.x) return true; if (fabs(a1.x - a2.x) > EPS && a1.x > a2.x) return false;\n\tif (fabs(a1.y - a2.y) > EPS && a1.y < a2.y) return true; if (fabs(a1.y - a2.y) > EPS && a1.y > a2.y) return false;\n\treturn false;\n}\nbool operator== (const Line &a1, const Line &a2) {\n\tif (fabs(a1.x - a2.x) < EPS && fabs(a1.y - a2.y) < EPS) return true;\n\treturn false;\n}\n\nlong long n, x[209], y[209], power[209], mod = 998244353; vector<Line> vec;\n\nlong long calc(long long n) {\n\treturn (power[n] - (n*(n - 1) / 2) - n - 1 + mod) % mod;\n}\n\nint main() {\n\tcin >> n;\n\tpower[0] = 1; for (int i = 1; i <= 208; i++) power[i] = (power[i - 1] * 2) % mod;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint X = (x[j] - x[i]), Y = (y[j] - y[i]); if (X < 0) { X *= -1; Y *= -1; }\n\t\t\tif (X == 0) { vec.push_back(Line{ 1.0L*x[j], 100000.0L }); }\n\t\t\telse {\n\t\t\t\tlong double D = 1.0L*Y / X;\n\t\t\t\tlong double E = 1.0L*y[i] - D*x[i];\n\t\t\t\tvec.push_back(Line{ E,D });\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\tint cx = 0; long long U = 0;\n\twhile (cx < vec.size()) {\n\t\tint pos1 = upper_bound(vec.begin(), vec.end(), vec[cx]) - vec.begin();\n\t\tint V = pos1 - cx, VV = 0;\n\t\tfor (int i = 2; i <= 200; i++) {\n\t\t\tif (V == i*(i - 1) / 2)VV = i;\n\t\t}\n\t\tU += calc(VV); U += mod; U %= mod;\n\t\tcx = pos1;\n\t}\n\tlong long ans = calc(n);\n\tans = (ans - U + mod) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n题解先咕着。\n#endif\n#include <cstdio>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 205, mod = 998244353;\n\ninline ll sq(ll x) { return x * x; }\ninline bool in_line(ll x1, ll y1, ll x2, ll y2) {\n\tll a = x1 * x2 + y1 * y2;\n\tll b = (sq(x1) + sq(y1)) * (sq(x2) + sq(y2));\n\t/* debug(\"chk %lld %lld\\n\", sq(a), b); */\n\treturn a >= 0 and sq(a) == b;\n}\n\nint x[maxn], y[maxn];\nll p2[maxn];\n\nint main() {\n\tint n = read;\n\tfor(int i = 1; i <= n; i ++)\n\t\tread(x[i], y[i]);\n\n\tp2[0] = 1;\n\tfor(int i = 1; i <= n; i ++)\n\t\tp2[i] = (p2[i - 1] << 1) % mod;\n\n\tll ans = 0;\n\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif(i != j) {\n\t\t\t\tint Dx = x[j] - x[i], Dy = y[j] - y[i];\n\t\t\t\tint tot = 0;\n\t\t\t\tfor(int k = 1; k <= n; k ++)\n\t\t\t\t\tif(k != i and k != j) {\n\t\t\t\t\t\tint dx = x[k] - x[j], dy = y[k] - y[j];\n\t\t\t\t\t\tif(in_line(Dx, Dy, dx, dy))\n\t\t\t\t\t\t\t/* debug(\"%d %d %d\\n\", i, j, k), */\n\t\t\t\t\t\t\t++ tot;\n\t\t\t\t\t}\n\t\t\t\tans += p2[tot];\n\t\t\t}\n\n\t/* debug(\"%lld\\n\", ans); */\n\n\t((ans %= mod) *= (mod + 1) >> 1) %= mod;\n\tans = (p2[n] - n - 1 - ans + mod) % mod;\n\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define ll long long\nusing namespace std;\nconst int mod=998244353;\nint n,st[210],top;\nbool vis[210][210];\nll ans,cpow[210];\nstruct pt\n{\n\tint x,y;\n}a[210];\nbool check(int p,int q,int r)\n{\n\tif((a[p].x-a[q].x)*(a[q].y-a[r].y)==(a[q].x-a[r].x)*(a[p].y-a[q].y)) return 1;\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tcpow[0]=1;\n\tfor(int i=1;i<=n;i++) cpow[i]=(cpow[i-1]<<1)%mod;\n\t\n\tans=cpow[n];\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=i-1;j++)\n\t\t\tif(!vis[i][j])\n\t\t\t{\n\t\t\t\ttop=2;st[1]=i;st[2]=j;\n\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\tif(k!=i&&k!=j&&check(i,j,k)) st[++top]=k;\n\t\t\t\tans=(ans-cpow[top]+top+1+mod)%mod;\t\n\t\t\t\t\t\n\t\t\t\tfor(int k=1;k<=top;k++)\n\t\t\t\t\tfor(int l=1;l<=k-1;l++)\n\t\t\t\t\t\tvis[st[k]][st[l]]=vis[st[l]][st[k]]=1;\n\t\t\t}\n\tans=(ans-n-1+mod)%mod;\n\tprintf(\"%lld\",ans);\t\n\treturn 0;\n}\n/*5\n0 4\n1 2\n0 0\n2 4\n2 0*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define SORT(name) sort(name.begin(), name.end())\n#define ZERO(p) memset(p, 0, sizeof(p))\n#define MINUS(p) memset(p, -1, sizeof(p))\n#if 1\n#  define DBG(fmt, ...) printf(fmt, ##__VA_ARGS__)\n#else\n#  define DBG(fmt, ...)\n#endif\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 998244353;\n#define MAX_N 210\n\n// --- 基本セット --- //\nconst double EPS = 1e-8;        // 非常に小さな値\nconst double PI = acos(-1);     // 円周率\n\n// a == b なら true (誤差に寛容)\ninline bool Eq(double a, double b) { return fabs(b - a) < EPS; }\n\n// ユークリッド平面上の点を表す構造体\nclass Point\n{\n    public:\n        double x, y;\n    public:\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n        Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n        Point operator*(const double b) const { return Point(x * b, y * b); }\n        Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n        Point operator/(const double b) const { return Point(x / b, y / b); }\n        bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n        bool operator==(const Point &b) const { return Eq(x, b.x) && Eq(y, b.y); }\n\n        // 大きさの二乗を返します\n        double Norm() { return x * x + y * y; }\n        // 逆正接(y = 0 からの rad を [-π, π] の範囲で表したもの)を返します\n        double Atan2() { return atan2(y, x); }\n        // 大きさを返します\n        double Abs() { return sqrt(Norm()); }\n        // 原点を中心として反時計周りに theta (rad)度回転した座標を返します\n        Point Rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n        // 原点を反時計周りに π/2 回転した座標を返します\n        Point Rotate90() { return Point(-y, x); }\n};\n\n// 2 点の外積\ndouble Cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }\n// 2 点の内積\ndouble Dot(const Point &a, const Point &b) { return a.x * b.x + a.y * b.y; }\n// ラジアンを角度に\ndouble RadianToDegree(double r) { return (r * 180.0 / acos(-1)); }\n// 角度をラジアンに\ndouble DegreeToRadian(double d) { return (d * acos(-1) / 180.0); }\n// a->b->c とたどったときの b の角度(ラジアン [0, π])\ndouble GetAngle(const Point &a, const Point &b, const Point &c)\n{\n  const Point v = a - b, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) { swap(alpha, beta); }\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\n// 直線を表すクラス\nclass Line\n{\n    public:\n        Point a, b;\n    public:\n        Line() {};\n        Line(Point a, Point b) : a(a), b(b) {};\n        // Ax + By = C という式が与えられたときの直線上の任意の 2 点を保存\n        Line(double A, double B, double C)\n        {\n            if(Eq(A, 0)) { a = Point(0, C / B); b = Point(1, C / B); }\n            else if(Eq(B, 0)) { a = Point(C / A, 0); b = Point(C / A, 1); }\n            else { a = Point(0, C / B); b = Point(C / A, 0); }\n        }\n        // 傾きとの取得\n        enum LineResult {\n            INF_SLOPE,  // 傾き無限のグラフ (x = n のグラフ)\n            NO_SLOPE,   // 切片のみのグラフ (y = b のグラフ)\n            VALID_SLOPE // 傾きと切片のあるグラフ\n        };\n        // out_a に傾きが、 out_b に切片が、返り値として LineResult が返る\n        // INF_SLOPE の時は out_b に x = n の n が入る\n        int GetAB(double& out_a, double& out_b) {\n            if(abs(a.x - b.x) < EPS) { return INF_SLOPE; }\n            if(abs(a.y - b.y) < EPS) {\n                out_b = a.y;\n                return NO_SLOPE;\n            }\n            out_a = (a.y - b.y) / (a.x - b.x);\n            out_b = a.y - out_a * a.x;\n            return VALID_SLOPE;\n        }\n        // x 座標を渡した時に対応する y 座標を返します\n        double GetY(double x) {\n            double slope, intercept;\n            // x = a の場合は適当な点を返す\n            if(GetAB(slope, intercept) == INF_SLOPE) { return a.y; }\n            return slope * x + intercept;\n        }\n        // y 座標を渡した時に対応する x 座標を返します\n        double GetX(double y) {\n            double slope, intercept;\n            // y = b の場合は適当な点を返す\n            if(GetAB(slope, intercept) == INF_SLOPE) { return a.x; }\n            return (y - intercept) / slope;\n        }\n};\n\n// 線分を表すクラス\n// 直線と違い端点が定義できる場合はこちら\nclass Segment\n{\n    public:\n        Point a, b;\n        Segment() {};\n        Segment(Point a, Point b) : a(a), b(b) {};\n        // 中点を求める\n        Point Center() { return Point((a.x + b.x) / 2, (a.y + b.y) / 2); }\n        // 垂直二等分線を求める\n        Line PerpBisector() {\n            Point center = this->Center();\n            return Line((a - center).Rotate90() + center, center);\n        }\n};\n\n// 円を表すクラス\nclass Circle\n{\n    public:\n        Point p;  // 中心\n        double r; // 半径\n\n        Circle() {};\n        Circle(Point p, double r) : p(p), r(r) {};\n};\n\n// その他図形を表す型定義\ntypedef vector< Point > Polygon;            // 多角形\ntypedef vector< Segment > Segments;         // 線分集合\ntypedef vector< Line > Lines;               // 直線集合\ntypedef vector< Circle > Circles;           // 円集合\ntypedef pair< Point, Point > PointPoint;    // 2 点\n\n// 点の進行方向を調べる\nenum DotDir {\n    Counterclockwise = 1,   // a -> b 反時計周りの方向に c\n    Clockwise = -1,         // a -> b 時計周りの方向に c\n    CAB = 2,                // c -> a -> b の順に並ぶ\n    ABC = -2,               // a -> b -> c の順に並ぶ\n    ACB = 0                 // a -> c -> b の順に並ぶ\n};\n// a -> b -> c の順に点をたどったときの進行方向 DotDir を返す\nint Ccw(const Point &a, Point b, Point c)\n{\n  b = b - a, c = c - a;\n  if(Cross(b, c) > EPS) { return Counterclockwise; }\n  if(Cross(b, c) < -EPS) { return Clockwise; }\n  if(Dot(b, c) < 0) { return CAB; }\n  if(b.Norm() < c.Norm()) { return ABC; }\n  return ACB;\n}\n\n// --- 基本セットここまで --- //\n\n// x の n 乗 を m で余りをとったもの\nll mod_pow(ll x, ll n, ll mod) {\n    ll res = 1;\n    while ( n > 0) {\n        if (n & 1) { res = res * x % mod; } // 最下位ビットが立っているときに x^(2^i) を掛ける\n        x = x * x % mod;                    // x を順次 2 乗していく\n        n >>= 1;\n    }\n    return res;\n}\n\n// 直線 l 上に点 p があるなら true\nbool Intersect(const Line &l, const Point &p) { return abs(Ccw(l.a, l.b, p)) != 1; }\n\nll N;\nPolygon P;\nbool isUsed[MAX_N][MAX_N] = {};\n\nsigned main()\n{\n    cin >> N;\n    REP(i, N) {\n        double x, y;\n        cin >> x >> y;\n        P.push_back(Point(x, y));\n    }\n    ll ans = mod_pow(2, N, MOD) + MOD - (N+1);\n    ans %= MOD;\n    //DBG(\"ans: %lld\\n\", ans);\n    REP(i, N) {\n        REP(j, N) {\n            if(isUsed[i][j] || i == j) { continue; }\n            set<ll> point;\n            point.insert(i);\n            point.insert(j);\n            REP(k, N) {\n                if(Intersect(Line(P[i], P[j]), P[k])) {\n                    //DBG(\"(%f %f) is in (%f %f) (%f %f)!\\n\", P[k].x, P[k].y, P[i].x, P[i].y, P[j].x, P[j].y);\n                    point.insert(k);\n                }\n            }\n            ans += MOD - (mod_pow(2, point.size(), MOD) - point.size() - 1);\n            ans %= MOD;\n            //DBG(\"  point.size(): %zu\\n\", point.size());\n            //DBG(\"  ans: %lld\\n\", ans);\n            for(auto& k : point) {\n                for(auto& l : point) {\n                    isUsed[k][l] = true;\n                }\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int maxn = 233, mod = 998244353;\n\nint n, ans, x[maxn], y[maxn], pw2[maxn];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tpw2[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tpw2[i] = (pw2[i - 1] << 1) % mod;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d%d\", x + i, y + i);\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tint m = 0;\n\t\t\tfor (int k = 0; k < j; ++k) {\n\t\t\t\tif((x[j] - x[k]) * (y[i] - y[k]) == (x[i] - x[k]) * (y[j] - y[k])) {\n\t\t\t\t\t++m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = (ans + pw2[m]) % mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (pw2[n] - ans - n - 1 + mod) % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\ntypedef long long ll;\nint n, cnt, X[210], Y[210], P[210]={1};\nbool done[210][210];\nint norm(int x){\n\treturn (x+MOD)%MOD;\n}\nbool linear(int a, int b, int c){\n\treturn (X[a]-X[c])*(Y[b]-Y[c])-(Y[a]-Y[c])*(X[b]-X[c])==0;\n}\nint subset(int x){\n\treturn norm(P[x]-x-1);\n}\nvoid count(int v, int u){\n\tif(done[v][u]) return;\n\tvector<int> V;\n\tfor(int i=1; i<=n; i++)\n\t\tif(linear(u,v,i))\n\t\t\tV.push_back(i);\n\tint m=V.size();\n\tfor(int i=0; i<m; i++)\n\t\tfor(int j=0; j<m; j++)\n\t\t\tdone[V[i]][V[j]]=true;\n\tcnt=(cnt+subset(m))%MOD;\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<=n; i++)\n\t\tP[i]=(P[i-1]*2)%MOD;\n\tfor(int i=1; i<=n; i++)\n\t\tscanf(\"%d%d\", X+i, Y+i);\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=i+1; j<=n; j++)\n\t\t\tcount(i, j);\n\tint ans=subset(n);\n\tprintf(\"%d\", norm(ans-cnt));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int Q = 998244353;\nconst int N = 209;\nll x[N], y[N], p[N], f[N], size[N];\ninline int read() {\n    int s = 1, a = 0; char ch = getchar();\n    while (ch < '0' || ch > '9') {if (ch == '-') s = -1; ch = getchar();}\n    while (ch >= '0' && ch <= '9') {a = a * 10 + ch - '0'; ch = getchar();}\n    return s * a;\n}\ninline int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\ninline int findSet(int x) {\n    return f[x] == x ? x : f[x] = findSet(f[x]);\n}\ninline void unionSet(int x, int y) {\n    int fx = findSet(x), fy = findSet(y);\n    if (fx != fy) {\n        f[fy] = fx;\n        size[fx] += size[fy];\n    }\n}\nstruct Seg {\n    int p, q; ll hash;\n    bool operator < (const Seg &rhs) const {\n        return hash < rhs.hash;\n    }\n};\nvector<Seg> seg;\nint main() {\n    p[0] = 1;\n    for (int i = 1; i < N; i++) {\n        p[i] = p[i - 1] << 1, p[i] %= Q;\n    }\n    int n = read();\n    for (int i = 1; i <= n; i++) {\n        x[i] = read(), y[i] = read();\n    }\n    ll res = (p[n] - n - 1) % Q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            int dx = x[i] - x[j], dy = y[i] - y[j], g = gcd(dx, dy);\n            dx /= g, dy /= g;\n            if (dx == 0) dy = 1;\n            if (dy == 0) dx = 1;\n            if (dx < 0) dx *= -1, dy *= -1;\n            Seg s; s.p = i, s.q = j, s.hash = dx * 10000 + dy;\n            seg.push_back(s);\n        }\n    }\n    sort(seg.begin(), seg.end());\n    //for (auto s : seg) cout << s.p << \" \" << s.q << \" \" << s.hash << endl; return 0;\n    for (int i = 0, j = 0; i < seg.size(); i = j) {\n        for (int k = 1; k <= n; k++) {\n            f[k] = k, size[k] = 1;\n        }\n        for (; j < seg.size() && seg[i].hash == seg[j].hash; j++) {\n            unionSet(seg[j].p, seg[j].q);\n        }\n        for (int k = 1; k <= n; k++) {\n            if (f[k] == k && size[k] >= 2) {\n                res -= (p[ size[k] ] - size[k] - 1), res += Q, res %= Q;\n            }\n        }\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-15;\nconst int MOD = 998244353;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n  unsigned get() const { return x; }\n\n  // 逆数\n  ModInt inv() const {\n    ll a = 1, p = x, e = MOD-2;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // e乗\n  ModInt pow(ll e) {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // 2のx乗\n  ModInt pow2() {\n    ll a = 1, p = 2, e = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // 代入\n  void operator=(ll b) { x = b; }\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  ModInt &operator+=(ModInt that) {\n    x = ((ll)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((ll)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (ll)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (ll)x * that.inv() % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (ll)x % that.x;\n    return *this;\n  }\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\nbool intersectSP(const L &s, const P &p) {\n  if(p.real() < min(s[0].real(), s[1].real())\n    || max(s[0].real(), s[1].real()) < p.real()) return false;\n  if(p.imag() < min(s[0].imag(), s[1].imag())\n    || max(s[0].imag(), s[1].imag()) < p.imag()) return false;\n  int x1 = s[0].imag() - p.imag(), x2 = s[1].imag() - p.imag();\n  int y1 = s[0].real() - p.real(), y2 = s[1].real() - p.real();\n  return x1*y2 == x2*y1;\n}\nP p[205];\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) {\n    double x, y;\n    cin >> x >> y;\n    p[i] = {x, y};\n  }\n\n  mint ret = mint(n).pow2() - n - 1;\n  REP(i, n) FOR(j, i+1, n) {\n    mint cnt = 0;\n    REP(k, n) if(k!=i && k!=j && intersectSP(L(p[i], p[j]), p[k])) ++cnt;\n    ret -= cnt.pow2();\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\nconst int N = 2000+10;\nconst int mod = 998244353;\nint x[N],y[N];\nll f[N];\n \nint cal(int i ,int j,int k)\n{\n    return (x[j] - x[i])*(y[k] - y[j]) == (y[j] - y[i])*(x[k] - x[j]);\n}\nint main()\n{\n    for(int i = 0;i < N;i++) f[i] = i == 0?1:(f[i-1]<<1)%mod;\n    int n;\n    scanf(\"%d\",&n);\n    for(int i = 1;i <= n ;i++)\n        scanf(\"%d%d\",&x[i],&y[i]);\n    ll ans = f[n] - n - 1;\n    for(int i = 1;i <= n;i++)\n        for(int j = i+1;j <= n;j++)\n        {\n            int tot = 0;\n            for(int k = j+1;k <= n;k++)\n                if(cal(i,j,k))  tot++; // 共线\n            ans = (ans - f[tot] + mod )%mod;\n        }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define AwD 998244353\nusing namespace std;\nll mi(ll a, ll b) {\n\tll ret = 1;\n    for (; b; b >>= 1, a = a * a % AwD)\n\tif (b & 1) ret = ret * a % AwD;\n    return ret;\n}\nll x[250], y[250], ans;\nmap<ll, int> MAP;\nint main() {\n    ll n; cin >> n;\n    for (int i = 1; i <= n; i ++) cin >> x[i] >> y[i];\n\tans = mi(2, n) - n - 1;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tMAP.clear();\n\t\tfor (int j = i + 1; j <= n; j ++) {\n            ll k;\n            if (x[j] == x[i]) k = -1;\n\t\t\telse k = ((y[j] - y[i]) * mi(x[j] - x[i], AwD - 2) + AwD)% AwD;\n\t\t\tMAP[k] ++;\n\t\t}\n\t\tfor (auto it = MAP.begin(); it != MAP.end(); it ++) (ans -= mi(2, it -> second) - 1) %= AwD;\n\t}\n\tcout << ((ans) % AwD + AwD) % AwD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nconst int maxn=300;\nstruct node{\n    int x,y;\n    node operator-(const node&p)const {\n        return (node){x-p.x,y-p.y};\n    }\n    int operator*(const node&p)const {\n        return x*p.y-y*p.x;\n    }\n}d[maxn];\nint n,p[maxn];\nbool check(node a,node b,node c){\n    return ((b-a)*(c-a)==0);\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    if(n<=2) return puts(\"0\"),0;\n    \n    for (int i=1; i<=n; i++)\n        scanf(\"%d%d\",&d[i].x,&d[i].y);\n        \n    p[0]=1;\n    for (int i=1; i<=n; i++)\n        p[i]=(p[i-1]*2)%mod;\n    int cnt;\n    long long ans=0;\n    \n    for (int i=1; i<n; i++)\n        for (int j=i+1; j<n; j++){\n            cnt=n-j;\n            for (int k=j+1; k<=n; k++)\n                if(check(d[i],d[j],d[k]))\n                    cnt--;\n            (ans+=1ll*p[n-j-cnt]*(p[cnt]-1)%mod)%=mod;\n        }\n    \n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// EPS\nconstexpr double EPS = 1e-9;\n/// --- Geometory Library {{{ ///\nusing Point = complex<int>;\n#define X real()\n#define Y imag()\n#define dot(a, b) real(conj(a)*b)\n#define cross(a, b) imag(conj(a)*b)\n#define norm abs\n\n// +1 : ccw\n// -1 : cw\n// +2 : a--b--c\n// -2 : b--c--a\n//  0 : b--a--c\n// int ccw(Point a, Point b, Point c) {\n//   b -= a; c -= a;\n//   if(cross(b, c) > EPS) return +1;\n//   if(cross(b, c) < -EPS) return -1;\n//   if(dot(b, c) < 0) return 0;\n//   if(norm(b) < norm(c)) return +2;\n//   return -2;\n// }\n//\n// double arg(Point a, Point b) {\n//   return acos(dot(a, b) / norm(a) / norm(b));\n// }\n/// ---}}} ///\n\nbool para(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  return b.X * c.Y == b.Y * c.X;\n}\n\nconstexpr ll mod = 998244353;\n\n/// --- modulo Library {{{ ///\nconstexpr ll extgcd(ll a, ll b, ll& x, ll& y) {\n  if(b==0) {\n    x = 1; y = 0;\n    return a;\n  }\n  ll d = extgcd(b, a % b, y, x);\n  y -= (a / b) * x;\n  return d;\n}\nconstexpr ll modpow(ll a, ll b, ll mod = 1e9 + 7) {\n  a = (a % mod + mod) % mod;\n  ll r = 1;\n  while(b){\n    if(b & 1) r = r * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return r;\n}\nconstexpr ll modinv(ll a, ll mod = 1e9 + 7) {\n  a = (a % mod + mod) % mod;\n  ll x = 0, y = 0;\n  extgcd(a, mod, x, y);\n  return (x % mod + mod) % mod;\n}\ntemplate<int N, int mod = 1e9 + 7> struct Factorial {\n  int arr[N+1], inv[N+1];\n  int operator[](int i) const { return arr[i]; }\n  constexpr Factorial(): arr(), inv() {\n    arr[0] = 1;\n    for(int i = 1; i <= N; i++) {\n      arr[i] = (ll) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N], mod);\n    for(int i = N-1; i >= 0; i--) {\n      inv[i] = (ll) (i + 1) * inv[i + 1] % mod;\n    }\n  }\n  int C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    return (ll) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n};\n/// }}}--- ///\n\nconstexpr Factorial<200, mod> fact;\n\nbool done[200][200];\n\n// 点集合のうち,(同一直線上の点のみを選ぶ)を覗いた集合の数とスコアが一致\n// O(N^3)\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n; cin >> n;\n  vector<Point> p(n);\n  for(int i = 0; i < n; i++) {\n    int x, y; cin >> x >> y;\n    p[i] = Point(x, y);\n  }\n  ll ans = modpow(2, n, mod) - fact.C(n, 2) - n - 1;\n  ans %= mod;\n  for(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++) {\n    if(done[i][j]) continue;\n    int cnt = 2;\n    vector<int> vs;\n    vs.emplace_back(i);\n    vs.emplace_back(j);\n    for(int k = j + 1; k < n; k++) {\n      if(para(p[i], p[j], p[k])) cnt++, vs.emplace_back(k);\n    }\n    for(int s = 0; s < (int) vs.size(); s++) for(int t = s + 1; t < (int) vs.size(); t++) {\n      done[vs[s]][vs[t]] = 1;\n    }\n    ans -= modpow(2, cnt, mod) - fact.C(cnt, 2) - cnt - 1;\n    ans %= mod;\n  }\n  cout << (ans + mod) % mod << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed sig) {\n    x = sig;\n    while(x < 0) x += MOD;\n    while(x >= MOD) x -= MOD;\n  }\n  unsigned get() const { return x; }\n\n  // 累乗\n  ModInt binpow(ModInt y, ModInt e) {\n    ModInt a = 1, p = y;\n    while(e>0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; --e;}\n    }\n    a %= MOD; x = a.get();\n    return a;\n  }\n  ModInt binpow(ll y, ll e) {\n    ModInt a = 1, p = y;\n    while(e>0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; --e;}\n    }\n    a %= MOD; x = a.get();\n    return a;\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // 代入\n  void operator=(ll b) { x = b; }\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  // ModInt and ModInt\n  ModInt &operator+=(ModInt that) {\n    x = ((unsigned long long)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((unsigned long long)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (unsigned long long)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (unsigned long long)x * that.binpow(that.x, MOD-2) % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (unsigned long long)x % that.x;\n    return *this;\n  }\n  // ModInt and long long\n  ModInt &operator+=(ll that) {\n    x = ((unsigned long long)x+that)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ll that) {\n    x = ((((unsigned long long)x-that)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ll that) {\n    x = (unsigned long long)x * that % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ll that) {\n    x = (unsigned long long)x * binpow(that, MOD-2).x % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ll that) {\n    x = (unsigned long long)x % that;\n    return *this;\n  }\n  // ModInt and ModInt\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n  // ModInt and ll\n  ModInt operator+(ll that)const{return ModInt(*this) += that;}\n  ModInt operator-(ll that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ll that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ll that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ll that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) {\n  os << a.x;\n  return os;\n}\nistream &operator>>(istream& is, mint &a) {\n  is >> a.x;\n  return is;\n}\n\nint x[205], y[205];\nbool check(int i, int j, int k) {\n\tif( y[i] > y[j] ) swap(i, j);\n\tif( y[k] < y[i] || y[k] > y[j] ) return false;\n\tif( x[i] > x[j] ) swap(i, j);\n\tif( x[k] < x[i] || x[k] > x[j] ) return false;\n\tint vx = x[k] - x[i], vy = y[k] - y[i];\n\tint wx = x[k] - x[j], wy = y[k] - y[j];\n\treturn vx*wy - vy*wx == 0;\n}\n\nmint pw[205];\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) cin >> x[i] >> y[i];\n\n  pw[0] = 1;\n  FOR(i, 1, n+1) pw[i] = pw[i-1]*2;\n  // REP(i, n+1) cout << pw[i] << \" \"; cout << endl;\n\n  // cout << pw[n] - n - 1 << endl;\n  mint ret(pw[n]-n-1-n*(n-1)/2);\n  // cout << ret << endl;\n  REP(i, n) {\n    FOR(j, i+1, n) {\n      int cnt = 2;\n      int a = y[j]-y[i], b = x[i]-x[j], c = -a * x[i] - b*y[i];\n      REP(k, n) {\n        if(k == i || k == j) continue;\n        int z = a*x[k]+b*y[k]+c;\n        if(z != 0) continue;\n        if(k < j) break;\n        cnt++;\n      }\n      ret -= pw[cnt] - cnt - 1 - cnt*(cnt-1)/2;\n      // cout << i << \" \" << j << \" \" << cnt << \" \" << ret << endl;\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2e5 + 5;\nconst int   mod = 998244353;\n\nvoid add(int&a,int b)   {   a += b; if (a >= mod)   a -= mod;   }\nvoid sub(int&a,int b)   {   a -= b; if (a <  0)     a += mod;   }\n\nint mul(int a,int b)    {   return  1ll * a * b % mod;  }\nint Pow(int a,int b)    {\n    int ans = 1;\n    while  (b)  {\n        if (b & 1)  ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\n\ntypedef pair<int,int>   ii;\ntypedef pair<ii ,int>   pii;\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    vector<ii>  P(n);\n    \n    for(ii &A : P)\n        cin >> A.X,\n        cin >> A.Y;\n    \n    vector<pii> Line;\n\n    for(ii  A : P)\n    for(ii  B : P)  {\n        if (A == B) break;\n\n        int dx = A.Y - B.Y;\n        int dy = B.X - A.X;\n\n        int g = __gcd(abs(dx),abs(dy));\n\n        dx /= g;\n        dy /= g;\n\n        if (dx < 0)     dx = -dx, dy = -dy;\n        if (dx == 0 &&  dy < 0)   dy = -dy;\n\n        Line.pb(ii(dx,dy),dx * A.X + dy * A.Y);\n    }\n    sort(all(Line));\n    Line.erase(unique(all(Line)),Line.end());\n\n    int ans = Pow(2,n);\n    sub(ans,n + 1);\n\n    for(pii d : Line)   {\n        int a = d.X.X;\n        int b = d.X.Y;\n\n        int cnt = 0;\n\n        for(ii  A : P)  cnt += (a * A.X + b * A.Y == d.Y);\n\n        sub(ans,Pow(2,cnt));\n        add(ans,cnt + 1);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 998244353;\nll N;\nvector<pair<ll, ll>> Points;\nmap<tuple<ll, ll, ll>, ll> Count;\nmap<ll, ll> InvNC2;\nvector<ll> Pow;\nll R;\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll pow_multi(ll n) { return (Pow[n] + MOD - n - 1) % MOD; }\nint main() {\n  cin >> N;\n  for (ll i = 0; i < N; ++i) {\n    ll x, y;\n    cin >> x >> y;\n    Points.push_back(make_pair(x, y));\n  }\n  for (ll i = 0; i < N; ++i)\n    for (ll j = i + 1; j < N; ++j) {\n      ll x, y, x2, y2;\n      tie(x, y) = Points[i];\n      tie(x2, y2) = Points[j];\n      ll dx = x2 - x, dy = y2 - y;\n      // line ax+by=c, a+b>=0, a and b are coprime\n      ll a = dy, b = -dx;\n      if (a + b < 0) {\n        a *= -1;\n        b *= -1;\n      }\n      ll g = gcd(abs(a), abs(b));\n      a /= g;\n      b /= g;\n      ll c = a * x + b * y;\n      ++Count[make_tuple(a, b, c)];\n    }\n  for (ll i = 2; i <= N; ++i) InvNC2[i * (i - 1) / 2] = i;\n  Pow.resize(N + 1);\n  Pow[0] = 1;\n  for (ll i = 1; i <= N; ++i) Pow[i] = 2 * Pow[i - 1] % MOD;\n  R = pow_multi(N);\n  for (const auto &linecount : Count) {\n    ll k = InvNC2[linecount.second];\n    (R += MOD - pow_multi(k)) %= MOD;\n  }\n  cout << R << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <ctime>\n#include <map>\n#include <set>\n#define x first\n#define y second\n#define MOD 998244353\n#define NMax 202\nusing namespace std;\n\nint N;\nint doi[NMax+1];\nint dp[NMax+1][NMax+1];\ntypedef pair<int, int> Point;\nPoint p[NMax+1];\n\nint Arie(Point A, Point B, Point C)\n{\n    return ( (B.x-A.x)*(C.y-A.y) - (B.y-A.y)*(C.x-A.x) ) > 0;\n}\n\nint Ariep(Point A, Point B, Point C)\n{\n    return ( (B.x-A.x)*(C.y-A.y) - (B.y-A.y)*(C.x-A.x) );\n}\n\nbool inside(Point A, Point B, Point C, Point D)\n{\n    if(D == A || D == B || D == C) return 0;\n    return ( abs( Ariep(A,D,B) ) + abs( Ariep(B,D,C) ) + abs(Ariep(C,D,A) ) ) == abs( Ariep(A,B,C) );\n}\n\nvoid Compute(int i, int j)\n{\n    dp[i][j] = 0;\n    int k,l,cnt=0;\n    for(k = i+1; k <= N; ++k)\n        if(k != j && Arie(p[i], p[j], p[k]))\n        {\n            cnt = 0;\n            if(dp[i][k] < 0) Compute(i,k);\n            for(l = i+1; l <= (p[k].y > p[j].y ? k : j); ++l)\n                if(inside(p[i], p[j], p[k], p[l])) ++cnt;\n\n            dp[i][j] = (dp[i][j] + 1LL * doi[cnt] * (dp[i][k]+1) ) % MOD;\n        }\n}\n\nbool cmp(Point A, Point B)\n{\n    if(A.y == B.y) return A.x < B.x;\n    return A.y < B.y;\n}\n\nint main(){\n\n    int i,j,res=0;\n\n    scanf(\"%d\",&N);\n    for(i = 1; i <= N; ++i) scanf(\"%d %d\",&p[i].x,&p[i].y);\n\n    doi[0] = 1;\n    for(i = 1; i <= NMax; ++i) doi[i] = (1LL * 2 * doi[i-1]) % MOD;\n\n    for(i = 1; i <= N; ++i)\n        for(j = i+1; j <= N; ++j)\n        dp[i][j] = -1;\n\n    sort(p+1,p+N+1,cmp);\n\n    for(i = 1; i <= N; ++i)\n        for(j = i+1; j <= N; ++j)\n        if(dp[i][j] < 0) Compute(i,j);\n\n    for(i = 1; i <= N; ++i)\n        for(j = i+1; j <= N; ++j)\n        res = ( res + dp[i][j] ) %  MOD;\n\n\n    printf(\"%d\\n\",res);\n\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define rep(i,n) for(int i=0;i<n;++i)\n#define srep(i,s,n) for(int i=s;i<n;++i)\n#define rrep(i,n) for(int i=n-1;i>=0;--i)\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\n\nstruct UnionFind\n{\n        ull *parent, *count, *rank;\n\n        UnionFind(ull n) {\n                parent = new ull[n+1];\n                count = new ull[n+1];\n                rank = new ull[n+1];\n                for (ull i = 0ULL; i < n+1; ++i) {\n                        parent[i] = i;\n                        count[i] = 1;\n                        rank[i] = 0;\n                }\n        }\n\n        ull root(ull i) {\n                if (parent[i] == i) return i;\n                parent[i] = root(parent[i]);\n                return parent[i];\n        }\n\n        void unite(ull i, ull j) {\n                ull rooti = root(i);\n                ull rootj = root(j);\n\n                if (rooti == rootj) return;\n\n                if (rank[rootj] < rank[rooti]) {\n                        parent[i] = parent[j] = parent[rootj] = rooti;\n                        count[rooti] += count[rootj];\n                }\n                else {\n                        parent[i] = parent[j] = parent[rooti] = rootj;\n                        count[rootj] += count[rooti];\n                        if (rank[rootj] == rank[rooti]) rank[rootj]++;\n                }\n        }\n\n        bool same(ull i, ull j) {\n                return root(i) == root(j);\n        }\n};\n\nstruct BIT\n{\n        ll *tree;\n        ll size;\n\n        BIT(ll n, ll init) {\n                tree = new ll[n+1];\n                size = n;\n                rep (i, n+1) tree[i] = init;\n        }\n\n        // idx is 1 origin\n        void add(ll idx, ll x) {\n                assert(idx > 0LL);\n                while (idx <= size) {\n                        tree[idx] += x;\n                        idx += (idx & (-idx));\n                }\n        }\n\n        // idx is 1 origin\n        ll sum(ll idx) {\n                assert(idx > 0LL);\n                ll ret = 0LL;\n                while (idx > 0LL) {\n                        ret += tree[idx];\n                        idx -= (idx & (-idx));\n                }\n                return ret;\n        }\n};\n\nstruct MaxFlow {\n        V<ll> links[1005];\n        ll capacities[1005][1005];\n        ll nodes;\n\n        MaxFlow(ll nodes) {\n                // i == 0       --> S\n                // i == nodes+1 --> T\n                rep (i, nodes+2LL) links[i].clear();\n                memset(capacities, 0, sizeof(capacities));\n                this->nodes = nodes;\n        }\n\n        void add_path(ll a, ll b, ll capacity) {\n                links[a].pb(b);\n                links[b].pb(a);\n                capacities[a][b] = capacity;\n                capacities[b][a] = 0LL;\n        }\n\n        ll solve(void) {\n                deque<V<ll>> q;\n                ll ret = 0LL;\n\n                for ( ; ; q.clear()) {\n\n                        V<ll> start;\n                        start.pb(0);\n                        q.push_front(start);\n\n                        bool checked[nodes+2];\n                        memset(checked, 0, sizeof(checked));\n\n                        V<ll> found;\n\n                        for ( ; !(q.empty()); ) {\n                                V<ll> path = q.front(); q.pop_front();\n                                ll last = path[path.size()-1];\n\n                                if (checked[last]) continue;\n                                if (last == nodes+1) {\n                                        found = path;\n                                        break;\n                                }\n\n                                checked[last] = true;\n                                for (auto next : (links[last])) {\n                                        if (capacities[last][next] == 0) continue;\n                                        V<ll> newpath(path);\n                                        newpath.pb(next);\n                                        q.push_front(newpath);\n                                }\n                        }\n\n                        if (found.size() == 0) {\n                                break;\n                        }\n                        else {\n                                ll flowcount = capacities[found[0]][found[1]];\n                                rep (i, found.size()-1) {\n                                        ll src = found[i];\n                                        ll dst = found[i+1];\n                                        flowcount = min(flowcount, capacities[src][dst]);\n                                }\n                                rep (i, found.size()-1) {\n                                        ll src = found[i];\n                                        ll dst = found[i+1];\n                                        capacities[src][dst] -= flowcount;\n                                        capacities[dst][src] += flowcount;\n                                }\n                                ret += flowcount;\n                        }\n                }\n\n                return ret;\n        }\n};\n\nvoid llin(ll &a)\n{\n        cin >> a;\n}\n\nvoid llinl1(auto &v, ll count)\n{\n        for (ll i = 0LL; i < count ; ++i) {\n                ll a;\n                cin >> a;\n                v.push_back(a);\n        }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n        for (ll i = 0LL; i < count ; ++i) {\n                ll a, b;\n                cin >> a >> b;\n                v.push_back(tuple<ll, ll>(a, b));\n        }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n        for (ll i = 0LL; i < count ; ++i) {\n                ll a, b, c;\n                cin >> a >> b >> c;\n                v.push_back(tuple<ll, ll, ll>(a, b, c));\n        }\n}\n\nvoid llina(auto &v, ll count)\n{\n        llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n        T ret = v[0];\n        for (auto i : v) ret = min(ret, i);\n        return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n        T ret = v[0];\n        for (auto i : v) ret = max(ret, i);\n        return ret;\n}\n\nll absll(ll x)\n{\n        if (x < 0) return -x;\n        return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n        ll ret = 0LL;\n        x %= mod;\n\n        while (y) {\n                if (y & 1LL) {\n                        ret += x;\n                        ret %= mod;\n                }\n                y >>= 1;\n                x <<= 1;\n                x %= mod;\n        }\n\n        return ret;\n}\n\nll mod_pow(ll base, ll exp, ll mod)\n{\n        ll ret = 1LL;\n\n        for ( ; exp; ) {\n                if (exp & 1LL) {\n                        ret *= base;\n                        ret %= mod;\n                }\n                base = (base * base) % mod;\n                exp >>= 1;\n        }\n\n        return ret;\n}\n\nll mod_inv(ll x, ll mod)\n{\n        // available only when mod is prime\n        return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n        while (y != 0) {\n                ll z = x % y;\n                x = y;\n                y = z;\n        }\n        return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n        sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n        sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n        for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n                if (x % i == 0LL) {\n                        retlist.push_back(i);\n                        retlist.push_back(x / i);\n                }\n        }\n}\n\nvoid get_factors(V<ll> &retlist, ll x)\n{\n        for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n                while (x % i == 0LL) {\n                        retlist.pb(i);\n                        x /= i;\n                }\n        }\n        retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n        V<ll> factors, factors2;\n\n        get_factors(factors, x);\n\n        for (auto factor : factors) {\n                if (factor > 1) factors2.pb(factor);\n        }\n\n        return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n        V<T> resultlist;\n\n        set_intersection(a.begin(), a.end(),\n                         b.begin(), b.end(),\n                         back_inserter(resultlist));\n\n        set<T> resultset(resultlist.begin(), resultlist.end());\n        result = resultset;\n}\n\null combination(ll x, ll y)\n{\n        if (y > x / 2LL) y = x - y;\n\n        ull ret = 1LL;\n        for (ll i = 0LL; i < y; ++i) {\n                ret *= x--;\n                ret /= (i + 1LL);\n        }\n\n        return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n        if (y > x / 2LL) y = x - y;\n\n        ll ret = 1;\n\n        for (ll i = 0LL; i < y; ++i) {\n                ret = (ret * x--) % mod;\n                ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n        }\n\n        return ret;\n}\n\nvoid make_linklist(const V<tuple<ll, ll>> &srclist, V<V<ll>> &dstlist)\n{\n        for (auto src : srclist) {\n                ll a = get<0>(src);\n                ll b = get<1>(src);\n                dstlist[a].pb(b);\n                dstlist[b].pb(a);\n        }\n}\n\nvoid debug_print(auto xlist)\n{\n        for (auto x : xlist) cout << \"-- \" << x << endl;\n}\n\nvoid debug_print_t2(auto xlist)\n{\n        for (auto x : xlist) {\n                ll x1 = get<0>(x);\n                ll x2 = get<1>(x);\n                cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n        }\n}\n\nint _main();\nint main()\n{\n        cout << setprecision(12);\n        return _main();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nint _main()\n{\n        ll n;\n        llin(n);\n        ll mod = 998244353;\n\n        V<t2> xylist;\n        llinl2(xylist, n);\n        sort(xylist);\n\n        ll ans = mod_pow(2, n, mod);\n        ans -= 1;   // count == 0\n        ans %= mod;\n        ans -= n;   // count == 1\n        ans %= mod;\n\n        int counts[205][205];\n        memset(counts, 0, sizeof(counts));\n\n        rep (i, n) {\n                srep (j, i+1, n) {\n                        ll x1 = get<0>(xylist[i]);\n                        ll y1 = get<1>(xylist[i]);\n                        ll x2 = get<0>(xylist[j]);\n                        ll y2 = get<1>(xylist[j]);\n                        ll delta_x = x2 - x1;\n                        ll delta_y = y2 - y1;\n                        int min_idx = min(i, j);\n                        int max_idx = max(i, j);\n                        int count = 2;\n\n                        rep (k, n) {\n                                if (k == i || k == j) continue;\n                                ll x3 = get<0>(xylist[k]);\n                                ll y3 = get<1>(xylist[k]);\n                                ll kdelta_x = x3 - x1;\n                                ll kdelta_y = y3 - y1;\n                                if (delta_x * kdelta_y == delta_y * kdelta_x) {\n                                        min_idx = min(min_idx, k);\n                                        max_idx = max(max_idx, k);\n                                        count++;\n                                }\n                        }\n\n                        counts[min_idx][max_idx] = count;\n                }\n        }\n\n        rep (i, 205) {\n                rep (j, 205) {\n                        if (counts[i][j] == 0) continue;\n                        ans -= mod_pow(2, counts[i][j], mod);\n                        ans %= mod;\n                        ans += (counts[i][j] + 1);\n                        ans %= mod;\n                }\n        }\n\n        cout << ans;\n\n        return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "//pragma\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define YOU using\n#define DONT namespace\n#define SAY std\n\nYOU DONT SAY;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n\n#define REPP(i,a,b,d) for(int i=a;i<=b;i+=d)\n#define REP(i,a,b) REPP(i,a,b,1)\n#define REVV(i,a,b,d) for(int i=a;i>=b;i-=d)\n#define REV(i,a,b) REVV(i,a,b,1)\n\n#define FOR(i,a) for(int i=0; i<a; i++)\n#define FORD(i,a) for(int i=(int)a-1; i>=0; i--)\n\n#define pb push_back\n#define F first\n#define S second\n\nconst int OO = 1e9;\nconst ll INF = 1e18;\n\nconst int irand(int lo,int hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\nconst ll lrand(ll lo,ll hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\n#define getc getchar\ntemplate<typename T>\nT getnum(){\n\tint sign = 1;\n\tT ret = 0;\n\tchar c;\n\n\tdo{\n\t\tc = getc();\n\t}while(c == ' ' || c == '\\n');\n\tif(c == '-')sign = -1;\n\telse ret = c-'0';\n\twhile(1){\n\t\tc = getc();\n\t\tif(c < '0' || c > '9')break;\n\t\tret = 10*ret + c-'0';\n\t}\n\treturn sign * ret;\n}\n\ninline void ini(int& x){\n\tx = getnum<int>();\n}\n\ninline void scani(int& x){\n\tscanf(\"%d\",&x);\n}\n\n//end of macro\n\nconst ll MOD = 998244353;\n\ninline ll addmod(ll a, ll b){\n    if(a+b < MOD)return a+b;\n    return a+b-MOD;\n}\ninline ll mulmod(ll a, ll b){\n    return (a*b)%MOD;\n}\ninline ll expmod(ll a, ll e){\n    ll ret = 1;\n    while(e){\n        if(e&1)ret = mulmod(ret, a);\n        a = mulmod(a, a);\n        e >>= 1;\n    }\n    return ret;\n}\n\nconst int N = 205;\n\nint n;\nint x[N], y[N];\nbool used[N];\n\nint piv;\nvi pts;\nint cross(int a, int b, int c){\n    return (x[b]-x[a]) * (y[c]-y[a]) - (y[b]-y[a]) * (x[c]-x[a]);\n}\nint dist2(int a, int b){\n    return (x[a]-x[b])*(x[a]-x[b]) + (y[a]*y[b])*(y[a]*y[b]);\n}\nbool cmp(int a, int b){\n    if(cross(piv, a, b) == 0)return dist2(piv, a) < dist2(piv, b);\n    return cross(piv, a, b) > 0;\n}\n\nint bitt[N];\nvoid update(int x, int v){\n    REPP(i,x,N-1,i&-i)bitt[i] += v;\n}\nint query(int x){\n    int ret = 0;\n    REVV(i,x,1,i&-i)ret += bitt[i];\n    return ret;\n}\n\nint arr[N];\nint dp[N];\nint tidx[N];\nint solve(int sz){\n//    printf(\"solve %d\\n\",sz);\n    arr[1] = piv;\n    REP(i,2,sz)arr[i] = pts[i-2];\n    \n    int ret = 0;\n    REP(i,2,sz){\n        dp[i] = 0;\n        \n        // extend : j --- i\n        piv = arr[i];\n        pts.clear();\n        REV(j,i-1,2){\n            pts.pb(arr[j]);\n        }\n        sort(pts.begin(), pts.end(), cmp);\n        FOR(i,pts.size()){\n            tidx[pts[i]] = i+1;\n        }\n        memset(bitt, 0, sizeof bitt);\n        REV(j,i-1,2){\n            int inside = query(tidx[arr[j]]);\n            update(tidx[arr[j]], 1);\n            if(cross(arr[1], arr[i], arr[j]) == 0)continue; // cannot extend from co-linear\n            dp[i] = addmod(dp[i], mulmod(dp[j], expmod(2, inside)));\n        }\n        \n        // close polygon : i --- 1\n        ret = addmod(ret, dp[i]);\n        \n        // start new : 1 --- i\n        dp[i] = addmod(dp[i], 1);\n        \n//        printf(\"dp %d = %d\\n\",i,dp[i]);\n    }\n//    printf(\"ret %d = %d\\n\",sz,ret);\n    return ret;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    #define endl '\\n'\n    cout.setf(ios::fixed);\n    cout.setf(ios::showpoint);\n    cout.precision(10);\n    \n    cin>>n;\n    REP(i,1,n){\n        cin>>x[i]>>y[i];\n    }\n    \n    int ans = 0;\n    REV(sz,n,3){\n        piv = -1;\n        REP(i,1,n){\n            if(used[i])continue;\n            if(piv == -1 || (y[i] < y[piv]) || (y[i] == y[piv] && x[i] < x[piv]))piv = i;\n        }\n        \n        used[piv] = true;\n        \n        pts.clear();\n        REP(i,1,n){\n            if(used[i])continue;\n            pts.pb(i);\n        }\n        sort(pts.begin(), pts.end(), cmp);\n        \n//        printf(\"pivot %d\\n\",piv);\n//        FOR(i,pts.size())printf(\"%d\\n\",pts[i]);\n        \n        ans = addmod(ans, solve(sz));\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <ctime>\n#include <map>\n#include <set>\n#define x first\n#define y second\n#define MOD 998244353\n#define NMax 202\nusing namespace std;\n\nint N;\nint doi[NMax+1];\nint dp[NMax+1][NMax+1];\ntypedef pair<int, int> Point;\nPoint p[NMax+1];\n\nint Arie(Point A, Point B, Point C)\n{\n    return ( (B.x-A.x)*(C.y-A.y) - (B.y-A.y)*(C.x-A.x) ) > 0;\n}\n\nint Ariep(Point A, Point B, Point C)\n{\n    return ( (B.x-A.x)*(C.y-A.y) - (B.y-A.y)*(C.x-A.x) );\n}\n\nbool inside(Point A, Point B, Point C, Point D)\n{\n    if(D == A || D == B || D == C) return 0;\n    return ( abs( Ariep(A,D,B) ) + abs( Ariep(B,D,C) ) + abs(Ariep(C,D,A) ) ) == abs( Ariep(A,B,C) );\n}\n\nvoid Compute(int i, int j)\n{\n    dp[i][j] = 0;\n    int k,l,cnt=0;\n    for(k = i+1; k <= N; ++k)\n        if(k != j && Arie(p[i], p[j], p[k]))\n        {\n            cnt = 0;\n            if(dp[i][k] < 0) Compute(i,k);\n            for(l = i+1; l <= (p[k].y > p[j].y ? k : j); ++l)\n                if(inside(p[i], p[j], p[k], p[l])) ++cnt;\n\n            dp[i][j] = (dp[i][j] + 1LL * doi[cnt] * (dp[i][k]+1) ) % MOD;\n        }\n}\n\nbool cmp(Point A, Point B)\n{\n    if(A.y == B.y) return A.x < B.x;\n    return A.y < B.y;\n}\n\nint main(){\n    freopen(\"date.in\",\"r\",stdin);\n    freopen(\"date.out\",\"w\",stdout);\n\n    int i,j,res=0;\n\n    scanf(\"%d\",&N);\n    for(i = 1; i <= N; ++i) scanf(\"%d %d\",&p[i].x,&p[i].y);\n\n    doi[0] = 1;\n    for(i = 1; i <= NMax; ++i) doi[i] = (1LL * 2 * doi[i-1]) % MOD;\n\n    for(i = 1; i <= N; ++i)\n        for(j = i+1; j <= N; ++j)\n        dp[i][j] = -1;\n\n    sort(p+1,p+N+1,cmp);\n\n    for(i = 1; i <= N; ++i)\n        for(j = i+1; j <= N; ++j)\n        if(dp[i][j] < 0) Compute(i,j);\n\n    for(i = 1; i <= N; ++i)\n        for(j = i+1; j <= N; ++j)\n        res = ( res + dp[i][j] ) %  MOD;\n\n\n    printf(\"%d\\n\",res);\n\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed sig) { x = sig; while(x >= MOD) x -= MOD; }\n  unsigned get() const { return x; }\n\n  // 累乗\n  ModInt binpow(ModInt y, ModInt e) {\n    ModInt a = 1, p = y;\n    while(e>0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; --e;}\n    }\n    a %= MOD; x = a.get();\n    return a;\n  }\n  ModInt binpow(ll y, ll e) {\n    ModInt a = 1, p = y;\n    while(e>0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; --e;}\n    }\n    a %= MOD; x = a.get();\n    return a;\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // 代入\n  void operator=(ll b) { x = b; }\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  // ModInt and ModInt\n  ModInt &operator+=(ModInt that) {\n    x = ((unsigned long long)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((unsigned long long)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (unsigned long long)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (unsigned long long)x * that.binpow(that.x, MOD-2) % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (unsigned long long)x % that.x;\n    return *this;\n  }\n  // ModInt and long long\n  ModInt &operator+=(ll that) {\n    x = ((unsigned long long)x+that)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ll that) {\n    x = ((((unsigned long long)x-that)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ll that) {\n    x = (unsigned long long)x * that % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ll that) {\n    x = (unsigned long long)x * binpow(that, MOD-2).x % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ll that) {\n    x = (unsigned long long)x % that;\n    return *this;\n  }\n  // ModInt and ModInt\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n  // ModInt and ll\n  ModInt operator+(ll that)const{return ModInt(*this) += that;}\n  ModInt operator-(ll that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ll that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ll that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ll that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) {\n  os << a.x;\n  return os;\n}\nistream &operator>>(istream& is, mint &a) {\n  is >> a.x;\n  return is;\n}\n\nint x[205], y[205];\nbool used[205];\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) cin >> x[i] >> y[i];\n\n  mint ret(0);\n  // cout << ret << endl;\n  REP(i, n) {\n    // cout << \"i:\" << i << endl;\n    memset(used, false, sizeof(used));\n    REP(j, i+1) used[j] = true;\n    FOR(j, i+1, n) {\n      // cout << \"j:\" << j << endl;\n      if(used[j]) continue;\n      // i, jが乗ってる直線上の点を列挙\n      int a, b;\n      bool tate = false;\n      if(x[i] != x[j]) {\n        a = (y[i]-y[j])/(x[i]-x[j]);\n        b = y[i] - a*x[i];\n      } else {\n        tate = true;\n        a = x[i];\n      }\n      // cout << \"j:\" << j << \" a:\" << a << \" b:\" << b << endl;\n      mint cnt(2);\n      bool flag = true;\n      REP(k, n) {\n        // cout << \"k:\" << k << endl;\n        if(k == i || k == j) continue;\n        if(tate) {\n          if(a == x[k]) {\n            if(used[k]) {flag = false; break;}\n            used[k] = true, cnt++;\n          }\n        } else {\n          if(a*x[k]+b == y[k]) {\n            if(used[k]) {flag = false; break;}\n            used[k] = true, cnt++;\n          }\n        }\n      }\n      // cout << \"cnt:\" << cnt << \" \";\n      if(flag) {\n        mint tmp = cnt;\n        ret += cnt.binpow(2, cnt);\n        // cout << \"ret:\" << ret << \" \";\n        ret -= tmp + 1;\n        // cout << \"ret:\" << ret << endl;\n      } else {\n        // cout << endl;\n      }\n    }\n  }\n  ret += n+1;\n\n  mint res;\n  res = res.binpow(2, n) - ret;\n  cout << res << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=222,mod=998244353;\n#define lson o<<1,l,mid\n#define rson o<<1|1,mid+1,r\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\twhile(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();\n\twhile(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\nstruct line{\n\tdouble k,b;\n\tbool operator<(const line &l)const{\n\t\tif(fabs(k-l.k)>1e-8) return k<l.k;\n\t\treturn b<l.b;\n\t}\n}l[maxn];\nint n,ans,pt[maxn],x[maxn],y[maxn],llen,cnt[25555];\ninline int gcd(int x,int y){return y?gcd(y,x%y):x;}\nint main(){\n\tn=read();\n\tFOR(i,1,n) x[i]=read(),y[i]=read();\n\tpt[0]=1;\n\tFOR(i,1,n) pt[i]=2*pt[i-1]%mod;\n\tans=(pt[n]-(n+1)+mod)%mod;\n\tFOR(i,1,n) FOR(j,i+1,n){\n\t\tdouble k,b;\n\t\tif(x[i]==x[j]) k=1e9,b=x[i];\n\t\telse k=1.0*(y[j]-y[i])/(x[j]-x[i]),b=y[i]-k*x[i];\n\t\tl[++llen]=(line){k,b};\n\t}\n\tsort(l+1,l+llen+1);\n\tFOR(i,2,n) cnt[i*(i-1)/2]=i;\n\tFOR(i,1,llen){\n\t\tint j=i;\n\t\twhile(j<=llen && fabs(l[i].k-l[j].k)<1e-8 && fabs(l[i].b-l[j].b)<1e-8) j++;\n\t\tj--;\n\t\tint x=cnt[j-i+1];\n\t\tans=(ans-(pt[x]-(x+1)+mod)%mod+mod)%mod;\n\t\ti=j;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:https://beta.atcoder.jp/contests/arc082/tasks/arc082_c>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() {ld x, y; cin >> x >> y; return Point(x, y);} // 点の入力\nbool eq(ld a, ld b) {return (abs(a - b) < eps);} // 誤差つき等号判定\nld dot(Point a, Point b) {return real(conj(a) * b);} // 内積\nld cross(Point a, Point b) {return imag(conj(a) * b);} // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {return !eq(cross(l.b - l.a, m.b - m.a), 0);}\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {return (abs(cross(l.b - p, l.a - p)) < eps);}\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);}\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 点の内外判定\n//  0 => out : 1 => on : 2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包 : 凸多角形のある一辺上にある点を含まない\nPolygon convex_hull(vector<Point> ps) {\n    int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull2(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n\n// 凸多角形の直径\npair<pll,ld> convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    if(n == 2) return make_pair(pll(0,1),abs(poly[0]-poly[1]));\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    pll resp = make_pair(-1,-1);\n    ld resd = 0;\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    while(i != maxj || j != maxi){\n        ld cur = abs(poly[i] - poly[j]);\n        if(resd + eps < cur){ resd = cur; resp = pll(i,j); }\n        int di = (i+1)%n, dj = (j+1)%n;\n        if(cross(poly[di]-poly[i],poly[dj]-poly[j]) < 0) i = di;\n        else j = dj;\n    }\n    return make_pair(resp,resd);\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\nconst ll MOD = 998244353;\nvector<ll> fact;\nll N;\nvoid rec(int n,int cnt,Polygon ps,const Polygon& allps,ll& res){\n    if(cnt >= 3){\n        auto _ps = convex_hull(ps);\n        if(_ps.size() != ps.size()) return;\n        ll in_on_p = 0;\n        for(int i = 0; i < N;i++){\n            if(is_in_polygon(ps, allps[i]) >= 1) in_on_p++;\n        }\n        ll sz = ps.size();\n        (res += fact[in_on_p-sz])%=MOD;\n    }\n    if(n == N) return;\n    for(int i = n; i < N;i++){\n        ps.push_back(allps[i]);\n        rec(i+1,cnt+1,ps,allps,res);\n        ps.pop_back();\n    }\n}\nll solve(){\n    ll res = 0;\n    cin >> N;\n    Polygon ps(N); for(Point& p:ps) p = input_point();\n    fact.resize(N+1);\n    fact[0] = 1;\n    for(int i = 1; i <= N;i++) (fact[i] = fact[i-1]*2)%=MOD;\n    rec(0,0,Polygon(0),ps,res);\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define mod 998244353\ntypedef long long ll;\nint main(){\n    int n,x[200],y[200],cnt;\n    ll c[201]={},two[201],ans;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d %d\",&x[i],&y[i]);\n    }\n    two[0]=1;\n    for(int i=1;i<=n;i++){\n        two[i]=2*two[i-1];\n        two[i]%=mod;\n    }\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            cnt=0;\n            for(int k=0;k<n;k++){\n                if(x[i]*y[j]-y[i]*x[j]+x[j]*y[k]-y[j]*x[k]+x[k]*y[i]-y[k]*x[i]==0){\n                    cnt++;\n                }\n            }\n            c[cnt]++;\n        }\n    }\n    ans=two[n];\n    ans-=n+1;\n    ans+=mod;\n    ans%=mod;\n    for(ll i=2LL;i<=n;i++){\n        c[i]*=2LL;\n        c[i]/=i;\n        c[i]/=(i-1LL);\n        ans-=(two[i]-i-1LL)*c[i];\n        ans%=mod;\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define mod(x) ((x % MOD) + MOD) % MOD\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define LB(c,x) (int)(lower_bound(ALL(c),x)-(c).begin())\n#define UB(c,x) (int)(upper_bound(ALL(c),x)-(c).begin())\n#define COUNT(c,x) (UB(c,x)-LB(c,x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DEL(v) decltype(v)().swap(v)\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\ntemplate<typename T1, typename T2> using P = pair<T1,T2>;\ntemplate<typename T> using V = vector<T>;\nstruct edge { int from, to; int cost; };\nbool operator< (const edge &edge1, const edge &edge2) { return edge1.cost < edge2.cost; };\nconst double INF = 1e18;\nconst int MOD = 998244353;\n\ntemplate<typename T> ostream& operator << (ostream& s, const V<T>& v) {\n   s << \"[\";\n   for (int i = 0; i < v.size(); i++) { s << v[i]; if (i < v.size() - 1) s << \" \"; }\n   s << \"]\";\n   return s;\n}\n\nint powM(int x, int n) {\n   int res = 1;\n   while (n > 0) {\n      if ((n & 1) == 1) {\n         res = mod(res * x);\n      }\n      x = mod(x * x);\n      n >>= 1;\n   }\n   return res;\n}\n\nstruct Point { int x, y; };\nconst Point operator- (const Point& p0, const Point& p1) { return (Point){ p0.x-p1.x, p0.y-p1.y }; };\nconst int operator* (const Point& p0, const Point& p1) { return p0.x*p1.y - p0.y*p1.x; };\nbool isAligned(Point p0, Point p1, Point p) {\n   return (p0-p)*(p1-p) == 0;\n}\nbool in(Point p0, Point p1, Point p) {\n   return (p-p0).x*(p1-p).x >= 0 && (p-p0).y*(p1-p).y >= 0;\n}\n\ntemplate<typename T1, typename T2> ostream& operator << (ostream& s, const P<T1,T2>& p) {\n   s << \"(\" << p.first << \",\" << p.second << \")\";\n   return s;\n}\n\nsigned main()\n{\n   int N; cin >> N;\n   V<Point> p(N);\n   REP(i, N) {\n      cin >> p[i].x >> p[i].y;\n   }\n\n   int sum = 0;\n   FOR(i, 0, N) {\n      FOR(j, i+1, N) {\n         int n = 2;\n         FOR(k, 0, N) {\n            if (i == k || j == k) continue;\n            if (isAligned(p[i], p[j], p[k])) {\n               if (!in(p[i], p[j], p[k])) {\n                  n = -1; break;\n               }\n               n++;\n            }\n         }\n         if (n != -1) {\n            sum += powM(2,n) - n - 1;\n         }\n      }\n   }\n\n   int ans = mod(powM(2,N) - sum - N - 1);\n   cout << ans << endl;\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst int mod=998244353;\nconst double eps=0.00000001;\n\nstruct punct\n{\n    int x,y;\n};\n\npunct v[210];\nint put[210];\n\nint egal(double a,double b)\n{\n    if(abs(a-b)<eps) return 1;\n    return 0;\n}\n\nint main()\n{\n    //freopen(\"file.in\",\"r\",stdin);\n    //freopen(\"file.out\",\"w\",stdout);\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d%d\",&v[i].x,&v[i].y);\n    put[0]=1;\n    for(int i=1;i<=n;i++) put[i]=(1LL*put[i-1]*2)%mod;\n    int sol=put[n];\n    sol--;\n    sol=(sol-n+mod)%mod;\n    for(int i=1;i<n;i++)\n        for(int j=i+1;j<=n;j++)\n        {\n            double a=0;\n            int p=0;\n            if(v[i].x!=v[j].x) a=1.0*(v[i].y-v[j].y)/(v[i].x-v[j].x);\n            else p=1;\n            double b=1.0*v[i].y-a*v[i].x;\n            int cnt=0;\n            for(int k=j+1;k<=n;k++)\n                if(p==1) {if(v[k].x==v[i].x) cnt++;}\n                else if(egal(1.0*v[k].y,a*v[k].x+b)==1) cnt++;\n            sol=(sol-put[cnt]+mod)%mod;\n        }\n    printf(\"%d\",sol);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define rint register int\n#define fo(i, n) for(rint i = 1; i <= (n); i ++)\n#define out(x) cerr << #x << \" = \" << x << \"\\n\"\n#define type(x) __typeof((x).begin())\n#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); ++ it)\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0;char c = getchar(); bool f = 0;\n  for(; c < '0' || c > '9'; f |= (c == '-'), c = getchar());\n  for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if(f) x = -x;\n}\nconst int N = 2333;\nconst int mo = 99824353;\nint n, x[N], y[N], pw[N], ans = 0;\nmain(void) {\n  read(n); fo(i, n) read(x[i]), read(y[i]);\n  pw[0] = 1; fo(i, n) pw[i] = pw[i - 1] * 2 % mo;\n  int ans = pw[n] - 1 - n;\n  // out(ans);\n  fo(i, n) fo(j, n) if(i != j) {\n    vector<pair<int, int> > vec;\n    vec.push_back({x[i], y[i]});\n    vec.push_back({x[j], y[j]});\n    fo(k, n) if(k != i && k != j) {\n      int x1 = x[k] - x[i], y1 = y[k] - y[i];\n      int x2 = x[j] - x[i], y2 = y[j] - y[i];\n      if(x1 * y2 - x2 * y1 == 0) {\n        vec.push_back({x[k], y[k]});\n      }\n    }\n    sort(vec.begin(), vec.end());\n    if(vec[0].first == x[i] && vec[0].second == y[i]\n       && vec[1].first == x[j] && vec[1].second == y[j]) {\n      int cnt = (int) vec.size();\n      ans = (ans - (pw[cnt] - 1 - cnt) + mo) % mo;\n    }\n  }\n  cout << (ans + mo) % mo << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 210;\nint n,x[N],y[N],po[N];\n\nint main() {\n\tpo[0]=1;\n\tREP(i,1,N-1) po[i]=po[i-1]*2ll%P;\n\tscanf(\"%d\",&n);\n\tREP(i,1,n) scanf(\"%d%d\",x+i,y+i);\n\tint ans = (po[n]-1-n*(n+1)/2)%P;\n\tREP(i,1,n) REP(j,i+1,n) {\n\t\tint cnt = 0;\n\t\tREP(k,j+1,n) if ((x[j]-x[i])*(y[k]-y[i])==(x[k]-x[i])*(y[j]-y[i])) ++cnt;\n\t\tans = (ans-po[cnt]+1)%P;\n\t}\n\tif (ans<0) ans+=P;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MX = 205, MOD = 998244353;\n#define rep(i,n) for(int i=0; i<(n); i++)\nint n, x[MX], y[MX],u;\nll ans=1;\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i,n) scanf(\"%d%d\", x+i, y+i);\n\tu = 1+n;\n\trep(i,n) for(int j=i+1; j<n; j++){\n\t\tll t=1, tx = x[j]-x[i], ty = y[j]-y[i];\n\t\tfor(int k=j+1; k<n; k++) if(tx*(y[k]-y[i])-ty*(x[k]-x[i])==0) t = t*2%MOD;\n\t\tu = (u+t) % MOD;\n\t}\n\tfor(ll b=2; n; n/=2, (b*=b)%=MOD) if(n&1) (ans *= b) %= MOD;\n\tprintf(\"%lld\\n\", (ans+MOD-u)%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint n;\nint x[202];\nint y[202];\nint l[222];\n\nll mod = 998244353;\n\nll pow2(ll x){\n    ll r = 1;\n    ll a = 2;\n    while(x){\n        if (x & 1){\n            r = r*a%mod;\n        }\n        a = a*a%mod;\n        x>>=1;\n    }\n    return r;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d\",&x[i],&y[i]);\n    }\n\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<=n;j++){\n            int cnt = 0;\n            int b = x[i] - x[j];\n            int a = y[j] - y[i];\n            int c = a*x[i] + b*y[i];\n            for(int k=1;k<=n;k++){\n                if (k == i || k == j || c == a*x[k] + b*y[k])cnt++;\n            }\n            l[cnt]++;\n        }\n    }\n    ll ans = (pow2(n) - n - 1 + mod)%mod;\n    for(int i=2;i<=n;i++){\n        l[i] /= i*(i-1)/2;\n        ans = (ans - (pow2(i) - i - 1)*l[i]%mod + mod) % mod;\n    }\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef double lld;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<double> vdl;\ntypedef vector<vector<lli>> mat;\ntypedef vector<vdl> mad;\ntypedef unordered_map<lli,unordered_map<lli,lli>> graph;\ntypedef complex<double> cmp;\ntypedef vector<cmp> vcl;\n\nconst lli mod = 998244353;\n\nlli n;\nvector<vdl> p;\nmat c;\nmat bl;\nlli ans = 0;\n\nlld deg(vdl a,vdl from){\n  return fmod(atan2(a[1]-from[1],a[0]-from[0])+2*M_PI,2*M_PI);\n}\n\nlld deg(vdl a,vdl b,vdl from){\n  return fmod(deg(b,from)-deg(a,from)+2*M_PI,2*M_PI);\n}\n\nlld abs(vdl to,vdl from){\n  lld x = to[0]-from[0];\n  lld y = to[1]-from[1];\n  return sqrt(x*x+y*y);\n}\n\nlld dot(vdl a,vdl b,vdl from){\n  lld x1 = a[0]-from[0];\n  lld y1 = a[1]-from[1];\n  lld x2 = b[0]-from[0];\n  lld y2 = b[1]-from[1];\n  return x1*x2+y1*y2;\n}\n\nlli pow(lli x,lli r,lli mod = 998244353){\n  lli ret = 1;\n  for(;r != 0;r >>= 1){\n    if(r&1 != 0) ret *= x,ret %= mod;\n    x *= x,x %= mod;\n  }\n  return ret;\n}\n\nset<vdl> s;\nmap<vdl,lli> m;\n\nint main(){\n  cin >> n;\n  p = vector<vdl>(n,vdl(2));\n  for(lli i = 0;i < n;i++) cin >> p[i][0] >> p[i][1];\n  bl = mat(n,vll(n));\n  for(lli i = 0;i < n;i++){\n    bl[i][i] = 1;\n    for(lli j = 0;j < n;j++){\n      if(bl[i][j]) continue;\n      set<lli> s;\n      bl[i][j] = bl[j][i] = 1;\n      s.insert(i);\n      s.insert(j);\n      for(lli k = 0;k < n;k++){\n        if((p[k][1]-p[i][1])*(p[j][0]-p[i][0]) == (p[j][1]-p[i][1])*(p[k][0]-p[i][0])){\n          for(lli x : s){\n            bl[x][k] = bl[k][x] = 1;\n          }\n          s.insert(k);\n        }\n      }\n      ans += pow(2ll,(lli)s.size())-1-s.size();\n\n    }\n  }\n\n  // for(lli i = 0;i < n;i++){\n  //   for(lli j = 0;j < n;j++){\n  //     cout << bl[i][j];\n  //   }\n  //   cout << endl;\n  // }\n  ans += 1ll;\n  ans += n;\n  ans %= mod;\n  cout << ((pow(2ll,n)-ans+mod)%mod) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nconst ll mod = 998244353;\nint n;\nll x[205],y[205];\nll ans;\nbool L(int a,int b,int c){\n\tll X1 = x[b]-x[a];\n\tll Y1 = y[b]-y[a];\n\tll X2 = x[c]-x[a];\n\tll Y2 = y[c]-y[a];\n\treturn X1*Y2 == X2*Y1;\n}\nll tri[205];\nint main(){\n\tcin >> n;\n\tif(n <= 2){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\trep(i,n) cin >> x[i] >> y[i];\n\tfor(int i=3;i<205;i++){\n\t\ttri[i] = 1;\n\t\trep(j,i) tri[i] = tri[i]*2LL%mod;\n\t\ttri[i] -= 1 + i * (i+1) / 2;\n\t}\n\tll ans = tri[n];\n\trep(i,n) rep(j,n){\n\t\tif(i >= j) continue;\n\t\tint bad = 0;\n\t\trep(a,j) if(a != i && L(a,i,j)){ bad = 1; break; }\n\t\tif(bad) continue;\n\t\tint C = 0;\n\t\trep(x,n) C += L(i,j,x);\n\t\tif(C <= 2) continue;\n\t\tans -= tri[C];\n\t}\n\tcout << (ans%mod+mod)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 998244353;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 210\nint x[N], y[N];\nll c[N][N];\nmap<P, bool> used[N];\n\nint comb(int n, int k){\n\tif(c[n][k]) return c[n][k];\n\tif(k==n || k==0) return c[n][k] = 1;\n\treturn c[n][k] = (comb(n-1, k-1)+comb(n-1, k))%mod;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tll res = -(1+n+n*(n-1)/2), t = 1;\n\tint m = n;\n\twhile(m--) (t<<=1)%=mod;\n\tres += t;\n\trep(i, n){\n\t\tcin>>x[i]>>y[i];\n\t}\n\trep(i, n) for(int j = i+1; j < n; j++){\n\t\tint cnt = 2;\n\t\tint xx = x[j]-x[i], yy = y[j]-y[i];\n\t\tint g = __gcd(xx, yy);\n\t\txx /= g; yy /= g;\n\t\tif(xx<0){\n\t\t\txx *= -1;\n\t\t\tyy *= -1;\n\t\t}\n\t\tP p = P(xx, yy);\n\t\tif(used[i][p]) continue;\n\t\tused[i][p] = used[j][p] = true;\n\t\tfor(int k = j+1; k < n; k++){\n\t\t\tint xx2 = x[k]-x[i], yy2 = y[k]-y[j];\n\t\t\tint g2 = __gcd(xx2, yy2);\n\t\t\txx2 /= g2; yy2 /= g2;\n\t\t\tif(xx2<0){\n\t\t\t\txx2 *= -1;\n\t\t\t\tyy2 *= -1;\n\t\t\t}\n\t\t\tP p2 = P(xx2, yy2);\n\t\t\tif(used[k][p2]) continue;\n\t\t\tif(xx==xx2 && yy==yy2){\n\t\t\t\tused[k][p2] = true;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 3; k <= cnt; k++){\n\t\t\t(res-=comb(cnt, k))%=mod;\n\t\t}\n\t\tcerr<<cnt<<endl;\n\t}\n\tcout<<(res+mod)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 30;\nconst int MOD = 998244353;\n\nconst int N = 200 + 10;\nint x[N], y[N];\n\nint cross(int u, int v, int w) {\n  return (x[v] - x[u]) * (y[w] - y[u]) - (x[w] - x[u]) * (y[v] - y[u]);\n}\n\nint dp[N][N][N];\nint64 cnt[N][N];\nint n, s;\n\nint solve(int i, int j, int k) {\n  int& ret = dp[i][j][k];\n  if (ret >= 0) return ret;\n  ret = cnt[j][k];\n  // trace(i, j, k, ret);\n  for (int u = 0; u < n; ++u) {\n    if (u > s && cross(i, j, u) > 0 && cross(s, k, u) < 0\n        && cross(u, j, k) < 0) {\n      ret += solve(j, u, k) * cnt[j][u] % MOD;\n      ret %= MOD;\n    }\n  }\n  // trace(i, j, k, ret);\n  return ret;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  // n = 200;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    // x[i] = rand() % 10000;\n    // y[i] = rand() % 10000;\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (i == j) continue;\n      cnt[i][j] = 1;\n      for (int k = 0; k < n; ++k) {\n        if (k == i || k == j) continue;\n        if (cross(i, j, k) == 0 &&\n            (x[k] - x[i]) * (x[k] - x[j]) <= 0 &&\n            (y[k] - y[i]) * (y[k] - y[j]) <= 0) {\n          cnt[i][j] = cnt[i][j] * 2 % MOD;\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < n; ++i) {\n    s = i;\n    memset(dp, 255, sizeof(dp));\n    for (int j = i + 1; j < n; ++j) {\n      for (int k = i + 1; k < n; ++k) {\n        if (cross(i, j, k) <= 0) continue;\n        ret += solve(i, j, k) * cnt[i][j] % MOD * cnt[i][k] % MOD;\n        ret %= MOD;\n      }\n    }\n  }\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 205\n#define mod 998244353\nint x[maxn],y[maxn];\nint pow(int a,int n)\n{\n    if(n==0)return 1;\n    int res=pow(a,n/2);\n    res=(long long)(res*res)%mod;\n    if(n&1)res=(long long)(res*a)%mod;\n    return res;\n}\nint add(int &a,int b)\n{\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nmain()\n{\n    int n;scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n    int ans=pow(2,n);\n    add(ans,mod-1);\n    add(ans,mod-n);\n    add(ans,mod-n*(n-1)/2);\n    for(int i=0;i<n;i++)for(int j=i+1;j<n;j++)\n    {\n        int a=y[j]-y[i];\n        int b=x[i]-x[j];\n        int c=-a*x[i]-b*y[i];\n        int cnt=2;\n        for(int k=0;k<n;k++)\n        {\n            if (k==i || k==j)continue;\n            int z=a*x[k]+b*y[k]+c;\n            if(z!=0)continue;\n            if(k<j)break;\n            cnt++;\n        }\n        add(ans,mod-pow(2,cnt));\n        add(ans,1);\n        add(ans,cnt);\n        add(ans,cnt*(cnt-1)/2);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef pair<int,int> pa;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\nconst int N=1e5+5,M=5e7+5,INF=1e9,mod=998244353;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint n;\nstruct P{\n\tint x,y;\n\til P(){}\n\til P(int x,int y):x(x),y(y){}\n\til bool operator<(const P&o)const{if(x==o.x)return y<o.y;return x<o.x;}\n\til int operator*(const P&o)const{return x*o.y-y*o.x;}\n\til P operator-(const P&o)const{return P(x-o.x,y-o.y);}\n}p[N];\nll pw[N];\nil int bad(int i,int j,int k){\n\tif((p[j]-p[i])*(p[k]-p[i])==0)return 1;\n\treturn 0;\n}\nint main(){\n\tread(n);rep(i,1,n)read(p[i].x,p[i].y);\n\tpw[0]=1;rep(i,1,n)pw[i]=pw[i-1]*2%mod;\n\tsort(p+1,p+1+n);\n\tll qaq=0;\n\trep(i,1,n)rep(j,i+1,n-1){\n\t\tint ok=1;\n\t\trep(k,1,j)\n\t\t\tif(k!=i&&k!=j)\n\t\t\t\tif(bad(i,j,k))ok=0;\n\t\tif(ok){\n\t\t\tint res=2;\n\t\t\trep(k,j+1,n)res+=bad(i,j,k);\n\t\t\tqaq+=pw[res]-res-1;\n\t\t}\n\t}\n\tqaq=pw[n]-qaq-n-1;\n\tcout<<qaq<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 998244353;\nll N;\nvector<pair<ll, ll>> Points;\nmap<tuple<ll, ll, ll>, ll> Count;\nmap<ll, ll> InvNC2;\nvector<ll> Pow;\nll R;\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll pow_multi(ll n) { return (Pow[n] + MOD - n - 1) % MOD; }\nint main() {\n  cin >> N;\n  for (ll i = 0; i < N; ++i) {\n    ll x, y;\n    cin >> x >> y;\n    Points.push_back(make_pair(x, y));\n  }\n  for (ll i = 0; i < N; ++i)\n    for (ll j = i + 1; j < N; ++j) {\n      ll x, y, x2, y2;\n      tie(x, y) = Points[i];\n      tie(x2, y2) = Points[j];\n      ll dx = x2 - x, dy = y2 - y;\n      // line ax+by=c, a>=0 or a==0 and b>0, a and b are coprime\n      ll a = dy, b = -dx;\n      if (a < 0 || (a == 0 && b < 0)) {\n        a *= -1;\n        b *= -1;\n      }\n      ll g = gcd(abs(a), abs(b));\n      assert(a >= 0 || (a == 0 && b > 0));\n      a /= g;\n      b /= g;\n      ll c = a * x + b * y;\n      assert(c == a * x2 + b * y2);\n      ++Count[make_tuple(a, b, c)];\n    }\n  for (ll i = 2; i <= N; ++i) InvNC2[i * (i - 1) / 2] = i;\n  Pow.resize(N + 1);\n  Pow[0] = 1;\n  for (ll i = 1; i <= N; ++i) Pow[i] = 2 * Pow[i - 1] % MOD;\n  R = pow_multi(N);\n  for (const auto &linecount : Count) {\n    ll k = InvNC2.at(linecount.second);\n    (R += MOD - pow_multi(k)) %= MOD;\n  }\n  cout << R << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace modular_space {\n\tlong long mod;\n\tstruct umod {\n\t\tlong long val;\n\t\tumod(): val(0ll){}\n\t\tumod(long long x){ x %= mod; if(x < 0) x += mod; val = x; }\n\t\tumod& operator += (umod oth){ val += oth.val; if(val >= mod) val -= mod; return *this; }\n\t\tumod& operator -= (umod oth){ val -= oth.val; if(val < 0) val += mod; return *this; }\n\t\tumod& operator *= (umod oth){ val = val * oth.val % mod; return *this; }\n\t\tumod& operator /= (umod oth){ return *this *= oth.inverse(); }\n\t\tumod& operator ^= (long long oth){ return *this = pwr(*this, oth); }\n\t\tumod operator + (umod oth) const { return umod(*this) += oth; }\n\t       \tumod operator - (umod oth) const { return umod(*this) -= oth; }\n\t\tumod operator * (umod oth) const { return umod(*this) *= oth; }\n\t\tumod operator / (umod oth) const { return umod(*this) /= oth; }\n\t\tumod operator ^ (long long oth) const { return umod(*this) ^= oth; }\n\t\tbool operator < (umod oth) const { return val < oth.val; }\n\t\tbool operator > (umod oth) const { return val > oth.val; }\n\t\tbool operator <= (umod oth) const { return val <= oth.val; }\n\t\tbool operator >= (umod oth) const { return val >= oth.val; }\n\t\tbool operator == (umod oth) const { return val == oth.val; }\n\t\tbool operator != (umod oth) const { return val != oth.val; }\n\t\tumod pwr(umod a, long long b) const {\n\t\t\tumod r = 1;\n\t\t\tfor(; b; a *= a, b >>= 1)\n\t\t\t\tif(b&1)\n\t\t\t\t\tr *= a;\n\t\t\treturn r;\n\t\t}\n\t\tumod inverse() const {\n\t\t\tlong long a = val, b = mod, u = 1, v = 0;\n\t\t\twhile(b){\n\t\t\t\tlong long t = a/b;\n\t\t\t\ta -= t * b; swap(a, b);\n\t\t\t\tu -= t * v; swap(u, v);\n\t\t\t}\n\t\t\tif(u < 0)\n\t\t\t\tu += mod;\n\t\t\treturn u;\n\t\t}\n\t\tfriend istream& operator >> (istream &is, umod &oth);\n\t\tfriend ostream& operator << (ostream &os, const umod& oth);\n\t};\n\tostream& operator << (ostream &os, const umod &oth){\n\t\tos << oth.val;\n\t\treturn os;\n\t}\n\tistream& operator >> (istream &is, umod &oth){\n\t\tlong long x; is >> x;\n\t\toth = umod(x);\n\t\treturn is;\n\t}\n\tstruct binprime_kit {\n\t\tint sz;\n\t\tvector<umod> fat, ifat;\n\t\tvoid init(int s){\n\t\t\tsz = s;\n\t\t\tfat.resize(sz + 1);\n\t\t\tifat.resize(sz + 1);\n\t\t\tfat[0] = 1;\n\t\t\tfor(int i = 1; i <= sz; i++) fat[i] = fat[i - 1] * i;\n\t\t\tifat[sz] = fat[sz] ^ (mod - 2);\n\t\t\tfor(int i = sz - 1; i >= 0; i--) ifat[i] = ifat[i + 1] * (i + 1);\n\t\t}\n\t\tumod coef(int n, int r){\n\t\t\tif(n < r) return 0;\n\t\t\treturn fat[n] / (ifat[r] * ifat[n - r]);\n\t\t}\n\t};\n};\nusing umod = modular_space::umod;\nconst int maxn = 202;\nint x[maxn], y[maxn];\nint seen[maxn][maxn];\nint main(){\n\tmodular_space::mod = 998244353;\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tumod ans = umod(2) ^ n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\tif(seen[i][j]) continue;\n\t\t\tvector<int> now;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tint val = (x[k] - x[i]) * (y[j] - y[i]) - (x[j] - x[i]) * (y[k] - y[i]);\n\t\t\t\tif(val == 0){\n\t\t\t\t\tnow.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint len = now.size();\n\t\t\tans -= umod(2) ^ len;\n\t\t\tans += len + 1;\n\t\t\tfor(int k = 0; k < len; k++) for(int l = k + 1; l < len; l++) seen[now[k]][now[l]] = 1;\n\t\t}\n\t}\n\tans -= n + 1;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int Maxn=210;\nconst int inf=2147483647;\nconst int mod=998244353;\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn x*f;\n}\nint Pow(int x,int y)\n{\n\tif(!y)return 1;\n\tint t=Pow(x,y>>1),re=(LL)t*t%mod;\n\tif(y&1)re=(LL)re*x%mod;\n\treturn re;\n}\nint n;bool mark[Maxn];\nstruct Point{int x,y;}p[Maxn];\nbool cmp(Point a,Point b)\n{\n\tif(a.x!=b.x)return a.x<b.x;\n\treturn a.y<b.y;\n}\nint multi(Point p0,Point p1,Point p2)\n{\n\tint X1=p1.x-p0.x,X2=p2.x-p0.x;\n\tint Y1=p1.y-p0.y,Y2=p2.y-p0.y;\n\treturn X1*Y2-X2*Y1;\n}\nint main()\n{\n\tn=read();\n\tint ans=(Pow(2,n)-1+mod)%mod;\n\tfor(int i=1;i<=n;i++)p[i].x=read(),p[i].y=read();\n\tsort(p+1,p+1+n,cmp);\n//\tfor(int i=1;i<=n;i++)printf(\" %d %d\\n\",p[i].x,p[i].y);\n\tfor(int i=1;i<=n;i++)\n\t{\n//\t\tbool flag=false;\n\t\tmemset(mark,false,sizeof(mark));\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif(mark[j])continue;\n\t\t\tint cnt=1;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\tif(multi(p[i],p[j],p[k])==0)cnt++,mark[k]=true;\n//\t\t\tprintf(\"%d %d %d\\n\",i,j,(Pow(2,cnt)-1+mod)%mod);\n\t\t\tans=(ans-(Pow(2,cnt)-1+mod)%mod+mod)%mod;\n//\t\t\tif(flag)break;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\",(ans-n+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "// fest\n#include <bits/stdc++.h>\t\n\n#define pb push_back\n#define F first\n#define S second\n#define y1 dasdasfasfas\n#define x1 wqdadfasfasfas\n#define All(c) c.begin(), c.end()\n#define SZ(A) (int((A).size()))\n#define umap unordered_map\n#define __ fflush(stdout)\n#define FILENAME \"\"\n\ntypedef long long ll;\ntypedef long double ld;    \n\nusing namespace std;\n\nvoid FREOPEN() {\n\t#ifdef LOCAL\n\t\tfreopen(\".in\", \"r\", stdin);\n\t\tfreopen(\"1.out\", \"w\", stdout);\n\t#else\n\t\t//freopen(FILENAME\".in\", \"r\", stdin);\n\t\t//freopen(FILENAME\".out\", \"w\", stdout);\n\t#endif\n}\n\ninline double Time() {return (clock() * 1.0) / CLOCKS_PER_SEC; }             \n\nconst int N = 201, inf = 1e9 * 2;\n\nconst ll MOD = 998244353, INF = 1e18;\n\nconst int dx[] = {1, -1, 0, 0, -1, 1, -1, 1};\nconst int dy[] = {0, 0, 1, -1, -1, 1, 1, -1};\n\nstruct Point {\n\tint x, y;\n};\n\nPoint a[N];\nPoint root;\n\nint tri[N][N], dp[N][N];\n\nint on_line[N];\n\nPoint make(int _x, int _y) {\n\tPoint ret;\n\tret.x = _x;\n\tret.y = _y;\n\treturn ret;\n}\n\nPoint vec(Point p1, Point p2) {\n\treturn make(p2.x - p1.x, p2.y - p1.y);\n}\n\nint crossp(Point p1, Point p2) {\n\treturn p1.x * p2.y - p1.y * p2.x; \n} \n\nint dist(Point p1, Point p2) {\n\treturn (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n}\n\nbool canbe(int i, int j) {\n\tif (i == j) return 0;\n\tif (a[i].x > a[j].x) return 0;\n\tif (a[i].x < a[j].x) return 1;\n\tif (a[i].y > a[j].y) return 0;\n\treturn 1;\n}\n\nbool cmp(Point p1, Point p2) {\n\tPoint v1 = vec(root, p1);\n\tPoint v2 = vec(root, p2);\n\tif (crossp(v1, v2) < 0) return 1;\n\tif (crossp(v1, v2) > 0) return 0;\n\tif (dist(root, p1) < dist(root, p2)) return 1;\n\treturn 0;\n}\n\nint power(int x) {\n\tint ret = 1;\n\tint num = 2;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tx--;\n\t\t\tret = (ret * 1ll * num) % MOD;\n\t\t}\n\t\telse {\n\t\t\tx /= 2;\n\t\t\tnum = (num * 1ll * num) % MOD;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid add(int &x, int y) {\n\tx += y;\n\twhile (x >= MOD) x -= MOD;\n}\n\nvoid out (Point p) {\n\tcerr << \"(\" << p.x << \" \" << p.y << \") \";\n}\n\nint main() {\n\tFREOPEN();\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _x, _y;\n\t\tscanf(\"%d %d\", &_x, &_y);\n\t\ta[i] = make(_x, _y);\n\t}\n\tint ans = 0;\n\tfor (int start = 1; start <= n; start++) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(tri, 0, sizeof(tri));\n\t\tmemset(on_line, 0, sizeof(on_line));\n\t\troot = a[start];\n\t\tvector<Point> ps;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (canbe(start, i)) ps.pb(a[i]); \n\t\t}\n\t\tsort(All(ps), cmp);\n\t\tint m = SZ(ps);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int k = i - 1; k >= 0; k--) {\n\t\t\t\tif (crossp(vec(root, ps[i]), vec(root, ps[k])) == 0) on_line[i]++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tfor (int k = i + 1; k < j; k++) {\n\t\t\t\t\tif (crossp(vec(ps[i], ps[j]), vec(ps[i], ps[k])) <= 0) tri[i][j]++;\n\t\t\t\t}\n\t\t\t\ttri[i][j] += on_line[i];\n\t\t\t\t//out(root), out(ps[i]), out(ps[j]), cerr << tri[i][j] << endl;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tassert(crossp(vec(root, ps[i]), vec(root, ps[j])) <= 0);\n\t\t\t\tif (crossp(vec(root, ps[i]), vec(root, ps[j])) == 0) continue;\n\t\t\t\tdp[i][j] += power(tri[i][j]);\n\t\t\t\tfor (int k = j + 1; k < m; k++) {\n\t\t\t\t\tif (crossp(vec(ps[i], ps[j]), vec(ps[i], ps[k])) >= 0) continue;\n\t\t\t\t\tadd(dp[j][k], (power(tri[j][k] - on_line[j]) * 1ll * dp[i][j]) % MOD);\n\t\t\t\t}\n\t\t\t\tadd(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d \", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-12;\ntypedef complex<long double> P;\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<L>se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\t//if(se.find({i,j})!=se.end())continue;\n\t\tL l(v[i],v[j]);\n\t\tvector<int>x={i,j};\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectSP(l,v[k]))x.push_back(k);\n\t\tr=(r-pow_binary_mod(2,x.size()-2,M))%M;\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\t//se.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define mod 998244353ll\n#define P pair<int,int>\nusing namespace std;\n\nP a[200];\nsigned main() {\n\tint ans = 1;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = ans * 2 % mod;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t}\n\tans -= n + 1;\n\tans %= mod;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tvector<int>V;\n\t\t\tif (a[i].first == a[j].first) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].first == a[i].first) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (a[i].second == a[j].second) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].second == a[i].second) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble x = double(a[j].second - a[i].second) / (a[j].first - a[i].first);\n\t\t\t\tdouble y = double(a[i].second) - a[i].first*x;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (abs(a[i].first*x + y - a[i].second) <= 1e-10) {\n\t\t\t\t\t\tV.push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(V.begin(), V.end());\n\t\t\tif (V.size()>=2&&V[0] == i&&V[1]==j) {\n\t\t\t\tint k = 1;\n\t\t\t\tfor (int j : V) {\n\t\t\t\t\tk = k * 2 % mod;\n\t\t\t\t}\n\t\t\t\tk -= V.size(); k--;\n\t\t\t\tans -= k;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tans += mod * 5;\n\tans %= mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define C 0.5772156649\n#define pi acos(-1.0)\n#define ll long long\n#define mod 998244353\n#define ls l,m,rt<<1\n#define rs m+1,r,rt<<1|1\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\nusing namespace std;\n\nconst double g=10.0,eps=1e-7;\nconst int N=200+10,maxn=20000+10,inf=0x3f3f3f;\n\nll x[N],y[N];\nmap<pair<ll,ll>,ll>a;\nll quick(ll a,ll b)\n{\n    ll ans=1;\n    while(b){\n        if(b&1)ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin>>n;\n    ll ans=(quick(2,n)-n-1+mod)%mod;\n    for(int i=1;i<=n;i++)cin>>x[i]>>y[i];\n    for(int i=1;i<=n;i++)\n    {\n        a.clear();\n        for(int j=i+1;j<=n;j++)\n        {\n            ll t1=y[i]-y[j];\n            ll t2=x[i]-x[j];\n            ll te=__gcd(t1,t2);\n            t1/=te;t2/=te;\n            ++a[make_pair(t1,t2)];\n        }\n        for(auto x : a)\n        {\n            ans=(ans-quick(2,x.second)+1+mod)%mod;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n/********************\n\n********************/\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: CNYALI_LK\nLANG: C++\nPROG: E.cpp\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconst double eps=1e-8;\nconst double PI=acos(-1.0);\ntypedef long long ll;\ntemplate<class T>void chkmin(T &a,T b){a=a<b?a:b;}\ntemplate<class T>void chkmax(T &a,T b){a=a>b?a:b;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\n#define min mmin\n#define max mmax\n#define abs aabs\nconst ll mod=998244353;\nll p[233];\nstruct zb{\n\tll x,y;\n};\nzb a[233];\nll cmp(zb a,zb b){return a.x<b.x||a.x==b.x&&a.y<b.y;}\nint main(){\n#ifdef cnyali_lk\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n\tll n,ans;\n\tscanf(\"%lld\",&n);\n\tp[0]=1;\n\tfor(ll i=1;i<=n;++i){p[i]=p[i-1]<<1;if(p[i]>=mod)p[i]-=mod;scanf(\"%lld%lld\",&a[i].x,&a[i].y);}\n\tsort(a+1,a+n+1,cmp);\n\tans=p[n]-n-1;\n\tfor(ll i=1;i<=n;++i)for(ll j=i+1;j<=n;++j){\n\t\tll no=0;\n\t\tfor(ll k=1;k<j;++k)if(k!=i&&(a[j].x-a[i].x)*(a[i].y-a[k].y)==(a[j].y-a[i].y)*(a[i].x-a[k].x)){no=1;break;}\n\t\tif(!no){\n///\t\t\tdebug(\"(%lld,%lld) (%lld,%lld)\",a[i].x,a[i].y,a[j].x,a[j].y);\n\t\t\tll tot=2;\n\t\t\tfor(ll k=j+1;k<=n;++k){\n\t\t\t\tif((a[j].x-a[i].x)*(a[i].y-a[k].y)==(a[j].y-a[i].y)*(a[i].x-a[k].x)){++tot;/*debug(\" (%lld,%lld)\",a[k].x,a[k].y);*/}\n\t\t\t}\n//\t\t\tdebug(\"\\n\");\n\t\t\tans-=p[tot]-tot-1;\n\t\t}\n\t}\t\n\tprintf(\"%lld\\n\",(ans%mod+mod)%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll X[202],Y[202];\nll mo=998244353;\nint did[202][202];\nll p2[202];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>X[i]>>Y[i];\n\t\n\tll ret=1;\n\tp2[0]=1;\n\tFOR(i,N) p2[i+1]=p2[i]*2%mo;\n\t\n\tret=(p2[N]+mo-1-N-N*(N-1)/2)%mo;\n\t\n\tFOR(y,N) FOR(x,y) if(did[y][x]==0) {\n\t\tvector<int> V;\n\t\tV.push_back(x);\n\t\tV.push_back(y);\n\t\tFOR(i,N) if(i!=x && i!=y) if((X[i]-X[x])*(Y[y]-Y[x])-(X[y]-X[x])*(Y[i]-Y[x])==0) V.push_back(i);\n\t\tFORR(a,V) FORR(b,V) did[a][b]=1;\n\t\tr=V.size();\n\t\tif(r>=3) ret=(ret+mo-p2[r]+r+r*(r-1)/2+1)%mo;\n\t}\n\t\n\t\n\tcout<<(ret%mo+mo)%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x first\n#define y second\n#define dbg(x) cout << #x << '=' << x << '\\n';\n#define ll long long\n#define pi pair<int,int>\n#define pl pair<long long,long long>\n#define lg length()\n#define pb push_back\n#define MAXN 100005\n#define INF 1000000005\n#define LINF 1000000000000000005\n\nlong long n,x[205],y[205],mod=998244353,cnt,v[205],s,p[205];\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0); cin.tie(); cout.tie();\n    cin >> n; p[0]=1;\n    for(int i=1;i<=n;i++){\n        cin >> x[i] >> y[i];\n        p[i]=p[i-1]*2%mod;\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++) v[j]=0;\n        for(int j=i+1;j<=n;j++){\n            if(v[j]) continue;\n            v[j]=1;\n            s=1;\n            for(int t=j+1;t<=n;t++){\n                if((x[t]-x[i])*(y[j]-y[i])==(x[j]-x[i])*(y[t]-y[i])) s++,v[t]=1;\n            }\n            cnt+=(p[s]-1);\n            cnt%=mod;\n        }\n    }\n    cnt=(p[n]-cnt-1-n+2*mod)%mod;\n    cout << cnt;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint mod=998244353;\nint x[101000],y[101000];\nint ans=0;\nlong long Pow(long long x,int p)\n{\n\tlong long ans=1;\n\twhile(p)\n\t{\n\t\tif(p&1)ans=(ans*x)%mod;\n\t\tx=(x*x)%mod;p>>=1;\n\t}\n\treturn ans;\n}\nint getans(int x){return (Pow(2,x) - ( (1 + x + x * ( x - 1 ) / 2) % mod) + mod ) % mod;}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n\tint ans=getans(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(k==i||k==j)continue;\n\t\t\t\tif((x[k] - x[i]) * (y[k] - y[j]) != (x[k] - x[j]) * (y[k] - y[i]))continue;\n\t\t\t\tif(k<j)break;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tans=(ans-getans(cnt+2)+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\",ans);return 0;\n } "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define rint register int\n#define fo(i, n) for(rint i = 1; i <= (n); i ++)\n#define out(x) cerr << #x << \" = \" << x << \"\\n\"\n#define type(x) __typeof((x).begin())\n#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); ++ it)\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0;char c = getchar(); bool f = 0;\n  for(; c < '0' || c > '9'; f |= (c == '-'), c = getchar());\n  for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if(f) x = -x;\n}\nconst int N = 2333;\nconst int mo = 998244353;\nint n, x[N], y[N], pw[N], ans = 0;\nmain(void) {\n  read(n); fo(i, n) read(x[i]), read(y[i]);\n  pw[0] = 1; fo(i, n) pw[i] = pw[i - 1] * 2 % mo;\n  int ans = pw[n] - 1 - n;\n  // out(ans);\n  fo(i, n) fo(j, n) if(i != j) {\n    vector<pair<int, int> > vec;\n    vec.push_back({x[i], y[i]});\n    vec.push_back({x[j], y[j]});\n    fo(k, n) if(k != i && k != j) {\n      int x1 = x[k] - x[i], y1 = y[k] - y[i];\n      int x2 = x[j] - x[i], y2 = y[j] - y[i];\n      if(x1 * y2 - x2 * y1 == 0) {\n        vec.push_back({x[k], y[k]});\n      }\n    }\n    sort(vec.begin(), vec.end());\n    if(vec[0].first == x[i] && vec[0].second == y[i]\n       && vec[1].first == x[j] && vec[1].second == y[j]) {\n      int cnt = (int) vec.size();\n      ans = (ans - (pw[cnt] - 1 - cnt) + mo) % mo;\n    }\n  }\n  cout << (ans + mo) % mo << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>bool chmin(T&a,const T&b){return a>b?(a=b,1):0;}\ntemplate<class T>bool chmax(T&a,const T&b){return a<b?(a=b,1):0;}\n\nconst ll MOD = 998244353;\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a%b);\n}\n\nconst int MAX_N = 210;\nint X[MAX_N];\nint Y[MAX_N];\n\n// (x1, y1) -- (x2, y2) を通る直線の方程式 ax + by + c == 0 の {a,b,c} を返す\nvector<int> line(int x1, int y1, int x2, int y2) {\n  if (x1 == x2) {\n    return {1, 0, -x1};\n  }\n  if (y1 == y2) {\n    return {0, 1, -y1};\n  }\n  int a = (y2 - y1);\n  int b = (x1 - x2);\n  int c = y1*x2 - x1*y2;\n  if (a < 0) {\n    a *= -1;\n    b *= -1;\n    c *= -1;\n  }\n  int g = gcd(a, gcd(abs(b), abs(c)));\n  a /= g;\n  b /= g;\n  c /= g;\n  return {a, b, c};\n}\n\nll two[100000];\n\nint main2() {\n  two[0] = 1;\n  for (int i = 1; i < 100000; i++) two[i] = 2 * two[i-1] % MOD;\n\n  int N = nextInt();\n  REP(i, N) {\n    X[i] = nextInt();\n    Y[i] = nextInt();\n  }\n  map<vector<int>, int> mp;\n  REP(i, N) REP(j, i) {\n    vector<int> l = line(X[i], Y[i], X[j], Y[j]);\n    ++mp[l];\n  }\n\n  ll ans = two[N] - 1 - N - N*(N-1)/2;\n  for(auto it = mp.begin(); it != mp.end(); ++it) {\n    int m = (1 + (int)sqrt(1.5 + 8 * (it->second))) / 2;\n    ans -= two[m] - 1 - m - (m)*(m-1)/2;\n    ans = (ans % MOD + MOD) % MOD;\n  }\n  ans %= MOD;\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n  for (;!cin.eof();cin>>ws) main2();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-3)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 998244353;\nusing Real = double;\nusing Point = complex< Real >;\nll inv[1000000];\nll FactorialInv[1000000];\nll Factorial[1000000];\nll beki(ll a, ll b){\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    inv[1] = 1;\n    FactorialInv[1] = 1;\n    Factorial[1] = 1;\n    for(int i = 2; i < 1000000; i++){\n        inv[i] = beki(i, mod - 2);\n        Factorial[i] = Factorial[i - 1] * i % mod;\n        FactorialInv[i] = FactorialInv[i - 1] * inv[i] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\n\nint main() {\n    cout.precision(10);\n    init_combination();\n    int n;\n    cin >> n;\n    vector<Point> vec;\n    for(int i = 0; i < n; i++){\n        int x, y;\n        cin >> x >> y;\n        Point p(x, y);\n        vec.push_back(p);\n    }\n    ll ans = beki(2, n) - n - 1;\n    ans = (ans + mod) % mod;\n    for(int i = 0; i < n; i++){\n        for(int j = i + 1; j < n; j++){\n            Line l(vec[i], vec[j]);\n            ll number = 0;\n            for(int k = 0; k < n; k++){\n                //cout << i << \" \" << j << \" \" << k << \" \" << ccw(vec[i], vec[j], vec[k]) << endl;\n                //cout << i << \" \" << j << \" \" << k << \" \" << distance(l, vec[k]) << endl;\n                if(intersect(l, vec[k])) number++;\n            }\n            //cout << i << \" \" << j << \" \" << number << endl;\n            ll now = (beki(2, number) - number - 1) * beki(combination(number, 2), mod - 2);\n            now = now % mod;\n            ans = (ans - now + mod) % mod;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <set>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define repn(i, m, n) for(i = m; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef complex<double> P;\n\nint mod = 998244353;\nint pow2[201];\nint n;\nP p[200];\n\ndouble cross(P a, P b) { return a.real() * b.imag() - a.imag() * b.real(); }\nbool onLine(P a, P b, P p) { return cross(b - a, p - a) == 0; }\n\nsigned main() {\n\tint i, j, k;\n\t\n\tpow2[0] = 1;\n\trepn(i, 1, 201) pow2[i] = (pow2[i - 1] * 2) % mod;\n\t\n\tcin >> n;\n\trep(i, n) { double x, y; cin >> x >> y; p[i] = P(x, y); }\n\t\n\tint ans = pow2[n];\n\t\n\tset<vector<int> > dict;\n\trep(i, n) {\n\t\trepn(j, i + 1, n) {\n\t\t\tvector<int> vec;\n\t\t\trep(k, n) if (onLine(p[i], p[j], p[k])) vec.push_back(k);\n\t\t\tif (dict.find(vec) != dict.end()) continue;\n\t\t\tdict.insert(vec);\n\t\t\tans += mod - (pow2[vec.size()] - vec.size() - 1);\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tans += mod - n - 1; ans %= mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n\n//点集合Sについて、Sが凸多角形なら「2^(凸多角形Sの内部にある点の個数)」がスコアになる。それ以外なら0がスコアになる。スコアの和を求めたい。\n//2^nが何を表すか？例えば、{1,2,…,n}の部分集合は2^n個ある。つまり、Sが凸多角形のときのスコアは、{Sの内部にある点}の部分集合の個数と等しい。\n//そこで、「点集合Sについて、Sの凸法が存在するなら1点, 存在しないなら0点」というスコアリングを考える。実はこれの和が、そのまま答えになる。\n//なぜだろうか。Sの凸法が存在するとき、凸法の点集合をTとおいてみる。Sが与えられたとき、Tはちょうど1個に定まる。ここで、S->Tという写像fを\n//考える。すると、各Tについて「2^(凸多角形Tの内部にある点の個数)」だけ矢印が来ていることが分かる。\n//また、写像fによって得られるTの集合（値域）は、与えられたN個の点によって作ることのできる「凸多角形」の集合と一致する。\n//新しいスコアリングでは、矢印の個数の和が合計スコアとなるが、これは上述より本問の答えと一致した。\n//\n//したがって、「凸法が存在するような点集合S」の個数を求める問題になる。補問題として「凸法が存在しないような点集合S」を考えると、Sは\n//直線または点または空集合を表すことが分かる。したがって、まず「答え=2^N」を仮定し、\n//そのような直線を全部列挙し、2^(乗っている点の個数) - (乗っている点の個数) - 1\n//を答えから引いていき、最後に答えからN+1を引けば、正しい答えが求まる。\n//計算量はO(N^3)となる()\n//\n//直線の列挙法：\n//直線は「乗っている点の集合X」と一対一対応するので、Xが今までに出現していないときだけ、リストに追加すればOK.\n//既に現れた点集合Xを、ハッシュで管理するとO(N^3), setで管理するとO(N^3logN)となる。"
  },
  {
    "language": "C++",
    "code": "// #include <bits/stdc++.h>\n\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <codecvt>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#if __cplusplus >= 201402L\n#include <shared_mutex>\n#endif\n\nusing namespace std;\n\nconst int N = 205;\nconst int MOD = 998244353;\n\nint x[N], y[N];\n\nlong P[N];\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d\", x + i, y + i);\n    }\n\n    P[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        P[i] = P[i - 1] << 1;\n        if (P[i] >= MOD) P[i] -= MOD;\n    }\n\n    long res = (P[n] - 1 - n + MOD) % MOD;\n    for (int i = 0; i < n - 1; ++ i) {\n        for (int j = i + 1; j < n; ++ j) {\n            int count = 0;\n            for (int k = j + 1; k < n; ++ k) {\n                if ((x[k] - x[i]) * (y[j] - y[i]) == (y[k] - y[i]) * (x[j] - x[i])) {\n                    count ++;\n                }\n            }\n            res = (res - P[count] + MOD) % MOD;\n        }\n    }\n    printf(\"%ld\\n\", res);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define re(i, n) for(int i = 0; i < n; ++i)\nusing namespace std;\nconst int MXN = 210, mol = 998244353;\nint n, ans = 0, pow2[MXN] = {1};\n\nstruct point {\n    int x, y;\n}p[MXN];\n\nint multi(point a, point b, point c) {\n    return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y);\n}\n\nint main() {\n    cin >> n;\n    re(i, n) cin >> p[i].x >> p[i].y, pow2[i + 1] = pow2[i] * 2 % mol;\n    ans = (pow2[n] + mol - n - 1) % mol;\n    re(i, n)\n        re(j, i) {\n            int t = 0;\n            re(k, j) {\n                if (multi(p[i], p[j], p[k]) == 0) ++t;\n            }\n            ans = (ans + mol - pow2[t]) % mol;\n        }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int Q = 998244353;\nconst int N = 209;\nll x[N], y[N], p[N], f[N];\ninline int read() {\n    int s = 1, a = 0; char ch = getchar();\n    while (ch < '0' || ch > '9') {if (ch == '-') s = -1; ch = getchar();}\n    while (ch >= '0' && ch <= '9') {a = a * 10 + ch - '0'; ch = getchar();}\n    return s * a;\n}\ninline int findSet(int x) {\n    return f[x] == x ? x : f[x] = findSet(f[x]);\n}\ninline void unionSet(int x, int y) {\n    int fx = findSet(x), fy = findSet(y);\n    if (fx != fy) f[fx] = fy;\n}\ninline bool isCollinear(int i, int j, int k) {\n    return (y[k] - y[j]) * (x[j] - x[i]) == (y[j] - y[i]) * (x[k] - x[j]);\n}\nint main() {\n    int n = read();\n    for (int i = 1; i <= n; i++) x[i] = read(), y[i] = read();\n    p[0] = 1;\n    for (int i = 1; i <= n; i++) p[i] = p[i - 1] * 2 % Q;\n    for (int i = 1; i <= n; i++) f[i] = i;\n    ll res = p[n];\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (findSet(i) == findSet(j)) continue;\n            int m = 2;\n            for (int k = j + 1; k <= n; k++) {\n                if (isCollinear(i, j, k)) {\n                    unionSet(i, k);\n                    unionSet(j, k);\n                    m++;\n                }\n            }\n            res = (res - p[m] + m + 1 + Q) % Q;\n        }\n    }\n    res = (res - n - 1 + Q) % Q;\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int p=998244353;\nint n,ans,cnt;\nint x[1010],y[1010],m[1010];\nbool check(int i,int j,int k)\n{return (y[i]-y[j])*(x[i]-x[k])==(x[i]-x[j])*(y[i]-y[k]);}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&x[i],&y[i]);\n\tm[0]=1;\n\tfor(int i=1;i<=n;i++) m[i]=(m[i-1]<<1)%p;\n\tans=m[n]-n-1;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n&&j!=i;j++){\n\t\tcnt=0;\n\t\tfor(int k=1;k<=n&&k!=i&&k!=j;k++) if(check(i,j,k)) cnt++;\n\t\tans=(ans-m[cnt]+p)%p;\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n//#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n) {\n\treturn std::vector<std::vector<T>>(n);\n}\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) res *= n, res %= mod;\n\t\tn *= n; n %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tVEC_ROW(int, n, x, y);\n\n\tauto dist = [&](int i, int j) {\n\t\treturn std::hypotl(x[i] - x[j], y[i] - y[j]);\n\t};\n\n\tint ans = powMod(2, n, MOD) - 1 - n;\n\tans %= MOD; ans += MOD; ans %= MOD;\n\tREP(i, n) FOR(j, i+1, n) {\n\t\tint cnt = 2;\n\t\tREP(k, n) {\n\t\t\tif (k == i || k == j) continue;\n\t\t\tif ((x[k] - x[i]) * (y[j] - y[i]) == (x[j] - x[i]) *(y[k] - y[i])) {\n\t\t\t\tif (k < j) {\n\t\t\t\t\tcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\tans -= powMod(2, cnt, MOD) - cnt - 1;\n\t\tans %= MOD; ans += MOD; ans %= MOD;\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define mod(x) ((x % MOD) + MOD) % MOD\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define LB(c,x) (int)(lower_bound(ALL(c),x)-(c).begin())\n#define UB(c,x) (int)(upper_bound(ALL(c),x)-(c).begin())\n#define COUNT(c,x) (UB(c,x)-LB(c,x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DEL(v) decltype(v)().swap(v)\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\ntemplate<typename T1, typename T2> using P = pair<T1,T2>;\ntemplate<typename T> using V = vector<T>;\nstruct edge { int from, to; int cost; };\nbool operator< (const edge &edge1, const edge &edge2) { return edge1.cost < edge2.cost; };\nconst double INF = 1e18;\nconst int MOD = 998244353;\n\ntemplate<typename T> ostream& operator << (ostream& s, const V<T>& v) {\n   s << \"[\";\n   for (int i = 0; i < v.size(); i++) { s << v[i]; if (i < v.size() - 1) s << \" \"; }\n   s << \"]\";\n   return s;\n}\n\nbool check(int x0, int y0, int x1, int y1, int x, int y)\n{\n   return (x1-x0)*(y-y0) == (y1-y0)*(x-x0);\n}\nint powM(int x, int n) {\n   int res = 1;\n   while (n > 0) {\n      if ((n & 1) == 1) {\n         res = mod(res * x);\n      }\n      x = mod(x * x);\n      n >>= 1;\n   }\n   return res;\n}\n\nsigned main()\n{\n   int N; cin >> N;\n   V<double> x(N), y(N);\n   REP(i, N) {\n      cin >> x[i] >> y[i];\n   }\n\n   set<P<double,double>> s;\n   set<double> t;\n   FOR(i, 0, N) {\n      FOR(j, i+1, N) {\n         if (x[i] != x[j]) {\n            double a = (y[j]-y[i])/(x[j]-x[i]);\n            double b = y[i] - a*x[i];\n            s.insert(MP(a, b));\n         } else {\n            t.insert(x[i]);\n         }\n      }\n   }\n   int sum = 0;\n   EACH(i, s) {\n      int n = 0;\n      double a = i->first, b = i->second;\n      FOR(j, 0, N) if (a*x[j] + b == y[j]) n++;\n      sum = mod(sum + powM(2,n) - n - 1);\n   }\n   EACH(i, t) {\n      int n = 0;\n      FOR(j, 0, N) if (x[j] == *i) n++;\n      sum = mod(sum + powM(2,n) - n - 1);\n   }\n\n   int ans = mod(powM(2,N) - sum - N - 1);\n   cout << ans << endl;\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=int(b); i++)\nusing namespace std;\n\nconst int maxn = 205, MOD = 998244353;\nint x[maxn], y[maxn], bin[maxn], n, ans, cnt;\n\ninline int mul(int a, int b) {\n\treturn 1LL * a * b % MOD;\n}\ninline int add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint main() {\n\tscanf(\"%d\", &n); bin[0] = 1;\n\trep (i, 1, n) scanf(\"%d%d\", &x[i], &y[i]);\n\trep (i, 1, n) bin[i] = bin[i-1] * 2 % MOD;\n\tans = add(bin[n], -n-1);\n\trep (i, 1, n) rep (j, i+1, n) {\n\t\tcnt = 0;\n\t\trep (k, j+1, n)\n\t\t\tif ((x[i]-x[k])*(y[j]-y[k]) - (x[j]-x[k])*(y[i]-y[k]) == 0) cnt++;\n\t\tans = add(ans, -bin[cnt]);\n\t}\n\tans = (ans % MOD + MOD) % MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nconst int mod=998244353;\nll p[2001];\nint x[201],y[201];\nbool used[201][201];\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        cin>>x[i]>>y[i];\n    }\n    p[0]=1;\n    rep(i,2000) p[i+1]=p[i]*2%mod;\n    ll sum=n+1;\n    rep(i,n)FOR(j,i+1,n){\n        if(used[i][j]) continue;\n        int cnt=0;\n        vector<int> u;\n        rep(k,n){\n            int a=(x[k]-x[i])*(y[j]-y[i]);\n            int b=(x[j]-x[i])*(y[k]-y[i]);\n            if(a==b){\n                //used[i][j]=used[j][i]=true;\n                u.pb(k);\n                ++cnt;\n            } \n        }\n        for(int it1:u)for(int it2:u) used[it1][it2]=true;\n        sum+=p[cnt]-cnt-1;\n        sum%=mod;\n    }\n    ll ans=(p[n]-sum+mod)%mod;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=500,mod=998244353;\nstruct point{\n\tint x,y;\n}c[maxn];\nint n;\nLL _2[maxn],ans;\nint main(){\n\tscanf(\"%d\",&n);\n\t_2[0]=1;\n\tfor(int i=1;i<=n;i++) _2[i]=(_2[i-1]<<1)%mod;\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&c[i].x,&c[i].y);\n\tans=_2[n];\n\tfor(int i=1;i<n-1;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tint cnt=0;\n\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\tif(1.0*(c[i].x-c[k].x)/(c[i].y-c[k].y)==1.0*(c[j].x-c[j].x)*(c[j].y-c[k].y)) cnt++;\n\t\t\t}\n\t\t\tans=(ans-_2[cnt]+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\",(ans-n-1+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\n\nconstexpr long long mod = 998244353;\nconst double pi = acos(-1);\n\nusing P = complex<long long>;\n\nlong long dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\nlong long cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nlong long gcd(long long a, long long b) {\n  a = abs(a);\n  b = abs(b);\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nP tomato(P a) {\n  long long g = gcd(a.real(), a.imag());\n  return P(a.real() / g, a.imag() / g);\n}\n\nbool argcomp(std::complex<long long> p1, std::complex<long long> p2) {\n  bool a = p1.imag() > 0 || (p1.imag() == 0 && p1.real() >= 0);\n  bool b = p2.imag() > 0 || (p2.imag() == 0 && p2.real() >= 0);\n  if (a != b) return a;\n  long long c = p2.real() * p1.imag();\n  long long d = p1.real() * p2.imag();\n  if (c != d) return c < d;\n  return std::norm(p1) < std::norm(p2);\n}\n\nnamespace std {\n  bool operator<(const P &a, const P &b) {\n    return argcomp(a, b);\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<P> ps(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    ps[i] = P(x, y);\n  }\n\n  vector<pair<int, int>> es;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      es.emplace_back(i, j);\n    }\n  }\n  sort(es.begin(), es.end(), [&](pair<int, int> a, pair<int, int> b) {\n    P d = ps[a.second] - ps[a.first];\n    P e = ps[b.second] - ps[b.first];\n    if (cross(d, e) == 0 && dot(d, e) >= 0) {\n      return dot(ps[a.second] - ps[a.first], ps[b.first] - ps[a.first]) < 0;\n    } else {\n      return d < e;\n    }\n  });\n\n  static int in[200][200][200];\n  for (int j = 0; j < n; j++) {\n    vector<pair<P, int>> qs;\n    for (int i = 0; i < n; i++) {\n      if (i == j) continue;\n      qs.emplace_back(ps[j] - ps[i], i);\n    }\n    sort(qs.begin(), qs.end());\n    for (int i = 0; i < n; i++) {\n      if (i == j) continue;\n      P s = tomato(ps[j] - ps[i]);\n      int f = lower_bound(qs.begin(), qs.end(), make_pair(s, 0)) - qs.begin();\n      for (int l = 0; l < n - 1; l++) {\n        int k = qs[(f + l) % (n - 1)].second;\n        in[i][j][k] -= l + 1;\n        in[j][k][i] -= l + 1;\n        in[k][i][j] -= l + 1;\n      }\n    }\n  }\n  static int on[200][200];\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      for (int k = 0; k < n; k++) {\n        if (i == k || j == k) continue;\n        on[i][j] += cross(ps[k] - ps[i], ps[j] - ps[i]) == 0 && dot(ps[k] - ps[i], ps[j] - ps[i]) > 0 && dot(ps[k] - ps[j], ps[i] - ps[j]) > 0;\n        in[i][j][k] = max(0, in[i][j][k] + n);\n      }\n    }\n  }\n\n  vector<long long> two(n + 1);\n  two[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two[i] = two[i - 1] * 2 % mod;\n  }\n\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    vector<long long> dp1(n);\n    vector<long long> dp2(n);\n    for (auto e : es) {\n      int u = e.first;\n      int v = e.second;\n\n      if (u == i) {\n        assert(dp1[v] == 0);\n        dp1[v] = two[on[u][v]];\n      } else if (v == i) {\n        dp2[v] += dp2[u];\n      } else {\n        int c = on[i][v] + on[u][v] + in[i][u][v];\n        dp2[v] += dp1[u] * two[c];\n        dp2[v] += dp2[u] * two[c];\n      }\n      dp2[v] %= mod;\n    }\n    ans += dp2[i];\n    ans %= mod;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n\nusing namespace std;\n\nconst int MAXN = 310;\nconst int MOD = 998244353;\n\ntypedef complex<int> Point;\n\nlong long cross(Point a, Point b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nint add(long long a, long long b)\n{\n\treturn (a + b + MOD) % MOD;\n}\n\nint mul(long long a, long long b)\n{\n\treturn (a * b) % MOD;\n}\n\nPoint a[MAXN];\nint pw[MAXN];\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\ta[i] = Point(x, y);\n\t}\n\tpw[0] = 1;\n\tfor (int i = 0; i < n; i++)\n\t\tpw[i + 1] = mul(pw[i], 2);\n\tint res = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = j + 1; k < n; k++)\n\t\t\t\tif (cross(a[k] - a[i], a[j] - a[i]) != 0)\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t\tres = add(res, pw[n - j - 1 - cnt]);\n\t\t\t\t}\n\t\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register int i=(a);i<=(b);i++)\n#define For(i,a,b) for (register int i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\n#define GO(u) for (register int j=f[u];j!=-1;j=nxt[j])\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define MP make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int N=205;\nconst int mod=998244353;\nint n,x[N],y[N],ans=0,er[N];\ninline int read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\ninline void write(int x)\n{\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>9) write(x/10);\n\tputchar(x%10+'0');\n\treturn;\n}\nint main()\n{\n\tn=read();\n\tFOR(i,1,n) x[i]=read(),y[i]=read();\n\ter[0]=1;\n\tFOR(i,1,n) er[i]=2LL*er[i-1]%mod;\n\tans=(1LL*er[n]-1-n+mod)%mod;\n\tFOR(i,1,n) FOR(j,1,i-1) \n\t{\n\t\tint cnt=0;\n\t\tFOR(k,1,j-1) if (1LL*((y[i]-y[j])*(x[j]-x[k]))==1LL*((x[i]-x[j])*(y[j]-y[k]))) cnt++;\n\t\tans=(1LL*ans-er[cnt]+mod)%mod;\n\t}\n\twrite(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (998244353LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef pair<int, ii> iii;\n \nll pwr(ll base, ll p, ll mod=MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n\n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nii arr[202];\n\nii get_slope(int i, int j){\n\tint a = arr[j].ff - arr[i].ff;\n\tint b = arr[j].ss - arr[i].ss;\n\tif(a == 0)\treturn ii(0, 1);\n\tif(b == 0)\treturn ii(1, 0);\n\tint g = gcd(a, b);\n\ta /= g;\tb /= g;\n\tif(a < 0){\n\t\ta *= -1;\tb *= -1;\n\t}\n\treturn ii(a, b);\n}\n\n\nint main(){\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    \tcin>>arr[i].ff>>arr[i].ss;\n\n    ll ans = pwr(2, n) - 1 - n - n*(n-1)/2;\n    for(int i=1;i<=n;i++)\n    \tfor(int j=i+1;j<=n;j++){\n    \t\tint cnt = 0;\n    \t\tfor(int k=j+1;k<=n;k++)\n    \t\t\tcnt += get_slope(i, k) == get_slope(i, j);\n    \t\tans -= pwr(2, cnt) - 1;\n    \t\tans %= MOD;\n// cout<<i<<\" \"<<j<<\", cnt = \"<<cnt<<endl;\n    \t}\n\n    ans %= MOD;\n    ans += MOD;\n    ans %= MOD;\n    cout<<ans;\n    return 0;\n}\n\n\n\n\n\n\n\n \n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<stdio.h>\n#include<algorithm>\n#define mod 998244353 \n#define maxn 505\nusing namespace std;\nint n, ans, x[maxn], y[maxn], pw[maxn];\n\nint main(){\n    scanf( \"%d\", &n );\n    pw[0] = 1;\n    for( int i = 1; i <= n; i ++ ) pw[i] = ( long long ) pw[i - 1] * 2 % mod;\n    for( int i = 1; i <= n; i ++ ) scanf( \"%d%d\", &x[i], &y[i] );\n    ans = ( pw[n] - n - 1 - n * ( n - 1 ) / 2 + mod ) % mod;\n    for( int i = 1; i <= n; i ++ ) {\n        for( int j = i + 1; j <= n; j ++ ) {\n            int tmp = 0;\n            for( int k = j + 1; k <= n; k ++ ) {\n                if( ( y[j] - y[i] ) * ( x[k] - x[j] ) == ( y[k] - y[j] ) * ( x[j] - x[i] ) ) tmp ++;\n            }\n            ans = ( ans + mod + 1 - pw[tmp] ) % mod;\n        }\n    }\n    printf( \"%d\", ans );\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\nusing ll = long long;\n\nconst ll MOD = 998244353;\nll mod(ll x) {\n    return x % MOD;\n}\nll pow_mod(ll x, ll p) {\n    ll v = 1;\n    while (p) {\n        if (p & 1) {\n            v = mod(v * x);\n        }\n        x = mod(x * x);\n        p >>= 1;\n    }\n    return v;\n}\n\nll N;\n\nstruct Point {\n    ll x, y;\n    friend Point operator-(const Point& a, const Point& b) {\n        return {a.x - b.x, a.y - b.y};\n    }\n    friend ll operator*(const Point& a, const Point& b) {\n        return a.x*b.y - a.y*b.x;\n    }\n    friend bool is_aligned(const Point& a, const Point& b, const Point& c) {\n        return (a-c)*(b-c) == 0;\n    }\n    friend bool in(const Point& a, const Point& b, const Point& c) {\n        auto s = a-c, t = b-c;\n        return s.x * t.x <= 0 and s.y * t.y <= 0;\n    }\n};\nvector<Point> points;\n\nvoid input() {\n    cin >> N;\n    for (ll i = 0; i < N; i++) {\n        ll x, y;\n        cin >> x >> y;\n        points.push_back({x, y});\n    }\n}\n\nvoid solve() {\n    ll sum = 0;\n    for (ll i = 0; i < N; i++) {\n        for (ll j = i + 1; j < N; j++) {\n            ll num_aligned_points = 2;;\n            for (ll k = 0; k < N; k++) {\n                if (k == i or k == j) continue;\n                if (is_aligned(points[i], points[j], points[k])) {\n                    if (not in(points[i], points[j], points[k])) {\n                        num_aligned_points = 0;\n                        break;\n                    }\n                    ++num_aligned_points;\n                }\n            }\n            if (num_aligned_points != 0)\n                sum += pow_mod(2, num_aligned_points) - num_aligned_points - 1;\n        }\n    }\n    ll ans = mod(pow_mod(2, N) - sum - N - 1);\n    cout << ans << endl;\n}\n\n\nint main() {\n    input();\n    solve();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nstruct point{\n\tint x , y;\n\tpoint(int _x = 0 , int _y = 0){\n\t\tx = _x;\n\t\ty = _y;\n\t}\n\tpoint operator + (const point &other) const {\n\t\treturn point(x + other.x , y + other.y);\n\t}\n\tpoint operator - (const point &other) const {\n\t\treturn point(x - other.x , y - other.y);\n\t}\n\tbool operator < (const point &other) const {\n\t\tif(x == other.x){\n\t\t\treturn y < other.y;\n\t\t}\n\t\treturn x < other.x;\n\t}\n\tvoid read(){\n\t\tscanf(\"%d %d\" , &x , &y);\n\t}\n};\ninline int dot(point a , point b){\n\treturn a.x * b.x + a.y * b.y;\n}\ninline int cross(point a , point b){\n\treturn a.x * b.y - a.y * b.x;\n}\ninline int orient(point a , point b , point c){//orientation of point c with respect to line from a -> b\n\tint val = cross(b - a , c - a);\n\tif(val > 0){\n\t\treturn 1;//c comes anticlockwise on line from a -> b\n\t}\n\tif(val < 0){\n\t\treturn -1;//c comes clockwise on line from a -> b\n\t}\n\treturn 0;//c is collinear with line from a -> b\n}\nint dist(point a , point b){\n\treturn dot(a - b , a - b);\n}\nconst int N = 205;\nconst int mod = 998244353;\nconst int inv = 499122177;\nint pw2[N];\nint n;\npoint arr[N];\nvector < point > v;\npoint bottom;\nint ans;\nbool cmp(point a , point b){\n\tint tmp = orient(bottom , a , b);\n\tif(tmp == -1){\n\t\treturn 1;\n\t}\n\tif(tmp == 1){\n\t\treturn 0;\n\t}\n\treturn dist(bottom , a) < dist(bottom , b);\n}\nbool inside(point p1 , point p2 , point p3 , point q){\n\tint o1 = orient(p1 , p2 , q);\n\tint o2 = orient(p2 , p3 , q);\n\tint o3 = orient(p3 , p1 , q);\n\treturn (o1 == o2) && (o2 == o3) && (o3 != 0);\n}\nint siz2[N][N][N];\nint siz3[N][N];\nmap < point , int > mp;\nvector < int > indexes;\n//int tot;\nint dp[N][N];\nint solve(int last1 , int last2){\n\tif(dp[last1][last2] != -1){\n\t\treturn dp[last1][last2];\n\t}\n\tint res = orient(v[last1] , v[last2] , v[0]) == -1;\n\t/*if(last1){\n\t\tcout << tot << \" \";\n\t}*/\n\tfor(int i = last2 + 1 ; i < v.size() ; ++i){\n\t\tif(orient(v[last1] , v[last2] , v[i]) == -1){\n\t\t\t//tot += siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0);\n\t\t\tres = (res + 1LL * solve(last2 , i) * pw2[siz2[indexes[0]][indexes[last2]][indexes[i]] + siz3[indexes[0]][indexes[i]] + siz3[indexes[last2]][indexes[i]]]) % mod;\n\t\t\t//tot -= siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0);\n\t\t}\n\t}\n\treturn dp[last1][last2] = res;\n}\nvoid solve(int idx){\n\tv.clear();\n\tbottom.x = arr[idx].x;\n\tbottom.y = arr[idx].y;\n\tv.emplace_back(arr[idx]);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tif(arr[i].y > bottom.y){\n\t\t\tv.emplace_back(arr[i]);\n\t\t}\n\t\telse if(arr[i].y == bottom.y && arr[i].x > bottom.x){\n\t\t\tv.emplace_back(arr[i]);\n\t\t}\n\t}\n\tsort(v.begin() + 1 , v.end() , cmp);\n\tindexes.clear();\n\tfor(int i = 0 ; i < v.size() ; ++i){\n\t\tindexes.emplace_back(mp[v[i]]);\n\t}\n\t//cout << v.size() << \"--\\n\";\n\tmemset(dp , -1 , sizeof(dp));\n\tfor(int i = 1 ; i < v.size() ; ++i){\n\t\t//tot = siz3[indexes[0]][indexes[i]];\n\t\tans = (ans + 1LL * solve(0 , i) * pw2[siz3[indexes[0]][indexes[i]]]) % mod;\n\t\t//cout << \"WTF\\n\";\n\t}\n\t//cout << ans << endl;\n}\nvoid pre(){\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tfor(int j = 1 ; j <= n ; ++j){\n\t\t\tif(i == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsiz3[i][j] = 0;\n\t\t\tint qlx = min(arr[i].x , arr[j].x);\n\t\t\tint qrx = max(arr[i].x , arr[j].x);\n\t\t\tint qly = min(arr[i].y , arr[j].y);\n\t\t\tint qry = max(arr[i].y , arr[j].y);\n\t\t\tfor(int k = 1 ; k <= n ; ++k){\n\t\t\t\tif(k != i && k != j){\n\t\t\t\t\tif(arr[k].x >= qlx && arr[k].x <= qrx && arr[k].y >= qly && arr[k].y <= qry && orient(arr[i] , arr[k] , arr[j]) == 0){\n\t\t\t\t\t\t++siz3[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tfor(int j = i + 1 ; j <= n ; ++j){\n\t\t\tfor(int k = j + 1 ; k <= n ; ++k){\n\t\t\t\tint res = 0;\n\t\t\t\tfor(int l = k + 1 ; l <= n ; ++l){\n\t\t\t\t\tres += inside(arr[i] , arr[j] , arr[k] , arr[l]);\n\t\t\t\t}\n\t\t\t\tsiz2[i][j][k] = siz2[i][k][j] = siz2[j][i][k] = siz2[j][k][i] = siz2[k][i][j] = siz2[k][j][i] = res;\n\t\t\t}\n\t\t}\n\t}\n\tmp.clear();\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tmp[arr[i]] = i;\n\t}\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tarr[i].read();\n\t}\n\tans = 0;\n\tpw2[0] = 1;\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tpw2[i] = (2LL * pw2[i - 1]) % mod;\n\t}\n\tpre();\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tsolve(i);\n\t}\n\tprintf(\"%d\\n\" , ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N=210,Mod=998244353;\n\nstruct Point{\n\tint x,y;\n\tPoint(int x=0,int y=0):x(x),y(y) {}\n\tPoint operator - ( const Point &A ) const { return Point(x-A.x,y-A.y); }\n\tPoint operator / ( const int &p ) const { return Point(x/p,y/p); }\n\tbool operator == ( const Point &A ) const { return x==A.x && y==A.y; }\n\tbool operator < ( const Point &A ) const { return x<A.x || ( x==A.x && y<A.y); }\n}p[N],q[N];\ntypedef Point Vector;\n\nint n,qp2[N];\n\nvoid Init() {\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i) scanf(\"%d%d\",&p[i].x,&p[i].y);\n}\n\nint gcd(int a,int b) { return (!b)?a:gcd(b,a%b); }\n\nVector C(const Vector &a) { return a/gcd(a.x,a.y); }\n\nvoid Solve() {\n\tint ans=1; \n\tqp2[0]=1; for (int i=1;i<=n;++i) qp2[i]=(qp2[i-1]<<1)%Mod,ans=(ans<<1)%Mod;\n\tans--; ans-=n;\n\tstd::sort(p+1,p+n+1);\n\tfor (int i=1;i<=n;++i) {\n\t\tint t=0;\n\t\tfor (int j=i+1;j<=n;++j) \n\t\t\tq[++t]=C(p[j]-p[i]);\n\t\tstd::sort(q+1,q+t+1);\n\t\tfor (int h=1;h<=t;) {\n\t\t\tint p=h; while (q[p]==q[h] && h<=t) ++h;\n\t\t\tans=(0ll+ans-(qp2[h-p]-1)+Mod)%Mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<998244353> mint;\nint gcd(int a, int b) { return a ? gcd(b%a, a) : b; }\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\nint N, X[202], Y[202];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) cin >> X[i] >> Y[i];\n\n    mint ans = mint(2)^N;\n\n    // no point\n    ans = ans - 1;\n\n    // one point\n    ans = ans - N;\n\n    // line points\n    map<pair<int, int>, vector<pair<int,int>>> m;\n    rep(i, 0, N) rep(j, i + 1, N) {\n        int dx = X[j] - X[i];\n        int dy = Y[j] - Y[i];\n        if (dx < 0) {\n            dx *= -1;\n            dy *= -1;\n        }\n\n        if (dx == 0) m[{101010, X[i]}].push_back({ i, j });\n        else if (dy == 0) m[{Y[i], 101010}].push_back({ i, j });\n        else {\n            int g = gcd(dx, abs(dy));\n            dx /= g;\n            dy /= g;\n            m[{dy, dx}].push_back({ i, j });\n        }\n    }\n\n    fore(p, m) {\n        auto v = p.second;\n        set<int> s;\n        fore(q, v) {\n            s.insert(q.first);\n            s.insert(q.second);\n        }\n\n        int n = s.size();\n        mint delta = (mint(2) ^ n) - 1 - n;\n        //cout << delta << endl;\n        ans -= delta;\n    }\n\n    cout << ans << endl;\n    //cout << (mint(2) ^ 2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\nstruct pos\n{\n    int x, y;\n};\n\npos arr[200];\nbool chk[200][200];\n\nconst int mod = 998244353;\nint exp(int a, int x)\n{\n    if(x == 0)\n        return 1;\n    if(x%2)\n        return 1LL * exp(a, x-1) * a % mod;\n    int t = exp(a, x/2);\n    return 1LL * t * t % mod;\n}\n\nint fac[201];\nint caf[201];\ninline int ncr(int n, int r)\n{\n    return 1LL * fac[n] * caf[r] % mod * caf[n-r] % mod;\n}\n\nvector<int> tmp;\n\nint main()\n{\n    //freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n\n    int n, x, y, r, t, i, j, k;\n    scanf(\"%d\", &n);\n    for(i = 0; i<n; i++)\n    {\n        scanf(\"%d%d\", &x, &y);\n        arr[i] = { x, y };\n    }\n\n    fac[0] = 1;\n    for(i = 1; i<=200; i++)\n        fac[i] = 1LL * fac[i-1] * i % mod;\n\n    for(i = 0; i<=200; i++)\n        caf[i] = exp(fac[i], mod-2);\n    \n    r = 0;\n    for(i = 3; i<=n; i++)\n        r += ncr(n, i);\n\n    for(i = 0; i<n-1; i++)\n    {\n        for(j = i+1; j<n; j++)\n        {\n            if(chk[i][j] || chk[j][i])\n                continue;\n\n            tmp.clear();\n\n            tmp.push_back(i);\n            tmp.push_back(j);\n\n            t = 2;\n            for(k = 0; k<n; k++)\n            {\n                if(k == i || k == j)\n                    continue;\n\n                if((arr[i].y - arr[j].y) * (arr[i].x - arr[k].x) != (arr[i].x - arr[j].x) * (arr[i].y - arr[k].y))\n                    continue;\n\n                tmp.push_back(k);\n                t++;\n            }\n\n            for(int ii = 0; ii<(int)tmp.size()-1; ii++)\n                for(int jj = ii+1; jj<tmp.size(); jj++)\n                    chk[ii][jj] = 1;\n\n            for(k = 3; k<=t; k++)\n                r -= ncr(t, k);\n        }\n    }\n\n    printf(\"%d\\n\", r);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define rep1(i, n) for(int i = 1; i <= (n); ++i)\n#define ms(x, v) memset(x, v, sizeof(x))\nusing namespace std;\nconst int N = 205, MOD = 998244353;\npair<int, int> s[N];\nint operator ^ (pair<int, int> a, pair<int, int> b)\n{\n\treturn a.first * b.second - a.second * b.first;\n}\npair<int, int> operator - (pair<int, int> a, pair<int, int> b)\n{\n\treturn make_pair(a.first - b.first, a.second - b.second);\n}\nvoid add(int &a, int b) { a = (a + b) % MOD; }\nint pw[N];\nint main()\n{\n#ifdef LOCAL\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\tios::sync_with_stdio(0), cin.tie(0);\n\tint n;\n\tcin >> n;\n\trep1(i, n) cin >> s[i].first >> s[i].second;\n\tpw[0] = 1;\n\trep1(i, n) pw[i] = pw[i - 1] * 2 % MOD;\n\tint ans = pw[n];\n\tadd(ans, MOD - 1);\n\tadd(ans, MOD - n);\n\trep1(i, n)\n\t{\n\t\trep1(j, n)\n\t\t{\n\t\t\tif (s[i] < s[j])\n\t\t\t{\n\t\t\t\tint cnt = 0;\n\t\t\t\trep1(k, n)\n\t\t\t\t{\n\t\t\t\t\tif (s[i] < s[k] && s[j] < s[k] && ((s[i] - s[k]) ^ (s[j] - s[k])) == 0) cnt++;\n\t\t\t\t}\n\t\t\t\tadd(ans, MOD - pw[cnt]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353;\nint n;\nll pw[210],ans=0;\nstruct node{int x,y;\n}p[210];\nbool check(node a,node b,node c)\n{ return (b.x-a.x)*(c.y-a.y)==(b.y-a.y)*(c.x-a.x);}\nvoid link(int x,int y){x+=y;}\nint main()\n{\n    link(0,1);\n    scanf(\"%d\",&n);\n    pw[0]=1;\n    for (int i=1;i<=n;i++) pw[i]=(pw[i-1]<<1)%mod;    \n    for (int i=1;i<=n;i++) scanf(\"%d%d\",&p[i].x,&p[i].y);\n    \n    ans=(pw[n]-n-1+mod)%mod;bool _is;int cnt;\n    for (int i=1;i<n;i++) \n        for (int j=i+1;j<=n;j++)\n        {\n            _is=1;\n            for (int k=1;k<i;k++) if (check(p[k],p[i],p[j])) {_is=0;break;}\n            for (int k=i+1;k<j;k++) if (check(p[k],p[i],p[j])) {_is=0;break;}\n            if (!_is) continue;\n            cnt=2;\n            for (int k=j+1;k<=n;k++) if (check(p[k],p[i],p[j])) cnt++;\n            ans=(ans-pw[cnt]+cnt+1+mod)%mod;\n        }\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nstruct Comb {\n    int N;\n    vector<mint> fac, ifac, inv;\n\n    Comb(int _n=1) {\n        resize(2);\n        fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;\n        N = 1; grow(_n);\n    }\n\n    void resize(int _s) {\n        fac.resize(_s); ifac.resize(_s); inv.resize(_s);\n    }\n    bool grow(int _n) {\n        if (_n <= N) return false;\n        swap(_n, N); resize(N+1);\n        for (int i = _n+1; i <= N; i++) {\n            fac[i] = fac[i-1] * i;\n            inv[i] = (-MOD/i) * inv[MOD%i];\n            ifac[i] = ifac[i-1] * inv[i];\n        }\n        return true;\n    }\n    // perm\n    mint a(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k];\n    }\n    // choose\n    mint c(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k] * ifac[k];\n    }\n\n}c(300);\n\nstruct Point {\n    int x, y;\n    Point() {}\n    Point(int _x, int _y) : x(_x), y(_y) {}\n};\n\nbool colinear(Point& a, Point& b, Point& c) {\n    int dx = a.x-b.x;\n    int dy = a.y-b.y;\n    int du = a.x-c.x;\n    int dv = a.y-c.y;\n    return dx*dv == dy*du;\n}\n\nvoid solve() {\n    int n; cin >> n;\n    vector<Point> a(n);\n    for (int i = 0; i < n; i++) {\n        int x,y;\n        cin >> x >> y;\n        a[i] = {x,y};\n    }\n    mint co = n + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            int cnt = 0;\n            for (int k = 0; k < n; k++) {\n                if (colinear(a[i],a[j],a[k])) cnt++;\n            }\n            mint ge2 = mint(2).exp(cnt) - (cnt+1);\n            mint rep = c.c(cnt, 2);\n            co += ge2/rep;\n        }\n    }\n    mint res = mint(2).exp(n) - co;\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n//#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n) {\n\treturn std::vector<std::vector<T>>(n);\n}\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) res *= n, res %= mod;\n\t\tn *= n; n %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\nbool used[202][202];\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tVEC_ROW(int, n, x, y);\n\n\tauto dist = [&](int i, int j) {\n\t\treturn std::hypotl(x[i] - x[j], y[i] - y[j]);\n\t};\n\n\tint ans = powMod(2, n, MOD) - 1 - n;\n\tans %= MOD; ans += MOD; ans %= MOD;\n\tREP(i, n) used[i][i] = true;\n\tREP(i, n) FOR(j, i+1, n) {\n\t\tif (used[i][j]) continue;\n\t\tstd::vector<int> vec;\n\t\tREP(k, n) {\n\t\t\tif ((x[k] - x[i]) * (y[j] - y[i]) == (x[j] - x[i]) *(y[k] - y[i])) {\n\t\t\t\tvec.emplace_back(k);\n\t\t\t}\n\t\t}\n\t\tint cnt = vec.size();\n\t\tREP(ii, vec.size()) REP(jj, vec.size()) {\n\t\t\tused[ii][jj] = true;\n\t\t}\n\t\tans -= powMod(2, cnt, MOD) - cnt - 1;\n\t\tans %= MOD; ans += MOD; ans %= MOD;\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=998244353;\n\nint N;\nvpint P;\n\nint po[222];\n\nsigned main(){\n    po[0]=1;\n    for(int i=1;i<222;i++)po[i]=po[i-1]*2%mod;\n    cin>>N;\n    rep(i,N){\n        int x,y;\n        cin>>x>>y;\n        P.pb({x,y});\n    }\n    sort(all(P));\n\n    int ans=po[N];\n    ans=(ans-1+mod)%mod;\n    ans=(ans-N+mod)%mod;\n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<N;j++){\n            int dx=P[j].fi-P[i].fi;\n            int dy=P[j].se-P[i].se;\n\n            int cnt=0;\n            for(int k=j+1;k<N;k++){\n                int dxx=P[k].fi-P[i].fi;\n                int dyy=P[k].se-P[i].se;\n\n                if(dy*dxx!=dx*dyy)continue;\n                cnt++;\n            }\n            ans=(ans-po[cnt]+mod)%mod;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) > 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<point> ns;\n        for (int j = 0; j < n; j++) {\n            if (j == i) {\n                continue;\n            }\n            if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {\n                need[j] = true;\n                ns.push_back(p[j]);\n            } else {\n                need[j] = false;\n            }\n        }\n        cur = p[i];\n        sort(all(ns), comp);\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                goods[j][k] = false;\n                cnt[j][k] = 0;\n                dp[j][k] = 0;\n                if (good(p[i], ns[j], ns[k])) {\n                    goods[j][k] = true;\n                    for (int g = 0; g < sz(ns); g++) {\n                        if (g == j || g == k) {\n                            continue;\n                        }\n                        if (inside(p[i], ns[j], ns[k], ns[g])) {\n                            cnt[j][k]++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (goods[j][k]) {\n                    dp[j][k] += st[cnt[j][k]];\n                    dp[j][k] %= Mod;\n                    ans += dp[j][k];\n                    ans %= Mod;\n                    for (int nxt = k + 1; nxt < sz(ns); nxt++) {\n                        if (vec(ns[nxt] - ns[j], ns[k] - ns[j]) < 0 && goods[k][nxt] && vec(ns[nxt] - p[i], ns[k] - p[i]) != 0) {\n                            dp[k][nxt] += dp[j][k];\n                            if (dp[k][nxt] >= Mod) {\n                                dp[k][nxt] %= Mod;\n                            }\n                        }\n                    }\n                }   \n            }\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vdouble = vector<double>;\nusing vvdouble = vector<vdouble>;\nusing vvvdouble = vector<vvdouble>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\nconstexpr int mod2 = 998244353;\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) { return (a > b && (a = b, true)); }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) { return (a < b && (a = b, true)); }\ntemplate<typename T>\nbool isin(T y, T x, T h, T w) { return (0 <= y && 0 <= x && y < h && x < w); }\ntemplate<typename T>\nbool isin1(T y, T x, T h, T w) { return (0 < y && 0 < x && y <= h && x <= w); }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++) os << \" \" << v[i];\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nconstexpr double EPS = 1e-10;\nconstexpr int COUNTER_CLOCKWISE = 1;\nconstexpr int CLOCKWISE = -1;\nconstexpr int ONLINE_BACK = 2;\nconstexpr int ONLINE_FRONT = -2;\nconstexpr int ON_SEGMENT = 0;\n\nbool equals(double a, double b) { return (abs(a - b) < EPS); }\n\nstruct V2 {\n\tdouble x, y;\n\tV2(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tV2 operator + (V2 p) const { return (V2(x + p.x, y + p.y)); }\n\tV2 operator - (V2 p) const { return (V2(x - p.x, y - p.y)); }\n\tV2 operator * (double r) const { return (V2(x * r, y * r)); }\n\tV2 operator / (double r) const { return (V2(x / r, y / r)); }\n\n\tdouble norm() const { return (sqrt(sqrNorm())); }\n\tdouble sqrNorm() const { return (x*x + y*y); }\n\n\tbool operator < (const V2 &p) const { \n\t\treturn (x != p.x ? x < p.x : y < p.y); \n\t}\n\tbool operator == (const V2 &p) const {\n\t\treturn (equals(x, p.x) && equals(y, p.y));\n\t}\n\n\tV2 rotate90() const { return (V2(y, -x)); }\n\tV2 normalized() const { return (*this / norm()); }\n\n\tdouble dot(const V2 &p) const { return (x*p.x + y*p.y); }\n\tdouble cross(const V2 &p) const { return (x*p.y - y*p.x); }\n\tdouble arg() const { return (atan2(y, x)); }\n};\n\nV2 polar(double r, double a) { return (V2(cos(a) * r, sin(a) * r)); }\n\n\nvoid Main() {\n\tll N; cin >> N;\n\tvector<V2> ps(N);\n\tll pow2[205];\n\n\tpow2[0] = 1;\n\tfor (int i = 1; i < 205; i++) {\n\t\tpow2[i] = (pow2[i-1] * 2) % mod2;\n\t}\n\n\tfor (auto &p : ps) {\n\t\tcin >> p.x >> p.y;\n\t}\n\t\n\tll ans = (mod2 + pow2[N] - N - 1) % mod2;\n\n\tbool flag[205][205] = {};\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i+1; j < N; j++) {\n\t\t\tif (flag[i][j]) continue;\n\t\t\tint cnt = 0;\n\t\t\tV2 a = ps[j]-ps[i];\n\t\t\tbool f = false;\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (i == k) { cnt++; continue; }\n\t\t\t\tV2 b = ps[k]-ps[i];\n\t\t\t\tif (equals(a.cross(b), 0)) {\n\t\t\t\t\tif (flag[i][k] || flag[k][i]) {\n\t\t\t\t\t\tf = true; break;\n\t\t\t\t\t}\n\t\t\t\t\tcnt++;\n\t\t\t\t\tflag[i][k] = flag[j][k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll val = (mod2 + pow2[cnt] - cnt - 1) % mod2;\n\t\t\tif (!f) (ans += mod2 - val) %= mod2;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nll am, n;\npair<ll, ll> points[300];\nbool colin(int a, int b, int c)\n{\n\tif (points[a].first == points[b].first && points[b].first == points[c].first) return true;\n\tld first = ((ld)points[a].second-points[b].second)/(points[a].first-points[b].first);\n\tld second = ((ld)points[a].second-points[c].second)/(points[a].first-points[c].first);\n\treturn first == second;\n}\nbool done[500][500];\nint main()\n{\n\tam = 1;\n\tll mod = 998244353L*1000;\n\tll mod2 = 998244353L;\n\tscanf(\"%lld\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld%lld\", &points[i].first, &points[i].second);\n\t\tam*=2;\n\t\tam%=mod;\n\t}\n\tam-=n+1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i+1; j < n; j++)\n\t\t{\t\t\t\n\t\t//\tprintf(\"%d %d %Lf %Lf\\n\", i, j, m, c);\n\t\t\tll am2 = 4;\n\t\t\tll in = 2;\n\t\t\tint smallest = i;\n\t\t\tint smallest2 = j;\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t{\n\t\t\t\tif (colin(i, j, k) && i != k && j != k)\n\t\t\t\t{\n\t\t\t\t\tam2*=2;\n\t\t\t\t\tam2%=mod2*2;\n\t\t\t\t\tin++;\n\t\t\t\t\tif (k < smallest)\n\t\t\t\t\t{\n\t\t\t\t\t\tsmallest2 = smallest;\n\t\t\t\t\t\tsmallest = k;\n\t\t\t\t\t}\n\t\t\t\t\telse smallest2 = min(smallest2, k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (done[smallest][smallest2]) continue;\n\t\t\tdone[smallest][smallest2] = true;\n\t\t\tam2-=in+1;\n\t\t\tam-=am2%(mod2);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", am%(mod2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef pair<int,int> pa;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\nconst int N=1e5+5,M=5e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint n;\nstruct P{\n\tint x,y;\n\til P(){}\n\til P(int x,int y):x(x),y(y){}\n\til bool operator<(const P&o)const{if(x==o.x)return y<o.y;return x<o.x;}\n\til int operator*(const P&o)const{return x*o.y-y*o.x;}\n\til P operator-(const P&o)const{return P(x-o.x,y-o.y);}\n}p[N];\nll pw[N];\nil int bad(int i,int j,int k){\n\tif((p[j]-p[i])*(p[k]-p[i])==0)return 1;\n\treturn 0;\n}\nint main(){\n\tread(n);rep(i,1,n)read(p[i].x,p[i].y);\n\tpw[0]=1;rep(i,1,n)pw[i]=pw[i-1]*2%mod;\n\tsort(p+1,p+1+n);\n\tll qaq=0;\n\trep(i,1,n)rep(j,i+1,n){\n\t\tint ok=1;\n\t\trep(k,1,j)\n\t\t\tif(k!=i&&k!=j)\n\t\t\t\tif(bad(i,j,k))ok=0;\n\t\tif(ok){\n\t\t\tint res=2;\n\t\t\trep(k,j+1,n)res+=bad(i,j,k);\n\t\t\tqaq+=pw[res]-res-1;\n\t\t}\n\t}\n\tqaq=pw[n]-qaq-n-1;\n\tcout<<qaq<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\nint gcd(int a, int b) { return a ? gcd(b%a, a) : b; }\ntypedef long long ll;\nll mod = 998244353LL;\nll add(ll x, ll y) { return (x += y) >= mod ? x - mod : x; }\nll sub(ll x, ll y) { return add(x, mod - y); }\nll modpow(ll a, ll b) {\n    ll ret = 1; while (b > 0) {\n        if (b & 1) ret = ret * a % mod; a = a * a % mod; b >>= 1;\n    } return ret;\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\nint N, X[202], Y[202];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) cin >> X[i] >> Y[i];\n\n    ll ans = modpow(2, N);\n\n    // no point\n    ans = sub(ans, 1);\n\n    // one point\n    ans = sub(ans, N);\n\n    // line points\n    map<pair<int, int>, vector<pair<int,int>>> m;\n    rep(i, 0, N) rep(j, i + 1, N) {\n        int dx = X[j] - X[i];\n        int dy = Y[j] - Y[i];\n        if (dx < 0) {\n            dx *= -1;\n            dy *= -1;\n        }\n\n        if (dx == 0) m[{101010, X[i]}].push_back({ i, j });\n        else if (dy == 0) m[{Y[i], 101010}].push_back({ i, j });\n        else {\n            int g = gcd(dx, abs(dy));\n            dx /= g;\n            dy /= g;\n            m[{dy, dx}].push_back({ i, j });\n        }\n    }\n\n    fore(p, m) {\n        auto v = p.second;\n        set<int> s;\n        fore(q, v) {\n            s.insert(q.first);\n            s.insert(q.second);\n        }\n\n        int n = s.size();\n        ll delta = sub(modpow(2, n), add(1, n));\n        //cout << delta << endl;\n        ans = sub(ans, delta);\n    }\n\n    cout << ans << endl;\n    //cout << (mint(2) ^ 2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nstruct point{\n\tint x , y;\n\tpoint(int _x = 0 , int _y = 0){\n\t\tx = _x;\n\t\ty = _y;\n\t}\n\tpoint operator + (const point &other) const {\n\t\treturn point(x + other.x , y + other.y);\n\t}\n\tpoint operator - (const point &other) const {\n\t\treturn point(x - other.x , y - other.y);\n\t}\n\tbool operator < (const point &other) const {\n\t\tif(x == other.x){\n\t\t\treturn y < other.y;\n\t\t}\n\t\treturn x < other.x;\n\t}\n\tvoid read(){\n\t\tscanf(\"%d %d\" , &x , &y);\n\t}\n};\ninline int dot(point a , point b){\n\treturn a.x * b.x + a.y * b.y;\n}\ninline int cross(point a , point b){\n\treturn a.x * b.y - a.y * b.x;\n}\ninline int orient(point a , point b , point c){//orientation of point c with respect to line from a -> b\n\tint val = cross(b - a , c - a);\n\tif(val > 0){\n\t\treturn 1;//c comes anticlockwise on line from a -> b\n\t}\n\tif(val < 0){\n\t\treturn -1;//c comes clockwise on line from a -> b\n\t}\n\treturn 0;//c is collinear with line from a -> b\n}\nint dist(point a , point b){\n\treturn dot(a - b , a - b);\n}\nconst int N = 205;\nconst int mod = 998244353;\nconst int inv = 499122177;\nint pw2[N];\nint n;\npoint arr[N];\nvector < point > v;\npoint bottom;\nint ans;\nbool cmp(point a , point b){\n\tint tmp = orient(bottom , a , b);\n\tif(tmp == -1){\n\t\treturn 1;\n\t}\n\tif(tmp == 1){\n\t\treturn 0;\n\t}\n\treturn dist(bottom , a) < dist(bottom , b);\n}\nbool inside(point p1 , point p2 , point p3 , point q){\n\tint o1 = orient(p1 , p2 , q);\n\tint o2 = orient(p2 , p3 , q);\n\tint o3 = orient(p3 , p1 , q);\n\treturn (o1 == o2) && (o2 == o3) && (o3 != 0);\n}\nint siz2[N][N][N];\nint siz3[N][N];\nmap < point , int > mp;\nvector < int > indexes;\n//int tot;\nint dp[N][N];\nint solve(int last1 , int last2){\n\tif(dp[last1][last2] != -1){\n\t\treturn dp[last1][last2];\n\t}\n\tint res = !!last1;\n\t/*if(last1){\n\t\tcout << tot << \" \";\n\t}*/\n\tfor(int i = last2 + 1 ; i < v.size() ; ++i){\n\t\tif(orient(v[last1] , v[last2] , v[i]) == -1){\n\t\t\t//tot += siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0);\n\t\t\tres = (res + 1LL * solve(last2 , i) * pw2[siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0) + siz3[indexes[last2]][indexes[i]]]) % mod;\n\t\t\t//tot -= siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0);\n\t\t}\n\t}\n\treturn dp[last1][last2] = res;\n}\nvoid solve(int idx){\n\tv.clear();\n\tbottom.x = arr[idx].x;\n\tbottom.y = arr[idx].y;\n\tv.emplace_back(arr[idx]);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tif(arr[i].y > bottom.y){\n\t\t\tv.emplace_back(arr[i]);\n\t\t}\n\t\telse if(arr[i].y == bottom.y && arr[i].x > bottom.x){\n\t\t\tv.emplace_back(arr[i]);\n\t\t}\n\t}\n\tsort(v.begin() + 1 , v.end() , cmp);\n\tindexes.clear();\n\tfor(int i = 0 ; i < v.size() ; ++i){\n\t\tindexes.emplace_back(mp[v[i]]);\n\t}\n\t//cout << v.size() << \"--\\n\";\n\tmemset(dp , -1 , sizeof(dp));\n\tfor(int i = 1 ; i < v.size() ; ++i){\n\t\t//tot = siz3[indexes[0]][indexes[i]];\n\t\tans = (ans + 1LL * solve(0 , i) * pw2[siz3[indexes[0]][indexes[i]]]) % mod;\n\t\t//cout << \"WTF\\n\";\n\t}\n\t//cout << ans << endl;\n}\nvoid pre(){\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tfor(int j = 1 ; j <= n ; ++j){\n\t\t\tif(i == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsiz3[i][j] = 0;\n\t\t\tint qlx = min(arr[i].x , arr[j].x);\n\t\t\tint qrx = max(arr[i].x , arr[j].x);\n\t\t\tint qly = min(arr[i].y , arr[j].y);\n\t\t\tint qry = max(arr[i].y , arr[j].y);\n\t\t\tfor(int k = 1 ; k <= n ; ++k){\n\t\t\t\tif(k != i && k != j){\n\t\t\t\t\tif(arr[k].x >= qlx && arr[k].x <= qrx && arr[k].y >= qly && arr[k].y <= qry && orient(arr[i] , arr[k] , arr[j]) == 0){\n\t\t\t\t\t\t++siz3[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tfor(int j = i + 1 ; j <= n ; ++j){\n\t\t\tfor(int k = j + 1 ; k <= n ; ++k){\n\t\t\t\tint res = 0;\n\t\t\t\tfor(int l = k + 1 ; l <= n ; ++l){\n\t\t\t\t\tres += inside(arr[i] , arr[j] , arr[k] , arr[l]);\n\t\t\t\t}\n\t\t\t\tsiz2[i][j][k] = siz2[i][k][j] = siz2[j][i][k] = siz2[j][k][i] = siz2[k][i][j] = siz2[k][j][i] = res;\n\t\t\t}\n\t\t}\n\t}\n\tmp.clear();\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tmp[arr[i]] = i;\n\t}\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tarr[i].read();\n\t}\n\tans = 0;\n\tpw2[0] = 1;\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tpw2[i] = (2LL * pw2[i - 1]) % mod;\n\t}\n\tpre();\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tsolve(i);\n\t}\n\tprintf(\"%d\\n\" , ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nbool on_the_line(pll &a, pll &b, pll &c){\n    return ((a.first - c.first)*(b.second-c.second)-(a.second-c.second)*(b.first-c.first)==0);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    pll points[N];\n    REP(i, N){\n        cin >> points[i].first >> points[i].second;\n    }\n    int did[N][N] = {};\n\n    ll pow2[N+2];\n    pow2[0] = 1;\n    for(int i=1;i<N+2;i++){\n        pow2[i] = (2*pow2[i-1])%mod;\n    }\n\n    ll res = pow2[N];\n    res = (res+mod-1)%mod;\n    res = (res+mod-N)%mod;\n\n    for(int i=0;i<N;i++){\n        for (int j=i+1;j<N;j++){\n            if(did[i][j]==0){\n                vector<int> tmp;\n                tmp.push_back(i);\n                tmp.push_back(j);\n                for(int k=j+1;k<N;k++){\n                    if(on_the_line(points[i], points[j], points[k])){\n                        tmp.push_back(k);\n                    }\n                }\n                REP(p, tmp.size()) REP(q, tmp.size()) did[p][q] = 1;\n                int s = tmp.size();\n                res = (res+mod-pow2[s]+1+s)%mod;\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<bitset>\n#include<map>\nusing namespace std;\ntemplate<typename __T>\ninline void read(__T &x)\n{\n    x=0;\n    int f=1;char c=getchar();\n    while(!isdigit(c)){if(c=='-')\tf=-1;c=getchar();}\n    while(isdigit(c))\t{x=x*10+c-'0';c=getchar();}\n    x*=f;\n}\nconst int mod=998244353;\nint n;\nint x[205],y[205];\nlong long pow2[205];\nint main()\n{\n\tread(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tread(x[i]);\n\t\tread(y[i]);\n\t}\n\tpow2[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tpow2[i]=pow2[i-1]*2%mod;\n\tlong long ans=(pow2[n]-1-n+mod)%mod;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\t\tif((y[k]-y[j])*(x[j]-x[i])==(y[j]-y[i])*(x[k]-x[j]))\n\t\t\t\t\tcnt++;\n\t\t\tans=(ans+mod-pow2[cnt])%mod;\n\t\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//pragma\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define YOU using\n#define DONT namespace\n#define SAY std\n\nYOU DONT SAY;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n\n#define REPP(i,a,b,d) for(int i=a;i<=b;i+=d)\n#define REP(i,a,b) REPP(i,a,b,1)\n#define REVV(i,a,b,d) for(int i=a;i>=b;i-=d)\n#define REV(i,a,b) REVV(i,a,b,1)\n\n#define FOR(i,a) for(int i=0; i<a; i++)\n#define FORD(i,a) for(int i=(int)a-1; i>=0; i--)\n\n#define pb push_back\n#define F first\n#define S second\n\nconst int OO = 1e9;\nconst ll INF = 1e18;\n\nconst int irand(int lo,int hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\nconst ll lrand(ll lo,ll hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\n#define getc getchar\ntemplate<typename T>\nT getnum(){\n\tint sign = 1;\n\tT ret = 0;\n\tchar c;\n\n\tdo{\n\t\tc = getc();\n\t}while(c == ' ' || c == '\\n');\n\tif(c == '-')sign = -1;\n\telse ret = c-'0';\n\twhile(1){\n\t\tc = getc();\n\t\tif(c < '0' || c > '9')break;\n\t\tret = 10*ret + c-'0';\n\t}\n\treturn sign * ret;\n}\n\ninline void ini(int& x){\n\tx = getnum<int>();\n}\n\ninline void scani(int& x){\n\tscanf(\"%d\",&x);\n}\n\n//end of macro\n\nconst ll MOD = 998244353;\n\ninline ll addmod(ll a, ll b){\n    if(a+b < MOD)return a+b;\n    return a+b-MOD;\n}\ninline ll submod(ll a, ll b){\n\treturn addmod(a, MOD-b);\n}\ninline ll mulmod(ll a, ll b){\n    return (a*b)%MOD;\n}\ninline ll expmod(ll a, ll e){\n    ll ret = 1;\n    while(e){\n        if(e&1)ret = mulmod(ret, a);\n        a = mulmod(a, a);\n        e >>= 1;\n    }\n    return ret;\n}\n\nconst int N = 205;\n\nint n;\nint x[N], y[N];\nbool used[N];\n\nint piv;\nvi pts;\nint cross(int a, int b, int c){\n    return (x[b]-x[a]) * (y[c]-y[a]) - (y[b]-y[a]) * (x[c]-x[a]);\n}\nint dist2(int a, int b){\n    return (x[a]-x[b])*(x[a]-x[b]) + (y[a]*y[b])*(y[a]*y[b]);\n}\nbool cmp(int a, int b){\n    if(cross(piv, a, b) == 0)return dist2(piv, a) < dist2(piv, b);\n    return cross(piv, a, b) > 0;\n}\n\nint bitt[N];\nvoid update(int x, int v){\n    REPP(i,x,N-1,i&-i)bitt[i] += v;\n}\nint query(int x){\n    int ret = 0;\n    REVV(i,x,1,i&-i)ret += bitt[i];\n    return ret;\n}\n\nint arr[N];\nint dp[N];\nint receive[N][N]; // receive[i][j] means the current value received by i from j\nint tidx[N];\nvi pts2;\nint solve(int sz){\n//    printf(\"-------------  solve %d  ------------------\\n\",sz);\n    arr[1] = piv;\n    REP(i,2,sz)arr[i] = pts[i-2];\n    \n//    printf(\"points\\n\");\n//    REP(i,1,sz)printf(\"%d %d\\n\",x[arr[i]], y[arr[i]]);\n    \n    int ret = 0;\n    REP(i,2,sz){\n//    \tprintf(\">>> processing %d\\n\",i);\n        dp[i] = 0;\n        receive[arr[i]][arr[1]] = 1; // start new\n        \n        // extend : j --- i\n        piv = arr[i];\n        pts.clear(); pts2.clear();\n        REV(j,i-1,1){\n            pts.pb(arr[j]);\n        }\n        REP(j,i+1,sz){\n        \tpts2.pb(arr[j]);\n\t\t}\n        sort(pts.begin(), pts.end(), cmp);\n        sort(pts2.begin(), pts2.end(), cmp);\n        FOR(i,pts.size()){\n            tidx[pts[i]] = i+1;\n        }\n        memset(bitt, 0, sizeof bitt);\n        // add the points to receive[i][j]\n        REV(j,i-1,1){\n            int inside = query(tidx[arr[j]]);\n            update(tidx[arr[j]], 1);\n            //if(cross(arr[1], arr[i], arr[j]) == 0)continue; // cannot extend from co-linear\n            //dp[i] = addmod(dp[i], mulmod(dp[j], expmod(2, inside)));\n            receive[arr[i]][arr[j]] = mulmod(receive[arr[i]][arr[j]], expmod(2, inside));\n        }\n        \n        // fill dp and the receive of the next points\n        int p = 0; // pointer for pts\n\t\tFOR(j,pts2.size()){\n        \twhile(p < pts.size() && cross(pts[p], arr[i], pts2[j]) > 0){\n        \t\tdp[i] = addmod(dp[i], receive[arr[i]][pts[p]]);\n//        \t\tprintf(\"received %d %d <- %d %d, %d\\n\",x[arr[i]],y[arr[i]],x[pts[p]],y[pts[p]],receive[arr[i]][pts[p]]);\n        \t\tp++;\n\t\t\t}\n\t\t\treceive[pts2[j]][arr[i]] = dp[i];\n//\t\t\tprintf(\"push value %d %d -> %d %d, %d\\n\",x[arr[i]],y[arr[i]],x[pts2[j]],y[pts2[j]],dp[i]);\n\t\t}\n\t\twhile(p < pts.size()){\n\t\t\tdp[i] = addmod(dp[i], receive[arr[i]][pts[p]]);\n//        \tprintf(\"received %d %d <- %d %d, %d\\n\",x[arr[i]],y[arr[i]],x[pts[p]],y[pts[p]],receive[arr[i]][pts[p]]);\n        \tp++;\n\t\t}\n        \n        // close polygon : i --- 1\n        ret = addmod(ret, submod(dp[i], 1));\n        \n//        printf(\"dp %d = %d\\n\",i,dp[i]);\n    }\n//    printf(\"ret %d = %d\\n\",sz,ret);\n    return ret;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    #define endl '\\n'\n    cout.setf(ios::fixed);\n    cout.setf(ios::showpoint);\n    cout.precision(10);\n    \n    cin>>n;\n    REP(i,1,n){\n        cin>>x[i]>>y[i];\n    }\n    \n    int ans = 0;\n    REV(sz,n,3){\n        piv = -1;\n        REP(i,1,n){\n            if(used[i])continue;\n            if(piv == -1 || (y[i] < y[piv]) || (y[i] == y[piv] && x[i] < x[piv]))piv = i;\n        }\n        \n        used[piv] = true;\n        \n        pts.clear();\n        REP(i,1,n){\n            if(used[i])continue;\n            pts.pb(i);\n        }\n        sort(pts.begin(), pts.end(), cmp);\n        \n//        printf(\"pivot %d\\n\",piv);\n//        FOR(i,pts.size())printf(\"%d\\n\",pts[i]);\n        \n        ans = addmod(ans, solve(sz));\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <ctime>\n#include <map>\n#include <set>\n#define x first\n#define y second\n#define MOD 998244353\n#define NMax 202\nusing namespace std;\n\nint N;\nint doi[NMax+1];\nint dp[NMax+1][NMax+1];\nint no[NMax+1][NMax+1];\ntypedef pair<int, int> Point;\nPoint p[NMax+1];\n\nint Arie(Point A, Point B, Point C)\n{\n    return ( (B.x-A.x)*(C.y-A.y) - (B.y-A.y)*(C.x-A.x) ) > 0;\n}\n\nbool inside(Point A, Point B, Point C, Point D)\n{\n    if(D == A || D == B || D == C) return 0;\n    return ( abs( Arie(A,B,D) + Arie(B,D,C) + Arie(D,C,A) ) == abs( Arie(A,B,C) ));\n}\n\nvoid Compute(int i, int j)\n{\n    dp[i][j] = 0;\n    int k,l,cnt=0;\n    for(k = i+1; k <= N; ++k)\n        if(k != j && Arie(p[i], p[j], p[k]))\n        {\n            cnt = 0;\n            if(dp[i][k] < 0) Compute(i,k);\n            for(l = i+1; l <= (p[k].y > p[j].y ? k : j); ++l)\n                if(inside(p[i], p[j], p[k], p[l])) ++cnt;\n            dp[i][j] = (dp[i][j] + 1LL * doi[cnt] * dp[i][k]) % MOD;\n        }\n\n    if(!dp[i][j]) dp[i][j] = 1, no[i][j] = 1;\n}\n\nbool cmp(Point A, Point B)\n{\n    if(A.y == B.y) return A.x < B.x;\n    return A.y < B.y;\n}\n\nint main(){\n\n\n    int i,j,res=0;\n\n    scanf(\"%d\",&N);\n    for(i = 1; i <= N; ++i) scanf(\"%d %d\",&p[i].x,&p[i].y);\n\n    doi[0] = 1;\n    for(i = 1; i <= NMax; ++i) doi[i] = (1LL * 2 * doi[i-1]) % MOD;\n\n    for(i = 1; i <= N; ++i)\n        for(j = i+1; j <= N; ++j)\n        dp[i][j] = -1;\n\n    sort(p+1,p+N+1,cmp);\n\n    for(i = 1; i <= N; ++i)\n        for(j = i+1; j <= N; ++j)\n        if(dp[i][j] < 0) Compute(i,j);\n\n    for(i = 1; i <= N; ++i)\n        for(j = i+1; j <= N; ++j)\n        if(!no[i][j])\n        res = ( res + dp[i][j] ) %  MOD;\n\n    printf(\"%d\\n\",res);\n\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\nint n,m,p,k,ans;\nint ksm(int n,int k){\n\tint ans=1;\n\twhile(k){\n\t\tif(k&1) ans=ans*n%p;\n\t\tn=n*n%p;\n\t\tk>>=1;\n\t}\n\treturn ans%p;\n}\nsigned main(){\n\tscanf(\"%lld%lld%lld%lld\",&n,&k,&m,&p);\n\tn%=p;\n\tans=n*ksm(m,k-1)%p-ksm(m,k-2)*(k-1)%p*(m*(m+1)/2%p)%p;\n\tprintf(\"%lld\",(ans+p)%p);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 210\n#define ll long long\n#define db double\n#define For(i,x,y) for(int i=(x);i<=(y);++i)\n#define Rof(i,x,y) for(int i=(x);i>=(y);--i)\n#define Edge(x) for(int i=head[x];i;i=e[i].nxt)\n#define lson l,mid,o<<1\n#define rson mid+1,r,o<<1|1\n#define mset(x,y) memset(x,y,sizeof(y))\n#define mcpy(x,y) memcpy(x,y,sizeof(x))\n#define p_b push_back\n#define mod 998244353\nusing namespace std;\nll _2[N];\nint x[N],y[N];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);_2[0]=1;\n\tFor(i,1,n) _2[i]=(_2[i-1]+_2[i-1])%mod;\n\tll ans=_2[n]-1-n-n*(n-1)/2;\n\twhile(ans<0) ans+=mod;\n\tFor(i,1,n) scanf(\"%d%d\",&x[i],&y[i]);\n\tFor(i,1,n) For(j,i+1,n){\n\t\tint tmp=0;\n\t\tFor(k,j+1,n) if(1ll*(1ll*y[j]-y[i])*(1ll*x[k]-x[j])==1ll*(1ll*y[k]-y[j])*(1ll*x[j]-x[i])) tmp++;\n\t\t(ans+=mod+1-_2[tmp])%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing lint = long long int;\nusing P = pair<int, int>;\nconstexpr lint MOD = 998244353;\n\nlint power(lint x, lint n, lint mod)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) ans = ans * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return ans;\n}\n\nvector<P> ps;\n\nbool collinear(P p, P q, P r)\n{\n    return (q.second - p.second) * (r.first - p.first) == (q.first - p.first) * (r.second - p.second);\n}\n\nint N;\n\nint main()\n{\n    cin >> N;\n    ps.resize(N);\n    for (int i=0; i<N; i++) cin >> ps[i].first >> ps[i].second;\n\n    lint ans = (power(2LL, (lint)N, MOD) - 1 - N + MOD) % MOD;\n\n    vector<vector<bool> > edge(N, vector<bool>(N, false));\n\n    for (int i=0; i<N; i++)\n    {\n        for (int j=i+1; j<N; j++)\n        {\n            if (edge[i][j]) continue;\n            vector<int> kyosen = {i, j};\n            for (int k=j+1; k<N; k++)\n            {\n                if (collinear(ps[i], ps[j], ps[k])) kyosen.push_back(k);\n            }\n            ans = (ans - power(2LL, (lint)kyosen.size(), MOD) + 1 + kyosen.size() + MOD) % MOD;\n\n            for (int k=0; k<kyosen.size(); k++)\n            {\n                for (int l=k+1; l<kyosen.size(); l++)\n                {\n                    edge[kyosen[k]][kyosen[l]] = edge[kyosen[l]][kyosen[k]] = true;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define MOD 998244353LL\n\nusing namespace std;\ntypedef long long int ll;\n\nint main()\n{\n\tint n;\n\tint x[200], y[200];\n\tscanf(\"%d\", &n);\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t}\n\tvector<int> v[200][200];\n\tint t[200];\n\tfor(int i=0; i<n; i++){\n\t\tt[i]=0;\n\t\tset<int> st;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(j!=i) st.insert(j);\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(st.find(j)==st.end()) continue;\n\t\t\tst.erase(j);\n\t\t\tv[i][t[i]].push_back(i);\n\t\t\tv[i][t[i]].push_back(j);\n\t\t\tfor(int k=j+1; k<n; k++){\n\t\t\t\tif(st.find(k)==st.end()) continue;\n\t\t\t\tif((x[j]-x[i])*(y[k]-y[i])==(x[k]-x[i])*(y[j]-y[i])){\n\t\t\t\t\tv[i][t[i]].push_back(k);\n\t\t\t\t\tst.erase(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[i]++;\n\t\t}\n\t}\n\tmultiset<int> c;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<t[i]; j++){\n\t\t\tint m=v[i][j].size();\n\t\t\tc.insert(m);\n\t\t}\n\t}\n\tll ans=1;\n\tfor(int i=0; i<n; i++){\n\t\tans=ans*2%MOD;\n\t}\n\tans=(ans-(ll)(n*(n+1)/2+1)+MOD)%MOD;\n\tfor(int i=3; i<=n; i++){\n\t\tint m=c.count(i);\n\t\tm/=i;\n\t\tll ans1=1;\n\t\tfor(int j=0; j<i; j++){\n\t\t\tans1=ans1*2%MOD;\n\t\t}\n\t\tans1=(ans1-(ll)(i*(i+1)/2+1)+MOD)%MOD;\n\t\tans1=ans1*(ll)m%MOD;\n\t\tans=(ans-ans1+MOD)%MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ Templates\n#include <bits/stdc++.h>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 998244353LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\n// }}}\n\ninline bool on(ll x0, ll y0, ll x1, ll y1, ll x, ll y)\n{\n    const ll DX = x1 - x0;\n    const ll DY = y1 - y0;\n    const ll dx = x - x0;\n    const ll dy = y - y0;\n    return dx * DY == dy * DX;\n}\n\nll power(const ll p, const ll n)\n{\n    if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 1) {\n        return (power(p, n - 1) * p) % MOD;\n    } else {\n        const ll pp = power(p, n / 2);\n        return (pp * pp) % MOD;\n    }\n}\n\ninline ll calc(const ll n)\n{\n    if (n <= 2) {\n        return 0;\n    }\n    return (((power(2, n) - (n * n + n + 2) / 2) % MOD) + MOD) % MOD;\n}\n\nstruct Line {\n    Line(ll ind_, ll dx_, ll dy_)\n    {\n        ind = ind_;\n        if (dx_ < 0) {\n            dx_ *= -1;\n            dy_ *= -1;\n        } else if (dx_ == 0) {\n            dy_ = 1;\n        }\n        if (dy_ == 0) {\n            dx_ = 1;\n        }\n        dx = dx_;\n        dy = dy_;\n    }\n    ll ind;\n    ll dx;\n    ll dy;\n    bool operator<(const Line& l) const\n    {\n        return (ind != l.ind) ? ind < l.ind : dx * l.dy < dy * l.dx;\n    }\n};\n\nostream& operator<<(ostream& os, const Line& l)\n{\n    os << \"{ind: \" << l.ind << \" dx: \" << l.dx << \" dy:\" << l.dy << \"}\";\n    return os;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    vector<ll> x(N);\n    vector<ll> y(N);\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    map<Line, ll> lines;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                if (k == i or k == j) {\n                    continue;\n                }\n                if (on(x[i], y[i], x[j], y[j], x[k], y[k])) {\n                    const Line ln = Line{min({i, j, k}), x[j] - x[i], y[j] - y[i]};\n                    if (lines.find(ln) == lines.end()) {\n                        lines[ln] = 3;\n                        for (int l = 0; l < N; l++) {\n                            if (l == i or l == j or l == k) {\n                                continue;\n                            }\n                            if (on(x[i], y[i], x[j], y[j], x[l], y[l])) {\n                                lines[ln]++;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    ll sum = calc(N);\n    for (const auto& e : lines) {\n        show(e);\n        sum -= calc(e.second);\n        sum = ((sum % MOD) + MOD) % MOD;\n    }\n    cout << sum << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) < 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\nint adds[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<point> ns;\n        for (int j = 0; j < n; j++) {\n            if (j == i) {\n                continue;\n            }\n            if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {\n                need[j] = true;\n                ns.push_back(p[j]);\n            } else {\n                need[j] = false;\n            }\n        }\n        cur = p[i];\n        sort(all(ns), comp);\n        for (int j = 0; j < sz(ns); j++) {\n            adds[j] = 0;\n            for (int k = 0; k < sz(ns); k++) {\n                if (j == k) {\n                    continue;\n                }\n                if (vec(ns[k] - p[i], ns[j] - p[i]) == 0 && (ns[k].x - cur.x) * (ns[k].x - cur.x) + (ns[k].y - cur.y) * (ns[k].y - cur.y) < (ns[j].x - cur.x) * (ns[j].x - cur.x) + (ns[j].y - cur.y) * (ns[j].y - cur.y)) {\n                    adds[j]++;\n                }\n            }\n            for (int k = j + 1; k < sz(ns); k++) {\n                goods[j][k] = false;\n                cnt[j][k] = 0;\n                dp[j][k] = 0;\n                if (good(cur, ns[j], ns[k])) {\n                    goods[j][k] = true;\n                    for (int g = j + 1; g < k; g++) {\n                        if (vec(ns[k] - cur, ns[g] - cur) != 0 && vec(ns[j] - cur, ns[g] - cur) != 0 && inside(cur, ns[j], ns[k], ns[g])) {\n                            cnt[j][k]++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (goods[j][k]) {\n                    dp[j][k] += st[cnt[j][k] + adds[j] + adds[k]];\n                    dp[j][k] %= Mod;\n                    ans += dp[j][k];\n                    ans %= Mod;\n                    for (int nxt = k + 1; nxt < sz(ns); nxt++) {\n                        if (vec(ns[nxt] - ns[j], ns[k] - ns[j]) > 0 && goods[k][nxt] && vec(ns[nxt] - cur, ns[k] - cur) != 0) {\n                            dp[k][nxt] += (1LL * dp[j][k] * st[cnt[k][nxt] - adds[k] + adds[nxt]]) % Mod;\n                            dp[k][nxt] %= Mod;\n                        }\n                    }\n                }   \n            }\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS = 1e-10;\nconst bool debug = 0;\n//------------------------------//\n\nll mod = 998244353;\nint N;\nvector<pii> p;\nint cnt[11234];\n\nll mod_pow(ll x, ll n, ll mod) {\n\tif (n == 0) return 1;\n\tll res = mod_pow(x * x % mod, n / 2, mod);\n\tif (n & 1) res = res * x % mod;\n\treturn res;\n}\n\nint calcn(int x) { // a*(a-1)/2 = xを満たすxを求める\n\tint l = 1, r = INF;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) / 2;\n\t\tif ((ll)m * (m - 1) / 2 <= x) l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\n\nint main() {\n\tcin >> N;\n\tp.resize(N);\n\tREP(i, N) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tp[i] = pii(a, b);\n\t}\n\tsort(ALL(p));\n\t\n\tll ans = (mod_pow(2, N, mod) - 1 - N + mod) % mod;\n\t\n\tREP(i, N) cnt[p[i].fi]++;\n\tREP(i, 11234) { // x=iの線分\n\t\tll now = (mod_pow(2, cnt[i], mod) - 1 - cnt[i] + mod) % mod;\n\t\tans = (ans - now + mod) % mod;\n\t}\n\t\n\tmap<pll, int> m; // (傾き, x=0でのy)*1e8\n\tREP(i, N) {\n\t\tREP(j, i) {\n\t\t\tif (p[i].fi == p[j].fi) continue;\n\t\t\tdouble a = (double)(p[i].se - p[j].se) / (p[i].fi - p[j].fi);\n\t\t\tdouble b = p[i].se - a * p[i].fi;\n\t\t\tm[make_pair((ll)round(a * 1e8), (ll)round(b * 1e8))]++;\n\t\t}\n\t}\n\t\n\tfor (map<pll, int>::iterator it = m.begin(); it != m.end(); ++it) {\n\t\tint c = calcn(it->se);\n\t\tll now = (mod_pow(2, c, mod) - 1 - c + mod) % mod;\n\t\tans = (ans - now + mod) % mod;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define AwD 998244353\nusing namespace std;\nll mi(ll a, ll b) {\n\tll ret = 1;\n    for (; b; b >>= 1, a = a * a % AwD)\n\tif (b & 1) ret = ret * a % AwD;\n    return ret;\n}\nll x[250], y[250], ans;\nmap<long double, int> MAP;\nint main() {\n    ll n; cin >> n;\n    ans = mi(2, n) - n - 1;\n    for (int i = 1; i <= n; i ++) cin >> x[i] >> y[i];\n\tfor (int i = 1; i <= n; i ++) {\n\t\tMAP.clear();\n\t\tfor (int j = i + 1; j <= n; j ++) {\n            long double k;\n            if (x[j] == x[i]) k = 2001.03222001;\n\t\t\telse k = (y[j] - y[i]) / (x[j] - x[i]);\n\t\t\tMAP[k] ++;\n\t\t}\n\t\tfor (auto it = MAP.begin(); it != MAP.end(); it ++) (ans -= mi(2, it -> second) - 1) %= AwD;\n\t}\n\tcout << (ans % AwD + AwD) % AwD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iomanip>\nusing namespace std;\n \n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\ntypedef long long ll;\n\nstruct ConvexHull {\n    \n    struct Point {\n        double x,y;\n        Point () {}\n        Point (double _x, double _y) : x(_x), y(_y) {}\n        bool operator < (const Point &a) const {\n            return (x == a.x) ? (y < a.y) : (x < a.x);\n        }\n    };\n    \n    double dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }\n    double cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }\n    double norm(Point a) { return sqrt(dot(a, a) * dot(a, a)); }\n    Point sub(Point a, Point b) { return Point(a.x - b.x, a.y - b.y); }\n    \n    vector< Point > Pos;\n    vector< Point > CHPos;\n    \n    int counter_clockwise(Point p0, Point p1, Point p2) {\n        Point a = sub(p1, p0);\n        Point b = sub(p2, p0);\n        if (cross(a,b) > 1.0e-8) return 1;\n        if (cross(a,b) < -1.0e-8) return -1;\n        if (dot(a,b) < -1.0e-8) return 2;\n        if (norm(a) < norm(b)) return -2;\n        return 0;\n    }\n    \n    void add_point(double x, double y) {\n        Pos.push_back(Point(x, y));\n    }\n    \n    void build() {\n        int n = (int) Pos.size(), k = 0;\n        sort(Pos.begin(),Pos.end());\n        vector< Point > ch(2 * n);\n        for (int i = 0; i < n; ch[k++] = Pos[i++]) {\n            while (k >= 2 && counter_clockwise(ch[k-2], ch[k-1], Pos[i]) <= 0) --k;\n        }\n        for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = Pos[i--]) {\n            while (k >= t && counter_clockwise(ch[k-2], ch[k-1], Pos[i]) <= 0) --k;\n        }\n        copy(ch.begin(), ch.begin() + k - 1, back_inserter(CHPos));\n    }\n    \n    double diameter() {\n        int n = (int) CHPos.size();\n        int is = 0, js = 0;\n        for (int i = 1; i < n; i++) {\n            if (CHPos[i].y > CHPos[is].y) is = i;\n            if (CHPos[i].y < CHPos[js].y) js = i;\n        }\n        double maxd = norm(sub(CHPos[is], CHPos[js]));\n        int i = is, maxi = is;\n        int j = js, maxj = js;\n        do{\n            if (cross(sub(CHPos[(i + 1) % n], CHPos[i]), sub(CHPos[(j + 1) % n], CHPos[j])) >= 0) {\n                j = (j + 1) % n;\n            } else {\n                i = (i + 1) % n;\n            }\n            if(norm(sub(CHPos[i], CHPos[j])) > maxd) {\n                maxd = norm(sub(CHPos[i], CHPos[j]));\n                maxi = i, maxj = j;\n            }\n        } while (i != is || j != js);\n        return sqrt(maxd);\n    }\n    \n    int size() {\n        return (int) CHPos.size();\n    }\n    \n    Point operator [] (int n) {\n        return CHPos[n];\n    }\n    \n};\n\nlong long pow_mod(long long n, long long k, long long mod) {\n    long long ret = 1, a = n % mod;\n    while (k > 0) {\n        if (k & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        k >>= 1;\n    }\n    return ret;\n}\n\n#define MOD 998244353\n\nll N;\nll ans;\nll p_mod[300];\nvector<int> x, y;\nset< vector<bool> > used;\nmap< pair<double, double>, int> table;\n\nvoid dfs(vector<bool> ver, int cnt) {\n\tif (cnt <= 2) return;\n\tif (used.find(ver) != used.end()) {\n\t\treturn;\n\t}\n\tConvexHull inst;\n\tREP(i,ver.size()) {\n\t\tif (ver[i]) inst.add_point((double) x[i], (double) y[i]);\n\t}\n\tinst.build();\n\tif (inst.size() < 3) return;\n\tif (inst.size() == 3 && cnt == 3) {\n\t\tans += p_mod[0];\n\t\tans %= MOD;\n\t\tused.insert(ver);\n\t\treturn;\n\t}\n\tans += p_mod[cnt - inst.size()];\n\tans %= MOD;\n\tREP(i,inst.size()) {\n\t\tpair<double, double> p = make_pair(inst[i].x, inst[i].y);\n\t\tint v = table[p];\n\t\tvector<bool> ver_t = ver;\n\t\tver_t[v] = false;\n\t\tdfs(ver_t, cnt - 1);\n\t}\n}\n\nint main() {\n\n\tcin >> N;\n\tx.resize(N);\n\ty.resize(N);\n\tREP(i,N) cin >> x[i] >> y[i];\n\tREP(i,N) table[make_pair((double) x[i], (double) y[i])] = i;\n\n\tans = 0;\n\tREP(i,300) p_mod[i] = pow_mod(2, i, MOD);\n\tvector<bool> ver(N);\n\tREP(i,N) ver[i] = true;\n\tdfs(ver, N);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\ntypedef pair < int , int > pp;\nconst int mod = 998244353;\nconst int N   = 2e2 + 2;    \n\npp A[N];\nint iki[N];\n\nsigned main(){  \n    int n;\n    cin >> n;\n    for(int i=iki[0]=1; i<=n; i++)\n        iki[i] = iki[i-1] * 2 % mod;\n    \n    int ans = 0;\n    for(int i=1; i<=n; i++){\n        int x, y;\n        cin >> x >> y;\n        A[i] = mp(x,y);\n        map < pp , int > M;\n        for(int j=1; j<i; j++){\n            pp t = A[j];    \n            int a = x - t.st;\n            int b = y - t.nd;\n            if(a < 0){ a = -a; b = -b; }\n                M[ mp(a / __gcd(a,b) , b / __gcd(a,b)) ]++;\n        }\n        \n        map < pp , int > :: iterator it;\n        for(it=M.begin(); it!=M.end(); it++){\n            if(it->nd == 0) cout << \"wtf\";    \n            ans = (ans + iki[ it->nd ] - 1) % mod;\n    \n        }\n    }\n    \n    \n    cout << (iki[n] - ans - n - 1 + mod) % mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define mod 998244353\ntypedef long long ll;\nint main(){\n    int n,x[200],y[200],cnt;\n    ll c[201]={},two[201],ans;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d %d\",&x[i],&y[i]);\n    }\n    two[0]=1;\n    for(int i=1;i<=n;i++){\n        two[i]=2*two[i-1];\n        two[i]%=mod;\n    }\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            cnt=0;\n            for(int k=0;k<n;k++){\n                if(x[i]*y[j]-y[i]*x[j]+x[j]*y[k]-y[j]*x[k]+x[k]*y[i]-y[k]*x[i]==0){\n                    cnt++;\n                }\n            }\n            c[cnt]++;\n        }\n    }\n    ans=two[n];\n    ans-=n+1;\n    ans+=mod;\n    ans%=mod;\n    for(ll i=2LL;i<=n;i++){\n        c[i]*=2LL;\n        c[i]/=i;\n        c[i]/=(i-1LL);\n        ans-=(two[i]-i-1LL)*c[i];\n        ans%=mod;\n        ans+=mod;\n        ans%=mod;\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define X first\n#define Y second\n#define pii pair<ll,ll>\n#define x1 dlfjl\n#define x2 dkfj\n#define MOD 998244353\n#define y1 dskgj\n#define y2 dskfj\n#define N 310\ntypedef int ll;\nusing namespace std;\nll n,i,j,k,x,y,z,m,q,w,h;\nll a[100500], b[100500], pre[1005000], C[205][205];\nmap<pair<pii,pii>,ll> f;\nll gcd(ll a, ll b)\n{\n    return (b==0?a:gcd(b,a%b));\n}\nll Abs(ll x)\n{\n    return (x>0?x:-x);\n}\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    for (i = 0; i <= 1000; i++)\n        pre[i*(i+1)/2] = i+1;\n    for (i = 0; i <= 200; i++)\n        C[i][0] = 1;\n    for (i = 1; i <= 200; i++)\n        for (j = i; j <= 200; j++)\n            C[j][i] = (C[j-1][i-1] + C[j-1][i])%MOD;\n    ll ans = 1;\n    cin >> n;\n    if (n < 3)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    for (i = 1; i <= n; i++)\n        ans = (ans*2)%MOD;\n    ans -= n+1;\n    ans -= n*(n-1)/2;\n    ans += MOD;\n    ans %= MOD;\n    for (i = 0; i < n; i++)\n        cin >> a[i] >> b[i];\n    for (i = 0; i < n; i++)\n        for (j = i+1; j < n; j++)\n        {\n            if (a[i] == a[j])\n            {\n                f[mp(mp(0,a[i]),mp(MOD,MOD))]++;\n                continue;\n            }\n            int p = a[i]-a[j];\n            int q = b[i]-b[j];\n            int g = gcd(Abs(p), Abs(q));\n            p /= g;\n            q /= g;\n            if ( p < 0)\n                p = -p, q = -q;\n            if (p == 0 && q < 0)\n                q = -q;\n            int x1 = a[i], y1 = b[i], x2 = a[j], y2 = b[j];\n            int xx = y1*(x2-x1)-x1*(y2-y1);\n            int yy = x2-x1;\n            int gg = gcd(Abs(xx), Abs(yy));\n            xx /= gg;\n            yy /= gg;\n            if ( xx < 0)\n                xx = -xx, yy = -yy;\n            if (xx == 0 && yy < 0)\n                yy = -yy;\n            f[mp(mp(p,q),mp(xx,yy))]++;\n        }\n    for (auto itr = f.begin(); itr != f.end(); itr++)\n    {\n        int val = (*itr).Y;\n        val = pre[val];\n        for (j = 3; j <= val; j++)\n        {\n            ans -= C[val][j];\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\ntypedef long long ll;\ntypedef pair<int, int> pi;\nconst int INF = 0x3f2f1f0f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 2e2 + 10, MOD = 998244353;\n\nint N; pi Nr[MAX_N];\nint F[MAX_N];\nll cross(pi a, pi b, pi c) {\n\tpi x = pi(b.one - a.one, b.two - a.two);\n\tpi y = pi(c.one - a.one, c.two - a.two);\n\treturn x.one * y.two - y.one * x.two;\n}\nint main() {\n\tcin >> N;\n\tfor(int i=0; i<N; i++) scanf(\"%d%d\", &Nr[i].one, &Nr[i].two);\n\t\n\tF[0] = 1; for(int i=1; i<=N; i++) F[i] = 1ll * F[i-1] * 2 % MOD;\n\n\tint ans = (F[N] - N - 1) % MOD;\n\tfor(int i=0; i<N; i++) for(int j=i+1; j<N; j++) {\n\t\tbool flag = false;\n\t\tfor(int k=0; k<j; k++) if(k != i && k != j && cross(Nr[i], Nr[j], Nr[k]) == 0) {flag = true; break;}\n\t\tif(flag) continue;\n\t\tint cnt = 2;\n\t\tfor(int k=j+1; k<N; k++) if(cross(Nr[i], Nr[j], Nr[k]) == 0) cnt++;\n\t\tans -= (F[cnt] - cnt - 1); ans %= MOD;\n\t}\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst ll MOD = 998244353;\n\nll modpow(ll x, ll n) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\tif (x[i] == x[j]) {\n\t\t\t\t\tif (x[k] == x[i]) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t} else if ((x[i] - x[j]) * (y[k] - y[i]) == (y[i] - y[j]) * (x[k] - x[i])) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t(ans += modpow(2, cnt)) %= MOD;\n\t\t}\n\t}\n\t(ans += n + 1) % MOD;\n\tans = (modpow(2, n) - ans + MOD) % MOD;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef pair<pll, lint> ppl;\n\nconst lint mod = 998244353;\n\nlint powmod(lint x, lint n){\n  lint ret = 1;\n  while(n > 0){\n    if(n&1) ret *= x, ret %= mod, n -= 1;\n    else x *= x, x %= mod, n >>= 1;\n  }\n  return ret;\n}\n\nlint gcd(lint p, lint q){\n    if(p < q) swap(p, q);\n    while(q){\n        lint r = p % q;\n        p = q;\n        q = r;\n    }\n    return p;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    lint x[n], y[n];\n    rep(i, n) scanf(\"%lld%lld\", &x[i], &y[i]);\n    \n    vector<ppl> L;\n    rep(i, n)For(j, i+1, n){\n        lint a = y[j] - y[i];\n        lint b = x[i] - x[j];\n        lint c = x[i]*(y[j]-y[i]) - y[i]*(x[j]-x[i]);\n        if(a < 0 || (a==0 && b < 0)) a *= -1, b *= -1, c *= -1;\n        lint g = gcd(gcd(abs(a), abs(b)), abs(c));\n        L.push_back(ppl(pll(a/g, b/g), c/g));\n    }\n    sort(L.begin(), L.end());\n    L.erase(unique(L.begin(), L.end()), L.end());\n    \n    lint ans = (powmod(2, n)-(n+1)+mod) % mod;\n    for(auto l: L){\n        lint a = l.fi.fi;\n        lint b = l.fi.se;\n        lint c = l.se;\n        int cnt = 0;\n        rep(i, n)if(a*x[i]+b*y[i] == c) ++cnt;\n        ans = (ans - powmod(2, cnt)+cnt+1 + mod) % mod;\n    }\n    \n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst ll MOD = 998244353;\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n\nstruct point {\n\tll x, y;\n\tpoint operator-(point a) {\n\t\treturn {x - a.x, y - a.y};\n\t}\n\tll operator*(point a) {\n\t\treturn x * a.y - y * a.x;\n\t}\n\tbool operator<(point a) {\n\t\treturn make_pair(x, y) < make_pair(a.x, a.y);\n\t}\n};\n\nint n;\npoint a[300];\n\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i].x >> a[i].y;\n\tll ans = 1;\n\tfor (int i = 0; i < n; ++i)\n\t\tans = ans * 2 % MOD;\n\tans = (ans - 1 + MOD) % MOD;\n\tans = (ans - n + MOD) % MOD;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (!(a[i] < a[j]))\n\t\t\t\tcontinue;\n\t\t\tint cc = 0;\n\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\tif (a[i] < a[k] && a[k] < a[j] && (a[k] - a[i]) * (a[j] - a[i]) == 0)\n\t\t\t\t\t++cc;\n\t\t\tll mn = pw(2, cc);\n\t\t\tans = (ans - mn + MOD) % MOD;\n\t\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <ctime>\n#include <map>\n#include <set>\n#define x first\n#define y second\n#define MOD 998244353\n#define NMax 202\nusing namespace std;\n\nint N;\nint doi[NMax+1];\nint dp[NMax+1][NMax+1];\ntypedef pair<int, int> Point;\nPoint p[NMax+1];\n\nint Arie(Point A, Point B, Point C)\n{\n    return ( (B.x-A.x)*(C.y-A.y) - (B.y-A.y)*(C.x-A.x) ) > 0;\n}\n\nint Ariep(Point A, Point B, Point C)\n{\n    return ( (B.x-A.x)*(C.y-A.y) - (B.y-A.y)*(C.x-A.x) );\n}\n\nbool inside(Point A, Point B, Point C, Point D)\n{\n    if(D == A || D == B || D == C) return 0;\n    return ( abs( Ariep(A,D,B) ) + abs( Ariep(B,D,C) ) + abs(Ariep(C,D,A) ) ) == abs( Ariep(A,B,C) );\n}\n\nvoid Compute(int i, int j)\n{\n    dp[i][j] = 0;\n    int k,l,cnt=0;\n    for(k = i+1; k <= N; ++k)\n        if(k != j && Arie(p[i], p[j], p[k]))\n        {\n            cnt = 0;\n            if(dp[i][k] < 0) Compute(i,k);\n            for(l = i+1; l <= (p[k].y > p[j].y ? k : j); ++l)\n                if(inside(p[i], p[j], p[k], p[l])) ++cnt;\n\n            dp[i][j] = (dp[i][j] + 1LL * doi[cnt] * (dp[i][k]+1) ) % MOD;\n        }\n}\n\nbool cmp(Point A, Point B)\n{\n    if(A.y == B.y) return A.x < B.x;\n    return A.y < B.y;\n}\n\nint main(){\n\n    int i,j,res=0;\n\n    scanf(\"%d\",&N);\n    for(i = 1; i <= N; ++i) scanf(\"%d %d\",&p[i].x,&p[i].y);\n\n    doi[0] = 1;\n    for(i = 1; i <= NMax; ++i) doi[i] = (1LL * 2 * doi[i-1]) % MOD;\n\n    for(i = 1; i <= N; ++i)\n        for(j = i+1; j <= N; ++j)\n        dp[i][j] = -1;\n\n    sort(p+1,p+N+1,cmp);\n\n    for(i = 1; i <= N; ++i)\n        for(j = i+1; j <= N; ++j)\n        if(dp[i][j] < 0) Compute(i,j);\n\n   for(i = 1; i <= N; ++i)\n    for(j = i+1; j <= N; ++j)\n   {\n       printf(\"%d cu %d %d\\n\",dp[i][j],i,j);\n    printf(\"\\n\");\n   }\n\n    for(i = 1; i <= N; ++i)\n        for(j = i+1; j <= N; ++j)\n        res = ( res + dp[i][j] ) %  MOD;\n\n\n    printf(\"%d\\n\",res);\n\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 211\n#define mod 998244353\n\nint n, i, j, k;\npair<int, int> P[maxN];\nvector< pair<int, int> > ord;\n\nll pows[maxN];\nll ans, dx, dy, d;\n\nll gcd(ll a, ll b) {\n    if (a < 0) a *= -1;\n    if (b < 0) b *= -1;\n    if (a < b) swap(a, b);\n\n    while (b > 0) {\n        a %= b;\n        swap(a, b);\n    }\n\n    return a;\n}\n\nint main()\n{\n  //  freopen(\"test.in\",\"r\",stdin);\n\n    cin >> n;\n    for (i = 1; i <= n; i++)\n        cin >> P[i].first >> P[i].second;\n\n    pows[0] = 1;\n    for (i = 1; i <= n; i++)\n        pows[i] = (pows[i - 1] * 2) % mod;\n\n    ans = pows[n];\n\n    for (i = 1; i <= n; i++) {\n        ord.clear();\n        for (j = i + 1; j <= n; j++) {\n            dx = P[i].first - P[j].first;\n            dy = P[i].second - P[j].second;\n\n            if (dx < 0) {\n                dx *= -1;\n                dy *= -1;\n            }\n\n            if (dx == 0 && dy < 0)\n                dy *= -1;\n\n            d = gcd(dx, dy);\n            dx /= d;\n            dy /= d;\n            ord.pb(mp(dx, dy));\n        }\n\n        sort(ord.begin(), ord.end());\n        for (j = 0; j < ord.size(); j = k) {\n            for (k = j; k < ord.size(); k++)\n                if (ord[j] != ord[k])\n                    break;\n\n            ans += mod - pows[k - j] + 1;\n            ans %= mod;\n        }\n\n        ans += mod - 1;\n        ans %= mod;\n    }\n\n    ans += mod - 1;\n    ans %= mod;\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 205;\nconst int mod = 998244353;\nconst double eps = 1e-9;\nconst double PI = acos(-1);\n\nint n, x[MAXN], y[MAXN], cnt[MAXN], bin[MAXN];\ndouble a[MAXN];\n\ninline int Sgn(double x)\n{\n\treturn fabs(x) < eps ? 0 : x > 0 ? 1 : -1;\n}\n\ninline int F(int x)\n{\n\treturn (bin[x] - 1 - x - x * (x - 1) / 2 + mod) % mod;\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), bin[0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\tx[i] = Read(), y[i] = Read(), bin[i] = (bin[i - 1] << 1) % mod;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tfor (int j = 1, k = 0; j <= n; j ++)\n\t\t\tif (j ^ i)\n\t\t\t{\n\t\t\t\ta[++ k] = atan2(y[j] - y[i], x[j] - x[i]);\n\t\t\t\tif (Sgn(a[k]) <= 0)\n\t\t\t\t\ta[k] += PI;\n\t\t\t}\n\t\tsort(a + 1, a + n);\n\t\tfor (int l = 1, r = 1; l < n; cnt[r - l + 1] ++, l = r)\n\t\t\twhile (r < n && !Sgn(a[r] - a[l]))\n\t\t\t\tr ++;\n\t}\n\tint ans = F(n);\n\tfor (int i = 1; i <= n; i ++)\n\t\tans = (ans - 1LL * cnt[i] / i * F(i) % mod + mod) % mod;\n\treturn printf(\"%d\\n\", ans), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\nint MOD = 998244353;\n#define int long long\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nint func(int a) {\n\tint res = 1;\n\tfor (int i = 0; i < a; i++) {\n\t\tres = (res * 2) % MOD;\n\t}\n\tres = (res + MOD - a) % MOD;\n\tres = (res + MOD - ((a*(a - 1)) / 2) - 1) % MOD;\n\treturn res;\n}\nsigned main() {\n\tint n;\n\tcin >> n;\n\tint res = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tres = (res * 2 % MOD);\n\t}\n\tvector<int> x(n);\n\tvector<int> y(n);\n\tUnionFind uf(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tif (n <= 2) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n - 2; i++) {\n\t\tfor (int j = i + 1; j < n - 1; j++) {\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\tif ((x[i] - x[k])*(y[j] - y[k]) == (x[j] - x[k])*(y[i] - y[k])) {\n\t\t\t\t\tuf.unionSet(i, j);\n\t\t\t\t\tuf.unionSet(i, k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> vec(n,0);\n\tfor (int i = 0; i < n; i++) {\n\t\tvec[uf.root(i)]++;\n\t}\n\tres = func(n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (vec[i] >= 3) {\n\t\t\tres = (res + MOD - func(vec[i])) % MOD;\n\t\t\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nconst int mod=998244353;\nint N,pw2[210];\nstruct Point{int x,y;}P[210];\nint o,L[210];\nbool cmp(int i,int j){\n\tint ti=P[i].y<P[o].y||P[i].y==P[o].y&&P[i].x<P[o].x,\n\t\ttj=P[j].y<P[o].y||P[j].y==P[o].y&&P[j].x<P[o].x;\n\tif(ti!=tj)return ti<tj;\n\treturn(P[i].x-P[o].x)*(P[j].y-P[o].y)>(P[i].y-P[o].y)*(P[j].x-P[o].x);\n}\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&P[i].x,&P[i].y);\n\tfor(int i=*pw2=1;i<=N;i++)pw2[i]=pw2[i-1]*2%mod;\n\tint s=0;\n\tfor(o=0;o<N;o++){\n\t\tint m=0;\n\t\tfor(int i=0;i<N;i++)if(i!=o)L[m++]=i;\n\t\tstd::sort(L,L+m,cmp);\n\t\tfor(int i=0,t=0;i<m;i++){\n\t\t\tif(i&&cmp(L[i-1],L[i]))t=0;\n\t\t\t(s+=pw2[t++])%=mod;\n\t\t}\n\t}\n\ts=(s*(mod+1ll)/2+N+1)%mod;\n\tprintf(\"%d\\n\",(pw2[N]+mod-s)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 02.09.2017 15:07:12       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 998244353;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\ninline int mul(int a, int b) {\n  return (long long) a * b % md;\n}\n\ninline int power(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int x) {\n  return power(x, md - 2);\n}\n\nconst int N = 12345;\n\nint x[N], y[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", x + i, y + i);\n  }\n  int ans = power(2, n);\n  add(ans, md - 1);\n  add(ans, md - n);\n  add(ans, md - n * (n - 1) / 2);\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int a = y[j] - y[i];\n      int b = x[i] - x[j];\n      int c = -a * x[i] - b * y[i];\n      int cnt = 2;\n      for (int k = 0; k < n; k++) {\n        if (k == i || k == j) {\n          continue;\n        }\n        int z = a * x[k] + b * y[k] + c;\n        if (z != 0) {\n          continue;\n        }\n        if (k < j) {\n          break;\n        }\n        cnt++;\n      }\n      add(ans, md - power(2, cnt));\n      add(ans, 1);\n      add(ans, cnt);\n      add(ans, cnt * (cnt - 1) / 2);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (lli i = 0; i < (n); i++)\n#define rrep(i, n) for (lli i = (n)-1; i >= 0; i--)\nusing namespace std;\nusing lli = long long int;\n\n\nusing node = tuple<lli, lli, lli, lli, int>;\nlli x[300], y[300];\n/*struct node {\n    lli x, y, diffx, diffy;\n    int type;  //0->normal 1-> y=const 2-> x=const\n    \n};\n*/\nvoid show(node x)\n{\n    return;\n    cout << get<0>(x) << \" \" << get<1>(x) << \" \" << get<2>(x) << \" \" << get<3>(x) << \" \" << get<4>(x) << endl;\n}\nbool ison(node a, lli x, lli y)\n{\n    int type = get<4>(a);\n    if (type != 0) {\n        if (type == 1) {\n            return y == get<1>(a);\n        } else {\n            return x == get<0>(a);\n        }\n    }\n    x -= get<0>(a);\n    y -= get<1>(a);\n    return x * get<3>(a) == y * get<2>(a);\n}\nnode get(int l, int r)\n{\n    if (x[l] == x[r]) {\n        return make_tuple(x[l], 0, 0, 0, 2);\n    } else if (y[l] == y[r]) {\n        return make_tuple(0, y[l], 0, 0, 1);\n    } else {\n        lli diffx = x[r] - x[l];\n        lli diffy = y[r] - y[l];\n        lli hoge = __gcd(diffx, diffy);\n        diffx /= hoge;\n        diffy /= hoge;\n        if (diffx < 0) {\n            diffx *= -1;\n            diffy *= -1;\n        }\n        lli nx = x[r] % diffx;\n        lli ny = y[r] - (x[r] / diffx) * diffy;\n        return make_tuple(nx, ny, diffx, diffy, 0);\n    }\n}\nlli powm(lli a, lli p, lli mod)\n{\n    lli ans = 1;\n    while (p > 0) {\n        if (p & 1)\n            ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        p >>= 1;\n    }\n    return ans % mod;\n}\nlli M = 998244353;\n\nvoid add(lli& l, lli r)\n{\n    (l += (r + M)) %= M;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    set<node> s;\n    rep(i, n) cin >> x[i] >> y[i];\n    rep(i, n) rep(j, i)\n    {\n        auto g = get(i, j);\n        show(g);\n        s.insert(g);\n    }\n    lli ans = powm(2, n, M);\n    add(ans, -n - 1);\n    for (auto t : s) {\n        int k = 0;\n        rep(i, n)\n        {\n            if (ison(t, x[i], y[i])) {\n                k++;\n            }\n        }\n        show(t);\n        //cout << \"#\" << k << endl;\n\n        add(ans, -powm(2, k, M) + k + 1);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nconst int mod = 998244353;\nconst int maxn = 250;\nconst double eps = 1e-7;\nint n, cnt = 0, in[maxn];\nbool flag[maxn][maxn] = {0};\nstruct points\n{\n\tdouble x, y;\n\tpoints(double xx = 0, double yy = 0) : x(xx), y(yy) {}\n\tpoints operator-(const points &a) const {return points(x - a.x, y - a.y);}\n\tdouble cross(const points &a) const {return x * a.y - y * a.x;}\n}p[maxn];\nlong long power(long long x, long long k)\n{\n\tlong long ans = 1;\n\twhile(k)\n\t{\n\t\tif(k & 1)\n\t\t\t(ans *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i = 1; i <= n; i ++)\n\t\tcin >> p[i].x >> p[i].y;\n\tlong long sum = (power(2, n) - n - 1+ mod) % mod;\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = i + 1; j <= n; j ++)\n\t\t\tif(!flag[i][j])\n\t\t\t{\n\t\t\t\tcnt = 2;\n\t\t\t\tin[1] = i, in[2] = j;\n\t\t\t\tfor(int k = j + 1; k <= n; k ++)\n\t\t\t\t\tif(abs((p[i] - p[j]).cross(p[k] - p[i])) <= eps)\n\t\t\t\t\t\tin[++ cnt] = k;\n\t\t\t\tsum = (sum - power(2, cnt) + 1 + cnt + mod) % mod;\n\t\t\t\tfor(int k = 1; k <= cnt; k ++)\n\t\t\t\t\tfor(int t = k + 1; t <= cnt; t ++)\n\t\t\t\t\t\tflag[in[k]][in[t]] = 1;\n\t\t\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define maxn 1010\nusing namespace std;\n\nconst ll mod=998244353;\n\nint n;\n\nll fac[maxn],ans;\n\nstruct node{\n\tint x,y;\n}a[maxn];\n\nll qpow(ll base,ll K){\n\tll res=1;\n\twhile(K){\n\t\tif(K&1) res=(res*base)%mod;\n\t\tbase=(base*base)%mod;\n\t\tK>>=1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=(fac[i-1]*2)%mod;\n\tans=(fac[n]-n-1+mod)%mod;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<i;j++){\n\t\t\tint sum=0;\n\t\t\tfor(int k=1;k<j;k++) if(1ll*(a[i].x-a[j].x)*(a[j].y-a[k].y)==1ll*(a[i].y-a[j].y)*(a[j].x-a[k].x)) sum++;\n\t\t\tans=(ans-fac[sum]+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint n;\nconst LL mods=998244353;\nstruct point{\n\tint x,y;\n\tpoint (int _x,int _y){\n\t\tx=_x;\n\t\ty=_y;\n\t}\n\tpoint(){\n\t}\n};\nstruct M{\n\tLL x;\n\tM(LL angka){\n\t\tif(angka>=mods||angka<=-mods)\n\t\t\tangka%=mods;\n\t\tif(angka<0)\n\t\t\tangka+=mods;\n\t\tx=angka;\n\t}\n\tM(){\n\t\tx=0;\n\t}\n\tM operator*(const M &other) const{\n\t\treturn M(x*other.x);\n\t}\n\tM operator+(const M &other) const{\n\t\treturn M(x+other.x);\n\t}\n\tM operator-(const M &other) const{\n\t\treturn M(x-other.x);\n\t}\n\tM operator-(){\n\t\treturn M(-x);\n\t}\n};\npoint plist[205];\nvector <pii> urutan;\nM pangkat[205],ans;\nint fpb(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\treturn fpb(b,a%b);\n}\npii kecilkan(pii pecah){\n\tif(pecah.fi==0)\n\t{\n\t\tassert(pecah.se!=0);\n\t\treturn mp(0,1);\n\t}\n\tif(pecah.se==0)\n\t{\n\t\tassert(pecah.fi!=0);\n\t\treturn mp(1,0);\n\t}\n\tint bagi=fpb(abs(pecah.fi),abs(pecah.se));\n\tpecah.fi/=bagi;\n\tpecah.se/=bagi;\n\tif(pecah.fi*pecah.se<0)\t\t//minus selalu di first\n\t{\n\t\tpecah.fi=-abs(pecah.fi);\n\t\tpecah.se=abs(pecah.se);\n\t}\n\treturn pecah;\n}\nvoid isipangkat(){\n\tpangkat[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tpangkat[i]=pangkat[i-1]*2;\n}\nvoid hitungansawal(){\n\tans=pangkat[n]-1-n;\n}\nint main()\n{\n\tscan(n);\n\tisipangkat();\n\thitungansawal();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscan(plist[i].x,plist[i].y);\n\t}\n\t//hitung ans modif\n\tfor(int i=1;i<n;i++)\n\t{\n\t\turutan.clear();\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\turutan.pb(kecilkan(mp(plist[j].x-plist[i].x,plist[j].y-plist[i].y)));\n\t\tsort(all(urutan));\n\t\tint totalkembar=0;\n\t\tpii last=urutan[0];\n\t\tfor(auto isi:urutan)\n\t\t{\n\t\t\tif(isi!=last)\n\t\t\t{\n\t\t\t\tlast=isi;\n\t\t\t\tans=ans-(pangkat[totalkembar]-1);\n\t\t\t\ttotalkembar=0;\n\t\t\t}\n\t\t\ttotalkembar++;\n\t\t}\n\t\tans=ans-(pangkat[totalkembar]-1);\n\t}\n\tcout<<ans.x<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define N 210\n#define ll long long\n#define mod 998244353\nusing namespace std;\nstruct node{\n\tint x,y;\n\tnode(int X=0,int Y=0):x(X),y(Y){}\n\tnode operator -(const node a)const{return node(a.x-x,a.y-y);}\n\tint operator *(const node a)const{return x*a.y-y*a.x;}\n}p[N];\nll _2[N];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\t_2[0]=1;\n\tfor(int i=1;i<=n;i++) _2[i]=_2[i-1]*2%mod;\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&p[i].x,&p[i].y);\n\tll res=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int k=1;k<i;k++)\t\n\t \t\tif((p[j]-p[i])*(p[k]-p[i])==0) cnt++;\n\t\t\t(res+=_2[cnt]-1)%=mod;\n\t\t}\n\tprintf(\"%lld\\n\",((_2[n]-n*(n-1)/2-n-1)%mod-res+2*mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\nconst int MAX =2000007;\nconst int MOD = 998244353;\n//\nint modpow(int a, int n, int mod) {\n    int res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n     signed main(){\n  int n;\n  cin>>n;\n  int x[n],y[n];for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  bool used[n][n];for(int i=0;i<n;i++)fill(used[i],used[i]+n,false);\n  int ans=(modpow(2,n,MOD)+MOD-n-1)%MOD;\n  for(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n      if(used[i][j])continue;\n      vector<int> v;\n      v.push_back(i);v.push_back(j);\n      for(int k=j+1;k<n;k++)if((x[i]-x[k])*(y[i]-y[j])==(y[i]-y[k])*(x[i]-x[j]))v.push_back(k);\n      ans=(ans+MOD-modpow(2,v.size(),MOD)+v.size()+1)%MOD;\n    for(int p=0;p<v.size();p++)for(int q=p+1;q<v.size();q++)used[v[p]][v[q]]=true;\n  }\n  cout<<ans<<endl;\n\n     }\n\n\n \n\n\n \n\n\n\n\n\n\n    \n\n\n\n\n\n      \n\n        \n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define DEBUG\n\nconst int maxn=205;\nconst int mod=998244353;\nint ans,n;\nint x[maxn],y[maxn],t2[maxn];\n\nbool coli(int i,int j,int k){return (y[j]-y[i])*(x[k]-x[j])==(y[k]-y[j])*(x[j]-x[i]);}\n\nint main(){\n#ifndef DEBUG\n\tfreopen(\"my.in\",\"r\",stdin);\n\tfreopen(\"my.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&n);\n\tt2[0]=1;\n\tREP(i,n)t2[i]=2LL*t2[i-1]%mod;\n\tans=(t2[n]-n-1)%mod;\n\tif(ans<0)ans+=mod;\n\trep(i,n)scanf(\"%d%d\",&x[i],&y[i]);\n\trep(i,n)for(int j=i+1;j<n;j++){\n\t\tint cnt=0;\n\t\tfor(int k=j+1;k<n;k++)if(coli(i,j,k))cnt++;\n\t\tans-=t2[cnt];\n\t\tif(ans<0)ans+=mod;\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-12;\ntypedef complex<double> P;\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<pair<int,int>>se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\tif(se.find({i,j})!=se.end())continue;\n\t\tvector<int>x={i,j};\n\t\tfor(int k=j+1;k<N;k++)if(abs(imag(conj(v[j]-v[k])*(v[i]-v[k])))<1e-12)x.push_back(k);\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\tr=(r-pow_binary_mod(2,b+~a,M))%M;\n\t\t\tse.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n#define ll long long\n\nint tw[201], md = 998244353;\n\nstruct V{\n\tint x, y;\n\tV(){}\n\tV(int a, int b):x(a), y(b) {}\n\tint operator |(V const o)const { return x * o.y - o.x * y; }\n\tbool operator <(V const o)const { return (*this | o) < 0; }\n\tvoid N() { if (x < 0 || x == 0 && y < 0)x = -x, y = -y; }\n\tV operator -(V o) { return V(x - o.x, y - o.y); }\n}p[200];\n\nint main(){\n\ttw[0] = 1;\n\tf(i, 1, 201)if ((tw[i] = tw[i - 1] << 1) >= md)tw[i] -= md;\n\tint n;\n\tscanf(\"%d\", &n);\n\tf(i, 0, n)scanf(\"%d%d\", &p[i].x, &p[i].y);\n\tint an = tw[n] - 1 - n;\n\tif (an < 0)an += md;\n\tf(i, 0, n){\n\t\tmap<V, int> mp;\n\t\tf(j, i + 1, n){\n\t\t\tV v = p[j] - p[i];\n\t\t\tv.N();\n\t\t\t++mp[v];\n\t\t}\n\t\tfor (map<V, int>::iterator it = mp.begin(); it != mp.end(); ++it)if ((an -= tw[it->second] - 1) < 0)an += md;\n\t}\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2000;\ntypedef long long ll;\nconst ll mod=998244353;\nll x[maxn],y[maxn];\nll power(ll a,ll b)\n{\n    int ret;\n    if (b==0) return 1;\n    ret=pow(a,b/2);\n    ret=ret*ret%mod;\n    if (b%2) ret=ret*2%mod;\n    return ret;\n}\nint main()\n{\n//    freopen(\"text.in\",\"r\",stdin);\n    ll i,ans,tmp,j,k,n;\n    scanf(\"%lld\",&n);\n    for (i=1;i<=n;i++) {\n        scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    ans=((power(2,n)-n-1)%mod+mod)%mod;\n    ans=((ans-(n-1)*n/2)%mod+mod)%mod;\n    for (i=1;i<=n;i++) {\n        for (j=i+1;j<=n;j++) {\n            tmp=0;\n            for (k=j+1;k<=n;k++) {\n                if ((y[k]-y[i])*(x[j]-x[i])==(x[k]-x[i])*(y[j]-y[i])) tmp++;\n            }\n            ans=((ans-power(2,tmp)+1)%mod+mod)%mod;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename _tp> inline void read(_tp&x){\n\tchar ch=getchar(),ob=0;x=0;\n\twhile(ch!='-'&&!isdigit(ch))ch=getchar();if(ch=='-')ob=1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();if(ob)x=-x;\n}\n\nconst int N = 203, mod = 998244353;\n\nstruct pnt {\n\tint x, y;\n\tinline void in() {read(x), read(y);}\n\tfriend inline pnt operator - (const pnt&A, const pnt&B) {return (pnt) {A.x - B.x, A.y - B.y};}\n\tfriend inline int operator * (const pnt&A, const pnt&B) {return A.x * B.y - A.y * B.x;}\n} p[N];\n\ninline bool con(const pnt&A, const pnt&B, const pnt&C) {\n\treturn (C - A) * (B - A) == 0;\n}\n\nint n;\nint bin[N];\nbool vs[N];\nll Ans;\n\nint main() {\n\tread(n);\n\tbin[0] = 1;\n\tfor(int i=1;i<=n;++i) bin[i] = (bin[i-1] << 1)%mod;\n\tfor(int i=1;i<=n;++i) p[i].in();\n\tfor(int i=1;i<n;++i) {\n\t\tfor(int j=1;j<=n;++j) vs[j] = false;\n\t\t\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif(!vs[j]) {\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int k=1;k<i;++k)\n\t\t\t\t\tif(con(p[i], p[j], p[k]))\n\t\t\t\t\t\tflg = false;\n\t\t\t\tint ct = 2;\n\t\t\t\tfor(int k=j+1;k<=n;++k)\n\t\t\t\t\tif(con(p[i], p[j], p[k]))\n\t\t\t\t\t\tvs[k] = true, ++ct;\n\t\t\t\tif(flg) Ans += bin[ct] - ct - 1;\n\t\t\t}\n\t}\n\tAns = ((ll)mod*mod - Ans - n - 1 + bin[n])%mod;\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 998244353\n#define maxn 210\nusing namespace std;\nstruct point{\n\tint x,y;\n\tpoint(){}\n\tpoint(int x,int y):x(x),y(y){}\n\tpoint operator-(const point& p)const{return point(x-p.x,y-p.y);}\n}p[maxn];\nint n,vis[maxn];\nint qpow(int a,int b){\n\tint ans=1,tmp=a;\n\tfor(;b;b>>=1,tmp=1ll*tmp*tmp%mod)\n\t\tif(b&1)ans=1ll*ans*tmp%mod;\n\treturn ans;\n}\nint cross(point A,point B){\n\treturn A.x*B.y-A.y*B.x;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d%d\",&p[i].x,&p[i].y);\n\tint ans=qpow(2,n);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int i=1;i<=n;++i)vis[i]=false;\n\t\tfor(int j=i+1;j<=n;++j)if(!vis[j]){\n\t\t\tint sum=1;\n\t\t\tfor(int k=1;k<i;++k)if(cross(p[k]-p[i],p[j]-p[i])==0)goto nxt;\n\t\t\tfor(int k=1;k<=n;++k)if(k!=i&&cross(p[k]-p[i],p[j]-p[i])==0)vis[k]=true,sum++;\n\t\t\tans=(ans-qpow(2,sum)+sum+1+mod)%mod;\n//\t\t\tprintf(\"[(%d,%d)%d]\\n\",i,j,sum);\n\t\t\tnxt:;\n\t\t}\n\t}\n\tans-=n+1;\n\tprintf(\"%d\",(ans%mod+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n\t\t//return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) >  EPS)   return +1;      // counter clockwise\n\tif(cross(b, c) < -EPS)   return -1;      // clockwise\n\tif(dot(b, c)   < -EPS)   return +2;      // c--a--b on line\n\tif(norm(b)+EPS <norm(c)) return -2;      // a--b--c on line\n\treturn 0;                                   // c is between a and b (inclusive)\n}\nint n;\nint on[200][200];\nbool can[200][200][200];\n\nint dp[200][200];\nll pw[201];\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tconst int mod = 998244353;\n\tpw[0] = 1;\n\trep(i, 200) pw[i + 1] = pw[i] * 2 % mod;\n\t\n\tcin >> n;\n\tG g;\n\trep(i, n){\n\t\tint x, y; cin >> x >> y;\n\t\tg.emplace_back(x, y);\n\t}\n\trep(i, n) rep(j, n) rep(k, n) if(ccw(g[i], g[j], g[k]) == 1) can[i][j][k] = 1;\n\trep(i, n) rep(j, i) rep(k, n) if(k != i && k != j){\n\t\tif(ccw(g[k], g[i], g[j]) != 2) continue;\n\t\ton[i][j]++;\n\t\ton[j][i]++;\n\t}\n\tll ans = 0;\n\trep(s, n){\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tvi idx;\n\t\trep(i, n) if(g[s] < g[i]) idx.pb(i);\n\t\tsort(all(idx), [&](int a, int b){\n\t\t\treturn arg(g[a] - g[s]) < arg(g[b] - g[s]);\n\t\t});\n\t\tidx.insert(idx.begin(), s);\n\t\t\n\t\tfor(int i : idx) if(i != s) (dp[s][i] += pw[on[s][i]]) %= mod;\n\t\tfor(int i : idx) for(int j : idx) if(dp[i][j]){\n\t\t\tif(can[i][j][s]) ans += dp[i][j] * pw[on[j][s]] % mod;\n\t\t\tfor(int k : idx) if(k != s && can[i][j][k]) (dp[j][k] += dp[i][j] * pw[on[j][k]] % mod) %= mod;\n\t\t}\n\t}\n\tcout << ans % mod << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nstruct point{\n\tint x , y;\n\tpoint(int _x = 0 , int _y = 0){\n\t\tx = _x;\n\t\ty = _y;\n\t}\n\tpoint operator + (const point &other) const {\n\t\treturn point(x + other.x , y + other.y);\n\t}\n\tpoint operator - (const point &other) const {\n\t\treturn point(x - other.x , y - other.y);\n\t}\n\tbool operator < (const point &other) const {\n\t\tif(x == other.x){\n\t\t\treturn y < other.y;\n\t\t}\n\t\treturn x < other.x;\n\t}\n\tvoid read(){\n\t\tscanf(\"%d %d\" , &x , &y);\n\t}\n};\ninline int dot(point a , point b){\n\treturn a.x * b.x + a.y * b.y;\n}\ninline int cross(point a , point b){\n\treturn a.x * b.y - a.y * b.x;\n}\ninline int orient(point a , point b , point c){//orientation of point c with respect to line from a -> b\n\tint val = cross(b - a , c - a);\n\tif(val > 0){\n\t\treturn 1;//c comes anticlockwise on line from a -> b\n\t}\n\tif(val < 0){\n\t\treturn -1;//c comes clockwise on line from a -> b\n\t}\n\treturn 0;//c is collinear with line from a -> b\n}\nint dist(point a , point b){\n\treturn dot(a - b , a - b);\n}\nconst int N = 205;\nconst int mod = 998244353;\nconst int inv = 499122177;\nint pw2[N];\nint n;\npoint arr[N];\nvector < point > v;\npoint bottom;\nint ans;\nbool cmp(point a , point b){\n\tint tmp = orient(bottom , a , b);\n\tif(tmp == -1){\n\t\treturn 1;\n\t}\n\tif(tmp == 1){\n\t\treturn 0;\n\t}\n\treturn dist(bottom , a) < dist(bottom , b);\n}\nbool inside(point p1 , point p2 , point p3 , point q){\n\tint o1 = orient(p1 , p2 , q);\n\tint o2 = orient(p2 , p3 , q);\n\tint o3 = orient(p3 , p1 , q);\n\treturn (o1 == o2) && (o2 == o3) && (o3 != 0);\n}\nint siz2[N][N][N];\nint siz3[N][N];\nmap < point , int > mp;\nvector < int > indexes;\n//int tot;\nint dp[N][N];\nint solve(int last1 , int last2){\n\tif(dp[last1][last2] != -1){\n\t\treturn dp[last1][last2];\n\t}\n\tint res = !!last1;\n\t/*if(last1){\n\t\tcout << tot << \" \";\n\t}*/\n\tfor(int i = last2 + 1 ; i < v.size() ; ++i){\n\t\tif(orient(v[last1] , v[last2] , v[i]) == -1){\n\t\t\t//tot += siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0);\n\t\t\tres = (res + 1LL * solve(last2 , i) * pw2[siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0)]) % mod;\n\t\t\t//tot -= siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0);\n\t\t}\n\t}\n\treturn dp[last1][last2] = res;\n}\nvoid solve(int idx){\n\tv.clear();\n\tbottom.x = arr[idx].x;\n\tbottom.y = arr[idx].y;\n\tv.emplace_back(arr[idx]);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tif(arr[i].y > bottom.y){\n\t\t\tv.emplace_back(arr[i]);\n\t\t}\n\t\telse if(arr[i].y == bottom.y && arr[i].x > bottom.x){\n\t\t\tv.emplace_back(arr[i]);\n\t\t}\n\t}\n\tsort(v.begin() + 1 , v.end() , cmp);\n\tindexes.clear();\n\tfor(int i = 0 ; i < v.size() ; ++i){\n\t\tindexes.emplace_back(mp[v[i]]);\n\t}\n\t//cout << v.size() << \"--\\n\";\n\tmemset(dp , -1 , sizeof(dp));\n\tfor(int i = 1 ; i < v.size() ; ++i){\n\t\t//tot = siz3[indexes[0]][indexes[i]];\n\t\tans = (ans + 1LL * solve(0 , i) * pw2[siz3[indexes[0]][indexes[i]]]) % mod;\n\t\t//cout << \"WTF\\n\";\n\t}\n\t//cout << ans << endl;\n}\nvoid pre(){\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tfor(int j = 1 ; j <= n ; ++j){\n\t\t\tif(i == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsiz3[i][j] = 0;\n\t\t\tint qlx = min(arr[i].x , arr[j].x);\n\t\t\tint qrx = max(arr[i].x , arr[j].x);\n\t\t\tint qly = min(arr[i].y , arr[j].y);\n\t\t\tint qry = max(arr[i].y , arr[j].y);\n\t\t\tfor(int k = 1 ; k <= n ; ++k){\n\t\t\t\tif(k != i && k != j){\n\t\t\t\t\tif(arr[k].x >= qlx && arr[k].x <= qrx && arr[k].y >= qly && arr[k].y <= qry && orient(arr[i] , arr[k] , arr[j]) == 0){\n\t\t\t\t\t\t++siz3[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tfor(int j = i + 1 ; j <= n ; ++j){\n\t\t\tfor(int k = j + 1 ; k <= n ; ++k){\n\t\t\t\tint res = 0;\n\t\t\t\tfor(int l = k + 1 ; l <= n ; ++l){\n\t\t\t\t\tres += inside(arr[i] , arr[j] , arr[k] , arr[l]);\n\t\t\t\t}\n\t\t\t\tsiz2[i][j][k] = siz2[i][k][j] = siz2[j][i][k] = siz2[j][k][i] = siz2[k][i][j] = siz2[k][j][i] = res;\n\t\t\t}\n\t\t}\n\t}\n\tmp.clear();\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tmp[arr[i]] = i;\n\t}\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tarr[i].read();\n\t}\n\tans = 0;\n\tpw2[0] = 1;\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tpw2[i] = (2LL * pw2[i - 1]) % mod;\n\t}\n\tpre();\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tsolve(i);\n\t}\n\tprintf(\"%d\\n\" , ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define e1 first\n#define e2 second\n#define pb push_back\n#define mp make_pair\n#define boost ios_base::sync_with_stdio(false)\n#define eb emplace_back\n#define OUT(x) {cout << x; exit(0); }\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define scanf(...) scanf(__VA_ARGS__)?:0\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef pair <int, int> PII;\ntypedef pair <ll, ll> PLL;\ntypedef pair <PLL, int> PLLI;\ntypedef pair <PLL, PLL> PP;\ntypedef pair <PII, int> PPI;\ntypedef pair <ll, int> PLI;\ntypedef unsigned int ui;\nconst int mod = 998244353;\nconst int inf = 1e9+9;\nconst ll MOD = 1e9+696969;\nconst long long INF = 1e18+3;\n\ninline ll det(PII a, PII b) {\n\treturn (ll)a.e1 * b.e2 - (ll)a.e2 * b.e1;\n}\ninline bool isLine(PII a, PII b, PII c) {\n\treturn (det(a, b) + det(b, c) + det(c, a) == 0);\n}\n\ninline void submod(ll &x, int val) {\n\tx -= val;\n\twhile (x < 0) x += mod;\n}\n\nconst int maxn = 210;\nint n;\nbool bylo[maxn][maxn];\nPII tab[maxn];\nll pot[maxn];\nvector <int> vec;\n\nll fun(ll sz) {\n\tll ile = pot[sz];\n\tsubmod(ile, 1);\n\tsubmod(ile, sz);\n\tsubmod(ile, sz * (sz - 1) / 2);\n\treturn ile;\n}\n\nint main()\n{\n\tboost;\n\tcin >> n;\n\tif (n <= 2) OUT(0);\n\tpot[0] = 1;\n\tFOR(i, 1, n) pot[i] = (pot[i-1] * 2)%mod;\n\tFOR(i, 1, n) cin >> tab[i].e1 >> tab[i].e2;\n\tll res = pot[n];\n\tsubmod(res, 1);\n\tsubmod(res, n);\n\tsubmod(res, n * (n - 1) /2);\n\t\n\tFOR(i, 1, n)\n\t\tFOR(j, i + 1, n)\n\t\t{\n\t\t\tif (bylo[i][j]) continue;\n\t\t\tvec.clear();\n\t\t\tvec.pb(i); vec.pb(j);\n\t\t\tFOR(k, 1, n)\n\t\t\t\tif (k != i && k != j && isLine(tab[i], tab[j], tab[k])) vec.pb(k);\n\t\t\t\n\t\t\tfor (auto u : vec)\n\t\t\t\tfor (auto v : vec) bylo[u][v] = 1;\n\t\t\t\t\n\t\t\tint sz = (int)vec.size();\n\t\t\tif (sz <= 2) continue;\n\t\t\tsubmod(res, fun(sz));\n\t\t}\n\t\t\n\tcout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <string>\n#include <complex>\n\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\n#define REP(i,e) for(int i=0;i<(int)(e);i++)\n#define FOR(i,b,e) for(int i=(int)(b);i<(int)(e);i++)\n#define ALL(c) (c).begin(), (c).end()\n#define EACH(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define RALL(c) (c).rbegin(), (c).rend()\n#define ALLA(a,n) ((a)+0), ((a)+n)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef vector<string> vstring;\ntypedef vector<double> vdouble;\n\ntemplate<class T>void pp(T v,int n){ REP(i,n)cout<<v[i]<< ' ' ; cout << endl; }\ntemplate<class T>void pp(T v){ EACH(it,v) cout << *it << ' ' ; cout << endl;  }\ntemplate<class T>T& ls(T& a,T b){ if(b<a) a=b; return a; }\ntemplate<class T>T& gs(T& a,T b){ if(b>a) a=b; return a; }\ninline ll to_i(const string& s){ll n;sscanf(s.c_str(),\"%lld\",&n);return n;}\ninline string to_s(ll n){char buf[32];sprintf(buf,\"%lld\",n);return string(buf);}\n\nstruct __scanner__{ bool e; operator bool(){ return e; } } IN = { false };\ninline __scanner__& operator>>(__scanner__& in,int &n)\n{ in.e = scanf(\"%d\",&n)==1; return in; }\ninline __scanner__& operator>>(__scanner__& in,ll &n)\n{ in.e = scanf(\"%lld\",&n)==1; return in; }\ninline __scanner__& operator>>(__scanner__& in,double &n)\n{ in.e = scanf(\"%lf\",&n)==1; return in; }\ninline __scanner__& operator>>(__scanner__& in,char &n)\n{ in.e = scanf(\" %c\",&n)==1; return in; }\ninline __scanner__& operator>>(__scanner__& in,string &n) // BUFFER SIZE!\n{ static char buf[1000000]; in.e = scanf(\" %s\",buf)==1; n = buf; return in; } \n\nconst ll MOD = 998244353;\n\n// constants\nconst double eps=1e-9;\nconst double inf=1e256;\nconst double pi=3.1415926535897932;\n\n// type definition\ntypedef complex<double> pt;\nstruct seg{ pt s,d; };\ntypedef seg line;\n\ntypedef vector<pt> gon;\ntypedef vector<pt> vpt;\n\n// basic function\nnamespace std{\n  bool operator<(const pt &a,const pt b){\n    return a.real()<b.real() || (a.real()==b.real() && a.imag()<b.imag());\n  }\n}\n\ninline bool eq(double a,double b){ return fabs(a-b)<eps; }\ninline bool pteq(pt a,pt b){ return eq(real(a),real(b)) && eq(imag(a),imag(b));}\n\ninline double dot  (pt a,pt b){ return real(conj(a)*b); }\ninline double cross(pt a,pt b){ return imag(conj(a)*b); }\n\n// counterclockwise\n//                 +1\n// +2 --- (l.s) ----0---> (l.d) --- -2\n//                 -1            (Same as Mr. Maebara's)\ninline int ccw(line l,pt p){\n  p-=l.s;\n  double c=cross(l.d-l.s,p);\n  if(!eq(c,0)) return (c<0 ? -1 : 1);\n  if(dot(l.d-l.s,p)<-eps) return 2;\n  if(norm(l.d-l.s)+eps<norm(p)) return -2;\n  return 0;\n}\n\nvll ps(256, 1);\n\nll compute(const vpt& v) {\n  vector<line> u;\n  REP(i,v.size()) REP(j,i) {\n    bool ok = true;\n    line t = { v[i], v[j] };\n    REP(k,u.size()) if (abs(ccw(u[k], v[i])) != 1 && abs(ccw(u[k], v[j])) != 1) {\n      // cout << u[k].s << \"-\" <<  u[k].d << ' '\n      // \t   << v[i] << ' ' << ccw(u[k], v[i])\n      // \t   << v[j] << ' ' << ccw(u[k], v[j]) << endl;\n      ok = false; break;\n    }\n    if (ok) u.push_back((line) { v[i], v[j] });\n  }\n  // cout << \"lines \" << u.size() << endl; \n  // REP(i, u.size()) cout << u[i].s << ' ' << u[i].d << endl;\n  \n  ll result = ps[v.size()];\n  // cout << \"entire: \" << result << endl;\n  result -= 1;\n  result -= v.size();\n  \n  REP(i,u.size()) {\n    ll cnt = 0;\n    REP(j,v.size()) if (abs(ccw(u[i], v[j])) != 1) cnt++;\n    // cout << \"minus: \" << cnt << ' ' << ps[cnt] - cnt - 1 << endl;\n    result -= ps[cnt] - cnt - 1;\n  }\n\n  return result;\n}\n\nint main(){\n  FOR(i,1,ps.size()) ps[i] = ps[i-1] * 2 % MOD;\n  int n;\n  while (cin >> n) {\n    vpt v(n);\n    double x, y;\n    REP(i,n) {\n      cin >> x >> y;\n      v[i] = pt(x, y);\n    }\n    cout << compute(v) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nll x[210], y[210];\nconst ll mod = 998244353LL;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\trep(i, n) cin >> x[i] >> y[i];\n\n\tif (n <= 2) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\n\n\tll ans = 1LL;\n\trep(loop, n) ans = 2LL * ans % mod;\n\n\trep(j, n)rep(i, j) {\n\t\tvector<int> ary;\n\t\trep(k, n) {\n\t\t\tll det = (x[k] - x[i]) * (y[j] - y[i]) - (x[j] - x[i]) * (y[k] - y[i]);\n\t\t\tif (det == 0) ary.push_back(k);\n\t\t}\n\n\t\tsort(begin(ary), end(ary));\n\t\tif (ary[0] != i or ary[1] != j) continue;\n\n\t\tll minus = 1LL;\n\t\trep(loop, ary.size()) minus = 2LL * minus % mod;\n\t\tminus = (minus + mod - ary.size() - 1 ) % mod;\n\t\tans = (ans + mod - minus) % mod;\n\t}\n\n\tans = (ans + mod - n - 1) % mod;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 205;\nconst int MOD = 998244353;\n\nint N;\nPii A[MAXN];\n\ninline Pii operator- (const Pii &a, const Pii &b)\n{\n    return MP(a.x - b.x, a.y - b.y);\n}\n\ninline int cross(const Pii &a, const Pii &b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvoid input()\n{\n    read(N);\n    for (int i = 1; i <= N; ++i) {\n        read(A[i].x); read(A[i].y);\n    }\n}\n\nvoid solve()\n{\n    static LL pow2[MAXN];\n\n    pow2[0] = 1;\n    for (int i = 1; i <= N; ++i) {\n        pow2[i] = pow2[i - 1] * 2 % MOD;\n    }\n\n    LL ans = (pow2[N] - 1 - N) % MOD;\n    for (int i = 1; i <= N; ++i) {\n        for (int j = i + 1; j <= N; ++j) {\n            int cnt = 0;\n            for (int k = j + 1; k <= N; ++k) {\n                cnt += !cross(A[k] - A[j], A[i] - A[j]);\n            }\n            (ans -= pow2[cnt]) %= MOD;\n        }\n    }\n    (ans += MOD) %= MOD;\n\n    printf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"E.in\", \"r\", stdin);\n    freopen(\"E.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 软件设计有两种方式：一种是设计得极为简洁，没有看得到的缺陷；\n// 另一种是设计得极为复杂，有缺陷也看不出来。第一种方式的难度要大得多。\n//     -- The Emperor's Old Clothes, CACM February 1981\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n//#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n) {\n\treturn std::vector<std::vector<T>>(n);\n}\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) res *= n, res %= mod;\n\t\tn *= n; n %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\nbool used[202][202];\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tVEC_ROW(int, n, x, y);\n\n\tauto dist = [&](int i, int j) {\n\t\treturn std::hypot(x[i] - x[j], y[i] - y[j]);\n\t};\n\n\tint ans = powMod(2, n, MOD) - 1 - n;\n\tans %= MOD; ans += MOD; ans %= MOD;\n\tREP(i, n) used[i][i] = true;\n\tREP(i, n) FOR(j, i+1, n) {\n\t\tif (used[i][j]) continue;\n\t\tstd::vector<int> vec;\n\t\tREP(k, n) {\n\t\t\tbool f = false;\n\t\t\tdouble ij = dist(i, j);\n\t\t\tdouble jk = dist(j, k);\n\t\t\tdouble ki = dist(k, i);\n\t\t\tf |= (std::abs(ij + jk - ki) < EPS);\n\t\t\tf |= (std::abs(jk + ki - ij) < EPS);\n\t\t\tf |= (std::abs(ki + ij - jk) < EPS);\n\t\t\tif (f) {\n\t\t\t\tvec.emplace_back(k);\n\t\t\t}\n\t\t}\n\t\tint cnt = vec.size();\n\t\tREP(ii, vec.size()) REP(jj, vec.size()) {\n\t\t\tused[ii][jj] = true;\n\t\t}\n\t\tans -= powMod(2, cnt, MOD) - cnt - 1;\n\t\tans %= MOD; ans += MOD; ans %= MOD;\n\t}\n\tans %= MOD; ans += MOD; ans %= MOD;\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long LL;\nconst int mod = 998244353;\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\nint read() {\n\tint s = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n\treturn s * f;\n}\n\nstruct node {\n\tint x, y;\n} a[210];\nint bin[210];\n\nint multi(node h1, node h2, node h) {\n\tint x1 = h1.x - h.x;\n\tint x2 = h2.x - h.x;\n\tint y1 = h1.y - h.y;\n\tint y2 = h2.y - h.y;\n\treturn x1 * y2 - x2 * y1;\n}\n\nint main() {\n\tint n = read();\n\tbin[0] = 1; for(int i = 1; i <= n; i++) bin[i] = bin[i - 1] * 2 % mod;\n\tfor(int i = 1; i <= n; i++) a[i].x = read(), a[i].y = read();\n\tint ans = bin[n] - 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = i + 1; j <= n; j++) {\n\t\t\tbool bk = 0;\n\t\t\tfor(int k = 1; k < j; k++) if(i != k && k != j){\n\t\t\t\tif(multi(a[i], a[j], a[k]) == 0) {bk = 1; break;}\n\t\t\t} if(bk) continue;\n\t\t\tint u = 2;\n\t\t\tfor(int k = j + 1; k <= n; k++) {\n\t\t\t\tif(multi(a[i], a[j], a[k]) == 0) ++u;\n\t\t\t} (ans -= (bin[u] - u - 1) % mod) %= mod;\n\t\t}\n\t} printf(\"%d\\n\", (ans - n + mod) % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nint N;\nlong long x[210], y[210];\n\nconst int MOD = 998244353;\ninline long long mod(long long a, long long m) { return (a % m + m) % m; }\n\nstruct Fp {\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n};\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\nbool operator == (Fp x, Fp y) { return mod(x.val, MOD) == mod(y.val, MOD); }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp power(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = power(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\n\nbool isin(long long x, long long y, long long x1, long long y1, long long x2, long long y2) {\n\tx1 -= x; x2 -= x;\n\ty1 -= y; y2 -= y;\n\treturn (x1 * y2 == x2 * y1);\n}\n\nint main() {\n\twhile (cin >> N) {\n\t\tfor (int i = 0; i < N; ++i) cin >> x[i] >> y[i];\n\t\tFp res = power(2, N);\n\t\tres -= 1 + N + N * (N - 1) / 2;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tvector<int> vec;\n\t\t\t\tvec.push_back(i);\n\t\t\t\tvec.push_back(j);\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tif (isin(x[k], y[k], x[i], y[i], x[j], y[j])) {\n\t\t\t\t\t\tvec.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (vec.size() > 2) {\n\t\t\t\t\tint m = vec.size();\n\t\t\t\t\tFp tmp = power(2, m) - 1 - m - m * (m - 1) / 2;\n\t\t\t\t\ttmp /= (m * (m - 1) / 2);\n\t\t\t\t\tres -= tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) < norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[m][m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n\ntypedef long long LL;\nconst int MOD=998244353;\nconst int N=200005;\n\nstruct pos {int x,y;} p[N];\n\npos operator -(pos a,pos b) {\n\treturn (pos) {a.x-b.x,a.y-b.y};\n}\n\nint operator *(pos a,pos b) {\n\treturn a.x*b.y-b.x*a.y;\n}\n\nLL bin[N];\n\nint read() {\n\tint x=0,v=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';v=(ch=='-')?(-1):v,ch=getchar());\n\tfor (;ch<='9'&&ch>='0';x=x*10+ch-'0',ch=getchar());\n\treturn x*v;\n}\n\nbool line(pos a,pos b,pos c) {\n\treturn (a-b)*(c-b)==0;\n}\n\nint main(void) {\n\tbin[0]=1; rep(i,1,N-1) bin[i]=bin[i-1]*2LL%MOD;\n\tint n=read();\n\trep(i,1,n) p[i].x=read(),p[i].y=read();\n\tLL ans=bin[n]-n-1-(n-1)*n/2; ans=(ans%MOD+MOD)%MOD;\n\trep(i,1,n) rep(j,i+1,n) {\n\t\tint s=0;\n\t\trep(k,j+1,n) {\n\t\t\ts+=line(p[i],p[j],p[k]);\n\t\t}\n\t\tans=(ans+MOD-bin[s]+1)%MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cstdlib>\n#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef long double ld;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<pii> vii;\ntypedef vector<string> vs;\n//typedef long long int;\nconst int mod = 998244353;\n\nbool line(pii a, pii b, pii c) {\n  a.first -= c.first;\n  b.first -= c.first;\n  a.second -= c.second;\n  b.second -= c.second;\n  return a.first*b.second == a.second*b.first;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  cin >> n;\n  vl p2(n+1, 1);\n  for (int i = 1; i < p2.size(); ++i) p2[i] = p2[i-1] * 2 % mod;\n  vii v(n);\n  for (int i = 0; i < n; ++i) cin >> v[i].first >> v[i].second;\n  ll res = p2[n] - 1 - n;\n//  cerr << res << endl;\n  vvi was(n, vi(n));\n  for (int i = 0; i < n; ++i) for (int j = i + 1; j < n; ++j) if (!was[i][j]) {\n    vi u(2);\n    u[0] = i; u[1] = j;\n    for (int t = 0; t < n; ++t) if (t != i && t != j && line(v[i], v[j], v[t])) {\n      u.push_back(t);\n    }\n    res -= p2[u.size()] - 1 - (int)u.size();\n    for (int a : u) for (int b : u) was[a][b] = was[b][a] = 1;\n  }\n  cout << (res % mod + mod) % mod << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint cnt[201][201] = {};\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nlong long moving[1000] = {};\nint main() {\n#define int long long\n\tvector<pair<int, int>> inputs;\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tinputs.push_back(make_pair(a, b));\n\t}\n\tmoving[0] = 1;\n\tfor (int i = 1; i < 1000; ++i) {\n\t\tmoving[i] = moving[i - 1] * 2;\n\t\tmoving[i] %= MOD;\n\t}\n\tlong long ans = moving[n];\n\tlong long tmp = n + 1;\n\tmap<tuple<long long, long long, long long>, int> edges;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int q = i + 1; q < n; ++q) {\n\t\t\tif (cnt[i][q] == 1) break;\n\t\t\tlong long A = inputs[q].second - inputs[i].second;\n\t\t\tlong long B = inputs[q].first - inputs[i].first;\n\t\t\tlong long C = (inputs[q].second - inputs[i].second) * inputs[i].first - (inputs[q].first - inputs[i].first) * inputs[i].second;\n\t\t\tlong long geko = 0;\n\t\t\tif (A == 0) {\n\t\t\t\tgeko = llabs(B);\n\t\t\t}\n\t\t\telse if (B == 0) {\n\t\t\t\tgeko = llabs(A);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeko = gcd(llabs(A), llabs(B));\n\t\t\t}\n\t\t\tif (geko == 0) {\n\t\t\t\tgeko = llabs(C);\n\t\t\t}\n\t\t\telse if (C == 0) {\n\t\t\t\tgeko = llabs(geko);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeko = gcd(llabs(C), llabs(geko));\n\t\t\t}\n\t\t\tif (geko != 0) {\n\t\t\t\tA /= geko;\n\t\t\t\tB /= geko;\n\t\t\t\tC /= geko;\n\t\t\t}\n\t\t\tif (A < 0) {\n\t\t\t\tA = -A;\n\t\t\t\tB = -B;\n\t\t\t\tC = -C;\n\t\t\t}\n\t\t\tedges[make_tuple(A, B, C)]++;\n\t\t}\n\t}\n\tfor (auto i = edges.begin(); i != edges.end(); ++i) {\n\t\tint cnt = 0;\n\t\tfor (int q = 1;; ++q) {\n\t\t\tcnt += q;\n\t\t\tassert(cnt <= n * n * n);\n\t\t\tif (i->second == cnt) {\n\t\t\t\ttmp += moving[q + 1] - (q + 1) - 1;\n\t\t\t\ttmp += MOD;\n\t\t\t\ttmp %= MOD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans + (MOD - tmp)) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nint x[205], y[205];\nlong long p2[205];\n\nbool linear(int i, int j, int k) {\n  return (y[j] - y[i]) * (x[k] - x[i]) == (y[k] - y[i]) * (x[j] - x[i]);\n}\n\nint main() {\n  long long t = 1;\n  for (int i = 0; i <= 200; i++) {\n    p2[i] = t;\n    t *= 2;\n    t %= mod;\n  }\n  int n;\n  cin >> n;\n  for (int ni = 0; ni < n; ni++) {\n    cin >> x[ni] >> y[ni];\n  }\n  if (n < 3) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long ans = 0;\n  for (int ni = 0; ni < n; ni++) {\n    for (int nj = ni + 1; nj < n; nj++) {\n      bool feasible = true;\n      for (int nk = 0; nk < nj; nk++) {\n        if (nk == ni) continue;\n        if (linear(ni, nj, nk)) {\n          feasible = false;\n          break;\n        }\n      }\n      if (!feasible) break;\n      int cnt = 2;\n      for (int nk = nj + 1; nk < n; nk++) {\n        if (linear(ni, nj, nk)) cnt++;\n      }\n      ans += p2[cnt] - 1 - cnt - cnt * (cnt - 1) / 2 + mod;\n      ans %= mod;\n    }\n  }\n  ans = p2[n] - 1 - n - n * (n - 1) / 2 - ans + mod;\n  ans %= mod;\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n//#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n) {\n\treturn std::vector<std::vector<T>>(n);\n}\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) res *= n, res %= mod;\n\t\tn *= n; n %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\n\nbool used[202][202];\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tVEC_ROW(int, n, x, y);\n\n\tauto dist = [&](int i, int j) {\n\t\treturn std::hypot(x[i] - x[j], y[i] - y[j]);\n\t};\n\n\tint ans = powMod(2, n, MOD) - 1 - n - n * (n - 1) % MOD * invMod(2, MOD);\n\tans %= MOD; ans += MOD; ans %= MOD;\n\tREP(i, n) used[i][i] = true;\n\tREP(i, n) REP(j, n) {\n\t\tif (used[i][j]) continue;\n\t\tint cnt = 0;\n\t\tstd::vector<int> vec;\n\t\tREP(k, n) {\n\t\t\tif (i == k || j == k) continue;\n\t\t\tbool f = false;\n\t\t\tdouble ij = dist(i, j);\n\t\t\tdouble jk = dist(j, k);\n\t\t\tdouble ki = dist(k, i);\n\t\t\tf |= std::abs(ij + jk - ki) < EPS;\n\t\t\tf |= std::abs(jk + ki - ij) < EPS;\n\t\t\tf |= std::abs(ki + ij - jk) < EPS;\n\t\t\tif (f) {\n\t\t\t\t++cnt;\n\t\t\t\tvec.emplace_back(k);\n\t\t\t}\n\t\t}\n\t\tvec.emplace_back(i);\n\t\tvec.emplace_back(j);\n\t\tREP(ii, vec.size()) REP(jj, vec.size()) {\n\t\t\tused[ii][jj] = used[jj][ii] = true;\n\t\t}\n\t\tREP(k, cnt) {\n\t\t\tans -= Combination(cnt + 2, k + 3);\n\t\t\tif (ans < 0) ans += MOD;\n\t\t}\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=233,md=998244353;\nstruct point{\n\tint x,y;\n\tinline point operator-(const point&rhs)const{return(point){x-rhs.x,y-rhs.y};}\n}a[N];\ninline int cross(point a,point b){return a.x*b.y-a.y*b.x;}\nint n,p2[N],ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfor(int i=*p2=1;i<=n;++i)p2[i]=p2[i-1]*2%md;\n\tans=(p2[n]-n-1LL-n*(n-1LL)/2%md+md*4LL)%md;\n\tfor(int i=1;i<n;++i)\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tint x=0;\n\t\t\tfor(int k=j+1;k<=n;++k)\n\t\t\t\tx+=!cross(a[j]-a[i],a[k]-a[i]);\n\t\t\tans=(ans-p2[x]+1+md)%md;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<ll> pt;\n\nstruct rational {\n  ll n, d;\n};\n\nll gcd(ll a, ll b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n  return a * (b / gcd(a, b));\n}\n\nrational operator*(const rational &a, const rational &b) {\n  rational res = rational {a.n * b.n, a.d * b.d};\n  ll g = gcd(res.n, res.d);\n  res.n /= g;\n  res.d /= g;\n  return res;\n}\n\nrational operator/(const rational &a, const rational &b) {\n  rational res = rational {a.n * b.d, a.d * b.n};\n  ll g = gcd(res.n, res.d);\n  res.n /= g;\n  res.d /= g;\n  return res;\n}\n\nrational operator-(const rational &a, const rational &b) {\n  ll l = lcm(a.d, b.d);\n  ll f1 = l / a.d;\n  ll f2 = l / b.d;\n  return rational {a.n * f1 - b.n * f2, l};\n}\n\nbool operator<(const rational &a, const rational &b)  {\n  if (a.n != b.n) return a.n < b.n;\n  return a.d < b.d;\n}\n\nbool operator!=(const rational &a, const rational &b) {\n  return a < b || b < a;\n}\n\nbool operator==(const rational &a, const rational &b) {\n  return !(a != b);\n}\n\nstruct line {\n  rational a, b, c;\n};\n\nline pointsToLine(pt p1, pt p2) {\n  line l;\n  if (p1.real() == p2.real()) {\n    l.a = rational {1, 1};\n    l.b = rational {0, 1};\n    l.c = rational {-p1.real(), 1};\n  } else {\n    l.a = rational {-p1.imag() + p2.imag(), 1} / rational {p1.real() - p2.real(), 1};\n    l.b = rational {1, 1};\n    l.c = l.a * rational {p1.real(), 1} - rational {p1.imag(), 1};\n  }\n  return l;\n}\n\nbool areParallel(line l1, line l2) {\n  return l1.a == l2.a && l1.b == l2.b;\n}\n\nbool operator==(const line &l1, const line &l2) {\n  return areParallel(l1, l2) && l1.c == l2.c;\n}\n\nbool operator<(const line &l1, const line &l2) {\n  if (l1.a != l2.a) return l1.a < l2.a;\n  if (l1.b != l2.b) return l1.b < l2.b;\n  return l1.c < l2.c;\n}\n\nmap<line, ll> counter;\nmap<ll, ll> invTri;\nll powers2[201];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pt> points(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    points[i] = pt(x, y);\n  }\n  sort(points.begin(), points.end(), [](const pt &a, const pt &b) {\n    if (a.real() == b.real()) return a.imag() < b.imag();\n    return a.real() < b.real();\n  });\n\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      counter[pointsToLine(points[i], points[j])]++;\n    }\n  }\n\n  powers2[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    powers2[i] = (2 * powers2[i - 1]) % MOD;\n  }\n\n  for (int i = 1; i <= n; i++) {\n    invTri[i * (i - 1) / 2] = i;\n  }\n\n  ll colSubs = n;\n  for (auto slope : counter) {\n    ll onLine = invTri[slope.second];\n    colSubs += powers2[onLine] - onLine - 1;\n    colSubs %= MOD;\n  }\n\n  printf(\"%lld\\n\", (powers2[n] - colSubs - 1LL + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define SORT(c) sort((c).begin(), (c).end())\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> V;\ntypedef map<int, int> M;\n\nconstexpr ll INF = 1e18;\nconstexpr ll MOD = 998244353;\nconstexpr double PI = 3.14159265358979323846;\nconstexpr int di[] = {0, 0, 1, -1};\nconstexpr int dj[] = {1, -1, 0, 0};\n\nll fastPow(ll x, ll n)\n{\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return fastPow(x * x % MOD, n / 2);\n    else\n        return x * fastPow(x, n - 1) % MOD;\n}\n\nll fac[112346];\nvoid combInit(int mx)\n{\n    fac[0] = 0;\n    fac[1] = 1;\n    for (int i = 2; i <= mx; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n}\n\nll modDiv(ll a, ll b)\n{\n    return a * fastPow(b, MOD - 2) % MOD;\n}\n\nll comb(ll a, ll b)\n{\n    if (b == 0)\n        return 1;\n    if (a < b)\n        return 0;\n    if (a <= 0 || b < 0)\n        return 0;\n    if (a == b)\n        return 1;\n\n    ll p, c;\n\n    c = modDiv(fac[a], fac[a - b]);\n    p = fac[b];\n\n    ll res = modDiv(c, p);\n\n    return res;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    combInit(210);\n\n    int n, x[210], y[210];\n\n    int li[210];\n    fill(li, li + n + 1, 0);\n\n    cin >> n;\n    REP(i, n)\n    cin >> x[i] >> y[i];\n\n    ll res = 0;\n\n    for (int i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++)\n        {\n            int cnt = 2;\n            for (int k = j + 1; k < n; k++)\n            {\n\n                int a = (x[j] - x[i]) * (y[k] - y[j]);\n                int b = (y[j] - y[i]) * (x[k] - x[j]);\n\n                if (a == b)\n                {\n                    cnt++;\n\n                    int c = cnt;\n\n                    while (c > 2)\n                    {\n                        li[c]++;\n                        c--;\n                    }\n                }\n            }\n        }\n\n    for (int i = 3; i <= n; i++)\n    {\n        ll tmp = 0;\n        tmp += comb(n, i);\n\n        tmp += MOD - li[i];\n        tmp %= MOD;\n\n        res += tmp;\n        res %= MOD;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int Q = 998244353;\nconst int N = 209;\nll x[N], y[N], p[N], f[N], size[N];\ninline int read() {\n    int s = 1, a = 0; char ch = getchar();\n    while (ch < '0' || ch > '9') {if (ch == '-') s = -1; ch = getchar();}\n    while (ch >= '0' && ch <= '9') {a = a * 10 + ch - '0'; ch = getchar();}\n    return s * a;\n}\ninline int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\ninline int findSet(int x) {\n    return f[x] == x ? x : f[x] = findSet(f[x]);\n}\ninline void unionSet(int x, int y) {\n    int fx = findSet(x), fy = findSet(y);\n    if (fx != fy) {\n        f[fy] = fx;\n        size[fx] += size[fy];\n    }\n}\nstruct Seg {\n    int p, q; ll hash;\n    bool operator < (const Seg &rhs) const {\n        return hash < rhs.hash;\n    }\n};\nvector<Seg> seg;\nint main() {\n    p[0] = 1;\n    for (int i = 1; i < N; i++) {\n        p[i] = p[i - 1] << 1, p[i] %= Q;\n    }\n    int n = read();\n    for (int i = 1; i <= n; i++) {\n        x[i] = read(), y[i] = read();\n    }\n    ll res = (p[n] - n - 1) % Q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            int dx = x[i] - x[j], dy = y[i] - y[j], g = gcd(dx, dy);\n            dx /= g, dy /= g;\n            if (dx == 0) dy = 1;\n            if (dy == 0) dx = 1;\n            if (dx < 0) dx *= -1, dy *= -1;\n            Seg s; s.p = i, s.q = j, s.hash = dx * 100000 + dy;\n            seg.push_back(s);\n        }\n    }\n    sort(seg.begin(), seg.end());\n    for (int i = 0, j = 0; i < seg.size(); i = j) {\n        for (int k = 1; k <= n; k++) {\n            f[k] = k, size[k] = 1;\n        }\n        for (; j < seg.size() && seg[i].hash == seg[j].hash; j++) {\n            unionSet(seg[j].p, seg[j].q);\n        }\n        for (int k = 1; k <= n; k++) {\n            if (f[k] == k && size[k] >= 2) {\n                res -= (p[ size[k] ] - size[k] - 1), res += Q, res %= Q;\n            }\n        }\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nbool usededge[200][200];\nld x[200], y[200];\nld dis(int i, int j) {\n\tld dx = x[i] - x[j]; dx *= dx;\n\tld dy = y[i] - y[j]; dy *= dy;\n\treturn sqrt(dx + dy);\n}\nbool online(int i, int j, int k) {\n\tld d[3];\n\td[0] = dis(i, j); d[1] = dis(i, k); d[2] = dis(j, k);\n\tsort(d, d + 3);\n\tif (abs(d[2] - (d[0] + d[1]))<eps)return true;\n\telse return false;\n}\nint main(){\n\tll n; cin >> n;\n\tll out = mod_pow(2, n);\n\tout = ((out - 1 - n - n * (n - 1) / 2) % mod + mod) % mod;\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\trep(i, n) {\n\t\tRep(j,i+1, n) {\n\t\t\tif (usededge[i][j])continue;\n\t\t\tll cnt = 2;\n\t\t\tRep(k, j + 1, n) {\n\t\t\t\tif (usededge[i][k])continue;\n\t\t\t\tif (online(i, j, k)) {\n\t\t\t\t\tusededge[i][k] = usededge[j][k] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout = ((out - mod_pow(2, cnt) + 1 + cnt + cnt * (cnt - 1) / 2) % mod + mod) % mod;\n\t\t}\n\t}\n\tcout << out << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nint x[205], y[205];\nlong long p2[205];\n\nbool linear(int x1, int y1, int x2, int y2, int x3, int y3) {\n  return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1);\n}\n\nint main() {\n  long long t = 1;\n  for (int i = 0; i <= 200; i++) {\n    p2[i] = t;\n    t *= 2;\n    t %= mod;\n  }\n  int n;\n  cin >> n;\n  for (int ni = 0; ni < n; ni++) {\n    cin >> x[ni] >> y[ni];\n  }\n  if (n < 3) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long ans = 0;\n  for (int ni = 0; ni < n; ni++) {\n    vector<pair<double, int>> neighbors;\n    for (int nj = 0; nj < n; nj++) {\n      if (nj == ni) continue;\n      double angle;\n      if (y[nj] < y[ni] || (y[nj] == y[ni] && x[nj] < x[ni])) {\n        angle = atan2(y[ni] - y[nj], x[ni] - x[nj]);\n      } else {\n        angle = atan2(y[nj] - y[ni], x[nj] - x[ni]);\n      }\n      neighbors.push_back({angle, nj});\n    }\n    sort(neighbors.begin(), neighbors.end());\n    int cnt = 1;\n    int last = neighbors[0].second;\n    bool feasible = true;\n    for (int nj = 1; nj < n - 1; nj++) {\n      int njj = neighbors[nj].second;\n      if (linear(x[ni], y[ni], x[last], y[last], x[njj], y[njj])) {\n        cnt++;\n      } else {\n        if (feasible) {\n          ans += p2[cnt + 1] - cnt - 2 - cnt * (cnt + 1) / 2 + mod;\n          ans %= mod;\n        }\n        last = njj;\n        cnt = 1;\n      }\n      if (njj < ni) feasible = false;\n    }\n    if (feasible) {\n      ans += p2[cnt + 1] - cnt - 2 - cnt * (cnt + 1) / 2 + mod;\n      ans %= mod;\n    }\n  }\n  ans = p2[n] - 1 - n - n * (n - 1) / 2 - ans + mod;\n  ans %= mod;\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//pragma\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define YOU using\n#define DONT namespace\n#define SAY std\n\nYOU DONT SAY;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n\n#define REPP(i,a,b,d) for(int i=a;i<=b;i+=d)\n#define REP(i,a,b) REPP(i,a,b,1)\n#define REVV(i,a,b,d) for(int i=a;i>=b;i-=d)\n#define REV(i,a,b) REVV(i,a,b,1)\n\n#define FOR(i,a) for(int i=0; i<a; i++)\n#define FORD(i,a) for(int i=(int)a-1; i>=0; i--)\n\n#define pb push_back\n#define F first\n#define S second\n\nconst int OO = 1e9;\nconst ll INF = 1e18;\n\nconst int irand(int lo,int hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\nconst ll lrand(ll lo,ll hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\n#define getc getchar\ntemplate<typename T>\nT getnum(){\n\tint sign = 1;\n\tT ret = 0;\n\tchar c;\n\n\tdo{\n\t\tc = getc();\n\t}while(c == ' ' || c == '\\n');\n\tif(c == '-')sign = -1;\n\telse ret = c-'0';\n\twhile(1){\n\t\tc = getc();\n\t\tif(c < '0' || c > '9')break;\n\t\tret = 10*ret + c-'0';\n\t}\n\treturn sign * ret;\n}\n\ninline void ini(int& x){\n\tx = getnum<int>();\n}\n\ninline void scani(int& x){\n\tscanf(\"%d\",&x);\n}\n\n//end of macro\n\nconst ll MOD = 998244353;\n\ninline ll addmod(ll a, ll b){\n    if(a+b < MOD)return a+b;\n    return a+b-MOD;\n}\ninline ll mulmod(ll a, ll b){\n    return (a*b)%MOD;\n}\ninline ll expmod(ll a, ll e){\n    ll ret = 1;\n    while(e){\n        if(e&1)ret = mulmod(ret, a);\n        a = mulmod(a, a);\n        e >>= 1;\n    }\n    return ret;\n}\n\nconst int N = 205;\n\nint n;\nint x[N], y[N];\nbool used[N];\n\nint piv;\nvi pts;\nint cross(int a, int b, int c){\n    return (x[b]-x[a]) * (y[c]-y[a]) - (y[b]-y[a]) * (x[c]-x[a]);\n}\nint dist2(int a, int b){\n    return (x[a]-x[b])*(x[a]-x[b]) + (y[a]*y[b])*(y[a]*y[b]);\n}\nbool cmp(int a, int b){\n    if(cross(piv, a, b) == 0)return dist2(piv, a) < dist2(piv, b);\n    return cross(piv, a, b) > 0;\n}\n\nint bitt[N];\nvoid update(int x, int v){\n    REPP(i,x,N-1,i&-i)bitt[i] += v;\n}\nint query(int x){\n    int ret = 0;\n    REVV(i,x,1,i&-i)ret += bitt[i];\n    return ret;\n}\n\nint arr[N];\nint dp[N];\nint tidx[N];\nint solve(int sz){\n    printf(\"solve %d\\n\",sz);\n    arr[1] = piv;\n    REP(i,2,sz)arr[i] = pts[i-2];\n    \n    int ret = 0;\n    REP(i,2,sz){\n        dp[i] = 0;\n        \n        // extend : j --- i\n        piv = arr[i];\n        pts.clear();\n        REV(j,i-1,2){\n            pts.pb(arr[j]);\n        }\n        sort(pts.begin(), pts.end(), cmp);\n        FOR(i,pts.size()){\n            tidx[pts[i]] = i+1;\n        }\n        memset(bitt, 0, sizeof bitt);\n        REV(j,i-1,2){\n            int inside = query(tidx[arr[j]]);\n            update(tidx[arr[j]], 1);\n            if(cross(arr[1], arr[i], arr[j]) == 0)continue; // cannot extend from co-linear\n            dp[i] = addmod(dp[i], mulmod(dp[j], expmod(2, inside)));\n        }\n        \n        // close polygon : i --- 1\n        ret = addmod(ret, dp[i]);\n        \n        // start new : 1 --- i\n        dp[i] = addmod(dp[i], 1);\n        \n        printf(\"dp %d = %d\\n\",i,dp[i]);\n    }\n    printf(\"ret %d = %d\\n\",sz,ret);\n    return ret;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    #define endl '\\n'\n    cout.setf(ios::fixed);\n    cout.setf(ios::showpoint);\n    cout.precision(10);\n    \n    cin>>n;\n    REP(i,1,n){\n        cin>>x[i]>>y[i];\n    }\n    \n    int ans = 0;\n    REV(sz,n,3){\n        piv = -1;\n        REP(i,1,n){\n            if(used[i])continue;\n            if(piv == -1 || (y[i] < y[piv]) || (y[i] == y[piv] && x[i] < x[piv]))piv = i;\n        }\n        \n        used[piv] = true;\n        \n        pts.clear();\n        REP(i,1,n){\n            if(used[i])continue;\n            pts.pb(i);\n        }\n        sort(pts.begin(), pts.end(), cmp);\n        \n//        printf(\"pivot %d\\n\",piv);\n//        FOR(i,pts.size())printf(\"%d\\n\",pts[i]);\n        \n        ans = addmod(ans, solve(sz));\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <limits>\n#include <set>\n#define REP(i,n) for(long (i)=0;(i)<(n);(i)++)\n#define REPI(i,a,b) for(long (i)=(a);(i)<(b);(i)++)\n#define INF numeric_limits<double>::infinity()\nconstexpr long MOD = 998244353;\nconstexpr double eps = 1e-10;\nusing namespace std;\nusing P = pair<double, double>;\nusing VI = vector<long>;\n\nP line(P a, P b) {\n    if (a.first == b.first) {\n        return P(INF, a.first);\n    } else if (a.second == b.second) {\n        return P(0, a.second);\n    }\n    double grad = (a.second - b.second) / (a.first - b.first);\n    return P(grad, a.second - grad * a.first);\n}\n\nbool onLine(P line, P p) {\n    if (line.first == INF) {\n        return line.second == p.first;\n    } else if (line.first == 0) {\n        return line.second == p.second;\n    }\n    return abs(line.first * p.first + line.second - p.second) < 1e-8;\n}\n\nlong powmod(long a, long n) {\n    if (n == 0) return 1l;\n    if (n % 2 == 0) {\n        long d = powmod(a, n / 2);\n        return d * d % MOD;\n    }\n    return a * powmod(a, n - 1) % MOD;\n}\n\nint main() {\n    long n;\n    cin >> n;\n    vector<P> v;\n    REP(i,n) {\n        long x, y;\n        cin >> x >> y;\n        v.push_back(P(x,y));\n    }\n    \n    long ans = powmod(2, n);\n    ans = ans - 1 - n - n * (n - 1) / 2;\n    \n    set<P> lines;\n    \n    REP(i,n) {\n        REPI(j,i+1,n) {\n            long cnt = 2;\n            P l = line(v[i], v[j]);\n            if (lines.find(l) == lines.end()) {\n                lines.insert(l);\n                REPI(k,j+1,n) {\n                    if (onLine(l, v[k])) cnt++;\n                }\n            }\n            if (cnt > 2) {\n                ans -= powmod(2, cnt) - 1 - cnt - cnt * (cnt - 1) / 2;\n            }\n        }\n    }\n    cout << (ans + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<long long, long long> P;\ntypedef pair<P, P> L;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 998244353\n\nint N;\nint X[200], Y[200];\nint p2[201];\n\nlong long gcd(long long a, long long b) {\n  if (a > b) swap(a, b);\n  if (a == 0) return b;\n  return gcd(b%a, a);\n}\n\nP reg(long long p, long long q) {\n  if (q < 0) p = -p, q = -q;\n  if (q == 0) return P(1, 0);\n  long long g = gcd(abs(p), abs(q));\n  p /= g, q /= g;\n  return P(p, q);\n}\nP pls(P a, P b) {\n  return reg(a._1*b._2 + a._2*b._1, a._2*b._2);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> X[i] >> Y[i];\n  p2[0] = 1;\n  for (int i=1; i<=200; i++) p2[i] = (2LL*p2[i-1]) % MOD;\n  vector<L> ls;\n  rep(i, N) {\n    rep(j, i) {\n      int x1 = X[i], x2 = X[j], y1 = Y[i], y2 = Y[j];\n      if (x1 == x2) {\n        ls.pb(L(reg(1, 0), reg(x1, 1)));\n      }\n      else {\n        P a = reg(y2-y1, x2-x1);\n        P c = reg(y1*(x2-x1) - x1*(y2-y1), x2-x1);\n        // cout<<\"(\"<<a._1<<\",\"<<a._2<<\"), (\"<<c._1<<\",\"<<c._2<<\")\\n\";\n        ls.pb(L(a, c));\n      }\n    }\n  }\n  sort(all(ls)); uniq(ls);\n\n  int s = 0;\n  for (L l : ls) {\n    P a = l._1, b = l._2;\n    int n = 0;\n    rep(i, N) {\n      int x = X[i], y = Y[i];\n      if (a == reg(1, 0)) {\n        if (x == b._1) n++;\n      }\n      else {\n        // y = ax + b\n        if (reg(y, 1) == pls(reg(a._1*x, a._2), b)) n++;\n      }\n    }\n    s += p2[n]-n-1;\n    s %= MOD;\n  }\n  s += N+1;\n  s %= MOD;\n  cout << ((p2[N] - s + MOD) % MOD) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint N;\nint x[220], y[220];\nint tw[220];\nint mod = 998244353;\n\nsigned main() {\n    tw[0] = 1;\n    for (int i = 1; i < 220; i++) {\n        tw[i] = tw[i - 1] * 2 % mod;\n    }\n    cin >> N;\n    for (int i = 0; i < N; i++)cin >> x[i] >> y[i];\n\n    int ans = (tw[N] - N - 1 + mod) % mod;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int cur = 0;\n            for (int k = j + 1; k < N; k++) {\n                if ((x[i] - x[j]) * (y[i] - y[k]) == (x[i] - x[k]) * (y[i] - y[j])) cur++;\n            }\n            (ans += mod - tw[cur]) %= mod;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 210, MOD = 998244353;\nint power(int a,int b) {\n  int ret = 1;\n  while (b) {\n    if (b & 1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\ntypedef double db;\nstruct point {\n  db x,y;\n  point(db x_=0, db y_=0): x(x_), y(y_) {}\n  point operator + (const point& a) const {\n    return point(x + a.x, y + a.y);\n  }\n  point operator - (const point& a) const {\n    return point(x - a.x, y - a.y);\n  }\n} po[N];\ndb cross(const point& a,const point& b) {\n  return a.x * b.y - a.y * b.x;\n}\nint n,ans,vis[N];\nint main() {\n  scanf(\"%d\",&n);\n  for (int i = 1, x, y ; i <= n ; ++ i) {\n    scanf(\"%d%d\",&x,&y);\n    po[i] = point(x,y);\n  }\n  ans = power(2, n);\n  for (int i = 1 ; i <= n ; ++ i) {\n    memset(vis,0,sizeof vis);\n    ans --;\n    for (int j = i + 1 ; j <= n ; ++ j) {\n      if (vis[j]) continue;\n      int num = 1;\n      for (int k = j + 1 ; k <= n ; ++ k) {\n\tif (cross(po[k] - po[i], po[k] - po[j]) != 0) continue;\n\tvis[k] = 1;\n\t++ num;\n      }\n      (ans -= power(2, num) - 1) %= MOD;\n    }\n  }\n  ans --;\n  ans = (ans % MOD + MOD) % MOD;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=205,P=998244353;\n\nint n,x[N],y[N],p[N];\n\nint main()\n{\n\tin,n;\n\tfo1(i,n)in,x[i],y[i];\n\tp[0]=1;fo1(i,n)p[i]=p[i-1]*2%P;\n\tint ans=p[n]-1;\n\tfo1(i,n)\n\t{\n\t\tstd::map<pii,int>t;\n\t\tfo1(j,i-1)\n\t\t{\n\t\t\tint a=x[j]-x[i],b=y[j]-y[i],c;\n\t\t\tif(a<0)a=-a,b=-b;\n\t\t\telse if(!a&&b<0)b=-b;\n\t\t\tc=gcd(a,abs(b));\n\t\t\ta/=c,b/=c;\n\t\t\tt[mp(a,b)]++;\n\t\t}\n\t\t//foe(j,t)out,j->xx.xx,' ',j->xx.yy,' ',j->yy,'\\n';out,'\\n';\n\t\tfoe(j,t)ans=(ans+P-p[j->yy]+1)%P;\n\t\tans=(ans+P-1)%P;\n\t}\n\tout,ans,'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// EPS\nconstexpr double EPS = 1e-9;\n/// --- Geometory Library {{{ ///\nusing Point = complex<int>;\n#define X real()\n#define Y imag()\n#define dot(a, b) real(conj(a)*b)\n#define cross(a, b) imag(conj(a)*b)\n#define norm abs\n\n// +1 : ccw\n// -1 : cw\n// +2 : a--b--c\n// -2 : b--c--a\n//  0 : b--a--c\n// int ccw(Point a, Point b, Point c) {\n//   b -= a; c -= a;\n//   if(cross(b, c) > EPS) return +1;\n//   if(cross(b, c) < -EPS) return -1;\n//   if(dot(b, c) < 0) return 0;\n//   if(norm(b) < norm(c)) return +2;\n//   return -2;\n// }\n//\n// double arg(Point a, Point b) {\n//   return acos(dot(a, b) / norm(a) / norm(b));\n// }\n/// ---}}} ///\n\nbool para(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  return b.X * c.Y == b.Y * c.X;\n}\n\nconstexpr ll mod = 998244353;\n\n/// --- modulo Library {{{ ///\nconstexpr ll extgcd(ll a, ll b, ll& x, ll& y) {\n  if(b==0) {\n    x = 1; y = 0;\n    return a;\n  }\n  ll d = extgcd(b, a % b, y, x);\n  y -= (a / b) * x;\n  return d;\n}\nconstexpr ll modpow(ll a, ll b, ll mod = 1e9 + 7) {\n  a = (a % mod + mod) % mod;\n  ll r = 1;\n  while(b){\n    if(b & 1) r = r * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return r;\n}\nconstexpr ll modinv(ll a, ll mod = 1e9 + 7) {\n  a = (a % mod + mod) % mod;\n  ll x = 0, y = 0;\n  extgcd(a, mod, x, y);\n  return (x % mod + mod) % mod;\n}\ntemplate<int N, int mod = 1e9 + 7> struct Factorial {\n  int arr[N+1], inv[N+1];\n  int operator[](int i) const { return arr[i]; }\n  constexpr Factorial(): arr(), inv() {\n    arr[0] = 1;\n    for(int i = 1; i <= N; i++) {\n      arr[i] = (ll) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N], mod);\n    for(int i = N-1; i >= 0; i--) {\n      inv[i] = (ll) (i + 1) * inv[i + 1] % mod;\n    }\n  }\n  int C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    return (ll) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n};\n/// }}}--- ///\n\nconstexpr Factorial<200, mod> fact;\n\nbool done[200][200];\n\n// 点集合のうち,(同一直線上の点のみを選ぶ)を覗いた集合の数とスコアが一致\n// O(N^3)\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n; cin >> n;\n  vector<Point> p(n);\n  for(int i = 0; i < n; i++) {\n    int x, y; cin >> x >> y;\n    p[i] = Point(x, y);\n  }\n  ll ans = modpow(2, n, mod) - fact.C(n, 2) - n - 1;\n  ans %= mod;\n  for(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++) {\n    if(done[i][j]) continue;\n    int cnt = 2;\n    for(int k = j + 1; k < n; k++) {\n      if(para(p[i], p[j], p[k])) cnt++, done[i][k] = done[j][k] = 1;\n    }\n    ans -= modpow(2, cnt, mod) - fact.C(cnt, 2) - cnt - 1;\n    ans %= mod;\n  }\n  cout << (ans % mod + mod) % mod << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll=long long;\n#define int ll\n \n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DMP(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n \nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n \ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n \ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n \nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n \nvoid printSpace(){\n\tprintf(\" \");\n}\n \nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n \nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n \nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n \nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n \ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n \ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n \ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n \nconst int inf=LLONG_MAX/3;\n\nconst int mod=998244353;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\ta=((ll)a+b)%mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\ta=((ll)a-b%mod+mod)%mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\tmult(s,a);\n\t\tmult(a,a);\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nstruct Pos{\n\tint x,y;\n};\nint cross(const Pos&a,const Pos&b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nsigned main(){\n\tint n=read(),dp[4]{1,0,0,0};\n\tREP(_,n){\n\t\tint k=dp[3];\n\t\tfor(int i=3;i>=1;i--)\n\t\t\tadd(dp[i],dp[i-1]);\n\t\tadd(dp[3],k);\n\t}\n\tvector<Pos> ps;\n\tREP(i,n){\n\t\tint x=read(),y=read();\n\t\tps.PB(Pos{x,y});\n\t}\n\tsort(ALL(ps),[&](const Pos&a,const Pos&b){\n\t\treturn a.x!=b.x?(a.x<b.x):(a.y<b.y);\n\t});\n\tREP(_,n){\n\t\tvector<Pos> cur;\n\t\tREP(i,_)\n\t\t\tcur.PB(Pos{ps[i].x-ps[_].x,ps[i].y-ps[_].y});\n\t\tsort(ALL(cur),[&](const Pos&a,const Pos&b){\n\t\t\treturn cross(a,b)>0;\n\t\t});\n\t\tint num=0;\n\t\tREP(i,cur.size()){\n\t\t\t//cerr<<_<<\" \"<<num<<endl;\n\t\t\tsub(dp[3],modPow(2,num++)-1);\n\t\t\tif(i+1==int(cur.size())||cross(cur[i],cur[i+1])!=0)\n\t\t\t\tnum=0;\n\t\t}\n\t}\n\tcout<<dp[3]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef pair<pi,pi> ppi;\n\nconst int N=205,P=998244353;\n\nmap<ppi,int>D;\nint n,x[N],y[N],p2[N],m,t;\n\ninline int gcd(int x,int y){return y?gcd(y,x%y):x;}\ninline pi mk(pi x){\n\tll g=gcd(x.fi,x.se);\n\tif(g)x.fi/=g,x.se/=g;\n\tif(x.fi<0)x.fi=-x.fi,x.se=-x.se;\n\telse if(x.fi==0&&x.se<0)x.se=-x.se;\n\treturn x;\n}\ninline ppi mp(ll u1,ll v1,ll u2,ll v2){\n\tpi l=mk({u2-u1,v2-v1}),s;\n\tif(l.fi)s=mk({v1*l.fi-u1*l.se,l.fi});else s={u1,0};\n\treturn {l,s};\n}\ninline int get(int s){return (1+sqrt(1+8*s+0.5))/2;}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tp2[0]=1;\n\tfor(int i=1;i<=n;i++)p2[i]=(p2[i-1]<<1)%P,scanf(\"%d%d\",&x[i],&y[i]);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<i;j++)D[mp(x[i],y[i],x[j],y[j])]++;\n\tm=p2[n];\n\tfor(auto&i:D)t=get(i.se),m=(m-p2[t]+t+1+P)%P;\n\tm=(m-n-1+P)%P;\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=210,p=998244353;\nstruct P{\n\tint x,y;\n\tP(int x=0,int y=0):x(x),y(y){}\n};\ninline P operator-(P u,P v){return P(u.x-v.x,u.y-v.y);}\ninline int cross(P u,P v){return u.x*v.y-u.y*v.x;}\n\nP o[N];\nint n,fac[N],inv[N];\ninline void D(int &x,int y){x-=y;if (x<0) x+=p;}\ninline void A(int &x,int y){x+=y;if (x>=p) x-=p;}\ninline int C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%p*inv[x-y]%p;\n}\ninline int qmi(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=1ll*x*x%p) if (y&1) ans=1ll*ans*x%p;\n\treturn ans;\n}\ninline int get_inv(int x){\n\treturn qmi(x,p-2);\n}\ninline int calc(int n){\n\treturn (qmi(2,n)-(1+C(n,1)+C(n,2))%p+p)%p;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==1) return puts(\"0\"),0;\n\tfac[0]=1;for (int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%p;\n\tinv[0]=inv[1]=1;for (int i=2;i<=n;++i) inv[i]=1ll*inv[p%i]*(p-p/i)%p;\n\tfor (int i=2;i<=n;++i) inv[i]=1ll*inv[i]*inv[i-1]%p;\n\tfor (int i=1;i<=n;++i) scanf(\"%d%d\",&o[i].x,&o[i].y);\n\tint ans=calc(n);\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j)if (i!=j){\n\t\t\tint tot=2;\n\t\t\tfor (int k=1;k<=n;++k) if (k!=i&&k!=j) tot+=(cross(o[k]-o[i],o[j]-o[i])==0);\n\t\t\tD(ans,1ll*calc(tot)*get_inv(tot*tot-tot)%p);\n\t\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int md = 998244353;\n \ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n \ninline int mul(int a, int b) {\n  return (long long) a * b % md;\n}\n \ninline int power(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n \ninline int inv(int x) {\n  return power(x, md - 2);\n}\n \nconst int N = 12345;\n \nint x[N], y[N];\n \nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", x + i, y + i);\n  }\n  int ans = power(2, n);\n  add(ans, md - 1);\n  add(ans, md - n);\n  add(ans, md - n * (n - 1) / 2);\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int a = y[j] - y[i];\n      int b = x[i] - x[j];\n      int c = -a * x[i] - b * y[i];\n      int cnt = 2;\n      for (int k = 0; k < n; k++) {\n        if (k == i || k == j) {\n          continue;\n        }\n        int z = a * x[k] + b * y[k] + c;\n        if (z != 0) {\n          continue;\n        }\n        if (k < j) {\n          break;\n        }\n        cnt++;\n      }\n      add(ans, md - power(2, cnt));\n      add(ans, 1);\n      add(ans, cnt);\n      add(ans, cnt * (cnt - 1) / 2);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-15;\nconst int MOD = 998244353;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n  unsigned get() const { return x; }\n\n  // 逆数\n  ModInt inv() const {\n    ll a = 1, p = x, e = MOD-2;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // e乗\n  ModInt pow(ll e) {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // 2のx乗\n  ModInt pow2() {\n    ll a = 1, p = 2, e = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  ModInt &operator+=(ModInt that) {\n    x = ((ll)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((ll)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (ll)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (ll)x * that.inv() % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (ll)x % that.x;\n    return *this;\n  }\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\nP p[205];\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) {\n    double x, y;\n    cin >> x >> y;\n    p[i] = {x, y};\n  }\n\n  mint ret = mint(n).pow2() - n - 1;\n  // 頂点i,jの線分上の点の数を数える\n  REP(i, n) FOR(j, i+1, n) {\n    if(!(p[i] < p[j])) continue;\n    mint cnt = 0;\n    REP(k, n) {\n      if(!(p[i]<p[k]) || !(p[k]<p[j])) continue;\n      if(dot(p[k]-p[i], p[j]-p[i]) == 0) {\n        ++cnt;\n      }\n    }\n    ret -= cnt.pow2();\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define mod 998244353\n#define P pair<int,int>\nusing namespace std;\n\nP a[200];\nsigned main() {\n\tint ans = 1;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = ans * 2 % mod;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t}\n\tans -= n + 1;\n\tans %= mod;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tvector<int>V;\n\t\t\tif (a[i].first == a[j].first) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].first == a[i].first) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (a[i].second == a[j].second) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].second == a[i].second) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble x = double(a[j].second - a[i].second) / (a[j].first - a[i].first);\n\t\t\t\tdouble y = double(a[i].second) - a[i].first*x;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (abs(a[i].first*x + y - a[i].second) <= 1e-10) {\n\t\t\t\t\t\tV.push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(V.begin(), V.end());\n\t\t\tif (V.size()>=2&&V[0] == i&&V[1]==j) {\n\t\t\t\tint k = 1;\n\t\t\t\tfor (int j : V) {\n\t\t\t\t\tk = k * 2 % mod;\n\t\t\t\t}\n\t\t\t\tk -= V.size(); k--;\n\t\t\t\tans -= k;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tans += mod;\n\tans %= mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < int(n); ++i)\n#define REPE(i, a, b) for (int i = (a); i <= int(b); ++i)\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n#define EB emplace_back\nusing LL = long long;\nusing PII = pair<int, int>;\n#define F first\n#define S second\n\nint n;\nPII a[222];\n\nLL dp[222][222][222];\n\nLL p[222];\nconst LL mod = 998244353;\n\nPII operator-(const PII &a, const PII &b) {\n  return {a.F - b.F, a.S - b.S};\n}\nostream& operator<<(ostream &os, const PII &a) {\n  os << \"(\" << a.F << \",\" << a.S << \")\";\n  return os;\n}\n\nint dir(int x, int y, int z) {\n  PII v1 = a[y] - a[x];\n  PII v2 = a[z] - a[x];\n  LL r = 1LL * v1.F * v2.S - 1LL * v1.S * v2.F;\n  return r == 0 ? 0 : (r > 0 ? 1 : -1);\n}\n\nbool f(int x, int y, int z) {\n  PII v1 = a[y] - a[x];\n  PII v2 = a[z] - a[x];\n  return 1LL * v1.F * v2.S - 1LL * v1.S * v2.F > 0;\n}\n\nLL g(int x, int y, int z) {\n  LL &r = dp[x][y][z];\n  if (r >= 0) return r;\n  int c1 = 0, c2 = 0;\n  r = 0;\n  for (int i = x + 1; i < n; ++i) {\n    if (y != i && z != i) {\n      if (dir(x, y, i) >= 0 && dir(y, z, i) >= 0) {\n        int t = dir(z, x, i);\n        if (t >= 0) {\n          if (t == 0) c1++;\n          else if (t == 1) c2++;\n        }\n      }\n      if (f(x, z, i) && f(y, z, i)) {\n        r += g(x, z, i);\n        r %= mod;\n      }\n    }\n  }\n  r = (r * p[c2] + p[c1 + c2]) % mod;\n  return r;\n}\n\n\nint main() {\n  p[0] = 1;\n  REPE(i, 1, 221) p[i] = p[i - 1] * 2 % mod;\n  scanf(\"%d\", &n);\n  REP(i, n) scanf(\"%d%d\", &a[i].F, &a[i].S);\n  sort(a, a + n);\n  memset(dp, -1, sizeof dp);\n  LL ans = 0;\n  REP(i, n) {\n    for (int j = i + 1; j < n; ++j) {\n      for (int k = i + 1; k < n; ++k) if (j != k && f(i, j, k)) {\n        ans += g(i, j, k);\n        ans %= mod;\n        // cout << a[i] << ' ' << a[j] << ' ' << a[k] << \": \" << g(i, j, k) << endl;\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=205,mo=998244353;\nint n,x,i,dn,pw[N],ans;\nstruct arr{int x,y;}a[N],d[N];\nint cross(arr A,arr B){return A.x*B.y-B.x*A.y;}\nbool operator < (arr A,arr B){return cross(A,B)>0;}\nint main(){\n\tfor (scanf(\"%d\",&n),i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfor (pw[0]=1,i=1;i<=n;i++) pw[i]=pw[i-1]*2%mo;\n\tans=pw[n]-1-n;\n\tfor (int x=1;x<=n;x++){\n\t\tfor (dn=0,i=x+1;i<=n;i++) if (i!=x){\n\t\t\td[++dn]=(arr){a[i].x-a[x].x,a[i].y-a[x].y};\n\t\t\tif (d[i].x<0) d[i].x=-d[i].x,d[i].y=-d[i].y;\n\t\t\tif (d[i].x==0&&d[i].y>0) d[i].y=-d[i].y;\n\t\t}\n\t\tsort(d+1,d+dn+1);int k=0;\n\t\tfor (i=1;i<=dn;i++){\n\t\t\tif (!cross(d[i-1],d[i])) k++;\n\t\t\telse ans=(ans-pw[k]+1)%mo,k=1;\n\t\t}\n\t\tans=(ans-pw[k]+1)%mo;\n\t}\n\tprintf(\"%d\",(ans+mo)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst LL MOD = 998244353LL;\nint x[200], y[200];\nLL p2[201];\nbool used[200][200];\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tp2[0] = 1;\n\tfor (int i = 1; i <= N; i++) p2[i] = (p2[i - 1] * 2) % MOD;\n\tLL ans = p2[N];\n\tLL sub = 1 + N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tif (used[i][j]) continue;\n\t\t\tvector<int> v;\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif ((x[j] - x[i])*(y[k] - y[i]) == (y[j] - y[i])*(x[k] - x[i])) {\n\t\t\t\t\tv.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < v.size(); k++) {\n\t\t\t\tfor (int l = 0; l < v.size(); l++) used[v[k]][v[l]] = 1;\n\t\t\t}\n\t\t\t(sub += p2[v.size()]) %= MOD;\n\t\t\tsub = (sub - (1 + v.size()) + MOD) % MOD;\n\t\t}\n\t}\n\tans = (ans - sub + MOD) % MOD;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Mod = 998244353, Nmax = 205;\n\nstruct Fractie\n{\n    int up, down;\n    bool operator < (const Fractie &other) const\n    {\n        return up * other.down < down * other.up;\n    }\n\n    bool operator == (const Fractie &other) const\n    {\n        return up * other.down == down * other.up;\n    }\n} v[Nmax];\n\nstruct Point\n{\n    int x, y;\n    bool operator < (const Point &other) const\n    {\n        if(x == other.x) return y < other.y;\n        return x < other.x;\n    }\n} a[Nmax];\n\nint pw[Nmax], i, n, ans, j, k;\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n\n    cin >> n;\n    for(i=1; i<=n; ++i) cin >> a[i].x >> a[i].y;\n    sort(a+1, a+n+1);\n\n    pw[0] = 1;\n    for(i=1; i<=n; ++i)\n        pw[i] = pw[i-1] * 2 % Mod;\n\n    ans = pw[n] - n - 1;\n    for(i=1; i<=n; ++i)\n    {\n        for(j=i+1; j<=n; ++j) v[j-i] = {a[j].y - a[i].y, a[j].x - a[i].x};\n        sort(v+1, v+n-i+1);\n\n        for(j=1; j<=n-i; ++j)\n        {\n            k = j;\n            while(k < n-i && v[j] == v[k+1]) ++k;\n            ans -= pw[k-j+1] - 1;\n            if(ans < 0) ans += Mod;\n            j = k;\n        }\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst int MOD = 998244353;\n\ni64 comb[202][202];\n\nvoid init() {\n    comb[0][0] = 1;\n    for (int j = 1; j <= 200; ++j) {\n        for (int k = 0; k <= 200; ++k) {\n            comb[j][k] = comb[j-1][k];\n            if (k > 0) {\n                comb[j][k] = (comb[j][k] + comb[j-1][k-1]) % MOD;\n            }\n        }\n    }\n}\n\nint N;\nint x[200], y[200];\n\nint main() {\n    init();\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> N;\n    for (int j = 0; j < N; ++j) {\n        cin >> x[j] >> y[j];\n    }\n\n    if (N < 3) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    i64 s = 1;\n    for (int j = 0; j < N; ++j) {\n        s = (s * 2) % MOD;\n    }\n    s = (s + MOD - 1 - N - N * (N-1) / 2)  % MOD;\n\n    for (int j = 0; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n            i64 q = 0;\n            for (int l = 0; l < N; ++l) {\n                if (j == l || k == l) continue;\n                i64 dx1 = x[l] - x[j], dy1 = y[l] - y[j];\n                i64 dx2 = x[l] - x[k], dy2 = y[l] - y[k];\n\n                i64 d = dx1 * dx2 + dy1 * dy2;\n\n                if (d < 0 && d * d == (dx1 * dx1 + dy1 * dy1) * (dx2 * dx2 + dy2 * dy2)) {\n                    ++q;\n                }\n            }\n            s = (s + MOD - (1LL << q) + 1) % MOD;\n        }\n    }\n    cout << s << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<pair<int,int> >se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\tif(se.find({i,j})!=se.end())continue;\n\t\tL l(v[i],v[j]);\n\t\tvector<int>x={i,j};\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectLP(l,v[k]))x.push_back(k);\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\tint n=b-a-1;\n\t\t\tr=(r-pow_binary_mod(2,n,M))%M;\n\t\t\tse.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FI first\n#define SE second\n#define PB push_back\n#define ll long long\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ROF(i,a,b) for(int i=b-1;i>=a;i--)\n#define YES(i) cout<<(i?\"YES\":\"NO\")<<endl\n#define Yes(i) cout<<(i?\"Yes\":\"No\")<<endl\n#define co(i) cout<<i<<endl\n#define fcout cout<<fixed<<setprecision(10)\n#define uni(i) i.erase(unique(i.begin(), i.end()), i.end());\nusing namespace std;\n\nconst int INF=1e9+7;\nconst int MOD=998244353;\n\ntypedef pair<int,int> PA;\ntypedef pair<int,PA> PA2;\n\nint comb[201][201];\n\nvoid comb_prepair(){\n    memset(comb,0,sizeof(comb));\n    FOR(i,1,201){\n        FOR(j,0,i+1){\n            if(j==0||j==i) comb[i][j]=1;\n            else (comb[i][j]=comb[i-1][j-1]+comb[i-1][j])%=MOD;\n        }\n    }\n}\n\nint gcd(int a,int b){\n    a=abs(a); b=abs(b);\n    if(a==0||b==0) return a+b;\n    else if(a>=b) return gcd(a%b,b);\n    else return gcd(a,b%a);\n}\n\nint main(){\n    int n; cin>>n;\n    vector<PA2> v;\n    vector<PA> z;\n    FOR(i,0,n){\n        int x,y; cin>>x>>y;\n        z.PB(PA(x,y));\n    }\n    ll ans=0;\n    if(n>=3){\n        comb_prepair();\n        FOR(i,0,n){\n            FOR(j,i+1,n){\n                int a=z[i].FI, b=z[i].SE, c=z[j].FI, d=z[j].SE;\n                int s=b-d, t=a-c, u=b*c-a*d;\n                if(s<0){\n                    s*=-1; t*=-1; u*=-1;\n                }\n                int g=gcd(gcd(s,t),u);\n                s/=g; t/=g; u/=g;\n                v.PB(PA2(s,PA(t,u)));\n            }\n        }\n        //co(\"test\");\n        v.PB(PA2(INF,PA(INF,INF)));//番兵\n        sort(v.begin(),v.end());\n        FOR(i,3,n+1){\n            ans+=comb[n][i];\n            ans%=MOD;\n        }\n        PA2 p=v[0];\n        int k=1;\n        int b[20000]={};\n        FOR(i,1,201){\n            b[i*(i-1)/2]=i;\n        }\n        FOR(i,1,v.size()){\n            PA2 q=v[i];\n            if(p!=q){\n                k=b[k];\n                //co(k);\n                FOR(j,3,k+1){\n                    ans+=(MOD-comb[k][j]);\n                    ans%=MOD;\n                }\n                k=1;\n                p=q;\n            }else{\n                k++;\n            }\n        }\n    }\n    co(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing\tnamespace\tstd;\n#define ll long long\n#define\tllu\tunsigned\tlong\tlong\n#define\tld\tdouble\n#define\tllu\tunsigned\tlong\tlong\n#define\trep(i,x,y)\t\tfor(ll\ti=x;i<y;++i)\n#define\tFor(i,x,y)\t\tfor(ll\ti=x;i<=y;++i)\n#define\tFOr(i,x,y)\t\tfor(ll\ti=ll(x);i>=ll(y);--i)\n#define\tpi\tacos(-1)\t\n#define\tmk\tmake_pair\n#define\tpa\tpair<ll,ll>\n#define\tlf\telse\tif\n#define\tIL\tinline\n#define\tmax(x,y)\t\t\t\t((x)<(y)?(y):(x))\n#define\tmin(x,y)\t\t\t\t((x)<(y)?(x):(y))\n#define\tsqr(x)\t\t\t\t\t\t((x)*(x))\n#define\tMul(x,y)\t\t\t\t((x)=1LL*(x)*(y)%mod)\n#define\tAdd(x,y)\t\t\t\t((x)=((x)+(y))%mod)\n#define\tMax(x,y)\t\t\t\t((x)=((x)<(y)?(y):(x)))\n#define\tMin(x,y)\t\t\t\t((x)=((x)>(y)?(y):(x)))\n#define\tE(x)\t\t\t\t\treturn\twriteln(x),0\n#define\tLL\t\t\t\t\t\t(long\tlong)\n#define\tp(x)\t\t\t\t\tprllf(\"~%lld~\\n\",LL(x))\n#define\tpp(x,y)\t\t\t\t\tprllf(\"~~%lld\t%lld~~\\n\",LL(x),LL(y))\n#define\tppp(x,y,z)\t\t\t\tprllf(\"~~~%lld\t%lld\t%lld~~~\\n\",LL(x),LL(y),LL(z))\n#define\tpppp(a,b,c,d)\t\t\tprllf(\"~~~%lld\t%lld\t%lld\t%lld\\n\",LL(a),LL(b),LL(c),LL(d))\n#define\tf_in(x)\t\t\t\t\tfreopen(x\".in\",\"r\",stdin)\n#define\tf_out(x)\t\t\t\tfreopen(x\".out\",\"w\",stdout)\n#define\topen(x)\t\t\t\t\tf_in(x),f_out(x)\n#define\tfi\tfirst\n#define\tse\tsecond\n#define\tGuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\ntypedef\tcomplex<double>\tE;\nnamespace\tSHENZHEBEI{\n#ifdef\tLOCAL\n\t\t\t\tstruct\t_{_(){freopen(\"cf.in\",\"r\",stdin);}}_;\n#endif\t\n#define\tNEG\t1\n\t\t\t\tinline\tchar\tgc(){\treturn\tgetchar();\t}\n#if\tNEG\n\t\t\t\tinline\tll\tread(){\t\t\t\tll\tx=0,fa=1;\tchar\tch=gc();\t\t\tfor\t(;!isdigit(ch);ch=gc())\tif\t(ch=='-')\tfa=-1;\t\tfor\t(;isdigit(ch);ch=gc())\t\tx=x*10-48+ch;\t\t\treturn\tx*fa;\t}\n\t\t\t\tinline\tvoid\twrite(ll\tx){\t\t\t\tif\t(x<0)\tputchar('-'),x=-x;\t\tif\t(x>=10)\t\t\twrite(x/10);\t\t\t\tputchar(x%10+'0');\t\t}\n#else\n\t\t\t\tinline\tll\tread(){\t\t\t\tll\tx=0;\tchar\tch=gc();\t\t\tfor\t(;!isdigit(ch);ch=gc());\t\t\t\tfor\t(;isdigit(ch);ch=gc())\t\tx=x*10-48+ch;\t\t\treturn\tx;\t\t\t}\n\t\t\t\tinline\tvoid\twrite(ll\tx){\t\t\t\tif\t(x>=10)\t\t\twrite(x/10);\t\t\t\tputchar(x%10+'0');\t\t}\n#endif\n\tvoid\twriteln(ll\tx){write(x);puts(\"\");}\n}using\tnamespace\tSHENZHEBEI;\nconst ll N=205,mod=998244353;\nll n,x[N],y[N],bin[N],ans,cnt;\nint main(){\n\tn=read();\tbin[0]=1;For(i,1,n)bin[i]=bin[i-1]*2%mod;\n\tll ans=(bin[n]-n-1)%mod;\n\tFor(i,1,n)For(j,i+1,n){\n\t\tll sum=0;\n\t\tFor(k,j+1,n)cnt+=(x[i]-x[k])*(y[j]-y[k])==(x[j]-x[k])*(y[i]-y[k]);\n\t\tAdd(ans,-bin[sum]);\n\t}writeln((ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i*i <= N; ++i)\n\t{\n\t\tif (N%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD> &other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<998244353> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\ntemplate<typename RET = mint, typename Integral>\nRET combination(Integral all, Integral get)\n{\n\tassert(all >= get);\n\tget = std::min(all - get, get);\n#if 1\n\t//時間計算量O(logMOD)\n\tstatic const auto fact_v = fact_set_c<100001>();\n\treturn fact_v[all] / (fact_v[get] * fact_v[all - get]);\n#elif 0\n\t//時間計算量O(1)\n\t//空間計算量、初期化時間計算量O(N^2)\n\tconstexpr int32_t ALL_MAX = 10'000;\n\tstatic std::vector<RET> DP_comb[ALL_MAX + 1];\n\tif (!DP_comb[all].empty())\n\t{\n\t\treturn DP_comb[all][get];\n\t}\n\n\tif (DP_comb[0].empty())\n\t{\n\t\tDP_comb[0].resize(1);\n\t\tDP_comb[0][0] = (RET)1;\n\t\tDP_comb[1].resize(1);\n\t\tDP_comb[1][0] = (RET)1;\n\t}\n\tfor (int32_t i = 2; i <= all; i++)\n\t{\n\t\tif (DP_comb[i].empty())\n\t\t{\n\t\t\tint32_t size = i / 2 + 1;\n\t\t\tDP_comb[i].resize(size);\n\t\t\tDP_comb[i][0] = (RET)1;\n\t\t\tfor (int32_t j = 1; j < size - 1; j++)\n\t\t\t{\n\t\t\t\tDP_comb[i][j] = DP_comb[i - 1][j - 1] + DP_comb[i - 1][j];\n\t\t\t}\n\t\t\tDP_comb[i][size - 1] = DP_comb[i - 1][size - 2] + DP_comb[i - 1][(i & 1) ? (size - 1) : (size - 2)];\n\t\t}\n\t}\n\treturn DP_comb[all][get];\n#else\n\t//時間計算量O(get * logMOD)\n\tRET ret = (RET)1;\n\tfor (Integral i = 1; i <= get; ++i)\n\t{\n\t\tret *= all + 1 - i;\n\t\tret /= i;\n\t}\n\treturn ret;\n#endif\n}\n\n\n\nint32_t N;\nusing std::vector;\nstruct P {\n\tint32_t x, y;\n\tint32_t dot(P o) {\n\t\treturn x*o.x + y*o.y;\n\t}\n\tint32_t det(P o) {\n\t\treturn x*o.y - y*o.x;\n\t}\n};\nP operator-(P a, P b) {\n\treturn P{ a.x - b.x, a.y - b.y };\n}\n// 辞書順で比較\ninline bool cmp_x(const P& p, const P& q) {\n\tif (p.x != q.x) return p.x < q.x;\n\treturn p.y < q.y;\n}\n// 凸包を求める\nvector<P> convex_hull(P* ps, int n) {\n\tstd::sort(ps, ps + n, cmp_x);\n\tint k = 0; // 凸包の頂点数\n\tvector<P> qs(n * 2); // 構築中の凸包\n\t\t// 下側凸包の作成\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\t\tqs[k++] = ps[i];\n\t\t}\n\t// 上側凸包の作成\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n// 距離の二乗\ndouble dist(P p, P q) {\n\treturn (p - q).dot(p - q);\n}\n// 入力\nint N;\nP ps[200];\nmint powpow[500];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tin >> ps[i].x >> ps[i].y;\n\t}\n\tpowpow[0] = 1;\n\tfor (size_t i = 1; i < 500; i++)\n\t{\n\t\tpowpow[i] = powpow[i - 1] * 2;\n\t}\n\n\n\tmint res = 0;\n\tvector<P> qs = convex_hull(ps, N);\n\tres += powpow[N - qs.size()];\n\tfor (int32_t i = qs.size(); i >= 0 ; i--)\n\t{\n\t\tres += powpow[std::max(0,N - qs.size()-i)]*i;\n\t}\n\tout << res << endl;\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f1r(i,a,b) for (int i = (a); i < (b); ++i)\n#define f0r(i,a) f1r(i,0,a)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\"; }\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) {\n\t\tre(t); re(ts...); }\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n\t\tpr(t); pr(ts...); }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) {\n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); }\n\ttemplate<class T> void pr(const T& x) {\n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n\t\tpr(\"}\"); }\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tcin.sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 998244353;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n\tT val;\n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(const ll& v) {\n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) {\n\t\tif ((val += m.val) >= MOD) val -= MOD;\n\t\treturn *this; }\n\tmi& operator-=(const mi& m) {\n\t\tif ((val -= m.val) < 0) val += MOD;\n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { val = (ll)val*m.val%MOD;\n\t\treturn *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 205;\npi reduce(pi x){\n    int n = x.f; int d = x.s;\n    if(n == 0){\n        n = 0; d = 1;\n    }\n    else if(d == 0){\n        n = 1; d = 0;\n    }\n    else{\n        int g = __gcd(abs(n), abs(d));\n        n /= g; d /= g;\n        if(d<0){\n            n *= -1;\n            d *= -1;\n        }\n    }\n    return mp(n, d);\n}\npi get_slope(pi a, pi b){\n    return reduce(mp(b.s - a.s, b.f - a.f));\n}\nmi po[MAX];\nvpi pts;\nint main(){\n    int n; re(n);\n    pts.resz(n);\n    f0r(i, n) re(pts[i].f, pts[i].s);\n    set<pair<pi, pi>> lines;\n    f0r(i, MAX) po[i] = pow(mi(2), i);\n    mi ans = po[n] - 1 - n;\n    f0r(i, n){\n        f1r(j, i, n){\n            if(pts[i] == pts[j]) continue;\n            int a = pts[i].f;\n            int b = pts[i].s;\n            int c = pts[j].f;\n            int d = pts[j].s;\n            pi slope = reduce(mp(d-b,c-a));\n            pi intercept = reduce(mp(b*c-a*d,c-a));\n            if(lines.find(mp(slope, intercept)) != lines.end()) continue;\n            lines.insert(mp(slope, intercept));\n            int cnt = 2;\n            f0r(k, n){\n                if(k == i || k == j) continue;\n                if(get_slope(pts[i], pts[k]) == get_slope(pts[j], pts[k])) cnt++;\n            }\n            ans -= (po[cnt] - 1 - cnt);\n        }\n    }\n    ps(ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 998244353;\nll N;\nvector<pair<ll, ll>> Points;\nmap<tuple<ll, ll, ll>, ll> Count;\nmap<ll, ll> InvNC2;\nvector<ll> Pow;\nll R;\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll pow_multi(ll n) { return (Pow[n] + MOD - n - 1) % MOD; }\nint main() {\n  cin >> N;\n  for (ll i = 0; i < N; ++i) {\n    ll x, y;\n    cin >> x >> y;\n    Points.push_back(make_pair(x, y));\n  }\n  for (ll i = 0; i < N; ++i)\n    for (ll j = i + 1; j < N; ++j) {\n      ll x, y, x2, y2;\n      tie(x, y) = Points[i];\n      tie(x2, y2) = Points[j];\n      ll dx = x2 - x, dy = y2 - y;\n      // ax+by=c, a>=0, a and b are coprime\n      ll a = dy, b = -dx;\n      if (a < 0) {\n        a *= -1;\n        b *= -1;\n      }\n      ll g = gcd(abs(a), abs(b));\n      a /= g;\n      b /= g;\n      ll c = a * x + b * y;\n      ++Count[make_tuple(a, b, c)];\n    }\n  for (ll i = 0; i <= N; ++i) InvNC2[i * (i - 1) / 2] = i;\n  Pow.resize(N + 1);\n  Pow[0] = 1;\n  for (ll i = 1; i <= N; ++i) Pow[i] = 2 * Pow[i - 1] % MOD;\n  R = pow_multi(N);\n  for (const auto &linecount : Count) {\n    ll k = InvNC2.at(linecount.second);\n    (R += MOD - pow_multi(k)) %= MOD;\n  }\n  cout << R << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//A,Elebereth Gilthoniel mantae!\n//For Temeria!\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<cstdio>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cstring> \nusing namespace std;\nvector<long long> siz;long long vis[205][205];long long mod=998244353;\nlong long quipow(long long a,long long b)\n{\n    long long ans=1;\n     while(b)\n     {\n         if(b&1) ans=ans*a%mod;\n         b>>=1;\n         a=a*a%mod;\n     }\n     return ans%mod;\n}\nlong long fac[505],inv[505];\nvoid prepare()    \n{\n    fac[0]=fac[1]=1;\n    for(long long i=2;i<=500;i++)   fac[i]=fac[i-1]*i%mod;\n\n    inv[500]=quipow(fac[500],mod-2);\n    for(long long i=500-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\npair<double,double> p[505];\nint main()\n{\n \t//freopen(\"\",\"r\",stdin);\n\t//freopen(\"\",\"w\",stdout);\n\tprepare();\n\tlong long n;cin>>n;\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tcin>>p[i].first>>p[i].second;\n\t}\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tfor(long long j=0;j<n;j++)\n\t\t{\n\t\t\tvector<int> v;v.clear();\n\t\t\tif(i==j or(vis[i][j]==1)) continue;v.push_back(i);v.push_back(j);\n\t\t\tif(p[i].first==p[j].first)\n\t\t\t{\n\t\t\t\tlong long u=0;u++;u++;\n\t\t\t\tfor(long long t=0;t<n;t++)\n\t\t\t\t{\n\t\t\t\t\tif(i==t or j==t) continue;\n\t\t\t\t\tif(p[t].first==p[i].first)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.push_back(t);\n\t\t\t\t\t\tu++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u>2)siz.push_back(u);\n\t\t\t\tfor(int t=0;t<v.size();t++) for(int y=0;y<v.size();y++) vis[v[y]][v[t]]=1; \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble k=(p[i].second-p[j].second)/(p[i].first-p[j].first);\n\t\t\tdouble b=p[i].second-p[i].first*k;\n\t\t\tlong long u=0;u++;u++;\n\t\t\tfor(long long t=0;t<n;t++)\n\t\t\t{\n\t\t\t\tif(i==t or j==t) continue;\n\t\t\t\tif(p[t].first*k+b==p[t].second)\n\t\t\t\t{\n\t\t\t\t\tv.push_back(t);\n\t\t\t\t\tu++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(u>2)siz.push_back(u);\n\t\t\tfor(int t=0;t<v.size();t++) for(int y=0;y<v.size();y++) vis[v[y]][v[t]]=1; \n\t\t}\n\t}\n\tlong long ans=0;long long y=n*(n-1);\n\tfor(long long i=3;i<=n;i++)\n\t{\n\t\ty=y*(n-i+1);y=y%mod;\n\t\tans+=y*inv[i];ans=ans%mod;\n\t}\n\tfor(long long i=0;i<siz.size();i++)\n\t{\n\t\ty=(siz[i])*(siz[i]-1);\n\t\tfor(long long j=3;j<=siz[i];j++)\n\t\t{\n\t\t\ty=y*(siz[i]-j+1);y=y%mod;\n\t\t\tans-=y*inv[j];ans=ans%mod;\n\t\t}\n\t}\n\tif(ans<0) ans+=mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100100,mod=998244353;\nint x[N],y[N],pw[N],n,ans;\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n;\n\tpw[0]=1;\n\tfor(int i=1;i<=n;++i)pw[i]=pw[i-1]*2%mod;\n\tfor(int i=1;i<=n;++i)cin>>x[i]>>y[i];\n\tans=(pw[n]-1+mod-n)%mod;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tint cnt=0;\n\t\t\tfor(int k=j+1;k<=n;++k)\n\t\t\t\tif((y[k]-y[j])*(x[k]-x[i])==(y[k]-y[i])*(x[k]-x[j]))++cnt;\n\t\t\tans=(ans-pw[cnt]+mod)%mod;\n\t\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// fest\n#include <bits/stdc++.h>\t\n\n#define pb push_back\n#define F first\n#define S second\n#define y1 dasdasfasfas\n#define x1 wqdadfasfasfas\n#define All(c) c.begin(), c.end()\n#define SZ(A) (int((A).size()))\n#define umap unordered_map\n#define __ fflush(stdout)\n#define FILENAME \"\"\n\ntypedef long long ll;\ntypedef long double ld;    \n\nusing namespace std;\n\nvoid FREOPEN() {\n\t#ifdef LOCAL\n\t\tfreopen(\".in\", \"r\", stdin);\n\t\tfreopen(\"1.out\", \"w\", stdout);\n\t#else\n\t\t//freopen(FILENAME\".in\", \"r\", stdin);\n\t\t//freopen(FILENAME\".out\", \"w\", stdout);\n\t#endif\n}\n\ninline double Time() {return (clock() * 1.0) / CLOCKS_PER_SEC; }             \n\nconst int N = 201, inf = 1e9 * 2;\n\nconst ll MOD = 998244353, INF = 1e18;\n\nconst int dx[] = {1, -1, 0, 0, -1, 1, -1, 1};\nconst int dy[] = {0, 0, 1, -1, -1, 1, 1, -1};\n\nstruct Point {\n\tint x, y;\n};\n\nPoint a[N];\nPoint root;\n\nint tri[N][N], dp[N][N];\n\nint on_line[N];\n\nPoint make(int _x, int _y) {\n\tPoint ret;\n\tret.x = _x;\n\tret.y = _y;\n\treturn ret;\n}\n\nPoint vec(Point p1, Point p2) {\n\treturn make(p2.x - p1.x, p2.y - p1.y);\n}\n\nint crossp(Point p1, Point p2) {\n\treturn p1.x * p2.y - p1.y * p2.x; \n} \n\nint dist(Point p1, Point p2) {\n\treturn (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n}\n\nbool canbe(int i, int j) {\n\tif (i == j) return 0;\n\tif (a[i].x > a[j].x) return 0;\n\tif (a[i].x < a[j].x) return 1;\n\tif (a[i].y > a[j].y) return 0;\n\treturn 1;\n}\n\nbool cmp(Point p1, Point p2) {\n\tPoint v1 = vec(root, p1);\n\tPoint v2 = vec(root, p2);\n\tif (crossp(v1, v2) < 0) return 1;\n\tif (crossp(v1, v2) > 0) return 0;\n\tif (dist(root, p1) > dist(root, p2)) return 1;\n\treturn 0;\n}\n\nint power(int x) {\n\tint ret = 1;\n\tint num = 2;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tx--;\n\t\t\tret = (ret * 1ll * num) % MOD;\n\t\t}\n\t\telse {\n\t\t\tx /= 2;\n\t\t\tnum = (num * 1ll * num) % MOD;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid add(int &x, int y) {\n\tx += y;\n\twhile (x >= MOD) x -= MOD;\n}\n\nvoid out (Point p) {\n\tcerr << \"(\" << p.x << \" \" << p.y << \") \";\n}\n\nint main() {\n\tFREOPEN();\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _x, _y;\n\t\tscanf(\"%d %d\", &_x, &_y);\n\t\ta[i] = make(_x, _y);\n\t}\n\tint ans = 0;\n\tfor (int start = 1; start <= n; start++) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(tri, 0, sizeof(tri));\n\t\tmemset(on_line, 0, sizeof(on_line));\n\t\troot = a[start];\n\t\tvector<Point> ps;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (canbe(start, i)) ps.pb(a[i]); \n\t\t}\n\t\tsort(All(ps), cmp);\n\t\tint m = SZ(ps);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tfor (int k = i + 1; k < m; k++) {\n\t\t\t\t\tif (j == k) continue;\n\t\t\t\t\tif (crossp(vec(root, ps[j]), vec(root, ps[k])) < 0) break;\n\t\t\t\t\tif (crossp(vec(ps[i], ps[j]), vec(ps[i], ps[k])) <= 0) tri[i][j]++;\n\t\t\t\t}\n\t\t\t\tif (crossp(vec(root, ps[i]), vec(root, ps[j])) == 0) on_line[i]++;\n\t\t\t\t//out(root), out(ps[i]), out(ps[j]), cerr << tri[i][j] << endl;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tassert(crossp(vec(root, ps[i]), vec(root, ps[j])) <= 0);\n\t\t\t\tif (crossp(vec(root, ps[i]), vec(root, ps[j])) == 0) continue;\n\t\t\t\tadd(dp[i][j], power(tri[i][j]));\n\t\t\t\tfor (int k = j + 1; k < m; k++) {\n\t\t\t\t\tif (crossp(vec(ps[i], ps[j]), vec(ps[i], ps[k])) >= 0) continue;\n\t\t\t\t\tif (crossp(vec(root, ps[j]), vec(root, ps[k])) >= 0) continue;\n\t\t\t\t\t//cerr << j << \" \" << k << \" \" << tri[j][k] << endl;\n\t\t\t\t\tadd(dp[j][k], (power(tri[j][k] - on_line[j]) * 1ll * dp[i][j]) % MOD);\n\t\t\t\t}\n\t\t\t\tadd(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\t//cerr << ans << endl;\n\t}\n\tprintf(\"%d \", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mk make_pair\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nll pwr[210], mod=998244353;\nvoid pre(){\n  pwr[0]=1;\n  for(int i=1; i<=200; ++i){\n    pwr[i]=(pwr[i-1]*2)%mod;\n  }\n}\nll x[210], y[210];\nmap<pair<ll,ll>, ll> mp;\nint main(){\n  int n;\n  pre();\n  while(cin>>n){\n    for(int i=0; i<n; ++i){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    ll ans=pwr[n]-n-1, tmp1, tmp2, tmp;\n    for(int i=0; i<n; ++i){\n      mp.clear();\n      for(int j=i+1; j<n; ++j){\n        tmp1=(y[i]-y[j]);\n        tmp2=(x[i]-x[j]);\n        tmp=__gcd(tmp1, tmp2);\n        tmp1/=tmp;\n        tmp2/=tmp;\n        ++mp[mk(tmp1, tmp2)];\n      }\n      for(map<pair<ll,ll>, ll>::iterator it=mp.begin(); it!=mp.end(); ++it){\n        ans-=(pwr[it->second])-1;\n        ans%=mod;\n      }\n    }\n    ans%=mod;\n    if(ans<0)\n      ans+=mod;\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF (1LL << 60)\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<ll, ll> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\ntypedef pair<P,P> PP;\n\nconst int MAX_N = 205;\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\ninline void make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - (ll)inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = (ll)fac[i-1] * i % MOD;\n\t\tfinv[i] = (ll)finv[i-1] * inv[i] % MOD;\n\t}\n}\n\ninline int comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn (ll)fac[a] * ((ll)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\ninline int add(int x,int y)\n{\n    return (x+y)%MOD;\n}\n\ninline int sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\ninline int mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\nint sm[MAX_N];\nvector<PP> line;\n\nll gcd(ll a, ll b)\n{\n    if(!b) return a;\n    if(a % b == 0){\n        return b;\n    }else{\n        return gcd(b,a%b);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vi x(n), y(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n    }\n    make();\n    srep(i,3,n+1){\n        srep(j,3,i+1){\n            sm[i] = add(sm[i], comb(i, j));\n        }\n    }\n    int ans = sm[n];\n    rep(i,n){\n        srep(j,i+1,n){\n            if(x[i] == x[j]){\n                line.pb(PP(P(INF, 0), P(x[i], 1)));\n            }else if(y[i] == y[j]){\n                line.pb(PP(P(0, 0), P(y[i], 1)));\n            }else{\n                ll dx = x[j] - x[i], dy = y[j] - y[i];\n                ll g = gcd(abs(dx), abs(dy));\n                P a;\n                if(dx * dy < 0){\n                    a = P(abs(dx)/g,-abs(dy)/g);\n                }else{\n                    a = P(abs(dx)/g,abs(dy)/g);\n                }\n                ll ddx = a.fi, ddy = y[i]*a.fi-a.se*x[i];\n                line.pb(PP(a, P(ddx, ddy)));\n            }\n        }\n    }\n    zip(line);\n    // show(ans);\n    each(it, line){\n        P a = it.fi, b = it.se;\n        // spair(a), spair(b);\n        int res = 0;\n        if(a.fi == INF){\n            rep(i,n){\n                res += (x[i] == b.fi);\n            }\n        }else if(a.fi == 0){\n            rep(i,n){\n                res += (y[i] == b.fi);\n            }\n        }else{\n            rep(i,n){\n                ll p = a.fi, q = a.se*x[i]+b.se;\n                ll g = gcd(p, q);\n                p /= g, q /= g;\n                res += (p == 1 && q == y[i]);\n            }\n        }\n        // show(res);\n        ans = sub(ans, sm[res]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 998244353\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\ntypedef pair<P,P> PP;\n\nconst int MAX_N = 205;\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\ninline void make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - (ll)inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = (ll)fac[i-1] * i % MOD;\n\t\tfinv[i] = (ll)finv[i-1] * inv[i] % MOD;\n\t}\n}\n\ninline int comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn (ll)fac[a] * ((ll)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\ninline int add(int x,int y)\n{\n    return (x+y)%MOD;\n}\n\ninline int sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\ninline int mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\nint sm[MAX_N];\n\nint gcd(int a, int b)\n{\n    if(!b) return a;\n    if(a % b == 0){\n        return b;\n    }else{\n        return gcd(b,a%b);\n    }\n}\n\nclass line\n{\npublic:\n    int a, b;\n    ll c;\n    line(){}\n    line(int a_, int b_, ll c_) : a(a_), b(b_), c(c_){}\n    line(int p, int q, int r, int s){\n        int dx = r-p, dy = s-q;\n        int g = gcd(abs(dx), abs(dy));\n        if((ll)dx * dy < 0){\n            a = abs(dy)/g, b = abs(dx)/g;\n        }else{\n            a = -abs(dy)/g, b = abs(dx)/g;\n        }\n        c = -(ll)a*p-(ll)b*q;\n    }\n    line(P x, P y) : line(x.first, x.second, y.first, y.second){}\n    bool operator< (const line& l) const {\n        return (a == l.a)?((b == l.b)?(c < l.c):(b < l.b)):(a < l.a);\n    }\n    bool operator> (const line& l) const {\n        return (a == l.a)?((b == l.b)?(c > l.c):(b > l.b)):(a > l.a);\n    }\n    bool operator== (const line& l) const {\n        return (a == l.a)?((b == l.b)?(c == l.c):false):false;\n    }\n    bool operator!= (const line& l) const {\n        return !(*this == l);\n    }\n    bool onLine(int p, int q){\n        return ((ll)a*p+(ll)b*q+c == 0);\n    }\n    bool onLine(P x){ return onLine(x.first, x.second); }\n};\n\nvector<line> Line;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vi x(n), y(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n    }\n    make();\n    srep(i,3,n+1){\n        srep(j,3,i+1){\n            sm[i] = add(sm[i], comb(i, j));\n        }\n    }\n    int ans = sm[n];\n    rep(i,n){\n        srep(j,i+1,n){\n            if(x[i] == x[j]){\n                Line.emplace_back(1,0,x[i]);\n            }else if(y[i] == y[j]){\n\t\t\t\tLine.emplace_back(0,1,y[i]);\n            }else{\n\t\t\t\tLine.emplace_back(x[i], y[i], x[j], y[j]);\n            }\n        }\n    }\n    zip(Line);\n    // show(ans);\n    each(it, Line){\n        int res = 0;\n\t\trep(i,n){\n\t\t\tres += it.onLine(x[i], y[i]);\n\t\t}\n        ans = sub(ans, sm[res]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int P = 998244353;\nint n;\nstruct Point\n{\n    int x, y;\n} pt[1007];\nint ep = 0, f[1007], sz[1007];\nint getfa(int x) {\n    while (x != f[x])\n        x = f[x] = x[f][f];\n    return x;\n}\nstruct Edge {\n    int a, b;\n    int v;\n    bool operator<(const Edge &e) const { return v < e.v; }\n    void uni(){\n        int x = getfa(a), y = getfa(b);\n        if (x != y)\n            f[x] = y, sz[y] += sz[x];\n    }\n}E[207 * 207];\nint gcd(int a, int b){\n    return b ? gcd(b, a % b) : a;\n}\nint pw[1007], ans;\nint main(){\n    scanf(\"%d\", &n);\n    pw[0] = 1;\n    for (int i = 1; i <= n; ++i)\n        pw[i] = pw[i - 1] * 2 % P;\n    ans = (pw[n] - n - 1) % P;\n    for (int i = 0; i < n; ++i)\n        scanf(\"%d%d\", &pt[i].x, &pt[i].y);\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j < i; ++j)\n        {\n            int x = pt[i].x - pt[j].x, y = pt[i].y - pt[j].y;\n            int g = gcd(x, y);\n            x /= g, y /= g;\n            if (!x)\n                y = 1;\n            if (!y)\n                x = 1;\n            if (x < 0)\n                x = -x, y = -y;\n            E[ep++] = (Edge){i, j, x * 30000 + y};\n        }\n    }\n    sort(E, E + ep);\n    for (int i = 0, j = 0; i < ep; i = j)\n    {\n        for (int a = 0; a < n; ++a)\n            sz[f[a] = a] = 1;\n        for (; j < ep && E[i].v == E[j].v; E[j++].uni())\n            ;\n        for (int a = 0; a < n; ++a)\n            if (f[a] == a && sz[a] > 1)\n                ans = (ans - pw[sz[a]] + sz[a] + 1) % P;\n    }\n    printf(\"%d\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 998244353\n\n//ここから編集する\nclass Combination {\n\npublic:\n    vector<ll> fact;\n\n    Combination(int max_n) {\n        //1 ~ n!までの階乗modを求める\n        int n = max_n;\n        vector<ll> fact(n + 1);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n        this->fact = fact;\n    }\n\n    template<typename T>\n    //templateをつかってみｔか\n    ll pow(T x, int y) {\n        if (y == 0) return 1;\n        if (y == 1) return x;\n        if (y == 2) return (x * x) % MOD;\n//        if (y % 2 == 1) return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        if (y % 2 == 1) return pow(pow(x, y / 2), 2) * x % MOD;\n//        return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        return pow(pow(x, y / 2), 2) % MOD;\n    }\n\n    ll nCk(int n, int k) {\n//        return (fact[n] * pow(fact[n-k],MOD-2) * pow(fact[k],MOD-2)) % MOD;\n        return (((fact[n] * pow(fact[n - k], MOD - 2)) % MOD) * pow(fact[k], MOD - 2)) % MOD;\n    }\n};\n\nll gcd(ll a, ll b) {\n    if (a < b) swap(a, b);\n    if (a % b == 0) return b;\n    return gcd(b, a % b);\n\n}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    Combination comb(300);\n    vector<int> x(N), y(N);\n    rep(i, 0, N) {\n        cin >> x[i] >> y[i];\n    }\n//    map<pair<int, int>, int> mp;\n    ll ans = comb.pow(2, N) - 1 - N;\n    rep(i, 0, N) {\n        rep(j, i + 1, N) {\n            int dx = x[j] - x[i];\n            int dy = y[j] - y[i];\n\n            int adx = abs(dx);\n            int ady = abs(dy);\n            int div;\n            if (dx == 0 && dy == 0) continue;\n            if (dy == 0) {\n                dx = 1;\n            } else if (dx == 0) {\n                dy = 1;\n            } else {\n                div = gcd(adx, ady);\n                dx /= div;\n                dy /= div;\n                if (dx < 0) {\n                    dx *= -1;\n                    dy *= -1;\n                }\n            }\n            int cnt = 2;\n            bool flag = true;\n            rep(k, 0, N) {\n                int dx2 = x[k] - x[i];\n                int dy2 = y[k] - y[i];\n\n//                    if (dx2 == 0 && dy2 == 0) continue;\n//                    if (dy2 == 0) {\n//                        dx2 = 1;\n//                    } else if (dx2 == 0) {\n//                        dy2 = 1;\n//                    } else {\n//                        div = gcd(abs(dx2), abs(dy2));\n//                        dx2 /= div;\n//                        dy2 /= div;\n//                    }\n//                    if (dx * dy2 == dx2 * dy) {\n//                        mp[pair<int, int>(dx, dy)]++;\n//                    }\n//                if (dx2 == 0 && dy2 == 0) continue;\n//                if (dx2 == dx && dy2 == dy) continue;\n                if(i == k || j == k) continue;\n                if (dx == 0) {\n                    if (dx2 == 0) {\n//                        mp[pair<int, int>(dx, dy)]++;\n                        cnt++;\n                        if (k < j) {\n                            flag = false;\n                        }\n                    }\n                } else if (dy == 0) {\n                    if (dy2 == 0) {\n//                        mp[pair<int, int>(dx, dy)]++;\n                        cnt++;\n                        if (k < j) {\n                            flag = false;\n                        }\n                    }\n                } else {\n                    if (dx * dy2 == dx2 * dy) {\n//                        mp[pair<int, int>(dx, dy)]++;\n                        cnt++;\n                        if (k < j) {\n                            flag = false;\n                        }\n                    }\n                }\n            }\n            if(flag){\n                ll minus = comb.pow(2, cnt) - 1 - cnt;\n                ans -= minus;\n//                cout << x[i] << \" \" <<  y[i] << \" \" << minus << endl;\n                if(ans < 0) ans += MOD;\n            }\n\n//            if (mp.find(pair<int, int>(dx, dy)) == mp.end()) {\n//                mp[pair<int, int>(dx, dy)] = 2;\n//\n//            }\n\n        }\n    }\n    if (ans < 0) ans += MOD;\n//    for (auto e : mp) {\n//        int k = e.second;\n//        cout << e.first.first << \" \" << e.first.second << \" \" << k << endl;\n//        ll minus = comb.pow(2, k) - 1 - k;\n//        ans -= minus;\n//        cout << minus << endl;\n//        if (ans < 0) ans += MOD;\n//    }\n    cout << ans << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Mo 998244353\n#define N 500\ntypedef long long LL;\nusing namespace std;\nint x[N], y[N], b[N], num[N], n;\n\nvoid prepare() {\n    b[0] = 1;\n    for(int i = 1; i <= n; i++) b[i] = ((LL)b[i - 1] * 2) % Mo;\n    for(int i = 1; i <= n; i++) b[i] = (b[i] - 1 - i - i * (i - 1) / 2) % Mo;\n}\n\nint main() {\n    cin >> n;\n    for(int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n    prepare();\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++) {\n            if (i == j) continue;\n            int cnt = 2;\n            for(int k = 1; k <= n; k++) {\n                if (k == i || k == j) continue;\n                if ((LL)(x[k] - x[i]) * (y[k] - y[j]) == (LL)(x[k] - x[j]) * (y[k] - y[i])) cnt++;\n            }\n            num[cnt]++;\n        }\n    for(int i = 3; i <= n; i++) num[i] = num[i] / i / (i - 1);\n    LL ans = b[n];\n    for(int i = 3; i <= n; i++) ans = (ans - (LL)num[i] * b[i] % Mo) % Mo;\n    cout << (ans % Mo + Mo) % Mo << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mod=998244353;\nconst int maxn=205;\nint x[maxn],y[maxn];\nint two[maxn];\nint main()\n{\n    two[0]=1;\n    for(int i=1;i<maxn;i++) two[i]=two[i-1]*2%mod;\n    int n;\n    cin>>n;\n    ll ans=(two[n]-n+mod-1)%mod;\n    for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n    for(int i=0;i<n;i++)\n    {\n        for(int j=i+1;j<n;j++)\n        {\n            int cc=0;\n            for(int k=j+1;k<n;k++)\n            {\n                if((y[k]-y[j])*(x[j]-x[i])==((x[k]-x[j])*(y[j]-y[i]))) cc++;\n            }\n            ans=(ans-two[cc]+mod)%mod;\n        }\n    }\n    print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define rt return\nusing dbl = double;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate<int MOD>\nclass ModInt {\npublic:\n    ModInt() :value(0) {}\n    ModInt(long long val) :value((int)(val<0 ? MOD + val%MOD : val%MOD)) { }\n\n    ModInt& operator+=(ModInt that) {\n        value = value + that.value;\n        if (value >= MOD)value -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that) {\n        value -= that.value;\n        if (value<0)value += MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that) {\n        value = (int)((long long)value * that.value % MOD);\n        return *this;\n    }\n    ModInt &operator/=(ModInt that) {\n        return *this *= that.inverse();\n    }\n    ModInt operator+(ModInt that) const {\n        return ModInt(*this) += that;\n    }\n    ModInt operator-(ModInt that) const {\n        return ModInt(*this) -= that;\n    }\n    ModInt operator*(ModInt that) const {\n        return ModInt(*this) *= that;\n    }\n    ModInt operator/(ModInt that) const {\n        return ModInt(*this) /= that;\n    }\n    ModInt pow(long long k) const {\n        if (value == 0)return 0;\n        ModInt n = *this, res = 1;\n        while (k) {\n            if (k & 1)res *= n;\n            n *= n;\n            k >>= 1;\n        }\n        return res;\n    }\n    ModInt inverse() const {\n        long long a = value, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n    int toi() const { return value; }\n\nprivate:\n    int value;\n};\ntypedef ModInt<998244353> mint;\nostream& operator<<(ostream& os, const mint& x) {\n    os << x.toi();\n    return os;\n}\n\nint gcd(int a, int b) {\n    return b ? gcd(b, a%b) : a;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int N;\n    cin >> N;\n    vi x(N), y(N);\n    rep(i, N)cin >> x[i] >> y[i];\n\n    mint ans = mint(2).pow(N) - 1 - N;\n\n    // z個の頂点を含む直線の数 * z\n    // = z個の頂点を含む直線上の点をカウント\n    map<int, int> S;\n    rep(i, N) {\n        map<pii, int> cnt;\n        rep(j, N) if (i != j) {\n            int vx = x[i] - x[j], vy = y[i] - y[j];\n            int g = gcd(vx, vy);\n            vx /= g;\n            vy /= g;\n            if (vx < 0) {\n                vx *= -1;\n                vy *= -1;\n            }\n            cnt[mp(vx, vy)]++;\n        }\n        each(p, cnt) {\n            S[p.second + 1]++;\n        }\n    }\n\n    each(p, S) {\n        int z, w;\n        tie(z, w) = p;\n        w /= z;\n        // z個の頂点を含む直線がw個ある\n        ans -= (mint(2).pow(z) - 1 - z)*w;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define X first\n#define Y second\n#define pii pair<ll,ll>\n#define x1 dlfjl\n#define x2 dkfj\n#define MOD 998244353\n#define y1 dskgj\n#define y2 dskfj\n#define N 310\ntypedef int ll;\nusing namespace std;\nll n,i,j,k,x,y,z,m,q,w,h;\nll a[100500], b[100500], pre[1005000], C[205][205];\nmap<pair<pii,pii>,ll> f;\nll gcd(ll a, ll b)\n{\n    return (b==0?a:gcd(b,a%b));\n}\nll Abs(ll x)\n{\n    return (x>0?x:-x);\n}\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    for (i = 0; i <= 1000; i++)\n        pre[i*(i+1)/2] = i+1;\n    for (i = 0; i <= 200; i++)\n        C[i][0] = 1;\n    for (i = 1; i <= 200; i++)\n        for (j = i; j <= 200; j++)\n            C[j][i] = (C[j-1][i-1] + C[j-1][i])%MOD;\n    ll ans = 1;\n    cin >> n;\n    if (n < 3)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    for (i = 1; i <= n; i++)\n        ans = (ans*2)%MOD;\n    ans -= n+1;\n    ans -= n*(n-1)/2;\n    ans += MOD;\n    ans %= MOD;\n    for (i = 0; i < n; i++)\n        cin >> a[i] >> b[i];\n    for (i = 0; i < n; i++)\n        for (j = i+1; j < n; j++)\n        {\n            if (a[i] == a[j])\n            {\n                f[mp(mp(0,a[i]),mp(MOD,MOD))]++;\n                continue;\n            }\n            int p = a[i]-a[j];\n            int q = b[i]-b[j];\n            int g = gcd(Abs(p), Abs(q));\n            p /= g;\n            q /= g;\n            if ( p < 0)\n                p = -p, q = -q;\n            int x1 = a[i], y1 = b[i], x2 = a[j], y2 = b[j];\n            int xx = y1*(x2-x1)-x1*(y2-y1);\n            int yy = x2-x1;\n            int gg = gcd(Abs(xx), Abs(yy));\n            xx /= gg;\n            yy /= gg;\n            if ( xx < 0)\n                xx = -xx, yy = -yy;\n            f[mp(mp(p,q),mp(xx,yy))]++;\n        }\n    for (auto itr = f.begin(); itr != f.end(); itr++)\n    {\n        int val = (*itr).Y;\n        val = pre[val];\n        for (j = 3; j <= val; j++)\n        {\n            ans -= C[val][j];\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) >  EPS)   return +1;      // counter clockwise\n\tif(cross(b, c) < -EPS)   return -1;      // clockwise\n\tif(dot(b, c)   < -EPS)   return +2;      // c--a--b on line\n\tif(norm(b)+EPS <norm(c)) return -2;      // a--b--c on line\n\treturn 0;                                   // c is between a and b (inclusive)\n}\nint n;\nint on[200][200];\nbool can[200][200][200];\n\nint dp[200][200];\nll pw[201];\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tconst int mod = 998244353;\n\tpw[0] = 1;\n\trep(i, 200) pw[i + 1] = pw[i] * 2 % mod;\n\t\n\tcin >> n;\n\tG g;\n\trep(i, n){\n\t\tint x, y; cin >> x >> y;\n\t\tg.emplace_back(x, y);\n\t}\n\trep(i, n) rep(j, n) rep(k, n) if(ccw(g[i], g[j], g[k]) == 1) can[i][j][k] = 1;\n\trep(i, n) rep(j, i) rep(k, n) if(k != i && k != j){\n\t\tif(ccw(g[k], g[i], g[j]) != 2) continue;\n\t\ton[i][j]++;\n\t\ton[j][i]++;\n\t}\n\tll ans = 0;\n\trep(s, n){\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tvi idx(1, s);\n\t\trep(i, n) if(g[s] < g[i]) idx.pb(i);\n\t\t\n\t\tfor(int i : idx) if(i != s) (dp[s][i] += pw[on[s][i]]) %= mod;\n\t\tfor(int i : idx) for(int j : idx) if(dp[i][j]){\n\t\t\tif(can[i][j][s]) ans += dp[i][j] * pw[on[j][s]] % mod;\n\t\t\tfor(int k : idx) if(k != s && can[i][j][k]) (dp[j][k] += dp[i][j] * pw[on[j][k]] % mod) %= mod;\n\t\t}\n\t}\n\tcout << ans % mod << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 30;\nconst int MOD = 998244353;\n\nconst int N = 200 + 10;\nint x[N], y[N];\n\nint cross(int u, int v, int w) {\n  return (x[v] - x[u]) * (y[w] - y[u]) - (x[w] - x[u]) * (y[v] - y[u]);\n}\n\nint dp[N][N][N];\nint64 cnt[N][N];\nint n;\n\nint solve(int i, int j, int k) {\n  int& ret = dp[i][j][k];\n  if (ret >= 0) return ret;\n  ret = cnt[j][k];\n  // trace(i, j, k, ret);\n  for (int u = 0; u < n; ++u) {\n    if (u > i && cross(i, j, u) > 0 && cross(i, k, u) < 0\n        && cross(u, j, k) < 0) {\n      ret += solve(i, u, k) * cnt[j][u] % MOD;\n      ret %= MOD;\n    }\n  }\n  // trace(i, j, k, ret);\n  return ret;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (i == j) continue;\n      cnt[i][j] = 1;\n      for (int k = 0; k < n; ++k) {\n        if (k == i || k == j) continue;\n        if (cross(i, j, k) == 0 &&\n            (x[k] - x[i]) * (x[k] - x[j]) <= 0 &&\n            (y[k] - y[i]) * (y[k] - y[j]) <= 0) {\n          cnt[i][j] = cnt[i][j] * 2 % MOD;\n        }\n      }\n    }\n  }\n  memset(dp, 255, sizeof(dp));\n  int ret = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      for (int k = i + 1; k < n; ++k) {\n        if (cross(i, j, k) <= 0) continue;\n        ret += solve(i, j, k) * cnt[i][j] % MOD * cnt[i][k] % MOD;\n        ret %= MOD;\n      }\n    }\n  }\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long> > vvll;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _rep(i,n) _rep2((i),0,(n))\n#define _rep2(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(...) GET_MACRO(__VA_ARGS__, _rep2, _rep)(__VA_ARGS__)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 998244353LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\n// Mod int\n// const int MOD = 1000000007;\nstruct mint{\n    ll x;\n    mint():x(0){}\n    mint(ll x):x((x%MOD+MOD)%MOD){}\n    mint operator+=(const mint& a){ if((x+=a.x)>=MOD) x-=MOD; return *this;}\n    mint operator-=(const mint& a){ if((x+=MOD-a.x)>=MOD) x-=MOD; return *this;}\n    mint operator*=(const mint& a){ (x*=a.x)%=MOD; return *this;}\n    mint operator+(const mint& a)const{ return mint(*this) += a;}\n    mint operator-(const mint& a)const{ return mint(*this) -= a;}\n    mint operator*(const mint& a)const{ return mint(*this) *= a;}\n    bool operator==(const mint& a)const{ return x == a.x;}\n    friend ostream& operator<<(ostream& os, const mint& mi)  \n    {  \n        os << mi.x;  \n        return os;  \n    }\n};\n\n\nmint comb[300][300];\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tvector<pii> v(n);\n\trep(i,n){\n\t\tcin>>v[i].fi>>v[i].se;\n\t}\n\trep(i,300){\n\t\tcomb[i][0] = comb[i][i] = mint(1);\n\t\trep(j,i-1){\n\t\t\tcomb[i][j+1] = comb[i-1][j]+comb[i-1][j+1];\n\t\t}\n\t}\n\tset<pii> used;\n\tmint ans;\n\trep(i,n){\n\t\trep(j,i){\n\t\t\tpii a(v[i].fi-v[j].fi, v[i].se-v[j].se);\n\t\t\tint t = __gcd(abs(a.fi), abs(a.se));\n\t\t\ta.fi /= t;\n\t\t\ta.se /= t;\n\t\t\tif(used.find(a)!=used.end()) continue;\n\t\t\tused.insert(a);\n\t\t\tint cnt = 1;\n\t\t\trep(k,n){\n\t\t\t\tif(i==k) continue;\n\t\t\t\tpii b(v[i].fi-v[k].fi, v[i].se-v[k].se);\n\t\t\t\tint t = __gcd(abs(b.fi), abs(b.se));\n\t\t\t\tb.fi /= t;\n\t\t\t\tb.se /= t;\n\t\t\t\tif(a==b) cnt++;\n\t\t\t}\n\t\t\trep(k,3,cnt+1){\n\t\t\t\tans -= comb[cnt][k];\n\t\t\t}\n\t\t}\n\t}\n\trep(i,3,n+1){\n\t\tans += comb[n][i];\n\t}\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn=201;\ntypedef long long LL;\nconst LL mod=998244353;\n\nint n,x[maxn],y[maxn];\nLL ans;\nbool f;\n\nLL pw(int p)\n{\n\tif (p==1) return 2ll;\n\tLL ans=pw(p/2);\n\tif (p%2) return (ans*ans*2ll)%mod;\n\telse return (ans*ans)%mod;\n}\n\nbool line(int p,int q,int r)\n{\n\treturn (y[q]-y[p])*(x[r]-x[q])==(y[r]-y[q])*(x[q]-x[p]);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) \n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\tans=(pw(n)-1ll-(LL)n-(LL)n*(n-1)/2)%mod;\n\t\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tf=true;\n\t\t\tfor(int k=1;k<j;k++)\n\t\t\t\tif (k!=i && line(i,j,k))\n\t\t\t\t{\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (!f) continue;\n\t\t\t\n\t\t\tint cnt=2;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\t\tif (line(i,j,k)) cnt++;\n\t\t\tLL tmp=(pw(cnt)-1ll-(LL)cnt-(LL)cnt*(cnt-1)/2)%mod;\n\t\t\tans-=tmp;\n\t\t}\n\t}\n\t\n\tans=(ans%mod+mod)%mod;\n\tprintf(\"%I64d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <cmath>\n#include <math.h>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <ctime>\n#define int long long\nusing namespace std;\ndouble INF = 1e9;\nint MOD = 998244353;\nint32_t main(){\n    int n, x, y;\n    vector<pair<int, int> > pr;\n    cin >> n;\n    for (int i=0; i < n; i++){\n        cin >> x >> y;\n        pr.push_back(make_pair(x, y));\n    }\n    map<pair<double, double>, set<int> > mm;\n    int ans = 2;\n    for (int i=0; i < n-1; i++){\n        ans *= 2;\n        ans %= MOD;\n    }\n    ans--;\n    ans %= MOD;\n    for (int i=0; i < n; i++){\n        for (int j=i+1; j < n; j++){\n            if (i == j) continue;\n            double k, b;\n            if (pr[i].first == pr[j].first){\n                k = INF;\n                b = pr[i].first;\n            }\n            else{\n                k = (double) (pr[i].second - pr[j].second) / (double) (pr[i].first - pr[j].first);\n                b = (double) pr[i].second - k * (double) pr[i].first;\n            }\n            if (mm.count(make_pair(k, b))){\n                mm[make_pair(k, b)].insert(i);\n                mm[make_pair(k, b)].insert(j);\n            }\n            else{\n                set<int> ms;\n                ms.insert(j);\n                ms.insert(i);\n                mm[make_pair(k, b)] = ms;\n            }\n        }\n    }\n    while (!mm.empty()){\n        pair<double, double> p = (*mm.begin()).first;\n        int sz = mm[p].size();\n        mm.erase(p);\n        int mins = 2;\n        for (int i=0; i < sz-1; i++){\n            mins *= 2;\n            mins %= MOD;\n        }\n        mins -= sz+1;\n        mins %= MOD;\n        ans -= mins;\n        ans %= MOD;\n    }\n    ans -= n;\n    ans %= MOD;\n    if (ans < 0) ans += MOD;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint N;\npair <int, int> A[205];\nbool Use[205][205];\nconst int MOD = 998244353;\nint Power[205];\nint ans;\nint Area(pair <int, int> a, pair <int, int> b, pair <int, int> c)\n{\n    return a.first * b.second + b.first * c.second + c.first * a.second - a.second * b.first - b.second * c.first - c.second * a.first;\n}\nvoid Read()\n{\n    cin >> N;\n    for(int i = 1; i <= N; i++)\n        cin >> A[i].first >> A[i].second;\n    Power[0] = 1;\n    for(int i = 1; i <= N; i++)\n    {\n        Power[i] = (1LL * Power[i - 1] * 2) % MOD;\n    }\n}\nvoid Solve()\n{\n    ans = Power[N] - 1;\n    if(ans < 0)\n        ans += MOD;\n    for(int i = 1; i <= N; i++)\n    {\n        ans--;\n        if(ans < 0)\n            ans += MOD;\n        for(int j = i + 1; j <= N; j++)\n        {\n            if(Use[i][j] == 1)\n            continue;\n            int cnt = 1;\n            for(int k = j + 1; k <= N; k++)\n            {\n                if(Area(A[i], A[j], A[k]) == 0)\n                {\n                    ++cnt;\n                    Use[i][k] = 1;\n                }\n            }\n            ans -= Power[cnt] - 1;\n            if(ans < 0)\n                ans += MOD;\n        }\n    }\n    cout << ans << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\n\nint n,x[205],y[205],p[205],Ans;\nconst int P=998244353;\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=p[0]=1;i<=n;++i)scanf(\"%d%d\",&x[i],&y[i]),p[i]=(p[i-1]<<1)%P;\n    Ans=(p[n]-n-1+P)%P;\n    for(int i=1;i<=n;++i)\n        for(int j=i+1;j<=n;++j)\n        {\n            int d=0;\n            for(int k=j+1;k<=n;++k)\n                d+=(y[i]-y[j])*(x[i]-x[k])==(y[i]-y[k])*(x[i]-x[j]);\n            Ans=(Ans+P-p[d])%P;\n        }\n    printf(\"%d\\n\",Ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nint X[210], Y[210];\n\nint gcd(int a, int b) {\n\tif (a < b) swap(a, b);\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nll MOD = 998244353;\n\nll power(ll a, ll b) {\n\tll res = 1;\n\twhile (b > 0) {\n\t\tif (b % 2) {\n\t\t\tres *= a;\n\t\t\tres %= MOD;\n\t\t}\n\t\tb /= 2;\n\t\ta *= a;\n\t\ta %= MOD;\n\t}\n\treturn res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    for (int i = 0;i < N;i++) cin >> X[i] >> Y[i];\n    set<set<int> > G;\n    for (int i = 0;i < N;i++) {\n    \tmap<PP, set<int> > T;\n    \tfor (int j = 0;j < N;j++) {\n    \t\tif (i == j) continue;\n    \t\tint dx = X[i] - X[j];\n    \t\tint dy = Y[i] - Y[j];\n    \t\tint k = gcd(abs(dx), abs(dy));\n    \t\tdx /= k;\n    \t\tdy /= k;\n    \t\tif (dx < 0) {\n    \t\t\tdx = -dx;\n    \t\t\tdy = -dy;\n    \t\t}\n    \t\tif (dx == 0 && dy < 0) dy = -dy;\n    \t\tT[make_pair(dx, dy)].insert(j);\n    \t}\n    \tfor (auto it : T) {\n    \t\tif (it.second.size() >= 2) {\n    \t\t\tset<int> q = it.second;\n    \t\t\tq.insert(i);\n    \t\t\tG.insert(q);\n    \t\t}\n    \t}\n    }\n    ll tol = power(2, N) + MOD - N - 1 - N * (N - 1) / 2;\n    tol %= MOD;\n    for (auto it : G) {\n    \tint k = it.size();\n    \ttol += MOD - (power(2, k) - 1 - k - k * (k - 1) / 2);\n    \ttol %= MOD; \n    }\n    cout << tol << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<map>\n#include<vector>\n#include<set>\n#define rep(i,j,k) for(register int i = j; i <= k; i++) \n#define dow(i,j,k) for(register int i = j; i >= k; i--)\n#define fi first\n#define se second\n//#define P pair<ull,ull>\n//#define PP pair<int,pair<int,int> >\n//#define mp(a,b) make_pair(a,b)\n#define ll long long\n#define ull unsigned long long\nusing namespace std;\n \ninline int read() { \n\tint s = 0, t = 1; char c = getchar();\n\twhile( !isdigit(c) ) { if( c == '-' ) t = -1; c = getchar(); }\n\twhile( isdigit(c) ) s = s * 10 + c - 48, c = getchar();\n\treturn s * t;\n}\n\nconst int N = 205, p = 998244353;\nll A[N], B[N]; \ninline int Q(int n) { return 1 + n + n * (n-1) / 2; }\ninline int Pow(ll x,int t) { \n\tint ret = 1;\n\twhile( t ) { \n\t\tif( t & 1 ) ret = ret * x % p;\n\t\tx = x * x % p, t >>= 1;\n\t} return ret;\n}\n\nint main() {\n\tint n = read();\n\trep(i,1,n) A[i] = read(), B[i] = read();\n\tll ans = (Pow(2,n) - Q(n) + p) % p; \n\t\n\trep(i,1,n) { \n\t\trep(j,i+1,n) { \n\t\t\tll X = A[i] - A[j], Y = B[i] - B[j]; int cnt = 2; \n\t\t\trep(k,1,n) { \n\t\t\t\tif( k == i || k == j ) continue;\n\t\t\t\tif( X * B[k] - Y * A[k] - B[j] * X + A[j] * Y != 0 ) continue;\n\t\t\t\tif( k < j ) break;\n\t\t\t\tcnt++; \n\t\t\t}\n\t\t\tans = (ans - Pow(2,cnt) + p) % p;\n\t\t\tans = (ans + Q(cnt)) % p;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MOD=998244353;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PI;\ntypedef pair<int,P> IP;\ntypedef pair<P,P> PP;\n\nint pw(int n,int k){\n  if(k<0)return pw(n,k+MOD-1);\n  int res=1;\n  while(k){\n    if(k&1)res*=n;res%=MOD;\n    n*=n;n%=MOD;\n    k>>=1;\n  }\n  return res;\n}\n\nint f(int a){\n  if(a<=2)return 0;\n  int res=pw(2,a);\n  res--;\n  res-=a;\n  res-=a*(a-1)/2;\n  res%=MOD;res+=MOD;res%=MOD;\n  //cout<<\"F\"<<a<<\" \"<<res<<endl;\n  return res;\n}\n\nsigned main(){\n  int n;cin>>n;\n  vector<P> a(n);\n  for(int i=0;i<n;i++){\n    int x,y;cin>>x>>y;\n    a[i]=P(x,y);\n  }\n  sort(a.begin(),a.end());\n  map<IP,int> m;\n  for(int i=0;i<n;i++){\n    map<int,PI> mp;\n    for(int j=i+1;j<n;j++){\n      int x=a[j].first-a[i].first,y=a[j].second-a[i].second;\n      int ka;\n      if(y)ka=x/y;\n      else ka=1e9;\n      mp[ka]=PI(a[j],mp[ka].second+1);\n    }\n    for(auto p:mp){\n      int ka=p.first,v=p.second.second;\n      P po=p.second.first;\n      if(m.count(IP(ka,po)))continue;\n      m[IP(ka,po)]=v+1;\n    }\n  }\n  //for(auto p:m)cout<<p.first.first<<\" \"<<p.first.second.first<<\" \"<<p.first.second.second<<\" \"<<p.second<<endl;\n  int ans=f(n);\n  for(auto p:m){\n    ans-=f(p.second);\n    ans+=MOD;\n    ans%=MOD;\n  }\n  ans%=MOD;ans+=MOD;ans%=MOD;\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 998244353;\n\nconst int MAXN = 2e2 + 5;\n\npii pp[MAXN];\n\nll st2[MAXN];\n\nint cross(int i, int j, int k){\n\treturn (pp[j]._1 - pp[i]._1) * (pp[k]._2 - pp[i]._2) - (pp[k]._1 - pp[i]._1) * (pp[j]._2 - pp[i]._2);\n}\n\nint used[MAXN][MAXN];\n\nvi tmp;\n\nll get_val(int n){\n\tll ans = st2[n];\n\tans = (ans - 1 - n + MOD) % MOD;\n\treturn ans;\n}\n\nvoid solve(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(i, 0, n){\n\t\tscanf(\"%d%d\",&pp[i]._1, &pp[i]._2);\n\t}\n\tst2[0] = 1;\n\tREPN(i, 1, n){\n\t\tst2[i] = (st2[i - 1] * 2ll) % MOD;\n\t}\n\t\n\tll ans = get_val(n);\n\t//printf(\"%lld\\n\", ans);\n\tREP(i, 0, n){\n\t\tREP(j, i + 1, n){\n\t\t\tif (used[i][j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp.clear();\n\t\t\tREP(k, 0, n){\n\t\t\t\tif (cross(i, j, k) == 0){\n\t\t\t\t\ttmp.pb(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k, 0, SZ(tmp)){\n\t\t\t\tREP(l, k + 1, SZ(tmp)){\n\t\t\t\t\tused[tmp[k]][tmp[l]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tll delta = get_val(SZ(tmp));\n\t\t\tans = (ans - delta + MOD) % MOD;\n\t\t\t//printf(\"%d %d %lld\\n\", i, j, ans);\n\t\t}\n\t}\t\n\tprintf(\"%lld\\n\", ans);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ Templates\n#include <bits/stdc++.h>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 998244353LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\n// }}}\n\ninline bool on(ll x0, ll y0, ll x1, ll y1, ll x, ll y)\n{\n    const ll DX = x1 - x0;\n    const ll DY = y1 - y0;\n    const ll dx = x - x0;\n    const ll dy = y - y0;\n    return dx * DY == dy * DX;\n}\n\nll power(const ll p, const ll n)\n{\n    if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 1) {\n        return (power(p, n - 1) * p) % MOD;\n    } else {\n        const ll pp = power(p, n / 2);\n        return (pp * pp) % MOD;\n    }\n}\n\ninline ll calc(const ll n)\n{\n    if (n <= 2) {\n        return 0;\n    }\n    return (((power(2, n) - (n * n + n + 2) / 2) % MOD) + MOD) % MOD;\n}\n\nstruct Line {\n    Line(ll ind_, ll dx_, ll dy_)\n    {\n        ind = ind_;\n        if (dx_ < 0) {\n            dx_ *= -1;\n            dy_ *= -1;\n        }\n        dx = dx_;\n        dy = dy_;\n    }\n    ll ind;\n    ll dx;\n    ll dy;\n    bool operator==(const Line& l) const\n    {\n        return (ind == l.ind) and (dx * l.dy == dy * l.dx);\n    }\n    bool operator<(const Line& l) const\n    {\n        return (ind != l.ind) ? ind < l.ind : dx * l.dy < dy * l.dx;\n    }\n};\n\nostream& operator<<(ostream& os, const Line& l)\n{\n    os << \"ind: \" << l.ind << \"\\ndx: \" << l.dx << \"\\ndy:\" << l.dy << endl;\n    return os;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    vector<ll> x(N);\n    vector<ll> y(N);\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    map<Line, ll> lines;\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = i + 1; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                if (k == i or k == j) {\n                    continue;\n                }\n                if (on(x[i], y[i], x[j], y[j], x[k], y[k])) {\n                    const Line ln = Line{min({i, j, k}), x[j] - x[i], y[j] - y[i]};\n                    if (lines.find(ln) == lines.end()) {\n                        lines[ln] = 3;\n                        for (int l = 0; l < N; l++) {\n                            if (l == i or l == j or l == k) {\n                                continue;\n                            }\n                            if (on(x[i], y[i], x[j], y[j], x[l], y[l])) {\n                                lines[ln]++;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    ll sum = calc(N);\n    for (const auto& e : lines) {\n        sum -= calc(e.second);\n        sum = ((sum % MOD) + MOD) % MOD;\n    }\n    cout << sum << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "import qualified Data.ByteString.Lazy.Char8 as B\nimport Data.List\nimport Data.Maybe\nimport qualified Data.Map as M\nimport qualified Data.Vector.Unboxed as V\n\nbsReadInts :: B.ByteString -> [Int]\nbsReadInts = map (fst . fromJust . B.readInt) . B.words\n\nvalM = 998244353\nprimes = [2, 3, 5, 7, 11, 13]\n\nprFact :: Int -> [Int]\nprFact n = map fst $ tail $ scanl (\\(_, y) p -> divppow p y) (1,n) primes \n\ndivppow :: Int -> Int -> (Int, Int)\ndivppow p y = f p 0 y\n  where\n    f p acc y | y `mod` p == 0 = f p (acc + 1) (y `div` p)\n              | otherwise      = (acc, y)\n\nmodAdd  x y = (x + y) `mod` valM\nmodMult x y = (x * y) `mod` valM\n\nmodFacted :: [Int] -> Int\nmodFacted pows = (foldl' modMult 1 $ zipWith modPow primes pows) `mod` valM\n\nmodPow :: Int -> Int -> Int\nmodPow p r = (iterate (modMult p) 1) !! r\n\ncombiSeq valN = scanr op [0,0,0,0,0,0] [4..valN]\n  where op n pows = let powA = prFact n\n                        powB = prFact (valN - n + 1)\n                    in zipWith3 (\\x a b -> x + a - b) pows powA powB\n\nnumPol valN = (sum $ map modFacted $ combiSeq valN) `mod` valM\n              \n\ntype MyMap = M.Map (Int, Int) (Maybe Int)\ntype Vline = V.Vector (Int, Int)\n\nsolve :: Int -> [[Int]] -> Int\nsolve 1 _ = 0\nsolve 2 _ = 0\nsolve valN pts = (numPol valN - sumPenalties + valM) `mod` valM\n  where\n    vline :: Vline\n    vline = V.fromList $ map (\\[x,y] -> (x,y)) pts\n\n    lmap :: MyMap\n    lmap = foldr op M.empty [0 .. valN - 1]\n\n    op :: Int -> MyMap -> MyMap\n    op i lm = foldr op2 (foldr op1 lm zjk) zj\n      where\n        zj = [i+1 .. valN-1]\n        zjk = [(j,k) | j <- [i+1 .. valN-1], k <- [j+1 .. valN-1]]\n\n        op1 :: (Int,Int) -> MyMap -> MyMap\n        op1 (j,k) lm =\n          if onALine i j k\n          then M.insert (i,k) Nothing\n                 (M.insert (i,j) Nothing\n                 (M.adjust (fmap (+ 1)) (j,k) lm))\n          else lm\n\n        op2 :: Int -> MyMap -> MyMap\n        op2 j lm = M.alter (maybe (Just (Just 0)) Just) (i,j) lm\n\n    onALine i j k = let (xi, yi) = vline V.! i\n                        (xj, yj) = vline V.! j\n                        (xk, yk) = vline V.! k\n                        (x1, y1) = (xi - xk, yi - yk)\n                        (x2, y2) = (xj - xk, yj - yk)\n                    in x1 * y2 == x2 * y1\n\n    sumPenalties = f 0 llist penalties'\n      where llist@(n0 : _) = sort $ catMaybes $ map snd $ M.toList lmap\n            penalties' = drop n0 penalties\n            f acc ls@(n:_) ps@(p:_) =\n              let (ls1, ls2) = span (== n) ls\n                  nextAcc = acc + (length ls1) * p\n              in case ls2 of\n              []    -> nextAcc\n              m : _ -> f nextAcc ls2 nextPs\n                where nextPs = drop (m - n) ps\n\npenalties :: [Int]\npenalties = scanl modAdd 0 $ map penaltyEach [1..]\n\npenaltyEach :: Int -> Int\npenaltyEach n = (sum $ zipWith modMult [n, n-1 .. 1] p2s) `mod` valM\n  where p2s = iterate (\\x -> modMult 2 x) 1 \n\n\n\n\n\nmain :: IO ()\nmain = do\n  conts <- B.getContents\n  let [n] : iss = map bsReadInts (B.lines conts)\n      answer = solve n iss\n  putStrLn (show answer)\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 200\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,b[MN+5][MN+5],x[MN+5],y[MN+5],ans,pw[MN+5],q[MN+5],top;\nint main()\n{\n    n=read();pw[0]=1;\n    for(int j=1;j<=n;++j) pw[j]=2*pw[j-1]%mod;ans=(pw[n]-n-1+mod)%mod;\n    for(int i=1;i<=n;++i) x[i]=read(),y[i]=read();\n    for(int i=1;i<=n;++i) for(int j=i+1;j<=n;++j) if(!b[i][j])\n    {\n        q[top=1]=i;q[top=2]=j;\n        for(int k=j+1;k<=n;++k) if((x[j]-x[i])*(y[k]-y[i])-(x[k]-x[i])*(y[j]-y[i])==0) q[++top]=k;\n        for(int l=1;l<top;++l) for(int r=l+1;r<=top;++r) b[q[l]][q[r]]=1;\n        ans=((ans-pw[top]+top+1)%mod+mod)%mod;\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Program from Luvwgyx*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2e2+10;\nconst int mod=998244353;\nint n,x[maxn],y[maxn],power[maxn];\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid print(int x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nvoid write(int x){print(x);puts(\"\");}\nvoid init(){power[0]=1;for(int i=1;i<=n;i++)power[i]=(power[i-1]<<1)%mod;}\nbool check(int i,int j,int k){return (x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]);}\nint main(){\n    n=read();init();int ans;\n    for(int i=1;i<=n;i++)x[i]=read(),y[i]=read();\n    ans=(power[n]-n-1+mod)%mod;\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++){\n            int ret=0;\n            for(int k=j+1;k<=n;k++)\n                if(check(i,j,k))ret++;\n            ans=(ans-power[ret]+mod)%mod;\n        }\n    write(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\nusing ll = long long;\n\nconst ll MOD = 998244353;\nll mod(ll x) {\n    return x % MOD;\n}\nll pow2(ll p) {\n    ll v = 1;\n    ll x = 2;\n    while (p) {\n        if (p & 1) {\n            v = mod(v * x);\n        }\n        x = mod(x * x);\n        p >>= 1;\n    }\n    return v;\n}\n\nll N;\nconst ll SIZE = 200;\n\nstruct Point {\n    ll x, y;\n    friend Point operator-(const Point& a, const Point& b) {\n        return {a.x - b.x, a.y - b.y};\n    }\n    friend ll operator*(const Point& a, const Point& b) {\n        return a.x*b.y - a.y*b.x;\n    }\n    friend bool is_aligned(const Point& a, const Point& b, const Point& c) {\n        return (a-c)*(b-c) == 0;\n    }\n    friend bool in(const Point& a, const Point& b, const Point& c) {\n        auto s = a-c, t = b-c;\n        return s.x * t.x <= 0 and s.y * t.y <= 0;\n    }\n};\nvector<Point> xy;\n\nvoid input() {\n    cin >> N;\n    for (ll i = 0; i < N; i++) {\n        ll x, y;\n        cin >> x >> y;\n        xy.push_back({x, y});\n    }\n}\n\nvoid solve() {\n    ll sum = 0;\n    for (ll i = 0; i < N; i++) {\n        for (ll j = i + 1; j < N; j++) {\n            ll num_aligned_points = 2;;\n            for (ll k = 0; k < N; k++) {\n                if (k == i or k == j) continue;\n                if (is_aligned(xy[i], xy[j], xy[k])) {\n                    if (not in(xy[i], xy[j], xy[k])) {\n                        num_aligned_points = 0;\n                        break;\n                    }\n                    ++num_aligned_points;\n                }\n            }\n            if (num_aligned_points != 0)\n                sum += (1ull << num_aligned_points) - num_aligned_points - 1;\n        }\n    }\n    ll ans = mod(pow2(N) - sum - N - 1);\n    cout << ans << endl;\n}\n\n\nint main() {\n    input();\n    solve();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lld long long int\n#define ld long double\n#define mod 1000000007\n#define modd 998244353\n#define all(v) v.begin(),v.end()\n#define rep(i,a,b)\tfor(lld i=a;i<=b;i++)\n#define repr(i,a,b) for(lld i=a;i>=b;i--)\n#define ar array\n#define pb push_back\n#define mp make_pair\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nlld n,m;\nar<lld,2> arr[300000];\nmap<ar<lld,3>, lld> ma;\nlld fastpower(lld x, unsigned lld y, lld p)\n{\n    lld res = 1;\n    x = x % p;\n    while (y > 0)\n    {\n        if (y & 1)\n            res = (res*x) % p;\n        y = y>>1;\n        x = (x*x) % p;\n    }\n    return res;\n}\nint main()\n{\n     ios;\n     lld TESTS,q,a,s,b,l,r,c,k,p,h,w,d,x,y,z,xs,ys,t;\n     TESTS=1;\n     //cin>>TESTS;\n     while(TESTS--)\n     {\n         cin>>n;\n         rep(i,0,n-1)cin>>arr[i][0]>>arr[i][1];\n         lld cou=0;\n         rep(i,0,n-1) rep(j,i+1,n-1){\n            x=arr[i][0]-arr[j][0];\n            y=arr[i][1]-arr[j][1];\n            z=arr[i][1]*x-arr[i][0]*y;\n            lld g=__gcd(abs(x),abs(y));\n            g=__gcd(g,abs(z));\n            x/=g;y/=g;z/=g;\n            if (ma[{x,y,z}]) continue;\n            ma[{x,y,z}]=1;\n            lld now=2;\n            rep(k,0,n-1){\n                if(k==i||k==j)continue;\n                xs=arr[k][0]-arr[i][0];\n                ys=arr[k][1]-arr[i][1];\n                if (xs*y==ys*x)now++;\n            }\n            cou+=fastpower(2,now,modd);\n            cou%=modd;\n            cou+=modd-1;\n            cou%=modd;\n            cou+=modd-now;\n            cou%=modd;\n         }\n      //   cout<<cou<<\"\\n\";\n      lld ans=fastpower(2,n,modd)-1;\n      ans+=modd-cou;\n      ans%=modd;\n      ans+=modd-n;\n      ans%=modd;\n         cout<<ans;\n     }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define ll long long\n#define ld long double\n#define inf 1000000000\nusing namespace std;\n#define N 205\n#define mod 998244353\nint n,pw[N],ans;\nstruct node{ int x,y; }a[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tpw[0]=1; rep (i,1,n) pw[i]=2ll*pw[i-1]%mod;\n\tans=(pw[n]+mod-1-n)%mod;\n\trep (i,1,n) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\trep (i,1,n) rep (j,i+1,n){\n\t\tint sum=0;\n\t\trep (k,j+1,n)\n\t\t\tif ((a[i].y-a[j].y)*(a[j].x-a[k].x)==(a[i].x-a[j].x)*(a[j].y-a[k].y)) sum++;\n\t\tans=(ans+mod-pw[sum])%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(LL x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(LL x){write(x);putchar('\\n');}\nconst LL mod=998244353;\nconst int MAXN=205;\nLL pow_mod(LL a,int b)\n{\n\tLL ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ret=ret*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ret;\n}\nvoid dl(LL &x,LL y){x-=y;if(x<0)x+=mod;}\nvoid ad(LL &x,LL y){x+=y;if(x>=mod)x-=mod;}\nstruct pt{int x,y;}w[MAXN];\nint n;\nint multi(int p0,int p1,int p2)\n{\n\tint u1=w[p0].x-w[p1].x;\n\tint u2=w[p0].x-w[p2].x;\n\tint v1=w[p0].y-w[p1].y;\n\tint v2=w[p0].y-w[p2].y;;\n\treturn u1*v2-u2*v1;\n}\nbool ok(int u1,int u2)\n{\n\tfor(int i=1;i<u2;i++)if(i!=u1){if(!multi(u1,u2,i))return false;}\n\treturn true;\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)w[i].x=read(),w[i].y=read();\n\tLL ans=(pow_mod(2LL,n)-1+mod)%mod;\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)if(ok(i,j))\n\t{\n\t\tint cnt=2;\n\t\tfor(int k=j+1;k<=n;k++)if(!multi(i,j,k))cnt++;\n\t\tLL sum=(pow_mod(2,cnt)-(cnt+1)%mod+mod)%mod;\n\t\tdl(ans,sum);\n\t}\n\tpr2((ans-n+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <tuple>\nusing namespace std;\n\n#define FOR(i,init,a) for(int i=init; i<a; i++)\n#define rep(i,a) FOR(i,0,a)\n#define rrep(i,a) for(int i=a; i>=0; i--)\n#define rep1(i,a) for(int i=1; i<=a; i++)\n#define cout1(a) cout << a << endl;\n#define cout2(a,b) cout << a << \" \" << b << endl;\n#define cout3(a,b,c) cout << a << \" \" << b << \" \" << c << endl;\n#define cout4(a,b,c,d) cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n#define mem(a,n) memset( a, n, sizeof(a))\n#define all(a) a.begin(),a.end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\nconst int INF = 1e9;\nconst int MOD = 998244353;\nconst ll LLINF = 1e18;\nstatic const double pi = 3.141592653589793;\n\nint N, did[202][202];\nll X[202], Y[202], p2[202];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>N;\n    rep(i,N) cin>>X[i]>>Y[i];\n    \n    ll ret=1;\n    p2[0]=1;\n    rep(i,N) p2[i+1]=p2[i]*2%MOD;\n    \n    ret=(p2[N]+MOD-1-N-N*(N-1)/2)%MOD;\n    rep(y,N)rep(x,y) if(did[y][x]==0){\n        vector<int> V;\n        V.push_back(x);\n        V.push_back(y);\n        rep(i,N) if(i!=x&&i!=y) if((X[i]-X[x])*(Y[y]-Y[x])-(X[y]-X[x])*(Y[i]-Y[x])==0) V.push_back(i);\n        for(auto& a:V) for(auto& b:V) did[a][b]=1;\n        int r=V.size();\n        if(r>=3) ret=(ret+MOD-p2[r]+r+r*(r-1)/2+1)%MOD;\n    }\n    cout1((ret%MOD+MOD)%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 205\n#define mod 998244353\nint x[maxn],y[maxn];\nint pow(int a,int n)\n{\n    if(n==0)return 1;\n    int res=pow(a,n/2);\n    res=(long long)(res*res)%mod;\n    if(n&1)res=(long long)(res*a)%mod;\n    return res;\n}\nint add(int &a,int b)\n{\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nmain()\n{\n    int n;scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n    int ans=pow(2,n);\n    add(ans,mod-1),add(ans,mod-n),add(ans,mod-n*(n-1)/2);\n    for(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)\n    {\n        int cnt=2;\n        int a=y[j]-y[i],b=x[i]-x[j],c=-a*x[i]-b*y[i];\n        for(int k=1;k<=n;k++)\n        {\n            if(k==i || k==j)continue;\n            int s=a*x[k]+b*y[k]+c;\n            if(s!=0)continue;\n            if(k<j)break;\n            cnt++;\n        }\n        add(ans,mod-pow(2,cnt));\n        add(ans,1);\n        add(ans,cnt);\n        add(ans,cnt*(cnt-1)/2);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nconst long long P = 998244353;\n\nusing pii = pair<int, int>;\n\nbool f(pii x, pii y, pii z) {\n  int x1 = x.first - y.first;\n  int y1 = x.second - y.second;\n  int x2 = x.first - z.first;\n  int y2 = x.second - z.second;\n  return x1 * y2 - y1 * x2 == 0;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<int, int>> p(n);\n  for (int i = 0; i < n; i++)\n    cin >> p[i].first >> p[i].second;\n  long long pw[222] = {0};\n  pw[0] = 1;\n  for (int i = 0; i < n; i++)\n    pw[i + 1] = (pw[i] * 2) % P;\n  long long ret = pw[n];\n  ret = (ret - n - 1 + P) % P;\n  bool used[222][222] = {0};\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++) {\n      if (used[i][j])\n        continue;\n      vector<int> v;\n      v.push_back(i);\n      v.push_back(j);\n      for (int k = j + 1; k < n; k++) {\n        if (used[i][k] || used[j][k] || !f(p[i], p[j], p[k]))\n          continue;\n        v.push_back(k);\n      }\n      ret = (ret - pw[v.size()] + v.size() + 1 + P) % P;\n      for (int k = 0; k < v.size(); k++)\n        for (int h = k + 1; h < v.size(); h++)\n          used[k][h] = true;\n    }\n  cout << ret << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\n//const int MOD = 998244353;\nconst long long int MOD = 998244353;\nconst double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>x(N);\n\tvector<int>y(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tvector<long long int>by(N + 1, 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tby[i] = by[i - 1] * 2;\n\t\tby[i] %= MOD;\n\t}\n\tlong long int ans = by[N];\n\tans--;\n\tans -= N;\n\tans += MOD;\n\tans %= MOD;\n\tvector<vector<int>>skip(N, vector<int>(N));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i+1; j < N; j++) {\n\t\t\tif (skip[i][j])continue;\n\t\t\tvector<int>box;\n\t\t\tbox.push_back(i);\n\t\t\tbox.push_back(j);\n\t\t\tfor (int k = j + 1; k < N; k++) {\n\t\t\t\tif ((y[k] - y[j])*(x[j] - x[i]) == (y[j] - y[i])*(x[k] - x[j])) {\n\t\t\t\t\tbox.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += MOD;\n\t\t\tans += box.size() + 1;\n\t\t\tans -= by[box.size()];\n\t\t\tans %= MOD;\n\t\t\tfor (auto k : box) {\n\t\t\t\tfor (auto l : box) {\n\t\t\t\t\tskip[k][l] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Math = ♥\n// Sometimes it is people that no one imagines anything of who do things that no one can imagine\n// After all this time? Always\n\n#include <bits/stdc++.h>                        // uncomment before submission\n//#include <ext/pb_ds/assoc_container.hpp>\t\t// uncomment before submission\n//#include <ext/pb_ds/tree_policy.hpp>\t\t\t// uncomment before submission\n//using namespace __gnu_pbds;\t\t\t\t\t// uncomment before submission\nusing namespace std;\n//<---------------------------------------------------Template----------------------------------------------------------->\n#define int long long\n#define ll long long\n#define ld long double\nint INF = 1e9 + 7;\ntypedef pair<ll, ll> ii;\ntypedef vector<ll> vi;                  // Vector of long long\ntypedef vector<vi> vvi;                 // Vector of vi\ntypedef vector<ii> vii;                 // Vector of pairs\ntypedef vector<vii> vvii;               // Vector of Vector of pairs\ntypedef vector<bool> vb;                // Vector of bool\n#define pq priority_queue               // Max heap (To convert to min heap, use negative sign before every value)\n#define ff first                        // For pairs\n#define ss second                       // For pairs\n#define pb push_back                    // Pushback to vector\n#define mp make_pair                    // Makes pairs to be stored as pair\n#define all(c) (c).begin(), (c).end()   // Mainly used by me in sorting\n// ordered_set adds two new functions to set - (set).find_by_order([kth element based on zero indexing]) and order_of_key()\n// order_of_key returns number of elements less that parameter. If element exists, that order is its index\n#define ordered_set tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>\n//<----------------------------------------------------------------------------------------------------------------------->\n\nint mod = 998244353;\n\nint pow(int x, int n)\n{\n    int ans = 1;\n    if (n < 0) return 0;\n    while (n != 0)\n    {\n        if (n % 2 == 0)\n            ans = (ans * x) % mod;\n        x = (x * x) % mod;\n        n = n / 2;\n    }\n    return ans;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    ii a[n + 5];\n\n    for (int i = 0; i < n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        a[i].ff = x, a[i].ss = y;\n    }\n\n    int ans;\n    ans = pow(2, n) - 1 - n;\n    ans = ans + mod;\n    ans = ans % mod;\n\n    for (int i = 0; i < n - 1; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            int count = 0;\n            for (int k = j + 1; k < n; ++k)\n            {\n                int x1 = a[i].ff - a[j].ff, y1 = a[j].ff - a[k].ff;\n                int x2 = a[i].ss - a[j].ss, y2 = a[j].ss - a[k].ss;\n\n                if (x1 * y2 == y1 * x2)\n                    count++;\n            }\n            ans = ans + mod;\n            ans = ((int) (ans - pow(2, count))) % mod;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nconst long long P = 998244353;\n\nusing pii = pair<int, int>;\n\nbool f(pii x, pii y, pii z) {\n  int x1 = x.first - y.first;\n  int y1 = x.second - y.second;\n  int x2 = x.first - z.first;\n  int y2 = x.second - z.second;\n  return x1 * y2 - y1 * x2 == 0;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<int, int>> p(n);\n  for (int i = 0; i < n; i++)\n    cin >> p[i].first >> p[i].second;\n  long long pw[222] = {0};\n  pw[0] = 1;\n  for (int i = 0; i < n; i++)\n    pw[i + 1] = (pw[i] * 2) % P;\n  long long ret = pw[n];\n  ret = (ret - n - 1 + P) % P;\n  bool used[222][222] = {0};\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++) {\n      if (used[i][j])\n        continue;\n      vector<int> v;\n      v.push_back(i);\n      v.push_back(j);\n      for (int k = j + 1; k < n; k++) {\n        if (used[i][k] || !f(p[i], p[j], p[k]))\n          continue;\n        v.push_back(k);\n      }\n      ret = (ret - pw[v.size()] + v.size() + 1 + P) % P;\n      for (int k = 0; k < v.size(); k++)\n        for (int h = k + 1; h < v.size(); h++)\n          used[v[k]][v[h]] = true;\n    }\n  cout << ret << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define gcd std::__gcd\n#define EB emplace_back\n#define get Get\n\ntypedef std::pair <int, int> pr;\n\nstruct _hash_ {\n\ttypedef unsigned long long u64;\n\tstatic std::hash <u64> H;\n\tinline size_t operator () (const pr &x) const {return H(x.first | (u64)x.second << 32);}\n};\n\ntypedef std::unordered_map <pr, int, _hash_> umap;\ntypedef std::vector <int> vector;\nconst int N = 254, mod = 998244353;\n\nint n, cnt = 0;\nint x[N], y[N], pw2[N];\numap M;\nvector ps[N * N];\n\ninline int get(const pr &v) {\n\tumap::iterator it; bool ret;\n\tstd::tie(it, ret) = M.emplace(v, cnt + 1);\n\treturn ret ? ++cnt : it->second;\n}\n\ninline int gw(int n) {return (pw2[n] - n - 1 + mod) % mod;}\n\nint main() {\n\tint i, j, A, B, d, m, ans = 0;\n\tscanf(\"%d\", &n);\n\tfor (*pw2 = i = 1; i <= n; ++i) pw2[i] = pw2[i - 1] * 2 % mod;\n\tM.reserve(n * n), M.rehash(n * n * n);\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\"%d%d\", x + i, y + i);\n\t\tfor (j = 0; j < i; ++j) {\n\t\t\td = gcd(A = y[i] - y[j], B = x[j] - x[i]);\n\t\t\tif (A /= d, B /= d, A < 0) A = -A, B = -B;\n\t\t\td = get(pr(A, B)), ps[d].EB(i), ps[d].EB(j);\n\t\t}\n\t}\n\tfor (auto &v : M) {\n\t\tstd::tie(A, B) = v.first;\n\t\tvector &p = ps[v.second];\n\t\tstd::sort(p.begin(), p.end());\n\t\tp.erase(std::unique(p.begin(), p.end()), p.end());\n\t\tfor (int &k : p) k = A * x[k] + B * y[k];\n\t\tstd::sort(p.begin(), p.end()), m = p.size();\n\t\tfor (i = j = 0; i < m; i = j) {\n\t\t\tfor (; j < m && p[i] == p[j]; ++j);\n\t\t\tans += gw(j - i);\n\t\t}\n\t}\n\tans = pw2[n] - n - 1 - ans;\n\tprintf(\"%d\\n\", ans + (ans >> 31 & mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 100010\ntypedef long long LL;\nusing namespace std;\nconst LL mod = 998244353;\nLL x[maxn], y[maxn], P[maxn];\nint fa[maxn], sz[maxn];\nvoid unionn(int x, int y) {\n    x = fa[x], y = fa[y];\n    if (x == y) return;\n    if (sz[x] > sz[y]) swap(x, y);\n    fa[x] = y; sz[y] += sz[x];\n}\nstruct node {\n    int p, q; LL dx, dy;\n};\nbool cmp(node u, node v) {\n    return u.dx < v.dx || (u.dx == v.dx && u.dy < v.dy);\n}\nvector<node> seg;\nLL GCD(LL x, LL y) {\n    return y ? GCD(y, x % y) : x;\n}\nint main() {\n    LL n;\n    scanf(\"%lld\", &n);\n    for (int i = 0; i < n; ++i) scanf(\"%lld%lld\", &x[i], &y[i]);\n    P[0] = 1;\n    for (int i = 1; i <= n; ++i) (P[i] = P[i-1] << 1) %= mod;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            LL dx = x[i]-x[j], dy = y[i]-y[j];\n            LL gcd = GCD(dx, dy);\n            dx /= gcd, dy /= gcd;\n            if (dx < 0) dx = -dx, dy = -dy;\n            seg.push_back(node{i, j, dx, dy});\n        }\n    }\n    sort(seg.begin(), seg.end(), cmp);\n\n    LL ans = P[n] - 1 - n;\n    int i = 0, j = 0;\n    for (; i < seg.size(); i = j+1) {\n        for (int k = 0; k < n; ++k) fa[k] = k, sz[k] = 1;\n        for (j = i; ; ++j) {\n            unionn(seg[j].p, seg[j].q);\n            if (j+1 >= seg.size() || seg[i].dx != seg[j+1].dx || seg[i].dy != seg[j+1].dy) break;\n        }\n        for (int k = 0; k < n; ++k) {\n            if (fa[k] == k) ((ans -= (P[sz[k]] - sz[k] - 1)) += mod) %= mod;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MOD=998244353;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PI;\ntypedef pair<int,P> IP;\ntypedef pair<P,P> PP;\n\nint pw(int n,int k){\n  if(k<0)return pw(n,k+MOD-1);\n  int res=1;\n  while(k){\n    if(k&1)res*=n;res%=MOD;\n    n*=n;n%=MOD;\n    k>>=1;\n  }\n  return res;\n}\n\nint f(int a){\n  if(a<=2)return 0;\n  int res=pw(2,a);\n  res--;\n  res-=a;\n  res-=a*(a-1)/2;\n  res%=MOD;res+=MOD;res%=MOD;\n  return res;\n}\n\nsigned main(){\n  int n;cin>>n;\n  vector<P> a(n);\n  for(int i=0;i<n;i++){\n    int x,y;cin>>x>>y;\n    a[i]=P(x,y);\n  }\n  sort(a.begin(),a.end());\n  map<PP,int> m;\n  for(int i=0;i<n;i++){\n    map<P,PI> mp;\n    for(int j=i+1;j<n;j++){\n      int x=a[j].first-a[i].first,y=a[j].second-a[i].second;\n      P ka;\n      int g=__gcd(x,y);\n      if(g)ka=P(x/g,y/g);\n      else ka=P(1e9,1e9);\n      mp[ka]=PI(a[j],mp[ka].second+1);\n    }\n    for(auto p:mp){\n      P ka=p.first,po=p.second.first;\n      int v=p.second.second;\n      if(m.count(PP(ka,po)))continue;\n      m[PP(ka,po)]=v+1;\n    }\n  }\n\n  int ans=f(n);\n  for(auto p:m){\n    ans-=f(p.second);\n    ans+=MOD;\n    ans%=MOD;\n  }\n  ans%=MOD;ans+=MOD;ans%=MOD;\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cassert>\n#include <array>\n\nusing namespace std;\n\nconstexpr long long mod = 998244353;\n\nusing P = complex<int>;\n\nint dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\nint cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nnamespace std {\n  bool operator<(P a, P b) {\n    return atan2(a.imag(), a.real()) < atan2(b.imag(), b.real());\n  }\n}\n\nint gcd(int x, int y) {\n  x = abs(x);\n  y = abs(y);\n  if (y == 0) return x;\n  return gcd(y, x % y);\n}\n\nP unit(P a) {\n  int g = gcd(a.real(), a.imag());\n  return P(a.real() / g, a.imag() / g);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<P> ps(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    ps[i] = P(x, y);\n  }\n\n  vector<pair<int, int>> es;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      es.emplace_back(i, j);\n    }\n  }\n  sort(es.begin(), es.end(), [&](pair<int, int> a, pair<int, int> b) {\n    P d = ps[a.second] - ps[a.first];\n    P e = ps[b.second] - ps[b.first];\n    if (cross(d, e) == 0 && dot(d, e) >= 0) {\n      return dot(ps[a.second] - ps[a.first], ps[b.first] - ps[a.first]) < 0;\n    } else {\n      return d < e;\n    }\n  });\n\n  vector<vector<P>> qs(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      qs[i].push_back(ps[j] - ps[i]);\n    }\n    sort(qs[i].begin(), qs[i].end());\n    for (int j = 0; j < n - 1; j++) {\n      qs[i].push_back(qs[i][j]);\n    }\n  }\n\n  static int in[200][200][200];\n  static int on[200][200];\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      for (int k = 0; k < n; k++) {\n        if (i == k || j == k) continue;\n        for (int l = 0; l < n; l++) {\n          if (i == l || j == l || k == l) continue;\n          for (tuple<int, int, int> t : {make_tuple(i, j, k), make_tuple(k, i, j), make_tuple(i, j, k)}) {\n            int x, y, z;\n            tie(x, y, z) = t;\n            int L = lower_bound(qs[y].begin(), qs[y].begin() + (n - 1), unit(ps[y] - ps[x])) - qs[y].begin();\n            if (L == n - 1) continue;\n            int R = lower_bound(qs[y].begin() + L, qs[y].begin() + (L + n - 1), unit(ps[z] - ps[y])) - qs[y].begin();\n          }\n          //if (cross(ps[j] - ps[i], ps[l] - ps[i]) > 0 && cross(ps[k] - ps[j], ps[l] - ps[j]) > 0 && cross(ps[i] - ps[k], ps[l] - ps[k]) > 0) {\n          //  in[i][j][k]++;\n          //}\n        }\n        on[i][j] += cross(ps[k] - ps[i], ps[j] - ps[i]) == 0 && dot(ps[k] - ps[i], ps[j] - ps[i]) > 0 && dot(ps[k] - ps[j], ps[i] - ps[j]) > 0;\n      }\n    }\n  }\n\n  vector<long long> two(n + 1);\n  two[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two[i] = two[i - 1] * 2 % mod;\n  }\n\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    vector<long long> dp1(n);\n    vector<long long> dp2(n);\n    for (auto e : es) {\n      int u = e.first;\n      int v = e.second;\n\n      if (u == i) {\n        assert(dp1[v] == 0);\n        dp1[v] = two[on[u][v]];\n      } else if (v == i) {\n        dp2[v] += dp2[u];\n      } else {\n        int c = on[i][v] + on[u][v] + in[i][u][v];\n        dp2[v] += dp1[u] * two[c];\n        dp2[v] += dp2[u] * two[c];\n      }\n      dp2[v] %= mod;\n    }\n    ans += dp2[i];\n    ans %= mod;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long> > vvll;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _rep(i,n) _rep2((i),0,(n))\n#define _rep2(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(...) GET_MACRO(__VA_ARGS__, _rep2, _rep)(__VA_ARGS__)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 998244353LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\n// Mod int\n// const int MOD = 1000000007;\nstruct mint{\n    ll x;\n    mint():x(0){}\n    mint(ll x):x((x%MOD+MOD)%MOD){}\n    mint operator+=(const mint& a){ if((x+=a.x)>=MOD) x-=MOD; return *this;}\n    mint operator-=(const mint& a){ if((x+=MOD-a.x)>=MOD) x-=MOD; return *this;}\n    mint operator*=(const mint& a){ (x*=a.x)%=MOD; return *this;}\n    mint operator+(const mint& a)const{ return mint(*this) += a;}\n    mint operator-(const mint& a)const{ return mint(*this) -= a;}\n    mint operator*(const mint& a)const{ return mint(*this) *= a;}\n    bool operator==(const mint& a)const{ return x == a.x;}\n    friend ostream& operator<<(ostream& os, const mint& mi)  \n    {  \n        os << mi.x;  \n        return os;  \n    }\n};\n\n\nmint comb[300][300];\nint used[300][300];\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tvector<pii> v(n);\n\trep(i,n){\n\t\tcin>>v[i].fi>>v[i].se;\n\t}\n\trep(i,300){\n\t\tcomb[i][0] = comb[i][i] = mint(1);\n\t\trep(j,i-1){\n\t\t\tcomb[i][j+1] = comb[i-1][j]+comb[i-1][j+1];\n\t\t}\n\t}\n\tmint ans;\n\trep(i,n){\n\t\trep(j,i){\n\t\t\tif(used[i][j]) continue;\n\t\t\tvint w;\n\t\t\tw.PB(i);\n\t\t\tw.PB(j);\n\t\t\trep(k,n){\n\t\t\t\tif(i==k) continue;\n\t\t\t\tif(j==k) continue;\n\t\t\t\tif((v[i].fi-v[j].fi)*(v[i].se-v[k].se)-(v[i].se-v[j].se)*(v[i].fi-v[k].fi)==0){\n\t\t\t\t\tw.PB(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x: w){\n\t\t\t\tfor(int y: w){\n\t\t\t\t\tused[x][y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(k,3,w.size()+1){\n\t\t\t\tans -= comb[w.size()][k];\n\t\t\t}\n\t\t}\n\t}\n\trep(i,3,n+1){\n\t\tans += comb[n][i];\n\t}\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n    vec d, root;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n        d = vec(V);\n        root = vec(V);\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void erase_edge(int from, int to){\n        vec e(0);\n        REP(i, G[from].size()){\n            if(G[from][i].to == to) e.push_back(i);\n        }\n        IREP(i, e.size()) G[from].erase(G[from].begin() + e[i]);\n    }\n\n    void erase_edge2(int v1, int v2){\n        erase_edge(v1, v2);\n        erase_edge(v2, v1);\n    }\n\n    void dfs(int v, vector<bool> &used, int &n){\n        REP(k, G[v].size()){\n            if(!used[G[v][k].to]){\n                n++;\n                used[G[v][k].to] = true;\n                dfs(used[G[v][k].to], used, n);\n            }\n        }\n    }\n\n};\n\nint fastpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = fastpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int comb(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nbool on_line(int x1, int y1, int x2, int y2, int x3, int y3){\n    int X1 = x1 - x3;\n    int Y1 = y1 - y3;\n    int X2 = x2 - x3;\n    int Y2 = y2 - y3;\n    if(X1 * Y2 == Y1 * X2){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    vec x(N), y(N);\n    REP(i, N) cin >> x[i] >> y[i];\n\n    Graph line(N);\n    REP(i, N){\n        FOR(j, i + 1, N){\n            FOR(k, j + 1, N){\n                if(on_line(x[i], y[i], x[j], y[j], x[k], y[k])){\n                    line.add_edge2(i, j, 0);\n                    line.add_edge2(i, k, 0);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    int mod = 998244353;\n    Combination C(N, mod);\n\n\n    \n    FOR(k, 3, N + 1) ans = (ans + C.comb(N, k)) % mod;\n\n    vector<bool> used(N, false);\n    REP(i, N){\n        if(!used[i]){\n            int n = 1;\n            used[i] = true;\n            line.dfs(i, used, n);\n            FOR(k, 3, n + 1) ans = (ans + mod - C.comb(n, k)) % mod;\n        }\n    }\n\n    cout << ans;\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int mod=998244353;\nint x[2005],y[2005],tw[2100],n,num,ans;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>x[i]>>y[i];\n\ttw[0]=1;\n\tfor(int i=1;i<=2000;i++)\n\t\ttw[i]=(tw[i-1]<<1)%mod;\n\tans=tw[n]-n-1;\n\t//cout<<tw[n]<<endl;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tnum=0;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\t\tif((x[j]-x[i])*(y[k]-y[j])==(x[k]-x[j])*(y[j]-y[i]))\n\t\t\t\t\tnum++;\n\t\t\tans=(ans-tw[num]+mod)%mod;\n\t\t//\tcout<<i<<\" \"<<j<<\" \"<<ans<<endl;\n\t\t}\n\t//ans-=(n+1);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <string>\n#include <complex>\n\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\n#define REP(i,e) for(int i=0;i<(int)(e);i++)\n#define FOR(i,b,e) for(int i=(int)(b);i<(int)(e);i++)\n#define ALL(c) (c).begin(), (c).end()\n#define EACH(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define RALL(c) (c).rbegin(), (c).rend()\n#define ALLA(a,n) ((a)+0), ((a)+n)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef vector<string> vstring;\ntypedef vector<double> vdouble;\n\ntemplate<class T>void pp(T v,int n){ REP(i,n)cout<<v[i]<< ' ' ; cout << endl; }\ntemplate<class T>void pp(T v){ EACH(it,v) cout << *it << ' ' ; cout << endl;  }\ntemplate<class T>T& ls(T& a,T b){ if(b<a) a=b; return a; }\ntemplate<class T>T& gs(T& a,T b){ if(b>a) a=b; return a; }\ninline ll to_i(const string& s){ll n;sscanf(s.c_str(),\"%lld\",&n);return n;}\ninline string to_s(ll n){char buf[32];sprintf(buf,\"%lld\",n);return string(buf);}\n\nstruct __scanner__{ bool e; operator bool(){ return e; } } IN = { false };\ninline __scanner__& operator>>(__scanner__& in,int &n)\n{ in.e = scanf(\"%d\",&n)==1; return in; }\ninline __scanner__& operator>>(__scanner__& in,ll &n)\n{ in.e = scanf(\"%lld\",&n)==1; return in; }\ninline __scanner__& operator>>(__scanner__& in,double &n)\n{ in.e = scanf(\"%lf\",&n)==1; return in; }\ninline __scanner__& operator>>(__scanner__& in,char &n)\n{ in.e = scanf(\" %c\",&n)==1; return in; }\ninline __scanner__& operator>>(__scanner__& in,string &n) // BUFFER SIZE!\n{ static char buf[1000000]; in.e = scanf(\" %s\",buf)==1; n = buf; return in; } \n\nconst ll MOD = 998244353;\n\n// constants\nconst double eps=1e-9;\nconst double inf=1e256;\nconst double pi=3.1415926535897932;\n\n// type definition\ntypedef complex<double> pt;\nstruct seg{ pt s,d; };\ntypedef seg line;\n\ntypedef vector<pt> gon;\ntypedef vector<pt> vpt;\n\n// basic function\nnamespace std{\n  bool operator<(const pt &a,const pt b){\n    return a.real()<b.real() || (a.real()==b.real() && a.imag()<b.imag());\n  }\n}\n\ninline bool eq(double a,double b){ return fabs(a-b)<eps; }\ninline bool pteq(pt a,pt b){ return eq(real(a),real(b)) && eq(imag(a),imag(b));}\n\ninline double dot  (pt a,pt b){ return real(conj(a)*b); }\ninline double cross(pt a,pt b){ return imag(conj(a)*b); }\n\n// counterclockwise\n//                 +1\n// +2 --- (l.s) ----0---> (l.d) --- -2\n//                 -1            (Same as Mr. Maebara's)\ninline int ccw(line l,pt p){\n  p-=l.s;\n  double c=cross(l.d-l.s,p);\n  if(!eq(c,0)) return (c<0 ? -1 : 1);\n  if(dot(l.d-l.s,p)<-eps) return 2;\n  if(norm(l.d-l.s)+eps<norm(p)) return -2;\n  return 0;\n}\n\nvll ps(256, 1);\n\nll compute(const vpt& v) {\n  vector<line> u;\n  REP(i,v.size()) REP(j,i) {\n    bool ok = true;\n    line t = { v[i], v[j] };\n    REP(k,u.size()) if (abs(ccw(u[k], v[i])) != 1 && abs(ccw(u[k], v[j])) != 1) {\n      // cout << u[k].s << \"-\" <<  u[k].d << ' '\n      // \t   << v[i] << ' ' << ccw(u[k], v[i])\n      // \t   << v[j] << ' ' << ccw(u[k], v[j]) << endl;\n      ok = false; break;\n    }\n    if (ok) u.push_back((line) { v[i], v[j] });\n  }\n  // cout << \"lines \" << u.size() << endl; \n  // REP(i, u.size()) cout << u[i].s << ' ' << u[i].d << endl;\n  \n  ll result = ps[v.size()];\n  // cout << \"entire: \" << result << endl;\n  result -= 1;\n  result -= v.size();\n  result += MOD; result %= MOD;\n  REP(i,u.size()) {\n    ll cnt = 0;\n    REP(j,v.size()) if (abs(ccw(u[i], v[j])) != 1) cnt++;\n    // cout << \"minus: \" << cnt << ' ' << ps[cnt] - cnt - 1 << endl;\n    result -= ps[cnt] - cnt - 1;\n    result += MOD; result %= MOD;\n  }\n\n  return result;\n}\n\nint main(){\n  FOR(i,1,ps.size()) ps[i] = ps[i-1] * 2 % MOD;\n  int n;\n  while (cin >> n) {\n    vpt v(n);\n    double x, y;\n    REP(i,n) {\n      cin >> x >> y;\n      v[i] = pt(x, y);\n    }\n    cout << compute(v) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, x[200], y[200];\nll res, pw2[200];\n\nll pw(ll x, int y) {\n\tll a = 1;\n\twhile (y) {\n\t\tif (y & 1) {\n\t\t\ta = a*x%mod;\n\t\t}\n\t\tx = x*x%mod;\n\t\ty >>= 1;\n\t}\n\treturn a;\n}\n\nll modinv(ll x) {\n\treturn pw(x, mod - 2);\n}\n\nint main(){\n\tcin >> N;\n\tll t = N*(N - 1), m = modinv(2);\n\tfor (int i = 3; i <= N; ++i) {\n\t\tt = (t*(N + 1 - i)) % mod;\n\t\tm = (m*modinv(i)) % mod;\n\t\tres = (res + t*m) % mod;\n\t}\n\tpw2[0] = 1;\n\tfor (int i = 1; i < 200; ++i) {\n\t\tpw2[i] = pw2[i - 1] * 2 % mod;\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\tint t = 0;\n\t\t\tfor (int k = j + 1; k < N; ++k) {\n\t\t\t\tif ((x[i] - x[j])*(y[j] - y[k]) == (x[j] - x[k])*(y[i] - y[j])) {\n\t\t\t\t\tres = (res + mod - pw2[t]) % mod;\n\t\t\t\t\t++t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define nl '\\n'\ntypedef long long ll;\ntypedef long double ld;\n//////////////////////////////////////////////////////////////////////\n\nconst int N = 221;\nstruct Line{\n  ll a,b,c;\n  Line(const pair<ll,ll>&p1,const pair<ll,ll>&p2){\n    a = p2.ss - p1.ss;\n    b = p1.ff - p2.ff;\n    c = -p2.ss * b - p2.ff * a;\n    ll g = __gcd(a,b);g = __gcd(g,c);\n    //cerr << \"!\" << a << ',' << b << ',' << c << endl;\n    a /= g;b /= g;c /= g;\n  }\n};\nbool operator<(const Line&l1,const Line&l2){\n  return l1.a != l2.a ? l1.a < l2.a : (l2.b!=l1.b ? l1.b<l2.b : l1.c < l2.c);\n}\nmap<Line,int > mp;\n\nll n,rev[N*N];\npair<ll,ll> p[N];\n\nconst ll mod = 998244353;\nll exMod(ll x,ll pow){\n  ll y = 1;\n  for(;pow>0;pow>>=1,x=(x*x)%mod)\n    if(pow&1)y = (y*x)%mod;\n  return y;\n}\n\nint main(){\n  ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n  \n  cin>>n;\n  for(int i=1;i<=n;i++){\n    cin>>p[i].ff>>p[i].ss;\n    rev[(i*i-i)/2] = i;\n  }\n\n  for(int i=1;i<=n;i++)\n    for(int j=i+1;j<=n;j++){\n      Line Lij = Line(p[i],p[j]);\n      mp[Lij]++;\n    }\n\n  ll ans = exMod(2,n);\n  for(auto&it:mp){\n    Line line = it.ff;int cnt = it.ss;\n    ll vertices = rev[cnt];\n    //cerr << \"#\" << vertices << endl;\n    ans = (ans + 1 + vertices + mod - exMod(2,vertices))%mod;\n  }\n  ans = (ans + mod - 1 - n)%mod;\n  cout << ans << endl;\n  \n  return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "// {{{ Templates\n#include <bits/stdc++.h>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 998244353LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\n// }}}\n\ninline bool on(ll x0, ll y0, ll x1, ll y1, ll x, ll y)\n{\n    const ll DX = x1 - x0;\n    const ll DY = y1 - y0;\n    const ll dx = x - x0;\n    const ll dy = y - y0;\n    return dx * DY == dy * DX;\n}\n\nll power(const ll p, const ll n)\n{\n    if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 1) {\n        return (power(p, n - 1) * p) % MOD;\n    } else {\n        const ll pp = power(p, n / 2);\n        return (pp * pp) % MOD;\n    }\n}\n\ninline ll calc(const ll n)\n{\n    if (n <= 2) {\n        return 0;\n    }\n    return (((power(2, n) - ((n * n + n + 2) / 2)) % MOD) + MOD) % MOD;\n}\n\nstruct Line {\n    ll ind;\n    ll dx;\n    ll dy;\n    bool operator==(const Line& l) const\n    {\n        return (ind == l.ind) and (dx * l.dy == dy * l.dx);\n    }\n    bool operator<(const Line& l) const\n    {\n        return (ind != l.ind) ? ind < l.ind : dx * l.dy < dy * l.dx;\n    }\n};\n\nostream& operator<<(ostream& os, const Line& l)\n{\n    os << \"ind: \" << l.ind << \"\\ndx: \" << l.dx << \"\\ndy:\" << l.dy << endl;\n    return os;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    vector<ll> x(N);\n    vector<ll> y(N);\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    map<Line, ll> lines;\n    for (int i = 0; i < N - 2; i++) {\n        for (int j = i + 1; j < N - 1; j++) {\n            bool flag = false;\n            for (int k = 0; k < N; k++) {\n                if (k == i or k == j) {\n                    continue;\n                }\n                if (on(x[i], y[i], x[j], y[j], x[k], y[k])) {\n                    const Line ln = Line{min({i, j, k}), x[j] - x[i], y[j] - y[i]};\n                    if (lines.find(ln) == lines.end()) {\n                        lines[ln] = 3;\n                        for (int l = 0; l < N; l++) {\n                            if (l == i or l == j or l == k) {\n                                continue;\n                            }\n                            if (on(x[i], y[i], x[j], y[j], x[l], y[l])) {\n                                lines[ln]++;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    ll calced = calc(N);\n    for (const auto& e : lines) {\n        const ll l = e.second;\n        calced -= calc(l);\n        calced = ((calced % MOD) + MOD) % MOD;\n    }\n    cout << calced << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 998244353;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-9;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll po[210];\n\nint main() {\n    ll N;\n    cin >> N;\n    plglg pt[N];\n    REP(i, 0, N) {\n        ll x, y;\n        cin >> x >> y;\n        pt[i] = plglg(x, y);\n    }\n    sort(pt, pt + N);\n    po[0] = 1;\n    REP(i, 1, 210) {\n        po[i] = multiply(po[i - 1], 2);\n    }\n    xy_t pt2[N];\n    REP(i, 0, N) {\n        pt2[i] = xy_t(pt[i].first, pt[i].second);\n    }\n    ll difnum = 0;\n    REP(k, 0, N) {\n        vector<pdlg> vec;\n        xy_t base = pt2[k];\n        REP(i, k + 1, N) {\n            xy_t tar = pt2[i];\n            double ab = abs(tar - base);\n            xy_t dif = (tar - base) / ab;\n            double d = dif.imag();\n            bool ok = false;\n            REP(j, 0, vec.size()) {\n                pdlg p = vec[j];\n                if (abs(d - p.first) < eps) {\n                    vec[j].second++;\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok) {\n                vec.push_back(pdlg(d, 1));\n            }\n        }\n        REP(i, 0, vec.size()) {\n            ll p = vec[i].second;\n            if (p > 1) {\n                ll zero = 1;\n                ll one = p;\n                ll sum = zero + one;\n                difnum = modadd(difnum, modadd(po[p], - sum));\n            }\n        }\n    }\n    ll anssum = 1 + N + N * (N - 1) / 2;\n    //cout << anssum << \" \" << difnum << endl;\n    ll ans = modadd(po[N], - modadd(anssum, difnum));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint read()\n{\n\tint ans=0;\n\tchar ch=getchar();\n\tfor(;(ch<'0' || ch>'9') && ch!='-';ch=getchar());\n\tbool flag=0;\n\tif(ch=='-')flag=1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())ans=ans*10+ch-'0';\n\tif(flag)ans=-ans;\n\treturn ans;\n}\n\nlong long rell()\n{\n\tlong long ans=0;\n\tchar ch=getchar();\n\tfor(;(ch<'0' || ch>'9') && ch!='-';ch=getchar());\n\tbool flag=0;\n\tif(ch=='-')flag=1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())ans=ans*10ll+(long long)(ch-'0');\n\tif(flag)ans=-ans;\n\treturn ans;\n}\n\nvoid writ(int n)\n{\n\tchar ch[25];\n\tint m=0;\n\tif(n<0)putchar('-'),n=-n;\n\tif(n==0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tfor(;n;n/=10)ch[m++]=n%10ll+'0';\n\tfor(;m;)putchar(ch[--m]);\n}\n\nvoid wrll(long long n)\n{\n\tchar ch[25];\n\tint m=0;\n\tif(n<0)putchar('-'),n=-n;\n\tif(n==0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tfor(;n;n/=10ll)ch[m++]=n%10ll+'0';\n\tfor(;m;)putchar(ch[--m]);\n}\nconst int N=1<<8;\nconst long long mod=998244353;\nlong long x[N],y[N],po[N];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tpo[0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tx[i]=read(),y[i]=read();\n\t\tpo[i+1]=po[i]*2ll%mod;\n\t}\n\tint ans=(po[n]-1-n+mod)%mod;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tlong long a=y[i]-y[j],b=x[j]-x[i],c=-x[i]*y[j]+x[j]*y[i];\n\t\t\tint sum=1;\n\t\t\tfor(int k=j+1;k<n;k++)\n\t\t\t{\n\t\t\t\tif(x[k]*a+y[k]*b+c==0)sum++;\n\t\t\t}\n\t\t\t(ans+=mod-po[sum-1])%=mod;\n\t\t\t//printf(\"i=%d j=%d sum=%d\\n\",i,j,sum);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fst first\n#define snd second\n#define rep(n) for(lint I = 0; (I) < (lint)(n); ++(I))\n#define repeat(i, n) for(lint i = 0; (i) < (lint)(n); ++(i))\n#define repeat_to(i, n) for(lint i = 0; (i) <= (lint)(n); ++(i))\n#define repeat_from(i, m, n) for(lint i = (m); (i) < (lint)(n); ++(i))\n#define repeat_from_to(i, m, n) for(lint i = (m); (i) <= (lint)(n); ++(i))\n#define repeat_reverse_from_to(i, m, n) for(lint i = (m); (i) >= (lint)(n); --(i))\n#define el cout<<endl\n#define dump(x) cout<<\" \"<<#x<<\"=\"<<x\n#define vdump(v) for(size_t I=0; I<v.size(); ++I){cout<<\" \"<<#v<<\"[\"<<I<<\"]=\"<<v[I];} cout<<endl\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\n\n// 最大公約数\nlint gcd(lint a, lint b) {\n    // 引数の一方が 0 なら他方の値を返す\n    return b ? gcd(b, a%b) : a;\n}\n\nint main(void) {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> p(n);\n    repeat(i, n) cin >> p[i].fst >> p[i].snd;\n    \n    auto normalized_line = [](pair<int, int> p, pair<int, int> q) {\n        tuple<int, int, int> t;\n        int x1 = p.fst, y1 = p.snd;\n        int x2 = q.fst, y2 = q.snd;\n        int a = y1 - y2;\n        int b = x2 - x1;\n        int c = x1 * y2 - x2 * y1;\n        if (a < 0) {\n            a = -a; b = -b; c = -c;\n        }\n        int g = gcd(a, b); g = gcd(g, c);\n        a /= g; b /= g; c /= g;\n        t = tuple<int, int, int>{a, b, c};\n        return t;\n    };\n    \n    map<tuple<int, int, int>, set<pair<int, int>>> mp;\n    \n    repeat(i, n) {\n        repeat_from(j, i + 1, n) {\n            auto t = normalized_line(p[i], p[j]);\n            mp[t].insert(p[i]);\n            mp[t].insert(p[j]);\n        }\n    }\n    \n    lint MOD = 998244353LL;\n    lint ans = 1;\n    rep(n) {\n        (ans *= 2) %= MOD;\n    }\n    ((ans += MOD) -= 1) %= MOD;\n    ((ans += MOD) -= n) %= MOD;\n    \n    for(auto e: mp) {\n        lint t = 1;\n        rep(e.snd.size()) {\n            (t *= 2) %= MOD;\n        }\n        ((t += MOD) -= 1) %= MOD;\n        ((t += MOD) -= e.snd.size()) %= MOD;\n        ((ans += MOD) -= t) %= MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define gcd std::__gcd\n#define EB emplace_back\n\ntypedef std::pair <int, int> pr;\n\nstruct _hash_ {\n\ttypedef unsigned long long u64;\n\tstatic std::hash <u64> H;\n\tinline size_t operator () (const pr &x) const {return H(x.first | (u64)x.second << 32);}\n};\n\ntypedef std::unordered_map <pr, int, _hash_> umap;\ntypedef std::vector <int> vector;\nconst int N = 254, mod = 998244353;\n\nint n, cnt = 0;\nint x[N], y[N], pw2[N];\numap M;\nvector ps[N * N];\n\ninline int get(const pr &v) {\n\tumap::iterator it; bool ret;\n\tstd::tie(it, ret) = M.emplace(v, cnt + 1);\n\treturn ret ? ++cnt : it->second;\n}\n\ninline int gw(int n) {return (pw2[n] - n - 1 + mod) % mod;}\n\nint main() {\n\tint i, j, A, B, d, m, ans = 0;\n\tscanf(\"%d\", &n);\n\tfor (*pw2 = i = 1; i <= n; ++i) pw2[i] = pw2[i - 1] * 2 % mod;\n\tM.reserve(n * n), M.rehash(n * n * n);\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\"%d%d\", x + i, y + i);\n\t\tfor (j = 0; j < i; ++j) {\n\t\t\td = gcd(A = y[i] - y[j], B = x[j] - x[i]);\n\t\t\tif (A /= d, B /= d, A < 0) A = -A, B = -B;\n\t\t\td = get(pr(A, B)), ps[d].EB(i), ps[d].EB(j);\n\t\t}\n\t}\n\tfor (auto &v : M) {\n\t\tstd::tie(A, B) = v.first;\n\t\tvector &p = ps[v.second];\n\t\tstd::sort(p.begin(), p.end());\n\t\tp.erase(std::unique(p.begin(), p.end()), p.end());\n\t\tfor (int &k : p) k = A * x[k] + B * y[k];\n\t\tstd::sort(p.begin(), p.end()), m = p.size();\n\t\tfor (i = j = 0; i < m; i = j) {\n\t\t\tfor (; j < m && p[i] == p[j]; ++j);\n\t\t\tans += gw(j - i);\n\t\t}\n\t}\n\tans = pw2[n] - n - 1 - ans;\n\tprintf(\"%d\\n\", ans + (ans >> 31 & mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\nint n, ans;\nstruct pnt\n{\n    int x, y;\n    double angle;\n    pnt() {}\n    pnt(int x, int y) : x(x), y(y) {}\n} p[210];\npnt operator+(pnt x, pnt y) { return pnt(x.x + y.x, x.y + y.y); }\npnt operator-(pnt x, pnt y) { return pnt(x.x - y.x, x.y - y.y); }\nint operator*(pnt x, pnt y) { return x.x * y.y - x.y * y.x; }\n\nlong long Pow2(int x)\n{\n    if (x <= 60) return (1LL << x) % mod;\n    long long ans = Pow2(x >> 1);\n    ans = ans * ans % mod;\n    if (x & 1) ans = (ans << 1) % mod;\n    return ans;\n}\nbool in(pnt x, pnt y, pnt p)\n{\n    if (x.x > y.x) swap(x.x, y.x);\n    if (x.y > y.y) swap(x.y, y.y);\n    return p.x >= x.x && p.x <= y.x && p.y >= x.y && p.y <= y.y;\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d%d\", &p[i].x, &p[i].y);\n    ans = Pow2(n) - 1 - n;\n    for (int i = 1; i < n; i++)\n    {\n        for (int j = 0; j < i; j++)\n        {\n            int cnt = 0;\n            for (int k = 0; k < n; k++)\n                if ((p[i] - p[k]) * (p[j] - p[k]) == 0)\n                {\n                    if (!in(p[i], p[j], p[k]))\n                    {\n                        // printf(\"%d %d %d\\n\", i, j, k);\n                        cnt = -1;\n                        break;\n                    }\n                    cnt++;\n                }\n            // printf(\"%d %d %d\\n\", i, j, cnt);\n            if (~cnt)\n            {\n                (ans -= Pow2(cnt) - 1 - cnt) %= mod;\n            }\n        }\n    }\n    printf(\"%d\\n\", (ans + mod) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vdouble = vector<double>;\nusing vvdouble = vector<vdouble>;\nusing vvvdouble = vector<vvdouble>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\nconstexpr int mod2 = 998244353;\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) { return (a > b && (a = b, true)); }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) { return (a < b && (a = b, true)); }\ntemplate<typename T>\nbool isin(T y, T x, T h, T w) { return (0 <= y && 0 <= x && y < h && x < w); }\ntemplate<typename T>\nbool isin1(T y, T x, T h, T w) { return (0 < y && 0 < x && y <= h && x <= w); }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++) os << \" \" << v[i];\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nconstexpr double EPS = 1e-10;\nbool equals(double a, double b) { return (abs(a - b) < EPS); }\n\nstruct V2 {\n\tdouble x, y;\n\tV2(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tV2 operator + (V2 p) const { return (V2(x + p.x, y + p.y)); }\n\tV2 operator - (V2 p) const { return (V2(x - p.x, y - p.y)); }\n\tV2 operator * (double r) const { return (V2(x * r, y * r)); }\n\tV2 operator / (double r) const { return (V2(x / r, y / r)); }\n\n\tdouble norm() const { return (sqrt(sqrNorm())); }\n\tdouble sqrNorm() const { return (x*x + y*y); }\n\n\tbool operator < (const V2 &p) const { \n\t\treturn (x != p.x ? x < p.x : y < p.y); \n\t}\n\tbool operator == (const V2 &p) const {\n\t\treturn (equals(x, p.x) && equals(y, p.y));\n\t}\n\n\tV2 rotate90() const { return (V2(y, -x)); }\n\tV2 normalized() const { return (*this / norm()); }\n\n\tdouble dot(const V2 &p) const { return (x*p.x + y*p.y); }\n\tdouble cross(const V2 &p) const { return (x*p.y - y*p.x); }\n\tdouble arg() const { return (atan2(y, x)); }\n};\n\nvoid Main() {\n\tint N; cin >> N;\n\tvector<V2> ps(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> ps[i].x >> ps[i].y;\n\t}\n\n\tll sum = 0;\n\n\tsort(begin(ps), end(ps));\n\tfor (int a = 0; a < N; a++) {\n\t\tvector<pair<double, V2>> dats;\n\t\tint n = N-a-1;\n\t\tfor (int b = a+1; b < N; b++) {\n\t\t\tdats.emplace_back((ps[b]-ps[a]).arg(), ps[b]-ps[a]);\n\t\t}\n\t\tsort(begin(dats), end(dats));\n\t\tvector<V2> nps(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnps[i] = dats[i].second;\n\t\t}\n\n\t\tvvll contval(n, vll(n, 1));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tfor (int k = j+1; k < n; k++) {\n\t\t\t\t\tif ((nps[k]-nps[i]).cross(nps[j]-nps[i]) > -EPS) {\n\t\t\t\t\t\t(contval[i][k] *= 2) %= mod2;\n\t\t\t\t\t\t//cout << a << \" \" << nps[i].x << \" \" << nps[i].y << \" \" << nps[k].x << \" \" << nps[k].y << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tvvll dp(n, vll(n, 0));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tif (!equals(nps[i].cross(nps[j]), 0.0)) dp[i][j] = contval[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tV2 v1 = nps[j]-nps[i];\n\t\t\t\tfor (int k = j+1; k < n; k++) {\n\t\t\t\t\tV2 v2 = nps[k]-nps[i];\n\t\t\t\t\tif (v1.cross(v2) < EPS) continue;\n\t\t\t\t\t(dp[j][k] += contval[j][k] * dp[i][j]) %= mod2;\n\t\t\t\t}\n\t\t\t\t(sum += dp[i][j]) %= mod2;\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nbool on_the_line(pii &a, pii &b, pii &c){\n    return ((a.first - c.first)*(b.second-c.second)-(a.second-c.second)*(b.first-c.first)==0);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    pii points[N];\n    REP(i, N){\n        cin >> points[i].first >> points[i].second;\n    }\n    int did[N][N] = {};\n\n    ll pow2[N+2];\n    pow2[0] = 1;\n    for(int i=1;i<N+2;i++){\n        pow2[i] = (2*pow2[i-1])%mod;\n    }\n\n    ll res = pow2[N];\n    res = (res+mod-1)%mod;\n    res = (res+mod-N)%mod;\n\n    for(int i=0;i<N;i++){\n        for (int j=i+1;j<N;j++){\n            if(did[i][j]==0){\n                vector<int> tmp;\n                tmp.push_back(i);\n                tmp.push_back(j);\n                for(int k=j+1;k<N;k++){\n                    if(on_the_line(points[i], points[j], points[k])){\n                        tmp.push_back(k);\n                    }\n                }\n                REP(p, tmp.size()) REP(q, tmp.size()) did[p][q] = 1;\n                int s = tmp.size();\n                res = (res+mod-(pow2[s]-1-s))%mod;\n            }\n        }\n    }\n    cout << (res%mod+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/** @Date    : 2017-09-02 20:30:47\n  * @FileName: C.cpp\n  * @Platform: Windows\n  * @Author  : Lweleth (SoungEarlf@gmail.com)\n  * @Link    : https://github.com/\n  * @Version : $Id$\n  */\n#include <bits/stdc++.h>\n#define LL long long\n#define PII pair<int ,int>\n#define MP(x, y) make_pair((x),(y))\n#define fi first\n#define se second\n#define PB(x) push_back((x))\n#define MMG(x) memset((x), -1,sizeof(x))\n#define MMF(x) memset((x),0,sizeof(x))\n#define MMI(x) memset((x), INF, sizeof(x))\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 210;\nconst double eps = 1e-8;\nconst LL mod = 998244353;\n\nLL fa[210], inv[210];\n\nLL fpow(LL a, int n)\n{\n    LL r = 1;\n    while(n > 0)\n    {\n        if(n & 1)\n            r = r * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return r;\n}\nvoid init()\n{\n    fa[0] = 1;\n    inv[0] = 1;\n    for(LL i = 1; i <= 200; i++)\n    {\n        fa[i] = fa[i-1] * i % mod;\n        inv[i] = fpow(fa[i], mod - 2);\n    }\n}\n\nLL C(LL n, LL m)\n{\n    if(n < 0)\n        return 0;\n    n >>= 1;\n    if(n == 0)\n    \treturn 1LL;\n    LL ans = 0;\n    ans = ((fa[n + m] * inv[m] % mod)* inv[n]) % mod;\n    return ans;\n}\n\n\nstruct point\n{\n\tdouble x, y;\n\tpoint(){}\n\tpoint(double _x, double _y){x = _x, y = _y;}\n\tpoint operator -(const point &b) const\n\t{\n\t\treturn point(x - b.x, y - b.y);\n\t}\n\tdouble operator *(const point &b) const \n\t{\n\t\treturn x * b.x + y * b.y;\n\t}\n\tdouble operator ^(const point &b) const\n\t{\n\t\treturn x * b.y - y * b.x;\n\t}\n};\n\ndouble xmult(point p1, point p2, point p0)  \n{  \n    return (p1 - p0) ^ (p2 - p0);  \n}  \n\ndouble distc(point a, point b)\n{\n\treturn sqrt((double)((b - a) * (b - a)));\n}\nint sign(double x)\n{\n\tif(fabs(x) < eps)\n\t\treturn 0;\n\tif(x < 0)\n\t\treturn -1;\n\telse \n\t\treturn 1;\n}\n\n////////\nint n;\npoint stk[N];\npoint p[N];\n\nint cmpC(point a, point b)//水平序排序\n{\n\treturn sign(a.x - b.x) < 0 || (sign(a.x - b.x) == 0 && sign(a.y - b.y) < 0);\n}\n\nint Graham()//水平序\n{\n\tsort(p, p + n, cmpC);\n\tint top = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\twhile(top >= 2 && sign(xmult(stk[top - 2], stk[top - 1], p[i])) < 0)\n\t\t\ttop--;\n\t\tstk[top++] = p[i];\n\t}\n\tint tmp = top;\n\tfor(int i = n - 2; i >= 0; i--)\n\t{\n\t\twhile(top > tmp && sign(xmult(stk[top - 2],stk[top - 1] ,p[i] )) < 0)\n\t\t\ttop--;\n\t\tstk[top++] = p[i];\n\t}\n\tif(n > 1)\n\t\ttop--;\n\treturn top;\n}\n\n\nint check(int m)\n{\n\t//cout << m << endl;\n\tLL c = 2;\n\tLL t = 0;\n\tfor(int i = 1; i < m; i++)\n\t{\n\t\tif(sign(xmult(stk[i - 1], stk[(i + 1)%(m)], stk[i])) == 0 \n\t\t\t&& sign(xmult(stk[i], stk[(i + 2)%(m)], stk[(i + 1)%(m)])) == 0)\n\t\t\tc++;\n\t\telse if(c > 2) c++ , t = (t + fpow(2, c) - (1LL + c + c * (c - 1) / 2LL) + mod) % mod, c = 2;\n\t}\n\tt = (t + fpow(2, c) - (1LL + c + c * (c - 1) / 2LL) + mod) % mod;\n\treturn t;\n}\n/////////\nint main()\n{\n\n\twhile(~scanf(\"%d\", &n))\n\t{\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tp[i] = point(x, y);\n\t\t}\n\t\tLL cnt = Graham();\n\t\t//cout << cnt;\n\t\tLL ans = (fpow(2, n) - check(cnt) - (1LL + n + (n - 1) * n / 2LL) + mod) % mod;\n\t\tif(cnt > 2)\n\t\t\tprintf(\"%lld\\n\", ans);\n\t\telse printf(\"0\\n\");\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n \nusing namespace std;\n \nconst long long p=998244353ll;\nlong long b[201],ans;\nint n,x[201],y[201];\n \nint main(){\n    scanf(\"%d\",&n);for(int i=1;i<=n;++i)scanf(\"%d%d\",x+i,y+i);\n    for(int i=b[0]=1;i<=n;++i)b[i]=b[i-1]*2ll%p;\n    ans=b[n]-(n*(n+1ll)>>1)%p-1ll;\n    for(int i=1;i<=n;++i){\n        for(int j=i+1;j<=n;++j){\n            int cnt=0ll;\n            for(int k=j+1;k<=n;++k)cnt+=(x[j]-x[i])*(y[k]-y[j])==(x[k]-x[j])*(y[j]-y[i]);\n            (ans-=b[cnt]-1ll)%=p;\n        }\n    }\n    printf(\"%lld\",ans<0ll?ans+p:ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n \nconst double EPS = 1e-12;\ntypedef complex<long double> P;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n \nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n \nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<L>se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\tL l(v[i],v[j]);\n\t\tint n=0;\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectSP(l,v[k]))n++;\n\t\tr=(r-pow_binary_mod(2,n,M))%M;\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nconst ll mod=998244353;\nconst int N=1005;\nint n,x[N],y[N];\n\nll fpow(ll a,ll p){\n\tll res=1;\n\twhile(p){\n\t\tif(p&1) res=res*a%mod;\n\t\ta=a*a%mod;\n\t\tp>>=1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;++i)\n\t\tcin>>x[i]>>y[i];\n\tll res=fpow(2,n);\n\tres=(res-1+mod)%mod;\n\tres=(res-n+mod)%mod;\n\tres=(res-n*(n-1)/2+mod)%mod;\n\tfor(int i=0;i<n;++i)\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tint a=y[j]-y[i];\n\t\t\tint b=x[i]-x[j];\n\t\t\tint c=-a*x[i]-b*y[i];\n\t\t\tll cnt=2;\n\t\t\tfor(int k=0;k<n;++k)\n\t\t\t\tif(k!=i&&k!=j){\n\t\t\t\t\tint t=a*x[k]+b*y[k]+c;\n\t\t\t\t\tif(t!=0) continue;\n\t\t\t\t\tif(k<j) break;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\tcnt%=mod;\n\t\t\tres=(res-fpow(2,cnt)+mod)%mod;\n\t\t\tres=(res+1)%mod;\n\t\t\tres=(res+cnt)%mod;\n\t\t\tres=(res+cnt*(cnt-1)/2)%mod;\n\t\t}\n\tcout<<res<<'\\n';\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nconst int kN = 200 + 5;\nconst int MOD = 998244353;\nint n;\n\nstruct Point {\n    int x, y;\n\n    Point() {}\n\n    Point(int x, int y): x(x), y(y) {}\n\n    Point operator - (const Point &rhs) const\n    {\n        return Point(x - rhs.x, y - rhs.y);\n    }\n\n    void read()\n    {\n        scanf(\"%d%d\", &x, &y);\n    }\n\n    bool operator < (const Point &rhs) const\n    {\n        return x < rhs.x || x == rhs.x && y < rhs.y;\n    }\n};\n\nint det(const Point &a, const Point &b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nint det(const Point &a, const Point &b, const Point &c)\n{\n    return det(b - a, c - a);\n}\n\nint inverse(int x)\n{\n    return x == 1 ? x : (MOD - MOD / x) * 1ll * inverse(MOD % x) % MOD;\n}\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a < 0) a += MOD;\n    else if (a >= MOD) a -= MOD;\n}\n\ninline int mul(int x)\n{\n    return x;\n}\n\ntemplate<typename... Args>\ninline int mul(int x, Args... args)\n{\n    return x * 1ll * mul(args...) % MOD;\n}\n\nPoint pt[kN];\n\nint pw[kN];\n\nint work()\n{\n    pw[0] = 1;\n    for (int i = 1; i < kN; ++ i)\n        pw[i] = mul(pw[i - 1], 2);\n    int ret = pw[n];\n    add(ret, -1 - n);\n    for (int i = 0; i < n; ++ i) {\n        for (int j = i + 1; j < n; ++ j) {\n            int cnt = 0;\n            for (int k = j + 1; k < n; ++ k)\n                if (det(pt[i], pt[j], pt[k]) == 0)\n                    ++ cnt;\n            add(ret, -pw[cnt]);\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++ i)\n        pt[i].read();\n    printf(\"%d\\n\", work());\n}\n"
  },
  {
    "language": "C++",
    "code": "#if defined(LOCAL)\n#define PROBLEM_NAME \"c\"\nconst double _max_double_error = 1e-9;\n#include \"testutils.h\"\n#define L(x...) debug(x)\n#else\n#define L(x...) (x)\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ii = pair<int,int>; using vii = vector<ii>;\nusing l = long long; using vl = vector<l>; using vvl = vector<vl>;\nusing ll = pair<l,l>; using vll = vector<ll>; using vvll = vector<vll>;\nusing lu = unsigned long long;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vd = vector<double>; using vvd = vector<vd>;\nusing mll = unordered_map<l, l>;\nconst l INF = numeric_limits<l>::max();\nconst double EPS = 1e-10; static constexpr auto PI = acos(-1);\nconst l e0=1, e3=1000, e5=100000, e6=10*e5, e7=10*e6, e8=10*e7, e9=10*e8;\nconst char lf = '\\n';\n#define all(x) begin(x), end(x)\n#define F(a,b,c) for (l a = l(b); a < l(c); a++)\n#define B(a,b,c) for (l a = l(c) - 1; a >= l(b); a--)\n\nl gcd(l a, l b) {\n  while (b) { l t = b; b = a % b; a = t; }\n  return a;\n}\n\nl lcm(l a, l b) { return a * b / gcd(a, b); }\nl sign(l n) {\n  if (n < 0) return -1;\n  if (n == 0) return 0;\n  return 1;\n}\n\n// conruent modulo, works for negative\nl cong(l x, l mod) {\n  return (x % mod + mod) % mod;\n}\n\n// (a * b) % mod, safe for l near max\nl mult_mod(l a, l b, l mod) {\n  l x = 0;\n  while (b) {\n    if (b % 2) x = (x + a) % mod;\n    a = (a * 2) % mod;\n    b /= 2;\n  }\n  return x;\n}\n\n// (base^power) % mod, safe for l near max\nl pow_mod(l base, l power, l mod) {\n  l r = 1;\n  while (power) {\n    if (power % 2) r = mult_mod(r, base, mod);\n    base = mult_mod(base, base, mod);\n    power /= 2;\n  }\n  return r;\n}\n\nl divup(l a, l b) { // ceil div\n  return (a + b - 1) / b;\n}\n\n// return gcd(a, b) and set x, y: a * x + b * y = gcd(a, b)\nl extended_euclid(l a, l b, l& x, l& y) {\n  if (b == 0) { x = 1; y = 0; return a; }\n  l d = extended_euclid(b, a % b, x, y);\n  l t = y;\n  y = x - (a / b) * y;\n  x = t;\n  return d;\n}\n\n// return b: a * b = 1 (mod n)\nl inverse_mod(l a, l n) {\n  l x, y;\n  l d = extended_euclid(a, n, x, y);\n  if (d != 1) return 0;\n  return cong(x, n);\n}\n\n// single combintions k from n\nl nCr(l n, l k, l mod) {\n  l a = 1;\n  for (l i = n; i > n - k; i--) a = mult_mod(a, i, mod);\n  l b = 1;\n  F(i, 1, k + 1) b = mult_mod(b, i, mod);\n  b = inverse_mod(b, mod);\n  return mult_mod(a, b, mod);\n}\n\n// precompute all combinations up to (n n)\nvvl combinations(l n, l mod) {\n  vvl c(n + 1, vl(n + 1));\n  F(i, 0, n) {\n    c[i][0] = 1;\n    F(j, 1, i + 1) {\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n    }\n  }\n  return c;\n}\n// a / b\nstruct Rat {\n  l a, b;\n  bool operator < (Rat const& rhs) const {\n    if (rhs.b * a == 0 and rhs.a * b == 0) {\n      if (a == 0) return b < rhs.b;\n      return a < rhs.a;\n    }\n    return a * rhs.b < rhs.a * b;\n  }\n\n  void set(l na, l nb) {\n    a = na; b = nb;\n    normalize();\n  }\n\n  void set(l na) {\n    set(na, 1);\n  }\n\n  void normalize() {\n    if (b < 0 and a != 0) {\n      a = -a;\n      b = -b;\n    }\n    l g = gcd(abs(a), abs(b));\n    assert(g);\n    a /= g;\n    b /= g;\n    if (b == 0) a = sign(a);\n    if (a == 0) b = sign(b);\n  }\n};\n\nostream& operator << (ostream& s, const Rat& p) {\n  s << p.a << \" / \" << p.b;\n  return s;\n}\n\nstruct Line {\n  Rat x0, d;\n\n  bool operator < (Line const& rhs) const {\n    if (x0 < rhs.x0) return true;\n    if (rhs.x0 < x0) return false;\n    return d < rhs.d;\n  }\n};\n\nl const MOD = 998244353;\n\n\n\n\nl set2(l n) {\n  return cong(pow_mod(2, n, MOD) - n - 1, MOD);\n}\n\nvoid solve(istream& cin, ostream& cout) {\n  l n; cin >> n;\n  vl x(n), y(n);\n  F(i, 0, n) cin >> x[i] >> y[i];\n  map<Line, l> m;\n  F(i, 0, n) F(j, i + 1, n) {\n    Line q;\n    q.d.set(y[j] - y[i], x[j] - x[i]);\n    if (q.d.b == 0) q.d.a = 1;\n    if (y[i] == y[j]) {\n      q.x0.set(y[i]);\n      q.d.set(-1, 0);\n    } else {\n      q.x0.set(x[i] * (y[j] - y[i]) - y[i] * (x[j] - x[i]), y[j] - y[i]);\n    }\n    // cerr << q.x0 << ' ' << q.d << endl;\n    m[q]++;\n  }\n  l answer = set2(n);\n  for (auto p : m) {\n    l t = p.second;\n    t = round(sqrt(8 * t + 1) + 1) / 2;\n    // cerr << p.second << ' ' << t << endl;\n    answer = cong(answer - set2(t), MOD);\n  }\n  cout << answer << lf;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout << fixed << setprecision(15);\n#if defined(LOCAL)\n  // _generate_random_test = generate_random;\n  // _solve_brute = solve_brute;\n  // _player_b = player_b;\n  // _custom_solution_checker = solution_checker;\n  maybe_run_tests(cin, cout);\n#else\n  solve(cin, cout);\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define pb push_back\n#define ppp pop_back\n#define pii pair<int, int>\n#define fi first\n#define se second\n\ntypedef complex<int> point;\n#define x real\n#define y imag\n\nconst ll p = 998244353;\nconst int N = 205;\n\nset<vector<int>> lines;\npoint a[N];\n\nint cross(point a, point b) {\n\treturn (conj(a) * b).y();\n}\n\nll add(ll a, ll b) {\n\ta += b;\n\tif (a >= p) a -= p;\n\tif (a < 0) a += p;\n\treturn a;\n}\n\nll binpow(ll a, ll b) {\n\tll res = 1;\n\twhile (b) {\n\t\tif (b & 1) res = res * a % p;\n\t\ta = a * a % p;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n;\n\tcin >> n;\n\tfor (int i=1; i<=n; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\ta[i] = {x, y};\n\t}\n\tll ans = add(binpow(2, n), add(-n, -1));\n\tfor (int i=1; i<=n; i++) {\n\t\tfor (int j=i+1; j<=n; j++) {\n\t\t\tvector<int> line;\n\t\t\tfor (int k=1; k<=n; k++) {\n\t\t\t\tif (cross(a[i] - a[k], a[j] - a[k]) == 0) line.pb(k);\n\t\t\t}\n\t\t\tif (lines.count(line)) continue;\n\t\t\tlines.insert(line);\n\t\t\tint k = line.size();\n\t\t\tans = add(ans, -add(binpow(2, k), add(-k, -1)));\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int N = 211;\nconst int mod = 998244353;\nint n;\nLL base[N];\nstruct ddd{\n    int x, y;\n}nd[N];\nLL sq(LL x){return x * x;}\nbool check(LL x1, LL y1, LL x2, LL y2){\n    LL a = x1 * x2 + y1 * y2;\n    LL b = (sq(x1) + sq(y1)) * (sq(x2) + sq(y2));\n    return a > 0 && b == sq(a);\n}\nint main(){\n    cin>>n;\n    for(int i = 1;i <= n; i++){\n        scanf(\"%d%d\", &nd[i].x, &nd[i].y);\n    }\n    base[0] = 1;\n    for(int i = 1;i <= 200; i++)base[i] = base[i-1] * 2 % mod;\n    LL ans = (base[n] - 1 - n + mod) % mod;\n    for(int i = 2;i <= n; i++){\n        for(int j = 1;j < i; j++){\n            int tot = 0;\n            for(int k = 1;k <= n; k++){\n                if(i == k || j == k)continue;\n                if(check(nd[i].x - nd[k].x, nd[i].y - nd[k].y, nd[k].x - nd[j].x, nd[k].y - nd[j].y))tot++;\n            }\n            ans = (ans + mod - base[tot]) % mod;\n            //printf(\"i=%d j=%d tot=%d\\n\", i, j, tot);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = 998244353;\nint n;\nconst int maxN = 202;\nint x[maxN], y[maxN];\nll pw2[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    pw2[0] = 1;\n    for (int i = 1; i <= n; i++) pw2[i] = (2LL * pw2[i - 1]) % mod;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i] >> y[i];\n    }\n    ll tot = pw2[n];\n    tot -= 1;\n    tot -= n;\n    map < vector < ll >, int > mp;\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            ll f1 = y[j] - y[i];\n            ll f2 = x[i] - x[j];\n            ll c = -f1 * x[i] - f2 * y[i];\n            ll d = __gcd(abs(f1), abs(f2));\n            f1 /= d;\n            f2 /= d;\n            c /= d;\n            if (f1 < 0 || (f1 == 0 && f2 < 0)) {\n                f1 *= -1;\n                f2 *= -1;\n                c *= -1;\n            }\n            mp[{f1, f2, c}]++;\n        }\n    }\n    for (auto it : mp) {\n        int f = (sqrt((8 * it.second + 1)) + 1) / 2;\n        tot -= (pw2[f] - f - 1);\n    }\n    tot %= mod;\n    if (tot < 0) tot += mod;\n    cout << tot;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define SORT(c) sort((c).begin(), (c).end())\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> V;\ntypedef map<int, int> M;\n\nconstexpr ll INF = 1e18;\nconstexpr ll MOD = 998244353;\nconstexpr double PI = 3.14159265358979323846;\nconstexpr int di[] = {0, 0, 1, -1};\nconstexpr int dj[] = {1, -1, 0, 0};\n\nll fastPow(ll x, ll n)\n{\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return fastPow(x * x % MOD, n / 2);\n    else\n        return x * fastPow(x, n - 1) % MOD;\n}\n\nll fac[112346];\nvoid combInit(int mx)\n{\n    fac[0] = 0;\n    fac[1] = 1;\n    for (int i = 2; i <= mx; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n}\n\nll modDiv(ll a, ll b)\n{\n    return a * fastPow(b, MOD - 2) % MOD;\n}\n\nll comb(ll a, ll b)\n{\n    if (b == 0)\n        return 1;\n    if (a < b)\n        return 0;\n    if (a <= 0 || b < 0)\n        return 0;\n    if (a == b)\n        return 1;\n\n    ll p, c;\n\n    c = modDiv(fac[a], fac[a - b]);\n    p = fac[b];\n\n    ll res = modDiv(c, p);\n\n    return res;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    combInit(210);\n\n    int n, x[210], y[210];\n\n    ll li[210];\n    fill(li, li + n + 1, 0);\n\n    cin >> n;\n    REP(i, n)\n    cin >> x[i] >> y[i];\n\n    ll res = 0;\n\n    bool used[210][210];\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            used[i][j] = i == j;\n\n    V l;\n\n    for (int i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++)\n        {\n            if (used[i][j])\n                continue;\n\n            V v;\n\n            v.push_back(i);\n            v.push_back(j);\n\n            int cnt = 2;\n            for (int k = j + 1; k < n; k++)\n            {\n                int a = (x[j] - x[i]) * (y[k] - y[j]);\n                int b = (y[j] - y[i]) * (x[k] - x[j]);\n\n                if (a == b)\n                {\n                    cnt++;\n\n                    v.push_back(k);\n                }\n            }\n\n            if (cnt > 2)\n            {\n                for (int k = 0; k < v.size(); k++)\n                    for (int m = 0; m < v.size(); m++)\n                        used[v[k]][v[m]] = true;\n\n                l.push_back(cnt);\n            }\n        }\n\n    res = fastPow(2, n);\n\n    res -= 1;\n    res -= n;\n    res -= n * (n - 1) / 2;\n\n    for (int i = 3; i <= n; i++)\n    {\n        ll tmp = 0;\n\n        for (int j : l)\n        {\n            if (i > j)\n                continue;\n            tmp += comb(j, i);\n            tmp %= MOD;\n        }\n\n        res += MOD - tmp;\n        res %= MOD;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) > norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[m][m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 205\n#define mod 998244353\nint x[maxn],y[maxn];\nint pow(int a,int n)\n{\n    if(n==0)return 1;\n    int res=pow(a,n/2);\n    res=res*res%mod;\n    if(n&1)res=res*a%mod;\n    return res;\n}\nint add(int &a,int b)\n{\n    a+=b;\n    if(a>=mod)a%=mod;\n}\nmain()\n{\n    int n;scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n    int ans=pow(2,n);\n    add(ans,mod-1),add(ans,mod-n),add(ans,mod-n*(n-1)/2);\n    for(int i=1;i<n;i++)for(int j=i+1;j<=n;j++)\n    {\n        int cnt=2;\n        int a=-(y[j]-y[i]),b=x[j]-x[i],c=x[j]*y[i]-x[i]*y[j];\n        for(int k=1;k<=n;k++)\n        {\n            if(k==i || k==j)continue;\n            int s=a*x[k]+b*y[k]-c;\n            if(s!=0)continue;\n            if(k<j)break;\n            cnt++;\n        }\n        add(ans,mod-pow(2,cnt));\n        add(ans,1);\n        add(ans,cnt);\n        add(ans,cnt*(cnt-1)/2);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nconst long long P = 998244353;\n\nusing pii = pair<int, int>;\n\nbool f(pii x, pii y, pii z) {\n  int x1 = x.first - y.first;\n  int y1 = x.second - y.second;\n  int x2 = x.first - z.first;\n  int y2 = x.second - z.second;\n  return x1 * y2 - y1 * x2 == 0;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<int, int>> p(n);\n  for (int i = 0; i < n; i++)\n    cin >> p[i].first >> p[i].second;\n  long long pw[222] = {0};\n  pw[0] = 1;\n  for (int i = 0; i < n; i++)\n    pw[i + 1] = (pw[i] * 2) % P;\n  long long ret = pw[n];\n  ret = (ret - n - 1) % P;\n  bool used[222][222] = {0};\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++) {\n      if (used[i][j])\n        continue;\n      vector<int> v;\n      v.push_back(i);\n      v.push_back(j);\n      for (int k = j + 1; k < n; k++) {\n        if (used[i][k] || used[j][k] || !f(p[i], p[j], p[k]))\n          continue;\n        v.push_back(k);\n      }\n      ret = (ret - pw[v.size()] + v.size() + 1 + P) % P;\n      for (int k = 0; k < v.size(); k++)\n        for (int h = k + 1; h < v.size(); h++)\n          used[k][h] = true;\n    }\n  cout << ret << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<functional>\n#include<vector>\n#include<map>\n#include<string>\n#include<set>\n#include<unordered_set>\n#include<math.h>\n#include<stack>\n#define int long long\n#define mod 998244353ll\n#define P pair<int,int>\nusing namespace std;\n\nP a[200];\nsigned main() {\n\tint ans = 1;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = ans * 2 % mod;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t}\n\tans -= n + 1;\n\tans %= mod;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tvector<int>V;\n\t\t\tif (a[i].first == a[j].first) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].first == a[i].first) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (a[i].second == a[j].second) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].second == a[i].second) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble x = double(a[j].second - a[i].second) / (a[j].first - a[i].first);\n\t\t\t\tdouble y = double(a[i].second) - a[i].first*x;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (abs(a[i].first*x + y - a[i].second) <= 1e-15) {\n\t\t\t\t\t\tV.push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(V.begin(), V.end());\n\t\t\tif (V.size()>=2&&V[0] == i&&V[1]==j) {\n\t\t\t\tint k = 1;\n\t\t\t\tfor (int j : V) {\n\t\t\t\t\tk = k * 2 % mod;\n\t\t\t\t}\n\t\t\t\tk -= V.size(); k--;\n\t\t\t\tans -= k;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tans += mod * 5;\n\tans %= mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M = 1e9 + 7;\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    int ans = 0;\n    for (int i = 0; i + 1 < n; ++i) {\n        if (a[i] == i + 1) {\n            swap(a[i], a[i + 1]);\n            ++ans;\n        }\n    }\n    if (a[n - 1] == n) {\n        ++ans;\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nstruct point{\n\tint x , y;\n\tpoint(int _x = 0 , int _y = 0){\n\t\tx = _x;\n\t\ty = _y;\n\t}\n\tpoint operator + (const point &other) const {\n\t\treturn point(x + other.x , y + other.y);\n\t}\n\tpoint operator - (const point &other) const {\n\t\treturn point(x - other.x , y - other.y);\n\t}\n\tbool operator < (const point &other) const {\n\t\tif(x == other.x){\n\t\t\treturn y < other.y;\n\t\t}\n\t\treturn x < other.x;\n\t}\n\tvoid read(){\n\t\tscanf(\"%d %d\" , &x , &y);\n\t}\n};\ninline int dot(point a , point b){\n\treturn a.x * b.x + a.y * b.y;\n}\ninline int cross(point a , point b){\n\treturn a.x * b.y - a.y * b.x;\n}\ninline int orient(point a , point b , point c){//orientation of point c with respect to line from a -> b\n\tint val = cross(b - a , c - a);\n\tif(val > 0){\n\t\treturn 1;//c comes anticlockwise on line from a -> b\n\t}\n\tif(val < 0){\n\t\treturn -1;//c comes clockwise on line from a -> b\n\t}\n\treturn 0;//c is collinear with line from a -> b\n}\nint dist(point a , point b){\n\treturn dot(a - b , a - b);\n}\nconst int N = 205;\nconst int mod = 998244353;\nconst int inv = 499122177;\nint pw2[N];\nint n;\npoint arr[N];\nvector < point > v;\npoint bottom;\nint ans;\nbool cmp(point a , point b){\n\tint tmp = orient(bottom , a , b);\n\tif(tmp == -1){\n\t\treturn 1;\n\t}\n\tif(tmp == 1){\n\t\treturn 0;\n\t}\n\treturn dist(bottom , a) < dist(bottom , b);\n}\nbool inside(point p1 , point p2 , point p3 , point q){\n\tint o1 = orient(p1 , p2 , q);\n\tint o2 = orient(p2 , p3 , q);\n\tint o3 = orient(p3 , p1 , q);\n\treturn (o1 == o2) && (o2 == o3) && (o3 != 0);\n}\nint siz2[N][N][N];\nint siz3[N][N];\nmap < point , int > mp;\nvector < int > indexes;\n//int tot;\nint dp[N][N];\nint solve(int last1 , int last2){\n\tif(dp[last1][last2] != -1){\n\t\treturn dp[last1][last2];\n\t}\n\tint res = !!last1;\n\t/*if(last1){\n\t\tcout << tot << \" \";\n\t}*/\n\tfor(int i = last2 + 1 ; i < v.size() ; ++i){\n\t\tif(orient(v[last1] , v[last2] , v[i]) == -1){\n\t\t\t//tot += siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0);\n\t\t\tres = (res + 1LL * solve(last2 , i) * pw2[siz2[indexes[0]][indexes[last2]][indexes[i]] + siz3[indexes[0]][indexes[i]] + siz3[indexes[last2]][indexes[i]]]) % mod;\n\t\t\t//tot -= siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0);\n\t\t}\n\t}\n\treturn dp[last1][last2] = res;\n}\nvoid solve(int idx){\n\tv.clear();\n\tbottom.x = arr[idx].x;\n\tbottom.y = arr[idx].y;\n\tv.emplace_back(arr[idx]);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tif(arr[i].y > bottom.y){\n\t\t\tv.emplace_back(arr[i]);\n\t\t}\n\t\telse if(arr[i].y == bottom.y && arr[i].x > bottom.x){\n\t\t\tv.emplace_back(arr[i]);\n\t\t}\n\t}\n\tsort(v.begin() + 1 , v.end() , cmp);\n\tindexes.clear();\n\tfor(int i = 0 ; i < v.size() ; ++i){\n\t\tindexes.emplace_back(mp[v[i]]);\n\t}\n\t//cout << v.size() << \"--\\n\";\n\tmemset(dp , -1 , sizeof(dp));\n\tfor(int i = 1 ; i < v.size() ; ++i){\n\t\t//tot = siz3[indexes[0]][indexes[i]];\n\t\tans = (ans + 1LL * solve(0 , i) * pw2[siz3[indexes[0]][indexes[i]]]) % mod;\n\t\t//cout << \"WTF\\n\";\n\t}\n\t//cout << ans << endl;\n}\nvoid pre(){\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tfor(int j = 1 ; j <= n ; ++j){\n\t\t\tif(i == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsiz3[i][j] = 0;\n\t\t\tint qlx = min(arr[i].x , arr[j].x);\n\t\t\tint qrx = max(arr[i].x , arr[j].x);\n\t\t\tint qly = min(arr[i].y , arr[j].y);\n\t\t\tint qry = max(arr[i].y , arr[j].y);\n\t\t\tfor(int k = 1 ; k <= n ; ++k){\n\t\t\t\tif(k != i && k != j){\n\t\t\t\t\tif(arr[k].x >= qlx && arr[k].x <= qrx && arr[k].y >= qly && arr[k].y <= qry && orient(arr[i] , arr[k] , arr[j]) == 0){\n\t\t\t\t\t\t++siz3[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tfor(int j = i + 1 ; j <= n ; ++j){\n\t\t\tfor(int k = j + 1 ; k <= n ; ++k){\n\t\t\t\tint res = 0;\n\t\t\t\tfor(int l = k + 1 ; l <= n ; ++l){\n\t\t\t\t\tres += inside(arr[i] , arr[j] , arr[k] , arr[l]);\n\t\t\t\t}\n\t\t\t\tsiz2[i][j][k] = siz2[i][k][j] = siz2[j][i][k] = siz2[j][k][i] = siz2[k][i][j] = siz2[k][j][i] = res;\n\t\t\t}\n\t\t}\n\t}\n\tmp.clear();\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tmp[arr[i]] = i;\n\t}\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tarr[i].read();\n\t}\n\tans = 0;\n\tpw2[0] = 1;\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tpw2[i] = (2LL * pw2[i - 1]) % mod;\n\t}\n\tpre();\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tsolve(i);\n\t}\n\tprintf(\"%d\\n\" , ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first setprecision\n\n#if MYDEBUG\n#include \"lib/cp_debug.h\"\n#else\n#define DBG(...) ;\n#endif\n\nusing LL = long long;\nconstexpr LL LINF=334ll<<53;\nconstexpr int INF=15<<26;\nconstexpr LL  MOD=998244353;\n\nstruct Problem{\n    int n;\n    vector<LL> x,y,c;\n    vector<vector<LL>> dp;\n    Problem(LL n):n(n),x(n),y(n),c(n+1),dp (n+1,vector<LL>(n+1)){};\n\n    void solve(){\n        dp[0][0]=1;\n        for(LL i=0; i<=n; ++i){\n            dp[0][i]=1;\n            dp[i][0]=1;\n        }\n        for(LL i=1; i<=n; ++i){\n            for(LL j=1; j<=n; ++j){\n                dp[i][j]=(dp[i][j-1]+dp[i-1][j])%MOD;\n            }\n        }\n        //nCk = dp[n-k][k]\n        for(LL i=0; i<n; ++i){\n            cin >> x[i] >> y[i];\n        }\n        vector<LL> sum(n+1);\n        for(int i=3; i<=n; ++i){\n            for(int j=3; j<=i; ++j){\n                sum[i]=(sum[i]+dp[i-j][j])%MOD;\n            }\n        }\n        LL ans =sum[n];\n        for(int i=n; i>0; --i){\n            sum[i]=sum[i]-sum[i-1];\n        }\n        DBG(ans)\n        for(int i=0; i<n; ++i){\n            vector<LL> used(n);\n            for(int j=i+1; j<n; ++j){\n                if(used[j])continue;\n                LL tmp =0;\n                for(int k=j+1; k<n; ++k){\n                    bool f =false;\n                    if(x[i]==x[j] and x[i] == x[k])f=true;\n                    else if(y[i]==y[j] and y[i] == y[k])f=true;\n                    else if((x[k]-x[i])*(y[k]-y[j])==(x[k]-x[j])*(y[k]-y[i])) f=true;\n                    DBG(i,j,k,f)\n                    if(f){\n                        used[k]=1;\n                        tmp++;\n                    }\n                }\n                DBG(tmp)\n                ans = (ans-sum[tmp+2]+MOD)%MOD;\n                DBG(ans)\n            }\n        }\n        cout << (ans+MOD)%MOD <<endl;\n    }\n\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    long long n=0;\n    cin >> n;\n    Problem p(n);\n    p.solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: CNYALI_LK\nLANG: C++\nPROG: E.cpp\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconst double eps=1e-8;\nconst double PI=acos(-1.0);\ntypedef long long ll;\ntemplate<class T>void chkmin(T &a,T b){a=a<b?a:b;}\ntemplate<class T>void chkmax(T &a,T b){a=a>b?a:b;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\n#define min mmin\n#define max mmax\n#define abs aabs\nconst ll mod=998244353;\nll p[233];\nstruct zb{\n\tll x,y;\n};\nzb a[233];\nll cmp(zb a,zb b){return a.x<b.x||a.x==b.x&&a.y<b.y;}\nint main(){\n#ifdef cnyali_lk\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n\tll n,ans;\n\tscanf(\"%lld\",&n);\n\tp[0]=1;\n\tfor(ll i=1;i<=n;++i){p[i]=p[i-1]<<1;if(p[i]>=mod)p[i]-=mod;scanf(\"%lld%lld\",&a[i].x,&a[i].y);}\n\tsort(a+1,a+n+1,cmp);\n\tans=p[n]-n-1;\n\tfor(ll i=1;i<=n;++i)for(ll j=i+1;j<=n;++j){\n\t\tll no=0;\n\t\tfor(ll k=1;k<j;++k)if(k!=i&&(a[j].x-a[i].x)*(a[i].y-a[k].y)==(a[j].y-a[i].y)*(a[i].x-a[k].x)){no=1;break;}\n\t\tif(!no){\n///\t\t\tdebug(\"(%lld,%lld) (%lld,%lld)\",a[i].x,a[i].y,a[j].x,a[j].y);\n\t\t\tll tot=2;\n\t\t\tfor(ll k=j+1;k<=n;++k){\n\t\t\t\tif((a[j].x-a[i].x)*(a[i].y-a[k].y)==(a[j].y-a[i].y)*(a[i].x-a[k].x)){++tot;/*debug(\" (%lld,%lld)\",a[k].x,a[k].y);*/}\n\t\t\t}\n//\t\t\tdebug(\"\\n\");\n\t\t\tans-=p[tot]-tot-1;\n\t\t}\n\t}\t\n\tprintf(\"%lld\\n\",(ans%mod+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// fest\n#include <bits/stdc++.h>\t\n\n#define pb push_back\n#define F first\n#define S second\n#define y1 dasdasfasfas\n#define x1 wqdadfasfasfas\n#define All(c) c.begin(), c.end()\n#define SZ(A) (int((A).size()))\n#define umap unordered_map\n#define __ fflush(stdout)\n#define FILENAME \"\"\n\ntypedef long long ll;\ntypedef long double ld;    \n\nusing namespace std;\n\nvoid FREOPEN() {\n\t#ifdef LOCAL\n\t\tfreopen(\".in\", \"r\", stdin);\n\t\tfreopen(\"1.out\", \"w\", stdout);\n\t#else\n\t\t//freopen(FILENAME\".in\", \"r\", stdin);\n\t\t//freopen(FILENAME\".out\", \"w\", stdout);\n\t#endif\n}\n\ninline double Time() {return (clock() * 1.0) / CLOCKS_PER_SEC; }             \n\nconst int N = 201, inf = 1e9 * 2;\n\nconst ll MOD = 998244353, INF = 1e18;\n\nconst int dx[] = {1, -1, 0, 0, -1, 1, -1, 1};\nconst int dy[] = {0, 0, 1, -1, -1, 1, 1, -1};\n\nstruct Point {\n\tint x, y;\n};\n\nPoint a[N];\nPoint root;\n\nint tri[N][N], dp[N][N];\n\nint on_line[N];\n\nPoint make(int _x, int _y) {\n\tPoint ret;\n\tret.x = _x;\n\tret.y = _y;\n\treturn ret;\n}\n\nPoint vec(Point p1, Point p2) {\n\treturn make(p2.x - p1.x, p2.y - p1.y);\n}\n\nint crossp(Point p1, Point p2) {\n\treturn p1.x * p2.y - p1.y * p2.x; \n} \n\nint dist(Point p1, Point p2) {\n\treturn (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n}\n\nbool canbe(int i, int j) {\n\tif (i == j) return 0;\n\tif (a[i].x > a[j].x) return 0;\n\tif (a[i].x < a[j].x) return 1;\n\tif (a[i].y > a[j].y) return 0;\n\treturn 1;\n}\n\nbool cmp(Point p1, Point p2) {\n\tPoint v1 = vec(root, p1);\n\tPoint v2 = vec(root, p2);\n\tif (crossp(v1, v2) < 0) return 1;\n\tif (crossp(v1, v2) > 0) return 0;\n\tif (dist(root, p1) > dist(root, p2)) return 1;\n\treturn 0;\n}\n\nint power(int x) {\n\tint ret = 1;\n\tint num = 2;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tx--;\n\t\t\tret = (ret * 1ll * num) % MOD;\n\t\t}\n\t\telse {\n\t\t\tx /= 2;\n\t\t\tnum = (num * 1ll * num) % MOD;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid add(int &x, int y) {\n\tx += y;\n\twhile (x >= MOD) x -= MOD;\n}\n\nvoid out (Point p) {\n\tcerr << \"(\" << p.x << \" \" << p.y << \") \";\n}\n\nint main() {\n\tFREOPEN();\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _x, _y;\n\t\tscanf(\"%d %d\", &_x, &_y);\n\t\ta[i] = make(_x, _y);\n\t}\n\tint ans = 0;\n\tfor (int start = 1; start <= n; start++) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(tri, 0, sizeof(tri));\n\t\tmemset(on_line, 0, sizeof(on_line));\n\t\troot = a[start];\n\t\tvector<Point> ps;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (canbe(start, i)) ps.pb(a[i]); \n\t\t}\n\t\tsort(All(ps), cmp);\n\t\tint m = SZ(ps);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tfor (int k = i + 1; k < m; k++) {\n\t\t\t\t\tif (j == k) continue;\n\t\t\t\t\tif (crossp(vec(root, ps[j]), vec(root, ps[k])) < 0) break;\n\t\t\t\t\tif (crossp(vec(ps[i], ps[j]), vec(ps[i], ps[k])) <= 0) tri[i][j]++;\n\t\t\t\t}\n\t\t\t\tif (crossp(vec(root, ps[i]), vec(root, ps[j])) == 0) on_line[i]++;\n\t\t\t\t//out(root), out(ps[i]), out(ps[j]), cerr << tri[i][j] << endl;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tassert(crossp(vec(root, ps[i]), vec(root, ps[j])) <= 0);\n\t\t\t\tif (crossp(vec(root, ps[i]), vec(root, ps[j])) == 0) continue;\n\t\t\t\tdp[i][j] += power(tri[i][j]);\n\t\t\t\tfor (int k = j + 1; k < m; k++) {\n\t\t\t\t\tif (crossp(vec(ps[i], ps[j]), vec(ps[i], ps[k])) >= 0) continue;\n\t\t\t\t\tif (crossp(vec(root, ps[j]), vec(root, ps[k])) >= 0) continue;\n\t\t\t\t\t//cerr << j << \" \" << k << \" \" << tri[j][k] << endl;\n\t\t\t\t\tadd(dp[j][k], (power(tri[j][k] - on_line[j]) * 1ll * dp[i][j]) % MOD);\n\t\t\t\t}\n\t\t\t\tadd(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\t//cerr << ans << endl;\n\t}\n\tprintf(\"%d \", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// EPS\nconstexpr double EPS = 1e-9;\n/// --- Geometory Library {{{ ///\nusing Point = complex<double>;\n#define X real()\n#define Y imag()\n#define dot(a, b) real(conj(a)*b)\n#define cross(a, b) imag(conj(a)*b)\n#define norm abs\n\n// +1 : ccw\n// -1 : cw\n// +2 : a--b--c\n// -2 : b--c--a\n//  0 : b--a--c\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if(cross(b, c) > EPS) return +1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b, c) < 0) return 0;\n  if(norm(b) < norm(c)) return +2;\n  return -2;\n}\n\ndouble arg(Point a, Point b) {\n  return acos(dot(a, b) / norm(a) / norm(b));\n}\n/// ---}}} ///\n\nconstexpr ll mod = 998244353;\n\n/// --- modulo Library {{{ ///\nconstexpr ll extgcd(ll a, ll b, ll& x, ll& y) {\n  if(b==0) {\n    x = 1; y = 0;\n    return a;\n  }\n  ll d = extgcd(b, a % b, y, x);\n  y -= (a / b) * x;\n  return d;\n}\nconstexpr ll modpow(ll a, ll b, ll mod = 1e9 + 7) {\n  a = (a % mod + mod) % mod;\n  ll r = 1;\n  while(b){\n    if(b & 1) r = r * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return r;\n}\nconstexpr ll modinv(ll a, ll mod = 1e9 + 7) {\n  a = (a % mod + mod) % mod;\n  ll x = 0, y = 0;\n  extgcd(a, mod, x, y);\n  return (x % mod + mod) % mod;\n}\ntemplate<int N, int mod = 1e9 + 7> struct Factorial {\n  int arr[N+1], inv[N+1];\n  int operator[](int i) const { return arr[i]; }\n  constexpr Factorial(): arr(), inv() {\n    arr[0] = 1;\n    for(int i = 1; i <= N; i++) {\n      arr[i] = (ll) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N], mod);\n    for(int i = N-1; i >= 0; i--) {\n      inv[i] = (ll) (i + 1) * inv[i + 1] % mod;\n    }\n  }\n  int C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    return (ll) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n};\n/// }}}--- ///\n\nconstexpr Factorial<200, mod> fact;\n\nbool done[200][200];\n\n// 点集合のうち,(同一直線上の点のみを選ぶ)を覗いた集合の数とスコアが一致\n// O(N^3)\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n; cin >> n;\n  vector<Point> p(n);\n  for(int i = 0; i < n; i++) {\n    int x, y; cin >> x >> y;\n    p[i] = Point(x, y);\n  }\n\n  ll ans = modpow(2, n, mod) - fact.C(n, 2) - n - 1;\n  ans %= mod;\n  for(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++) {\n    if(done[i][j]) continue;\n    int cnt = 2;\n    for(int k = j + 1; k < n; k++) {\n      if(abs(ccw(p[i], p[j], p[k])) != 1) cnt++, done[i][k] = done[j][k] = 1;\n    }\n    ans -= modpow(2, cnt, mod) - fact.C(cnt, 2) - cnt - 1;\n    ans %= mod;\n  }\n  cout << (ans % mod + mod) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nconst int g = 998244353;\n\nint main() {\n    int n, x[200], y[200], p[201];\n    cin >> n;\n    p[0] = 1;\n    for(int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n        p[i+1] = p[i] * 2 % g;\n    }\n    int a = p[n];\n    for(int i = 0; i < n; i++) {\n        for(int j = i + 1; j < n; j++) {\n            int d = 0;\n            for(int k = j + 1; k - n; k++) {\n                d += (x[j] - x[i]) * (y[k] - y[i]) == (x[k] - x[i]) * (y[j] - y[i]);\n            }\n            a = (a + g - p[d]) % g;\n        }\n    }\n    cout << (a + g - 1 - n) % g << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 205;\nconst int mod = 998244353;\n\nint n, res = 1;\nint x[N], y[N];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i] >> y[i]; res = 2 * res % mod; \n\t}\n\tres = (res - 1 + mod) % mod;\n\tres = (res - n + mod) % mod;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tint sub = 1;\n\t\t\tfor (int k = 0; k < j; ++k) {\n\t\t\t\tif ((y[j] - y[i]) * (x[k] - x[j]) == (x[j] - x[i]) * (y[k] - y[j])) sub = 2 * sub % mod;\n\t\t\t}\n\t\t\tres = (res - sub + mod) % mod;\n\t\t}\n\t}\n\tcout << res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 210;\nconst LL mod = 998244353;\nint N;\nint x[MC] , y[MC];\nLL sel[MC];\nLL l[MC];\n\nint gcd(int a , int b){\n\treturn b ? gcd(b,a%b) : a;\n}\n\nint main(){\n\tscanf(\"%d\" , &N);\n\trepp(i,0,N){\n\t\tscanf(\"%d%d\" , x + i , y + i);\n\t}\n\tsel[3] = 8;\n\trepp(i,4,MC){\n\t\tsel[i] = sel[i-1] * 2 % mod;\n\t\t(sel[i-1] += mod - i - (i-1) * (i-2) / 2) %= mod;\n\t}\n\tLL ans = sel[N];\n\trepp(i,0,N){\n\t\tmap<P2,int> M;\n\t\trepp(j,0,N){\n\t\t\tif(i==j) continue;\n\t\t\tint dx = x[j] - x[i];\n\t\t\tint dy = y[j] - y[i];\n\t\t\tif(dx < 0){\n\t\t\t\tdx *= -1;\n\t\t\t\tdy *= -1;\n\t\t\t}\n\t\t\tif(dx == 0) dy = 1;\n\t\t\telse if(dy == 0) dx = 1;\n\t\t\telse {\n\t\t\t\tint g = gcd(dx,abs(dy));\n\t\t\t\tdx /= g;\n\t\t\t\tdy /= g;\n\t\t\t}\n\t\t\t++M[MP(dx,dy)];\n\t\t}\n\t\tfor(auto z : M) ++l[z.second + 1];\n\t}\n\trepp(i,3,N+1){\n\t\t(ans += (mod - sel[i]) * (l[i]/i)) %= mod;\n\t}\n\tprintf(\"%lld\\n\" , ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nusing Line = tuple<int, int, int>;\nconst ll MOD = 998244353ll;\n\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n\nll mod_pow(ll x, ll e) {\n  ll v = 1;\n  for (; e > 0; e >>= 1) {\n    if (e & 1) {\n      v = v * x % MOD;\n    }\n    x = x * x % MOD;\n  }\n  return v;\n}\n\nLine getNormalizedLine(int x1, int y1, int x2, int y2) {\n  int a = y2 - y1;\n  int b = x1 - x2;\n  int c = (-a * x1) + (-b * y1);\n  int g = gcd(abs(a), abs(b));\n  a /= g;\n  b /= g;\n  c /= g;\n  if (a < 0) {\n    a = -a;\n    b = -b;\n    c = -c;\n  }\n  if (a == 0 && b < 0) {\n    b = -b;\n    c = -c;\n  }\n  return Line(a, b, c);\n}\n\nint main() {\n  int N;\n  while (cin >> N) {\n    vector<int> x(N), y(N);\n    for (int i = 0; i < N; i++) {\n      cin >> x[i] >> y[i];\n    }\n    map<Line, set<int>> linePoints;\n    for (int i = 0; i < N; i++) {\n      for (int j = i + 1; j < N; j++) {\n        Line line = getNormalizedLine(x[i], y[i], x[j], y[j]);\n        linePoints[line].insert(i);\n        linePoints[line].insert(j);\n      }\n    }\n    ll ans = mod_pow(2, N);\n    ans = (ans - 1 + MOD) % MOD;\n    ans = (ans - N + MOD) % MOD;\n    for (auto& entry : linePoints) {\n      int k = entry.second.size();\n      ll ng = (mod_pow(2, k) - k - 1 + MOD) % MOD;\n      ans = (ans - ng + MOD) % MOD;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\nconstexpr int MOD = 1000000007;\n\ntypedef std::pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nauto fraclt = [](const pii&a,const pii&b) { return (ll)a.x * b.y < (ll)b.x * a.y; };\nstruct cmpfrac { bool operator()(const pii&a,const pii&b)const { return (ll)a.x * b.y < (ll)b.x * a.y; }};\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) {ui b=0;while(x){x>>=1;++b;}return b;}\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector<vector<T>>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector<vector<T>>>(a,vector<vector<T>>(b,vector<T>(c,t))){}};\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { B = 0; for (auto &a: A) a = queue<T>(); }\nprivate:\n\tvector<queue<T>> A; ui B;\n};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if ((ll)v+o.v >= N) v = (ll)v+o.v-N; else v = v+o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v = N-o.v+v; else v=v-o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\tstatic int div(int p, int q, int N) {\n\t\tll t=0,nt=1,r=N,nr=q;\n\t\twhile(nr){ ll q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r) { return 0; }\n\t\treturn (int)(((ll)t*(ll)p/r)%N);\n\t}\n};\n#endif\n\n\nll ccw(const pii&a, const pii&b, const pii&c) { return (ll)(b.x-a.x)*(c.y-a.y) - (ll)(b.y-a.y)*(c.x-a.x); }\nll area(const pii&a,const pii&b,const pii&c) { return abs(ccw(a,b,c)); }\n\n\ntypedef Field<998244353> F;\n\nclass E {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector<pii> P(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> P[i].x >> P[i].y;\n        }\n\n        F ans = F(2).pow(N) - F(N) - F(1) - F(N)*F(N-1)/2;\n        for (int i = 0; i < N; ++i) {\n            for (int j = i+1; j < N; ++j) {\n                int totCol = 2;\n                for (int k = 0; k < N; ++k) {\n                    if (i == k || k == j ) continue;\n                    if (area(P[i], P[j], P[k]) == 0) {\n                        totCol++;\n                    }\n                }\n\n                if (totCol > 2) {\n                    ans -= (F(2).pow(totCol) - F(totCol) - F(1) - F(totCol)*F(totCol-1)/2)/(F(totCol)*F(totCol-1)/2);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tE solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y;\n\tdata(){}\n\tdata(int xx,int yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn atan2(y,x)<atan2(d.y,d.x);\n\t}\n};\n\nint n;\ndata d[205];\nll two[205];\nbool flag[205][205];\nll res=0;\n\nbool check(int f,int t,int vx,int vy){\n\tint sax=d[t].x-d[f].x;\n\tint say=d[t].y-d[f].y;\n\treturn (sax*vy-say*vx)==0;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\ttwo[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\ttwo[i]=two[i-1]*2LL%MOD;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&d[i].x,&d[i].y);\n\t}\n\tll res=two[n];\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(flag[i][j])continue;\n\t\t\tint vx=d[i].x-d[j].x;\n\t\t\tint vy=d[i].y-d[j].y;\n\t\t\tvector<int> vec;\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(check(j,k,vx,vy)){\n\t\t\t\t\tvec.push_back(k);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres-=two[cnt];\n\t\t\tres+=MOD;\n\t\t\tres%=MOD;\n\t\t\tres+=cnt+1LL;\n\t\t\tres%=MOD;\n\t\t\tfor(int k=0;k<vec.size();k++){\n\t\t\t\tfor(int l=0;l<vec.size();l++){\n\t\t\t\t\tflag[k][l]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres-=(ll)n+1LL;\n\tres+=MOD;\n\tres%=MOD;\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n  return a * (b / gcd(a, b));\n}\n\nstruct pt {\n  ll x, y;\n};\n\npt operator-(const pt &a, const pt &b) {\n  return pt {a.x - b.x, a.y - b.y};\n}\n\nstruct frac {\n  ll num, den;\n};\n\nvoid cancel(frac &a) {\n  ll d = gcd(a.num, a.den);\n  a.num /= d;\n  a.den /= d;\n  if (a.den < 0) {\n    a.num *= -1;\n    a.den *= -1;\n  }\n}\n\nfrac operator*(const frac &a, ll b) {\n  frac res = frac {a.num * b, a.den};\n  cancel(res);\n  return res;\n}\n\nfrac operator-(const frac &a, const frac &b) {\n  ll m = lcm(a.den, b.den);\n  ll f1 = m / a.den;\n  ll f2 = m / b.den;\n  frac res = frac {a.num * f1 - b.num * f2, m};\n  cancel(res);\n  return res;\n}\n\nfrac operator/(const frac &a, const frac &b) {\n  frac res = frac {a.num * b.den, a.den * b.num};\n  cancel(res);\n  return res;\n}\n\nbool operator==(const frac &a, const frac &b) {\n  return a.num == b.num && a.den == b.den;\n}\n\nbool operator!=(const frac &a, const frac &b) {\n  return a.num != b.num || a.den != b.den;\n}\n\nbool operator<(const frac &a, const frac &b) {\n  return (double)a.num / (double)a.den < double(b.num) / (double)b.den;\n}\n\nstruct line {\n  frac a, b, c;\n};\n\nbool operator==(const line &a, const line &b) {\n  return a.a == b.a && a.b == b.b && a.c == b.c;\n}\n\nbool operator<(const line &a, const line &b) {\n  if (a.a != b.a) return a.a < b.a;\n  if (a.b != b.b) return a.b < b.b;\n  return a.c < b.c;\n}\n\nll powers2[201];\n\nll cross(pt a, pt b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nbool collinear(pt a, pt b, pt c) {\n  return !cross(b - a, c - a);\n}\n\nline pointsToLine(pt a, pt b) {\n  line l;\n  if (a.x == b.x) {\n    l.a = frac {1, 1};    \n    l.b = frac {0, 1};\n    l.c = frac {-a.x, 1};\n  } else {\n    l.a = frac {-a.y - b.y, 1} / frac {a.x - b.x, 1};\n    l.b = frac {1, 0};\n    l.c = (l.a * -a.x) - frac{a.y, 1};\n  }\n  return l;\n}\n\nint main() {\n  powers2[0] = 1;\n  for (int i = 1; i <= 200; i++) powers2[i] = powers2[i - 1] * 2LL % MOD;\n\n  ll sum = 0;\n  map<ll, int> invTri;\n  for (int i = 1; i <= 200; i++) {\n    sum += i;\n    invTri[sum] = i;\n  }\n\n  int n;\n  scanf(\"%d\", &n);\n  vector<pt> points(n);\n  for (int i = 0; i < n; i++) scanf(\"%lld %lld\", &points[i].x, &points[i].y);\n  \n  map<line, int> counter;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      line l = pointsToLine(points[i], points[j]);\n      counter[l]++;\n    }\n  }\n  ll res = powers2[n];\n  for (auto c : counter) {\n    int points = invTri[c.second] + 1;\n    res += MOD - powers2[points] + points + 1;\n    res %= MOD; \n  }\n  res += MOD - 1 - n;\n  res %= MOD;\n  printf(\"%lld\\n\", (res % MOD + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int maxn=200+2;\nconst int mod=998244353;\nint n;\nstruct Point{\n\tint x,y;\n};\nPoint p[maxn];\nint _2[maxn];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d%d\",&p[i].x,&p[i].y);\n\t_2[0]=1;\n\tfor (int i=1;i<maxn;i++) _2[i]=(1LL*_2[i-1]*2)%mod;\n\tint ans=(_2[n]-n-1+mod)%mod;\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tint tmp=1;\n\t\t\tfor (int k=j+1;k<=n;k++)\n\t\t\t\tif ((p[j].x-p[i].x)*(p[k].y-p[i].y)==(p[k].x-p[i].x)*(p[j].y-p[i].y)) tmp=(tmp<<1)%mod;\n\t\t\tans=(ans-tmp+mod)%mod;\n\t\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int md=998244353;\nint n,ans,x[205],y[205],pw[205],cc[205];\nint main()\n{\n\tpw[0]=1;\n\tfor(int i=1;i<205;i++)pw[i]=pw[i-1]*2%md;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n\tans=(pw[n]+md-n-1)%md;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int k=1;k<=n;k++)if((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))cnt++;\n\t\t\tcc[cnt]++;\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)cc[i]=cc[i]*2/i/(i-1);\n\tfor(int i=2;i<=n;i++)ans=(ans+md-1ll*cc[i]*(pw[i]+md-i-1))%md;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-15;\nconst int MOD = 998244353;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n  unsigned get() const { return x; }\n\n  // 逆数\n  ModInt inv() const {\n    ll a = 1, p = x, e = MOD-2;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // e乗\n  ModInt pow(ll e) {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // 2のx乗\n  ModInt pow2() {\n    ll a = 1, p = 2, e = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  ModInt &operator+=(ModInt that) {\n    x = ((ll)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((ll)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (ll)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (ll)x * that.inv() % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (ll)x % that.x;\n    return *this;\n  }\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\nP p[205];\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) {\n    double x, y;\n    cin >> x >> y;\n    p[i] = {x, y};\n  }\n\n  mint ret = mint(n).pow2() - n - 1;\n  // 頂点i,jの線分上の点の数を数える\n  REP(i, n) REP(j, n) {\n    if(!(p[i] < p[j])) continue;\n    mint cnt = 0;\n    REP(k, n) {\n      if(!(p[i]<p[k]) || !(p[k]<p[j])) continue;\n      // 頂点kが線分上に存在する\n      if(cross(p[k]-p[i], p[j]-p[i]) == 0) {\n        ++cnt;\n      }\n    }\n    ret -= cnt.pow2();\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long n, x[209], y[209], power[209], mod = 998244353; vector<pair<long double, long double>> vec;\n\nlong long calc(long long n) {\n\treturn (power[n] - (n*(n - 1) / 2) - n - 1 + mod) % mod;\n}\n\nint main() {\n\tcin >> n;\n\tpower[0] = 1; for (int i = 1; i <= 208; i++) power[i] = (power[i - 1] * 2) % mod;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint X = (x[j] - x[i]), Y = (y[j] - y[i]);\n\t\t\tif (X == 0) { vec.push_back(make_pair(1.0L*x[j], 100000.0L)); }\n\t\t\telse {\n\t\t\t\tlong double D = 1.0L*Y / X;\n\t\t\t\tlong double E = 1.0L*y[i] - D*x[i];\n\t\t\t\tvec.push_back(make_pair(E, D));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\tint cx = 0; long long U = 0;\n\twhile (cx < vec.size()) {\n\t\tint pos1 = upper_bound(vec.begin(), vec.end(), vec[cx]) - vec.begin();\n\t\tint V = pos1 - cx, VV = 0;\n\t\tfor (int i = 2; i <= 200; i++) {\n\t\t\tif (V == i*(i - 1) / 2)VV = i;\n\t\t}\n\t\tU += calc(VV); U += mod; U %= mod;\n\t\tcx = pos1;\n\t}\n\tlong long ans = calc(n);\n\tans = (ans - U + mod) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint mod = 998244353;\nint n;\nint x[200], y[200];\nint power2[201];\n\nP getPair(int pa, int pb) {\n\tint i;\n\tint tx = x[pb] - x[pa];\n\tint ty = y[pb] - y[pa];\n\tint minRet = n;\n\tint maxRet = -1;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tint dx = x[i] - x[pa];\n\t\tint dy = y[i] - y[pa];\n\t\tif (tx * dy - ty * dx != 0) continue;\n\t\tmaxRet = max(maxRet, i);\n\t\tminRet = min(minRet, i);\n\t}\n\treturn P(minRet, maxRet);\n}\n\nint getCount(int pa, int pb) {\n\tint i;\n\tint tx = x[pb] - x[pa];\n\tint ty = y[pb] - y[pa];\n\tint ret = 0;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tint dx = x[i] - x[pa];\n\t\tint dy = y[i] - y[pa];\n\t\tif (tx * dy - ty * dx != 0) continue;\n\t\tret++;\n\t}\n\treturn ret;\n}\n\nint count_line() {\n\tint i, j;\n\tvector<P> lines;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tlines.push_back(getPair(i, j));\n\t\t}\n\t}\n\tsort(lines.begin(), lines.end());\n\tlines.erase(unique(lines.begin(), lines.end()), lines.end());\n\t\n\tint ret = 0;\n\tfor (i = 0; i < lines.size(); i++) {\n\t\tint k = getCount(lines[i].first, lines[i].second);\n\t\tret += power2[k] - k - 1;\n\t\tret %= mod;\n\t}\n\tret += n + 1;\n\treturn ret;\n}\n\nint main() {\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) cin >> x[i] >> y[i];\n\t\n\tpower2[0] = 1;\n\tfor (i = 1; i <= n; i++) power2[i] = (power2[i - 1] * 2) % mod;\n\tint k = count_line();\n\tint ans = (power2[n] - k + mod) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n\n//基本方針は全探索を丁寧に見直すこと。\n//U:    {点1,点2,…,点n}\n//f(S): S⊆Uについて, Sが凸なら1, 凸でないなら0.\n//T(S): 凸なS⊆Uについて, Sの境界または内部にある点の集合.\n//E(S): S⊆Uにおけるスコア. (Sが凸としたときのスコア. 非凸ならドントケア)\n//とおくと\n//Ans = Σf(S)E(S)\n//E(S) = 2^(|T(S)| - |S|) = 2^|T(S) - S| = |2^(T(S) - S)| = |S・2^(T(S) - S)|\n//が成り立つ.\n//S・2^(T(S) - S)は, {∀u : S ⊆ u ⊆ T(S)}で表せる.\n//\n//ここで, g(S) = {S'| S'⊆U, f(S') = 1, S' ⊆ S ⊆ T(S')}とおく。\n//すると, Σ|g(S)|が答えになる。(ループの順番を変えただけ）\n//\n//任意のSについて, Sの凸法(多角形)をP(S)とおく. P(S)はSの凸法の境界と内部にある無限個の点の集合である.\n//g(S)を計算する。\n//Sが一直線上 or 空集合のとき … S' ⊆ S, f(S') = 1となるS'は存在しないので, g(S) = 空集合.\n//それ以外のとき …\n//S' ⊆ S ⇒ P(S') ⊆ P(S)\n//S  ⊆ T(S') ⇒ P(S) ⊆ P(T(S'))\n//f(S') = 1 ⇒ P(S') = P(T(S'))\n//より, 条件を満たすS'において, P(S) = P(S')が成り立つ.\n//また, f(S') = 1より, P(S') and U = S'が成り立つ. そのようなS'はP(S')と1対1対応している.\n//実際, S' = {Sの凸法に使われた点の集合}とすれば, P(S) = P(S')が成り立つ.\n//(任意の点集合について凸法が一意に定まること, 凸法の包含の性質を使った）\n//\n//よって, 2^N - |{S|S⊆U,  Sが一直線上 or S=空集合}|が答えになる。直線の候補はnC2通りあるので, それらを列挙して, 重複除去をして,\n//各直線に乗っている点の数をkとしたときの2^k - k - 1の合計値を求める. それにn + 1を足したものが答え.\n//重複除去は, 直線上の{Min番の点の番号, Max番の点の番号}をペアとして持って, sort→uniqueとすれば、O(n^3)でできる。\n//数え上げパートもO(n^3)なので、この問題はO(n^3)で解けた。\n//\n//E(S)の式変形パートをどうやって思いついたか？：\n//｛N = 4, 非凸, どの3点も1直線上にない｝ケースについて以下の実験をした。\n//・点の部分集合(16パターン)それぞれについて, 凸法を作図して, スコアを書く.\n//あとは, ぐっと睨むと気付いた。\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by maze on 2019-07-21.\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n    using value_type = ::std::uint_fast64_t;\n    value_type n;\npublic:\n    ModInt() : n(0) {}\n    ModInt(value_type n_) : n(n_ % mod) {}\n    ModInt(const ModInt& m) : n(m.n) {}\n\n    template<typename T>\n    explicit operator T() const { return static_cast<T>(n); }\n    value_type get() const { return n; }\n\n    friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n        return os << a.n;\n    }\n\n    friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n        value_type x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return is;\n    }\n\n    bool operator==(const ModInt& m) const { return n == m.n; }\n    bool operator!=(const ModInt& m) const { return n != m.n; }\n    ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n    ModInt pow(value_type b) const{\n        ModInt ans = 1, m = ModInt(*this);\n        while(b){\n            if(b & 1) ans *= m;\n            m *= m;\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    ModInt inv() const { return (*this).pow(mod-2); }\n    ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n    ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n    ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n    ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n    ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n    ModInt& operator++(){ n += 1; return *this; }\n    ModInt& operator--(){ n -= 1; return *this; }\n    ModInt operator++(int){\n        ModInt old(n);\n        n += 1;\n        return old;\n    }\n    ModInt operator--(int){\n        ModInt old(n);\n        n -= 1;\n        return old;\n    }\n    ModInt operator-() const { return ModInt(mod-n); }\n};\n\nconstexpr int64 mod = 998244353;\nusing Mint = ModInt<mod>;\n\nint main(void) {\n    int64 N;\n    cin >> N;\n    vector<int64> x(N), y(N);\n    REP(i, N) {\n        cin >> x[i] >> y[i];\n    }\n    using T = tuple<int64, int64, int64>;\n    map<T, int64> cnt;\n    Mint res = Mint(2).pow(N);\n    REP(i, N) {\n        FOR(j, i+1, N) {\n            int64 a = y[i]-y[j], b = -(x[i]-x[j]), c = (x[i]*y[j]-x[j]*y[i]);\n            int64 sgn = 1;\n            if (a != 0) sgn *= a / abs(a);\n            if (b != 0) sgn *= b / abs(b);\n            if (c != 0) sgn *= c / abs(c);\n            a *= sgn; b *= sgn; c *= sgn;\n            int64 g = __gcd(abs(a), __gcd(abs(b), abs(c)));\n            a /= g; b /= g; c /= g;\n            if (cnt[T(a, b, c)]) continue;\n            cnt[T(a, b, c)] = 1;\n            int64 sum = 2;\n            FOR(k, j+1, N) {\n                if (a * x[k] + b * y[k] + c == 0) {\n                    sum++;\n                }\n            }\n//            cout << i << \" \" << j << \" \" << a << \" \" << b << \" \" << c << \": \" << sum << endl;\n            res -= Mint(2).pow(sum) - sum - 1;\n        }\n    }\n    cout << res-N-1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 Sayutin Dmitry.\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n#include <iostream>\n#include <vector>\n#include <stdint.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <array>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <string>\n#include <assert.h>\n#include <iterator>\n#include <cstdint>\n#include <cinttypes>\n#include <string.h>\n#include <random>\n#include <numeric>\n#include <tuple>\n\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::min;\nusing std::abs;\nusing std::max;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\n#define pb push_back\n#define eb emplace_back\n\nconst int mod = 998244353;\n\nint mult(int a, int b) {\n    return int64_t(a) * b % mod;\n}\n\nint add(int a, int b) {\n    return (a + b) % mod;\n}\n\nint sub(int a, int b) {\n    return (mod + a - b) % mod;\n}\n\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    // code here.\n    int n = input<int>();\n    vector<pair<int, int>> crd(n);\n\n    for (int i = 0; i != n; ++i)\n        cin >> crd[i].first >> crd[i].second;\n\n    vector<int> pws(n + 1);\n    pws[0] = 1;\n    for (int i = 1; i <= n; ++i)\n        pws[i] = mult(pws[i - 1], 2);\n\n    int ans = sub(pws[n], n + 1);\n\n    vector<vector<char>> mat(n, vector<char>(n));\n\n    auto line = [](pair<int, int> a, pair<int, int> b, pair<int, int> c) {\n        pair<int, int> v = {b.first - a.first, b.second - a.second};\n        pair<int, int> u = {c.first - a.first, c.second - a.second};\n\n        return (v.first * int64_t(u.second) - v.second * int64_t(u.first) == 0);\n    };\n    \n    for (int i = 0; i != n; ++i)\n        for (int j = i + 1; j != n; ++j) {\n            if (mat[i][j])\n                continue;\n            \n            vector<int> lst;\n            for (int k = 0; k != n; ++k)\n                if (line(crd[i], crd[j], crd[k]))\n                    lst.pb(k);\n\n            for (int a: lst)\n                for (int b: lst)\n                    mat[a][b] = 1;\n\n//            cerr << SZ(lst) << \"\\n\";\n            \n            ans = sub(ans, sub(pws[SZ(lst)], SZ(lst) + 1));\n        }\n\n    cout << ans << \"\\n\";\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//HEAD_OF_CONFIG_\n\nstatic const int MOD=998244353;\nstatic const long long MODL=1000000000000000003LL;\nstatic const double eps=1e-8;\n\n//TAIL_OF_CONFIG_\n\n//HEAD_OF_JKI'S_HEADER_\n\n    //TYPEDEF\n    typedef long long lld;\n    typedef unsigned long long u64;\n    typedef pair<int, int> pii;\n\n    //COMPARE\n    template<class T> inline T MIN(const T x, const T y){ return (x<y)?x:y; }\n    template<class T> inline T MAX(const T x, const T y){ return (x>y)?x:y; }\n\n    template<class T> inline void UPDMIN(T &x, const T y){ if(x>y)x=y; }\n    template<class T> inline void UPDMAX(T &x, const T y){ if(x<y)x=y; }\n\n    //STL\n    template<class T>  inline int SIZE(const T &x){ return (int)x.size(); }\n    template<class T>  inline int LENGTH(const T &x){ return (int)x.length(); }\n    template<class T1, class T2> inline pair<T1, T2> MP(const T1 &x, const T2 &y){ return make_pair(x, y); }\n\n    //BIT\n    inline int BINT(const int x){ return 1<<x; }\n    inline lld BLLD(const int x){ return 1LL<<x; }\n    inline int BINT_TEST(const int s, const int x){ return (s&BINT(x))!=0; }\n    inline int BLLD_TEST(const lld s, const int x){ return (s&BLLD(x))!=0LL; }\n\n    template<class T> inline T LOWBIT(const T x){ return (x^(x-1))&x; }\n    template<class T> inline int BITCOUNT(const T x){ return (!x)?x:(1+BITCOUNT(x&(x-1))); }\n\n    //CONST VALUE\n    const double PI=acos(-1.0);\n    const double EPS=1e-5;\n\n    //CALCULATE\n    template<class T> inline T SQR(const T x){ return x*x; }\n    template<class T1, class T2> inline T1 POW(const T1 x, const T2 y){\n        if(!y)return 1;else if((y&1)==0){\n            return SQR(POW(x, y>>1));\n        }else return POW(x, y^1)*x;\n    }\n\n    //NUMBERIC\n    template<class T> inline T GCD(const T x, const T y){\n        if(x<0)return GCD(-x, y);\n        if(y<0)return GCD(x, -y);\n        return (!y)?x:GCD(y, x%y);\n    }\n    template<class T> inline T LCM(const T x, const T y){\n        if(x<0)return LCM(-x, y);\n        if(y<0)return LCM(x, -y);\n        return x*(y/GCD(x, y));\n    }\n    template<class T> inline T EEA(const T a, const T b, T &x, T &y){\n        /* a*x+b*y == GCD(a, b) == EEA(a, b, x, y) */\n        if(a<0){ T d=EEA(-a, b, x, y); x=-x; return d; }\n        if(b<0){ T d=EEA(a, -b, x, y); y=-y; return d; }\n        if(!b){\n            x=1; y=0; return a;\n        }else{\n            T d=EEA(b, a%b, x, y);\n            T t=x; x=y; y=t-(a/b)*y;\n            return d;\n        }\n    }\n    template<class T> inline vector<pair<T, int> > FACTORIZE(T x){\n        vector<pair<T, int> > ret;\n        if(x<0)x=-x;\n        for (T i=2;x>1;){\n            if(x%i==0){\n                int count=0;\n                for(;x%i==0;x/=i)count++;\n                ret.push_back(MP(i, count));\n            }\n            i++;if(i>x/i)i=x;\n        }\n        return ret;\n    }\n    template<class T> inline int ISPRIME(const T x){\n        if(x<=1)return 0;\n        for(T i=2; SQR(i)<=x; i++)if(x%i==0)return 0;\n        return 1;\n    }\n    template<class T> inline T EULARFUNCTION(T x){\n        vector<pair<T, int> > f=FACTORIZE(x);\n        for(typename vector<pair<T, int> >::iterator it=f.begin(); it!=f.end(); it++){\n            x=x/it->first*(it->first-1);\n        }\n        return x;\n    }\n    template<class T> inline T INVERSEE(const T a, const T b=MOD){\n        T x, y;\n        EEA(a, b, x, y);\n        return x?x:1;\n    }\n    int *PRIMELIST(const int til, int *length=NULL){\n        int *foo=(int*)malloc(sizeof(int)*(til+1));\n        int len=0;\n        memset(foo, 0, sizeof(int)*(til+1));\n        for(int i=2; i<=til; i++){\n            if(!foo[i])foo[len++]=i;\n            for(int j=0; j<len && foo[j]<=til/i; j++){\n                foo[foo[j]*i]=1;\n                if(i%foo[j]==0)break;\n            }\n        }\n        if(length!=NULL){\n            *length=len;\n        }\n        foo[len++]=0;\n        foo=(int*)realloc(foo, sizeof(int)*len);\n        return foo;\n    }\n\n    //REMINDER-LIZATION\n    template<class T> inline T MOD_STD(const T x, const T m=MOD){ return (x%m+m)%m; }\n    template<class T> inline void MOD_STD(T *x, const T m=MOD){ *x=(*x%m+m)%m; }\n    template<class T> inline T MOD_ADD(const T x, const T y, const T m=MOD){ return (x+y)%m; }\n    template<class T> inline void MOD_ADD(T *x, const T y, const T m=MOD){ *x=(*x+y)%m; }\n    template<class T> inline T MOD_MUL(const T x, const T y, const T m=MOD){ return (T)((1LL*x*y)%m); }\n    template<class T> inline void MOD_MUL(T *x, const T y, const T m=MOD){ *x=(T)((1LL*(*x)*y)%m); }\n    template<class T1, class T2> inline T1 MOD_POW(const T1 x, const T2 y, const T1 m=MOD){\n        if(y==0)return 1%m;else if((y&1)==0){\n            T1 z=MOD_POW(x, y>>1, m); return MOD_MUL(z, z, m);\n        }else return MOD_MUL(MOD_POW(x, y^1, m), x, m);\n    }\n    inline lld MODL_MUL(lld x, lld y, const lld m=MOD){\n        if(x<y)swap(x, y);\n        lld z=0LL;\n        while(y>0){\n            if(y&1){\n                MOD_ADD(&z, x, m);\n            }\n            MOD_ADD(&x, x, m);\n            y>>=1;\n        }\n        return z;\n    }\n    inline lld MODL_POW(const lld x, const lld y, const lld m=MOD){\n        if(y==0LL)return 1LL%m;else if((y&1)==0LL){\n            lld z=MODL_POW(x, y>>1, m); return MODL_MUL(z, z, m);\n        }else return MODL_MUL(MODL_POW(x, y^1, m), x, m);\n    }\n\n    //MATRIX\n    template<class T> class MATX{\n        private:\n            unsigned long hig, wid;\n            T *data;\n\n            void __init(){\n                this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                memset(this->data, 0, sizeof(T)*this->hig*this->wid);\n            }\n\n        public:\n            MATX(){ \n                this->hig=this->wid=1;\n                __init();\n            }\n            MATX(const unsigned long _len){\n                this->hig=this->wid=_len;\n                __init();\n            }\n            MATX(const unsigned long _hig, const unsigned long _wid){\n                this->hig=_hig;\n                this->wid=_wid;\n                __init();\n            }\n            MATX(const MATX &rhs){\n                this->hig=rhs.hig;\n                this->wid=rhs.wid;\n                this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=rhs.at(x, y);\n            }\n            ~MATX(){\n                free(this->data);\n            }\n\n            T & operator()(const unsigned long x, const unsigned long y){\n                if(x>=this->hig || y>=this->wid)return (*(T*)NULL);\n                return this->data[x*this->wid+y];\n            }\n\n            T * operator[](const unsigned long x){\n                if(x>=this->hig)return (T*)NULL;\n                return this->data+(x*this->wid);\n            }\n\n            MATX & operator=(const MATX &rhs){\n                if(this->hig!=rhs.hig || this->wid!=rhs.wid){\n                    free(this->data);\n                    this->hig=rhs.hig;\n                    this->wid=rhs.wid;\n                    this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                }\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=rhs.at(x, y);\n                return *this;\n            }\n\n            const MATX operator+(const MATX &opn) const{\n                MATX ret(*this);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        ret.data[x*ret.wid+y]+=opn.at(x, y);\n                return ret;\n            }\n            const MATX operator-(const MATX &opn) const{\n                MATX ret(*this);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        ret.data[x*ret.wid+y]-=opn.at(x, y);\n                return ret;\n            }\n            const MATX operator*(const MATX &opn) const{\n                MATX ret(this->hig, opn.wid);\n                const unsigned long len=MIN(this->wid, opn.hig);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        for(unsigned long z=0; z<len; z++)\n                            ret.data[x*ret.wid+y]+=this->at(x, z)*opn.at(z, y);\n                return ret;\n            }\n\n            const MATX mul(const MATX &opn) const{ return *this*opn; }\n            template<class T2> const MATX mul(const MATX &opn, const T2 m) const{\n                MATX ret(this->hig, opn.wid);\n                const unsigned long len=MIN(this->wid, opn.wid);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        for(unsigned long z=0; z<len; z++)\n                            MOD_ADD(&ret.data[x*ret.wid+y], MOD_MUL(this->at(x, z), opn.at(z, y), m), m);\n                return ret;\n            }\n\n            MATX & operator +=(const MATX &rhs){\n                *this=*this+rhs;\n                return *this;\n            }\n            MATX & operator -=(const MATX &rhs){\n                *this=*this-rhs;\n                return *this;\n            }\n            MATX & operator *=(const MATX &rhs){\n                *this=*this*rhs;\n                return *this;\n            }\n\n            const MATX pow(const unsigned long p) const{\n                MATX buff(*this), ret(this->hig, this->wid);\n                ret.set_one();\n                if(p>0)for(unsigned long i=1;;i<<=1){\n                    if(p&i)ret*=buff;\n                    buff*=buff;\n                    if(i>(p>>1))break;\n                }\n                return ret;\n            }\n            template<class T2> const MATX pow(const unsigned long p, const T2 m) const{\n                MATX buff(*this), ret(this->hig, this->wid);\n                ret.set_one();\n                if(p>0)for(unsigned long i=1;;i<<=1){\n                    if(p&i)ret=ret.mul(buff, m);\n                    buff=buff.mul(buff, m);\n                    if(i>(p>>1))break;\n                }\n                return ret;\n            }\n\n\n            const T at(const unsigned long x, const unsigned long y) const{\n                if(x>=this->hig || y>=this->wid)return 0;\n                return this->data[x*wid+y];\n            }\n\n            void show() const{\n                for(unsigned long x=0; x<this->hig; x++){\n                    for(unsigned long y=0; y<this->wid; y++)\n                        cout<<this->at(x, y)<<\" \";\n                    cout<<endl;\n                }\n            }\n\n            void set_one(){\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=(x==y)?1:0;\n            }\n\n    };\n\n    //Complex\n    template<class T> class complex_t{\n        public:\n        T r, i;//real part & imaginary part; x+yi\n        complex_t(T x=0.0, T y=0.0){ this->r=x; this->i=y; }\n        complex_t operator + (const complex_t &opn) const { return complex_t(this->r+opn.r, this->i+opn.i); }\n        complex_t operator - (const complex_t &opn) const { return complex_t(this->r-opn.r, this->i-opn.i); }\n        complex_t operator * (const complex_t &opn) const { return complex_t(this->r*opn.r-this->i*opn.i, this->r*opn.i+this->i*opn.r); }\n    };\n\n    template<class T> void fast_fourier_trans(complex_t<T> f[], const int len, const int is_dft){\n        for(int i=1, j=len>>1; i<len-1; i++){\n            if(i<j)swap(f[i], f[j]);\n            int k=len>>1;\n            while(j>=k){\n                j-=k;\n                k>>=1;\n            }\n            if(j<k)j+=k;\n        }\n        for(int h=2; h<=len; h<<=1){\n            complex_t<T> wn(cos(is_dft?(-2*PI/h):(2*PI/h)), sin(is_dft?(-2*PI/h):(2*PI/h)));\n            for(int i=0; i<len; i+=h){\n                complex_t<T> wm(1.0, 0.0);\n                for(int j=i; j<i+(h>>1); j++){\n                    complex_t<T> u = f[j];\n                    complex_t<T> t = wm*f[j+(h>>1)];\n                    f[j] = u+t;\n                    f[j+(h>>1)] = u-t;\n                    wm = wm*wn;\n                }\n            }\n        }\n        if(!is_dft){\n            for(int i=0; i<len; i++)\n                f[i].r/=len*1.0;\n        }\n    }\n\n    //MILLERRABIN\n    class MILLERRABIN{\n        private:\n        static const int prime_table[12];\n        int witness(lld a, lld d, lld s, lld n){\n            lld r=MODL_POW(a, d, n);\n            if(r==1 || r==n-1)return 0;\n            for(int i=0; i<s-1; i++){\n                r = MODL_MUL(r, r, n);\n                if(r==1)return 1;\n                if(r==n-1)return 0;\n            }\n            return 1;\n        }\n        public:\n        int test(const lld n){\n            if(n<=2LL) return 0;\n            lld p=n-1LL, s=0LL;\n            while(!(p&1)){ p>>=1;s++; }\n            for(int i=0; i<12 && this->prime_table[i]<n; i++){\n                if(witness(this->prime_table[i], p, s, n))return 0;\n            }\n            return 1;\n        }\n    };\n    const int MILLERRABIN::prime_table[12] = { 2, 3, 5, 7, 11, 13 ,17, 19, 23, 29, 31, 37 };\n\n    //Computational Geometry\n\n    template<class T> inline int fsign(const T x){\n        if(x>-eps && x<eps)return 0;\n        return (x<0.0)?-1:1;\n    }\n\n    template<class T> class point_t{\n        public:\n        T x, y;\n        int idx;\n        point_t (){\n            this->x=0.0;\n            this->y=0.0;\n        }\n        point_t (const T _x, const T _y){\n            this->x=_x;\n            this->y=_y;\n        }\n        point_t operator - (const point_t &rhs) const{\n            return point_t(this->x-rhs.x, this->y-rhs.y);\n        }\n        T operator ^ (const point_t &rhs) const{\n            return this->x*rhs.y - this->y*rhs.x;\n        }\n        T operator * (const point_t &rhs) const{\n            return this->x*rhs.x + this->y*rhs.y;\n        }\n        bool operator < (const point_t &rhs) const{\n            if(fsign(this->y-rhs.y)!=0)\n                return fsign(this->y-rhs.y)<0;\n            return fsign(this->x-rhs.x)<0;\n        }\n        T cross(const point_t &p, const point_t &q) const{\n            return (p-*this)^(q-*this);\n        }\n        void rotate(const double radian){\n            T x0=x, y0=y;\n            T sinr=sin(radian);\n            T cosr=cos(radian);\n            x=x0*cosr-y0*sinr;\n            y=x0*sinr+y0*cosr;\n        }\n        void rotate(const point_t &p, const double radian){\n            T x0=x-p.x, y0=y-p.y;\n            T sinr=sin(radian);\n            T cosr=cos(radian);\n            x=x0*cosr-y0*sinr+p.x;\n            y=x0*sinr+y0*cosr+p.y;\n        }\n        T dist2(const point_t &lhs, const point_t &rhs) const{\n            return (lhs-rhs)*(lhs-rhs);\n        }\n        T dist2(const point_t &rhs) const{\n            return (*this-rhs)*(*this-rhs);\n        }\n        T dist(const point_t &lhs, const point_t &rhs) const{\n            return sqrt((lhs-rhs)*(lhs-rhs));\n        }\n        T dist(const point_t &rhs) const{\n            return sqrt((*this-rhs)*(*this-rhs));\n        }\n    };\n\n    template<class T> class segment_t{\n        public:\n        point_t<T> p, q;\n        segment_t (){\n            this->p.x=this->p.y=0.0;\n            this->q.x=this->q.y=0.0;\n        }\n        template<class T2> segment_t (const point_t<T2> &_p, const point_t<T2> &_q){\n            this->p.x=_p.x;\n            this->p.y=_p.y;\n            this->q.x=_q.x;\n            this->q.y=_q.y;\n        }\n        segment_t (const T px, const T py, const T qx, const T qy){\n            this->p.x=px;\n            this->p.y=py;\n            this->q.x=qx;\n            this->q.y=qy;\n        }\n        T length() const{\n            return this->p.dist(this->q);\n        }\n        T length2() const{\n            return this->p.dist2(this->q);\n        }\n        int contain(const point_t<T> &pnt, const int ignore_endpoint=0) const{\n            if(ignore_endpoint){\n                return fsign((this->p-pnt)^(this->q-pnt))==0\n                    && fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <0\n                    && fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <0;\n            }else{\n                return fsign((this->p-pnt)^(this->q-pnt))==0\n                    && fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <=0\n                    && fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <=0;\n            }\n        }\n        int intersection(const segment_t &sa, const segment_t &sb, const int ignore_endpoint=0) const{\n            if(!ignore_endpoint){\n                if(sa.contain(sb.p) || sa.contain(sb.q) || sb.contain(sa.p) || sb.contain(sa.q))\n                    return 1;\n            }\n            return fsign(sa.p.cross(sa.q, sb.p))*fsign(sa.p.cross(sa.q, sb.q))<0\n                && fsign(sb.p.cross(sb.q, sa.p))*fsign(sb.p.cross(sb.q, sa.q))<0;\n        }\n        int intersection(const segment_t &rhs, const int ignore_endpoint=0) const{\n            return this->intersection(*this, rhs, ignore_endpoint);\n        }\n    };\n\n    template<class T> static int compare_pas(const void *x, const void *y, void *z){\n        const point_t<T> *p1 = (point_t<T>*)x;\n        const point_t<T> *p2 = (point_t<T>*)y;\n        const point_t<T> *p0 = (point_t<T>*)z;\n        int sgn = fsign(((*p1)-(*p0))^((*p2)-(*p0)));\n        if(sgn!=0)return -sgn;\n        return fsign(p0->dist2(*p1)-p0->dist2(*p2));\n    }\n    template<class T> void polar_angle_sort(point_t<T> *pnts, const int n){\n        int p=0;\n        for(int i=1; i<n; i++){\n            if(pnts[p]<pnts[i])p=i;\n        }\n        swap(pnts[0], pnts[p]);\n        qsort_r(pnts+1, n-1, sizeof(point_t<T>), compare_pas<T>, pnts);\n    }\n\n    template<class T> void graham(point_t<T> *pnts, const int n, int *idx, int &m){\n        polar_angle_sort(pnts, n);\n        m=0;\n        if(n<3)return;\n        idx[m++]=0;\n        idx[m++]=1;\n        for(int i=2; i<n; i++){\n            while(m>1 && fsign(pnts[idx[m-2]].cross(pnts[idx[m-1]], pnts[i]))<=0)m--;\n            idx[m++]=i;\n        }\n    }\n\n\n//TAIL_OF_JKI'S_HEADER\n\nint n, ans;\npoint_t<double> a[210];\n\nint vst[41000], pow2[210];\n\nint sub2(const int k){\n    return MOD_ADD(pow2[k], -k-1);\n}\n\nint main(){\n    pow2[0]=1;\n    for(int i=1; i<210; i++){\n        pow2[i]=MOD_MUL(pow2[i-1], 2);\n    }\n    while(scanf(\"%d\", &n)!=EOF){\n        for(int i=0; i<n; i++){\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            a[i].x=x*1.0;\n            a[i].y=y*1.0;\n            a[i].idx=i;\n        }\n        memset(vst, 0, sizeof(vst));\n        ans=sub2(n);\n        for(int s=0; s<n; s++){\n            polar_angle_sort(a+s, n-s);\n            for(int i=s+1; i<n; i++){\n                int j=i;\n                while(j+1<n && fsign((a[j+1]-a[s])^(a[i]-a[s]))==0)j++;\n                int mask=a[s].idx*n+a[i].idx;\n                if(!vst[mask]){\n                    for(int k=i; k<=j; k++){\n                        int curr=a[s].idx*n+a[k].idx;\n                        vst[curr]=1;\n                    }\n                    for(int x=i; x<=j; x++){\n                        for(int y=x+1; y<=j; y++){\n                            int curr=a[x].idx*n+a[y].idx;\n                            vst[curr]=1;\n                        }\n                    }\n                    MOD_ADD(&ans, -sub2(j-i+2));\n                }\n                i=j;\n            }\n        }\n        MOD_STD(&ans);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\nstruct pos\n{\n    int x, y;\n};\n\npos arr[200];\nbool chk[200][200];\n\nconst int mod = 998244353;\nint exp(int a, int x)\n{\n    if(x == 0)\n        return 1;\n    if(x%2)\n        return 1LL * exp(a, x-1) * a % mod;\n    int t = exp(a, x/2);\n    return 1LL * t * t % mod;\n}\n\nint fac[201];\nint caf[201];\ninline int ncr(int n, int r)\n{\n    return 1LL * fac[n] * caf[r] % mod * caf[n-r] % mod;\n}\n\nvector<int> tmp;\n\nint main()\n{\n    //freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n\n    int n, x, y, r, t, i, j, k;\n    scanf(\"%d\", &n);\n    for(i = 0; i<n; i++)\n    {\n        scanf(\"%d%d\", &x, &y);\n        arr[i] = { x, y };\n    }\n\n    fac[0] = 1;\n    for(i = 1; i<=200; i++)\n        fac[i] = 1LL * fac[i-1] * i % mod;\n\n    for(i = 0; i<=200; i++)\n        caf[i] = exp(fac[i], mod-2);\n\n    r = 0;\n    for(i = 3; i<=n; i++)\n    {\n        r += ncr(n, i);\n        r %= mod;\n    }\n\n    for(i = 0; i<n-1; i++)\n    {\n        for(j = i+1; j<n; j++)\n        {\n            if(chk[i][j] || chk[j][i])\n                continue;\n\n            tmp.clear();\n\n            tmp.push_back(i);\n            tmp.push_back(j);\n\n            t = 2;\n            for(k = 0; k<n; k++)\n            {\n                if(k == i || k == j)\n                    continue;\n\n                if(1LL * (arr[i].y - arr[j].y) * (arr[i].x - arr[k].x) != 1LL * (arr[i].x - arr[j].x) * (arr[i].y - arr[k].y))\n                    continue;\n\n                tmp.push_back(k);\n                t++;\n            }\n\n            for(int ii = 0; ii<t-1; ii++)\n                for(int jj = ii+1; jj<t; jj++)\n                    chk[ii][jj] = 1;\n\n            for(k = 3; k<=t; k++)\n            {\n                r -= ncr(t, k);\n                r += mod;\n                r %= mod;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", r);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-12;\ntypedef complex<long double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<pair<int,int> >se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\tif(se.find({i,j})!=se.end())continue;\n\t\tL l(v[i],v[j]);\n\t\tvector<int>x={i,j};\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectLP(l,v[k]))x.push_back(k);\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\tint n=b-a-1;\n\t\t\tr=(r-pow_binary_mod(2,n,M))%M;\n\t\t\tse.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define mp(a, b) make_pair(a, b)\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &t) {\n    os << \"[\";\n    for (const auto &it : t) {\n        if (it != t.begin()) os << \",\";\n        os << it;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const set<T> &t) {\n    os << \"{\";\n    for (const auto &it : t) {\n        if (it != t.begin()) os << \",\";\n        os << it;\n    }\n    os << \"}\";\n    return os;\n}\n\ntemplate<class S, class T>\nostream &operator<<(ostream &os, const map<S, T> &t) {\n    os << \"{\";\n    for (const auto &it : t) {\n        if (it != t.begin()) os << \",\";\n        os << it;\n    }\n    os << \"}\";\n    return os;\n}\n\ntemplate<class S, class T>\nostream &operator<<(ostream &os, const pair<S, T> &t) { return os << \"(\" << t.first << \",\" << t.second << \")\"; }\n\ntemplate<class S, class T>\npair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) {\n    return pair<S, T>(s.first + t.first, s.second + t.second);\n}\n\ntemplate<class S, class T>\npair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) {\n    return pair<S, T>(s.first - t.first, s.second - t.second);\n}\n\nconst int INF = 1 << 28;\nconst double EPS = 1e-8;\nconst int MOD = 998244353;\n\nnamespace int_geom {\n#define at(i) ((*this)[i])\n#define SELF (*this)\n    enum {\n        TRUE = -1, FALSE = 0, BORDER = 1\n    };\n    typedef ll R;\n\n    struct P {\n        R X, Y;\n\n        P(R X = 0, R Y = 0) : X(X), Y(Y) {}\n\n        bool operator<(const P &q) const {\n            return X != q.X ? X < q.X : Y < q.Y;\n        }\n\n        bool operator==(const P &q) const { return X == q.X && Y == q.Y; }\n\n        P operator+(const P &q) const { return P(X + q.X, Y + q.Y); }\n\n        P operator-(const P &q) const { return P(X - q.X, Y - q.Y); }\n\n        P operator*(const R &q) const { return P(X * q, Y * q); }\n\n        P operator/(const R &q) const { return P(X / q, Y / q); }\n\n        P operator-() const { return P(-X, -Y); }\n    };\n\n    void swap(P &a, P &b) {\n        P t = a;\n        a = b;\n        b = t;\n    }\n\n    inline R norm(const P &p) { return p.X * p.X + p.Y * p.Y; }\n\n    inline R inp(const P &p, const P &q) { return p.X * q.X + p.Y * q.Y; }\n\n    inline R outp(const P &p, const P &q) { return p.X * q.Y - p.Y * q.X; }\n\n    inline int ccw(const P &s, const P &t, const P &p, int adv = 0) {\n        int res = outp(t - s, p - s);\n        if (res || !adv) return res ? (res < 0 ? -1 : 1) : 0;\n        if (inp(t - s, p - s) < 0) return -2;    // p-s-t\n        if (inp(s - t, p - t) < 0) return 2;        // s-t-p\n        return 0;                            // s-p-t\n    }\n\n    int orthant(const P &p) {\n        return p.X < 0 || (p.X == 0 && p.Y > 0);\n    }\n\n    bool comparg(const P &i, const P &j) {\n        if (i == P(0, 0)) return true;\n        if (j == P(0, 0)) return false;\n        if (orthant(i) != orthant(j)) return orthant(i) < orthant(j);\n        if ((i.Y) * (j.X) == (j.Y) * (i.X)) return norm(i) > norm(j);\n        return ((i.Y) * (j.X) < (j.Y) * (i.X));\n    }\n\n    void argsort(vector<P> &v) {\n        sort(v.begin(), v.end(), comparg);\n    }\n\n    void normalize(P &p) {\n        ll g = __gcd(abs(p.X), abs(p.Y));\n        p.X /= g;\n        p.Y /= g;\n    }\n\n\n    struct G : public vector<P> {\n        G(size_type size = 0) : vector(size) {}\n\n        G(vector<P>::iterator begin, vector<P>::iterator end) : vector(begin, end) {}\n\n//\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n        bool contains(const P &p) const {\n            bool in = false;\n            for (int i = 0; i < size(); ++i) {\n                P a = at(i) - p, b = at(i + 1 == size() ? 0 : i + 1) - p;\n                if (a.Y > b.Y) int_geom::swap(a, b);\n                if (a.Y <= 0 && 0 < b.Y && outp(a, b) < 0) in = !in;\n                if (outp(a, b) == 0 && inp(a, b) <= 0) return BORDER;\n            }\n            return in ? TRUE : FALSE;\n        }\n\n        G convex_hull(bool online = false) {\n            if (size() < 2) return *this;\n            sort(this->begin(), this->end());\n            G r;\n            r.resize((int) size() * 2);\n            int k = 0;\n            for (int i = 0; i < size(); r[k++] = at(i++))\n                while (k > 1 && ccw(r[k - 2], r[k - 1], at(i)) < 1 - online) k--;\n            int t = k;\n            for (int i = (int) size() - 1; i >= 0; r[k++] = at(i--))\n                while (k > t && ccw(r[k - 2], r[k - 1], at(i)) < 1 - online) k--;\n            r.resize(k - 1);\n            return r;\n        }\n\n        R area() const {    // return 2 * area of a polygon\n            R sum = 0;\n            for (int i = 0; i < size(); ++i) {\n                sum += outp(at(i), at((i + 1) % size()));\n            }\n            return abs(sum);\n        }\n    };\n\n};\nusing namespace int_geom;\nnamespace std {\n    ostream &operator<<(ostream &os, const int_geom::P &p) { return os << \"(\" << p.X << \", \" << p.Y << \")\"; }\n}\n\nint T, n, m;\nint tricount[201][201][201];\nint pow2[300];\n\nmap<P, int> idx;\n\nll solve(vector<P> op, int leftest) {\n    vector<P> p;\n    for (int i = 0; i < n; ++i) {\n        if (op[leftest].X < op[i].X || (op[leftest].X == op[i].X && op[leftest].Y <= op[i].Y )) p.emplace_back(op[i].X - op[leftest].X, op[i].Y - op[leftest].Y);\n    }\n    argsort(p);\n    vector<int> is;\n    for (auto it : p) {\n        is.push_back(idx[it + op[leftest]]);\n    }\n    int n = p.size();\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n    for (int j = 1; j < n; ++j) {\n        dp[0][j] = 1;\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k)\n                if (ccw(p[i], p[j], p[k]) == 1) {\n                    dp[j][k] = (dp[j][k] + dp[i][j] * pow2[tricount[is[i]][is[j]][is[k]]] % MOD);\n                }\n        }\n    }\n    ll ans = 0;\n    for (int i = 1; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) if (ccw(p[i], p[j], p[0]) == 1){\n            ans += dp[i][j];\n        }\n    }\n    return ans % MOD;\n}\n\nvoid calculateTriCount(vector<P> p) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int k = 0; k < n; ++k)\n                if (ccw(p[i], p[j], p[k]) == 1) {\n                    for (int l = 0; l < n; ++l) {\n                        if (i != l && j != l && k != l) {\n                            if (\n                                    ccw(p[i], p[j], p[l]) != -1 &&\n                                    ccw(p[j], p[k], p[l]) != -1 &&\n                                    ccw(p[k], p[i], p[l]) != -1\n                                    ) {\n                                tricount[i][j][k]++;\n                            }\n                        }\n                    }\n\n                }\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    pow2[0] = 1;\n    for (int i = 0; i < n; ++i) {\n        pow2[i + 1] = pow2[i] * 2 % MOD;\n    }\n    vector<P> p;\n    for (int i = 0; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        p.emplace_back(x, y);\n    }\n    sort(p.begin(), p.end());\n    for (int i = 0; i < n; ++i) {\n        idx[p[i]] = i;\n    }\n    calculateTriCount(p);\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n        ans += solve(p, i);\n    }\n    cout << ans % MOD << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int mo=998244353;\nint ksm(int a,int b){\n  int ans=1;\n  while (b){\n\tif (b&1) ans=1ll*ans*a%mo;\n\tb>>=1;a=1ll*a*a%mo;\n  }\n  return ans;\n}\nstruct point {\n  int x,y;\n  point operator-(const point &a){\n   return (point){x-a.x,y-a.y};\n  }\n  bool operator==(const point &a){\n    return x==a.x && y==a.y;\n  }\n};\n\nint cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nvoid add(int &x,int y){\n  x+=y;\n  if (x>=mo) x-=mo;\n  if (x<0) x+=mo;\n}\n\nint dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\nbool cmp(point a,point b){\n   if (a.x==0 && b.x==0) return a.y<b.y;\n   if (a.x==0) return 0;\n   if (b.x==0) return 1;\n   if (cross(a,b)==0) {\n\t if (a.x*b.x<0) return a.x<b.x;\n\t else return dot(a,a)<dot(b,b);\n   }\n   if (a.x<0) {a.x*=-1;a.y*=-1;}\n   if (b.y<0) {b.x*=-1;b.y*=-1;}\n   return cross(a,b)>0;\n}\npoint p[210],t[210];\nint main()\n{\n    int i,j;\n    int n;\n    cin>>n;\n    for (i=1;i<=n;i++) scanf(\"%d %d\",&p[i].x,&p[i].y);\n    int ans=ksm(2,n);\n    add(ans,-1-n);\n    int cnt;\n    for (i=1;i<=n;i++){\n      cnt=0;\n      for (j=1;j<=n;j++){\n        if (j==i) continue;\n        t[cnt++]=p[j]-p[i];\n      }\n      sort(t,t+cnt,cmp);\n      int last=0;\n      for (j=1;j<cnt;j++){\n\t\tif (cross(t[j-1],t[j])){\n\t\t\tif (t[last].x<0 || (t[last].x==0 && t[last].y<0)) continue;\n\t\t\tadd(ans,-(ksm(2,j-last+1)-(j-last+1)-1));\n\t\t\tlast=j;\n\t\t}\n      }\n      if (cnt && !(t[last].x<0 || (t[last].x==0 && t[last].y<0))){\n\t\tadd(ans,-(ksm(2,j-last+1)-(j-last+1)-1));\n      }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<stdio.h>\n#include<queue>\n#define x first\n#define y second\nusing namespace std;\nconst int mod=998244353;\nint N;\n\nint x[205],y[205],power[205];\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tint ans;\n\tpower[0]=1;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tpower[i+1]=(power[i]<<1)%mod;\n\t}\n\tans=power[N]-N-1;\n\n\tfor(int i=0;i<N;i++)\n\tfor(int j=0;j<i;j++)\n\t{\n\t\tint cnt=0;\n\t\tfor(int k=0;k<j;k++)\n\t\t{\n\t\t\tif((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))\n\t\t\tcnt++;\n\t\t}\n\t\tans=(ans-power[cnt]+mod)%mod;\n\t}\n\t\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nconst double eps=1e-9;\nconst int p=998244353;\nint n,x[210],y[210],pow2[210],ans;\nbool flag[210][210];\nstruct data\n{\n    int id;\n    double agl;\n    bool operator<(const data &t) const\n    {\n        return agl<t.agl;\n    }\n} a[210];\n\ndouble get(int y,int x)\n{\n    if (y<0 || !y && x<0)\n        return atan2(-y,-x);\n    return atan2(y,x);\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    repu(i,1,n)\n        scanf(\"%d%d\",&x[i],&y[i]);\n    pow2[0]=1;\n    repu(i,1,n)\n        pow2[i]=pow2[i-1]*2%p;\n    ans=(pow2[n]+p-n-1)%p;\n    repu(i,1,n)\n    {\n        int m=0;\n        repu(j,i+1,n)\n            a[++m]=(data){j,get(y[j]-y[i],x[j]-x[i])};\n        for (int j=1,k; j<=m; j=k)\n        {\n            for (k=j+1; k<=m && (a[k].agl-a[j].agl)<eps; ++k);\n            if (!flag[i][a[j].id])\n            {\n                (ans+=p-pow2[k-j+1]+k-j+2)%=p;\n                repu(ii,j,k-1)\n                {\n                    flag[i][a[ii].id]=flag[a[ii].id][i]=1;\n                    repu(jj,ii+1,k-1)\n                        flag[a[ii].id][a[jj].id]=flag[a[jj].id][a[ii].id]=1;\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=220,P=998244353;\nint i,j,k,n,m,ch,ans,g;\nint tm2[N];\nstruct point {\n\tint x,y;\n\tbool operator < (const point &n) const {\n\t\tif (x==n.x) return y<n.y;\n\t\treturn x<n.x;\n\t}\n} A[N],B[N];\nvoid R(int &x) {\n\tx=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) ch=getchar();\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n}\nint gcd(int a,int b) {\n\tif (!b) return a;\n\treturn gcd(b,a%b);\n}\nint main() {\n\tR(n);\n\ttm2[0]=1;\n\tfor (i=1;i<=n;i++) tm2[i]=(tm2[i-1]+tm2[i-1])%P;\n\tfor (i=1;i<=n;i++) R(A[i].x),R(A[i].y);\n\tsort(A+1,A+n+1);\n\tans=1;\n\tfor (i=1;i<=n;i++) {\n\t\tm=0;\n\t\tans=(ans+1)%P;\n\t\tfor (j=i+1;j<=n;j++) {\n\t\t\tm++;\n\t\t\tB[m].x=A[j].x-A[i].x;\n\t\t\tB[m].y=A[j].y-A[i].y;\n\t\t\tif (B[m].y<0) g=gcd(B[m].x,-B[m].y);\n\t\t\telse g=gcd(B[m].x,B[m].y);\n\t\t\tB[m].x/=g;\n\t\t\tB[m].y/=g;\n\t\t}\n\t\tsort(B+1,B+m+1);\n\t\tB[m+1].x=-1;\n\t\tk=1;\n\t\tfor (j=1;j<=m;j++) {\n\t\t\tif (B[j].x==B[j+1].x && B[j].y==B[j+1].y) k++;\n\t\t\telse {\n\t\t\t\tans=(ans+tm2[k]-1)%P;\n\t\t\t\tk=1;\n\t\t\t}\n\t\t}\n\t}\n\tans=(tm2[n]+P-ans)%P;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nstruct Int2D {\n  const int64 x, y;\n  Int2D(int64 x, int64 y) : x(x), y(y) {}\n  Int2D operator-(Int2D o) const {\n    return Int2D(x - o.x, y - o.y);\n  }\n  int64 CrossProduct(Int2D o) const {\n    return x * o.y - y * o.x;\n  }\n};\n\nint64 CrossProduct(Int2D p1, Int2D p2) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\nbool Colinear(Int2D p1, Int2D p2, Int2D p3) {\n  Int2D v12 = p2 - p1;\n  Int2D v13 = p3 - p1;\n  return CrossProduct(v12, v13) == 0;\n}\n\nconstexpr int64 P = 998244353;\n\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 x) : x(x) {\n    if (x > P || x < 0) { cerr << \"Invalied FiniteField!\" << endl; exit(1); }\n  }\n  FiniteField() : x(0) {}\n  int64 Value() const { return x; }\n  inline FiniteField operator+(FiniteField o) const {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) const {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) const {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) const {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  vector<Int2D> ps;\n  for (int i = 0; i < n; i++) {\n    int64 x, y;\n    cin >> x >> y;\n    ps.emplace_back(x, y);\n  }\n\n  FiniteField r = 0;\n  r += 1;\n  r += n;\n\n  set<pair<int, int>> visited;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (visited.find(make_pair(i, j)) != visited.end()) {\n        continue;\n      }\n\n      vector<int> vs({i, j});\n      for (int k = j + 1; k < n; k++) {\n        if (Colinear(ps[i], ps[j], ps[k])) {\n          vs.push_back(k);\n        }\n      }\n\n      int m = vs.size();\n      FiniteField s = 1;\n      for (int k = 0; k < m; k++) s *= 2;\n      s -= 1;\n      s -= m;\n\n      r += s;\n\n      for (int i1 = 0; i1 < vs.size(); i1++) {\n        for (int i2 = i1 + 1; i2 < vs.size(); i2++) {\n          visited.insert(make_pair(i1, i2));\n        }\n      }\n    }\n  }\n\n  FiniteField ans = 1;\n  for (int i = 0; i < n; i++) ans *= 2;\n  ans -= r;\n  // cout << r.Value() << endl;\n  cout << ans.Value() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vdouble = vector<double>;\nusing vvdouble = vector<vdouble>;\nusing vvvdouble = vector<vvdouble>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\nconstexpr int mod2 = 998244353;\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) { return (a > b && (a = b, true)); }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) { return (a < b && (a = b, true)); }\ntemplate<typename T>\nbool isin(T y, T x, T h, T w) { return (0 <= y && 0 <= x && y < h && x < w); }\ntemplate<typename T>\nbool isin1(T y, T x, T h, T w) { return (0 < y && 0 < x && y <= h && x <= w); }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++) os << \" \" << v[i];\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nconstexpr double EPS = 1e-10;\nbool equals(double a, double b) { return (abs(a - b) < EPS); }\n\nstruct V2 {\n\tdouble x, y;\n\tV2(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tV2 operator + (V2 p) const { return (V2(x + p.x, y + p.y)); }\n\tV2 operator - (V2 p) const { return (V2(x - p.x, y - p.y)); }\n\tV2 operator * (double r) const { return (V2(x * r, y * r)); }\n\tV2 operator / (double r) const { return (V2(x / r, y / r)); }\n\n\tdouble norm() const { return (sqrt(sqrNorm())); }\n\tdouble sqrNorm() const { return (x*x + y*y); }\n\n\tbool operator < (const V2 &p) const { \n\t\treturn (x != p.x ? x < p.x : y < p.y); \n\t}\n\tbool operator == (const V2 &p) const {\n\t\treturn (equals(x, p.x) && equals(y, p.y));\n\t}\n\n\tV2 rotate90() const { return (V2(y, -x)); }\n\tV2 normalized() const { return (*this / norm()); }\n\n\tdouble dot(const V2 &p) const { return (x*p.x + y*p.y); }\n\tdouble cross(const V2 &p) const { return (x*p.y - y*p.x); }\n\tdouble arg() const { return (atan2(y, x)); }\n};\n\nvoid Main() {\n\tint N; cin >> N;\n\tvector<V2> ps(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> ps[i].x >> ps[i].y;\n\t}\n\n\tll sum = 0;\n\n\tsort(begin(ps), end(ps));\n\tfor (int a = 0; a < N; a++) {\n\t\tvector<pair<double, V2>> dats;\n\t\tint n = N-a-1;\n\t\tfor (int b = a+1; b < N; b++) {\n\t\t\tdats.emplace_back((ps[b]-ps[a]).arg(), ps[b]-ps[a]);\n\t\t}\n\t\tsort(begin(dats), end(dats));\n\t\tvector<V2> nps(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnps[i] = dats[i].second;\n\t\t}\n\n\t\tvvll contval(n, vll(n, 1));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tfor (int k = j+1; k < n; k++) {\n\t\t\t\t\tif ((nps[k]-nps[i]).cross(nps[j]-nps[i]) > -EPS) {\n\t\t\t\t\t\t(contval[i][k] *= 2) %= mod2;\n\t\t\t\t\t\t//cout << a << \" \" << nps[i].x << \" \" << nps[i].y << \" \" << nps[k].x << \" \" << nps[k].y << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tvvll dp(n, vll(n, 0));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tif (!equals(nps[i].cross(nps[j]), 0.0)) dp[i][j] = contval[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tV2 v1 = nps[j]-nps[i];\n\t\t\t\tfor (int k = j+1; k < n; k++) {\n\t\t\t\t\tV2 v2 = nps[k]-nps[i];\n\t\t\t\t\tif (v1.cross(v2) < EPS) continue;\n\t\t\t\t\tif (equals(nps[j].arg(), nps[k].arg())) continue;\n\t\t\t\t\t(dp[j][k] += contval[j][k] * dp[i][j]) %= mod2;\n\t\t\t\t}\n\t\t\t\t(sum += dp[i][j]) %= mod2;\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';\n\treturn !f?x:-x;\n}\n\nconst int N=200+19;\nconst int p=998244353;\n\nstruct Point{\n\tint x,y;\n\tbool operator < (const Point &B) const{\n\t\treturn x<B.x||x==B.x&&y<B.y;\n\t}\n} P[N],Pt;\ntypedef Point Vector;\n\nint dp[N][N],val[N][N],pw2[N];\nint n,ans;\n\nVector operator - (Point A,Point B){\n\treturn (Vector){\n\t\tA.x-B.x,A.y-B.y\n\t};\n}\nll cross(Vector A,Vector B){\n\treturn 1ll*A.x*B.y-1ll*A.y*B.x;\n}\nbool cmp(Point A,Point B){\n\treturn cross(A-Pt,B-Pt)>0;\n}\n\nvoid Work(vector<Point> V){\n\tint n=V.size();\n\tmemset(dp,0,sizeof(dp));\n\tmemset(val,0,sizeof(val));\n\tsort(V.begin()+1,V.end(),cmp);\n\tFor(i,1,n) For(j,i+1,n){\n\t\tFor(k,1,n) if (k!=i&&k!=j&&cross(V[i]-V[0],V[k]-V[0])>=0&&cross(V[k]-V[0],V[j]-V[0])>=0&&cross(V[j]-V[i],V[k]-V[i])>=0) val[i][j]++;\n\t\tval[i][j]=pw2[val[i][j]];\n\t}\n\tFor(i,1,n) dp[0][i]=1;\n\tFor(i,0,n) For(j,i+1,n) if (dp[i][j]){\n\t\tFor(k,j+1,n) if (cross(V[j]-V[i],V[k]-V[j])>0){\n\t\t\tdp[j][k]=(dp[j][k]+1ll*val[j][k]*dp[i][j])%p;\n\t\t}\n\t}\n\tFor(i,1,n) For(j,i+1,n)\n\t\tif (cross(V[j]-V[i],V[0]-V[j])>0){\n\t\t\tans=(ans+dp[i][j])%p;\n\t\t}\n}\n\nint main(){\n\tpw2[0]=1;\n\tFor(i,1,N) pw2[i]=2ll*pw2[i-1]%p;\n\tn=IN();\n\tFor(i,1,n+1) P[i]=(Point){IN(),IN()};\n\tsort(P+1,P+n+1);\n\tFor(i,1,n+1){\n\t\tPt=P[i];\n\t\tvector<Point> V;\n\t\tFor(j,i,n+1) V.pb(P[j]);\n\t\tWork(V);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define mk make_pair\nusing namespace std;\nconst int N = 2e2 + 5;\nconst int mod = 998244353;\nbool bo[N][N];\nint n, x[N], y[N];\nvector<int> V;\nll ans, p[N];\nbool line(int i, int j, int k) {\n\treturn (x[j] - x[i]) * (y[k] - y[i]) - (x[k] - x[i]) * (y[j] - y[i]) == 0; \n}\nint main() {\n\tp[0] = 1;\n\tfor (int i = 1; i < N; i++) p[i] = p[i - 1] * 2 % mod;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (bo[i][j]) continue;\n\t\t\tV.clear();\n\t\t\tV.push_back(i);\n\t\t\tV.push_back(j);\n\t\t\tfor (int k = j + 1; k <= n; k++) {\n\t\t\t\tif (line(i, j, k)) V.push_back(k);\n\t\t\t}\n\t\t\tfor (int k = 0; k < V.size(); k++)\n\t\t\t\tfor (int l = 0; l < V.size(); l++)\n\t\t\t\t\tbo[V[k]][V[l]] = 1;\n\t\t\tans += p[V.size()] - V.size() - 1;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tans = p[n] - ans - n - ;\n\tans %= mod;\n\tans += mod;\n\tans %= mod;\n\tcout << ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nbool on_the_line(pll &a, pll &b, pll &c){\n    return ((a.first - c.first)*(b.second-c.second)-(a.second-c.second)*(b.first-c.first)==0);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    pll points[N];\n    REP(i, N){\n        cin >> points[i].first >> points[i].second;\n    }\n    int did[N][N] = {};\n\n    ll pow2[N+2];\n    pow2[0] = 1;\n    for(int i=1;i<N+2;i++){\n        pow2[i] = (2*pow2[i-1])%mod;\n    }\n\n    ll res = pow2[N];\n    res = (res+mod-1)%mod;\n    res = (res+mod-N)%mod;\n\n    for(int i=0;i<N;i++){\n        for (int j=i+1;j<N;j++){\n            if(did[i][j]==0){\n                vector<int> tmp;\n                tmp.push_back(i);\n                tmp.push_back(j);\n                for(int k=0;k<N;k++){\n                    if(k!=i && k!=j && on_the_line(points[i], points[j], points[k])){\n                        tmp.push_back(k);\n                    }\n                }\n                REP(p, tmp.size()) REP(q, tmp.size()) did[p][q] = 1;\n                int s = tmp.size();\n                res = (res+mod-pow2[s]+1+s)%mod;\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint read()\n{\n\tint ans=0;\n\tchar ch=getchar();\n\tfor(;(ch<'0' || ch>'9') && ch!='-';ch=getchar());\n\tbool flag=0;\n\tif(ch=='-')flag=1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())ans=ans*10+ch-'0';\n\tif(flag)ans=-ans;\n\treturn ans;\n}\n\nlong long rell()\n{\n\tlong long ans=0;\n\tchar ch=getchar();\n\tfor(;(ch<'0' || ch>'9') && ch!='-';ch=getchar());\n\tbool flag=0;\n\tif(ch=='-')flag=1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())ans=ans*10ll+(long long)(ch-'0');\n\tif(flag)ans=-ans;\n\treturn ans;\n}\n\nvoid writ(int n)\n{\n\tchar ch[25];\n\tint m=0;\n\tif(n<0)putchar('-'),n=-n;\n\tif(n==0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tfor(;n;n/=10)ch[m++]=n%10ll+'0';\n\tfor(;m;)putchar(ch[--m]);\n}\n\nvoid wrll(long long n)\n{\n\tchar ch[25];\n\tint m=0;\n\tif(n<0)putchar('-'),n=-n;\n\tif(n==0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tfor(;n;n/=10ll)ch[m++]=n%10ll+'0';\n\tfor(;m;)putchar(ch[--m]);\n}\nconst int N=1<<8;\nconst int mod=998244353;\nint x[N],y[N],po[N];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tpo[0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tx[i]=read();y[i]=read();\n\t\tpo[i+1]=po[i]*2ll%mod;\n\t}\n\tint ans=(po[n]-1-n+mod)%mod;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tint sum=0,a=y[i]-y[j],b=x[j]-x[i],c=-x[i]*y[j]+x[j]*y[i];\n\t\t\tfor(int k=j+1;k<n;k++)\n\t\t\t{\n\t\t\t\tif(x[k]*a+y[k]*b+c==0)sum++;\n\t\t\t}\n\t\t\t(ans+=mod-po[sum])%=mod;\n\t\t\t//printf(\"i=%d j=%d sum=%d\\n\",i,j,sum);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define mod 998244353ll\n#define P pair<int,int>\nusing namespace std;\n\nP a[200];\nsigned main() {\n\tint ans = 1;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = ans * 2 % mod;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t}\n\tans -= n + 1;\n\tans %= mod;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tvector<int>V;\n\t\t\tif (a[i].first == a[j].first) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].first == a[i].first) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (a[i].second == a[j].second) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].second == a[i].second) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble x = double(a[j].second - a[i].second) / (a[j].first - a[i].first);\n\t\t\t\tdouble y = double(a[i].second) - a[i].first*x;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (abs(a[i].first*x + y - a[i].second) <= 1e-15) {\n\t\t\t\t\t\tV.push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(V.begin(), V.end());\n\t\t\tif (V.size()>=2&&V[0] == i&&V[1]==j) {\n\t\t\t\tint k = 1;\n\t\t\t\tfor (int j : V) {\n\t\t\t\t\tk = k * 2 % mod;\n\t\t\t\t}\n\t\t\t\tk -= V.size(); k--;\n\t\t\t\tans -= k;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tans += mod * 5;\n\tans %= mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\n\nconstexpr long long mod = 998244353;\n\nusing P = complex<int>;\n\nint dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\nint cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nbool onseg(P p, P q, P r) {\n  if (cross(q - p, r - p) != 0) return false;\n  return dot(q - p, r - p) >= 0 && dot(p - q, r - q) >= 0;\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<P> ps(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    ps[i] = P(x, y);\n  }\n\n  vector<pair<int, int>> es;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      es.emplace_back(i, j);\n    }\n  }\n  sort(es.begin(), es.end(), [&](pair<int, int> a, pair<int, int> b) {\n    if (a == b) return false;\n    P d = ps[a.second] - ps[a.first];\n    P e = ps[b.second] - ps[b.first];\n    if (cross(d, e) == 0 && dot(d, e) > 0) {\n      return dot(ps[a.second] - ps[a.first], ps[b.first] - ps[a.first]) < 0;\n    } else {\n      return atan2(d.imag(), d.real()) < atan2(e.imag(), e.real());\n    }\n  });\n\n  vector<long long> two(n + 1);\n  two[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two[i] = two[i - 1] * 2 % mod;\n  }\n\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    vector<long long> dp1(n);\n    vector<long long> dp2(n);\n    for (auto e : es) {\n      int u = e.first;\n      int v = e.second;\n\n      int cnt = 0;\n      for (int w = 0; w < n; w++) {\n        if (w == u || w == v || w == i) continue;\n        bool ok = true;\n        ok &= cross(ps[u] - ps[i], ps[w] - ps[i]) >= 0;\n        ok &= cross(ps[v] - ps[u], ps[w] - ps[u]) >= 0;\n        ok &= cross(ps[i] - ps[v], ps[w] - ps[v]) > 0 - (v == i);\n        cnt += ok;\n      }\n\n      if (u == i) {\n        dp1[v] = two[cnt];\n        continue;\n      }\n\n      if (v == i) {\n        dp2[v] += dp2[u] * two[cnt];\n      } else {\n        dp2[v] += dp2[u] * two[cnt];\n        dp2[v] += dp1[u] * two[cnt];\n      }\n      dp2[v] %= mod;\n    }\n    ans += dp2[i];\n    ans %= mod;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NDEBUG\n#ifdef DEBUG\n#include \"../cout11.h\"\n#undef NDEBUG\n#endif\n#include <cassert>\n\ntypedef long long ll;\ntypedef long double Double;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> llll;\ntypedef pair<double,double> dd;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ii> vii;\ntypedef vector<vector<ii>> vvii;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<long double> vD;\n\n#define sz(a)  int((a).size())\n#define pb  push_back\n#define FOR(var,from,to) for(int var=(from);var<=(to);++var)\n#define rep(var,n)  for(int var=0;var<(n);++var)\n#define rep1(var,n)  for(int var=1;var<=(n);++var)\n#define repC2(vari,varj,n)  for(int vari=0;vari<(n)-1;++vari)for(int varj=vari+1;varj<(n);++varj)\n#define ALL(c)  (c).begin(),(c).end()\n#define RALL(c)  (c).rbegin(),(c).rend()\n#define tr(i,c)  for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define found(s,e)  ((s).find(e)!=(s).end())\n#define mset(arr,val)  memset(arr,val,sizeof(arr))\n#define mid(x,y) ((x)+((y)-(x))/2)\n#define IN(x,a,b) ((a)<=(x)&&(x)<=(b))\n#define cons make_pair\n\n\nll gcd(ll a, ll b) { while(a) swap(a, b%=a); return b; }\n\nconst ll MOD=998244353LL;\n\nll ADD(ll x, ll y) { return (x+y) % MOD; }\nll SUB(ll x, ll y) { return (x-y+MOD) % MOD; }\nll MUL(ll x, ll y) { return x*y % MOD; }\nll POW(ll x, ll e) { ll v=1; for(; e; x=MUL(x,x), e>>=1) if (e&1) v = MUL(v,x); return v; }\nll DIV(ll x, ll y) { /*assert(y%MOD!=0);*/ return MUL(x, POW(y, MOD-2)); }\n// ll comb(ll n, ll k) { ll v=1; for(ll i=1; i<=k; i++) v = DIV(MUL(v, n-i+1),i); return v; }\n//\n\ntypedef tuple<double,double,double> LINE;\n\nvoid render_fnum(FILE* fp, double x) {\n    if (x == 1) return;\n    fprintf(fp, \"%g\", x);\n}\nvoid render_line(FILE* fp, LINE& line) {\n    double a,b,c; tie(a,b,c) = line;\n    if (a != 0){\n        render_fnum(fp, a);\n        fprintf(fp, \"x\");\n    }\n\n    if (b != 0) {\n        if (b > 0) {\n            if (a != 0)\n                fprintf(fp, \" + \");\n            render_fnum(fp, b);\n        } else if (b < 0) {\n            fprintf(fp, \" - \");\n            render_fnum(fp, -b);\n        }\n        fprintf(fp, \"y\");\n    }\n\n    if (c != 0) {\n        if (c > 0) {\n            fprintf(fp, \" + %g\", c);\n        } else if (c < 0) {\n            fprintf(fp, \" - %g\", -c);\n        }\n    }\n\n    fprintf(fp, \" = 0\");\n}\n\nLINE get_line(ii& p0, ii& p1){\n    int x0 = p0.first, y0 = p0.second,\n        x1 = p1.first, y1 = p1.second;\n    int dx = x1 - x0, dy = y1 - y0;\n\n    assert(dx != 0 || dy != 0);\n\n    double a, b, c;\n\n    if (dx == 0) {\n        // 1x [+ 0y] - some = 0\n        // some = x\n        // double some = (double)x0;\n        a = 1.0;\n        b = 0.0;\n        c = (double)(-x0); // -some;\n    } else if (dy == 0) {\n        // [0x +] 1y - some = 0\n        // some = y\n        // double some = (double)y0;\n        a = 0.0;\n        b = 1.0;\n        c = (double)(-y0); // -some;\n    } else {\n        // m = dy/dx\n        // y = mx + b\n        // mx - y + b = 0\n        int g = gcd(dx, dy);\n        dx /= g; dy /= g;\n\n        double _m = (double)dx / dy;\n        assert(_m != 0.0);\n        // x - _my - some = 0\n        // double some = (double)x0 - _m * y0;\n        a = 1.0;\n        b = -_m;\n        c = (double)(_m * y0 - x0); // -some;\n    }\n\n    // fprintf(stderr, \"(a,b,c)=(%g,%g,%g)\\n\", a,b,c);\n\n    double z0 = a * x0 + b * y0 + c;\n    double z1 = a * x1 + b * y1 + c;\n#ifdef DEBUG\n    // fprintf(stderr, \"%g * %d + %g * %d + %g = %g\\n\", a,x0, b,y0, c, z0);\n    // fprintf(stderr, \"%g * %d + %g * %d + %g = %g\\n\", a,x1, b,y1, c, z1);\n#endif\n    assert(fabs(z0) < 1e-7);\n    assert(fabs(z1) < 1e-7);\n\n    return LINE(a, b, c);\n}\n\n\nll f(int n){\n    // return (1 << n) - n - 1;\n    return SUB(POW(2, n), ADD(n,1));\n}\n\nll solve(int N, vii& p){\n    // map<LINE, set<int>> by_line;\n    map<vector<ll>, set<int>> by_line;\n\n    repC2(i,j,N){\n#ifdef DEBUG\n        // cerr << \"---\" << endl;\n        // fprintf(stderr, \"[%d %d] \", i, j);\n        // cerr << p[i] << \" \" << p[j] << \" : \";\n#endif\n        LINE line = get_line(p[i], p[j]);\n#ifdef DEBUG\n        // render_line(stderr, line);\n        // cerr << endl;\n#endif\n\n        double a,b,c; tie(a,b,c) = line;\n        vector<ll> _line { (ll)round(1e8*a), (ll)round(1e8*b), (ll)round(1e8*c) };\n        by_line[_line].insert(i);\n        by_line[_line].insert(j);\n    }\n\n    ll ans = f(N); // (1 << N) - (N+1);\n    for(auto p: by_line){\n        // LINE line = p.first;\n        vector<ll> _line = p.first;\n        set<int> s = p.second;\n        int k = p.second.size();\n#ifdef DEBUG\n        render_line(stderr, line);\n        cerr << \" : \" << s << endl;\n#endif\n        ans = SUB(ans, f(k)); // (1 << k) - (k+1));\n    }\n    return ans;\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    vector<ii> p(N);\n    rep(i,N){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        p[i] = ii(x, y);\n    }\n\n    cout << solve(N,p) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2000;\ntypedef long long ll;\nconst ll mod=998244353;\nll x[maxn],y[maxn],power[maxn];\n/*ll power(ll a,ll b)\n{\n    ll ret;\n    if (b==0) return 1LL;\n    ret=pow(a,b/2);\n    ret=ret*ret%mod;\n    if (b%2) ret=ret*a%mod;\n    return ret;\n}*/\nint main()\n{\n    //freopen(\"text.in\",\"r\",stdin);\n    ll i,ans,tmp,j,k,n;\n    scanf(\"%lld\",&n);\n    power[0]=1LL;\n    for (i=1;i<=n;i++) {\n        power[i]=power[i-1]*2LL%mod;\n        scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    ans=((power[n]-n-1)%mod+mod)%mod;\n    //ans=((ans-(n-1)*n/2)%mod+mod)%mod;\n    for (i=1;i<=n;i++) {\n        for (j=i+1;j<=n;j++) {\n            tmp=0;\n            for (k=j+1;k<=n;k++) {\n                if ((y[j]-y[i])*(x[k]-x[j])==(y[k]-y[j])*(x[j]-x[i])) tmp++;\n                //if ((y[k]-y[i])*(x[j]-x[i])==(x[k]-x[i])*(y[j]-y[i])) tmp++;\n            }\n            ans=((ans-/*power(2LL,tmp)*/power[tmp])%mod+mod)%mod;\n        }\n    }\n    printf(\"%lld\\n\",(ans%mod+mod)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nstruct node{\n\tint x;\n\tint y;\n}no[205];\nlong long Qpow(long long x,int n)\n{\n\tlong long ans=1;\n\twhile(n)\n\t{\n\t\tif(n&1)\n\t\t\tans=(ans*x)%mod;\n\t\tx=(x*x)%mod;\n\t\tn=n>>1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tlong long ans=Qpow(2,n)-1-n;\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%d%d\",&no[i].x,&no[i].y);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tint sum=0;\n\t\t\tfor(int k=j+1;k<n;k++)\n\t\t\t\tif ((no[j].x-no[i].x) * (no[k].y-no[j].y) == (no[k].x-no[j].x) * (no[j].y-no[i].y)) \n\t\t\t\t\tsum++;\n\t\t\tans=(ans-Qpow(2,sum)+mod)%mod;\n\t\t}\t\n\t}\t\n\tprintf(\"%lld\\n\",ans%mod); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 2e2 + 10,mod = 998244353;\nconst double Pi = acos(-1.0),eps = 1e-7;\n\nstruct node {\n\tint x,y;\n} P[N];\nbool vis[N];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline int fpm(int a,int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1) res = 1ll * res * a % mod;\n\t\ta = 1ll * a * a % mod,b /= 2;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n = read(),ans = 0;\n\tFor(i,1,n) P[i].x = read(),P[i].y = read();\n\tans = (fpm(2,n) - 1 - n - 1ll * n * (n - 1) / 2) % mod;\n\n\tFor(i,1,n) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tFor(j,1,n) if((i ^ j) && !vis[j]) {\n\t\t\tint cnt = 1;\n\t\t\tdouble val = atan2(P[j].y - P[i].y,P[j].x - P[i].x);\n\t\t\tif(val < eps) val += Pi;\n\t\t\tFor(k,1,n) if(k ^ i) {\n\t\t\t\tdouble cur = atan2(P[k].y - P[i].y,P[k].x - P[i].x);\n\t\t\t\tif(cur < eps) cur += Pi;\n\t\t\t\tif(abs(cur - val) < eps || abs(cur - val - Pi) < eps || abs(cur - val + Pi) < eps)\n\t\t\t\t\tcnt++,vis[k] = true;\n\t\t\t}\n\t\t\tans = (ans - 1ll * (fpm(2,cnt) - 1 - cnt - 1ll * cnt * (cnt - 1) / 2 % mod) * fpm(cnt,mod - 2)) % mod;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",(ans + mod) % mod);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint cnt[201][201] = {};\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nlong long moving[1000] = {};\nint main() {\n#define int long long\n\tvector<pair<int, int>> inputs;\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tinputs.push_back(make_pair(a, b));\n\t}\n\tmoving[0] = 1;\n\tfor (int i = 1; i < 1000; ++i) {\n\t\tmoving[i] = moving[i - 1] * 2;\n\t\tmoving[i] %= MOD;\n\t}\n\tlong long ans = moving[n];\n\tlong long tmp = n + 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tvector<pair<tuple<long long, long long, long long>, int>> edges;\n\t\tfor (int q = i+1; q < n; ++q) {\n\t\t\tif (cnt[i][q] == 1) break;\n\t\t\tlong long A = inputs[q].second - inputs[i].second;\n\t\t\tlong long B = inputs[q].first - inputs[i].first;\n\t\t\tlong long C = (inputs[q].second - inputs[i].second) * inputs[i].first - (inputs[q].first - inputs[i].first) * inputs[i].second;\n\t\t\tlong long geko = gcd(llabs(A), llabs(B));\n\t\t\tgeko = gcd(geko, llabs(C));\n\t\t\tA /= geko;\n\t\t\tB /= geko;\n\t\t\tC /= geko;\n\t\t\tif (A < 0) {\n\t\t\t\tA = -A;\n\t\t\t\tB = -B;\n\t\t\t\tC = -C;\n\t\t\t}\n\t\t\tedges.push_back(make_pair(make_tuple(A, B, C), q));\n\t\t}\n\t\tsort(edges.begin(), edges.end());\n\t\tint back = 0;\n\t\tedges.push_back(make_pair(make_tuple(-1, 0, 0), -1));\n\t\tfor (int i = 1; i < edges.size(); ++i) {\n\t\t\tif (edges[i].first != edges[i - 1].first) {\n\t\t\t\tfor (int q = back; q < i; ++q) {\n\t\t\t\t\tfor (int j = q + 1; j < i; ++j) {\n\t\t\t\t\t\tcnt[q][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += moving[i - back + 1] - (i - back + 1) - 1;\n\t\t\t\ttmp += MOD;\n\t\t\t\ttmp %= MOD;\n\t\t\t\tback = i;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans + (MOD - tmp))%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <map>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <iterator>\n\n#define FOR(n) for(int i=0;i<(n);++i)\n#define FOR_R(it,cont) for(auto it=rbegin(cont);it!=rend(cont);++it)\n#define FOR_F(it,cont) for(auto it=begin(cont);it!=end(cont);++it)\n#define ALL(cont) begin(cont), end(cont)\n#define LB(b,e,v) lower_bound(b,e,v)\n#define UB(b,e,v) upper_bound(b,e,v)\n#define AS_MOD(a,b) ((((a) % (b) ) + (b)) % (b))\n#define MODDING(a,b) (a) = AS_MOD(a,b)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P, P> PP;\ntypedef long long ll;\nint N;\nlong long MOD=998244353;\ntypedef long long POW;\nPOW powlong(POW x, POW i) {\n  POW ret = 1;\n  POW temp = x;\n  while(i!=0) {\n    if (i&1) {\n      ret *= temp;\n      MODDING(ret,MOD);\n    }\n    temp *=temp;\n    MODDING(temp,MOD);\n    i = i>>1;\n  }\n  return ret;\n}\ntemplate<class T,int SIZE>struct Vector_{\n  T value[SIZE];\n  Vector_(){\n    for(int i=0;i<SIZE;++i)value[i]=0;\n  };\n  Vector_(T x,T y){value[0]=x;value[1]=y;};\n  Vector_(T x,T y,T z){value[0]=x;value[1]=y;value[2]=z;};\n  Vector_ operator-(const Vector_& rhs) {\n    Vector_ temp;\n    for(int i=0;i<SIZE;++i)temp.value[i]=value[i]-rhs.value[i];\n    return temp;\n  }\n  T dot(const Vector_& rhs) {\n    T temp=0;\n    for(int i=0;i<SIZE;++i)temp += value[i]*rhs.value[i];\n    return temp;\n  }\n  Vector_ getPerp2D() {\n    return Vector_(-value[1],value[0]);\n  }\n};\ntypedef Vector_<int,2> Vector;\nVector Points[200];\nbool sum[200][200];\nint main() {\n  scanf(\"%d\", &N);\n  for(int i=0;i<N;++i) {\n    int x,y;\n    scanf(\"%d%d\", &x, &y);\n    Points[i] = {x,y};\n  }\n  long long answer = powlong(2, N);\n  answer -= 1;\n  answer -= N;\n  for(int i=0;i<N;++i) {\n    for(int j=i+1;j<N;++j) {\n      int num=2;\n      for(int k=0;k<N;++k) {\n        if (k==j || k==i)continue;\n        Vector ang=Points[j]-Points[i];\n        Vector perp=ang.getPerp2D();\n        Vector to=Points[k]-Points[i];\n        if (to.dot(perp)==0) {\n          if (k<j) {\n            num=0;\n            break;\n          }\n          num++;\n        }\n      }\n      answer -= (powlong(2, num) - num - 1);\n      MODDING(answer, MOD);\n    }\n  }\n  printf(\"%lld\\n\",answer);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <utility>\n#include <cstdio>\n#include <set>\n#define MOD 998244353\n#define mp std::make_pair\ntypedef long long ll; \nint x[405], y[405], seq[405]; \nstd::set<std::pair<int, int> > se; \ninline bool comp(int a, int b)\n{\n\tif (x[a] == x[b])\n\t\treturn y[a] < y[b]; \n\treturn x[a] < x[b]; \n}\ninline bool same(int a, int b, int c)\n{\n\treturn (x[b] - x[a]) * (y[c] - y[a]) == (x[c] - x[a]) * (y[b] - y[a]); \n}\ninline int quick_pow(int a, int n)\n{\n\tint res = 1; \n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (ll)res * a % MOD; \n\t\ta = (ll)a * a % MOD; \n\t\tn >>= 1; \n\t}\n\treturn res; \n}\nint main()\n{\n\t// freopen(\"ARC082-E.in\", \"r\", stdin); \n\tint n; \n\tscanf(\"%d\", &n); \n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d%d\", x + i, y + i); \n\tint ans = (quick_pow(2, n) - n - 1 + MOD) % MOD; \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\tcontinue; \n\t\t\tint cnt = 0; \n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t{\n\t\t\t\tif (same(i, j, k))\n\t\t\t\t\tseq[cnt++] = k; \n\t\t\t}\n\t\t\tstd::sort(seq, seq + cnt, comp); \n\t\t\tse.insert(mp(seq[0], seq[1])); \n\t\t}\n\t}\n\tfor (auto line : se)\n\t{\n\t\tint cnt = 0; \n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (same(line.first, line.second, i))\n\t\t\t\tcnt++; \n\t\t}\n\t\tans = (ans - quick_pow(2, cnt) + cnt + 1 + MOD) % MOD; \n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\n#define ll long long\nconst int maxn = 1e5 + 100;\nconst int mod = 998244353;\n\nstruct point{\n    int x,y;\n}e[maxn];\n\nll ans=0;\n\nll pow_mod(ll a,ll b){\n    ll ret = 1;\n    while (b){\n        if(b&1) ret = ret*a%mod;\n        a = a*a%mod;\n        b >>=1;\n    }\n    return ret;\n}\n\nbool check(point a,point b,point c){\n    a.x-=c.x,a.y-=c.y;\n    b.x-=c.x,b.y-=c.y;\n    if(a.x*b.y-a.y*b.x==0)\n        return 1;\n    return 0;\n}\n\nint main() {\n   // freopen(\"input.txt\",\"r\",stdin);\n    int n;\n    cin>>n;\n    for (int i = 0; i < n; ++i) {\n        cin>>e[i].x>>e[i].y;\n    }\n    ans = pow_mod(2,n)-n-1;\n    //cout<<pow_mod(2,n)<<endl;\n    //cout<<ans<<endl;\n   // cout<<ans<<endl;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            int d=0;\n            for (int k = j+1; k < n; ++k) {\n                if(check(e[i],e[j],e[k]))\n                    d++;\n            }\n            ans = (ans -pow_mod(2,d)+mod)%mod;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct vec{\n    int x,y;\n    vec () {}\n    vec(int x,int y):x(x),y(y) {}\n    vec operator-(const vec &rhs)const {\n        return vec(x-rhs.x,y-rhs.y);\n    }\n    int cross(const vec &rhs)const {\n        return x*rhs.y-y*rhs.x;\n    }\n    bool operator<(const vec &rhs)const {\n        return x==rhs.x ? y<rhs. y : x<rhs.x;\n    }\n}arr[200];\nint n;\n\nint ccw(vec a,vec b){\n    int v=a.cross(b);\n    if(v>0) return 1;\n    else if(v==0) return 0;\n    else return -1;\n}\nint ccw(vec p,vec a,vec b) {\n    return ccw(a-p,b-p);\n}\n\nconst int MOD=998244353;\nint power(int a,int p) {\n    int ret=1;\n    while(p) {\n        if(p&1) ret=1ll*ret*a%MOD;\n        a=1ll*a*a%MOD;\n        p>>=1;\n    }\n    return ret;\n}\nint main() {\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++) scanf(\"%d%d\",&arr[i].x,&arr[i].y);\n\n    int ans=(power(2,n)-n-1+MOD)%MOD;\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++) if(i!=j && arr[i]<arr[j]) {\n        int cnt=2;\n        for(int k=0;k<n;k++) if(i!=k && j!=k && ccw(arr[i],arr[j],arr[k])==0) {\n            if(arr[k] < arr[i] || arr[k] < arr[j]) {\n                cnt=0;\n                break;\n            }\n            cnt++;\n        }\n        ans = (ans - (power(2,cnt)-cnt-1) + MOD)%MOD;\n    }\n    printf(\"%d\\n\",ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 998244353;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint x[205], y[205], pw[205];\n\nbool check( int i, int j, int k ) {\n\tif( y[i] > y[j] ) swap(i, j);\n\tif( y[k] < y[i] || y[k] > y[j] ) return false;\n\tif( x[i] > x[j] ) swap(i, j);\n\tif( x[k] < x[i] || x[k] > x[j] ) return false;\n\tint vx = x[k] - x[i], vy = y[k] - y[i];\n\tint wx = x[k] - x[j], wy = y[k] - y[j];\n\treturn vx*wy - vy*wx == 0;\n}\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) cin >> x[i] >> y[i];\n\n  pw[0] = 1;\n  FOR(i, 1, n+1) pw[i] = pw[i-1] * 2 % MOD;\n  int ret = (pw[n] - n + MOD) % MOD;\n  REP(i, n) FOR(j, i+1, n) {\n    int cnt = 0;\n    REP(k, n) if(k!=i && k!=j && check(i,j,k)) ++cnt;\n    ret = (ret - pw[cnt] + MOD) % MOD;\n  }\n  cout << (ret - 1 + MOD) % MOD << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int int64_t\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\twhile(a >= mod)\n\t\ta -= mod;\n\twhile(a < 0)\n\t\ta += mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) < norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[m][m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\ntypedef long long ll;\nint n,ans,x[501],y[501],pw[501];\nint main(){\n    scanf(\"%d\",&n);\n    pw[0]=1;\n    for(int i=1;i<=n;i++)pw[i]=(ll)pw[i-1]*2%mod;\n    for(int i=1;i<=n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n    ans=(pw[n]-n-1-n*(n-1)/2+mod)%mod;\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<=n;j++){\n            int tmp=0;\n            for(int k=j+1;k<=n;k++){\n                if((y[j]-y[i])*(x[k]-x[j])==(y[k]-y[j])*(x[j]-x[i]))tmp++;\n            }\n            ans=(ans+mod+1-pw[tmp])%mod;\n        }\n    }\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef pair<int,int> pa;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\nconst int N=1e5+5,M=5e7+5,INF=1e9,mod=998244353;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint n;\nstruct P{\n\tint x,y;\n\til P(){}\n\til P(int x,int y):x(x),y(y){}\n\til bool operator<(const P&o)const{if(x==o.x)return y<o.y;return x<o.x;}\n\til int operator*(const P&o)const{return x*o.y-y*o.x;}\n\til P operator-(const P&o)const{return P(x-o.x,y-o.y);}\n}p[N];\nll pw[N];\nil int bad(int i,int j,int k){\n\tif((p[j]-p[i])*(p[k]-p[i])==0)return 1;\n\treturn 0;\n}\nint main(){\n\tread(n);rep(i,1,n)read(p[i].x,p[i].y);\n\tpw[0]=1;rep(i,1,n)pw[i]=pw[i-1]*2%mod;\n\tsort(p+1,p+1+n);\n\tll qaq=0;\n\trep(i,1,n)rep(j,i+1,n){\n\t\tint ok=1;\n\t\trep(k,1,j)\n\t\t\tif(k!=i&&k!=j)\n\t\t\t\tif(bad(i,j,k))ok=0;\n\t\tif(ok){\n\t\t\tint res=2;\n\t\t\trep(k,j+1,n)res+=bad(i,j,k);\n\t\t\t(qaq+=pw[res]-res-1)%=mod;\n\t\t}\n\t}\n\tqaq=pw[n]-qaq-n-1;\n\tcout<<qaq<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Math = ♥\n// Sometimes it is people that no one imagines anything of who do things that no one can imagine\n// After all this time? Always\n\n#include <bits/stdc++.h>                        // uncomment before submission\n//#include <ext/pb_ds/assoc_container.hpp>\t\t// uncomment before submission\n//#include <ext/pb_ds/tree_policy.hpp>\t\t\t// uncomment before submission\n//using namespace __gnu_pbds;\t\t\t\t\t// uncomment before submission\nusing namespace std;\n//<---------------------------------------------------Template----------------------------------------------------------->\n#define int long long\n#define ll long long\n#define ld long double\nint INF = 1e9 + 7;\ntypedef pair<ll, ll> ii;\ntypedef vector<ll> vi;                  // Vector of long long\ntypedef vector<vi> vvi;                 // Vector of vi\ntypedef vector<ii> vii;                 // Vector of pairs\ntypedef vector<vii> vvii;               // Vector of Vector of pairs\ntypedef vector<bool> vb;                // Vector of bool\n#define pq priority_queue               // Max heap (To convert to min heap, use negative sign before every value)\n#define ff first                        // For pairs\n#define ss second                       // For pairs\n#define pb push_back                    // Pushback to vector\n#define mp make_pair                    // Makes pairs to be stored as pair\n#define all(c) (c).begin(), (c).end()   // Mainly used by me in sorting\n// ordered_set adds two new functions to set - (set).find_by_order([kth element based on zero indexing]) and order_of_key()\n// order_of_key returns number of elements less that parameter. If element exists, that order is its index\n#define ordered_set tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>\n//<----------------------------------------------------------------------------------------------------------------------->\n\nconst int MOD = 998244353;\nint n, cnt;\nint ans;\n\nint collinear(int w, int x, int y, int z)\n{\n    return w * z == x * y;\n}\n\nint pow(int x, int k)\n{\n    if (k < 0) return 0;\n    int res = 1;\n    while (k != 0)\n    {\n        if (k % 2 == 0)\n            res = res * x % MOD;\n        x = x * x % MOD;\n        k = k / 2;\n    }\n    return res;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    ii a[210];\n\n    cin >> n;\n\n    for (int i = 0; i < n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        a[i].ff = x, a[i].ss = y;\n    }\n\n    ans = pow(2, n) - 1 - n;\n    ans = (ans + MOD) % MOD;\n\n    for (int i = 0; i < n - 1; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            cnt = 0;\n            for (int k = j + 1; k < n; ++k)\n                cnt += collinear(a[i].ff - a[j].ff, a[j].ff - a[k].ff, a[i].ss - a[j].ss, a[j].ss - a[k].ss);\n            (ans = MOD + ans - pow(2, cnt)) %= MOD;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) scanf(\"%d%d\", &x[i], &y[i]);\n\n    constexpr int kMod = 998244353;\n    int ans = 1;\n    for (int i = 0; i < n; ++i) ans = (ans + ans) % kMod;\n    (ans += kMod - (n + 1)) %= kMod;\n\n    auto GetSlope = [&](int i, int j) {\n        int dx = x[i] - x[j], dy = y[i] - y[j];\n        if (dx == 0) return make_pair(0, 1);\n        if (dy == 0) return make_pair(1, 0);\n        int g = __gcd(abs(dx), abs(dy));\n        dx /= g, dy /= g;\n        if (dx < 0) dx = -dx, dy = -dy;\n        return make_pair(dx, dy);\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int cnt = 2;\n            auto s = GetSlope(i, j);\n            bool ok = true;\n            for (int k = 0; k < n; ++k) {\n                if (k == i || k == j) continue;\n                auto t = GetSlope(i, k);\n                if (s == t) {\n                    cnt++;\n                    ok &= k > j;\n                }\n            }\n            if (!ok) continue;\n            int v = 1;\n            for (int k = 0; k < cnt; ++k) v = (v + v) % kMod;\n            (v += kMod - (cnt + 1)) %= kMod;\n            (ans += kMod - v) %= kMod;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';\n\treturn !f?x:-x;\n}\n\nconst int N=200+19;\nconst int p=998244353;\n\nstruct Point{\n\tint x,y;\n\tbool operator < (const Point &B) const{\n\t\treturn x<B.x||x==B.x&&y<B.y;\n\t}\n} P[N],Pt;\ntypedef Point Vector;\n\nint dp[N][N],val[N][N],val2[N][N],pw2[N];\nint n,ans;\n\nVector operator - (Point A,Point B){\n\treturn (Vector){\n\t\tA.x-B.x,A.y-B.y\n\t};\n}\nll cross(Vector A,Vector B){\n\treturn 1ll*A.x*B.y-1ll*A.y*B.x;\n}\nbool cmp(Point A,Point B){\n\treturn cross(A-Pt,B-Pt)>0;\n}\n\nvoid Work(vector<Point> V){\n\tint n=V.size();\n\tmemset(dp,0,sizeof(dp));\n\tmemset(val,0,sizeof(val));\n\tmemset(val2,0,sizeof(val2));\n\tsort(V.begin()+1,V.end(),cmp);\n\tFor(i,1,n) For(j,i+1,n){\n\t\tFor(k,1,n) if (k!=i&&k!=j&&cross(V[i]-V[0],V[k]-V[0])>=0&&cross(V[j]-V[i],V[k]-V[i])>=0){\n\t\t\tll tmp=cross(V[k]-V[0],V[j]-V[0]);\n\t\t\tif (tmp>0) val[i][j]++;\n\t\t\tlf (tmp==0) val2[i][j]++;\n\t\t}\n\t\tval[i][j]=pw2[val[i][j]];\n\t\tval2[i][j]=pw2[val2[i][j]];\n\t}\n\tFor(i,1,n) dp[0][i]=1;\n\tFor(i,0,n) For(j,i+1,n) if (dp[i][j]){\n\t\tFor(k,j+1,n) if (cross(V[j]-V[i],V[k]-V[j])>0){\n\t\t\tdp[j][k]=(dp[j][k]+1ll*val[j][k]*dp[i][j])%p;\n\t\t}\n\t}\n\tFor(i,1,n) For(j,i+1,n)\n\t\tif (cross(V[j]-V[i],V[0]-V[j])>0){\n\t\t\tans=(ans+1ll*val2[i][j]*dp[i][j])%p;\n\t\t}\n}\n\nint main(){\n\tpw2[0]=1;\n\tFor(i,1,N) pw2[i]=2ll*pw2[i-1]%p;\n\tn=IN();\n\tFor(i,1,n+1) P[i]=(Point){IN(),IN()};\n\tsort(P+1,P+n+1);\n\tFor(i,1,n+1){\n\t\tPt=P[i];\n\t\tvector<Point> V;\n\t\tFor(j,i,n+1) V.pb(P[j]);\n\t\tWork(V);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,x[205],y[205],mod=998244353;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tlong long ans=1ll*((1<<n)%mod-1-n-(n-1)*n/2%mod+mod)%mod;\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",x+i,y+i);\n\tfor(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++){\n\t\tint tot=0;\n\t\tfor(int k=j+1;k<=n;k++) if((y[i]-y[j])*(x[j]-x[k])==(x[i]-x[j])*(y[j]-y[k])) tot++;\n\t\tans=1ll*(ans-(1<<tot)+mod+1)%mod;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 100010\ntypedef long long LL;\nusing namespace std;\nconst LL mod = 998244353;\nLL x[maxn], y[maxn], P[maxn];\nint fa[maxn], sz[maxn];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nvoid unionn(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return;\n    if (sz[x] > sz[y]) swap(x, y);\n    fa[x] = y; sz[y] += sz[x];\n}\nstruct node { int p, q; LL dx, dy; };\nbool cmp(node u, node v) { return u.dx < v.dx || (u.dx == v.dx && u.dy < v.dy); }\nvector<node> seg;\nLL GCD(LL x, LL y) { return y ? GCD(y, x % y) : x; }\nint main() {\n    LL n;\n    scanf(\"%lld\", &n);\n    for (int i = 0; i < n; ++i) scanf(\"%lld%lld\", &x[i], &y[i]);\n    P[0] = 1;\n    for (int i = 1; i <= n; ++i) (P[i] = P[i-1] << 1) %= mod;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            LL dx = x[i]-x[j], dy = y[i]-y[j];\n            LL gcd = GCD(dx, dy);\n            dx /= gcd, dy /= gcd;\n            if (dx < 0) dx = -dx, dy = -dy;\n            seg.push_back(node{i, j, dx, dy});\n        }\n    }\n    sort(seg.begin(), seg.end(), cmp);\n\n    LL ans = P[n] - 1 - n;\n    int i = 0, j = 0;\n    for (; i < seg.size(); i = j+1) {\n        for (int k = 0; k < n; ++k) fa[k] = k, sz[k] = 1;\n        for (j = i; ; ++j) {\n            unionn(seg[j].p, seg[j].q);\n            if (j+1 >= seg.size() || seg[i].dx != seg[j+1].dx || seg[i].dy != seg[j+1].dy) break;\n        }\n        for (int k = 0; k < n; ++k) {\n            if (fa[k] == k) ((ans -= (P[sz[k]] - sz[k] - 1)) += mod) %= mod;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iostream>\n#include <ios>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) < norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[m][m] = {0};\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed sig) {\n    x = sig;\n    while(x < 0) x += MOD;\n    while(x >= MOD) x -= MOD;\n  }\n  unsigned get() const { return x; }\n\n  // 累乗\n  ModInt binpow(ModInt y, ModInt e) {\n    ModInt a = 1, p = y;\n    while(e>0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; --e;}\n    }\n    a %= MOD; x = a.get();\n    return a;\n  }\n  ModInt binpow(ll y, ll e) {\n    ModInt a = 1, p = y;\n    while(e>0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; --e;}\n    }\n    a %= MOD; x = a.get();\n    return a;\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // 代入\n  void operator=(ll b) { x = b; }\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  // ModInt and ModInt\n  ModInt &operator+=(ModInt that) {\n    x = ((unsigned long long)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((unsigned long long)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (unsigned long long)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (unsigned long long)x * that.binpow(that.x, MOD-2) % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (unsigned long long)x % that.x;\n    return *this;\n  }\n  // ModInt and long long\n  ModInt &operator+=(ll that) {\n    x = ((unsigned long long)x+that)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ll that) {\n    x = ((((unsigned long long)x-that)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ll that) {\n    x = (unsigned long long)x * that % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ll that) {\n    x = (unsigned long long)x * binpow(that, MOD-2).x % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ll that) {\n    x = (unsigned long long)x % that;\n    return *this;\n  }\n  // ModInt and ModInt\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n  // ModInt and ll\n  ModInt operator+(ll that)const{return ModInt(*this) += that;}\n  ModInt operator-(ll that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ll that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ll that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ll that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) {\n  os << a.x;\n  return os;\n}\nistream &operator>>(istream& is, mint &a) {\n  is >> a.x;\n  return is;\n}\n\nint x[205], y[205];\nbool check(int i, int j, int k) {\n\tif( y[i] > y[j] ) swap(i, j);\n\tif( y[k] < y[i] || y[k] > y[j] ) return false;\n\tif( x[i] > x[j] ) swap(i, j);\n\tif( x[k] < x[i] || x[k] > x[j] ) return false;\n\tint vx = x[k] - x[i], vy = y[k] - y[i];\n\tint wx = x[k] - x[j], wy = y[k] - y[j];\n\treturn vx*wy - vy*wx == 0;\n}\n\nmint pw[205];\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) cin >> x[i] >> y[i];\n\n  pw[0] = 1;\n  FOR(i, 1, n+1) pw[i] = pw[i-1]*2;\n  // REP(i, n+1) cout << pw[i] << \" \"; cout << endl;\n\n  // cout << pw[n] - n - 1 << endl;\n  mint ret(pw[n]-n-1);\n  // cout << ret << endl;\n  REP(i, n) {\n    FOR(j, i+1, n) {\n      int cnt = 0;\n      REP(k, n) {\n        if(k != i && k != j && check(i, j, k)) ++cnt;\n      }\n      ret -= pw[cnt];\n      // cout << i << \" \" << j << \" \" << cnt << \" \" << ret << endl;\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define ll long long\nusing namespace std;\nconst int mod=998244353;\nint n,st[210],top;\nbool vis[210][210];\nll ans,cpow[210];\nstruct pt\n{\n\tint x,y;\n}a[210];\nbool check(int p,int q,int r)\n{\n\tif(abs(a[p].x-a[q].x)*abs(a[q].y-a[r].y)==abs(a[q].x-a[r].x)*abs(a[p].y-a[q].y)) return 1;\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tcpow[0]=1;\n\tfor(int i=1;i<=n;i++) cpow[i]=(cpow[i-1]<<1)%mod;\n\tans=cpow[n];\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=i-1;j++)\n\t\t\tif(!vis[i][j])\n\t\t\t{\n\t\t\t\ttop=2;st[1]=i;st[2]=j;\n\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\tif(k!=i&&k!=j&&check(i,j,k)) st[++top]=k;\n\t\t\t\tans=(ans-cpow[top]+top+1+mod*2)%mod;\t\n\t\t\t\tfor(int k=1;k<=top;k++)\n\t\t\t\t\tfor(int l=1;l<=k-1;l++)\n\t\t\t\t\t\tvis[st[k]][st[l]]=vis[st[l]][st[k]]=1;\n\t\t\t}\n\tans=(ans-n-1+mod)%mod;\n\tprintf(\"%lld\",ans);\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/** @Date    : 2017-09-02 20:30:47\n  * @FileName: C.cpp\n  * @Platform: Windows\n  * @Author  : Lweleth (SoungEarlf@gmail.com)\n  * @Link    : https://github.com/\n  * @Version : $Id$\n  */\n#include <bits/stdc++.h>\n#define LL long long\n#define PII pair<int ,int>\n#define MP(x, y) make_pair((x),(y))\n#define fi first\n#define se second\n#define PB(x) push_back((x))\n#define MMG(x) memset((x), -1,sizeof(x))\n#define MMF(x) memset((x),0,sizeof(x))\n#define MMI(x) memset((x), INF, sizeof(x))\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 210;\nconst double eps = 1e-6;\nconst LL mod = 998244353;\n\nLL fa[210], inv[210];\n\nLL fpow(LL a, LL n)\n{\n    LL r = 1LL;\n    while(n > 0)\n    {\n        if(n & 1)\n            r = r * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return r;\n}\n\nvoid init()\n{\n    fa[0] = 1;\n    inv[0] = 1;\n    for(LL i = 1; i <= 200; i++)\n    {\n        fa[i] = fa[i-1] * i % mod;\n        inv[i] = fpow(fa[i], mod - 2);\n    }\n}\n\nLL C(LL n, LL m)\n{\n    if(n < 0)\n        return 0;\n    n >>= 1;\n    if(n == 0)\n    \treturn 1LL;\n    LL ans = 0;\n    ans = ((fa[n + m] * inv[m] % mod)* inv[n]) % mod;\n    return ans;\n}\n\n\nstruct point\n{\n\tdouble x, y;\n\tpoint(){}\n\tpoint(double _x, double _y){x = _x, y = _y;}\n\tpoint operator -(const point &b) const\n\t{\n\t\treturn point(x - b.x, y - b.y);\n\t}\n\tdouble operator *(const point &b) const \n\t{\n\t\treturn x * b.x + y * b.y;\n\t}\n\tdouble operator ^(const point &b) const\n\t{\n\t\treturn x * b.y - y * b.x;\n\t}\n\tbool operator == (const point &b) const\n\t{\n\t\treturn x==b.x && y==b.y;\n\t}\n\t\n};\n\ndouble xmult(point p1, point p2, point p0)  \n{  \n    return (p1 - p0) ^ (p2 - p0);  \n}  \n\ndouble distc(point a, point b)\n{\n\treturn sqrt((double)((b - a) * (b - a)));\n}\nint sign(double x)\n{\n\tif(fabs(x) < eps)\n\t\treturn 0;\n\tif(x < 0)\n\t\treturn -1;\n\telse \n\t\treturn 1;\n}\n\nstruct line\n{\n\tpoint s, t;\n\tline(){}\n\tline(point ss, point tt){\n\t\ts = ss, t = tt;\n\t}\n};\n\n////////\nint n;\npoint stk[N];\npoint p[N];\n\nint cmpC(point a, point b)//水平序排序\n{\n\treturn sign(a.x - b.x) < 0 || (sign(a.x - b.x) == 0 && sign(a.y - b.y) < 0);\n}\n\nint Graham()//水平序\n{\n\tsort(p, p + n, cmpC);\n\tint top = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\twhile(top >= 2 && sign(xmult(stk[top - 2], stk[top - 1], p[i])) < 0)\n\t\t\ttop--;\n\t\tstk[top++] = p[i];\n\t}\n\tint tmp = top;\n\tfor(int i = n - 2; i >= 0; i--)\n\t{\n\t\twhile(top > tmp && sign(xmult(stk[top - 2],stk[top - 1] ,p[i] )) < 0)\n\t\t\ttop--;\n\t\tstk[top++] = p[i];\n\t}\n\tif(n > 1)\n\t\ttop--;\n\treturn top;\n}\n\n\nLL check(int m)\n{\n\t//cout << m << endl;\n\tLL c = 2;\n\tLL t = 0;\n\tfor(int i = 1; i < m; i++)\n\t{\n\t\tif(sign(xmult(stk[i - 1], stk[(i + 1)%(m)], stk[i])) == 0)\n\t\t\tc++;\n\t\telse t = (t + fpow(2, c) - (1LL + c + c * (c - 1) / 2LL) + mod) % mod, c = 2;\n\t\t//cout << c << endl;\n\t}\n\tif(c > 2)\n\t\t t = (t + fpow(2, c) - (1LL + c + c * (c - 1) / 2LL) + mod) % mod;\n\treturn t;\n}\n\n/////////\nint main()\n{\n\n\twhile(~scanf(\"%d\", &n))\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tp[i] = point(x, y);\n\t\t}\n\t\tLL ans = 0;\n\t\tLL cnt = Graham();\n\t\t//cout << cnt;\n\t\t//ans = (fpow(2, n) - check(cnt) - (1LL + n + (n - 1) * n / 2LL) + mod) % mod;\n\t\tans = (fpow(2, n) - (1LL + n) + mod) % mod;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tmap<LL, int>q;\n\t\t\tfor(int j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tLL t;\n\t\t\t\tif(p[i].x == p[j].x)\n\t\t\t\t\tt = -1;\n\t\t\t\telse t = ((LL)(p[j].y - p[i].y) * fpow(p[j].x - p[i].x, mod - 2) % mod + mod ) % mod;\n\t\t\t\t\tq[t]++;\n\t\t\t}\n\t\t\tfor(auto j : q)\n\t\t\t{\n\t\t\t\tans -= fpow(2, j.se) - 1;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t\twhile(ans < 0)\n\t\t\tans += mod;\n\t\tif(cnt > 2)\n\t\t\tprintf(\"%lld\\n\", ans);\n\t\telse printf(\"0\\n\");\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n\nusing namespace std;\n\nint powers2[201], x[200], y[200];\n\nint main() {\n  powers2[0] = 1;\n  for (int i = 1; i <= 200; i++) powers2[i] = powers2[i - 1] * 2 % MOD;\n\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d %d\", &x[i], &y[i]);\n  \n  int res = powers2[n];\n  res -= 1 + n + n * (n - 1) / 2;\n  res %= MOD;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int counter = 2;\n      int a = y[j] - y[i];\n      int b = x[i] - x[j];\n      int c = -a * x[i] - b * y[i];\n      for (int k = 0; k < n; k++) {\n        if (k == i || k == j) continue;\n        if (a * x[k] + b * y[k] + c != 0) continue;\n        if (k < j) break;\n        counter++;\n      }\n      res -= powers2[counter];\n      res += 1 + counter + counter * (counter - 1) / 2;\n      res %= MOD;\n    }\n  }\n  printf(\"%d\\n\", (res % MOD + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint vis[210][210]; \nint area(pair<int,int>a,pair<int,int>b,pair<int,int>c)\n{\n\treturn a.first*b.second+b.first*c.second+c.first*a.second-a.second*b.first-b.second*c.first-c.second*a.first;\n}\nint n;\nint ans;\npair<int,int>co[210];\nint pw[210];\nconst int md=998244353;\nint add(int x,int y)\n{\n\tx+=y;\n\tif(x>=md)x-=md;\n\treturn x;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++)pw[i]=add(pw[i-1],pw[i-1]);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&co[i].first,&co[i].second);\n\tans=pw[n]-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans--;\n\t\tif(ans<0)ans+=md;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif(vis[i][j])continue;\n\t\t\tint cnt=1;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(area(co[i],co[j],co[k]))continue;\n\t\t\t\tcnt++;\n\t\t\t\tvis[i][k]=true;\n\t\t\t}\n\t\t\tans-=pw[cnt]-1;\n\t\t\tif(ans<0)ans+=md; \n\t\t}\n\t} \n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\nconst int N=205;\nconst int MOD=998244353;\nint n;\nint x[N],y[N];\nint Pow[N];\nint mul (int a,int b,int c)\n{\n\tint x_1=x[a]-x[c],y_1=y[a]-y[c];\n\tint x_2=x[b]-x[c],y_2=y[b]-y[c];\n\treturn x_1*y_2-x_2*y_1;\n}\nbool check (int x,int y)\n{\n\tfor (int u=1;u<y;u++)\n\t{\n\t\tif (u==x) continue;\n\t\tif (mul(x,y,u)==0)\t\n\t\t{\n\t\t//\tprintf(\"NO:%d %d %d\\n\",x,y,u);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint dec (int x,int y)\t{x=x-y;return x<0?x+MOD:x;}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tPow[0]=1;for (int u=1;u<=n;u++) Pow[u]=Pow[u-1]*2%MOD;\n\tfor (int u=1;u<=n;u++) scanf(\"%d%d\",&x[u],&y[u]);\n\tint ans=dec(Pow[n],n+1);\n\tfor (int u=1;u<=n;u++)\n\t\tfor (int i=u+1;i<=n;i++)\n\t\t\tif (check(u,i))//这条线有没有枚举过\n\t\t\t{\n\t\t\t//\tprintf(\"YES:%d %d\\n\",u,i);\n\t\t\t\tint cnt=2;\n\t\t\t\tfor (int j=i+1;j<=n;j++) cnt=cnt+(mul(u,i,j)==0);\n\t\t\t\tans=dec(ans,dec(Pow[cnt],cnt+1));\n\t\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct pnt{\n\tint x,y;\n\tpnt(){}\n\tpnt(int _x,int _y){\n\t\tx=_x;y=_y;\n\t}\n};\nbool operator <(pnt x,pnt y){\n\treturn x.x < y.x || x.x == y.x && x.y<y.y;\n}\npnt operator-(pnt x,pnt y){\n\treturn pnt(x.x-y.x,x.y-y.y);\n}\nint operator*(pnt x,pnt y){\n\treturn x.x*y.y-x.y*y.x;\n}\nint n;\npnt a[222];\n#define mod 998244353\nint add(int x,int y){\n\treturn (x+y)%mod;\n}\nint sub(int x,int y){\n\treturn add(x,mod-y);\n}\nint p2[222];\nint main(){\n\tscanf(\"%d\",&n);\n\tp2[0] = 1;\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tp2[i+1]=add(p2[i],p2[i]);\n\t}\n\tint res = p2[n];\n\tres = sub(res, 1);\n\tres = sub(res, n);\n\tres = sub(res, n*(n-1)/2);\n\tfor(int i=0; i<n; i++)for(int j=0; j<n; j++)\n\t\tif(a[i] < a[j]){\n\t\t\tint w = 0;\n\t\t\tfor(int k=0; k<n; k++)\n\t\t\tif(a[i] < a[k] && a[j] < a[k] && (a[j]-a[i])*(a[k]-a[i]) == 0)\n\t\t\t\tw++;\n\t\t\tres = sub(res, sub(p2[w],1));\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxn=205;\nll x[maxn],y[maxn];\nconst ll mod=998244353;\n\nll power_mod(ll a,ll b){\n\tll ans=1;\n\ta%=mod;\n\twhile(b){\n\t\tif(b&1) ans=(ans*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\nll gcd(ll a,ll b){\n\treturn b==0?a:gcd(b,a%b);\n}\nmap<pair<ll,ll>,ll>a;\n\nint main(int argc, char const *argv[])\n{\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile(cin>>n){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tcin>>x[i]>>y[i];\n\t\tll ans=(power_mod(2,n)-1LL-n+mod)%mod;\n\t\tll tmp1,tmp2,tmp;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta.clear();\n\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\ttmp1=x[i]-x[j];\n\t\t\t\ttmp2=y[i]-y[j];\n\t\t\t\ttmp=gcd(tmp1,tmp2);\n\t\t\t\ttmp1/=tmp,tmp2/=tmp;\n\t\t\t\ta[make_pair(tmp1,tmp2)]++;\n\t\t\t}\n\t\t\tfor(auto iter:a){\n\t\t\t\tll temp=(power_mod(2,iter.second)-1+mod)%mod;\n\t\t\t\tans=(ans-temp+mod)%mod;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) > 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\nint adds[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<point> ns;\n        for (int j = 0; j < n; j++) {\n            if (j == i) {\n                continue;\n            }\n            if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {\n                need[j] = true;\n                ns.push_back(p[j]);\n            } else {\n                need[j] = false;\n            }\n        }\n        cur = p[i];\n        sort(all(ns), comp);\n        for (int j = 0; j < sz(ns); j++) {\n            adds[j] = 0;\n            for (int k = 0; k < sz(ns); k++) {\n                if (vec(ns[k] - p[i], ns[j] - p[i]) == 0 && (ns[k].x - p[i].x) * (ns[k].y - p[i].y) < (ns[j].x - p[i].x) * (ns[j].y - p[i].y)) {\n                    adds[j]++;\n                }\n            }\n            for (int k = j + 1; k < sz(ns); k++) {\n                goods[j][k] = false;\n                cnt[j][k] = 0;\n                dp[j][k] = 0;\n                if (good(p[i], ns[j], ns[k])) {\n                    goods[j][k] = true;\n                    for (int g = j + 1; g < k; g++) {\n                        if (vec(ns[k] - p[i], ns[g] - p[i]) != 0 && vec(ns[j] - p[i], ns[g] - p[i]) != 0 && inside(p[i], ns[j], ns[k], ns[g])) {\n                            cnt[j][k]++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (goods[j][k]) {\n                    dp[j][k] += st[cnt[j][k] + adds[j] + adds[k]];\n                    dp[j][k] %= Mod;\n                    ans += dp[j][k];\n                    ans %= Mod;\n                    for (int nxt = k + 1; nxt < sz(ns); nxt++) {\n                        if (vec(ns[nxt] - ns[j], ns[k] - ns[j]) < 0 && goods[k][nxt] && vec(ns[nxt] - p[i], ns[k] - p[i]) != 0) {\n                            dp[k][nxt] += (1LL * dp[j][k] * st[cnt[k][nxt] - adds[k] + adds[nxt]]) % Mod;\n                            dp[k][nxt] %= Mod;\n                        }\n                    }\n                }   \n            }\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 998244353\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll ruijo(ll x,ll n){\n\tlong long p,ans;\n\tif(n==0)return 1;\n\tif(n==1)return x;\n\tif(n%2){\n\t\tp = ruijo(x,n/2);\n\t\tans = (x*p)%mod;\n\t\tans = (ans*p)%mod;\n\t\treturn ans;\n\t}else{\n\t\tp = ruijo(x,n/2);\n\t\tans = (p*p)%mod;\n\t\treturn ans;\n\t}\n}\n\nint main(){\n    int n;\n    cin >> n;\n    if(n<=2){\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<int> x(n),y(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n    }\n    bool flag[210][210]={};\n    vector<int> c;\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            vector<int> p;\n            if(flag[i][j])continue;\n            p.push_back(i);\n            p.push_back(j);\n            for(int k=j+1;k<n;k++){\n                if((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j])){\n                    p.push_back(k);\n                }\n            }\n            for(int s=0;s<p.size();s++){\n                for(int t = s+1;t<p.size();t++){\n                    flag[s][t] = 1;\n                }\n            }\n            c.push_back(p.size());\n        }\n    }\n    ll res = ruijo(2,n);\n    res += mod-1-n;\n    res %= mod;\n    for(int x:c){\n        res += 2*mod - (ruijo(2,x)-x-1);\n        res %= mod;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\nconst int N = 203, mod = 998244353;\nint n, x[N], y[N], fac[N], inv[N], po[N], ans;\ninline int sub(int a, int b){int c = a - b; if(c < 0) c += mod; return c;}\ninline int add(int a, int b){int c = a + b; if(c >= mod) c -= mod; return c;}\ninline void upd(int &a, int b){a += b; if(a >= mod) a -= mod;}\ninline int kasumi(int a, int b){\n\tint res = 1;\n\twhile(b){\n\t\tif(b & 1) res = (LL) res * a % mod;\n\t\ta = (LL) a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\ninline bool check(int i, int j, int k){\n\treturn (x[j] - x[i]) * (y[k] - y[i]) == (x[k] - x[i]) * (y[j] - y[i]);\n}\nint main(){\n\tscanf(\"%d\", &n); ans = n + 1;\n\tfac[0] = po[0] = 1;\n\tfor(Rint i = 1;i <= n;i ++) fac[i] = (LL) i * fac[i - 1] % mod, po[i] = add(po[i - 1], po[i - 1]);\n\tinv[n] = kasumi(fac[n], mod - 2);\n\tfor(Rint i = n;i;i --) inv[i - 1] = (LL) inv[i] * i % mod;\n\tfor(Rint i = 1;i <= n;i ++) scanf(\"%d %d\", x + i, y + i);\n\tfor(Rint i = 1;i <= n;i ++)\n\t\tfor(Rint j = i + 1;j <= n;j ++){\n\t\t\tint sum = 0;\n\t\t\tfor(Rint k = 1;k <= n;k ++) sum += check(i, j, k);\n\t\t\tupd(ans, (LL) (po[sum] - sum - 1) * fac[sum - 2] % mod * inv[sum] % mod * 2ll % mod);\n\t\t}\n\tprintf(\"%d\\n\", sub(po[n], ans));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<stdio.h>\n#include<queue>\n#define x first\n#define y second\nusing namespace std;\nconst int mod=998244353;\nint N;\ntypedef pair<int,int> Pair;\nPair pos[205];\nint x[205],y[205],power[205];\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tint ans=0;\n\tpower[0]=1;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tpower[i+1]=(power[i]*2+mod)%mod;\n\t}\n\tans=power[N]-N-1;\n\n\tfor(int i=0;i<N;i++)\n\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<j;k++)\n\t\t\tif((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))\n\t\t\tcnt++;\n\t\t\tans=(ans-power[cnt]+mod)%mod;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <string>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <random>\n#include <chrono>\nusing namespace std;\n\nint n;\nconst int maxn = 205;\n\nstruct P{\n    int x, y;\n    P(){}\n    P(int _x, int _y):x(_x), y(_y){}\n    P operator - (P p){return P(x-p.x, y-p.y);}\n    int det(P p){return x * p.y - y * p.x;}\n    void read(){\n        cin >> x >> y;\n    }\n}p[maxn], p1[maxn];\n\nconst int mod = 998244353;\n\nbool cmp(P a, P b){\n    return a.det(b) < 0; \n}\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nvoid sub(int &a, int b){\n    a -= b;\n    if(a < 0)\n        a += mod;\n}\n\nint qpow(int a, int n){\n    int ret = 1;\n    while(n > 0){\n        if(n & 1)\n            ret = 1LL * ret * a % mod;\n        a = 1LL * a * a % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint main(){\n    cin >> n;\n    for(int i = 1;i <= n;i++){\n        p[i].read();\n    }\n    int ans = qpow(2, n);\n    sub(ans, 1);\n    sub(ans, n);\n    sub(ans, n * (n - 1) / 2);\n    for(int i = 1;i <= n;i++){\n        int cnt = n - i;\n        for(int j = i + 1;j <= n;j++){\n            p1[j - i] = p[j] - p[i];\n            if(p1[j].x < 0){\n                p1[j].x = -p1[j].x;\n                p1[j].y = -p1[j].y;\n            }\n            if(p1[j].x == 0 and p1[j].y < 0){\n                p1[j].y = -p1[j].y;\n            }\n        }\n        sort(p1 + 1, p1 + 1 + cnt, cmp);\n        for(int j = 1, k = 1;j <= cnt;j = k + 1, k = j){\n            while(k < cnt and p1[j].det(p1[k + 1]) == 0){\n                k++;\n            }\n            for(int l = j;l < k;l++){\n                int len = k - l;\n                int tmp = qpow(2, len);\n                sub(tmp, 1);\n                sub(ans, tmp);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define repr(i,b,e) for(int i = (b); i <= (e); i++)\n#define INF (1001001001)\n#define EPS (1e-15)\n\n#define pr(x) do{cerr << (#x) << \" = \" << (x) << endl;}while(0)\n#define pri(x,i) do{cerr << (#x) << \"[\" << i << \"] = \" << (x[i]) << endl;}while(0)\n#define pra(x,n) rep(__i,n) pri(x,__i);\n#define prar(x,b,e) repr(__i,b,e) pri(x,__i);\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n\nll MOD = 998244353;\n\nint in() {\n\tint a;\n\tscanf(\"%d \", &a);\n\treturn a;\n}\n\nint main() {\n\tint N = in();\n\ttypedef complex<double> P;\n\tvector<P> a(N);\n\trep(i,N) {\n\t\ta[i].real() = in();\n\t\ta[i].imag() = in();\n\t}\n\t\n\tvector<ll> twop(220);\n\ttwop[0] = 1;\n\trepr(i,1,210)twop[i] = twop[i-1] * 2 % MOD;\n\t\n\tvector<ll> hoge(220);\n\trep(i,210) {\n\t\tif (i < 3) hoge[i] = 0;\n\t\telse hoge[i] = (twop[i] - 1 - i - i * (i - 1) / 2 + MOD) % MOD;\n\t}\n\t\n\tvint cnt(N+10);\n\trep(p,N) {\n\t\tvint found(N);\n\t\trepr(q,p+1,N-1) {\n\t\t\tP l = a[q] - a[p];\n\t\t\tint temp = 2;\n\t\t\trepr(r,q+1,N-1) {\n\t\t\t\tif (found[r]) continue;\n\t\t\t\tP m = a[r] - a[p];\n\t\t\t\tif (l.imag() * m.real() == l.real() * m.imag()) {\n\t\t\t\t\ttemp++;\n\t\t\t\t\tfound[r] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (temp >= 3) {\n\t\t\t\tcnt[temp]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 3; i < 10; i++) pri(cnt, i);\n\tfor (int i = 200; i >= 3; i--) {\n\t\tfor (int k = i - 1; k >= 3; k--) {\n\t\t\tcnt[k] -= cnt[i];\n\t\t}\n\t}\n\tfor (int i = 3; i < 10; i++) pri(cnt, i);\n\t\n\tll ans = hoge[N];\n\tfor (int i = N - 1; i >= 3; i--) {\n\t\tans = (ans - cnt[i] * hoge[i]);\n\t\twhile (ans < 0) ans += MOD;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PII pair<LL,LL>\n#define fi first\n#define se second\n#define lowbit(x) ((x)&(-(x)))\n#define FOR(i,a,b) for (LL i=(a);i<=(b);++i)\n#define ROF(i,b,a) for (LL i=(b);i>=(a);--i)\ntypedef long long LL;\ninline LL read(){\n\tLL x=0,f=1; char ch=getchar();\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\twhile (ch>='0'&&ch<='9') { x=x*10+ch-'0'; ch=getchar(); }\n\treturn x*f;\n}\n\nconst LL MAXN=300005,Mo=998244353;\nstruct list{\n\tLL l,lt[MAXN],nt[MAXN*2],x[MAXN*2],y[MAXN*2];\n\tvoid clear(){ l=0; memset(lt,0,sizeof(lt)); }\n\tvoid addedge(LL a,LL b){ l++; nt[l]=lt[a]; lt[a]=l; x[l]=b; }\n}E;\nstruct P{\n\tLL x,y;\n\tP(LL xx=0,LL yy=0):x(xx),y(yy){}\n\tP operator +(const P &E)const{ return P(x+E.x,y+E.y); }\n\tP operator -(const P &E)const{ return P(x-E.x,y-E.y); }\n\tLL operator *(const P &E)const{ return x*E.y-E.x*y; }\n\tLL operator ^(const P &E)const{ return x*E.x+y*E.y; }\n}A[MAXN],B[MAXN];\nLL n,m,a[MAXN],b[MAXN];\nLL power(LL a,LL b){\n\tLL c=1; a%=Mo;\n\twhile (b) {\n\t\tif (b&1) c=1LL*c*a%Mo;\n\t\ta=1LL*a*a%Mo; b>>=1;\n\t}\n\treturn c;\n}\nLL cmp(P i,P j){ return i*j<0; }\nint main(){\n\tn=read();\n\tFOR(i,1,n) a[i]=power(i,Mo-2);\n\tFOR(i,1,n) { A[i].x=read(); A[i].y=read(); }\n\tLL tmp,ans=power(2,n)-n-1;\n\tif (ans<0) ans+=Mo; else if (ans>=Mo) ans-=Mo;\n\t//cout<<ans<<endl;\n\tFOR(i,1,n) {\n\t\tFOR(j,1,i-1) B[j]=A[j]-A[i];\n\t\tFOR(j,i+1,n) B[j-1]=A[j]-A[i];\n\t\tFOR(j,1,n-1) if (B[j].x<0) B[j].x=-B[j].x,B[j].y=-B[j].y;\n\t\tsort(B+1,B+n,cmp);\n\t\t//cout<<i<<':';\n\t\tfor (LL j=1,k,tot;j<n;j=k+1) {\n\t\t\tfor (k=j;k<n-1&&B[k+1]*B[j]==0;++k);\n\t\t\ttot=k-j+2;\n\t\t\ttmp=1LL*(power(2,tot)-tot-1)*a[tot]%Mo;\n\t\t\tif (tmp<0) tmp+=Mo; else if (tmp>=Mo) tmp-=Mo;\n\t\t\t//cout<<tmp<<',';\n\t\t\tans-=tmp;\n\t\t\tif (ans<0) ans+=Mo; else if (ans>=Mo) ans-=Mo;\n\t\t}\n\t\t//cout<<endl;\n\t}\n\tcout<<(ans%Mo+Mo)%Mo<<endl;\n\treturn 0;\n}\n\n/*\n4\n0 0\n0 1\n1 0\n1 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long> > vvll;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _rep(i,n) _rep2((i),0,(n))\n#define _rep2(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(...) GET_MACRO(__VA_ARGS__, _rep2, _rep)(__VA_ARGS__)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 998244353LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\n// Mod int\n// const int MOD = 1000000007;\nstruct mint{\n    ll x;\n    mint():x(0){}\n    mint(ll x):x((x%MOD+MOD)%MOD){}\n    mint operator+=(const mint& a){ if((x+=a.x)>=MOD) x-=MOD; return *this;}\n    mint operator-=(const mint& a){ if((x+=MOD-a.x)>=MOD) x-=MOD; return *this;}\n    mint operator*=(const mint& a){ (x*=a.x)%=MOD; return *this;}\n    mint operator+(const mint& a)const{ return mint(*this) += a;}\n    mint operator-(const mint& a)const{ return mint(*this) -= a;}\n    mint operator*(const mint& a)const{ return mint(*this) *= a;}\n    bool operator==(const mint& a)const{ return x == a.x;}\n    friend ostream& operator<<(ostream& os, const mint& mi)  \n    {  \n        os << mi.x;  \n        return os;  \n    }\n};\n\n\nmint comb[300][300];\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tvector<pii> v(n);\n\trep(i,n){\n\t\tcin>>v[i].fi>>v[i].se;\n\t}\n\trep(i,300){\n\t\tcomb[i][0] = comb[i][i] = mint(1);\n\t\trep(j,i-1){\n\t\t\tcomb[i][j+1] = comb[i-1][j]+comb[i-1][j+1];\n\t\t}\n\t}\n\tset<pii> used;\n\tmint ans;\n\trep(i,n){\n\t\trep(j,i){\n\t\t\tpii a(v[i].fi-v[j].fi, v[i].se-v[j].se);\n\t\t\tint t = __gcd(a.fi, a.se);\n\t\t\ta.fi /= t;\n\t\t\ta.se /= t;\n\t\t\tif(used.find(a)!=used.end()) continue;\n\t\t\tused.insert(a);\n\t\t\tint cnt = 1;\n\t\t\trep(k,n){\n\t\t\t\tif(i==k) continue;\n\t\t\t\tpii b(v[i].fi-v[k].fi, v[i].se-v[k].se);\n\t\t\t\tint t = __gcd(b.fi, b.se);\n\t\t\t\tb.fi /= t;\n\t\t\t\tb.se /= t;\n\t\t\t\tif(a==b) cnt++;\n\t\t\t}\n\t\t\trep(k,3,cnt+1){\n\t\t\t\tans -= comb[cnt][k];\n\t\t\t}\n\t\t}\n\t}\n\trep(i,3,n+1){\n\t\tans += comb[n][i];\n\t}\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS = 1e-10;\nconst bool debug = 0;\n//------------------------------//\n\nll mod = 998244353;\nint N;\nvector<pii> p;\nint cnt[11234];\n\nll mod_pow(ll x, ll n, ll mod) {\n\tif (n == 0) return 1;\n\tll res = mod_pow(x * x % mod, n / 2, mod);\n\tif (n & 1) res = res * x % mod;\n\treturn res;\n}\n\nint calcn(int x) { // a*(a-1)/2 = xを満たすxを求める\n\tint l = 1, r = INF;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) / 2;\n\t\tif ((ll)m * (m - 1) / 2 <= x) l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\n\nint main() {\n\tcin >> N;\n\tp.resize(N);\n\tREP(i, N) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tp[i] = pii(a, b);\n\t}\n\tsort(ALL(p));\n\t\n\tll ans = (mod_pow(2, N, mod) - 1 - N + mod) % mod;\n\t\n\tREP(i, N) cnt[p[i].fi]++;\n\tREP(i, 5) { // x=iの線分\n\t\tll now = (mod_pow(2, cnt[i], mod) - 1 - cnt[i] + mod) % mod;\n\t\tans = (ans - now + mod) % mod;\n\t}\n\t\n\tmap<pll, int> m; // (傾き, x=0でのy)*1e8\n\tREP(i, N) {\n\t\tREP(j, i) {\n\t\t\tif (p[i].fi == p[j].fi) continue;\n\t\t\tdouble a = (double)(p[i].se - p[j].se) / (p[i].fi - p[j].fi);\n\t\t\tdouble b = p[i].se - a * p[i].fi;\n\t\t\tm[make_pair((ll)round(a * 1e8), (ll)round(b * 1e8))]++;\n\t\t}\n\t}\n\t\n\tfor (map<pll, int>::iterator it = m.begin(); it != m.end(); ++it) {\n\t\tint c = calcn(it->se);\n\t\tll now = (mod_pow(2, c, mod) - 1 - c + mod) % mod;\n\t\tans = (ans - now + mod) % mod;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=200;\nconst int MOD=998244353;\ntypedef struct P { int x,y; P() {} P(int x,int y):x(x),y(y) {} } P;\nconst P operator-(const P &a,const P &b) { return P(a.x-b.x,a.y-b.y); }\nconst ll operator^(const P &a,const P &b) { return (ll)a.x*b.y-(ll)a.y*b.x; }\nbool online(const P &a,const P &b,const P &c) { return ((b-a)^(c-a))==0; }\n\nint n;\nP p[MAXN];\n\nint p2[MAXN+1];\n\nvoid run() {\n\tscanf(\"%d\",&n); REP(i,n) scanf(\"%d%d\",&p[i].x,&p[i].y);\n\n\tp2[0]=1; REP(i,n) p2[i+1]=(ll)2*p2[i]%MOD;\n\tint ret=(p2[n]+MOD-1)%MOD;\n\tREP(i,n) {\n\t\tret=(ret+MOD-1)%MOD;\n\t\tFOR(j,i+1,n) {\n\t\t\tint cnt=0;\n\t\t\tFOR(k,j+1,n) if(online(p[i],p[j],p[k])) ++cnt;\n\t\t\t//printf(\"%d and %d -> %d (%d)\\n\",i,j,cnt,p2[cnt]);\n\t\t\tret=(ret+MOD-p2[cnt])%MOD;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=205;\nconst int mod=998244353;\nint x[maxn],y[maxn];\nint gcd(int a,int b)\n{\n    while(b){\n        a=a%b;\n        swap(a,b);\n    }\n    return a;\n}\nmap<pair<int,int>,int>mp;\nint two[205];\nint main()\n{\n    mp.clear();\n    two[0]=1;\n    int n;\n    for(int i=1;i<maxn;i++)\n        two[i]=two[i-1]*2%mod;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%d%d\",x+i,y+i);\n    }\n    if(n<3){\n        printf(\"0\\n\");\n        return 0;\n    }\n    long long ans=two[n]-(n+1);\n    for(int i=0;i<n;i++)\n    {\n        mp.clear();\n        for(int j=i+1;j<n;j++)\n        {\n            int tx=x[i]-x[j];\n            int ty=y[i]-y[j];\n            //printf(\"%d %dss\\n\",tx,ty);\n            if(tx==0) mp[make_pair(0,1)]=mp[make_pair(0,1)]+1;\n            else if(ty==0) mp[make_pair(1,0)]=mp[make_pair(1,0)]+1;\n            else{\n                int t=gcd(abs(tx),abs(ty));\n                tx/=t;ty/=t;\n                if(tx<0){\n                    tx=-tx;ty=-ty;\n                }\n                mp[make_pair(tx,ty)]=mp[make_pair(tx,ty)]+1;\n            }\n        }\n        map<pair<int,int>,int>::iterator it;\n        for(it=mp.begin();it!=mp.end();it++)\n        {\n            pair<int,int> fuck=it->first;\n            int num=it->second;\n            ans=ans-(two[num]-1);\n            //printf(\"%d %lld %d %d\\n\",num,ans,fuck.first,fuck.second);\n        }\n    }\n    ans=(ans%mod+mod)%mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) < norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[m][m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 210\n#define ll long long\n#define mod 998244353\nusing namespace std;\n\nstruct data{int x, y;}b[N];\nstruct line{data a, b;}a[20010];\nint n, l, ans;\n\ninline data operator-(data a, data b){data x; x.x=a.x-b.x; x.y=a.y-b.y; return x;}\ninline int operator*(data a, data b){return a.x*b.y-a.y*b.x;}\n\ninline bool cmp(line A, line B){\n\treturn (A.b.y-A.a.y)*(B.b.x-B.a.x)<(B.b.y-B.a.y)*(A.b.x-A.a.x);\n}\n\ninline int in(line A, data P){return (A.a-P)*(A.b-P)==0?1:0;}\n\ninline void solve(line A){\n\tint sum=0, s;\n\tfor(int i=1; i<=n; i++)if(in(A, b[i]))sum++;\n\ts=1; for(int i=1; i<=sum; i++)s=s*2%mod;\n\ts=(s-1-sum-sum*(sum-1)/2+mod)%mod;\n\tans=(ans-s+mod)%mod;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<=n; i++)scanf(\"%d%d\", &b[i].x, &b[i].y);\n\tl=0;\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=i+1; j<=n; j++){\n\t\t\tl++; a[l].a=b[i]; a[l].b=b[j];\n\t\t}\n\tsort(a+1, a+1+l, cmp);\n\tans=1; for(int i=1; i<=n; i++)ans=ans*2%mod;\n\tans=(ans-1-n-n*(n-1)/2+mod)%mod;\n\tsolve(a[1]);\n\tfor(int i=2; i<=l; i++)if(!in(a[i-1], a[i].a)||!in(a[i-1], a[i].b))solve(a[i]);\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int mod=998244353;\nint x[205],y[205],tw[210],n,num,ans;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>x[i]>>y[i];\n\ttw[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\ttw[i]=((tw[i-1]<<1)+mod)%mod;\n\tans=tw[n];\n\t//cout<<tw[n]<<endl;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tnum=0;\n\t\t\tfor(int k=1;k<j;k++)\n\t\t\t\tif((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))\n\t\t\t\t\tnum++;\n\t\t\tans=(ans-tw[num]+mod)%mod;\n\t\t}\n\tans-=(n+1);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i*i <= N; ++i)\n\t{\n\t\tif (N%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD> &other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<998244353> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\ntemplate<typename RET = mint, typename Integral>\nRET combination(Integral all, Integral get)\n{\n\tassert(all >= get);\n\tget = std::min(all - get, get);\n#if 1\n\t//時間計算量O(logMOD)\n\tstatic const auto fact_v = fact_set_c<100001>();\n\treturn fact_v[all] / (fact_v[get] * fact_v[all - get]);\n#elif 0\n\t//時間計算量O(1)\n\t//空間計算量、初期化時間計算量O(N^2)\n\tconstexpr int32_t ALL_MAX = 10'000;\n\tstatic std::vector<RET> DP_comb[ALL_MAX + 1];\n\tif (!DP_comb[all].empty())\n\t{\n\t\treturn DP_comb[all][get];\n\t}\n\n\tif (DP_comb[0].empty())\n\t{\n\t\tDP_comb[0].resize(1);\n\t\tDP_comb[0][0] = (RET)1;\n\t\tDP_comb[1].resize(1);\n\t\tDP_comb[1][0] = (RET)1;\n\t}\n\tfor (int32_t i = 2; i <= all; i++)\n\t{\n\t\tif (DP_comb[i].empty())\n\t\t{\n\t\t\tint32_t size = i / 2 + 1;\n\t\t\tDP_comb[i].resize(size);\n\t\t\tDP_comb[i][0] = (RET)1;\n\t\t\tfor (int32_t j = 1; j < size - 1; j++)\n\t\t\t{\n\t\t\t\tDP_comb[i][j] = DP_comb[i - 1][j - 1] + DP_comb[i - 1][j];\n\t\t\t}\n\t\t\tDP_comb[i][size - 1] = DP_comb[i - 1][size - 2] + DP_comb[i - 1][(i & 1) ? (size - 1) : (size - 2)];\n\t\t}\n\t}\n\treturn DP_comb[all][get];\n#else\n\t//時間計算量O(get * logMOD)\n\tRET ret = (RET)1;\n\tfor (Integral i = 1; i <= get; ++i)\n\t{\n\t\tret *= all + 1 - i;\n\t\tret /= i;\n\t}\n\treturn ret;\n#endif\n}\n\n\n\nint32_t N;\nusing std::vector;\nstruct P {\n\tint32_t x, y;\n\tint32_t dot(P o) {\n\t\treturn x*o.x + y*o.y;\n\t}\n\tint32_t det(P o) {\n\t\treturn x*o.y - y*o.x;\n\t}\n};\nP operator-(P a, P b) {\n\treturn P{ a.x - b.x, a.y - b.y };\n}\n// 辞書順で比較\ninline bool cmp_x(const P& p, const P& q) {\n\tif (p.x != q.x) return p.x < q.x;\n\treturn p.y < q.y;\n}\n// 凸包を求める\nvector<P> convex_hull(P* ps, int n) {\n\tstd::sort(ps, ps + n, cmp_x);\n\tint k = 0; // 凸包の頂点数\n\tvector<P> qs(n * 2); // 構築中の凸包\n\t\t\t\t\t\t // 下側凸包の作成\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\t// 上側凸包の作成\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n// 距離の二乗\ndouble dist(P p, P q) {\n\treturn (p - q).dot(p - q);\n}\n// 入力\nP ps[200];\nmint powpow[500];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tin >> ps[i].x >> ps[i].y;\n\t}\n\tpowpow[0] = 1;\n\tfor (size_t i = 1; i < 500; i++)\n\t{\n\t\tpowpow[i] = powpow[i - 1] * 2;\n\t}\n\n\n\tmint res = 0;\n\tvector<P> qs = convex_hull(ps, N);\n\tfor (int32_t i = 0,length=(int32_t)(qs.size())-3; i <= length; i++)\n\t{\n\t\tres += powpow[std::max(0,N - (int32_t)(qs.size()) - i)]*combination()\n\t\t\t;\n\t}\n\tres += powpow[N - qs.size()];\n\tfor (int32_t i = qs.size(); i >= 0; i--)\n\t{\n\t\tres += powpow[std::max<long long>(0, N - qs.size() - i)] * i;\n\t}\n\tout << res << endl;\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\nconst int MAXN = 210;\nconst int MOD = 998244353;\nint nowarn;\n\nint n, x[MAXN], y[MAXN];\nint ans, pw[MAXN];\n\nbool OnLine( int i, int j, int k ) {\n\tif( y[i] > y[j] ) swap(i, j);\n\tif( y[k] < y[i] || y[k] > y[j] ) return false;\n\tif( x[i] > x[j] ) swap(i, j);\n\tif( x[k] < x[i] || x[k] > x[j] ) return false;\n\tint vx = x[k] - x[i], vy = y[k] - y[i];\n\tint wx = x[k] - x[j], wy = y[k] - y[j];\n\treturn vx*wy - vy*wx == 0;\n}\n\nint main() {\n\tnowarn = scanf( \"%d\", &n );\n\tfor( int i = 0; i < n; ++i )\n\t\tnowarn = scanf( \"%d%d\", x+i, y+i );\n\tpw[0] = 1;\n\tfor( int i = 1; i <= n; ++i )\n\t\tpw[i] = pw[i-1] * 2 % MOD;\n\tans = (pw[n] - n + MOD) % MOD;\n\tfor( int i = 0; i < n; ++i )\n\t\tfor( int j = i+1; j < n; ++j ) {\n\t\t\tint cnt = 0;\n\t\t\tfor( int k = 0; k < n; ++k )\n\t\t\t\tif( k != i && k != j && OnLine(i, j, k) )\n\t\t\t\t\t++cnt;\n\t\t\tans = (ans - pw[cnt] + MOD) % MOD;\n\t\t}\n\tprintf( \"%d\\n\", (ans - 1 + MOD) % MOD );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nusing int64 = long long;\n\nconst int64 mod = 998244353LL;\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<int> x(N), y(N);\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    static int64 pat[210];\n    pat[0] = 1;\n    for (int i = 0; i < N; i++) (pat[i + 1] = 2 * pat[i]) %= mod;\n    int64 ans = (pat[N] + mod - N - 1 - N * (N - 1) / 2) % mod;\n    // 3頂点以上\n    static bool used[210][210];\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (used[i][j]) continue;\n            vector<int> vec = {i, j};\n            for (int k = 0; k < N; k++) {\n                if (k == i or k == j) continue;\n                if ((y[i] - y[j]) * (x[k] - x[j]) == (y[k] - y[j]) * (x[i] - x[j])) {\n                    vec.emplace_back(k);\n                }\n            }\n            for (int k = 0; k < vec.size(); k++) {\n                for (int l = k + 1; l < vec.size(); l++) {\n                    used[vec[k]][vec[l]] = used[vec[l]][vec[k]] = true;\n                }\n            }\n            int64 num = vec.size();\n            if (num < 3) continue;\n            ans = (ans - pat[num] + num + 1 + num * (num - 1) / 2 + mod * mod) % mod;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\nconst int MOD = 998244353;\n\nint N;\nll dp[200][200], ans = 0;\nvector<pii> p, tmp;\n\nint area (pii a, pii b, pii c) {\n    b.s -= a.s, b.f -= a.f;\n    c.s -= a.s, c.f -= a.f;\n    return b.s*c.f-b.f*c.s;\n}\n\ndouble angle (pii a, pii b) {\n    b.f -= a.f, b.s -= a.s;\n    if (b.f == 0) return MOD;\n    return atan((double)b.s/b.f);\n}\n\nbool comp (pii a, pii b) {\n    double a1 = angle(tmp[0],a), b1 = angle(tmp[0],b);\n    if (a1 != b1) return a1 > b1;\n    return a < b;\n}\n\nbool cw(pii a, pii b, pii c) {\n    if (a == b) return 1;\n    return area(a,b,c) > 0;\n}\n\nbool in (pii a, pii b, pii c, pii o) {\n    if (o == a || o == b || o == c) return 0;\n    if (area(a,b,o) == 0 && o > min(a,b) && o < max(a,b)) return 0;\n    if (abs(area(a,b,o))+abs(area(b,c,o))+abs(area(a,c,o)) != abs(area(a,b,c))) return 0;\n    if (a == b) return o < c;\n    return 1;\n}\n\nvoid solve(int x) {\n    dp[0][0] = 1;\n    tmp.clear();\n    FOR(i,x,p.size()) tmp.pb(p[i]);\n    sort(tmp.begin()+1,tmp.end(),comp);\n    \n    FOR(i,1,tmp.size()) F0R(j,i) {\n        dp[j][i] = 0; ll num = 1;\n        \n        FOR(k,j+1,i) if (in(tmp[0],tmp[j],tmp[i],tmp[k])) num = 2*num % MOD;\n        F0R(k,j+1) if (cw(tmp[k],tmp[j],tmp[i])) \n            dp[j][i] = (dp[j][i]+num*dp[k][j]) % MOD;\n            \n        if (j != 0)  ans = (ans+dp[j][i]) % MOD;\n    }\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tcin >> N; p.resize(N);\n\tF0R(i,N) cin >> p[i].f >> p[i].s;\n\tsort(p.begin(),p.end());\n\tF0R(i,p.size()) solve(i);\n\tcout << ans;\n}\n\n// read!\n// ll vs. int!"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; const int inf = 0x3fffffff; const ll INF = 0x3fffffffffffffff;\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//template end\n\nint mod=998244353;\nstruct Mint {\n    int val;\n    Mint inv() const{\n        int tmp,a=val,b=mod,x=1,y=0;\n        while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n        return Mint(x);\n    }\npublic:\n    Mint():val(0){}\n    Mint(ll x){if((val=x%mod)<0)val+=mod;}\n    Mint pow(ll t){Mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n    Mint& operator+=(const Mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n    Mint& operator-=(const Mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n    Mint& operator*=(const Mint& x){val=(ll)val*x.val%mod; return *this;}\n    Mint& operator/=(const Mint& x){return *this*=x.inv();}\n    Mint operator+(const Mint& x) const{return Mint(*this)+=x;}\n    Mint operator-(const Mint& x) const{return Mint(*this)-=x;}\n    Mint operator*(const Mint& x) const{return Mint(*this)*=x;}\n    Mint operator/(const Mint& x) const{return Mint(*this)/=x;}\n};\nstruct factorial {\n    vector<Mint> Fact, Finv;\npublic:\n    factorial(int maxx){\n        Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*(i+1);\n        Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*i;\n    }\n    Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n    Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n    Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    vector<int> x(n),y(n);\n    rep(i,0,n)scanf(\"%d%d\",&x[i],&y[i]);\n    Mint pw[210]; pw[0]=1;\n    rep(i,0,205)pw[i+1]=pw[i]*2;\n    Mint res=pw[n]-1-n-Mint(n*(n-1)/2);\n    bool used[210][210]={};\n    rep(i,0,n)rep(j,i+1,n)if(!used[i][j]){\n        vector<int> a={i,j};\n        int cnt=2,x1=x[j]-x[i],y1=y[j]-y[i];\n        rep(k,0,n)if(k!=i&&k!=j){\n            int x2=x[k]-x[i],y2=y[k]-y[i];\n            if(x1*y2==y1*x2){\n                a.push_back(k); cnt++;\n            }\n        }\n        sort(ALL(a));\n        rep(k,0,a.size())rep(l,k,a.size())used[a[k]][a[l]]=1;\n        if(cnt>=3)res-=(pw[cnt]-1-cnt-Mint(cnt*(cnt-1)/2));\n    }\n    printf(\"%d\\n\",res.val);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cal(a,b) ((a+=b)%=mo)\n#define cross(a,b,c) ((b-a)*(c-a))\nusing namespace std;\nconst int N=250,mo=998244353;\nconst double eps=1e-7;\nint p[N],n,ans;\nstruct data{\n    int x,y;\n    data operator - (const data &c)const{\n\treturn (data){x-c.x,y-c.y};\n    }\n    int operator * (const data &c)const{\n\treturn x*c.y-y*c.x;\n    }\n}d[N];\nint main(){\n    cin>>n,p[0]=1;\n    if (n<=2) return puts(\"0\"),0;\n    for (int i=1; i<=n; ++i) cin>>d[i].x>>d[i].y;\n    for (int i=1; i<=n; ++i) p[i]=p[i-1]*2%mo;\n    for (int i=1; i<n; ++i)\n\tfor (int j=i+1; j<n; ++j){\n\t    int cnt=n-j;\n\t    for (int k=j+1; k<=n; ++k)\n\t\tif (cross(d[i],d[j],d[k])==0)\n\t\t    --cnt;\n\t    cal(ans,1ll*p[n-j-cnt]*(p[cnt]-1)%mo);\n\t}\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#include <cstdio>\n#include <cstdlib>\n#include <utility>\n#include <map>\n#else\n#include <bits/stdc++.h>\n#endif\n\n//#undef DEBUG\n\nconst int maxn = 233, mod = 998244353;\n\nint n, x[maxn], y[maxn], c[maxn][maxn], ans, f[maxn];\nstd::map<std::pair<int, std::pair<int, int> >, int> m;\n\ninline int ABS(int x) {\n\treturn x < 0 ? -x : x;\n}\n\ninline int gcd(int a, int b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i <= n; ++i) {\n\t\tc[i][0] = 1;\n\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n\t\t\tif(j > 2) {\n\t\t\t\tf[i] = (f[i] + c[i][j]) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d%d\", x + i, y + i);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tint A, B, C;\n\t\t\tif(x[i] == x[j]) {\n\t\t\t\tA = 1;\n\t\t\t\tC = -x[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tA = y[j] - y[i], B = x[i] - x[j], C = y[i] - x[i] * (y[j] - y[i]);\n\t\t\t\tif(B < 0) {\n\t\t\t\t\tA = -A;\n\t\t\t\t\tB = -B;\n\t\t\t\t\tC = -C;\n\t\t\t\t}\n\t\t\t\tint d = B;\n\t\t\t\tif(ABS(A)) {\n\t\t\t\t\td = gcd(d, A);\n\t\t\t\t}\n\t\t\t\tif(ABS(C)) {\n\t\t\t\t\td = gcd(d, C);\n\t\t\t\t}\n\t\t\t\tA /= d;\n\t\t\t\tC /= d;\n\t\t\t\tB /= d;\n\t\t\t}\n\t\t\tauto t = std::make_pair(A, std::make_pair(B, C));\n\t\t\tif(m.find(t) == m.end()) {\n\t\t\t\tm[t] = 0;\n\t\t\t}\n\t\t\t++m[t];\n\t\t}\n\t}\n\tfor (auto it = m.begin(); it != m.end(); ++it) {\n\t\tint x = it->second;\n\t\tint lb = 0, rb = n, y;\n\t\twhile(lb <= rb) {\n\t\t\tint mid = lb + rb >> 1;\n\t\t\tif(mid * (mid - 1) == x) {\n\t\t\t\ty = mid;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(mid * (mid - 1) > x) {\n\t\t\t\trb = mid - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlb = mid + 1;\n\t\t\t}\n\t\t}\n\t\tans = (ans + f[y]) % mod;\n\t}\n\tprintf(\"%d\\n\", (f[n] - ans + mod) % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lld long long int\n#define ld long double\n#define mod 1000000007\n#define modd 998244353\n#define all(v) v.begin(),v.end()\n#define rep(i,a,b)\tfor(lld i=a;i<=b;i++)\n#define repr(i,a,b) for(lld i=a;i>=b;i--)\n#define ar array\n#define pb push_back\n#define mp make_pair\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nlld n,m;\nar<lld,2> arr[300000];\nmap<ar<lld,3>, lld> ma;\nlld fastpower(lld x, unsigned lld y, lld p)\n{\n    lld res = 1;\n    x = x % p;\n    while (y > 0)\n    {\n        if (y & 1)\n            res = (res*x) % p;\n        y = y>>1;\n        x = (x*x) % p;\n    }\n    return res;\n}\nint main()\n{\n     ios;\n     lld TESTS,q,a,s,b,l,r,c,k,p,h,w,d,x,y,z,xs,ys,t;\n     TESTS=1;\n     //cin>>TESTS;\n     while(TESTS--)\n     {\n         cin>>n;\n         rep(i,0,n-1)cin>>arr[i][0]>>arr[i][1];\n         lld cou=0;\n         rep(i,0,n-1) rep(j,i+1,n-1){\n            x=arr[i][0]-arr[j][0];\n            y=arr[i][1]-arr[j][1];\n            z=arr[i][1]*x-arr[i][0]*y;\n            lld g=__gcd(abs(x),abs(y));\n            g=__gcd(g,abs(z));\n            x/=g;y/=g;z/=g;\n            if (ma[{x,y,z}]) continue;\n            ma[{x,y,z}]=1;\n            lld now=2;\n            rep(k,0,n-1){\n                if(k==i||k==j)continue;\n                xs=arr[k][0]-arr[i][0];\n                ys=arr[k][1]-arr[i][1];\n                if (xs*y==ys*x)now++;\n            }\n            cou+=(fastpower(2,now,modd)-1-now+2*modd)%modd;\n            cou%=modd;\n         }\n      //   cout<<cou<<\"\\n\";\n         cout<<(fastpower(2,n,modd)-cou-1-n+2*modd)%modd;\n     }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y;\n\tdata(){}\n\tdata(int xx,int yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n};\n\nint n;\ndata d[205];\nll two[205];\nbool flag[205][205];\nll res=0;\n\nbool check(int f,int t,int vx,int vy){\n\tint sax=d[t].x-d[f].x;\n\tint say=d[t].y-d[f].y;\n\treturn (sax*vy-say*vx)==0;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\ttwo[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\ttwo[i]=two[i-1]*2LL%MOD;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&d[i].x,&d[i].y);\n\t}\n\tll res=two[n];\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(flag[i][j])continue;\n\t\t\tint vx=d[i].x-d[j].x;\n\t\t\tint vy=d[i].y-d[j].y;\n\t\t\tvector<int> vec;\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(check(j,k,vx,vy)){\n\t\t\t\t\tvec.push_back(k);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres-=two[cnt];\n\t\t\tres+=MOD;\n\t\t\tres%=MOD;\n\t\t\tres+=cnt+1LL;\n\t\t\tres%=MOD;\n\t\t\tfor(int k=0;k<vec.size();k++){\n\t\t\t\tfor(int l=0;l<vec.size();l++){\n\t\t\t\t\tflag[vec[k]][vec[l]]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres-=(ll)n+1LL;\n\tres+=MOD;\n\tres%=MOD;\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#define LL long long\n#define mod 998244353\nusing namespace std;\nint n,X[201],Y[201];\ninline LL gcd(LL x,LL y){return (y==0)?x:gcd(y,x%y);}\nstruct num{\n\tLL x,y;\n\tnum(LL xx=0,LL yy=1){LL d=gcd(xx,yy);x=xx/d;y=yy/d;if(y<0){x=-x;y=-y;}}\n\tfriend bool operator<(num a,num b){return (a.x*b.y)<(a.y*b.x);}\n\tfriend bool operator==(num a,num b){return (a.x==b.x)&&(a.y==b.y);}\n};\nstruct line{\n\tnum k,b;\n\tfriend bool operator<(line x,line y){return (x.k<y.k)||(x.k==y.k&&x.b<y.b);}\n};\nmap<line,int>mp;int cn=0,b[40127];\ninline int ID(line x)\n{\n\tif(mp.find(x)!=mp.end())return mp[x];\n\treturn mp[x]=++cn;\n}\ninline int ksm(int p,int k)\n{\n\tint res=1;\n\twhile(k)\n\t{\n\t\tif(k&1)res=1ll*res*p%mod;\n\t\tp=1ll*p*p%mod;k>>=1;\n\t}return res;\n}\nint main(){\n\tscanf(\"%d\",&n);int i,j,k,d,ans=ksm(2,n);num K,B;\n\tfor(i=1;i<=n;i++)scanf(\"%d%d\",&X[i],&Y[i]);\n\tfor(i=1;i<=n-1;i++)\n\tfor(j=i+1;j<=n;j++)\n\tif(i!=j)\n\t{\n\t\tint res=2;\n\t\tif(X[i]==X[j]){K=num(1,0);B=X[i];}\n\t\telse{K=num(Y[i]-Y[j],X[i]-X[j]);B=num(1ll*X[i]*Y[j]-1ll*X[j]*Y[i],X[i]-X[j]);}\n\t\tif(b[d=ID((line){K,B})])continue;b[d]=1;\n\t\tfor(k=1;k<=n;k++)\n\t\tif(k!=i&&k!=j)\n\t\t{\n\t\t\tif(X[i]==X[j]){if(X[i]==X[k])++res;}\n\t\t\telse if(K.x*X[k]*B.y+K.y*B.x==B.y*K.y*Y[k])++res;\n\t\t}\n\t\tres=ksm(2,res)-res-1;res=(res%mod+mod)%mod;\n\t\tans=((ans-res)%mod+mod)%mod;\n\t}ans=((ans-n)%mod+mod)%mod;\n\tprintf(\"%d\",((ans-1)%mod+mod)%mod);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n \n#include <vector>\n#include <iostream>\n \ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n \n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(int value) { \n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// TODO\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n \n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n};\n \n#endif\n \n//#include \"Union_Find.h\"\n \n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n \nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT fixed << setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n \n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n \ntypedef IntMod<998244353> MM;\n \nint N;\nPP A[200];\nbool used[200][200];\nMM ans;\n \nbool collinear(int i, int j, int k) {\n\treturn (A[j].second - A[i].second) * (A[k].first - A[i].first)\n\t\t== (A[k].second - A[i].second) * (A[j].first - A[i].first);\n}\n \nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tcin >> A[i].first >> A[i].second;\n\t}\n \n\tans = MM(2).Pow(N) - (N + 1);\n \n\tREP(i, 0, N) {\n\t\tREP(j, i + 1, N) {\n\t\t\tif (used[i][j]) continue;\n \n\t\t\tvector<int> S({i, j});\n\t\t\tREP(k, 0, N) {\n\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\tif (collinear(i, j, k)) S.push_back(k);\n\t\t\t}\n\t\t\tans -= MM(2).Pow(S.size()) - ((unsigned int)S.size() + 1);\n\t\t\tREP(p, 0, S.size()) {\n\t\t\t\tREP(q, p + 1, S.size()) {\n\t\t\t\t\tused[S[p]][S[q]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans.Get_value() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n  return a * (b / gcd(a, b));\n}\n\nstruct pt {\n  ll x, y;\n};\n\npt operator-(const pt &a, const pt &b) {\n  return pt {a.x - b.x, a.y - b.y};\n}\n\nstruct frac {\n  ll num, den;\n};\n\nvoid cancel(frac &a) {\n  ll d = gcd(a.num, a.den);\n  a.num /= d;\n  a.den /= d;\n  if (a.num <= 0 && a.den <= 0) {\n    a.num *= -1;\n    a.den *= -1;\n  }\n}\n\nfrac operator*(const frac &a, ll b) {\n  frac res = frac {a.num * b, a.den};\n  cancel(res);\n  return res;\n}\n\nfrac operator-(const frac &a, const frac &b) {\n  ll m = lcm(a.den, b.den);\n  ll f1 = m / a.den;\n  ll f2 = m / b.den;\n  frac res = frac {a.num * f1 - b.num * f2, m};\n  cancel(res);\n  return res;\n}\n\nfrac operator/(const frac &a, const frac &b) {\n  frac res = frac {a.num * b.den, a.den * b.num};\n  cancel(res);\n  return res;\n}\n\nbool operator==(const frac &a, const frac &b) {\n  return a.num == b.num && a.den == b.den;\n}\n\nbool operator!=(const frac &a, const frac &b) {\n  return a.num != b.num || a.den != b.den;\n}\n\nbool operator<(const frac &a, const frac &b) {\n  return (double)a.num / (double)a.den < double(b.num) / (double)b.den;\n}\n\nstruct line {\n  frac a, b, c;\n};\n\nbool operator==(const line &a, const line &b) {\n  return a.a == b.a && a.b == b.b && a.c == b.c;\n}\n\nbool operator<(const line &a, const line &b) {\n  if (a.a != b.a) return a.a < b.a;\n  if (a.b != b.b) return a.b < b.b;\n  return a.c < b.c;\n}\n\nll powers2[201];\n\nll cross(pt a, pt b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nbool collinear(pt a, pt b, pt c) {\n  return !cross(b - a, c - a);\n}\n\nline pointsToLine(pt a, pt b) {\n  line l;\n  if (a.x == b.x) {\n    l.a = frac {1, 1};    \n    l.b = frac {0, 1};\n    l.c = frac {-a.x, 1};\n  } else {\n    l.a = frac {-a.y - b.y, 1} / frac {a.x - b.x, 1};\n    l.b = frac {1, 0};\n    l.c = (l.a * -a.x) - frac{a.y, 1};\n  }\n  return l;\n}\n\nint main() {\n  powers2[0] = 1;\n  for (int i = 1; i <= 200; i++) powers2[i] = powers2[i - 1] * 2LL % MOD;\n\n  ll sum = 0;\n  map<ll, int> invTri;\n  for (int i = 1; i <= 200; i++) {\n    sum += i;\n    invTri[sum] = i;\n  }\n\n  int n;\n  scanf(\"%d\", &n);\n  vector<pt> points(n);\n  for (int i = 0; i < n; i++) scanf(\"%lld %lld\", &points[i].x, &points[i].y);\n  \n  map<line, int> counter;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      line l = pointsToLine(points[i], points[j]);\n      counter[l]++;\n    }\n  }\n  ll res = powers2[n];\n  for (auto c : counter) {\n    int points = invTri[c.second] + 1;\n    res += MOD - powers2[points] + points + 1;\n    res %= MOD; \n  }\n  res += MOD - 1 - n;\n  res %= MOD;\n  printf(\"%lld\\n\", (res % MOD + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint n,ans,x[210],y[210],f[210];\nconst int MD=998244353;\nint main()\n{\n    scanf(\"%d\",&n);\n    f[0]=1;\n    for(int i=1; i<=n; i++)\n    {\n        scanf(\"%d%d\",&x[i],&y[i]);\n        f[i]=1ll*f[i-1]*2%MD;\n    }\n    ans=f[n]-n-1;\n    for(int i=1; i<=n; i++)\n    {\n        for(int j=i+1; j<=n; j++)\n        {\n            int d=0;\n            for(int k=j+1; k<=n; k++)\n            d+=(y[i]-y[j])*(x[i]-x[k])==(y[i]-y[k])*(x[i]-x[j]);\n            ans=(ans+MD-f[d])%MD;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 998244353;\nll N;\nvector<pair<ll, ll>> Points;\nmap<tuple<ll, ll, ll>, ll> Count;\nmap<ll, ll> InvNC2;\nvector<ll> Pow;\nll R;\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll pow_multi(ll n) { return (Pow[n] + MOD - n - 1) % MOD; }\nint main() {\n  cin >> N;\n  for (ll i = 0; i < N; ++i) {\n    ll x, y;\n    cin >> x >> y;\n    Points.push_back(make_pair(x, y));\n  }\n  for (ll i = 0; i < N; ++i)\n    for (ll j = i + 1; j < N; ++j) {\n      ll x, y, x2, y2;\n      tie(x, y) = Points[i];\n      tie(x2, y2) = Points[j];\n      ll dx = x2 - x, dy = y2 - y;\n      // line ax+by=c, a+b>=0, a and b are coprime\n      ll a = dy, b = -dx;\n      if (a + b < 0) {\n        a *= -1;\n        b *= -1;\n      }\n      ll g = gcd(abs(a), abs(b));\n      a /= g;\n      b /= g;\n      assert(a + b >= 0 && gcd(abs(a), abs(b)) == 1);\n      ll c = a * x + b * y;\n      assert(c == a * x2 + b * y2);\n      ++Count[make_tuple(a, b, c)];\n    }\n  for (ll i = 2; i <= N; ++i) InvNC2[i * (i - 1) / 2] = i;\n  Pow.resize(N + 1);\n  Pow[0] = 1;\n  for (ll i = 1; i <= N; ++i) Pow[i] = 2 * Pow[i - 1] % MOD;\n  R = pow_multi(N);\n  for (const auto &linecount : Count) {\n    ll k = InvNC2[linecount.second];\n    (R += MOD - pow_multi(k)) %= MOD;\n  }\n  cout << R << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T>\nvector<vector<T> > make_v(size_t a,size_t b){\n  return vector<vector<T> >(a,make_v<T>(b));\n}\ntemplate<typename T>\nvector<vector<vector<T> > > make_v(size_t a,size_t b,size_t c){\n  return vector<vector<vector<T> > > (a,make_v<T>(b,c));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n//INSERT ABOVE HERE\nInt cross(Int x1,Int y1,Int x2,Int y2){\n  return x1*y2-x2*y1;\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> x(n),y(n);\n  for(Int i=0;i<n;i++) cin>>x[i]>>y[i];\n  const Int MOD = 998244353;\n  vector<Int> po(n+1,1);\n  for(Int i=0;i<n;i++) po[i+1]=po[i]*2%MOD;\n  \n  Int ans=po[n]+MOD-(n+1);\n  auto used=make_v<Int>(n,n);\n  fill_v(used,0);\n  for(Int i=0;i<n;i++){\n    for(Int j=0;j<i;j++){\n      if(used[i][j]) continue;\n      vector<Int> v;\n      for(Int k=0;k<n;k++)\n\tif(cross(x[i]-x[k],y[i]-y[k],x[j]-x[k],y[j]-y[k])==0)\n\t  v.emplace_back(k);\n\n      //cout<<i<<\" \"<<j<<\":\"<<v.size()<<endl;\n      ans+=MOD-(po[v.size()]-v.size()-1);\n      ans%=MOD;\n      \n      for(Int k:v)\n\tfor(Int l:v)\n\t  used[k][l]=1;\n    }\n  }\n  ans%=MOD;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint n;\nconst LL mods=998244353;\nstruct point{\n\tint x,y;\n\tpoint (int _x,int _y){\n\t\tx=_x;\n\t\ty=_y;\n\t}\n\tpoint(){\n\t}\n};\nstruct M{\n\tLL x;\n\tM(LL angka){\n\t\tif(angka>=mods||angka<=-mods)\n\t\t\tangka%=mods;\n\t\tif(angka<0)\n\t\t\tangka+=mods;\n\t\tx=angka;\n\t}\n\tM(){\n\t\tx=0;\n\t}\n\tM operator*(const M &other) const{\n\t\treturn M(x*other.x);\n\t}\n\tM operator+(const M &other) const{\n\t\treturn M(x+other.x);\n\t}\n\tM operator-(const M &other) const{\n\t\treturn M(x-other.x);\n\t}\n\tM operator-(){\n\t\treturn M(-x);\n\t}\n};\npoint plist[205];\nvector <pii> urutan;\nM pangkat[205],ans;\nint fpb(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\treturn fpb(b,a%b);\n}\npii kecilkan(pii pecah){\n\tif(pecah.fi==0)\n\t{\n\t\tassert(pecah.se!=0);\n\t\treturn mp(0,1);\n\t}\n\tif(pecah.se==0)\n\t{\n\t\tassert(pecah.fi!=0);\n\t\treturn mp(1,0);\n\t}\n\tint bagi=fpb(abs(pecah.fi),abs(pecah.se));\n\tpecah.fi/=bagi;\n\tpecah.se/=bagi;\n\tif(pecah.fi*pecah.se<0)\t\t//minus selalu di first\n\t{\n\t\tpecah.fi=-abs(pecah.fi);\n\t\tpecah.se=abs(pecah.se);\n\t}\n\telse\n\t{\n\t\tpecah.fi=abs(pecah.fi);\n\t\tpecah.se=abs(pecah.se);\n\t}\n\treturn pecah;\n}\nvoid isipangkat(){\n\tpangkat[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tpangkat[i]=pangkat[i-1]*2;\n}\nvoid hitungansawal(){\n\tans=pangkat[n]-1-n;\n}\nint main()\n{\n\tscan(n);\n\tisipangkat();\n\thitungansawal();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscan(plist[i].x,plist[i].y);\n\t}\n\t//hitung ans modif\n\tfor(int i=1;i<n;i++)\n\t{\n\t\turutan.clear();\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\turutan.pb(kecilkan(mp(plist[j].x-plist[i].x,plist[j].y-plist[i].y)));\n\t\tsort(all(urutan));\n\t\tint totalkembar=0;\n\t\tpii last=urutan[0];\n\t\tfor(auto isi:urutan)\n\t\t{\n\t\t\tif(isi!=last)\n\t\t\t{\n\t\t\t\tlast=isi;\n\t\t\t\tans=ans-(pangkat[totalkembar]-1);\n\t\t\t\ttotalkembar=0;\n\t\t\t}\n\t\t\ttotalkembar++;\n\t\t}\n\t\tans=ans-(pangkat[totalkembar]-1);\n\t}\n\tcout<<ans.x<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 998244353;\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nint func(int a) {\n\tint res = 1;\n\tfor (int i = 0; i < a; i++) {\n\t\tres = (res * 2) % MOD;\n\t}\n\tres = (res + MOD - a) % MOD;\n\tres = (res + MOD - ((a*(a - 1)) / 2) - 1) % MOD;\n\treturn res;\n}\nsigned main() {\n\tint n;\n\tcin >> n;\n\tint res = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tres = (res * 2 % MOD);\n\t}\n\tvector<int> x(n);\n\tvector<int> y(n);\n\tUnionFind uf(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tif (n <= 2) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n - 2; i++) {\n\t\tfor (int j = i + 1; j < n - 1; j++) {\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\tif ((x[i] - x[k])*(y[j] - y[k]) == (x[j] - x[k])*(y[i] - y[k])) {\n\t\t\t\t\tuf.unionSet(i, j);\n\t\t\t\t\tuf.unionSet(i, k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> vec(n,0);\n\tfor (int i = 0; i < n; i++) {\n\t\tvec[uf.root(i)]++;\n\t}\n\tres = func(n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (vec[i] >= 3) {\n\t\t\tres = (res + MOD - func(vec[i])) % MOD;\n\t\t\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define SORT(c) sort((c).begin(), (c).end())\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> V;\ntypedef map<int, int> M;\n\nconstexpr ll INF = 1e18;\nconstexpr ll MOD = 998244353;\nconstexpr double PI = 3.14159265358979323846;\nconstexpr int di[] = {0, 0, 1, -1};\nconstexpr int dj[] = {1, -1, 0, 0};\n\nll fastPow(ll x, ll n)\n{\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return fastPow(x * x % MOD, n / 2);\n    else\n        return x * fastPow(x, n - 1) % MOD;\n}\n\nll fac[112346];\nvoid combInit(int mx)\n{\n    fac[0] = 0;\n    fac[1] = 1;\n    for (int i = 2; i <= mx; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n}\n\nll modDiv(ll a, ll b)\n{\n    return a * fastPow(b, MOD - 2) % MOD;\n}\n\nll comb(ll a, ll b)\n{\n    if (b == 0)\n        return 1;\n    if (a < b)\n        return 0;\n    if (a <= 0 || b < 0)\n        return 0;\n    if (a == b)\n        return 1;\n\n    ll p, c;\n\n    c = modDiv(fac[a], fac[a - b]);\n    p = fac[b];\n\n    ll res = modDiv(c, p);\n\n    return res;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    combInit(210);\n\n    int n, x[210], y[210];\n\n    ll li[210];\n    fill(li, li + n + 1, 0);\n\n    cin >> n;\n    REP(i, n)\n    cin >> x[i] >> y[i];\n\n    ll res = 0;\n\n    for (int i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++)\n        {\n            int cnt = 2;\n            for (int k = j + 1; k < n; k++)\n            {\n\n                int a = (x[j] - x[i]) * (y[k] - y[j]);\n                int b = (y[j] - y[i]) * (x[k] - x[j]);\n\n                if (a == b)\n                {\n                    cnt++;\n\n                    int c = cnt;\n\n                    while (c > 2)\n                    {\n                        li[c]++;\n                        c--;\n                    }\n                }\n            }\n        }\n\n    for (int i = 3; i <= n; i++)\n    {\n        ll tmp = 0;\n        tmp += comb(n, i);\n\n        tmp += MOD - li[i];\n        tmp %= MOD;\n\n        res += tmp;\n        res %= MOD;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n// #include <fstream>\n#define int long long int\n#define mod(x) ((x % MOD) + MOD) % MOD\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);--i)\n\n#define ALL(c) (c).begin(),(c).end()\n#define SIZE(c) (int)((c).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define SORT(c) sort(ALL(c))\n#define LB(c,x) lower_bound(ALL(c),x)\n#define UB(c,x) upper_bound(ALL(c),x)\n#define COUNT(c,x) (int)(UB(c,x)-LB(c,x))\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl;\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nstruct edge {\n  int to, cost;\n};\n\nconst int INF = 1e18;\nconst int MOD = 998244353;\n\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size();\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \" \";\n  }\n  return s;\n}\n\nint powM(int x, int n){\n  if(n == 0){\n    return 1;\n  }\n  if(n % 2 == 0){\n    return powM(mod(x * x), n / 2);\n  }\n  return mod(powM(x, n-1) * x);\n}\n\n\nsigned main()\n{\n  // string filename; cin >> filename;\n  // ifstream in(filename);\n  // cin.rdbuf(in.rdbuf());\n\n  int N; cin >> N;\n  vector<int> x(N), y(N);\n  rep(i, 0, N) {\n    cin >> x[i] >> y[i];\n  }\n\n  int ans = powM(2, N);\n  ans = mod(ans - 1);\n  ans = mod(ans - N);\n  rep(i, 0, N-1) {\n    rep(j, i+1, N) {\n      int num = 0;\n      bool is_new = true;\n      rep(k, 0, N) {\n        if (i == k || j == k) {\n          num++;\n          continue;\n        }\n        if ((x[j]-x[i])*(y[k]-y[i]) == (y[j]-y[i])*(x[k]-x[i])) {\n          if (k < j) {\n            is_new = false;\n            break;\n          } else {\n            num++;\n          }\n        }\n      }\n      if (is_new) {\n        ans = mod(ans - (powM(2, num) - num - 1));\n      }\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int N = 211;\nconst int mod = 998244353;\nint n;\nLL base[N];\nstruct ddd{\n    int x, y;\n}nd[N];\nint sq(int x){return x * x;}\nbool check(int x1, int y1, int x2, int y2){\n    int a = x1 * x2 + y1 * y2;\n    int b = (sq(x1) + sq(y1)) * (sq(x2) + sq(y2));\n    return a > 0 && b == sq(a);\n}\nint main(){\n    cin>>n;\n    for(int i = 1;i <= n; i++){\n        scanf(\"%d%d\", &nd[i].x, &nd[i].y);\n    }\n    base[0] = 1;\n    for(int i = 1;i <= 200; i++)base[i] = base[i-1] * 2 % mod;\n    LL ans = (base[n] - 1 - n + mod) % mod;\n    for(int i = 2;i <= n; i++){\n        for(int j = 1;j < i; j++){\n            int tot = 0;\n            for(int k = 1;k <= n; k++){\n                if(i == k || j == k)continue;\n                if(check(nd[i].x - nd[k].x, nd[i].y - nd[k].y, nd[k].x - nd[j].x, nd[k].y - nd[j].y))tot++;\n            }\n            ans = (ans + mod - base[tot]) % mod;\n            //printf(\"i=%d j=%d tot=%d\\n\", i, j, tot);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 1000001;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a%b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a * b / gcd(a, b);\n}\n\nstruct edge {\n\tll ind;\n\tll to;\n\tll d;\n};\n\n\n///////////////////////////\n\n\nll p(ll x){\n    if(x==0){return 1;}\n    ll y=p(x/2);\n    if(x%2==1){return y*y%MOD*2%MOD;}\n    else{return y*y%MOD;}\n}\n\nint main() {\n   ll N;\n   cin >>N;\n   vector<ll> x(N+1),y(N+1);\n   repn(i,N) cin >>x[i]>>y[i];\n\n   bool ch[300][300]={};\n\n   ll ans=(p(N)-N-1)%MOD;\n\n   repn(i,N)repn(j,N){\n    if(i==j){continue;}\n\n    if(ch[i][j]==1){continue;}\n\n    vector<ll> line;\n    \n    repn(k,N){\n        if((x[i]-x[j])*(y[j]-y[k])==(x[j]-x[k])*(y[i]-y[j])){line.push_back(k);}\n     }\n\n     ll K=line.size();\n\n     rep(k,K)rep(l,K)ch[line[k]][line[l]]=1;\n\n     ans=ans-p(K)+K+1;\n     ans%=MOD;\n    \n\n   }\n\n   if(ans<0){ans+=MOD;}\n\n   cout <<ans;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int P=998244353;\nint n;\nstruct pos{\n\tint x,y;\n}ps[1007];\nint ep=0,f[1007],sz[1007];\nint gf(int x){while(x!=f[x])x=f[x]=x[f][f];return x;}\nstruct edge{\n\tint a,b;\n\tint v;\n\tbool operator<(const edge&e)const{return v<e.v;}\n\tvoid cal(){\n\t\tint x=gf(a),y=gf(b);\n\t\tif(x!=y)f[x]=y,sz[y]+=sz[x];\n\t}\n}es[207*207];\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\nint pw[1007],ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor(int i=1;i<=n;++i)pw[i]=pw[i-1]*2%P;\n\tans=(pw[n]-n-1)%P;\n\tfor(int i=0;i<n;++i)scanf(\"%d%d\",&ps[i].x,&ps[i].y);\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=0;j<i;++j){\n\t\t\tint x=ps[i].x-ps[j].x,y=ps[i].y-ps[j].y;\n\t\t\tint g=gcd(x,y);\n\t\t\tx/=g,y/=g;\n\t\t\tif(!x)y=1;\n\t\t\tif(!y)x=1;\n\t\t\tif(x<0)x=-x,y=-y;\n\t\t\tes[ep++]=(edge){i,j,x*30000+y};\n\t\t}\n\t}\n\tstd::sort(es,es+ep);\n\tfor(int i=0,j=0;i<ep;i=j){\n\t\tfor(int a=0;a<n;++a)sz[f[a]=a]=1;\n\t\tfor(;j<ep&&es[i].v==es[j].v;es[j++].cal());\n\t\tfor(int a=0;a<n;++a)if(f[a]==a&&sz[a]>1)ans=(ans-pw[sz[a]]+sz[a]+1)%P;\n\t}\n\tprintf(\"%d\\n\",(ans%P+P)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\n\ntypedef long long ll;\nint N;\nll x[2000],y[2000];\nll gcd(ll x,ll y){\n\tif(y==0) return abs(x);\n\treturn gcd(y,x%y);\n}\nusing T = tuple<ll,ll,ll>;\nmap<T,int> cnt;\nmap<int,int> c2i;\n\nmint p2[2001];\n\nint main(){\n\tcin>>N;\n\tp2[0] = 1;\n\trep1(i,N) p2[i] = p2[i-1]*2;\n\tfor(int i=2;i<=N;i++){\n\t\tint x = i*(i-1)/2;\n\t\tc2i[x] = i;\n\t}\n\trep(i,N) cin>>x[i]>>y[i];\n\trep(i,N) rep(j,i){\n\t\tll a = y[i]-y[j];\n\t\tll b = x[j]-x[i];\n\t\tll c = y[i]*x[j]-y[j]*x[i];\n\t\tll g = gcd(a,gcd(b,c));\n\t\tif(a<0 || (a==0&&b<0)) g*=-1;\n\t\ta/=g,b/=g,c/=g;\n\t\tcnt[T(a,b,c)]++;\n\t}\n\tmint ans = p2[N];\n\tfor(auto it:cnt){\n\t\tint n = c2i[it.sc];\n\t\tans -= p2[n]-n-1;\n\t}\n\tans -= N+1;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n \nusing namespace std;\n \n template<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define PB emplace_back\n#define MP make_pair \n#define SZ(a) int((a).size())\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SORT(c) sort((c).begin(),(c).end())\n//constant\n//--------------------------------------------\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\nconst double EPS=0.00001;\nconst LL mod=998244353;\nbool chk(PII a,PII b,PII c){\n    return ((b.first - a.first) * (c.second - a.second) - (b.second - a.second) * (c.first - a.first))==0;\n}\n\nint main(){\n    int N;cin>>N;\n    vector<PII>xy(N);\n    set<vector<PII>>st;\n    REP(i,N){\n        cin>>xy[i].first>>xy[i].second;\n    }\n    LL res=N+1;\n    REP(i,N)FOR(j,i+1,N){\n        LL cnt=2;\n        vector<PII>pi;\n        pi.PB(xy[i]);pi.PB(xy[j]);\n        REP(k,N)if(k!=i&&k!=j){\n            if(chk(xy[i],xy[j],xy[k])){\n                cnt++;pi.PB(xy[k]);\n            }\n        }\n        SORT(pi);\n        if(st.find(pi)==st.end()){\n            LL tmp=1;\n            REP(ii,cnt)tmp=tmp*2LL%mod;\n            res+=tmp-cnt-1LL;\n            res%=mod;\n            st.insert(pi);\n        }\n    }\n    LL res2=1LL;\n    REP(i,N)res2=res2*2LL%mod;\n    cout<<(res2-res+mod)%mod<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <iterator>\n#define LL long long\n#define For(x) for (int i=1;i<=n;++i)\n#define rep(i,x) for (int i=1;i<=x;++i)\n#define repp(i,x,y) for (int i=x;i<=y;++i) \n#define F(x) for (int i=head[x];i;i=b[i].next)\n#define mk(x,y) make_pair(x,y)\n#define ft first\n#define sd second\n#define _ b[i].v;\n#define mod  998244353\nconst int maxn=2e2+10;\nusing namespace std;\n\nint n,x[maxn],y[maxn];\nLL tmp1,tmp2,tmp,ans;\nmap <pair<LL,LL>,int> a;\n\nLL qsm(LL a,LL b)\n{\n\tLL tmp=1;\n\twhile (b)\n\t{\n\t\tif (b&1) tmp=(tmp*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn tmp;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tans=(qsm(2,n)-n-1+mod)%mod;\n\tFor (n) scanf(\"%d%d\",&x[i],&y[i]);\n\tFor (n)\n\t{\n\t\ta.clear();\n\t\trepp(j,i+1,n)\n\t\t{\n\t\t\ttmp1=y[i]-y[j];\n\t\t\ttmp2=x[i]-x[j];\n\t\t\ttmp=__gcd(tmp1,tmp2);\n\t\t\ttmp1/=tmp;\n\t\t\ttmp2/=tmp;\n\t\t\t++a[mk(tmp1,tmp2)];\n\t\t}\n\t\tfor (map <pair<LL,LL>,int>::iterator k=a.begin();k!=a.end();++k)\n\t\t  ans=(ans-qsm(2,k->sd)+1+mod)%mod;\n\t}\n\treturn 0*printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n#define EPS 1e-9\n\nusing namespace std;\n\ntypedef complex<int> pt;\n\nstruct line {\n  double a, b, c;\n};\n\nline pointsToLine(pt p1, pt p2) {\n  line l;\n  if (abs(p1.real() - p2.real()) < EPS) {\n    l.a = 1;\n    l.b = 0;\n    l.c = -p1.real();\n  } else {\n    l.a = -(double)(p1.imag() - p2.imag()) / (p1.real() - p2.real());\n    l.b = 1.0;\n    l.c = -(double)(l.a * p1.real()) - p1.imag();\n  }\n  return l;\n}\n\nbool areParallel(line l1, line l2) {\n  return (abs(l1.a - l2.a) < EPS) && (abs(l1.b - l2.b) < EPS);\n}\n\nbool operator==(const line &l1, const line &l2) {\n  return areParallel(l1, l2) && (abs(l1.c - l2.c) < EPS);\n}\n\nbool operator<(const line &l1, const line &l2) {\n  if (l1.a != l2.a) return l1.a < l2.a;\n  if (l1.b != l2.b) return l1.b < l2.b;\n  return l1.c < l2.c;\n}\n\nmap<line, int> counter;\nint powers2[201];\n\nint cross(pt a, pt b) {\n  return imag(conj(a) * b);\n}\n\nbool collinear(pt a, pt b, pt c) {\n  return !cross(b - a, c - a);\n}\n\nint gcd(int a, int b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\n\nint invTri(int x) {\n  return ((int)sqrt(8 * x + 1) + 1) / 2;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pt> points(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    points[i] = pt(x, y);\n  }\n  sort(points.begin(), points.end(), [](const pt &a, const pt &b) {\n    if (a.real() == b.real()) return a.imag() < b.imag();\n    return a.real() < b.real();\n  });\n\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      counter[pointsToLine(points[i], points[j])]++;\n    }\n  }\n\n  powers2[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    powers2[i] = (2 * powers2[i - 1]) % MOD;\n  }\n\n  int colSubs = n;\n  for (auto slope : counter) {\n    int onLine = invTri(slope.second);\n    colSubs += powers2[onLine] - onLine - 1;\n    colSubs %= MOD;\n  }\n\n  printf(\"%d\\n\", (powers2[n] - colSubs - 1 + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <int MOD> struct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tModInt(signed long long sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = (unsigned long long)x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n\tModInt inverse() const {\n\t\tsigned a = x, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tsigned t = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\tif (u < 0)\n\t\t\tu += MOD;\n\t\tModInt res;\n\t\tres.x = (unsigned)u;\n\t\treturn res;\n\t}\n};\ntemplate <int MOD> ostream &operator<<(ostream &os, const ModInt<MOD> &m) {\n\treturn os << m.x;\n}\ntemplate <int MOD> istream &operator>>(istream &is, ModInt<MOD> &m) {\n\tsigned long long s;\n\tis >> s;\n\tm = ModInt<MOD>(s);\n\treturn is;\n};\n// pow(mint(2), 1000) のように\ntemplate <int MOD> ModInt<MOD> pow(ModInt<MOD> a, unsigned long long k) {\n\tModInt<MOD> r = 1;\n\twhile (k) {\n\t\tif (k & 1)\n\t\t\tr *= a;\n\t\ta *= a;\n\t\tk >>= 1;\n\t}\n\treturn r;\n}\n\n//#define int long long を使っても大丈夫\nusing mint = ModInt<998244353>;\n\n// nCrで用いる\nvector<mint> fact, factinv;\n// nCrで用いる 予め計算しておく\nvoid nCr_compute_factinv(int N) {\n\tN = min(N, mint::Mod - 1);\n\tfact.resize(N + 1);\n\tfactinv.resize(N + 1);\n\tfact[0] = 1;\n\trep(i, 1, N + 1) fact[i] = fact[i - 1] * i;\n\tfactinv[N] = fact[N].inverse();\n\tfor (int i = N; i >= 1; i--)\n\t\tfactinv[i - 1] = factinv[i] * i;\n}\nmint nCr(int n, int r) {\n\tif (n >= mint::Mod)\n\t\treturn nCr(n % mint::Mod, r % mint::Mod) *\n\t\tnCr(n / mint::Mod, r / mint::Mod);\n\treturn r > n ? 0 : fact[n] * factinv[n - r] * factinv[r];\n}\n\nmint nHr(int n, int r) { return r == 0 ? 1 : nCr(n + r - 1, r); }\n\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N; cin >> N;\n\tvector<int>x(N), y(N); rep(i, 0, N) { cin >> x[i] >> y[i]; }\n\tmint ans = pow(mint(2), N) - 1 - N;\n\tusing L = bitset<205>;\n\tunordered_set<L>st;\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tL b;\n\t\t\trep(k, 0, N) {\n\t\t\t\tpii p0 = pii(x[k] - x[i], y[k] - y[i]);\n\t\t\t\tpii p1 = pii(x[j] - x[i], y[j] - y[i]);\n\t\t\t\tint z = p0.first*p1.second - p0.second*p1.first;\n\t\t\t\tif (z == 0)b.set(k);\n\t\t\t}\n\t\t\tif (st.count(b))continue;\n\t\t\tst.insert(b);\n\t\t\tint cnt = b.count();\n\t\t\tdump(cnt);\n\t\t\tans -= pow(mint(2), cnt) - cnt - 1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define X first\n#define Y second\n#define pii pair<ll,ll>\n#define x1 dlfjl\n#define x2 dkfj\n#define MOD 998244353\n#define y1 dskgj\n#define y2 dskfj\n#define N 310\ntypedef long long ll;\nusing namespace std;\nll n,i,j,k,x,y,z,m,q,w,h;\nll a[100500], b[100500], pre[1005000], C[205][205];\nmap<pair<pii,pii>,ll> f;\nll gcd(ll a, ll b)\n{\n    return (b==0?a:gcd(b,a%b));\n}\nll Abs(ll x)\n{\n    return (x>0?x:-x);\n}\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    for (i = 0; i <= 1000; i++)\n        pre[i*(i+1)/2] = i+1;\n    for (i = 0; i <= 200; i++)\n        C[i][0] = 1;\n    for (i = 1; i <= 200; i++)\n        for (j = i; j <= 200; j++)\n            C[j][i] = (C[j-1][i-1] + C[j-1][i])%MOD;\n    ll ans = 1;\n    cin >> n;\n    if (n < 3)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    for (i = 1; i <= n; i++)\n        ans = (ans*2)%MOD;\n    ans -= n+1;\n    ans -= n*(n-1)/2;\n    ans += MOD;\n    ans %= MOD;\n    for (i = 0; i < n; i++)\n        cin >> a[i] >> b[i];\n    for (i = 0; i < n; i++)\n        for (j = i+1; j < n; j++)\n        {\n            if (a[i] == a[j])\n            {\n                f[mp(mp(0,a[i]),mp(MOD,MOD))]++;\n                continue;\n            }\n            int p = a[i]-a[j];\n            int q = b[i]-b[j];\n            int g = gcd(Abs(p), Abs(q));\n            p /= g;\n            q /= g;\n            if ( p < 0)\n                p = -p, q = -q;\n            int x1 = a[i], y1 = b[i], x2 = a[j], y2 = b[j];\n            int xx = y1*(x2-x1)-x1*(y2-y1);\n            int yy = x2-x1;\n            int gg = gcd(Abs(xx), Abs(yy));\n            xx /= gg;\n            yy /= gg;\n            if ( xx < 0)\n                xx = -xx, yy = -yy;\n            f[mp(mp(p,q),mp(xx,yy))]++;\n        }\n    for (auto itr = f.begin(); itr != f.end(); itr++)\n    {\n        int val = (*itr).Y;\n        val = pre[val];\n        for (j = 3; j <= val; j++)\n        {\n            ans -= C[val][j];\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define mod 998244353\n\nll mod_pow(ll x,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*x%mod;\n    x=x*x%mod;\n    n>>=1;\n  }\n  return res;\n}\n\n\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\nconst D eps=1e-8;\nconst D inf=1e12;\nD cross(P a,P b){ return (conj(a)*b).Y; }\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\nbool intersectLP(L l,P p){\n  return abs(cross(l[1]-p,l[0]-p))<eps;\n}\n\nint N;\nvector<P> ps;\n\nint main(){\n  cin>>N;\n  rep(i,N){\n    D x,y;\n    cin>>x>>y;\n    ps.push_back(P(x,y));\n  }\n  ll res=(mod_pow(2,N)+(mod-N)+(mod-((N*(N-1)/2)%mod))+(mod-1))%mod;\n  rep(i,N)repl(j,i+1,N){\n    ll cnt=0;\n    bool ok=true;\n    rep(k,N){\n      if(intersectLP(L(ps[i],ps[j]),ps[k])){\n        if(k<i||(k!=i&&k<j))ok=false;\n        else cnt++;\n      }\n    }\n    if(!ok)continue;\n    ll sub=(mod_pow(2,cnt)+(mod-cnt)%mod+(mod-((cnt*(cnt-1)/2)%mod))%mod+(mod-1))%mod;\n    (res+=mod-sub)%=mod;\n  }\n  cout<<res<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\n#define pb push_back\n#define w1 first\n#define w2 second\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=205,mod=998244353;\nconst db pi=acos(-1.0);\nint n,ans;\nint x[maxn],y[maxn],bin[maxn];\nmap<db,int>cnt;\nint sub(int x,int y){return x-y<0?x-y+mod:x-y;}\nint main(){\n\tread(n);\n\tbin[0]=1;rep(i,1,n)bin[i]=2ll*bin[i-1]%mod;\n\tans=bin[n];\n\trep(i,1,n)read(x[i]),read(y[i]);\n\trep(i,1,n){\n\t\tcnt.clear();\n\t\trep(j,i+1,n)cnt[atan2(y[j]-y[i],x[j]-x[i])]++;\n\t\tfor(map<db,int>::iterator it=cnt.begin();it!=cnt.end();it++)ans=sub(ans,sub(bin[it->w2],1));\n\t}\n\tprintf(\"%d\\n\",sub(ans,n+1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\nconst int N = 210, P = 998244353;\nint n,x[N],y[N],po[N];\n\nint main() {\n\tpo[0]=1;\n\tREP(i,1,N-1) po[i]=po[i-1]*2ll%P;\n\tscanf(\"%d\",&n);\n\tREP(i,1,n) scanf(\"%d%d\",x+i,y+i);\n\tint ans = (po[n]-1-n*(n+1)/2)%P;\n\tREP(i,1,n) REP(j,i+1,n) {\n\t\tint cnt = 0;\n\t\tREP(k,j+1,n) if ((x[j]-x[i])*(y[k]-y[i])==(x[k]-x[i])*(y[j]-y[i])) ++cnt;\n\t\tans = (ans-po[cnt]+1)%P;\n\t}\n\tif (ans<0) ans+=P;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, x[213] = {}, y[213] = {}, p[213] = {1}, z = 0;\n    bool b[213][213] = {};\n    cin >> n;\n    for (int i = 1; i <= n; i++) p[i] = p[i - 1] * 2 % 998244353;\n    for (int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n    for (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) if (!b[i][j]) {\n        vector<int> c = {i, j};\n        int w = 2;\n        for (int k = j + 1; k <= n; k++) if ((x[i] - x[j]) * (y[i] - y[k]) == (y[i] - y[j]) * (x[i] - x[k])) w++, c.push_back(k);\n        for (int k : c) for (int l : c) b[k][l] = 1;\n        z = (z + p[w] + 998244352 - w) % 998244353;\n    }\n    cout << (p[n] - z - n + 998244352) % 998244353;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 2e2 + 10,mod = 998244353;\nconst double Pi = acos(-1.0),eps = 1e-9;\n\nstruct node {\n\tint x,y;\n} P[N];\nbool vis[N];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline int fpm(int a,int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1) res = 1ll * res * a % mod;\n\t\ta = 1ll * a * a % mod,b /= 2;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n = read(),ans = 0;\n\tFor(i,1,n) P[i].x = read(),P[i].y = read();\n\tans = (fpm(2,n) - 1 - n - 1ll * n * (n - 1) / 2) % mod;\n\n\tFor(i,1,n) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tFor(j,1,n) if((i ^ j) && !vis[j]) {\n\t\t\tint cnt = 1;\n\t\t\tdouble val = atan2(P[j].y - P[i].y,P[j].x - P[i].x);\n\t\t\tFor(k,1,n) if(k ^ i) {\n\t\t\t\tdouble cur = atan2(P[k].y - P[i].y,P[k].x - P[i].x);\n\t\t\t\tif(abs(cur - val) < eps || abs(cur - val - Pi) < eps || abs(cur - val + Pi) < eps)\n\t\t\t\t\tcnt++,vis[k] = true;\n\t\t\t}\n\t\t\tans = (ans - 1ll * (fpm(2,cnt) - 1 - cnt - 1ll * cnt * (cnt - 1) / 2 % mod) * fpm(cnt,mod - 2)) % mod;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",(ans + mod) % mod);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#include <bitset>\n#include <complex>\n#include <cmath>\n#include <array>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3fLL\n#define mod 998244353\n#define MOD 1000000007\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pint;\ntypedef pair<ll,ll> pll;\ntypedef tuple<int,int,int> tint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<ull> vull;\ntypedef vector<pint> vpint;\nint dx[8]={0,0,-1,1,1,1,-1,-1};\nint dy[8]={-1,1,0,0,1,-1,1,-1};\nconst int SIZE=250;\n//ここまでテンプレ\nvint X,Y;\nbool onLine(int i,int j,int k){\n\tint ret=(X[j]-X[i])*(Y[k]-Y[i])-(Y[j]-Y[i])*(X[k]-X[i]);\n\treturn !ret;\n}\nint main(){\n\tint N;\n\tcin>>N;\n\tfor(int i=0;i<N;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tX.pb(x);\n\t\tY.pb(y);\n\t}\n\tset<vint> tes;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\tvint v;\n\t\t\tv.pb(i);\n\t\t\tv.pb(j);\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tif(i==k || j==k)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(onLine(i,j,k))\n\t\t\t\t\tv.pb(k);\n\t\t\t}\n\t\t\tsort(v.begin(),v.end());\n\t\t\ttes.insert(v);\n\t\t}\n\t}\n\tint di[SIZE]={1,0};\n\tfor(int i=1;i<SIZE;i++)\n\t\tdi[i]=di[i-1]*2%mod;\n\tll ans=1+N;\n\tfor(vint v:tes){\n\t\tint n=v.size();\n\t\t(ans+=di[n]-n-1)%=mod;\n\t}\n\tcout<<(di[N]+mod-ans)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nconst double pi=acos(-1);\nconst int p=998244353;\nint n,x[210],y[210],pow2[210],ans;\nbool flag[210][210];\nstruct data\n{\n    int id;\n    double agl;\n    bool operator<(const data &t) const\n    {\n        return agl<t.agl;\n    }\n} a[210];\n\ndouble get(int y,int x)\n{\n    if (y<0 || !y && x<0)\n        return atan2(-y,-x);\n    return atan2(y,x);\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    repu(i,1,n)\n        scanf(\"%d%d\",&x[i],&y[i]);\n    pow2[0]=1;\n    repu(i,1,n)\n        pow2[i]=pow2[i-1]*2%p;\n    ans=(pow2[n]+p-n-1)%p;\n    repu(i,1,n)\n    {\n        int m=0;\n        repu(j,i+1,n)\n            a[++m]=(data){j,get(y[j]-y[i],x[j]-x[i])};\n        for (int j=1,k; j<=m; j=k)\n        {\n            for (k=j+1; k<=m && a[k].agl==a[j].agl; ++k);\n            if (!flag[i][a[j].id])\n            {\n                (ans+=p-pow2[k-j+1]+k-j+2)%=p;\n                repu(ii,j,k-1)\n                {\n                    flag[i][a[ii].id]=flag[a[ii].id][i]=1;\n                    repu(jj,ii+1,k-1)\n                        flag[a[ii].id][a[jj].id]=flag[a[jj].id][a[ii].id]=1;\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing I = long long;\nconst I M = 998244353;\n\nstruct Point {I x, y;};\nbool same_line(auto& a, auto& b, auto& p) {\n  Point v1{b.x-a.x, b.y-a.y};\n  Point v2{p.x-a.x, p.y-a.y};\n  return v1.x*v2.y == v1.y*v2.x;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  vector<Point> P(N);\n  for(auto& i: P) cin >> i.x >> i.y;\n\n  I ans = 1;\n  for(auto i=0; i<N; ++i) ((ans *= 2) %= M);\n  (ans -= 1 + N + N*(N-1)/2) %= M;\n\n  vector<vector<bool>> used(N, vector<bool>(N));\n  for(auto i=0; i<N; ++i) for(auto j=i+1; j<N; ++j) if(!used[i][j]) {\n    vector<int> v = {i, j};\n    for(auto k=j+1; k<N; ++k) if(same_line(P[i], P[j], P[k])) v.emplace_back(k);\n    if(v.size() <= 2) continue;\n    for(auto x: v) for(auto y: v) used[x][y] = true;\n    I cnt = 1;\n    for(auto k=0; k<v.size(); ++k) (cnt *= 2) %= M;\n    (ans -= cnt) %= M;\n    (ans += 1 + v.size() + v.size()*(v.size()-1)/2) %= M;\n  }\n\n  cout << (ans + M) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n//#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n) {\n\treturn std::vector<std::vector<T>>(n);\n}\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) res *= n, res %= mod;\n\t\tn *= n; n %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\nbool used[202][202];\n\ndouble Heron(double a, double b, double c) {\n\tdouble s = (a + b + c) / 2;\n\treturn std::sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tVEC_ROW(int, n, x, y);\n\n\tauto dist = [&](int i, int j) {\n\t\treturn std::hypot(x[i] - x[j], y[i] - y[j]);\n\t};\n\n\tint ans = powMod(2, n, MOD) - 1 - n;\n\tans %= MOD; ans += MOD; ans %= MOD;\n\tREP(i, n) used[i][i] = true;\n\tREP(i, n) FOR(j, i+1, n) {\n\t\tif (used[i][j]) continue;\n\t\tstd::vector<int> vec;\n\t\tREP(k, n) {\n\t\t\tdouble ij = dist(i, j);\n\t\t\tdouble jk = dist(j, k);\n\t\t\tdouble ki = dist(k, i);\n\t\t\tif (Heron(ij,jk,ki) < EPS) {\n\t\t\t\tvec.emplace_back(k);\n\t\t\t}\n\t\t}\n\t\tint cnt = vec.size();\n\t\tREP(ii, vec.size()) REP(jj, vec.size()) {\n\t\t\tused[ii][jj] = true;\n\t\t}\n\t\tans -= powMod(2, cnt, MOD) - cnt - 1;\n\t\tans %= MOD; ans += MOD; ans %= MOD;\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n    vec d, root;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n        d = vec(V);\n        root = vec(V);\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void erase_edge(int from, int to){\n        vec e(0);\n        REP(i, G[from].size()){\n            if(G[from][i].to == to) e.push_back(i);\n        }\n        IREP(i, e.size()) G[from].erase(G[from].begin() + e[i]);\n    }\n\n    void erase_edge2(int v1, int v2){\n        erase_edge(v1, v2);\n        erase_edge(v2, v1);\n    }\n\n    void dfs(int v, vector<bool> &used, int &n){\n        REP(k, G[v].size()){\n            if(!used[G[v][k].to]){\n                n++;\n                used[G[v][k].to] = true;\n                dfs(used[G[v][k].to], used, n);\n            }\n        }\n    }\n\n};\n\nint fastpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = fastpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int comb(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nbool on_line(int x1, int y1, int x2, int y2, int x3, int y3){\n    int X1 = x1 - x3;\n    int Y1 = y1 - y3;\n    int X2 = x2 - x3;\n    int Y2 = y2 - y3;\n    if(X1 * Y2 == Y1 * X2){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    vec x(N), y(N);\n    REP(i, N) cin >> x[i] >> y[i];\n\n    Graph line(N);\n    REP(i, N){\n        FOR(j, i + 1, N){\n            FOR(k, j + 1, N){\n                if(on_line(x[i], y[i], x[j], y[j], x[k], y[k])){\n                    line.add_edge2(i, j, 0);\n                    line.add_edge2(i, k, 0);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    int mod = 998244353;\n    Combination C(N, mod);\n    FOR(k, 3, N + 1) ans = (ans + C.comb(N, k)) % mod;\n\n    vector<bool> used(N, false);\n    REP(i, N){\n        if(!used[i]){\n            int n = 0;\n            line.dfs(i, used, n);\n            FOR(k, 3, n + 1) ans = (ans + mod - C.comb(n, k)) % mod;\n        }\n    }\n\n    cout << ans;\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vdouble = vector<double>;\nusing vvdouble = vector<vdouble>;\nusing vvvdouble = vector<vvdouble>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\nconstexpr int mod2 = 998244353;\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) { return (a > b && (a = b, true)); }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) { return (a < b && (a = b, true)); }\ntemplate<typename T>\nbool isin(T y, T x, T h, T w) { return (0 <= y && 0 <= x && y < h && x < w); }\ntemplate<typename T>\nbool isin1(T y, T x, T h, T w) { return (0 < y && 0 < x && y <= h && x <= w); }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++) os << \" \" << v[i];\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nconstexpr double EPS = 1e-10;\nbool equals(double a, double b) { return (abs(a - b) < EPS); }\n\nstruct V2 {\n\tdouble x, y;\n\tV2(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tV2 operator + (V2 p) const { return (V2(x + p.x, y + p.y)); }\n\tV2 operator - (V2 p) const { return (V2(x - p.x, y - p.y)); }\n\tV2 operator * (double r) const { return (V2(x * r, y * r)); }\n\tV2 operator / (double r) const { return (V2(x / r, y / r)); }\n\n\tdouble norm() const { return (sqrt(sqrNorm())); }\n\tdouble sqrNorm() const { return (x*x + y*y); }\n\n\tbool operator < (const V2 &p) const { \n\t\treturn (x != p.x ? x < p.x : y < p.y); \n\t}\n\tbool operator == (const V2 &p) const {\n\t\treturn (equals(x, p.x) && equals(y, p.y));\n\t}\n\n\tV2 rotate90() const { return (V2(y, -x)); }\n\tV2 normalized() const { return (*this / norm()); }\n\n\tdouble dot(const V2 &p) const { return (x*p.x + y*p.y); }\n\tdouble cross(const V2 &p) const { return (x*p.y - y*p.x); }\n\tdouble arg() const { return (atan2(y, x)); }\n};\n\nvoid Main() {\n\tint N; cin >> N;\n\tvector<V2> ps(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> ps[i].x >> ps[i].y;\n\t}\n\n\tll sum = 0;\n\n\tsort(begin(ps), end(ps));\n\tfor (int a = 0; a < N; a++) {\n\t\tvector<pair<double, V2>> dats;\n\t\tint n = N-a-1;\n\t\tfor (int b = a+1; b < N; b++) {\n\t\t\tdats.emplace_back((ps[b]-ps[a]).arg(), ps[b]-ps[a]);\n\t\t}\n\t\tsort(begin(dats), end(dats));\n\t\tvector<V2> nps(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnps[i] = dats[i].second;\n\t\t}\n\n\t\tvvll contval(n, vll(n, 1));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tfor (int k = j+1; k < n; k++) {\n\t\t\t\t\tif (j == i || j == k) continue;\n\t\t\t\t\tdouble cr1 = nps[i].cross(nps[j]), cr2 = -nps[k].cross(nps[j]-nps[k]);\n\t\t\t\t\tdouble cr3 = (nps[k]-nps[i]).cross(nps[j]-nps[i]);\n\t\t\t\t\tif (cr1 > -EPS && cr2 > -EPS && cr3 > -EPS || cr1 < EPS && cr2 < EPS && cr3 < EPS) {\n\t\t\t\t\t\t(contval[i][k] *= 2) %= mod2;\n\t\t\t\t\t\t//cout << a << \" \" << nps[i].x << \" \" << nps[i].y << \" \" << nps[k].x << \" \" << nps[k].y << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tvvll dp(n, vll(n, 0));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tif (!equals(nps[i].cross(nps[j]), 0.0)) dp[i][j] = contval[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tV2 v1 = nps[j]-nps[i];\n\t\t\t\tfor (int k = j+1; k < n; k++) {\n\t\t\t\t\tV2 v2 = nps[k]-nps[i];\n\t\t\t\t\tif (v1.cross(v2) < EPS) continue;\n\t\t\t\t\tif (equals(nps[j].arg(), nps[k].arg())) continue;\n\t\t\t\t\t(dp[j][k] += contval[j][k] * dp[i][j]) %= mod2;\n\t\t\t\t}\n\t\t\t\t(sum += dp[i][j]) %= mod2;\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n   }\n\n    rep (i, size) {\n        perm_invs[i] = mod_inv(perms[i], mod);\n    }\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define MOD    (998244353LL)\n\nbool oneline(t2 xy1, t2 xy2, t2 xy3)\n{\n    ll x1 = get<0>(xy1);\n    ll y1 = get<1>(xy1);\n    ll x2 = get<0>(xy2);\n    ll y2 = get<1>(xy2);\n    ll x3 = get<0>(xy3);\n    ll y3 = get<1>(xy3);\n\n    ll val1 = (x2 - x1) * (y3 - y1);\n    ll val2 = (x3 - x1) * (y2 - y1);\n    return val1 == val2;\n}\n\nbool group_find(set<ll> groups[202], ll a, ll b, ll c) {\n    set<ll> group_exists;\n    intersection(groups[a], groups[b], group_exists);\n\n    if (!group_exists.empty()) {\n        assert(group_exists.size() == 1);\n        groups[c].insert(*(group_exists.begin()));\n        return true;\n    }\n\n    return false;\n}\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    V<t2> xylist; llinl2(xylist, n);\n\n    S set<ll> groups[202];\n    ll group_end = 0LL;\n    rep (i, n) srep (j, i+1, n) srep (k, j+1, n) {\n        if (!oneline(xylist[i], xylist[j], xylist[k])) continue;\n\n        if (group_find(groups, i, j, k)) continue;\n        if (group_find(groups, j, k, i)) continue;\n        if (group_find(groups, k, i, j)) continue;\n\n        groups[i].insert(group_end);\n        groups[j].insert(group_end);\n        groups[k].insert(group_end);\n        group_end++;\n    }\n\n    S ll group_cnt[5005];\n    memset(group_cnt, 0, sizeof(group_cnt));\n    rep (i, 202) for (auto gid : groups[i]) group_cnt[gid]++;\n\n    S ll gcnt_cnt[202];\n    memset(gcnt_cnt, 0, sizeof(gcnt_cnt));\n    rep (gid, 5005) gcnt_cnt[group_cnt[gid]]++;\n\n    S ll perms[202];\n    S ll perm_invs[202];\n    make_perms(perms, perm_invs, 202, MOD);\n\n    ll ans = 0LL;\n    srep (pcnt, 3, n+1) {\n        ll incr = 1LL;\n        incr *= perms[n];\n        incr %= MOD;\n        incr *= perm_invs[pcnt];\n        incr %= MOD;\n        incr *= perm_invs[n-pcnt];\n        incr %= MOD;\n        ans += incr;\n        ans %= MOD;\n    }\n\n    srep (gcnt, 3, n+1) {\n        srep (pcnt, 3, gcnt+1) {\n            ll decr = 1LL;\n            decr *= perms[gcnt];\n            decr %= MOD;\n            decr *= perm_invs[pcnt];\n            decr %= MOD;\n            decr *= perm_invs[gcnt-pcnt];\n            decr %= MOD;\n            decr *= gcnt_cnt[gcnt];\n            decr %= MOD;\n            ans -= decr;\n            while (ans < 0) ans += MOD;\n        }\n    }\n\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nbool usededge[200][200];\nll x[200], y[200];\nbool online(int i, int j, int k) {\n\tif ((x[j] - x[i])*(y[k] - y[i]) - (x[k] - x[i])*(y[j] - y[i]))return false;\n\telse return true;\n}\nint main(){\n\tll n; cin >> n;\n\tll out = mod_pow(2, n);\n\tout = ((out - 1 - n - n * (n - 1) / 2) % mod + mod) % mod;\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\trep(i, n) {\n\t\tRep(j,i+1, n) {\n\t\t\tif (usededge[i][j])continue;\n\t\t\tll cnt = 2;\n\t\t\tRep(k, j + 1, n) {\n\t\t\t\tif (usededge[i][k])continue;\n\t\t\t\tif (online(i, j, k)) {\n\t\t\t\t\tusededge[i][k] = usededge[j][k] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout = ((out - mod_pow(2, cnt) + 1 + cnt + cnt * (cnt - 1) / 2) % mod + mod) % mod;\n\t\t}\n\t}\n\tcout << out << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct point {\n\tint x, y;\n\tbool operator<(const point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tpoint operator -(const point &p)const {\n\t\treturn { x - p.x,y - p.y };\n\t}\n\tint Mul(point p) const{\n\t\treturn x*p.x + y*p.y;\n\t}\n}P[210], OO;\n\nint ccw(point a, point b, point c) {\n\treturn (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);\n}\n\nstruct Vec {\n\tpoint p;\n\tbool operator<(const Vec &v)const {\n\t\treturn p.y * v.p.x != v.p.y * p.x ? p.y * v.p.x < v.p.y * p.x : p.Mul(p) < v.p.Mul(v.p);\n\t}\n}w[210];\n\nbool between(point a, point b, point c) {\n\treturn ccw(a, b, c) == 0 && (c - a).Mul(c - b) <= 0;\n}\n\nint CC[210], D[210][210], Mod = 998244353, po[210], res, C[210][210];\n\nvoid Do(int n) {\n\tint i, j, k;\n\tif (n <= 1)return;\n\tfor (i = 1; i <= n; i++) {\n\t\tCC[i] = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (i != j && between(OO, w[i].p, w[j].p))CC[i]++;\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)for (j = i + 2; j <= n; j++){\n\t\tC[i][j] = 0;\n\t\tfor (k = i + 1; k < j; k++) if (ccw(w[i].p, w[j].p, w[k].p) >= 0)C[i][j]++;\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = i+1; j <= n; j++) {\n\t\t\tD[i][j] = 0;\n\t\t\tif (between(OO, w[j].p, w[i].p)) continue;\n\t\t\tint c = C[i][j];\n\t\t\tfor (k = 1; k < i; k ++) {\n\t\t\t\tD[i][j] = (D[i][j] + 1ll * D[k][i] * po[c]) % Mod;\n\t\t\t}\n\t\t\tD[i][j] = (D[i][j] + po[c + CC[i]]) % Mod;\n\t\t\tres = (res + D[i][j]) % Mod;\n\t\t}\n\t}\n}\n\nint main() {\n\tint i, j, n;\n\tscanf(\"%d\", &n);\n\tpo[0] = 1;\n\tfor (i = 1; i <= n; i++)po[i] = po[i - 1] * 2 % Mod;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &P[i].x, &P[i].y);\n\t}\n\tsort(P, P + n);\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tw[j - i].p = P[j] - P[i];\n\t\t}\n\t\tsort(w + 1, w + n - i);\n\t\tDo(n - i - 1);\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <limits>\n#include <set>\n#define REP(i,n) for(long (i)=0;(i)<(n);(i)++)\n#define REPI(i,a,b) for(long (i)=(a);(i)<(b);(i)++)\n#define INF numeric_limits<double>::infinity()\nconstexpr long MOD = 998244353;\nconstexpr double eps = 1e-10;\nusing namespace std;\nusing P = pair<double, double>;\nusing VI = vector<long>;\n\nP line(P a, P b) {\n    double grad = (a.second - b.second) / (a.first - b.first + eps);\n    if (abs(grad) > 1e8) {\n        return P(INF, a.first);\n    } else if (abs(grad) < 1e-8) {\n        return P(0, a.second);\n    }\n    return P(grad, a.second - grad * a.first);\n}\n\nbool onLine(P line, P p) {\n    if (line.first == INF) {\n        return line.second == p.first;\n    } else if (line.first == 0) {\n        return line.second == p.second;\n    }\n    return abs(line.first * p.first + line.second - p.second) < 1e-8;\n}\n\nlong powmod(long a, long n) {\n    if (n == 0) return 1l;\n    if (n % 2 == 0) {\n        long d = powmod(a, n / 2);\n        return d * d % MOD;\n    }\n    return a * powmod(a, n - 1) % MOD;\n}\n\nint main() {\n    long n;\n    cin >> n;\n    vector<P> v;\n    REP(i,n) {\n        long x, y;\n        cin >> x >> y;\n        v.push_back(P(x,y));\n    }\n    \n    long ans = powmod(2, n);\n    ans = ans - 1 - n - n * (n - 1) / 2;\n    \n    set<P> lines;\n    \n    REP(i,n) {\n        long cnt = 2;\n        REPI(j,i+1,n) {\n            P l = line(v[i], v[j]);\n            if (lines.find(l) == lines.end()) {\n                lines.insert(l);\n                REPI(k,j+1,n) {\n                    if (onLine(l, v[k])) cnt++;\n                }\n            }\n        }\n        if (cnt > 2) {\n            ans -= powmod(2, cnt) - 1 - cnt - cnt * (cnt - 1) / 2;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2000;\ntypedef long long ll;\nconst ll mod=998244353;\nll x[maxn],y[maxn];\nll power(ll a,ll b)\n{\n    ll ret;\n    if (b==0) return 1;\n    ret=pow(a,b/2);\n    ret=ret*ret%mod;\n    if (b%2) ret=ret*2%mod;\n    return ret;\n}\nint main()\n{\n    //freopen(\"text.in\",\"r\",stdin);\n    ll i,ans,tmp,j,k,n;\n    scanf(\"%lld\",&n);\n    for (i=1;i<=n;i++) {\n        scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    ans=((power(2LL,n)-n-1)%mod+mod)%mod;\n    ans=((ans-(n-1)*n/2)%mod+mod)%mod;\n    for (i=1;i<=n;i++) {\n        for (j=i+1;j<=n;j++) {\n            tmp=0;\n            for (k=j+1;k<=n;k++) {\n                if ((y[k]-y[i])*(x[j]-x[i])==(x[k]-x[i])*(y[j]-y[i])) tmp++;\n            }\n            ans=((ans-power(2LL,tmp)+1)%mod+mod)%mod;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/** @Date    : 2017-09-02 20:30:47\n  * @FileName: C.cpp\n  * @Platform: Windows\n  * @Author  : Lweleth (SoungEarlf@gmail.com)\n  * @Link    : https://github.com/\n  * @Version : $Id$\n  */\n#include <bits/stdc++.h>\n#define LL long long\n#define PII pair<int ,int>\n#define MP(x, y) make_pair((x),(y))\n#define fi first\n#define se second\n#define PB(x) push_back((x))\n#define MMG(x) memset((x), -1,sizeof(x))\n#define MMF(x) memset((x),0,sizeof(x))\n#define MMI(x) memset((x), INF, sizeof(x))\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 210;\nconst double eps = 1e-8;\nconst LL mod = 998244353;\n\nLL fa[210], inv[210];\n\nLL fpow(LL a, int n)\n{\n    LL r = 1;\n    while(n > 0)\n    {\n        if(n & 1)\n            r = r * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return r;\n}\nvoid init()\n{\n    fa[0] = 1;\n    inv[0] = 1;\n    for(LL i = 1; i <= 200; i++)\n    {\n        fa[i] = fa[i-1] * i % mod;\n        inv[i] = fpow(fa[i], mod - 2);\n    }\n}\n\nLL C(LL n, LL m)\n{\n    if(n < 0)\n        return 0;\n    n >>= 1;\n    if(n == 0)\n    \treturn 1LL;\n    LL ans = 0;\n    ans = ((fa[n + m] * inv[m] % mod)* inv[n]) % mod;\n    return ans;\n}\n\n\nstruct point\n{\n\tdouble x, y;\n\tpoint(){}\n\tpoint(double _x, double _y){x = _x, y = _y;}\n\tpoint operator -(const point &b) const\n\t{\n\t\treturn point(x - b.x, y - b.y);\n\t}\n\tdouble operator *(const point &b) const \n\t{\n\t\treturn x * b.x + y * b.y;\n\t}\n\tdouble operator ^(const point &b) const\n\t{\n\t\treturn x * b.y - y * b.x;\n\t}\n};\n\ndouble xmult(point p1, point p2, point p0)  \n{  \n    return (p1 - p0) ^ (p2 - p0);  \n}  \n\ndouble distc(point a, point b)\n{\n\treturn sqrt((double)((b - a) * (b - a)));\n}\nint sign(double x)\n{\n\tif(fabs(x) < eps)\n\t\treturn 0;\n\tif(x < 0)\n\t\treturn -1;\n\telse \n\t\treturn 1;\n}\n\n////////\nint n;\npoint stk[N];\npoint p[N];\n\nint cmpC(point a, point b)//水平序排序\n{\n\treturn sign(a.x - b.x) < 0 || (sign(a.x - b.x) == 0 && sign(a.y - b.y) < 0);\n}\n\nint Graham()//水平序\n{\n\tsort(p, p + n, cmpC);\n\tint top = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\twhile(top >= 2 && sign(xmult(stk[top - 2], stk[top - 1], p[i])) < 0)\n\t\t\ttop--;\n\t\tstk[top++] = p[i];\n\t}\n\tint tmp = top;\n\tfor(int i = n - 2; i >= 0; i--)\n\t{\n\t\twhile(top > tmp && sign(xmult(stk[top - 2],stk[top - 1] ,p[i] )) < 0)\n\t\t\ttop--;\n\t\tstk[top++] = p[i];\n\t}\n\tif(n > 1)\n\t\ttop--;\n\treturn top;\n}\n\n\nint check(int m)\n{\n\t//cout << m << endl;\n\tLL c = 2;\n\tLL t = 0;\n\tfor(int i = 1; i < m; i++)\n\t{\n\t\tif(sign(xmult(stk[i - 1], stk[(i + 1)%(m)], stk[i])) == 0 \n\t\t\t&& sign(xmult(stk[i], stk[(i + 2)%(m)], stk[(i + 1)%(m)])) == 0)\n\t\t\tc++;\n\t\telse if(c > 2) c++ , t = (t + fpow(2, c) - (1LL + c + c * (c - 1) / 2LL) + mod) % mod, c = 2;\n\t}\n\tif(c > 2)\n\t\tc++, t = (t + fpow(2, c) - (1LL + c + c * (c - 1) / 2LL) + mod) % mod;\n\treturn t;\n}\n/////////\nint main()\n{\n\n\twhile(~scanf(\"%d\", &n))\n\t{\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tp[i] = point(x, y);\n\t\t}\n\t\tLL cnt = Graham();\n\t\t//cout << cnt;\n\t\tLL ans = (fpow(2, n) - check(cnt) - (1LL + n + (n - 1) * n / 2LL) + mod) % mod;\n\t\tif(cnt > 2)\n\t\t\tprintf(\"%lld\\n\", ans);\n\t\telse printf(\"0\\n\");\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\nconst int maxn = 205;\n\nint x[maxn],y[maxn];\n\nlong long ans[maxn];\n\nconst int mod = 998244353;\n\nint qpow(int x,int n){\n\tint ret = 1;\n\twhile(n > 0){\n\t\tif(n & 1){\n\t\t\tret = 1LL * ret * x % mod;\n\t\t}\n\t\tx = 1LL * x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid upd(long long &a,int b){\n\ta += b;\n\tif(a >= mod) a -= mod;\n\tif(a < 0) a += mod;\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d%d\",x + i,y + i);\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++) if(j != i){\n\t\t\tint num = 2;\n\t\t\tfor(int k = 1;k <= n;k++) if(k != i && k != j){\n\t\t\t\tif((x[k] - x[i]) * (y[j] - y[i]) - (x[j] - x[i]) * (y[k] - y[i]) == 0) num++;\t\n\t\t\t}\n\t\t\tupd(ans[num],(qpow(2,num) - 1 - num + mod) % mod);\n\t\t}\n\t}\n\tlong long res = 0;\n\tupd(res,qpow(2,n));\n\tupd(res,-n-1);\n\tfor(int i = 1;i <= n;i++){\n\t\tint tmp = ans[i] * qpow(i,mod - 2) % mod * qpow(i - 1,mod - 2) % mod;\n\t\tupd(res,-tmp);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct mypt {\n        int x;\n        int y;\n};\n\nbool on_line(mypt a, mypt b, mypt t) {\n        return (t.x-a.x)*(t.y-b.y) - (t.y-a.y)*(t.x-b.x) == 0;\n}\n\npair<ll,ll> egcd(ll a, ll b) {\n        ll s0=1,s1=0,s2=a;\n        ll t0=0,t1=1,t2=b;\n        while (t2 != 0) {\n                ll q=s2/t2;\n                ll r0=t0,r1=t1,r2=t2;\n                t0=s0-q*t0,t1=s1-q*t1,t2=s2-q*t2;\n                s0=r0,s1=r1,s2=r2;\n        }\n\n        return pair<ll,ll>(s0,s1);\n}\n\nll mod_inv(ll x, ll m) {\n        x %= m;\n        pair<ll,ll> p = egcd(x,m);\n        return (p.first%m+m)%m;\n}\n\nconst int MAXN=2e2+2+2;\nconst ll MOD=998244353;\nint N;\nmypt p[MAXN];\n\nll twos[MAXN];\nll tot_weight[MAXN];\nll line_weight[MAXN];\n\nint main() {\n        cin >> N;\n        for (int i=0; i<N; ++i)\n                cin >> p[i].x >> p[i].y;\n\n        twos[0] = 1;\n        for (int i=1; i<MAXN; i++)\n                twos[i] = (2*twos[i-1])%MOD;\n\n        tot_weight[0] = 0;\n        tot_weight[1] = 0;\n        for (int i=2; i<MAXN; ++i)\n                tot_weight[i] = (twos[i]+MOD-i-1)%MOD;\n\n\n        for (int i=0; i<MAXN; ++i)\n                line_weight[i] = (mod_inv(i*(i-1)/2,MOD)*tot_weight[i])%MOD;\n\n\n        ll subs = tot_weight[N];\n        for (int a=0; a<N; ++a) {\n                for (int b=a+1; b<N; ++b) {\n                        int line_ct=0;\n                        for (int c=0; c<N; ++c) {\n                                if (on_line(p[a],p[b],p[c])) {\n                                        line_ct++;\n                                }\n                        }\n\n                        subs = (subs + MOD - line_weight[line_ct])%MOD;\n                }\n        }\n\n        cout << subs << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\nusing namespace std;\n\nconst int maxn = 210;\nconst ll Mod = 998244353;\n\nint n;\nll pw[maxn];\nstruct point\n{\n\tint x,y;\n}p[maxn]; \nbool v[maxn][maxn];\n\nbool judge(point x,point y,const point z)\n{\n\tx.x-=z.x; x.y-=z.y;\n\ty.x-=z.x; y.y-=z.y;\n\treturn (x.x*y.y-x.y*y.x)==0;\n}\nll ans;\n\nint main()\n{\n\tpw[0]=1ll;\n\tfor(int i=1;i<maxn;i++) pw[i]=pw[i-1]*2ll%Mod;\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&p[i].x,&p[i].y);\n\tans=pw[n];\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++) \n\t\t{\n\t\t\tbool flag=true;\n\t\t\tfor(int k=i+1;k<j;k++) if(judge(p[i],p[k],p[j])) {flag=false; break;}\n\t\t\tfor(int k=1;k<i;k++) if(judge(p[k],p[i],p[j])) {flag=false; break;}\n\t\t\tif(!flag) continue;\n\t\t\tint ct=2;\n\t\t\tfor(int k=j+1;k<=n;k++) if(judge(p[i],p[j],p[k])) ct++;\n\t\t\t(ans-=pw[ct]-ct-1)%=Mod;\n\t\t}\n\t}\n\t\n\tans=(ans-n-1+Mod)%Mod;\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n//#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n) {\n\treturn std::vector<std::vector<T>>(n);\n}\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) res *= n, res %= mod;\n\t\tn *= n; n %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\nbool used[202][202];\n\ndouble Heron(ld a, ld b, ld c) {\n\tld s = (a + b + c) / 2;\n\treturn std::sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tVEC_ROW(int, n, x, y);\n\n\tauto dist = [&](int i, int j) {\n\t\treturn std::hypotl(x[i] - x[j], y[i] - y[j]);\n\t};\n\n\tint ans = powMod(2, n, MOD) - 1 - n;\n\tans %= MOD; ans += MOD; ans %= MOD;\n\tREP(i, n) used[i][i] = true;\n\tREP(i, n) FOR(j, i+1, n) {\n\t\tif (used[i][j]) continue;\n\t\tstd::vector<int> vec;\n\t\tREP(k, n) {\n\t\t\tld ij = dist(i, j);\n\t\t\tld jk = dist(j, k);\n\t\t\tld ki = dist(k, i);\n\t\t\tif (Heron(ij,jk,ki) < EPS) {\n\t\t\t\tvec.emplace_back(k);\n\t\t\t}\n\t\t}\n\t\tint cnt = vec.size();\n\t\tREP(ii, vec.size()) REP(jj, vec.size()) {\n\t\t\tused[ii][jj] = true;\n\t\t}\n\t\tans -= powMod(2, cnt, MOD) - cnt - 1;\n\t\tans %= MOD; ans += MOD; ans %= MOD;\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n//#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n) {\n\treturn std::vector<std::vector<T>>(n);\n}\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) res *= n, res %= mod;\n\t\tn *= n; n %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\nbool used[202][202];\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tVEC_ROW(int, n, x, y);\n\n\tauto dist = [&](int i, int j) {\n\t\treturn std::hypot(x[i] - x[j], y[i] - y[j]);\n\t};\n\n\tint ans = powMod(2, n, MOD) - 1 - n;\n\tans %= MOD; ans += MOD; ans %= MOD;\n\tREP(i, n) used[i][i] = true;\n\tREP(i, n) FOR(j, i+1, n) {\n\t\tif (used[i][j]) continue;\n\t\tstd::vector<int> vec;\n\t\tREP(k, n) {\n\t\t\tif (i == k || j == k) continue;\n\t\t\tbool f = false;\n\t\t\tdouble ij = dist(i, j);\n\t\t\tdouble jk = dist(j, k);\n\t\t\tdouble ki = dist(k, i);\n\t\t\tf |= std::abs(ij + jk - ki) < EPS;\n\t\t\tf |= std::abs(jk + ki - ij) < EPS;\n\t\t\tf |= std::abs(ki + ij - jk) < EPS;\n\t\t\tif (f) {\n\t\t\t\tvec.emplace_back(k);\n\t\t\t}\n\t\t}\n\t\tvec.emplace_back(i);\n\t\tvec.emplace_back(j);\n\t\tint cnt = vec.size();\n\t\tREP(ii, vec.size()) REP(jj, vec.size()) {\n\t\t\tused[ii][jj] = used[jj][ii] = true;\n\t\t}\n\t\tans -= powMod(2, cnt, MOD) - cnt - 1;\n\t\tif (ans < 0) ans += MOD;\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\n#define PII pair<int, int>\n\nvoid add(int &a, int b) {\n    a += b;\n    while(a >= MOD) {\n        a -= MOD;\n    }\n    while(a < 0) {\n        a += MOD;\n    }\n}\n\nint det(PII a, PII b, PII c) {\n    return a.first * b.second + b.first * c.second + c.first * a.second - b.first * a.second - c.first * b.second - a.first * c.second;    \n};\n\nint main() {\n    int n; cin >> n;\n    vector<pair<int, int>> p(n);\n    \n    for(int i = 0; i < n; ++i)\n        cin >> p[i].first >> p[i].second;\n\n    sort(p.begin(), p.end());\n    \n    vector<int> two(n + 1, 1);\n    for(int i = 1; i <= n; ++i) {\n        two[i] = 2LL * two[i - 1] % MOD;\n    }\n    \n    int ans = two[n];\n    add(ans, -1);\n    add(ans, -n);\n    add(ans, -(n * (n - 1) / 2));\n    \n    map<pair<int, int>, int> have;\n\n    for(int i = 0; i < n; ++i) {\n        for(int j = i + 1; j < n; ++j) {\n            int many = 0;\n            \n            vector<int> who;\n\n            for(int k = 0; k < n; ++k) {\n                if(det(p[i], p[j], p[k]) == 0) {\n                    many += 1;\n                    if(who.size() < 2) {\n                        who.push_back(k);\n                    }\n                }\n            }\n\n            if(have[make_pair(who[0], who[1])])\n                continue;\n            have[make_pair(who[0], who[1])] = 1;\n            \n            int temp = (MOD - (two[many] - 1)) ;\n            add(temp, many);\n            add(temp, (many * (many - 1) / 2));\n            add(ans, temp);\n        }\n    }\n\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nlong long int INF = 998244353;\n\nlong long int pow2(int n){\n\tif(n == 0){\n\t\treturn 1;\n\t}\n\tlong long int ret = (pow2(n - 1) * 2) % INF;\n\treturn ret;\n}\n\nint main(){\n\t\n\tint N;\n\t\n\tcin >> N;\n\t\n\tlong long int x[20000], y[20000];\n\tlong long int cnt2[20000] = {};\n\t\n\tlong long int score[20000];\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tif(N < 3){\n\t\tcout << \"0\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = i + 1; j < N; j++){\n\t\t\tint cnt = 0;\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tlong long int x1, x2, y1, y2;\n\t\t\t\tx1 = x[i] - x[k];\n\t\t\t\tx2 = x[j] - x[k];\n\t\t\t\ty1 = y[i] - y[k];\n\t\t\t\ty2 = y[j] - y[k];\n\t\t\t\tif(x1 * y2 == x2 * y1){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt2[cnt]++;\n\t\t}\n\t}\n\t\n\tfor(long long int i = 3; i < N; i++){\n\t\tcnt2[i] /= i * (i - 1) / 2;\n\t}\n\t\n\t\n\tfor(int i = 0; i < 300; i++){\n\t\tscore[i] = pow2(i) - 1 - i - i * (i - 1) / 2;\n\t}\n\t\n\tlong long int ans = score[N];\n\t\n\tfor(int i = 3; i < 300; i++){\n\t\tans -= cnt2[i] * score[i];\n\t\tans %= INF;\n\t\tans += INF;\n\t\tans %= INF;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nint x[205], y[205];\nlong long p2[205];\n\nbool linear(int i, int j, int k) {\n  return (y[j] - y[i]) * (x[k] - x[i]) == (y[k] - y[i]) * (x[j] - x[i]);\n}\n\nint main() {\n  long long t = 1;\n  for (int i = 0; i <= 200; i++) {\n    p2[i] = t;\n    t *= 2;\n    t %= mod;\n  }\n  int n;\n  cin >> n;\n  for (int ni = 0; ni < n; ni++) {\n    cin >> x[ni] >> y[ni];\n  }\n  if (n < 3) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long ans = 0;\n  for (int ni = 0; ni < n; ni++) {\n    for (int nj = ni + 1; nj < n; nj++) {\n      bool feasible = true;\n      for (int nk = 0; nk < nj; nk++) {\n        if (nk == ni) continue;\n        if (linear(ni, nj, nk)) {\n          feasible = false;\n          break;\n        }\n      }\n      if (!feasible) continue;\n      int cnt = 2;\n      for (int nk = nj + 1; nk < n; nk++) {\n        if (linear(ni, nj, nk)) cnt++;\n      }\n      ans += p2[cnt] - 1 - cnt - cnt * (cnt - 1) / 2 + mod;\n      ans %= mod;\n    }\n  }\n  ans = p2[n] - 1 - n - n * (n - 1) / 2 - ans + mod;\n  ans %= mod;\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <list>\n#include <random>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 998244353;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\n\nstruct point{\n  ll x, y;\n  point(ll x, ll y): x(x), y(y){}\n  point(){}\n};\n\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)((ll)res * curr % mod);\n    }\n    curr = (T)((ll)curr * curr % mod);\n    tmp >>= 1;\n  }\n  return res;\n}\n\nbool used[201][201];\n\nint main(int argc, char const* argv[])\n{\n  int n;\n  cin >> n;\n  vector<point> p(n);\n  rep(i, n)cin >> p[i].x >> p[i].y;\n  ll res = power(2, n, mod);\n  res = (res - 1 - n + mod) % mod;\n  res = (res - n * (n-1) / 2 + mod) % mod;\n  for(int i = 0; i < n; i++){\n    for(int j = i + 1; j < n; j++){\n      if(used[i][j])continue;\n      vector<int> vec;\n      vec.pb(i);\n      vec.pb(j);\n      for(int k = j + 1; k < n; k++){\n        ll tmp = (p[k].y - p[i].y) * (p[i].x - p[j].x) - (p[k].x - p[i].x) * (p[i].y - p[j].y);\n        if(tmp == 0)vec.pb(k);\n      }\n      if(sz(vec) == 2)continue;\n      ll tmp = (power(2, sz(vec), mod) - 1 - sz(vec) - sz(vec) * (sz(vec) - 1) / 2 + mod) % mod;\n      res = (res - tmp + mod) % mod;\n      for(int k = 0; k < sz(vec); k++){\n        for(int l = 0; l < sz(vec); l++){\n          used[vec[k]][vec[l]] = true;\n        }\n      }\n    }\n  }\n  cout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 30;\nconst int MOD = 998244353;\n\nconst int N = 200 + 10;\nint x[N], y[N];\n\nint cross(int u, int v, int w) {\n  return (x[v] - x[u]) * (y[w] - y[u]) - (x[w] - x[u]) * (y[v] - y[u]);\n}\n\nint dp[N][N][N];\nint64 cnt[N][N];\nint n;\n\nint solve(int i, int j, int k) {\n  int& ret = dp[i][j][k];\n  if (ret >= 0) return ret;\n  ret = cnt[j][k];\n  // trace(i, j, k, ret);\n  for (int u = 0; u < n; ++u) {\n    if (u > i && cross(i, j, u) > 0 && cross(i, k, u) < 0) {\n      ret += solve(i, u, k) * cnt[j][u] % MOD;\n      ret %= MOD;\n    }\n  }\n  // trace(i, j, k, ret);\n  return ret;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (i == j) continue;\n      cnt[i][j] = 1;\n      for (int k = 0; k < n; ++k) {\n        if (k == i || k == j) continue;\n        if (cross(i, j, k) == 0 &&\n            (x[k] - x[i]) * (x[k] - x[j]) <= 0 &&\n            (y[k] - y[i]) * (y[k] - y[j]) <= 0) {\n          cnt[i][j] = cnt[i][j] * 2 % MOD;\n        }\n      }\n    }\n  }\n  memset(dp, 255, sizeof(dp));\n  int ret = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      for (int k = i + 1; k < n; ++k) {\n        if (cross(i, j, k) <= 0) continue;\n        ret += solve(i, j, k) * cnt[i][j] % MOD * cnt[i][k] % MOD;\n        ret %= MOD;\n      }\n    }\n  }\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nconst int maxn=300;\nstruct node{\n    int x,y;\n    node operator-(const node&p)const {\n        return (node){x-p.x,y-p.y};\n    }\n    int operator*(const node&p)const {\n        return x*p.y-y*p.x;\n    }\n}d[maxn];\nint n,p[maxn];\nbool check(node a,node b,node c){\n    return ((b-a)*(c-a)==0);\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    if(n<=2){\n        puts(\"0\");\n        return 0;\n    }\n    for (int i=1; i<=n; i++)\n        scanf(\"%d%d\",&d[i].x,&d[i].y);\n        \n    p[0]=1;\n    for (int i=1; i<maxn; i++)\n        p[i]=(p[i-1]<<1)%mod;\n    int cnt;\n    long long ans=0;\n    \n    for (int i=1; i<n; i++)\n        for (int j=i+1; j<n; j++){\n            cnt=n-j;\n            for (int k=j+1; k<=n; k++)\n                if(check(d[i],d[j],d[k]))\n                    cnt--;\n            (ans+=1ll*(p[n-j-cnt]*(p[cnt]-1))%mod)%=mod;\n        }\n    \n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n\nstatic const int MOD = 998244353;\nusing ll = int64_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\n\nint main() {\n    ll n;\n    cin >> n;\n    vector<array<int, 2>> v(n);\n    for (auto &&i : v) scanf(\"%d %d\", &i[0], &i[1]);\n    vector<ll> p2(n+1);\n    p2[0] = 1;\n    for (int i = 0; i < n; ++i) {\n        p2[i+1] = p2[i]*2%MOD;\n    }\n    ll ans = (p2[n]+MOD-1-n-n*(n-1)/2) % MOD;\n    auto checked = make_v(n, n, 0);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if(!checked[i][j]){\n                vector<int> u;\n                u.emplace_back(i); u.emplace_back(j);\n                for (int k = 0; k < n; ++k) {\n                    if(k != i && k != j){\n                        if((v[k][0]-v[i][0])*(v[j][1]-v[i][1]) ==\n                            (v[k][1]-v[i][1])*(v[j][0]-v[i][0])) u.emplace_back(k);\n                    }\n                }\n                for (auto &&l : u) {\n                    for (auto &&k : u) {\n                        checked[l][k] = 1;\n                    }\n                }\n                int w = static_cast<int>(u.size());\n                if(w >= 3) (ans += (MOD- p2[w]+w+w*(w-1)/2 + 1)) %=  MOD;\n            }\n        }\n    }\n    cout << (ans%MOD+MOD)%MOD << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define X first\n#define Y second\n#define pii pair<ll,ll>\n#define x1 dlfjl\n#define x2 dkfj\n#define MOD 998244353\n#define y1 dskgj\n#define y2 dskfj\n#define N 310\ntypedef long long ll;\nusing namespace std;\nll n,i,j,k,x,y,z,m,q,w,h;\nll a[100500], b[100500], pre[1005000], C[205][205];\nmap<pii,ll> f;\nll gcd(ll a, ll b)\n{\n    return (b==0?a:gcd(b,a%b));\n}\nll Abs(ll x)\n{\n    return (x>0?x:-x);\n}\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    for (i = 0; i <= 1000; i++)\n        pre[i*(i+1)/2] = i+1;\n    for (i = 0; i <= 200; i++)\n        C[i][0] = 1;\n    for (i = 1; i <= 200; i++)\n        for (j = i; j <= 200; j++)\n            C[j][i] = (C[j-1][i-1] + C[j-1][i])%MOD;\n    ll ans = 1;\n    cin >> n;\n    if (n < 3)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    for (i = 1; i <= n; i++)\n        ans = (ans*2)%MOD;\n    ans -= n+1;\n    ans -= n*(n-1)/2;\n    ans += MOD;\n    ans %= MOD;\n    for (i = 0; i < n; i++)\n        cin >> a[i] >> b[i];\n    for (i = 0; i < n; i++)\n        for (j = i+1; j < n; j++)\n        {\n            int p = a[i]-a[j];\n            int q = b[i]-b[j];\n            int g = gcd(Abs(p), Abs(q));\n            p /= g;\n            q /= g;\n            if ( p < 0)\n                p = -p, q = -q;\n            f[mp(p,q)]++;\n        }\n    for (auto itr = f.begin(); itr != f.end(); itr++)\n    {\n        int val = (*itr).Y;\n        val = pre[val];\n        for (j = 3; j <= val; j++)\n        {\n            ans -= C[val][j];\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 998244353\nusing namespace std;\nint x[200010],y[200010],mi[200010];\nset<pair<int,int> >mp;\nint main()\n{\n\tint n,w=0;scanf(\"%d\",&n);mi[0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tmi[i]=mi[i-1]*2%mo;\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t}\n\tw=mi[n];\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=i+1;j<=n;j++)\n\t{\n\t\tbool err=false;\n\t\tfor (int k=i+1;k<=n;k++) if (k!=j) if ((x[k]-x[i])*(y[j]-y[i])==(x[j]-x[i])*(y[k]-y[i])) err=true;\n\t\tif (!err)\n\t\t{\n\t\t\tint js=0;\n\t\t\tfor (int k=1;k<=n;k++) if ((x[k]-x[i])*(y[j]-y[i])==(x[j]-x[i])*(y[k]-y[i])) js++;\n\t\t\tw=(w-(mi[js]-js-1))%mo;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(w+mo-n-1)%mo);\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 2e2 + 10,mod = 998244353;\nconst double Pi = acos(-1.0),eps = 1e-7;\n\nstruct node {\n\tint x,y;\n} P[N];\nbool vis[N];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline int fpm(int a,int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1) res = 1ll * res * a % mod;\n\t\ta = 1ll * a * a % mod,b /= 2;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n = read(),ans = 0;\n\tFor(i,1,n) P[i].x = read(),P[i].y = read();\n\tans = (fpm(2,n) - 1 - n - 1ll * n * (n - 1) / 2) % mod;\n\n\tFor(i,1,n) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tFor(j,1,n) if((i ^ j) && !vis[j]) {\n\t\t\tint cnt = 1;\n\t\t\tdouble val = atan2(P[j].y - P[i].y,P[j].x - P[i].x);\n\t\t\tif(val < 0) val += Pi;\n\t\t\tFor(k,1,n) if(k ^ i) {\n\t\t\t\tdouble cur = atan2(P[k].y - P[i].y,P[k].x - P[i].x);\n\t\t\t\tif(cur < 0) cur += Pi;\n\t\t\t\tif(abs(cur - val) < eps) cnt++,vis[k] = true;\n\t\t\t}\n\t\t\tans = (ans - 1ll * (fpm(2,cnt) - 1 - cnt - 1ll * cnt * (cnt - 1) / 2 % mod) * fpm(cnt,mod - 2)) % mod;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",(ans + mod) % mod);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 998244353\n#define eps 1e-10\n#define N 209\nusing namespace std;\n\nint n,cnt,bin[N],inv[N]; double b[N];\nstruct node{ int x,y; }a[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,j,k;\n\tfor (i=bin[0]=1; i<=n; i++) bin[i]=(bin[i-1]<<1)%mod;\n\tinv[0]=inv[1]=1;\n\tfor (i=2; i<=n; i++) inv[i]=mod-(ll)inv[mod%i]*(mod/i)%mod;\n\tfor (i=1; i<=n; i++) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\tint ans=bin[n]-1;\n\tfor (i=1; i<=n; i++){\n\t\tfor (j=1,cnt=0; j<=n; j++)\n\t\t\tif (i!=j) b[++cnt]=min(atan2(a[j].y-a[i].y,a[j].x-a[i].x),atan2(a[i].y-a[j].y,a[i].x-a[j].x));\n\t\tsort(b+1,b+cnt+1);\n\t\tfor (j=k=1; j<=cnt; j=k){\n\t\t\tfor (; k<=cnt && abs(b[k]-b[j])<eps; k++);\n\t\t\tans=(ans-(ll)(bin[k-j+1]-k+j-2)*inv[k-j+1]%mod+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ans-n+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//A,Elebereth Gilthoniel mantae!\n//For Temeria!\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<cstdio>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cstring> \nusing namespace std;\nvector<long long> siz;long long vis[205][205];long long mod=998244353;\nlong long quipow(long long a,long long b)\n{\n    long long ans=1;\n     while(b)\n     {\n         if(b&1) ans=ans*a%mod;\n         b>>=1;\n         a=a*a%mod;\n     }\n     return ans%mod;\n}\nlong long fac[505],inv[505];\nvoid prepare()    \n{\n    fac[0]=fac[1]=1;\n    for(long long i=2;i<=500;i++)   fac[i]=fac[i-1]*i%mod;\n\n    inv[500]=quipow(fac[500],mod-2);\n    for(long long i=500-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\npair<double,double> p[505];\nint main()\n{\n \t//freopen(\"\",\"r\",stdin);\n\t//freopen(\"\",\"w\",stdout);\n\tprepare();\n\tlong long n;cin>>n;\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tcin>>p[i].first>>p[i].second;\n\t}\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tfor(long long j=0;j<n;j++)\n\t\t{\n\t\t\tvector<int> v;\n\t\t\tif(i==j or(vis[i][j]==1)) continue;v.push_back(i);v.push_back(j);\n\t\t\tif(p[i].first==p[j].first)\n\t\t\t{\n\t\t\t\tlong long u=0;u++;u++;\n\t\t\t\tfor(long long t=0;t<n;t++)\n\t\t\t\t{\n\t\t\t\t\tif(i==t or j==t) continue;\n\t\t\t\t\tif(p[t].first==p[i].first)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.push_back(t);\n\t\t\t\t\t\tu++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u>2)siz.push_back(u);\n\t\t\t\tfor(int t=0;t<v.size();t++) for(int y=0;y<v.size();y++) vis[y][t]=1; \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble k=(p[i].second-p[j].second)/(p[i].first-p[j].first);\n\t\t\tdouble b=p[i].second-p[i].first*k;\n\t\t\tlong long u=0;u++;u++;\n\t\t\tfor(long long t=0;t<n;t++)\n\t\t\t{\n\t\t\t\tif(i==t or j==t) continue;\n\t\t\t\tif(p[t].first*k+b==p[t].second)\n\t\t\t\t{\n\t\t\t\t\tv.push_back(t);\n\t\t\t\t\tu++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(u>2)siz.push_back(u);\n\t\t\tfor(int t=0;t<v.size();t++) for(int y=0;y<v.size();y++) vis[y][t]=1; \n\t\t}\n\t}\n\tlong long ans=0;long long y=n*(n-1);\n\tfor(long long i=3;i<=n;i++)\n\t{\n\t\ty=y*(n-i+1);y=y%mod;\n\t\tans+=y*inv[i];ans=ans%mod;\n\t}\n\tfor(long long i=0;i<siz.size();i++)\n\t{\n\t\ty=(siz[i])*(siz[i]-1);\n\t\tfor(long long j=3;j<=siz[i];j++)\n\t\t{\n\t\t\ty=y*(siz[i]-j+1);y=y%mod;\n\t\t\tans-=y*inv[j];ans=ans%mod;\n\t\t}\n\t}\n\tif(ans<0) ans+=mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mo=998244353;\nint ans,x,n,a[205],b[205];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i) scanf(\"%d%d\",&a[i],&b[i]);\n\tans=1; for (int i=1;i<=n;++i) ans=ans*2%mo;\n\tfor (int i=1;i<=n;++i)\n\tfor (int j=i+1;j<=n;++j){\n\t\tx=1;\n\t\tfor (int k=j+1;k<=n;++k)\n\t\tif ((a[j]-a[i])*(b[k]-b[i])-(b[j]-b[i])*(a[k]-a[i])==0) x=x*2%mo;\n\t\t(ans-=x)%=mo;\n\t}\n\tprintf(\"%d\",((ans-n-1)%mo+mo)%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int N = 211;\nconst int mod = 998244353;\nint n;\nLL base[N];\nstruct ddd{\n    int x, y;\n}nd[N];\nLL sq(LL x){return x * x;}\nbool check(LL x1, LL y1, LL x2, LL y2){\n    LL a = x1 * x2 + y1 * y2;\n    LL b = (sq(x1) + sq(y1)) * (sq(x2) + sq(y2));\n    return a > 0 && b == sq(a);\n}\nint main(){\n    cin>>n;\n    for(int i = 1;i <= n; i++){\n        scanf(\"%d%d\", &nd[i].x, &nd[i].y);\n    }\n    base[0] = 1;\n    for(int i = 1;i <= 200; i++)base[i] = base[i-1] * 2 % mod;\n    LL ans = (base[n] - 1 - n + mod) % mod;\n    for(int i = 2;i <= n; i++){\n        for(int j = 1;j < i; j++){\n            int tot = 0;\n            for(int k = 1;k <= n; k++){\n                if(i == k || j == k)continue;\n                if(check(nd[i].x - nd[k].x, nd[i].y - nd[k].y, nd[k].x - nd[j].x, nd[k].y - nd[j].y))tot++;\n            }\n            ans = (ans + mod - base[tot]) % mod;\n            //printf(\"i=%d j=%d tot=%d\\n\", i, j, tot);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nconst int mod=998244353;\nint N;\nstruct Point{int x,y;bool operator<(const Point&p)const{return x<p.x||x==p.x&&y<p.y;}}P[210];\nint cro[210][210][210],area[210][210][2],pw2[210],f[210][210][210];\nint o,L[210],R[210];\nbool cmp(int i,int j){\n\t//printf(\"cmp(%d,%d)=%d\\n\",i,j,cro[o][i][j]>0);\n\treturn cro[o][i][j]>0;\n}\nint geta(int ty,int i,int j,int k){\n\tint s=area[i][j][ty]+area[j][k][ty]-area[i][k][ty];\n\tif(ty)s=-s;\n\t//printf(\"geta(%d,%d,%d,%d)=%d\\n\",ty,i,j,k,s-1);\n\treturn s-1;\n}\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&P[i].x,&P[i].y);\n\tstd::sort(P,P+N);\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tcro[i][j][k]=(P[j].x-P[i].x)*(P[k].y-P[i].y)-(P[k].x-P[i].x)*(P[j].y-P[i].y);\n\t\t\t\tif(i<=k&&k<j){\n\t\t\t\t\tif(cro[i][j][k]>=0)area[i][j][0]++;\n\t\t\t\t\tif(cro[i][j][k]>0)area[i][j][1]++;\n\t\t\t\t}\n\t\t\t}\n\tfor(int i=*pw2=1;i<=N;i++)pw2[i]=pw2[i-1]*2%mod;\n\tfor(o=N;o--;){\n\t\t//printf(\"o=%d\\n\",o);\n\t\tint lc=0,rc=0;\n\t\tfor(int i=0;i<o;i++)L[lc++]=i;\n\t\tfor(int i=o+1;i<N;i++)R[rc++]=i;\n\t\tstd::sort(L,L+lc,cmp);\n\t\tstd::sort(R,R+rc,cmp);\n\t\t//printf(\"L:\");for(int i=0;i<lc;i++)printf(\" %d\",L[i]);puts(\"\");\n\t\t//printf(\"R:\");for(int i=0;i<rc;i++)printf(\" %d\",R[i]);puts(\"\");\n\t\tfor(int j=0;j<rc;j++){\n\t\t\t//printf(\"j=R[%d]=%d\\n\",j,R[j]);\n\t\t\tint m=0;\n\t\t\twhile(m<lc&&cro[L[m]][R[j]][o]<0)m++;\n\t\t\tfor(int i=m,p=j,sum=1;i--;)if(cro[L[i]][R[j]][o]<0){\n\t\t\t\twhile(p&&cro[L[i]][R[p-1]][o]<0)(sum+=f[o][R[--p]][R[j]])%=mod;\n\t\t\t\tf[L[i]][o][R[j]]=1ll*sum*pw2[geta(0,L[i],o,R[j])]%mod;\n\t\t\t\t//printf(\"up i=L[%d]=%d p=R[%d]=%d sum=%d\\n\",i,L[i],p,R[p],sum);\n\t\t\t\t//printf(\"f(%d,%d,%d)=%d\\n\",L[i],o,R[j],f[L[i]][o][R[j]]);\n\t\t\t}\n\t\t\tfor(int i=m,p=j,sum=1;i<lc;i++)if(cro[L[i]][R[j]][o]>0){\n\t\t\t\twhile(p<rc&&cro[L[i]][R[p]][o]>0)(sum+=f[o][R[p++]][R[j]])%=mod;\n\t\t\t\tf[L[i]][o][R[j]]=1ll*sum*pw2[geta(1,L[i],o,R[j])]%mod;\n\t\t\t\t//printf(\"dn i=L[%d]=%d p=R[%d]=%d sum=%d\\n\",i,L[i],p,R[p],sum);\n\t\t\t\t//printf(\"f(%d,%d,%d)=%d\\n\",L[i],o,R[j],f[L[i]][o][R[j]]);\n\t\t\t}\n\t\t}\n\t}\n\tint s=0;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tint up=0,dn=0,on=1;\n\t\t\tfor(int k=i+1;k<j;k++){\n\t\t\t\tint c=cro[i][j][k];\n\t\t\t\tif(c>0)(up+=f[i][k][j])%=mod;\n\t\t\t\telse if(c<0)(dn+=f[i][k][j])%=mod;\n\t\t\t\telse(on*=2)%=mod;\n\t\t\t}\n\t\t\ts=(s+(1ll*up*(dn+1)%mod+dn)*on)%mod;\n\t\t\t//printf(\"i=%d j=%d up=%d dn=%d on=%d\\n\",i,j,up,dn,on);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2000;\ntypedef long long ll;\nconst ll mod=998244353;\nll x[maxn],y[maxn];\nll power(ll a,ll b)\n{\n    ll ret;\n    if (b==0) return 1LL;\n    ret=pow(a,b/2);\n    ret=ret*ret%mod;\n    if (b%2) ret=ret*2LL%mod;\n    return ret;\n}\nint main()\n{\n    //freopen(\"text.in\",\"r\",stdin);\n    ll i,ans,tmp,j,k,n;\n    scanf(\"%lld\",&n);\n    for (i=1;i<=n;i++) {\n        scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    ans=((power(2LL,n)-n-1)%mod+mod)%mod;\n    ans=((ans-(n-1)*n/2)%mod+mod)%mod;\n    for (i=1;i<=n;i++) {\n        for (j=i+1;j<=n;j++) {\n            tmp=0;\n            for (k=j+1;k<=n;k++) {\n                if ((y[j]-y[i])*(x[k]-x[j])==(y[k]-y[j])*(x[j]-x[i])) tmp++;\n                //if ((y[k]-y[i])*(x[j]-x[i])==(x[k]-x[i])*(y[j]-y[i])) tmp++;\n            }\n            ans=((ans-power(2LL,tmp)+1)%mod+mod)%mod;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(int value) { \n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// TODO\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n};\n\n#endif\n\n//#include \"Union_Find.h\"\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT fixed << setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\ntypedef IntMod<998244353> MM;\n\nint N;\nPP A[200];\nbool used[200][200];\nMM ans;\n\nbool collinear(int i, int j, int k) {\n\treturn (A[j].second - A[i].second) * (A[k].first - A[i].first)\n\t\t== (A[k].second - A[i].second) * (A[j].first - A[i].first);\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tcin >> A[i].first >> A[i].second;\n\t}\n\n\tans = MM(2).Pow(N) - (N + 1);\n\n\tREP(i, 0, N) {\n\t\tREP(j, i + 1, N) {\n\t\t\tif (used[i][j]) continue;\n\n\t\t\tvector<int> S({i, j});\n\t\t\tREP(k, 0, N) {\n\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\tif (collinear(i, j, k)) S.push_back(k);\n\t\t\t}\n\t\t\tans -= MM(2).Pow(S.size()) - (S.size() + 1);\n\t\t\tREP(p, 0, S.size()) {\n\t\t\t\tREP(q, p + 1, S.size()) {\n\t\t\t\t\tused[S[p]][S[q]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans.Get_value() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define SORT(c) sort((c).begin(), (c).end())\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> V;\ntypedef map<int, int> M;\n\nconstexpr ll INF = 1e18;\nconstexpr ll MOD = 998244353;\nconstexpr double PI = 3.14159265358979323846;\nconstexpr int di[] = {0, 0, 1, -1};\nconstexpr int dj[] = {1, -1, 0, 0};\n\nll fastPow(ll x, ll n)\n{\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return fastPow(x * x % MOD, n / 2);\n    else\n        return x * fastPow(x, n - 1) % MOD;\n}\n\nll fac[112346];\nvoid combInit(int mx)\n{\n    fac[0] = 0;\n    fac[1] = 1;\n    for (int i = 2; i <= mx; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n}\n\nll modDiv(ll a, ll b)\n{\n    return a * fastPow(b, MOD - 2) % MOD;\n}\n\nll comb(ll a, ll b)\n{\n    if (b == 0)\n        return 1;\n    if (a < b)\n        return 0;\n    if (a <= 0 || b < 0)\n        return 0;\n    if (a == b)\n        return 1;\n\n    ll p, c;\n\n    c = modDiv(fac[a], fac[a - b]);\n    p = fac[b];\n\n    ll res = modDiv(c, p);\n\n    return res;\n}\n\nint n, uf_par[112345], uf_rnk[112345];\n\nvoid uf_init(int size)\n{\n    REP(i, size)\n    {\n        uf_par[i] = i;\n        uf_rnk[i] = 0;\n    }\n}\n\nint uf_find(int x)\n{\n    if (uf_par[x] == x)\n        return x;\n    else\n        return uf_par[x] = uf_find(uf_par[x]);\n}\n\nvoid uf_unite(int x, int y)\n{\n    x = uf_find(x);\n    y = uf_find(y);\n    if (x == y)\n        return;\n\n    if (uf_rnk[x] < uf_rnk[y])\n    {\n        uf_par[x] = y;\n    }\n    else\n    {\n        uf_par[y] = x;\n        if (uf_rnk[x] == uf_rnk[y])\n            uf_rnk[x]++;\n    }\n}\n\nbool uf_same(int x, int y)\n{\n    return uf_find(x) == uf_find(y);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    combInit(210);\n\n    int x[210], y[210];\n\n    cin >> n;\n    REP(i, n)\n    cin >> x[i] >> y[i];\n\n    uf_init(n);\n\n    ll res = 0;\n\n    V l;\n\n    for (int i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++)\n        {\n            if (uf_same(i, j))\n                continue;\n\n            int cnt = 2;\n\n            for (int k = 0; k < n; k++)\n            {\n                if (i == k || j == k)\n                    continue;\n\n                int a = (x[j] - x[i]) * (y[k] - y[j]);\n                int b = (y[j] - y[i]) * (x[k] - x[j]);\n\n                if (a == b)\n                {\n                    cnt++;\n\n                    uf_unite(i, k);\n                }\n            }\n\n            if (cnt > 2)\n            {\n                uf_unite(i, j);\n\n                l.push_back(cnt);\n            }\n        }\n\n    for (int i = 3; i <= n; i++)\n    {\n        ll tmp = 0;\n        tmp += comb(n, i);\n\n        for (int j : l)\n        {\n            if (i > j)\n                continue;\n\n            tmp += MOD - comb(j, i);\n\n            tmp %= MOD;\n        }\n\n        res += tmp;\n        res %= MOD;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<cmath>\n#include<stdlib.h>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nconst int MX = 205;\nconst int MM = 998244353;\n\nint N;\npii D[MX];\n\npii operator-(const pii &l, const pii &r){\n\treturn pii(l.first - r.first, l.second - r.second);\n}\n\nll operator /(const pii &l, const pii &r){\n\treturn (ll)l.first * r.second - (ll)l.second * r.first;\n}\n\nll pw2[MX];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d%d\", &D[i].first, &D[i].second);\n\tll ans = 1;\n\tpw2[0] = 1;\n\tfor(int i = 1; i <= N; i++) pw2[i] = pw2[i-1]*2 % MM;\n\tans = pw2[N];\n\tans = (ans - (ll)N*(N-1)/2 - N - 1) % MM;\n\tans = (ans + MM) % MM;\n\n\tint vst[MX][MX] = {};\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = i+1; j <= N; j++){\n\t\t\tif( vst[i][j] ) continue;\n\t\t\tvector<int> P;\n\t\t\tfor(int k = 1; k <= N; k++){\n\t\t\t\tif( (D[i] - D[j]) / (D[i] - D[k]) == 0 ) P.push_back(k);\n\t\t\t}\n\t\t\tif( P.size() >= 3 ) ans = ((ans - pw2[P.size()] + P.size()*(P.size()-1)/2 + P.size() + 1) % MM + MM) % MM;\n\t\t\tfor(int c : P){\n\t\t\t\tfor(int d : P) vst[c][d] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MN 205\nusing namespace std;\nint n;\nconst int mod=998244353;\nstruct po{\n\tint x,y;\n\tfriend po operator-(po x,po y){return (po){x.x-y.x,x.y-y.y};}\n\tfriend int operator*(po x,po y){return x.x*y.x+x.y*y.y;}\n\tfriend int operator/(po x,po y){return x.y*y.x-x.x*y.y;}\n}p[MN];\nint pow(int x,int y){\n\tint tmp=1;\n\twhile(y){\n\t\tif(y&1)tmp=1ll*tmp*x%mod;y>>=1;x=1ll*x*x%mod;\n\t}return tmp;\n}\nvoid dec(long long &x,int y){(x-=y)<0?x+=mod:0;}\nlong long ans=0;\nint main(){\n\tscanf(\"%d\",&n);ans=pow(2,n);dec(ans,n+1);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&p[i].x,&p[i].y);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1,cnt=0;j<=n;j++,dec(ans,pow(2,cnt)),cnt=0)\n\t\t\tfor(int k=1;k<=n;k++)if((p[k]-p[i])/(p[k]-p[j])==0&&(p[k]-p[i])*(p[k]-p[j])<0)cnt++;\n\tprintf(\"%lld\\n\",ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\ntemplate <class T1>\nclass Operators\n{\npublic:\n    template <class T2>\n    const T1 operator+(const T2& right) const{\n        T1 ans = static_cast<const T1&>( *this );\n        ans += right;\n        return ans;\n    }\n    template <class T2>\n    const T1 operator-(const T2& right) const{\n        T1 ans = static_cast<const T1&>( *this );\n        ans -= right;\n        return ans;\n    }\n    template <class T2>\n    const T1 operator*(const T2& right) const{\n        T1 ans = static_cast<const T1&>( *this );\n        ans *= right;\n        return ans;\n    }\n    template <class T2>\n    const T1 operator/(const T2& right) const{\n        T1 ans = static_cast<const T1&>( *this );\n        ans /= right;\n        return ans;\n    }\n    bool operator!=(const T1& right) const{\n        const T1& left = static_cast<const T1&>( *this );\n        return !(left == right);\n    }\n    bool operator>(const T1& right) const{\n        const T1& left = static_cast<const T1&>( *this );\n        return right < left;\n    }\n    bool operator<=(const T1& right) const{\n        const T1& left = static_cast<const T1&>( *this );\n        return !(right < left);\n    }\n    bool operator>=(const T1& right) const{\n        const T1& left = static_cast<const T1&>( *this );\n        return !(left < right);\n    }\n};\n\nclass Point : public Operators<Point>\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    Point& operator+=(const Point& p){\n        y += p.y;\n        x += p.x;\n        return *this;\n    }\n    Point& operator-=(const Point& p){\n        y -= p.y;\n        x -= p.x;\n        return *this;\n    }\n    Point& operator*=(int a){\n        y *= a;\n        x *= a;\n        return *this;\n    }\n    Point& operator/=(int a){\n        y /= a;\n        x /= a;\n        return *this;\n    }\n    bool operator==(const Point& p) const{\n        return y == p.y && x == p.x;\n    }\n    long long length2() const{\n        return y * (long long)y + x * (long long)x;\n    }\n    long long dist2(const Point& p) const{\n        return (y - p.y) * (long long)(y - p.y) + (x - p.x) * (long long)(x - p.x);\n    }\n    long long dot(const Point& p) const{\n        return y * (long long)p.y + x * (long long)p.x; // |a|*|b|*cosθ\n    }\n    long long cross(const Point& p) const{\n        return x * (long long)p.y - y * (long long)p.x; // |a|*|b|*sinθ\n    }\n};\n\nclass Mod : public Operators<Mod>\n{\nprivate:\n    static const int MOD = 998244353;\n    long long a;\npublic:\n    Mod(){\n        a = 0;\n    }\n    Mod(long long x){\n        a = (x % MOD + MOD) % MOD;\n    }\n    Mod& operator+=(const Mod& x){\n        a = (a + x.a) % MOD;\n        return *this;\n    }\n    Mod& operator-=(const Mod& x){\n        a = (a - x.a + MOD) % MOD;\n        return *this;\n    }\n    Mod& operator*=(const Mod& x){\n        a = (a * x.a) % MOD;\n        return *this;\n    }\n    Mod& operator/=(const Mod& x){ // フェルマーの小定理、MODが素数である場合のみ有効\n        int b = MOD - 2;\n        long long c = x.a;\n        while(b > 0){\n            if(b & 1){\n                a *= c;\n                a %= MOD;\n            }\n            c *= c;\n            c %= MOD;\n            b >>= 1;\n        }\n        return *this;\n    }\n    bool operator==(const Mod& x) const{\n        return a == x.a;\n    }\n    long long getValue(){\n        return a;\n    }\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<Point> p(n);\n    for(int i=0; i<n; ++i)\n        cin >> p[i].x >> p[i].y;\n\n    Mod ans = 1;\n    for(int i=0; i<n; ++i)\n        ans *= 2;\n    ans -= n + 1;\n\n    for(int i=0; i<n; ++i){\n        for(int j=i+1; j<n; ++j){\n            Mod tmp = 1;\n            for(int k=j+1; k<n; ++k){\n                if((p[j] - p[i]).cross(p[k] - p[i]) == 0)\n                    tmp *= 2;\n            }\n            ans -= tmp;\n        }\n    }\n    cout << ans.getValue() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=100005,M=100005,mod=998244353;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,pw[N];\nmap<pii,bool> vis;\nstruct node{int x,y;}p[N];\ninline node operator - (const node &a,const node &b){return (node){a.x-b.x,a.y-b.y};}\ninline ll operator * (const node &a,const node &b){return (ll)a.x*b.y-(ll)a.y*b.x;}\ninline int calc(int x){return (pw[x]-x-1+mod)%mod;}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tread(n);pw[0]=1;\n\tfor(int i=1;i<=n;i++) pw[i]=(pw[i-1]<<1)%mod;\n\tfor(int i=1;i<=n;i++)\n\t\tread(p[i].x,p[i].y);\n\tint ans=calc(n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint cnt=0;\n\t\t\tint h1=0,h2=0;\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\th1=(ll)h1*3%1000000007;\n\t\t\t\th2=(ll)h2*5%1000000009;\n\t\t\t\tif((p[i]-p[k])*(p[j]-p[k])==0) h1++,h2++,cnt++;\n\t\t\t}\n\t\t\th1%=1000000007,h2%=1000000009;\n\t\t\tif(vis[mp(h1,h2)]) continue;\n\t\t\tvis[mp(h1,h2)]=1;\n\t\t\tch(ans,mod-calc(cnt));\n\t\t}\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=int(b); i++)\nusing namespace std;\n\nconst int maxn = 205, MOD = 998244353;\nint x[maxn], y[maxn], bin[maxn], n, ans, cnt;\n\ninline int mul(int a, int b) {\n\treturn 1LL * a * b % MOD;\n}\ninline int add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint main() {\n\tscanf(\"%d\", &n); bin[0] = 1;\n\trep (i, 1, n) scanf(\"%d%d\", &x[i], &y[i]);\n\trep (i, 1, n) bin[i] = bin[i-1] * 2 % MOD;\n\tans = add(bin[n], -n-1);\n\trep (i, 1, n) rep (j, i+1, n) {\n\t\tcnt = 0;\n\t\trep (k, j+1, n)\n\t\t\tif ((x[i]-x[k])*(y[j]-y[k]) - (x[j]-x[k])*(y[i]-y[k]) == 0) cnt++;\n\t\tans = add(ans, -bin[cnt]);\n\t}\n\tans = (ans % MOD + MOD) % MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nstruct Point {\n\tll x, y;\n\n\tPoint() : x(), y() {}\n\tPoint (ll _x, ll _y) : x(_x), y(_y) {}\n\n\tvoid scan() {\n\t\tscanf(\"%lld%lld\", &x, &y);\n\t}\n\n\tPoint operator + (const Point &a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\tPoint operator - (const Point &a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n\tll operator % (const Point &a) const {\n\t\treturn x * a.x + y * a.y;\n\t}\n\tll operator * (const Point &a) const {\n\t\treturn x * a.y - y * a.x;\n\t}\n};\n\nconst ll MOD = 998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 300;\nbool onLine(Point A, Point B, Point C) {\n\treturn (A - B) * (A - C) == 0;\n}\n\nint n;\nPoint a[N];\nll p2[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\ta[i].scan();\n\n\tp2[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tp2[i] = add(p2[i - 1], p2[i - 1]);\n\n\tll ans = p2[n];\n\tans = sub(ans, 1 + n);\n\t\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint cnt = 0;\n\t\t\tbool bad = false;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (onLine(a[i], a[j], a[k])) cnt++;\n\t\t\t\tif (k == j)\n\t\t\t\t\tbad = (cnt > 2);\n\t\t\t}\n\t\t\tif (!bad)\n\t\t\t\tans = sub(ans, sub(p2[cnt], cnt + 1));\n\t\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int Q = 998244353;\nconst int N = 209;\nll x[N], y[N], p[N], f[N], size[N];\ninline int read() {\n    int s = 1, a = 0; char ch = getchar();\n    while (ch < '0' || ch > '9') {if (ch == '-') s = -1; ch = getchar();}\n    while (ch >= '0' && ch <= '9') {a = a * 10 + ch - '0'; ch = getchar();}\n    return s * a;\n}\ninline int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\ninline int findSet(int x) {\n    return f[x] == x ? x : f[x] = findSet(f[x]);\n}\ninline void unionSet(int x, int y) {\n    int fx = findSet(x), fy = findSet(y);\n    if (fx != fy) {\n        f[fy] = fx;\n        size[fx] += size[fy];\n    }\n}\nstruct Seg {\n    int p, q; ll hash;\n    bool operator < (const Seg &rhs) const {\n        return hash < rhs.hash;\n    }\n};\nvector<Seg> seg;\nint main() {\n    p[0] = 1;\n    for (int i = 1; i < N; i++) {\n        p[i] = p[i - 1] << 1, p[i] %= Q;\n    }\n    int n = read();\n    for (int i = 1; i <= n; i++) {\n        x[i] = read(), y[i] = read();\n    }\n    ll res = (p[n] - n - 1) % Q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            int dx = x[i] - x[j], dy = y[i] - y[j], g = gcd(dx, dy);\n            dx /= g, dy /= g;\n            if (dx == 0) dy = 1;\n            if (dy == 0) dx = 1;\n            if (dx < 0) dx *= -1, dy *= -1;\n            Seg s; s.p = i, s.q = j, s.hash = dx * 10000 + dy;\n            seg.push_back(s);\n        }\n    }\n    sort(seg.begin(), seg.end());\n    for (int i = 0, j = 0; i < seg.size(); i = j) {\n        for (int k = 1; k <= n; k++) {\n            f[k] = k, size[k] = 1;\n        }\n        for (; j < seg.size() && seg[i].hash == seg[j].hash; j++) {\n            unionSet(seg[j].p, seg[j].q);\n        }\n        for (int k = 1; k <= n; k++) {\n            if (f[k] == k && size[k] >= 2) {\n                res -= (p[ size[k] ] - size[k] - 1), res += Q, res %= Q;\n            }\n        }\n    }\n    res += Q, res %= Q;\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst int N = 6010;\nconst long long MOD = 998244353;\n\nint n, m;\nint x[N], y[N];\nset<vector<int> > s;\nlong long st2[N];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    st2[0] = 1;\n    for (int i = 1; i < N; i++) st2[i] = st2[i - 1] * 2 % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x[i] >> y[i];\n    }\n    long long ans = 1;\n    for (int i = 0; i < n; i++)\n    {\n        ans = ans * 2 % MOD;\n        for (int j = i + 1; j < n; j++)\n        {\n            vector<int> v;\n            for (int k = 0; k < n; k++)\n            {\n                if (k == i || k == j)\n                {\n                    v.push_back(k);\n                    continue;\n                }\n                if ((x[k] - x[i]) * (y[j] - y[i]) == (x[j] - x[i]) * (y[k] - y[i]))\n                {\n                    v.push_back(k);\n                }\n            }\n            //for (auto e : v) cout << e << \" \"; cout << \"\\n\";\n            s.insert(v);\n        }\n    }\n    ans = (ans - n - 1 + MOD) % MOD;\n    for (auto it : s)\n    {\n        //cout << it.size() << endl;\n        ans = (ans - st2[it.size()] + it.size() + 1 + MOD) % MOD;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconstexpr int N = 200, P = 998244353;\n\nint n;\nint x[N], y[N], pw[N + 1];\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::cin >> n;\n    for (int i = 0; i < n; ++i)\n        std::cin >> x[i] >> y[i];\n    \n    pw[0] = 1;\n    for (int i = 1; i <= n; ++i)\n        pw[i] = 2 * pw[i - 1] % P;\n    int ans = (pw[n] - n - 1 + P) % P;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int cnt = 0;\n            for (int k = j + 1; k < n; ++k)\n                if ((x[i] - x[j]) * (y[i] - y[k]) == (y[i] - y[j]) * (x[i] - x[k]))\n                    ++cnt;\n            ans = (ans - pw[cnt] + P) % P;\n        }\n    }\n    \n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ha 998244353\nusing namespace std;\n\nstruct Point\n{\n\tint x,y;\n\tPoint(int a=0,int b=0):x(a),y(b){}\n\tfriend Point operator - (const Point &a,const Point &b){return Point(a.x-b.x,a.y-b.y);}\n\tfriend int operator * (const Point &a,const Point &b){return a.x*b.y-a.y*b.x;}\n} p[210];\nint pw2[210];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&p[i].x,&p[i].y);\n\tpw2[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tpw2[i]=(pw2[i-1]<<1)%ha;\n\tint ans=(pw2[n]-n*(n-1)/2-n-1+ha)%ha;\n\tfor(int i=2;i<n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint sum=0;\n\t\t\tfor(int k=1;k<i;k++)\n\t\t\t\tsum+=((p[k]-p[i])*(p[j]-p[i])==0);\n\t\t\tans=(ans-pw2[sum]+1+ha)%ha;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nint n;\nstruct pos{\n\tint x,y;\n}pointset[1007];\nint edgenum=0,f[1007],sizex[1007];\nint gf(int x) {\n\twhile(x!=f[x])\n\t\tx=f[x]=x[f][f];\n\treturn x;\n}\nstruct edge{\n\tint a,b,v;\n\tbool operator<(const edge&e)const {\n\t\treturn v<e.v;\n\t}\n\tvoid unite() {\n\t\tint x=gf(a),y=gf(b);\n\t\tif(x!=y) {\n\t\t\tf[x]=y;\n\t\t\tsizex[y]+=sizex[x];\n\t\t}\n\t}\n}edgeset[207*207];\nint gcd(int a,int b) {\n\treturn b?gcd(b,a%b):a;\n}\nint pow2[1007],ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tpow2[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tpow2[i]=pow2[i-1]*2%mod;\n\tans=(pow2[n]-n-1)%mod;\n\tfor(int i=0;i<n;++i)\n\t\tscanf(\"%d%d\",&pointset[i].x,&pointset[i].y);\n\tfor(int i=0;i<n;++i) {\n\t\tfor(int j=0;j<i;++j) {\n\t\t\tint x=pointset[i].x-pointset[j].x,y=pointset[i].y-pointset[j].y;\n\t\t\tint g=gcd(x,y);\n\t\t\tx/=g,y/=g;\n\t\t\tif(!x)\n\t\t\t\ty=1;\n\t\t\tif(!y)\n\t\t\t\tx=1;\n\t\t\tif(x<0)\n\t\t\t\tx=-x,y=-y;\n\t\t\tedgeset[edgenum++]=(edge){i,j,x*30000+y};\n\t\t}\n\t}\n\tsort(edgeset,edgeset+edgenum);\n\tfor(int i=0,j=0;i<edgenum;i=j) {\n\t\tfor(int a=0;a<n;++a)\n\t\t\tsizex[f[a]=a]=1;\n\t\tfor(;j<edgenum&&edgeset[i].v==edgeset[j].v;edgeset[j++].unite());\n\t\tfor(int a=0;a<n;++a)\n\t\t\tif(f[a]==a&&sizex[a]>1)\n\t\t\t\tans=(ans-pow2[sizex[a]]+sizex[a]+1)%mod;\n\t}\n\tprintf(\"%d\\n\",(ans%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=205,mod=998244353;\nint n,ans,fastpow[N],x[N],y[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfastpow[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tfastpow[i]=1LL*fastpow[i-1]*2%mod;\n\t}\n\tans=(fastpow[n]-n-n*(n-1)/2-1)%mod;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(register int j=i+1;j<=n;j++){\n\t\t\tint tot=0;\n\t\t\tfor(register int k=j+1;k<=n;k++){\n\t\t\t\tif((x[i]-x[j])*(y[j]-y[k])==(y[i]-y[j])*(x[j]-x[k])){\n\t\t\t\t\ttot++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=(ans-fastpow[tot]+1)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define rint register int\n#define fo(i, n) for(rint i = 1; i <= (n); i ++)\n#define out(x) cerr << #x << \" = \" << x << \"\\n\"\n#define type(x) __typeof((x).begin())\n#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); ++ it)\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0;char c = getchar(); bool f = 0;\n  for(; c < '0' || c > '9'; f |= (c == '-'), c = getchar());\n  for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if(f) x = -x;\n}\nconst int N = 2333;\nconst int mo = 99824353;\nint n, x[N], y[N], pw[N], ans = 0;\nmain(void) {\n  read(n); fo(i, n) read(x[i]), read(y[i]);\n  pw[0] = 1; fo(i, n) pw[i] = pw[i - 1] * 2 % mo;\n  int ans = pw[n] - 1 - n;\n  // out(ans);\n  fo(i, n) fo(j, n) if(i != j) {\n    vector<pair<int, int> > vec;\n    vec.push_back({x[i], y[i]});\n    vec.push_back({x[j], y[j]});\n    fo(k, n) if(k != i && k != j) {\n      int x1 = x[k] - x[i], y1 = y[k] - y[i];\n      int x2 = x[j] - x[i], y2 = y[j] - y[i];\n      if(x1 * y2 - x2 * y1 == 0) {\n        vec.push_back({x[k], y[k]});\n      }\n    }\n    sort(vec.begin(), vec.end());\n    if(vec[0].first == x[i] && vec[0].second == y[i]\n       && vec[1].first == x[j] && vec[1].second == y[j]) {\n      int cnt = (int) vec.size();\n      ans = (ans - (pw[cnt] - 1 - cnt) + mo) % mo;\n    }\n  }\n  cout << (ans + mo) % mo << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<ll, ll> pll;\ntypedef long double ldouble;\ntypedef pair<double, double> pdd;\n\npii p[220];\nint n;\nconst int MOD = 998244353;\n\nint chk(pii a, pii b, pii c) {\n\tpii x = pii(a.Fi - b.Fi, a.Se - b.Se);\n\tpii y = pii(c.Fi - b.Fi, c.Se - b.Se);\n\tif((ll)x.Fi * y.Se == (ll)x.Se * y.Fi) {\n\t\tif((ll)x.Fi * y.Fi + (ll)x.Se * y.Se < 0) return 1;\n\t\telse return -1;\n\t}\n\treturn 0;\n}\n\nvoid solve(){\n\tscanf(\"%d\", &n);\n\trep(i, n) scanf(\"%d%d\", &p[i].Fi, &p[i].Se);\n\tint ans = 1;\n\trep(i, n) ans = ans * 2 % MOD;\n\tans -= 1;\n\tans -= n;\n\tans -= n * (n - 1) / 2;\n\tif(ans < 0) ans += MOD;\n\tsort(p, p+n);\n\trep(i, n) rep(j, i) {\n\t\tint cnt = 2;\n\t\trep(k, n) if(k != i && k != j) {\n\t\t\tint t = chk(p[j], p[i], p[k]);\n\t\t\tif(t == -1) { cnt = 0; break; }\n\t\t\tcnt += t;\n\t\t}\n\t\tif(cnt >= 3) {\n\t\t\tint s = 1;\n\t\t\trep(a, cnt) s = s * 2 % MOD;\n\t\t\ts -= 1 + cnt + cnt * (cnt - 1) / 2;\n\t\t\tif(s < 0) s += MOD;\n\t\t\tans -= s;\n\t\t\tif(ans < 0) ans += MOD;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\t// printf(\"Case #%d: \", tc);\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int mod=998244353;\nint x[2005],y[2005],tw[2100],n,num,ans;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>x[i]>>y[i];\n\ttw[0]=1;\n\tfor(int i=1;i<=2000;i++)\n\t\ttw[i]=(tw[i-1]<<1)%mod;\n\tans=tw[n]-n-1;\n\t//cout<<tw[n]<<endl;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tnum=0;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\t\tif((x[j]-x[i])*(y[k]-y[j])==(x[k]-x[j])*(y[j]-y[i]))\n\t\t\t\t\tnum++;\n\t\t\tans=(ans-tw[num]+mod)%mod;\n\t\t//\tcout<<i<<\" \"<<j<<\" \"<<ans<<endl;\n\t\t}\n\t//ans-=(n+1);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 110;\nconst int moder = 998244353;\n\nint x[N], y[N];\nint n;\n\nint powermod(int a, int exp){\n\tint ret = 1;\n\tfor ( ; exp; exp >>= 1){\n\t\tif (exp & 1){\n\t\t\tret = 1ll * ret * a % moder;\n\t\t}\n\t\ta = 1ll * a * a % moder;\n\t}\n\treturn ret;\n}\n\nint det(int x1, int y1, int x2, int y2){\n\treturn x1 * y2 - y1 * x2;\n}\n\nbool onSeg(int x1, int y1, int x2, int y2, int x3, int y3){\n\treturn !det(x2 - x1, y2 - y1, x3 - x1, y3 - y1);\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i){\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++ i){\n\t\tfor (int j = i + 1; j < n; ++ j){\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = 0; k < n; ++ k){\n\t\t\t\tcnt += onSeg(x[i], y[i], x[j], y[j], x[k], y[k]);\n\t\t\t}\n\t\t\tans = (ans + 1ll * (powermod(2, cnt) - (cnt + 1) + moder) * powermod(cnt * (cnt - 1) >> 1, moder - 2)) % moder;\n\t\t}\n\t}\n\tans = (ans + n + 1) % moder;\n\treturn printf(\"%d\\n\", (powermod(2, n) - ans + moder) % moder), 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 998244353LL;\n\nint N, X[210], Y[210], p[210];\nbool used[210][210];\n\nsigned main() {\n    cin >> N;\n    rep(i,0,N) cin >> X[i] >> Y[i];\n\n    p[0] = 1;\n    rep(i,0,N) p[i+1] = (p[i] * 2) % MOD;\n    int noneed = (1 + N + N*(N-1)/2) % MOD; // nC0, nC1, nC2\n    int ret = (p[N] - noneed + MOD) % MOD;\n\n    rep(P,0,N) rep(Q,0,P) {\n        if(used[P][Q]) continue;\n        vector<int> points;\n        points.push_back(P);\n        points.push_back(Q);\n        rep(i,0,N) {\n            if(i == P || i == Q) continue;\n            if((X[Q]-X[i])*(Y[i]-Y[P])==(X[i]-X[P])*(Y[Q]-Y[i])) points.push_back(i);\n        }\n        int S = points.size();\n        rep(i,0,S) rep(j,0,S) used[ points[i] ][ points[j] ] = true;\n        if(S >= 3) {\n            int noneed_par = (S*MOD + p[S] - (1 + S + S*(S-1)/2)) % MOD;\n            ret = (ret - noneed_par + MOD) % MOD;\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\nconst ll mod = 998244353;\n\nll powmod(ll a, ll e) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\n\nint main(void) {\n  int n;\n  cin >> n;\n  vector<PL> pt(n);\n  REP(i, 0, n) {\n    int x, y;\n    cin >> x >> y;\n    pt[i] = PI(x, y);\n  }\n  ll tot = pow(2, n);\n  tot += mod - 1 - n;\n  tot %= mod;\n  // Eliminate one-liners\n  REP(i, 0, n) {\n    REP(j, i + 1, n) {\n      int elim = 0;\n      REP(k, j + 1, n) {\n\t// i-j-k?\n\tPI v1(pt[j].first - pt[i].first, pt[j].second - pt[i].second);\n\tPI v2(pt[k].first - pt[i].first, pt[k].second - pt[i].second);\n\tll outer = v1.first * v2.second - v1.second * v2.first;\n\tif (outer == 0) {\n\t  elim += 1;\n\t}\n      }\n      tot += mod - pow(2, elim);\n      tot %= mod;\n    }\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#define LL long long\n#define mod 998244353\nusing namespace std;\nint n,X[201],Y[201];\ninline LL gcd(LL x,LL y){return (y==0)?x:gcd(y,x%y);}\nstruct num{\n\tLL x,y;\n\tnum(LL xx=0,LL yy=1){LL d=gcd(xx,yy);x=xx/d;y=yy/d;if(y<0){x=-x;y=-y;}}\n\tfriend bool operator<(num a,num b){return (a.x*b.y)<(a.y*b.x);}\n\tfriend bool operator==(num a,num b){return (a.x==b.x)&&(a.y==b.y);}\n};\nstruct line{\n\tnum k,b;\n\tfriend bool operator<(line x,line y){return (x.k<y.k)||(x.k==y.k&&x.b<y.b);}\n};\nmap<line,int>mp;int cn=0,b[40127];\ninline int ID(line x)\n{\n\tif(mp.find(x)!=mp.end())return mp[x];\n\treturn mp[x]=++cn;\n}\ninline int ksm(int p,int k)\n{\n\tint res=1;\n\twhile(k)\n\t{\n\t\tif(k&1)res=1ll*res*p%mod;\n\t\tp=1ll*p*p%mod;k>>=1;\n\t}return res;\n}\nint main(){\n\tscanf(\"%d\",&n);int i,j,k,d,ans=ksm(2,n);num K,B;\n\tfor(i=1;i<=n;i++)scanf(\"%d%d\",&X[i],&Y[i]);\n\tfor(i=1;i<=n-1;i++)\n\tfor(j=i+1;j<=n;j++)\n\tif(i!=j)\n\t{\n\t\tint res=2;\n\t\tif(X[i]==X[j]){K=num(1,0);B=X[i];}\n\t\telse{K=num(Y[i]-Y[j],X[i]-X[j]);B=num(1ll*X[i]*Y[j]-1ll*X[j]*Y[i],X[i]-X[j]);}\n\t\tif(b[d=ID((line){K,B})])continue;b[d]=1;\n\t\tfor(k=1;k<=n;k++)\n\t\tif(k!=i&&k!=j)\n\t\t{\n\t\t\tif(X[i]==X[j]){if(X[i]==X[k])++res;}\n\t\t\telse if(K.x*X[k]*B.y+K.y*B.x==B.y*K.y*Y[k])++res;\n\t\t}\n\t\tres=ksm(2,res)-res-1;res=(res%mod+mod)%mod;\n\t\tans=((ans-res)%mod+mod)%mod;\n\t}ans=((ans-n)%mod+mod)%mod;\n\tprintf(\"%d\",((ans-1)%mod+mod)%mod);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//A,Elebereth Gilthoniel mantae!\n//For Temeria!\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<cstdio>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cstring> \nusing namespace std;\nvector<long long> siz;long long vis[205][205];long long mod=998244353;\nlong long quipow(long long a,long long b)\n{\n    long long ans=1;\n     while(b)\n     {\n         if(b&1) ans=ans*a%mod;\n         b>>=1;\n         a=a*a%mod;\n     }\n     return ans%mod;\n}\nlong long fac[505],inv[505];\nvoid prepare()    \n{\n    fac[0]=fac[1]=1;\n    for(long long i=2;i<=500;i++)   fac[i]=fac[i-1]*i%mod;\n\n    inv[500]=quipow(fac[500],mod-2);\n    for(long long i=500-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\npair<double,double> p[505];\nint main()\n{\n \t//freopen(\"\",\"r\",stdin);\n\t//freopen(\"\",\"w\",stdout);\n\tprepare();\n\tlong long n;cin>>n;\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tcin>>p[i].first>>p[i].second;\n\t}\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tfor(long long j=0;j<n;j++)\n\t\t{\n\t\t\tvector<int> v;\n\t\t\tif(i==j or(vis[i][j]==1)) continue;v.push_back(i);v.push_back(j);\n\t\t\tif(p[i].first==p[j].first)\n\t\t\t{\n\t\t\t\tlong long u=0;u++;u++;\n\t\t\t\tfor(long long t=0;t<n;t++)\n\t\t\t\t{\n\t\t\t\t\tif(i==t or j==t) continue;\n\t\t\t\t\tif(p[t].first==p[i].first)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.push_back(t);\n\t\t\t\t\t\tu++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u>2)siz.push_back(u);\n\t\t\t\tfor(int t=0;t<v.size();t++) for(int y=0;y<v.size();y++) vis[v[y]][v[t]]=1; \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble k=(p[i].second-p[j].second)/(p[i].first-p[j].first);\n\t\t\tdouble b=p[i].second-p[i].first*k;\n\t\t\tlong long u=0;u++;u++;\n\t\t\tfor(long long t=0;t<n;t++)\n\t\t\t{\n\t\t\t\tif(i==t or j==t) continue;\n\t\t\t\tif(p[t].first*k+b==p[t].second)\n\t\t\t\t{\n\t\t\t\t\tv.push_back(t);\n\t\t\t\t\tu++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(u>2)siz.push_back(u);\n\t\t\tfor(int t=0;t<v.size();t++) for(int y=0;y<v.size();y++) vis[v[y]][v[t]]=1; \n\t\t}\n\t}\n\tlong long ans=0;long long y=n*(n-1);\n\tfor(long long i=3;i<=n;i++)\n\t{\n\t\ty=y*(n-i+1);y=y%mod;\n\t\tans+=y*inv[i];ans=ans%mod;\n\t}\n\tfor(long long i=0;i<siz.size();i++)\n\t{\n\t\ty=(siz[i])*(siz[i]-1);\n\t\tfor(long long j=3;j<=siz[i];j++)\n\t\t{\n\t\t\ty=y*(siz[i]-j+1);y=y%mod;\n\t\t\tans-=y*inv[j];ans=ans%mod;\n\t\t}\n\t}\n\tif(ans<0) ans+=mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\n\nconstexpr long long mod = 998244353;\nconst double pi = acos(-1);\n\nusing P = complex<long long>;\n\nlong long dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\nlong long cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nlong long gcd(long long a, long long b) {\n  a = abs(a);\n  b = abs(b);\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nP tomato(P a) {\n  long long g = gcd(a.real(), a.imag());\n  return P(a.real() / g, a.imag() / g);\n}\n\nP onion(P a) {\n  long long g = gcd(a.real(), a.imag());\n  return P(a.real() / g * 10010, a.imag() / g * 10010);\n}\n\nbool argcomp(std::complex<long long> p1, std::complex<long long> p2) {\n  bool a = p1.imag() > 0 || (p1.imag() == 0 && p1.real() >= 0);\n  bool b = p2.imag() > 0 || (p2.imag() == 0 && p2.real() >= 0);\n  if (a != b) return a;\n  long long c = p2.real() * p1.imag();\n  long long d = p1.real() * p2.imag();\n  if (c != d) return c < d;\n  return std::norm(p1) < std::norm(p2);\n}\n\nnamespace std {\n  bool operator<(const P &a, const P &b) {\n    return argcomp(a, b);\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<P> ps(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    ps[i] = P(x, y);\n  }\n\n  vector<pair<int, int>> es;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      es.emplace_back(i, j);\n    }\n  }\n  sort(es.begin(), es.end(), [&](pair<int, int> a, pair<int, int> b) {\n    P d = ps[a.second] - ps[a.first];\n    P e = ps[b.second] - ps[b.first];\n    if (cross(d, e) == 0 && dot(d, e) >= 0) {\n      return dot(ps[a.second] - ps[a.first], ps[b.first] - ps[a.first]) < 0;\n    } else {\n      return argcomp(d, e);\n    }\n  });\n\n  vector<vector<pair<int, P>>> qs(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      qs[i].emplace_back(0, ps[j] - ps[i]);\n      qs[i].emplace_back(1, ps[j] - ps[i]);\n    }\n    sort(qs[i].begin(), qs[i].end());\n  }\n\n  static int in[200][200][200];\n  static int on[200][200];\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      for (int k = 0; k < n; k++) {\n        if (i == k || j == k) continue;\n        in[i][j][k] = n;\n        for (tuple<int, int, int> t : {make_tuple(i, j, k), make_tuple(k, i, j), make_tuple(j, k, i)}) {\n          int x, y, z;\n          tie(x, y, z) = t;\n          P s = tomato(ps[y] - ps[x]);\n          P t = onion(ps[z] - ps[y]);\n          if (argcomp(s, t)) {\n            int L = lower_bound(qs[y].begin(), qs[y].end(), make_pair(0, s)) - qs[y].begin();\n            int R = upper_bound(qs[y].begin(), qs[y].end(), make_pair(0, t)) - qs[y].begin();\n            in[i][j][k] -= R - L;\n          } else {\n            int L = lower_bound(qs[y].begin(), qs[y].end(), make_pair(0, s)) - qs[y].begin();\n            int R = upper_bound(qs[y].begin(), qs[y].end(), make_pair(1, t)) - qs[y].begin();\n            in[i][j][k] -= R - L;\n          }\n        }\n        if (in[i][j][k] < 0) {\n          in[i][j][k] = 0;\n        }\n        on[i][j] += cross(ps[k] - ps[i], ps[j] - ps[i]) == 0 && dot(ps[k] - ps[i], ps[j] - ps[i]) > 0 && dot(ps[k] - ps[j], ps[i] - ps[j]) > 0;\n      }\n    }\n  }\n\n  vector<long long> two(n + 1);\n  two[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two[i] = two[i - 1] * 2 % mod;\n  }\n\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    vector<long long> dp1(n);\n    vector<long long> dp2(n);\n    for (auto e : es) {\n      int u = e.first;\n      int v = e.second;\n\n      if (u == i) {\n        assert(dp1[v] == 0);\n        dp1[v] = two[on[u][v]];\n      } else if (v == i) {\n        dp2[v] += dp2[u];\n      } else {\n        int c = on[i][v] + on[u][v] + in[i][u][v];\n        dp2[v] += dp1[u] * two[c];\n        dp2[v] += dp2[u] * two[c];\n      }\n      dp2[v] %= mod;\n    }\n    ans += dp2[i];\n    ans %= mod;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=205,mod=998244353;\nint n,x[N],y[N],Pow[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tPow[0]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]),Pow[i]=Pow[i-1]*2%mod;\n\tint ans=(Pow[n]-n-1+mod)%mod;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tint cnt=0;\n\t\t\tfor (int k=j+1;k<=n;k++)\n\t\t\t\tif ((x[i]-x[k])*(y[j]-y[k])==(x[j]-x[k])*(y[i]-y[k]))\n\t\t\t\t\tcnt++;\n\t\t\tans=(ans-Pow[cnt]+mod)%mod;\n\t\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//pragma\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define YOU using\n#define DONT namespace\n#define SAY std\n\nYOU DONT SAY;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n\n#define REPP(i,a,b,d) for(int i=a;i<=b;i+=d)\n#define REP(i,a,b) REPP(i,a,b,1)\n#define REVV(i,a,b,d) for(int i=a;i>=b;i-=d)\n#define REV(i,a,b) REVV(i,a,b,1)\n\n#define FOR(i,a) for(int i=0; i<a; i++)\n#define FORD(i,a) for(int i=(int)a-1; i>=0; i--)\n\n#define pb push_back\n#define F first\n#define S second\n\nconst int OO = 1e9;\nconst ll INF = 1e18;\n\nconst int irand(int lo,int hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\nconst ll lrand(ll lo,ll hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\n#define getc getchar\ntemplate<typename T>\nT getnum(){\n\tint sign = 1;\n\tT ret = 0;\n\tchar c;\n\n\tdo{\n\t\tc = getc();\n\t}while(c == ' ' || c == '\\n');\n\tif(c == '-')sign = -1;\n\telse ret = c-'0';\n\twhile(1){\n\t\tc = getc();\n\t\tif(c < '0' || c > '9')break;\n\t\tret = 10*ret + c-'0';\n\t}\n\treturn sign * ret;\n}\n\ninline void ini(int& x){\n\tx = getnum<int>();\n}\n\ninline void scani(int& x){\n\tscanf(\"%d\",&x);\n}\n\n//end of macro\n\nint main(){\n//    ios_base::sync_with_stdio(0);\n//    cin.tie(0);\n//    cout.tie(0);\n//    #define endl '\\n'\n//    cout.setf(ios::fixed);\n//    cout.setf(ios::showpoint);\n//    cout.precision(10);\n    \n    int n;\n    cin>>n;\n    bool yes = false;\n    while(n){\n    \tif(n%10 == 9)yes = true;\n    \tn /= 10;\n\t}\n\tif(yes)cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 205, P = 998244353;\n\nint n, h[N], t;\nbool v[N][N];\n\nint qp (int a, int b) { int c = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b & 1) c = 1ll * c * a % P; return c; }\n\nstruct Vector {\n\tint x, y;\n}p[N];\n\nVector operator - (const Vector &A, const Vector &B) { return Vector{A.x - B.x, A.y - B.y}; }\nint operator * (const Vector &A, const Vector &B) { return A.x * B.y - A.y * B.x; }\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d%d\", &p[i].x, &p[i].y);\n\tint ans = qp(2, n) - 1 - n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\th[1] = i;\n\t\tfor (int j = i + 1; j <= n; ++j) if (!v[i][j]) {\n\t\t\th[t = 2] = j;\n\t\t\tfor (int k = j + 1; k <= n; ++k) if ((p[k] - p[i]) * (p[j] - p[i]) == 0) h[++t] = k;\n\t\t\tans = (ans - qp(2, t) + 1 + t) % P;\n\t\t\tfor (int a = 1; a <= t; ++a) for (int b = 1; b <= t; ++b) v[h[a]][h[b]] = 1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (ans + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-14;\ntypedef complex<double> P;\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<L>se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\t//if(se.find({i,j})!=se.end())continue;\n\t\tL l(v[i],v[j]);\n\t\tvector<int>x={i,j};\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectSP(l,v[k]))x.push_back(k);\n\t\tr=(r-pow_binary_mod(2,x.size()-2,M))%M;\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\t//se.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3,\"Ofast\",\"inline\")\n#include<bits/stdc++.h>\n#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\n#define ms(a,b) memset(a,b,sizeof(a))\n#define msn(a,n,b) for(int i=0;i<=n;i++)a[i]=b\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define fi first\n#define se second\nusing namespace std;\nmt19937 rng_32(chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef double db;\nconst int mod=998244353;\nconst int seed=233;\nconst double PI=acos(-1.0);\nconst double eps=1e-7;\nconst int inf=0x3f3f3f3f;\nconst int max_n=100005;\nll ceil(ll x,ll y){if(x==0)return 0;if(y<0)x=-x,y=-y;bool sign=x>0;x=abs(x);return sign?(x+y-1)/y:-x/y;}\nll floor(ll x,ll y){if(x==0)return 0;if(y<0)x=-x,y=-y;bool sign=x>0;x=abs(x);return sign?x/y:-(x+y-1)/y;}\nnamespace {\n    inline int Add(int x,int y){return (x+=y)>=mod?x-mod:x;}\n    inline int Sub(int x,int y){return (x-=y)<0?x+mod:x;}\n    inline int Mul(int x,int y) {return 1ll*x*y%mod;}\n    inline int Pow(int x,int y=mod-2){if(y==0)return 1;int res=1;while(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}return res;}\n}\n/**********************head************************/\nint n;\nint p2[max_n];\nP p[max_n];\nint main(){\n    scanf(\"%d\",&n);\n    p2[0]=1;\n    for(int i=1;i<=n;i++)p2[i]=Mul(p2[i-1],2);\n    for(int i=1;i<=n;i++)scanf(\"%d%d\",&p[i].fi,&p[i].se);\n    int ans=n+1;\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<=n;j++){\n            int a=p[j].se-p[i].se,b=p[i].fi-p[j].fi;\n            int c=-a*p[j].fi-b*p[j].se;\n            int cnt=2;\n            for(int k=j+1;k<=n;k++){\n                if(a*p[k].fi+b*p[k].se+c==0)cnt++;\n            }\n            for(int k=1;k<j;k++){\n                if(k==i||k==j)continue;\n                if(a*p[k].fi+b*p[k].se+c==0)cnt=0;\n            }\n            ans=Add(ans,Sub(p2[cnt],cnt+1));\n        }\n    }\n    printf(\"%d\\n\",Sub(p2[n],ans));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define x first\n#define y second\n\nconst int MOD = 998244353;\n\nint n;\nPII p[200];\nint ans = 0;\nint a[200][200];\nint p2[205];\n\nint dist2(int dx, int dy) {\n    return dx * dx + dy * dy;\n}\n\nint prod(const PII &a, const PII &b, const PII &c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ninline bool cmp(const PII &lhs, const PII &rhs) {\n    int pr = prod(p[0], lhs, rhs);\n    if (pr != 0) {\n        return pr < 0;\n    }\n    return dist2(lhs.x - p[0].x, lhs.y - p[0].y) < dist2(rhs.x - p[0].x, rhs.y - p[0].y);\n}\n\nvoid solve() {\n    sort(p + 1, p + n, cmp);\n    int sameLine = 0;\n    memset(a, 0, sizeof a);\n    for (int i = 1; i < n; ++i) {\n        if (i != 1 && prod(p[0], p[i - 1], p[i]) == 0) {\n            ++sameLine;\n        } else {\n            sameLine = 0;\n        }\n        a[i][0] = p2[sameLine];\n        for (int j = 1; j < i - sameLine; ++j) {\n            int mul = 0;\n            for (int k = j + 1; k < i; ++k) {\n                mul += prod(p[i], p[k], p[j]) < 0;\n            }\n            mul = p2[mul];\n            forn(k, j) {\n                if (a[j][k] && prod(p[j], p[i], p[k]) < 0) {\n                    a[i][j] = (a[i][j] + (LL)mul * a[j][k]) % MOD;\n                    ans = (ans + (LL)mul * a[j][k]) % MOD;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n//    freopen(\"input.txt\", \"r\", stdin);\n    p2[0] = 1;\n    for (int i = 1; i < 205; ++i) {\n        p2[i] = p2[i - 1] * 2 % MOD;\n    }\n    scanf(\"%d\", &n);\n    forn(i, n) scanf(\"%d%d\", &p[i].x, &p[i].y);\n    while (n >= 3) {\n        sort(p, p + n);\n        solve();\n        swap(p[0], p[n - 1]);\n        --n;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n Question Description:\n You are given N points (xi,yi) located on a two-dimensional plane. Consider a subset S of the N points that\n forms a convex polygon. Here, we say a set of points S forms a convex polygon when there exists a convex \n polygon with a positive area that has the same set of vertices as S. All the interior angles of the polygon\n must be strictly less than 180°.\n For a given set S, let n be the number of the points among the N points that are inside the convex hull of S \n (including the boundary and vertices). Then, we will define the score of S as 2^{n−|S|}.\n Compute the total score.\n ***\n Input:\n N\n x1 y1\n x2 y2\n ...\n xN yN\n ***\n Output:\n Total Score.\n \n ***\n Idea: count subsets\n*/\n\n#include <memory.h>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n\n#define REP(i,s,n) for(int (i)=s; (i)<(int)(n);(i)++)\n#define RIT(it,c) for(__typeof(c.begin()) it = c.begin();it!=c.end();it++)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)(x).size()\n#define MSET(m,v) memset(m,v,sizeof(m))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<LL> vL;\ntypedef vector<bool> vb;\ntypedef unordered_set<int> ui;\ntypedef pair<LL,LL> pLL;\n\nint N;\nvector<ii> PT;\n\n\n// For mod questions\nconst LL MOD = 998244353;\nint gcd(int x,int y){\n    if(x<y) swap(x,y);\n    if(!y) return x;\n    return gcd(y, x%y);\n}\ninline LL Add(LL x,LL y){return (x+y)%MOD; }\ninline LL Mul(LL x,LL y){return (x*y)%MOD; }\nvoid Ad(LL &x, LL y){\n    x += y;\n    if(x >= MOD) x %= MOD;\n}\nvoid Mu(LL &x, LL y){\n    x *= y;\n    if(x >= MOD) x %= MOD;\n}\nLL Pow(LL x, LL k){\n    LL ans = 1;\n    while(k){\n        if(1&k) Mu(ans, x);\n        Mu(x, x);\n        k >>= 1;\n    }\n    return ans;\n}\n\nclass ConvexScore{\n    vL pw2;\n    vector<vb> coline;\n    ii makeLine(int x, int y){\n        if(!x) return ii(0,1);\n        if(!y) return ii(1,0);\n        int m = gcd(abs(x), abs(y));\n        if(x >= 0) return ii(x/m, y/m);\n        else return ii(-x/m, -y/m);\n    }\n    void init(int N){\n        pw2.resize(N+1);\n        pw2[0] = 1;\n        for(int i=1;i<=N;++i) pw2[i] = Mul(pw2[i-1], 2);\n        coline = vector<vb>(N,vb(N,false));\n    }\n    inline LL cntGroup(LL m){ return Add(pw2[m], MOD - 1 - m - m*(m-1)/2); }\npublic:\n    LL totalScore(int N, vector<ii> &PT){\n        if(N<3) return 0;\n        init(N);\n        LL ans = 0, cnt = 0;\n        for(int i=0;i<N;++i){\n            map<ii,vi> line;\n            for(int j=i+1;j<N;++j) if(!coline[i][j]){\n                auto key = makeLine(PT[i].first-PT[j].first, PT[i].second-PT[j].second);\n                line[key].push_back(j);\n            }\n            for(auto p:line){\n                auto vec = p.second;\n                int nv = (int)vec.size();\n                if(nv<2) continue;\n                Ad(cnt, cntGroup(nv+1));\n                for(int j=0;j<nv;++j) for(int k = j+1;k<nv;++k) coline[vec[j]][vec[k]] = true;\n            }\n        }\n        ans = Add(cntGroup(N), MOD - cnt);\n        return ans;\n    }\n};\n\n\nint main(){\n    /*Write your code here*/\n    cin>>N;\n    PT.resize(N);\n    for(int i=0;i<N;++i) cin>>PT[i].first>>PT[i].second;\n    cout<<ConvexScore().totalScore(N, PT)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nset<pair<ld, ld> > done;\nll am, n;\npair<ll, ll> points[300];\nbool colin(int a, int b, int c)\n{\n\tif (points[a].first == points[b].first && points[b].first == points[c].first) return true;\n\tld first = ((ld)points[a].second-points[b].second)/(points[a].first-points[b].first);\n\tld second = ((ld)points[a].second-points[c].second)/(points[a].first-points[c].first);\n\treturn first == second;\n}\nint main()\n{\n\tam = 1;\n\tll mod = 998244353L*1000;\n\tscanf(\"%lld\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld%lld\", &points[i].first, &points[i].second);\n\t\tam*=2;\n\t\tam%=mod;\n\t}\n\tam-=n+1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i+1; j < n; j++)\n\t\t{\n\t\t\tld m = ((ld)points[i].second-points[j].second)/(points[i].first-points[j].first);\n\t\t\tld c = points[i].second-m*points[i].first;\n\t\t\tif (points[i].first == points[j].first)\n\t\t\t{\n\t\t\t\tm = 6487.27;\n\t\t\t\tc = points[i].first;\n\t\t\t}\n\t\t\t\n\t\t\tif (done.find(make_pair(m, c)) != done.end()) continue;\n\t\t//\tprintf(\"%d %d %Lf %Lf\\n\", i, j, m, c);\n\t\t\tdone.insert(make_pair(m, c));\n\t\t\tll am2 = 4;\n\t\t\tll in = 2;\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t{\n\t\t\t\tif (colin(i, j, k) && i != k && j != k)\n\t\t\t\t{\n\t\t\t\t\tam2*=2;\n\t\t\t\t\tam2%=mod/1000;\n\t\t\t\t\tin++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tam2-=in+1;\n\t\t//\tprintf(\" %lld %lld\\n\", in, am2);\n\t\t\tam-=am2;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", am%(mod/1000));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<ctime>\n#include<random>\nusing namespace std;\n\nint n;\nvector<pair<int, int> > v;\n\nbool use[202];\nlong long int p2[202];\n#define MOD 998244353\nint main(){\n\tp2[0] = 1;\n\tfor (int i = 1; i < 202; i++){\n\t\tp2[i] = p2[i - 1];\n\t\tp2[i] *= 2;\n\t\tif (p2[i] >= MOD){\n\t\t\tp2[i] %= MOD;\n\t\t}\n\t}\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tv.push_back(make_pair(a, b));\n\t}\n\tlong long int ng = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tng++;\n\t\tmemset(use, false, sizeof(use));\n\t\tfor (int j = i + 1; j < n; j++){\n\t\t\tint cnt = 1;\n\t\t\tif (use[j])continue;\n\t\t\tuse[j] = true;\n\t\t\tpair<long long int, long long int> vec = make_pair(v[j].first - v[i].first, v[j].second - v[i].second);\n\t\t\tfor (int k = j+1; k < n; k++){\n\t\t\t\tpair<long long int, long long int> vec2 = make_pair(v[k].first - v[i].first, v[k].second - v[i].second);\n\t\t\t\tif (vec.first*vec2.second == vec.second*vec2.first){\n\t\t\t\t\tuse[k] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long int way = p2[cnt];\n\t\t\tway += MOD - 1;\n\t\t\tif (way >= MOD)way %= MOD;\n\t\t\tng += way;\n\t\t\tif (ng >= MOD)ng %= MOD;\n\t\t}\n\t}\n\tlong long int ALL = p2[n] + MOD - 1 + MOD - ng;\n\tALL %= MOD;\n\tprintf(\"%lld\\n\", ALL);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define reg register\n#define ll long long\n#define mo 998244353\n#define maxn 205\ninline ll read()\n{\n\tll x=0,w=0;char ch=getchar();\n\twhile(!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn w?-x:x;\n}\nint n,x[maxn],y[maxn],po[maxn],ans;\ninline bool bd(int i,int j,int k)\n{\n    int a=x[k]-x[i],b=y[k]-y[i];\n    int c=x[j]-x[k],d=y[j]-y[k];\n    if(1ll*a*c<0)return false;\n    if(1ll*b*d<0)return false;\n    if(1ll*a*d!=1ll*b*c)return false;\n    return true;\n}\nint main()\n{\n    n=read();reg int i,j,k,tot;po[0]=1;\n    for(i=1;i<=n;++i)x[i]=read(),y[i]=read();\n    for(i=1;i<=n;++i)po[i]=po[i-1]*2%mo;\n    ans=po[n]-n-1;\n    for(i=2;i<=n;++i)\n        for(j=1;j<i;++j)\n        {\n            tot=0;\n            for(k=1;k<=n;++k)\n                if(i!=k&&j!=k&&bd(i,j,k))\n                    ++tot;\n            ans=(ans+mo-po[tot])%mo;\n        }\n    cout<<ans<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define SORT(c) sort((c).begin(), (c).end())\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> V;\ntypedef map<int, int> M;\n\nconstexpr ll INF = 1e18;\nconstexpr ll MOD = 998244353;\nconstexpr double PI = 3.14159265358979323846;\nconstexpr int di[] = {0, 0, 1, -1};\nconstexpr int dj[] = {1, -1, 0, 0};\n\nll fastPow(ll x, ll n)\n{\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return fastPow(x * x % MOD, n / 2);\n    else\n        return x * fastPow(x, n - 1) % MOD;\n}\n\nll fac[112346];\nvoid combInit(int mx)\n{\n    fac[0] = 0;\n    fac[1] = 1;\n    for (int i = 2; i <= mx; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n}\n\nll modDiv(ll a, ll b)\n{\n    return a * fastPow(b, MOD - 2) % MOD;\n}\n\nll comb(ll a, ll b)\n{\n    if (b == 0)\n        return 1;\n    if (a < b)\n        return 0;\n    if (a <= 0 || b < 0)\n        return 0;\n    if (a == b)\n        return 1;\n\n    ll p, c;\n\n    c = modDiv(fac[a], fac[a - b]);\n    p = fac[b];\n\n    ll res = modDiv(c, p);\n\n    return res;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    combInit(210);\n\n    int n, x[210], y[210];\n\n    cin >> n;\n    REP(i, n)\n    cin >> x[i] >> y[i];\n\n    ll res = 0;\n\n    V l;\n\n    bool used[210][210];\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            used[i][j] = false;\n\n    for (int i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++)\n        {\n            if (used[i][j] || used[j][i])\n                continue;\n\n            int cnt = 2;\n\n            for (int k = 0; k < n; k++)\n            {\n                if (i == k || j == k)\n                    continue;\n\n                if (used[i][k] || used[j][k] || used[k][i] || used[k][j])\n                {\n                    cnt = 0;\n                    break;\n                }\n\n                int a = (x[j] - x[i]) * (y[k] - y[j]);\n                int b = (y[j] - y[i]) * (x[k] - x[j]);\n\n                if (a == b)\n                {\n                    cnt++;\n                    used[i][k] = true;\n                    used[k][i] = true;\n                    used[j][k] = true;\n                    used[k][j] = true;\n                }\n            }\n\n            if (cnt > 2)\n            {\n                used[i][j] = true;\n                used[j][i] = true;\n\n                l.push_back(cnt);\n            }\n        }\n\n    for (int i = 3; i <= n; i++)\n    {\n        ll tmp = 0;\n        tmp += comb(n, i);\n\n        for (int j : l)\n        {\n            if (i > j)\n                continue;\n\n            tmp += MOD - comb(j, i);\n\n            tmp %= MOD;\n        }\n\n        res += tmp;\n        res %= MOD;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n#include \"ext/pb_ds/tree_policy.hpp\"\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define all(x) x.begin(), x.end()\n#define IO ios :: sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define pii pair<int,int>\n#define sz(x) (int)x.size()\nconst int mod = 1e9 + 7;\nconst int mod1 = 998244353;\ntypedef long double f80;\n\n#ifndef LOCAL\n#pragma GCC optimize (\"O2\")\n#define endl '\\n'\n#endif\n\ntemplate<typename T>\nusing ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rand(int l, int r){\n    uniform_int_distribution<int> uid(l, r);\n    return uid(rng);\n}\n\nll pwr(ll a,ll b, ll mod){\n    a %= mod;\n    int ans = 1;\n    while(b){\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nconst int N = 205;\npii p[N];\nset<pair<int,pii>> m;\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tfr(i ,1, n){\n\t\tcin >> p[i].fi >> p[i].se;\n\t}\n\tint ans = pwr(2, n, mod1);\n\tfr(i, 1, n){\n\t\tfr(j, i + 1, n){\n\t\t\tint c = 0;\n\t\t\tpii lol = {p[j].fi - p[i].fi, p[j].se - p[i].se};\n\t\t\tint g = abs(__gcd(lol.fi, lol.se));\n\t\t\tif(lol.fi < 0)\n\t\t\t\tg *= -1;\n\t\t\tlol.fi /= g, lol.se /= g;\n\t\t\tif(m.count({i, lol}))\n\t\t\t\tcontinue;\n\t\t\tfr(k, 1, n){\n\t\t\t\tif((p[k].se - p[i].se) * (p[j].fi - p[i].fi) == (p[j].se - p[i].se) * (p[k].fi - p[i].fi))\n\t\t\t\t\t{ c++; m.insert({k, lol}); }\n\t\t\t}\n\t\t\tint val = pwr(2, c, mod1) - c - 1;\n\t\t\tans = (ans + mod1 - val) % mod1;\n\t\t}\n\t}\n\tans -= n + 1;\n\tcout << ans;\n}\nsigned main(){\n    IO;\n    #ifdef LOCAL\n        freopen(\"inp.txt\",\"r\", stdin);\n        freopen(\"out.txt\", \"w\", stdout);\n    #endif\n    cout << setprecision(10) << fixed;\n    int t = 1;\n    // cin >> t;\n    fr(tt, 1, t){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\n//const int MOD = 1000000007;\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nvoid solve() {\n\tint n; cin >> n;\n    vector<int> x(n), y(n);\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n    }\n    bc.init(1000);\n    mint ans = 0;\n    for(int i = 3; i <= n; ++ i) {\n        ans += bc.com(n, i);\n    }\n    map<int, int> mp;\n    rep(i, n) {\n        for(int j = i + 1; j < n; ++ j) {\n            int cnt = 2;\n            rep(k, n) {\n                if(k == i || k == j) continue;\n                if((y[j] - y[i]) * (x[k] - x[i]) == (y[k] - y[i]) * (x[j] - x[i])) {\n                    ++ cnt;\n                }\n            }\n            mp[cnt] ++;\n        }\n    }\n    for(int i = 3; i <= n; ++ i) {\n        mint res = 0;\n        for(int j = 3; j <= i; ++ j) {\n            res += bc.com(i, j);\n        }\n        ans -= res * (mint)mp[i] / bc.com(i, 2);\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 998244353;\nconst int maxn = 200 + 50;\nint n;\nll p[maxn];\nll x[maxn], y[maxn];\nmap<pair<ll, ll>, ll> mp;\nvoid pre(){\n    p[0] = 1;\n    for(int i = 1; i < maxn; i++){\n        p[i] = (p[i-1] * 2) % mod;\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    pre();\n    while(cin >> n){\n        for(int i = 0; i < n; i++)\n            cin >> x[i] >> y[i];\n        ll ans = p[n] - n - 1;//减去空集和单点集\n        ll deltay, deltax, k;\n        for(int j = 0; j < n; j++){\n            mp.clear();\n            for(int j = i+1; j < n; j++){\n                deltay = y[j] - y[i];\n                deltax = x[j] - x[i];\n                k = __gcd(deltay, deltax);\n                deltay/=k;\n                deltax/=k;\n                ++mp[{deltay,deltax}];\n            }\n            for(map<pair<ll, ll>, ll>::iterator iter = mp.begin(); iter != mp.end(); iter++){\n                ll tmp = p[iter->second] - 1;//除i点以外共线集的个数，减去只有一个i点的情况\n                ans = (ans - tmp + mod) % mod;\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int maxn=200+10,mo=998244353;\nconst db eps=1e-6;\nint two[maxn],x[maxn],y[maxn];\nint i,j,k,l,t,n,m,ans;\nbool check(int i,int j,int k){\n\tif ((y[j]-y[i])*(x[k]-x[i])==(y[k]-y[i])*(x[j]-x[i])) return 1;else return 0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\ttwo[0]=1;\n\tfo(i,1,n) two[i]=(ll)two[i-1]*2%mo;\n\tfo(i,1,n) scanf(\"%d%d\",&x[i],&y[i]);\n\tans=(two[n]-n-1)%mo;\n\tfo(i,1,n-1)\n\t\tfo(j,i+1,n){\n\t\t\tt=0;\n\t\t\tfo(k,j+1,n)\n\t\t\t\tif (check(i,j,k)) t++;\n\t\t\t(ans-=two[t])%=mo;\n\t\t}\n\t(ans+=mo)%=mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\nint fastpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = fastpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int comb(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nbool on_line(int x1, int y1, int x2, int y2, int x3, int y3){\n    int X1 = x1 - x3;\n    int Y1 = y1 - y3;\n    int X2 = x2 - x3;\n    int Y2 = y2 - y3;\n    if(X1 * Y2 == Y1 * X2){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    vec x(N), y(N);\n    REP(i, N) cin >> x[i] >> y[i];\n\n    int ans = 0;\n    int mod = 998244353;\n    Combination C(N, mod);\n    FOR(k, 3, N + 1) ans = (ans + C.comb(N, k)) % mod;\n\n    vector<vector<bool>> used(N, vector<bool>(N, false));\n    REP(i, N){\n        FOR(j, i + 1, N){\n            if(used[i][j]) continue;\n            vec list({i, j});\n            FOR(k, j + 1, N) if(on_line(x[i], y[i], x[j], y[j], x[k], y[k])) list.push_back(k);\n            int n = list.size();\n            FOR(k, 3, n + 1) ans = (ans + mod - C.comb(n, k)) % mod;\n            REP(k, n) FOR(l, k + 1, n) used[list[k]][list[l]] = true;\n        }\n    }\n\n    cout << ans;\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2018\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\n\nnamespace mine\n{\n\ttypedef long long ll;\n\tconst int INF=0x3f3f3f3f;\n\t//#define pr pair<double,int>\n\t#define FR first\n\t#define SE second\n\t#define MP make_pair\n\n\tconst int MAX_N=210;\n\tstruct Nod{int x,y;}p[MAX_N];\n\tint cross(Nod a,Nod b) {return a.x*b.y-a.y*b.x;}\n\tconst int MOD=998244353;\n\tbool v[MAX_N][MAX_N];\n\tint bin[MAX_N];\n\tvoid main()\n\t{\n\t\tbin[0]=1;for(int i=1;i<MAX_N;i++) bin[i]=bin[i-1]*2%MOD;\n\n\t\tint n;scanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&p[i].x,&p[i].y);\n\n\t\tint ans=bin[n]-1-n;//printf(\"ans=%d\\n\",ans);\n\t\tfor(int a=1;a<=n;a++)\n\t\t\tfor(int b=a+1;b<=n;b++)\n\t\t\t{\n\t\t\t\tint mi,mx;\n\t\t\t\tif(p[a].x==p[b].x) {if(p[a].y<p[b].y) mi=a,mx=b; else mi=b,mx=a;}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(p[a].x<p[b].x) mi=a,mx=b;\n\t\t\t\t\telse mi=b,mx=a;\n\t\t\t\t}\n\n\t\t\t\tint tot=2;\n\t\t\t\tfor(int c=1;c<=n;c++) if(c!=a and c!=b)\n\t\t\t\t{\n\t\t\t\t\tif(cross(\n\t\t\t\t\t\t(Nod){p[a].x-p[b].x,p[a].y-p[b].y},\n\t\t\t\t\t\t(Nod){p[a].x-p[c].x,p[a].y-p[c].y})==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(p[a].x==p[b].x)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(p[c].y<p[mi].y) mi=c;\n\t\t\t\t\t\t\telse if(p[c].y>p[mx].y) mx=c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(p[c].x<p[mi].x) mi=c;\n\t\t\t\t\t\t\telse if(p[c].x>p[mx].x) mx=c;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttot++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(v[mi][mx]) continue;\n\t\t\t\tv[mi][mx]=1;\n\t\t\t\tans-=bin[tot]-tot-1;\n\t\t\t\tans%=MOD;\n\t\t\t\t//printf(\"(%d,%d,%d,%d)=%d\\n\",mi,mx,a,b,tot);\n\t\t\t}\n\t\tprintf(\"%d\",(ans+MOD)%MOD);\n\t}\n};\nint main()\n{\n\tsrand(time(0));\n\tmine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef pair<int,int> pa;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\nconst int N=1e5+5,M=5e7+5,INF=1e9,mod=998244353;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint n;\nstruct P{\n\tint x,y;\n\til P(){}\n\til P(int x,int y):x(x),y(y){}\n\til bool operator<(const P&o)const{if(x==o.x)return y<o.y;return x<o.x;}\n\til int operator*(const P&o)const{return x*o.y-y*o.x;}\n\til P operator-(const P&o)const{return P(x-o.x,y-o.y);}\n}p[N];\nll pw[N];\nil int bad(int i,int j,int k){\n\tif((p[j]-p[i])*(p[k]-p[i])==0)return 1;\n\treturn 0;\n}\nint main(){\n\tread(n);rep(i,1,n)read(p[i].x,p[i].y);\n\tpw[0]=1;rep(i,1,n)pw[i]=pw[i-1]*2%mod;\n\tsort(p+1,p+1+n);\n\tll qaq=0;\n\trep(i,1,n)rep(j,i+1,n){\n\t\tint ok=1;\n\t\trep(k,1,j)\n\t\t\tif(k!=i&&k!=j)\n\t\t\t\tif(bad(i,j,k))ok=0;\n\t\tif(ok){\n\t\t\tint res=2;\n\t\t\trep(k,j+1,n)res+=bad(i,j,k);\n\t\t\tqaq+=pw[res]-res-1;\n\t\t}\n\t}\n\tqaq=pw[n]-qaq-n-1;\n\tcout<<qaq<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\n\nconst int N = 203, mod = 998244353;\n\nstruct pnt {\n\tint x, y;\n\tinline void in() {scanf(\"%d%d\", &x, &y);}\n\tfriend inline pnt operator - (const pnt&A, const pnt&B) {return (pnt) {A.x - B.x, A.y - B.y};}\n\tfriend inline int operator * (const pnt&A, const pnt&B) {return A.x * B.y - A.y * B.x;}\n} p[N];\n\ninline bool con(const pnt&A, const pnt&B, const pnt&C) {\n\treturn (C - A) * (B - A) == 0;\n}\n\nint n;\nint bin[N];\nbool vs[N];\nll Ans;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i=bin[0]=1;i<=n;++i) bin[i] = (bin[i-1] << 1)%mod;\n\tfor(int i=1;i<=n;++i) p[i].in();\n\tfor(int i=1;i<n;++i) {\n\t\tfor(int j=1;j<=n;++j) vs[j] = false;\n\t\t\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif(!vs[j]) {\n\t\t\t\tint ct = 2;\n\t\t\t\tfor(int k=j+1;k<=n;++k)\n\t\t\t\t\tif(con(p[i], p[j], p[k])) vs[k] = true, ++ct;\n\t\t\t\t\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int k=1;k<i and flg;++k)\n\t\t\t\t\tif(con(p[i], p[j], p[k])) flg = false;\n\t\t\t\tif(flg) Ans += bin[ct] - ct - 1;\n\t\t\t}\n\t}\n\tAns = ((ll)mod*mod - Ans - n - 1 + bin[n])%mod;\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int Q = 998244353;\nconst int N = 209;\nll x[N], y[N], p[N];\ninline int read() {\n    int s = 1, a = 0; char ch = getchar();\n    while (ch < '0' || ch > '9') {if (ch == '-') s = -1; ch = getchar();}\n    while (ch >= '0' && ch <= '9') {a = a * 10 + ch - '0'; ch = getchar();}\n    return s * a;\n}\ninline bool isCollinear(int i, int j, int k) {\n    return (y[k] - y[j]) * (x[j] - x[i]) == (y[j] - y[i]) * (x[k] - x[j]);\n}\nint main() {\n    int n = read();\n    for (int i = 1; i <= n; i++) x[i] = read(), y[i] = read();\n    p[0] = 1;\n    for (int i = 1; i <= n; i++) p[i] = p[i - 1] * 2 % Q;\n    ll res = p[n];\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            int m = 2;\n            for (int k = j + 1; k <= n; k++) {\n                if (isCollinear(i, j, k)) m++;\n            }\n            res = (res - p[m] + m + 1 + Q) % Q;\n        }\n    }\n    res = (res - n - 1 + Q) % Q;\n    printf(\"%d\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-12;\ntypedef complex<double> P;\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<pair<int,int> >se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\tif(se.find({i,j})!=se.end())continue;\n\t\tvector<int>x={i,j};\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&abs(imag(conj(v[j]-v[k])*(v[i]-v[k]))) < EPS)x.push_back(k);\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\tint n=b-a-1;\n\t\t\tr=(r-pow_binary_mod(2,n,M))%M;\n\t\t\tse.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include  <functional>\n#include  <algorithm>\n#include  <exception>\n#include  <stdexcept>\n#include  <streambuf>\n#include  <iterator>\n#include  <string.h>\n#include  <stdlib.h>\n#include  <typeinfo>\n#include  <valarray>\n#include  <iostream>\n#include  <sstream>\n#include  <istream>\n#include  <stdio.h>\n#include  <climits>\n#include  <clocale>\n#include  <complex>\n#include  <csetjmp>\n#include  <csignal>\n#include  <cstdarg>\n#include  <cstddef>\n#include  <ctype.h>\n#include  <cassert>\n#include  <cstdlib>\n#include  <utility>\n#include  <cstring>\n#include  <numeric>\n#include  <ostream>\n#include  <cwctype>\n#include  <fstream>\n#include  <iomanip>\n#include  <math.h>\n#include  <bitset>\n#include  <cctype>\n#include  <string>\n#include  <vector>\n#include  <limits>\n#include  <locale>\n#include  <memory>\n#include  <cerrno>\n#include  <time.h>\n#include  <iosfwd>\n#include  <cfloat>\n#include  <cstdio>\n#include  <cwchar>\n#include  <cmath>\n#include  <ctime>\n#include  <deque>\n#include  <queue>\n#include  <stack>\n#include  <list>\n#include  <ios>\n#include  <map>\n#include  <set>\n#include  <new>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ll long long\n#define pii pair<int,int>\nusing namespace std;\nconst int P=998244353;\nint n;\nstruct pos{\n\tint x,y;\n}ps[1007];\nint ep=0,f[1007],sz[1007];\nint gf(int x){while(x!=f[x])x=f[x]=x[f][f];return x;}\nstruct edge{\n\tint a,b;\n\tint v;\n\tbool operator<(const edge&e)const{return v<e.v;}\n\tvoid cal(){\n\t\tint x=gf(a),y=gf(b);\n\t\tif(x!=y)f[x]=y,sz[y]+=sz[x];\n\t}\n}es[207*207];\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\nint pw[1007],ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor(int i=1;i<=n;++i)pw[i]=pw[i-1]*2%P;\n\tans=(pw[n]-n-1)%P;\n\tfor(int i=0;i<n;++i)scanf(\"%d%d\",&ps[i].x,&ps[i].y);\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=0;j<i;++j){\n\t\t\tint x=ps[i].x-ps[j].x,y=ps[i].y-ps[j].y;\n\t\t\tint g=gcd(x,y);\n\t\t\tx/=g,y/=g;\n\t\t\tif(!x)y=1;\n\t\t\tif(!y)x=1;\n\t\t\tif(x<0)x=-x,y=-y;\n\t\t\tes[ep++]=(edge){i,j,x*30000+y};\n\t\t}\n\t}\n\tstd::sort(es,es+ep);\n\tfor(int i=0,j=0;i<ep;i=j){\n\t\tfor(int a=0;a<n;++a)sz[f[a]=a]=1;\n\t\tfor(;j<ep&&es[i].v==es[j].v;es[j++].cal());\n\t\tfor(int a=0;a<n;++a)if(f[a]==a&&sz[a]>1)ans=(ans-pw[sz[a]]+sz[a]+1)%P;\n\t}\n\tprintf(\"%d\\n\",(ans%P+P)%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n#define ll long long\n#define Vector Point\nconst int MOD=998244353;\nconst int MAXN=200;\nvoid M(int& a){((a%=MOD)+=MOD)%=MOD;}\nstruct Point{int x,y;};\nVector operator-(const Point& a,const Point& b){return (Vector){a.x-b.x,a.y-b.y};}\nint cross(const Vector& a,const Vector& b){return a.x*b.y-a.y*b.x;}\nint n,ans;\nPoint p[MAXN+10];\nint quickpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y;y>>=1,x=(ll)x*x%MOD)if(y&1)res=(ll)res*x%MOD;\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);M(ans=quickpow(2,n)-n-1);\n\tfor(int i=1;i<=n;++i)scanf(\"%d%d\",&p[i].x,&p[i].y);\n\tPoint a,b;int cnt;bool flag;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tflag=true;a=p[i];b=p[j];\n\t\t\tfor(int k=1;k<j;++k)if(k!=i&&cross(a-p[k],b-p[k])==0){flag=false;break;}\n\t\t\tif(!flag)continue;\n\t\t\tcnt=2;\n\t\t\tfor(int k=j+1;k<=n;++k)if(cross(a-p[k],b-p[k])==0)++cnt;\n\t\t\tM(ans-=quickpow(2,cnt)-cnt-1);\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: CNYALI_LK\nLANG: C++\nPROG: E.cpp\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconst double eps=1e-8;\nconst double PI=acos(-1.0);\ntypedef long long ll;\ntemplate<class T>void chkmin(T &a,T b){a=a<b?a:b;}\ntemplate<class T>void chkmax(T &a,T b){a=a>b?a:b;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\n#define min mmin\n#define max mmax\n#define abs aabs\nconst ll mod=998244353;\nll p[233];\nstruct zb{\n\tll x,y;\n};\nzb a[233];\nll cmp(zb a,zb b){return a.x<b.x||a.x==b.x&&a.y<b.y;}\nint main(){\n#ifdef cnyali_lk\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n\tll n,ans;\n\tscanf(\"%lld\",&n);\n\tp[0]=1;\n\tfor(ll i=1;i<=n;++i){p[i]=p[i-1]<<1;if(p[i]>=mod)p[i]-=mod;scanf(\"%lld%lld\",&a[i].x,&a[i].y);}\n\tsort(a+1,a+n+1,cmp);\n\tans=p[n]-n-1;\n\tfor(ll i=1;i<=n;++i)for(ll j=i+1;j<=n;++j){\n\t\tll no=0;\n\t\tfor(ll k=1;k<j;++k)if(k!=i&&(a[j].x-a[i].x)*(a[i].y-a[k].y)==(a[j].y-a[i].y)*(a[i].x-a[k].x)){no=1;break;}\n\t\tif(!no){\n///\t\t\tdebug(\"(%lld,%lld) (%lld,%lld)\",a[i].x,a[i].y,a[j].x,a[j].y);\n\t\t\tll tot=2;\n\t\t\tfor(ll k=j+1;k<=n;++k){\n\t\t\t\tif((a[j].x-a[i].x)*(a[i].y-a[k].y)==(a[j].y-a[i].y)*(a[i].x-a[k].x)){++tot;/*debug(\" (%lld,%lld)\",a[k].x,a[k].y);*/}\n\t\t\t}\n//\t\t\tdebug(\"\\n\");\n\t\t\tans-=p[tot]-tot-1;\n\t\t}\n\t}\t\n\tprintf(\"%lld\\n\",(ans%mod+mod)%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nset<pair<ld, ld> > done;\nll am, n;\npair<ll, ll> points[300];\nbool colin(int a, int b, int c)\n{\n\tif (points[a].first == points[b].first && points[b].first == points[c].first) return true;\n\tld first = ((ld)points[a].second-points[b].second)/(points[a].first-points[b].first);\n\tld second = ((ld)points[a].second-points[c].second)/(points[a].first-points[c].first);\n\treturn first == second;\n}\nint main()\n{\n\tam = 1;\n\tll mod = 998244353L*1000;\n\tscanf(\"%lld\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld%lld\", &points[i].first, &points[i].second);\n\t\tam*=2;\n\t\tam%=mod;\n\t}\n\tam-=n+1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i+1; j < n; j++)\n\t\t{\n\t\t\tld m = ((ld)points[i].second-points[j].second)/(points[i].first-points[j].first);\n\t\t\tld c = points[i].second-m*points[i].first;\n\t\t\tif (points[i].first == points[j].first)\n\t\t\t{\n\t\t\t\tm = 6487.27;\n\t\t\t\tc = points[i].first;\n\t\t\t}\n\t\t\t\n\t\t\tif (done.find(make_pair(m, c)) != done.end()) continue;\n\t\t//\tprintf(\"%d %d %Lf %Lf\\n\", i, j, m, c);\n\t\t\tdone.insert(make_pair(m, c));\n\t\t\tll am2 = 4;\n\t\t\tll in = 2;\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t{\n\t\t\t\tif (colin(i, j, k) && i != k && j != k)\n\t\t\t\t{\n\t\t\t\t\tam2*=2;\n\t\t\t\t\tam2%=mod/500;\n\t\t\t\t\tin++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tam2-=in+1;\n\t\t//\tprintf(\" %lld %lld\\n\", in, am2);\n\t\t\tam-=am2%mod/1000;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", am%(mod/1000));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n; pii ps[2333];\npii jf(pii g)\n{\n\tint x=__gcd(g.fi,g.se);\n\tif(x) g.fi/=x, g.se/=x;\n\tif(g.fi<0) g.fi=-g.fi,g.se=-g.se;\n\treturn g;\n}\nmap<pii,int> cnt;\npii operator - (pii a,pii b)\n{\n\treturn pii(a.fi-b.fi,a.se-b.se);\n}\nconst int MOD=998244353;\nll qp(ll a,ll b)\n{\n\tll x=1;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d%d\",&ps[i].first,&ps[i].second);\n\tsort(ps+1,ps+1+n);\n\tll ans=qp(2,n)-n-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tcnt.clear();\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\t++cnt[jf(ps[j]-ps[i])];\n\t\tfor(auto g:cnt)\n\t\t\tans-=qp(2,g.se)-1;\n\t}\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) < 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\nint adds[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<point> ns;\n        for (int j = 0; j < n; j++) {\n            if (j == i) {\n                continue;\n            }\n            if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {\n                need[j] = true;\n                ns.push_back(p[j]);\n            } else {\n                need[j] = false;\n            }\n        }\n        cur = p[i];\n        sort(all(ns), comp);\n        for (int j = 0; j < sz(ns); j++) {\n            adds[j] = 0;\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (vec(ns[k] - p[i], ns[j] - p[i]) == 0) {\n                    adds[j]++;\n                }\n            }\n            for (int k = j + 1; k < sz(ns); k++) {\n                goods[j][k] = false;\n                cnt[j][k] = 0;\n                dp[j][k] = 0;\n                if (good(p[i], ns[j], ns[k])) {\n                    goods[j][k] = true;\n                    for (int g = j + 1; g < k; g++) {\n                        if (vec(ns[k] - p[i], ns[g] - p[i]) > 0 && vec(ns[j] - p[i], ns[g] - p[i]) > 0 && inside(p[i], ns[j], ns[k], ns[g])) {\n                            cnt[j][k]++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (goods[j][k]) {\n                    dp[j][k] += st[cnt[j][k] + adds[j] + adds[k]];\n                    dp[j][k] %= Mod;\n                    ans += dp[j][k];\n                    ans %= Mod;\n                    for (int nxt = k + 1; nxt < sz(ns); nxt++) {\n                        if (vec(ns[nxt] - ns[j], ns[k] - ns[j]) > 0 && goods[k][nxt] && vec(ns[nxt] - p[i], ns[k] - p[i]) != 0) {\n                            dp[k][nxt] += (1LL * dp[j][k] * st[cnt[k][nxt] - adds[k] + adds[nxt]]) % Mod;\n                            dp[k][nxt] %= Mod;\n                        }\n                    }\n                }   \n            }\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <cstdio> \n#include <iostream> \n#include <cmath> \n#include <string> \n#include <list> \n#include <vector> \n#include <algorithm> \n#include <functional> \n#include <utility> \n#include <set> \n#include <map> \n#include <complex> \n#include <queue> \n#include <stack> \n#include <cstdlib> \n#include <ctime> \n#include <cstring> \n#include <string.h> \n#include <unordered_set>\n#include <unordered_map>\n#include <cassert>\n\nusing namespace std; \n\ntypedef unsigned int uint; \ntypedef long long int64; \ntypedef unsigned long long uint64; \ntypedef unsigned short ushort; \ntypedef unsigned char uchar; \ntypedef pair<int,int> ipair; \ntypedef vector<int> VI; \ntypedef vector<string> VS; \ntypedef vector<double> VD; \n#define SIZE(A) ((int)(A.size()))\n#define LENGTH(A) ((int)(A.length()))\n#define MP(A,B) make_pair(A,B)\nconst double pi=acos(-1.0); \nconst double eps=1e-11; \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(a) (a).begin(),(a).end()\n\ntemplate<class T> T sqr(const T &x) { return x*x; } \ntemplate<class T> T lowbit(const T &x) { return (x^(x-1))&x; } \ntemplate<class T> int countbit(const T &n) { return (n==0)?0:(1+countbit(n&(n-1))); } \ntemplate<class T> void ckmin(T &a,const T &b) { if (b<a) a=b; } \ntemplate<class T> void ckmax(T &a,const T &b) { if (b>a) a=b; } \n\nconst int maxn=256;\nconst int MOD=998244353;\n\ninline int multiply(int a,int b)\n{\n\treturn ((int64)a*(int64)b)%MOD;\n}\ninline void addto(int &a,int b)\n{\n\ta+=b;\n\tif (a>=MOD) a-=MOD;\n}\ninline void delto(int &a,int b)\n{\n\ta-=b;\n\tif (a<0) a+=MOD;\n}\n\nint n;\nint x[maxn],y[maxn];\nint c[maxn][maxn][maxn];\nint s[maxn][maxn][maxn];\nint f[maxn][maxn];\nint p2[maxn];\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios_base::sync_with_stdio(false);\n\tcin>>n;\n\tREP(i,n) cin>>x[i]>>y[i];\n\tREP(i,n) REP(j,n) REP(k,n)\n\t{\n\t\tint t=(x[j]-x[i])*(y[k]-y[i])-(x[k]-x[i])*(y[j]-y[i]);\n\t\tc[i][j][k]=((t==0)?0:(t<0?-1:1));\n\t}\n\tREP(i,n+1) p2[i]=(i==0?1:multiply(p2[i-1],2));\n\tmemset(s,0,sizeof(s));\n\tREP(i,n) REP(j,n) REP(k,n) if (c[i][j][k]>0)\n\t{\n\t\tif (j<i) { s[i][j][k]=s[j][k][i]; continue; }\n\t\tif (k<i) { s[i][j][k]=s[k][i][j]; continue; }\n\t\tint w=0;\n\t\tREP(p,n) if (c[i][j][p]>=0 && c[j][k][p]>=0 && c[k][i][p]>=0) ++w;\n\t\ts[i][j][k]=w-3;\n\t}\n\tint ret=0;\n\tREP(key,n)\n\t{\n\t\tint size=0;\n\t\tint p[maxn];\n\t\tREP(i,n) if (x[i]>x[key] || x[i]==x[key] && y[i]>y[key]) p[size++]=i;\n\t\tsort(p,p+size,[&](int a,int b) { return c[a][b][key]>0; });\n\t\tREP(s1,size) FOR(s2,s1+1,size) if (c[key][p[s1]][p[s2]]>0)\n\t\t{\n\t\t\tf[s1][s2]=1;\n\t\t\tREP(s0,s1) if (c[key][p[s0]][p[s1]]>0 && c[p[s0]][p[s1]][p[s2]]>0) addto(f[s1][s2],f[s0][s1]);\n\t\t\tf[s1][s2]=multiply(f[s1][s2],p2[s[key][p[s1]][p[s2]]]);\n\t\t\taddto(ret,f[s1][s2]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by maze on 2019-07-21.\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n    using value_type = ::std::uint_fast64_t;\n    value_type n;\npublic:\n    ModInt() : n(0) {}\n    ModInt(value_type n_) : n(n_ % mod) {}\n    ModInt(const ModInt& m) : n(m.n) {}\n\n    template<typename T>\n    explicit operator T() const { return static_cast<T>(n); }\n    value_type get() const { return n; }\n\n    friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n        return os << a.n;\n    }\n\n    friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n        value_type x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return is;\n    }\n\n    bool operator==(const ModInt& m) const { return n == m.n; }\n    bool operator!=(const ModInt& m) const { return n != m.n; }\n    ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n    ModInt pow(value_type b) const{\n        ModInt ans = 1, m = ModInt(*this);\n        while(b){\n            if(b & 1) ans *= m;\n            m *= m;\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    ModInt inv() const { return (*this).pow(mod-2); }\n    ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n    ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n    ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n    ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n    ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n    ModInt& operator++(){ n += 1; return *this; }\n    ModInt& operator--(){ n -= 1; return *this; }\n    ModInt operator++(int){\n        ModInt old(n);\n        n += 1;\n        return old;\n    }\n    ModInt operator--(int){\n        ModInt old(n);\n        n -= 1;\n        return old;\n    }\n    ModInt operator-() const { return ModInt(mod-n); }\n};\n\nconstexpr int64 mod = 998244353;\nusing Mint = ModInt<mod>;\n\nint main(void) {\n    int64 N;\n    cin >> N;\n    vector<int64> x(N), y(N);\n    REP(i, N) {\n        cin >> x[i] >> y[i];\n    }\n    using T = tuple<int64, int64, int64>;\n    map<T, int64> cnt;\n    Mint res = Mint(2).pow(N);\n    REP(i, N) {\n        FOR(j, i+1, N) {\n            int64 a = y[i]-y[j], b = -(x[i]-x[j]), c = (x[i]*y[j]-x[j]*y[i]);\n            if (a < 0) {\n                a *= -1; b *= -1; c *= -1;\n            }\n            int64 g = __gcd(abs(a), __gcd(abs(b), abs(c)));\n            a /= g; b /= g; c /= g;\n            if (cnt[T(a, b, c)]) continue;\n            cnt[T(a, b, c)] = 1;\n            int64 sum = 2;\n            FOR(k, j+1, N) {\n                if (a * x[k] + b * y[k] + c == 0) {\n                    sum++;\n                }\n            }\n//            cout << i << \" \" << j << \" \" << a << \" \" << b << \" \" << c << \": \" << sum << endl;\n            res -= Mint(2).pow(sum) - sum - 1;\n        }\n    }\n    cout << res-N-1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mk make_pair\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nll pwr[210], mod=998244353;\nvoid pre(){\n  pwr[0]=1;\t\n  for(int i=1; i<=200; ++i){\n    pwr[i]=(pwr[i-1]*2)%mod;\n  }\n}\nll x[210], y[210];\nmap<pair<ll,ll>, ll> mp;\nint main(){\n  int n;\n  pre();\n  while(cin>>n){\n    for(int i=0; i<n; ++i){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    ll ans=pwr[n]-n-1, tmp1, tmp2, tmp;\n    for(int i=0; i<n; ++i){\n      mp.clear();\n      for(int j=i+1; j<n; ++j){\n        tmp1=(y[i]-y[j]);\n        tmp2=(x[i]-x[j]);\n        tmp=__gcd(tmp1, tmp2);\n        tmp1/=tmp;\n        tmp2/=tmp;\n        ++mp[mk(tmp1, tmp2)];\n      }\n      for(map<pair<ll,ll>, ll>::iterator it=mp.begin(); it!=mp.end(); ++it){\n        ans-=(pwr[it->second])-1;\n        ans%=mod;\n      }\n    }\n    ans%=mod;\n    if(ans<0)\n      ans+=mod;\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stdio.h>\nusing namespace std;\n#define ll long long\ntypedef pair<ll,ll> pi;\nint n;\npi arr[205];\nll mod = 998244353;\nll answer = 0;\nll factorial[205];\nll ifactorial[205];\nvector<int> v;\nbool collinear[205][205];\n\nll power(ll a, ll b){\n\ta %= mod;\n\tif (b == 0) return 1;\n\tif (b == 1) return a;\n\tll half = power(a, b/2);\n\thalf*=half;\n\thalf%=mod;\n\tif (b % 2 == 1){\n\t\thalf *= a;\n\t\thalf %= mod;\n\t}\n\treturn half;\n}\n\nvoid init(){\n\tfactorial[0] = 1;\n\tfor (int i = 1; i < 205; i++){\n\t\tfactorial[i] = factorial[i - 1]*i;\n\t\tfactorial[i] %= mod;\n\t}\n\tfor (int i = 1; i < 205; i++){\n\t\tifactorial[i] = power(factorial[i], mod - 2);\n\t}\n\t\n}\n\nll choose(ll n, ll k){\n\tif (n == k) return (long long)1;\n\treturn (((factorial[n]*ifactorial[k])%mod)*ifactorial[n - k])%mod;\n}\n\nll adjust(ll x){\n\tx %= mod;\n\tif (x < 0){\n\t\tx += mod;\n\t}\n\treturn x;\n}\n\nint main(){\n\tinit();\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lld%lld\", &arr[i].first, &arr[i].second);\n\t}\n\tsort(arr, arr + n);\n\tll answer = 0;\n\tfor (int i = 3; i <= n; i++){\n\t\tanswer += choose(n, i);\n\t\t//cout << \"choose (\" << n << \", \" << i << \") = \" << choose(n, i) << endl;\n\t}\n\tanswer = adjust(answer);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = i + 1; j < n; j++){\n\t\t\tif (collinear[i][j]) continue;\n\t\t\tv.clear();\n\t\t\tv.push_back(i);\n\t\t\tv.push_back(j);\n\t\t\tfor (int k = j + 1; k < n; k++){\n\t\t\t\tif ((arr[i].second - arr[j].second)*(arr[i].first - arr[k].first) == (arr[i].second - arr[k].second)*(arr[i].first - arr[j].first)){\n\t\t\t\t\tv.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < v.size(); k++){\n\t\t\t\tfor (int l = 0; l < v.size(); l++){\n\t\t\t\t\tcollinear[k][l] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 3; k <= v.size(); k++){\n\t\t\t\tanswer -= choose(v.size(), k);\n\t\t\t}\n\t\t\tanswer = adjust(answer);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", answer);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define SORT(c) sort((c).begin(), (c).end())\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> V;\ntypedef map<int, int> M;\n\nconstexpr ll INF = 1e18;\nconstexpr ll MOD = 998244353;\nconstexpr double PI = 3.14159265358979323846;\nconstexpr int di[] = {0, 0, 1, -1};\nconstexpr int dj[] = {1, -1, 0, 0};\n\nll fastPow(ll x, ll n)\n{\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return fastPow(x * x % MOD, n / 2);\n    else\n        return x * fastPow(x, n - 1) % MOD;\n}\n\nll fac[112346];\nvoid combInit(int mx)\n{\n    fac[0] = 0;\n    fac[1] = 1;\n    for (int i = 2; i <= mx; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n}\n\nll modDiv(ll a, ll b)\n{\n    return a * fastPow(b, MOD - 2) % MOD;\n}\n\nll comb(ll a, ll b)\n{\n    if (b == 0)\n        return 1;\n    if (a < b)\n        return 0;\n    if (a <= 0 || b < 0)\n        return 0;\n    if (a == b)\n        return 1;\n\n    ll p, c;\n\n    c = modDiv(fac[a], fac[a - b]);\n    p = fac[b];\n\n    ll res = modDiv(c, p);\n\n    return res;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    combInit(210);\n\n    int n, x[210], y[210];\n\n    ll li[210];\n    fill(li, li + n + 1, 0);\n\n    cin >> n;\n    REP(i, n)\n    cin >> x[i] >> y[i];\n\n    ll res = 0;\n\n    bool used[210][210];\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            used[i][j] = i == j;\n\n    V l;\n\n    for (int i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++)\n        {\n            if (used[i][j])\n                continue;\n\n            V v;\n\n            v.push_back(i);\n            v.push_back(j);\n\n            int cnt = 2;\n            for (int k = j + 1; k < n; k++)\n            {\n                int a = (x[j] - x[i]) * (y[k] - y[j]);\n                int b = (y[j] - y[i]) * (x[k] - x[j]);\n\n                if (a == b)\n                {\n                    cnt++;\n\n                    v.push_back(k);\n                }\n            }\n\n            if (cnt > 2)\n            {\n                for (int k = 0; k < v.size(); k++)\n                    for (int m = 0; m < v.size(); m++)\n                        used[v[k]][v[m]] = true;\n\n                l.push_back(cnt);\n            }\n        }\n\n    for (int i = 3; i <= n; i++)\n    {\n        ll tmp = 0;\n        tmp += comb(n, i);\n\n        for (int j : l)\n        {\n            if (i > j)\n                continue;\n            tmp += MOD - comb(j, i);\n            tmp %= MOD;\n        }\n\n        res += tmp;\n        res %= MOD;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nconst double eps = 1e-10;\nconst double inf = 1e+10;\nconst double pi = acos(-1.0);\nint sgn(double a) { return a < -eps ? -1 : a > eps; }\nusing P = complex<double>;\nnamespace std {\n  istream& operator>>(istream& i, P& p) { double x, y; i >> x >> y; p = P(x, y); return i; }\n  ostream& operator<<(ostream& o, const P& p) { o << real(p) << ' ' << imag(p); return o; }\n  bool operator<(const P& p, const P& q) { return sgn(real(p) - real(q)) ? sgn(real(p) - real(q)) < 0 : sgn(imag(p) - imag(q)) < 0; }\n  bool operator>(const P& p, const P& q) { return q < p; }\n  bool operator<=(const P& p, const P& q) { return !(p > q); }\n  bool operator>=(const P& p, const P& q) { return !(p < q); }\n}\nbool eq(const P& p, const P& q) { return !(p < q) and !(p > q); }\ndouble dot(const P& p, const P& q) { return real(conj(p) * q); }\ndouble cross(const P& p, const P& q) { return imag(conj(p) * q); }\n\nint ccw(P p0, P p1, P p2) {\n  p1 -= p0, p2 -= p0;                         //             (1)\n  if (sgn(cross(p1, p2)) > 0) return 1;       //\n  if (sgn(cross(p1, p2)) < 0) return -1;      // (-2)---p0---(0)---p1---(2)\n  if (sgn(dot(p1, p2) < 0)) return -2;        //\n  if (sgn(norm(p1) - norm(p2)) < 0) return 2; //             (-1)\n  return 0;\n}\n\nbool intLP(const P& p1, const P& p2, const P& p) {\n  return !(ccw(p1, p2, p) & 1);\n}\n\nconst lint mod = 998244353;\ninline lint emod(lint a, lint p = mod) { return (a % p + p) % p; }\ninline lint powm(lint a, lint n, lint p = mod) { return !n ? 1 : powm(a * a % p, n >> 1, p) * (n & 1 ? a : 1) % p; }\ninline lint invm(lint a, lint p = mod) { a %= p; return a == 1 ? 1 : -p / a * invm(p % a) % p; }\n\nV<lint> fact, ifact;\nvoid init_table(int n) {\n  fact.assign(n + 1, 1), ifact.assign(n + 1, 1);\n  for (int i = 2; i < n + 1; i++) fact[i] = i * fact[i - 1] % mod;\n  ifact[n] = invm(fact[n]);\n  for (int i = n; i > 2; i--) ifact[i - 1] = i * ifact[i] % mod;\n}\n\nlint comb(lint n, lint r) {\n  if (n < 0 or r < 0 or r > n) return 0;\n  return fact[n] * ifact[r] % mod * ifact[n - r] % mod;\n}\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  V<P> a(n); for (int i = 0; i < n; i++) cin >> a[i];\n  VV<> ls;\n  for (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) {\n    int c = 0;\n    for (int k = 0; k < n; k++) c += intLP(a[i], a[j], a[k]);\n    if (c >= 3) {\n      V<> l;\n      for (int k = 0; k < n; k++) if (intLP(a[i], a[j], a[k])) l.push_back(k);\n      ls.push_back(l);\n    }\n  }\n  sort(ls.begin(), ls.end()); ls.erase(unique(ls.begin(), ls.end()), ls.end());\n\n  init_table(n);\n  lint res = powm(2, n) - (1 + n + comb(n, 2));\n  for (auto&& l : ls) {\n    int m = l.size();\n    for (int i = 3; i < m + 1; i++) (res -= comb(m, i)) %= mod;\n  }\n  cout << emod(res) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y;\n\tdata(){}\n\tdata(int xx,int yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn atan2(y,x)<atan2(d.y,d.x);\n\t}\n};\n\nint n;\ndata d[205];\nll two[205];\nbool flag[205][205];\nll res=0;\n\nbool check(int f,int t,int vx,int vy){\n\tif(vx==0){\n\t\treturn d[f].x==d[t].x;\n\t}\n\tif(vy==0){\n\t\treturn d[f].y==d[t].y;\n\t}\n\tint sax=d[t].x-d[f].x;\n\tint say=d[t].y-d[f].y;\n\treturn (sax*vy-say*vx)==0;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\ttwo[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\ttwo[i]=two[i-1]*2LL%MOD;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&d[i].x,&d[i].y);\n\t}\n\tll res=two[n];\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(flag[i][j])continue;\n\t\t\tint vx=d[i].x-d[j].x;\n\t\t\tint vy=d[i].y-d[j].y;\n\t\t\tvector<int> vec;\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(check(j,k,vx,vy)){\n\t\t\t\t\tvec.push_back(k);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres-=two[cnt];\n\t\t\tres+=MOD;\n\t\t\tres%=MOD;\n\t\t\tres+=cnt+1;\n\t\t\tres%=MOD;\n\t\t\tfor(int k=0;k<vec.size();k++){\n\t\t\t\tfor(int l=0;l<vec.size();l++){\n\t\t\t\t\tflag[k][l]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres-=(ll)n+1LL;\n\tres+=MOD;\n\tres%=MOD;\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n#define mo 998244353\n\nint used[210][210];\nint x[210];\nint y[210];\nint pow2[210];\n\nint main()\n{\n  int i,j,k,n,ans,o,p,b1;\n  vector<int> q;\n  pow2[0]=1;\n  for (i=1;i<210;i++)\n  {\n    pow2[i]=pow2[i-1]+pow2[i-1];\n    pow2[i]%=mo;\n  }\n  scanf(\"%d\",&n);\n  for (i=0;i<n;i++)\n    scanf(\"%d%d\",&x[i],&y[i]);\n  ans=pow2[n];\n  ans--;\n  ans-=n;\n  ans+=mo;\n  ans%=mo;\n  memset(used,0,sizeof(used));\n  for (i=0;i<n;i++)\n    for (j=i+1;j<n;j++)\n      if (used[i][j]==0)\n      {\n        q.clear();\n        q.push_back(i);\n        q.push_back(j);\n        for (k=j+1;k<n;k++)\n        {\n          b1=0;\n          if ((x[i]==x[j])&&(x[k]==x[i])) b1=1;\n          else if ((y[i]==y[j])&&(y[k]==y[i])) b1=1;\n          else\n          {\n            if ((y[j]-y[i])*(x[k]-x[i])==(y[k]-y[i])*(x[j]-x[i])) b1=1;\n          }\n          if (b1==1) q.push_back(k);\n        }\n        ans-=pow2[q.size()];\n        ans+=q.size();\n        ans++;\n        ans%=mo;\n        ans+=mo;\n        ans%=mo;\n        for (o=0;o<q.size();o++)\n          for (p=o+1;p<q.size();p++)\n            used[q[o]][q[p]]=1;\n      }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mo=998244353;\nconst double pi=acos(-1),eps=1e-10;\nint n,x[205],y[205],s[205],ans;\ndouble a[205]; \n\nint qpow(int a,int b)\n{\n\tint x=a;  a=1;\n\twhile (b)\n\t\t{\n\t\t\tif (b&1)  a=1LL*a*x%mo;\n\t\t\tx=1LL*x*x%mo,b>>=1;\n\t\t}\n\treturn a;\n}\n\nint f(int x){return (qpow(2,x)+mo-(1+x+1LL*x*(x-1)/2)%mo)%mo;}\nint dcmp(double x){return (x>eps)-(x<-eps);}\n\nvoid work()\n{\n\tscanf(\"%d\",&n),ans=f(n);\n\tfor (int i=1; i<=n; i++)  scanf(\"%d %d\",&x[i],&y[i]);\n\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1,k=0; j<=n; j++)\n\t\t\t\tif (i!=j)  a[++k]=atan2(y[i]-y[j],x[i]-x[j]);\n\t\t\tfor (int j=1; j<n; j++)  a[j]+=pi*(a[j]<=0);\n\t\t\tsort(a+1,a+n);\n\t\t\tfor (int l,r=1; r<n; )\n\t\t\t\t{\n\t\t\t\t\tl=r;\n\t\t\t\t\twhile ((r<n)&&(a[r]==a[l]))  r++;\n\t\t\t\t\ts[r-l+1]++;\n\t\t\t\t}\n\t\t}\n\tfor (int i=1; i<=n; i++)  ans=(ans+mo-1LL*s[i]/i*f(i)%mo)%mo;\n\tprintf(\"%d\",ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T>\nT gcd(T x,T y)\n{\n\twhile(y)swap(x%=y,y);\n\treturn x;\n}\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n\nconst int N=200+5,U=2e4+5,D=998244353;\nint mi_2[N];\nstruct point\n{\n\tint x,y;\n};\npoint operator -(const point &a)\n{\n\treturn (point){-a.x,-a.y};\n}\npoint operator -(const point &a,const point &b)\n{\n\treturn (point){a.x-b.x,a.y-b.y};\n}\npoint operator /(const point &a,int k)\n{\n\treturn (point){a.x/k,a.y/k};\n}\npoint standard(point p)\n{\n\tif(p.x==0)return (point){0,1};\n\tif(p.x<0)p=-p;\n\treturn p/gcd(p.x,abs(p.y));\n}\nint dy(const point &p)\n{\n\treturn p.x*U+p.y;\n}\npoint p[N];\nint F2(int n)\n{\n\treturn mi_2[n]-1-n;\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\trep(i,1,n)cin>>p[i].x>>p[i].y;\n\tmi_2[0]=1;\n\trep(i,1,n)mi_2[i]=mi_2[i-1]*2%D;\n\tll ans=mi_2[n]-1-n-n*(n-1)/2;\n\trep(i,1,n)\n\t{\n\t\tunordered_map<int,int>mp;\n\t\trep(j,i+1,n)++mp[dy(standard(p[j]-p[i]))];\n\t\tfor(auto pr:mp)ans-=F2(pr.second);\n\t}\n\tcout<<(ans%D+D)%D<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nconst int mod=998244353;\nint n,x[205],y[205],tw[205]; \nint main()\n{\n\tcin>>n;tw[0]=1;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>x[i]>>y[i];\n\tfor(int i=1;i<=n;i++)\n\t\ttw[i]=tw[i-1]*2%mod;\n\tint ans=(tw[n]-n-1+mod)%mod; \n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<j;k++)\n\t\t\t\tif((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))\n\t\t\t\t\tcnt++;\n\t\t\tans=(ans-tw[cnt]+mod)%mod;\n\t\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iostream>\n#include <ios>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[202];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) < norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[201][201] = {0};\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//A,Elebereth Gilthoniel mantae!\n//For Temeria!\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<cstdio>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cstring> \nusing namespace std;\nvector<long long> siz;long long vis[205][205];long long mod=998244353;\nlong long quipow(long long a,long long b)\n{\n    long long ans=1;\n     while(b)\n     {\n         if(b&1) ans=ans*a%mod;\n         b>>=1;\n         a=a*a%mod;\n     }\n     return ans%mod;\n}\nlong long fac[505],inv[505];\nvoid prepare()    \n{\n    fac[0]=fac[1]=1;\n    for(long long i=2;i<=500;i++)   fac[i]=fac[i-1]*i%mod;\n\n    inv[500]=quipow(fac[500],mod-2);\n    for(long long i=500-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\npair<double,double> p[505];\nint main()\n{\n \t//freopen(\"\",\"r\",stdin);\n\t//freopen(\"\",\"w\",stdout);\n\tprepare();\n\tlong long n;cin>>n;\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tcin>>p[i].first>>p[i].second;\n\t}\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tfor(long long j=0;j<n;j++)\n\t\t{\n\t\t\tvector<int> v;v.clear();\n\t\t\tif(i==j or(vis[i][j]==1)) continue;v.push_back(i);v.push_back(j);\n\t\t\tif(p[i].first==p[j].first)\n\t\t\t{\n\t\t\t\tlong long u=0;u++;u++;\n\t\t\t\tfor(long long t=0;t<n;t++)\n\t\t\t\t{\n\t\t\t\t\tif(i==t or j==t) continue;\n\t\t\t\t\tif(p[t].first==p[i].first)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.push_back(t);\n\t\t\t\t\t\tu++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u>2)siz.push_back(u);\n\t\t\t\tfor(int t=0;t<v.size();t++) for(int y=0;y<v.size();y++) vis[v[y]][v[t]]=1; \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble k=(p[i].second-p[j].second)/(p[i].first-p[j].first);\n\t\t\tdouble b=p[i].second-p[i].first*k;\n\t\t\tlong long u=0;u++;u++;\n\t\t\tfor(long long t=0;t<n;t++)\n\t\t\t{\n\t\t\t\tif(i==t or j==t) continue;\n\t\t\t\tif(p[t].first*k+b==p[t].second)\n\t\t\t\t{\n\t\t\t\t\tv.push_back(t);\n\t\t\t\t\tu++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(u>2)siz.push_back(u);\n\t\t\tfor(int t=0;t<v.size();t++) for(int y=0;y<v.size();y++) vis[v[y]][v[t]]=1; \n\t\t}\n\t}\n\tlong long ans=0;long long y=n*(n-1);\n\tfor(long long i=3;i<=n;i++)\n\t{\n\t\ty=y*(n-i+1);y=y%mod;\n\t\tans+=y*inv[i];ans=ans%mod;\n\t}\n\tfor(long long i=0;i<siz.size();i++)\n\t{\n\t\ty=(siz[i])*(siz[i]-1);\n\t\tfor(long long j=3;j<=siz[i];j++)\n\t\t{\n\t\t\ty=y*(siz[i]-j+1);y=y%mod;\n\t\t\tans-=y*inv[j];ans=ans%mod;\n\t\t}\n\t}\n\tif(ans<0) ans+=mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 210\n#define ll long long\n#define mod 998244353\nusing namespace std;\n\nstruct data{int x, y;}b[N];\nstruct line{data a, b;}a[20010];\nint n, l, ans;\n\ninline data operator-(data a, data b){data x; x.x=a.x-b.x; x.y=a.y-b.y; return x;}\ninline int operator*(data a, data b){return a.x*b.y-a.y*b.x;}\n\ninline bool cmp(line A, line B){\n\tint x1=(A.b.y-A.a.y)*(B.b.x-B.a.x), x2=(B.b.y-B.a.y)*(A.b.x-A.a.x);\n\tif(x1!=x2)return x1<x2;\n\treturn (A.a-B.a)*(A.b-B.a)<0;\n}\n\ninline int in(line A, data P){return (A.a-P)*(A.b-P)==0?1:0;}\n\ninline void solve(line A){\n\tint sum=0, s;\n\tfor(int i=1; i<=n; i++)if(in(A, b[i]))sum++;\n\ts=1; for(int i=1; i<=sum; i++)s=s*2%mod;\n\ts=(s-1-sum-sum*(sum-1)/2+mod)%mod;\n\tans=(ans-s+mod)%mod;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<=n; i++)scanf(\"%d%d\", &b[i].x, &b[i].y);\n\tl=0;\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=i+1; j<=n; j++){\n\t\t\tl++; a[l].a=b[i]; a[l].b=b[j];\n\t\t}\n\tfor(int i=1; i<=l; i++){\n\t\tif(a[i].a.x==a[i].b.x&&a[i].a.y>a[i].b.y)swap(a[i].a, a[i].b);\n\t\tif(a[i].a.x>a[i].b.x)swap(a[i].a, a[i].b);\n\t}\n\tsort(a+1, a+1+l, cmp);\n\tans=1; for(int i=1; i<=n; i++)ans=ans*2%mod;\n\tans=(ans-1-n-n*(n-1)/2+mod)%mod;\n\tsolve(a[1]);\n\tfor(int i=2; i<=l; i++)if(!in(a[i-1], a[i].a)||!in(a[i-1], a[i].b))solve(a[i]);\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef pair<pi,pi> ppi;\n\nconst int N=205,P=998244353;\n\nmap<ppi,int>D;\nint n,x[N],y[N],p2[N],m;\n\ninline int gcd(int x,int y){return y?gcd(y,x%y):x;}\ninline pi mk(pi x){\n\tll g=gcd(x.fi,x.se);\n\tif(g)x.fi/=g,x.se/=g;\n\tif(x.fi<0)x.fi=-x.fi,x.se=-x.se;\n\treturn x;\n}\ninline ppi mp(ll u1,ll v1,ll u2,ll v2){\n\tpi l=mk({u2-u1,v2-v1});\n\tpi s=mk({v1*l.fi-u1*l.se,l.fi});\n\treturn {l,s};\n}\nint get(int s){\n\ts*=2;\n\tint v=sqrt(1+4*s+0.5);\n\treturn (1+v)/2;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tp2[0]=1;\n\tfor(int i=1;i<=n;i++)p2[i]=(p2[i-1]<<1)%P,scanf(\"%d%d\",&x[i],&y[i]);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<i;j++)D[mp(x[i],y[i],x[j],y[j])]++;\n\tm=p2[n];\n\tfor(auto&i:D){int t=get(i.se);m=(m-p2[t]+t+1+P)%P;}\n\tm=(m-n-1+P)%P;\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Written by Filip Hlasek 2017 */\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <iostream>\n\n#define FOR(i, a, b)   for (int i = (a); i <= (b); i++)\n#define FORD(i, a, b)  for (int i = (a); i >= (b); i--)\n#define REP(i, b)      for (int i =  0 ; i <  (b); i++)\n\nusing namespace std;\n\n#define MOD 998244353\n#define MAXN 333\nint pow2[MAXN];\nint f[MAXN];\n\nint X[MAXN], Y[MAXN];\n\nbool done[MAXN][MAXN];\n\nint main(int argc, char *argv[]) {\n  pow2[0] = 1;\n  REP(i, MAXN - 1) pow2[i + 1] = (pow2[i] * 2) % MOD;\n  REP(i, MAXN) f[i] = (pow2[i] - (long long)i * (i - 1) / 2 - i - 1) % MOD;\n  // REP(i, 10) printf(\"%d\\n\", f[i]);\n  int N;\n  scanf(\"%d\", &N);\n  REP(i, N) scanf(\"%d%d\", X + i, Y + i);\n\n  int ans = f[N];\n\n  REP(i, N) REP(j, i) if (!done[i][j]) {\n    vector<int> line;\n    line.push_back(i);\n    line.push_back(j);\n    FOR(k, i + 1, N - 1) {\n      int x1 = X[k] - X[i], x2 = X[k] - X[j], y1 = Y[k] - Y[i], y2 = Y[k] - Y[j];\n      if (x1 * y2 == y1 * x2) {\n        line.push_back(k);\n      }\n    }\n    REP(a, line.size()) REP(b, line.size()) done[line[a]][line[b]] = true;\n    ans = (ans - f[line.size()] + MOD) % MOD;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 100010\ntypedef long long LL;\nconst LL mod = 998244353;\nLL x[maxn], y[maxn], P[maxn];\nint main()\n{\n    LL n;\n    scanf(\"%lld\", &n);\n    for (int i = 0; i < n; ++i)\n        scanf(\"%lld%lld\", &x[i], &y[i]);\n    P[0] = 1;\n    for (int i = 1; i <= n; ++i)\n        (P[i] = P[i-1] << 1) %= mod;\n    LL ans = P[n] - 1 - n - n*(n-1)/2;\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = i+1; j < n; ++j)\n        {\n            int cnt = 0;\n            for (int k = j+1; k < n; ++k)\n            {\n                if ((x[j]-x[i]) * (y[k]-y[j]) == (x[k]-x[j]) * (y[j]-y[i]))\n                    ++cnt;\n            }\n            ((ans -= P[cnt]-1) += mod) %= mod;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst ll mod = 998244353;\nconst double EPS = 1e-14, PI = acos(-1.0);\n\nint main() {\n    int n;\n    cin >> n;\n    vector<double> x(n), y(n);\n    REP(i,n) cin >> x[i] >> y[i];\n\n    VL two(n+1);\n    two[0] = 1;\n    REP(i,n) two[i+1] = (two[i] * 2) % mod;\n\n    ll ans = (two[n] + mod - 1 - n) % mod;\n\n    VL c(n+1);\n\n    REP(i,n) REP(j,n) {\n        if (i == j) continue;\n        double theta = atan2(y[j] - y[i], x[j] - x[i]);\n        int p = 2;\n        REP(k,n){\n            if (k == i || k == j) continue;\n            double phi = atan2(y[k] - y[i], x[k] - x[i]);\n            phi = fabs(phi - theta);\n            if (fabs(phi) < EPS || fabs(phi - PI) < EPS) p++;\n        }\n        c[p]++;\n    }\n\n    FOR(x,2,n){\n        c[x] /= x * (x-1);\n        // cout << c[x] << endl;\n        ll tmp = (c[x] * (two[x] + mod - x - 1)) % mod;\n        ans = (ans - tmp + mod) % mod;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n#define rep(i, l, r) for (int i = l; i<r;i++)\n#define print(arr, r, c) rep(i, 0, r) {rep(j, 0, c)cout<<arr[i][j]<<\"\";cout<<endl;}\n#define all(b) b.begin() , b.end()\n#define mp(a, b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define vi vector<int>\n#define vd vector<double>\n#define vs vector<string>\n#define vii vector<pair<int,int>>\n#define vvi vector<vector<int>>\n#define ii pair<int,int>\n#define turnOff(k, i) (k&(~(1<<(i-1))))\n#define isOn(k, i) (k&&(1<<i-1)?true:false)\n#define pll pair<long long int , long long int>\n#define ull unsigned long long int\n#define ll  long long int\n#define add(a, b) (((a)+(b))%MOD)\n#define sub(a, b) (((a)-(b)+MOD)%MOD)\n#define mul(a, b) ((1ll*(a)*(b))%MOD)\n#ifdef  DEBUG\n#define MAXN 5203\n#else\n#define MAXN 300007\n#endif\n#define MAXLG 20\n#define endl '\\n'\n#define PI 3.141592653589793238\n#define MOD (998244353)\n#define INF (2000000000)\n#define EPS (0.00000001)\n#define treap treapNode\nlong mod_pow(long x, int y)\n{\n    // exponentiation by squaring\n    long r = 1;\n    while (y > 0) {\n        if (y % 2 == 1) {\n            r = (r*x) % MOD;\n        }\n        x = (x*x) % MOD;\n        y /= 2;\n    }\n    return r;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n#ifdef DEBUG\n    freopen(\"input\", \"r\", stdin);\n#endif\n    int n;\n    cin>>n;\n    ii p[n];\n    rep (i,0,n)\n        cin>>p[i].first>>p[i].second;\n\n    ll ans = sub(mod_pow(2,n),1+n);\n\n\n    rep (i,0,n) {\n        map<ii,int> sl;\n        rep (j, i+1, n) {\n            int m1 = (p[i].first-p[j].first);\n            int m2 = (p[i].second-p[j].second);\n            int gcd = __gcd(abs(m1),abs(m2));\n            ii slope;\n            slope.first = abs(m1)/gcd;\n            slope.second = abs(m2)/gcd;\n\n            if (m1*m2 <0) {\n              slope.first *=-1;\n            }\n            if (sl.count(slope)==0) {\n                sl[slope]=0;\n            }\n            sl[slope] =  sl[slope] + 1;\n\n        }\n\n\n        for (pair<ii,int> val : sl) {\n            int k = val.second;\n            ans =  (MOD + ans - sub(mod_pow(2,k),1))%MOD;\n        }\n    }\n\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define repr(i,b,e) for(int i = (b); i <= (e); i++)\n#define INF (1001001001)\n#define EPS (1e-15)\n\n#define pr(x) do{cerr << (#x) << \" = \" << (x) << endl;}while(0)\n#define pri(x,i) do{cerr << (#x) << \"[\" << i << \"] = \" << (x[i]) << endl;}while(0)\n#define pra(x,n) rep(__i,n) pri(x,__i);\n#define prar(x,b,e) repr(__i,b,e) pri(x,__i);\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n\nll MOD = 998244353;\n\nint in() {\n\tint a;\n\tscanf(\"%d \", &a);\n\treturn a;\n}\n\nint main() {\n\tint N = in();\n\ttypedef complex<double> P;\n\tvector<P> a(N);\n\trep(i,N) {\n\t\tint x = in();\n\t\tint y = in();\n\t\ta[i] = P(x, y);\n\t}\n\t\n\tvector<ll> twop(220);\n\ttwop[0] = 1;\n\trepr(i,1,210)twop[i] = twop[i-1] * 2 % MOD;\n\t\n\tvector<ll> hoge(220);\n\trep(i,210) {\n\t\tif (i < 3) hoge[i] = 0;\n\t\telse hoge[i] = (twop[i] - 1 - i - i * (i - 1) / 2 + MOD) % MOD;\n\t}\n\t\n\tvint cnt(N+10);\n\trep(p,N) {\n\t\tvint found(N);\n\t\trepr(q,p+1,N-1) {\n\t\t\tP l = a[q] - a[p];\n\t\t\tint temp = 2;\n\t\t\trepr(r,q+1,N-1) {\n\t\t\t\tif (found[r]) continue;\n\t\t\t\tP m = a[r] - a[p];\n\t\t\t\tif (l.imag() * m.real() == l.real() * m.imag()) {\n\t\t\t\t\ttemp++;\n\t\t\t\t\tfound[r] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (temp >= 3) {\n\t\t\t\tcnt[temp]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 3; i < 201; i++) pri(cnt, i);\n\tfor (int i = 200; i >= 3; i--) {\n\t\tfor (int k = i - 1; k >= 3; k--) {\n\t\t\tcnt[k] -= cnt[i];\n\t\t}\n\t}\n\tfor (int i = 3; i < 201; i++) pri(cnt, i);\n\t\n\tll ans = hoge[N];\n\tfor (int i = N; i >= 3; i--) {\n\t\tans = (ans - cnt[i] * hoge[i]);\n\t\twhile (ans < 0) ans += MOD;\n\t}\n\t\n\tif (N <= 2) ans = 0;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst long double EPS = 1e-9;\n\nstruct Line {\n\tlong double x, y;\n};\nbool operator< (const Line &a1, const Line &a2) {\n\tif (fabs(a1.x - a2.x) > EPS && a1.x < a2.x) return true; if (fabs(a1.x - a2.x) > EPS && a1.x > a2.x) return false;\n\tif (fabs(a1.y - a2.y) > EPS && a1.y < a2.y) return true; if (fabs(a1.y - a2.y) > EPS && a1.y > a2.y) return false;\n\treturn false;\n}\nbool operator== (const Line &a1, const Line &a2) {\n\tif (fabs(a1.x - a2.x) < EPS && fabs(a1.y - a2.y) < EPS) return true;\n\treturn false;\n}\n\nlong long n, x[209], y[209], power[209], mod = 998244353; vector<Line> vec;\n\nlong long calc(long long n) {\n\treturn (power[n] - (n*(n - 1) / 2) - n - 1 + mod) % mod;\n}\n\nint main() {\n\tcin >> n;\n\tpower[0] = 1; for (int i = 1; i <= 208; i++) power[i] = (power[i - 1] * 2) % mod;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint X = (x[j] - x[i]), Y = (y[j] - y[i]); if (X < 0) { X *= -1; Y *= -1; }\n\t\t\tif (X == 0) { vec.push_back(Line{ 1.0L*x[j], 100000.0L }); }\n\t\t\telse {\n\t\t\t\tlong double D = 1.0L*Y / X;\n\t\t\t\tlong double E = 1.0L*y[i] - D*x[i];\n\t\t\t\tvec.push_back(Line{ E,D });\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\tint cx = 0; long long U = 0;\n\twhile (cx < vec.size()) {\n\t\tint pos1 = upper_bound(vec.begin(), vec.end(), vec[cx]) - vec.begin();\n\t\tint V = pos1 - cx, VV = 0;\n\t\tfor (int i = 2; i <= 200; i++) {\n\t\t\tif (V == i*(i - 1) / 2)VV = i;\n\t\t}\n\t\tU += calc(VV); U += mod; U %= mod;\n\t\tcx = pos1;\n\t}\n\tlong long ans = calc(n);\n\tans = (ans - U + mod) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LLI long long int\n#define FOR(v, a, b) for(LLI v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(LLI v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(LLI v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define fst first\n#define snd second\n#define popcount __builtin_popcount\n#define UNIQ(v) (v).erase(unique(ALL(v)), (v).end())\n#define bit(i) (1LL<<(i))\n\n#ifdef DEBUG\n#include <misc/C++/Debug.cpp>\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> bool chmin(T &a, const U &b){return (a>b ? a=b, true : false);}\ntemplate <typename T, typename U> bool chmax(T &a, const U &b){return (a<b ? a=b, true : false);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\nstruct Init{\n  Init(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n    cerr << fixed << setprecision(12);\n  }\n}init;\n\n\n\ntemplate <std::uint32_t M> class ModInt{\npublic:\n  std::uint64_t val;\n  ModInt(): val(0){}\n  ModInt(std::int64_t n){\n    if(n >= M) val = n % M;\n    else if(n < 0) val = n % M + M;\n    else val = n;\n  }\n  \n  inline constexpr ModInt operator+(const ModInt &a) const {return ModInt((val+a.val) % M);}\n  inline constexpr ModInt operator-(const ModInt &a) const {return ModInt((val-a.val+M) % M);}\n  inline constexpr ModInt operator*(const ModInt &a) const {return ModInt((val*a.val) % M);}\n  inline constexpr ModInt operator/(const ModInt &a) const {return ModInt((val*a.inv().val) % M);}\n  \n  inline constexpr ModInt& operator=(const ModInt &a){val = a.val; return *this;}\n  inline constexpr ModInt& operator+=(const ModInt &a){if((val += a.val) >= M) val -= M; return *this;}\n  inline constexpr ModInt& operator-=(const ModInt &a){if(val < a.val) val += M; val -= a.val; return *this;}\n  inline constexpr ModInt& operator*=(const ModInt &a){(val *= a.val) %= M; return *this;}\n  inline constexpr ModInt& operator/=(const ModInt &a){(val *= a.inv().val) %= M; return *this;}\n\n  inline constexpr bool operator==(const ModInt &a) const {return val == a.val;}\n  inline constexpr bool operator!=(const ModInt &a) const {return val != a.val;}\n\n  inline constexpr ModInt& operator++(){*this += 1; return *this;}\n  inline constexpr ModInt& operator--(){*this -= 1; return *this;}\n\n  inline constexpr ModInt operator++(int){ModInt t = *this; *this += 1; return t;}\n  inline constexpr ModInt operator--(int){ModInt t = *this; *this -= 1; return t;}\n\n  inline constexpr static ModInt frac(std::int64_t a, std::int64_t b){\n    return ModInt(a) / ModInt(b);\n  }\n  \n  inline constexpr static ModInt power(std::int64_t n, std::int64_t p){\n    if(p < 0) return power(n, -p).inv();\n    \n    ModInt ret = 1, e = n;\n    for(; p; e *= e, p >>= 1) if(p&1) ret *= e;\n    return ret;\n  }\n\n  inline constexpr ModInt power(std::int64_t p) const {return power(val,p);}\n  \n  inline constexpr ModInt inv() const {\n    std::int64_t a = val, b = M, u = 1, v = 0;\n    \n    while(b){\n      std::int64_t t = a/b;\n      a -= t*b; std::swap(a,b);\n      u -= t*v; std::swap(u,v);\n    }\n    u %= M;\n    if(u < 0) u += M;\n    \n    return u;\n  }\n};\n\ntemplate <std::uint32_t M> ModInt<M> operator-(const ModInt<M> &a){return M-a.val;}\n\ntemplate <std::uint32_t M> ModInt<M> operator+(std::int64_t a, const ModInt<M> &b){return ModInt<M>(ModInt<M>(a)+b.val);}\ntemplate <std::uint32_t M> ModInt<M> operator-(std::int64_t a, const ModInt<M> &b){return ModInt<M>(ModInt<M>(a)-b.val);}\ntemplate <std::uint32_t M> ModInt<M> operator*(std::int64_t a, const ModInt<M> &b){return ModInt<M>(ModInt<M>(a)*b.val);}\ntemplate <std::uint32_t M> ModInt<M> operator/(std::int64_t a, const ModInt<M> &b){return ModInt<M>(ModInt<M>(a)/b.val);}\n\ntemplate <std::uint32_t M> std::istream& operator>>(std::istream &is, ModInt<M> &a){is >> a.val; return is;}\ntemplate <std::uint32_t M> std::ostream& operator<<(std::ostream &os, const ModInt<M> &a){ os << a.val; return os;}\n\n\n\nconstexpr double eps = 1e-7;\n\ntemplate <typename T, typename U> bool EQ(const T &a, const U &b){return std::fabs(a-b) < eps;}\ntemplate <typename T, typename U> bool NE(const T &a, const U &b){return not EQ(a,b);}\ntemplate <typename T, typename U> bool LT(const T &a, const U &b){return a-b < -eps;}\ntemplate <typename T, typename U> bool LE(const T &a, const U &b){return a-b < eps;}\ntemplate <typename T, typename U> bool GT(const T &a, const U &b){return not LE(a,b);}\ntemplate <typename T, typename U> bool GE(const T &a, const U &b){return not LT(a,b);}\n\ntemplate <typename T> struct Point{\n  T x, y;\n  Point(): x(0), y(0){}\n  Point(const T &x, const T &y): x(x), y(y){}\n  T size() const {return sqrt(x*x+y*y);}\n  T size_sq() const {return x*x+y*y;}\n  \n  static Point<T> polar(const T &r, const T &ang){return Point(r * cos(ang), r * sin(ang));}\n};\n\ntemplate <typename T> Point<T> operator+(const Point<T> &a, const Point<T> &b){return Point<T>(a.x+b.x, a.y+b.y);}\ntemplate <typename T> Point<T> operator-(const Point<T> &a, const Point<T> &b){return Point<T>(a.x-b.x, a.y-b.y);}\ntemplate <typename T> Point<T> operator-(const Point<T> &a){return Point<T>(-a.x, -a.y);}\ntemplate <typename T, typename U> Point<T> operator*(const Point<T> &a, const U &k){return Point<T>(a.x*k, a.y*k);}\ntemplate <typename T, typename U> Point<T> operator*(const U &k, const Point<T> &a){return Point<T>(a.x*k, a.y*k);}\ntemplate <typename T, typename U> Point<T> operator/(const Point<T> &a, const U &k){return Point<T>(a.x/k, a.y/k);}\ntemplate <typename T> bool operator==(const Point<T> &a, const Point<T> &b){return EQ(a.x,b.x) and EQ(a.y,b.y);}\ntemplate <typename T> bool operator!=(const Point<T> &a, const Point<T> &b){return !(a==b);}\ntemplate <typename T> bool operator<(const Point<T> &a, const Point<T> &b){return LT(a.x,b.x) or (EQ(a.x,b.x) and LT(a.y,b.y));}\ntemplate <typename T> std::istream& operator>>(std::istream &is, Point<T> &a){is >> a.x >> a.y; return is;}\ntemplate <typename T> std::ostream& operator<<(std::ostream &os, const Point<T> &a){os << \"(\" << a.x << \",\" << a.y << \")\"; return os;}\ntemplate <typename T> T dot(const Point<T> &a, const Point<T> &b){return a.x*b.x+a.y*b.y;}\ntemplate <typename T> T cross(const Point<T> &a, const Point<T> &b){return a.x*b.y-a.y*b.x;}\ntemplate <typename T> T angle(const Point<T> &a, const Point<T> &b){return atan2(b.y-a.y, b.x-a.x);} // 点aから点bへの角度\ntemplate <typename T> Point<T> unit(const Point<T> &a){return a / a.size();} // 単位ベクトル\ntemplate <typename T> Point<T> normal(const Point<T> &p){return Point<T>(-p.y,p.x);}\ntemplate <typename T> T phase(const Point<T> &a){return std::atan2(a.y, a.x);}\n\ntemplate <typename T>\nT angle_diff(const Point<T> &a, const Point<T> &b){\n  T r = phase(b) - phase(a);\n\n  if(r < -M_PI) return r + 2 * M_PI;\n  else if(r > M_PI) return r - 2 * M_PI;\n  return r;\n}\n\ntemplate <typename T> struct Line{\n  Point<T> from, to;\n  Line(): from(), to(){}\n  Line(const Point<T> &from, const Point<T> &to): from(from), to(to){}\n  Point<T> diff() const {return to-from;}\n  T size() const {return diff().size();}\n};\n\ntemplate <typename T> using Segment = Line<T>;\ntemplate <typename T> using Polygon = std::vector<Point<T>>;\n\ntemplate <typename T> struct Circle{\n  Point<T> center;\n  T radius;\n  Circle(): center(), radius(0){}\n  Circle(const Point<T> &center, T radius): center(center), radius(radius){}\n};\n\n\nnamespace ccw{\n  enum CCW{\n           ONLINE_BACK       = -2,\n           COUNTER_CLOCKWISE = -1,\n           ON_SEGMENT        = 0,\n           CLOCKWISE         = 1,\n           ONLINE_FRONT      = 2\n  };\n\n  template <typename T>\n  CCW ccw(const Point<T> &p0, const Point<T> &p1, const Point<T> &p2){\n    const T cr = cross(p1-p0, p2-p0);\n    const T d = dot(p1-p0, p2-p0);\n\n    if(EQ(cr,0)){\n      if(LT(d,0)) return ONLINE_BACK;\n      else if(GT((p2-p0).size(),(p1-p0).size())) return ONLINE_FRONT;\n      else return ON_SEGMENT;\n    }else if(GT(cr,0)){\n      return COUNTER_CLOCKWISE;\n    }else{\n      return CLOCKWISE;\n    }\n  }\n}\n\nusing mint = ModInt<998244353>;\n\n\nint main(){\n  int N;\n  while(cin >> N){\n    vector<Point<double>> p(N); cin >> p;\n\n    mint ans = mint::power(2, N);\n\n    ans -= N + 1;\n\n    REP(i,N){\n      FOR(j,i+1,N){\n        const auto &a = p[i], &b = p[j];\n\n        int s = 0;\n        \n        for(auto c : p){\n          if(c == a or c == b) continue;\n          if(ccw::ccw(a, b, c) == ccw::ON_SEGMENT) ++s;\n        }\n\n        ans -= mint::power(2, s);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ld = long double;\nconst int maxn = 303, mod = 119<<23|1;\nint n, pw[maxn];\nvector<array<int, 2>> v;\nbool onl(array<int, 2> a, array<int, 2> b, array<int, 2> c) {\n\tif(a[1] == b[1] || b[1] == c[1]) return a[1] == b[1] && b[1] == c[1];\n\tld r1 = ld(a[0]-b[0])/ld(a[1]-b[1]);\n\tld r2 = ld(c[0]-b[0])/ld(c[1]-b[1]);\n\tld r3 = ld(a[0]-c[0])/ld(a[1]-c[1]);\n\treturn fabs(r1-r2) < 1e-7 && fabs(r3-r2) < 1e-7;\n}\nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tpw[0] = 1;\n\tfor(int i = 1; i < maxn; i++) pw[i] = (pw[i-1]+pw[i-1])%mod;\n\tcin >> n;\n\tv.resize(n);\n\tfor(auto &i : v) cin >> i[0] >> i[1];\n\tsort(all(v));\n\tint ans = pw[n];\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tint c = 0;\n\t\t\tarray<int, 2> mn = v[j];\n\t\t\tarray<int, 2> mx = v[i];\n\t\t\tfor(auto &[x, y] : v) if(v[i] == array<int, 2>{x, y} || v[j] == array<int, 2>{x, y} || onl(v[i], v[j], {x, y})) {\n\t\t\t\tc++;\n\t\t\t\tmn = min(mn, {x, y});\n\t\t\t\tmx = max(mx, {x, y});\n\t\t\t}\n\t\t\tif(v[j] != mn || v[i] != mx) continue;\n\t\t\t//cout << v[i][0] << \" \" << v[i][1] << \" | \" << v[j][0] << \" \" << v[j][1] << \" | \" << pw[c] - c - 1 << endl;\n\t\t\tans = (mod + ans - (pw[c] - c - 1))%mod;\t\n\t\t}\n\tans = (mod + ans - n - 1)%mod;\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cfloat>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\n\n#define EPS 1e-12\n#define ull unsigned long long\n#define ll long long\n#define VI vector<ll>\n#define PII pair<ll, ll> \n#define VVI vector<vector<ll> >\n#define REP(i,n) for(int i=0,_n=(n);(i)<(int)_n;++i)\n#define RANGE(i,a,b) for(int i=(int)a,_b=(int)(b);(i)<_b;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define ALLR(c) (c).rbegin(), (c).rend()\n#define PB push_back\n#define MP(a, b) make_pair(a, b)\n#define POPCOUNT __builtin_popcount\n#define POPCOUNTLL __builtin_popcountll\n#define CLEAR(table, v) memset(table, v, sizeof(table));\n#define PRINT1(table, D0) REP(d0, D0) cout<<table[d0]<<\" \"; cout<<\"\\n\";\n#define PRINT2(table, D0, D1) REP(d0, D0) { REP(d1, D1) cout<<table[d0][d1]<<\" \"; cout<<\"\\n\"; }\n#define PRINT3(table, D0, D1, D2) REP(d0, D0) { REP(d1, D1) { REP(d2, D2) cout<<table[d0][d1][d2]<<\" \"; cout<<\"\\n\"; } cout<<\"\\n\"; }\n#define UNIFORM_DOUBLE(a, b) (((b-a)*(double)rand()/RAND_MAX)+a) // [a, b) \n#define UNIFORM_LL(a, b) (ll)UNIFORM_DOUBLE(a, b) // [a, b) \n#define IN(v, lo, hi) ((lo)<=(v) && (v)<(hi))\n#define DD(v) cout<<#v<<\": \"<<v<<endl\ntemplate <typename T0, typename T1> std::ostream& operator<<(std::ostream& os, const map<T0, T1>& v) { for( typename map<T0, T1>::const_iterator p = v.begin(); p!=v.end(); p++ ){os << p->first << \": \" << p->second << \" \";} return os; }\ntemplate <typename T0, typename T1> std::ostream& operator<<(std::ostream& os, const pair<T0, T1>& v) { os << v.first << \": \" << v.second << \" \"; return os; }\ntemplate <typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& v) { for( int i = 0; i < (int)v.size(); i++ ) { os << v[i] << \" \"; } return os; }\ntemplate <typename T> std::ostream& operator<<(std::ostream& os, const vector<vector<T> >& v) { for( int i = 0; i < (int)v.size(); i++ ) { os << v[i] << endl; } return os; }\ntemplate <typename T> std::ostream& operator<<(std::ostream& os, const set<T>& v) { vector<T> tmp(v.begin(), v.end()); os << tmp; return os; }\ntemplate <typename T> std::ostream& operator<<(std::ostream& os, const deque<T>& v) { vector<T> tmp(v.begin(), v.end()); os << tmp; return os; }\n\nstruct modll {\n\tstatic const ll MODVAL;\n\tll val;\n\tmodll() : val(0) {}\n\tmodll(ll v) : val(v) { normalize(); }\n\tvoid normalize() { val = (val+MODVAL) % MODVAL; }\n\tmodll  operator+ (ll v) { return modll(val+v); }\n\tmodll& operator+=(ll v) { val+=v; normalize(); return *this; }\n\tmodll  operator- (ll v) { return modll(val-v); }\n\tmodll& operator-=(ll v) { val-=v; normalize(); return *this; }\n\tmodll  operator* (ll v) { return modll(val*v); }\n\tmodll& operator*=(ll v) { val*=v; normalize(); return *this; }\n\tmodll  operator^ (ll e) { modll x(val); modll v(1); for(;e;x=x*x,e>>=1) if(e&1) v = v * x; return v; } // pow\n\tmodll inv() { modll x(val); return x^(MODVAL-2); } // MODVAL must be prime number when use this!\n\tstatic modll inv(ll v) { return modll(v).inv(); }\n\toperator ll() { return val; }\n};\nconst ll modll::MODVAL = 998244353;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll N;\n\twhile(cin>>N) {\n\t\tVI X(N), Y(N);\n\t\tREP(i, N) cin>>X[i]>>Y[i];\n\t\tmodll ans = (modll(2)^N) - (N*(N-1)/2 + N + 1);\n\t\tDD(ans);\n\t\tVVI done(N, VI(N));\n\t\tREP(i, N) REP(j, i) if(!done[i][j]) {\n\t\t\tVI onLine = {i, j};\n\t\t\tREP(k, N) if(k!=i && k!=j && (X[k]-X[i])*(Y[j]-Y[i])-(Y[k]-Y[i])*(X[j]-X[i])==0) onLine.PB(k);\n\t\t\tll r = onLine.size();\n\t\t\tREP(a, r) REP(b, r) done[a][b]=1;\n\t\t\tDD(onLine);\n\t\t\tif(r>=3) ans -= (modll(2)^r) - (1 + r + (r*(r-1)/2));\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int Q = 998244353;\nconst int N = 209;\nll x[N], y[N], p[N], f[N], size[N];\ninline int read() {\n    int s = 1, a = 0; char ch = getchar();\n    while (ch < '0' || ch > '9') {if (ch == '-') s = -1; ch = getchar();}\n    while (ch >= '0' && ch <= '9') {a = a * 10 + ch - '0'; ch = getchar();}\n    return s * a;\n}\ninline int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\ninline int findSet(int x) {\n    return f[x] == x ? x : f[x] = findSet(f[x]);\n}\ninline void unionSet(int x, int y) {\n    int fx = findSet(x), fy = findSet(y);\n    if (fx != fy) {\n        f[fy] = fx;\n        size[fx] += size[fy];\n    }\n}\nstruct Seg {\n    int p, q; ll hash;\n    bool operator < (const Seg &rhs) const {\n        return hash < rhs.hash;\n    }\n};\nvector<Seg> seg;\nint main() {\n    p[0] = 1;\n    for (int i = 1; i < N; i++) {\n        p[i] = p[i - 1] << 1, p[i] %= Q;\n    }\n    int n = read();\n    for (int i = 1; i <= n; i++) {\n        x[i] = read(), y[i] = read();\n    }\n    ll res = (p[n] - n - 1) % Q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            int dx = x[i] - x[j], dy = y[i] - y[j], g = gcd(dx, dy);\n            dx /= g, dy /= g;\n            if (dx == 0) dy = 1;\n            if (dy == 0) dx = 1;\n            if (dx < 0) dx *= -1, dy *= -1;\n            Seg s; s.p = i, s.q = j, s.hash = dx * 50000 + dy;\n            seg.push_back(s);\n        }\n    }\n    sort(seg.begin(), seg.end());\n    for (int i = 0, j = 0; i < seg.size(); i = j) {\n        for (int k = 1; k <= n; k++) {\n            f[k] = k, size[k] = 1;\n        }\n        for (; j < seg.size() && seg[i].hash == seg[j].hash; j++) {\n            unionSet(seg[j].p, seg[j].q);\n        }\n        for (int k = 1; k <= n; k++) {\n            if (f[k] == k && size[k] >= 2) {\n                res -= (p[ size[k] ] - size[k] - 1), res += Q, res %= Q;\n            }\n        }\n    }\n    res += Q, res %= Q;\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 998244353ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n;\npii pts[252];\nll bin[252];\n\nint cross(pii a,pii b){\n  return a.first*b.second - a.second*b.first;\n}\nint sp(pii a,pii b,pii c){\n  pii x = pii(b.first-a.first, b.second-a.second);\n  pii y = pii(c.first-a.first, c.second-a.second);\n  return cross(x,y);\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n){\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    pts[i] = pii(x,y);\n  }\n\n  bin[0] = 1;\n  FOR(i,1,252)bin[i] = bin[i-1]*2%MOD;\n\n  ll ans = bin[n];\n  FOR(i,0,n)FOR(j,i+1,n){\n    int x = 0;\n    FOR(k,j+1,n){\n      if(sp(pts[i],pts[j],pts[k]) == 0){\n        x++;\n      }\n    }\n    ans -= bin[x];\n  }\n  ans -= n;\n  ans -= 1;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nconst LL m_MOD = 998244353;\n\n//負数がないMOD関数\ninline long long imod(long long a, long long b)\n{\n\treturn (a >= 0) ? (a % b) : (a % b + b);\n}\n\n//mint_base型用の累乗関数\ntemplate <long long MOD> class mint_base;\ntemplate <long long MOD> mint_base<MOD> m_pow(long long x, long long n);\n\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <long long MOD = 1000000007>\nclass mint_base\n{\npublic:\n\tmint_base<MOD> operator+(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a + other.a, MOD));\n\t}\n\tmint_base<MOD> operator-(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a - other.a, MOD));\n\t}\n\tmint_base<MOD> operator*(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a * other.a, MOD));\n\t}\n\tmint_base<MOD> operator+=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a + other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator-=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a - other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator*=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a * other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator+()const\n\t{\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator-()const\n\t{\n\t\treturn mint_base<MOD>(-a);\n\t}\n\tmint_base<MOD>& operator++()\n\t{\n\t\t*this += 1;\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator++(int)\n\t{\n\t\tauto tmp = *this;\n\t\t*this += 1;\n\t\treturn tmp;\n\t}\n\tmint_base<MOD>& operator--()\n\t{\n\t\t*this -= 1;\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator--(int)\n\t{\n\t\tauto tmp = *this;\n\t\t*this -= 1;\n\t\treturn tmp;\n\t}\n\tmint_base<MOD> operator~()const\n\t{\n\t\treturn m_pow<MOD>(a, (long long)e_phi - 1);\n\t}\n\tmint_base<MOD>& operator=(const mint_base<MOD> &other)\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\texplicit operator long long()const\n\t{\n\t\treturn a;\n\t}\n\texplicit operator int()const\n\t{\n\t\treturn (int)a;\n\t}\n\n\t//無効な数値を指定された場合\n\tstatic_assert(MOD >= 2, \"MOD cannot be below 2.\");\n\tmint_base(long long a_) :a(imod(a_, MOD))\n\t{\n\t\tif (e_phi > 0)return;\n\t\t//オイラー値の導出\n\t\te_phi = MOD;\n\t\tlong long m_ = MOD;\n\t\tfor (int i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\te_phi = e_phi / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)e_phi = e_phi / m_ * (m_ - 1);\n\t}\n\tmint_base() :a(0) {}\nprivate:\n\tstatic long long e_phi;\n\tlong long a;\n};\n\n//mint_base型用の累乗関数\ntemplate<long long MOD>mint_base<MOD> m_pow(long long x, long long n)\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tx %= MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<long long MOD>mint_base<MOD> fact(mint_base<MOD> x)\n{\n\tmint_base<MOD> res(1);\n\tfor (long long i = 1; i <= (long long)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n\n//mint_baseの階乗計算\n//0からxまでの階乗をsetに出力する\ntemplate<long long MOD>void fact_set(std::vector<mint_base<MOD>> &set, mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tset.push_back(1);\n\tfor (long long i = 1; i <= (long long)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset.push_back(res);\n\t}\n}\n\ntemplate<long long MOD>long long mint_base<MOD>::e_phi = -1;\n\n//mint_base型のstreamへの出力\ntemplate<long long MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (long long)i;\n\treturn os;\n}\n\n//mint_base型のstreamからの入力\ntemplate<long long MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tlong long tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\n\ntypedef mint_base<m_MOD> mint;\n\ntemplate <typename T>\nclass point\n{\nprivate:\n\tT x_m, y_m;\npublic:\n\tpoint(T x_, T y_)\n\t\t:x_m(x_), y_m(y_)\n\t{}\n\tpoint()\n\t\t:x_m(0), y_m(0)\n\t{}\n\n\tT x()const\n\t{\n\t\treturn x_m;\n\t}\n\tT y()const\n\t{\n\t\treturn y_m;\n\t}\n\n\tpoint operator+(const point& other)const\n\t{\n\t\treturn point(x_m + other.x(), y_m + other.y());\n\t}\n\tpoint operator-(const point& other)const\n\t{\n\t\treturn point(x_m - other.x(), y_m - other.y());\n\t}\n\tpoint operator+()const\n\t{\n\t\treturn *this;\n\t}\n\tpoint& operator+=(const point& other)const\n\t{\n\t\tx_m += other.x();\n\t\ty_m += other.y();\n\t\treturn *this;\n\t}\n\tpoint& operator-=(const point& other)const\n\t{\n\t\tx_m -= other.x();\n\t\ty_m -= other.y();\n\t\treturn *this;\n\t}\n\tpoint& operator*=(const T& k)const\n\t{\n\t\tx_m *= k;\n\t\ty_m *= k;\n\t\treturn *this;\n\t}\n\tpoint operator-()const\n\t{\n\t\treturn point(-x_m, -y_m);\n\t}\n\tT dot(const point& other)const\n\t{\n\t\treturn x_m * other.x() + y_m * other.y();\n\t}\n\tT cross(const point& other)const\n\t{\n\t\treturn x_m * other.y() - y_m * other.x();\n\t}\n\tpoint mult(const T& k)const\n\t{\n\t\treturn point(x_m * k, y_m * k);\n\t}\n};\n\nclass union_find\n{\nprivate:\n\tstd::vector<int>parent;\n\tstd::vector<int>rank;\n\tstd::vector<int>clump;\npublic:\n\tunion_find(int siz)\n\t{\n\t\tparent.resize(siz);\n\t\trank.resize(siz);\n\t\tclump.resize(siz);\n\t\tfor (int i = 0; i < siz; ++i)\n\t\t{\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tclump[i] = 1;\n\t\t}\n\t}\n\tvoid unite(int x, int y)\n\t{\n\t\tint xr = find(x);\n\t\tint yr = find(y);\n\t\tif (xr == yr)return;\n\t\tif (rank[xr] > rank[yr])\n\t\t{\n\t\t\tparent[yr] = xr;\n\t\t\tclump[xr] += clump[yr];\n\t\t}\n\t\telse if (rank[yr] > rank[xr])\n\t\t{\n\t\t\tparent[xr] = yr;\n\t\t\tclump[yr] += clump[xr];\n\t\t}\n\t\telse if (xr != yr)\n\t\t{\n\t\t\tparent[yr] = xr;\n\t\t\tclump[xr] += clump[yr];\n\t\t\t++rank[xr];\n\t\t}\n\t}\n\tint find(int x)\n\t{\n\t\tif (parent[x] == x)\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\tbool check(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x)\n\t{\n\t\treturn clump[find(x)];\n\t}\n};\n\n\n\nint main(void)\n{\n\tint n;\n\tcin >> n;\n\tvector<mint>vec;\n\tfact_set(vec, mint(1000));\n\tauto cond = [&](int n,int k)\n\t{\n\t\treturn vec[n] * ~vec[k] * ~vec[n - k];\n\t};\n\tmint ans = 0;\n\tfor (int i = 3; i <= n; ++i)\n\t{\n\t\tans += cond(n, i);\n\t}\n\tvector<point<int>>input;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tint x, y; cin >> x >> y;\n\t\tinput.push_back({ x, y });\n\t}\n\tunion_find uf(n * n);//i * n + j\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int j = 0; j < i; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < j; ++k)\n\t\t\t{\n\t\t\t\tif ((input[i] - input[j]).cross(input[i] - input[k]) == 0)\n\t\t\t\t{\n\t\t\t\t\tuf.unite(i * n + j, j * n + k);\n\t\t\t\t\tuf.unite(j * n + k, k * n + i);\n\t\t\t\t\tuf.unite(j * n + i, k * n + j);\n\t\t\t\t\tuf.unite(k * n + j, i * n + k);\n\t\t\t\t\tuf.unite(i * n + j, j * n + i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmap<int, set<int>>S;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int j = 0; j < i; ++j)\n\t\t{\n\t\t\tint cos = uf.find(i * n + j);\n\t\t\tS[cos].insert(i);\n\t\t\tS[cos].insert(j);\n\t\t}\n\t}\n\tset<set<int>>T;\n\tfor (auto& p : S)\n\t{\n\t\tif(p.second.size() > 2)\n\t\t\tT.insert(p.second);\n\t}\n\tfor (auto& q : T)\n\t{\n\t\tint shuf = q.size();\n\t\t//TLE?\n\t\tfor (int i = 3; i <= shuf; ++i)\n\t\t{\n\t\t\tans -= cond(shuf, i);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <limits>\n#include <set>\n#define REP(i,n) for(long (i)=0;(i)<(n);(i)++)\n#define REPI(i,a,b) for(long (i)=(a);(i)<(b);(i)++)\n#define INF numeric_limits<double>::infinity()\nconstexpr long MOD = 998244353;\nconstexpr double eps = 1e-10;\nusing namespace std;\nusing P = pair<double, double>;\nusing VI = vector<long>;\n\nP line(P a, P b) {\n    if (a.first == b.first) {\n        return P(INF, a.first);\n    } else if (a.second == b.second) {\n        return P(0, a.second);\n    }\n    double grad = (a.second - b.second) / (a.first - b.first);\n    return P(grad, a.second - grad * a.first);\n}\n\nbool onLine(P line, P p) {\n    if (line.first == INF) {\n        return line.second == p.first;\n    } else if (line.first == 0) {\n        return line.second == p.second;\n    }\n    return abs(line.first * p.first + line.second - p.second) < eps;\n}\n\nlong powmod(long a, long n) {\n    if (n == 0) return 1l;\n    if (n % 2 == 0) {\n        long d = powmod(a, n / 2);\n        return d * d % MOD;\n    }\n    return a * powmod(a, n - 1) % MOD;\n}\n\nint main() {\n    long n;\n    cin >> n;\n    vector<P> v;\n    REP(i,n) {\n        long x, y;\n        cin >> x >> y;\n        v.push_back(P(x,y));\n    }\n    \n    long ans = powmod(2, n);\n    ans = ans - 1 - n - n * (n - 1) / 2;\n    \n    set<P> lines;\n    \n    REP(i,n) {\n        REPI(j,i+1,n) {\n            long cnt = 2;\n            P l = line(v[i], v[j]);\n            if (lines.find(l) == lines.end()) {\n                lines.insert(l);\n                REPI(k,j+1,n) {\n                    if (onLine(l, v[k])) cnt++;\n                }\n            }\n            if (cnt > 2) {\n                ans -= powmod(2, cnt) - 1 - cnt - cnt * (cnt - 1) / 2;\n            }\n        }\n    }\n    cout << (ans + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define mod 998244353\n#define MN 205\nusing namespace std;\ninline int in(){\n    int x=0;bool f=0; char c;\n    for (;(c=getchar())<'0'||c>'9';f=c=='-');\n    for (x=c-'0';(c=getchar())>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0');\n    return f?-x:x;\n}\nstruct st{\n\tint x,y;\n}a[MN];\nint n,sum,res;\ninline bool cmp(st a,st b){\n\treturn (a.x==b.x)?a.y<b.y:a.x<b.x; \n}\ninline int qpow(int x,int k){\n\tint res=1;\n\twhile (k){\n\t\tif (k&1) res=(1ll*res*x)%mod;\n\t\tx=(1ll*x*x)%mod;k>>=1;\n\t}return res;\n}\nint main()\n{\n\tn=in();\n\tfor (int i=1;i<=n;++i) a[i].x=in(),a[i].y=in();\n\tsort(a+1,a+n+1,cmp);\n\tfor (int i=1;i<=n;++i)\n\tfor (int j=i+1;j<=n;++j){\n\t\tint cnt=0,tmp;\n\t\tfor (int k=j+1;k<=n;++k)\n\t\tif ((1ll*(a[k].x-a[i].x)*(a[j].y-a[i].y))==(1ll*(a[j].x-a[i].x)*(a[k].y-a[i].y))) ++cnt;\n\t\ttmp=((cnt*(cnt+1))>>1)%mod;res=(res+tmp)%mod;\n\t}\n\tsum=(qpow(2,n)+mod-((n*(n+1))>>1)-1)%mod;sum=(sum+mod-res)%mod;\n\tprintf(\"%d\",sum);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint MOD=998244353;\nint used[210][210];\nint main(){\n\n\tint n;\n\tcin>>n;\n\tvi x(n),y(n);\n\trep(i,n)cin>>x[i]>>y[i];\n\tvi po(300,1);\n\trep(i,299)po[i+1]=po[i]*2%MOD;\n\tint out=(po[n]+MOD-n-1)%MOD;\n\trep(i,n)loop(j,i+1,n)if(used[i][j]==0){\n\t\tvi t{i,j};\n\t\tloop(k,j+1,n)if(i!=k&&j!=k&&(x[k]-x[i])*(y[k]-y[j])==(x[k]-x[j])*(y[k]-y[i]))t.pb(k);\n\t\trep(k,t.size())rep(l,t.size())used[t[k]][t[l]]=1;\n\t\tout=(out+MOD-po[t.size()]+t.size()+1)%MOD;\n\t}\n\tcout<<out<<endl;\n\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 1000001;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a%b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a * b / gcd(a, b);\n}\n\nstruct edge {\n\tll ind;\n\tll to;\n\tll d;\n};\n\n\n///////////////////////////\n\n\nll p(ll x){\n    if(x==0){return 1;}\n    ll y=p(x/2);\n    if(x%2==1){return y*y%MOD*2%MOD;}\n    else{return y*y%MOD;}\n}\n\nint main() {\n   ll N;\n   cin >>N;\n   vector<ll> x(N+1),y(N+1);\n   repn(i,N) cin >>x[i]>>y[i];\n\n   bool ch[300][300]={};\n\n   ll ans=(p(N)-N-1)%MOD;\n\n   repn(i,N)repn(j,N){\n    if(i==j){continue;}\n\n    if(ch[i][j]==1){continue;}\n\n    vector<ll> line;\n    \n    repn(k,N){\n        if((x[i]-x[j])*(y[j]-y[k])==(x[j]-x[k])*(y[i]-y[j])){line.push_back(k);}\n     }\n\n     ll K=line.size();\n\n     rep(k,K)rep(l,K)ch[line[k]][line[l]]=1;\n\n     ans=ans-p(K)+K+1;\n     ans%=MOD;\n    \n\n   }\n\n   if(ans<0){ans+=MOD;}\n\n   cout <<ans;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed sig) {\n    x = sig;\n    while(x < 0) x += MOD;\n    while(x >= MOD) x -= MOD;\n  }\n  unsigned get() const { return x; }\n\n  // 累乗\n  ModInt binpow(ModInt y, ModInt e) {\n    ModInt a = 1, p = y;\n    while(e>0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; --e;}\n    }\n    a %= MOD; x = a.get();\n    return a;\n  }\n  ModInt binpow(ll y, ll e) {\n    ModInt a = 1, p = y;\n    while(e>0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; --e;}\n    }\n    a %= MOD; x = a.get();\n    return a;\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // 代入\n  void operator=(ll b) { x = b; }\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  // ModInt and ModInt\n  ModInt &operator+=(ModInt that) {\n    x = ((unsigned long long)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((unsigned long long)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (unsigned long long)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (unsigned long long)x * that.binpow(that.x, MOD-2) % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (unsigned long long)x % that.x;\n    return *this;\n  }\n  // ModInt and long long\n  ModInt &operator+=(ll that) {\n    x = ((unsigned long long)x+that)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ll that) {\n    x = ((((unsigned long long)x-that)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ll that) {\n    x = (unsigned long long)x * that % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ll that) {\n    x = (unsigned long long)x * binpow(that, MOD-2).x % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ll that) {\n    x = (unsigned long long)x % that;\n    return *this;\n  }\n  // ModInt and ModInt\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n  // ModInt and ll\n  ModInt operator+(ll that)const{return ModInt(*this) += that;}\n  ModInt operator-(ll that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ll that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ll that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ll that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) {\n  os << a.x;\n  return os;\n}\nistream &operator>>(istream& is, mint &a) {\n  is >> a.x;\n  return is;\n}\n\nint x[205], y[205];\n\nbool check(int i, int j, int k) {\n\tif( y[i] > y[j] ) swap(i, j);\n\tif( y[k] < y[i] || y[k] > y[j] ) return false;\n\tif( x[i] > x[j] ) swap(i, j);\n\tif( x[k] < x[i] || x[k] > x[j] ) return false;\n\tint vx = x[k] - x[i], vy = y[k] - y[i];\n\tint wx = x[k] - x[j], wy = y[k] - y[j];\n\treturn vx*wy - vy*wx == 0;\n}\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) cin >> x[i] >> y[i];\n\n  mint tmp;\n  tmp.binpow(2, n);\n  mint ret(tmp.get()-n-1);\n  // cout << ret << endl;\n  REP(i, n) {\n    FOR(j, i+1, n) {\n      mint cnt(0);\n      REP(k, n) {\n        if(k != i && k != j && check(i, j, k)) ++cnt;\n      }\n      ret -= cnt.binpow(2, cnt);\n      // cout << i << \" \" << j << \" \" << ret << endl;\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 100010\ntypedef long long LL;\nconst LL mod = 998244353;\nLL x[maxn], y[maxn], P[maxn];\nint main() {\n    LL n;\n    scanf(\"%lld\", &n);\n    for (int i = 0; i < n; ++i) scanf(\"%lld%lld\", &x[i], &y[i]);\n    P[0] = 1;\n    for (int i = 1; i <= n; ++i) (P[i] = P[i-1] << 1) %= mod;\n    LL ans = P[n] - 1 - n - n*(n-1)/2;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            int cnt = 0;\n            for (int k = j+1; k < n; ++k) {\n                if ((x[j]-x[i]) * (y[k]-y[j]) == (x[k]-x[j]) * (y[j]-y[i])) ++cnt;\n            }\n            ((ans -= P[cnt]-1) += mod) %= mod;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n,x[205],y[205],mod=998244353,ans,two[205]={1};\n\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) two[i]=two[i-1]*2%mod;\n\tans=(two[n]-1-n-(n-1)*n/2+mod)%mod;\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",x+i,y+i);\n\tfor(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++){\n\t\tint tot=0;\n\t\tfor(int k=j+1;k<=n;k++) if((y[i]-y[j])*(x[j]-x[k])==(x[i]-x[j])*(y[j]-y[k])) tot++;\n\t\tans=(ans-two[tot]+mod+1)%mod;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nbool on_the_line(pii &a, pii &b, pii &c){\n    return ((a.first - c.first)*(b.second-c.second)-(a.second-c.second)*(b.first-c.first)==0);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    pii points[N];\n    REP(i, N){\n        cin >> points[i].first >> points[i].second;\n    }\n    int did[N][N] = {};\n\n    ll pow2[N+2];\n    pow2[0] = 1;\n    for(int i=1;i<N+2;i++){\n        pow2[i] = (2*pow2[i-1])%mod;\n    }\n\n    ll res = pow2[N];\n    res = (res+mod-1)%mod;\n    res = (res+mod-N)%mod;\n\n    for(int i=0;i<N;i++){\n        for (int j=i+1;j<N;j++){\n            if(did[i][j]==0){\n                vector<int> tmp;\n                tmp.push_back(i);\n                tmp.push_back(j);\n                for(int k=j+1;k<N;k++){\n                    if(on_the_line(points[i], points[j], points[k])){\n                        tmp.push_back(k);\n                    }\n                }\n                REP(i, tmp.size()) REP(j, tmp.size()) did[i][j] = 1;\n                int s = tmp.size();\n                res = (res+mod-(pow2[s]-1-s))%mod;\n            }\n        }\n    }\n    cout << (res%mod+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<long long, long long> P;\ntypedef pair<P, P> L;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 998244353\n\nint N;\nint X[200], Y[200];\nint p2[201];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> X[i] >> Y[i];\n  p2[0] = 1;\n  for (int i=1; i<=200; i++) p2[i] = (2LL*p2[i-1]) % MOD;\n\n  int s = N+1;\n  rep(i, N) {\n    rep(j, i) {\n      int x1 = X[i], y1 = Y[i], x2 = X[j], y2 = Y[j];\n      int a = y1-y2, b = -(x1-x2), c = -(a*x1 + b*y1);\n      bool uniq = true;\n      int n = 0;\n      rep(k, N) {\n        int x = X[k], y = Y[k];\n        if (a*x+b*y+c != 0) continue;\n        n++;\n        // j(min) - k - i(max)\n        if (k < j || k > i) {\n          uniq = false;\n          break;\n        }\n      }\n      if (!uniq) continue;\n      s += (p2[n]-n-1+MOD)%MOD;\n      s %= MOD;\n    }\n  }\n  cout << (p2[N]-s+MOD)%MOD << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f1r(i,a,b) for (int i = (a); i < (b); ++i)\n#define f0r(i,a) f1r(i,0,a)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\"; }\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) {\n\t\tre(t); re(ts...); }\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n\t\tpr(t); pr(ts...); }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) {\n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); }\n\ttemplate<class T> void pr(const T& x) {\n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n\t\tpr(\"}\"); }\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tcin.sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 998244353;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n\tT val;\n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(const ll& v) {\n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) {\n\t\tif ((val += m.val) >= MOD) val -= MOD;\n\t\treturn *this; }\n\tmi& operator-=(const mi& m) {\n\t\tif ((val -= m.val) < 0) val += MOD;\n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { val = (ll)val*m.val%MOD;\n\t\treturn *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 205;\npi reduce(pi x){\n    int n = x.f; int d = x.s;\n    if(n == 0){\n        n = 0; d = 1;\n    }\n    else if(d == 0){\n        n = 1; d = 0;\n    }\n    else{\n        int g = __gcd(abs(n), abs(d));\n        n /= g; d /= g;\n        if(d<0){\n            n *= -1;\n            d *= -1;\n        }\n    }\n    return mp(n, d);\n}\npi get_slope(pi a, pi b){\n    return reduce(mp(b.s - a.s, b.f - a.f));\n}\nmi po[MAX];\nvpi pts;\nint main(){\n    int n; re(n);\n    pts.resz(n);\n    f0r(i, n) re(pts[i].f, pts[i].s);\n    set<pair<pi, pi>> lines;\n    f0r(i, MAX) po[i] = pow(mi(2), i);\n    mi ans = po[n] - 1 - n;\n    f0r(i, n){\n        f1r(j, i, n){\n            if(pts[i] == pts[j]) continue;\n            int a = pts[i].f;\n            int b = pts[i].s;\n            int c = pts[j].f;\n            int d = pts[j].s;\n            pi slope = reduce(mp(d-b,c-a));\n            pi intercept = reduce(mp(b*c-a*d,c-a));\n            if(slope.s == 0) intercept = mp(a, 0);\n            if(lines.find(mp(slope, intercept)) != lines.end()) continue;\n            lines.insert(mp(slope, intercept));\n            int cnt = 2;\n            f0r(k, n){\n                if(k == i || k == j) continue;\n                if(get_slope(pts[i], pts[k]) == get_slope(pts[j], pts[k])) cnt++;\n            }\n            ans -= (po[cnt] - 1 - cnt);\n        }\n    }\n    ps(ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by maze on 2019-07-21.\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n    using value_type = ::std::uint_fast64_t;\n    value_type n;\npublic:\n    ModInt() : n(0) {}\n    ModInt(value_type n_) : n(n_ % mod) {}\n    ModInt(const ModInt& m) : n(m.n) {}\n\n    template<typename T>\n    explicit operator T() const { return static_cast<T>(n); }\n    value_type get() const { return n; }\n\n    friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n        return os << a.n;\n    }\n\n    friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n        value_type x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return is;\n    }\n\n    bool operator==(const ModInt& m) const { return n == m.n; }\n    bool operator!=(const ModInt& m) const { return n != m.n; }\n    ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n    ModInt pow(value_type b) const{\n        ModInt ans = 1, m = ModInt(*this);\n        while(b){\n            if(b & 1) ans *= m;\n            m *= m;\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    ModInt inv() const { return (*this).pow(mod-2); }\n    ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n    ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n    ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n    ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n    ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n    ModInt& operator++(){ n += 1; return *this; }\n    ModInt& operator--(){ n -= 1; return *this; }\n    ModInt operator++(int){\n        ModInt old(n);\n        n += 1;\n        return old;\n    }\n    ModInt operator--(int){\n        ModInt old(n);\n        n -= 1;\n        return old;\n    }\n    ModInt operator-() const { return ModInt(mod-n); }\n};\n\nconstexpr int64 mod = 998244353;\nusing Mint = ModInt<mod>;\n\nint main(void) {\n    int64 N;\n    cin >> N;\n    vector<int64> x(N), y(N);\n    REP(i, N) {\n        cin >> x[i] >> y[i];\n    }\n    using T = tuple<int64, int64, int64>;\n    map<T, int64> cnt;\n    Mint res = Mint(2).pow(N);\n    REP(i, N) {\n        FOR(j, i+1, N) {\n            int64 a = y[i]-y[j], b = -(x[i]-x[j]), c = (x[i]*y[j]-x[j]*y[i]);\n            if (a < 0) {\n                a *= -1; b *= -1; c *= -1;\n            } else if (a == 0) {\n                if (b < 0) {\n                    b *= -1; c *= -1;\n                } else if (b == 0) {\n                    if (c < 0) c *= -1;\n                }\n            }\n            int64 g = __gcd(abs(a), __gcd(abs(b), abs(c)));\n            a /= g; b /= g; c /= g;\n            if (cnt[T(a, b, c)]) continue;\n            cnt[T(a, b, c)] = 1;\n            int64 sum = 2;\n            FOR(k, j+1, N) {\n                if (a * x[k] + b * y[k] + c == 0) {\n                    sum++;\n                }\n            }\n//            cout << i << \" \" << j << \" \" << a << \" \" << b << \" \" << c << \": \" << sum << endl;\n            res -= Mint(2).pow(sum) - sum - 1;\n        }\n    }\n    cout << res-N-1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repi(i, a, b) for (int i = (a); i < int(b); i++)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ll << (b))\n#define uniq(v) (v).erase(unique(all(v)), (v).end())\n#define rsort(v) sort(all(v)); reverse(all(v))\n\nusing namespace std;\nusing i32 = int;\nusing i64 = long long;\nusing f80 = long double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void ioinit() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }\ninline vi32 plist(i32 n) { vi32 f(n, 1); f[0] = f[1] = 0; repi(i, 2, n) for (int j = i * 2; j < n; j += i) f[j] = 0; return f; }\ninline bool isprime(i32 n) { if (n < 2) return 0; for (i32 i = 2; i * i <= n; i++) if (n % i == 0) return 0; return 1; }\ntemplate<class T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate<class T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate<class T> inline bool amax(T &x, T y) { if (x >= y) return 0; x = y; return 1; }\ntemplate<class T> inline bool amin(T &x, T y) { if (x <= y) return 0; x = y; return 1; }\ntemplate<class T> inline i64 lbi(vector<T> &v, T e) { return lower_bound(all(v), e) - v.begin(); }\ntemplate<class T> inline i64 ubi(vector<T> &v, T e) { return upper_bound(all(v), e) - v.begin(); }\ntemplate<class T> inline T power(T x, i64 n) { T r = 1; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\n\ntemplate<int mod> struct modint {\n  int x;\n  modint(): x(0) {}\n  modint(int a) { x = a % mod; if (x < 0) x += mod; }\n  modint &operator+=(modint that) { x = (x + that.x) % mod; return *this; }\n  modint &operator-=(modint that) { x = (x + mod - that.x) % mod; return *this; }\n  modint &operator*=(modint that) { x = (i64) x * that.x % mod; return *this; }\n  modint &operator/=(modint that) { return *this *= that.inverse(); }\n  modint operator-() { return modint(-this->x); }\n  friend ostream& operator<<(ostream &out, modint m) { return out << m.x; }\n  modint inverse() {\n    int a = x, b = mod, u = 1, v = 0;\n    while (b) { int t = a / b; a -= t * b; u -= t * v; swap(a, b); swap(u, v); }\n    return modint(u);\n  }\n  #define op(o, p) modint operator o(modint that) { return modint(*this) p that; }\n    op(+, +=) op(-, -=) op(*, *=) op(/, /=)\n  #undef op\n  #define op(o) bool operator o(modint that) const { return x o that.x; }\n    op(==) op(!=) op(<) op(<=) op(>) op(>=)\n  #undef op\n};\n\nusing mint = modint<998244353>;\n\nstruct point {\n  f80 x, y;\n  point() : x(), y() {}\n  point(f80 x, f80 y) : x(x), y(y) {}\n  point operator+(const point &a) const { return point(x + a.x, y + a.y); }\n  point operator-(const point &a) const { return point(x - a.x, y - a.y); }\n  f80 operator%(const point &a) const { return x * a.x + y * a.y; }\n  f80 operator*(const point &a) const { return x * a.y - y * a.x; }\n};\n\nbool line(point a, point b, point c) {\n  return (b.x - a.x) * (c.y - a.y) == (b.y - a.y) * (c.x - a.x);\n}\n\nint main() {\n  ioinit();\n  int n;\n  cin >> n;\n  vector<point> xy(n);\n  rep(i, n) {\n    int x, y;\n    cin >> x >> y;\n    xy[i] = point(x, y);\n  }\n  mint ans = power((mint) 2, n);\n  ans -= 1;\n  ans -= n;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      ans -= 1;\n      int cnt = 0;\n      for (int k = j + 1; k < n; k++) {\n        if (line(xy[i], xy[j], xy[k])) cnt++;\n      }\n      if (cnt > 0) ans -= power((mint) 2, cnt) - 1;\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 105\nusing namespace std;\n\n#define db double\n#define eps 1e-8\nstruct point{db x,y;};\npoint operator +(point a,point b){return (point){a.x+b.x,a.y+b.y};}\npoint operator -(point a,point b){return (point){a.x-b.x,a.y-b.y};}\ndb operator *(point a,point b){return a.x*b.y-b.x*a.y;}\npoint operator *(point a,db x){return (point){a.x*x,a.y*x};}\npoint operator /(point a,db x){return (point){a.x/x,a.y/x};}\nbool a_onleft(point a,point b){return a*b<-eps;}\ndb area(point a,point b,point c){return abs((a-c)*(b-c)/2.0);}\npoint inter(point a1,point a2,point b1,point b2){\n\tdouble s1=area(b1,b2,a1),s2=area(b1,b2,a2);\n\treturn (a1-a2)/(s1+s2)*s2+a2;\n}\n#undef db\n#undef eps\nconst int mod=998244353;\npoint p[N];\nint n,pw[N];\nint main(){\n\tscanf(\"%d\",&n);pw[0]=1;\n\tfor(int i=1;i<=n;i++) scanf(\"%lfq%lf\",&p[i].x,&p[i].y),pw[i]=pw[i-1]*2%mod;\n\tlong long ans=pw[n]-1-n;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint cnt=0;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\t\tif(area(p[i],p[j],p[k])<1e-8) cnt++;\n\t\t\tans-=pw[cnt];\n\t\t}\n\tcout<<(ans%mod+mod)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NDEBUG\n#ifdef DEBUG\n#include \"../cout11.h\"\n#undef NDEBUG\n#endif\n#include <cassert>\n\ntypedef long long ll;\ntypedef long double Double;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> llll;\ntypedef pair<double,double> dd;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ii> vii;\ntypedef vector<vector<ii>> vvii;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<long double> vD;\n\n#define sz(a)  int((a).size())\n#define pb  push_back\n#define FOR(var,from,to) for(int var=(from);var<=(to);++var)\n#define rep(var,n)  for(int var=0;var<(n);++var)\n#define rep1(var,n)  for(int var=1;var<=(n);++var)\n#define repC2(vari,varj,n)  for(int vari=0;vari<(n)-1;++vari)for(int varj=vari+1;varj<(n);++varj)\n#define ALL(c)  (c).begin(),(c).end()\n#define RALL(c)  (c).rbegin(),(c).rend()\n#define tr(i,c)  for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define found(s,e)  ((s).find(e)!=(s).end())\n#define mset(arr,val)  memset(arr,val,sizeof(arr))\n#define mid(x,y) ((x)+((y)-(x))/2)\n#define IN(x,a,b) ((a)<=(x)&&(x)<=(b))\n#define cons make_pair\n\n\nll gcd(ll a, ll b) { while(a) swap(a, b%=a); return b; }\n\nconst ll MOD=998244353LL;\n\nll ADD(ll x, ll y) { return (x+y) % MOD; }\nll SUB(ll x, ll y) { return (x-y+MOD) % MOD; }\nll MUL(ll x, ll y) { return x*y % MOD; }\nll POW(ll x, ll e) { ll v=1; for(; e; x=MUL(x,x), e>>=1) if (e&1) v = MUL(v,x); return v; }\nll DIV(ll x, ll y) { /*assert(y%MOD!=0);*/ return MUL(x, POW(y, MOD-2)); }\n// ll comb(ll n, ll k) { ll v=1; for(ll i=1; i<=k; i++) v = DIV(MUL(v, n-i+1),i); return v; }\n//\n\ntypedef tuple<double,double,double> LINE;\n\nvoid render_fnum(FILE* fp, double x) {\n    if (x == 1) return;\n    fprintf(fp, \"%g\", x);\n}\nvoid render_line(FILE* fp, LINE& line) {\n    double a,b,c; tie(a,b,c) = line;\n    if (a != 0){\n        render_fnum(fp, a);\n        fprintf(fp, \"x\");\n    }\n\n    if (b != 0) {\n        if (b > 0) {\n            if (a != 0)\n                fprintf(fp, \" + \");\n            render_fnum(fp, b);\n        } else if (b < 0) {\n            fprintf(fp, \" - \");\n            render_fnum(fp, -b);\n        }\n        fprintf(fp, \"y\");\n    }\n\n    if (c != 0) {\n        if (c > 0) {\n            fprintf(fp, \" + %g\", c);\n        } else if (c < 0) {\n            fprintf(fp, \" - %g\", -c);\n        }\n    }\n\n    fprintf(fp, \" = 0\");\n}\n\nLINE get_line(ii& p0, ii& p1){\n    int x0 = p0.first, y0 = p0.second,\n        x1 = p1.first, y1 = p1.second;\n    int dx = x1 - x0, dy = y1 - y0;\n\n    assert(dx != 0 || dy != 0);\n\n    double a, b, c;\n\n    if (dx == 0) {\n        // 1x [+ 0y] - some = 0\n        // some = x\n        double some = (double)x0;\n        a = 1.0;\n        b = 0.0;\n        c = -some;\n    } else if (dy == 0) {\n        // [0x +] 1y - some = 0\n        // some = y\n        double some = (double)y0;\n        a = 0.0;\n        b = 1.0;\n        c = -some;\n    } else {\n        // m = dy/dx\n        // y = mx + b\n        // mx - y + b = 0\n        double _m = (double)dx / dy;\n        assert(_m != 0.0);\n        // x - _my - some = 0\n        double some = (double)x0 - _m * y0;\n        a = 1.0;\n        b = -_m;\n        c = -some;\n    }\n\n    // fprintf(stderr, \"(a,b,c)=(%g,%g,%g)\\n\", a,b,c);\n\n    double z0 = a * x0 + b * y0 + c;\n    double z1 = a * x1 + b * y1 + c;\n#ifdef DEBUG\n    // fprintf(stderr, \"%g * %d + %g * %d + %g = %g\\n\", a,x0, b,y0, c, z0);\n    // fprintf(stderr, \"%g * %d + %g * %d + %g = %g\\n\", a,x1, b,y1, c, z1);\n#endif\n    assert(fabs(z0) < 1e-7);\n    assert(fabs(z1) < 1e-7);\n\n    return LINE(a, b, c);\n}\n\n\nll f(int n){\n    // return (1 << n) - n - 1;\n    return SUB(POW(2, n), ADD(n,1));\n}\n\nll solve(int N, vii& p){\n    map<LINE, set<int>> by_line;\n\n    repC2(i,j,N){\n#ifdef DEBUG\n        // cerr << \"---\" << endl;\n        // fprintf(stderr, \"[%d %d] \", i, j);\n        // cerr << p[i] << \" \" << p[j] << \" : \";\n#endif\n        LINE line = get_line(p[i], p[j]);\n#ifdef DEBUG\n        // render_line(stderr, line);\n        // cerr << endl;\n#endif\n        by_line[line].insert(i);\n        by_line[line].insert(j);\n    }\n\n    ll ans = f(N); // (1 << N) - (N+1);\n    for(auto p: by_line){\n        LINE line = p.first;\n        set<int> s = p.second;\n        int k = p.second.size();\n#ifdef DEBUG\n        render_line(stderr, line);\n        cerr << \" : \" << s << endl;\n#endif\n        ans = SUB(ans, f(k)); // (1 << k) - (k+1));\n    }\n    return ans;\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    vector<ii> p(N);\n    rep(i,N){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        p[i] = ii(x, y);\n    }\n\n    cout << solve(N,p) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n \nconst double EPS = 1e-12;\ntypedef complex<double> P;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n \nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n \nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<L>se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\tL l(v[i],v[j]);\n\t\tint n=0;\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectSP(l,v[k]))n++;\n\t\tr=(r-pow_binary_mod(2,n,M))%M;\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst bool debug = true;\n#define dbg(...) if(debug) printf(__VA_ARGS__)\n#define print(var) if (debug) cout << #var << \" = \" << var << endl\n/** whole range */\n#define whole(xs) (xs).begin(), (xs).end()\n\nnamespace {\n    template<typename T> istream& operator>>(istream& is, vector<T>& xs) { for (auto& x : xs) is >> x; return is; }\n    using ll = long long;\n    using real = double;\n    const real EPS = 1e-6;\n\n    template<ll mod> ll modpow(ll n, ll k) {\n        if (k == 0) return 1LL;\n        if (k % 2 == 0) return modpow<mod>(n * n % mod, k / 2);\n        return modpow<mod>(n, k - 1) * n % mod;\n    }\n    template<ll mod> ll inverse(ll n) { return modpow<mod>(n, mod - 2); }\n\n    struct Point {\n        real x, y;\n        Point() {}\n        Point(real x, real y) : x(x), y(y) {}\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n        Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n        Point operator*(real k) const { return Point(k * x, k * y); }\n        Point operator/(real k) const { return Point(x / k, y / k); }\n    };\n    real dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n    real cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    real norm(const Point& a) { return sqrt(dot(a, a)); }\n    Point rot90(const Point& p) { return Point(-p.y, p.x); }  // 反時計回りに90度回転\n    real angle(const Point& a) { return atan2(a.y, a.x); }  // x軸を反時計回りに何ラジアン回転させれば点aに乗るか\n    ostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; };\n    int ccw(Point a, Point b, Point c) {\n        b = b - a;\n        c = c - a;\n        if (cross(b, c) > EPS) return +1;   // a,b,cの順に反時計周り\n        if (cross(b, c) < -EPS) return -1;  // a,b,cの順に時計周り\n        if (dot(b, c) < 0) return +2;       // c--a--b 直線\n        if (norm(b) < norm(c)) return -2;   // a--b--c 直線\n        return 0;                           // a--c--b 直線\n    }\n    struct Line {\n        Point a, b;\n        Line() {}\n        Line(const Point& a, const Point& b) : a(a), b(b) {}\n    };\n    bool contains(const Line& l, const Point& p) { return ccw(l.a, l.b, p) % 2 == 0; }\n    bool parallel(const Line& s, const Line& t) { return abs(cross(s.b - s.a, t.b - t.a)) < EPS; }\n    bool orthogonal(const Line& s, const Line& t) { return abs(dot(s.b - s.a, t.b - t.a)) < EPS; }\n    bool equals(const Line& s, const Line& t) { return parallel(s, t) && contains(s, t.a); }\n    Point crosspoint(const Line& s, const Line& t) {\n        real d = cross(t.b - t.a, s.b - s.a);\n        assert(abs(d) >= EPS);\n        return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n    }\n    ostream& operator<<(ostream& os, const Line& l) {\n        return os << \"Line(\" << l.a << \", \" << l.b << \")\";\n    }\n\n    int N;\n    vector<Point> ps;\n    void input() {\n        cin >> N;\n        ps.resize(N);\n        cin >> ps;\n    }\n    const ll mod = 998244353;\n    void solve() {\n        vector<Line> lines;\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                auto& a = ps[i];\n                auto& b = ps[j];\n                lines.emplace_back(a, b);\n            }\n        }\n        vector<Line> nlines;\n        vector<bool> used(lines.size(), false);\n        for (int i = 0; i < lines.size(); i++) {\n            if (used[i]) continue;\n            nlines.push_back(lines[i]);\n            for (int j = i + 1; j < lines.size(); j++) {\n                if (equals(lines[i], lines[j])) used[j] = true;\n            }\n        }\n        lines = nlines;\n        vector<ll> count(lines.size(), 0);\n        for (int i = 0; i < lines.size(); i++) {\n            auto& line = lines[i];\n            for (int k = 0; k < N; k++) {\n                if (contains(line, ps[k])) {\n                    count[i]++;\n                }\n            }\n        }\n        auto c = [&](ll n) {\n            return (modpow<mod>(2LL, n) + (mod - 1) + (mod - n) + (mod - (n * (n - 1) / 2) % mod)) % mod;\n        };\n        ll ans = c(N);\n        for (int i = 0; i < lines.size(); i++) {\n            auto& cnt = count[i];\n            ans = (ans + mod - c(cnt)) % mod;\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) < 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<point> ns;\n        for (int j = 0; j < n; j++) {\n            if (j == i) {\n                continue;\n            }\n            if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {\n                need[j] = true;\n                ns.push_back(p[j]);\n            } else {\n                need[j] = false;\n            }\n        }\n        cur = p[i];\n        sort(all(ns), comp);\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                goods[j][k] = false;\n                cnt[j][k] = 0;\n                dp[j][k] = 0;\n                if (good(p[i], ns[j], ns[k])) {\n                    goods[j][k] = true;\n                    for (int g = 0; g < sz(ns); g++) {\n                        if (g == j || g == k) {\n                            continue;\n                        }\n                        if (inside(p[i], ns[j], ns[k], ns[g])) {\n                            cnt[j][k]++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (goods[j][k]) {\n                    dp[j][k] += st[cnt[j][k]];\n                    dp[j][k] %= Mod;\n                    ans += dp[j][k];\n                    ans %= Mod;\n                    for (int nxt = k + 1; nxt < sz(ns); nxt++) {\n                        if (vec(ns[nxt] - ns[j], ns[k] - ns[j]) > 0 && goods[k][nxt] && vec(ns[nxt] - p[i], ns[k] - p[i]) != 0) {\n                            dp[k][nxt] += dp[j][k];\n                            if (dp[k][nxt] >= Mod) {\n                                dp[k][nxt] %= Mod;\n                            }\n                        }\n                    }\n                }   \n            }\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stdio.h>\nusing namespace std;\n#define ll long long\ntypedef pair<ll,ll> pi;\nint n;\npi arr[205];\nll mod = 998244353;\nll answer = 0;\nll factorial[205];\nll ifactorial[205];\nvector<ll> v;\nbool collinear[205][205];\n\nll power(ll a, ll b){\n\ta %= mod;\n\tif (b == 0) return 1;\n\tif (b == 1) return a;\n\tll half = power(a, b/2);\n\thalf*=half;\n\thalf%=mod;\n\tif (b % 2 == 1){\n\t\thalf *= a;\n\t\thalf %= mod;\n\t}\n\treturn half;\n}\n\nvoid init(){\n\tfactorial[0] = 1;\n\tfor (int i = 1; i < 205; i++){\n\t\tfactorial[i] = factorial[i - 1]*i;\n\t\tfactorial[i] %= mod;\n\t}\n\tfor (int i = 1; i < 205; i++){\n\t\tifactorial[i] = power(factorial[i], mod - 2);\n\t}\n\t\n}\n\nll choose(ll n, ll k){\n\tif (n == k) return (long long)1;\n\treturn (((factorial[n]*ifactorial[k])%mod)*ifactorial[n - k])%mod;\n}\n\nll adjust(ll x){\n\tx %= mod;\n\tif (x < 0){\n\t\tx += mod;\n\t}\n\treturn x;\n}\n\nint main(){\n\tinit();\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lld%lld\", &arr[i].first, &arr[i].second);\n\t}\n\tsort(arr, arr + n);\n\tll answer = 0;\n\tfor (int i = 3; i <= n; i++){\n\t\tanswer += choose(n, i);\n\t\t//cout << \"choose (\" << n << \", \" << i << \") = \" << choose(n, i) << endl;\n\t}\n\tanswer = adjust(answer);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = i + 1; j < n; j++){\n\t\t\tif (collinear[i][j]) continue;\n\t\t\tv.clear();\n\t\t\tv.push_back(i);\n\t\t\tv.push_back(j);\n\t\t\tfor (int k = j + 1; k < n; k++){\n\t\t\t\tif ((arr[i].second - arr[j].second)*(arr[i].first - arr[k].first) == (arr[i].second - arr[k].second)*(arr[i].first - arr[j].first)){\n\t\t\t\t\tv.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < (int)v.size(); k++){\n\t\t\t\tfor (int l = 0; l < (int)v.size(); l++){\n\t\t\t\t\tcollinear[k][l] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 3; k <= (int)v.size(); k++){\n\t\t\t\tanswer -= choose((long long)v.size(), (long long)k);\n\t\t\t}\n\t\t\tanswer = adjust(answer);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", answer);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 2e2 + 10,mod = 998244353;\nconst double Pi = acos(-1.0),eps = 1e-7;\n\nstruct node {\n\tint x,y;\n} P[N];\nbool vis[N];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline int fpm(int a,int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1) res = 1ll * res * a % mod;\n\t\ta = 1ll * a * a % mod,b /= 2;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n = read(),ans = 0;\n\tFor(i,1,n) P[i].x = read(),P[i].y = read();\n\tans = (fpm(2,n) - 1 - n - 1ll * n * (n - 1) / 2) % mod;\n\n\tFor(i,1,n) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tFor(j,1,n) if((i ^ j) && !vis[j]) {\n\t\t\tint cnt = 1;\n\t\t\tdouble val = atan2(P[j].y - P[i].y,P[j].x - P[i].x);\n\t\t\tif(val < eps) val += Pi;\n\t\t\tFor(k,1,n) if(k ^ i) {\n\t\t\t\tdouble cur = atan2(P[k].y - P[i].y,P[k].x - P[i].x);\n\t\t\t\tif(cur < eps) cur += Pi;\n\t\t\t\tif(abs(cur - val) < eps) cnt++,vis[k] = true;\n\t\t\t}\n\t\t\tans = (ans - 1ll * (fpm(2,cnt) - 1 - cnt - 1ll * cnt * (cnt - 1) / 2 % mod) * fpm(cnt,mod - 2)) % mod;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",(ans + mod) % mod);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint read()\n{\n\tint ans=0;\n\tchar ch=getchar();\n\tfor(;(ch<'0' || ch>'9') && ch!='-';ch=getchar());\n\tbool flag=0;\n\tif(ch=='-')flag=1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())ans=ans*10+ch-'0';\n\tif(flag)ans=-ans;\n\treturn ans;\n}\n\nlong long rell()\n{\n\tlong long ans=0;\n\tchar ch=getchar();\n\tfor(;(ch<'0' || ch>'9') && ch!='-';ch=getchar());\n\tbool flag=0;\n\tif(ch=='-')flag=1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())ans=ans*10ll+(long long)(ch-'0');\n\tif(flag)ans=-ans;\n\treturn ans;\n}\n\nvoid writ(int n)\n{\n\tchar ch[25];\n\tint m=0;\n\tif(n<0)putchar('-'),n=-n;\n\tif(n==0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tfor(;n;n/=10)ch[m++]=n%10ll+'0';\n\tfor(;m;)putchar(ch[--m]);\n}\n\nvoid wrll(long long n)\n{\n\tchar ch[25];\n\tint m=0;\n\tif(n<0)putchar('-'),n=-n;\n\tif(n==0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tfor(;n;n/=10ll)ch[m++]=n%10ll+'0';\n\tfor(;m;)putchar(ch[--m]);\n}\nconst int N=1<<8;\nconst int mod=998244353;\nint x[N],y[N],po[N];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tpo[0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tx[i]=read();y[i]=read();\n\t\tpo[i+1]=po[i]*2ll%mod;\n\t}\n\tint ans=(po[n]-1-n+mod)%mod;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tint sum=0,a=y[i]-y[j],b=x[j]-x[i],c=x[i]*y[j]-x[j]*y[i];\n\t\t\tfor(int k=j+1;k<n;k++)\n\t\t\t{\n\t\t\t\tif(x[k]*a+y[k]*b+c==0)sum++;\n\t\t\t}\n\t\t\t(ans+=mod-po[sum])%=mod;\n\t\t\t//printf(\"i=%d j=%d sum=%d\\n\",i,j,sum);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\nconst int MAXN = 200 + 100;\nconst int MOD = 998244353;\n\nstruct Point\n{\n\tint x, y;\n\tPoint(int _x = 0, int _y = 0) : x(_x), y(_y)\n\t{}\n};\n\ntypedef Point Vector;\n\nVector operator - (const Vector &a, const Vector &b)\n{\n\treturn Vector(a.x - b.x, a.y - b.y);\n}\nint cross(const Vector &a, const Vector &b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\nbool on_line(const Point &p, const Point &a, const Point &b)\n{\n\treturn cross(b - a, p - a) == 0;\n}\n\ntypedef pair<int, int> pii;\n\npii min2(const pii &p, int x)\n{\n\tif(x <= p.first) return make_pair(x, p.first);\n\tif(p.first < x && x <= p.second) return make_pair(p.first, x);\n\treturn p;\n}\n\nint fpow(int x, int p)\n{\n\tint ret = 1;\n\tfor(; p; p >>= 1, x = (long long)x * x % MOD)\n\t\tif(p & 1)\n\t\t\tret = (long long)ret * x % MOD;\n\treturn ret;\n}\n\nint n, ans = 0;\nPoint p[MAXN];\nvector<int> num;\nset<pair<int, int> > vis;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> p[i].x >> p[i].y;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tpii mn = make_pair(i, j);\n\t\t\tint cnt = 2;\n\t\t\tfor(int k = 1; k <= n; k++)\n\t\t\t\tif(k != i && k != j && on_line(p[k], p[i], p[j]))\n\t\t\t\t\tcnt++, mn = min2(mn, k);\n\t\t\tif(!vis.count(mn))\n\t\t\t\tvis.insert(mn), num.push_back(cnt);\n\t\t}\n\t// cerr << num.size() << ' ' << num[0] << endl;\n\tans = (fpow(2, n) - n - 1 + MOD) % MOD;\n\t// cerr << ans << endl;\n\tfor(int i = 0; i < num.size(); i++)\n\t\tans = (ans - (fpow(2, num[i]) - num[i] - 1) + MOD) % MOD;\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\n//priority_queue<ll> max;//大きい順\n//priority_queue<ll, Array, greater<ll>> min;//小さい順\n\n/*firstについては昇順 secondについては降順\nsort(all(wh), [&](P x, P y) {\n\tif (x.first == y.first)return x.second > y.second;\n\treturn x.first < y.first;\n});\n*/\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//substr　文字列取り出し\n//upper_bound ある値より大きい一番左のイテレータを返す、lowerは以上(setに対して使うとO(N)なので、setのメンバ関数を使う\n//stoi\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unionSet(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\n\tint _sum(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tint s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tint s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tint n, height;\n\tvector<int> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(int _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<int>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(int i, int x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tint sum(int a, int b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\n\nll ModPow(ll x, ll n) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix& A, const Matrix& B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>> &s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst ll mod = 998244353;\nll two[300];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tll n;\n\tcin >> n;\n\tvector<P> xy(n);\n\tREP(i, n)cin >> xy[i].first >> xy[i].second;\n\tll ans = 1;\n\ttwo[0] = 1;\n\tREP(i, n) {\n\t\t(ans *= 2) %= mod;\n\t\ttwo[i + 1] = ans;\n\t}\n\t(ans += mod - n - 1) %= mod;\n\tmap<P, ll> mp;\n\t\n\tREP(i, n) {\n\t\trep(j, i + 1, n) {\n\t\t\tif (mp.count(make_pair(i, j)))continue;\n\t\t\tArray temp;\n\t\t\ttemp.push_back(i);\n\t\t\ttemp.push_back(j);\n\t\t\tll x = xy[i].first - xy[j].first;\n\t\t\tll y = xy[i].second - xy[j].second;\n\t\t\trep(k, j + 1, n) {\n\t\t\t\tll a = xy[i].first - xy[k].first;\n\t\t\t\tll b = xy[i].second - xy[k].second;\n\t\t\t\tif (x*b == y * a) {\n\t\t\t\t\ttemp.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\t(ans += mod - two[temp.size()]+temp.size()+1) %= mod;\n\t\t\tREP(l, temp.size()) {\n\t\t\t\trep(m, l + 1, temp.size()) {\n\t\t\t\t\tmp[make_pair(temp[l], temp[m])]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) < norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[m][m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define MOD (998244353)\n#define N (300)\n\nusing namespace std;\n\nint x[N],y[N],p[N];\n\ninline long long myPow(long long a,long long b)\n{\n    long long c = 1;\n\n    for(;b > 0;b >>=1,a = a * a % MOD)\n\tif(b & 1)\n\t    c = c * a % MOD;\n\n    return c;\n}\n\ninline bool det(int i,int j,int l)\n{\n    return (x[l]-x[j])*(y[j] - y[i]) - (x[j] - x[i])*(y[l]-y[j]) == 0;\n}\n\nint main(void)\n{\n    int n;\n    long long ans = 0;\n    \n    cin>>n;\n\n    for(int i = 0;i <= n;i++)\n    {\n\tp[i] = myPow(2,i);\n    }\n\n    for(int i = 1;i <= n;i++)\n    {\n\tcin>>x[i]>>y[i];\n    }\n\n    for(int i = 1;i <= n;i++) {\n\tfor(int j = i+1;j <= n;j++) {\n\t    int k = 0;\n\t    for(int l = j+1;l <= n;l++)\n\t\tif(det(i,j,l))\n\t\t    k++;\n\t    ans = (ans + p[k]) % MOD;\n\t}\n    }\n\n    ans = (p[n] - ans - n - 1) % MOD;\n    \n    cout<<ans<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nstruct point{\n\tint x , y;\n\tpoint(int _x = 0 , int _y = 0){\n\t\tx = _x;\n\t\ty = _y;\n\t}\n\tpoint operator + (const point &other) const {\n\t\treturn point(x + other.x , y + other.y);\n\t}\n\tpoint operator - (const point &other) const {\n\t\treturn point(x - other.x , y - other.y);\n\t}\n\tbool operator < (const point &other) const {\n\t\tif(x == other.x){\n\t\t\treturn y < other.y;\n\t\t}\n\t\treturn x < other.x;\n\t}\n\tvoid read(){\n\t\tscanf(\"%d %d\" , &x , &y);\n\t}\n};\ninline int dot(point a , point b){\n\treturn a.x * b.x + a.y * b.y;\n}\ninline int cross(point a , point b){\n\treturn a.x * b.y - a.y * b.x;\n}\ninline int orient(point a , point b , point c){//orientation of point c with respect to line from a -> b\n\tint val = cross(b - a , c - a);\n\tif(val > 0){\n\t\treturn 1;//c comes anticlockwise on line from a -> b\n\t}\n\tif(val < 0){\n\t\treturn -1;//c comes clockwise on line from a -> b\n\t}\n\treturn 0;//c is collinear with line from a -> b\n}\nint dist(point a , point b){\n\treturn dot(a - b , a - b);\n}\nconst int N = 205;\nconst int mod = 998244353;\nconst int inv = 499122177;\nint pw2[N];\nint n;\npoint arr[N];\nvector < point > v;\npoint bottom;\nint ans;\nbool cmp(point a , point b){\n\tint tmp = orient(bottom , a , b);\n\tif(tmp == -1){\n\t\treturn 1;\n\t}\n\tif(tmp == 1){\n\t\treturn 0;\n\t}\n\treturn dist(bottom , a) < dist(bottom , b);\n}\nbool inside(point p1 , point p2 , point p3 , point q){\n\tint o1 = orient(p1 , p2 , q);\n\tint o2 = orient(p2 , p3 , q);\n\tint o3 = orient(p3 , p1 , q);\n\treturn (o1 == o2) && (o2 == o3) && (o3 != 0);\n}\nint siz2[N][N][N];\nint siz3[N][N];\nmap < point , int > mp;\nvector < int > indexes;\n//int tot;\nint dp[N][N];\nint solve(int last1 , int last2){\n\tif(dp[last1][last2] != -1){\n\t\treturn dp[last1][last2];\n\t}\n\tint res = !!last1;\n\t/*if(last1){\n\t\tcout << tot << \" \";\n\t}*/\n\tfor(int i = last2 + 1 ; i < v.size() ; ++i){\n\t\tif(orient(v[last1] , v[last2] , v[i]) == -1){\n\t\t\t//tot += siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0);\n\t\t\tres = (res + 1LL * solve(last2 , i) * pw2[siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][indexes[i]] : 0) + siz3[indexes[last2]][indexes[i]]]) % mod;\n\t\t\t//tot -= siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0);\n\t\t}\n\t}\n\treturn dp[last1][last2] = res;\n}\nvoid solve(int idx){\n\tv.clear();\n\tbottom.x = arr[idx].x;\n\tbottom.y = arr[idx].y;\n\tv.emplace_back(arr[idx]);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tif(arr[i].y > bottom.y){\n\t\t\tv.emplace_back(arr[i]);\n\t\t}\n\t\telse if(arr[i].y == bottom.y && arr[i].x > bottom.x){\n\t\t\tv.emplace_back(arr[i]);\n\t\t}\n\t}\n\tsort(v.begin() + 1 , v.end() , cmp);\n\tindexes.clear();\n\tfor(int i = 0 ; i < v.size() ; ++i){\n\t\tindexes.emplace_back(mp[v[i]]);\n\t}\n\t//cout << v.size() << \"--\\n\";\n\tmemset(dp , -1 , sizeof(dp));\n\tfor(int i = 1 ; i < v.size() ; ++i){\n\t\t//tot = siz3[indexes[0]][indexes[i]];\n\t\tans = (ans + 1LL * solve(0 , i) * pw2[siz3[indexes[0]][indexes[i]]]) % mod;\n\t\t//cout << \"WTF\\n\";\n\t}\n\t//cout << ans << endl;\n}\nvoid pre(){\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tfor(int j = 1 ; j <= n ; ++j){\n\t\t\tif(i == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsiz3[i][j] = 0;\n\t\t\tint qlx = min(arr[i].x , arr[j].x);\n\t\t\tint qrx = max(arr[i].x , arr[j].x);\n\t\t\tint qly = min(arr[i].y , arr[j].y);\n\t\t\tint qry = max(arr[i].y , arr[j].y);\n\t\t\tfor(int k = 1 ; k <= n ; ++k){\n\t\t\t\tif(k != i && k != j){\n\t\t\t\t\tif(arr[k].x >= qlx && arr[k].x <= qrx && arr[k].y >= qly && arr[k].y <= qry && orient(arr[i] , arr[k] , arr[j]) == 0){\n\t\t\t\t\t\t++siz3[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tfor(int j = i + 1 ; j <= n ; ++j){\n\t\t\tfor(int k = j + 1 ; k <= n ; ++k){\n\t\t\t\tint res = 0;\n\t\t\t\tfor(int l = k + 1 ; l <= n ; ++l){\n\t\t\t\t\tres += inside(arr[i] , arr[j] , arr[k] , arr[l]);\n\t\t\t\t}\n\t\t\t\tsiz2[i][j][k] = siz2[i][k][j] = siz2[j][i][k] = siz2[j][k][i] = siz2[k][i][j] = siz2[k][j][i] = res;\n\t\t\t}\n\t\t}\n\t}\n\tmp.clear();\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tmp[arr[i]] = i;\n\t}\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tarr[i].read();\n\t}\n\tans = 0;\n\tpw2[0] = 1;\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tpw2[i] = (2LL * pw2[i - 1]) % mod;\n\t}\n\tpre();\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tsolve(i);\n\t}\n\tprintf(\"%d\\n\" , ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=1;//pow_binary_mod(2,N,M);\n\tfor(int _=0;_<N;_++)r=r*2%M;\n\tset<L>se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\t//if(se.find({i,j})!=se.end())continue;\n\t\tL l(v[i],v[j]);\n\t\tvector<int>x={i,j};\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectSP(l,v[k]))x.push_back(k);\n\t\tint q=1;//pow_binary_mod(2,x.size()-2,M)\n\t\tfor(int _=0;_<x.size()-2;_++)q=q*2%M;\n\t\tr=(r-q)%M;\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\t//se.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tr=(r-N-1)%M;\n\tprintf(\"%d\\n\",(r+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\n\nint N;\nint xs[300], ys[300], finished[300][300];\nconst ll MOD = 998244353ll;\n\ntemplate <typename T>\nT expt(T a, T n, T mod = std::numeric_limits<T>::max()){\n    T res = 1;\n    while(n){\n        if(n & 1){res = res * a % mod;}\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint cross(int x1, int y1, int x2, int y2){\n    return x1 * y2 - x2 * y1;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    std::cin >> N;\n    for(int i=0;i<N;++i){\n        std::cin >> xs[i] >> ys[i];\n    }\n\n    ll score = (expt<ll>(2ll, N, MOD) - N - 1) % MOD;\n    if(score < 0){score += MOD;}\n    \n    for(int i=0;i<N;++i){\n        for(int j=i+1;j<N;++j){\n            if(finished[i][j]){continue;}\n\n            vector<int> v;\n            for(int k=0;k<N;++k){\n                if(cross(xs[j] - xs[i], ys[j] - ys[i], xs[k] - xs[i], ys[k] - ys[i]) == 0){\n                    v.emplace_back(k);\n                }\n            }\n\n            int n = v.size();\n            for(int k=0;k<n;++k){\n                for(int l=k+1;l<n;++l){\n                    finished[v[k]][v[l]] = true;\n                }\n            }\n\n            score = (score - (expt<ll>(2ll, n, MOD) - n - 1)) % MOD;\n            if(score < 0){score += MOD;}\n        }\n    }\n\n    std::cout << score << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint cnt[201][201] = {};\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nlong long moving[1000] = {};\nint main() {\n#define int long long\n\tvector<pair<int, int>> inputs;\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tinputs.push_back(make_pair(a, b));\n\t}\n\tmoving[0] = 1;\n\tfor (int i = 1; i < 1000; ++i) {\n\t\tmoving[i] = moving[i - 1] * 2;\n\t\tmoving[i] %= MOD;\n\t}\n\tlong long ans = moving[n];\n\tlong long tmp = n + 1;\n\tmap<tuple<long long, long long, long long>, int> edges;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int q = i + 1; q < n; ++q) {\n\t\t\tif (cnt[i][q] == 1) break;\n\t\t\tlong long A = inputs[q].second - inputs[i].second;\n\t\t\tlong long B = -(inputs[q].first - inputs[i].first);\n\t\t\tlong long C = (inputs[q].second - inputs[i].second) * inputs[i].first - (inputs[q].first - inputs[i].first) * inputs[i].second;\n\t\t\tlong long geko = 0;\n\t\t\tif (A == 0) {\n\t\t\t\tgeko = llabs(B);\n\t\t\t}\n\t\t\telse if (B == 0) {\n\t\t\t\tgeko = llabs(A);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeko = gcd(llabs(A), llabs(B));\n\t\t\t}\n\t\t\tif (geko == 0) {\n\t\t\t\tgeko = llabs(C);\n\t\t\t}\n\t\t\telse if (C == 0) {\n\t\t\t\tgeko = llabs(geko);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeko = gcd(llabs(C), llabs(geko));\n\t\t\t}\n\t\t\tif (geko != 0) {\n\t\t\t\tA /= geko;\n\t\t\t\tB /= geko;\n\t\t\t\tC /= geko;\n\t\t\t}\n\t\t\tif (A < 0) {\n\t\t\t\tA = -A;\n\t\t\t\tB = -B;\n\t\t\t\tC = -C;\n\t\t\t}\n\t\t\tedges[make_tuple(A, B, C)]++;\n\t\t}\n\t}\n\tfor (auto i = edges.begin(); i != edges.end(); ++i) {\n\t\tint cnt = 0;\n\t\tfor (int q = 1;; ++q) {\n\t\t\tcnt += q;\n\t\t\tassert(cnt <= n * n * n);\n\t\t\tif (i->second == cnt) {\n\t\t\t\ttmp += moving[q + 1] - (q + 1) - 1;\n\t\t\t\ttmp += MOD;\n\t\t\t\ttmp %= MOD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans + (MOD - tmp)) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if defined(LOCAL)\n#define PROBLEM_NAME \"c\"\nconst double _max_double_error = 1e-9;\n#include \"testutils.h\"\n#define L(x...) debug(x)\n#else\n#define L(x...) (x)\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ii = pair<int,int>; using vii = vector<ii>;\nusing l = long long; using vl = vector<l>; using vvl = vector<vl>;\nusing ll = pair<l,l>; using vll = vector<ll>; using vvll = vector<vll>;\nusing lu = unsigned long long;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vd = vector<double>; using vvd = vector<vd>;\nusing mll = unordered_map<l, l>;\nconst l INF = numeric_limits<l>::max();\nconst double EPS = 1e-10; static constexpr auto PI = acos(-1);\nconst l e0=1, e3=1000, e5=100000, e6=10*e5, e7=10*e6, e8=10*e7, e9=10*e8;\nconst char lf = '\\n';\n#define all(x) begin(x), end(x)\n#define F(a,b,c) for (l a = l(b); a < l(c); a++)\n#define B(a,b,c) for (l a = l(c) - 1; a >= l(b); a--)\n\nl gcd(l a, l b) {\n  while (b) { l t = b; b = a % b; a = t; }\n  return a;\n}\n\nl lcm(l a, l b) { return a * b / gcd(a, b); }\n\nl sign(l n) {\n  if (n < 0) return -1;\n  if (n == 0) return 0;\n  return 1;\n}\n\n// conruent modulo, works for negative\nl cong(l x, l mod) {\n  return (x % mod + mod) % mod;\n}\n\n// (a * b) % mod, safe for l near max\nl mult_mod(l a, l b, l mod) {\n  l x = 0;\n  while (b) {\n    if (b % 2) x = (x + a) % mod;\n    a = (a * 2) % mod;\n    b /= 2;\n  }\n  return x;\n}\n\n// (base^power) % mod, safe for l near max\nl pow_mod(l base, l power, l mod) {\n  l r = 1;\n  while (power) {\n    if (power % 2) r = mult_mod(r, base, mod);\n    base = mult_mod(base, base, mod);\n    power /= 2;\n  }\n  return r;\n}\n\nl divup(l a, l b) { // ceil div\n  return (a + b - 1) / b;\n}\n\n// return gcd(a, b) and set x, y: a * x + b * y = gcd(a, b)\nl extended_euclid(l a, l b, l& x, l& y) {\n  if (b == 0) { x = 1; y = 0; return a; }\n  l d = extended_euclid(b, a % b, x, y);\n  l t = y;\n  y = x - (a / b) * y;\n  x = t;\n  return d;\n}\n\n// return b: a * b = 1 (mod n)\nl inverse_mod(l a, l n) {\n  l x, y;\n  l d = extended_euclid(a, n, x, y);\n  if (d != 1) return 0;\n  return cong(x, n);\n}\n\n// single combintions k from n\nl nCr(l n, l k, l mod) {\n  l a = 1;\n  for (l i = n; i > n - k; i--) a = mult_mod(a, i, mod);\n  l b = 1;\n  F(i, 1, k + 1) b = mult_mod(b, i, mod);\n  b = inverse_mod(b, mod);\n  return mult_mod(a, b, mod);\n}\n\n// precompute all combinations up to (n n)\nvvl combinations(l n, l mod) {\n  vvl c(n + 1, vl(n + 1));\n  F(i, 0, n) {\n    c[i][0] = 1;\n    F(j, 1, i + 1) {\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n    }\n  }\n  return c;\n}\n// a / b\nstruct Rat {\n  l a, b;\n  bool operator < (Rat const& rhs) const {\n    if (rhs.b == 0 and b == 0) {\n      return a < rhs.a;\n    }\n    if (b == 0) return a < 0;\n    if (rhs.b == 0) return rhs.a > 0;\n    return a * rhs.b < rhs.a * b;\n  }\n\n  void set(l na, l nb) {\n    a = na; b = nb;\n    normalize();\n  }\n\n  void set(l na) {\n    set(na, 1);\n  }\n\n  void normalize() {\n    if (b < 0 and a != 0) {\n      a = -a;\n      b = -b;\n    }\n    l g = gcd(abs(a), abs(b));\n    assert(g);\n    a /= g;\n    b /= g;\n    if (b == 0) a = sign(a);\n    if (a == 0) b = sign(b);\n  }\n};\n\nostream& operator << (ostream& s, const Rat& p) {\n  s << p.a << \" / \" << p.b;\n  return s;\n}\n\nstruct Line {\n  Rat x0, d;\n\n  bool operator < (Line const& rhs) const {\n    if (x0 < rhs.x0) return true;\n    if (rhs.x0 < x0) return false;\n    return d < rhs.d;\n  }\n};\n\nl const MOD = 998244353;\n\nl set2(l n) {\n  return cong(pow_mod(2, n, MOD) - n - 1, MOD);\n}\n\nvoid solve(istream& cin, ostream& cout) {\n  l n; cin >> n;\n  vl x(n), y(n);\n  F(i, 0, n) cin >> x[i] >> y[i];\n  map<Line, l> m;\n  F(i, 0, n) F(j, i + 1, n) {\n    Line q;\n    q.d.set(y[j] - y[i], x[j] - x[i]);\n    if (q.d.b == 0) q.d.a = 1;\n    if (y[i] == y[j]) {\n      q.x0.set(y[i]);\n      q.d.set(-1, 0);\n    } else {\n      q.x0.set(x[i] * (y[j] - y[i]) - y[i] * (x[j] - x[i]), y[j] - y[i]);\n    }\n    // cerr << q.x0 << ' ' << q.d << endl;\n    m[q]++;\n  }\n  l answer = set2(n);\n  for (auto p : m) {\n    l t = p.second;\n    t = round(sqrt(8 * t + 1) + 1) / 2;\n    // cerr << p.second << ' ' << t << endl;\n    answer = cong(answer - set2(t), MOD);\n  }\n  cout << answer << lf;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout << fixed << setprecision(15);\n#if defined(LOCAL)\n  // _generate_random_test = generate_random;\n  // _solve_brute = solve_brute;\n  // _player_b = player_b;\n  // _custom_solution_checker = solution_checker;\n  maybe_run_tests(cin, cout);\n#else\n  solve(cin, cout);\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <string>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <random>\n#include <chrono>\nusing namespace std;\n\nint n;\nconst int maxn = 205;\n\nstruct P{\n    int x, y;\n    P(){}\n    P(int _x, int _y):x(_x), y(_y){}\n    P operator - (P p){return P(x-p.x, y-p.y);}\n    int det(P p){return x * p.y - y * p.x;}\n    void read(){\n        cin >> x >> y;\n    }\n}p[maxn], p1[maxn];\n\nconst int mod = 998244353;\n\nbool cmp(P a, P b){\n    return a.det(b) < 0; \n}\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nvoid sub(int &a, int b){\n    a -= b;\n    if(a < 0)\n        a += mod;\n}\n\nint qpow(int a, int n){\n    int ret = 1;\n    while(n > 0){\n        if(n & 1)\n            ret = 1LL * ret * a % mod;\n        a = 1LL * a * a % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint main(){\n    cin >> n;\n    for(int i = 1;i <= n;i++){\n        p[i].read();\n    }\n    int ans = qpow(2, n);\n    sub(ans, 1);\n    sub(ans, n);\n    sub(ans, n * (n - 1) / 2);\n    for(int i = 1;i <= n;i++){\n        for(int j = i + 1;j <= n;j++){\n            int num = 0;\n            for(int k = j + 1;k <= n;k++){\n                if((p[i] - p[j]).det(p[j] - p[k]) == 0){\n                    num++;\n                }\n            }\n            int tmp = qpow(2, num);\n            sub(tmp, 1);\n            sub(ans, tmp);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353LL\n#define EPS 1e-9\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y;\n\tdata(){}\n\tdata(int xx,int yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn atan2(y,x)<atan2(d.y,d.x);\n\t}\n};\n\nint n;\ndata d[205];\nll two[205];\nbool flag[205][205];\nll res=0;\n\nbool check(int f,int t,int vx,int vy){\n\tif(vx==0){\n\t\treturn d[f].x==d[t].x;\n\t}\n\tif(vy==0){\n\t\treturn d[f].y==d[t].y;\n\t}\n\tint sax=d[t].x-d[f].x;\n\tint say=d[t].y-d[f].y;\n\treturn (sax*vy-say*vx)==0;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\ttwo[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\ttwo[i]=two[i-1]*2LL%MOD;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&d[i].x,&d[i].y);\n\t}\n\tll res=two[n];\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(flag[i][j])continue;\n\t\t\tint vx=d[i].x-d[j].x;\n\t\t\tint vy=d[i].y-d[j].y;\n\t\t\tvector<int> vec;\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(check(j,k,vx,vy)){\n\t\t\t\t\tvec.push_back(k);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres-=two[cnt];\n\t\t\tres+=MOD;\n\t\t\tres%=MOD;\n\t\t\tres+=cnt+1;\n\t\t\tres%=MOD;\n\t\t\tfor(int k=0;k<vec.size();k++){\n\t\t\t\tfor(int l=0;l<vec.size();l++){\n\t\t\t\t\tflag[k][l]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres-=n+1;\n\tres+=MOD;\n\tres%=MOD;\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FI first\n#define SE second\n#define PB push_back\n#define ll long long\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ROF(i,a,b) for(int i=b-1;i>=a;i--)\n#define YES(i) cout<<(i?\"YES\":\"NO\")<<endl\n#define Yes(i) cout<<(i?\"Yes\":\"No\")<<endl\n#define co(i) cout<<i<<endl\n#define fcout cout<<fixed<<setprecision(10)\n#define uni(i) i.erase(unique(i.begin(), i.end()), i.end());\nusing namespace std;\n\nconst int INF=1e9+7;\nconst int MOD=998244353;\n\ntypedef pair<int,int> PA;\ntypedef pair<int,PA> PA2;\n\nint comb[201][201];\n\nvoid comb_prepair(){\n    memset(comb,0,sizeof(comb));\n    FOR(i,1,201){\n        FOR(j,0,i+1){\n            if(j==0||j==i) comb[i][j]=1;\n            else (comb[i][j]=comb[i-1][j-1]+comb[i-1][j])%=MOD;\n        }\n    }\n}\n\nint gcd(int a,int b){\n    a=abs(a); b=abs(b);\n    if(a==0||b==0) return a+b;\n    else if(a>=b) return gcd(a%b,b);\n    else return gcd(a,b%a);\n}\n\nint main(){\n    int n; cin>>n;\n    vector<PA2> v;\n    vector<PA> z;\n    FOR(i,0,n){\n        int x,y; cin>>x>>y;\n        z.PB(PA(x,y));\n    }\n    ll ans=0;\n    if(n>=3){\n        comb_prepair();\n        FOR(i,0,n){\n            FOR(j,i+1,n){\n                int a=z[i].FI, b=z[i].SE, c=z[j].FI, d=z[j].SE;\n                int s=b-d, t=a-c, u=b*c-a*d;\n                if(s<0||(s==0&&t<0)){\n                    s*=-1; t*=-1; u*=-1;\n                }\n                int g=gcd(gcd(s,t),u);\n                s/=g; t/=g; u/=g;\n                v.PB(PA2(s,PA(t,u)));\n            }\n        }\n        //co(\"test\");\n        v.PB(PA2(INF,PA(INF,INF)));//番兵\n        sort(v.begin(),v.end());\n        FOR(i,3,n+1){\n            ans+=comb[n][i];\n            ans%=MOD;\n        }\n        PA2 p=v[0];\n        int k=1;\n        int b[20000]={};\n        FOR(i,1,201){\n            b[i*(i-1)/2]=i;\n        }\n        /*\n        FOR(i,0,v.size()){\n            printf(\"%d %d %d\\n\",v[i].FI,v[i].SE.FI,v[i].SE.SE);\n        }\n        */\n        FOR(i,1,v.size()){\n            PA2 q=v[i];\n            if(p!=q){\n                k=b[k];\n                //co(k);\n                FOR(j,3,k+1){\n                    ans+=(MOD-comb[k][j]);\n                    ans%=MOD;\n                }\n                k=1;\n                p=q;\n            }else{\n                k++;\n            }\n        }\n    }\n    co(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\nconst int mod=998244353;\nstruct point{int x,y;}p[210];\nbool vis[210][210];\nint multi(point p1,point p2,point p0)\n{\n\tint x1=p1.x-p0.x,y1=p1.y-p0.y;\n\tint x2=p2.x-p0.x,y2=p2.y-p0.y;\n\treturn x1*y2-x2*y1;\n}\nint n,bin[210],sta[210],top=0;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d %d\",&p[i].x,&p[i].y);\n\tbin[0]=1;for(int i=1;i<=n;i++) bin[i]=(bin[i-1]*2)%mod;\n\tint ans=(bin[n]-n-1)%mod;\n\tmemset(vis,false,sizeof(vis));\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j||vis[i][j]) continue;\n\t\t\ttop=0;sta[++top]=i;sta[++top]=j;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\tif(i!=k&&j!=k&&multi(p[i],p[j],p[k])==0) sta[++top]=k;\n\t\t\tfor(int k=1;k<=top;k++) for(int u=1;u<=top;u++) vis[sta[k]][sta[u]]=true;\n\t\t\t(ans-=(bin[top]-(top+1)))%=mod;\n\t\t\t//printf(\"ans:%d %d\\n\",ans,top);\n\t\t\t//for(int k=1;k<=top;k++) printf(\"%d \",sta[k]);printf(\"\\n\");\n\t\t}\n\t//(ans-=1)%=mod;\n\tprintf(\"%d\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nconst int mod=998244353;\nint n,x[205],y[205],tw[205]; \nint main()\n{\n\tcin>>n;tw[0]=1;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>x[i]>>y[i];\n\tfor(int i=1;i<=n;i++)\n\t\ttw[i]=tw[i-1]*2%mod;\n\tint ans=(tw[n]-n-1+mod)%mod; \n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<j;k++)\n\t\t\t\tif((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))\n\t\t\t\t\tcnt++;\n\t\t\tans=(ans-tw[cnt]+mod)%mod;\n\t\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1005,INF=1<<30;\nconst long double eps=0.000000000003;\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    int N;cin>>N;\n    vector<double> X(N),Y(N);\n    for(int i=0;i<N;i++){\n        cin>>X[i]>>Y[i];\n    }\n    \n    ll ans=rui(2,N);\n    ans+=mod-(N+1);\n    ans%=mod;\n    \n    for(int a=0;a<N;a++){\n        for(int b=a+1;b<N;b++){\n            ll cnt=0;\n            for(int k=0;k<N;k++){\n                if(k==a||k==b) continue;\n                long double i=atan2(X[b]-X[k],Y[b]-Y[k]),j=atan2(X[a]-X[k],Y[a]-Y[k]);\n                if(i>=0&&j<0) swap(i,j);\n                if(i*j<=0){\n                    if(abs(abs(i)-j)<eps) cnt++;\n                }\n            }\n            ans+=mod-rui(2,cnt);\n            ans%=mod;\n        }\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint x[201],y[201];\nconst int mod = 998244353;\n\nlong long int mypow(long long int x,long long int b){\n\tlong long int res=1;\n\twhile(b){\n\t\tif(b&1)\n\t\t\tres=res*x%mod;\n\t\tx=x*x%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>x[i]>>y[i];\n\tlong long int ans=mypow(2,n);\n\tans=((ans-1-n-n*(n-1)/2)%mod+mod)%mod;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint cnt=2;\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(k==i||k==j)\tcontinue;\n\t\t\t\tif((x[i]-x[j])*(y[k]-y[j])!=(x[k]-x[j])*(y[i]-y[j]))\n\t\t\t\t\tcontinue;\n\t\t\t\tif(k<i||k<j)\tbreak;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tans=(ans-mypow(2,cnt)+mod+1+cnt+cnt*(cnt-1)/2)%mod;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define mid (l+r>>1)\n#define M 202\n#define mod 998244353\nusing namespace std;\nLL read(){\n\tLL nm=0,fh=1;char cw=getchar();\n\tfor(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n\tfor(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n\treturn nm*fh;\n}\nbool vis[M];\nLL n,m,C[M][M],X[M],Y[M],T[M],ans;\nbool ol(LL t1,LL t2,LL t3){return (Y[t1]-Y[t2])*(X[t1]-X[t3])==(Y[t1]-Y[t3])*(X[t1]-X[t2]);}\nint main(){\n\tmemset(vis,false,sizeof(vis));\n\tn=read(),T[0]=1;\n\tfor(LL i=1;i<=n;i++) T[i]=(T[i-1]<<1)%mod,X[i]=read(),Y[i]=read();\n\tans=T[n],ans+=mod-n-1,ans%=mod;\n\tfor(LL i=1;i<=n;i++){\n\t\tmemset(vis,false,sizeof(vis));\n\t\tfor(LL j=i+1;j<=n;j++){\n\t\t\tif(vis[j]) continue;\n\t\t\tvis[j]=true;\n\t\t\tLL sum=2;\n\t\t\tbool fg=true;\n\t\t\tfor(LL k=1;k<i;k++) if(ol(i,j,k)) fg=false;\n\t\t\tif(!fg) continue;\n\t\t\tfor(LL k=j+1;k<=n;k++) if(ol(i,j,k)) sum++,vis[k]=true;\n\t\t\tans-=T[sum]-sum-1,ans+=mod,ans%=mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <climits>\nusing namespace std;\n#define MOD 998244353\n \nlong long powmod(int n){\n    long long ret = 1;\n    for(int i=0; i<n; i++){\n        ret *= 2;\n        ret %= MOD;\n    }\n    return ret;\n}\n \nbool isColinear(pair<int, int> xy1, pair<int, int> xy2, pair<int, int> xy3){\n    return (xy1.first-xy2.first)*(xy3.second-xy1.second)==(xy3.first-xy1.first)*(xy1.second-xy2.second);\n}\n \n \nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    vector<pair<int, int>> xy(N);\n    for(int i=0; i<N; i++) cin >> xy[i].first >> xy[i].second;\n \n    long long mns = 1 + N + N*(N-1)/2;\n    for(int i=0; i<N; i++){\n        for(int j=i+1; j<N; j++){\n            int cnt = 2;\n            for(int k=0; k<N; k++){\n                if(k == i || k == j) continue;\n                if(!isColinear(xy[i], xy[j], xy[k])) continue;\n                if(k < j) break;\n                cnt++;\n            }\n            if(cnt >= 3){\n                mns += powmod(cnt);\n                mns %= MOD;\n                mns += MOD - (1 + cnt + cnt*(cnt-1)/2);\n                mns %= MOD;\n            }\n        }\n    }\n    long long ans = powmod(N);\n    ans += MOD - mns;\n    ans %= MOD;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\nconst int N=205;\nconst int MOD=998244353;\nint n;\nint x[N],y[N];\nint Pow[N];\nint mul (int a,int b,int c)\n{\n\tint x_1=x[a]-x[c],y_1=y[a]-y[c];\n\tint x_2=x[b]-x[c],y_2=y[b]-y[c];\n\treturn x_1*y_2-x_2*y_1;\n}\nbool check (int x,int y)\n{\n\tfor (int u=1;u<y;u++)\n\t{\n\t\tif (u==x) continue;\n\t\tif (mul(x,y,u)==0)\t\n\t\t{\n\t\t\tprintf(\"NO:%d %d %d\\n\",x,y,u);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint dec (int x,int y)\t{x=x-y;return x<0?x+MOD:x;}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tPow[0]=1;for (int u=1;u<=n;u++) Pow[u]=Pow[u-1]*2%MOD;\n\tfor (int u=1;u<=n;u++) scanf(\"%d%d\",&x[u],&y[u]);\n\tint ans=dec(Pow[n],n+1);\n\tfor (int u=1;u<=n;u++)\n\t\tfor (int i=u+1;i<=n;i++)\n\t\t\tif (check(u,i))//这条线有没有枚举过\n\t\t\t{\n\t\t\t//\tprintf(\"YES:%d %d\\n\",u,i);\n\t\t\t\tint cnt=2;\n\t\t\t\tfor (int j=i+1;j<=n;j++) cnt=cnt+(mul(u,i,j)==0);\n\t\t\t\tans=dec(ans,dec(Pow[cnt],cnt+1));\n\t\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n#define DEBUG_IS_VALID \n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){cout << \"{\"; for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\nvoid _main();\nint main(){ cin.tie(0); ios::sync_with_stdio(false); _main(); return 0;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-12,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntemplate<typename T, int FAC_MAX> struct Comb { vector<T> fac, ifac;\n    Comb(){fac.resize(FAC_MAX,1);ifac.resize(FAC_MAX,1); for(int i = 1; i < FAC_MAX; i++)fac[i]=fac[i-1]*i;\n        ifac[FAC_MAX-1]=T(1)/fac[FAC_MAX-1];for(int i = FAC_MAX-2; i >= 1; i--)ifac[i]=ifac[i+1]*T(i+1);}\n    T aPb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b]; }\n    T aCb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b] * ifac[b]; }\n    T nHk(int n, int k) { if (n == 0 && k == 0) return T(1); if (n <= 0 || k < 0) return 0;\n        return aCb(n + k - 1, k); }}; // nHk = (n+k-1)Ck : n is separator\n\nusing mint =  ModInt<998244353>;\n\nvoid _main(){\n  int N; cin >> N ;\n  using vd = vector<double>;\n  using Pd = pair<double,double>;\n  vd x(N),y(N);\n  set<Pd> st;\n  rep(i,N) cin >> x[i] >> y[i] ;\n  rep(i,N-1) REP(j,i+1,N){\n    double a,b;\n    if(x[j]==x[i]){\n      a = 1e10; b = x[i];\n    }else{\n      a = (y[j]-y[i])/(x[j]-x[i]);\n      b = y[i] - a * x[i];\n    }\n    auto itr = lower_bound(st.begin(),st.end(),Pd(a-EPS,b-EPS));\n    bool exist = false;\n    for(auto&& p:st) exist |= abs(p.first-a)<EPS && abs(p.second-b)<EPS;\n    if(!exist) st.insert(Pd(a,b));\n  }\n  mint ans = mint(2)^N;\n  for(auto&& p:st){\n    int cnt = 0;\n    double a,b; tie(a,b) = p;\n    rep(i,N){\n      if(a!=1e10){\n        if(abs(y[i]-a*x[i]-b)<EPS) cnt++;\n      }else if(abs(x[i]-b)<EPS) cnt++;\n    }\n    ans -= (mint(2)^cnt) - mint(cnt+1);\n  }\n  ans -= mint(1+N);\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//HEAD_OF_CONFIG_\n\nstatic const int MOD=998244353;\nstatic const long long MODL=1000000000000000003LL;\nstatic const double eps=1e-8;\n\n//TAIL_OF_CONFIG_\n\n//HEAD_OF_JKI'S_HEADER_\n\n    //TYPEDEF\n    typedef long long lld;\n    typedef unsigned long long u64;\n    typedef pair<int, int> pii;\n\n    //COMPARE\n    template<class T> inline T MIN(const T x, const T y){ return (x<y)?x:y; }\n    template<class T> inline T MAX(const T x, const T y){ return (x>y)?x:y; }\n\n    template<class T> inline void UPDMIN(T &x, const T y){ if(x>y)x=y; }\n    template<class T> inline void UPDMAX(T &x, const T y){ if(x<y)x=y; }\n\n    //STL\n    template<class T>  inline int SIZE(const T &x){ return (int)x.size(); }\n    template<class T>  inline int LENGTH(const T &x){ return (int)x.length(); }\n    template<class T1, class T2> inline pair<T1, T2> MP(const T1 &x, const T2 &y){ return make_pair(x, y); }\n\n    //BIT\n    inline int BINT(const int x){ return 1<<x; }\n    inline lld BLLD(const int x){ return 1LL<<x; }\n    inline int BINT_TEST(const int s, const int x){ return (s&BINT(x))!=0; }\n    inline int BLLD_TEST(const lld s, const int x){ return (s&BLLD(x))!=0LL; }\n\n    template<class T> inline T LOWBIT(const T x){ return (x^(x-1))&x; }\n    template<class T> inline int BITCOUNT(const T x){ return (!x)?x:(1+BITCOUNT(x&(x-1))); }\n\n    //CONST VALUE\n    const double PI=acos(-1.0);\n    const double EPS=1e-5;\n\n    //CALCULATE\n    template<class T> inline T SQR(const T x){ return x*x; }\n    template<class T1, class T2> inline T1 POW(const T1 x, const T2 y){\n        if(!y)return 1;else if((y&1)==0){\n            return SQR(POW(x, y>>1));\n        }else return POW(x, y^1)*x;\n    }\n\n    //NUMBERIC\n    template<class T> inline T GCD(const T x, const T y){\n        if(x<0)return GCD(-x, y);\n        if(y<0)return GCD(x, -y);\n        return (!y)?x:GCD(y, x%y);\n    }\n    template<class T> inline T LCM(const T x, const T y){\n        if(x<0)return LCM(-x, y);\n        if(y<0)return LCM(x, -y);\n        return x*(y/GCD(x, y));\n    }\n    template<class T> inline T EEA(const T a, const T b, T &x, T &y){\n        /* a*x+b*y == GCD(a, b) == EEA(a, b, x, y) */\n        if(a<0){ T d=EEA(-a, b, x, y); x=-x; return d; }\n        if(b<0){ T d=EEA(a, -b, x, y); y=-y; return d; }\n        if(!b){\n            x=1; y=0; return a;\n        }else{\n            T d=EEA(b, a%b, x, y);\n            T t=x; x=y; y=t-(a/b)*y;\n            return d;\n        }\n    }\n    template<class T> inline vector<pair<T, int> > FACTORIZE(T x){\n        vector<pair<T, int> > ret;\n        if(x<0)x=-x;\n        for (T i=2;x>1;){\n            if(x%i==0){\n                int count=0;\n                for(;x%i==0;x/=i)count++;\n                ret.push_back(MP(i, count));\n            }\n            i++;if(i>x/i)i=x;\n        }\n        return ret;\n    }\n    template<class T> inline int ISPRIME(const T x){\n        if(x<=1)return 0;\n        for(T i=2; SQR(i)<=x; i++)if(x%i==0)return 0;\n        return 1;\n    }\n    template<class T> inline T EULARFUNCTION(T x){\n        vector<pair<T, int> > f=FACTORIZE(x);\n        for(typename vector<pair<T, int> >::iterator it=f.begin(); it!=f.end(); it++){\n            x=x/it->first*(it->first-1);\n        }\n        return x;\n    }\n    template<class T> inline T INVERSEE(const T a, const T b=MOD){\n        T x, y;\n        EEA(a, b, x, y);\n        return x?x:1;\n    }\n    int *PRIMELIST(const int til, int *length=NULL){\n        int *foo=(int*)malloc(sizeof(int)*(til+1));\n        int len=0;\n        memset(foo, 0, sizeof(int)*(til+1));\n        for(int i=2; i<=til; i++){\n            if(!foo[i])foo[len++]=i;\n            for(int j=0; j<len && foo[j]<=til/i; j++){\n                foo[foo[j]*i]=1;\n                if(i%foo[j]==0)break;\n            }\n        }\n        if(length!=NULL){\n            *length=len;\n        }\n        foo[len++]=0;\n        foo=(int*)realloc(foo, sizeof(int)*len);\n        return foo;\n    }\n\n    //REMINDER-LIZATION\n    template<class T> inline T MOD_STD(const T x, const T m=MOD){ return (x%m+m)%m; }\n    template<class T> inline void MOD_STD(T *x, const T m=MOD){ *x=(*x%m+m)%m; }\n    template<class T> inline T MOD_ADD(const T x, const T y, const T m=MOD){ return (x+y)%m; }\n    template<class T> inline void MOD_ADD(T *x, const T y, const T m=MOD){ *x=(*x+y)%m; }\n    template<class T> inline T MOD_MUL(const T x, const T y, const T m=MOD){ return (T)((1LL*x*y)%m); }\n    template<class T> inline void MOD_MUL(T *x, const T y, const T m=MOD){ *x=(T)((1LL*(*x)*y)%m); }\n    template<class T1, class T2> inline T1 MOD_POW(const T1 x, const T2 y, const T1 m=MOD){\n        if(y==0)return 1%m;else if((y&1)==0){\n            T1 z=MOD_POW(x, y>>1, m); return MOD_MUL(z, z, m);\n        }else return MOD_MUL(MOD_POW(x, y^1, m), x, m);\n    }\n    inline lld MODL_MUL(lld x, lld y, const lld m=MOD){\n        if(x<y)swap(x, y);\n        lld z=0LL;\n        while(y>0){\n            if(y&1){\n                MOD_ADD(&z, x, m);\n            }\n            MOD_ADD(&x, x, m);\n            y>>=1;\n        }\n        return z;\n    }\n    inline lld MODL_POW(const lld x, const lld y, const lld m=MOD){\n        if(y==0LL)return 1LL%m;else if((y&1)==0LL){\n            lld z=MODL_POW(x, y>>1, m); return MODL_MUL(z, z, m);\n        }else return MODL_MUL(MODL_POW(x, y^1, m), x, m);\n    }\n\n    //MATRIX\n    template<class T> class MATX{\n        private:\n            unsigned long hig, wid;\n            T *data;\n\n            void __init(){\n                this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                memset(this->data, 0, sizeof(T)*this->hig*this->wid);\n            }\n\n        public:\n            MATX(){ \n                this->hig=this->wid=1;\n                __init();\n            }\n            MATX(const unsigned long _len){\n                this->hig=this->wid=_len;\n                __init();\n            }\n            MATX(const unsigned long _hig, const unsigned long _wid){\n                this->hig=_hig;\n                this->wid=_wid;\n                __init();\n            }\n            MATX(const MATX &rhs){\n                this->hig=rhs.hig;\n                this->wid=rhs.wid;\n                this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=rhs.at(x, y);\n            }\n            ~MATX(){\n                free(this->data);\n            }\n\n            T & operator()(const unsigned long x, const unsigned long y){\n                if(x>=this->hig || y>=this->wid)return (*(T*)NULL);\n                return this->data[x*this->wid+y];\n            }\n\n            T * operator[](const unsigned long x){\n                if(x>=this->hig)return (T*)NULL;\n                return this->data+(x*this->wid);\n            }\n\n            MATX & operator=(const MATX &rhs){\n                if(this->hig!=rhs.hig || this->wid!=rhs.wid){\n                    free(this->data);\n                    this->hig=rhs.hig;\n                    this->wid=rhs.wid;\n                    this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                }\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=rhs.at(x, y);\n                return *this;\n            }\n\n            const MATX operator+(const MATX &opn) const{\n                MATX ret(*this);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        ret.data[x*ret.wid+y]+=opn.at(x, y);\n                return ret;\n            }\n            const MATX operator-(const MATX &opn) const{\n                MATX ret(*this);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        ret.data[x*ret.wid+y]-=opn.at(x, y);\n                return ret;\n            }\n            const MATX operator*(const MATX &opn) const{\n                MATX ret(this->hig, opn.wid);\n                const unsigned long len=MIN(this->wid, opn.hig);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        for(unsigned long z=0; z<len; z++)\n                            ret.data[x*ret.wid+y]+=this->at(x, z)*opn.at(z, y);\n                return ret;\n            }\n\n            const MATX mul(const MATX &opn) const{ return *this*opn; }\n            template<class T2> const MATX mul(const MATX &opn, const T2 m) const{\n                MATX ret(this->hig, opn.wid);\n                const unsigned long len=MIN(this->wid, opn.wid);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        for(unsigned long z=0; z<len; z++)\n                            MOD_ADD(&ret.data[x*ret.wid+y], MOD_MUL(this->at(x, z), opn.at(z, y), m), m);\n                return ret;\n            }\n\n            MATX & operator +=(const MATX &rhs){\n                *this=*this+rhs;\n                return *this;\n            }\n            MATX & operator -=(const MATX &rhs){\n                *this=*this-rhs;\n                return *this;\n            }\n            MATX & operator *=(const MATX &rhs){\n                *this=*this*rhs;\n                return *this;\n            }\n\n            const MATX pow(const unsigned long p) const{\n                MATX buff(*this), ret(this->hig, this->wid);\n                ret.set_one();\n                if(p>0)for(unsigned long i=1;;i<<=1){\n                    if(p&i)ret*=buff;\n                    buff*=buff;\n                    if(i>(p>>1))break;\n                }\n                return ret;\n            }\n            template<class T2> const MATX pow(const unsigned long p, const T2 m) const{\n                MATX buff(*this), ret(this->hig, this->wid);\n                ret.set_one();\n                if(p>0)for(unsigned long i=1;;i<<=1){\n                    if(p&i)ret=ret.mul(buff, m);\n                    buff=buff.mul(buff, m);\n                    if(i>(p>>1))break;\n                }\n                return ret;\n            }\n\n\n            const T at(const unsigned long x, const unsigned long y) const{\n                if(x>=this->hig || y>=this->wid)return 0;\n                return this->data[x*wid+y];\n            }\n\n            void show() const{\n                for(unsigned long x=0; x<this->hig; x++){\n                    for(unsigned long y=0; y<this->wid; y++)\n                        cout<<this->at(x, y)<<\" \";\n                    cout<<endl;\n                }\n            }\n\n            void set_one(){\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=(x==y)?1:0;\n            }\n\n    };\n\n    //Complex\n    template<class T> class complex_t{\n        public:\n        T r, i;//real part & imaginary part; x+yi\n        complex_t(T x=0.0, T y=0.0){ this->r=x; this->i=y; }\n        complex_t operator + (const complex_t &opn) const { return complex_t(this->r+opn.r, this->i+opn.i); }\n        complex_t operator - (const complex_t &opn) const { return complex_t(this->r-opn.r, this->i-opn.i); }\n        complex_t operator * (const complex_t &opn) const { return complex_t(this->r*opn.r-this->i*opn.i, this->r*opn.i+this->i*opn.r); }\n    };\n\n    template<class T> void fast_fourier_trans(complex_t<T> f[], const int len, const int is_dft){\n        for(int i=1, j=len>>1; i<len-1; i++){\n            if(i<j)swap(f[i], f[j]);\n            int k=len>>1;\n            while(j>=k){\n                j-=k;\n                k>>=1;\n            }\n            if(j<k)j+=k;\n        }\n        for(int h=2; h<=len; h<<=1){\n            complex_t<T> wn(cos(is_dft?(-2*PI/h):(2*PI/h)), sin(is_dft?(-2*PI/h):(2*PI/h)));\n            for(int i=0; i<len; i+=h){\n                complex_t<T> wm(1.0, 0.0);\n                for(int j=i; j<i+(h>>1); j++){\n                    complex_t<T> u = f[j];\n                    complex_t<T> t = wm*f[j+(h>>1)];\n                    f[j] = u+t;\n                    f[j+(h>>1)] = u-t;\n                    wm = wm*wn;\n                }\n            }\n        }\n        if(!is_dft){\n            for(int i=0; i<len; i++)\n                f[i].r/=len*1.0;\n        }\n    }\n\n    //MILLERRABIN\n    class MILLERRABIN{\n        private:\n        static const int prime_table[12];\n        int witness(lld a, lld d, lld s, lld n){\n            lld r=MODL_POW(a, d, n);\n            if(r==1 || r==n-1)return 0;\n            for(int i=0; i<s-1; i++){\n                r = MODL_MUL(r, r, n);\n                if(r==1)return 1;\n                if(r==n-1)return 0;\n            }\n            return 1;\n        }\n        public:\n        int test(const lld n){\n            if(n<=2LL) return 0;\n            lld p=n-1LL, s=0LL;\n            while(!(p&1)){ p>>=1;s++; }\n            for(int i=0; i<12 && this->prime_table[i]<n; i++){\n                if(witness(this->prime_table[i], p, s, n))return 0;\n            }\n            return 1;\n        }\n    };\n    const int MILLERRABIN::prime_table[12] = { 2, 3, 5, 7, 11, 13 ,17, 19, 23, 29, 31, 37 };\n\n    //Computational Geometry\n\n    template<class T> inline int fsign(const T x){\n        if(x>-eps && x<eps)return 0;\n        return (x<0.0)?-1:1;\n    }\n\n    template<class T> class point_t{\n        public:\n        T x, y;\n        int idx;\n        point_t (){\n            this->x=0.0;\n            this->y=0.0;\n        }\n        point_t (const T _x, const T _y){\n            this->x=_x;\n            this->y=_y;\n        }\n        point_t operator - (const point_t &rhs) const{\n            return point_t(this->x-rhs.x, this->y-rhs.y);\n        }\n        T operator ^ (const point_t &rhs) const{\n            return this->x*rhs.y - this->y*rhs.x;\n        }\n        T operator * (const point_t &rhs) const{\n            return this->x*rhs.x + this->y*rhs.y;\n        }\n        bool operator < (const point_t &rhs) const{\n            if(fsign(this->y-rhs.y)!=0)\n                return fsign(this->y-rhs.y)<0;\n            return fsign(this->x-rhs.x)<0;\n        }\n        T cross(const point_t &p, const point_t &q) const{\n            return (p-*this)^(q-*this);\n        }\n        void rotate(const double radian){\n            T x0=x, y0=y;\n            T sinr=sin(radian);\n            T cosr=cos(radian);\n            x=x0*cosr-y0*sinr;\n            y=x0*sinr+y0*cosr;\n        }\n        void rotate(const point_t &p, const double radian){\n            T x0=x-p.x, y0=y-p.y;\n            T sinr=sin(radian);\n            T cosr=cos(radian);\n            x=x0*cosr-y0*sinr+p.x;\n            y=x0*sinr+y0*cosr+p.y;\n        }\n        T dist2(const point_t &lhs, const point_t &rhs) const{\n            return (lhs-rhs)*(lhs-rhs);\n        }\n        T dist2(const point_t &rhs) const{\n            return (*this-rhs)*(*this-rhs);\n        }\n        T dist(const point_t &lhs, const point_t &rhs) const{\n            return sqrt((lhs-rhs)*(lhs-rhs));\n        }\n        T dist(const point_t &rhs) const{\n            return sqrt((*this-rhs)*(*this-rhs));\n        }\n    };\n\n    template<class T> class segment_t{\n        public:\n        point_t<T> p, q;\n        segment_t (){\n            this->p.x=this->p.y=0.0;\n            this->q.x=this->q.y=0.0;\n        }\n        template<class T2> segment_t (const point_t<T2> &_p, const point_t<T2> &_q){\n            this->p.x=_p.x;\n            this->p.y=_p.y;\n            this->q.x=_q.x;\n            this->q.y=_q.y;\n        }\n        segment_t (const T px, const T py, const T qx, const T qy){\n            this->p.x=px;\n            this->p.y=py;\n            this->q.x=qx;\n            this->q.y=qy;\n        }\n        T length() const{\n            return this->p.dist(this->q);\n        }\n        T length2() const{\n            return this->p.dist2(this->q);\n        }\n        int contain(const point_t<T> &pnt, const int ignore_endpoint=0) const{\n            if(ignore_endpoint){\n                return fsign((this->p-pnt)^(this->q-pnt))==0\n                    && fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <0\n                    && fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <0;\n            }else{\n                return fsign((this->p-pnt)^(this->q-pnt))==0\n                    && fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <=0\n                    && fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <=0;\n            }\n        }\n        int intersection(const segment_t &sa, const segment_t &sb, const int ignore_endpoint=0) const{\n            if(!ignore_endpoint){\n                if(sa.contain(sb.p) || sa.contain(sb.q) || sb.contain(sa.p) || sb.contain(sa.q))\n                    return 1;\n            }\n            return fsign(sa.p.cross(sa.q, sb.p))*fsign(sa.p.cross(sa.q, sb.q))<0\n                && fsign(sb.p.cross(sb.q, sa.p))*fsign(sb.p.cross(sb.q, sa.q))<0;\n        }\n        int intersection(const segment_t &rhs, const int ignore_endpoint=0) const{\n            return this->intersection(*this, rhs, ignore_endpoint);\n        }\n    };\n\n    template<class T> static int compare_pas(const void *x, const void *y, void *z){\n        const point_t<T> *p1 = (point_t<T>*)x;\n        const point_t<T> *p2 = (point_t<T>*)y;\n        const point_t<T> *p0 = (point_t<T>*)z;\n        int sgn = fsign(((*p1)-(*p0))^((*p2)-(*p0)));\n        if(sgn!=0)return -sgn;\n        return fsign(p0->dist2(*p1)-p0->dist2(*p2));\n    }\n    template<class T> void polar_angle_sort(point_t<T> *pnts, const int n){\n        int p=0;\n        for(int i=1; i<n; i++){\n            if(pnts[p]<pnts[i])p=i;\n        }\n        swap(pnts[0], pnts[p]);\n        qsort_r(pnts+1, n-1, sizeof(point_t<T>), compare_pas<T>, pnts);\n    }\n\n    template<class T> void graham(point_t<T> *pnts, const int n, int *idx, int &m){\n        polar_angle_sort(pnts, n);\n        m=0;\n        if(n<3)return;\n        idx[m++]=0;\n        idx[m++]=1;\n        for(int i=2; i<n; i++){\n            while(m>1 && fsign(pnts[idx[m-2]].cross(pnts[idx[m-1]], pnts[i]))<=0)m--;\n            idx[m++]=i;\n        }\n    }\n\n\n//TAIL_OF_JKI'S_HEADER\n\nint n, ans;\npoint_t<double> a[210];\n\nint vst[41000], pow2[210];\n\nint sub2(const int k){\n    return MOD_ADD(pow2[k], -k-1);\n}\n\nint main(){\n    pow2[0]=1;\n    for(int i=1; i<210; i++){\n        pow2[i]=MOD_MUL(pow2[i-1], 2);\n    }\n    while(scanf(\"%d\", &n)!=EOF){\n        for(int i=0; i<n; i++){\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            a[i].x=x*1.0;\n            a[i].y=y*1.0;\n            a[i].idx=i;\n        }\n        memset(vst, 0, sizeof(vst));\n        ans=sub2(n);\n        for(int s=0; s<n; s++){\n            polar_angle_sort(a, n-s);\n            for(int i=s+1; i<n; i++){\n                int j=i;\n                while(j+1<n && fsign((a[j+1]-a[s])^(a[i]-a[s]))==0)j++;\n                int mask=a[s].idx*n+a[i].idx;\n                if(!vst[mask]){\n                    for(int k=i; k<=j; k++){\n                        int curr=a[s].idx*n+a[k].idx;\n                        vst[curr]=1;\n                    }\n                    for(int x=i; x<=j; x++){\n                        for(int y=x+1; y<=j; y++){\n                            int curr=a[x].idx*n+a[y].idx;\n                            vst[curr]=1;\n                        }\n                    }\n                    MOD_ADD(&ans, -sub2(j-i+2));\n                }\n                i=j;\n            }\n        }\n        MOD_STD(&ans);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 998244353;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed sig) {\n    x = sig;\n    while(x < 0) x += MOD;\n    while(x >= MOD) x -= MOD;\n  }\n  unsigned get() const { return x; }\n\n  // 累乗\n  ModInt binpow(ModInt y, ModInt e) {\n    ModInt a = 1, p = y;\n    while(e>0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; --e;}\n    }\n    a %= MOD; x = a.get();\n    return a;\n  }\n  ModInt binpow(ll y, ll e) {\n    ModInt a = 1, p = y;\n    while(e>0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; --e;}\n    }\n    a %= MOD; x = a.get();\n    return a;\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // 代入\n  void operator=(ll b) { x = b; }\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  // ModInt and ModInt\n  ModInt &operator+=(ModInt that) {\n    x = ((unsigned long long)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((unsigned long long)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (unsigned long long)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (unsigned long long)x * that.binpow(that.x, MOD-2) % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (unsigned long long)x % that.x;\n    return *this;\n  }\n  // ModInt and long long\n  ModInt &operator+=(ll that) {\n    x = ((unsigned long long)x+that)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ll that) {\n    x = ((((unsigned long long)x-that)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ll that) {\n    x = (unsigned long long)x * that % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ll that) {\n    x = (unsigned long long)x * binpow(that, MOD-2).x % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ll that) {\n    x = (unsigned long long)x % that;\n    return *this;\n  }\n  // ModInt and ModInt\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n  // ModInt and ll\n  ModInt operator+(ll that)const{return ModInt(*this) += that;}\n  ModInt operator-(ll that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ll that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ll that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ll that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) {\n  os << a.x;\n  return os;\n}\nistream &operator>>(istream& is, mint &a) {\n  is >> a.x;\n  return is;\n}\n\nint x[205], y[205], pw[205];\n\nbool check( int i, int j, int k ) {\n\tif( y[i] > y[j] ) swap(i, j);\n\tif( y[k] < y[i] || y[k] > y[j] ) return false;\n\tif( x[i] > x[j] ) swap(i, j);\n\tif( x[k] < x[i] || x[k] > x[j] ) return false;\n\tint vx = x[k] - x[i], vy = y[k] - y[i];\n\tint wx = x[k] - x[j], wy = y[k] - y[j];\n\treturn vx*wy - vy*wx == 0;\n}\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) cin >> x[i] >> y[i];\n\n  pw[0] = 1;\n  FOR(i, 1, n+1) pw[i] = pw[i-1] * 2 % MOD;\n  mint ret = pw[n] - n;\n  REP(i, n) FOR(j, i+1, n) {\n    int cnt = 0;\n    REP(k, n) if(k!=i && k!=j && check(i,j,k)) ++cnt;\n    ret -= pw[cnt];\n  }\n  cout << ret-1 << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int int64_t\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) < norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[m][m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <int MOD> struct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tModInt(signed long long sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = (unsigned long long)x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n\tModInt inverse() const {\n\t\tsigned a = x, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tsigned t = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\tif (u < 0)\n\t\t\tu += MOD;\n\t\tModInt res;\n\t\tres.x = (unsigned)u;\n\t\treturn res;\n\t}\n};\ntemplate <int MOD> ostream &operator<<(ostream &os, const ModInt<MOD> &m) {\n\treturn os << m.x;\n}\ntemplate <int MOD> istream &operator>>(istream &is, ModInt<MOD> &m) {\n\tsigned long long s;\n\tis >> s;\n\tm = ModInt<MOD>(s);\n\treturn is;\n};\n// pow(mint(2), 1000) のように\ntemplate <int MOD> ModInt<MOD> pow(ModInt<MOD> a, unsigned long long k) {\n\tModInt<MOD> r = 1;\n\twhile (k) {\n\t\tif (k & 1)\n\t\t\tr *= a;\n\t\ta *= a;\n\t\tk >>= 1;\n\t}\n\treturn r;\n}\n\n//#define int long long を使っても大丈夫\nusing mint = ModInt<998244353>;\n\n// nCrで用いる\nvector<mint> fact, factinv;\n// nCrで用いる 予め計算しておく\nvoid nCr_compute_factinv(int N) {\n\tN = min(N, mint::Mod - 1);\n\tfact.resize(N + 1);\n\tfactinv.resize(N + 1);\n\tfact[0] = 1;\n\trep(i, 1, N + 1) fact[i] = fact[i - 1] * i;\n\tfactinv[N] = fact[N].inverse();\n\tfor (int i = N; i >= 1; i--)\n\t\tfactinv[i - 1] = factinv[i] * i;\n}\nmint nCr(int n, int r) {\n\tif (n >= mint::Mod)\n\t\treturn nCr(n % mint::Mod, r % mint::Mod) *\n\t\tnCr(n / mint::Mod, r / mint::Mod);\n\treturn r > n ? 0 : fact[n] * factinv[n - r] * factinv[r];\n}\n\nmint nHr(int n, int r) { return r == 0 ? 1 : nCr(n + r - 1, r); }\n\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N; cin >> N;\n\tvector<int>x(N), y(N); rep(i, 0, N) { cin >> x[i] >> y[i]; }\n\tmint ans = pow(mint(2), N) - 1 - N;\n\tusing L = bitset<205>;\n\tunordered_set<L>st;\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tL b;\n\t\t\trep(k, 0, N) {\n\t\t\t\tpii p0 = pii(x[k] - x[i], y[k] - y[i]);\n\t\t\t\tpii p1 = pii(x[j] - x[i], y[j] - y[i]);\n\t\t\t\tint z = p0.first*p1.second - p0.second*p1.first;\n\t\t\t\tif (z == 0)b.set(k);\n\t\t\t}\n\t\t\tif (st.count(b))continue;\n\t\t\tst.insert(b);\n\t\t\tint cnt = b.count();\n\t\t\tdump(cnt);\n\t\t\tans -= pow(mint(2), cnt) - cnt - 1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FI first\n#define SE second\n#define PB push_back\n#define ll long long\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ROF(i,a,b) for(int i=b-1;i>=a;i--)\n#define YES(i) cout<<(i?\"YES\":\"NO\")<<endl\n#define Yes(i) cout<<(i?\"Yes\":\"No\")<<endl\n#define co(i) cout<<i<<endl\n#define fcout cout<<fixed<<setprecision(10)\n#define uni(i) i.erase(unique(i.begin(), i.end()), i.end());\nusing namespace std;\n\nconst int INF=1e9+7;\nconst int MOD=998244353;\n\ntypedef pair<int,int> PA;\ntypedef pair<int,PA> PA2;\n\nint comb[201][201];\n\nvoid comb_prepair(){\n    memset(comb,0,sizeof(comb));\n    FOR(i,1,201){\n        FOR(j,0,i+1){\n            if(j==0||j==i) comb[i][j]=1;\n            else (comb[i][j]=comb[i-1][j-1]+comb[i-1][j])%=MOD;\n        }\n    }\n}\n\nint gcd(int a,int b){\n    if(a==0||b==0) return a+b;\n    else if(a>=b) return gcd(a%b,b);\n    else return gcd(a,b%a);\n}\n\nint main(){\n    int n; cin>>n;\n    vector<PA2> v;\n    vector<PA> z;\n    FOR(i,0,n){\n        int x,y; cin>>x>>y;\n        z.PB(PA(x,y));\n    }\n    ll ans=0;\n    if(n>=3){\n        comb_prepair();\n        FOR(i,0,n){\n            FOR(j,i+1,n){\n                int a=z[i].FI, b=z[i].SE, c=z[j].FI, d=z[j].SE;\n                int s=b-d, t=a-c, u=b*c-a*d;\n                if(s<0){\n                    s*=-1; t*=-1; u*=-1;\n                }\n                int g=gcd(gcd(s,t),u);\n                s/=g; t/=g; u/=g;\n                v.PB(PA2(s,PA(t,u)));\n            }\n        }\n        v.PB(PA2(INF,PA(INF,INF)));//番兵\n        sort(v.begin(),v.end());\n        FOR(i,3,n+1){\n            ans+=comb[n][i];\n            ans%=MOD;\n        }\n        PA2 p=v[0];\n        int k=1;\n        int b[20000]={};\n        FOR(i,1,201){\n            b[i*(i-1)/2]=i;\n        }\n        FOR(i,1,v.size()){\n            PA2 q=v[i];\n            if(p!=q){\n                k=b[k];\n                //co(k);\n                FOR(j,3,k+1){\n                    ans+=(MOD-comb[k][j]);\n                    ans%=MOD;\n                }\n                k=1;\n                p=q;\n            }else{\n                k++;\n            }\n        }\n    }\n    co(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint main(){\nwhile(1){for(;;){}}\n}"
  },
  {
    "language": "C++",
    "code": "// Crt. 2020-01-07  0946\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define PII pair<int, int>\n#define mk make_pair\n#define N 204\nusing namespace std;\nconst int Mod = 998244353;\n\ninline int fsp(int x, int p = Mod - 2) {\n    int res = 1;\n    while (p) {\n        if (p & 1) res = 1ll * res * x % Mod;\n        x = 1ll * x * x % Mod, p >>= 1;\n    } return res;\n}\n\ninline int getp(int x) {\n    return x < 0 ? -1 : 1;\n}\n\ninline int Abs(int x) {\n    return x < 0 ? -x : x;\n}\n\ninline int gcd(int x, int y) {\n    while (y ^= x ^= y ^= x %= y);\n    return x;\n}\n\nint n, x[N], y[N], m, z[N];\nPII k[N * N];\n\nint main(){\n#ifdef LOCAL_JUDGE\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i)\n        scanf(\"%d%d\", x + i, y + i);\n\n    for (int i = 1; i <= n; ++i)\n        z[i] = 1ll * i * (i - 1) / 2;\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n; ++j) {\n            int a = y[j] - y[i], b = x[j] - x[i];\n            //cout << i << \" \" << j << \" \" << a << \" \" << b << endl;\n            if (!a) { k[++m] = mk(-100000, y[i]); continue; }\n            if (!b) { k[++m] = mk(x[i], -100000); continue; } \n            int pa = getp(a), pb = getp(b);\n            if (pa < 0) pa = -pa, pb = -pb;\n            a = Abs(a), b = Abs(b);\n            int g = gcd(a, b);\n            a /= g, b /= g;\n            a *= pa, b *= pb;\n            k[++m] = mk(a, b);\n        }\n\n    sort(k + 1, k + m + 1);\n\n    long long ans = fsp(2, n) - 1 - n;\n\n//    for (int i = 1; i <= m; ++i)\n//        cout << k[i].first << \" \" << k[i].second << endl;\n\n    for (int i = 1, j; i <= m; i = j + 1) {\n        for (j = i; j < m && k[j + 1] == k[i]; ++j);\n        int pos = lower_bound(z + 1, z + n + 1, j - i + 1) - z;\n        //if (z[pos] != j - i + 1) cout<<z[pos]<<\" \"<<j-i+1<<\"#\"<<i<<endl;\n        ans -= fsp(2, pos) - 1 - pos, ans %= Mod;\n    }\n        \n    if (ans < 0) ans += Mod;\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <complex>\n#include <cstring>\n\nusing namespace std;\n\nconst int N = 200 + 5;\nconst int MOD = 998244353;\n\nint n;\nint o;\nint p2[N];\nint x[N], y[N];\nint cnt[N][N][N];\nlong long f[N][N];\n\nint cross(int i, int j, int k)\n{\n    long long x1 = x[j] - x[i], y1 = y[j] - y[i];\n    long long x2 = x[k] - x[j], y2 = y[k] - y[j];\n    return x1 * y2 - x2 * y1;\n}\n\nbool inside(int o, int i, int j, int k)\n{\n    return cross(i, j, o) > 0 && cross(j, k, o) >= 0 && cross(k, i, o) >= 0 && o != k;\n}\n\nint calc_on(int i, int j)\n{\n    int ans = 0;\n    for(int k = 0; k < n; ++ k) {\n        if (cross(i, j, k) == 0 && (x[k] - x[i]) * (x[k] - x[j]) + (y[k] - y[i]) * (y[k] - y[j]) < 0) \n            ans ++;\n    }\n    return ans;\n}\n\nint cmp(const int &a, const int &b)\n{\n    return (x[a] - x[o]) * (y[b] - y[o]) - (x[b] - x[o]) * (y[a] - y[o]) > 0;\n}\n\nvoid solve()\n{\n    cin >> n;\n    for(int i = 0; i < n; ++ i) {\n        scanf(\"%d%d\", x + i, y + i);\n    }\n\n    p2[0] = 1;\n    for(int i = 1; i < N; ++ i) {\n        p2[i] = p2[i - 1] * 2 % MOD;\n    }\n    memset(cnt, -1, sizeof cnt);\n    for(int i = 0; i < n; ++ i) {\n        for(int j = 0; j < n; ++ j) {\n            if (i == j) continue;\n            for(int k = 0; k < n; ++ k) {\n                if (k == i || k == j) continue;\n                if (cross(i, j, k) > 0) {\n                    cnt[i][j][k] = 0;\n                    for(int l = 0; l < n; ++ l) {\n                        cnt[i][j][k] += inside(l, i, j, k);\n                    }\n                }\n            }\n        }\n    }\n\n    long long ans = 0;\n\n    for(int st = 0; st < n; ++ st) {\n        o = st;\n        memset(f, 0, sizeof f);\n        vector<int> order;\n        order.push_back(st);\n        for(int i = 0; i < n; ++ i) {\n            if (make_pair(x[i], y[i]) > make_pair(x[st], y[st])) {\n                order.push_back(i);\n                f[st][i] = p2[calc_on(st, i)];\n            }\n        }\n        sort(order.begin() + 1, order.end(), cmp);\n        order.push_back(st);\n\n        for(int i = 1; i + 1 < order.size(); ++ i) {\n            int me = order[i];\n            for(int j = 0; j < i; ++ j) {\n                int from = order[j];\n                if (cnt[from][me][st] >= 0) \n                    (ans += f[from][me]) %= MOD;\n                if (f[from][me] == 0) continue;\n                for(int k = i + 1; k < order.size(); ++ k) {\n                    int to = order[k];\n                    if (cnt[from][me][to] >= 0) {\n                        (f[me][to] += f[from][me] * p2[cnt[from][me][to]]) %= MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 998244353;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 210\nint x[N], y[N];\nll c[N][N];\nmap<P, bool> used[N];\n\nint comb(int n, int k){\n\tif(c[n][k]) return c[n][k];\n\tif(k==n || k==0) return c[n][k] = 1;\n\treturn c[n][k] = (comb(n-1, k-1)+comb(n-1, k))%mod;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tll res = -(1+n+n*(n-1)/2), t = 1;\n\tint m = n;\n\twhile(m--) (t<<=1)%=mod;\n\tres += t;\n\trep(i, n){\n\t\tcin>>x[i]>>y[i];\n\t}\n\trep(i, n) for(int j = i+1; j < n; j++){\n\t\tint cnt = 2;\n\t\tint xx = x[j]-x[i], yy = y[j]-y[i];\n\t\tint g = __gcd(xx, yy);\n\t\txx /= g; yy /= g;\n\t\tif(xx<0){\n\t\t\txx *= -1;\n\t\t\tyy *= -1;\n\t\t}\n\t\tP p = P(xx, yy);\n\t\tif(used[i][p]) continue;\n\t\tused[i][p] = used[j][p] = true;\n\t\tfor(int k = j+1; k < n; k++){\n\t\t\tint xx2 = x[k]-x[i], yy2 = y[k]-y[i];\n\t\t\tint g2 = __gcd(xx2, yy2);\n\t\t\txx2 /= g2; yy2 /= g2;\n\t\t\tif(xx2<0){\n\t\t\t\txx2 *= -1;\n\t\t\t\tyy2 *= -1;\n\t\t\t}\n\t\t\tP p2 = P(xx2, yy2);\n\t\t\tif(used[k][p2]) continue;\n\t\t\tif(xx==xx2 && yy==yy2){\n\t\t\t\tused[k][p2] = true;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 3; k <= cnt; k++){\n\t\t\t(res-=comb(cnt, k))%=mod;\n\t\t}\n\t\tcerr<<cnt<<endl;\n\t}\n\tcout<<(res+mod)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\n\nconstexpr long long mod = 998244353;\nconst double pi = acos(-1);\n\nusing P = complex<long long>;\n\nlong long dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\nlong long cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nlong long gcd(long long a, long long b) {\n  a = abs(a);\n  b = abs(b);\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nP tomato(P a) {\n  long long g = gcd(a.real(), a.imag());\n  return P(a.real() / g, a.imag() / g);\n}\n\nP onion(P a) {\n  long long g = gcd(a.real(), a.imag());\n  return P(a.real() / g * 10010, a.imag() / g * 10010);\n}\n\nbool argcomp(std::complex<long long> p1, std::complex<long long> p2) {\n  bool a = p1.imag() > 0 || (p1.imag() == 0 && p1.real() >= 0);\n  bool b = p2.imag() > 0 || (p2.imag() == 0 && p2.real() >= 0);\n  if (a != b) return a;\n  long long c = p2.real() * p1.imag();\n  long long d = p1.real() * p2.imag();\n  if (c != d) return c < d;\n  return std::norm(p1) < std::norm(p2);\n}\n\nnamespace std {\n  bool operator<(const P &a, const P &b) {\n    return argcomp(a, b);\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<P> ps(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    ps[i] = P(x, y);\n  }\n\n  vector<pair<int, int>> es;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      es.emplace_back(i, j);\n    }\n  }\n  sort(es.begin(), es.end(), [&](pair<int, int> a, pair<int, int> b) {\n    P d = ps[a.second] - ps[a.first];\n    P e = ps[b.second] - ps[b.first];\n    if (cross(d, e) == 0 && dot(d, e) >= 0) {\n      return dot(ps[a.second] - ps[a.first], ps[b.first] - ps[a.first]) < 0;\n    } else {\n      return argcomp(d, e);\n    }\n  });\n\n  vector<vector<pair<int, P>>> qs(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      qs[i].emplace_back(0, ps[j] - ps[i]);\n      qs[i].emplace_back(1, ps[j] - ps[i]);\n    }\n    sort(qs[i].begin(), qs[i].end());\n  }\n\n  static int in[200][200][200];\n  static int on[200][200];\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      for (int k = 0; k < n; k++) {\n        if (i == k || j == k) continue;\n        in[i][j][k] = n;\n        for (tuple<int, int, int> turip : {make_tuple(i, j, k), make_tuple(k, i, j), make_tuple(j, k, i)}) {\n          int x, y, z;\n          tie(x, y, z) = turip;\n          P s = tomato(ps[y] - ps[x]);\n          P t = onion(ps[z] - ps[y]);\n          if (argcomp(s, t)) {\n            int L = lower_bound(qs[y].begin(), qs[y].end(), make_pair(0, s)) - qs[y].begin();\n            int R = upper_bound(qs[y].begin(), qs[y].end(), make_pair(0, t)) - qs[y].begin();\n            in[i][j][k] -= R - L;\n          } else {\n            int L = lower_bound(qs[y].begin(), qs[y].end(), make_pair(0, s)) - qs[y].begin();\n            int R = upper_bound(qs[y].begin(), qs[y].end(), make_pair(1, t)) - qs[y].begin();\n            in[i][j][k] -= R - L;\n          }\n        }\n        if (in[i][j][k] < 0) {\n          in[i][j][k] = 0;\n        }\n        on[i][j] += cross(ps[k] - ps[i], ps[j] - ps[i]) == 0 && dot(ps[k] - ps[i], ps[j] - ps[i]) > 0 && dot(ps[k] - ps[j], ps[i] - ps[j]) > 0;\n      }\n    }\n  }\n\n  vector<long long> two(n + 1);\n  two[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two[i] = two[i - 1] * 2 % mod;\n  }\n\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    vector<long long> dp1(n);\n    vector<long long> dp2(n);\n    for (auto e : es) {\n      int u = e.first;\n      int v = e.second;\n\n      if (u == i) {\n        assert(dp1[v] == 0);\n        dp1[v] = two[on[u][v]];\n      } else if (v == i) {\n        dp2[v] += dp2[u];\n      } else {\n        int c = on[i][v] + on[u][v] + in[i][u][v];\n        dp2[v] += dp1[u] * two[c];\n        dp2[v] += dp2[u] * two[c];\n      }\n      dp2[v] %= mod;\n    }\n    ans += dp2[i];\n    ans %= mod;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// EPS\nconstexpr double EPS = 1e-9;\n/// --- Geometory Library {{{ ///\nusing Point = complex<double>;\n#define X real()\n#define Y imag()\n#define dot(a, b) real(conj(a)*b)\n#define cross(a, b) imag(conj(a)*b)\n#define norm abs\n\n// +1 : ccw\n// -1 : cw\n// +2 : a--b--c\n// -2 : b--c--a\n//  0 : b--a--c\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if(cross(b, c) > EPS) return +1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b, c) < 0) return 0;\n  if(norm(b) < norm(c)) return +2;\n  return -2;\n}\n\ndouble arg(Point a, Point b) {\n  return acos(dot(a, b) / norm(a) / norm(b));\n}\n/// ---}}} ///\n\nconstexpr ll mod = 998244353;\n\n/// --- modulo Library {{{ ///\nconstexpr ll extgcd(ll a, ll b, ll& x, ll& y) {\n  if(b==0) {\n    x = 1; y = 0;\n    return a;\n  }\n  ll d = extgcd(b, a % b, y, x);\n  y -= (a / b) * x;\n  return d;\n}\nconstexpr ll modpow(ll a, ll b, ll mod = 1e9 + 7) {\n  a = (a % mod + mod) % mod;\n  ll r = 1;\n  while(b){\n    if(b & 1) r = r * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return r;\n}\nconstexpr ll modinv(ll a, ll mod = 1e9 + 7) {\n  a = (a % mod + mod) % mod;\n  ll x = 0, y = 0;\n  extgcd(a, mod, x, y);\n  return (x % mod + mod) % mod;\n}\ntemplate<int N, int mod = 1e9 + 7> struct Factorial {\n  int arr[N+1], inv[N+1];\n  int operator[](int i) const { return arr[i]; }\n  constexpr Factorial(): arr(), inv() {\n    arr[0] = 1;\n    for(int i = 1; i <= N; i++) {\n      arr[i] = (ll) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N], mod);\n    for(int i = N-1; i >= 0; i--) {\n      inv[i] = (ll) (i + 1) * inv[i + 1] % mod;\n    }\n  }\n  int C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    return (ll) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n};\n/// }}}--- ///\n\nconstexpr Factorial<200, mod> fact;\n\nbool done[200][200];\n\n// 点集合のうち,(同一直線上の点のみを選ぶ)を覗いた集合の数とスコアが一致\n// O(N^3)\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n; cin >> n;\n  vector<Point> p(n);\n  for(int i = 0; i < n; i++) {\n    int x, y; cin >> x >> y;\n    p[i] = Point(x, y);\n  }\n\n  ll ans = modpow(2, n, mod) - fact.C(n, 2) - n - 1;\n  ans %= mod;\n  for(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++) {\n    if(done[i][j]) continue;\n    int cnt = 2;\n    for(int k = j + 1; k < n; k++) {\n      if(abs(ccw(p[i], p[j], p[k])) != 1) cnt++, done[j][k] = 1;\n    }\n    ans -= fact.C(cnt, 3);\n    ans %= mod;\n  }\n  cout << (ans % mod + mod) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long xx,er[2010],n,x[1001],y[1001],mod=998244353,ans;\nint main()\n{\n\tscanf(\"%lld\",&n);\n\ter[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\t\ter[i]=(er[i-1]*2)%mod;\n\t}\n\tans=(er[n]-n-1+mod)%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int k=1;k<j;k++)\n\t\t\t{\n\t\t\t\tif((y[i]-y[k])*(x[j]-x[k])==(y[j]-y[k])*(x[i]-x[k]))\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=(ans-er[cnt]+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 200;\nconst int mod = 998244353;\nint x[N],y[N];\ntypedef pair<int,int> pii;\nint C(int i,int j){\n\treturn x[i]*y[j]-x[j]*y[i];\n}\nint ccw(int i,int j,int k){\n\treturn C(i,j)+C(j,k)+C(k,i);\n}\nint pp[N+1];\n#define mul(x,y) ((long long)(x)*(y)%mod)\nint main(){\n\tint n;scanf(\"%d\",&n);\n\tpp[0]=1;for(int i=1;i<=n;i++)pp[i]=mul(pp[i-1],2);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t}\n\tint ans=pp[n];\n\tans = (ans+mod-1)%mod;\n\tans = (ans+mod-n)%mod;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tint r=n;\n\t\t\tpii a = min(pii(x[i],y[i]),pii(x[j],y[j]));\n\t\t\tpii b = max(pii(x[i],y[i]),pii(x[j],y[j]));\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(ccw(i,j,k)==0 && a <= pii(x[k],y[k]) && pii(x[k],y[k])<=b)r--;\n\t\t\t}\n\t\t\tans-=pp[n-2-r];\n\t\t\tif(ans<0)ans+=mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"YES\"; }\n  string_type do_falsename() const { return \"NO\"; }\n};\n\nusing Point = complex<ld>;\n\nconst ld eps = 1e-10;\n\nbool comp(Point a, Point b) {\n  return real(a - b) * 1.347589 + imag(a - b) > 0;\n}\n\nld dot(Point a, Point b) { return real(conj(a) * b); }\nld cross(Point a, Point b) { return imag(conj(a) * b); }\n\nstruct Line {\n  Point a, b;\n  Line (Point p, Point q) : a(p), b(q) {;}\n};\n\nPoint is_ll(Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nvoid solve(ll N, vector<ll> x, vector<ll> y) {\n  const Point p1 = Point(3.293485, 9.49480194);\n  const Point p2 = Point(4.47101083, 9.1273874);\n  const Line line(p1, p2);\n  vector<Point> p(N);\n  REP(i,N) p[i] = Point(x[i], y[i]);\n  vector<pair<ld,int>> vec1;\n  vector<ld> vec2;\n  REP(i,N) REP(j,i) {\n    Line l(p[i], p[j]);\n    Point point = is_ll(l, line);\n    const ld d = abs(point - p1);\n    vec1.emplace_back(d, i);\n    vec1.emplace_back(d, j);\n    vec2.push_back(d);\n  }\n  sort(ALL(vec2));\n  vector<ld> vec3;\n  for (ld x: vec2) {\n    if (vec3.empty() || abs(vec3.back() - x) > eps)\n      vec3.push_back(x);\n  }\n  const int m = vec3.size();\n  vector<set<int>> sets(m);\n  for (auto p: vec1) {\n    auto it = lower_bound(ALL(vec3), p.first - eps);\n    sets[it - begin(vec3)].insert(p.second);\n  }\n  vector<int> two(256);\n  const int mod = 998244353;\n  two[0] = 1;\n  REP(i,255) two[i+1] = two[i] * 2 % mod;\n  int res = two[N];\n  for (auto &s: sets) {\n    res = (res - (two[s.size()] - 1 - s.size()) + mod) % mod;\n  }\n  res -= N + 1;\n  cout << res << endl;\n}\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha << setprecision(12) << fixed;\n  cout.imbue(loc);\n  ll N;\n \tscanf(\"%lld\", &N);\n\tvector<ll> x(N-1+1);\n\tvector<ll> y(N-1+1);\n\tfor (int i = 0 ; i <= N-1 ; i++) {\n\t  scanf(\"%lld\", &x[i]);\n\t  scanf(\"%lld\", &y[i]);\n\t}\n\tsolve(N, x, y);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n \nusing namespace std;\n \n template<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define PB emplace_back\n#define MP make_pair \n#define SZ(a) int((a).size())\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SORT(c) sort((c).begin(),(c).end())\n//constant\n//--------------------------------------------\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\nconst double EPS=0.00001;\nconst LL mod=998244353;\nbool chk(PII a,PII b,PII c){\n    return ((b.first - a.first) * (c.second - a.second) - (b.second - a.second) * (c.first - a.first))==0;\n}\n\nint main(){\n    int N;cin>>N;\n    vector<PII>xy(N);\n    set<vector<PII>>st;\n    REP(i,N){\n        cin>>xy[i].first>>xy[i].second;\n    }\n    LL res=N+1;\n    REP(i,N)FOR(j,i+1,N){\n        LL cnt=2;\n        vector<PII>pi;\n        pi.PB(xy[i]);pi.PB(xy[j]);\n        REP(k,N)if(k!=i&&k!=j){\n            if(chk(xy[i],xy[j],xy[k])){\n                cnt++;pi.PB(xy[k]);\n            }\n        }\n        SORT(pi);\n        if(st.find(pi)==st.end()){\n            res+=pow(2,cnt)-cnt-1;\n            res%=mod;\n            //cout<<pow(2,cnt)-cnt-1<<endl;\n            st.insert(pi);\n        }\n    }\n    LL res2=1LL;\n    REP(i,N)res2=res2*2LL%mod;\n    cout<<(res2-res+mod)%mod<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\n#define ll long long\nconst int maxn = 1e5 + 100;\nconst int mod = 998244353;\n\nstruct point{\n    int x,y;\n}e[maxn];\n\nll ans=0;\n\nll pow_mod(ll a,ll b){\n    ll ret = 1;\n    while (b){\n        if(b&1) ret = ret*a%mod;\n        a = a*a%mod;\n        b >>=1;\n    }\n    return ret;\n}\n\nbool check(point a,point b,point c){\n    a.x-=c.x,a.y-=c.y;\n    b.x-=c.x,b.y-=c.y;\n    if(a.x*b.y-a.y*b.x==0)\n        return 1;\n    return 0;\n}\n\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    int n;\n    cin>>n;\n    for (int i = 0; i < n; ++i) {\n        cin>>e[i].x>>e[i].y;\n    }\n    ans = pow_mod(2,n)-n-1;\n    //cout<<pow_mod(2,n)<<endl;\n    //cout<<ans<<endl;\n    cout<<ans<<endl;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            int d=0;\n            for (int k = j+1; k < n; ++k) {\n                if(check(e[i],e[j],e[k]))\n                    d++;\n            }\n            ans = (ans -pow_mod(2,d)+mod)%mod;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <memory.h>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n\n#define REP(i,s,n) for(int (i)=s; (i)<(int)(n);(i)++)\n#define RIT(it,c) for(__typeof(c.begin()) it = c.begin();it!=c.end();it++)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)(x).size()\n#define MSET(m,v) memset(m,v,sizeof(m))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<LL> vL;\ntypedef vector<bool> vb;\ntypedef unordered_set<int> ui;\ntypedef pair<LL,LL> pLL;\n\nint N;\nvector<ii> PT;\n\n\n// For mod questions\nconst LL MOD = 998244353;\nint gcd(int x,int y){\n    if(x<y) swap(x,y);\n    if(!y) return x;\n    return gcd(y, x%y);\n}\ninline LL Add(LL x,LL y){return (x+y)%MOD; }\ninline LL Mul(LL x,LL y){return (x*y)%MOD; }\nvoid Ad(LL &x, LL y){\n    x += y;\n    if(x >= MOD) x %= MOD;\n}\nvoid Mu(LL &x, LL y){\n    x *= y;\n    if(x >= MOD) x %= MOD;\n}\nLL Pow(LL x, LL k){\n    LL ans = 1;\n    while(k){\n        if(1&k) Mu(ans, x);\n        Mu(x, x);\n        k >>= 1;\n    }\n    return ans;\n}\n\nclass ConvexScore{\n    vL pw2;\n    vector<vb> coline;\n    ii makeLine(int x, int y){\n        if(!x) return ii(0,1);\n        if(!y) return ii(1,0);\n        int m = gcd(abs(x), abs(y));\n        if(x >= 0) return ii(x/m, y/m);\n        else return ii(-x/m, -y/m);\n    }\n    void init(int N){\n        pw2.resize(N+1);\n        pw2[0] = 1;\n        for(int i=1;i<=N;++i) pw2[i] = Mul(pw2[i-1], 2);\n        coline = vector<vb>(N,vb(N,false));\n    }\n    inline LL cntGroup(LL m){ return Add(pw2[m], MOD - 1 - m - m*(m-1)/2); }\npublic:\n    LL totalScore(int N, vector<ii> &PT){\n        if(N<3) return 0;\n        init(N);\n        LL ans = 0, cnt = 0;\n        for(int i=0;i<N;++i){\n            map<ii,vi> line;\n            for(int j=i+1;j<N;++j) if(!coline[i][j]){\n                auto key = makeLine(PT[i].first-PT[j].first, PT[i].second-PT[j].second);\n                line[key].push_back(j);\n            }\n            for(auto p:line){\n                auto vec = p.second;\n                int nv = (int)vec.size();\n                if(nv<2) continue;\n                Ad(cnt, cntGroup(nv+1));\n                for(int j=0;j<nv;++j) for(int k = j+1;k<nv;++k) coline[j][k] = true;\n            }\n        }\n        ans = Add(cntGroup(N), MOD - cnt);\n        return ans;\n    }\n};\n\n\nint main(){\n    /*Write your code here*/\n    cin>>N;\n    PT.resize(N);\n    for(int i=0;i<N;++i) cin>>PT[i].first>>PT[i].second;\n    cout<<ConvexScore().totalScore(N, PT)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 202;\nconst ll MOD = 998244353;\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct vec\n{\n\tint x, y;\n\t\n\tvec (const int &x0 = 0, const int &y0 = 0) : x(x0), y(y0) {}\n\tvec operator + (const vec &t) const {return vec(x+t.x, y+t.y);}\n\tvec operator - (const vec &t) const {return vec(x-t.x, y-t.y);}\n};\n\nint crs(const vec &a, const vec &b)\n{\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint dot(const vec &a, const vec &b)\n{\n\treturn a.x*b.x + a.y*b.y;\n}\n\nint n;\nvec pot[MX];\nll pw2[MX];\n\nvoid input()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++) read(pot[i].x), read(pot[i].y);\n}\n\nvoid work()\n{\n\tpw2[0] = 1;\n\tfor(int i=1; i<=n; i++) pw2[i] = pw2[i-1]*2 % MOD;\n\tll ans = pw2[n] - n - 1;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=i+1; j<=n; j++)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tfor(int k=j+1; k<=n; k++)\n\t\t\t{\n\t\t\t\tif(crs(pot[k]-pot[i], pot[j]-pot[i]) == 0)\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = (ans + MOD - pw2[cnt]) % MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 210;\nconst int mod = 998244353;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nint n, xs[MAXN], ys[MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) std::cin >> xs[i] >> ys[i];\n\tint ans = pow(2, n);\n\treduce(ans -= n + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tint bak = 0;\n\t\t\tfor (int k = j + 1; k <= n; ++k)\n\t\t\t\tif ((xs[k] - xs[i]) * (ys[k] - ys[j]) == (xs[k] - xs[j]) * (ys[k] - ys[i]))\n\t\t\t\t\t++bak;\n\t\t\treduce(ans -= pow(2, bak));\n\t\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint N,X[202],Y[202];\n\nint gcd(int a, int b)\n{\n\treturn b ? gcd(b,a%b) : a;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=0;i<N;i++) scanf (\"%d %d\",&X[i],&Y[i]);\n\n\tlong long mod = 998244353;\n\tlong long pw[202] = {1,};\n\tfor (int i=1;i<=N;i++) pw[i] = pw[i-1] * 2 % mod;\n\n\tlong long ans = (pw[N] - 1 + mod - N) % mod;\n\n\tfor (int i=0;i<N;i++){\n\t\tmap<pair<int, int>, int> chk;\n\t\tfor (int j=i+1;j<N;j++){\n\t\t\tint dx = X[j] - X[i], dy = Y[j] - Y[i];\n\t\t\tint g = gcd(abs(dx),abs(dy));\n\t\t\tdx /= g; dy /= g;\n\t\t\tif (dx < 0 || (dx == 0 && dy < 0)) dx = -dx, dy = -dy;\n\t\t\tchk[{dx,dy}]++;\n\t\t}\n\n\t\tfor (auto &p : chk) ans = (ans + mod - pw[p.second] + 1) % mod;\n\t}\n\t\n\tprintf (\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mk make_pair\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nll pwr[210], mod=998244353;\nvoid pre(){\n  pwr[0]=1;\n  for(int i=1; i<=200; ++i){\n    pwr[i]=(pwr[i-1]*2)%mod;\n  }\n}\nll x[210], y[210];\nmap<pair<ll, ll>, ll> mp;\nint main(){\n  int n;\n  pre();\n  while(cin>>n){\n    for(int i=0; i<n; ++i){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    ll ans=pwr[n]-n-1, tmp1, tmp2, tmp;\n    for(int i=0; i<n; ++i){\n      mp.clear();\n      for(int j=i+1; j<n; ++j){\n        tmp1=(y[i]-y[j]);\n        tmp2=(x[i]-x[j]);\n        tmp=__gcd(tmp1, tmp2);\n        tmp1/=tmp;\n        tmp2/=tmp;\n        ++mp[mk(tmp1, tmp2)];\n      }\n      for(map<pair<ll, ll>, ll>::iterator it=mp.begin(); it!=mp.end(); ++it){\n        ans-=(pwr[it->second])-1;\n        ans%=mod;\n      }\n    }\n    ans%=mod;\n    if(ans<0)\n      ans+=mod;\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 998244353;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll po[210];\n\nint main() {\n    ll N;\n    cin >> N;\n    plglg pt[N];\n    REP(i, 0, N) {\n        ll x, y;\n        cin >> x >> y;\n        pt[i] = plglg(x, y);\n    }\n    sort(pt, pt + N);\n    po[0] = 1;\n    REP(i, 1, 210) {\n        po[i] = multiply(po[i - 1], 2);\n    }\n    xy_t pt2[N];\n    REP(i, 0, N) {\n        pt2[i] = xy_t(pt[i].first, pt[i].second);\n    }\n    ll difnum = 0;\n    REP(k, 0, N) {\n        vector<pdlg> vec;\n        xy_t base = pt2[k];\n        REP(i, k + 1, N) {\n            xy_t tar = pt2[i];\n            double ab = abs(tar - base);\n            xy_t dif = (tar - base) / ab;\n            double d = dif.imag();\n            bool ok = false;\n            REP(j, 0, vec.size()) {\n                pdlg p = vec[j];\n                if (abs(d - p.first) < eps) {\n                    vec[j].second++;\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok) {\n                vec.push_back(pdlg(d, 1));\n            }\n        }\n        REP(i, 0, vec.size()) {\n            ll p = vec[i].second;\n            if (p > 1) {\n                ll zero = 1;\n                ll one = p;\n                ll sum = zero + one;\n                difnum = modadd(difnum, modadd(po[p], - sum));\n            }\n        }\n    }\n    ll anssum = 1 + N + N * (N - 1) / 2;\n    //cout << anssum << \" \" << difnum << endl;\n    ll ans = modadd(po[N], - modadd(anssum, difnum));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(LL x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(LL x){write(x);putchar('\\n');}\nconst LL mod=998244353;\nconst int MAXN=205;\nstruct pt{int x,y;double pp;}w[MAXN],g[MAXN];int tot;\nint f[MAXN][MAXN],n,pre[MAXN][MAXN],l1[MAXN];\nint multi(pt p0,pt p1,pt p2)\n{\n\tint ux,uy,vx,vy;\n\tux=p0.x-p1.x;uy=p0.y-p1.y;\n\tvx=p0.x-p2.x;vy=p0.y-p2.y;\n\treturn ux*vy-vx*uy;\n}\nbool cmp(pt u1,pt u2){return u1.pp!=u2.pp?u1.pp<u2.pp:u1.y<u2.y;}\nbool check(pt u1,pt u2,pt u3,pt u4)\n{\n\tint g1=multi(u1,u2,u3),g2=multi(u1,u2,u4);\n\tif((g1<=0&&g2<=0)||(g1>=0&&g2>=0))return true;\n\treturn false;\n}\nbool ok(pt p0,pt p1,pt p2,pt p3)//p0~p1不能取 \n{\n\tif(multi(p0,p1,p3)==0)return false;\n\tif(!check(p0,p1,p2,p3)||!check(p1,p2,p0,p3)||!check(p2,p0,p1,p3))return false;\n\treturn true;\n}\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nint temp[MAXN];\nint ans;\nbool in(pt u1,pt u2,pt u3)\n{\n\tif(u2.x>u3.x)swap(u2,u3);\n\telse if(u2.x==u3.x&&u2.y>u3.y)swap(u2,u3);\n\tif(u1.x>=u2.x&&u1.x<=u3.x&&(u1.y>=u2.y&&u1.y<=u3.y||u1.y>=u3.y&&u1.y<=u2.y))return true;\n\treturn false;\n}\nvoid solve(int x)\n{\n\ttot=0;\n\tfor(int i=1;i<=n;i++)if(w[i].y>w[x].y||(w[i].y==w[x].y&&w[i].x>w[x].x))g[++tot]=w[i];\n\tfor(int i=1;i<=tot;i++)g[i].pp=atan2(g[i].y-w[x].y,g[i].x-w[x].x);\n\tsort(g+1,g+1+tot,cmp);\n\tmemset(pre,0,sizeof(pre));\n\tmemset(l1,0,sizeof(l1));\n\tfor(int i=1;i<=tot;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(multi(w[x],g[i],w[j])==0&&in(w[j],w[x],g[i]))\n\t\t\t\tl1[i]++;\n\t//printf(\"%d\\n\",x);\n\tfor(int i=1;i<=tot;i++)for(int j=1;j<=tot;j++)if(i!=j)\n\t{\n\t\tfor(int k=1;k<=n;k++)if(ok(w[x],g[i],g[j],w[k]))\n\t\t\tpre[i][j]++;\n\t\t//printf(\"%d %d %d\\n\",i,j,pre[i][j]);\n\t}\n//\tprintf(\"%d\\n\",x);\n//\tfor(int i=1;i<=tot;i++)printf(\"YES id=%d %d %d\\n\",i,g[i].x,g[i].y);\n\tmemset(f,0,sizeof(f));g[0]=w[x];\n//\tfor(int i=1;i<=tot;i++)f[0][i]=1;\n\tfor(int i=1;i<=tot;i++)\n\t\tfor(int j=i+1;j<=tot;j++)\n\t\t{\n\t\t\tfor(int k=0;k<i;k++)if(multi(g[k],g[i],g[j])>0)\n\t\t\t{\n\t\t\t\tint pt=pre[j][i];\n\t\t\t\tif(k==0)ad(f[i][j],temp[pt-1]);\n\t\t\t\telse ad(f[i][j],(LL)f[k][i]*temp[pt-1]%mod);\n\t\t\t}\n\t\t\tint pt=l1[j];\n\t\t\tad(ans,(LL)f[i][j]*temp[pt-2]%mod);\n//\t\t\tprintf(\"%d %d\\n\",j,(LL)f[i][j]*temp[pt-2]%mod);\n\t\t}\n}\nint main()\n{\n\ttemp[0]=1;for(int i=1;i<MAXN;i++)temp[i]=temp[i-1]*2%mod;\n\tn=read();\n\tfor(int i=1;i<=n;i++)w[i].x=read(),w[i].y=read();\n\tfor(int i=1;i<=n;i++)\n\t\tsolve(i);\n\tpr2(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long LL;\nconst int MOD=998244353;\nconst int N=205;\nint n;\nstruct qq\n{\n\tint x,y;\n\tvoid print ()\t{printf(\"%d %d\\n\",x,y);}\n}a[N],b[N];\nint tot;\nint ans;\nqq tmp;\nint mul (qq x,qq y,qq z)\n{\n\tint x1=x.x-z.x,y1=x.y-z.y;\n    int x2=y.x-z.x,y2=y.y-z.y;\n    return x1*y2-x2*y1;\n}\nint dis (qq x,qq y)\t{return (x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y);}\nbool cmp (qq x,qq y)\n{\n\tif (mul(x,y,tmp)==0) return dis(x,tmp)<dis(y,tmp);\n\treturn mul(x,y,tmp)>0;\n}\nbool check (qq x,qq y,qq z)//z是否在 (tmp,x,y)\n{\n\tif (mul(z,x,tmp)==0) return false;\n\tif (mul(z,y,x)>0) return false;\n\treturn true;\n}\nint f[N][N];\nint g[N][N];\nint mul (int x,int y)\t{return (LL)x*y%MOD;}\nint add (int x,int y)\t{x=x+y;return x>=MOD?x-MOD:x;}\nvoid solve (int x)\n{\n\ttot=0;tmp=a[x];\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\tif (a[u].y>a[x].y||(a[u].y>=a[x].y&&a[u].x>=a[x].x))\tb[++tot]=a[u];\n\t}\n\tsort(b+1,b+1+tot,cmp);\n//\tfor (int u=1;u<=tot;u++) b[u].print();\n\tfor (int u=1;u<=tot;u++)\t\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tg[u][i]=f[u][i]=0;\n\tfor (int u=1;u<=tot;u++)\n\t\tfor (int i=u+1;i<=tot;i++)//(1,u,i)\n\t\t{\n\t\t\tg[u][i]=1;\n\t\t\tfor (int k=u+1;k<i;k++)\n\t\t\t\tif (check(b[u],b[i],b[k]))\n\t\t\t\t\tg[u][i]=add(g[u][i],g[u][i]);\n\t\t}\n\tfor (int u=2;u<=tot;u++)\n\t{\n\t\tf[1][u]=1;\n\t\tfor (int i=2;i<u;i++)\n\t\t\tif (mul(b[i],b[u],b[1])==0)\n\t\t\t\tf[1][u]=add(f[1][u],f[1][u]);\n\t}\n\tfor (int u=1;u<=tot;u++)\n\t\tfor (int i=u+1;i<=tot;i++)\n\t\t\tfor (int k=i+1;k<=tot;k++)\n\t\t\t{\n\t\t\t\tif (mul(b[k],b[i],b[u])<0)\n\t\t\t\t{\n\t\t\t\t//\tprintf(\"YES:%d %d %d %d %d\\n\",u,i,k,f[u][i],g[i][k]);\n\t\t\t\t\tf[i][k]=add(f[i][k],mul(f[u][i],g[i][k]));\n\t\t\t\t}\n\t\t\t}\n\tfor (int u=2;u<=tot;u++)\n\t\tfor (int i=u+1;i<=tot;i++)\n\t\t{\n\t\t//\tprintf(\"%d %d %d\\n\",u,i,f[u][i]);\n\t\t\tans=add(ans,f[u][i]);\n\t\t}\n//\tsystem(\"pause\");\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int u=1;u<=n;u++)\tscanf(\"%d%d\",&a[u].x,&a[u].y);\n\tfor (int u=1;u<=n;u++) solve(u);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//A,Elebereth Gilthoniel mantae!\n//For Temeria!\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<cstdio>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cstring> \nusing namespace std;\nvector<long long> siz;long long vis[205][205];long long mod=998244353;\nlong long quipow(long long a,long long b)\n{\n    long long ans=1;\n     while(b)\n     {\n         if(b&1) ans=ans*a%mod;\n         b>>=1;\n         a=a*a%mod;\n     }\n     return ans%mod;\n}\nlong long fac[505],inv[505];\nvoid prepare()    \n{\n    fac[0]=fac[1]=1;\n    for(long long i=2;i<=500;i++)   fac[i]=fac[i-1]*i%mod;\n\n    inv[500]=quipow(fac[500],mod-2);\n    for(long long i=500-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\npair<double,double> p[505];\nint main()\n{\n \t//freopen(\"\",\"r\",stdin);\n\t//freopen(\"\",\"w\",stdout);\n\tprepare();\n\tlong long n;cin>>n;\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tcin>>p[i].first>>p[i].second;\n\t}\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tfor(long long j=0;j<n;j++)\n\t\t{\n\t\t\tvector<int> v;v.clear();\n\t\t\tif(i==j or(vis[i][j]==1)) continue;v.push_back(i);v.push_back(j);\n\t\t\tif(p[i].first==p[j].first)\n\t\t\t{\n\t\t\t\tlong long u=0;u++;u++;\n\t\t\t\tfor(long long t=0;t<n;t++)\n\t\t\t\t{\n\t\t\t\t\tif(i==t or j==t) continue;\n\t\t\t\t\tif(abs(p[t].first-p[i].first)<e-10)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.push_back(t);\n\t\t\t\t\t\tu++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u>2)siz.push_back(u);\n\t\t\t\tfor(int t=0;t<v.size();t++) for(int y=0;y<v.size();y++) vis[v[y]][v[t]]=1; \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble k=(p[i].second-p[j].second)/(p[i].first-p[j].first);\n\t\t\tdouble b=p[i].second-p[i].first*k;\n\t\t\tlong long u=0;u++;u++;\n\t\t\tfor(long long t=0;t<n;t++)\n\t\t\t{\n\t\t\t\tif(i==t or j==t) continue;\n\t\t\t\tif(abs(p[t].first*k+b-p[t].second)<=e-10)\n\t\t\t\t{\n\t\t\t\t\tv.push_back(t);\n\t\t\t\t\tu++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(u>2)siz.push_back(u);\n\t\t\tfor(int t=0;t<v.size();t++) for(int y=0;y<v.size();y++) vis[v[y]][v[t]]=1; \n\t\t}\n\t}\n\tlong long ans=0;long long y=n*(n-1);\n\tfor(long long i=3;i<=n;i++)\n\t{\n\t\ty=y*(n-i+1);y=y%mod;\n\t\tans+=y*inv[i];ans=ans%mod;\n\t}\n\tfor(long long i=0;i<siz.size();i++)\n\t{\n\t\ty=(siz[i])*(siz[i]-1);\n\t\tfor(long long j=3;j<=siz[i];j++)\n\t\t{\n\t\t\ty=y*(siz[i]-j+1);y=y%mod;\n\t\t\tans-=y*inv[j];ans=ans%mod;\n\t\t}\n\t}\n\tif(ans<0) ans+=mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 998244353;\nconst int maxn = 200 + 50;\nint n;\nll p[maxn];\nll x[maxn], y[maxn];\nmap<pair<ll, ll>, ll> mp;\nvoid pre(){\n    p[0] = 1;\n    for(int i = 1; i < maxn; i++){\n        p[i] = (p[i-1] * 2) % mod;\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    pre();\n    while(cin >> n){\n        for(int i = 0; i < n; i++)\n            cin >> x[i] >> y[i];\n        ll ans = p[n] - n - 1;//减去空集和单点集\n        ll deltay, deltax, k;\n        for(int i = 0; i < n; i++){\n            mp.clear();\n            for(int j = i+1; j < n; j++){\n                deltay = y[j] - y[i];\n                deltax = x[j] - x[i];\n                k = __gcd(deltay, deltax);\n                deltay/=k;\n                deltax/=k;\n                ++mp[{deltay,deltax}];\n                //mp记录共线的点，用pair是防止斜率为0，或者为小数\n            }\n            for(map<pair<ll, ll>, ll>::iterator iter = mp.begin(); iter != mp.end(); iter++){\n                ll tmp = p[iter->second] - 1;//除i点以外共线集的个数，减去只有一个i点的情况\n                ans = (ans - tmp + mod) % mod;\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\n\nconstexpr long long mod = 998244353;\n\nusing P = complex<int>;\n\nint dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\nint cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nnamespace std {\n  bool operator<(P a, P b) {\n    return atan2(a.imag(), a.real()) < atan2(b.imag(), b.real());\n  }\n}\n\nint gcd(int x, int y) {\n  x = abs(x);\n  y = abs(y);\n  if (y == 0) return x;\n  return gcd(y, x % y);\n}\n\nP unit(P a) {\n  int g = gcd(a.real(), a.imag());\n  return P(a.real() / g, a.imag() / g);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<P> ps(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    ps[i] = P(x, y);\n  }\n\n  vector<pair<int, int>> es;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      es.emplace_back(i, j);\n    }\n  }\n  sort(es.begin(), es.end(), [&](pair<int, int> a, pair<int, int> b) {\n    P d = ps[a.second] - ps[a.first];\n    P e = ps[b.second] - ps[b.first];\n    if (cross(d, e) == 0 && dot(d, e) >= 0) {\n      return dot(ps[a.second] - ps[a.first], ps[b.first] - ps[a.first]) < 0;\n    } else {\n      return d < e;\n    }\n  });\n\n  vector<vector<P>> qs(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      qs[i].push_back(ps[j] - ps[i]);\n    }\n    sort(qs[i].begin(), qs[i].end());\n    for (int j = 0; j < n - 1; j++) {\n      qs[i].push_back(qs[i][j]);\n    }\n  }\n\n  static int in[200][200][200];\n  static int on[200][200];\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      for (int k = 0; k < n; k++) {\n        if (i == k || j == k) continue;\n        for (tuple<int, int, int> t : {make_tuple(i, j, k), make_tuple(k, i, j), make_tuple(i, j, k)}) {\n          int x, y, z;\n          tie(x, y, z) = t;\n          int L = lower_bound(qs[y].begin(), qs[y].begin() + (n - 1), unit(ps[y] - ps[x])) - qs[y].begin();\n          if (L == n - 1) continue;\n          int R = lower_bound(qs[y].begin() + L, qs[y].begin() + (L + n - 1), unit(ps[z] - ps[y])) - qs[y].begin();\n        }\n        on[i][j] += cross(ps[k] - ps[i], ps[j] - ps[i]) == 0 && dot(ps[k] - ps[i], ps[j] - ps[i]) > 0 && dot(ps[k] - ps[j], ps[i] - ps[j]) > 0;\n      }\n    }\n  }\n\n  vector<long long> two(n + 1);\n  two[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two[i] = two[i - 1] * 2 % mod;\n  }\n\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    vector<long long> dp1(n);\n    vector<long long> dp2(n);\n    for (auto e : es) {\n      int u = e.first;\n      int v = e.second;\n\n      if (u == i) {\n        assert(dp1[v] == 0);\n        dp1[v] = two[on[u][v]];\n      } else if (v == i) {\n        dp2[v] += dp2[u];\n      } else {\n        int c = on[i][v] + on[u][v] + in[i][u][v];\n        dp2[v] += dp1[u] * two[c];\n        dp2[v] += dp2[u] * two[c];\n      }\n      dp2[v] %= mod;\n    }\n    ans += dp2[i];\n    ans %= mod;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\n\nconst int N = 203, mod = 998244353;\n\nstruct pnt {\n\tint x, y;\n\tinline void in() {scanf(\"%d%d\", &x, &y);}\n\tfriend inline pnt operator - (const pnt&A, const pnt&B) {return (pnt) {A.x - B.x, A.y - B.y};}\n\tfriend inline int operator * (const pnt&A, const pnt&B) {return A.x * B.y - A.y * B.x;}\n} p[N];\n\ninline bool con(const pnt&A, const pnt&B, const pnt&C) {\n\treturn (C - A) * (B - A) == 0;\n}\n\nint n;\nint bin[N];\nbool vs[N];\nll Ans;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i=bin[0]=1;i<=n;++i) bin[i] = (bin[i-1] << 1)%mod;\n\tfor(int i=1;i<=n;++i) p[i].in();\n\tfor(int i=1;i<n;++i) {\n\t\tfor(int j=1;j<=n;++j) vs[j] = false;\n\t\t\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif(!vs[j]) {\n\t\t\t\tint ct = 2;\n\t\t\t\tfor(int k=j+1;k<=n;++k)\n\t\t\t\t\tif(con(p[i], p[j], p[k])) vs[k] = true, ++ct;\n\t\t\t\t\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int k=1;k<i and flg;++k)\n\t\t\t\t\tif(con(p[i], p[j], p[k])) flg = false;\n\t\t\t\tif(flg) Ans += bin[ct] - ct - 1;\n\t\t\t}\n\t}\n\tAns = ((ll)mod*mod - Ans - n - 1 + bin[n])%mod;\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <unordered_map>\n#include <iomanip>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst ll mod = 998244353;\n\nstruct point{\n    ll x,y;\n};\n\nll fpow(ll x, ll p){\n    ll r=1;\n    for (; p; p>>=1){\n        if (p&1) r=(r*x)%mod;\n        x=(x*x)%mod;\n    }\n    return r;\n}\n\nll ccw(point A, point B, point C){\n    return (A.x*B.y+B.x*C.y+C.x*A.y-B.y*C.x-C.y*A.x-A.y*B.x);\n}\n\nll N; point a[210];\nbool v[210][210];\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> N;\n\n    int i,j,k;\n    for (i=1; i<=N; i++) cin >> a[i].x >> a[i].y;\n\n    ll res=fpow(2,N)-1-N-N*(N-1)/2;\n\n    for (i=1; i<=N; i++)\n        for (j=i+1; j<=N; j++){\n            if (v[i][j]) continue;\n\n            int cnt=0;\n            vi ind;\n            for (k=1; k<=N; k++){\n                if (ccw(a[i],a[j],a[k])==0) cnt++;\n                ind.pb(k);\n            }\n\n            for (int x=0; x<(int)ind.size(); x++)\n                for (int y=x+1; y<(int)ind.size(); y++)\n                    v[ind[x]][ind[y]]=v[ind[y]][ind[x]]=1;\n            res=(res-(fpow(2,cnt)-1-cnt-cnt*(cnt-1)/2))%mod;\n        }\n\n    res=(res+mod)%mod;\n    cout << res << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, x[200], y[200];\nbool b[200];\nll res, pw2[200];\n\nll pw(ll x, int y) {\n\tll a = 1;\n\twhile (y) {\n\t\tif (y & 1) {\n\t\t\ta = a*x%mod;\n\t\t}\n\t\tx = x*x%mod;\n\t\ty >>= 1;\n\t}\n\treturn a;\n}\n\nll modinv(ll x) {\n\treturn pw(x, mod - 2);\n}\n\nint main(){\n\tcin >> N;\n\tll t = N*(N - 1), m = modinv(2);\n\tfor (int i = 3; i <= N; ++i) {\n\t\tt = (t*(N + 1 - i)) % mod;\n\t\tm = (m*modinv(i)) % mod;\n\t\tres = (res + t*m) % mod;\n\t}\n\tpw2[0] = 1;\n\tfor (int i = 1; i < 200; ++i) {\n\t\tpw2[i] = pw2[i - 1] * 2 % mod;\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tmemset(b, false, sizeof b);\n\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\tif (b[j])continue;\n\t\t\tint u = 1;\n\t\t\tfor (int k = j + 1; k < N; ++k) {\n\t\t\t\tif (b[k])continue;\n\t\t\t\tif ((x[i] - x[j])*(y[j] - y[k]) == (x[j] - x[k])*(y[i] - y[j])) {\n\t\t\t\t\tb[k] = true;\n\t\t\t\t\t++u;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = u;\n\t\t\tm = modinv(1);\n\t\t\tfor (int k = 2; k <= u; ++k) {\n\t\t\t\tt = (t*(u + 1 - k)) % mod;\n\t\t\t\tm = (m*modinv(k)) % mod;\n\t\t\t\tres = (res + mod - t*m%mod) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nvector <pair<int, int>> p;\nvector <int> q;\nconst int g = 998244353;\n\nint fp(int a, int b) {\n    return (a + g + b) % g;\n}\n\nint f(int k) {\n    int a = 1;\n    for (int i = 0; i < k; i++) a = 2 * a % g;\n    return fp(a, -(1 + k + k * (k - 1) / 2));\n}\n\nint main() {\n    int n, x, y, b{0};\n    cin >> n;\n    for(int i = 0; i < n; i++) {\n        cin >> x >> y;\n        p.emplace_back(make_pair(x, y));\n    }\n    for (int i = 0; i < n - 2; i++)\n        for (int j = i + 1; j < n - 1; j++) {\n            if (find(q.begin(), q.end(), i * 200 + j) != q.end()) continue;\n            vector <int> t;\n            t.push_back(i);\n            t.push_back(j);\n            for (int k = j + 1; k < n; k++)\n                if ((p[i].first - p[j].first) * (p[i].second - p[k].second) ==\n                    (p[i].second - p[j].second) * (p[i].first - p[k].first))\n                    t.push_back(k);\n            if (t.size() > 2) {\n                b = fp(b, f(int(t.size())));\n                for (int v = 0; v < t.size() - 1; v++)\n                    for (int w = v + 1; w < t.size(); w++)\n                        q.push_back(t[v] * 200 + t[w]);\n            }\n        }\n    cout << fp(f(n), -b) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nint N;\nint x[200], y[200];\nlong long mod = 998244353;\nlong long ans = 0;\n\n\n\nint main(){\n    cin >> N;\n    for(int i = 0; i < N; i++){\n        cin >> x[i] >> y[i];\n    }\n    ans = 1;\n    for(int i = 0; i < N; i++){\n        ans *= 2;\n        ans %= mod;\n    }\n\n    ans += mod - 1;\n    ans %= mod;\n    ans += mod - N;\n    ans %= mod;\n    for(int i = 0; i < N; i++){\n        for(int j = i + 1; j < N; j++){\n            int cnt = 0;\n            for(int k = j + 1; k < N; k++){\n                int dx1 = x[k] - x[i];\n                int dx2 = x[k] - x[j];\n                int dy1 = y[k] - y[i];\n                int dy2 = y[k] - y[j];\n                if(dx1*dy2 == dx2*dy1){\n                    cnt++;\n                }\n            }\n            int minus = 1;\n            for(int k = 0; k < cnt; k++){\n                minus *= 2;\n                minus %= mod;\n            }\n            ans += mod - minus;\n            ans %= mod;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint dx[] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n/*\n#define cin ifs\n#define cout ofs\nifstream ifs(\"in.txt\");\nofstream ofs(\"out.txt\");\n//*/\n\nint N;\nint x[200], y[200];\nint mod = 998244353;\nbool used[200][200];\n\nsigned main() {\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    int ans = 1;\n    for (int i = 0; i < N; i++) {\n        ans *= 2;\n        ans %= mod;\n    }\n    ans -= 1 + N;\n    ans += mod;\n    ans %= mod;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j)\n                continue;\n            int cur = 0;\n            int diff = 1;\n            for (int k = 0; k < N; k++) {\n                if (used[i][k] && used[j][k] &&\n                    (x[i] - x[j]) * (y[i] - y[k]) ==\n                        (x[i] - x[k]) * (y[i] - y[j])) {\n                    goto check;\n                }\n            }\n            for (int k = 0; k < N; k++) {\n                if ((x[i] - x[j]) * (y[i] - y[k]) ==\n                    (x[i] - x[k]) * (y[i] - y[j])) {\n                    cur++;\n                    used[i][k] = used[k][i] = true;\n                }\n            }\n            for (int k = 0; k < cur; k++) {\n                diff *= 2;\n                diff %= mod;\n            }\n            diff -= 1 + cur;\n            diff += mod;\n            diff %= mod;\n            ans -= diff;\n            ans %= mod;\n        check:;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int Q = 998244353;\nconst int N = 209;\nll x[N], y[N], p[N], f[N], size[N];\ninline int read() {\n    int s = 1, a = 0; char ch = getchar();\n    while (ch < '0' || ch > '9') {if (ch == '-') s = -1; ch = getchar();}\n    while (ch >= '0' && ch <= '9') {a = a * 10 + ch - '0'; ch = getchar();}\n    return s * a;\n}\ninline int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\ninline int findSet(int x) {\n    return f[x] == x ? x : f[x] = findSet(f[x]);\n}\ninline void unionSet(int x, int y) {\n    int fx = findSet(x), fy = findSet(y);\n    if (fx != fy) {\n        f[fy] = fx;\n        size[fx] += size[fy];\n    }\n}\nstruct Seg {\n    int p, q; ll hash;\n    bool operator < (const Seg &rhs) const {\n        return hash < rhs.hash;\n    }\n};\nvector<Seg> seg;\nint main() {\n    p[0] = 1;\n    for (int i = 1; i < N; i++) {\n        p[i] = p[i - 1] << 1, p[i] %= Q;\n    }\n    int n = read();\n    for (int i = 1; i <= n; i++) {\n        x[i] = read(), y[i] = read();\n    }\n    ll res = (p[n] - n - 1) % Q;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            int dx = x[i] - x[j], dy = y[i] - y[j], g = gcd(dx, dy);\n            dx /= g, dy /= g;\n            if (dx == 0) dy = 1;\n            if (dy == 0) dx = 1;\n            if (dx < 0) dx *= -1, dy *= -1;\n            Seg s; s.p = i, s.q = j, s.hash = dx * 100000 + dy;\n            seg.push_back(s);\n        }\n    }\n    sort(seg.begin(), seg.end());\n    for (int i = 0, j = 0; i < seg.size(); i = j) {\n        for (int k = 1; k <= n; k++) {\n            f[k] = k, size[k] = 1;\n        }\n        for (; j < seg.size() && seg[i].hash == seg[j].hash; j++) {\n            unionSet(seg[j].p, seg[j].q);\n        }\n        for (int k = 1; k <= n; k++) {\n            if (f[k] == k && size[k] >= 2) {\n                res -= (p[ size[k] ] - size[k] - 1), res += Q, res %= Q;\n            }\n        }\n    }\n    res += Q, res %= Q;\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n// #define DEBUG_IS_VALID \n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){cout << \"{\"; for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\nvoid _main();\nint main(){ cin.tie(0); ios::sync_with_stdio(false); _main(); return 0;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-5,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntemplate<typename T, int FAC_MAX> struct Comb { vector<T> fac, ifac;\n    Comb(){fac.resize(FAC_MAX,1);ifac.resize(FAC_MAX,1); for(int i = 1; i < FAC_MAX; i++)fac[i]=fac[i-1]*i;\n        ifac[FAC_MAX-1]=T(1)/fac[FAC_MAX-1];for(int i = FAC_MAX-2; i >= 1; i--)ifac[i]=ifac[i+1]*T(i+1);}\n    T aPb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b]; }\n    T aCb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b] * ifac[b]; }\n    T nHk(int n, int k) { if (n == 0 && k == 0) return T(1); if (n <= 0 || k < 0) return 0;\n        return aCb(n + k - 1, k); }}; // nHk = (n+k-1)Ck : n is separator\n\nusing mint =  ModInt<998244353>;\n\nstruct Point {\n    ll x, y;\n    friend Point operator-(const Point& a, const Point& b) {\n        return {a.x - b.x, a.y - b.y};\n    }\n    friend ll operator*(const Point& a, const Point& b) {\n        return a.x*b.y - a.y*b.x;\n    }\n    friend bool are_aligned(const Point& a, const Point& b, const Point& c) {\n        return (a-c)*(b-c) == 0;\n    }\n    friend bool in(const Point& a, const Point& b, const Point& c) {\n        auto s = a-c, t = b-c;\n        return s.x * t.x <= 0 and s.y * t.y <= 0;\n    }\n};\n\nvoid _main(){\n  int N; cin >> N ;\n  vector<Point> p(N);\n  rep(i,N) cin >> p[i].x >> p[i].y ;\n  mint ans = mint(2)^N;\n  rep(i,N-1) REP(j,i+1,N){\n    int cnt = 2;\n    bool skip = false;\n    rep(k,N){\n      if(k==i||k==j) continue;\n      if(!are_aligned(p[i],p[j],p[k])) continue;\n      if(!in(p[i],p[j],p[k])){\n        skip = true; \n        break;\n      }\n      cnt++;\n    }\n    if(skip) continue;\n    if(cnt==0) continue;\n    dump(p[i].x,p[i].y,p[j].x,p[j].y,cnt);\n    ans -= (mint(2)^cnt) - mint(cnt+1);\n  }\n  ans -= mint(1+N);\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll mod = 998244353;\n\nll modpow(ll x, ll n) {\n    ll res = 1;\n    while(n > 0) {\n        if(n & 1) (res *= x) %= mod;\n        (x *= x) %= mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<int> x(n), y(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    ll ans = (modpow(2, n) - n - 1 + mod) % mod;\n    set<vector<int>> vss;\n    for(int i = 0; i < n; ++i) {\n        for(int j = i + 1; j < n; ++j) {\n            vector<int> vs;\n            for(int k = 0; k < n; ++k) {\n                const int dx1 = x[j] - x[i], dx2 = x[k] - x[i];\n                const int dy1 = y[j] - y[i], dy2 = y[k] - y[i];\n                if(dx1 * dy2 - dx2 * dy1 == 0) {\n                    vs.push_back(k);\n                }\n            }\n            if(vss.count(vs)) continue;\n            ans = (ans - modpow(2, vs.size()) + vs.size() + 1 + mod) % mod;\n            vss.insert(move(vs));\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//注意点\n//Tは3つの値を持つ構造\n//だがワイルドカードとしても使っている\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\nusing P = pair<ll, ll>;\n#define F first\n#define fi first\n#define S second\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\n#define vvi(a, b, c) vec<vi> a(b,vi(c))\nusing vb = vector<bool>;\n#define vvb(a, b, c) vec<vb> a(b,vb(c))\nusing vs = vector<string>;\n#define vvs(a, b, c) vec<vs> a(b,vs(c))\nusing vl = vector<ll>;\n#define vvl(a, b, c) vec<vl> a(b,vl(c))\nusing vd = vector<double>;\n#define vvd(a, b, c) vec<vd> a(b,vd(c))\nusing vc=vector<char>;\n#define vvc(a, b, c) vec<vc> a(b,vc(c))\nusing vp = vector<P>;\n#define vvp(a, b, c) vec<vp> a(b,vp(c))\nusing vt = vector<T>;\n#define vvt(a, b, c) vec<vt> a(b,vt(c))\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\nusing seti = set<int>;\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define rep(...) _overloadrep(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rer(...) _overloadrep(__VA_ARGS__,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) if (ve.size())for (int gi = 0, f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost; gi < ve.size(); gi++,f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost)\n\n//マクロ 定数\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) (a.size())\n#define rs(a) (a.resize())\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n// 境界チェック付きvector\nnamespace std_vector_bounds_checking {\n    using namespace std;\n    template<class T, class A = std::allocator<T>> struct vector : std::vector<T, A> {\n        using std::vector<T, A>::vector;\n        typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {\n            return this->at(n);\n        }\n    };\n}\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) {  //再帰の終端。 可変長templateの長さが 0 になるとこっちが呼ばれる。\n    vec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T &vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T &vall) {\n    for (auto &vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T in() {\n    T x;\n    cin >> x;\n    return (x);\n}\nstring sin() { return in<string>(); }\ndouble din() { return in<double>(); }\nll lin() { return in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nad(a, n) a.resize(n); rep(i,n) cin >> a[i], a[i]--;\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i],a[i]--,b[i]--;\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i],a[i]--,b[i]--,c[i]--;\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//汎用便利関数 出力\ntemplate<class T> void out(T x) { typeid(x) == typeid(double) ? cout << fixed << setprecision(10) << x << endl : cout << x << endl; }\n//デバッグ\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    vec<vi> sets() {\n        vec<vi> res(trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.F;\n            res[i].push_back(r);\n            for (auto &&v:p.S) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\n//MOD関連\nll MOD = (int) 1e9 + 7;\nclass mint {\npublic:\n    int x;\n    mint() : x(0) {}\n    mint(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n    mint(int y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n    static int _mpow(int v, ll a) {\n        ll x = v, n = a, res = 1;\n        while (n) {\n            if (n & 1)res = (res * x) % MOD;\n            x = (x * x) % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    // Arithmetic Oprators\n    mint &operator+=(mint that) {\n        if ((x += that.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint &operator-=(mint that) {\n        if ((x += MOD - that.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint &operator*=(mint that) {\n        x = 1LL * x * that.x % MOD;\n        return *this;\n    }\n    mint &operator/=(const mint &that);\n    mint &operator^=(const mint &that) {\n        this->x = _mpow(x, that.x);\n        return *this;\n    }\n    mint &operator%=(mint that) {\n        x %= that.x;\n        return *this;\n    }\n\n    mint &operator+=(const int that) { return *this += mint(that); }\n    mint &operator-=(const int that) { return *this -= mint(that); }\n    mint &operator*=(const int that) { return *this *= mint(that); }\n    mint &operator/=(const int that);\n    mint &operator^=(const int that) {\n        this->x = _mpow(x, that);\n        return *this;\n    }\n    mint &operator%=(const int that) { return *this %= mint(that); }\n\n    mint &operator+=(const signed that) { return *this += mint(that); }\n    mint &operator-=(const signed that) { return *this -= mint(that); }\n    mint &operator*=(const signed that) { return *this *= mint(that); }\n    mint &operator/=(const signed that);\n    mint &operator^=(const signed that) {\n        this->x = _mpow(x, that);\n        return *this;\n    }\n    mint &operator%=(const signed that) { return *this %= mint(that); }\n\n    // Comparators\n    bool operator<(mint that) { return x < that.x; }\n    bool operator>(mint that) { return x > that.x; }\n    bool operator<=(mint that) { return x <= that.x; }\n    bool operator>=(mint that) { return x >= that.x; }\n    bool operator!=(mint that) { return x != that.x; }\n    bool operator==(mint that) { return x == that.x; }\n    bool operator!=(int that) { return x != that; }\n    bool operator==(int that) { return x == that; }\n    bool operator!=(signed that) { return x != that; }\n    bool operator==(signed that) { return x == that; }\n\n    // Utilities\n    unsigned getval() const { return x; }\n    operator int() { return x; }\n    mint operator+(mint that) const { return mint(*this) += that; }\n    mint operator-(mint that) const { return mint(*this) -= that; }\n    mint operator*(mint that) const { return mint(*this) *= that; }\n    mint operator%(mint that) const { return mint(*this) %= that; }\n    mint operator+(const int that) const { return mint(*this) += that; }\n    mint operator-(const int that) const { return mint(*this) -= that; }\n    mint operator*(const int that) const { return mint(*this) *= that; }\n    mint operator%(const int that) const { return mint(*this) %= that; }\n    mint operator=(const int that) { return *this = mint(that); }\n    mint operator+(const signed that) const { return mint(*this) += that; }\n    mint operator-(const signed that) const { return mint(*this) -= that; }\n    mint operator*(const signed that) const { return mint(*this) *= that; }\n    mint operator%(const signed that) const { return mint(*this) %= that; }\n    mint operator=(const signed that) { return *this = mint(that); }\n    friend void operator+=(ll &a, const mint &b) { a = mint(a % MOD + b.x); }\n    friend void operator-=(ll &a, const mint &b) { a = mint(a % MOD - b.x); }\n    friend void operator*=(ll &a, const mint &b) { a = mint(a % MOD * b.x); }\n    friend void operator/=(ll &a, const mint &b);\n    friend mint operator+(const ll a, const mint &b) { return mint(a % MOD + b.x); }\n    friend mint operator-(const ll a, const mint &b) { return mint(a % MOD - b.x); }\n    friend mint operator*(const ll a, const mint &b) { return mint(a % MOD * b.x); }\n    friend mint operator^(const ll a, const mint &b) { return _mpow(a, b.x); }\n};\nconst int setModMax = 510000;\nmint fac[setModMax], finv[setModMax], inv[setModMax];\nvoid setMod(int m = MOD) {\n    MOD = m;\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < setModMax; i++) {\n        fac[i] = fac[i - 1].x * i % MOD;\n        inv[i] = MOD - inv[MOD % i].x * (MOD / i) % MOD;\n        finv[i] = finv[i - 1].x * inv[i].x % MOD;\n    }\n}\nmint mpow(int v, ll a) {\n    return mint::_mpow(v, a);\n}\nmint com(ll n, ll r) {\n    if (n < r || n < 0 || r < 0)return 0;\n    if (fac[0] == 0)setMod();\n    return fac[n] * finv[r] * finv[n - r];\n}\nmint ncr(ll n, ll r) { return com(n, r); }\nmint nhr(ll n, ll r) { return com(n + r - 1, r); }\n\n//拡張ユークリッドの互除法\nmint minv(ll a) {\n    if (fac[0] == 0)setMod();\n    if (a < setModMax) return inv[a];\n    a %= MOD;\n    ll b = MOD, x = 1, y = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b;\n        swap(a, b);\n        x -= t * y;\n        swap(x, y);\n    }\n    return x;\n}\nmint &mint::operator/=(const mint &that) { return *this *= minv(that.x); }\nmint &mint::operator/=(const ll a) { return *this *= minv(a); }\nmint &mint::operator/=(const signed a) { return *this *= minv(a); }\nvoid operator/=(ll &a, const mint &b) { a = (a * minv(b.x)).x; }\nusing vm=vector<mint>;\n#define vvm(a, b, c) vec<vm> a(b,vm(c))\nbool isPrime[4010101];\nvi primes;\n\nvoid setPrime() {\n    fill(isPrime, true);\n    int len = sizeof(isPrime) / sizeof(isPrime[0]);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n//幾何 Pをcomplexとして扱う\nbool eq(double a, double b) { return fabs(a - b) < eps; }\n\nusing C =complex<double>;\n\nC rot(C &a, dou th) {\n    return a * C(cos(th), sin(th));\n}\n\ndou inpro(C &a, C &b) {\n    return real(a * conj(b));\n}\n\n//90度回転させて内積が0なら平行\nbool line(C a, C b, C c) {\n    C ab = b - a;\n    C ac = c - a;\n    //複素数の掛け算は回転\n    ab *= C(0, 1);\n    return eq(inpro(ab, ac), 0);\n}\nbool line(P a, P b, P c) {\n    return line(C(a.F, a.S), C(b.F, b.S), C(c.F, c.S));\n}\n\nbool line(int xa, int ya, int xb, int yb, int xc, int yc) {\n    C a = C(xa, ya);\n    C b = C(xb, yb);\n    C c = C(xc, yc);\n    return line(a, b, c);\n}\n\n//便利関数\n//テスト用\nchar ranc() {\n    return (char) ('a' + rand() % 26);\n}\nint rand(int min, int max) {\n    return rand() % (max + 1 - min) + min;\n}\nvi ranv(int n, int min, int max) {\n    vi v(n);\n    rep(i, n)v[i] = rand(min, max);\n    return v;\n}\nvoid iota(vector<int> ve, int s, int n) {\n    ve.resize(n);\n    iota(all(ve), s);\n}\nvoid ole() {\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll reverse(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0)ole();\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    for (int i = 1; i <= sqrt(v); ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (!isPrime[2])setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\n\nunordered_map<int, int> factorizationMap(int v) {\n    int tv = v;\n    unordered_map<int, int> res;\n    if (!isPrime[2])setPrime();\n    for (auto &&p :primes) {\n        while (v % p == 0) {\n            res[p]++;\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res[v]++;\n    return res;\n}\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(int v) {\n    int cou = 0;\n    while (v) { cou++, v %= 10; }\n    return cou;\n}\n\ntemplate<class T> void imo(vector<T> &v) {\n    int n = v.size();\n    rep(i, n - 1)v[i + 1] += v[i];\n}\n\n//変換系\ntemplate<class T, class U> vector<T> keys(vector<pair<T, U>> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.F);\n    return res;\n}\ntemplate<class T, class U> vector<U> keys(map<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.F);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> keys(umap<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.F);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> values(vector<pair<T, U>> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.S);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(map<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.S);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(umap<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.S);\n    return res;\n}\n\nvi list(int a) {\n    vi res;\n    while (a) {\n        res.insert(res.begin(), a % 10);\n        a /= 10;\n    }\n    return res;\n}\n\ntemplate<class T, class U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> T min(T a, signed b) {\n    return a < b ? a : b;\n}\n\ntemplate<class T> T max(T a, signed b) {\n    return a < b ? b : a;\n}\n\ntemplate<class T> T min(T a, T b, T c) {\n    return a >= b ? b >= c ? c : b : a >= c ? c : a;\n}\ntemplate<class T> T max(T a, T b, T c) {\n    return a <= b ? b <= c ? c : b : a <= c ? c : a;\n}\n\ntemplate<class T> T min(vector<T> a) {\n    return *min_element(all(a));\n}\ntemplate<class T> T min(vector<T> a, int n) {\n    return *min_element(a.begin(), a.begin() + min(n, sz(a)));\n}\ntemplate<class T> T min(vector<T> a, int s, int n) {\n    return *min_element(a.begin() + s, a.begin() + min(n, sz(a)));\n}\ntemplate<class T> T max(vector<T> a) {\n    return *max_element(all(a));\n}\ntemplate<class T> T max(vector<T> a, int n) {\n    return *max_element(a.begin(), a.begin() + min(n, sz(a)));\n}\ntemplate<class T> T max(vector<T> a, int s, int n) {\n    return *max_element(a.begin() + s, a.begin() + min(n, sz(a)));\n}\n\ntemplate<class T> T min(T a[]) {\n    T res = a[0];\n    rep(i, arsz(a))chmin(res, a[i]);\n    return res;\n}\n\ntemplate<class T> T max(T a[]) {\n    T res = a[0];\n    rep(i, arsz(a))chmax(res, a[i]);\n    return res;\n}\ntemplate<class T> T sum(vector<T> v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 0;\n    chmin(len, v.size());\n    rep(i, len)res += v[i];\n    return res;\n}\ntemplate<class T> T sum(vector<vector<T>> &v, int h = -1, int w = -1) {\n    if (h == -1)h = v.size();\n    if (w == -1)w = v[0].size();\n    T res = 0;\n    chmin(h, v.size());\n    chmin(w, v[0].size());\n    rep(i, h)rep(j, w)res += v[i][j];\n    return res;\n}\n\nP sump(vp &v, int len = -1) {\n    if (len == -1)len = v.size();\n    P res = {0, 0};\n    chmin(len, v.size());\n    rep(i, len) {\n        res.F += v[i].F;\n        res.S += v[i].S;\n    }\n    return res;\n}\n\n///要素が0の時、返り値は0か1か\ntemplate<class T> T mul(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 1;\n    chmin(len, v.size());\n    rep(i, len)res *= v[i];\n    return res;\n}\nvoid clear(PQ &q) { while (q.size())q.pop(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(int size) {\n    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));\n    return body + size;\n}\ntemplate<class T> T *negarr2(int h, int w) {\n    double **dummy1 = new double *[2 * h + 1];\n    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];\n    dummy1[0] = dummy2 + w;\n    for (int i = 1; i <= 2 * h + 1; i++) {\n        dummy1[i] = dummy1[i - 1] + 2 * w + 1;\n    }\n    double **a = dummy1 + h;\n}\n\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> res(a.size() + 1);\n    rep(i, a.size())res[i + 1] = res[i] + a[i];\n    return res;\n}\n\ntemplate<class T> vector<T> ruim(vector<T> &a) {\n    vector<T> res(a.size() + 1, 1);\n    rep(i, a.size())res[i + 1] = res[i] * a[i];\n    return res;\n}\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> T *rrui(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    rer(i, len - 1)res[i - 1] = res[i] + a[i];\n    return res;\n}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    res[len - 1] = 1;\n    rer(i, len - 1)res[i - 1] = res[i] * a[i];\n    return res;\n}\ntemplate<class T> void plus(vector<T> &a, T v = 1) { for (auto &&u :a)u += v; }\ntemplate<class T> void minu(vector<T> &a, T v = 1) { for (auto &&u :a)u -= v; }\ntemplate<class T> void minus(vector<T> &a, T v = 1) { for (auto &&u :a)u -= v; }\ninline bool inside(int y, int x, int H, int W) { return y >= 0 && x >= 0 && y < H && x < W; }\nll u(ll a) { return a < 0 ? 0 : a; }\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\ntemplate<class T> T min(vector<vector<T>> &a) {\n    T res = MAX(T);\n    rep(i, a.size())chmin(res, *min_element(all(a[i])));\n    return res;\n}\ntemplate<class T> T max(vector<vector<T>> &a) {\n    T res = MIN(T);\n    rep(i, a.size())chmax(res, *max_element(all(a[i])));\n    return res;\n}\nbool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\ninline ll bit(int n) { return (1LL << (n)); }\ninline ll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint bcou(ll m) { return __builtin_popcount(m & 0xFFFFFFFF) + __builtin_popcount(m >> 32); }\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {\n    if (!mask)return mask = (1LL << r) - 1;\n    ll x = mask & -mask; //最下位の1\n    ll y = mask + x; //連続した下の1を繰り上がらせる\n    ll res = ((mask & ~y) / x >> 1) | y;\n    if (bget(res, n))return mask = 0;\n    else return mask = res;\n}\n\n//n桁以下でビットがr個立っているもののvectorを返す\nvl bitCombList(int n, int r) {\n    vl res;\n    int m = 0;\n    while (nextComb(m, n, r)) {\n        res.pb(m);\n    }\n    return res;\n}\n//大文字小文字を区別する\nint altoiaZ(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a' + 26;\n}\nchar itoalaZ(int i) {\n    if (i < 26)return 'A' + i;\n    return 'a' + i - 26;\n}\n//aもAも0を返す 基本小文字\nint altoi(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a';\n}\nchar itoal(int i) {\n    return 'a' + i;\n}\nint ctoi(char c) { return c - '0'; }\nvector<vector<int>> ctoi(vector<vector<char>> s, char c) {\n    int n = sz(s), m = sz(s[0]);\n    vector<vector<int>> res(n, vector<int>(m));\n    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;\n    return res;\n}\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nvoid compress(vi &a) {\n    vi b;\n    int len = a.size();\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n\nvoid compress(int a[], int len) {\n    vi b;\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\n#define ans(a) cout<<a<<endl;continue;\n#define poll(a) q.front();q.pop()\n#define dpoll(a) q.front();q.pop_front()\n#define pollLast(a) q.back();q.pop_back()\n#define pollBack(a) q.back();q.pop_back()\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n, root = -1;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    bool isleaf(int v) {\n        assert(root != -1);\n        return g[v].size() == 1 && g[v][0].from != root;\n    }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\n\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n))ole();\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n))ole();\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, ty, id);\n        edges.emplace_back(f, t, cost, ty, id);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<class T> bool nibu(const graph<T> &g) {\n    UnionFind uf(g.n * 2);\n    for (auto &&e :g.edges)uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);\n    return !uf.same(0, g.n);\n}\ntemplate<class T> vector<T> &dijkstra(const graph<T> &g, int s) {\n    if (!(0 <= s && s < g.n))ole();\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().F;\n        int i = q.top().S;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.to;\n            T cost = nowc + e.cost;\n            if (dis[to] > cost) {\n                dis[to] = cost;\n                q.emplace(dis[to], to);\n            }\n        }\n    }\n    //たどり着かないなら-1\n    for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\n\n//機能拡張\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) {\n    a.push(v);\n}\ntemplate<class T, class U>\npriority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {\n    a.insert(v);\n    return a;\n}\n\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U &v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {\n    a.pb(b);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, initializer_list<U> v) {\n    for (auto &&va :v)a.pb(va);\n    return a;\n}\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b))ole();\n    rep(i, sz(a))a[i] -= b[i];\n    return a;\n}\ntemplate<class T> vector<T> &operator-(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b))ole();\n    vector<T> res;\n    rep(i, sz(a))res[i] = a[i] - b[i];\n    return res;\n}\ntemplate<typename T> void remove(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void remove(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void removen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T> void insert(vector<T> &v, unsigned int i, T t) { v.insert(v.begin() + i, t); }\ntemplate<typename T> void insert(vector<T> &v, unsigned int i, vector<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, initializer_list<U> list) {\n    for (auto &&va :list)v.pb(va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, initializer_list<U> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\ntemplate<typename T> void insert(set<T> &v, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\n\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.to]++;\n    queue<int> st;\n    rep(i, n)if (nyu[i] == 0)st.push(i);\n    while (st.size()) {\n        int v = st.front();\n        st.pop();\n        res.pb(v);\n        fora(e, g[v]) if (--nyu[e.to] == 0)st.push(e.to);\n    }\n    return res.size() == n;\n}\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.to]++;\n    //小さい順\n    priority_queue<int, vector<int>, greater<int> > q;\n    rep(i, n)if (nyu[i] == 0)q.push(i);\n    while (q.size()) {\n        int i = q.top();\n        q.pop();\n        res.pb(i);\n        fora(e, g[i])if (--nyu[e.to] == 0)q.push(e.to);\n    }\n    return res.size() == n;\n}\nvector<string> split(const string a, const char deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size();\n    vector<string> res;\n    rep(i, n) {\n        if (b[i] == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvector<string> split(const string a, const string deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size(), dn = deli.size();\n    vector<string> res;\n    rep(i, n) {\n        if (i + dn <= n && b.substr(i, i + dn) == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            i += dn - 1;\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi a, b, c;\nvvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\n\nvoid solve() {\n    cin >> n;\n    na(p, n);\n    setMod(998244353);\n    //                 0   1   2\n    cou = mpow(2, n) - 1 - n - n * (n - 1) / 2;\n    vvb(us, 2020, 2020);\n    rep(i, n) {\n        rep(j, i) {\n            if (us[i][j])con;\n            a = {i, j};\n            b = {i, j};\n            rep(k, n) {\n                if (k == i || k == j)con;\n                if (line(p[i], p[j], p[k])) {\n                    a += k, b += k;\n                }\n            }\n            fora(ai, a)fora(bi, b)us[ai][bi] = 1;\n            int an = sz(a);\n            cou -= (mpow(2, an) - 1 - an - an * (an - 1) / 2);\n        }\n    }\n    cout << cou << endl;\n}\nint my(int n, vi a) {\n    return 0;\n}\nint sister(int n, vi a) {\n    return 0;\n}\n\nsigned main() {\n    solve();\n//    cin >> n;\n//    addn(a, n);\n//    cout << my(n, m, a) << endl;\n//    cout << sister(n, m, a) << endl;\n#ifdef _DEBUG\n    for (int i = 0, ok = 1; i < k5 && ok; i++) {\n        int n = rand(2, 5);\n        int m = rand(2, 5);\n        int k = rand(2, 5);\n        vi a = ranv(n, 1, 10);\n        vi b = ranv(n, 1, 10);\n#define _arg n,a\n        int myres = my(_arg);\n        int res = sister(_arg);\n        ok = myres == res;\n        if (!ok) {\n            cout << n << endl;\n            cout << a << endl;\n            cout << \"正解 : \" << res << endl;\n            cout << \"出力 : \" << myres << endl;\n        }\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (lint ngtkana_is_a_genius = 0; ngtkana_is_a_genius < lint(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (lint i = lint(begin); (i) < lint(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n\tdo {\\\n\t\tstd::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n\t\tdebug_impl(__VA_ARGS__);\\\n\t\tstd::cerr << std::noboolalpha;\\\n\t} while (false)\n#else\n#define debug(...) {}\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n\tT u = 0, v = 1;\n\twhile (a != 0) {\n\t\tT t = m / a;\n\t\tm -= t * a; std::swap(a, m);\n\t\tu -= t * v; std::swap(u, v);\n\t}\n\tassert(m == 1);\n\treturn u;\n}\ntemplate <typename T>\nclass modular {\n\tprivate:\n\t\tint value;\n\tpublic:\n\t\tconstexpr modular() = default;\n\t\tconstexpr modular(const modular&) = default;\n\t\tconstexpr modular(modular&&) = default;\n\t\tmodular& operator=(const modular&) = default;\n\t\tmodular& operator=(modular&&) = default;\n\n\t\ttemplate <typename U>\n\t\tmodular (const U& x) {value = normalize(x);}\n\n\t\ttemplate <typename U>\n\t\tstatic auto normalize(const U& x) {\n\t\t\tint v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());\n\t\t\tif (v < 0) v += mod();\n\t\t\treturn v;\n\t\t}\n\n\t\tauto const& operator()() const { return value; }\n\t\ttemplate <typename U>\n\t\texplicit operator U() const { return static_cast<U>(value); }\n\t\tconstexpr static auto mod() { return T::value; }\n\n\t\tauto& operator+=(const modular& other) {\n\t\t\tif ((value += other.value) >= mod()) value -= mod();\n\t\t\treturn *this;\n\t\t}\n\t\tauto& operator-=(const modular& other) {\n\t\t\tif ((value -= other.value) < 0) value += mod();\n\t\t\treturn *this;\n\t\t}\n\t\ttemplate <typename U>\n\t\tauto& operator+=(const U& other) {return *this += modular(other); }\n\t\ttemplate <typename U>\n\t\tauto& operator-=(const U& other) {return *this -= modular(other); }\n\t\tauto operator-() const { return modular(-value); }\n\t\tauto& operator++() {return *this += 1;}\n\t\tauto& operator--() {return *this -= 1;}\n\t\tauto  operator++(int) {modular result(*this); operator++(); return result;}\n\t\tauto  operator--(int) {modular result(*this); operator--(); return result;}\n\n\t\ttemplate <typename U = T>\n\t\tauto& operator*=(const modular& rhs) {\n\t\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n\t\t\treturn *this;\n\t\t}\n\t\tauto& operator/=(const modular& other) {\n\t\t\treturn *this *= modular(inverse(other.value, mod()));\n\t\t}\n};\ntemplate <typename T> struct is_modular : std::false_type {};\ntemplate <typename T> struct is_modular <modular<T>> : std::true_type{};\ntemplate <typename T> constexpr bool is_modular_v = is_modular<T>::value;\n\ntemplate <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs() == rhs(); }\ntemplate <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\n\ntemplate <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nmodular<T> power (const modular<T>& a, U b) {\n\tassert(b >= 0);\n\tmodular<T> x = a, ret = 1;\n\tfor (; b > 0; b /= 2) {\n\t\tif (b % 2 == 1) ret *= x;\n\t\tx *= x;\n\t}\n\treturn ret;\n}\n\ntemplate <typename T>\nstd::string to_string(const modular<T>& a) {\n\treturn std::to_string(a());\n}\ntemplate <typename T>\nauto operator<<(std::ostream& os, const T& a)\n\t-> std::enable_if_t<is_modular_v<T>, std::ostream&>{\n\t\treturn os << a();\n\t}\ntemplate <typename T>\nauto operator>>(std::istream& is, T& a)\n\t-> std::enable_if_t<is_modular_v<T>, std::istream&> {\n\tlong long x; is >> x;\n\ta = T(x);\n\treturn is;\n}\n\n// using mod_type = int;\n\n// struct variable_mod { static mod_type value; };\n// mod_type variable_mod::value;\n// mod_type& mod = variable_mod::value;\n// using mint = modular< variable_mod >;\n\ntemplate < typename Value >\nclass factorials {\n\t\tstd::vector< Value > fact, finv;\n\n\tpublic:\n\t\tfactorials()=default;\n\n\t\tvoid build(int n) {\n\t\t\tfact.resize(n), finv.resize(n);\n\t\t\tfact.at(0) = 1;\n\t\t\tfor (int i = 1; i < n; i++) fact.at(i) = fact.at(i - 1) * Value(i);\n\t\t\tfinv.at(n - 1) = Value(1) / fact.at(n - 1);\n\t\t\tfor (int i = n - 2; i >= 0; i--) finv.at(i) = finv.at(i + 1) * Value(i + 1);\n\t\t}\n\t\tauto operator()  (int i) const {return fact.at(i);}\n\t\tauto inv         (int i) const {return finv.at(i);}\n\t\tauto binom(int i, int j) const {\n\t\t\tassert(0 <= i);\n\t\t\tif (j < 0 ||i < j) return Value(0);\n\t\t\treturn fact.at(i) * finv.at(j) * finv.at(i - j);\n\t\t}\n\t\tauto deal(int i, int j) const\n\t\t\t{ return binom(i + j - 1, j - 1); }\n};\n\nconstexpr int mod = 998244353;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(mod)>, mod>>;\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n\t{ for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n\tfor (auto it = v.begin(); it != v.end(); it++)\n\t\t{os << (it != v.begin() ? \",\" : \"\") << *it;}\n\treturn os << \"}\";\n}\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& tuple_input_impl(std::istream& os, Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n\t{ (void)std::initializer_list<int>{((void)(os >> std::get< Inds >(tuple)), 0)...}; return os; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& operator>> (std::istream& os, Tuple<Args...>& tuple)\n\t{ return tuple_input_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& tuple_output_impl(std::ostream& os, const Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n\t{ os << \"(\"; (void)std::initializer_list<int>{((void)(os << (Inds > 0 ? \",\" : \"\") << std::get< Inds >(tuple)), 0)...}; return os << \")\"; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& operator<< (std::ostream& os, const Tuple<Args...>& tuple)\n { return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate < std::size_t I, typename Container,\n\ttypename Value = typename std::tuple_element_t< I, typename Container::value_type >>\ninline auto project(Container const& v) {\n\tstd::vector< Value > ret(v.size());\n\tstd::transform(v.begin(), v.end(), ret.begin(), [](auto&& t){ return std::get< I >(t); });\n\treturn ret;\n}\n\ntemplate < class Container, class Value = typename Container::value_type >\nauto run_length(Container const& v) {\n\tauto n = (int)v.size();\n\tif (n == 0)\n\t\t{ return std::vector< std::pair< Value, int > >{}; }\n\tauto pos = std::vector< int >{};\n\tfor (auto i = 1; i < n; i++) {\n\t\tif (v.at(i - 1) != v.at(i))\n\t\t\t{ pos.emplace_back(i); }\n\t}\n\tpos.emplace_back(n);\n\tauto m = (int)pos.size();\n\tauto len = std::vector< int >(m);\n\tstd::adjacent_difference(pos.begin(), pos.end(), len.begin());\n\tauto ret = std::vector< std::pair< Value, int > >(m);\n\tfor (auto i = 0; i != m; i++)\n\t\t{ ret.at(i) = {v.at(pos.at(i) - 1), len.at(i)}; }\n\treturn ret;\n}\n\nint main() {\n\tstd::cin.tie(0); std::cin.sync_with_stdio(false);\n\tint n; std::cin >> n;\n\tstd::vector<std::pair<int,int>> pts(n);\n\tstd::cin>>pts;\n\tauto x = project<0>(pts);\n\tauto y = project<1>(pts);\n\n\tauto cal = [&] (int x) -> mint {\n\t\tif (x < 3) return mint{0};\n\t\tmint ans = power(mint{2}, x)\n\t\t\t- 1\n\t\t\t- x\n\t\t\t- x*(x-1) / 2;\n\t\treturn ans;\n\t};\n\trep(i,0,5) {\n\t\tdebug(i,cal(i));\n\t}\n\n\tmint ans = cal(n);\n\n\tauto check = [&] (lint a, lint b) {\n\t\tdebug(a,b);\n\t\tstd::vector<int> z(n);\n\t\trep(i,0,n) {\n\t\t\tz.at(i) = a * x.at(i) + b * y.at(i);\n\t\t}\n\t\tstd::sort(all(z));\n\t\tauto rle = run_length(z);\n\t\tauto mul = project<1>(rle);\n\t\tdebug(a,b,z,mul);\n\t\tfor (int x : mul) {\n\t\t\tmint y = cal(x);\n\t\t\tif (y != 0) { debug(x, y); }\n\t\t\tans -= y;\n\t\t}\n\t};\n\n\tstd::vector<std::pair<int,int>> tan;\n\ttan.emplace_back(0,1);\n\ttan.emplace_back(1,0);\n\trep(i,0,n) rep(j,0,n) {\n\t\tint dx = x.at(i) - x.at(j);\n\t\tint dy = y.at(i) - y.at(j);\n\t\tif (dx==0 || dy==0) continue;\n\t\tint g = std::__gcd(dx,dy);\n\t\tdx /= g;\n\t\tdy /= g;\n\t\tif (dx < 0) {\n\t\t\tdx = -dx;\n\t\t\tdy = -dy;\n\t\t}\n\t\tint a = -dy;\n\t\tint b = dx;\n\t\ttan.emplace_back(a,b);\n\t}\n\tstd::sort(all(tan));\n\ttan.resize(std::unique(all(tan)) - tan.begin());\n\tdebug(tan);\n\n\tfor (auto&& pair : tan) {\n\t\tint a,b; std::tie(a,b) = pair;\n\t\tcheck(a,b);\n\t}\n\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 998244353;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n  unsigned get() const { return x; }\n\n  // 逆数\n  ModInt inv() const {\n    ll a = 1, p = x, e = MOD-2;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // e乗\n  ModInt pow(ll e) {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // 2のx乗\n  ModInt pow2() {\n    ll a = 1, p = 2, e = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // 代入\n  void operator=(ll b) { x = b; }\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  ModInt &operator+=(ModInt that) {\n    x = ((ll)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((ll)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (ll)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (ll)x * that.inv() % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (ll)x % that.x;\n    return *this;\n  }\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\n\nint x[205], y[205];\n\nbool check( int i, int j, int k ) {\n\tif( y[i] > y[j] ) swap(i, j);\n\tif( y[k] < y[i] || y[k] > y[j] ) return false;\n\tif( x[i] > x[j] ) swap(i, j);\n\tif( x[k] < x[i] || x[k] > x[j] ) return false;\n\tint vx = x[k] - x[i], vy = y[k] - y[i];\n\tint wx = x[k] - x[j], wy = y[k] - y[j];\n\treturn vx*wy - vy*wx == 0;\n}\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) cin >> x[i] >> y[i];\n\n  mint ret = mint(n).pow2() - n - 1;\n  REP(i, n) FOR(j, i+1, n) {\n    mint cnt = 0;\n    REP(k, n) if(k!=i && k!=j && check(i,j,k)) ++cnt;\n    ret -= cnt.pow2();\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint n,d,ans,x[210],y[210],p[210];\nint main(){\n\tscanf(\"%d\",&n);\n\tint M=998244353;\n\tp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tp[i]=1ll*p[i-1]*2%M;\n\t}\n\tans=p[n]-n-1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\td=0;\n\t\t\tfor(int k=j+1;k<=n;k++)d+=(y[i]-y[j])*(x[i]-x[k])==(y[i]-y[k])*(x[i]-x[j]);\n\t\t\tans=(ans+M-p[d])%M;\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\n\nconst ll MOD = 998244353;\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b % MOD;\n    if (n % 2 == 0) {\n        return mypow(b * b % MOD, n / 2);\n    } else {\n        return mypow(b, n - 1) * b % MOD;\n    }\n}\n\nbool linear(pair<int, int> a, pair<int, int> b, pair<int, int> c) {\n    int dx[2] = {b.first - a.first, c.first - a.first};\n    int dy[2] = {b.second - a.second, c.second - a.second};\n\n    return dx[0] * dy[1] == dx[1] * dy[0];\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    pair<int, int> x[N];\n    for (int i = 0; i < N; ++i) {\n        cin >> x[i].first >> x[i].second;\n    }\n\n    set<set<int>> lineset;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            set<int> s = {i, j};\n\n            for (int k = 0; k < N; ++k) {\n                if (k == i || k == j) continue;\n                if (linear(x[i], x[j], x[k])) s.insert(k);\n            }\n\n            lineset.insert(s);\n        }\n    }\n\n    ll ans = (mypow(2LL, N) - N - 1 + MOD) % MOD;\n\n    for (auto s : lineset) {\n        int n = s.size();\n        ans += MOD - (mypow(2LL, n) - n - 1);\n        ans %= MOD;\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ld = long double;\nconst int maxn = 303, mod = 119<<23|1;\nint n, pw[maxn];\nvector<array<int, 2>> v;\nbool onl(array<int, 2> a, array<int, 2> b, array<int, 2> c) {\n\tif(a[1] == b[1] || b[1] == c[1]) return a[1] == b[1] && b[1] == c[1];\n\tld r1 = ld(a[0]-b[0])/ld(a[1]-b[1]);\n\tld r2 = ld(c[0]-b[0])/ld(c[1]-b[1]);\n\tld r3 = ld(a[0]-c[0])/ld(a[1]-c[1]);\n\treturn fabs(r1-r2) < 1e-5 && fabs(r3-r2) < 1e-5;\n}\nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tpw[0] = 1;\n\tfor(int i = 1; i < maxn; i++) pw[i] = (pw[i-1]+pw[i-1])%mod;\n\tcin >> n;\n\tv.resize(n);\n\tfor(auto &i : v) cin >> i[0] >> i[1];\n\tsort(all(v));\n\tint ans = pw[n];\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tint c = 0;\n\t\t\tarray<int, 2> mn = v[j];\n\t\t\tarray<int, 2> mx = v[i];\n\t\t\tfor(auto &[x, y] : v) if(v[i] == array<int, 2>{x, y} || v[j] == array<int, 2>{x, y} || onl(v[i], v[j], {x, y})) {\n\t\t\t\tc++;\n\t\t\t\tmn = min(mn, {x, y});\n\t\t\t\tmx = max(mx, {x, y});\n\t\t\t}\n\t\t\tif(v[j] != mn || v[i] != mx) continue;\n\t\t\t//cout << v[i][0] << \" \" << v[i][1] << \" | \" << v[j][0] << \" \" << v[j][1] << \" | \" << pw[c] - c - 1 << endl;\n\t\t\tans = (mod + ans - (pw[c] - c - 1))%mod;\t\n\t\t}\n\tans = (mod + ans - n - 1)%mod;\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int Q = 998244353;\nconst int N = 209;\nint x[N], y[N];\nll p[N];\ninline int read() {\n    int s = 1, a = 0; char ch = getchar();\n    while (ch < '0' || ch > '9') {if (ch == '-') s = -1; ch = getchar();}\n    while (ch >= '0' && ch <= '9') {a = a * 10 + ch - '0'; ch = getchar();}\n    return s * a;\n}\ninline bool isCollinear(int i, int j, int k) {\n    return (y[k] - y[j]) * (x[j] - x[i]) == (y[j] - y[i]) * (x[k] - x[j]);\n}\nint main() {\n    int n = read();\n    for (int i = 1; i <= n; i++) x[i] = read(), y[i] = read();\n    p[0] = 1;\n    for (int i = 1; i <= n; i++) p[i] = p[i - 1] * 2 % Q;\n    ll res = p[n];\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            int m = 1;\n            for (int k = j + 1; k <= n; k++) {\n                if (isCollinear(i, j, k)) m++;\n            }\n            res -= (p[m] - m - 1);\n            res += Q;\n            res %= Q;\n        }\n    }\n    res -= (n + 1);\n    res += Q;\n    res %= Q;\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint fact[200005], fact_i[200005];\n\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 200005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 200005; i++){\n\t\tfact_i[i] = pow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_i[k], ret %= mod;\n\tret *= fact_i[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint N;\nllint x[205], y[205];\n\nbool onLine(llint x1, llint y1, llint x2, llint y2, llint x3, llint y3)\n{\n\tif(x1 == x2) return x1 == x3;\n\tif((y2-y1)*(x3-x1) % (x2-x1)) return false;\n\treturn (y2-y1)*(x3-x1)/(x2-x1)+y1 == y3;\n}\n\nint main(void)\n{\n\tmake_fact();\n\t\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) cin >> x[i] >> y[i];\n\t\n\tif(N <= 2){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 3; i <= N; i++){\n\t\tans += comb(N, i);\n\t\tans %= mod;\n\t}\n\t\n\tint cnt;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tcnt = 2;\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tif(k == i || k == j) continue;\n\t\t\t\tif(!onLine(x[i], y[i], x[j], y[j], x[k], y[k])) continue;\n\t\t\t\tif(k < j) break;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(cnt >= 3){\n\t\t\t\tfor(int k = 3; k <= cnt; k++){\n\t\t\t\t\tans -= comb(cnt, k);\n\t\t\t\t\tif(ans < 0) ans += mod;\n\t\t\t\t\tans %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PII pair<LL,LL>\n#define fi first\n#define se second\n#define lowbit(x) ((x)&(-(x)))\n#define FOR(i,a,b) for (LL i=(a);i<=(b);++i)\n#define ROF(i,b,a) for (LL i=(b);i>=(a);--i)\ntypedef long long LL;\ninline LL read(){\n\tLL x=0,f=1; char ch=getchar();\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\twhile (ch>='0'&&ch<='9') { x=x*10+ch-'0'; ch=getchar(); }\n\treturn x*f;\n}\n\nconst LL MAXN=300005,Mo=998244353;\nstruct list{\n\tLL l,lt[MAXN],nt[MAXN*2],x[MAXN*2],y[MAXN*2];\n\tvoid clear(){ l=0; memset(lt,0,sizeof(lt)); }\n\tvoid addedge(LL a,LL b){ l++; nt[l]=lt[a]; lt[a]=l; x[l]=b; }\n}E;\nstruct P{\n\tLL x,y;\n\tP(LL xx=0,LL yy=0):x(xx),y(yy){}\n\tP operator +(const P &E)const{ return P(x+E.x,y+E.y); }\n\tP operator -(const P &E)const{ return P(x-E.x,y-E.y); }\n\tLL operator *(const P &E)const{ return x*E.y-E.x*y; }\n\tLL operator ^(const P &E)const{ return x*E.x+y*E.y; }\n}A[MAXN],B[MAXN];\nLL n,m,a[MAXN],b[MAXN];\nLL power(LL a,LL b){\n\tLL c=1; a%=Mo;\n\twhile (b) {\n\t\tif (b&1) c=c*a%Mo;\n\t\ta=a*a%Mo; b>>=1;\n\t}\n\treturn c;\n}\nLL cmp(P i,P j){ return i*j>0; }\nint main(){\n\tn=read();\n\tFOR(i,1,n) a[i]=power(i,Mo-2);\n\tFOR(i,1,n) { A[i].x=read(); A[i].y=read(); }\n\tLL tmp,ans=power(2,n)+Mo-n-1;\n\tif (ans>=Mo) ans-=Mo;\n\t//cout<<ans<<endl;\n\tFOR(i,1,n) {\n\t\tFOR(j,1,i-1) B[j]=A[j]-A[i];\n\t\tFOR(j,i+1,n) B[j-1]=A[j]-A[i];\n\t\tFOR(j,1,n-1) if (B[j].x<0||B[j].x==0&&B[j].y<0) B[j].x=-B[j].x,B[j].y=-B[j].y;\n\t\tsort(B+1,B+n,cmp);\n\t\tfor (LL j=1,k,tot;j<n;j=k+1) {\n\t\t\tfor (k=j;k<n-1&&B[k+1]*B[j]==0;++k);\n\t\t\ttot=k-j+2;\n\t\t\ttmp=(power(2,tot)+Mo-tot-1)*a[tot]%Mo;\n\t\t\t//cout<<i<<':'<<tmp*tot%Mo<<endl;\n\t\t\tans+=Mo-tmp; if (ans>=Mo) ans-=Mo;\n\t\t}\n\t}\n\tcout<<(ans%Mo+Mo)%Mo<<endl;\n\treturn 0;\n}\n\n/*\n4\n0 0\n0 1\n1 0\n1 1\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "//pragma\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define YOU using\n#define DONT namespace\n#define SAY std\n\nYOU DONT SAY;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n\n#define REPP(i,a,b,d) for(int i=a;i<=b;i+=d)\n#define REP(i,a,b) REPP(i,a,b,1)\n#define REVV(i,a,b,d) for(int i=a;i>=b;i-=d)\n#define REV(i,a,b) REVV(i,a,b,1)\n\n#define FOR(i,a) for(int i=0; i<a; i++)\n#define FORD(i,a) for(int i=(int)a-1; i>=0; i--)\n\n#define pb push_back\n#define F first\n#define S second\n\nconst int OO = 1e9;\nconst ll INF = 1e18;\n\nconst int irand(int lo,int hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\nconst ll lrand(ll lo,ll hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\n#define getc getchar\ntemplate<typename T>\nT getnum(){\n\tint sign = 1;\n\tT ret = 0;\n\tchar c;\n\n\tdo{\n\t\tc = getc();\n\t}while(c == ' ' || c == '\\n');\n\tif(c == '-')sign = -1;\n\telse ret = c-'0';\n\twhile(1){\n\t\tc = getc();\n\t\tif(c < '0' || c > '9')break;\n\t\tret = 10*ret + c-'0';\n\t}\n\treturn sign * ret;\n}\n\ninline void ini(int& x){\n\tx = getnum<int>();\n}\n\ninline void scani(int& x){\n\tscanf(\"%d\",&x);\n}\n\n//end of macro\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    #define endl '\\n'\n    cout.setf(ios::fixed);\n    cout.setf(ios::showpoint);\n    cout.precision(10);\n    \n    int n;\n    cin>>n;\n    bool yes = false;\n    while(n){\n    \tif(n%10 == 9)yes = true;\n    \tn /= 10;\n\t}\n\tif(yes)cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n#define mod 998244353\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nconst int FACT_MAX = 200005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nllint n;\nllint x[205], y[205];\nvector<llint> vec;\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tllint cnt = 0, dx = x[j]-x[i], dy = y[j]-y[i];\n\t\t\tfor(int k = 1; k <= n; k++){\n\t\t\t\tllint dx2 = x[k]-x[i], dy2 = y[k]-y[i];\n\t\t\t\tif(dx*dy2 - dx2*dy == 0) cnt++;\n\t\t\t}\n\t\t\tvec.push_back(cnt);\n\t\t}\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tif(vec[i] < 2) continue;\n\t\tllint tmp = modpow(2, vec[i]);\n\t\ttmp += mod - (vec[i]+1), tmp %= mod;\n\t\tans += tmp * modpow(vec[i]*(vec[i]-1)/2, mod-2) % mod, ans %= mod;\n\t}\n\tans += n+1, ans %= mod;\n\t\n\tans = modpow(2, n) - ans + mod, ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\n\nconstexpr long long mod = 998244353;\nconst double pi = acos(-1);\n\nusing P = complex<long long>;\n\nlong long dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\nlong long cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nlong long gcd(long long a, long long b) {\n  a = abs(a);\n  b = abs(b);\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nP tomato(P a) {\n  long long g = gcd(a.real(), a.imag());\n  return P(a.real() / g, a.imag() / g);\n}\n\nbool argcomp(std::complex<long long> p1, std::complex<long long> p2) {\n  bool a = p1.imag() > 0 || (p1.imag() == 0 && p1.real() >= 0);\n  bool b = p2.imag() > 0 || (p2.imag() == 0 && p2.real() >= 0);\n  if (a != b) return a;\n  long long c = p2.real() * p1.imag();\n  long long d = p1.real() * p2.imag();\n  if (c != d) return c < d;\n  return std::norm(p1) < std::norm(p2);\n}\n\nnamespace std {\n  bool operator<(const P &a, const P &b) {\n    return argcomp(a, b);\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<P> ps(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    ps[i] = P(x, y);\n  }\n\n  vector<pair<int, int>> es;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      es.emplace_back(i, j);\n    }\n  }\n  sort(es.begin(), es.end(), [&](pair<int, int> a, pair<int, int> b) {\n    P d = ps[a.second] - ps[a.first];\n    P e = ps[b.second] - ps[b.first];\n    if (cross(d, e) == 0 && dot(d, e) >= 0) {\n      return dot(ps[a.second] - ps[a.first], ps[b.first] - ps[a.first]) < 0;\n    } else {\n      return argcomp(d, e);\n    }\n  });\n\n  static int on[200][200];\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      for (int k = 0; k < n; k++) {\n        if (i == k || j == k) continue;\n        on[i][j] += cross(ps[k] - ps[i], ps[j] - ps[i]) == 0 && dot(ps[k] - ps[i], ps[j] - ps[i]) > 0 && dot(ps[k] - ps[j], ps[i] - ps[j]) > 0;\n      }\n    }\n  }\n\n  static int in[200][200][200];\n  vector<vector<tuple<int, P, int>>> qs(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      qs[i].emplace_back(0, ps[j] - ps[i], j);\n      qs[i].emplace_back(1, ps[j] - ps[i], j);\n    }\n    sort(qs[i].begin(), qs[i].end());\n  }\n  for (int j = 0; j < n; j++) {\n    for (int i = 0; i < n; i++) {\n      if (i == j) continue;\n      P s = tomato(ps[j] - ps[i]);\n      int f = lower_bound(qs[j].begin(), qs[j].end(), make_tuple(0, s, 0)) - qs[j].begin();\n      for (int l = f; l < f + n - 1; l++) {\n        int k = get<2>(qs[j][l]);\n        in[i][j][k] -= l - f + 1;\n        in[j][k][i] -= l - f + 1;\n        in[k][i][j] -= l - f + 1;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      for (int k = 0; k < n; k++) {\n        in[i][j][k] += n;\n        if (in[i][j][k] < 0) {\n          in[i][j][k] = 0;\n        }\n      }\n    }\n  }\n\n  vector<long long> two(n + 1);\n  two[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two[i] = two[i - 1] * 2 % mod;\n  }\n\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    vector<long long> dp1(n);\n    vector<long long> dp2(n);\n    for (auto e : es) {\n      int u = e.first;\n      int v = e.second;\n\n      if (u == i) {\n        assert(dp1[v] == 0);\n        dp1[v] = two[on[u][v]];\n      } else if (v == i) {\n        dp2[v] += dp2[u];\n      } else {\n        int c = on[i][v] + on[u][v] + in[i][u][v];\n        dp2[v] += dp1[u] * two[c];\n        dp2[v] += dp2[u] * two[c];\n      }\n      dp2[v] %= mod;\n    }\n    ans += dp2[i];\n    ans %= mod;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int P=998244353;\nint n;\nstruct pos{\n\tint x,y;\n}ps[1007];\nint ep=0,f[1007],sz[1007];\nint gf(int x){while(x!=f[x])x=f[x]=x[f][f];return x;}\nstruct edge{\n\tint a,b;\n\tint v;\n\tbool operator<(const edge&e)const{return v<e.v;}\n\tvoid cal(){\n\t\tint x=gf(a),y=gf(b);\n\t\tif(x!=y)f[x]=y,sz[y]+=sz[x];\n\t}\n}es[207*207];\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\nint pw[1007],ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor(int i=1;i<=n;++i)pw[i]=pw[i-1]*2%P;\n\tans=(pw[n]-n-1)%P;\n\tfor(int i=0;i<n;++i)scanf(\"%d%d\",&ps[i].x,&ps[i].y);\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=0;j<i;++j){\n\t\t\tint x=ps[i].x-ps[j].x,y=ps[i].y-ps[j].y;\n\t\t\tint g=gcd(x,y);\n\t\t\tx/=g,y/=g;\n\t\t\tif(!x)y=1;\n\t\t\tif(!y)x=1;\n\t\t\tif(x<0)x=-x,y=-y;\n\t\t\tes[ep++]=(edge){i,j,x*30000+y};\n\t\t}\n\t}\n\tstd::sort(es,es+ep);\n\tfor(int i=0,j=0;i<ep;i=j){\n\t\tfor(int a=0;a<n;++a)sz[f[a]=a]=1;\n\t\tfor(;j<ep&&es[i].v==es[j].v;es[j++].cal());\n\t\tfor(int a=0;a<n;++a)if(f[a]==a&&sz[a]>1)ans=(ans-pw[sz[a]]+sz[a]+1)%P;\n\t}\n\tprintf(\"%d\\n\",(ans%P+P)%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mo=998244353;\nconst double pi=acos(-1),eps=1e-10;\nint n,x[205],y[205],s[205],ans;\ndouble a[205]; \n\nint qpow(int a,int b)\n{\n\tint x=a;  a=1;\n\twhile (b)\n\t\t{\n\t\t\tif (b&1)  a=1LL*a*x%mo;\n\t\t\tx=1LL*x*x%mo,b>>=1;\n\t\t}\n\treturn a;\n}\n\nint f(int x){return (qpow(2,x)+mo-(1+x+1LL*x*(x-1)/2)%mo)%mo;}\nint dcmp(double x){return (x>eps)-(x<-eps);}\n\nvoid work()\n{\n\tscanf(\"%d\",&n),ans=f(n);\n\tfor (int i=1; i<=n; i++)  scanf(\"%d %d\",&x[i],&y[i]);\n\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1,k=0; j<=n; j++)\n\t\t\t\tif (i!=j)  a[++k]=atan2(y[i]-y[j],x[i]-x[j]);\n\t\t\tfor (int j=1; j<n; j++)  a[j]+=pi*(a[j]<0);\n\t\t\tsort(a+1,a+n);\n\t\t\tfor (int l,r=1; r<n; )\n\t\t\t\t{\n\t\t\t\t\tl=r;\n\t\t\t\t\twhile ((r<n)&&(dcmp(a[r]-a[l])==0))  r++;\n\t\t\t\t\ts[r-l+1]++;\n\t\t\t\t}\n\t\t}\n\tfor (int i=1; i<=n; i++)  ans=(ans+mo-1LL*s[i]/i*f(i)%mo)%mo;\n\tprintf(\"%d\",ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\nconstexpr long long mod = 998244353;\n\nusing P = complex<int>;\n\nint dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\nint cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nbool argcomp(std::complex<int> p1, std::complex<int> p2) {\n  bool a = p1.imag() > 0 || (p1.imag() == 0 && p1.real() >= 0);\n  bool b = p2.imag() > 0 || (p2.imag() == 0 && p2.real() >= 0);\n  if (a != b) return a;\n  long long c = p2.real() * p1.imag();\n  long long d = p1.real() * p2.imag();\n  if (c != d) return c < d;\n  return std::norm(p1) < std::norm(p2);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<P> ps(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    ps[i] = P(x, y);\n  }\n\n  vector<pair<int, int>> es;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      es.emplace_back(i, j);\n    }\n  }\n  sort(es.begin(), es.end(), [&](pair<int, int> a, pair<int, int> b) {\n    P d = ps[a.second] - ps[a.first];\n    P e = ps[b.second] - ps[b.first];\n    if (cross(d, e) == 0 && dot(d, e) >= 0) {\n      return dot(ps[a.second] - ps[a.first], ps[b.first] - ps[a.first]) < 0;\n    } else {\n      return argcomp(d, e);\n    }\n  });\n\n  static int in[200][200][200];\n  static int on[200][200];\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) continue;\n      for (int k = 0; k < n; k++) {\n        if (i == k || j == k) continue;\n        for (int l = 0; l < n; l++) {\n          if (i == l || j == l || k == l) continue;\n          if (cross(ps[j] - ps[i], ps[l] - ps[i]) > 0 && cross(ps[k] - ps[j], ps[l] - ps[j]) > 0 && cross(ps[i] - ps[k], ps[l] - ps[k]) > 0) {\n            in[i][j][k]++;\n          }\n        }\n        on[i][j] += cross(ps[k] - ps[i], ps[j] - ps[i]) == 0 && dot(ps[k] - ps[i], ps[j] - ps[i]) > 0 && dot(ps[k] - ps[j], ps[i] - ps[j]) > 0;\n      }\n    }\n  }\n\n  vector<long long> two(n + 1);\n  two[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two[i] = two[i - 1] * 2 % mod;\n  }\n\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    vector<long long> dp1(n);\n    vector<long long> dp2(n);\n    for (auto e : es) {\n      int u = e.first;\n      int v = e.second;\n\n      if (u == i) {\n        assert(dp1[v] == 0);\n        dp1[v] = two[on[u][v]];\n      } else if (v == i) {\n        dp2[v] += dp2[u];\n      } else {\n        int c = on[i][v] + on[u][v] + in[i][u][v];\n        dp2[v] += dp1[u] * two[c];\n        dp2[v] += dp2[u] * two[c];\n      }\n      dp2[v] %= mod;\n    }\n    ans += dp2[i];\n    ans %= mod;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define mod 998244353\n#define P pair<int,int>\nusing namespace std;\n\nP a[200];\nsigned main() {\n\tint ans = 1;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = ans * 2 % mod;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t}\n\tans -= n + 1;\n\tans %= mod;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tvector<int>V;\n\t\t\tif (a[i].first == a[j].first) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].first == a[i].first) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (a[i].second == a[j].second) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].second == a[i].second) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble x = double(a[j].second - a[i].second) / (a[j].first - a[i].first);\n\t\t\t\tdouble y = double(a[i].second) - a[i].first*x;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (abs(a[i].first*x + y - a[i].second) <= 1e-10) {\n\t\t\t\t\t\tV.push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(V.begin(), V.end());\n\t\t\tif (V.size()>=2&&V[0] == i&&V[1]==j) {\n\t\t\t\tint k = 1;\n\t\t\t\tfor (int j : V) {\n\t\t\t\t\tk = k * 2 % mod;\n\t\t\t\t}\n\t\t\t\tk -= V.size(); k--;\n\t\t\t\tans -= k;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tans += mod * 5;\n\tans %= mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint cnt[201][201] = {};\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nlong long moving[1000] = {};\nint main() {\n#define int long long\n\tvector<pair<int, int>> inputs;\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tinputs.push_back(make_pair(a, b));\n\t}\n\tmoving[0] = 1;\n\tfor (int i = 1; i < 1000; ++i) {\n\t\tmoving[i] = moving[i - 1] * 2;\n\t\tmoving[i] %= MOD;\n\t}\n\tlong long ans = moving[n];\n\tlong long tmp = n + 1;\n\tmap<tuple<long long, long long, long long>, int> edges;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int q = i + 1; q < n; ++q) {\n\t\t\tif (cnt[i][q] == 1) break;\n\t\t\tlong long A = inputs[q].first - inputs[i].first;\n\t\t\tlong long B = inputs[i].second - inputs[q].second;\n\t\t\tlong long C = (inputs[i].first - inputs[q].first) * inputs[i].second + (inputs[q].second - inputs[i].second) * inputs[i].first;\n\t\t\tlong long geko = 0;\n\t\t\tif (A == 0) {\n\t\t\t\tgeko = llabs(B);\n\t\t\t}\n\t\t\telse if (B == 0) {\n\t\t\t\tgeko = llabs(A);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeko = gcd(llabs(A), llabs(B));\n\t\t\t}\n\t\t\tif (geko == 0) {\n\t\t\t\tgeko = llabs(C);\n\t\t\t}\n\t\t\telse if (C == 0) {\n\t\t\t\tgeko = llabs(geko);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeko = gcd(llabs(C), llabs(geko));\n\t\t\t}\n\t\t\tif (geko != 0) {\n\t\t\t\tA /= geko;\n\t\t\t\tB /= geko;\n\t\t\t\tC /= geko;\n\t\t\t}\n\t\t\tif (A < 0) {\n\t\t\t\tA = -A;\n\t\t\t\tB = -B;\n\t\t\t\tC = -C;\n\t\t\t}\n\t\t\tedges[make_tuple(A, B, C)]++;\n\t\t}\n\t}\n\tfor (auto i = edges.begin(); i != edges.end(); ++i) {\n\t\tint cnt = 0;\n\t\tfor (int q = 1;; ++q) {\n\t\t\tcnt += q;\n\t\t\tassert(cnt <= n * n * n);\n\t\t\tif (i->second == cnt) {\n\t\t\t\ttmp += moving[q + 1] - (q + 1) - 1;\n\t\t\t\ttmp += MOD;\n\t\t\t\ttmp %= MOD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans + (MOD - tmp)) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 998244353;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n  unsigned get() const { return x; }\n\n  // 逆数\n  ModInt inv() const {\n    ll a = 1, p = x, e = MOD-2;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // e乗\n  ModInt pow(ll e) {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // 2のx乗\n  ModInt pow2() {\n    ll a = 1, p = 2, e = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // 代入\n  void operator=(ll b) { x = b; }\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  ModInt &operator+=(ModInt that) {\n    x = ((ll)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((ll)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (ll)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (ll)x * that.inv() % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (ll)x % that.x;\n    return *this;\n  }\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) == 0; // triangle inequality\n}\nP p[205];\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) {\n    double x, y;\n    cin >> x >> y;\n    p[i] = {x, y};\n  }\n\n  mint ret = mint(n).pow2() - n - 1;\n  REP(i, n) FOR(j, i+1, n) {\n    mint cnt = 0;\n    REP(k, n) if(k!=i && k!=j && intersectSP(L(p[i], p[j]), p[k])) ++cnt;\n    ret -= cnt.pow2();\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\nusing namespace std;\nint main(){\n\tint N; \n\tcin >> N; \n\tlong long int X[210] = {}; \n\tlong long int Y[210] = {}; \n\tfor(int i = 0; i < N; i++){\n\t\tcin >> X[i] >> Y[i]; \n\t}\n\tlong long int P = 998244353; \n\tlong long int A[210] = {}; // 一般項2^n-n-1\n\tbool B[210][210] = {}; \n\tfor(int i = 1; i <= 200; i++){\n\t\tA[i] = (2 * A[i-1] + i - 1) % P; \n\t}\n\tlong long int ans = A[N]; \n\tfor(int i = 0; i < N; i++){ //2点以下の集合も含めて和をとると，各部分集合が1回ずつ数えられる(ように重みが設定されている)ので総和は2^N．2点以下の分を引く．0点は1，1点はN，2点はちょうどm点が一直線上とすると2^m-m-1で，これをすべての直線について加える．\n\t\tfor(int j = i+1; j < N; j++){\n\t\t\tif(B[i][j] == true) continue;\n\t\t\tvector<int> tansaku; \n\t\t\ttansaku.push_back(i); \n\t\t\ttansaku.push_back(j); \n\t\t\tfor(int k = j+1; k < N; k++){\n\t\t\t\tlong long int s = (Y[i]-Y[j])*X[k] + (X[j]-X[i])*Y[k] - (Y[i]*X[j]-X[i]*Y[j]);\n\t\t\t\tif(s == 0){\n\t\t\t\t\ttansaku.push_back(k); \n\t\t\t\t}\n\t\t\t}\n\t\tint c = tansaku.size(); \n\t\tfor(int p = 0; p < c; p++){\n\t\t\tfor(int q = p+1; q < c; q++){\n\t\t\t\tB[tansaku.at(p)][tansaku.at(q)] = true; \n\t\t\t}\n\t\t}\n          \tans = (ans + P - A[c]) % P; \n\t\t}\n\t}\n\tcout << ans << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) < norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[m][m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<cmath>\n#include<stdlib.h>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nconst int MX = 205;\nconst int MM = 998244353;\n\nint N;\npii D[MX];\n\npii operator-(const pii &l, const pii &r){\n\treturn pii(l.first - r.first, l.second - r.second);\n}\n\nll operator /(const pii &l, const pii &r){\n\treturn (ll)l.first * r.second - (ll)l.second * r.first;\n}\n\nll pw2[MX];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d%d\", &D[i].first, &D[i].second);\n\t}\n\tll ans = 1;\n\tpw2[0] = 1;\n\tfor(int i = 1; i <= N; i++) pw2[i] = pw2[i-1]*2 % MM;\n\tans = pw2[N];\n\tans = (ans - N*(N-1)/2 - N - 1) % MM;\n\tans = (ans + MM) % MM;\n\n\tint vst[MX][MX] = {};\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = i+1; j <= N; j++){\n\t\t\tif( vst[i][j] ) continue;\n\t\t\tvector<int> P;\n\t\t\tfor(int k = 1; k <= N; k++){\n\t\t\t\tif( (D[i] - D[j]) / (D[i] - D[k]) == 0 ) P.push_back(k);\n\t\t\t}\n\t\t\tint sz = P.size();\n\t\t\tif( sz >= 3 ) ans = ((ans - pw2[sz] + sz*(sz-1)/2 + sz + 1) % MM + MM) % MM;\n\t\t\tfor(int c : P){\n\t\t\t\tfor(int d : P) vst[c][d] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int int64_t\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\twhile(a >= mod)\n\t\ta -= mod;\n\twhile(a < 0)\n\t\ta += mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a - o) < norm(b - o);});\n\t\tint m = pts.size();\n\t\tint dp[m][m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 210, mod = 998244353;\nint n;\nint x[N], y[N];\nll ans;\nll p[N];\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d%d\", &x[i], &y[i]);\n\tp[0] = 1;\n\tfor(int i = 1; i <= n; ++i) p[i] = (p[i - 1] << 1) % mod;\n\tans = p[n] - n * (n - 1) / 2 - n - 1;\n\tfor(int i = 1; i <= n; ++i)  \n\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t{\n\t\t\tint cnt = 0;   \n\t\t\tfor(int k = j + 1; k <= n; ++k) if((y[k] - y[i]) * (x[k] - x[j]) == (y[k] - y[j]) * (x[k] - x[i])) ++cnt;\n\t\t\tans = ((ans - p[cnt] + 1) % mod + mod) % mod;\n\t\t}\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int N = 211;\nconst int mod = 998244353;\nint n;\nLL base[N];\nstruct ddd{\n    int x, y;\n}nd[N];\nLL sq(LL x){return x * x;}\nbool check(LL x1, LL y1, LL x2, LL y2){\n    LL a = x1 * x2 + y1 * y2;\n    LL b = (sq(x1) + sq(y1)) * (sq(x2) + sq(y2));\n    return a > 0 && b == sq(a);\n}\nint main(){\n    cin>>n;\n    for(int i = 1;i <= n; i++){\n        scanf(\"%d%d\", &nd[i].x, &nd[i].y);\n    }\n    base[0] = 1;\n    for(int i = 1;i <= 200; i++)base[i] = base[i-1] * 2 % mod;\n    LL ans = (base[n] - 1 - n + mod) % mod;\n    for(int i = 2;i <= n; i++){\n        for(int j = 1;j < i; j++){\n            int tot = 0;\n            for(int k = 1;k <= n; k++){\n                if(i == k || j == k)continue;\n                if(check(nd[i].x - nd[k].x, nd[i].y - nd[k].y, nd[k].x - nd[j].x, nd[k].y - nd[j].y))tot++;\n            }\n            ans = (ans + mod - base[tot]) % mod;\n            //printf(\"i=%d j=%d tot=%d\\n\", i, j, tot);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stdio.h>\nusing namespace std;\n#define ll long long\ntypedef pair<ll,ll> pi;\nint n;\npi arr[205];\nll mod = 998244353;\nll answer = 0;\nll factorial[205];\nll ifactorial[205];\nvector<ll> v;\nbool collinear[205][205];\n\nll power(ll a, ll b){\n\ta %= mod;\n\tif (b == 0) return 1;\n\tif (b == 1) return a;\n\tll half = power(a, b/2);\n\thalf*=half;\n\thalf%=mod;\n\tif (b % 2 == 1){\n\t\thalf *= a;\n\t\thalf %= mod;\n\t}\n\treturn half;\n}\n\nvoid init(){\n\tfactorial[0] = 1;\n\tfor (int i = 1; i < 205; i++){\n\t\tfactorial[i] = factorial[i - 1]*i;\n\t\tfactorial[i] %= mod;\n\t}\n\tfor (int i = 1; i < 205; i++){\n\t\tifactorial[i] = power(factorial[i], mod - 2);\n\t}\n\t\n}\n\nll choose(ll n, ll k){\n\tif (n == k) return (long long)1;\n\treturn (((factorial[n]*ifactorial[k])%mod)*ifactorial[n - k])%mod;\n}\n\nll adjust(ll x){\n\tx %= mod;\n\tif (x < 0){\n\t\tx += mod;\n\t}\n\treturn x;\n}\n\nint main(){\n\tinit();\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lld%lld\", &arr[i].first, &arr[i].second);\n\t}\n\tsort(arr, arr + n);\n\tll answer = 0;\n\tfor (int i = 3; i <= n; i++){\n\t\tanswer += choose(n, i);\n\t\tanswer = adjust(answer);\n\t\t//cout << \"choose (\" << n << \", \" << i << \") = \" << choose(n, i) << endl;\n\t}\n\tanswer = adjust(answer);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = i + 1; j < n; j++){\n\t\t\tif (collinear[i][j]) continue;\n\t\t\tv.clear();\n\t\t\tv.push_back(i);\n\t\t\tv.push_back(j);\n\t\t\tfor (int k = j + 1; k < n; k++){\n\t\t\t\tif ((arr[i].second - arr[j].second)*(arr[i].first - arr[k].first) == (arr[i].second - arr[k].second)*(arr[i].first - arr[j].first)){\n\t\t\t\t\tv.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < (int)v.size(); k++){\n\t\t\t\tfor (int l = 0; l < (int)v.size(); l++){\n\t\t\t\t\tcollinear[k][l] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 3; k <= (int)v.size(); k++){\n\t\t\t\tanswer -= choose((long long)v.size(), (long long)k);\n\t\t\t\tanswer = adjust(answer);\n\t\t\t}\n\t\t}\n\t}\n\tanswer = adjust(answer);\n\tprintf(\"%lld\\n\", answer);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=205;\nconst int mod=998244353;\nstruct point{\n\tint x,y;\n}c[maxn];\nint n;\nLL _2[maxn],ans;\nint main(){\n\tscanf(\"%d\",&n);\n\t_2[0]=1;\n\tfor(int i=1;i<=n;i++) _2[i]=_2[i-1]<<1%mod;\n\tans=_2[n]-n-1;\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&c[i].x,&c[i].y);\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tint cnt=0;\n\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\tif((c[i].x-c[k].x)*(c[j].y-c[k].y)==(c[j].x-c[k].x)*(c[i].y-c[k].y)) cnt++;\n\t\t\t}\n\t\t\tans=(ans-_2[cnt]+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n \nusing namespace std;\n \nconst int MAXN = 200 + 10;\nconst int MOD = 998244353;\n \nstruct TPoint\n{\n\tlong long x, y;\n};\n \nlong long CrossProduct(TPoint A, TPoint B, TPoint C)\n{\n\treturn (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);\n}\n \nint n;\nlong long twomod[MAXN];\nlong long C[MAXN][MAXN];\nlong long arr[MAXN];\nTPoint p[MAXN];\nint used[MAXN];\nint redu[MAXN];\n \nvoid Work()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i ++)\n\t\tscanf(\"%lld%lld\", &p[i].x, &p[i].y);\n\ttwomod[0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\ttwomod[i] = (twomod[i - 1] + twomod[i - 1]) % MOD;\n\tC[0][0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tC[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j ++)\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n\t}\n \n\tfor (int tt = 3; tt <= n; tt ++)\n\t{\n\t\tarr[tt] = 0;\n\t\tfor (int i = 3; i <= tt; i ++)\n\t\t\tarr[tt] = (arr[tt] + C[tt][i]) % MOD;\n\t}\n \n\tlong long ans = arr[n];\n\t\n\tfor (int i = 0; i < n; i ++)\n\t\tfor (int j = 0; j < n; j ++) if (i != j)\n\t\t{\n\t\t\tlong long c = 2;\n\t\t\tfor (int k = 0; k < n; k ++) if (i != k && j != k)\n\t\t\t\tif (CrossProduct(p[i], p[j], p[k]) == 0)\n\t\t\t\t\tc ++;\n\t\t\t//printf(\"%d %d %d\\n\", i, j, c);\n\t\t\tredu[c] ++;\n\t\t}\n \n\tfor (int c = 3; c <= n; c ++)\n\t{\n\t\tif (redu[c] == 0) continue;\n\t\tlong long times = redu[c] / (c * (c - 1));\n\t\tans -= (arr[c] * times) % MOD;\n\t\tans += MOD;\n\t\tans %= MOD;\n\t}\n \n\tprintf(\"%lld\\n\", ans);\n}\n \nint main()\n{\n\tWork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int mod=998244353;\nint x[2005],y[2005],tw[2100],n,num,ans;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>x[i]>>y[i];\n\ttw[0]=1;\n\tfor(int i=1;i<=2000;i++)\n\t\ttw[i]=(tw[i-1]<<1)%mod;\n\tans=tw[n]-n-1;\n\t//cout<<tw[n]<<endl;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tnum=0;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\t\tif((x[j]-x[i])*(y[k]-y[j])==(x[k]-x[j])*(y[j]-y[i]))\n\t\t\t\t\tnum++;\n\t\t\tans=(ans-tw[num]+mod)%mod;\n\t\t//\tcout<<i<<\" \"<<j<<\" \"<<ans<<endl;\n\t\t}\n\t//ans-=(n+1);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int maxn = 2e2 + 10;\nconst long long mod = 998244353;\n\nint n;\nlong double x[maxn], y[maxn];\nlong long pot[maxn];\n\nlong long solve() {\n\tpot[0] = 1LL;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tpot[i] = (pot[i - 1] * 2LL) % mod;\n\n\tlong long ans = (pot[n] - 1 + mod) % mod;\n\n\tfor(int i = 1; i <= n; ++i) {\n\t\tmap <long double, int> angle;\n\n\t\tfor(int j = i + 1; j <= n; ++j) {\n\t\t\tlong double dx = x[i] - x[j];\n\t\t\tlong double dy = y[i] - y[j];\n\n\t\t\t++angle[dy / dx];\n\t\t}\n\n\t\tlong long add = 0;\n\n\t\tfor(auto it: angle) \n\t\t\tadd = (add + pot[it.second] - 1 + mod) % mod;\n\n\t\tadd = (add + 1) % mod;\n\n\t\tans = (ans - add + mod) % mod;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tcin >> x[i] >> y[i];\n\n\tcout << solve() << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint dx[] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n/*\n#define cin ifs\n#define cout ofs\nifstream ifs(\"in.txt\");\nofstream ofs(\"out.txt\");\n//*/\n\nint N;\nint x[200], y[200];\nint mod = 998244353;\nbool used[200][200];\n\nsigned main() {\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    int ans = 1;\n    for (int i = 0; i < N; i++) {\n        ans *= 2;\n        ans %= mod;\n    }\n    ans -= 1 + N;\n    ans += mod;\n    ans %= mod;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j)\n                continue;\n            int cur = 0;\n            int diff = 1;\n            for (int k = 0; k < N; k++) {\n                if (used[i][k] && used[j][k] &&\n                    (x[i] - x[j]) * (y[i] - y[k]) ==\n                        (x[i] - x[k]) * (y[i] - y[j])) {\n                    goto check;\n                }\n            }\n            for (int k = 0; k < N; k++) {\n                if ((x[i] - x[j]) * (y[i] - y[k]) ==\n                    (x[i] - x[k]) * (y[i] - y[j])) {\n                    cur++;\n                    used[i][k] = used[k][i] = true;\n                }\n            }\n            for (int k = 0; k < cur; k++) {\n                diff *= 2;\n                diff %= mod;\n            }\n            diff -= 1 + cur;\n            diff += mod;\n            diff %= mod;\n            ans -= diff;\n            ans += mod;\n            ans %= mod;\n        check:;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <set>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define repn(i, m, n) for(i = m; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef complex<double> P;\n\nint mod = 998244353;\nint pow2[201];\nint n;\nP p[100];\n\ndouble cross(P a, P b) { return a.real() * b.imag() - a.imag() * b.real(); }\nbool onLine(P a, P b, P p) { return cross(b - a, p - a) == 0; }\n\nsigned main() {\n\tint i, j, k;\n\t\n\tpow2[0] = 1;\n\trepn(i, 1, 201) pow2[i] = (pow2[i - 1] * 2) % mod;\n\t\n\tcin >> n;\n\trep(i, n) { double x, y; cin >> x >> y; p[i] = P(x, y); }\n\t\n\tint ans = pow2[n];\n\t\n\tset<vector<int> > dict;\n\trep(i, n) {\n\t\trepn(j, i + 1, n) {\n\t\t\tvector<int> vec;\n\t\t\trep(k, n) if (onLine(p[i], p[j], p[k])) vec.push_back(k);\n\t\t\tif (dict.find(vec) != dict.end()) continue;\n\t\t\tdict.insert(vec);\n\t\t\tans += mod - (pow2[vec.size()] - vec.size() - 1);\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tans += mod - n - 1; ans %= mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n\n//点集合Sについて、Sが凸多角形なら「2^(凸多角形Sの内部にある点の個数)」がスコアになる。それ以外なら0がスコアになる。スコアの和を求めたい。\n//2^nが何を表すか？例えば、{1,2,…,n}の部分集合は2^n個ある。つまり、Sが凸多角形のときのスコアは、{Sの内部にある点}の部分集合の個数と等しい。\n//そこで、「点集合Sについて、Sの凸法が存在するなら1点, 存在しないなら0点」というスコアリングを考える。実はこれの和が、そのまま答えになる。\n//なぜだろうか。Sの凸法が存在するとき、凸法の点集合をTとおいてみる。Sが与えられたとき、Tはちょうど1個に定まる。ここで、S->Tという写像fを\n//考える。すると、各Tについて「2^(凸多角形Tの内部にある点の個数)」だけ矢印が来ていることが分かる。\n//また、写像fによって得られるTの集合（値域）は、与えられたN個の点によって作ることのできる「凸多角形」の集合と一致する。\n//新しいスコアリングでは、矢印の個数の和が合計スコアとなるが、これは上述より本問の答えと一致した。\n//\n//したがって、「凸法が存在するような点集合S」の個数を求める問題になる。補問題として「凸法が存在しないような点集合S」を考えると、Sは\n//直線または点または空集合を表すことが分かる。したがって、まず「答え=2^N」を仮定し、\n//そのような直線を全部列挙し、2^(乗っている点の個数) - (乗っている点の個数) - 1\n//を答えから引いていき、最後に答えからN+1を引けば、正しい答えが求まる。\n//計算量はO(N^3)となる()\n//\n//直線の列挙法：\n//直線は「乗っている点の集合X」と一対一対応するので、Xが今までに出現していないときだけ、リストに追加すればOK.\n//既に現れた点集合Xを、ハッシュで管理するとO(N^3), setで管理するとO(N^3logN)となる。"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#include <bitset>\n#include <complex>\n#include <cmath>\n#include <array>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3fLL\n#define mod 998244353\n#define MOD 1000000007\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pint;\ntypedef pair<ll,ll> pll;\ntypedef tuple<int,int,int> tint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<ull> vull;\ntypedef vector<pint> vpint;\nint dx[8]={0,0,-1,1,1,1,-1,-1};\nint dy[8]={-1,1,0,0,1,-1,1,-1};\nconst int SIZE=250;\n//ここまでテンプレ\nvint X,Y;\nbool onLine(int i,int j,int k){\n\tint ret=(X[j]-X[i])*(Y[k]-Y[i])-(Y[j]-Y[i])*(X[k]-X[i]);\n\treturn !ret;\n}\nint main(){\n\tint N;\n\tcin>>N;\n\tfor(int i=0;i<N;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tX.pb(x);\n\t\tY.pb(y);\n\t}\n\tset<vint> tes;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\tvint v;\n\t\t\tv.pb(i);\n\t\t\tv.pb(j);\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tif(i==k || j==k)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(onLine(i,j,k))\n\t\t\t\t\tv.pb(k);\n\t\t\t}\n\t\t\tsort(v.begin(),v.end());\n\t\t\ttes.insert(v);\n\t\t}\n\t}\n\tint di[SIZE]={1,0};\n\tfor(int i=1;i<SIZE;i++)\n\t\tdi[i]=di[i-1]*2;\n\tll ans=1+N;\n\tfor(vint v:tes){\n\t\tint n=v.size();\n\t\t(ans+=di[n]-n-1)%=mod;\n\t}\n\tcout<<(di[N]+mod-ans)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 998244353\n#define N 210\n\nint n;\n\nll power(ll x,ll y) {\n\tif (!y) return 1;\n\tll ret=power(x,y>>1)%mod;\n\tret=ret*ret%mod;\n\tif (y&1) ret=ret*x%mod;\n\treturn ret%mod;\n}\n\nint x[N],y[N],A,B,cnt;\nll ans,C;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d%d\",&x[i],&y[i]);\n\tans=power(2,n);\n\tans=(ans-1+mod)%mod;\n\tans=(ans-n+mod)%mod;\n\tans=(ans-(ll)(n-1)*n/2+mod)%mod;\n\t\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tA=y[i]-y[j];\n\t\t\tB=x[j]-x[i];\n\t\t\tC=-x[i]*A-y[i]*B;\n\t\t\tcnt=2;\n\t\t\tfor (int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tif (k==i || k==j) continue;\n\t\t\t\tif (A*x[k]+B*y[k]+C!=0) continue;\n\t\t\t\tif (k<j) break;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tans=(ans-power(2,cnt)+mod)%mod;\n\t\t\tans=(ans+1)%mod;\n\t\t\tans=(ans+cnt)%mod;\n\t\t\tans=(ans+(ll)(cnt-1)*cnt/2)%mod;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define SORT(c) sort((c).begin(), (c).end())\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> V;\ntypedef map<int, int> M;\n\nconstexpr ll INF = 1e18;\nconstexpr ll MOD = 998244353;\nconstexpr double PI = 3.14159265358979323846;\nconstexpr int di[] = {0, 0, 1, -1};\nconstexpr int dj[] = {1, -1, 0, 0};\n\nll fastPow(ll x, ll n)\n{\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return fastPow(x * x % MOD, n / 2);\n    else\n        return x * fastPow(x, n - 1) % MOD;\n}\n\nll fac[112346];\nvoid combInit(int mx)\n{\n    fac[0] = 0;\n    fac[1] = 1;\n    for (int i = 2; i <= mx; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n}\n\nll modDiv(ll a, ll b)\n{\n    return a * fastPow(b, MOD - 2) % MOD;\n}\n\nll comb(ll a, ll b)\n{\n    if (b == 0)\n        return 1;\n    if (a < b)\n        return 0;\n    if (a <= 0 || b < 0)\n        return 0;\n    if (a == b)\n        return 1;\n\n    ll p, c;\n\n    c = modDiv(fac[a], fac[a - b]);\n    p = fac[b];\n\n    ll res = modDiv(c, p);\n\n    return res;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    combInit(210);\n\n    int n, x[210], y[210];\n\n    ll li[210];\n    fill(li, li + n + 1, 0);\n\n    cin >> n;\n    REP(i, n)\n    cin >> x[i] >> y[i];\n\n    ll res = 0;\n\n    bool used[210][210];\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            used[i][j] = i == j;\n\n    V l;\n\n    for (int i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++)\n        {\n            if (used[i][j])\n                continue;\n\n            V v;\n\n            v.push_back(i);\n            v.push_back(j);\n\n            int cnt = 2;\n            for (int k = j + 1; k < n; k++)\n            {\n                int a = (x[j] - x[i]) * (y[k] - y[j]);\n                int b = (y[j] - y[i]) * (x[k] - x[j]);\n\n                if (a == b)\n                {\n                    cnt++;\n\n                    v.push_back(k);\n                }\n            }\n\n            if (cnt > 2)\n            {\n                for (int k = 0; k < v.size(); k++)\n                    for (int m = 0; m < v.size(); m++)\n                        used[v[k]][v[m]] = true;\n\n                l.push_back(cnt);\n            }\n        }\n\n    for (int i = 3; i <= n; i++)\n    {\n        ll tmp = 0;\n        tmp += comb(n, i);\n\n        for (int j : l)\n        {\n            if (i > j)\n                continue;\n            tmp += MOD - comb(j, i);\n            tmp %= MOD;\n        }\n\n        res += tmp;\n        res %= MOD;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define SZ(x) int((x).size())\n#define mp make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n\nconst LL mod=998244353;\nconst double PI=acos(-1);\nconst double EPS=1e-6;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\nLL qmod(LL a,LL b,LL c){\n    LL ret=1;\n    for(;b;b>>=1){\n        if(b&1) ret=ret*a%c;\n        a=a*a%c;\n    }\n    return ret;\n}\n\ninline void add(LL &x,LL y){\n    x+=y;\n    if(x>=mod) x-=mod;\n}\n\nLL has[205];\n\ninline LL cal(int n){\n    if(n<3) return 0;\n    if(has[n]) return has[n];\n    LL ans=qmod(2,n,mod);\n    add(ans,mod-1-n);\n    add(ans,mod-n*(n-1)/2);\n    return has[n]=ans;\n}\n\nint x[205],y[205];\n\ninline bool check(int i,int j,int k){\n    int ax=x[k]-x[i];\n    int bx=x[k]-x[j];\n    int ay=y[k]-y[i];\n    int by=y[k]-y[j];\n    return (ax*by-ay*bx)==0;\n}\n\nint main(){//ios_base::sync_with_stdio(0);cin.tie(0);\n    int n=readint();\n    for(int i=1;i<=n;i++) x[i]=readint(),y[i]=readint();\n    LL ans=cal(n);\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<=n;j++){\n            int cnt=0;\n            for(int k=1;k<=j;k++) cnt+=check(i,j,k);\n            if(cnt>2) continue;\n            for(int k=j+1;k<=n;k++) cnt+=check(i,j,k);\n            add(ans,mod-cal(cnt));\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define rep(i,n) for(int i=0;i<n;++i)\n#define srep(i,s,n) for(int i=s;i<n;++i)\n#define rrep(i,n) for(int i=n-1;i>=0;--i)\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\n\nstruct UnionFind\n{\n        ull *parent, *count, *rank;\n\n        UnionFind(ull n) {\n                parent = new ull[n+1];\n                count = new ull[n+1];\n                rank = new ull[n+1];\n                for (ull i = 0ULL; i < n+1; ++i) {\n                        parent[i] = i;\n                        count[i] = 1;\n                        rank[i] = 0;\n                }\n        }\n\n        ull root(ull i) {\n                if (parent[i] == i) return i;\n                parent[i] = root(parent[i]);\n                return parent[i];\n        }\n\n        void unite(ull i, ull j) {\n                ull rooti = root(i);\n                ull rootj = root(j);\n\n                if (rooti == rootj) return;\n\n                if (rank[rootj] < rank[rooti]) {\n                        parent[i] = parent[j] = parent[rootj] = rooti;\n                        count[rooti] += count[rootj];\n                }\n                else {\n                        parent[i] = parent[j] = parent[rooti] = rootj;\n                        count[rootj] += count[rooti];\n                        if (rank[rootj] == rank[rooti]) rank[rootj]++;\n                }\n        }\n\n        bool same(ull i, ull j) {\n                return root(i) == root(j);\n        }\n};\n\nstruct BIT\n{\n        ll *tree;\n        ll size;\n\n        BIT(ll n, ll init) {\n                tree = new ll[n+1];\n                size = n;\n                rep (i, n+1) tree[i] = init;\n        }\n\n        // idx is 1 origin\n        void add(ll idx, ll x) {\n                assert(idx > 0LL);\n                while (idx <= size) {\n                        tree[idx] += x;\n                        idx += (idx & (-idx));\n                }\n        }\n\n        // idx is 1 origin\n        ll sum(ll idx) {\n                assert(idx > 0LL);\n                ll ret = 0LL;\n                while (idx > 0LL) {\n                        ret += tree[idx];\n                        idx -= (idx & (-idx));\n                }\n                return ret;\n        }\n};\n\nstruct MaxFlow {\n        V<ll> links[1005];\n        ll capacities[1005][1005];\n        ll nodes;\n\n        MaxFlow(ll nodes) {\n                // i == 0       --> S\n                // i == nodes+1 --> T\n                rep (i, nodes+2LL) links[i].clear();\n                memset(capacities, 0, sizeof(capacities));\n                this->nodes = nodes;\n        }\n\n        void add_path(ll a, ll b, ll capacity) {\n                links[a].pb(b);\n                links[b].pb(a);\n                capacities[a][b] = capacity;\n                capacities[b][a] = 0LL;\n        }\n\n        ll solve(void) {\n                deque<V<ll>> q;\n                ll ret = 0LL;\n\n                for ( ; ; q.clear()) {\n\n                        V<ll> start;\n                        start.pb(0);\n                        q.push_front(start);\n\n                        bool checked[nodes+2];\n                        memset(checked, 0, sizeof(checked));\n\n                        V<ll> found;\n\n                        for ( ; !(q.empty()); ) {\n                                V<ll> path = q.front(); q.pop_front();\n                                ll last = path[path.size()-1];\n\n                                if (checked[last]) continue;\n                                if (last == nodes+1) {\n                                        found = path;\n                                        break;\n                                }\n\n                                checked[last] = true;\n                                for (auto next : (links[last])) {\n                                        if (capacities[last][next] == 0) continue;\n                                        V<ll> newpath(path);\n                                        newpath.pb(next);\n                                        q.push_front(newpath);\n                                }\n                        }\n\n                        if (found.size() == 0) {\n                                break;\n                        }\n                        else {\n                                ll flowcount = capacities[found[0]][found[1]];\n                                rep (i, found.size()-1) {\n                                        ll src = found[i];\n                                        ll dst = found[i+1];\n                                        flowcount = min(flowcount, capacities[src][dst]);\n                                }\n                                rep (i, found.size()-1) {\n                                        ll src = found[i];\n                                        ll dst = found[i+1];\n                                        capacities[src][dst] -= flowcount;\n                                        capacities[dst][src] += flowcount;\n                                }\n                                ret += flowcount;\n                        }\n                }\n\n                return ret;\n        }\n};\n\nvoid llin(ll &a)\n{\n        cin >> a;\n}\n\nvoid llinl1(auto &v, ll count)\n{\n        for (ll i = 0LL; i < count ; ++i) {\n                ll a;\n                cin >> a;\n                v.push_back(a);\n        }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n        for (ll i = 0LL; i < count ; ++i) {\n                ll a, b;\n                cin >> a >> b;\n                v.push_back(tuple<ll, ll>(a, b));\n        }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n        for (ll i = 0LL; i < count ; ++i) {\n                ll a, b, c;\n                cin >> a >> b >> c;\n                v.push_back(tuple<ll, ll, ll>(a, b, c));\n        }\n}\n\nvoid llina(auto &v, ll count)\n{\n        llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n        T ret = v[0];\n        for (auto i : v) ret = min(ret, i);\n        return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n        T ret = v[0];\n        for (auto i : v) ret = max(ret, i);\n        return ret;\n}\n\nll absll(ll x)\n{\n        if (x < 0) return -x;\n        return x;\n}\n\nll mod_sub(ll x, ll y, ll mod)\n{\n        ll ret = x - y;\n        while (ret < 0) ret += mod;\n        return ret;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n        ll ret = 0LL;\n        x %= mod;\n\n        while (y) {\n                if (y & 1LL) {\n                        ret += x;\n                        ret %= mod;\n                }\n                y >>= 1;\n                x <<= 1;\n                x %= mod;\n        }\n\n        return ret;\n}\n\nll mod_pow(ll base, ll exp, ll mod)\n{\n        ll ret = 1LL;\n\n        for ( ; exp; ) {\n                if (exp & 1LL) {\n                        ret *= base;\n                        ret %= mod;\n                }\n                base = (base * base) % mod;\n                exp >>= 1;\n        }\n\n        return ret;\n}\n\nll mod_inv(ll x, ll mod)\n{\n        // available only when mod is prime\n        return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n        while (y != 0) {\n                ll z = x % y;\n                x = y;\n                y = z;\n        }\n        return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n        sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n        sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n        for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n                if (x % i == 0LL) {\n                        retlist.push_back(i);\n                        retlist.push_back(x / i);\n                }\n        }\n}\n\nvoid get_factors(V<ll> &retlist, ll x)\n{\n        for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n                while (x % i == 0LL) {\n                        retlist.pb(i);\n                        x /= i;\n                }\n        }\n        retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n        V<ll> factors, factors2;\n\n        get_factors(factors, x);\n\n        for (auto factor : factors) {\n                if (factor > 1) factors2.pb(factor);\n        }\n\n        return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n        V<T> resultlist;\n\n        set_intersection(a.begin(), a.end(),\n                         b.begin(), b.end(),\n                         back_inserter(resultlist));\n\n        set<T> resultset(resultlist.begin(), resultlist.end());\n        result = resultset;\n}\n\null combination(ll x, ll y)\n{\n        if (y > x / 2LL) y = x - y;\n\n        ull ret = 1LL;\n        for (ll i = 0LL; i < y; ++i) {\n                ret *= x--;\n                ret /= (i + 1LL);\n        }\n\n        return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n        if (y > x / 2LL) y = x - y;\n\n        ll ret = 1;\n\n        for (ll i = 0LL; i < y; ++i) {\n                ret = (ret * x--) % mod;\n                ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n        }\n\n        return ret;\n}\n\nvoid make_linklist(const V<tuple<ll, ll>> &srclist, V<V<ll>> &dstlist)\n{\n        for (auto src : srclist) {\n                ll a = get<0>(src);\n                ll b = get<1>(src);\n                dstlist[a].pb(b);\n                dstlist[b].pb(a);\n        }\n}\n\nvoid debug_print(auto xlist)\n{\n        for (auto x : xlist) cout << \"-- \" << x << endl;\n}\n\nvoid debug_print_t2(auto xlist)\n{\n        for (auto x : xlist) {\n                ll x1 = get<0>(x);\n                ll x2 = get<1>(x);\n                cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n        }\n}\n\nint _main();\nint main()\n{\n        cout << setprecision(12);\n        return _main();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nint _main()\n{\n        ll n;\n        llin(n);\n        ll mod = 998244353;\n\n        V<t2> xylist;\n        llinl2(xylist, n);\n        sort(xylist);\n\n        ll ans = mod_pow(2, n, mod);\n        ans = mod_sub(ans, 1, mod);  // count == 0\n        ans = mod_sub(ans, n, mod);  // count == 1\n\n        int counts[205][205];\n        memset(counts, 0, sizeof(counts));\n\n        rep (i, n) {\n                srep (j, i+1, n) {\n                        ll x1 = get<0>(xylist[i]);\n                        ll y1 = get<1>(xylist[i]);\n                        ll x2 = get<0>(xylist[j]);\n                        ll y2 = get<1>(xylist[j]);\n                        ll delta_x = x2 - x1;\n                        ll delta_y = y2 - y1;\n                        int min_idx = min(i, j);\n                        int max_idx = max(i, j);\n                        int count = 2;\n\n                        rep (k, n) {\n                                if (k == i || k == j) continue;\n                                ll x3 = get<0>(xylist[k]);\n                                ll y3 = get<1>(xylist[k]);\n                                ll kdelta_x = x3 - x1;\n                                ll kdelta_y = y3 - y1;\n                                if (delta_x * kdelta_y == delta_y * kdelta_x) {\n                                        min_idx = min(min_idx, k);\n                                        max_idx = max(max_idx, k);\n                                        count++;\n                                }\n                        }\n\n                        counts[min_idx][max_idx] = count;\n                }\n        }\n\n        rep (i, 205) {\n                rep (j, 205) {\n                        if (counts[i][j] == 0) continue;\n                        ans = mod_sub(ans, mod_pow(2, counts[i][j], mod), mod);\n                        ans += (counts[i][j] + 1);\n                        ans %= mod;\n                }\n        }\n\n        cout << ans;\n\n        return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\ntypedef long long ll;\nint n, cnt, X[210], Y[210], P[210] = { 1 };\nbool done[210][210];\nint norm(int x) {\n\treturn (x + MOD) % MOD;\n}\nbool linear(int a, int b, int c) {\n\treturn (X[a] - X[c])*(Y[b] - Y[c]) - (Y[a] - Y[c])*(X[b] - X[c]) == 0;\n}\nint subset(int x) {\n\treturn norm(P[x] - x - 1);\n}\nvoid count(int v, int u) {\n\tif (done[v][u]) return;\n\tvector<int> V;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (linear(u, v, i))\n\t\t\tV.push_back(i);\n\tint m = V.size();\n\tfor (int i = 0; i<m; i++)\n\t\tfor (int j = 0; j<m; j++)\n\t\t\tdone[V[i]][V[j]] = true;\n\tcnt = (cnt + subset(m)) % MOD;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tP[i] = (P[i - 1] * 2) % MOD;\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d%d\", X + i, Y + i);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tcount(i, j);\n\tint ans = subset(n);\n\tprintf(\"%d\", norm(ans - cnt));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i*i <= N; ++i)\n\t{\n\t\tif (N%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD> &other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<998244353> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\ntemplate<typename RET = mint, typename Integral>\nRET combination(Integral all, Integral get)\n{\n\tassert(all >= get);\n\tget = std::min(all - get, get);\n#if 1\n\t//時間計算量O(logMOD)\n\tstatic const auto fact_v = fact_set_c<100001>();\n\treturn fact_v[all] / (fact_v[get] * fact_v[all - get]);\n#elif 0\n\t//時間計算量O(1)\n\t//空間計算量、初期化時間計算量O(N^2)\n\tconstexpr int32_t ALL_MAX = 10'000;\n\tstatic std::vector<RET> DP_comb[ALL_MAX + 1];\n\tif (!DP_comb[all].empty())\n\t{\n\t\treturn DP_comb[all][get];\n\t}\n\n\tif (DP_comb[0].empty())\n\t{\n\t\tDP_comb[0].resize(1);\n\t\tDP_comb[0][0] = (RET)1;\n\t\tDP_comb[1].resize(1);\n\t\tDP_comb[1][0] = (RET)1;\n\t}\n\tfor (int32_t i = 2; i <= all; i++)\n\t{\n\t\tif (DP_comb[i].empty())\n\t\t{\n\t\t\tint32_t size = i / 2 + 1;\n\t\t\tDP_comb[i].resize(size);\n\t\t\tDP_comb[i][0] = (RET)1;\n\t\t\tfor (int32_t j = 1; j < size - 1; j++)\n\t\t\t{\n\t\t\t\tDP_comb[i][j] = DP_comb[i - 1][j - 1] + DP_comb[i - 1][j];\n\t\t\t}\n\t\t\tDP_comb[i][size - 1] = DP_comb[i - 1][size - 2] + DP_comb[i - 1][(i & 1) ? (size - 1) : (size - 2)];\n\t\t}\n\t}\n\treturn DP_comb[all][get];\n#else\n\t//時間計算量O(get * logMOD)\n\tRET ret = (RET)1;\n\tfor (Integral i = 1; i <= get; ++i)\n\t{\n\t\tret *= all + 1 - i;\n\t\tret /= i;\n\t}\n\treturn ret;\n#endif\n}\n\n\n\nint32_t N;\nusing std::vector;\nstruct P {\n\tint32_t x, y;\n\tint32_t dot(P o) {\n\t\treturn x*o.x + y*o.y;\n\t}\n\tint32_t det(P o) {\n\t\treturn x*o.y - y*o.x;\n\t}\n};\nP operator-(P a, P b) {\n\treturn P{ a.x - b.x, a.y - b.y };\n}\n// 辞書順で比較\ninline bool cmp_x(const P& p, const P& q) {\n\tif (p.x != q.x) return p.x < q.x;\n\treturn p.y < q.y;\n}\n// 凸包を求める\nvector<P> convex_hull(P* ps, int n) {\n\tstd::sort(ps, ps + n, cmp_x);\n\tint k = 0; // 凸包の頂点数\n\tvector<P> qs(n * 2); // 構築中の凸包\n\t\t// 下側凸包の作成\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\t\tqs[k++] = ps[i];\n\t\t}\n\t// 上側凸包の作成\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n// 距離の二乗\ndouble dist(P p, P q) {\n\treturn (p - q).dot(p - q);\n}\n// 入力\nint N;\nP ps[200];\nmint powpow[500];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tin >> ps[i].x >> ps[i].y;\n\t}\n\tpowpow[0] = 1;\n\tfor (size_t i = 1; i < 500; i++)\n\t{\n\t\tpowpow[i] = powpow[i - 1] * 2;\n\t}\n\n\n\tmint res = 0;\n\tvector<P> qs = convex_hull(ps, N);\n\tres += powpow[N - qs.size()];\n\tfor (int32_t i = qs.size(); i >= 0 ; i--)\n\t{\n\t\tres += powpow[std::max<long long>(0,N - qs.size()-i)]*i;\n\t}\n\tout << res << endl;\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n#define EPS 1e-5\n\nusing namespace std;\n\ntypedef complex<int> pt;\n\nstruct line {\n  double a, b, c;\n};\n\nline pointsToLine(pt p1, pt p2) {\n  line l;\n  if (abs(p1.real() - p2.real()) < EPS) {\n    l.a = 1;\n    l.b = 0;\n    l.c = -p1.real();\n  } else {\n    l.a = -(double)(p1.imag() - p2.imag()) / (p1.real() - p2.real());\n    l.b = 1.0;\n    l.c = -(double)(l.a * p1.real()) - p1.imag();\n  }\n  return l;\n}\n\nbool areParallel(line l1, line l2) {\n  return abs(l1.a - l2.a) < EPS && abs(l1.b - l2.b) < EPS;\n}\n\nbool operator==(const line &l1, const line &l2) {\n  return areParallel(l1, l2) && abs(l1.c - l2.c) < EPS;\n}\n\nbool operator<(const line &l1, const line &l2) {\n  if (l1.a != l2.a) return l1.a < l2.a;\n  if (l1.b != l2.b) return l1.b < l2.b;\n  return l1.c < l2.c;\n}\n\nmap<line, int> counter;\nint powers2[201];\n\nint invTri(int x) {\n  return ((int)sqrt(8 * x + 1) + 1) / 2;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pt> points(n);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    points[i] = pt(x, y);\n  }\n  sort(points.begin(), points.end(), [](const pt &a, const pt &b) {\n    if (a.real() == b.real()) return a.imag() < b.imag();\n    return a.real() < b.real();\n  });\n\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      counter[pointsToLine(points[i], points[j])]++;\n    }\n  }\n\n  powers2[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    powers2[i] = (2 * powers2[i - 1]) % MOD;\n  }\n\n  int colSubs = n;\n  for (auto slope : counter) {\n    int onLine = invTri(slope.second);\n    colSubs += powers2[onLine] - onLine - 1;\n    colSubs %= MOD;\n  }\n\n  printf(\"%d\\n\", (powers2[n] - colSubs - 1 + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) < 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\nint adds[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<point> ns;\n        for (int j = 0; j < n; j++) {\n            if (j == i) {\n                continue;\n            }\n            if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {\n                need[j] = true;\n                ns.push_back(p[j]);\n            } else {\n                need[j] = false;\n            }\n        }\n        cur = p[i];\n        sort(all(ns), comp);\n        for (int j = 0; j < sz(ns); j++) {\n            adds[j] = 0;\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (vec(ns[k] - p[i], ns[j] - p[i]) == 0) {\n                    adds[j]++;\n                }\n            }\n            for (int k = j + 1; k < sz(ns); k++) {\n                goods[j][k] = false;\n                cnt[j][k] = 0;\n                dp[j][k] = 0;\n                if (good(p[i], ns[j], ns[k])) {\n                    goods[j][k] = true;\n                    for (int g = j + 1; g < k; g++) {\n                        if (inside(p[i], ns[j], ns[k], ns[g])) {\n                            cnt[j][k]++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (goods[j][k]) {\n                    dp[j][k] += st[cnt[j][k] + adds[j] + adds[k]];\n                    dp[j][k] %= Mod;\n                    ans += dp[j][k];\n                    ans %= Mod;\n                    for (int nxt = k + 1; nxt < sz(ns); nxt++) {\n                        if (vec(ns[nxt] - ns[j], ns[k] - ns[j]) > 0 && goods[k][nxt] && vec(ns[nxt] - p[i], ns[k] - p[i]) != 0) {\n                            dp[k][nxt] += (1LL * dp[j][k] * st[cnt[k][nxt] - adds[k] + adds[nxt]]) % Mod;\n                            dp[k][nxt] %= Mod;\n                        }\n                    }\n                }   \n            }\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VL vector<long long>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 998244353;\nconst int SIZE = 1e6+10;\nconst double EPS=1e-12;\nconst double PI=acos(-1);\nstruct Point{\n    LL x,y;\n    Point(LL _x=0,LL _y=0){x=_x;y=_y;}\n    Point operator-(const Point& b){return Point(x-b.x,y-b.y);}\n    Point operator+(const Point& b){return Point(x+b.x,y+b.y);}\n    Point operator*(const LL v){return Point(x*v,y*v);}\n    LL operator*(const Point& b){return x*b.y-y*b.x;}\n    LL operator^(const Point& b){return x*b.x+y*b.y;}\n    bool operator<(const Point& b)const{\n        return x<b.x||(x==b.x&&y<b.y);\n    }\n    double angle(){return atan2(y,x);}\n    double dis(){return sqrt(x*x+y*y);}\n    void scan(){cin>>x>>y;}\n    void print(){cout<<x<<\" \"<<y<<endl;}\n}p[200];\nmap<pair<PII,int>,int>ppp;\nint my_gcd(int x,int y){\n    x=abs(x);y=abs(y);\n    if(!x||!y)return x+y;\n    return __gcd(x,y);\n}\nvoid ADD(LL& x,LL v){\n    x=(x+v)%MOD;\n    if(x<0)x+=MOD;\n}\nLL two[210];\nint main(){\n    two[0]=1;\n    REPP(i,1,210){\n        two[i]=two[i-1]*2%MOD;\n    }\n    DRI(n);\n    REP(i,n){\n        p[i].scan();\n    }\n    REP(i,n)REP(j,i){\n        Point d=p[i]-p[j];\n        int gg=my_gcd(d.x,d.y);\n        if(d.x<0||(!d.x&&d.y<0)){\n            d=Point(-d.x,-d.y);\n        }\n        d.x/=gg;\n        d.y/=gg;\n        ppp[MP(MP(d.x,d.y),d.y*p[i].x-d.x*p[i].y)]++;\n    }\n    LL an=two[n];\n    ADD(an,-1-n);\n    for(auto it=ppp.begin();it!=ppp.end();it++){\n        int v=it->S;\n        int num=2;\n        while(num*(num+1)/2<=v)num++;\n        ADD(an,-two[num]+num+1);\n    }\n    return 0*printf(\"%lld\\n\",an);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fst first\n#define snd second\n#define rep(n) for(lint I = 0; (I) < (lint)(n); ++(I))\n#define repeat(i, n) for(lint i = 0; (i) < (lint)(n); ++(i))\n#define repeat_to(i, n) for(lint i = 0; (i) <= (lint)(n); ++(i))\n#define repeat_from(i, m, n) for(lint i = (m); (i) < (lint)(n); ++(i))\n#define repeat_from_to(i, m, n) for(lint i = (m); (i) <= (lint)(n); ++(i))\n#define repeat_reverse_from_to(i, m, n) for(lint i = (m); (i) >= (lint)(n); --(i))\n#define el cout<<endl\n#define dump(x) cout<<\" \"<<#x<<\"=\"<<x\n#define vdump(v) for(size_t I=0; I<v.size(); ++I){cout<<\" \"<<#v<<\"[\"<<I<<\"]=\"<<v[I];} cout<<endl\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\n\n// 最大公約数\nlint gcd(lint a, lint b) {\n    // 引数の一方が 0 なら他方の値を返す\n    return b ? gcd(b, a%b) : a;\n}\n\nint main(void) {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> p(n);\n    repeat(i, n) cin >> p[i].fst >> p[i].snd;\n    \n    auto normalized_line = [](pair<int, int> p, pair<int, int> q) {\n        tuple<int, int, int> t;\n        int x1 = p.fst, y1 = p.snd;\n        int x2 = q.fst, y2 = q.snd;\n        int a = y1 - y2;\n        int b = x2 - x1;\n        int c = x1 * y2 - x2 * y1;\n        if (a < 0) {\n            a = -a; b = -b; c = -c;\n        }\n        int g = gcd(a, b); g = gcd(g, c);\n        a /= g; b /= g; c /= g;\n        t = {a, b, c};\n        return t;\n    };\n    \n    map<tuple<int, int, int>, set<pair<int, int>>> mp;\n    \n    repeat(i, n) {\n        repeat_from(j, i + 1, n) {\n            auto t = normalized_line(p[i], p[j]);\n            mp[t].insert(p[i]);\n            mp[t].insert(p[j]);\n        }\n    }\n    \n    lint MOD = 998244353LL;\n    lint ans = 1;\n    rep(n) {\n        (ans *= 2) %= MOD;\n    }\n    ((ans += MOD) -= 1) %= MOD;\n    ((ans += MOD) -= n) %= MOD;\n    \n    for(auto e: mp) {\n        lint t = 1;\n        rep(e.snd.size()) {\n            (t *= 2) %= MOD;\n        }\n        ((t += MOD) -= 1) %= MOD;\n        ((t += MOD) -= e.snd.size()) %= MOD;\n        ((ans += MOD) -= t) %= MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\n/*Atcoder Regular Contest 082 E\n  For each convex polygon,we count it for 2^t times,\n  while t is the size of the subset of points inside the polygon.\n  So,it can be considered as,each subset of t is counted once.\n  And it can be tranformed to the number of subsets having a convex hull.\n  Then it's easy to calculate the number of it.\n*/\nint x[205],y[205],num[205];\nint ans,n,b[205];\nint gcd(int a,int b)\n{if (a%b==0) return b;\nreturn gcd(b,a%b);\n}\ninline int abs(int a)\n{if (a<0) return -a;\nreturn a;\n}\ninline int read()\n{int x=0;\nchar c=getchar();\nwhile (c<'0'||c>'9') c=getchar();\nwhile (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\nreturn x;\n}\nint main (){\n\tint i,j,k;\n\tn=read();\n\tb[0]=1;\n\tfor (i=1;i<=n;i++)\n\t{b[i]=b[i-1]*2;b[i]%=mod;}\n\tans=b[n]-1-n;\n\tfor (i=1;i<=n;i++)\n\t{x[i]=read();y[i]=read();}\n\tfor (i=1;i<=n;i++)\n\t{memset (num,0,sizeof(num));\n\tmap <int,int> d[2][10005];\n\tmap <int,int>::iterator it;\n\tint nx=0,ny=0;\n\tfor (j=i+1;j<=n;j++)\n\t{int dx=x[i]-x[j],dy=y[i]-y[j],tag;\n\tif (dx==0) {nx++;continue;}\n\tif (dy==0) {ny++;continue;}\n\tif (dx*dy<0) {tag=0;}\n\telse {tag=1;}\n\tdx=abs(dx);dy=abs(dy);\n\tint t=gcd(dx,dy);\n\tdx/=t;dy/=t;\n\tif (d[tag][dx][dy])\n\t{num[d[tag][dx][dy]]--;}\n\td[tag][dx][dy]++;\n\tnum[d[tag][dx][dy]]++;\n\t}\n\tnum[nx]++;num[ny]++;\n\t//printf (\"Case %d\\n\",i);\n\tfor (j=1;j<=n;j++)\n\t{if (num[j])\n\t{//printf (\"%d %d\\n\",j,num[j]);\n\tans-=num[j]*(b[j]-1);ans%=mod;\n\tif (ans<0) ans+=mod;\n\t}\n\t}\n\t}\n\tprintf (\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef double lld;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<double> vdl;\ntypedef vector<vector<lli>> mat;\ntypedef vector<vdl> mad;\ntypedef unordered_map<lli,unordered_map<lli,lli>> graph;\ntypedef complex<double> cmp;\ntypedef vector<cmp> vcl;\n\nconst lli mod = 998244353;\n\nlli n;\nvector<vdl> p;\nmat c;\nmat bl;\nlli ans = 0;\n\nlld deg(vdl a,vdl from){\n  return fmod(atan2(a[1]-from[1],a[0]-from[0])+2*M_PI,2*M_PI);\n}\n\nlld deg(vdl a,vdl b,vdl from){\n  return fmod(deg(b,from)-deg(a,from)+2*M_PI,2*M_PI);\n}\n\nlld abs(vdl to,vdl from){\n  lld x = to[0]-from[0];\n  lld y = to[1]-from[1];\n  return sqrt(x*x+y*y);\n}\n\nlld dot(vdl a,vdl b,vdl from){\n  lld x1 = a[0]-from[0];\n  lld y1 = a[1]-from[1];\n  lld x2 = b[0]-from[0];\n  lld y2 = b[1]-from[1];\n  return x1*x2+y1*y2;\n}\n\nlli pow(lli x,lli r,lli mod = 998244353){\n  lli ret = 1;\n  for(;r != 0;r >>= 1){\n    if(r&1 != 0) ret *= x,ret %= mod;\n    x *= x,x %= mod;\n  }\n  return ret;\n}\n\nset<vdl> s;\nmap<vdl,lli> m;\n\nint main(){\n  cin >> n;\n  p = vector<vdl>(n,vdl(2));\n  for(lli i = 0;i < n;i++) cin >> p[i][0] >> p[i][1];\n  bl = mat(n,vll(n));\n  for(lli i = 0;i < n;i++){\n    bl[i][i] = 1;\n    for(lli j = 0;j < n;j++){\n      if(bl[i][j]) continue;\n      set<lli> s;\n      bl[i][j] = bl[j][i] = 1;\n      s.insert(i);\n      s.insert(j);\n      for(lli k = 0;k < n;k++){\n        if((p[k][1]-p[i][1])*(p[j][0]-p[i][0]) == (p[j][1]-p[i][1])*(p[k][0]-p[i][0])){\n          for(lli x : s){\n            bl[x][k] = bl[k][x] = 1;\n          }\n          s.insert(k);\n        }\n      }\n      ans += pow(2ll,s.size())-1-s.size();\n    }\n  }\n\n  // for(lli i = 0;i < n;i++){\n  //   for(lli j = 0;j < n;j++){\n  //     cout << bl[i][j];\n  //   }\n  //   cout << endl;\n  // }\n  ans += 1ll;\n  ans += n;\n  ans %= mod;\n  cout << ((pow(2ll,n)-ans+mod)%mod) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PII pair<LL,LL>\n#define fi first\n#define se second\n#define lowbit(x) ((x)&(-(x)))\n#define FOR(i,a,b) for (LL i=(a);i<=(b);++i)\n#define ROF(i,b,a) for (LL i=(b);i>=(a);--i)\ntypedef long long LL;\ninline LL read(){\n\tLL x=0,f=1; char ch=getchar();\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\twhile (ch>='0'&&ch<='9') { x=x*10+ch-'0'; ch=getchar(); }\n\treturn x*f;\n}\n\nconst LL MAXN=300005,Mo=998244353;\nstruct list{\n\tLL l,lt[MAXN],nt[MAXN*2],x[MAXN*2],y[MAXN*2];\n\tvoid clear(){ l=0; memset(lt,0,sizeof(lt)); }\n\tvoid addedge(LL a,LL b){ l++; nt[l]=lt[a]; lt[a]=l; x[l]=b; }\n}E;\nstruct P{\n\tLL x,y;\n\tP(LL xx=0,LL yy=0):x(xx),y(yy){}\n\tP operator +(const P &E)const{ return P(x+E.x,y+E.y); }\n\tP operator -(const P &E)const{ return P(x-E.x,y-E.y); }\n\tLL operator *(const P &E)const{ return x*E.y-E.x*y; }\n\tLL operator ^(const P &E)const{ return x*E.x+y*E.y; }\n}A[MAXN],B[MAXN];\nLL n,m,a[MAXN],b[MAXN];\nLL power(LL a,LL b){\n\tLL c=1; a%=Mo;\n\twhile (b) {\n\t\tif (b&1) c=c*a%Mo;\n\t\ta=a*a%Mo; b>>=1;\n\t}\n\treturn c;\n}\nLL cmp(P i,P j){ return i*j>0; }\nint main(){\n\tn=read();\n\tFOR(i,1,n) a[i]=power(i,Mo-2);\n\tFOR(i,1,n) { A[i].x=read(); A[i].y=read(); }\n\tLL tmp,ans=power(2,n)+Mo-n-1;\n\tif (ans>=Mo) ans-=Mo;\n\tcout<<ans<<endl;\n\tFOR(i,1,n) {\n\t\tFOR(j,1,i-1) B[j]=A[j]-A[i];\n\t\tFOR(j,i+1,n) B[j-1]=A[j]-A[i];\n\t\tFOR(j,1,n-1) if (B[j].x<0||B[j].x==0&&B[j].y<0) B[j].x=-B[j].x,B[j].y=-B[j].y;\n\t\tsort(B+1,B+n,cmp);\n\t\tfor (LL j=1,k,tot;j<n;j=k+1) {\n\t\t\tfor (k=j;k<n-1&&B[k+1]*B[j]==0;++k);\n\t\t\ttot=k-j+2;\n\t\t\ttmp=(power(2,tot)+Mo-tot-1)*a[tot]%Mo;\n\t\t\t//cout<<i<<':'<<tmp*tot%Mo<<endl;\n\t\t\tans+=Mo-tmp; if (ans>=Mo) ans-=Mo;\n\t\t}\n\t}\n\tcout<<(ans%Mo+Mo)%Mo<<endl;\n\treturn 0;\n}\n\n/*\n4\n0 0\n0 1\n1 0\n1 1\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint read()\n{\n  int x=0,f=1;\n  char ch=getchar();\n  while((ch<'0')||(ch>'9'))\n    {\n      if(ch=='-')\n        {\n          f=-f;\n        }\n      ch=getchar();\n    }\n  while((ch>='0')&&(ch<='9'))\n    {\n      x=x*10+ch-'0';\n      ch=getchar();\n    }\n  return x*f;\n}\n\nconst int maxn=200;\nconst int mod=998244353;\n\nstruct point\n{\n  int x,y;\n};\n\npoint p[maxn+10];\nint n,ans;\n\nint quickpow(int a,int b,int m)\n{\n  int res=1;\n  while(b)\n    {\n      if(b&1)\n        {\n          res=1ll*res*a%m;\n        }\n      a=1ll*a*a%m;\n      b>>=1;\n    }\n  return res;\n}\n\nint in_line(point a,point b,point c)\n{\n  return (b.y-a.y)*(c.x-a.x)==(c.y-a.y)*(b.x-a.x);\n}\n\nint main()\n{\n  n=read();\n  for(int i=1; i<=n; ++i)\n    {\n      p[i].x=read();\n      p[i].y=read();\n    }\n  for(int i=1; i<=n; ++i)\n    {\n      for(int j=i+1; j<=n; ++j)\n        {\n          int cnt=0;\n          for(int k=j+1; k<=n; ++k)\n            {\n              if(in_line(p[i],p[j],p[k]))\n                {\n                  ++cnt;\n                }\n            }\n          ans+=quickpow(2,cnt,mod);\n          if(ans>=mod)\n            {\n              ans-=mod;\n            }\n        }\n    }\n  ans+=n+1;\n  if(ans>=mod)\n    {\n      ans-=mod;\n    }\n  ans=quickpow(2,n,mod)-ans;\n  if(ans<0)\n    {\n      ans+=mod;\n    }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=205,mod=998244353;\ntypedef long long LL;\nint n,tot;\nLL ans,f[N][N],g[N][N];\n\nstruct P\n{\n\tint x,y;\n\n\tP operator - (P t) {return (P){x-t.x,y-t.y};}\n\tint operator * (P t) {return -t.x*y+x*t.y;}\n} dat[N],p[N],tmp;\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nint sqr(int x)\n{\n\treturn x*x;\n}\n\nint dis(P a,P b)\n{\n\treturn sqr(a.x-b.x)+sqr(a.y-b.y);\n}\n\nbool cmp(P a,P b)\n{\n\tint x=(a-tmp)*(b-tmp);\n\treturn !x?(dis(a,tmp)<dis(b,tmp)):x>0;\n}\n\nbool check(P a,P b,P c,P d)\n{\n\tint t=abs((a-c)*(b-c));\n\tint s=abs((a-c)*(d-c))+abs((b-a)*(d-a))+abs((c-b)*(d-b));\n\treturn t==s && ((a-c)*(d-c));\n}\n\nvoid solve(int x)\n{\n\tp[tot=1]=tmp=dat[x];\n\trep(i,1,n) if(i!=x)\n\t\tif(dat[i].y>dat[x].y || (dat[i].y==dat[x].y && dat[i].x>=dat[x].x))\n\t\t\tp[++tot]=dat[i];\n\tsort(p+2,p+1+tot,cmp);\n\trep(i,2,tot-1) rep(j,i+1,tot)\n\t{\n\t\tg[i][j]=1;\n\t\trep(k,i+1,j-1)\n\t\t\tif(check(p[i],p[j],tmp,p[k]))\n\t\t\t\tg[i][j]=g[i][j]*2%mod;\n\t}\n\trep(i,1,tot) rep(j,1,tot) f[i][j]=0;\n\trep(i,2,tot)\n\t{\n\t\tf[1][i]=1;\n\t\trep(j,2,i-1) if((p[i]-tmp)*(p[j]-tmp)==0) f[1][i]=f[1][i]*2%mod;\n\t}\n\trep(i,1,tot-2)\n\t\trep(j,i+1,tot-1)\n\t\t\trep(k,j+1,tot)\n\t\t\t\tif((p[k]-p[j])*(p[i]-p[j])>0)\n\t\t\t\t\tf[j][k]=(f[j][k]+g[j][k]*f[i][j])%mod;\n\trep(i,2,tot-1) rep(j,i+1,tot) \n\t\tif((tmp-p[j])*(p[i]-p[j])>0) ans=(ans+f[i][j])%mod;\n}\n\nint main()\n{\n\tn=getint();\n\trep(i,1,n)\n\t\tdat[i].x=getint(),dat[i].y=getint();\n\trep(i,1,n)\n\t\tsolve(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// fest\n#include <bits/stdc++.h>\t\n\n#define pb push_back\n#define F first\n#define S second\n#define y1 dasdasfasfas\n#define x1 wqdadfasfasfas\n#define All(c) c.begin(), c.end()\n#define SZ(A) (int((A).size()))\n#define umap unordered_map\n#define __ fflush(stdout)\n#define FILENAME \"\"\n\ntypedef long long ll;\ntypedef long double ld;    \n\nusing namespace std;\n\nvoid FREOPEN() {\n\t#ifdef LOCAL\n\t\tfreopen(\".in\", \"r\", stdin);\n\t\tfreopen(\"1.out\", \"w\", stdout);\n\t#else\n\t\t//freopen(FILENAME\".in\", \"r\", stdin);\n\t\t//freopen(FILENAME\".out\", \"w\", stdout);\n\t#endif\n}\n\ninline double Time() {return (clock() * 1.0) / CLOCKS_PER_SEC; }             \n\nconst int N = 201, inf = 1e9 * 2;\n\nconst ll MOD = 998244353, INF = 1e18;\n\nconst int dx[] = {1, -1, 0, 0, -1, 1, -1, 1};\nconst int dy[] = {0, 0, 1, -1, -1, 1, 1, -1};\n\nstruct Point {\n\tint x, y;\n};\n\nPoint a[N];\nPoint root;\n\nint tri[N][N], dp[N][N];\n\nPoint make(int _x, int _y) {\n\tPoint ret;\n\tret.x = _x;\n\tret.y = _y;\n\treturn ret;\n}\n\nPoint vec(Point p1, Point p2) {\n\treturn make(p2.x - p1.x, p2.y - p1.y);\n}\n\nint crossp(Point p1, Point p2) {\n\treturn p1.x * p2.y - p1.y * p2.x; \n} \n\nint dist(Point p1, Point p2) {\n\treturn (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n}\n\nbool canbe(int i, int j) {\n\tif (i == j) return 0;\n\tif (a[i].x > a[j].x) return 0;\n\tif (a[i].x < a[j].x) return 1;\n\tif (a[i].y > a[j].y) return 0;\n\treturn 1;\n}\n\nbool cmp(Point p1, Point p2) {\n\tPoint v1 = vec(root, p1);\n\tPoint v2 = vec(root, p2);\n\tif (crossp(v1, v2) < 0) return 1;\n\tif (crossp(v1, v2) > 0) return 0;\n\tif (dist(root, p1) > dist(root, p2)) return 1;\n\treturn 0;\n}\n\nint power(int x) {\n\tint ret = 1;\n\tint num = 2;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tx--;\n\t\t\tret = (ret * 1ll * num) % MOD;\n\t\t}\n\t\telse {\n\t\t\tx /= 2;\n\t\t\tnum = (num * 1ll * num) % MOD;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid add(int &x, int y) {\n\tx += y;\n\twhile (x >= MOD) x -= MOD;\n}\n\nvoid out (Point p) {\n\tcerr << \"(\" << p.x << \" \" << p.y << \") \";\n}\n\nint main() {\n\tFREOPEN();\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _x, _y;\n\t\tscanf(\"%d %d\", &_x, &_y);\n\t\ta[i] = make(_x, _y);\n\t}\n\tint ans = 0;\n\tfor (int start = 1; start <= n; start++) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(tri, 0, sizeof(tri));\n\t\troot = a[start];\n\t\tvector<Point> ps;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (canbe(start, i)) ps.pb(a[i]); \n\t\t}\n\t\tsort(All(ps), cmp);\n\t\tint m = SZ(ps);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tfor (int k = i + 1; k < j; k++) {\n\t\t\t\t\tif (crossp(vec(ps[i], ps[j]), vec(ps[i], ps[k])) <= 0) tri[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tif (crossp(vec(root, ps[i]), vec(root, ps[j])) == 0) continue;\n\t\t\t\tdp[i][j] += power(tri[i][j]);\n\t\t\t\tfor (int k = j + 1; k < m; k++) {\n\t\t\t\t\tif (crossp(vec(ps[i], ps[j]), vec(ps[i], ps[k])) >= 0) continue;\n\t\t\t\t\tdp[j][k] += (power(tri[j][k]) * 1ll * dp[i][j]) % MOD;\n\t\t\t\t}\n\t\t\t\tadd(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d \", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 998244353\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\nll f[220];\nll comb[220][220];\n\nvoid fact() {\n    f[0] = 1;\n    rep(i, 1, 210){\n        f[i] = f[i - 1] * i;\n        f[i] %= mod;\n    }\n}\n\nll pow_mod(ll a, ll b, ll m){\n    ll ret = 1;\n    while (b > 0) {\n        if (b & 1) {\n            ret = ret * a % m;\n        }\n        a = a * a % m;\n        b >>= 1;\n    }\n    return ret;\n}\n\nll inv_mod(ll a, ll m){\n    return pow_mod(a, m - 2, m);\n}\n\nvoid calc() {\n    // i C j\n    rep(i, 210){\n        rep(j, i + 1) {\n            comb[i][j] = f[i];\n            ll tmp = inv_mod(f[j] * f[i - j] % mod, mod);\n            (comb[i][j] *= tmp) %= mod;\n        }\n    }\n}\n\n\nbool line(pair<ll, ll> p, pair<ll, ll> q, pair<ll, ll> r){\n    return (p.first - q.first) * (p.second - r.second) == (p.first - r.first) * (p.second - q.second);\n}\n\nbool vis[220][220];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    fact();\n    calc();\n    int N;\n    cin >> N;\n    vector<pair<ll, ll>> A(N);\n    rep(i, N) cin >> A[i].first >> A[i].second;\n    \n    ll ans = 0;\n    rep(i, 3, N + 1){\n        ans += comb[N][i];\n        ans %= mod;\n    }\n//    output(ans);\n    ll sub = 0;\n    rep(i, N){\n        rep(j, i + 1, N){\n            if(!vis[i][j]){\n                int cnt = 2;\n                rep(k, j + 1, N){\n                    if(line(A[i], A[j], A[k])){\n                        cnt++;\n                        vis[i][j] = vis[j][i] = true;\n                        vis[i][k] = vis[k][i] = true;\n                        vis[j][k] = vis[k][j] = true;\n                    }\n                }\n                \n                if(cnt > 2){\n                    rep(l, 3, cnt + 1){\n                        sub += comb[cnt][l];\n                        sub %= mod;\n                    }\n                    \n                }\n            }\n        }\n    }\n    ans = ans - sub;\n    ans %= mod;\n    ans += mod;\n    ans %= mod;\n    output(ans);\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read(){\n\tint x=0,f=0;\n\tchar ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar()) f^=(ch=='-');\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn f ? -x : x;\n}\nconst int P=998244353,maxn=1010;\ninline int kasumi(int x,int y) {\n\tint qwq=1;\n\twhile (y) {\n\t\tif (y&1) qwq=qwq*x%P;\n\t\ty>>=1;\n\t\tx=x*x%P;\n\t}\n\treturn qwq;\n}\nint x[maxn],y[maxn],n,ans;\nsigned main(){\n\tn=read();\n\tfor (int i=1;i<=n;++i) {\n\t\tx[i]=read();y[i]=read();\n\t} \n\tans=(kasumi(2,n)-n-1-n*(n-1)/2+P)%P;\n\tfor (int i=1;i<=n;++i) {\n\t\tfor (int j=i+1;j<=n;++j) {\n\t\t\tint qwq=0;\n\t\t\tfor (int k=j+1;k<=n;++k) {\n\t\t\t\tif ((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j])) ++qwq;\n\t\t\t}\n\t\t\tans=(ans-kasumi(2,qwq)+P+1)%P;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nint x[205], y[205];\nlong long p2[205];\n\nbool linear(int i, int j, int k) {\n  return (y[j] - y[i]) * (x[k] - x[i]) == (y[k] - y[i]) * (x[j] - x[i]);\n}\n\nint main() {\n  long long t = 1;\n  for (int i = 0; i <= 200; i++) {\n    p2[i] = t;\n    t *= 2;\n    t %= mod;\n  }\n  int n;\n  cin >> n;\n  for (int ni = 0; ni < n; ni++) {\n    cin >> x[ni] >> y[ni];\n  }\n  if (n < 3) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long ans = 0;\n  for (int ni = 0; ni < n; ni++) {\n    for (int nj = ni + 1; nj < n; nj++) {\n      bool feasible = true;\n      for (int nk = 0; nk < nj; nk++) {\n        if (nk == ni) continue;\n        if (linear(ni, nj, nk)) {\n          feasible = false;\n          break;\n        }\n      }\n      if (!feasible) break;\n      int cnt = 2;\n      for (int nk = nj + 1; nk < n; nk++) {\n        if (linear(ni, nj, nk)) cnt++;\n      }\n      ans += p2[cnt] - 1 - cnt - cnt * (cnt - 1) / 2 + mod;\n      ans %= mod;\n    }\n  }\n  ans = p2[n] - 1 - n - n * (n - 1) / 2 - ans + mod;\n  ans %= mod;\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1116\n#define mod 998244353\n\nint n,x[N],y[N],e[N],ans;\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++)\n\t\tx[i]=read(),y[i]=read();\n\tfor (int i=e[0]=1;i<=n;i++)\n\t\te[i]=e[i-1]*2%mod;\n\tans=e[n]-1-n;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tint t=0;\n\t\t\tfor (int k=j+1;k<=n;k++)\n\t\t\t\tt+=((x[j]-x[i])*(y[k]-y[i])==(x[k]-x[i])*(y[j]-y[i]));\n\t\t\tans=(ans-e[t])%mod;\n\t\t}\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n#define MN 200\n#define mod 998244353\nint n,x[MN+5],y[MN+5];\nint b[MN+5][MN+5],ans,pw[MN+5],q[MN+5],top;\nint main(){\n\tn=read();pw[0]=1;register int i,j,l,r,k;\n    for(j=1;j<=n;++j) pw[j]=2*pw[j-1]%mod;ans=(pw[n]-n-1+mod)%mod;\n    for(i=1;i<=n;++i) x[i]=read(),y[i]=read();\n    for(i=1;i<=n;++i) for(j=i+1;j<=n;++j) if(!b[i][j]){\n        q[top=1]=i;q[top=2]=j;\n        for(k=j+1;k<=n;++k) if((x[j]-x[i])*(y[k]-y[i])==(x[k]-x[i])*(y[j]-y[i])) q[++top]=k;\n        for(l=1;l<top;++l) for(r=l+1;r<=top;++r) b[q[l]][q[r]]=1;\n        ans=((ans-pw[top]+top+1)%mod+mod)%mod;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NDEBUG\n#ifdef DEBUG\n#include \"../cout11.h\"\n#undef NDEBUG\n#endif\n#include <cassert>\n\ntypedef long long ll;\ntypedef long double Double;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> llll;\ntypedef pair<double,double> dd;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ii> vii;\ntypedef vector<vector<ii>> vvii;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<long double> vD;\n\n#define sz(a)  int((a).size())\n#define pb  push_back\n#define FOR(var,from,to) for(int var=(from);var<=(to);++var)\n#define rep(var,n)  for(int var=0;var<(n);++var)\n#define rep1(var,n)  for(int var=1;var<=(n);++var)\n#define repC2(vari,varj,n)  for(int vari=0;vari<(n)-1;++vari)for(int varj=vari+1;varj<(n);++varj)\n#define ALL(c)  (c).begin(),(c).end()\n#define RALL(c)  (c).rbegin(),(c).rend()\n#define tr(i,c)  for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define found(s,e)  ((s).find(e)!=(s).end())\n#define mset(arr,val)  memset(arr,val,sizeof(arr))\n#define mid(x,y) ((x)+((y)-(x))/2)\n#define IN(x,a,b) ((a)<=(x)&&(x)<=(b))\n#define cons make_pair\n\n\nll gcd(ll a, ll b) { while(a) swap(a, b%=a); return b; }\n\nconst ll MOD=998244353LL;\n\nll ADD(ll x, ll y) { return (x+y) % MOD; }\nll SUB(ll x, ll y) { return (x-y+MOD) % MOD; }\nll MUL(ll x, ll y) { return x*y % MOD; }\nll POW(ll x, ll e) { ll v=1; for(; e; x=MUL(x,x), e>>=1) if (e&1) v = MUL(v,x); return v; }\nll DIV(ll x, ll y) { /*assert(y%MOD!=0);*/ return MUL(x, POW(y, MOD-2)); }\n// ll comb(ll n, ll k) { ll v=1; for(ll i=1; i<=k; i++) v = DIV(MUL(v, n-i+1),i); return v; }\n//\n\ntypedef tuple<double,double,double> LINE;\n\nvoid render_fnum(FILE* fp, double x) {\n    if (x == 1) return;\n    fprintf(fp, \"%g\", x);\n}\nvoid render_line(FILE* fp, LINE& line) {\n    double a,b,c; tie(a,b,c) = line;\n    if (a != 0){\n        render_fnum(fp, a);\n        fprintf(fp, \"x\");\n    }\n\n    if (b != 0) {\n        if (b > 0) {\n            if (a != 0)\n                fprintf(fp, \" + \");\n            render_fnum(fp, b);\n        } else if (b < 0) {\n            fprintf(fp, \" - \");\n            render_fnum(fp, -b);\n        }\n        fprintf(fp, \"y\");\n    }\n\n    if (c != 0) {\n        if (c > 0) {\n            fprintf(fp, \" + %g\", c);\n        } else if (c < 0) {\n            fprintf(fp, \" - %g\", -c);\n        }\n    }\n\n    fprintf(fp, \" = 0\");\n}\n\nLINE get_line(ii& p0, ii& p1){\n    int x0 = p0.first, y0 = p0.second,\n        x1 = p1.first, y1 = p1.second;\n    int dx = x1 - x0, dy = y1 - y0;\n\n    assert(dx != 0 || dy != 0);\n\n    double a, b, c;\n\n    if (dx == 0) {\n        // 1x [+ 0y] - some = 0\n        // some = x\n        // double some = (double)x0;\n        a = 1.0;\n        b = 0.0;\n        c = (double)(-x0); // -some;\n    } else if (dy == 0) {\n        // [0x +] 1y - some = 0\n        // some = y\n        // double some = (double)y0;\n        a = 0.0;\n        b = 1.0;\n        c = (double)(-y0); // -some;\n    } else {\n        // m = dy/dx\n        // y = mx + b\n        // mx - y + b = 0\n        int g = gcd(dx, dy);\n        dx /= g; dy /= g;\n\n        double _m = (double)dx / dy;\n        assert(_m != 0.0);\n        // x - _my - some = 0\n        // double some = (double)x0 - _m * y0;\n        a = 1.0;\n        b = -_m;\n        c = (double)(_m * y0 - x0); // -some;\n    }\n\n    // fprintf(stderr, \"(a,b,c)=(%g,%g,%g)\\n\", a,b,c);\n\n    double z0 = a * x0 + b * y0 + c;\n    double z1 = a * x1 + b * y1 + c;\n#ifdef DEBUG\n    // fprintf(stderr, \"%g * %d + %g * %d + %g = %g\\n\", a,x0, b,y0, c, z0);\n    // fprintf(stderr, \"%g * %d + %g * %d + %g = %g\\n\", a,x1, b,y1, c, z1);\n#endif\n    assert(fabs(z0) < 1e-7);\n    assert(fabs(z1) < 1e-7);\n\n    return LINE(a, b, c);\n}\n\n\nll f(int n){\n    // return (1 << n) - n - 1;\n    return SUB(POW(2, n), ADD(n,1));\n}\n\nll solve(int N, vii& p){\n    // map<LINE, set<int>> by_line;\n    map<vector<ll>, set<int>> by_line;\n\n    repC2(i,j,N){\n#ifdef DEBUG\n        // cerr << \"---\" << endl;\n        // fprintf(stderr, \"[%d %d] \", i, j);\n        // cerr << p[i] << \" \" << p[j] << \" : \";\n#endif\n        LINE line = get_line(p[i], p[j]);\n#ifdef DEBUG\n        // render_line(stderr, line);\n        // cerr << endl;\n#endif\n\n        double a,b,c; tie(a,b,c) = line;\n        vector<ll> _line { (ll)round(1000000*a), (ll)round(1000000*b), (ll)round(1000000*c) };\n        by_line[_line].insert(i);\n        by_line[_line].insert(j);\n    }\n\n    ll ans = f(N); // (1 << N) - (N+1);\n    for(auto p: by_line){\n        // LINE line = p.first;\n        vector<ll> _line = p.first;\n        set<int> s = p.second;\n        int k = p.second.size();\n#ifdef DEBUG\n        render_line(stderr, line);\n        cerr << \" : \" << s << endl;\n#endif\n        ans = SUB(ans, f(k)); // (1 << k) - (k+1));\n    }\n    return ans;\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    vector<ii> p(N);\n    rep(i,N){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        p[i] = ii(x, y);\n    }\n\n    cout << solve(N,p) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define repr(i,b,e) for(int i = (b); i <= (e); i++)\n#define INF (1001001001)\n#define EPS (1e-15)\n\n#define pr(x) do{cerr << (#x) << \" = \" << (x) << endl;}while(0)\n#define pri(x,i) do{cerr << (#x) << \"[\" << i << \"] = \" << (x[i]) << endl;}while(0)\n#define pra(x,n) rep(__i,n) pri(x,__i);\n#define prar(x,b,e) repr(__i,b,e) pri(x,__i);\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n\nll MOD = 998244353;\n\nint in() {\n\tint a;\n\tscanf(\"%d \", &a);\n\treturn a;\n}\n\nint main() {\n\tint N = in();\n\ttypedef complex<double> P;\n\tvector<P> a(N);\n\trep(i,N) {\n\t\tint x = in();\n\t\tint y = in();\n\t\ta[i] = P(x, y);\n\t}\n\t\n\tvector<ll> twop(220);\n\ttwop[0] = 1;\n\trepr(i,1,210)twop[i] = twop[i-1] * 2 % MOD;\n\t\n\tvector<ll> hoge(220);\n\trep(i,210) {\n\t\tif (i < 3) hoge[i] = 0;\n\t\telse hoge[i] = (twop[i] - 1 - i - i * (i - 1) / 2 + MOD) % MOD;\n\t}\n\t\n\tvint cnt(N+10);\n\trep(p,N) {\n\t\tvint found(N);\n\t\trepr(q,p+1,N-1) {\n\t\t\tP l = a[q] - a[p];\n\t\t\tint temp = 2;\n\t\t\trepr(r,q+1,N-1) {\n\t\t\t\tif (found[r]) continue;\n\t\t\t\tP m = a[r] - a[p];\n\t\t\t\tif (l.imag() * m.real() == l.real() * m.imag()) {\n\t\t\t\t\ttemp++;\n\t\t\t\t\tfound[r] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (temp >= 3) {\n\t\t\t\tcnt[temp]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 3; i < 10; i++) pri(cnt, i);\n\tfor (int i = 200; i >= 3; i--) {\n\t\tfor (int k = i - 1; k >= 3; k--) {\n\t\t\tcnt[k] -= cnt[i];\n\t\t}\n\t}\n\tfor (int i = 3; i < 10; i++) pri(cnt, i);\n\t\n\tll ans = hoge[N];\n\tfor (int i = N - 1; i >= 3; i--) {\n\t\tans = (ans - cnt[i] * hoge[i]);\n\t\twhile (ans < 0) ans += MOD;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=205,mo=998244353;\nint n,x,i,dn,pw[N],ans;\nstruct arr{int x,y;}a[N],d[N];\nint cross(arr A,arr B){return A.x*B.y-B.x*A.y;}\nbool operator < (arr A,arr B){return cross(A,B)>0;}\nint main(){\n\tfor (scanf(\"%d\",&n),i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfor (pw[0]=1,i=1;i<=n;i++) pw[i]=pw[i-1]*2%mo;\n\tans=pw[n]-1-n;\n\tfor (int x=1;x<=n;x++){\n\t\tfor (dn=0,i=x+1;i<=n;i++) if (i!=x){\n\t\t\td[++dn]=(arr){a[i].x-a[x].x,a[i].y-a[x].y};\n\t\t\tif (d[i].x<0) d[i].x=-d[i].x,d[i].y=-d[i].y;\n\t\t}\n\t\tsort(d+1,d+dn+1);int k=0;\n\t\tfor (i=1;i<=dn;i++){\n\t\t\tif (!cross(d[i-1],d[i])) k++;\n\t\t\telse ans=(ans-pw[k]+1)%mo,k=1;\n\t\t}\n\t\tans=(ans-pw[k]+1)%mo;\n\t}\n\tprintf(\"%d\",(ans+mo)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#include <unistd.h>\n//#include <iostream>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n//#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n//int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n//int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\nvi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 555555;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nusing P = complex<ll>;\n#define EPS (1e-10)\n// 2�̃X�J���[�����������ǂ���\n#define EQ(a,b) (abs((a)-(b)) < EPS)\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\nint is_point_on_line(P a, P b, P c) {\n\treturn EQ(cross(b - a, c - a), 0.0);\n}\n\nsigned main() {\n  int n;\n  cin >> n;\n  vector<P> xy(n);\n  rep (i, n) {\n    int x, y;\n    cin >> x >> y;\n    xy[i].real(x);\n    xy[i].imag(y);\n  }\n\n  ll ans = mod_pow(2, n);\n  ans -= 1 + n + n * (n - 1) / 2;\n\n  rep (i, n) {\n    for (int j = i + 1; j < n; j++) {\n      int cnt = 0;\n      for (int k = j + 1; k < n; k++) {\n        if (is_point_on_line(xy[i], xy[j], xy[k])) {\n          cnt++;\n        }\n      }\n      ans -= mod_pow(2, cnt) - 1;\n      ans %= MOD;\n    }\n  }\n  ans = (ans + MOD) % MOD;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nconst int mo=998244353;\n\nint n,Ans;\n\nstruct Point{\n\tint x,y;\n\tPoint() {}\n\tPoint(int x,int y):x(x),y(y) {}\n\tPoint operator + (const Point &p) {return Point(x+p.x,y+p.y);}\n}P[210];\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&P[i].x,&P[i].y);\n\tAns=power(2,n);\n\tfor (i=1;i<=n;i++)\n\tfor (j=i+1;j<=n;j++)\n\t{\n\t\tint cnt=0;\n\t\tfor (k=j+1;k<=n;k++)\n\t\t\tcnt+=(P[i].x-P[j].x)*(P[i].y-P[k].y)==(P[i].x-P[k].x)*(P[i].y-P[j].y);\n\t\t(Ans+=mo-power(2,cnt))%=mo;\n\t}\n\t(Ans+=mo-n-1)%=mo;\n\tprintf(\"%d\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\nint gcd(int a, int b) { return a ? gcd(b%a, a) : b; }\ntypedef long long ll;\nll mod = 998244353LL;\nll add(ll x, ll y) { return (x += y) >= mod ? x - mod : x; }\nll sub(ll x, ll y) { return add(x, mod - y); }\nll modpow(ll a, ll b) {\n    ll ret = 1; while (b > 0) {\n        if (b & 1) ret = ret * a % mod; a = a * a % mod; b >>= 1;\n    } return ret;\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\nint N, X[202], Y[202];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) cin >> X[i] >> Y[i];\n\n    ll ans = modpow(2, N);\n\n    // no point\n    ans = sub(ans, 1);\n\n    // one point\n    ans = sub(ans, N);\n\n    // line points\n    rep(i, 0, N) rep(j, i + 1, N) {\n        int n = 0;\n        rep(k, j + 1, N) {\n            int dx1 = X[j] - X[i], dy1 = Y[j] - Y[i];\n            int dx2 = X[k] - X[i], dy2 = Y[k] - Y[i];\n            // dy1/dx1 == dy2/dx2\n            if (dy1 * dx2 == dy2 * dx1) n++;\n        }\n        ans = sub(ans, modpow(2, n));\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\n\nconst int MOD = 998244353;\n\nll pow2[11111];\n\nll add(ll a, ll b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\n\nll mult(ll a, ll b)\n{\n\treturn (a*b)%MOD;\n}\n\nll subt(ll a, ll b)\n{\n\ta-=b;\n\twhile(a<0) a+=MOD;\n\treturn a;\n}\n\nmap<pair<ll,ll>,ll> ma;\nbool vis[201][201];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tvector<ii> vec;\n\tpow2[0]=1;\n\tfor(int i=1;i<=10000;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tvec.pb(mp(x,y));\n\t}\n\tll ans = pow2[n];\n\tans = subt(ans,1); //subtract empty set\n\tans = subt(ans,n); //subtract set of size 1\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif(vis[i][j]||vis[j][i]) continue;\n\t\t\t//cerr<<i<<' '<<j<<'\\n';\n\t\t\tll Y = vec[j].se-vec[i].se;\n\t\t\tll X = vec[j].fi-vec[i].fi;\n\t\t\tii gradient;\n\t\t\tif(X==0) \n\t\t\t{\n\t\t\t\tgradient = mp(1,0);\n\t\t\t}\n\t\t\telse if(Y==0)\n\t\t\t{\n\t\t\t\tgradient = mp(0,1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll g = __gcd(X,Y);\n\t\t\t\tY/=g; X/=g;\n\t\t\t\tif(X<0)\n\t\t\t\t{\n\t\t\t\t\tX*=-1;\n\t\t\t\t\tY*=-1;\n\t\t\t\t}\n\t\t\t\tgradient = mp(Y,X);\n\t\t\t}\n\t\t\tll cnt=2;\n\t\t\tvis[i][j]=vis[j][i]=1;\n\t\t\tvi V;\n\t\t\tV.pb(i); V.pb(j);\n\t\t\tfor(int k = 0; k < n; k++)\n\t\t\t{\n\t\t\t\tif(k!=i&&k!=j)\n\t\t\t\t{\n\t\t\t\t\tll Y2 = vec[k].se-vec[i].se;\n\t\t\t\t\tll X2 = vec[k].fi-vec[i].fi;\n\t\t\t\t\tii gradient2;\n\t\t\t\t\tif(X2==0) \n\t\t\t\t\t{\n\t\t\t\t\t\tgradient2 = mp(1,0);\n\t\t\t\t\t}\n\t\t\t\t\telse if(Y2==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tgradient2 = mp(0,1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tll g2 = __gcd(X2,Y2);\n\t\t\t\t\t\tY2/=g2; X2/=g2;\n\t\t\t\t\t\tif(X2<0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tX2*=-1;\n\t\t\t\t\t\t\tY2*=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgradient2 = mp(Y2,X2);\n\t\t\t\t\t}\n\t\t\t\t\tif(gradient==gradient2) \n\t\t\t\t\t{\n\t\t\t\t\t\tif(!vis[i][k]&&!vis[j][k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tV.pb(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int z=0;z<V.size();z++)\n\t\t\t{\n\t\t\t\tfor(int z2=0;z2<V.size();z2++)\n\t\t\t\t{\n\t\t\t\t\tvis[V[z]][V[z2]]=1;\n\t\t\t\t\t//cerr<<z<<' '<<z2<<'\\n';\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cerr<<cnt<<'\\n';\n\t\t\tans = subt(ans, pow2[cnt]-cnt-1);\n\t\t}\n\t}\n\t\n\tans%=MOD;\n\tif(ans<0) ans+=MOD;\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n\nusing namespace std;\n\nint powers2[201], x[200], y[200];\n\nint main() {\n  powers2[0] = 1;\n  for (int i = 1; i <= 200; i++) powers2[i] = (powers2[i - 1] * 2) % MOD;\n\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d %d\", &x[i], &y[i]);\n  \n  int res = powers2[n];\n  res -= 1 + n + n * (n - 1) / 2;\n  res %= MOD;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int counter = 2;\n      int a = y[j] - y[i];\n      int b = x[i] - x[j];\n      int c = -a * x[i] - b * y[i];\n      for (int k = 0; k < n; k++) {\n        if (k == i || k == j) continue;\n        if (k < j) break;\n        if (a * x[k] + b * y[k] + c == 0) counter++;\n      }\n      res -= powers2[counter];\n      res += 1 + counter + counter * (counter - 1) / 2;\n      res %= MOD;\n    }\n  }\n  printf(\"%d\\n\", (res % MOD + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//A,Elebereth Gilthoniel mantae!\n//For Temeria!\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<cstdio>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cstring> \nusing namespace std;\nvector<long long> siz;long long vis[205][205];long long mod=998244353;\nlong long quipow(long long a,long long b)\n{\n    long long ans=1;\n     while(b)\n     {\n         if(b&1) ans=ans*a%mod;\n         b>>=1;\n         a=a*a%mod;\n     }\n     return ans%mod;\n}\nlong long fac[505],inv[505];\nvoid prepare()    \n{\n    fac[0]=fac[1]=1;\n    for(long long i=2;i<=500;i++)   fac[i]=fac[i-1]*i%mod;\n\n    inv[500]=quipow(fac[500],mod-2);\n    for(long long i=500-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\npair<double,double> p[505];\nint main()\n{\n \t//freopen(\"\",\"r\",stdin);\n\t//freopen(\"\",\"w\",stdout);\n\tprepare();\n\tlong long n;cin>>n;\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tcin>>p[i].first>>p[i].second;\n\t}\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tfor(long long j=0;j<n;j++)\n\t\t{\n\t\t\tvector<int> v;v.clear();\n\t\t\tif(i==j or(vis[i][j]==1)) continue;v.push_back(i);v.push_back(j);\n\t\t\tif(p[i].first==p[j].first)\n\t\t\t{\n\t\t\t\tlong long u=0;u++;u++;\n\t\t\t\tfor(long long t=0;t<n;t++)\n\t\t\t\t{\n\t\t\t\t\tif(i==t or j==t) continue;\n\t\t\t\t\tif(abs(p[t].first-p[i].first)<1e-10)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.push_back(t);\n\t\t\t\t\t\tu++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u>2)siz.push_back(u);\n\t\t\t\tfor(int t=0;t<v.size();t++) for(int y=0;y<v.size();y++) vis[v[y]][v[t]]=1; \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble k=(p[i].second-p[j].second)/(p[i].first-p[j].first);\n\t\t\tdouble b=p[i].second-p[i].first*k;\n\t\t\tlong long u=0;u++;u++;\n\t\t\tfor(long long t=0;t<n;t++)\n\t\t\t{\n\t\t\t\tif(i==t or j==t) continue;\n\t\t\t\tif(abs(p[t].first*k+b-p[t].second)<=1e-10)\n\t\t\t\t{\n\t\t\t\t\tv.push_back(t);\n\t\t\t\t\tu++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(u>2)siz.push_back(u);\n\t\t\tfor(int t=0;t<v.size();t++) for(int y=0;y<v.size();y++) vis[v[y]][v[t]]=1; \n\t\t}\n\t}\n\tlong long ans=0;long long y=n*(n-1);\n\tfor(long long i=3;i<=n;i++)\n\t{\n\t\ty=y*(n-i+1);y=y%mod;\n\t\tans+=y*inv[i];ans=ans%mod;\n\t}\n\tfor(long long i=0;i<siz.size();i++)\n\t{\n\t\ty=(siz[i])*(siz[i]-1);\n\t\tfor(long long j=3;j<=siz[i];j++)\n\t\t{\n\t\t\ty=y*(siz[i]-j+1);y=y%mod;\n\t\t\tans-=y*inv[j];ans=ans%mod;\n\t\t}\n\t}\n\tif(ans<0) ans+=mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#include <unistd.h>\n//#include <iostream>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n//#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n//int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n//int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\nvi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 555555;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nusing P = complex<int>;\n#define EPS (1e-10)\n// 2�̃X�J���[�����������ǂ���\n#define EQ(a,b) (abs((a)-(b)) < EPS)\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\nint is_point_on_line(P a, P b, P c) {\n\treturn EQ(cross(b - a, c - a), 0.0);\n}\n\nsigned main() {\n  int n;\n  cin >> n;\n  vector<P> xy(n);\n  rep (i, n) {\n    int x, y;\n    cin >> x >> y;\n    xy[i].real(x);\n    xy[i].imag(y);\n  }\n  DEBUG_VEC(xy);\n\n  ll ans = mod_pow(2, n);\n  ans -= 1 + n + n * (n - 1) / 2;\n\n  rep (i, n) {\n    for (int j = i + 1; j < n; j++) {\n      int cnt = 0;\n      for (int k = j + 1; k < n; k++) {\n        if (is_point_on_line(xy[i], xy[j], xy[k])) {\n          cnt++;\n        }\n      }\n      ans -= mod_pow(2, cnt) - 1;\n      ans %= MOD;\n    }\n  }\n  ans = (ans + MOD) % MOD;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int mod=998244353;\nint x[201],y[201],p[201];\nint main(){\n    int n;scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n    p[0]=1;\n    for(int i=0;i<n;i++)p[i+1]=(p[i]<<1)%mod;\n    int ans=p[n]-n-1;\n    for(int i=0;i<n;i++)\n        for(int j=0;j<i;j++){\n            int cnt=0;\n            for(int k=0;k<j;k++)if((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))cnt++;\n            ans=(ans-p[cnt]+mod)%mod;\n        }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=205,mod=998244353;\ntypedef long long LL;\nint n,tot;\nLL ans,f[N][N],g[N][N];\n\nstruct P\n{\n\tint x,y;\n\n\tP operator - (P t) {return (P){x-t.x,y-t.y};}\n\tint operator * (P t) {return -t.x*y+x*t.y;}\n} dat[N],p[N],tmp;\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nint sqr(int x)\n{\n\treturn x*x;\n}\n\nint dis(P a,P b)\n{\n\treturn sqr(a.x-b.x)+sqr(a.y-b.y);\n}\n\nbool cmp(P a,P b)\n{\n\tint x=(a-tmp)*(b-tmp);\n\treturn !x?(dis(a,tmp)<dis(b,tmp)):x>0;\n}\n\nbool check(P a,P b,P c,P d)\n{\n\tint t=abs((a-c)*(b-c));\n\tint s=abs((a-c)*(d-c))+abs((b-a)*(d-a))+abs((c-b)*(d-b));\n\treturn t==s && ((a-c)*(d-c));\n}\n\nvoid solve(int x)\n{\n\tp[tot=1]=tmp=dat[x];\n\trep(i,1,n) if(i!=x)\n\t\tif(dat[i].y>dat[x].y || (dat[i].y==dat[x].y && dat[i].x>=dat[x].x))\n\t\t\tp[++tot]=dat[i];\n\tsort(p+2,p+1+tot,cmp);\n\trep(i,2,tot-1) rep(j,i+1,tot)\n\t{\n\t\tg[i][j]=1;\n\t\trep(k,i+1,j-1)\n\t\t\tif(check(p[i],p[j],tmp,p[k]))\n\t\t\t\tg[i][j]=g[i][j]*2%mod;\n\t}\n\trep(i,1,tot) rep(j,1,tot) f[i][j]=0;\n\trep(i,2,tot)\n\t{\n\t\tf[1][i]=1;\n\t\trep(j,2,i-1) if((p[i]-tmp)*(p[j]-tmp)==0) f[1][i]=f[1][i]*2%mod;\n\t}\n\trep(i,1,tot-2)\n\t\trep(j,i+1,tot-1)\n\t\t\trep(k,j+1,tot)\n\t\t\t\tif((p[k]-p[j])*(p[i]-p[j])>0)\n\t\t\t\t\tf[j][k]=(f[j][k]+g[j][k]*f[i][j])%mod;\n\trep(i,2,tot-1) rep(j,i+1,tot) \n\t\tif((tmp-p[j])*(p[i]-p[j])>0) ans=(ans+f[i][j])%mod;\n}\n\nint main()\n{\n\tn=getint();\n\trep(i,1,n)\n\t\tdat[i].x=getint(),dat[i].y=getint();\n\trep(i,1,n)\n\t\tsolve(i);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int maxn = 2e2 + 10;\nconst long long mod = 998244353;\n\nint n;\ndouble x[maxn], y[maxn];\nlong long pot[maxn];\n\nlong long solve() {\n\tpot[0] = 1LL;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tpot[i] = (pot[i - 1] * 2LL) % mod;\n\n\tlong long ans = (pot[n] - 1 + mod) % mod;\n\n\tfor(int i = 1; i <= n; ++i) {\n\t\tmap <double, int> angle;\n\n\t\tfor(int j = i + 1; j <= n; ++j) {\n\t\t\tdouble dx = x[i] - x[j];\n\t\t\tdouble dy = y[i] - y[j];\n\n\t\t\t++angle[dy / dx];\n\t\t}\n\n\t\tlong long add = 0;\n\n\t\tfor(auto it: angle) \n\t\t\tadd = (add + pot[it.second] - 1 + mod) % mod;\n\n\t\tadd = (add + 1) % mod;\n\n\t\tans = (ans - add + mod) % mod;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tcin >> x[i] >> y[i];\n\n\tcout << solve() << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cmath>\n#define Mod 998244353\nusing namespace std;\nint Lv[10000005];\nint KSM(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=(ans*a)%Mod;\n\t\tb>>=1;\n\t\ta=(a*a)%Mod;\n\t}\n\treturn ans;\n}\nint cal(int n)\n{\n\tint hole;\n\thole=KSM(2,n);\n\thole-=n;\n\tif(n%2==0)\n\t{\n\t\thole-=(n/2*(n-1))%Mod;\n\t}\n\telse\n\t{\n\t\thole-=((n-1)/2*n)%Mod;\n\t}\n\treturn hole;\n}\nint C(double x)\n{\n\tint ans=floor(x);\n\tdouble k=ans*1.00;\n\tif(x-k<0.5)\n\t\treturn ans;\n\telse\n\t\treturn ans+1;\n}\nint main()\n{\n\tint n,hole,a,b,anss;\n\tdouble ans;\n\tscanf(\"%d\",&n);\n\tif(n<=2)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\thole=cal(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\t/*ans=(a*1.0)/(b*1.0);\n\t\tanss=C(ans);\n\t\tLv[anss]++;*/\n\t\tif(b!=0)\n\t\t\tLv[a/b]++;\n\t\telse\n\t\t\tLv[10000000]++;\n\t}\n\tanss=0;\n\tfor(int i=0;i<=10000000;i++)\n\t\tif(Lv[i]>=3)\n\t\t\tanss+=cal(Lv[i]);\n\tprintf(\"%d\\n\",hole-anss-1);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i*i <= N; ++i)\n\t{\n\t\tif (N%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD> &other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<998244353> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\ntemplate<typename RET = mint, typename Integral>\nRET combination(Integral all, Integral get)\n{\n\tassert(all >= get);\n\tget = std::min(all - get, get);\n#if 1\n\t//時間計算量O(logMOD)\n\tstatic const auto fact_v = fact_set_c<100001>();\n\treturn fact_v[all] / (fact_v[get] * fact_v[all - get]);\n#elif 0\n\t//時間計算量O(1)\n\t//空間計算量、初期化時間計算量O(N^2)\n\tconstexpr int32_t ALL_MAX = 10'000;\n\tstatic std::vector<RET> DP_comb[ALL_MAX + 1];\n\tif (!DP_comb[all].empty())\n\t{\n\t\treturn DP_comb[all][get];\n\t}\n\n\tif (DP_comb[0].empty())\n\t{\n\t\tDP_comb[0].resize(1);\n\t\tDP_comb[0][0] = (RET)1;\n\t\tDP_comb[1].resize(1);\n\t\tDP_comb[1][0] = (RET)1;\n\t}\n\tfor (int32_t i = 2; i <= all; i++)\n\t{\n\t\tif (DP_comb[i].empty())\n\t\t{\n\t\t\tint32_t size = i / 2 + 1;\n\t\t\tDP_comb[i].resize(size);\n\t\t\tDP_comb[i][0] = (RET)1;\n\t\t\tfor (int32_t j = 1; j < size - 1; j++)\n\t\t\t{\n\t\t\t\tDP_comb[i][j] = DP_comb[i - 1][j - 1] + DP_comb[i - 1][j];\n\t\t\t}\n\t\t\tDP_comb[i][size - 1] = DP_comb[i - 1][size - 2] + DP_comb[i - 1][(i & 1) ? (size - 1) : (size - 2)];\n\t\t}\n\t}\n\treturn DP_comb[all][get];\n#else\n\t//時間計算量O(get * logMOD)\n\tRET ret = (RET)1;\n\tfor (Integral i = 1; i <= get; ++i)\n\t{\n\t\tret *= all + 1 - i;\n\t\tret /= i;\n\t}\n\treturn ret;\n#endif\n}\n\n\n\nint32_t N;\nusing std::vector;\nstruct P {\n\tint32_t x, y;\n\tint32_t dot(P o) {\n\t\treturn x*o.x + y*o.y;\n\t}\n\tint32_t det(P o) {\n\t\treturn x*o.y - y*o.x;\n\t}\n};\nP operator-(P a, P b) {\n\treturn P{ a.x - b.x, a.y - b.y };\n}\n// 辞書順で比較\ninline bool cmp_x(const P& p, const P& q) {\n\tif (p.x != q.x) return p.x < q.x;\n\treturn p.y < q.y;\n}\n// 凸包を求める\nvector<P> convex_hull(P* ps, int n) {\n\tstd::sort(ps, ps + n, cmp_x);\n\tint k = 0; // 凸包の頂点数\n\tvector<P> qs(n * 2); // 構築中の凸包\n\t\t// 下側凸包の作成\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\t\tqs[k++] = ps[i];\n\t\t}\n\t// 上側凸包の作成\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n// 距離の二乗\ndouble dist(P p, P q) {\n\treturn (p - q).dot(p - q);\n}\n// 入力\nint N;\nP ps[200];\nmint powpow[500];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tin >> ps[i].x >> ps[i].y;\n\t}\n\tpowpow[0] = 1;\n\tfor (size_t i = 1; i < 500; i++)\n\t{\n\t\tpowpow[i] = powpow[i - 1] * 2;\n\t}\n\n\n\tmint res = 0;\n\tvector<P> qs = convex_hull(ps, N);\n\tres += powpow[N - qs.size()];\n\tfor (int32_t i = qs.size(); i >= 0 ; i--)\n\t{\n\t\tres += powpow[N - qs.size()]*i;\n\t}\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define LL long long\nconst int maxn = 205;\nconst LL mo = 998244353;\nusing namespace std;\nint x[maxn], y[maxn], n;\nLL ans = 0, pw[maxn];\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d%d\", x + i, y + i);\n\tpw[0] = 1; for (int i = 1; i <= n; i++) pw[i] = pw[i - 1] * 2 % mo; \n\tans = (pw[n] - 1 - n + mo) % mo;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++){\n\t\t\tint tmp = 0;\n\t\t\tfor (int k = 1; k <= n; k++){\n\t\t\t\tif (x[k] >= min(x[i], x[j]) && x[k] <= max(x[i], x[j]) && y[k] >= min(y[i], y[j]) && y[k] <= max(y[i], y[j])){\n\t\t\t\t\tif ((y[k] - y[i]) * (x[j] - x[k]) == (x[k] - x[i]) * (y[j] - y[k])) ++tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = (ans - pw[tmp - 2] + mo) % mo;\n\t\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-8;\nconst int MOD = 998244353;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n  unsigned get() const { return x; }\n\n  // 逆数\n  ModInt inv() const {\n    ll a = 1, p = x, e = MOD-2;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // e乗\n  ModInt pow(ll e) {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // 2のx乗\n  ModInt pow2() {\n    ll a = 1, p = 2, e = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // 代入\n  void operator=(ll b) { x = b; }\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  ModInt &operator+=(ModInt that) {\n    x = ((ll)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((ll)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (ll)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (ll)x * that.inv() % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (ll)x % that.x;\n    return *this;\n  }\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP p[205];\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) {\n    double x, y;\n    cin >> x >> y;\n    p[i] = {x, y};\n  }\n\n  mint ret = mint(n).pow2() - n - 1;\n  REP(i, n) FOR(j, i+1, n) {\n    mint cnt = 0;\n    REP(k, n) if(k!=i && k!=j && intersectSP(L(p[i], p[j]), p[k])) ++cnt;\n    ret -= cnt.pow2();\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define MAXN 201\nconst int mod = 998244353;\n\npair<int, int> p[MAXN];\nint n, bio[MAXN][MAXN];\n\nint check(int i, int j) {\n  int ret = 1;\n  set<int> s;\n  s.insert(i);\n  s.insert(j);\n  pair<int, int> v = make_pair(p[j].first-p[i].first, p[j].second-p[i].second);\n  for (int k = 0; k < n; ++k) {\n    if (k==i || k==j) continue;\n    pair<int, int> v2 = make_pair(p[k].first-p[i].first, p[k].second-p[i].second);\n    if (v.first*v2.second-v.second*v2.first==0) {\n      s.insert(k);\n    }\n  }\n  for (auto si : s) {\n    for (auto sj : s) {\n      bio[si][sj] = 1;\n      bio[sj][si] = 1;\n    }\n  }\n  for (int i = 0; i < s.size(); ++i) {\n    ret *= 2;\n    ret %= mod;\n  }\n  ret--;\n  ret -= s.size();\n  return ret;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int ans = 1;\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i].first >> p[i].second;\n  }\n  for (int i = 0; i < n; ++i) {\n    ans *= 2;\n    ans %= mod;\n  }\n  ans--;\n  ans -= n;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i+1; j < n; ++j) {\n      if (bio[i][j]) continue;\n      ans -= check(i, j);\n      if (ans<0) ans += mod;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) < 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<point> ns;\n        for (int j = 0; j < n; j++) {\n            if (j == i) {\n                continue;\n            }\n            if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {\n                need[j] = true;\n                ns.push_back(p[j]);\n            } else {\n                need[j] = false;\n            }\n        }\n        cur = p[i];\n        sort(all(ns), comp);\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                goods[j][k] = false;\n                cnt[j][k] = 0;\n                dp[j][k] = 0;\n                if (good(p[i], ns[j], ns[k])) {\n                    goods[j][k] = true;\n                    for (int g = 0; g < sz(ns); g++) {\n                        if (g == j || g == k) {\n                            continue;\n                        }\n                        if (inside(p[i], ns[j], ns[k], ns[g])) {\n                            cnt[j][k]++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (goods[j][k]) {\n                    dp[j][k] += st[cnt[j][k]];\n                    dp[j][k] %= Mod;\n                    ans += dp[j][k];\n                    ans %= Mod;\n                    for (int nxt = k + 1; nxt < sz(ns); nxt++) {\n                        if (vec(ns[nxt] - ns[j], ns[k] - ns[j]) > 0 && goods[k][nxt] && vec(ns[nxt] - p[i], ns[k] - p[i]) != 0) {\n                            dp[k][nxt] += (1LL * dp[j][k] * st[cnt[k][nxt]]) % Mod;\n                            dp[k][nxt] %= Mod;\n                        }\n                    }\n                }   \n            }\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int N = 211;\nconst int mod = 998244353;\nint n;\nLL base[N];\nstruct ddd{\n    int x, y;\n}nd[N];\nint sq(int x){return x * x;}\nbool check(LL x1, LL y1, LL x2, LL y2){\n    LL a = x1 * x2 + y1 * y2;\n    LL b = (sq(x1) + sq(y1)) * (sq(x2) + sq(y2));\n    return a > 0 && b == sq(a);\n}\nint main(){\n    cin>>n;\n    for(int i = 1;i <= n; i++){\n        scanf(\"%d%d\", &nd[i].x, &nd[i].y);\n    }\n    base[0] = 1;\n    for(int i = 1;i <= 200; i++)base[i] = base[i-1] * 2 % mod;\n    LL ans = (base[n] - 1 - n + mod) % mod;\n    for(int i = 2;i <= n; i++){\n        for(int j = 1;j < i; j++){\n            int tot = 0;\n            for(int k = 1;k <= n; k++){\n                if(i == k || j == k)continue;\n                if(check(nd[i].x - nd[k].x, nd[i].y - nd[k].y, nd[k].x - nd[j].x, nd[k].y - nd[j].y))tot++;\n            }\n            ans = (ans + mod - base[tot]) % mod;\n            //printf(\"i=%d j=%d tot=%d\\n\", i, j, tot);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nconst int N=205,mo=998244353;\nint pw[N],s;\nstruct P{\n\tint x,y;\n\tP(const int xx=0,const int yy=0):x(xx),y(yy){}\n}p[N];\nP operator -(P a,P b){return P(a.x-b.x,a.y-b.y);}\nint operator *(P a,P b){return a.x*b.y-a.y*b.x;}\nbool operator <(P a,P b){return a.x!=b.x?a.x<b.x:a.y<b.y;}\nbool cmp(P a,P b){return (a-p[s])*(b-p[s])<0;}\nint main(){\n\tint n;\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d%d\",&p[i].x,&p[i].y);\n\tpw[0]=1;\n\tfor (int i=1;i<=n;i++) pw[i]=pw[i-1]*2%mo;\n\tint ans=pw[n]-n-1;\n\tfor (int i=1;i<=n;i++){\n\t\ts=i;\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (p[j]<p[s]) s=j;\n\t\tstd::swap(p[i],p[s]);s=i;\n\t\tstd::sort(p+i+1,p+n+1,cmp);\n\t\tfor (int j=i+1,k=i+1;j<=n;j=k){\n\t\t\tfor (;k<=n && (p[j]-p[i])*(p[k]-p[i])==0;k++);\n\t\t\t(ans-=pw[k-j]-1)%=mo;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ans+mo)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 998244353\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nll ppow(ll a,ll b){\n\tll res=1;\n\twhile(b){\n\t\tif(b&1)res=(res*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nstruct Point{int x,y;};\nint cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint operator-(Point a,Point b){\n\treturn {a.x-b.x,a.y-b.y};\n}\n\nPoint p[300];\nint main(){\n\tint n;cin>>n;\n\trep(i,n){\n\t\tscanf(\"%d%d\",&p[i].x,&p[i].y);\n\t}\n\tsort(p,p+n,[](Point a,Point b){\n\t\tif(a.x==b.x)return a.y<b.y;\n\t\treturn a.x<b.x;\n\t});\n\tint ans=(ppow(2,n)+MOD-(1+n)%MOD)%MOD;\n\trep(i,n){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tPoint pp=p[j]-p[i];\n\t\t\tbool ok=true;\n\t\t\tint cnt=2;\n\t\t\trep(k,n){\n\t\t\t\tif(k==i||k==j)continue;\n\t\t\t\tif(cross(pp,p[k]-p[j])==0){\n\t\t\t\t\tif(k<j){ok=false;break;}\n\t\t\t\t\telse cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tans=(ans+MOD-(ppow(2,cnt)+MOD-(1+cnt)%MOD)%MOD)%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\n#ifdef ONLINE_JUDGE\nconst int N = 1e6+50;\n#else\nconst int N = 1e2+10;\n#endif\n\n\nint n,x[N],y[N],po[N];\n\nint main() {\n\tpo[0]=1;\n\tREP(i,1,N-1) po[i]=po[i-1]*2ll%P;\n\tscanf(\"%d\",&n);\n\tREP(i,1,n) scanf(\"%d%d\",x+i,y+i);\n\tint ans = (po[n]-1-n*(n+1)/2)%P;\n\tREP(i,1,n) REP(j,i+1,n) {\n\t\tint cnt = 0;\n\t\tREP(k,j+1,n) if ((x[j]-x[i])*(y[k]-y[i])==(x[k]-x[i])*(y[j]-y[i])) ++cnt;\n\t\tans = (ans-po[cnt]+1)%P;\n\t}\n\tif (ans<0) ans+=P;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<functional>\n#include<vector>\n#include<map>\n#include<string>\n#include<set>\n#include<unordered_set>\n#include<stack>\n#define int long long\n#define mod 998244353\n#define P pair<int,int>\nusing namespace std;\n\nP a[200];\nsigned main() {\n\tint ans = 1;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = ans * 2 % mod;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t}\n\tans -= n + 1;\n\tans %= mod;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tvector<int>V;\n\t\t\tif (a[i].first == a[j].first) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].first == a[i].first) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (a[i].second == a[j].second) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (a[k].second == a[i].second) {\n\t\t\t\t\t\tV.push_back(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble x = double(a[j].second - a[i].second) / (a[j].first - a[i].first);\n\t\t\t\tdouble y = double(a[i].second) - a[i].first*x;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (abs(a[i].first*x + y - a[i].second) <= 1e-10) {\n\t\t\t\t\t\tV.push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(V.begin(), V.end());\n\t\t\tif (V.size()>=2&&V[0] == i&&V[1]==j) {\n\t\t\t\tint k = 1;\n\t\t\t\tfor (int j : V) {\n\t\t\t\t\tk = k * 2 % mod;\n\t\t\t\t}\n\t\t\t\tk -= V.size(); k--;\n\t\t\t\tans -= k;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tans += mod * 5;\n\tans %= mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-15;\nconst int MOD = 998244353;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n  unsigned get() const { return x; }\n\n  // 逆数\n  ModInt inv() const {\n    ll a = 1, p = x, e = MOD-2;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // e乗\n  ModInt pow(ll e) {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // 2のx乗\n  ModInt pow2() {\n    ll a = 1, p = 2, e = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // 代入\n  void operator=(ll b) { x = b; }\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator++(int) {ModInt a = *this; x++; return a;}\n  ModInt operator--() { x--; return *this; }\n  ModInt operator--(int) {ModInt a = *this; x--; return a;}\n\n  // Basic Operations\n  ModInt &operator+=(ModInt that) {\n    x = ((ll)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((ll)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (ll)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (ll)x * that.inv() % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (ll)x % that.x;\n    return *this;\n  }\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<998244353> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP p[205];\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) {\n    double x, y;\n    cin >> x >> y;\n    p[i] = {x, y};\n  }\n\n  mint ret = mint(n).pow2() - n - 1;\n  REP(i, n) FOR(j, i+1, n) {\n    mint cnt = 0;\n    REP(k, n) if(k!=i && k!=j && intersectSP(L(p[i], p[j]), p[k])) ++cnt;\n    ret -= cnt.pow2();\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nstruct point{\n\tint x , y;\n\tpoint(int _x = 0 , int _y = 0){\n\t\tx = _x;\n\t\ty = _y;\n\t}\n\tpoint operator + (const point &other) const {\n\t\treturn point(x + other.x , y + other.y);\n\t}\n\tpoint operator - (const point &other) const {\n\t\treturn point(x - other.x , y - other.y);\n\t}\n\tbool operator < (const point &other) const {\n\t\tif(x == other.x){\n\t\t\treturn y < other.y;\n\t\t}\n\t\treturn x < other.x;\n\t}\n\tvoid read(){\n\t\tscanf(\"%d %d\" , &x , &y);\n\t}\n};\ninline int dot(point a , point b){\n\treturn a.x * b.x + a.y * b.y;\n}\ninline int cross(point a , point b){\n\treturn a.x * b.y - a.y * b.x;\n}\ninline int orient(point a , point b , point c){//orientation of point c with respect to line from a -> b\n\tint val = cross(b - a , c - a);\n\tif(val > 0){\n\t\treturn 1;//c comes anticlockwise on line from a -> b\n\t}\n\tif(val < 0){\n\t\treturn -1;//c comes clockwise on line from a -> b\n\t}\n\treturn 0;//c is collinear with line from a -> b\n}\nint dist(point a , point b){\n\treturn dot(a - b , a - b);\n}\nconst int N = 205;\nconst int mod = 998244353;\nconst int inv = 499122177;\nint pw2[N];\nint n;\npoint arr[N];\nvector < point > v;\npoint bottom;\nint ans;\nbool cmp(point a , point b){\n\tint tmp = orient(bottom , a , b);\n\tif(tmp == -1){\n\t\treturn 1;\n\t}\n\tif(tmp == 1){\n\t\treturn 0;\n\t}\n\treturn dist(bottom , a) < dist(bottom , b);\n}\nbool inside(point p1 , point p2 , point p3 , point q){\n\tint o1 = orient(p1 , p2 , q);\n\tint o2 = orient(p2 , p3 , q);\n\tint o3 = orient(p3 , p1 , q);\n\treturn (o1 == o2) && (o2 == o3) && (o3 != 0);\n}\nint siz2[N][N][N];\nint siz3[N][N];\nmap < point , int > mp;\nvector < int > indexes;\n//int tot;\nint dp[N][N];\nint solve(int last1 , int last2){\n\tif(dp[last1][last2] != -1){\n\t\treturn dp[last1][last2];\n\t}\n\tint res = !!last1;\n\t/*if(last1){\n\t\tcout << tot << \" \";\n\t}*/\n\tfor(int i = last2 + 1 ; i < v.size() ; ++i){\n\t\tif(orient(v[last1] , v[last2] , v[i]) == -1){\n\t\t\t//tot += siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0);\n\t\t\tres = (res + 1LL * solve(last2 , i) * pw2[siz2[indexes[0]][indexes[last1]][indexes[i]] + siz3[indexes[0]][indexes[i]] + siz3[indexes[last2]][indexes[i]]]) % mod;\n\t\t\t//tot -= siz2[indexes[0]][indexes[last1]][indexes[i]] + (last1 ? siz3[indexes[0]][i] : 0);\n\t\t}\n\t}\n\treturn dp[last1][last2] = res;\n}\nvoid solve(int idx){\n\tv.clear();\n\tbottom.x = arr[idx].x;\n\tbottom.y = arr[idx].y;\n\tv.emplace_back(arr[idx]);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tif(arr[i].y > bottom.y){\n\t\t\tv.emplace_back(arr[i]);\n\t\t}\n\t\telse if(arr[i].y == bottom.y && arr[i].x > bottom.x){\n\t\t\tv.emplace_back(arr[i]);\n\t\t}\n\t}\n\tsort(v.begin() + 1 , v.end() , cmp);\n\tindexes.clear();\n\tfor(int i = 0 ; i < v.size() ; ++i){\n\t\tindexes.emplace_back(mp[v[i]]);\n\t}\n\t//cout << v.size() << \"--\\n\";\n\tmemset(dp , -1 , sizeof(dp));\n\tfor(int i = 1 ; i < v.size() ; ++i){\n\t\t//tot = siz3[indexes[0]][indexes[i]];\n\t\tans = (ans + 1LL * solve(0 , i) * pw2[siz3[indexes[0]][indexes[i]]]) % mod;\n\t\t//cout << \"WTF\\n\";\n\t}\n\t//cout << ans << endl;\n}\nvoid pre(){\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tfor(int j = 1 ; j <= n ; ++j){\n\t\t\tif(i == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsiz3[i][j] = 0;\n\t\t\tint qlx = min(arr[i].x , arr[j].x);\n\t\t\tint qrx = max(arr[i].x , arr[j].x);\n\t\t\tint qly = min(arr[i].y , arr[j].y);\n\t\t\tint qry = max(arr[i].y , arr[j].y);\n\t\t\tfor(int k = 1 ; k <= n ; ++k){\n\t\t\t\tif(k != i && k != j){\n\t\t\t\t\tif(arr[k].x >= qlx && arr[k].x <= qrx && arr[k].y >= qly && arr[k].y <= qry && orient(arr[i] , arr[k] , arr[j]) == 0){\n\t\t\t\t\t\t++siz3[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tfor(int j = i + 1 ; j <= n ; ++j){\n\t\t\tfor(int k = j + 1 ; k <= n ; ++k){\n\t\t\t\tint res = 0;\n\t\t\t\tfor(int l = k + 1 ; l <= n ; ++l){\n\t\t\t\t\tres += inside(arr[i] , arr[j] , arr[k] , arr[l]);\n\t\t\t\t}\n\t\t\t\tsiz2[i][j][k] = siz2[i][k][j] = siz2[j][i][k] = siz2[j][k][i] = siz2[k][i][j] = siz2[k][j][i] = res;\n\t\t\t}\n\t\t}\n\t}\n\tmp.clear();\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tmp[arr[i]] = i;\n\t}\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tarr[i].read();\n\t}\n\tans = 0;\n\tpw2[0] = 1;\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tpw2[i] = (2LL * pw2[i - 1]) % mod;\n\t}\n\tpre();\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tsolve(i);\n\t}\n\tprintf(\"%d\\n\" , ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\nconst int MOD=998244353;\nstruct mint{int x;mint(int x=0):x(x){}};\ninline mint operator+  (mint a,mint b){return a.x+b.x<MOD?a.x+b.x:a.x+b.x-MOD;}\ninline mint operator-  (mint a){return MOD-a.x;}\ninline mint operator-  (mint a,mint b){return a+-b;}\ninline mint operator*  (mint a,mint b){return 1LL*a.x*b.x%MOD;}\ninline mint operator<< (mint x,int y){mint r=1;for(;y;y>>=1,x=x*x)if(y&1)r=r*x;return r;}\ninline mint operator~  (mint x){return x<<MOD-2;}\ninline mint operator/  (mint a,mint b){return a*~b;}\ninline mint&operator+= (mint&a,mint b){return a=a+b;}\ninline mint&operator-= (mint&a,mint b){return a=a-b;}\ninline mint&operator*= (mint&a,mint b){return a=a*b;}\ninline mint&operator<<=(mint&x,int y){return x=x<<y;}\ninline mint&operator/= (mint&a,mint b){return a=a/b;}\n#define MN 200\nint x[MN+5],y[MN+5];\nint main()\n{\n\tint n=read(),i,j,k,cnt;\n\tfor(i=1;i<=n;++i)x[i]=read(),y[i]=read();\n\tmint ans=(mint(2)<<n)-n*(n+1)/2-1;\n\tfor(i=1;i<=n;++i)for(j=1;j<=n;++j)if(i!=j)\n\t{\n\t\tfor(cnt=2,k=1;k<=n;++k)if(k!=i&&k!=j)\n\t\t\tif((x[k]-x[i])*(y[j]-y[i])==(y[k]-y[i])*(x[j]-x[i]))++cnt;\n\t\tans-=((mint(2)<<cnt)-cnt*(cnt+1)/2-1)/cnt/(cnt-1);\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst int MOD = 998244353;\n\ni64 comb[202][202];\n\nvoid init() {\n    comb[0][0] = 1;\n    for (int j = 1; j <= 200; ++j) {\n        for (int k = 0; k <= 200; ++k) {\n            comb[j][k] = comb[j-1][k];\n            if (k > 0) {\n                comb[j][k] = (comb[j][k] + comb[j-1][k-1]) % MOD;\n            }\n        }\n    }\n}\n\nint N;\nint x[200], y[200];\n\nint main() {\n    init();\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> N;\n    for (int j = 0; j < N; ++j) {\n        cin >> x[j] >> y[j];\n    }\n\n    if (N < 3) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    i64 s = 1;\n    for (int j = 0; j < N; ++j) {\n        s = (s * 2) % MOD;\n    }\n    s = (s + MOD - 1 - N - N * (N-1) / 2)  % MOD;\n\n    for (int j = 0; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n            i64 q = 0;\n            for (int l = 0; l < N; ++l) {\n                if (j == l || k == l) continue;\n                i64 dx1 = x[l] - x[j], dy1 = y[l] - y[j];\n                i64 dx2 = x[l] - x[k], dy2 = y[l] - y[k];\n\n                i64 d = dx1 * dx2 + dy1 * dy2;\n\n                if (d < 0 && abs(abs(d) - sqrt((dx1 * dx1 + dy1 * dy1) * (dx2 * dx2 + dy2 * dy2))) < 1e-8) {\n                    ++q;\n                }\n            }\n            s = (s + MOD - (1LL << q) + 1) % MOD;\n        }\n    }\n    cout << s << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nbool on_the_line(pii &a, pii &b, pii &c){\n    return ((a.first - c.first)*(b.second-c.second)-(a.second-c.second)*(b.first-c.first)==0);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    pii points[N];\n    REP(i, N){\n        cin >> points[i].first >> points[i].second;\n    }\n    int did[N][N] = {};\n\n    ll pow2[N+2];\n    pow2[0] = 1;\n    for(int i=1;i<N+2;i++){\n        pow2[i] = (2*pow2[i-1])%mod;\n    }\n\n    ll res = pow2[N];\n    res = (res+mod-1)%mod;\n    res = (res+mod-N)%mod;\n\n    for(int i=0;i<N;i++){\n        for (int j=i+1;j<N;j++){\n            if(did[i][j]==0){\n                vector<int> tmp;\n                tmp.push_back(i);\n                tmp.push_back(j);\n                for(int k=j+1;k<N;k++){\n                    if(on_the_line(points[i], points[j], points[k])){\n                        tmp.push_back(k);\n                    }\n                }\n                REP(p, tmp.size()) REP(q, tmp.size()) did[p][q] = 1;\n                int s = tmp.size();\n                res = (res+mod-pow2[s]+1+s)%mod;\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 200\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,b[MN+5][MN+5],x[MN+5],y[MN+5],ans,pw[MN+5],q[MN+5],top;\nint main()\n{\n    n=read();pw[0]=1;\n    for(int j=1;j<=n;++j) pw[j]=2*pw[j-1]%mod;ans=(pw[n]-n-1+mod)%mod;\n    for(int i=1;i<=n;++i) x[i]=read(),y[i]=read();\n    for(int i=1;i<=n;++i) for(int j=i+1;j<=n;++j) if(!b[i][j])\n    {\n        q[top=1]=i;q[top=2]=j;\n        for(int k=j+1;k<=n;++k) if((x[j]-x[i])*(y[k]-y[i])-(x[k]-x[i])*(y[j]-y[i])==0) q[++top]=k;\n        for(int l=1;l<=top;++l) for(int r=l+1;r<=top;++r) b[l][r]=1;\n        ans=((ans-pw[top]+top+1)%mod+mod)%mod;\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing\tnamespace\tstd;\n#define ll long long\n#define\tllu\tunsigned\tlong\tlong\n#define\tld\tdouble\n#define\tllu\tunsigned\tlong\tlong\n#define\trep(i,x,y)\t\tfor(ll\ti=x;i<y;++i)\n#define\tFor(i,x,y)\t\tfor(ll\ti=x;i<=y;++i)\n#define\tFOr(i,x,y)\t\tfor(ll\ti=ll(x);i>=ll(y);--i)\n#define\tpi\tacos(-1)\t\n#define\tmk\tmake_pair\n#define\tpa\tpair<ll,ll>\n#define\tlf\telse\tif\n#define\tIL\tinline\n#define\tmax(x,y)\t\t\t\t((x)<(y)?(y):(x))\n#define\tmin(x,y)\t\t\t\t((x)<(y)?(x):(y))\n#define\tsqr(x)\t\t\t\t\t\t((x)*(x))\n#define\tMul(x,y)\t\t\t\t((x)=1LL*(x)*(y)%mod)\n#define\tAdd(x,y)\t\t\t\t((x)=((x)+(y))%mod)\n#define\tMax(x,y)\t\t\t\t((x)=((x)<(y)?(y):(x)))\n#define\tMin(x,y)\t\t\t\t((x)=((x)>(y)?(y):(x)))\n#define\tE(x)\t\t\t\t\treturn\twriteln(x),0\n#define\tLL\t\t\t\t\t\t(long\tlong)\n#define\tp(x)\t\t\t\t\tprllf(\"~%lld~\\n\",LL(x))\n#define\tpp(x,y)\t\t\t\t\tprllf(\"~~%lld\t%lld~~\\n\",LL(x),LL(y))\n#define\tppp(x,y,z)\t\t\t\tprllf(\"~~~%lld\t%lld\t%lld~~~\\n\",LL(x),LL(y),LL(z))\n#define\tpppp(a,b,c,d)\t\t\tprllf(\"~~~%lld\t%lld\t%lld\t%lld\\n\",LL(a),LL(b),LL(c),LL(d))\n#define\tf_in(x)\t\t\t\t\tfreopen(x\".in\",\"r\",stdin)\n#define\tf_out(x)\t\t\t\tfreopen(x\".out\",\"w\",stdout)\n#define\topen(x)\t\t\t\t\tf_in(x),f_out(x)\n#define\tfi\tfirst\n#define\tse\tsecond\n#define\tGuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\ntypedef\tcomplex<double>\tE;\nnamespace\tSHENZHEBEI{\n#ifdef\tLOCAL\n\t\t\t\tstruct\t_{_(){freopen(\"cf.in\",\"r\",stdin);}}_;\n#endif\t\n#define\tNEG\t1\n\t\t\t\tinline\tchar\tgc(){\treturn\tgetchar();\t}\n#if\tNEG\n\t\t\t\tinline\tll\tread(){\t\t\t\tll\tx=0,fa=1;\tchar\tch=gc();\t\t\tfor\t(;!isdigit(ch);ch=gc())\tif\t(ch=='-')\tfa=-1;\t\tfor\t(;isdigit(ch);ch=gc())\t\tx=x*10-48+ch;\t\t\treturn\tx*fa;\t}\n\t\t\t\tinline\tvoid\twrite(ll\tx){\t\t\t\tif\t(x<0)\tputchar('-'),x=-x;\t\tif\t(x>=10)\t\t\twrite(x/10);\t\t\t\tputchar(x%10+'0');\t\t}\n#else\n\t\t\t\tinline\tll\tread(){\t\t\t\tll\tx=0;\tchar\tch=gc();\t\t\tfor\t(;!isdigit(ch);ch=gc());\t\t\t\tfor\t(;isdigit(ch);ch=gc())\t\tx=x*10-48+ch;\t\t\treturn\tx;\t\t\t}\n\t\t\t\tinline\tvoid\twrite(ll\tx){\t\t\t\tif\t(x>=10)\t\t\twrite(x/10);\t\t\t\tputchar(x%10+'0');\t\t}\n#endif\n\tvoid\twriteln(ll\tx){write(x);puts(\"\");}\n}using\tnamespace\tSHENZHEBEI;\nconst ll N=205,mod=998244353;\nll n,x[N],y[N],bin[N],ans,cnt;\nint main(){\n\tn=read();\tbin[0]=1;For(i,1,n)bin[i]=bin[i-1]*2%mod;\n\tFor(i,1,n)x[i]=read(),y[i]=read();\n\tll ans=(bin[n]-n-1)%mod;\n\tFor(i,1,n)For(j,i+1,n){\n\t\tll sum=0;\n\t\tFor(k,j+1,n)sum+=((x[i]-x[k])*(y[j]-y[k])==(x[j]-x[k])*(y[i]-y[k]));\n\t\tAdd(ans,-bin[sum]);\n\t}writeln((ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint gcd(int a,int b) {return b ? gcd(b,a%b) : abs(a);}\nconst int N = 205, M = 998244353;\nint p2[N];\npair<int,int> a[205];\nint main()\n{\n    int n;\n    cin >> n;\n    p2[0] = 1;\n    for (int i = 1; i <= n; ++i)\n        p2[i] = p2[i-1] * 2 % M;\n    long long ans = 1;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i].first >> a[i].second;\n        map<pair<int,int>,int> mp;\n        for (int j = 0; j < i; ++j) {\n            pair<int,int> v = {a[j].first - a[i].first, a[j].second - a[i].second};\n            if (v.first < 0) {\n                v.first *= -1;\n                v.second *= -1;\n            } else if (v.first == 0 && v.second < 0) {\n                v.second *= -1;\n            }\n            int d = gcd(v.first, v.second);\n            v.first /= d;\n            v.second /= d;\n            ++mp[v];\n        }\n        ++ans;\n        for (auto it = begin(mp); it != end(mp); ++it)\n            ans += p2[it->second] + M - 1;\n    }\n    cout << (p2[n] + M - ans%M) % M << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Point { long long px, py; };\n\nlong long n, mod = 998244353; Point P[1009]; bool used[209][209];\n\nbool solve(Point A, Point B, Point C) {\n\tif ((B.px - A.px)*(C.py - A.py) == (B.py - A.py)*(C.px - A.px)) return true;\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> P[i].px >> P[i].py;\n\t}\n\tlong long ans = 1; for (int i = 1; i <= n; i++) { ans *= 2; ans %= mod; }\n\tans += (mod - n - 1); ans %= mod;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (used[i][j] == true) continue;\n\t\t\tvector<int>G = { i,j };\n\t\t\tfor (int k = j + 1; k <= n; k++) {\n\t\t\t\tif (solve(P[i], P[j], P[k]) == true) G.push_back(k);\n\t\t\t}\n\t\t\tfor (int k = 0; k < G.size(); k++) {\n\t\t\t\tfor (int l = k + 1; l < G.size(); l++) used[G[k]][G[l]] = true;\n\t\t\t}\n\t\t\tlong long Y = 1; for (int k = 0; k < G.size(); k++) { Y *= 2; Y %= mod; }\n\t\t\tY += (mod - G.size() - 1); Y %= mod;\n\t\t\tans -= Y; ans += mod; ans %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:https://beta.atcoder.jp/contests/arc082/tasks/arc082_c>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() {ld x, y; cin >> x >> y; return Point(x, y);} // 点の入力\nbool eq(ld a, ld b) {return (abs(a - b) < eps);} // 誤差つき等号判定\nld dot(Point a, Point b) {return real(conj(a) * b);} // 内積\nld cross(Point a, Point b) {return imag(conj(a) * b);} // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {return !eq(cross(l.b - l.a, m.b - m.a), 0);}\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {return (abs(cross(l.b - p, l.a - p)) < eps);}\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);}\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 点の内外判定\n//  0 => out : 1 => on : 2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包 : 凸多角形のある一辺上にある点を含まない\nPolygon convex_hull(vector<Point>& ps) {\n    int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull2(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n\n// 凸多角形の直径\npair<pll,ld> convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    if(n == 2) return make_pair(pll(0,1),abs(poly[0]-poly[1]));\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    pll resp = make_pair(-1,-1);\n    ld resd = 0;\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    while(i != maxj || j != maxi){\n        ld cur = abs(poly[i] - poly[j]);\n        if(resd + eps < cur){ resd = cur; resp = pll(i,j); }\n        int di = (i+1)%n, dj = (j+1)%n;\n        if(cross(poly[di]-poly[i],poly[dj]-poly[j]) < 0) i = di;\n        else j = dj;\n    }\n    return make_pair(resp,resd);\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\nconst ll MOD = 998244353;\nvector<ll> fact;\nll N;\nmap<Polygon,bool> mp;\nvoid rec(Polygon ps,ll& res){\n    if(ps.size() <= 2) return;\n    if(mp[ps]) return;\n    mp[ps] = true;\n    auto ch = convex_hull(ps);\n    if(ch.size() == 2) return;\n    (res += fact[ps.size()-ch.size()])%=MOD;\n    if(ps.size() == 3) return;\n    for(auto& p:ch){\n        auto next = ps;\n        next.erase(remove(next.begin(),next.end(),p),next.end());\n        rec(next,res);\n    }\n}\nll solve(){\n    ll res = 0;\n    cin >> N;\n    Polygon ps(N); for(Point& p:ps) p = input_point();\n    sort(ps.begin(),ps.end());\n    fact.resize(N+1);\n    fact[0] = 1;\n    for(int i = 1; i <= N;i++) fact[i] = fact[i-1]*2%MOD;\n    rec(ps,res);\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nstruct Int2D {\n  const int64 x, y;\n  Int2D(int64 x, int64 y) : x(x), y(y) {}\n  Int2D operator-(Int2D o) const {\n    return Int2D(x - o.x, y - o.y);\n  }\n  int64 CrossProduct(Int2D o) const {\n    return x * o.y - y * o.x;\n  }\n};\n\nint64 CrossProduct(Int2D p1, Int2D p2) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\nbool Colinear(Int2D p1, Int2D p2, Int2D p3) {\n  Int2D v12 = p2 - p1;\n  Int2D v13 = p3 - p1;\n  return CrossProduct(v12, v13) == 0;\n}\n\nconstexpr int64 P = 998244353;\n\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 x) : x(x) {\n    if (x > P || x < 0) { cerr << \"Invalied FiniteField!\" << endl; exit(1); }\n  }\n  FiniteField() : x(0) {}\n  int64 Value() const { return x; }\n  inline FiniteField operator+(FiniteField o) const {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) const {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) const {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) const {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  vector<Int2D> ps;\n  for (int i = 0; i < n; i++) {\n    int64 x, y;\n    cin >> x >> y;\n    ps.emplace_back(x, y);\n  }\n\n  FiniteField r = 0;\n  r += 1;\n  r += n;\n\n  set<pair<int, int>> visited;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (visited.find(make_pair(i, j)) != visited.end()) {\n        continue;\n      }\n\n      vector<int> vs({i, j});\n      for (int k = j + 1; k < n; k++) {\n        if (Colinear(ps[i], ps[j], ps[k])) {\n          vs.push_back(k);\n        }\n      }\n\n      int m = vs.size();\n      FiniteField s = 1;\n      for (int k = 0; k < m; k++) s *= 2;\n      s -= 1;\n      s -= m;\n\n      r += s;\n\n      for (int i1 = 0; i1 < vs.size(); i1++) {\n        for (int i2 = i1 + 1; i2 < vs.size(); i2++) {\n          visited.insert(make_pair(vs[i1], vs[i2]));\n        }\n      }\n    }\n  }\n\n  FiniteField ans = 1;\n  for (int i = 0; i < n; i++) ans *= 2;\n  ans -= r;\n  // cout << r.Value() << endl;\n  cout << ans.Value() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int MaxN = 200;\nconst int M = 998244353;\n\nint n;\nint prePow[MaxN + 1];\n\nstruct point\n{\n\tint x, y;\n\tpoint() {}\n\tpoint(const int &_x, const int &_y)\n\t\t: x(_x), y(_y) {}\n\n\tfriend inline point operator-(const point &lhs, const point &rhs)\n\t{\n\t\treturn point(lhs.x - rhs.x, lhs.y - rhs.y);\n\t}\n\n\tfriend inline int operator*(const point &lhs, const point &rhs)\n\t{\n\t\treturn lhs.x * rhs.y - lhs.y * rhs.x;\n\t}\n};\npoint po[MaxN + 1];\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcin >> po[i].x >> po[i].y;\n\n\tprePow[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tprePow[i] = prePow[i - 1] * 2 % M;\n\n\tint res = (prePow[n] - n - 1 + M) % M;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t{\n\t\t\tint num = 0;\n\t\t\tfor (int k = j + 1; k <= n; ++k)\n\t\t\t\tnum += (po[k] - po[i]) * (po[j] - po[i]) == 0;\n\n\t\t\tres = (res + M - prePow[num]) % M;\n\t\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nbool on_the_line(pll &a, pll &b, pll &c){\n    return ((a.first - c.first)*(b.second-c.second)-(a.second-c.second)*(b.first-c.first)==0);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    pll points[N];\n    REP(i, N){\n        cin >> points[i].first >> points[i].second;\n    }\n    int did[N][N] = {};\n\n    ll pow2[N+2];\n    pow2[0] = 1;\n    for(int i=1;i<N+2;i++){\n        pow2[i] = (2*pow2[i-1])%mod;\n    }\n\n    ll res = pow2[N];\n    res = (res+mod-1)%mod;\n    res = (res+mod-N)%mod;\n\n    for(int i=0;i<N;i++){\n        for (int j=i+1;j<N;j++){\n            if(did[i][j]==0){\n                vector<int> tmp;\n                tmp.push_back(i);\n                tmp.push_back(j);\n                for(int k=0;k<N;k++){\n                    if(k!=i && k!=j && on_the_line(points[i], points[j], points[k])){\n                        tmp.push_back(k);\n                    }\n                }\n                REP(p, tmp.size()) REP(q, tmp.size()) did[p][q] = 1;\n                int s = tmp.size();\n                res = (res+mod-pow2[s]+1+s)%mod;\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(int i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pii pair<int,int>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\nll int MOD=998244353;\n#define INF (ll)1e16\n#define N 310000\n \nusing namespace std;\nstring alphabet(\"abcdefghijklmnopqrstuvwxyz\");\n\nll int power(int a,int b){\n    ll int ans=1;\n    rep(i,b){\n        ans*=a;\n        ans%=MOD;\n    }\n    return ans;\n}\nmain(){\n    int n;\n    cin>>n;\n    int a[300][2];\n    rep(i,n){\n        cin>>a[i][0]>>a[i][1];\n    }\n    ll int ans=0;\n    rep(i,n-1){\n        rep2(j,i+1,n){\n            int count=2;\n            bool flag=false;\n            int x1=a[i][0],x2=a[j][0],y1=a[i][1],y2=a[j][1];\n            rep(k,n){\n                if(k==i||k==j)continue;\n                if(y1*(x2-x1)+(y2-y1)*(a[k][0]-x1)==a[k][1]*(x2-x1)){\n                    if(k<j) flag=true;\n                    else count++;\n                }\n            }\n            if(flag)continue;\n            ans-=(power(2,count)-count*(count-1)/2-count-1);\n            ans%=MOD;\n        }\n    }\n    ans+=(power(2,n)-n*(n-1)/2-n-1);\n    ans%=MOD;\n    cout<<ans;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first setprecision\n\n#if MYDEBUG\n#include \"lib/cp_debug.h\"\n#else\n#define DBG(...) ;\n#endif\n\nusing LL = long long;\nconstexpr LL LINF=334ll<<53;\nconstexpr int INF=15<<26;\nconstexpr LL  MOD=998244353;\n\nstruct Problem{\n    int n;\n    vector<LL> x,y,c;\n    vector<vector<LL>> dp;\n    Problem(LL n):n(n),x(n),y(n),c(n+1),dp (n+1,vector<LL>(n+1)){};\n\n    void solve(){\n        dp[0][0]=1;\n        for(LL i=0; i<=n; ++i){\n            dp[0][i]=1;\n            dp[i][0]=1;\n        }\n        for(LL i=1; i<=n; ++i){\n            for(LL j=1; j<=n; ++j){\n                dp[i][j]=(dp[i][j-1]+dp[i-1][j])%MOD;\n            }\n        }\n        //nCk = dp[n-k][k]\n        for(LL i=0; i<n; ++i){\n            cin >> x[i] >> y[i];\n        }\n        vector<LL> sum(n+1);\n        for(int i=3; i<=n; ++i){\n            for(int j=3; j<=min(i,n); ++j){\n                sum[i]+=dp[i-j][j]%MOD;\n            }\n        }\n        LL ans =sum[n];\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                LL tmp =0;\n                for(int k=j+1; k<n; ++k){\n                    bool f =false;\n                    if(x[i]==x[j] and x[i] == x[k])f=true;\n                    else if(y[i]==y[j] and y[i] == y[k])f=true;\n                    else if((x[k]-x[i])*(y[k]-y[j])==(x[k]-x[j])*(y[k]-y[j])) f=true;\n                    if(f)tmp++;\n                }\n                ans = (ans-sum[tmp+2]+MOD)%MOD;\n            }\n        }\n        cout << (ans+MOD)%MOD <<endl;\n    }\n\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    long long n=0;\n    cin >> n;\n    Problem p(n);\n    p.solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=500,mod=998244353;\nstruct point{\n\tint x,y;\n}p[maxn];\nint n;\nlong long po[maxn],ans;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tpo[0]=1;for(int i=1;i<=n;i++){po[i]=po[i-1]*2%mod;}\n\tfor(int i=1;i<=n;i++){scanf(\"%d%d\",&p[i].x,&p[i].y);}\n\tans=po[n]-n-1;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint cnt=0;\n\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\tif((p[i].x-p[k].x)*(p[j].y-p[k].y)==(p[j].x-p[k].x)*(p[i].y-p[k].y)){cnt++;}\n\t\t\t}\n\t\t\tans=(ans-po[cnt]+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=205;\nconst int MOD=998244353;\n\nstruct point\n{\n    int x,y;\n    point(int _x=0,int _y=0):x(_x),y(_y){}\n}p[MAXN];\n\npoint operator - (const point& a,const point& b)\n{\n    return point(a.x-b.x,a.y-b.y);\n}\n\nint cross(const point& a,const point& b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n\nint dot(const point& a,const point& b)\n{\n    return a.x*b.x+a.y*b.y;\n}\n\nLL Q_pow(LL x,LL n)\n{\n    LL res=1;\n    while(n>0)\n    {\n        if(n&1) res=res*x%MOD;\n        x=x*x%MOD;\n        n>>=1;\n    }\n    return res;\n}\n\nint main()\n{\n    int n;\n    while(scanf(\"%lld\",&n)!=EOF)\n    {\n        for(int i=1;i<=n;i++)\n            scanf(\"%d%d\",&p[i].x,&p[i].y);\n        LL ans=Q_pow(2,n);\n        ans=(ans-1+MOD)%MOD;\n        ans=(ans-n+MOD)%MOD;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=i+1;j<=n;j++)\n            {\n                LL cnt=0;\n                for(int k=1;k<=n;k++)\n                {\n                    if(cross(p[k]-p[i],p[k]-p[j])==0&&dot(p[k]-p[i],p[k]-p[j])<0)\n                        ++cnt;\n                }\n                ans=(ans-Q_pow(2,cnt)+MOD)%MOD;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define MOD 998244353\n\nLL powmod(LL a, LL n){\n\tif(n == 0) return 1;\n\tif(n % 2) return (a * powmod(a, n-1)) % MOD;\n\tLL c = powmod(a, n/2);\n\treturn (c*c) % MOD;\n}\n\nstruct UF{\n\tint n;\n\tvector<int> par;\n\tUF(int n) : n(n) {\n\t\tfor(int i = 0; i < n; i++) par.push_back(i);\n\t}\n\tint find(int a){\n\t\tif(a != par[a]) par[a] = find(par[a]);\n\t\treturn par[a];\n\t}\n\tvoid join(int a, int b){\n\t\tpar[find(a)] = find(b);\n\t}\n};\n\n\nint main(){\n\tLL n = 0;\n\tcin >> n;\n\tpair<LL,LL> d[n];\n\tfor(LL i = 0; i < n; i++){\n\t\tcin >> d[i].first >> d[i].second;\n\t}\n\tLL ans = powmod(2, n);\n\t//ans -= 1;\n\t//ans -= n;\n\tmap<pair<LL,LL>, LL> f;\n\tfor(LL i = 0; i < n; i++){\n\t\tfor(LL j = 0; j < i; j++){\n\t\t\tLL a1 = d[i].first - d[j].first;\n\t\t\tLL a2 = d[i].second - d[j].second;\n\t\t\tLL gc = __gcd(a1,a2);\n\t\t\ta1 /= gc; a2 /=gc;\n\t\t\tif(a1 < 0 || (a1 == 0 && a2 < 0)){\n\t\t\t\ta1 = -a1; a2 = -a2;\n\t\t\t}\n\t\t\tf[make_pair(a1,a2)] = 1;\n\t\t}\n\t}\n\tfor(auto it = f.begin(); it != f.end(); it++){\n\t\tpair<LL,LL> s = it->first;\n\t\tUF r(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tLL a1 = d[i].first - d[j].first;\n\t\t\t\tLL a2 = d[i].second - d[j].second;\n\t\t\t\tLL f = __gcd(a1,a2);\n\t\t\t\ta1 /= f; a2 /=f;\n\t\t\t\tif(a1 < 0 || (a1 == 0 && a2 < 0)){\n\t\t\t\t\ta1 = -a1; a2 = -a2;\n\t\t\t\t}\n\t\t\t\tif(make_pair(a1,a2) == s){\n\t\t\t\t\tr.join(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLL freq[n];\n\t\tfor(int i = 0; i < n; i++) freq[i] = 0;\n\t\tfor(int i = 0; i < n; i++) freq[r.find(i)]++;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tLL gg = freq[i];\n\t\t\tans -= powmod(2, gg);\n\t\t\tans += gg;\n\t\t\tans += 1;\n\t\t}\n\t}\n\tans -= n;\n\tans -= 1;\n\tans %= MOD;\n\twhile(ans < 0) ans += MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nbool on_the_line(pii &a, pii &b, pii &c){\n    return ((a.first - c.first)*(b.second-c.second)-(a.second-c.second)*(b.first-c.first)==0);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    pii points[N];\n    REP(i, N){\n        cin >> points[i].first >> points[i].second;\n    }\n    int did[N][N] = {};\n\n    ll pow2[N+2];\n    pow2[0] = 1;\n    for(int i=1;i<N+2;i++){\n        pow2[i] = (2*pow2[i-1])%mod;\n    }\n\n    ll res = pow2[N];\n    res = (res+mod-1)%mod;\n    res = (res+mod-N)%mod;\n\n    for(int i=0;i<N;i++){\n        for (int j=i+1;j<N;j++){\n            if(did[i][j]==0){\n                vector<int> tmp;\n                tmp.push_back(i);\n                tmp.push_back(j);\n                for(int k=j+1;k<N;k++){\n                    if(on_the_line(points[i], points[j], points[k])){\n                        tmp.push_back(k);\n                    }\n                }\n                REP(i, tmp.size()) REP(j, tmp.size()) did[i][j] = 1;\n                int s = tmp.size();\n                res = (res+mod-(pow2[s]-1-s))%mod;\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\nconstexpr i64 MOD = 998244353;\n\ni64 modpow(i64 a, i64 n, i64 mod) {\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        i64 t = modpow(a, n / 2, mod);\n        return t * t % mod;\n    }\n    return a * modpow(a, n - 1, mod) % mod;\n}\n\nstruct Point {\n    int x, y;\n};\n\nstruct Line {\n    int x, y;\n    int dx, dy;\n\n    bool operator==(const Line rhs) const {\n        if (dx * rhs.dy != dy * rhs.dx) {\n            return false;\n        }\n        return (x - rhs.x) * dy == (y - rhs.y) * dx;\n    }\n};\n\nLine make_line(Point a, Point b) {\n    return {a.x, a.y, b.x - a.x, b.y - a.y};\n}\n\nint main() {\n    int n;\n    cin >> n;\n    i64 ans = modpow(2, n, MOD) - 1 - n - n * (n - 1) / 2;\n    vector<Point> ps;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        ps.push_back({x, y});\n    }\n\n    vector<Line> ls;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int ok = 1;\n            Line line = make_line(ps[i], ps[j]);\n            for (Line& l: ls) {\n                if (l == line) {\n                    ok = 0;\n                    break;\n                }\n            }\n            if (ok) {\n                int cnt = 0;\n                for (int k = 0; k < n; k++) {\n                    if (k == i || k == j) continue;\n                    if (line == make_line(ps[i], ps[k])) {\n                        cnt++;\n                    }\n                }\n                ls.emplace_back(line);\n                // cout << cnt << endl;\n                if (cnt > 0) {\n                    cnt += 2;\n                    ans -= modpow(2, cnt, MOD) - 1 - cnt - cnt * (cnt - 1) / 2; \n                    ans %= MOD;\n                }\n            }\n        }\n    }\n\n    cout << (ans % MOD + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#if defined(LOCAL)\n#define PROBLEM_NAME \"c\"\nconst double _max_double_error = 1e-9;\n#include \"testutils.h\"\n#define L(x...) debug(x)\n#else\n#define L(x...) (x)\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ii = pair<int,int>; using vii = vector<ii>;\nusing l = long long; using vl = vector<l>; using vvl = vector<vl>;\nusing ll = pair<l,l>; using vll = vector<ll>; using vvll = vector<vll>;\nusing lu = unsigned long long;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vd = vector<double>; using vvd = vector<vd>;\nusing mll = unordered_map<l, l>;\nconst l INF = numeric_limits<l>::max();\nconst double EPS = 1e-10; static constexpr auto PI = acos(-1);\nconst l e0=1, e3=1000, e5=100000, e6=10*e5, e7=10*e6, e8=10*e7, e9=10*e8;\nconst char lf = '\\n';\n#define all(x) begin(x), end(x)\n#define F(a,b,c) for (l a = l(b); a < l(c); a++)\n#define B(a,b,c) for (l a = l(c) - 1; a >= l(b); a--)\n\nl gcd(l a, l b) {\n  while (b) { l t = b; b = a % b; a = t; }\n  return a;\n}\n\nl lcm(l a, l b) { return a * b / gcd(a, b); }\n\n// a / b\nstruct Rat {\n  l a, b;\n  bool operator < (Rat const& rhs) const {\n    if (rhs.b * a == 0 and rhs.a * b == 0) {\n      if (a == 0) return b < rhs.b;\n      return a < rhs.a;\n    }\n    return a * rhs.b < rhs.a * b;\n  }\n\n  void set(l na, l nb) {\n    a = na; b = nb;\n    normalize();\n  }\n\n  void set(l na) {\n    set(na, 1);\n  }\n\n  void normalize() {\n    if (b < 0 and a != 0) {\n      a = -a;\n      b = -b;\n    }\n    l g = gcd(abs(a), abs(b));\n    assert(g);\n    a /= g;\n    b /= g;\n  }\n};\n\nostream& operator << (ostream& s, const Rat& p) {\n  s << p.a << \" / \" << p.b;\n  return s;\n}\n\nstruct Line {\n  Rat x0, d;\n\n  bool operator < (Line const& rhs) const {\n    if (x0 < rhs.x0) return true;\n    if (rhs.x0 < x0) return false;\n    return d < rhs.d;\n  }\n};\n\nl const MOD = 998244353;\n\nl sign(l n) {\n  if (n < 0) return -1;\n  if (n == 0) return 0;\n  return 1;\n}\n\n// conruent modulo, works for negative\nl cong(l x, l mod) {\n  return (x % mod + mod) % mod;\n}\n\n// (a * b) % mod, safe for l near max\nl mult_mod(l a, l b, l mod) {\n  l x = 0;\n  while (b) {\n    if (b % 2) x = (x + a) % mod;\n    a = (a * 2) % mod;\n    b /= 2;\n  }\n  return x;\n}\n\n// (base^power) % mod, safe for l near max\nl pow_mod(l base, l power, l mod) {\n  l r = 1;\n  while (power) {\n    if (power % 2) r = mult_mod(r, base, mod);\n    base = mult_mod(base, base, mod);\n    power /= 2;\n  }\n  return r;\n}\n\nl divup(l a, l b) { // ceil div\n  return (a + b - 1) / b;\n}\n\n// return gcd(a, b) and set x, y: a * x + b * y = gcd(a, b)\nl extended_euclid(l a, l b, l& x, l& y) {\n  if (b == 0) { x = 1; y = 0; return a; }\n  l d = extended_euclid(b, a % b, x, y);\n  l t = y;\n  y = x - (a / b) * y;\n  x = t;\n  return d;\n}\n\n// return b: a * b = 1 (mod n)\nl inverse_mod(l a, l n) {\n  l x, y;\n  l d = extended_euclid(a, n, x, y);\n  if (d != 1) return 0;\n  return cong(x, n);\n}\n\n// single combintions k from n\nl nCr(l n, l k, l mod) {\n  l a = 1;\n  for (l i = n; i > n - k; i--) a = mult_mod(a, i, mod);\n  l b = 1;\n  F(i, 1, k + 1) b = mult_mod(b, i, mod);\n  b = inverse_mod(b, mod);\n  return mult_mod(a, b, mod);\n}\n\n// precompute all combinations up to (n n)\nvvl combinations(l n, l mod) {\n  vvl c(n + 1, vl(n + 1));\n  F(i, 0, n) {\n    c[i][0] = 1;\n    F(j, 1, i + 1) {\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n    }\n  }\n  return c;\n}\n\n\nl set2(l n) {\n  return cong(pow_mod(2, n, MOD) - n - 1, MOD);\n}\n\nvoid solve(istream& cin, ostream& cout) {\n  l n; cin >> n;\n  vl x(n), y(n);\n  F(i, 0, n) cin >> x[i] >> y[i];\n  map<Line, l> m;\n  F(i, 0, n) F(j, i + 1, n) {\n    Line q;\n    q.d.set(y[j] - y[i], x[j] - x[i]);\n    if (q.d.b == 0) q.d.a = 1;\n    if (y[i] == y[j]) {\n      q.x0.set(y[i]);\n      q.d.set(-1, 0);\n    } else {\n      q.x0.set(x[i] * (y[j] - y[i]) - y[i] * (x[j] - x[i]), y[j] - y[i]);\n    }\n    // cerr << q.x0 << ' ' << q.d << endl;\n    m[q]++;\n  }\n  l answer = set2(n);\n  for (auto p : m) {\n    l t = p.second;\n    t = round(sqrt(8 * t + 1) + 1) / 2;\n    // cerr << p.second << ' ' << t << endl;\n    answer = cong(answer - set2(t), MOD);\n  }\n  cout << answer << lf;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout << fixed << setprecision(15);\n#if defined(LOCAL)\n  // _generate_random_test = generate_random;\n  // _solve_brute = solve_brute;\n  // _player_b = player_b;\n  // _custom_solution_checker = solution_checker;\n  maybe_run_tests(cin, cout);\n#else\n  solve(cin, cout);\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst int MAXN = 100500;\n\nstruct Point \n{\n\tint x, y;\n\n\tPoint () {}\n\n\tPoint (int _x, int _y): x(_x), y(_y) {}\n\n\tvoid Scan()\n\t{\n\t\tcin >> x >> y;\n\t}\n\n\tPoint operator-(Point b)\n\t{\n\t\treturn Point(x - b.x, y - b.y);\n\t}\n\n\tPoint operator+(Point b)\n\t{\n\t\treturn Point(x + b.x, y + b.y);\n\t}\n\n\tint operator%(Point b)\n\t{\n\t\treturn x * b.x + y * b.y;\n\t}\n\n\tint operator*(Point b)\n\t{\n\t\treturn x * b.y - y * b.x;\n\t}\n};\n\nPoint pt[MAXN];\nint n;\nint cnt[MAXN];\n\nll sum(ll a, ll b)\n{\n\treturn (a + b) % MOD;\n}\n\nll sub(ll a, ll b)\n{\n\treturn (a - b + MOD) % MOD;\n}\n\nll mul(ll a, ll b)\n{\n\treturn a * b % MOD;\n}\n\nlong long bin_pow(ll a, ll n)\n{\n\tll res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = mul(res, a);\n\t\ta = mul(a, a);\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\nint main()\n{                                                     \n\tios_base::sync_with_stdio(0);\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t\tpt[i].Scan();\n\t\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tint count = 0;\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif ((pt[i] - pt[j]) * (pt[i] - pt[k]) == 0)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tcnt[count]++;\n\t\t\t}\n\t\t}\n\n\n\tassert(cnt[0] == 0 && cnt[1] == 0);\n\n\n\tlong long dif = 1 + n;\n\t\n\tfor (int i = 2; i <= n; i++)\n\t{\n\t\tint kek = i * (i - 1);\n\t\tassert(cnt[i] % kek == 0);\n\t\tcnt[i] /= kek;\n\n\t\tdif = sum(dif, mul(cnt[i],sub(bin_pow(2, i), i + 1)));\n\t}\n\n\tlong long ans = sub(bin_pow(2, n), dif);\n\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n \n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\nconst int MOD = 998244353;\nconst int INF = INT_MAX / 2;\nstruct edge { int v, w; };\n\nconst double EPS = 1e-8;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n \nint main() {\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\trep(i, N) cin >> x[i] >> y[i];\n\tint ans = 1;\n\trep(t, N) ans = ans * 2 % MOD;\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\tL l({x[i],y[i]},{x[j],y[j]});\n\t\tint n = 0;\n\t\trep(k, N) if (k != i && k != j) {\n\t\t\t/*double d1 = d(x[k], y[k], x[i], y[i]);\n\t\t\tdouble d2 = d(x[k], y[k], x[j], y[j]);\n\t\t\tdouble d3 = d(x[i], y[i], x[j], y[j]);\n\t\t\tif (abs(d1 + d2 - d3) < 1e-12)*/\n\t\t\tif(intersectSP(l,{x[k],y[k]})) n++;\n\t\t}\n\t\tint x = 1;\n\t\trep(t, n) x = x * 2 % MOD;\n\t\tans = (ans - x) % MOD;\n\t}\n\tans = (ans - N - 1) % MOD;\n\tcout << (ans + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MMOD 998244353\n#define MAX 2010101\nusing namespace std;\nusing Edge=pair<ll,ll>;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint n,d,ans,x[210],y[210],p[210];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint M=998244353;\n\tp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tp[i]=1ll*p[i-1]*2%M;\n\t}\n\tans=p[n]-n-1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\td=0;\n\t\t\tfor(int k=j+1;k<=n;k++)d+=(y[i]-y[j])*(x[i]-x[k])==(y[i]-y[k])*(x[i]-x[j]);\n\t\t\tans=(ans+M-p[d])%M;\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n  \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define mod 998244353\nusing namespace std;\nint x[500],y[500],k[500];\nint ans,n;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\tk[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tk[i]=(k[i-1]<<1)%mod;\n\tans=k[n]-1-n;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tint num=0;\n\t\t\tfor(int ki=1;ki<j;ki++)\n\t\t\t\tif((x[i]-x[j])*(y[i]-y[ki])==(x[i]-x[ki])*(y[i]-y[j])) num++;\n\t\t\tans=(ans-k[num]+mod)%mod;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-12;\ntypedef complex<long double> P;\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectSP(const L &s, const P &p) {\n  return absl(s[0]-p)+absl(s[1]-p)-absl(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nlong long pow_binary_mod(long long x,long long y,long long M){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%M;\n\t\tx=x*x%M;\n\t}\n\treturn z;\n}\n\nint main(){\n\tint M=998244353;\n\tint N,x,y;\n\tscanf(\"%d\",&N);\n\tvector<P>v(N);\n\tint r=pow_binary_mod(2,N,M);\n\tset<L>se;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&x,&y),v[i]={(double)x,(double)y};\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++){\n\t\t//if(se.find({i,j})!=se.end())continue;\n\t\tL l(v[i],v[j]);\n\t\tvector<int>x={i,j};\n\t\tfor(int k=0;k<N;k++)if(k!=i&&k!=j&&intersectSP(l,v[k]))x.push_back(k);\n\t\tr=(r-pow_binary_mod(2,x.size()-2,M))%M;\n\t\tfor(int a=0;a<x.size();a++)for(int b=a+1;b<x.size();b++){\n\t\t\t//se.emplace(x[a],x[b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",((r-N-1)%M+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: CNYALI_LK\nLANG: C++\nPROG: E.cpp\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconst double eps=1e-8;\nconst double PI=acos(-1.0);\ntypedef long long ll;\ntemplate<class T>void chkmin(T &a,T b){a=a<b?a:b;}\ntemplate<class T>void chkmax(T &a,T b){a=a>b?a:b;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\n#define min mmin\n#define max mmax\n#define abs aabs\nconst ll mod=998244353;\nll p[233];\nstruct zb{\n\tll x,y;\n};\nzb a[233];\nll cmp(zb a,zb b){return a.x<b.x||a.x==b.x&&a.y<b.y;}\nint main(){\n#ifdef cnyali_lk\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n\tll n,ans;\n\tscanf(\"%lld\",&n);\n\tp[0]=1;\n\tfor(ll i=1;i<=n;++i){p[i]=p[i-1]<<1;if(p[i]>=mod)p[i]-=mod;scanf(\"%lld%lld\",&a[i].x,&a[i].y);}\n\tsort(a+1,a+n+1,cmp);\n\tans=p[n]-n-1;\n\tfor(ll i=1;i<=n;++i)for(ll j=i+1;j<=n;++j){\n\t\tll no=0;\n\t\tfor(ll k=1;k<j;++k)if(k!=i&&(a[j].x-a[i].x)*(a[i].y-a[k].y)==(a[j].y-a[i].y)*(a[i].x-a[k].x)){no=1;break;}\n\t\tif(!no){\n//\t\t\tdebug(\"(%lld,%lld) (%lld,%lld)\",a[i].x,a[i].y,a[j].x,a[j].y);\n\t\t\tll tot=2;\n\t\t\tfor(ll k=j+1;k<=n;++k){\n\t\t\t\tif((a[j].x-a[i].x)*(a[i].y-a[k].y)==(a[j].y-a[i].y)*(a[i].x-a[k].x)){++tot;/*debug(\" (%lld,%lld)\",a[k].x,a[k].y);*/}\n\t\t\t}\n\t\t\t//debug(\"\\n\");\n\t\t\tans-=p[tot]-tot-1;\n\t\t}\n\t}\t\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1005,INF=1<<30;\nconst double eps=0.000000003;\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    int N;cin>>N;\n    vector<double> X(N),Y(N);\n    for(int i=0;i<N;i++){\n        cin>>X[i]>>Y[i];\n    }\n    \n    ll ans=rui(2,N);\n    ans+=mod-(N+1);\n    ans%=mod;\n    \n    for(int a=0;a<N;a++){\n        for(int b=a+1;b<N;b++){\n            ll cnt=0;\n            for(int k=0;k<N;k++){\n                if(k==a||k==b) continue;\n                double i=atan2(X[b]-X[k],Y[b]-Y[k]),j=atan2(X[a]-X[k],Y[a]-Y[k]);\n                if(i>=0&&j<0) swap(i,j);\n                if(i*j<=0){\n                    if(abs(abs(i)-j)<eps) cnt++;\n                }\n            }\n            ans+=mod-rui(2,cnt);\n            ans%=mod;\n        }\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int mo=998244353;\nint ksm(int a,int b){\n  int ans=1;\n  while (b){\n\tif (b&1) ans=1ll*ans*a%mo;\n\tb>>=1;a=1ll*a*a%mo;\n  }\n  return ans;\n}\nstruct point {\n  int x,y;\n  point operator-(const point &a){\n   return (point){x-a.x,y-a.y};\n  }\n  bool operator==(const point &a){\n    return x==a.x && y==a.y;\n  }\n};\n\nint cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nvoid add(int &x,int y){\n  x+=y;\n  if (x>=mo) x-=mo;\n  if (x<0) x+=mo;\n}\n\nint dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\nbool cmp(point a,point b){\n   if (a.x==0 && b.x==0) return a.y<b.y;\n   if (a.x==0) return 0;\n   if (b.x==0) return 1;\n   if (cross(a,b)==0) {\n\t if (a.x*b.x<0) return a.x<b.x;\n\t else return dot(a,a)<dot(b,b);\n   }\n   if (a.x<0) {a.x*=-1;a.y*=-1;}\n   if (b.y<0) {b.x*=-1;b.y*=-1;}\n   return cross(a,b)>0;\n}\npoint p[210],t[210];\nint main()\n{\n    int i,j;\n    int n;\n    cin>>n;\n    for (i=1;i<=n;i++) scanf(\"%d %d\",&p[i].x,&p[i].y);\n    int ans=ksm(2,n);\n    add(ans,-1-n);\n    int cnt;\n    for (i=1;i<=n;i++){\n      cnt=0;\n      for (j=1;j<=n;j++){\n        if (j==i) continue;\n        t[cnt++]=p[j]-p[i];\n      }\n      sort(t,t+cnt,cmp);\n      int last=0;\n      for (j=1;j<cnt;j++){\n\t\tif (cross(t[j-1],t[j])){\n\t\t\tif (t[last].x<0 || (t[last].x==0 && t[last].y<0)) {last=j;continue;}\n\t\t\tadd(ans,-(ksm(2,j-last+1)-(j-last+1)-1));\n\t\t\tlast=j;\n\t\t}\n      }\n      if (cnt && !(t[last].x<0 || (t[last].x==0 && t[last].y<0))){\n\t\tadd(ans,-(ksm(2,j-last+1)-(j-last+1)-1));\n      }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst ll MAX=204;\nconst ll MOD=998244353;\npll pt[MAX];\nll chk[MAX][MAX],ans,n;\nvector<int> tmp;\nll power(ll x,ll y){\n    if(y==0) return 1;\n    ll t=power(x,y/2);\n    if(y%2) return t*t%MOD*x%MOD;\n    return t*t%MOD;\n}\nll func(ll x){\n    return (power(2,x)-x*(x-1)/2-x-1+MOD)%MOD;\n}\nmain(){\n    scanf(\"%lld\",&n);\n    ans=func(n);\n    for(ll i=0;i<n;i++) scanf(\"%lld%lld\",&pt[i].x,&pt[i].y);\n    for(ll i=0;i<n;i++) for(ll j=i+1;j<n;j++) if(chk[i][j]==0){\n        ll cnt=2;\n        tmp.push_back(i),tmp.push_back(j);\n        for(ll k=j+1;k<n;k++) if((pt[k].x-pt[j].x)*(pt[j].y-pt[i].y)==(pt[k].y-pt[j].y)*(pt[j].x-pt[i].x)){\n            tmp.push_back(k);\n        }\n        for(ll k=0;k<tmp.size();k++) for(ll l=0;l<tmp.size();l++) chk[tmp[k]][tmp[l]]=1;\n        if(tmp.size()>=3) ans+=MOD-func(tmp.size()),ans%=MOD;\n        tmp.clear();\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nint x[210],y[210];\nconst ll mod = 1000000007LL;\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\tif(n<=2){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\n\n\tll ans = 1LL;\n\trep(loop,n) ans = 2LL * ans % mod;\n\t\n\trep(j,n)rep(i,j){\n\t\tvector<int> ary;\n\t\trep(k,n){\n\t\t\tll det = (x[k]-x[i])*(y[j]-y[i]) - (x[j]-x[i])*(y[k]-y[i]);\n\t\t\tif(det == 0) ary.push_back(k);\n\t\t}\n\n\t\tsort(begin(ary),end(ary));\n\t\tif(ary[0]!=i or ary[1]!=j) continue;\n\n\t\tll minus = 1LL;\n\t\trep(loop,ary.size()) minus = 2LL * minus % mod;\n\t\tminus = (minus + mod - ary.size() -1 ) % mod;\n\t\tans = (ans + mod - minus) % mod;\n\t}\n\n\tans = (ans + mod - n - 1) % mod;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nint main()\n{\n  int fact[501];\n  fact[0] = 1;\n  for(int i = 1; i < 501; i++) (fact[i] = fact[i - 1] * 2) %= mod;\n\n  int N, X[500], Y[500];\n  cin >> N;\n  for(int i = 0; i < N; i++) cin >> X[i] >> Y[i];\n\n  int ret = fact[N];\n\n  for(int i = 0; i < N; i++) {\n    for(int j = i + 1; j < N; j++) {\n      int sum = 0;\n      for(int k = j + 1; k < N; k++) {\n        sum += (X[j] - X[i]) * (Y[k] - Y[i]) == (X[k] - X[i]) * (Y[j] - Y[i]);\n      }\n      (ret += mod - fact[sum]) %= mod;\n    }\n  }\n\n  (ret += mod - 1) %= mod;\n  (ret += mod - N) %= mod;\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) > 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<point> ns;\n        for (int j = 0; j < n; j++) {\n            if (j == i) {\n                continue;\n            }\n            if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {\n                need[j] = true;\n                ns.push_back(p[j]);\n            } else {\n                need[j] = false;\n            }\n        }\n        cur = p[i];\n        sort(all(ns), comp);\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                goods[j][k] = false;\n                cnt[j][k] = 0;\n                dp[j][k] = 0;\n                if (good(p[i], ns[j], ns[k])) {\n                    goods[j][k] = true;\n                    for (int g = 0; g < sz(ns); g++) {\n                        if (g == j || g == k) {\n                            continue;\n                        }\n                        if (inside(p[i], ns[j], ns[k], ns[g])) {\n                            cnt[j][k]++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (goods[j][k]) {\n                    dp[j][k] += st[cnt[j][k]];\n                    dp[j][k] %= Mod;\n                    ans += dp[j][k];\n                    ans %= Mod;\n                    for (int nxt = k + 1; nxt < sz(ns); nxt++) {\n                        if (vec(ns[nxt] - ns[j], ns[k] - ns[j]) < 0 && goods[k][nxt]) {\n                            dp[k][nxt] += dp[j][k];\n                            if (dp[k][nxt] >= Mod) {\n                                dp[k][nxt] %= Mod;\n                            }\n                        }\n                    }\n                }   \n            }\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nconst int p=998244353;\nint n,x[210],y[210],pow2[210],ans;\nbool flag[210][210];\nstruct data\n{\n    int id;\n    double agl;\n    bool operator<(const data &t) const\n    {\n        return agl<t.agl;\n    }\n} a[210];\n\ndouble get(int y,int x)\n{\n    if (y<0 || !y && x<0)\n        return atan2(-y,-x);\n    return atan2(y,x);\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    repu(i,1,n)\n        scanf(\"%d%d\",&x[i],&y[i]);\n    pow2[0]=1;\n    repu(i,1,n)\n        pow2[i]=pow2[i-1]*2%p;\n    ans=(pow2[n]+p-n-1)%p;\n    repu(i,1,n)\n    {\n        int m=0;\n        repu(j,i+1,n)\n            a[++m]=(data){j,get(y[j]-y[i],x[j]-x[i])};\n        sort(a+1,a+1+m);\n        for (int j=1,k; j<=m; j=k)\n        {\n            for (k=j+1; k<=m && a[k].agl==a[j].agl; ++k);\n            if (!flag[i][a[j].id])\n            {\n                (ans+=p-pow2[k-j+1]+k-j+2)%=p;\n                repu(ii,j,k-1)\n                {\n                    flag[i][a[ii].id]=flag[a[ii].id][i]=1;\n                    repu(jj,ii+1,k-1)\n                        flag[a[ii].id][a[jj].id]=flag[a[jj].id][a[ii].id]=1;\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <limits>\n#include <set>\n#define REP(i,n) for(long (i)=0;(i)<(n);(i)++)\n#define REPI(i,a,b) for(long (i)=(a);(i)<(b);(i)++)\n#define INF numeric_limits<double>::infinity()\nconstexpr long MOD = 998244353;\nconstexpr double eps = 1e-10;\nusing namespace std;\nusing P = pair<double, double>;\nusing VI = vector<long>;\n\nP line(P a, P b) {\n    double grad = (a.second - b.second) / (a.first - b.first + eps);\n    if (abs(grad) > 1e8) {\n        return P(INF, a.first);\n    } else if (abs(grad) < 1e-8) {\n        return P(0, a.second);\n    }\n    return P(grad, a.second - grad * a.first);\n}\n\nbool onLine(P line, P p) {\n    if (line.first == INF) {\n        return line.second == p.first;\n    } else if (line.first == 0) {\n        return line.second == p.second;\n    }\n    return abs(line.first * p.first + line.second - p.second) < 1e-8;\n}\n\nlong powmod(long a, long n) {\n    if (n == 0) return 1l;\n    if (n % 2 == 0) {\n        long d = powmod(a, n / 2);\n        return d * d % MOD;\n    }\n    return a * powmod(a, n - 1) % MOD;\n}\n\nint main() {\n    long n;\n    cin >> n;\n    vector<P> v;\n    REP(i,n) {\n        long x, y;\n        cin >> x >> y;\n        v.push_back(P(x,y));\n    }\n    \n    long ans = powmod(2, n);\n    ans = ans - 1 - n - n * (n - 1) / 2;\n    \n    set<P> lines;\n    \n    REP(i,n) {\n        long cnt = 2;\n        REPI(j,i+1,n) {\n            P l = line(v[i], v[j]);\n            if (lines.find(l) == lines.end()) {\n                lines.insert(l);\n                REPI(k,j+1,n) {\n                    if (onLine(l, v[k])) cnt++;\n                }\n            }\n        }\n        if (cnt > 2) {\n            ans -= powmod(2, cnt) - 1 - cnt - cnt * (cnt - 1) / 2;\n        }\n    }\n    cout << (ans + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nconst double eps = 1e-10;\nconst double inf = 1e+10;\nconst double pi = acos(-1.0);\nint sgn(double a) { return a < -eps ? -1 : a > eps; }\nusing P = complex<double>;\nnamespace std {\n  istream& operator>>(istream& i, P& p) { double x, y; i >> x >> y; p = P(x, y); return i; }\n  ostream& operator<<(ostream& o, const P& p) { o << real(p) << ' ' << imag(p); return o; }\n  bool operator<(const P& p, const P& q) { return sgn(real(p) - real(q)) ? sgn(real(p) - real(q)) < 0 : sgn(imag(p) - imag(q)) < 0; }\n  bool operator>(const P& p, const P& q) { return q < p; }\n  bool operator<=(const P& p, const P& q) { return !(p > q); }\n  bool operator>=(const P& p, const P& q) { return !(p < q); }\n}\nbool eq(const P& p, const P& q) { return !(p < q) and !(p > q); }\ndouble dot(const P& p, const P& q) { return real(conj(p) * q); }\ndouble cross(const P& p, const P& q) { return imag(conj(p) * q); }\n\nint ccw(P p0, P p1, P p2) {\n  p1 -= p0, p2 -= p0;                         //             (1)\n  if (sgn(cross(p1, p2)) > 0) return 1;       //\n  if (sgn(cross(p1, p2)) < 0) return -1;      // (-2)---p0---(0)---p1---(2)\n  if (sgn(dot(p1, p2) < 0)) return -2;        //\n  if (sgn(norm(p1) - norm(p2)) < 0) return 2; //             (-1)\n  return 0;\n}\n\nbool intLP(const P& p1, const P& p2, const P& p) {\n  return !(ccw(p1, p2, p) & 1);\n}\n\nconst lint mod = 998244353;\ninline lint emod(lint a, lint p = mod) { return (a % p + p) % p; }\ninline lint powm(lint a, lint n, lint p = mod) { return !n ? 1 : powm(a * a % p, n >> 1, p) * (n & 1 ? a : 1) % p; }\ninline lint invm(lint a, lint p = mod) { a %= p; return a == 1 ? 1 : -p / a * invm(p % a) % p; }\n\nV<lint> fact, ifact;\nvoid init_table(int n) {\n  fact.assign(n + 1, 1), ifact.assign(n + 1, 1);\n  for (int i = 2; i < n + 1; i++) fact[i] = i * fact[i - 1] % mod;\n  ifact[n] = invm(fact[n]);\n  for (int i = n; i > 2; i--) ifact[i - 1] = i * ifact[i] % mod;\n}\n\nlint comb(lint n, lint r) {\n  if (n < 0 or r < 0 or r > n) return 0;\n  return fact[n] * ifact[r] % mod * ifact[n - r] % mod;\n}\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  V<P> a(n); for (int i = 0; i < n; i++) cin >> a[i];\n  VV<> ls;\n  for (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) {\n    int c = 0;\n    for (int k = 0; k < n; k++) c += intLP(a[i], a[j], a[k]);\n    if (c >= 3) {\n      V<> l;\n      for (int k = 0; k < n; k++) if (intLP(a[i], a[j], a[k])) l.push_back(k);\n      ls.push_back(l);\n    }\n  }\n  sort(ls.begin(), ls.end()); ls.erase(unique(ls.begin(), ls.end()), ls.end());\n\n  init_table(n);\n  lint res = powm(2, n) - (1 + n + comb(n, 2));\n  for (auto&& l : ls) {\n    int m = l.size();\n    for (int i = 3; i < m + 1; i++) (res -= comb(m, i)) %= mod;\n  }\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 998244353;\nll N;\nvector<pair<ll, ll>> Points;\nmap<tuple<ll, ll, ll>, ll> Count;\nmap<ll, ll> InvNC2;\nvector<ll> Pow;\nll R;\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll pow_multi(ll n) { return (Pow[n] + MOD - n - 1) % MOD; }\nint main() {\n  cin >> N;\n  for (ll i = 0; i < N; ++i) {\n    ll x, y;\n    cin >> x >> y;\n    Points.push_back(make_pair(x, y));\n  }\n  for (ll i = 0; i < N; ++i)\n    for (ll j = i + 1; j < N; ++j) {\n      ll x, y, x2, y2;\n      tie(x, y) = Points[i];\n      tie(x2, y2) = Points[j];\n      ll dx = x2 - x, dy = y2 - y;\n      // line ax+by=c, a+b>=0, a and b are coprime\n      ll a = dy, b = -dx;\n      if (a + b < 0) {\n        a *= -1;\n        b *= -1;\n      }\n      ll g = gcd(abs(a), abs(b));\n      a /= g;\n      b /= g;\n      ll c = a * x + b * y;\n      assert(a + b >= 0 && gcd(abs(a), abs(b) == 1));\n      assert(c == a * x2 + b * y2);\n      ++Count[make_tuple(a, b, c)];\n    }\n  for (ll i = 2; i <= N; ++i) InvNC2[i * (i - 1) / 2] = i;\n  Pow.resize(N + 1);\n  Pow[0] = 1;\n  for (ll i = 1; i <= N; ++i) Pow[i] = 2 * Pow[i - 1] % MOD;\n  R = pow_multi(N);\n  for (const auto &linecount : Count) {\n    ll k = InvNC2[linecount.second];\n    (R += MOD - pow_multi(k)) %= MOD;\n  }\n  cout << R << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define MOD 998244353\nusing namespace std;\npair<int,int> P[205];\ndouble tmp[205];\nint pw2[205];\nint N;\nint rez;\nvoid fix(int &val)\n{\n    if(val<0)val+=MOD;\n    if(val>=MOD)val-=MOD;\n}\nvoid baga(pair<int,int> a)\n{\n    int len=0;\n    for(int i=1;i<=N;i++)\n    {\n\n        if(a<P[i])\n        {\n            tmp[++len]=atan2(P[i].second-a.second,P[i].first-a.first);\n        }\n    }\n    sort(tmp+1,tmp+1+len);\n    int cnt=(len>0);\n    //printf(\"%d \",rez);\n    fix(rez=rez-1);\n    for(int i=2;i<=len;i++)\n    {\n        if(tmp[i]==tmp[i-1])\n        {\n            cnt++;\n        }\n        else\n        {\n            fix(rez-=(pw2[cnt]-1));\n            cnt=1;\n        }\n    }\n    fix(rez-=(pw2[cnt]-1));\n//    printf(\"%d\\n\",rez);\n}\nint main()\n{\n    pw2[0]=1;\n    for(int i=1;i<=200;i++)fix(pw2[i]=2*pw2[i-1]);\n    scanf(\"%d\",&N);rez=pw2[N]-1;\n    for(int i=1;i<=N;i++)scanf(\"%d %d\",&P[i].first,&P[i].second);\n    for(int i=1;i<=N;i++)\n    {\n        baga(P[i]);\n    }\n    printf(\"%d\",rez);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\nusing ll = long long;\n\nconst ll MOD = 998244353;\nll mod(ll x) {\n    return x % MOD;\n}\nll pow_mod(ll x, ll p) {\n    ll v = 1;\n    while (p) {\n        if (p & 1) {\n            v = mod(v * x);\n        }\n        x = mod(x * x);\n        p >>= 1;\n    }\n    return v;\n}\n\nll N;\n\nstruct Point {\n    ll x, y;\n    friend Point operator-(const Point& a, const Point& b) {\n        return {a.x - b.x, a.y - b.y};\n    }\n    friend ll operator*(const Point& a, const Point& b) {\n        return a.x*b.y - a.y*b.x;\n    }\n    friend bool are_aligned(const Point& a, const Point& b, const Point& c) {\n        return (a-c)*(b-c) == 0;\n    }\n    friend bool in(const Point& a, const Point& b, const Point& c) {\n        auto s = a-c, t = b-c;\n        return s.x * t.x <= 0 and s.y * t.y <= 0;\n    }\n};\nvector<Point> points;\n\nvoid input() {\n    cin >> N;\n    for (ll i = 0; i < N; i++) {\n        ll x, y;\n        cin >> x >> y;\n        points.push_back({x, y});\n    }\n}\n\nvoid solve() {\n    ll sum = 0;\n    for (ll i = 0; i < N; i++) {\n        for (ll j = i + 1; j < N; j++) {\n            ll num_aligned_points = 2;\n            bool skip = false;\n            for (ll k = 0; k < N; k++) {\n                if (k == i or k == j) continue;\n                if (are_aligned(points[i], points[j], points[k])) {\n                    if (not in(points[i], points[j], points[k])) {\n                        skip = true;\n                        break;\n                    }\n                    ++num_aligned_points;\n                }\n            }\n            if (skip) continue;\n            sum += pow_mod(2, num_aligned_points) - num_aligned_points - 1;\n        }\n    }\n    ll ans = mod(pow_mod(2, N) - sum - N - 1);\n    cout << ans << endl;\n}\n\n\nint main() {\n    input();\n    solve();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<numeric>\n#include<limits>\n#include<bitset>\n#include<functional>\n#include<type_traits>\n#include<queue>\n#include<stack>\n#include<array>\n\nnamespace lib\n{\n\ttemplate<std::uint64_t Mod>struct modnum;\n\ttemplate<class T>constexpr T pow(T base, std::size_t p)\n\t{\n\t\tif (p == 0)\n\t\t{\n\t\t\treturn T(1);\n\t\t}\n\t\telse if (p == 1)\n\t\t{\n\t\t\treturn base;\n\t\t}\n\t\telse if (p == 2)\n\t\t{\n\t\t\treturn base*base;\n\t\t}\n\t\telse if (p % 2 == 0)\n\t\t{\n\t\t\treturn pow(pow(base, p / 2), 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pow(pow(base, p / 2), 2)*base;\n\t\t}\n\t}\n\ttemplate<std::uint64_t Mod>constexpr auto inverse(modnum<Mod> const&);\n\n\ttemplate<std::uint64_t Mod>struct modnum\n\t{\n\t\tstatic constexpr auto mod = Mod;\n\t\tstd::uint64_t val;\n\t\tmodnum() = default;\n\t\tconstexpr modnum(std::uint64_t v):val(v%Mod)\n\t\t{\n\n\t\t}\n\n\t\tconstexpr modnum& operator+=(modnum const& v)\n\t\t{\n\t\t\tval += v.val;\n\t\t\tval %= mod;\n\t\t\treturn *this;\n\t\t}\n\t\tconstexpr modnum& operator-=(modnum const& v)\n\t\t{\n\t\t\tval += mod - v.val;\n\t\t\tval %= mod;\n\t\t\treturn *this;\n\t\t}\n\t\tconstexpr modnum& operator*=(modnum const& v)\n\t\t{\n\t\t\tval *= v.val;\n\t\t\tval %= mod;\n\t\t\treturn *this;\n\t\t}\n\t\tconstexpr modnum& operator/=(modnum const& v)\n\t\t{\n\t\t\treturn operator*=(inverse(v));\n\t\t}\n\t};\n\ttemplate<std::uint64_t Mod>constexpr auto operator+(modnum<Mod> lhs, modnum<Mod>const& rhs)\n\t{\n\t\treturn lhs += rhs;\n\t}\n\ttemplate<std::uint64_t Mod>constexpr auto operator-(modnum<Mod> lhs, modnum<Mod>const& rhs)\n\t{\n\t\treturn lhs -= rhs;\n\t}\n\ttemplate<std::uint64_t Mod>constexpr auto operator*(modnum<Mod> lhs, modnum<Mod>const& rhs)\n\t{\n\t\treturn lhs *= rhs;\n\t}\n\ttemplate<std::uint64_t Mod>constexpr auto operator/(modnum<Mod> lhs, modnum<Mod>const& rhs)\n\t{\n\t\treturn lhs /= rhs;\n\t}\n\n\ttemplate<std::uint64_t Mod>constexpr auto inverse(modnum<Mod>const& base)\n\t{\n\t\treturn pow(base, Mod - 2);\n\t}\n\n\ttemplate<class T>constexpr auto clamp(T v)\n\t{\n\t\treturn std::max(v, T());\n\t}\n\ttemplate<class T>void sort(std::vector<T>& vec)\n\t{\n\t\tstd::sort(vec.begin(), vec.end());\n\t}\n\ttemplate<class T, class Compare>void sort(std::vector<T>& vec, Compare&& compare)\n\t{\n\t\tstd::sort(vec.begin(), vec.end(), std::forward<Compare>(compare));\n\t}\n\n\n\ttemplate<class T>auto lower_bound(std::vector<T>const& vec, T v)\n\t{\n\t\treturn std::distance(vec.begin(), std::lower_bound(vec.begin(), vec.end(), v));\n\t}\n\ttemplate<class T>auto upper_bound(std::vector<T>const& vec, T v)\n\t{\n\t\treturn std::distance(vec.begin(), std::upper_bound(vec.begin(), vec.end(), v));\n\t}\n\n\tstruct scope_exit\n\t{\n\t\tstd::function<void(void)> func;\n\t\tscope_exit(std::function<void(void)> f):func(f)\n\t\t{\n\n\t\t}\n\t\t~scope_exit()\n\t\t{\n\t\t\tfunc();\n\t\t}\n\t};\n\n\ttemplate<int val>using int_tag = std::integral_constant<int, val>;\n\n\ttemplate<class Return, class Argument>struct minimam_searcher\n\t{\n\t\tReturn operator()(std::function<Return(Argument)> func, Argument beg, Argument end)const\n\t\t{\n\t\t\tReturn min = std::numeric_limits<Return>::max();\n\t\t\tfor (; beg != end; ++beg)\n\t\t\t{\n\t\t\t\tmin = std::min(min, func(beg));\n\t\t\t}\n\t\t\treturn min;\n\t\t}\n\t};\n\ttemplate<class Return, class Argument>constexpr minimam_searcher<Return, Argument> minimam{};\n\n\ttemplate<class T>T gcd(T a, T b)\n\t{\n\t\tif (a > b)\n\t\t{\n\t\t\treturn gcd(b, a);\n\t\t}\n\t\tif (a == T())\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t\treturn gcd(b%a, a);\n\t}\n\n\tstatic constexpr int intlog2(int x)\n\t{\n\t\tfor (int i = 0, j = 2; i < 32; ++i, j <<= 1)\n\t\t{\n\t\t\tif (j > x)\n\t\t\t{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn 32;\n\t}\n\n\tstruct segtree\n\t{\n\t\tstd::vector<std::int64_t> tree;\n\t\tstd::size_t depth_;\n\t\tsegtree(std::size_t depth):tree(std::size_t(1) << (depth + 1)), depth_(depth)\n\t\t{\n\n\t\t}\n\n\t\tvoid change(std::size_t index, std::int64_t val)\n\t\t{\n\t\t\tchange(index, val, 0);\n\t\t}\n\n\t\tstd::int64_t get(std::size_t left, std::size_t right)//[left, right]の範囲\n\t\t{\n\t\t\treturn get(left, right + 1, 0, 1, 0);\n\t\t}\n\n\t\tvoid increment(std::size_t index)\n\t\t{\n\t\t\tincrement(index, 0);\n\t\t}\n\n\t\tvoid decrement(std::size_t index)\n\t\t{\n\t\t\tdecrement(index, 0);\n\t\t}\n\tprivate:\n\t\tstd::int64_t change(std::size_t index, std::int64_t val, std::size_t dep)\n\t\t{\n\t\t\tauto shift = std::size_t(1) << dep;\n\t\t\tauto s = std::size_t(1) << (depth_ - dep);\n\t\t\tif (dep == depth_)\n\t\t\t{\n\t\t\t\tstd::swap(tree[shift + index / s - 1], val);\n\t\t\t\treturn val;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto v = change(index, val, dep + 1);\n\t\t\t\ttree[shift + index / s - 1] += val - v;\n\t\t\t\treturn v;\n\t\t\t}\n\t\t}\n\n\t\tstd::int64_t get(std::size_t a, std::size_t b, std::size_t left, std::size_t right, std::size_t dep)\n\t\t{\n\t\t\tauto lshift = left << (depth_ - dep);\n\t\t\tauto rshift = right << (depth_ - dep);\n\t\t\tif (a <= lshift && rshift <= b)\n\t\t\t{\n\t\t\t\treturn tree[(std::size_t(1) << dep) + left - 1];\n\t\t\t}\n\t\t\telse if (rshift <= a || b <= lshift)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn\n\t\t\t\t\tget(a, b, left << 1, left + right, dep + 1) +\n\t\t\t\t\tget(a, b, left + right, right << 1, dep + 1);\n\t\t\t}\n\t\t}\n\n\t\tvoid increment(std::size_t index, std::size_t dep)\n\t\t{\n\t\t\tauto shift = std::size_t(1) << dep;\n\t\t\tauto s = std::size_t(1) << (depth_ - dep);\n\t\t\t\t++tree[shift + index / s - 1];\n\t\t\tif (dep != depth_)\n\t\t\t{\n\t\t\t\tincrement(index, dep + 1);\n\t\t\t}\n\t\t}\n\n\t\tvoid decrement(std::size_t index, std::size_t dep)\n\t\t{\n\t\t\tauto shift = std::size_t(1) << dep;\n\t\t\tauto s = std::size_t(1) << (depth_ - dep);\n\t\t\t--tree[shift + index / s - 1];\n\t\t\tif (dep != depth_)\n\t\t\t{\n\t\t\t\tdecrement(index, dep + 1);\n\t\t\t}\n\t\t}\n\t};\n\ttemplate<class T, int N>class binary_indexed_tree\n\t{\n\t\tstd::array<T, N> ar;\n\tpublic:\n\t\tbinary_indexed_tree(T val = 0)//全ての要素をvalで初期化する\n\t\t\t:ar{}\n\t\t{\n\t\t\tfor (int i = 1; i <= N; ++i)\n\t\t\t{\n\t\t\t\tar[i - 1] = (i&-i)*val;\n\t\t\t}\n\t\t}\n\t\tvoid add(T val, int index)//index番の要素にvalを足す\n\t\t{\n\t\t\t++index;\n\t\t\tfor (;index <= N; index += index&-index)\n\t\t\t{\n\t\t\t\tar[index - 1] += val;\n\t\t\t}\n\t\t}\n\t\tT get(int index)const//0からindex番までの要素の和を返す\n\t\t{\n\t\t\tT ret{};\n\t\t\tfor (++index; index > 0; index -= index&-index)\n\t\t\t{\n\t\t\t\tret += ar[index - 1];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n\n\ttemplate<class T>using p_queue = std::priority_queue<T, std::vector<T>, std::greater<>>;\n\n\ttemplate<class T>auto max(std::vector<T>const& vec)\n\t{\n\t\treturn *std::max_element(vec.begin(), vec.end());\n\t}\n\ttemplate<class T>auto min(std::vector<T>const& vec)\n\t{\n\t\treturn *std::min_element(vec.begin(), vec.end());\n\t}\n}\n\nnamespace std\n{\n\ttemplate<std::uint64_t Mod>decltype(auto) operator<<(ostream& ost, lib::modnum<Mod>const& v)\n\t{\n\t\treturn ost << v.val;\n\t}\n}\n\nvoid Main();\nint main()\n{\n\tstd::cin.tie(nullptr);\n\tstd::cin.sync_with_stdio(false);\n\tMain();\n}\n\ntypedef lib::modnum<998244353> mod_t;\n\nmod_t counter(int k)\n{\n\treturn lib::pow(mod_t(2), k) - mod_t(k)*mod_t(k - 1) / mod_t(2) - mod_t(k) - mod_t(1);\n}\n\nstruct point\n{\n\tint x, y;\n};\nbool check(point const&a, point const&b, point const&c)\n{\n\treturn (b.y - a.y)*(c.x - a.x) - (b.x - a.x)*(c.y - a.y) == 0;\n}\nbool operator<(point const& lhs, point const& rhs)\n{\n\treturn std::make_pair(lhs.x, lhs.y) < std::make_pair(rhs.x, rhs.y);\n}\n\nvoid Main()\n{\n\tint N;\n\tstd::cin >> N;\n\tstd::vector<point> points(N);\n\tfor (auto& p : points)\n\t{\n\t\tstd::cin >> p.x >> p.y;\n\t}\n\tstd::vector<std::pair<point, point>> lines;\n\tfor (int i = 0; i < N; ++i) \n\t{\n\t\tfor (int j = 0; j < i; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < i; ++k)\n\t\t\t{\n\t\t\t\tif (j == k)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (check(points[i], points[j], points[k]))\n\t\t\t\t{\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlines.emplace_back(points[i], points[j]);\n\t\tnext:;\n\t\t}\n\t}\n\tmod_t value = counter(N);\n\tfor (auto const& line : lines)\n\t{\n\t\tvalue -= counter(std::count_if(points.begin(), points.end(), [&](auto p) {return check(line.first, line.second, p); }));\n\t}\n\tstd::cout << value << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Crt. 2020-01-07  0946\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define PII pair<int, int>\n#define mk make_pair\n#define N 204\nusing namespace std;\nconst int Mod = 998244353;\n\ninline int fsp(int x, int p = Mod - 2) {\n    int res = 1;\n    while (p) {\n        if (p & 1) res = 1ll * res * x % Mod;\n        x = 1ll * x * x % Mod, p >>= 1;\n    } return res;\n}\n\ninline int getp(int x) {\n    return x < 0 ? -1 : 1;\n}\n\ninline int Abs(int x) {\n    return x < 0 ? -x : x;\n}\n\ninline int gcd(int x, int y) {\n    while (y ^= x ^= y ^= x %= y);\n    return x;\n}\n\nint n, x[N], y[N], m, z[N];\n\ninline PII getk(int i, int j) {\n    int a = y[j] - y[i], b = x[j] - x[i];\n    //cout << i << \" \" << j << \" \" << a << \" \" << b << endl;\n    if (!a) { return mk(-100000, y[i]); }\n    if (!b) { return mk(x[i], -100000); } \n    int pa = getp(a), pb = getp(b);\n    if (pa < 0) pa = -pa, pb = -pb;\n    a = Abs(a), b = Abs(b);\n    int g = gcd(a, b);\n    a /= g, b /= g;\n    a *= pa, b *= pb;\n    return mk(a, b);\n}\n\nint main(){\n#ifdef LOCAL_JUDGE\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i)\n        scanf(\"%d%d\", x + i, y + i);\n\n    long long ans = fsp(2, n) - 1 - n;\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n; ++j) {\n            int cnt = 0;\n            for (int k = j + 1; k <= n; ++k) {\n                if (getk(i, j) != getk(i, k)) continue; \n                ++cnt;\n            }\n            (ans -= fsp(2, cnt)) %= Mod;\n        }\n\n    if (ans < 0) ans += Mod;\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define get get228\n#define y1 y1228                                                         \nconst int MAXN = 201;\nconst int Mod = 998244353;\n\n\nstruct point\n{   \n    int x, y;\n    point(){}\n    point(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\n\npoint operator -(point a, point b) {\n    return point(a.x - b.x, a.y - b.y);\n}\n\n\nint vec(point a, point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nint scal(point a, point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n\nbool good(point a, point b, point c) {\n    return vec(b - a, c - a) != 0;\n}\n\n\nbool inside(point a, point b, point c, point x) {\n    int f = vec(b - a, x - a);\n    int f1 = vec(c - b, x - b);\n    int f2 = vec(a - c, x - c);\n    return (f >= 0 && f1 >= 0 && f2 >= 0) || (f <= 0 && f1 <= 0 && f2 <= 0);\n}\n\n\npoint cur;\n\n\nbool comp(point a, point b) {\n    if (vec(a - cur, b - cur) == 0) {\n        return (a.x - cur.x) * (a.y - cur.y) > (b.x - cur.x) * (b.y - cur.y);\n    }\n    return vec(a - cur, b - cur) > 0;\n}\n\n\nint n;\npoint p[MAXN];\nbool need[MAXN];\nbool goods[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint st[MAXN];\n\n\nint main() {    \n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        p[i].x = readInt(), p[i].y = readInt();\n    }\n    st[0] = 1; \n    for (int i = 1; i <= n; i++) {\n        st[i] = (st[i - 1] * 2) % Mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<point> ns;\n        for (int j = 0; j < n; j++) {\n            if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {\n                need[j] = true;\n                ns.push_back(p[j]);\n            } else {\n                need[j] = false;\n            }\n        }\n        cur = p[i];\n        sort(all(ns), comp);\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                goods[j][k] = false;\n                cnt[j][k] = 0;\n                dp[j][k] = 0;\n                if (good(p[i], ns[j], ns[k])) {\n                    goods[j][k] = true;\n                    for (int g = j + 1; g < k; g++) {\n                        if (inside(p[i], ns[j], ns[k], ns[g])) {\n                            cnt[j][k]++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < sz(ns); j++) {\n            for (int k = j + 1; k < sz(ns); k++) {\n                if (goods[j][k]) {\n                    dp[j][k] += st[cnt[j][k]];\n                    dp[j][k] %= Mod;\n                    ans += dp[j][k];\n                    ans %= Mod;\n                    for (int nxt = k + 1; nxt < sz(ns); nxt++) {\n                        if (vec(ns[nxt] - ns[j], ns[k] - ns[j]) < 0 && goods[k][nxt]) {\n                            dp[k][nxt] += dp[j][k];\n                            if (dp[k][nxt] >= Mod) {\n                                dp[k][nxt] %= Mod;\n                            }\n                        }\n                    }\n                }   \n            }\n        }\n    }\n    writeInt(ans, '\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 998244353\n\nint dame[222][222];\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll seica[2222];\nint main()\n{\n\tseica[0] = 1;\n\tREP(i,2221)seica[i+1] = seica[i] * 2 % MOD;\n\tint n;cin >> n;\n\tvector<pair<ll,ll>> v;\n\tREP(i,n){\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(a,b));\n\t}\n\tll ans = (seica[n] - n - 1 + MOD) % MOD; \n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = i+1;j < n;j++){\n\t\t\tvector<int> tmp;\n\t\t\tint cou = 0;\n\t\t\tll a = v[i].FI - v[j].FI;\n\t\t\tll b = v[i].SE - v[j].SE;\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tll c = v[i].FI - v[k].FI;\n\t\t\t\tll d = v[i].SE - v[k].SE;\n\t\t\t\tDBG(cout << \"cd \" << c << ' ' << d << endl;);\n\t\t\t\tif(a * d == b * c){\n\t\t\t\t\tcou++;\n\t\t\t\t\ttmp.PB(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp.size() > 2){\n\t\t\t\tREP(ii,tmp.size()){\n\t\t\t\t\tREP(jj,tmp.size()){\n\t\t\t\t\t\tif(ii != jj && dame[ii][jj] > 0){\n\t\t\t\t\t\t\tcou = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tDBG(cout << \"cou \" << cou << endl;SHOW1d(tmp,tmp.size()););\n\t\t\tdame[i][j] = cou;\n\t\t\tif(cou != 1)ans = (ans - (seica[cou] - cou - 1) + MOD) % MOD;\n\t\t}\n\t}\n\tDBG(SHOW2d(dame,n,n););\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nlong long int INF = 998244353;\n\nlong long int pow2(int n){\n\tif(n == 0){\n\t\treturn 1;\n\t}\n\tlong long int ret = (pow2(n - 1) * 2) % INF;\n\treturn ret;\n}\n\nint main(){\n\t\n\tint N;\n\t\n\tcin >> N;\n\t\n\tlong long int x[20000], y[20000];\n\tlong long int cnt2[20000] = {};\n\t\n\tlong long int score[20000];\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tif(N < 3){\n\t\tcout << \"0\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = i + 1; j < N; j++){\n\t\t\tint cnt = 0;\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tlong long int x1, x2, y1, y2;\n\t\t\t\tx1 = x[i] - x[k];\n\t\t\t\tx2 = x[j] - x[k];\n\t\t\t\ty1 = y[i] - y[k];\n\t\t\t\ty2 = y[j] - y[k];\n\t\t\t\tif(x1 * y2 == x2 * y1){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt2[cnt]++;\n\t\t}\n\t}\n\t\n\tfor(long long int i = 3; i < 300; i++){\n\t\tcnt2[i] /= i * (i - 1) / 2;\n\t}\n\t\n\t\n\tfor(int i = 0; i < 300; i++){\n\t\tscore[i] = pow2(i) - 1 - i - i * (i - 1) / 2;\n\t}\n\t\n\tlong long int ans = score[N];\n\t\n\tfor(int i = 1; i < 300; i++){\n\t\tans -= cnt2[i] * score[i];\n\t\tans %= INF;\n\t\tans += INF;\n\t\tans %= INF;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';\n\treturn !f?x:-x;\n}\n\nconst int N=200+19;\nconst int p=998244353;\n\nstruct Point{\n\tint x,y;\n\tbool operator < (const Point &B) const{\n\t\treturn x<B.x||x==B.x&&y<B.y;\n\t}\n} P[N],Pt;\ntypedef Point Vector;\n\nll cal[N][N];\nint dp[N][N],val[N][N],val2[N][N],pw2[N];\nint n,ans;\n\nVector operator - (Point A,Point B){\n\treturn (Vector){\n\t\tA.x-B.x,A.y-B.y\n\t};\n}\nll cross(Vector A,Vector B){\n\treturn 1ll*A.x*B.y-1ll*A.y*B.x;\n}\nbool cmp(Point A,Point B){\n\treturn cross(A-Pt,B-Pt)>0;\n}\n\nvoid Work(vector<Point> V){\n\tint n=V.size();\n\tmemset(dp,0,sizeof(dp));\n\tmemset(val,0,sizeof(val));\n\tmemset(val2,0,sizeof(val2));\n\tsort(V.begin()+1,V.end(),cmp);\n\tFor(i,1,n) For(j,1,n) cal[i][j]=cross(V[i]-V[0],V[j]-V[0]);\n\tFor(i,1,n) For(j,i+1,n){\n\t\tFor(k,1,n) if (k!=i&&k!=j&&cal[i][k]>=0&&cross(V[j]-V[i],V[k]-V[i])>=0){\n\t\t\tll tmp=cal[k][j];\n\t\t\tif (tmp>0) val[i][j]++;\n\t\t\tlf (tmp==0) val2[i][j]++;\n\t\t}\n\t\tval[i][j]=pw2[val[i][j]];\n\t\tval2[i][j]=pw2[val2[i][j]];\n\t}\n\tFor(i,1,n) dp[0][i]=1;\n\tFor(i,0,n) For(j,i+1,n) if (dp[i][j]){\n\t\tFor(k,j+1,n) if (cross(V[j]-V[i],V[k]-V[j])>0){\n\t\t\tdp[j][k]=(dp[j][k]+1ll*val[j][k]*dp[i][j])%p;\n\t\t}\n\t}\n\tFor(i,1,n) For(j,i+1,n)\n\t\tif (cross(V[j]-V[i],V[0]-V[j])>0){\n\t\t\tans=(ans+1ll*val2[i][j]*dp[i][j])%p;\n\t\t}\n}\n\nint main(){\n\tpw2[0]=1;\n\tFor(i,1,N) pw2[i]=2ll*pw2[i-1]%p;\n\tn=IN();\n\tFor(i,1,n+1) P[i]=(Point){IN(),IN()};\n\tsort(P+1,P+n+1);\n\tFor(i,1,n+1){\n\t\tPt=P[i];\n\t\tvector<Point> V;\n\t\tFor(j,i,n+1) V.pb(P[j]);\n\t\tWork(V);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 205;\nconst LL mod = 998244353LL;\n\nLL ans, base[N];\nbool done[N][N];\nLL x[N], y[N];\nint sta[N], top;\n\ninline LL mul(int a, int b, int c) {\n  return (x[b] - x[a]) * (y[c] - y[a]) - (x[c] - x[a]) * (y[b] - y[a]);\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  ans = 1;\n  base[0] = 1;\n  for (int i = 1; i <= n; i ++) base[i] = base[i - 1] * 2LL % mod;\n  ans = base[n];\n  for (int i = 1; i <= n; i ++) scanf(\"%lld%lld\", &x[i], &y[i]);\n  ans = (ans + mod - n - 1) % mod;\n  for (int i = 1; i <= n; i ++)\n    for (int j = 1; j <= n; j ++)\n      if (!done[i][j] && i != j) {\n\ttop = 0;\n\tsta[++ top] = i;\n\tsta[++ top] = j;\n\tfor (int k = 1; k <= n; k ++)\n\t  if (k != i && k != j && mul(i, j, k) == 0) sta[++ top] = k;\n\tans = (mod + ans + top + 1 - base[top]) % mod;\n\tfor (int k = 1; k <= top; k ++)\n\t  for (int l = 1; l < k; l ++) done[sta[k]][sta[l]] = done[sta[l]][sta[k]] = 1;\n      }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N; \nint x[1010], y[1010];\n\n\nusing line = tuple<int, int, int>; //ax + by + c = 0;\nline pass(int x1, int y1, int x2, int y2)\n{\n  int A = y2-y1;\n  int B = x1-x2;\n  int C = y1*x2-y2*x1;\n  if(A<0) A = -A, B = -B, C = -C;\n  if(A==0 && B<0) B = -B, C = -C;\n  int g = __gcd(A, __gcd(B, C));\n  A /= g; B /= g; C /= g;\n  \n  \n  return line(A, B, C);\n}\n\nconst int MOD = 998244353;\n\nint main()\n{\n  int pow2[202]; pow2[0] = 1;\n  map<line, int> M;\n  scanf(\"%d\", &N);\n  for(int i=0; i<N; ++i) scanf(\"%d%d\", x+i, y+i);\n  for(int i=1; i<=N; ++i) pow2[i] = pow2[i-1]*2%MOD;\n  for(int i=0; i<N; ++i)\n    for(int j=0; j<i; ++j)\n    {\n      line l = pass(x[i], y[i], x[j], y[j]);\n      M[l] = M[l] + 1;\n    }\n  int ans = (pow2[N]-1+MOD-N)%MOD; // {}, singleton\n  for(auto x: M)\n  {\n    int cnt = x.second;\n    int il = sqrt(cnt*2)+1;\n    ans = (ans + MOD - pow2[il])%MOD; // >2\n    ans = (ans + il) % MOD; // = 1\n    ans = (ans + 1) % MOD; // = 0\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#if defined(LOCAL)\n#define PROBLEM_NAME \"c\"\nconst double _max_double_error = 1e-9;\n#include \"testutils.h\"\n#define L(x...) debug(x)\n#else\n#define L(x...) (x)\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ii = pair<int,int>; using vii = vector<ii>;\nusing l = long long; using vl = vector<l>; using vvl = vector<vl>;\nusing ll = pair<l,l>; using vll = vector<ll>; using vvll = vector<vll>;\nusing lu = unsigned long long;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vd = vector<double>; using vvd = vector<vd>;\nusing mll = unordered_map<l, l>;\nconst l INF = numeric_limits<l>::max();\nconst double EPS = 1e-10; static constexpr auto PI = acos(-1);\nconst l e0=1, e3=1000, e5=100000, e6=10*e5, e7=10*e6, e8=10*e7, e9=10*e8;\nconst char lf = '\\n';\n#define all(x) begin(x), end(x)\n#define F(a,b,c) for (l a = l(b); a < l(c); a++)\n#define B(a,b,c) for (l a = l(c) - 1; a >= l(b); a--)\n\nl gcd(l a, l b) {\n  while (b) { l t = b; b = a % b; a = t; }\n  return a;\n}\n\nl lcm(l a, l b) { return a * b / gcd(a, b); }\n\nl sign(l n) {\n  if (n < 0) return -1;\n  if (n == 0) return 0;\n  return 1;\n}\n\n// conruent modulo, works for negative\nl cong(l x, l mod) {\n  return (x % mod + mod) % mod;\n}\n\n// (a * b) % mod, safe for l near max\nl mult_mod(l a, l b, l mod) {\n  l x = 0;\n  while (b) {\n    if (b % 2) x = (x + a) % mod;\n    a = (a * 2) % mod;\n    b /= 2;\n  }\n  return x;\n}\n\n// (base^power) % mod, safe for l near max\nl pow_mod(l base, l power, l mod) {\n  l r = 1;\n  while (power) {\n    if (power % 2) r = mult_mod(r, base, mod);\n    base = mult_mod(base, base, mod);\n    power /= 2;\n  }\n  return r;\n}\n\nl divup(l a, l b) { // ceil div\n  return (a + b - 1) / b;\n}\n\n// return gcd(a, b) and set x, y: a * x + b * y = gcd(a, b)\nl extended_euclid(l a, l b, l& x, l& y) {\n  if (b == 0) { x = 1; y = 0; return a; }\n  l d = extended_euclid(b, a % b, x, y);\n  l t = y;\n  y = x - (a / b) * y;\n  x = t;\n  return d;\n}\n\n// return b: a * b = 1 (mod n)\nl inverse_mod(l a, l n) {\n  l x, y;\n  l d = extended_euclid(a, n, x, y);\n  if (d != 1) return 0;\n  return cong(x, n);\n}\n\n// single combintions k from n\nl nCr(l n, l k, l mod) {\n  l a = 1;\n  for (l i = n; i > n - k; i--) a = mult_mod(a, i, mod);\n  l b = 1;\n  F(i, 1, k + 1) b = mult_mod(b, i, mod);\n  b = inverse_mod(b, mod);\n  return mult_mod(a, b, mod);\n}\n\n// precompute all combinations up to (n n)\nvvl combinations(l n, l mod) {\n  vvl c(n + 1, vl(n + 1));\n  F(i, 0, n) {\n    c[i][0] = 1;\n    F(j, 1, i + 1) {\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n    }\n  }\n  return c;\n}\n// a / b\nstruct Rat {\n  l a, b;\n  bool operator < (Rat const& rhs) const {\n    if (rhs.b == 0 and b == 0) {\n      return a < rhs.a;\n    }\n    if (b == 0) return a < 0;\n    if (rhs.b == 0) return rhs.a > 0;\n    return a * rhs.b < rhs.a * b;\n  }\n\n  void set(l na, l nb) {\n    a = na; b = nb;\n    normalize();\n  }\n\n  void set(l na) {\n    set(na, 1);\n  }\n\n  void normalize() {\n    l g = gcd(abs(a), abs(b));\n    assert(g);\n    a /= g;\n    b /= g;\n    if (a == 0) b = 1;\n    if (b == 0) a = sign(a);\n    if (b < 0 and a != 0) {\n      a = -a;\n      b = -b;\n    }\n  }\n};\n\nostream& operator << (ostream& s, const Rat& p) {\n  s << p.a << \" / \" << p.b;\n  return s;\n}\n\nstruct Line {\n  Rat x0, d;\n\n  bool operator < (Line const& rhs) const {\n    if (x0 < rhs.x0) return true;\n    if (rhs.x0 < x0) return false;\n    return d < rhs.d;\n  }\n};\n\nl const MOD = 998244353;\n\nl set2(l n) {\n  return cong(pow_mod(2, n, MOD) - n - 1, MOD);\n}\n\nvoid solve(istream& cin, ostream& cout) {\n  l n; cin >> n;\n  vl x(n), y(n);\n  F(i, 0, n) cin >> x[i] >> y[i];\n  map<Line, l> m;\n  F(i, 0, n) F(j, i + 1, n) {\n    Line q;\n    q.d.set(y[j] - y[i], x[j] - x[i]);\n    if (q.d.b == 0) q.d.a = 1;\n    if (y[i] == y[j]) {\n      q.x0.set(y[i]);\n      q.d.set(-1, 0);\n    } else {\n      q.x0.set(x[i] * (y[j] - y[i]) - y[i] * (x[j] - x[i]), y[j] - y[i]);\n    }\n    // cerr << q.x0 << ' ' << q.d << endl;\n    m[q]++;\n  }\n  l answer = set2(n);\n  for (auto p : m) {\n    l t = p.second;\n    t = round(sqrt(8 * t + 1) + 1) / 2;\n    // cerr << p.second << ' ' << t << endl;\n    answer = cong(answer - set2(t), MOD);\n  }\n  cout << answer << lf;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout << fixed << setprecision(15);\n#if defined(LOCAL)\n  // _generate_random_test = generate_random;\n  // _solve_brute = solve_brute;\n  // _player_b = player_b;\n  // _custom_solution_checker = solution_checker;\n  maybe_run_tests(cin, cout);\n#else\n  solve(cin, cout);\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int int64_t\n\ntypedef int64_t ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n\nftype dot(point a, point b)\n{\n\treturn (conj(a) * b).x();\n}\n\nftype cross(point a, point b)\n{\n\treturn (conj(a) * b).y();\n}\n\nconst int mod = 998244353;\n\nvoid add_mod(int &a, int b)\n{\n\ta += b;\n\twhile(a >= mod)\n\t\ta -= mod;\n\twhile(a < 0)\n\t\ta += mod;\n}\n\nsigned main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tpoint r[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tr[i] = {x, y};\n\t}\n\tint ans = 0;\n\tfor(int s = 0; s < n; s++)\n\t{\n\t\tpoint o = r[s];\n\t\tvector<point> pts;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(r[i].y() > o.y() || r[i].y() == o.y() && r[i].x() > o.x())\n\t\t\t\tpts.push_back(r[i]);\n\t\tsort(begin(pts), end(pts), [&](point a, point b)\n\t\t\t{return cross(a - o, b - o) < 0 || cross(a - o, b - o) == 0 && norm(a) < norm(b);});\n\t\tint m = pts.size();\n\t\tint dp[m][m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tdp[i][j] = 0;\n\t\tfor(int r = 0; r < m; r++)\n\t\t\tfor(int l = 0; l < r; l++)\n\t\t\t{\n\t\t\t\tif(cross(pts[r] - o, pts[l] - o) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[l][r] = 1;\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[p] - o, pts[l] - o) == 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tfor(int p = 0; p < l; p++)\n\t\t\t\t\tif(cross(pts[l] - pts[p], pts[r] - pts[p]) < 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[p][l]);\n\t\t\t\tfor(int p = l + 1; p < r; p++)\n\t\t\t\t\tif(cross(pts[r] - pts[l], pts[p] - pts[l]) <= 0)\n\t\t\t\t\t\tadd_mod(dp[l][r], dp[l][r]);\n\t\t\t\tadd_mod(ans, dp[l][r]);\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 998244353\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\ntypedef pair<P,P> PP;\n\nconst int MAX_N = 201;\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\ninline void make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - (ll)inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = (ll)fac[i-1] * i % MOD;\n\t\tfinv[i] = (ll)finv[i-1] * inv[i] % MOD;\n\t}\n}\n\ninline int comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn (ll)fac[a] * ((ll)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\ninline int add(int x,int y)\n{\n    return (x+y)%MOD;\n}\n\ninline int sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\ninline int mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\nint sm[MAX_N];\n\nint gcd(int a, int b)\n{\n    if(!b) return a;\n    if(a % b == 0){\n        return b;\n    }else{\n        return gcd(b,a%b);\n    }\n}\n\nclass line\n{\npublic:\n    int a, b, c;\n    line(){}\n    line(int a_, int b_, ll c_) : a(a_), b(b_), c(c_){}\n    line(int p, int q, int r, int s){\n\t\tif(p == r){\n\t\t\ta = 1, b = 0, c = -p;\n\t\t}else if(q == s){\n\t\t\ta = 0, b = 1, c = -q;\n\t\t}else{\n\t\t\tint dx = r-p, dy = s-q;\n\t\t\tint g = gcd(abs(dx), abs(dy));\n\t\t\tif(dx * dy < 0){\n\t\t\t\ta = abs(dy)/g, b = abs(dx)/g;\n\t\t\t}else{\n\t\t\t\ta = -abs(dy)/g, b = abs(dx)/g;\n\t\t\t}\n\t\t\tc = -a*p-b*q;\n\t\t}\n    }\n    line(P x, P y) : line(x.first, x.second, y.first, y.second){}\n    bool operator< (const line& l) const {\n        return (a == l.a)?((b == l.b)?(c < l.c):(b < l.b)):(a < l.a);\n    }\n    bool operator> (const line& l) const {\n        return (a == l.a)?((b == l.b)?(c > l.c):(b > l.b)):(a > l.a);\n    }\n    bool operator== (const line& l) const {\n        return (a == l.a)?((b == l.b)?(c == l.c):false):false;\n    }\n    bool operator!= (const line& l) const {\n        return !(*this == l);\n    }\n    inline bool onLine(int p, int q){\n        return (a*p+b*q+c == 0);\n    }\n    inline bool onLine(P x){ return onLine(x.first, x.second); }\n};\n\nvector<line> Line;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vi x(n), y(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n    }\n    make();\n    srep(i,3,n+1){\n        srep(j,3,i+1){\n            sm[i] = add(sm[i], comb(i, j));\n        }\n    }\n    int ans = sm[n];\n    rep(i,n){\n        srep(j,i+1,n){\n\t\t\tLine.emplace_back(x[i], y[i], x[j], y[j]);\n        }\n    }\n    zip(Line);\n    // show(ans);\n    each(it, Line){\n        int res = 0;\n\t\trep(i,n){\n\t\t\tres += it.onLine(x[i], y[i]);\n\t\t}\n        ans = sub(ans, sm[res]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint n;\nint x[maxn], y[maxn];\nint pw[maxn];\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\t*pw = 1;\n\tcin >> n;\n\trep(i, 1, n) {\n\t\tcin >> x[i] >> y[i];\n\t\tpw[i] = (pw[i - 1] << 1) % mod;\n\t}\n\tint ans = pw[n] - n - 1;\n\tans += ans >> 31 & mod;\n\trep(i, 1, n) {\n\t\trep(j, i + 1, n) {\n\t\t\tint cnt = 0;\n\t\t\trep(k, j + 1, n) {\n\t\t\t\tcnt += (ll) (x[j] - x[i]) * (y[k] - y[i]) == (ll) (x[k] - x[i]) * (y[j] - y[i]);\n\t\t\t}\n\t\t\tans -= pw[cnt];\n\t\t\tans += ans >> 31 & mod;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint N,X[202],Y[202];\n\nint gcd(int a, int b)\n{\n\treturn b ? gcd(b,a%b) : a;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=0;i<N;i++) scanf (\"%d %d\",&X[i],&Y[i]);\n\n\tlong long mod = 998244353;\n\tlong long pw[202] = {1,};\n\tfor (int i=1;i<=N;i++) pw[i] = pw[i-1] * 2 % mod;\n\n\tlong long ans = (pw[N] - 1 + mod - N) % mod;\n\n\tfor (int i=0;i<N;i++){\n\t\tmap<pair<int, int>, int> chk;\n\t\tfor (int j=i+1;j<N;j++){\n\t\t\tint dx = X[j] - X[i], dy = Y[j] - Y[i];\n\t\t\tint g = gcd(abs(dx),abs(dy));\n\t\t\tdx /= g; dy /= g;\n\t\t\tif (dx < 0) dx = -dx, dy = -dy;\n\t\t\tchk[{dx,dy}]++;\n\t\t}\n\n\t\tfor (auto &p : chk) ans = (ans + mod - pw[p.second] + 1) % mod;\n\t}\n\t\n\tprintf (\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef double lld;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<double> vdl;\ntypedef vector<vector<lli>> mat;\ntypedef vector<vdl> mad;\ntypedef unordered_map<lli,unordered_map<lli,lli>> graph;\ntypedef complex<double> cmp;\ntypedef vector<cmp> vcl;\n\nconst lli mod = 998244353;\n\nlli n;\nvector<vdl> p;\nmat c;\nmat bl;\nlli ans = 0;\n\nlld deg(vdl a,vdl from){\n  return fmod(atan2(a[1]-from[1],a[0]-from[0])+2*M_PI,2*M_PI);\n}\n\nlld deg(vdl a,vdl b,vdl from){\n  return fmod(deg(b,from)-deg(a,from)+2*M_PI,2*M_PI);\n}\n\nlld abs(vdl to,vdl from){\n  lld x = to[0]-from[0];\n  lld y = to[1]-from[1];\n  return sqrt(x*x+y*y);\n}\n\nlld dot(vdl a,vdl b,vdl from){\n  lld x1 = a[0]-from[0];\n  lld y1 = a[1]-from[1];\n  lld x2 = b[0]-from[0];\n  lld y2 = b[1]-from[1];\n  return x1*x2+y1*y2;\n}\n\nlli pow(lli x,lli r,lli mod = 998244353){\n  lli ret = 1;\n  for(;r != 0;r >>= 1){\n    if(r&1 != 0) ret *= x,ret %= mod;\n    x *= x,x %= mod;\n  }\n  return ret;\n}\n\nset<vdl> s;\nmap<vdl,lli> m;\n\nint main(){\n  cin >> n;\n  p = vector<vdl>(n,vdl(2));\n  for(lli i = 0;i < n;i++) cin >> p[i][0] >> p[i][1];\n  bl = mat(n,vll(n));\n  for(lli i = 0;i < n;i++){\n    bl[i][i] = 1;\n    for(lli j = 0;j < n;j++){\n      if(bl[i][j]) continue;\n      set<lli> s;\n      bl[i][j] = bl[j][i] = 1;\n      s.insert(i);\n      s.insert(j);\n      for(lli k = 0;k < n;k++){\n        if((p[k][1]-p[i][1])*(p[j][0]-p[i][0]) == (p[j][1]-p[i][1])*(p[k][0]-p[i][0])){\n          for(lli x : s){\n            bl[x][k] = bl[k][x] = 1;\n          }\n          s.insert(k);\n        }\n      }\n      ans += pow(2ll,s.size())-1-s.size();\n    }\n  }\n\n  // for(lli i = 0;i < n;i++){\n  //   for(lli j = 0;j < n;j++){\n  //     cout << bl[i][j];\n  //   }\n  //   cout << endl;\n  // }\n  ans += 1ll;\n  ans += n;\n  cout << ((pow(2ll,n)-ans+mod)%mod) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, x[213] = {}, y[213] = {}, p[213] = {1}, z = 0;\n    bool b[213][213] = {};\n    cin >> n;\n    for (int i = 1; i <= n; i++) p[i] = p[i - 1] * 2 % 998244353;\n    for (int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n    for (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) if (!b[i][j]) {\n        vector<int> c = {i, j};\n        int w = 2;\n        for (int k = j + 1; k <= n; k++) if ((x[i] - x[j]) * (y[i] - y[k]) == (y[i] - y[j]) * (x[i] - x[k])) w++, c.push_back(k);\n        for (int k : c) for (int l : c) b[k][l] = 1;\n        z = (z + p[w] - 1 - w) % 998244353;\n    }\n    cout << (p[n] - z - n + 998244352) % 998244353;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define R register\n#define MN 205\n#define P 998244353\nint n,x[MN],y[MN],p[MN],ans;\ninline int read(){\n\tR int x; R bool f; R char c;\n\tfor (f=0; (c=getchar())<'0'||c>'9'; f=c=='-');\n\tfor (x=c^'0'; (c=getchar())>='0'&&c<='9'; x=(x<<1)+(x<<3)+(c^'0'));\n\treturn f?-x:x;\n}\ninline void del(int &x,int y){x-=y; if (x<0) x+=P;}\nint main(){\n\tn=read();for (R int i=1; i<=n; ++i) x[i]=read(),y[i]=read();\n\tp[0]=1;for (R int i=1; i<=n; ++i) p[i]=p[i-1]<<1,p[i]>=P?p[i]-=P:0;\n\tans=p[n];del(ans,n+1);\t\n\tfor (R int i=2; i<=n; ++i)\n\t\tfor (R int j=1,cnt; j<i; ++j){\n\t\t\tcnt=0;\n\t\t\tfor (R int k=1; k<j; ++k)\n\t\t\t\tif ((x[k]-x[i])*(y[j]-y[i])==(y[k]-y[i])*(x[j]-x[i])) ++cnt;\n\t\t\tdel(ans,p[cnt]);\t\n\t\t}printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "                #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                        #define ppa pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                 \n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpas(int x=0,int y=0):x(x),y(y) {}\n                                        \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                        \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                        \tpas operator * (int a) {return pas(x*a,y*a);}\n                                        \tpas operator / (int a) {return pas(x/a,y/a);}\n                                        \t\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        };\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 \n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             \n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n            \n           \nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\n\npas po[210];\nint d[210]={0};\nint mod;\nbool ch(pas x1,pas x2,pas x3){\n\tx3=x3-x1;\n\tx2=x2-x1;\n\tint ans= abs(x3.x*x2.y-x2.x*x3.y);\n\tif(ans==0) return 1;\n\telse return 0;\n}\nint saizu(int u){\nint ans=\tbeki(2,u,mod);\n\tans-=1+u+u*(u-1)/2;\n\tans=(ans+mod)%mod;\n\treturn ans;\n}\n      signed main(){\n     int n;\n      \tcin>>n;\n      \tif(n<3){\n      \t\tcout<<0<<endl;\n      \t\treturn 0;\n      \t}\n       mod=\t998244353;\n      \tfor(int i=0;i<n;i++)cin>>po[i].x>>po[i].y;\n      \t\n      \tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n      \t\tint cn=0;\n      \t\tfor(int k=0;k<n;k++)if(k!=i && k!=j){\n      \t\t\tif(ch(po[i],po[j],po[k]))cn++;\n      \t\t}\t\n      \t\tif(cn>0)d[cn+2]++;\n      \t}\n      \tint ans=beki(2,n,mod);\n      \tans-=1+n+n*(n-1)/2;\n      \tans=(ans+mod)%mod;\n      \t\n      \tfor(int i=3;i<=n;i++){\n      \t\tint r=i*(i-1)/2;\n      \t\td[i]/=r;\n      \t\t\n      \t\tans += (mod-(saizu(i)*d[i]));\n      \t\tans%=mod;\n      \t}\n      \t\n      \tcout<<ans<<endl;\n        \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <bitset>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n#define FOR(i,a,b)   for(ll i = (a); i < (b); i++ )\n#define REP(i, n)    FOR(i,0,n)\ntypedef pair< ll, ll >   cp2;\ntypedef pair< ll, cp2 >   cp3;\n#define fi first\n#define se second\n#define sec  se.fi\n#define thr  se.se\nconst ll mod = 1000000007;\n//              123456789\n\n\n///////////////////////////////////////////////\n//\n//\n///////////////////////////////////////////////\n\n////////////////////////////////////////////////\n////////////////////////////////////////////////\n\nll MOD = 998244353;\n//        12345678\n\n#define MAX   212  //nCrのnの最大値より大きい値\nint fact[MAX]; //階乗を入れておく\nint inv[MAX];  //逆元を入れておく\n\nvoid setC()//nCrのnの最大値までの配列準備\n{\n  ll num = 1;\n  ll w;\n  fact[0] = 1;\n  inv[0] = 1;\n  FOR( i, 1, MAX ){\n    (num *= i) %= mod;\n    fact[i] = num;\n  }\n  int jdg;\n  FOR( i, 1, MAX ){\n    w = 1;\n    num = fact[i];\n    jdg = mod-2;\n    \n    while( jdg ){\n      if( jdg % 2 ) (w *= num) %= mod;\n      jdg >>= 1;\n      (num *= num) %= mod; \n    }\n    inv[i] = w;\n  }\n}\n\nint  combination( int n, int r )//mod付きnCr(コンビネーション)\n{\n  ll a;\n  int b;\n  a = ( (ll)fact[n] * (ll)inv[n-r] ) % (ll)mod;\n  (a *= (ll)inv[r]) %= mod;\n  b = a;\n  \n  return b;  \n}\n\nint N;\ncp2 P[212];\nint x, y;\nll ans = 1;\n\nint main(){\n\t\n\tcin>>N;\n\t\n\tREP( i, N ){\t\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tP[i].fi = x;\n\t\tP[i].se = y;\n\t}\n\t\n\tll num = 1;\n\tint dx;\n\tint dy;\n\tint a, b;\n\tll cnt;\n\t\n\t\n\tREP( i, N ){\n\t\tFOR( j, i+1, N ){\n\t\t\tdx = P[i].fi-P[j].fi;\n\t\t\tdy = P[i].se-P[j].se;\n\t\t\tcnt = 0;\n\t\t\tFOR( k, j+1, N ){\n\t\t\t\ta = P[i].fi-P[k].fi;\n\t\t\t\tb = P[i].se-P[k].se;\n\t\t\t\tif( !(a*dy-b*dx) ) cnt++;\n\t\t\t}\n\t\t\t\n\t\t\t(num += cnt*(cnt+1)/2) %= MOD;\n\t\t}\n\t}\n\t\n\tsetC();\n\t\n\t//cout<<num<<endl;\n\t\n\tFOR( i, 3, N+1 ){\n\t\tans += combination( N, i );\n\t}\n\t\n\tans -= num;\n\tif( ans < 0 ) ans += MOD;\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll=long long;\n#define int ll\n \n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DMP(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n \nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n \ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n \ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n \nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n \nvoid printSpace(){\n\tprintf(\" \");\n}\n \nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n \nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n \nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n \nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n \ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n \ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n \ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n \nconst int inf=LLONG_MAX/3;\n\nconst int mod=998244353;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\ta=((ll)a+b)%mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\ta=((ll)a-b%mod+mod)%mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\tmult(s,a);\n\t\tmult(a,a);\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nstruct Pos{\n\tint x,y;\n};\nint cross(const Pos&a,const Pos&b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nsigned main(){\n\tint n=read(),dp[4]{1,0,0,0};\n\tREP(_,n){\n\t\tint k=dp[3];\n\t\tfor(int i=3;i>=1;i--)\n\t\t\tadd(dp[i],dp[i-1]);\n\t\tadd(dp[3],k);\n\t}\n\tcout<<dp[3]<<endl;\n\tvector<Pos> ps;\n\tREP(i,n){\n\t\tint x=read(),y=read();\n\t\tps.PB(Pos{x,y});\n\t}\n\tsort(ALL(ps),[&](const Pos&a,const Pos&b){\n\t\treturn a.x!=b.x?(a.x<b.x):(a.y<b.y);\n\t});\n\tREP(_,n){\n\t\tvector<Pos> cur;\n\t\tREP(i,_)\n\t\t\tcur.PB(Pos{ps[i].x-ps[_].x,ps[i].y-ps[_].y});\n\t\tsort(ALL(cur),[&](const Pos&a,const Pos&b){\n\t\t\treturn cross(a,b)>0;\n\t\t});\n\t\tint num=0;\n\t\tREP(i,cur.size()){\n\t\t\t//cerr<<_<<\" \"<<num<<endl;\n\t\t\tsub(dp[3],modPow(2,num++)-1);\n\t\t\tif(i+1==int(cur.size())||cross(cur[i],cur[i+1])!=0)\n\t\t\t\tnum=0;\n\t\t}\n\t}\n\tcout<<dp[3]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint cnt[201][201] = {};\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nlong long moving[1000] = {};\nint main() {\n#define int long long\n\tvector<pair<int, int>> inputs;\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tinputs.push_back(make_pair(a, b));\n\t}\n\tmoving[0] = 1;\n\tfor (int i = 1; i < 1000; ++i) {\n\t\tmoving[i] = moving[i - 1] * 2;\n\t\tmoving[i] %= MOD;\n\t}\n\tlong long ans = moving[n];\n\tlong long tmp = n + 1;\n\tmap<tuple<long long, long long, long long>, int> edges;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int q = 0; q < n; ++q) {\n\t\t\tif (i == q) continue;\n\t\t\tlong long A = inputs[q].second - inputs[i].second;\n\t\t\tlong long B = -(inputs[q].first - inputs[i].first);\n\t\t\tlong long C = A * inputs[i].first + B * inputs[i].second;\n\t\t\tlong long geko = 0;\n\t\t\tif (A == 0) {\n\t\t\t\tgeko = llabs(B);\n\t\t\t}\n\t\t\telse if (B == 0) {\n\t\t\t\tgeko = llabs(A);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeko = gcd(llabs(A), llabs(B));\n\t\t\t}\n\t\t\tif (geko == 0) {\n\t\t\t\tgeko = llabs(C);\n\t\t\t}\n\t\t\telse if (C == 0) {\n\t\t\t\tgeko = llabs(geko);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeko = gcd(llabs(C), llabs(geko));\n\t\t\t}\n\t\t\tif (geko != 0) {\n\t\t\t\tA /= geko;\n\t\t\t\tB /= geko;\n\t\t\t\tC /= geko;\n\t\t\t}\n\t\t\tif (A < 0) {\n\t\t\t\tA = -A;\n\t\t\t\tB = -B;\n\t\t\t\tC = -C;\n\t\t\t}\n\t\t\telse if (A == 0 && B < 0) {\n\t\t\t\tA = -A;\n\t\t\t\tB = -B;\n\t\t\t\tC = -C;\n\t\t\t}\n\t\t\telse if (A == 0 && B == 0 && C < 0) {\n\t\t\t\tA = -A;\n\t\t\t\tB = -B;\n\t\t\t\tC = -C;\n\t\t\t}\n\t\t\tedges[make_tuple(A, B, C)]++;\n\t\t}\n\t}\n\tfor (auto i = edges.begin(); i != edges.end(); ++i) {\n\t\tint cnt = 0;\n\t\tfor (int q = 1;; ++q) {\n\t\t\tcnt += q*2;\n\t\t\tif (i->second == cnt) {\n\t\t\t\ttmp += moving[q + 1] - (q + 1) - 1;\n\t\t\t\ttmp += MOD;\n\t\t\t\ttmp %= MOD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans + (MOD - tmp)) % MOD << endl;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, V.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , V.convert input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | V.length v == 1 = 0\n                     | otherwise = case m' $ (m' 2^n  )- (m' $ 1 + n + res  ) of \n                         res' -> if res' < 0 then res' + 998244353\n                                 else res'                         \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ (m' dScore)) )\n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ (m' dScore)) ) ( ins l )\n          | otherwise = go i1 (i2+1) ( m' (accum'+ (m' dScore)) ) (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                n1 = v V.! i1\n                n2 = v V.! i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | UV.length v == 1 = 0\n                     | otherwise = m' $ (m' 2^n  )- (m' $ 1 + n + res  )\n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ (m' dScore)) )\n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ (m' dScore)) ) ( ins l )\n          | otherwise = go i1 (i2+1) ( m' (accum'+ (m' dScore)) ) (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                n1 = v!i1\n                n2 = v!i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 2)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | n == 1 = 0\n                     | otherwise = m' (  2^n - ( 1 + n + res  ) ) \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = (  (accum'+ dScore))  \n          | i2 == n-1 = go (i1+1) (i1+2) (  (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) (   (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                  L (False,_,_,_,_) -> UV.length . UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                n1 = v UV.! i1\n                n2 = v UV.! i2\n                ins = flip insert lset\n\n-- getAnswer :: Input -> Answer \n-- getAnswer (I (n, v)) | n == 1 = 0\n--                      | otherwise = m' ( (m' 2^n + 998244353)- (m' $ 1 + n + res  ) ) \n--   where res =  go 0 1 0 Data.Set.empty\n--         go !i1 !i2 !accum' !lset \n--           | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n--           | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n--           | otherwise = go i1 (i2+1) (  m' (accum'+ dScore))  (ins l)\n--           where l = lineFromPoint n1 n2 \n--                 dScore | l `member` lset = 0\n--                        | otherwise = 2^k - k - 1\n--                 (k:: Int) = case l of\n--                   L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n--                   L (False,_,_,_,_) -> UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n--                 n1 = v UV.! i1\n--                 n2 = v UV.! i2\n--                 ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\nnewtype Line = L (Bool, Int,Int,Int,Int)\n  deriving(Show)\n\ninstance Eq Line where\n  (==) (L (False,x,_,_,_)) (L (False,x',_,_,_)) = x == x'\n  (==) (L (True,a,a',b,b')) (L (True,aa,aa',bb,bb')) = Prelude.and [ a==aa,a'==aa',b==bb,b'==bb']\n  (==) _ _ = False\n\ninstance Ord Line where\n  compare (L (False,_,_,_,_)) (L (True,_,_,_,_)) = GT\n  compare (L (True,_,_,_,_)) (L (False,_,_,_,_)) = LT\n  compare (L (False,x,_,_,_)) (L (False,x',_,_,_)) = compare x x'\n  compare l l' = compare ab ab'\n    where coefficient (L ( True, x,y,z,a) ) = (x,y,z,a)\n          ab = coefficient l\n          ab' = coefficient l'\n\n\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n    L ( True , divA, divA' , divB, divB')    \n  | otherwise = L (False,x0,minBound,minBound,minBound)\n  where a = y1-y0\n        a' = x1-x0\n        b = (x1-x0)*y0 - (y1-y0)*x0\n        b' = x1-x0\n        factorA = gcd a a'\n        factorB = gcd b b'\n        (divA, divA') | a >= 0 && a' >= 0 = (a `div` factorA ,a' `div` factorA) \n                      | a < 0 && a' >= 0 = (a `div` factorA ,a' `div` factorA) \n                      | a >= 0 && a' < 0 = (-1 * a `div` factorA ,-1 * a' `div` factorA) \n                      | a <  0 && a' < 0 = (-1 * a `div` factorA ,-1 * a' `div` factorA) \n        (divB, divB')\n          | factorB == 0 = (0,0)\n          | b >= 0 && b' >= 0 = (b `div` factorB ,b' `div` factorB) \n          | b < 0 && b' >= 0 = (b `div` factorB ,b' `div` factorB) \n          | b >= 0 && b' < 0 = (-1 * b `div` factorB ,-1 * b' `div` factorB) \n          | b <  0 && b' < 0 = (-1 * b `div` factorB ,-1 * b' `div` factorB) \n\n\n\nm' :: Int -> Int \nm' i = i `rem`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | n == 1 = 0\n                     | otherwise =  ( ( 2^n + 998244353)- ( 1 + n + res  ) ) \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = (  (accum'+ dScore)) \n          | i2 == n-1 = go (i1+1) (i1+2) (  (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) (   (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                  L (False,_,_,_,_) -> UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                n1 = v UV.! i1\n                n2 = v UV.! i2\n                ins = flip insert lset\n\n-- getAnswer :: Input -> Answer \n-- getAnswer (I (n, v)) | n == 1 = 0\n--                      | otherwise = m' ( (m' 2^n + 998244353)- (m' $ 1 + n + res  ) ) \n--   where res =  go 0 1 0 Data.Set.empty\n--         go !i1 !i2 !accum' !lset \n--           | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n--           | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n--           | otherwise = go i1 (i2+1) (  m' (accum'+ dScore))  (ins l)\n--           where l = lineFromPoint n1 n2 \n--                 dScore | l `member` lset = 0\n--                        | otherwise = 2^k - k - 1\n--                 (k:: Int) = case l of\n--                   L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n--                   L (False,_,_,_,_) -> UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n--                 n1 = v UV.! i1\n--                 n2 = v UV.! i2\n--                 ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\nnewtype Line = L (Bool, Int,Int,Int,Int)\n  deriving(Show)\n\ninstance Eq Line where\n  (==) (L (False,x,_,_,_)) (L (False,x',_,_,_)) = x == x'\n  (==) (L (True,a,a',b,b')) (L (True,aa,aa',bb,bb')) = Prelude.and [ a==aa,a'==aa',b==bb,b'==bb']\n  (==) _ _ = False\n\ninstance Ord Line where\n  compare (L (False,_,_,_,_)) (L (True,_,_,_,_)) = GT\n  compare (L (True,_,_,_,_)) (L (False,_,_,_,_)) = LT\n  compare (L (False,x,_,_,_)) (L (False,x',_,_,_)) = compare x x'\n  compare l l' = compare ab ab'\n    where coefficient (L ( True, x,y,z,a) ) = (x,y,z,a)\n          ab = coefficient l\n          ab' = coefficient l'\n\n\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n    L ( True , divA, divA' , divB, divB')    \n  | otherwise = L (False,x0,minBound,minBound,minBound)\n  where a = y1-y0\n        a' = x1-x0\n        b = (x1-x0)*y0 - (y1-y0)*x0\n        b' = x1-x0\n        factorA = gcd a a'\n        factorB = gcd b b'\n        (divA, divA') | a >= 0 && a' >= 0 = (a `div` factorA ,a `div` factorA) \n                      | a < 0 && a' >= 0 = (a `div` factorA ,a `div` factorA) \n                      | a >= 0 && a' < 0 = (-1 * a `div` factorA ,-1 * a `div` factorA) \n                      | a <  0 && a' < 0 = (-1 * a `div` factorA ,-1 * a `div` factorA) \n        (divB, divB') | b >= 0 && b' >= 0 = (b `div` factorB ,b `div` factorB) \n                      | b < 0 && b' >= 0 = (b `div` factorB ,b `div` factorB) \n                      | b >= 0 && b' < 0 = (-1 * b `div` factorB ,-1 * b `div` factorB) \n                      | b <  0 && b' < 0 = (-1 * b `div` factorB ,-1 * b `div` factorB) \n\n\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, V.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , V.convert input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | V.length v == 1 = 0\n                     | otherwise = case  (m' 2^n  )- (m' $ 1 + n + res  ) of \n                         res' -> if res' < 0 then res' + 998244353\n                                 else res'                         \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) ( m' (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) ( v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) ( v :: V.Vector (Int,Int) )  \n                n1 = v V.! i1\n                n2 = v V.! i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | n == 1 = 0\n                     | otherwise = m' ( (m' 2^n + 998244353)- (m' $ 1 + n + res  ) ) \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) (  m' (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                  L (False,_,_,_,_) -> UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                n1 = v UV.! i1\n                n2 = v UV.! i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\nnewtype Line = L (Bool, Int,Int,Int,Int)\n  deriving(Show, Ord)\n\ninstance Eq Line where\n  (==) (L (False,x,_,_,_)) (L (False,x',_,_,_)) = x == x'\n  (==) (L (True,a,a',b,b')) (L (True,aa,aa',bb,bb')) = Prelude.and [ a==aa,a'==aa',b==bb,b'==bb']\n  (==) _ _ = False\n\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n    L ( True , divA, divA' , divB, divB')    \n  | otherwise = L (False,x0,minBound,minBound,minBound)\n  where a = y1-y0\n        a' = x1-x0\n        b = (x1-x0)*y0 - (y1-y0)*x0\n        b' = x1-x0\n        factorA = gcd a a'\n        factorB = gcd b b'\n        (divA, divA') | a >= 0 && a' >= 0 = (a `div` factorA ,a `div` factorA) \n                      | a < 0 && a' >= 0 = (a `div` factorA ,a `div` factorA) \n                      | a >= 0 && a' < 0 = (-1 * a `div` factorA ,-1 * a `div` factorA) \n                      | a <  0 && a' < 0 = (-1 * a `div` factorA ,-1 * a `div` factorA) \n        (divB, divB') | a >= 0 && a' >= 0 = (a `div` factorB ,a `div` factorB) \n                      | a < 0 && a' >= 0 = (a `div` factorB ,a `div` factorB) \n                      | a >= 0 && a' < 0 = (-1 * a `div` factorB ,-1 * a `div` factorB) \n                      | a <  0 && a' < 0 = (-1 * a `div` factorB ,-1 * a `div` factorB) \n\n\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule ContestMain where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, V.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , V.convert input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | V.length v == 1 = 0\n                     | otherwise = case m' $ (m' 2^n  )- (m' $ 1 + n + res  ) of \n                         res' -> if res' < 0 then res' + 998244353\n                                 else res'                         \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) ( m' (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                n1 = v V.! i1\n                n2 = v V.! i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | UV.length v == 1 = 0\n                     | otherwise = (2^n `mod` 998244353 )- (1 + n + res) `mod` 998244353\n  where res =  go 0 1 0 Data.Set.empty\n        go i1 i2 accum' lset \n          | i1 == n-2 && i2 == n-1 = ( (accum'+dScore)`mod`998244353)\n          | i2 == n-1 = go (i1+1) (i1+2) ( (accum'+dScore)`mod`998244353) ( ins l )\n          | otherwise = go i1 (i2+1) ( (accum'+dScore)`mod`998244353) (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                n1 = v!i1\n                n2 = v!i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 2)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, V.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , V.convert input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | n == 1 = 0\n                     | otherwise = m' ( (m' 2^n + 998244353)- (m' $ 1 + n + res  ) ) \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) (  m' (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n1)) ( v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n1)) ( v :: V.Vector (Int,Int) )  \n                n1 = v V.! i1\n                n2 = v V.! i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, V.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , V.convert input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | V.length v == 1 = 0\n                     | otherwise = case  (m' 2^n  )- (m' $ 1 + n + res  ) of \n                         res' -> if res' < 0 then res' + 998244353\n                                 else res'                         \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) ( m' (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) ( v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) ( v :: V.Vector (Int,Int) )  \n                n1 = v V.! i1\n                n2 = v V.! i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | n == 1 = 0\n                     | otherwise =  ( ( 2^n )- ( 1 + n + res  ) ) \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = (  (accum'+ dScore)) \n          | i2 == n-1 = go (i1+1) (i1+2) (  (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) (   (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                  L (False,_,_,_,_) -> UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                n1 = v UV.! i1\n                n2 = v UV.! i2\n                ins = flip insert lset\n\n-- getAnswer :: Input -> Answer \n-- getAnswer (I (n, v)) | n == 1 = 0\n--                      | otherwise = m' ( (m' 2^n + 998244353)- (m' $ 1 + n + res  ) ) \n--   where res =  go 0 1 0 Data.Set.empty\n--         go !i1 !i2 !accum' !lset \n--           | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n--           | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n--           | otherwise = go i1 (i2+1) (  m' (accum'+ dScore))  (ins l)\n--           where l = lineFromPoint n1 n2 \n--                 dScore | l `member` lset = 0\n--                        | otherwise = 2^k - k - 1\n--                 (k:: Int) = case l of\n--                   L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n--                   L (False,_,_,_,_) -> UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n--                 n1 = v UV.! i1\n--                 n2 = v UV.! i2\n--                 ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\nnewtype Line = L (Bool, Int,Int,Int,Int)\n  deriving(Show)\n\ninstance Eq Line where\n  (==) (L (False,x,_,_,_)) (L (False,x',_,_,_)) = x == x'\n  (==) (L (True,a,a',b,b')) (L (True,aa,aa',bb,bb')) = Prelude.and [ a==aa,a'==aa',b==bb,b'==bb']\n  (==) _ _ = False\n\ninstance Ord Line where\n  compare (L (False,_,_,_,_)) (L (True,_,_,_,_)) = GT\n  compare (L (True,_,_,_,_)) (L (False,_,_,_,_)) = LT\n  compare (L (False,x,_,_,_)) (L (False,x',_,_,_)) = compare x x'\n  compare l l' = compare ab ab'\n    where coefficient (L ( True, x,y,z,a) ) = (x,y,z,a)\n          ab = coefficient l\n          ab' = coefficient l'\n\n\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n    L ( True , divA, divA' , divB, divB')    \n  | otherwise = L (False,x0,minBound,minBound,minBound)\n  where a = y1-y0\n        a' = x1-x0\n        b = (x1-x0)*y0 - (y1-y0)*x0\n        b' = x1-x0\n        factorA = gcd a a'\n        factorB = gcd b b'\n        (divA, divA') | a >= 0 && a' >= 0 = (a `div` factorA ,a `div` factorA) \n                      | a < 0 && a' >= 0 = (a `div` factorA ,a `div` factorA) \n                      | a >= 0 && a' < 0 = (-1 * a `div` factorA ,-1 * a `div` factorA) \n                      | a <  0 && a' < 0 = (-1 * a `div` factorA ,-1 * a `div` factorA) \n        (divB, divB') | b >= 0 && b' >= 0 = (b `div` factorB ,b `div` factorB) \n                      | b < 0 && b' >= 0 = (b `div` factorB ,b `div` factorB) \n                      | b >= 0 && b' < 0 = (-1 * b `div` factorB ,-1 * b `div` factorB) \n                      | b <  0 && b' < 0 = (-1 * b `div` factorB ,-1 * b `div` factorB) \n\n\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | UV.length v == 1 = 0\n                     | otherwise = case m' $ (m' 2^n  )- (m' $ 1 + n + res  ) of \n                         res' -> if res' < 0 then res' + 998244353\n                                 else res'                         \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ (m' dScore)) )\n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ (m' dScore)) ) ( ins l )\n          | otherwise = go i1 (i2+1) ( m' (accum'+ (m' dScore)) ) (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                n1 = v!i1\n                n2 = v!i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | n == 1 = 0\n                     | otherwise = m' ( (m' 2^n + 998244353)- (m' $ 1 + n + res  ) ) \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) (  m' (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                  L (False,_,_,_,_) -> UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                n1 = v UV.! i1\n                n2 = v UV.! i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\nnewtype Line = L (Bool, Int,Int,Int,Int)\n  deriving(Show,Ord)\n\ninstance Eq Line where\n  (==) (L (False,x,_,_,_)) (L (False,x',_,_,_)) = x == x'\n  (==) (L (True,a,a',b,b')) (L (True,aa,aa',bb,bb')) = Prelude.and [ a==aa,a'==aa',b==bb,b'==bb']\n  (==) _ _ = False\n\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n    L ( True , divA, divA' , divB, divB')    \n  | otherwise = L (False,x0,minBound,minBound,minBound)\n  where a = y1-y0\n        a' = x1-x0\n        b = (x1-x0)*y0 - (y1-y0)*x0\n        b' = x1-x0\n        factorA = gcd a a'\n        factorB = gcd b b'\n        (divA, divA') | a >= 0 && a' >= 0 = (a `div` factorA ,a `div` factorA) \n                      | a < 0 && a' >= 0 = (a `div` factorA ,a `div` factorA) \n                      | a >= 0 && a' < 0 = (-1 * a `div` factorA ,-1 * a `div` factorA) \n                      | a <  0 && a' < 0 = (-1 * a `div` factorA ,-1 * a `div` factorA) \n        (divB, divB') | b >= 0 && b' >= 0 = (b `div` factorB ,b `div` factorB) \n                      | b < 0 && b' >= 0 = (b `div` factorB ,b `div` factorB) \n                      | b >= 0 && b' < 0 = (-1 * b `div` factorB ,-1 * b `div` factorB) \n                      | b <  0 && b' < 0 = (-1 * b `div` factorB ,-1 * b `div` factorB) \n\n\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP    {-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, V.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , V.convert input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | V.length v == 1 = 0\n                     | otherwise = case m' $ (m' 2^n  )- (m' $ 1 + n + res  ) of \n                         res' -> if res' < 0 then res' + 998244353\n                                 else res'                         \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ (m' dScore)) )\n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ (m' dScore)) ) ( ins l )\n          | otherwise = go i1 (i2+1) ( m' (accum'+ (m' dScore)) ) (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                n1 = v V.! i1\n                n2 = v V.! i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n           #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule ContestMain where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, V.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , V.convert input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | V.length v == 1 = 0\n                     | otherwise = case m' $ (m' 2^n  )- (m' $ 1 + n + res  ) of \n                         res' -> if res' < 0 then res' + 998244353\n                                 else res'                         \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ (m' dScore)) )\n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ (m' dScore)) ) ( ins l )\n          | otherwise = go i1 (i2+1) ( m' (accum'+ (m' dScore)) ) (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                n1 = v V.! i1\n                n2 = v V.! i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | UV.length v == 1 = 0\n                     | otherwise = (2^n `mod` 998244353 )- (1 + n + res) `mod` 998244353\n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( (accum'+dScore)`mod`998244353)\n          | i2 == n-1 = go (i1+1) (i1+2) ( (accum'+dScore)`mod`998244353) ( ins l )\n          | otherwise = go i1 (i2+1) ( (accum'+dScore)`mod`998244353) (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                n1 = v!i1\n                n2 = v!i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 2)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, V.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , V.convert input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | V.length v == 1 = 0\n                     | otherwise = case m' $ (m' 2^n  )- (m' $ 1 + n + res  ) of \n                         res' -> if res' < 0 then res' + 998244353\n                                 else res'                         \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) ( m' (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                n1 = v V.! i1\n                n2 = v V.! i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\n-- getAnswer :: Input -> Answer \n-- getAnswer (I (n, v)) | n == 1 = 0\n--                      | otherwise = m' (   2^n - (  1 + n + res  ) ) \n--   where res =  go 0 1 0 Data.Set.empty\n--         go !i1 !i2 !accum' !lset \n--           | i1 == n-2 && i2 == n-1 = (  (accum'+ dScore))  \n--           | i2 == n-1 = go (i1+1) (i1+2) (  (accum'+ dScore))  ( ins l )\n--           | otherwise = go i1 (i2+1) (   (accum'+ dScore))  (ins l)\n--           where l = lineFromPoint n1 n2 \n--                 dScore | l `member` lset = 0\n--                        | otherwise = 2^k - k - 1\n--                 (k:: Int) = case l of\n--                   L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n--                   L (False,_,_,_,_) -> UV.length . UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n--                 n1 = v UV.! i1\n--                 n2 = v UV.! i2\n--                 ins = flip insert lset\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | n == 1 = 0\n                     | otherwise = m' ( (m' 2^n + 998244353)- (m' $ 1 + n + res  ) ) \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) (  m' (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                  L (False,_,_,_,_) -> UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                n1 = v UV.! i1\n                n2 = v UV.! i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\nnewtype Line = L (Bool, Int,Int,Int,Int)\n  deriving(Show)\n\ninstance Eq Line where\n  (==) (L (False,x,_,_,_)) (L (False,x',_,_,_)) = x == x'\n  (==) (L (True,a,a',b,b')) (L (True,aa,aa',bb,bb')) = Prelude.and [ a==aa,a'==aa',b==bb,b'==bb']\n  (==) _ _ = False\n\ninstance Ord Line where\n  compare (L (False,_,_,_,_)) (L (True,_,_,_,_)) = GT\n  compare (L (True,_,_,_,_)) (L (False,_,_,_,_)) = LT\n  compare (L (False,x,_,_,_)) (L (False,x',_,_,_)) = compare x x'\n  compare l l' = compare ab ab'\n    where coefficient (L ( True, x,y,z,a) ) = (x,y,z,a)\n          ab = coefficient l\n          ab' = coefficient l'\n\n\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n    L ( True , divA, divA' , divB, divB')    \n  | otherwise = L (False,x0,minBound,minBound,minBound)\n  where a = y1-y0\n        a' = x1-x0\n        b = (x1-x0)*y0 - (y1-y0)*x0\n        b' = x1-x0\n        factorA = gcd a a'\n        factorB = gcd b b'\n        (divA, divA') | a >= 0 && a' >= 0 = (a `div` factorA ,a' `div` factorA) \n                      | a < 0 && a' >= 0 = (a `div` factorA ,a' `div` factorA) \n                      | a >= 0 && a' < 0 = (-1 * a `div` factorA ,-1 * a' `div` factorA) \n                      | a <  0 && a' < 0 = (-1 * a `div` factorA ,-1 * a' `div` factorA) \n        (divB, divB')\n          | factorB == 0 = (0,0)\n          | b >= 0 && b' >= 0 = (b `div` factorB ,b' `div` factorB) \n          | b < 0 && b' >= 0 = (b `div` factorB ,b' `div` factorB) \n          | b >= 0 && b' < 0 = (-1 * b `div` factorB ,-1 * b' `div` factorB) \n          | b <  0 && b' < 0 = (-1 * b `div` factorB ,-1 * b' `div` factorB) \n\n\n\nm' :: Int -> Int \nm' i = i `rem`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | n == 1 = 0\n                     | otherwise =  ( ( 2^n )- ( 1 + n + res  ) ) \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = (  (accum'+ dScore)) \n          | i2 == n-1 = go (i1+1) (i1+2) (  (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) (   (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                  L (False,_,_,_,_) -> UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                n1 = v UV.! i1\n                n2 = v UV.! i2\n                ins = flip insert lset\n\n-- getAnswer :: Input -> Answer \n-- getAnswer (I (n, v)) | n == 1 = 0\n--                      | otherwise = m' ( (m' 2^n + 998244353)- (m' $ 1 + n + res  ) ) \n--   where res =  go 0 1 0 Data.Set.empty\n--         go !i1 !i2 !accum' !lset \n--           | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n--           | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n--           | otherwise = go i1 (i2+1) (  m' (accum'+ dScore))  (ins l)\n--           where l = lineFromPoint n1 n2 \n--                 dScore | l `member` lset = 0\n--                        | otherwise = 2^k - k - 1\n--                 (k:: Int) = case l of\n--                   L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n--                   L (False,_,_,_,_) -> UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n--                 n1 = v UV.! i1\n--                 n2 = v UV.! i2\n--                 ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\nnewtype Line = L (Bool, Int,Int,Int,Int)\n  deriving(Show)\n\ninstance Eq Line where\n  (==) (L (False,x,_,_,_)) (L (False,x',_,_,_)) = x == x'\n  (==) (L (True,a,a',b,b')) (L (True,aa,aa',bb,bb')) = Prelude.and [ a==aa,a'==aa',b==bb,b'==bb']\n  (==) _ _ = False\n\ninstance Ord Line where\n  compare (L (False,_,_,_,_)) (L (True,_,_,_,_)) = GT\n  compare (L (True,_,_,_,_)) (L (False,_,_,_,_)) = LT\n  compare (L (False,x,_,_,_)) (L (False,x',_,_,_)) = compare x x'\n  compare l l' = compare ab ab'\n    where coefficient (L ( True, x,y,z,a) ) = (x,y,z,a)\n          ab = coefficient l\n          ab' = coefficient l'\n\n\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n    L ( True , divA, divA' , divB, divB')    \n  | otherwise = L (False,x0,minBound,minBound,minBound)\n  where a = y1-y0\n        a' = x1-x0\n        b = (x1-x0)*y0 - (y1-y0)*x0\n        b' = x1-x0\n        factorA = gcd a a'\n        factorB = gcd b b'\n        (divA, divA') | a >= 0 && a' >= 0 = (a `div` factorA ,a `div` factorA) \n                      | a < 0 && a' >= 0 = (a `div` factorA ,a `div` factorA) \n                      | a >= 0 && a' < 0 = (-1 * a `div` factorA ,-1 * a `div` factorA) \n                      | a <  0 && a' < 0 = (-1 * a `div` factorA ,-1 * a `div` factorA) \n        (divB, divB') | b >= 0 && b' >= 0 = (b `div` factorB ,b `div` factorB) \n                      | b < 0 && b' >= 0 = (b `div` factorB ,b `div` factorB) \n                      | b >= 0 && b' < 0 = (-1 * b `div` factorB ,-1 * b `div` factorB) \n                      | b <  0 && b' < 0 = (-1 * b `div` factorB ,-1 * b `div` factorB) \n\n\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "import qualified Data.ByteString.Lazy.Char8 as B\nimport Data.List\nimport Data.Maybe\nimport qualified Data.Map as M\nimport qualified Data.Vector.Unboxed as V\n\nbsReadInts :: B.ByteString -> [Int]\nbsReadInts = map (fst . fromJust . B.readInt) . B.words\n\nvalM = 998244353\nprimes = [2, 3, 5, 7, 11, 13]\n\nprFact :: Int -> [Int]\nprFact n = map fst $ tail $ scanl (\\(_, y) p -> divppow p y) (1,n) primes \n\ndivppow :: Int -> Int -> (Int, Int)\ndivppow p y = f p 0 y\n  where\n    f p acc y | y `mod` p == 0 = f p (acc + 1) (y `div` p)\n              | otherwise      = (acc, y)\n\nmodAdd  x y = (x + y) `mod` valM\nmodMult x y = (x * y) `mod` valM\n\nmodFacted :: [Int] -> Int\nmodFacted pows = (foldl' modMult 1 $ zipWith modPow primes pows) `mod` valM\n\nmodPow :: Int -> Int -> Int\nmodPow p r = (iterate (modMult p) 1) !! r\n\ncombiSeq valN = scanr op [0,0,0,0,0,0] [4..valN]\n  where op n pows = let powA = prFact n\n                        powB = prFact (valN - n + 1)\n                    in zipWith3 (\\x a b -> x + a - b) pows powA powB\n\nnumPol valN = (sum $ map modFacted $ combiSeq valN) `mod` valM\n              \n\ntype MyMap = M.Map (Int, Int) (Maybe Int)\ntype Vline = V.Vector (Int, Int)\n\nsolve :: Int -> [[Int]] -> Int\nsolve 1 _ = 0\nsolve 2 _ = 0\nsolve valN pts = (numPol valN - sumPenalties + valM) `mod` valM\n  where\n    vline :: Vline\n    vline = V.fromList $ map (\\[x,y] -> (x,y)) pts\n\n    lmap :: MyMap\n    lmap = foldr op M.empty [0 .. valN - 1]\n\n    op :: Int -> MyMap -> MyMap\n    op i lm = foldr op2 (foldr op1 lm zjk) zj\n      where\n        zj = [i+1 .. valN-1]\n        zjk = [(j,k) | j <- [i+1 .. valN-1], k <- [j+1 .. valN-1]]\n\n        op1 :: (Int,Int) -> MyMap -> MyMap\n        op1 (j,k) lm =\n          if onALine i j k\n          then M.insert (i,k) Nothing\n                 (M.insert (i,j) Nothing\n                 (M.adjust (fmap (+ 1)) (j,k) lm))\n          else lm\n\n        op2 :: Int -> MyMap -> MyMap\n        op2 j lm = M.alter (maybe (Just (Just 0)) Just) (i,j) lm\n\n    onALine i j k = let (xi, yi) = vline V.! i\n                        (xj, yj) = vline V.! j\n                        (xk, yk) = vline V.! k\n                        (x1, y1) = (xi - xk, yi - yk)\n                        (x2, y2) = (xj - xk, yj - yk)\n                    in x1 * y2 == x2 * y1\n\n    sumPenalties = f 0 llist penalties'\n      where llist@(n0 : _) = sort $ catMaybes $ map snd $ M.toList lmap\n            penalties' = drop n0 penalties\n            f acc ls@(n:_) ps@(p:_) =\n              let (ls1, ls2) = span (== n) ls\n                  nextAcc = acc + (length ls1) * p\n              in case ls2 of\n              []    -> nextAcc\n              m : _ -> f nextAcc ls2 nextPs\n                where nextPs = drop (m - n) ps\n\npenalties :: [Int]\npenalties = scanl modAdd 0 $ map penaltyEach [1..]\n\npenaltyEach :: Int -> Int\npenaltyEach n = (sum $ zipWith modMult [n, n-1 .. 1] p2s) `mod` valM\n  where p2s = iterate (\\x -> modMult 2 x) 1 \n\n\n\n\n\nmain :: IO ()\nmain = do\n  conts <- B.getContents\n  let [n] : iss = map bsReadInts (B.lines conts)\n      answer = solve n iss\n  putStrLn (show answer)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | n == 1 = 0\n                     | otherwise = m' (  2^n - ( 1 + n + res  ) ) \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = (  (accum'+ dScore))  \n          | i2 == n-1 = go (i1+1) (i1+2) (  (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) (   (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                  L (False,_,_,_,_) -> UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n                n1 = v UV.! i1\n                n2 = v UV.! i2\n                ins = flip insert lset\n\n-- getAnswer :: Input -> Answer \n-- getAnswer (I (n, v)) | n == 1 = 0\n--                      | otherwise = m' ( (m' 2^n + 998244353)- (m' $ 1 + n + res  ) ) \n--   where res =  go 0 1 0 Data.Set.empty\n--         go !i1 !i2 !accum' !lset \n--           | i1 == n-2 && i2 == n-1 = ( m' (accum'+ dScore)) \n--           | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ dScore))  ( ins l )\n--           | otherwise = go i1 (i2+1) (  m' (accum'+ dScore))  (ins l)\n--           where l = lineFromPoint n1 n2 \n--                 dScore | l `member` lset = 0\n--                        | otherwise = 2^k - k - 1\n--                 (k:: Int) = case l of\n--                   L (True,_,_,_,_) -> (1+). UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n--                   L (False,_,_,_,_) -> UV.length .UV.filter  ( == True) $ UV.map ( (l==) . (lineFromPoint n1)) ( v :: UV.Vector (Int,Int) )  \n--                 n1 = v UV.! i1\n--                 n2 = v UV.! i2\n--                 ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\nnewtype Line = L (Bool, Int,Int,Int,Int)\n  deriving(Show)\n\ninstance Eq Line where\n  (==) (L (False,x,_,_,_)) (L (False,x',_,_,_)) = x == x'\n  (==) (L (True,a,a',b,b')) (L (True,aa,aa',bb,bb')) = Prelude.and [ a==aa,a'==aa',b==bb,b'==bb']\n  (==) _ _ = False\n\ninstance Ord Line where\n  compare (L (False,_,_,_,_)) (L (True,_,_,_,_)) = GT\n  compare (L (True,_,_,_,_)) (L (False,_,_,_,_)) = LT\n  compare (L (False,x,_,_,_)) (L (False,x',_,_,_)) = compare x x'\n  compare l l' = compare ab ab'\n    where coefficient (L ( True, x,y,z,a) ) = (x,y,z,a)\n          ab = coefficient l\n          ab' = coefficient l'\n\n\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n    L ( True , divA, divA' , divB, divB')    \n  | otherwise = L (False,x0,minBound,minBound,minBound)\n  where a = y1-y0\n        a' = x1-x0\n        b = (x1-x0)*y0 - (y1-y0)*x0\n        b' = x1-x0\n        factorA = gcd a a'\n        factorB = gcd b b'\n        (divA, divA') | a >= 0 && a' >= 0 = (a `div` factorA ,a' `div` factorA) \n                      | a < 0 && a' >= 0 = (a `div` factorA ,a' `div` factorA) \n                      | a >= 0 && a' < 0 = (-1 * a `div` factorA ,-1 * a' `div` factorA) \n                      | a <  0 && a' < 0 = (-1 * a `div` factorA ,-1 * a' `div` factorA) \n        (divB, divB')\n          | factorB == 0 = (0,0)\n          | b >= 0 && b' >= 0 = (b `div` factorB ,b' `div` factorB) \n          | b < 0 && b' >= 0 = (b `div` factorB ,b' `div` factorB) \n          | b >= 0 && b' < 0 = (-1 * b `div` factorB ,-1 * b' `div` factorB) \n          | b <  0 && b' < 0 = (-1 * b `div` factorB ,-1 * b' `div` factorB) \n\n\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, V.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , V.convert input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | n == 1 = 0\n                     | otherwise = m' ( (m' 2^n + 998244353)- (m' $ 1 + n + res  ) ) \n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( (accum'+ dScore)) \n          | i2 == n-1 = go (i1+1) (i1+2) (  (accum'+ dScore))  ( ins l )\n          | otherwise = go i1 (i2+1) (  (accum'+ dScore))  (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) ( v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) ( v :: V.Vector (Int,Int) )  \n                n1 = v V.! i1\n                n2 = v V.! i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n-- extension section\n{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE BangPatterns      #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n-- not supported extension\n--{-# LANGUAGE Strict, StrictData #-}\n\n\nmodule Main where\n\n-- @@@@@@@@@@@@@@@@@--\n-- import section   --\n-- @@@@@@@@@@@@@@@@@--\n--    import A.B.C( function name )  ...\n-- or import A.B.C \n\n--\nimport           Prelude hiding(\n  getLine,\n  getContents,\n  lines,\n  words\n  )\n\n-- standard library\nimport           Control.Monad.ST\nimport           Control.Applicative\nimport           Data.Char\nimport           Data.Ratio\n\n\n-- bytestring\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\n\n\n-- containers\nimport           Data.Set\n\n-- deepseq\n\n\n-- regex-posix\n\n\n-- text\nimport           Data.Text.Lazy.IO as TIO\nimport           Data.Text.Lazy as T\nimport           Data.Text.Lazy.Read as TR\n\n-- import Data.Text.IO as TIO\n-- import Data.Text as T\n-- import Data.Text.Read as TR\n\n\n\n-- unordered-containers\n\n\n-- vectors\nimport qualified Data.Vector as V\nimport           Data.Vector.Unboxed as UV\nimport           Data.Vector.Unboxed.Mutable as MV\n\n\n-- mtl\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- main section     --\n-- @@@@@@@@@@@@@@@@@--\n\nmain :: IO ()\nmain = do\n  input <- getInput\n  Prelude.putStr . show . getAnswer $ input \n\n-- main :: IO()\n-- main = do\n--   answer <- getInputandanser\n--   putStr . show $ answer\n\n\n-- @@@@@@@@@@@@@@@@@@@@@--\n-- I/O DataType section --\n-- @@@@@@@@@@@@@@@@@@@@@--\ndata Input = I (Int, UV.Vector (Int, Int) )\n  deriving(Show)\n\ntype Answer = Int\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- answerSection    --\n-- @@@@@@@@@@@@@@@@@--\ngetInput :: IO Input\ngetInput = do\n  n <- (UV.!0) <$> intVectorFromLine 1 \n  input <- generatePairVectorFromLine n\n  return $ I (n , input)\n\ngetAnswer :: Input -> Answer \ngetAnswer (I (n, v)) | UV.length v == 1 = 0\n                     | otherwise = m' $ (m' 2^n  )- (m' $ 1 + n + res  )\n  where res =  go 0 1 0 Data.Set.empty\n        go !i1 !i2 !accum' !lset \n          | i1 == n-2 && i2 == n-1 = ( m' (accum'+ (m' dScore)) )\n          | i2 == n-1 = go (i1+1) (i1+2) ( m' (accum'+ (m' dScore)) ) ( ins l )\n          | otherwise = go i1 (i2+1) ( m' (accum'+ (m' dScore)) ) (ins l)\n          where l = lineFromPoint n1 n2 \n                dScore | l `member` lset = 0\n                       | otherwise = 2^k - k - 1\n                (k:: Int) = case l of\n                  L (_,_) -> (1+). V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                  L0 _ -> V.length .V.filter  ( == True) $ V.map ( (l==) . (lineFromPoint n2)) (convert v :: V.Vector (Int,Int) )  \n                n1 = v!i1\n                n2 = v!i2\n                ins = flip insert lset\n\ngetInputAndAnser :: IO Answer\ngetInputAndAnser = undefined\n\n\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n-- question unique section    --\n-- @@@@@@@@@@@@@@@@@@@@@@@@@@--\n\ndata Line = L (Ratio Int, Ratio Int) | L0 Int\n  deriving(Show, Eq, Ord)\n\nlineFromPoint :: (Int,Int) -> (Int,Int) -> Line\nlineFromPoint (x0,y0) (x1,y1)\n  | x0 /= x1 =\n      L ( (y1-y0) % (x1-x0) , ( (x1-x0)*y0 - (y1-y0)*x0) % (x1-x0) )\n  | otherwise = L0 x0\n\nm' :: Int -> Int \nm' i = i `mod`998244353\n\n\n-- @@@@@@@@@@@@@@@@@--\n-- util section     --\n-- @@@@@@@@@@@@@@@@@--\n\n-- standard Input Function\ngLine :: IO Text\ngLine = getLine\n\ngContents :: IO Text\ngContents = getContents\n\n-- intVectorFromline 5  (\"1 2 3 4 5\") -> vector <1,2,3,4,5> \nintVectorFromLine ::Int -> IO ( Vector Int )\nintVectorFromLine n = UV.unfoldrN n (B.readInt.B.dropWhile isSpace) <$> B.getLine\n\npairFromLine :: IO (Int,Int)\npairFromLine = do\n  v <- intVectorFromLine 2\n  return ( v ! 0, v ! 1)\n\ngeneratePairVectorFromLine :: Int -> IO ( Vector (Int, Int) )\ngeneratePairVectorFromLine n = generateM n (const pairFromLine)\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nhwll xy[N_MAX];\n\nlinell lines[N_MAX];\null rev[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 1; i <= n; i++) {\n\t\trev[i * (i - 1) / 2] = i;\n\t}\n\n\tqsort(xy, n, sizeof(hwll), phwllREVcomp);\n\n\tki = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tsll x1 = xy[i].a, y1 = xy[i].b, x2 = xy[j].a, y2 = xy[j].b;\n\t\t\tlinell l = {\n\t\t\t\t{y2 - y1, x2 - x1},\n\t\t\t\t{y1 * x2 - y2 * x1, x2 - x1}\n\t\t\t};\n\n\t\t\tull g;\n\t\t\tg = gcd(sdiff(l.a.a, 0), l.a.b);\n\t\t\tif (g) {\n\t\t\t\tl.a.a /= g;\n\t\t\t\tl.a.b /= g;\n\t\t\t}\n\t\t\tg = gcd(sdiff(l.b.a, 0), l.b.b);\n\t\t\tif (g) {\n\t\t\t\tl.b.a /= g;\n\t\t\t\tl.b.b /= g;\n\t\t\t}\n\n\t\t\tlines[ki++] = l;\n\t\t}\n\t}\n\tfflush(stdout);\n\tqsort(lines, ki, sizeof(linell), pquadcomp);\n\n\tresult = (bitpow(2, n, FOD) + FOD - 1 - n) % FOD;\n\n\ti = 0;\n\twhile (i < ki) {\n\t\tj = i;\n\t\twhile (i < ki && !pquadcomp(lines + i, lines + j)) i++;\n\n\t\tull x = rev[i - j];\n\t\tresult = (result - bitpow(2, x, FOD) + FOD + 1 + x) % FOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\treturn 0;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%llu\", &n, &m);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t}\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nhwll xy[N_MAX];\n// sll table[1000][1000];\n\n\n\nlinell lines[N_MAX];\null rev[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 1; i <= n; i++) {\n\t\trev[i * (i - 1) / 2] = i;\n\t}\n\n\tqsort(xy, n, sizeof(hwll), phwllABcomp);\n\n\tki = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tsll x1 = xy[i].a, y1 = xy[i].b, x2 = xy[j].a, y2 = xy[j].b;\n\t\t\tlinell l = {\n\t\t\t\t{y2 - y1, x2 - x1},\n\t\t\t\t{y1 * x2 - y2 * x1, x2 - x1}\n\t\t\t};\n\t\t\t// printf(\"%lld %lld %lld %lld ->\\t\", l.a.a, l.a.b, l.b.a, l.b.b);\n\n\t\t\tif (x1 == x2) {\n\t\t\t\tl.a.a = 1;\n\t\t\t\tl.b.a = x1;\n\t\t\t} else {\n\t\t\t\tsll g;\n\t\t\t\tg = gcd((ull)sdiff(l.a.a, 0), l.a.b);\n\t\t\t\t// printf(\"(g1 %lld) \", g);\n\t\t\t\tl.a.a /= g;\n\t\t\t\tl.a.b /= g;\n\t\t\t\tg = gcd((ull)sdiff(l.b.a, 0), l.b.b);\n\t\t\t\t// printf(\"(g2 %lld) \", g);\n\t\t\t\tl.b.a /= g;\n\t\t\t\tl.b.b /= g;\n\t\t\t}\n\n\t\t\tlines[ki++] = l;\n\t\t\t// printf(\"%lld %lld %lld %lld\\n\", l.a.a, l.a.b, l.b.a, l.b.b);\n\t\t}\n\t}\n\tfflush(stdout);\n\tqsort(lines, ki, sizeof(linell), pquadcomp);\n\n\tresult = (bitpow(2, n, FOD) + FOD - 1 - n) % FOD;\n\n\ti = 0;\n\twhile (i < ki) {\n\t\tj = i;\n\t\twhile (i < ki && !pquadcomp(lines + i, lines + j)) i++;\n\n\t\tull x = rev[i - j];\n\t\tresult = (result + FOD - bitpow(2, x, FOD) + 1 + x) % FOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nhwll xy[N_MAX];\n// sll table[1000][1000];\n\n\n\nlinell lines[N_MAX];\null rev[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 1; i <= n; i++) {\n\t\trev[i * (i - 1) / 2] = i;\n\t}\n\n\tqsort(xy, n, sizeof(hwll), phwllABcomp);\n\n\tki = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tsll x1 = xy[i].a, y1 = xy[i].b, x2 = xy[j].a, y2 = xy[j].b;\n\t\t\tlinell l = {\n\t\t\t\t{y2 - y1, x2 - x1},\n\t\t\t\t{y1 * x2 - y2 * x1, x2 - x1}\n\t\t\t};\n\n\t\t\tull g;\n\t\t\tg = gcd(sdiff(l.a.a, 0), l.a.b);\n\t\t\tif (g) {\n\t\t\t\tl.a.a /= g;\n\t\t\t\tl.a.b /= g;\n\t\t\t}\n\t\t\tif (!l.b.b) {\n\t\t\t\tl.b.a = x1;\n\t\t\t} else {\n\t\t\t\tg = gcd(sdiff(l.b.a, 0), l.b.b);\n\t\t\t\tif (g) {\n\t\t\t\t\tl.b.a /= g;\n\t\t\t\t\tl.b.b /= g;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlines[ki++] = l;\n\t\t}\n\t}\n\tfflush(stdout);\n\tqsort(lines, ki, sizeof(linell), pquadcomp);\n\n\tresult = (bitpow(2, n, FOD) + FOD - 1 - n) % FOD;\n\n\ti = 0;\n\twhile (i < ki) {\n\t\tj = i;\n\t\twhile (i < ki && !pquadcomp(lines + i, lines + j)) i++;\n\n\t\tull x = rev[i - j];\n\t\tresult = (result + FOD - bitpow(2, x, FOD) + 1 + x) % FOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nhwll xy[N_MAX];\n// sll table[1000][1000];\n\n\n\nlinell lines[N_MAX];\null rev[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 1; i <= n; i++) {\n\t\trev[i * (i - 1) / 2] = i;\n\t}\n\n\tqsort(xy, n, sizeof(hwll), phwllABcomp);\n\n\tki = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tsll x1 = xy[i].a, y1 = xy[i].b, x2 = xy[j].a, y2 = xy[j].b;\n\t\t\tlinell l = {\n\t\t\t\t{y2 - y1, x2 - x1},\n\t\t\t\t{y1 * x2 - y2 * x1, x2 - x1}\n\t\t\t};\n\n\t\t\tull g;\n\t\t\tg = gcd(sdiff(l.a.a, 0), l.a.b);\n\t\t\tif (g) {\n\t\t\t\tl.a.a /= g;\n\t\t\t\tl.a.b /= g;\n\t\t\t}\n\t\t\tg = gcd(sdiff(l.b.a, 0), l.b.b);\n\t\t\tif (g) {\n\t\t\t\tl.b.a /= g;\n\t\t\t\tl.b.b /= g;\n\t\t\t}\n\n\t\t\tlines[ki++] = l;\n\t\t}\n\t}\n\tfflush(stdout);\n\tqsort(lines, ki, sizeof(linell), pquadcomp);\n\n\tresult = (bitpow(2, n, FOD) + FOD - 1 - n) % FOD;\n\n\ti = 0;\n\twhile (i < ki) {\n\t\tj = i;\n\t\twhile (i < ki && !pquadcomp(lines + i, lines + j)) i++;\n\n\t\tull x = rev[i - j];\n\t\tif (!x) abort();\n\t\tresult = (result + FOD - bitpow(2, x, FOD) + 1 + x) % FOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <bits/stdc++.h>\n#define maxn 100010\n#define ll long long\nusing namespace std;\n\nconst ll mod=998244353;\n\nll n,R,B,G,RB,RG,BG,ans=1;\n\nchar s[maxn*3];\n\nint main(){\n\tscanf(\"%lld%s\",&n,s+1);\n\tfor(int i=1;i<=n;i++) ans*=i,ans%=mod;\n\tfor(int i=1;i<=n*3;i++){\n\t\tif(s[i]=='R'){\n\t\t\tif(BG) ans*=BG,BG--;\n\t\t\telse if(B) ans*=B,B--,RB++;\n\t\t\telse if(G) ans*=G,G--,RG++;\n\t\t\telse R++;\n\t\t}\n\t\telse if(s[i]=='B'){\n\t\t\tif(RG) ans*=RG,RG--;\n\t\t\telse if(R) ans*=R,R--,RB++;\n\t\t\telse if(G) ans*=G,G--,BG++;\n\t\t\telse B++;\n\t\t}\n\t\telse if(s[i]=='G'){\n\t\t\tif(RB) ans*=RB,RB--;\n\t\t\telse if(R) ans*=R,R--,RG++;\n\t\t\telse if(B) ans*=B,B--,BG++;\n\t\t\telse G++;\n\t\t}\n\t\tans%=mod;\n\t}\n\tprintf(\"%lld\",ans%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define MOD 998244353\n\nll n;\nll x[210],y[210];\nll temp[210];\n\nint main(){\n\tscanf(\"%lld\",&n);\n\trep(i,0,n)scanf(\"%lld%lld\",x+i,y+i);\n\trep(i,0,n)rep(j,i+1,n){\n\t\tll c=0;\n\t\trep(k,0,n){\n\t\t\tif((x[i]-x[j])*(y[j]-y[k])==(x[j]-x[k])*(y[i]-y[j]))c++;\n\t\t}\n\t\ttemp[c]++;\n\t}\n\tll ans=pom(2,n,MOD)-1-n;\n\trep(i,2,n+1)if(temp[i]){\n\t\tll cnt=temp[i]*2/i/(i-1);\n\t\t//ちょうどi点乗っている直線がcnt本\n\t\tans=(ans-(pom(2,i,MOD)-i-1)*cnt)%MOD;\n\t}\n\tprintf(\"%lld\\n\",(ans+MOD)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nhwll xy[N_MAX];\n// sll table[1000][1000];\n\n\n\nlinell lines[N_MAX];\null rev[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 1; i <= n; i++) {\n\t\trev[i * (i - 1) / 2] = i;\n\t}\n\n\tqsort(xy, n, sizeof(hwll), phwllABcomp);\n\n\tki = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tsll x1 = xy[i].a, y1 = xy[i].b, x2 = xy[j].a, y2 = xy[j].b;\n\t\t\tlinell l = {\n\t\t\t\t{y2 - y1, x2 - x1},\n\t\t\t\t{y1 * x2 - y2 * x1, x2 - x1}\n\t\t\t};\n\n\t\t\tif (x1 == x2) {\n\t\t\t\tl.a.a = 1;\n\t\t\t\tl.b.a = x1;\n\t\t\t} else {\n\t\t\t\tull g;\n\t\t\t\tg = gcd(sdiff(l.a.a, 0), l.a.b);\n\t\t\t\tif (g) {\n\t\t\t\t\tl.a.a /= g;\n\t\t\t\t\tl.a.b /= g;\n\t\t\t\t}\n\t\t\t\tg = gcd(sdiff(l.b.a, 0), l.b.b);\n\t\t\t\tif (g) {\n\t\t\t\t\tl.b.a /= g;\n\t\t\t\t\tl.b.b /= g;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlines[ki++] = l;\n\t\t}\n\t}\n\tfflush(stdout);\n\tqsort(lines, ki, sizeof(linell), pquadcomp);\n\n\tresult = (bitpow(2, n, FOD) + FOD - 1 - n) % FOD;\n\n\ti = 0;\n\twhile (i < ki) {\n\t\tj = i;\n\t\twhile (i < ki && !pquadcomp(lines + i, lines + j)) i++;\n\n\t\tull x = rev[i - j];\n\t\tresult = (result + FOD - bitpow(2, x, FOD) + 1 + x) % FOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nhwll xy[N_MAX];\n// sll table[1000][1000];\n\n\n\nlinell lines[N_MAX];\null rev[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 1; i <= n; i++) {\n\t\trev[i * (i - 1) / 2] = i;\n\t}\n\n\tqsort(xy, n, sizeof(hwll), phwllABcomp);\n\n\tki = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tsll x1 = xy[i].a, y1 = xy[i].b, x2 = xy[j].a, y2 = xy[j].b;\n\t\t\tlinell l = {\n\t\t\t\t{y2 - y1, x2 - x1},\n\t\t\t\t{y1 * x2 - y2 * x1, x2 - x1}\n\t\t\t};\n\n\t\t\tull g;\n\t\t\tg = gcd(sdiff(l.a.a, 0), l.a.b);\n\t\t\tif (g) {\n\t\t\t\tl.a.a /= g;\n\t\t\t\tl.a.b /= g;\n\t\t\t}\n\t\t\tg = gcd(sdiff(l.b.a, 0), l.b.b);\n\t\t\tif (g) {\n\t\t\t\tl.b.a /= g;\n\t\t\t\tl.b.b /= g;\n\t\t\t}\n\n\t\t\tlines[ki++] = l;\n\t\t}\n\t}\n\tfflush(stdout);\n\tqsort(lines, ki, sizeof(linell), pquadcomp);\n\n\tresult = (bitpow(2, n, FOD) + FOD - 1 - n) % FOD;\n\n\ti = 0;\n\twhile (i < ki) {\n\t\tj = i;\n\t\twhile (i < ki && !pquadcomp(lines + i, lines + j)) i++;\n\n\t\tull x = rev[i - j];\n\t\tresult = (result + FOD - bitpow(2, x, FOD) + 1 + x) % FOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 998244353\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\ntypedef struct{\n  long long xz;\n  long long yz;\n}point;\n\npoint vector_plus(point a,point b){\n  point r;\n  r.xz=a.xz+b.xz;\n  r.yz=a.yz+b.yz;\n  return r;\n}\n\npoint vector_minus(point a,point b){\n  point r;\n  r.xz=a.xz-b.xz;\n  r.yz=a.yz-b.yz;\n  return r;\n}\n\n//naiseki\nlong long dotproduct(point a,point b){\n  return a.xz*b.xz+a.yz*b.yz;\n}\n\n//gaiseki\nlong long crossproduct(point a,point b){\n  return a.xz*b.yz-a.yz*b.xz;\n}\n\nlong long factorial[256];\n\nvoid cfact(){\n    long long i;\n    factorial[0]=1;\n    factorial[1]=1;\n    for(i=2;i<256;i++){\n        factorial[i]=factorial[i-1]*i;\n        factorial[i]%=mod;\n    }\n}\n\nlong long power(long long a, long long b){\n\tlong long x = 1, y = a;\n\twhile (b > 0){\n\t\tif(b%2){\n\t\t\tx = (x*y)%mod;\n\t\t}\n\t\ty = (y*y)%mod;\n\t\tb /= 2;\n\t}\n\treturn x%mod;\n}\n\nlong long modular_inverse(long long n){\n\treturn power(n, mod-2);\n}\n\nlong long calcnCr(long long n,long long k){\n\treturn (factorial[n]*(modular_inverse(factorial[k])*modular_inverse(factorial[n-k])%mod))%mod;\n}\n\nint main(void){\n    cfact();\n    long long i,j,k,n,r,v,w,c;\n    point pts[256],o,vb;\n    scanf(\"%lld\",&n);\n    r=power(2,n);\n    r+=mod;\n    r-=(n+1);\n    r%=mod;\n    for(i=0;i<n;i++){\n      scanf(\"%lld%lld\",&pts[i].xz,&pts[i].yz);\n    }\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n        o=pts[i];\n        v=-1;\n        w=-1;\n        c=0;\n        vb=vector_minus(pts[j],pts[i]);\n        for(k=n-1;k>=0;k--){\n          if(crossproduct(vector_minus(pts[k],o),vb)==0){\n            c++;\n            w=v;v=k;\n          }\n        }\n        if(v!=i || w!=j){continue;}\n        //printf(\"%lld %lld %lld\\n\",i,j,c);\n        r+=mod;\n        r-=power(2,c);\n        r+=(c+1);\n        r%=mod;\n      }\n    }\n    printf(\"%lld\\n\",r);\n    return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int[][] p = ntable(n, 2);\n    int mod = 998244353;\n\n    long ret = modpow(2, n, mod);\n    Map<Long, Set<Integer>> map = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        long a = p[i][1] - p[j][1];\n        long b = p[i][0] - p[j][0];\n        long c = p[i][0] * (p[j][1] - p[i][1]) - p[i][1] * (p[j][0] - p[i][0]);\n        long gcd = gcd(a, gcd(b, c));\n\n        long hash = (a * 100000L * 100000L + b * 100000L + c) / gcd;\n        if (hash < 0) hash = -hash;\n        if (!map.containsKey(hash)) map.put(hash, new HashSet<>());\n        map.get(hash).add(i);\n        map.get(hash).add(j);\n      }\n    }\n    for (Set<Integer> v : map.values()) {\n      ret += mod - modpow(2, v.size(), mod) + v.size() + 1;\n      ret %= mod;\n    }\n    ret += mod - n - 1;\n    ret %= mod;\n    out.println(ret);\n  }\n\n  public static long gcd(long a, long b) {\n    if (a > b) {\n      long tmp = a;\n      a = b;\n      b = tmp;\n    }\n    while (a != 0) {\n      long c = a;\n      a = b % c;\n      b = c;\n    }\n    return b;\n  }\n\n  public static long modpow(long a, long n, long mod) {\n    long ret = 1;\n    long mul = a;\n    for (; n > 0; n >>>= 1) {\n      if ((n & 1) == 1) {\n        ret = (ret * mul) % mod;\n      }\n      mul = (mul * mul) % mod;\n    }\n    return ret;\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            LineGeometry.Point[] points = new LineGeometry.Point[n];\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt();\n                int y = in.nextInt();\n                points[i] = new LineGeometry.Point(x, y);\n            }\n\n            Modulo modulo = new Modulo(998244353);\n            long ans = modulo.pow(2, n);\n            ans = modulo.sub(ans, n + 1);\n            boolean[][] calced = new boolean[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (calced[i][j]) continue;\n\n                    int count = 0;\n                    List<Integer> list = new ArrayList<>();\n                    for (int k = 0; k < n; k++) {\n                        if (LineGeometry.orientation(points[i], points[j], points[k]) == 0) {\n                            list.add(k);\n                            count++;\n                        }\n                    }\n                    for (int k = 0; k < list.size(); k++) {\n                        for (int l = k + 1; l < list.size(); l++) {\n                            calced[k][l] = true;\n                        }\n                    }\n\n                    long tmp = modulo.pow(2, count);\n                    tmp = modulo.sub(tmp, count + 1);\n                    ans -= tmp;\n                }\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static class Modulo {\n        long m;\n\n        public Modulo(long m) {\n            this.m = m;\n        }\n\n        public long sub(long a, long b) {\n            return (a - b + m) % m;\n        }\n\n        public long pow(long a, long x) {\n            long ans = 1;\n            while (x > 0) {\n                if ((x & 1) != 0) {\n                    ans = (ans * a) % m;\n                }\n                x >>= 1;\n                a = (a * a) % m;\n            }\n            return ans;\n        }\n\n    }\n\n    static class LineGeometry {\n        static final double EPS = 1e-10;\n\n        public static int sign(double a) {\n            return a < -EPS ? -1 : a > EPS ? 1 : 0;\n        }\n\n        public static int orientation(LineGeometry.Point a, LineGeometry.Point b, LineGeometry.Point c) {\n            LineGeometry.Point AB = b.minus(a);\n            LineGeometry.Point AC = c.minus(a);\n            return sign(AB.cross(AC));\n        }\n\n        public static class Point implements Comparable<LineGeometry.Point> {\n            public double x;\n            public double y;\n\n            public Point(double x, double y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            public LineGeometry.Point minus(LineGeometry.Point b) {\n                return new LineGeometry.Point(x - b.x, y - b.y);\n            }\n\n            public double cross(LineGeometry.Point b) {\n                return x * b.y - y * b.x;\n            }\n\n\n            public int compareTo(LineGeometry.Point o) {\n                // return Double.compare(Math.atan2(y, x), Math.atan2(o.y, o.x));\n                return Double.compare(x, o.x) != 0 ? Double.compare(x, o.x) : Double.compare(y, o.y);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader in;\n        StringTokenizer tok;\n\n        public String nextString() {\n            while (!tok.hasMoreTokens()) {\n                try {\n                    tok = new StringTokenizer(in.readLine(), \" \");\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n            }\n            return tok.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n        public InputReader(InputStream inputStream) {\n            in = new BufferedReader(new InputStreamReader(inputStream));\n            tok = new StringTokenizer(\"\");\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.HashMap;\n\nclass Main{\n\n    static long C=20000*20000;\n    static long B=20000;\n    static long A=1;\n\n    static long baseC = (long)1e8;\n    static long baseB = (long)1e4;\n    static long baseA = (long)1e4;\n\n    static long mod =998244353;\n\n    static int gcd(int x, int y){\n        if(x*y==0)return 1;\n        if(x%y==0)return x/y;\n        return gcd(y, x%y);\n    }\n\n    static long getVal(int a, int b,int c){\n        int m = gcd(a, gcd(Math.abs(b),Math.abs(c)));\n        a/=m; b/=m; c/=m;\n        return ((long)c+baseC)*C + ((long)b + baseB)*B +((long)a + baseA)*A;\n    }\n\n    static long getLine(int x1,int y1,int x2, int y2){\n        if(x1==x2)return getVal(1, 0, -x1);\n        \n        if(y2-y1<0){\n            int tmp = y1;y1=y2;y2=tmp;\n            tmp=x1;x1=x2;x2=tmp;\n        }else if(y2-y1==0 && x2-x1<0){\n            int tmp = x1;x1=x2;x2=tmp;\n        }\n        return getVal(y2-y1, x2-x1, y2*x1-y1*x2);\n    }\n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        int[] x = new int[N];\n        int[] y = new int[N];\n        for(int i=0;i<N;++i){\n            x[i]=scan.nextInt();\n            y[i]= scan.nextInt();\n        }\n        long two[] = new long[N+1];\n        two[0]=1;\n        for(int i=1;i<=N;++i)two[i]=(two[i-1]*2)%mod;\n\n        long ans = two[N];\n        ans = (ans - (N*(N-1)/2) - N -1 +mod)%mod;\n\n        Set<Long> used = new HashSet<>();\n        for(int i=0;i<N;++i){\n            Map<Long, Integer> line = new HashMap<>();\n            for(int j=i+1;j<N;++j){\n                long l = getLine(x[i], y[i], x[j], y[j]);\n                if(used.contains(l))continue;\n                if(!line.containsKey(l))line.put(l,0);\n                line.put(l, line.get(l)+1);\n            }\n            for(Map.Entry<Long, Integer> entry : line.entrySet()){\n                if(entry.getValue() >1){\n                    int k = entry.getValue()+1;\n                    ans = (ans - (two[k] - (k*(k-1)/2 +k +1) +mod)%mod +mod)%mod;\n                    used.add(entry.getKey());\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int[][] p = ntable(n, 2);\n    int mod = 998244353;\n\n    long ret = modpow(2, n, mod);\n    Map<String, Set<Integer>> map = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        String hash = lineHash(p[i][0], p[i][1], p[j][0], p[j][1]);\n\n        if (!map.containsKey(hash))\n          map.put(hash, new HashSet<>());\n        map.get(hash).add(i);\n        map.get(hash).add(j);\n      }\n    }\n    for (Set<Integer> v : map.values()) {\n      ret += mod - modpow(2, v.size(), mod) + v.size() + 1;\n      ret %= mod;\n    }\n    ret += mod - n - 1;\n    ret %= mod;\n    out.println(ret);\n  }\n\n  public static String lineHash(long x1, long y1, long x2, long y2) {\n    long a = x1 - x2, b = y1 - y2, c = x1 * (y2 - y1) - y1 * (x2 - x1);\n    long x = a, y = b, z = c;\n    while (y != 0) {\n      long d = x;\n      x = y;\n      y = d % y;\n    }\n    while (z != 0) {\n      long d = x;\n      x = z;\n      z = d % z;\n    }\n    if (a / x < 0)\n      x = -x;\n    a /= x;\n    b /= x;\n    c /= x;\n\n    return a + \",\" + b + \",\" + c;\n  }\n\n  public static long modpow(long a, long n, long mod) {\n    long ret = 1;\n    long mul = a;\n    for (; n > 0; n >>>= 1) {\n      if ((n & 1) == 1) {\n        ret = (ret * mul) % mod;\n      }\n      mul = (mul * mul) % mod;\n    }\n    return ret;\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    long MOD = 998244353;\n    int inf = Integer.MAX_VALUE/2;\n\n\n    void solve(){\n        int n = ni();\n        int[][] x = new int[n][2];\n        for(int i = 0; i < n; i++){\n            x[i][0] = ni();\n            x[i][1] = ni();\n        }\n        long total = 1;\n        for(int i = 0; i < n; i++){\n            total *= 2;\n            total %= MOD;\n        }\n        total-=n+1;\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                long p = 1;\n                int[] v1 = new int[]{x[j][0]-x[i][0], x[j][1]-x[i][1]};\n                for(int k = j+1; k < n; k++){\n                    int[] v2 = new int[]{x[k][0]-x[i][0], x[k][1]-x[i][1]};\n                    int cross = v1[0]*v2[1] - v1[1]*v2[0];\n                    if(cross==0){\n                        p*=2;\n                        p %= MOD;\n                    }\n                }\n                p %= MOD;\n                total = (total-p+MOD)%MOD;\n            }\n        }\n        out.println(total);\n\n    }    \n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n\npublic class C {\n\t\n\tstatic class Point {\n\t\tint x, y;\n\t\tpublic Point(int xx, int yy) {\n\t\t\tx = xx;\n\t\t\ty = yy;\n\t\t}\n\t\tint cross(Point o) {\n\t\t\treturn x * o.y - o.x * y;\n\t\t}\n\t\tPoint sub(Point o){\n\t\t\treturn new Point(x - o.x, y - o.y);\n\t\t}\n\t}\n\t\n\tstatic class Scanner{\n\t\tBufferedReader br=null;\n\t\tStringTokenizer tk=null;\n\t\tpublic Scanner(){\n\t\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tpublic String next() throws IOException{\n\t\t\twhile(tk==null || !tk.hasMoreTokens()) {\n\t\t\t\tString cad = br.readLine();\n\t\t\t\tif (cad == null)\n\t\t\t\t\treturn null;\n\t\t\t\ttk=new StringTokenizer(cad);\n\t\t\t}\n\t\t\treturn tk.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws NumberFormatException, IOException{\n\t\t\treturn Integer.valueOf(next());\n\t\t}\n\t\tpublic long nextLong() throws NumberFormatException, IOException{\n\t\t\treturn Long.valueOf(next());\n\t\t}\n\t\tpublic double nextDouble() throws NumberFormatException, IOException{\n\t\t\treturn Double.valueOf(next());\n\t\t}\n\t}\n\t\n\tstatic long mod = 998244353;\n\tstatic long[] pow2;\n\t\n\tpublic static void main(String args[]) throws NumberFormatException, IOException {\n\t\tScanner sc = new Scanner();\n\t\tint N = sc.nextInt();\n\t\tPoint[] p = new Point[N];\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tp[i] = new Point(sc.nextInt(), sc.nextInt());\n\t\tpow2 = new long[N + 1];\n\t\tpow2[0] = 1;\n\t\tfor(int i = 1; i <= N; i++)\n\t\t\tpow2[i] = (pow2[i - 1] * 2) % mod;\n\t\tlong sub = 1;\n\t\tfor(int i = 0; i < N; i++) { \n\t\t\tsub++;\n\t\t\tfor(int j = i + 1; j < N; j++) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int k = j + 1; k < N; k++) {\n\t\t\t\t\tif (p[j].sub(p[i]).cross(p[k].sub(p[i])) == 0)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tsub = (sub + pow2[count]) % mod;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((pow2[N] - sub + mod) % mod);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskE {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int MOD = 998244353;\n\t\t\tint n = in.nextInt();\n\t\t\tPoint[] p = new Point[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\t\t\t\tp[i] = new Point(x, y, i);\n\t\t\t}\n\t\t\tint[] p2 = new int[n + 1];\n\t\t\tp2[0] = 1;\n\t\t\tfor (int i = 1; i < p2.length; i++) {\n\t\t\t\tp2[i] = 2 * p2[i - 1] % MOD;\n\t\t\t}\n\n\t\t\tArrays.sort(p, (u, v) -> {\n\t\t\t\tif (u.x != v.x) {\n\t\t\t\t\treturn u.x - v.x;\n\t\t\t\t}\n\t\t\t\tif (u.y != v.y) {\n\t\t\t\t\treturn u.y - v.y;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tint ans = 0;\n\t\t\tint[][] d = new int[n][n];\n\t\t\tint[][] g = new int[n][n];\n\t\t\tfor (int s = 0; s < n; s++) {\n\t\t\t\tPoint[] r = new Point[n - s - 1];\n\t\t\t\tSystem.arraycopy(p, s + 1, r, 0, r.length);\n\t\t\t\tfinal Point o = p[s];\n\t\t\t\tArrays.sort(r, (u, v) -> -Long.signum(cross(u, v, o)));\n\t\t\t\t// Number of points inside or on the borders of the triangle ij.\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < r.length; j++) {\n\t\t\t\t\t\tg[i][j] = 0;\n\t\t\t\t\t\tfor (int k = i + 1; k < j; k++) {\n\t\t\t\t\t\t\tif (cross(r[k], r[j], r[i]) >= 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++g[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int[] arr : d) {\n\t\t\t\t\tArrays.fill(arr, 0);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tint si = 0;\n\t\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t\tif (cross(r[i], r[j], o) == 0) {\n\t\t\t\t\t\t\t++si;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = i + 1; j < r.length; j++) {\n\t\t\t\t\t\tif (cross(r[i], r[j], o) <= 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\td[i][j] += p2[g[i][j] + si];\n\t\t\t\t\t\tif (d[i][j] >= MOD) {\n\t\t\t\t\t\t\td[i][j] -= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += d[i][j];\n\t\t\t\t\t\tif (ans >= MOD) {\n\t\t\t\t\t\t\tans -= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = j + 1; k < r.length; k++) {\n\t\t\t\t\t\t\tif (cross(r[i], r[j], r[k]) < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\td[j][k] = (int) ((d[j][k] + (long) d[i][j] * p2[g[j][k]]) % MOD);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long cross(Point p1, Point p2, Point o) {\n\t\t\tlong x1 = p1.x - o.x;\n\t\t\tlong x2 = p2.x - o.x;\n\t\t\tlong y1 = p1.y - o.y;\n\t\t\tlong y2 = p2.y - o.y;\n\t\t\treturn x1 * y2 - x2 * y1;\n\t\t}\n\n\t\tclass Point {\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint id;\n\n\t\t\tPoint(int x, int y, int id) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.id = id;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n//\t\tModUtil mu = new ModUtil();\n//\t\tSystem.out.println(mu.getC(200, 100));\n\t\tnew Main().exec();\n\t}\n\t\n\tpublic void exec() throws IOException {\n\t\tInputUtil in = new InputUtil();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tModUtil mu = new ModUtil();\n\t\tint N = in.nextInt();\n\t\tPoint[] P = new Point[N];\n\t\tHashMap<Line,Integer> lineMap = new HashMap<>();\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tP[i] = new Point(in.nextInt(),in.nextInt());\n\t\t}\n\t\tint lineMax = 1;\n\t\tfor(int i=0; i<N-1; i++){\n\t\t\tfor(int j=i+1; j<N; j++) {\n\t\t\t\tLine l = Line.getLine(P[i], P[j]);\n\t\t\t\tif(lineMap.containsKey(l)){\n\t\t\t\t\tint tmp = lineMap.get(l) + 1;\n\t\t\t\t\tlineMap.put(l, tmp);\n\t\t\t\t\tlineMax = Math.max(lineMax, tmp);\n\t\t\t\t}else{\n\t\t\t\t\tlineMap.put(l, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tHashMap<Integer,Integer> lineNumMap = new HashMap<>();\n\t\tfor(int lineNum: lineMap.values()) {\n\t\t\tif(lineNumMap.containsKey(lineNum)){\n\t\t\t\tlineNumMap.put(lineNum, lineNumMap.get(lineNum)+1);\n\t\t\t}else{\n\t\t\t\tlineNumMap.put(lineNum, 1);\n\t\t\t}\n\t\t}\n\t\tint ans = mu.power(2, N);\n\t\tans = mu.sub(ans, 1);\n\t\tans = mu.sub(ans, N);\n\t\tint pointMax = 2;\n\t\tint lines = 1;\n\t\twhile(lines <= lineMax){\n\t\t\tInteger lineNum = lineNumMap.get(lines);\n\t\t\tif(lineNum != null) {\n\t\t\t\tfor(int j=2; j<=pointMax; j++) {\n\t\t\t\t\tint subSetNum = mu.getC(pointMax, j);\n\t\t\t\t\tint totalSubSetNum = mu.multiple(subSetNum, lineNum);\n\t\t\t\t\tans = mu.sub(ans, totalSubSetNum);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointMax++;\n\t\t\tlines = pointMax * (pointMax-1) / 2;\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t\tout.flush();\n\t}\n\t\n}\n\nclass Fraction implements Comparable<Fraction> {\n\tpublic static final Fraction INFINITE = new Fraction();\n\tint numerator = 0;\n\tint denominator = 1;\n\t\n\tprivate Fraction (){\n\t\tnumerator = 1;\n\t\tdenominator = 0;\n\t}\n\tpublic Fraction(int n, int d) {\n\t\tif(d<=0) throw new IllegalArgumentException();\n\t\tnumerator=n;\n\t\tdenominator=d;\n\t\treduce();\n\t}\n\t\n\tpublic Fraction reduce() {\n\t\tif(this==INFINITE) return this;\n\t\tint gcd = MyMath.getGcd(numerator,denominator);\n\t\tnumerator /= gcd;\n\t\tdenominator /= gcd;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + denominator;\n\t\tresult = prime * result + numerator;\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tFraction other = (Fraction) obj;\n\t\tif (denominator != other.denominator)\n\t\t\treturn false;\n\t\tif (numerator != other.numerator)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\tpublic double doubleValue() {\n\t\tif(this==INFINITE) return Double.NaN;\n\t\treturn ((double)numerator)/denominator;\n\t}\n\n\t@Override\n\tpublic int compareTo(Fraction f) {\n\t\tif(this==f) return 0;\n\t\treturn Double.compare(doubleValue(), f.doubleValue());\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn new StringBuilder().append(\"Fraction(\").append(numerator).append(\"/\").append(denominator).append(\")\").toString();\n\t}\n\n}\n\nclass Line {\n\tFraction slope = null;\n\tFraction intercept = null;\n\t\n\tpublic static Line getLine(Point a, Point b) {\n\t\tif(a.x==b.x)\n\t\t\treturn new Line(Fraction.INFINITE,new Fraction(a.x,1));\n\t\tif(a.x > b.x) \n\t\t\treturn getLine(b,a);\n\t\telse{\n\t\t\tint sn = b.y-a.y;\n\t\t\tint sd = b.x-a.x;\n\t\t\tint in = sd*a.y - sn*a.x;\n\t\t\tint id = sd;\n\t\t\treturn new Line(sn, sd, in, id);\n\t\t}\n\t}\n\t\n\tprivate Line(int sn, int sd, int in, int id) {\n\t\tthis(new Fraction(sn,sd),new Fraction(in,id));\n\t}\n\t\n\tprivate Line(Fraction slope, Fraction intercept) {\n\t\tthis.slope=slope;\n\t\tthis.intercept=intercept;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((intercept == null) ? 0 : intercept.hashCode());\n\t\tresult = prime * result + ((slope == null) ? 0 : slope.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tLine other = (Line) obj;\n\t\tif (intercept == null) {\n\t\t\tif (other.intercept != null)\n\t\t\t\treturn false;\n\t\t} else if (!intercept.equals(other.intercept))\n\t\t\treturn false;\n\t\tif (slope == null) {\n\t\t\tif (other.slope != null)\n\t\t\t\treturn false;\n\t\t} else if (!slope.equals(other.slope))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn new StringBuilder().append(\"Line(\").append(slope).append(\",\").append(intercept).append(\")\").toString();\n\t}\n\n}\n\nclass ModUtil {\n\t//Static Fields\n\tpublic static final int BASE_DEF = 998244353;\n\tpublic static final int CAPACITY_F = 200;\n\t\n\t//Fields\n\tprotected int mod = BASE_DEF;\n\tprotected int capacity = CAPACITY_F;\n\tprivate int[] Farray = null;;\n\tprivate int[] FInvarray = null;\n\n\t//Constructors\n\tpublic ModUtil() {\n\t\tinitF();\n\t}\n\tpublic ModUtil(int m, int cap) {\n\t\tmod = m;\n\t\tcapacity=cap;\n\t\tinitF();\n\t}\n\t\n\t//Methods\n\t//Initializer\n\tprotected void initF() {\n\t\tif(Farray != null) return;\n\t\tFarray = new int[capacity+1];\n\t\tFInvarray = new int[capacity+1];\n\t\tfor(int n=0; n<Farray.length; n++) {\n\t\t\tFarray[n] = (n==0) ? 1 : multiple(n, Farray[n-1]);\n\t\t\tFInvarray[n] = divide(1, Farray[n]);\n\t\t}\n\t}\n\n\t//Basic Opertion\n\tpublic int modulo(long v) {return (int)(v%mod);}\n\tpublic int add(int a, int b) {return modulo(a + b);}\n\tpublic int sub(int a, int b) {return add(a, mod - b);}\n\tpublic int multiple(int a, int b) {return modulo((long)a * modulo(b));}\n\tpublic int divide(int a, int b) {return multiple(a, power(b, mod-2));}\n\t\n\tpublic int divideF(int a, int fn) {\n\t\tif(fn<=capacity) {\n\t\t\treturn multiple(a, getFInv(fn));\n\t\t}else{\n\t\t\treturn divide(a, getF(fn));\n\t\t}\n\t}\n\t\n\tpublic int power(int a, int b) {\n\t\tint ret = 1;\n\t\tfor (int bitMask = 1; bitMask<=b; bitMask<<=1) {\n\t\t\tif ( (b & bitMask) != 0 ) ret = multiple(ret, a);\n\t\t\ta = multiple(a, a);\n\t\t}\n\t\treturn ret;\n\t}\n\n\t//Factorial Operation\n\tpublic int getF(int n) {return Farray[n];}\n\tpublic int getFInv(int n) {return FInvarray[n];}\n\n\t//Permutation Operation\n\tprotected int calcP(int n, int r) {\n\t\tif (n < 0 || r < 0 || n < r) throw new IllegalArgumentException(\"n=\" +n+ \",r=\" +r);\n\t\tif (n <= 1 || r == 0) return 1;\n\t\tif (r == 1) return n;\n\t\treturn divideF(getF(n), n-r);\n\t\t\n\t}\n\n\tpublic int getP(int n, int r) {return calcP(n, r);}\n\n\t//Combination Operation\n\tprotected int calcC(int n, int r) {\n\t\tif(n < 0 || r < 0 || n < r) throw new IllegalArgumentException(\"n=\" +n+ \",r=\" +r);\n\t\tif(n == 0 || n == 1) return 1;\n\t\tif(n - r < r) r = n - r;\n\t\treturn divideF(divideF(getF(n), r),n-r);\n\t}\n\t\n\tpublic int getC(int n, int r) {return calcC(n,r);}\n\tpublic int getH(int n, int r) {return calcC(n+r-1, r);}\n\n}\n\nclass MyMath {\n\tpublic static long getGcd(long a, long b){\n\t\tlong tmp = 0;\n\t\twhile (a%b!=0) {\n\t\t\ttmp = b;\n\t\t\tb = a%b;\n\t\t\ta = tmp;\n\t\t}\n\t\treturn b;\n\t}\n\n\tpublic static int getGcd(int a, int b){\n\t\treturn (int)getGcd((long)a, (long)b);\n\t}\n\n\t\n\tpublic static long getLcm(long a, long b){\n\t\tlong gcd = getGcd(a,b);\n\t\treturn (a/gcd)*b;\n\t}\n\tpublic static int getLcm(int a, int b){\n\t\treturn (int)getLcm((long)a, (long)b);\n\t}\n\t\n\t\n\n}\n\nclass InputUtil {\n\t//Static Fields\n\tprivate static final int BUFSIZ = 100000;\n\t\n\t//Fields\n\tprotected InputStream in;\n\tprivate byte[] buf = null;\n\tprivate int ptr = 0;\n\tprivate int max = -1;\n\tprivate DataInputStream dis = null;\n\t//Constructors\n\tpublic InputUtil() {this(System.in,BUFSIZ);}\n\tpublic InputUtil(InputStream in, int bufsiz) {\n\t\tinitBuf(bufsiz);\n\t\tinitIn(in);\n\t}\n\t\n\t//Methods\n\t//Initializer\n\tprotected void initIn(InputStream in) {dis = new DataInputStream(this.in = in);}\n\tprotected void initBuf(int bufsiz) {buf = new byte[bufsiz];}\n\t\n\t//buffer operation\n\tprivate void next() throws IOException {ptr++; readBuf();}\n\tprivate void readBuf() throws IOException {\n\t\tif(ptr >= max && dis.available()>0) {\n\t\t\tif(max>0) Arrays.fill(buf,0,max,(byte)0);\n\t\t\tmax = dis.read(buf);\n\t\t\tptr = 0;\n\t\t}\n\t}\n\t\n\t//Number Input Reader/Parser\n\tprivate boolean isNum(byte b) {return '0' <= b && b <= '9'; }\n\tprivate boolean isMinus(byte b) {return b=='-'; }\n\n\tprivate int _nextInt() throws IOException {\n\t\tint sign = 1;\n\t\tint res = 0;\n\t\tbyte c;\n\t\twhile (!isNum(c=buf[ptr]) && !isMinus(c)) \n\t\t\tnext();\n\t\tif (isMinus(buf[ptr])) {\n\t\t\tsign = -1;\n\t\t\tnext();\n\t\t}\n\t\twhile (isNum(c=buf[ptr])) {\n\t\t\tres *= 10;\n\t\t\tres += c - '0' ;\n\t\t\tnext();\n\t\t}\n\t\tnext();\n\t\treturn sign * res;\n\t}\n\t\n\tpublic int nextInt() throws IOException {\n\t\treadBuf();\n\t\treturn _nextInt();\n\t}\n\n\tpublic int[] nextInt(int[] result) throws IOException {\n\t\treadBuf();\n\t\tfor(int i=0; i<result.length; i++) {\n\t\t\tresult[i] = _nextInt();\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t//Close \n\tpublic void close() throws IOException {\n\t\tif(!this.in.equals(System.in)) \n\t\t\tthis.in.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            LineGeometry.Point[] points = new LineGeometry.Point[n];\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt();\n                int y = in.nextInt();\n                points[i] = new LineGeometry.Point(x, y);\n            }\n\n            Modulo modulo = new Modulo(998244353);\n            long ans = modulo.pow(2, n);\n            ans = modulo.sub(ans, n * (n - 1) / 2);\n            ans = modulo.sub(ans, n + 1);\n            boolean[][] calced = new boolean[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (calced[i][j]) continue;\n\n                    List<Integer> list = new ArrayList<>();\n                    for (int k = 0; k < n; k++) {\n                        if (LineGeometry.orientation(points[i], points[j], points[k]) == 0) {\n                            list.add(k);\n                        }\n                    }\n                    for (int k = 0; k < list.size(); k++) {\n                        for (int l = k + 1; l < list.size(); l++) {\n                            calced[k][l] = true;\n                        }\n                    }\n\n                    long tmp = modulo.pow(2, list.size());\n                    tmp = modulo.sub(tmp, list.size() * (list.size() - 1) / 2);\n                    tmp = modulo.sub(tmp, list.size() + 1);\n                    ans -= tmp;\n                }\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static class Modulo {\n        long m;\n\n        public Modulo(long m) {\n            this.m = m;\n        }\n\n        public long sub(long a, long b) {\n            return (a - b + m) % m;\n        }\n\n        public long pow(long a, long x) {\n            long ans = 1;\n            while (x > 0) {\n                if ((x & 1) != 0) {\n                    ans = (ans * a) % m;\n                }\n                x >>= 1;\n                a = (a * a) % m;\n            }\n            return ans;\n        }\n\n    }\n\n    static class LineGeometry {\n        static final double EPS = 1e-10;\n\n        public static int sign(double a) {\n            return a < -EPS ? -1 : a > EPS ? 1 : 0;\n        }\n\n        public static int orientation(LineGeometry.Point a, LineGeometry.Point b, LineGeometry.Point c) {\n            LineGeometry.Point AB = b.minus(a);\n            LineGeometry.Point AC = c.minus(a);\n            return sign(AB.cross(AC));\n        }\n\n        public static class Point implements Comparable<LineGeometry.Point> {\n            public double x;\n            public double y;\n\n            public Point(double x, double y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            public LineGeometry.Point minus(LineGeometry.Point b) {\n                return new LineGeometry.Point(x - b.x, y - b.y);\n            }\n\n            public double cross(LineGeometry.Point b) {\n                return x * b.y - y * b.x;\n            }\n\n\n            public int compareTo(LineGeometry.Point o) {\n                // return Double.compare(Math.atan2(y, x), Math.atan2(o.y, o.x));\n                return Double.compare(x, o.x) != 0 ? Double.compare(x, o.x) : Double.compare(y, o.y);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader in;\n        StringTokenizer tok;\n\n        public String nextString() {\n            while (!tok.hasMoreTokens()) {\n                try {\n                    tok = new StringTokenizer(in.readLine(), \" \");\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n            }\n            return tok.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n        public InputReader(InputStream inputStream) {\n            in = new BufferedReader(new InputStreamReader(inputStream));\n            tok = new StringTokenizer(\"\");\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            LineGeometry.Point[] points = new LineGeometry.Point[n];\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt();\n                int y = in.nextInt();\n                points[i] = new LineGeometry.Point(x, y);\n            }\n\n            Modulo modulo = new Modulo(998244353);\n            long ans = modulo.pow(2, n);\n            ans = modulo.sub(ans, n + 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    int count = 0;\n                    for (int k = j + 1; k < n; k++) {\n                        if (LineGeometry.orientation(points[i], points[j], points[k]) == 0) {\n                            count++;\n                        }\n                    }\n\n                    long tmp = modulo.pow(2, count);\n                    ans = modulo.sub(ans, tmp);\n                }\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static class Modulo {\n        long m;\n\n        public Modulo(long m) {\n            this.m = m;\n        }\n\n        public long sub(long a, long b) {\n            return (a - b + m) % m;\n        }\n\n        public long pow(long a, long x) {\n            long ans = 1;\n            while (x > 0) {\n                if ((x & 1) != 0) {\n                    ans = (ans * a) % m;\n                }\n                x >>= 1;\n                a = (a * a) % m;\n            }\n            return ans;\n        }\n\n    }\n\n    static class LineGeometry {\n        static final double EPS = 1e-10;\n\n        public static int sign(double a) {\n            return a < -EPS ? -1 : a > EPS ? 1 : 0;\n        }\n\n        public static int orientation(LineGeometry.Point a, LineGeometry.Point b, LineGeometry.Point c) {\n            LineGeometry.Point AB = b.minus(a);\n            LineGeometry.Point AC = c.minus(a);\n            return sign(AB.cross(AC));\n        }\n\n        public static class Point implements Comparable<LineGeometry.Point> {\n            public double x;\n            public double y;\n\n            public Point(double x, double y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            public LineGeometry.Point minus(LineGeometry.Point b) {\n                return new LineGeometry.Point(x - b.x, y - b.y);\n            }\n\n            public double cross(LineGeometry.Point b) {\n                return x * b.y - y * b.x;\n            }\n\n\n            public int compareTo(LineGeometry.Point o) {\n                // return Double.compare(Math.atan2(y, x), Math.atan2(o.y, o.x));\n                return Double.compare(x, o.x) != 0 ? Double.compare(x, o.x) : Double.compare(y, o.y);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader in;\n        StringTokenizer tok;\n\n        public String nextString() {\n            while (!tok.hasMoreTokens()) {\n                try {\n                    tok = new StringTokenizer(in.readLine(), \" \");\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n            }\n            return tok.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n        public InputReader(InputStream inputStream) {\n            in = new BufferedReader(new InputStreamReader(inputStream));\n            tok = new StringTokenizer(\"\");\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n    static ContestScanner in;\n    static Writer out;\n    public static void main(String[] args) {\n        new Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n\n    public void run() {\n        Main main = new Main();\n        try {\n            in = new ContestScanner();\n            out = new Writer();\n            main.solve();\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void solve() throws IOException {\n        int n = in.nextInt();\n        final long mod = 998244353;\n        Pos[] p = new Pos[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = new Pos(i, in.nextInt(), in.nextInt());\n        }\n        int[][] line = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(line[i], -1);\n        }\n        Pos maximam = new Pos(-1, Integer.MAX_VALUE / 2, 0);\n        Pos minimam = new Pos(-1, Integer.MIN_VALUE / 2, 0);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                Pos max = minimam;\n                Pos min = maximam;\n                int cnt = 0;\n                for (int k = 0; k < n; k++) {\n                    if (triarea(p[i], p[j], p[k]) != 0) continue;\n                    cnt++;\n                    if (p[k].compareTo(max) > 0) {\n                        max = p[k];\n                    }\n                    if (p[k].compareTo(min) < 0) {\n                        min = p[k];\n                    }\n                }\n                if (line[min.id][max.id] >= 0) continue;\n                line[min.id][max.id] = cnt;\n            }\n        }\n\n        long ans = (modpow(2, n, mod) - n - 1 + mod) % mod;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (line[i][j] <= 0) continue;\n                int m = line[i][j];\n                long rem = (modpow(2, m, mod) - m - 1 + mod) % mod;\n                ans = (ans - rem + mod) % mod;\n            }\n        }\n        System.out.println(ans);\n    }\n\n    static int triarea(Pos a, Pos b, Pos c){\n        int dx1 = b.x - a.x;\n        int dy1 = b.y - a.y;\n        int dx2 = c.x - a.x;\n        int dy2 = c.y - a.y;\n        return dx1*dy2 - dx2*dy1;\n    }\n\n    long modpow(long n, long a, long mod){\n        long res = 1;\n        while(a > 0){\n            if((a&1)==1) res = (res * n) % mod;\n            n = n * n % mod;\n            a >>= 1;\n        }\n        return res;\n    }\n}\n\nclass Pos implements Comparable<Pos> {\n    int x, y, id;\n    Pos(int i, int x, int y) {\n        id = i;\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public int compareTo(Pos o) {\n        if (x != o.x) return x - o.x;\n        return y - o.y;\n    }\n}\n\nclass Writer extends PrintWriter{\n    public Writer(String filename)throws IOException\n    {super(new BufferedWriter(new FileWriter(filename)));}\n    public Writer()throws IOException {super(System.out);}\n}\nclass ContestScanner implements Closeable {\n    private BufferedReader in;private int c=-2;\n    public ContestScanner()throws IOException\n    {in=new BufferedReader(new InputStreamReader(System.in));}\n    public ContestScanner(String filename)throws IOException\n    {in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n    public String nextToken()throws IOException {\n        StringBuilder sb=new StringBuilder();\n        while((c=in.read())!=-1&&Character.isWhitespace(c));\n        while(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n        return sb.toString();\n    }\n    public String readLine()throws IOException{\n        StringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n        while(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n        return sb.toString();\n    }\n    public long nextLong()throws IOException,NumberFormatException\n    {return Long.parseLong(nextToken());}\n    public int nextInt()throws NumberFormatException,IOException\n    {return(int)nextLong();}\n    public double nextDouble()throws NumberFormatException,IOException\n    {return Double.parseDouble(nextToken());}\n    public void close() throws IOException {in.close();}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Objects;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author anand.oza\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EConvexScore solver = new EConvexScore();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EConvexScore {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n\n            NumberTheory.ModM m = new NumberTheory.ModM(998244353L);\n\n            long answer = 0;\n            answer = m.add(answer, m.pow(2, n));\n            answer = m.subtract(answer, m.ncr(n, 0));\n            answer = m.subtract(answer, m.ncr(n, 1));\n\n            Geometry.Point[] p = new Geometry.Point[n];\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt(), y = in.nextInt();\n                p[i] = new Geometry.Point(x, y);\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    int count = 0;\n                    Geometry.Point[] polygon = {p[i],\n                                                p[j]};\n\n                    for (int k = 0; k < n; k++) {\n                        if (k == i || k == j)\n                            continue;\n\n                        if (p[k].classify(polygon) == Geometry.Point.Classification.ON) {\n                            count++;\n                        }\n                    }\n\n                    System.out.println(count);\n\n                    long overcount = m.pow(2, count);\n                    answer = m.subtract(answer, overcount);\n                }\n            }\n\n            out.println(answer);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class Geometry {\n        public static class Point implements Comparable<Geometry.Point> {\n            long x;\n            long y;\n\n            public Point(long x, long y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            public Geometry.Point copy() {\n                return new Geometry.Point(x, y);\n            }\n\n            public Geometry.Point subtract(Geometry.Point o) {\n                x -= o.x;\n                y -= o.y;\n                return this;\n            }\n\n            public static Geometry.Point subtract(Geometry.Point a, Geometry.Point b) {\n                return a.copy().subtract(b);\n            }\n\n            public boolean equals(Object o) {\n                if (this == o)\n                    return true;\n                if (o == null || getClass() != o.getClass())\n                    return false;\n                Geometry.Point point = (Geometry.Point) o;\n                return x == point.x && y == point.y;\n            }\n\n            public int hashCode() {\n                return Objects.hash(x, y);\n            }\n\n            public static long cross(Geometry.Point a, Geometry.Point b) {\n                return a.x * b.y - a.y * b.x;\n            }\n\n            public static long cross(Geometry.Point p, Geometry.Point a, Geometry.Point b) {\n                return cross(subtract(a, p), subtract(b, p));\n            }\n\n            public int compareTo(Geometry.Point o) {\n                int ret = Long.compare(x, o.x);\n                if (ret != 0)\n                    return ret;\n                return Long.compare(y, o.y);\n            }\n\n            public Geometry.Point.Classification classify(Geometry.Point[] polygon) {\n                boolean ans = false;\n                for (int i = 0; i < polygon.length; i++) {\n                    Geometry.Point a = polygon[i], b = polygon[(i + 1) % polygon.length];\n                    if (cross(a, b, this) == 0 && (a.compareTo(this) <= 0 || b.compareTo(this) <= 0) && (this.compareTo(a) <= 0 || this.compareTo(b) <= 0))\n                        return Geometry.Point.Classification.ON;\n                    if (a.y > b.y) {\n                        Geometry.Point t = a;\n                        a = b;\n                        b = t;\n                    }\n                    if (a.y <= y && y < b.y && cross(this, a, b) > 0)\n                        ans ^= true;\n                }\n                return ans ? Geometry.Point.Classification.IN : Geometry.Point.Classification.OUT;\n            }\n\n            public enum Classification {\n                ON, IN, OUT,\n                ;\n            }\n\n        }\n\n    }\n\n    static class NumberTheory {\n        private static void ASSERT(boolean assertion) {\n            if (!assertion)\n                throw new AssertionError();\n        }\n\n        public abstract static class Modulus<M extends NumberTheory.Modulus<M>> {\n            ArrayList<Long> factorial = new ArrayList<>();\n            ArrayList<Long> invFactorial = new ArrayList<>();\n\n            public abstract long modulus();\n\n            public Modulus() {\n                super();\n                factorial.add(1L);\n                invFactorial.add(1L);\n            }\n\n            public long fact(int n) {\n                while (factorial.size() <= n) {\n                    factorial.add(mult(factorial.get(factorial.size() - 1), factorial.size()));\n                }\n\n                return factorial.get(n);\n            }\n\n            public long fInv(int n) {\n                while (invFactorial.size() <= n) {\n                    invFactorial.add(div(invFactorial.get(invFactorial.size() - 1), invFactorial.size()));\n                }\n\n                return invFactorial.get(n);\n            }\n\n            public long ncr(int n, int r) {\n                ASSERT(n >= 0);\n                if (r < 0 || n < r)\n                    return 0;\n                return mult(fact(n), mult(fInv(r), fInv(n - r)));\n            }\n\n            public long normalize(long x) {\n                x %= modulus();\n                if (x < 0)\n                    x += modulus();\n                return x;\n            }\n\n            public long add(long a, long b) {\n                return normalize(a + b);\n            }\n\n            public long subtract(long a, long b) {\n                return normalize(a - b);\n            }\n\n            public long mult(long a, long b) {\n                return normalize(a * b);\n            }\n\n            public long div(long a, long b) {\n                return mult(a, inv(b));\n            }\n\n            public long pow(long x, int e) {\n                if (e == 0)\n                    return 1;\n                if ((e & 1) > 0)\n                    return mult(x, pow(x, e - 1));\n                return pow(mult(x, x), e / 2);\n            }\n\n            public long inv(long value) {\n                long g = modulus(), x = 0, y = 1;\n                for (long r = value; r != 0; ) {\n                    long q = g / r;\n                    g %= r;\n\n                    long temp = g;\n                    g = r;\n                    r = temp;\n\n                    x -= q * y;\n\n                    temp = x;\n                    x = y;\n                    y = temp;\n                }\n\n                ASSERT(g == 1);\n                ASSERT(y == modulus() || y == -modulus());\n\n                return normalize(x);\n            }\n\n        }\n\n        public static class ModM extends NumberTheory.Modulus<NumberTheory.ModM> {\n            private final long modulus;\n\n            public ModM(long modulus) {\n                this.modulus = modulus;\n            }\n\n            public long modulus() {\n                return modulus;\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.security.SecureRandom;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws FileNotFoundException {\n        ConsoleIO io = new ConsoleIO(new InputStreamReader(System.in), new PrintWriter(System.out));\n        //String test = \"sample\";\n        //ConsoleIO io = new ConsoleIO(new FileReader(\"D:\\\\Dropbox\\\\code\\\\practice\\\\jb\\\\src\\\\\" + test + \".in\"), new PrintWriter(new File(\"D:\\\\Dropbox\\\\code\\\\practice\\\\jb\\\\src\\\\\" + test + \"-out.txt\")));\n\n       new Main(io).solve();\n\n        io.close();\n    }\n\n    ConsoleIO io;\n    Main(ConsoleIO io) {\n        this.io = io;\n    }\n\n    List<List<Integer>> gr = new ArrayList<>();\n    long MOD = 998244353; //1_000_000_007;\n\n    public void solve() {\n        int n = io.ri();\n        int[] x = new int[n];\n        int[] y = new int[n];\n        for(int i =0;i<n;i++) {\n            x[i] = io.ri();\n            y[i] = io.ri();\n        }\n\n        long[][] binom = new long[n+1][n+1];\n        binom[0][0] = 1;\n        for(int i = 1;i<=n;i++) {\n            binom[i][0] = 1;\n            for(int j = 1;j<=i;j++)\n                binom[i][j] = (binom[i-1][j-1]+binom[i-1][j])%MOD;\n        }\n        long res = 0;\n        for(int i = 3;i<=n;i++)\n            res = (res+binom[n][i])%MOD;\n\n        int[] count = new int[n+1];\n        for(int i = 0;i<n;i++) {\n            boolean[] marked = new boolean[n];\n            for (int j = i + 1; j < n; j++)if(!marked[j]) {\n                int k = 2;\n                int x1 = x[j] - x[i];\n                int y1 = y[j] - y[i];\n                for (int q = j + 1; q < n; q++) {\n                    int x2 = x[q] - x[i];\n                    int y2 = y[q] - y[i];\n                    if (x1 * y2 - x2 * y1 == 0) {\n                        k++;\n                        marked[q] = true;\n                    }\n                }\n                if(k>2){\n                    count[k]++;\n                }\n            }\n        }\n        for(int i = n;i>=3;i--) {\n            if (count[i] > 0) {\n                long minus = 0;\n                for (int j = 3; j <= i; j++)\n                    minus = (minus + binom[i][j]) % MOD;\n                res = (res - count[i] * minus) % MOD;\n                for (int j = i - 1; j > 0; j--)\n                    count[j] -= count[i];\n            }\n        }\n        io.writeLine(res+\"\");\n    }\n}\n\nclass ConsoleIO {\n    BufferedReader br;\n    PrintWriter out;\n    public ConsoleIO(Reader reader, PrintWriter writer){br = new BufferedReader(reader);out = writer;}\n    public void flush(){this.out.flush();}\n    public void close(){this.out.close();}\n    public void writeLine(String s) {this.out.println(s);}\n    public void writeInt(int a) {this.out.print(a);this.out.print(' ');}\n    public void writeWord(String s){\n        this.out.print(s);\n    }\n    public void writeIntArray(int[] a, int k, String separator) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < k; i++) {\n            if (i > 0) sb.append(separator);\n            sb.append(a[i]);\n        }\n        this.writeLine(sb.toString());\n    }\n    public int read(char[] buf, int len){try {return br.read(buf,0,len);}catch (Exception ex){ return -1; }}\n    public String readLine() {try {return br.readLine();}catch (Exception ex){ return \"\";}}\n    public long[] readLongArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");long[]r=new long[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Long.parseLong(n[i]);\n        return r;\n    }\n    public int[] readIntArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");int[]r=new int[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Integer.parseInt(n[i]);\n        return r;\n    }\n    public int[] readIntArray(int n) {\n        int[] res = new int[n];\n        char[] all = this.readLine().toCharArray();\n        int cur = 0;boolean have = false;\n        int k = 0;\n        boolean neg = false;\n        for(int i = 0;i<all.length;i++){\n            if(all[i]>='0' && all[i]<='9'){\n                cur = cur*10+all[i]-'0';\n                have = true;\n            }else if(all[i]=='-') {\n                neg = true;\n            }\n            else if(have){\n                res[k++] = neg?-cur:cur;\n                cur = 0;\n                have = false;\n                neg = false;\n            }\n        }\n        if(have)res[k++] = neg?-cur:cur;\n        return res;\n    }\n    public int ri() {\n        try {\n            int r = 0;\n            boolean start = false;\n            boolean neg = false;\n            while (true) {\n                int c = br.read();\n                if (c >= '0' && c <= '9') {\n                    r = r * 10 + c - '0';\n                    start = true;\n                } else if (!start && c == '-') {\n                    start = true;\n                    neg = true;\n                } else if (start || c == -1) return neg ? -r : r;\n            }\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n    public long readLong() {\n        try {\n            long r = 0;\n            boolean start = false;\n            boolean neg = false;\n            while (true) {\n                int c = br.read();\n                if (c >= '0' && c <= '9') {\n                    r = r * 10 + c - '0';\n                    start = true;\n                } else if (!start && c == '-') {\n                    start = true;\n                    neg = true;\n                } else if (start || c == -1) return neg ? -r : r;\n            }\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n    public String readWord() {\n        try {\n            boolean start = false;\n            StringBuilder sb = new StringBuilder();\n            while (true) {\n                int c = br.read();\n                if (c!= ' ' && c!= '\\r' && c!='\\n' && c!='\\t') {\n                    sb.append((char)c);\n                    start = true;\n                } else if (start || c == -1) return sb.toString();\n            }\n        } catch (Exception ex) {\n            return \"\";\n        }\n    }\n    public char readSymbol() {\n        try {\n            while (true) {\n                int c = br.read();\n                if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t') {\n                    return (char) c;\n                }\n            }\n        } catch (Exception ex) {\n            return 0;\n        }\n    }\n    //public char readChar(){try {return (char)br.read();}catch (Exception ex){ return 0; }}\n}\nclass Pair {\n    public Pair(int a, int b) {this.a = a;this.b = b;}\n    public int a;\n    public int b;\n}\nclass PairLL {\n    public PairLL(long a, long b) {this.a = a;this.b = b;}\n    public long a;\n    public long b;\n}\nclass Triple {\n    public Triple(int a, int b, int c) {this.a = a;this.b = b;this.c = c;}\n    public int a;\n    public int b;\n    public int c;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tfinal long MODULO = 998244353L;\n\tlong[] fac = new long[400];\n\tlong[] invfac = new long[400];\n\tlong[] inv = new long[400];\n\tlong[][] C = new long[400][400];\n\tlong[] pow2 = new long[400];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i % MODULO;\n\t\t}\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = (MODULO - (MODULO / i) * inv[(int) (MODULO % i)] % MODULO) % MODULO;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MODULO;\n\t\t}\n\t\tC[0][0] = 1;\n\t\tfor (int i = 1; i < C.length; ++i) {\n\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\tC[i][j] = (j > 0 ? C[i - 1][j - 1] : 0) + C[i - 1][j];\n\t\t\t\tC[i][j] %= MODULO;\n\t\t\t}\n\t\t}\n\t\tpow2[0] = 1;\n\t\tfor (int i = 1; i < pow2.length; ++i) {\n\t\t\tpow2[i] = pow2[i - 1] * 2 % MODULO;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tRandom rand = new Random();\n\t\t// while (true) {\n\t\tint n = sc.nextInt();\n\t\t// int n = rand.nextInt(5);\n\t\tlong[] x = new long[n];\n\t\tlong[] y = new long[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\t// x[i] = rand.nextInt(5);\n\t\t\t// y[i] = rand.nextInt(5);\n\t\t}\n\t\tsolver(n, x, y);\n\t\t// }\n\t}\n\n\tvoid solver(int n, long[] x, long[] y) {\n\t\tlong ans = pow2[n];\n\n\t\tans = (ans - n + MODULO) % MODULO;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tvis[i] = true;\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tif (vis[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tvis[j] = true;\n\t\t\t\tint cnt = 1;\n\t\t\t\tfor (int k = j + 1; k < n; ++k) {\n\t\t\t\t\tif ((x[i] - x[j]) * (y[k] - y[i]) == (y[i] - y[j]) * (x[k] - x[i])) {\n\t\t\t\t\t\tif (vis[k]) {\n\t\t\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvis[k] = true;\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = (ans - (pow2[cnt] - 1) + MODULO) % MODULO;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans - 1);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tfinal long MODULO = 998244353L;\n\tlong[] fac = new long[400];\n\tlong[] invfac = new long[400];\n\tlong[] inv = new long[400];\n\tlong[][] C = new long[400][400];\n\tlong[] pow2 = new long[400];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i % MODULO;\n\t\t}\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = (MODULO - (MODULO / i) * inv[(int) (MODULO % i)] % MODULO) % MODULO;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MODULO;\n\t\t}\n\t\tC[0][0] = 1;\n\t\tfor (int i = 1; i < C.length; ++i) {\n\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\tC[i][j] = (j > 0 ? C[i - 1][j - 1] : 0) + C[i - 1][j];\n\t\t\t\tC[i][j] %= MODULO;\n\t\t\t}\n\t\t}\n\t\tpow2[0] = 1;\n\t\tfor (int i = 1; i < pow2.length; ++i) {\n\t\t\tpow2[i] = pow2[i - 1] * 2 % MODULO;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong[] x = new long[n];\n\t\tlong[] y = new long[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t}\n\t\tsolver(n, x, y);\n\t}\n\n\tvoid solver(int n, long[] x, long[] y) {\n\t\tlong ans = pow2[n];\n\n\t\tans = (ans - n + MODULO) % MODULO;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tvis[i] = true;\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tif (vis[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tvis[j] = true;\n\t\t\t\tint cnt = 1;\n\t\t\t\tfor (int k = j + 1; k < n; ++k) {\n\t\t\t\t\tif (vis[k]) {\n\t\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t\t}\n\t\t\t\t\tif ((x[i] - x[j]) * (y[k] - y[i]) == (y[i] - y[j]) * (x[k] - x[i])) {\n\t\t\t\t\t\tvis[k] = true;\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = (ans - (pow2[cnt] - 1) + MODULO) % MODULO;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans - 1);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().exec();\n\t}\n\t\n\tpublic void exec() throws IOException {\n\t\tInputUtil in = new InputUtil();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tModUtil mu = new ModUtil();\n\t\tint N = in.nextInt();\n\t\tPoint[] P = new Point[N];\n\t\tHashMap<Line,Integer> lineMap = new HashMap<>();\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tP[i] = new Point(in.nextInt(),in.nextInt());\n\t\t}\n\t\tint lineMax = 1;\n\t\tfor(int i=0; i<N-1; i++){\n\t\t\tfor(int j=i+1; j<N; j++) {\n\t\t\t\tLine l = Line.getLine(P[i], P[j]);\n\t\t\t\tif(lineMap.containsKey(l)){\n\t\t\t\t\tint tmp = lineMap.get(l) + 1;\n\t\t\t\t\tlineMap.put(l, tmp);\n\t\t\t\t\tlineMax = Math.max(lineMax, tmp);\n\t\t\t\t}else{\n\t\t\t\t\tlineMap.put(l, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tHashMap<Integer,Integer> lineNumMap = new HashMap<>();\n\t\tfor(int lineNum: lineMap.values()) {\n\t\t\tif(lineNumMap.containsKey(lineNum)){\n\t\t\t\tlineNumMap.put(lineNum, lineNumMap.get(lineNum)+1);\n\t\t\t}else{\n\t\t\t\tlineNumMap.put(lineNum, 1);\n\t\t\t}\n\t\t}\n\t\tint ans = mu.power(2, N);\n\t\tans = mu.sub(ans, 1);\n\t\tans = mu.sub(ans, N);\n\t\tint pointMax = 2;\n\t\tint lines = 1;\n\t\twhile(lines <= lineMax){\n\t\t\tInteger lineNum = lineNumMap.get(lines);\n\t\t\tif(lineNum != null) {\n\t\t\t\tfor(int j=2; j<=pointMax; j++) {\n\t\t\t\t\tint subSetNum = mu.getC(pointMax, j);\n\t\t\t\t\tint totalSubSetNum = mu.multiple(subSetNum, lineNum);\n\t\t\t\t\tans = mu.sub(ans, totalSubSetNum);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointMax++;\n\t\t\tlines = pointMax * (pointMax-1) / 2;\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t\tout.flush();\n\t}\n\t\n}\n\nclass Fraction {\n\tpublic static final Fraction INFINITE = new Fraction();\n\tint numerator = 0;\n\tint denominator = 1;\n\t\n\tprivate Fraction (){\n\t\tnumerator = 1;\n\t\tdenominator = 0;\n\t}\n\tpublic Fraction(int n, int d) {\n\t\tif(d<=0) throw new IllegalArgumentException();\n\t\tnumerator=n;\n\t\tdenominator=d;\n\t\treduce();\n\t}\n\t\n\tpublic Fraction reduce() {\n\t\tif(this==INFINITE) return this;\n\t\tint gcd = MyMath.getGcd(numerator,denominator);\n\t\tnumerator /= gcd;\n\t\tdenominator /= gcd;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn new StringBuilder().append(\"Fraction(\").append(numerator).append(\"/\").append(denominator).append(\")\").toString();\n\t}\n\n}\n\nclass Line {\n\tFraction slope = null;\n\tFraction intercept = null;\n\t\n\tpublic static Line getLine(Point a, Point b) {\n\t\tif(a.x==b.x)\n\t\t\treturn new Line(Fraction.INFINITE,new Fraction(a.x,1));\n\t\tif(a.x > b.x) \n\t\t\treturn getLine(b,a);\n\t\telse{\n\t\t\tint sn = b.y-a.y;\n\t\t\tint sd = b.x-a.x;\n\t\t\tint in = sd*a.y - sn*a.x;\n\t\t\tint id = sd;\n\t\t\treturn new Line(sn, sd, in, id);\n\t\t}\n\t}\n\t\n\tprivate Line(int sn, int sd, int in, int id) {\n\t\tthis(new Fraction(sn,sd),new Fraction(in,id));\n\t}\n\t\n\tprivate Line(Fraction slope, Fraction intercept) {\n\t\tthis.slope=slope;\n\t\tthis.intercept=intercept;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((intercept == null) ? 0 : intercept.hashCode());\n\t\tresult = prime * result + ((slope == null) ? 0 : slope.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tLine other = (Line) obj;\n\t\tif (intercept == null) {\n\t\t\tif (other.intercept != null)\n\t\t\t\treturn false;\n\t\t} else if (!intercept.equals(other.intercept))\n\t\t\treturn false;\n\t\tif (slope == null) {\n\t\t\tif (other.slope != null)\n\t\t\t\treturn false;\n\t\t} else if (!slope.equals(other.slope))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn new StringBuilder().append(\"Line(\").append(slope).append(\",\").append(intercept).append(\")\").toString();\n\t}\n\n}\n\nclass ModUtil {\n\t//Static Fields\n\tpublic static final int BASE_DEF = 998244353;\n\tpublic static final int CAPACITY_F = 200;\n\t\n\t//Fields\n\tprotected int mod = BASE_DEF;\n\tprotected int capacity = CAPACITY_F;\n\tprivate int[] Farray = null;;\n\tprivate int[] FInvarray = null;\n\n\t//Constructors\n\tpublic ModUtil() {\n\t\tinitF();\n\t}\n\tpublic ModUtil(int m, int cap) {\n\t\tmod = m;\n\t\tcapacity=cap;\n\t\tinitF();\n\t}\n\t\n\t//Methods\n\t//Initializer\n\tprotected void initF() {\n\t\tif(Farray != null) return;\n\t\tFarray = new int[capacity+1];\n\t\tFInvarray = new int[capacity+1];\n\t\tfor(int n=0; n<Farray.length; n++) {\n\t\t\tFarray[n] = (n==0) ? 1 : multiple(n, Farray[n-1]);\n\t\t\tFInvarray[n] = divide(1, Farray[n]);\n\t\t}\n\t}\n\n\t//Basic Opertion\n\tpublic int modulo(long v) {return (int)(v%mod);}\n\tpublic int add(int a, int b) {return modulo(a + b);}\n\tpublic int sub(int a, int b) {return add(a, mod - b);}\n\tpublic int multiple(int a, int b) {return modulo((long)a * modulo(b));}\n\tpublic int divide(int a, int b) {return multiple(a, power(b, mod-2));}\n\t\n\tpublic int divideF(int a, int fn) {\n\t\tif(fn<=capacity) {\n\t\t\treturn multiple(a, getFInv(fn));\n\t\t}else{\n\t\t\treturn divide(a, getF(fn));\n\t\t}\n\t}\n\t\n\tpublic int power(int a, int b) {\n\t\tint ret = 1;\n\t\tfor (int bitMask = 1; bitMask<=b; bitMask<<=1) {\n\t\t\tif ( (b & bitMask) != 0 ) ret = multiple(ret, a);\n\t\t\ta = multiple(a, a);\n\t\t}\n\t\treturn ret;\n\t}\n\n\t//Factorial Operation\n\tpublic int getF(int n) {return Farray[n];}\n\tpublic int getFInv(int n) {return FInvarray[n];}\n\n\t//Permutation Operation\n\tprotected int calcP(int n, int r) {\n\t\tif (n < 0 || r < 0 || n < r) throw new IllegalArgumentException(\"n=\" +n+ \",r=\" +r);\n\t\tif (n <= 1 || r == 0) return 1;\n\t\tif (r == 1) return n;\n\t\treturn divideF(getF(n), n-r);\n\t\t\n\t}\n\n\tpublic int getP(int n, int r) {return calcP(n, r);}\n\n\t//Combination Operation\n\tprotected int calcC(int n, int r) {\n\t\tif(n < 0 || r < 0 || n < r) throw new IllegalArgumentException(\"n=\" +n+ \",r=\" +r);\n\t\tif(n == 0 || n == 1) return 1;\n\t\tif(n - r < r) r = n - r;\n\t\treturn divideF(divideF(getF(n), r),n-r);\n\t}\n\t\n\tpublic int getC(int n, int r) {return calcC(n,r);}\n\tpublic int getH(int n, int r) {return calcC(n+r-1, r);}\n\n}\n\nclass MyMath {\n\tpublic static long getGcd(long a, long b){\n\t\tlong tmp = 0;\n\t\twhile (a%b!=0) {\n\t\t\ttmp = b;\n\t\t\tb = a%b;\n\t\t\ta = tmp;\n\t\t}\n\t\treturn b;\n\t}\n\n\tpublic static int getGcd(int a, int b){\n\t\treturn (int)getGcd((long)a, (long)b);\n\t}\n\n\t\n\tpublic static long getLcm(long a, long b){\n\t\tlong gcd = getGcd(a,b);\n\t\treturn (a/gcd)*b;\n\t}\n\tpublic static int getLcm(int a, int b){\n\t\treturn (int)getLcm((long)a, (long)b);\n\t}\n\t\n\t\n\n}\n\nclass InputUtil {\n\t//Static Fields\n\tprivate static final int BUFSIZ = 100000;\n\t\n\t//Fields\n\tprotected InputStream in;\n\tprivate byte[] buf = null;\n\tprivate int ptr = 0;\n\tprivate int max = -1;\n\tprivate DataInputStream dis = null;\n\t//Constructors\n\tpublic InputUtil() {this(System.in,BUFSIZ);}\n\tpublic InputUtil(InputStream in, int bufsiz) {\n\t\tinitBuf(bufsiz);\n\t\tinitIn(in);\n\t}\n\t\n\t//Methods\n\t//Initializer\n\tprotected void initIn(InputStream in) {dis = new DataInputStream(this.in = in);}\n\tprotected void initBuf(int bufsiz) {buf = new byte[bufsiz];}\n\t\n\t//buffer operation\n\tprivate void next() throws IOException {ptr++; readBuf();}\n\tprivate void readBuf() throws IOException {\n\t\tif(ptr >= max && dis.available()>0) {\n\t\t\tif(max>0) Arrays.fill(buf,0,max,(byte)0);\n\t\t\tmax = dis.read(buf);\n\t\t\tptr = 0;\n\t\t}\n\t}\n\t\n\t//Number Input Reader/Parser\n\tprivate boolean isNum(byte b) {return '0' <= b && b <= '9'; }\n\tprivate boolean isMinus(byte b) {return b=='-'; }\n\n\tprivate int _nextInt() throws IOException {\n\t\tint sign = 1;\n\t\tint res = 0;\n\t\tbyte c;\n\t\twhile (!isNum(c=buf[ptr]) && !isMinus(c)) \n\t\t\tnext();\n\t\tif (isMinus(buf[ptr])) {\n\t\t\tsign = -1;\n\t\t\tnext();\n\t\t}\n\t\twhile (isNum(c=buf[ptr])) {\n\t\t\tres *= 10;\n\t\t\tres += c - '0' ;\n\t\t\tnext();\n\t\t}\n\t\tnext();\n\t\treturn sign * res;\n\t}\n\t\n\tpublic int nextInt() throws IOException {\n\t\treadBuf();\n\t\treturn _nextInt();\n\t}\n\n\tpublic int[] nextInt(int[] result) throws IOException {\n\t\treadBuf();\n\t\tfor(int i=0; i<result.length; i++) {\n\t\t\tresult[i] = _nextInt();\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t//Close \n\tpublic void close() throws IOException {\n\t\tif(!this.in.equals(System.in)) \n\t\t\tthis.in.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tfinal long MODULO = 998244353L;\n\tlong[] fac = new long[400];\n\tlong[] invfac = new long[400];\n\tlong[] inv = new long[400];\n\tlong[][] C = new long[400][400];\n\tlong[] pow2 = new long[400];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i % MODULO;\n\t\t}\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = (MODULO - (MODULO / i) * inv[(int) (MODULO % i)] % MODULO) % MODULO;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MODULO;\n\t\t}\n\t\tC[0][0] = 1;\n\t\tfor (int i = 1; i < C.length; ++i) {\n\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\tC[i][j] = (j > 0 ? C[i - 1][j - 1] : 0) + C[i - 1][j];\n\t\t\t\tC[i][j] %= MODULO;\n\t\t\t}\n\t\t}\n\t\tpow2[0] = 1;\n\t\tfor (int i = 1; i < pow2.length; ++i) {\n\t\t\tpow2[i] = pow2[i - 1] * 2 % MODULO;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tRandom rand = new Random();\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\t// int n = rand.nextInt(5);\n\t\t\tlong[] x = new long[n];\n\t\t\tlong[] y = new long[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\t// x[i] = rand.nextInt(5);\n\t\t\t\t// y[i] = rand.nextInt(5);\n\t\t\t}\n\t\t\tsolver(n, x, y);\n\t\t}\n\t}\n\n\tvoid solver(int n, long[] x, long[] y) {\n\t\tlong ans = pow2[n];\n\n\t\tans = (ans - n + MODULO) % MODULO;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tvis[i] = true;\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tif (vis[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tvis[j] = true;\n\t\t\t\tint cnt = 1;\n\t\t\t\tfor (int k = j + 1; k < n; ++k) {\n\t\t\t\t\tif ((x[i] - x[j]) * (y[k] - y[i]) == (y[i] - y[j]) * (x[k] - x[i])) {\n\t\t\t\t\t\tif (vis[k]) {\n\t\t\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvis[k] = true;\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = (ans - (pow2[cnt] - 1) + MODULO) % MODULO;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans - 1);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int[][] p = ntable(n, 2);\n    int mod = 998244353;\n\n    long ret = modpow(2, n, mod);\n    Map<Long, Set<Integer>> map = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        long a = p[i][1] - p[j][1];\n        long b = p[i][0] - p[j][0];\n        long c = p[i][0] * (p[j][1] - p[i][1]) - p[i][1] * (p[j][0] - p[i][0]);\n        long gcd = gcd(a, gcd(b, c));\n\n        long hash = (a * 100000L * 100000L + b * 100000L + c) / gcd;\n        if (!map.containsKey(hash)) map.put(hash, new HashSet<>());\n        map.get(hash).add(i);\n        map.get(hash).add(j);\n      }\n    }\n    for (Set<Integer> v : map.values()) {\n      ret += mod - modpow(2, v.size(), mod) + v.size() + 1;\n      ret %= mod;\n    }\n    ret += mod - n - 1;\n    ret %= mod;\n    out.println(ret);\n  }\n\n  public static long gcd(long a, long b) {\n    if (a > b) {\n      long tmp = a;\n      a = b;\n      b = tmp;\n    }\n    while (a != 0) {\n      long c = a;\n      a = b % c;\n      b = c;\n    }\n    return b;\n  }\n\n  public static long modpow(long a, long n, long mod) {\n    long ret = 1;\n    long mul = a;\n    for (; n > 0; n >>>= 1) {\n      if ((n & 1) == 1) {\n        ret = (ret * mul) % mod;\n      }\n      mul = (mul * mul) % mod;\n    }\n    return ret;\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\t\n\tstatic class Point {\n\t\tint x, y;\n\t\tpublic Point(int xx, int yy) {\n\t\t\tx = xx;\n\t\t\ty = yy;\n\t\t}\n\t\tint cross(Point o) {\n\t\t\treturn x * o.y - o.x * y;\n\t\t}\n\t\tPoint sub(Point o){\n\t\t\treturn new Point(x - o.x, y - o.y);\n\t\t}\n\t}\n\t\n\tstatic class Scanner{\n\t\tBufferedReader br=null;\n\t\tStringTokenizer tk=null;\n\t\tpublic Scanner(){\n\t\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tpublic String next() throws IOException{\n\t\t\twhile(tk==null || !tk.hasMoreTokens()) {\n\t\t\t\tString cad = br.readLine();\n\t\t\t\tif (cad == null)\n\t\t\t\t\treturn null;\n\t\t\t\ttk=new StringTokenizer(cad);\n\t\t\t}\n\t\t\treturn tk.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws NumberFormatException, IOException{\n\t\t\treturn Integer.valueOf(next());\n\t\t}\n\t\tpublic long nextLong() throws NumberFormatException, IOException{\n\t\t\treturn Long.valueOf(next());\n\t\t}\n\t\tpublic double nextDouble() throws NumberFormatException, IOException{\n\t\t\treturn Double.valueOf(next());\n\t\t}\n\t}\n\t\n\tstatic long mod = 998244353;\n\tstatic long[] pow2;\n\t\n\tpublic static void main(String args[]) throws NumberFormatException, IOException {\n\t\tScanner sc = new Scanner();\n\t\tint N = sc.nextInt();\n\t\tPoint[] p = new Point[N];\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tp[i] = new Point(sc.nextInt(), sc.nextInt());\n\t\tpow2 = new long[N + 1];\n\t\tpow2[0] = 1;\n\t\tfor(int i = 1; i <= N; i++)\n\t\t\tpow2[i] = (pow2[i - 1] * 2) % mod;\n\t\tlong sub = 1;\n\t\tfor(int i = 0; i < N; i++) { \n\t\t\tsub++;\n\t\t\tfor(int j = i + 1; j < N; j++) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int k = j + 1; k < N; k++) {\n\t\t\t\t\tif (p[j].sub(p[i]).cross(p[k].sub(p[i])) == 0)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tsub = (sub + pow2[count]) % mod;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((pow2[N] - sub + mod) % mod);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tlong[][] co = new long[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tco[i] = new long[]{ni(), ni()};\n\t\t}\n\t\t\n\t\tint mod = 998244353;\n\t\tlong all = pow(2, n, mod) - n*(n-1)/2 - n - 1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tinner:\n\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\tint on = 0;\n\t\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\t\tif(onSameLine(co[i], co[k], co[j])){\n\t\t\t\t\t\tif(i != k && k != j && !isACB(co[i], co[k], co[j]))continue inner;\n\t\t\t\t\t\ton++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tall -= pow(2, on, mod) - on*(on-1)/2 - on - 1;\n\t\t\t}\n\t\t}\n\t\tall %= mod;\n\t\tif(all < 0)all += mod;\n\t\tout.println(all);\n\t}\n\tpublic static boolean isACB(long[] a, long[] b, long[] c) { return isACB(a[0], a[1], b[0], b[1], c[0], c[1]); }\n\t\n\tpublic static boolean isACB(long ax, long ay, long bx, long by, long cx, long cy)\n\t{\n\t\treturn (cx-ax)*(by-ay)-(cy-ay)*(bx-ax)==0 && (cx-ax)*(cx-bx)+(cy-ay)*(cy-by) <= 0;\n\t}\n\t\n\tpublic static boolean onSameLine(long[] a, long[] b, long[] c)\n\t{\n\t\treturn (c[0]-a[0])*(b[1]-a[1])-(c[1]-a[1])*(b[0]-a[0])==0;\n\t}\n\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n//\t\tint n = 200, m = 99999;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tsb.append(gen.nextInt(10000) + \" \");\n//\t\t\tsb.append(gen.nextInt(10000) + \" \");\n//\t\t}\n//\t\tINPUT = sb.toString();\n\n\t\t\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            LineGeometry.Point[] points = new LineGeometry.Point[n];\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt();\n                int y = in.nextInt();\n                points[i] = new LineGeometry.Point(x, y);\n            }\n\n            Modulo modulo = new Modulo(998244353);\n            long ans = modulo.pow(2, n);\n            ans = modulo.sub(ans, n + 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    int count = 0;\n                    for (int k = j + 1; k < n; k++) {\n                        if (LineGeometry.orientation(points[i], points[j], points[k]) == 0) {\n                            count++;\n                        }\n                    }\n\n                    ans -= modulo.pow(2, count);\n                }\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static class Modulo {\n        long m;\n\n        public Modulo(long m) {\n            this.m = m;\n        }\n\n        public long sub(long a, long b) {\n            return (a - b + m) % m;\n        }\n\n        public long pow(long a, long x) {\n            long ans = 1;\n            while (x > 0) {\n                if ((x & 1) != 0) {\n                    ans = (ans * a) % m;\n                }\n                x >>= 1;\n                a = (a * a) % m;\n            }\n            return ans;\n        }\n\n    }\n\n    static class LineGeometry {\n        static final double EPS = 1e-10;\n\n        public static int sign(double a) {\n            return a < -EPS ? -1 : a > EPS ? 1 : 0;\n        }\n\n        public static int orientation(LineGeometry.Point a, LineGeometry.Point b, LineGeometry.Point c) {\n            LineGeometry.Point AB = b.minus(a);\n            LineGeometry.Point AC = c.minus(a);\n            return sign(AB.cross(AC));\n        }\n\n        public static class Point implements Comparable<LineGeometry.Point> {\n            public double x;\n            public double y;\n\n            public Point(double x, double y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            public LineGeometry.Point minus(LineGeometry.Point b) {\n                return new LineGeometry.Point(x - b.x, y - b.y);\n            }\n\n            public double cross(LineGeometry.Point b) {\n                return x * b.y - y * b.x;\n            }\n\n\n            public int compareTo(LineGeometry.Point o) {\n                // return Double.compare(Math.atan2(y, x), Math.atan2(o.y, o.x));\n                return Double.compare(x, o.x) != 0 ? Double.compare(x, o.x) : Double.compare(y, o.y);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader in;\n        StringTokenizer tok;\n\n        public String nextString() {\n            while (!tok.hasMoreTokens()) {\n                try {\n                    tok = new StringTokenizer(in.readLine(), \" \");\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n            }\n            return tok.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n        public InputReader(InputStream inputStream) {\n            in = new BufferedReader(new InputStreamReader(inputStream));\n            tok = new StringTokenizer(\"\");\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author anand.oza\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EConvexScore solver = new EConvexScore();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EConvexScore {\n        int[] x;\n        int[] y;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n\n            NumberTheory.ModM m = new NumberTheory.ModM(998244353L);\n\n            long answer = 0;\n            answer = m.add(answer, m.pow(2, n));\n            answer = m.subtract(answer, m.ncr(n, 0));\n            answer = m.subtract(answer, m.ncr(n, 1));\n            answer = m.subtract(answer, m.ncr(n, 2));\n\n            x = new int[n];\n            y = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = in.nextInt();\n                y[i] = in.nextInt();\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    EConvexScore.Slope s = from(i, j);\n                    int count = 0;\n\n                    for (int k = 0; k < n; k++) {\n                        if (k == i || k == j)\n                            continue;\n\n                        if (from(i, k).eq(s)) {\n                            count++;\n                        }\n                    }\n\n                    if (count > 0) {\n                        count += 2;\n                        long overcount = m.pow(2, count);\n                        overcount = m.subtract(overcount, m.ncr(count, 0));\n                        overcount = m.subtract(overcount, m.ncr(count, 1));\n                        overcount = m.subtract(overcount, m.ncr(count, 2));\n                        overcount = m.div(overcount, m.ncr(count, 2));\n                        answer = m.subtract(answer, overcount);\n                    }\n                }\n            }\n\n            out.println(answer);\n        }\n\n        private EConvexScore.Slope from(int i, int j) {\n            int dx = x[j] - x[i];\n            int dy = y[j] - y[i];\n            return new EConvexScore.Slope(dx, dy);\n        }\n\n        static class Slope {\n            final int x;\n            final int y;\n\n            Slope(int x, int y) {\n                if (x < 0) {\n                    x *= -1;\n                    y *= -1;\n                }\n\n                int g = NumberTheory.gcd(x, y);\n                x /= g;\n                y /= g;\n\n                this.x = x;\n                this.y = y;\n            }\n\n            boolean eq(EConvexScore.Slope o) {\n                return x == o.x && y == o.y;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class NumberTheory {\n        public static int gcd(int a, int b) {\n            int c;\n            while (a != 0) {\n                c = a;\n                a = b % a;\n                b = c;\n            }\n            return b;\n        }\n\n        private static void ASSERT(boolean assertion) {\n            if (!assertion)\n                throw new AssertionError();\n        }\n\n        public abstract static class Modulus<M extends NumberTheory.Modulus<M>> {\n            ArrayList<Long> factorial = new ArrayList<>();\n            ArrayList<Long> invFactorial = new ArrayList<>();\n\n            public abstract long modulus();\n\n            public Modulus() {\n                super();\n                factorial.add(1L);\n                invFactorial.add(1L);\n            }\n\n            public long fact(int n) {\n                while (factorial.size() <= n) {\n                    factorial.add(mult(factorial.get(factorial.size() - 1), factorial.size()));\n                }\n\n                return factorial.get(n);\n            }\n\n            public long fInv(int n) {\n                while (invFactorial.size() <= n) {\n                    invFactorial.add(div(invFactorial.get(invFactorial.size() - 1), invFactorial.size()));\n                }\n\n                return invFactorial.get(n);\n            }\n\n            public long ncr(int n, int r) {\n                ASSERT(n >= 0);\n                if (r < 0 || n < r)\n                    return 0;\n                return mult(fact(n), mult(fInv(r), fInv(n - r)));\n            }\n\n            public long normalize(long x) {\n                x %= modulus();\n                if (x < 0)\n                    x += modulus();\n                return x;\n            }\n\n            public long add(long a, long b) {\n                return normalize(a + b);\n            }\n\n            public long subtract(long a, long b) {\n                return normalize(a - b);\n            }\n\n            public long mult(long a, long b) {\n                return normalize(a * b);\n            }\n\n            public long div(long a, long b) {\n                return mult(a, inv(b));\n            }\n\n            public long pow(long x, int e) {\n                if (e == 0)\n                    return 1;\n                if ((e & 1) > 0)\n                    return mult(x, pow(x, e - 1));\n                return pow(mult(x, x), e / 2);\n            }\n\n            public long inv(long value) {\n                long g = modulus(), x = 0, y = 1;\n                for (long r = value; r != 0; ) {\n                    long q = g / r;\n                    g %= r;\n\n                    long temp = g;\n                    g = r;\n                    r = temp;\n\n                    x -= q * y;\n\n                    temp = x;\n                    x = y;\n                    y = temp;\n                }\n\n                ASSERT(g == 1);\n                ASSERT(y == modulus() || y == -modulus());\n\n                return normalize(x);\n            }\n\n        }\n\n        public static class ModM extends NumberTheory.Modulus<NumberTheory.ModM> {\n            private final long modulus;\n\n            public ModM(long modulus) {\n                this.modulus = modulus;\n            }\n\n            public long modulus() {\n                return modulus;\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C solver = new C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C {\n        long mod = 998244353;\n        long[] p2;\n\n        long gcd(long a, long b) {\n            if (a < 0) a = -a;\n            if (b < 0) b = -b;\n            if (b == 0) return a;\n            return gcd(b, a % b);\n        }\n\n        long f(int k) {\n            if (k <= 2) {\n                return 0;\n            }\n            return ((p2[k] - (k * (k - 1) / 2) - k - 1) % mod + mod) % mod;\n        }\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] x = new int[n];\n            int[] y = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = in.nextInt();\n                y[i] = in.nextInt();\n            }\n\n            p2 = new long[n + 1];\n            p2[0] = 1;\n            for (int i = 0; i < n; i++) {\n                p2[i + 1] = (p2[i] * 2) % mod;\n            }\n\n            long ans = f(n);\n            Set<Line> lines = new HashSet<>();\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    long a = y[i] - y[j];\n                    long b = x[j] - x[i];\n                    long c = a * x[i] + b * y[i];\n                    long d = gcd(a, b);\n                    d = gcd(d, c);\n                    a /= d;\n                    b /= d;\n                    c /= d;\n                    if (a < 0 || a == 0 && b < 0) {\n                        a = -a;\n                        b = -b;\n                        c = -c;\n                    }\n\n                    Line l = new Line(a, b, c);\n                    if (lines.contains(l)) {\n                        continue;\n                    }\n                    lines.add(l);\n                    int cnt = 0;\n                    for (int k = 0; k < n; k++) {\n                        if (a * x[k] + b * y[k] == c) {\n                            cnt++;\n                        }\n                    }\n                    ans = ((ans - f(cnt)) % mod + mod) % mod;\n                }\n            }\n\n            out.println(ans);\n        }\n\n        class Line {\n            long a;\n            long b;\n            long c;\n\n            public Line(long a, long b, long c) {\n                this.a = a;\n                this.b = b;\n                this.c = c;\n            }\n\n\n            public boolean equals(Object o) {\n                if (this == o) return true;\n                if (o == null || getClass() != o.getClass()) return false;\n\n                Line line = (Line) o;\n\n                if (a != line.a) return false;\n                if (b != line.b) return false;\n                return c == line.c;\n            }\n\n\n            public int hashCode() {\n                int result = (int) (a ^ (a >>> 32));\n                result = 31 * result + (int) (b ^ (b >>> 32));\n                result = 31 * result + (int) (c ^ (c >>> 32));\n                return result;\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.security.SecureRandom;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws FileNotFoundException {\n        ConsoleIO io = new ConsoleIO(new InputStreamReader(System.in), new PrintWriter(System.out));\n        //String test = \"sample\";\n        //ConsoleIO io = new ConsoleIO(new FileReader(\"D:\\\\Dropbox\\\\code\\\\practice\\\\jb\\\\src\\\\\" + test + \".in\"), new PrintWriter(new File(\"D:\\\\Dropbox\\\\code\\\\practice\\\\jb\\\\src\\\\\" + test + \"-out.txt\")));\n\n       new Main(io).solve();\n\n        io.close();\n    }\n\n    ConsoleIO io;\n    Main(ConsoleIO io) {\n        this.io = io;\n    }\n\n    List<List<Integer>> gr = new ArrayList<>();\n    long MOD = 998244353; //1_000_000_007;\n\n    public void solve() {\n        int n = io.ri();\n        int[] x = new int[n];\n        int[] y = new int[n];\n        for(int i =0;i<n;i++) {\n            x[i] = io.ri();\n            y[i] = io.ri();\n        }\n\n        long[][] binom = new long[n+1][n+1];\n        binom[0][0] = 1;\n        for(int i = 1;i<=n;i++) {\n            binom[i][0] = 1;\n            for(int j = 1;j<=i;j++)\n                binom[i][j] = (binom[i-1][j-1]+binom[i-1][j])%MOD;\n        }\n        long res = 0;\n        for(int i = 3;i<=n;i++)\n            res = (res+binom[n][i])%MOD;\n\n        int[] count = new int[n+1];\n        for(int i = 0;i<n;i++) {\n            boolean[] marked = new boolean[n];\n            for (int j = i + 1; j < n; j++)if(!marked[j]) {\n                int k = 2;\n                int x1 = x[j] - x[i];\n                int y1 = y[j] - y[i];\n                for (int q = j + 1; q < n; q++) {\n                    int x2 = x[q] - x[i];\n                    int y2 = y[q] - y[i];\n                    if (x1 * y2 - x2 * y1 == 0) {\n                        k++;\n                        marked[q] = true;\n                    }\n                }\n                if(k>2){\n                    count[k]++;\n                }\n            }\n        }\n        for(int i = n;i>=3;i--) {\n            if (count[i] > 0) {\n                long minus = 0;\n                for (int j = 3; j <= i; j++)\n                    minus = (minus + binom[i][j]) % MOD;\n                res = (res - count[i] * minus + MOD) % MOD;\n                for (int j = i - 1; j > 0; j--)\n                    count[j] -= count[i];\n            }\n        }\n        io.writeLine(res+\"\");\n    }\n}\n\nclass ConsoleIO {\n    BufferedReader br;\n    PrintWriter out;\n    public ConsoleIO(Reader reader, PrintWriter writer){br = new BufferedReader(reader);out = writer;}\n    public void flush(){this.out.flush();}\n    public void close(){this.out.close();}\n    public void writeLine(String s) {this.out.println(s);}\n    public void writeInt(int a) {this.out.print(a);this.out.print(' ');}\n    public void writeWord(String s){\n        this.out.print(s);\n    }\n    public void writeIntArray(int[] a, int k, String separator) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < k; i++) {\n            if (i > 0) sb.append(separator);\n            sb.append(a[i]);\n        }\n        this.writeLine(sb.toString());\n    }\n    public int read(char[] buf, int len){try {return br.read(buf,0,len);}catch (Exception ex){ return -1; }}\n    public String readLine() {try {return br.readLine();}catch (Exception ex){ return \"\";}}\n    public long[] readLongArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");long[]r=new long[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Long.parseLong(n[i]);\n        return r;\n    }\n    public int[] readIntArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");int[]r=new int[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Integer.parseInt(n[i]);\n        return r;\n    }\n    public int[] readIntArray(int n) {\n        int[] res = new int[n];\n        char[] all = this.readLine().toCharArray();\n        int cur = 0;boolean have = false;\n        int k = 0;\n        boolean neg = false;\n        for(int i = 0;i<all.length;i++){\n            if(all[i]>='0' && all[i]<='9'){\n                cur = cur*10+all[i]-'0';\n                have = true;\n            }else if(all[i]=='-') {\n                neg = true;\n            }\n            else if(have){\n                res[k++] = neg?-cur:cur;\n                cur = 0;\n                have = false;\n                neg = false;\n            }\n        }\n        if(have)res[k++] = neg?-cur:cur;\n        return res;\n    }\n    public int ri() {\n        try {\n            int r = 0;\n            boolean start = false;\n            boolean neg = false;\n            while (true) {\n                int c = br.read();\n                if (c >= '0' && c <= '9') {\n                    r = r * 10 + c - '0';\n                    start = true;\n                } else if (!start && c == '-') {\n                    start = true;\n                    neg = true;\n                } else if (start || c == -1) return neg ? -r : r;\n            }\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n    public long readLong() {\n        try {\n            long r = 0;\n            boolean start = false;\n            boolean neg = false;\n            while (true) {\n                int c = br.read();\n                if (c >= '0' && c <= '9') {\n                    r = r * 10 + c - '0';\n                    start = true;\n                } else if (!start && c == '-') {\n                    start = true;\n                    neg = true;\n                } else if (start || c == -1) return neg ? -r : r;\n            }\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n    public String readWord() {\n        try {\n            boolean start = false;\n            StringBuilder sb = new StringBuilder();\n            while (true) {\n                int c = br.read();\n                if (c!= ' ' && c!= '\\r' && c!='\\n' && c!='\\t') {\n                    sb.append((char)c);\n                    start = true;\n                } else if (start || c == -1) return sb.toString();\n            }\n        } catch (Exception ex) {\n            return \"\";\n        }\n    }\n    public char readSymbol() {\n        try {\n            while (true) {\n                int c = br.read();\n                if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t') {\n                    return (char) c;\n                }\n            }\n        } catch (Exception ex) {\n            return 0;\n        }\n    }\n    //public char readChar(){try {return (char)br.read();}catch (Exception ex){ return 0; }}\n}\nclass Pair {\n    public Pair(int a, int b) {this.a = a;this.b = b;}\n    public int a;\n    public int b;\n}\nclass PairLL {\n    public PairLL(long a, long b) {this.a = a;this.b = b;}\n    public long a;\n    public long b;\n}\nclass Triple {\n    public Triple(int a, int b, int c) {this.a = a;this.b = b;this.c = c;}\n    public int a;\n    public int b;\n    public int c;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskE {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int MOD = 998244353;\n\t\t\tint n = in.nextInt();\n\t\t\tPoint[] p = new Point[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\t\t\t\tp[i] = new Point(x, y, i);\n\t\t\t}\n\t\t\tint[] p2 = new int[n + 1];\n\t\t\tp2[0] = 1;\n\t\t\tfor (int i = 1; i < p2.length; i++) {\n\t\t\t\tp2[i] = 2 * p2[i - 1] % MOD;\n\t\t\t}\n\n\t\t\tArrays.sort(p, (u, v) -> {\n\t\t\t\tif (u.x != v.x) {\n\t\t\t\t\treturn u.x - v.x;\n\t\t\t\t}\n\t\t\t\tif (u.y != v.y) {\n\t\t\t\t\treturn u.y - v.y;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tint ans = 0;\n\t\t\tint[][] d = new int[n][n];\n\t\t\tint[][] g = new int[n][n];\n\t\t\tfor (int s = 0; s < n; s++) {\n\t\t\t\tPoint[] r = new Point[n - s - 1];\n\t\t\t\tSystem.arraycopy(p, s + 1, r, 0, r.length);\n\t\t\t\tfinal Point o = p[s];\n\t\t\t\tArrays.sort(r, (u, v) -> {\n\t\t\t\t\tPoint u1 = u.sub(o);\n\t\t\t\t\tPoint v1 = v.sub(o);\n\t\t\t\t\treturn -Long.signum(cross(u1, v1));\n\t\t\t\t});\n\n\t\t\t\t// Number of points inside or on the borders of the triangle ij.\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < r.length; j++) {\n\t\t\t\t\t\tg[i][j] = 0;\n\t\t\t\t\t\tfor (int k = i + 1; k < j; k++) {\n\t\t\t\t\t\t\tif (cross(r[k].sub(r[i]), r[j].sub(r[i])) > 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++g[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int[] arr : d) {\n\t\t\t\t\tArrays.fill(arr, 0);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < r.length; j++) {\n\t\t\t\t\t\tif (cross(r[i].sub(o), r[j].sub(o)) <= 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\td[i][j] += p2[g[i][j]];\n\t\t\t\t\t\tif (d[i][j] >= MOD) {\n\t\t\t\t\t\t\td[i][j] -= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += d[i][j];\n\t\t\t\t\t\tif (ans >= MOD) {\n\t\t\t\t\t\t\tans -= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = j + 1; k < r.length; k++) {\n\t\t\t\t\t\t\tif (cross(r[k].sub(r[j]), r[k].sub(r[i])) >= 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\td[j][k] = (int) ((d[j][k] + (long) d[i][j] * p2[g[j][k]]) % MOD);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long cross(Point p1, Point p2) {\n\t\t\treturn p1.x * (long) p2.y - p1.y * (long) p2.x;\n\t\t}\n\n\t\tclass Point {\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint id;\n\n\t\t\tPoint(int x, int y, int id) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.id = id;\n\t\t\t}\n\n\t\t\tPoint sub(Point o) {\n\t\t\t\treturn new Point(x - o.x, y - o.y, -1);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    long MOD = 998244353;\n    int inf = Integer.MAX_VALUE/2;\n\n\n    void solve(){\n        int n = ni();\n        int[][] x = new int[n][2];\n        for(int i = 0; i < n; i++){\n            x[i][0] = ni();\n            x[i][1] = ni();\n        }\n        long total = 1;\n        for(int i = 0; i < n; i++){\n            total *= 2;\n            total %= MOD;\n        }\n        total--;\n        long res = n;\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                long p = 1;\n                int[] v1 = new int[]{x[j][0]-x[i][0], x[j][1]-x[i][1]};\n                for(int k = j+1; k < n; k++){\n                    int[] v2 = new int[]{x[k][0]-x[i][0], x[k][1]-x[i][1]};\n                    int cross = v1[0]*v2[1] - v1[1]*v2[0];\n                    if(cross==0){\n                        out.println(i+\" \"+j+\" \"+k);\n                        p*=2;\n                        p %= MOD;\n                        out.println(p);\n                    }\n                }\n                res += p;\n                res %= MOD;\n            }\n        }\n        res %= MOD;\n        total = (total-res+MOD)%MOD;\n        out.println(total);\n\n    }    \n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tclass Point {\n\t\tlong x, y;\n\n\t\tpublic Point(long x, long y) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t}\n\t\n\tlong vm(Point a, Point b, Point c) {\n\t\treturn (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n\t}\n\t\n\tvoid solve() {\n\t\tint mod = 998244353;\n\t\tint n = in.nextInt();\n\t\tPoint[] a=  new Point[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = new Point(in.nextLong(), in.nextLong());\n\t\t}\n\t\tlong[] pow2 = new long[n + 1];\n\t\tpow2[0] = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpow2[i + 1] = pow2[i] * 2 % mod;\n\t\t}\n\t\tlong result = pow2[n] - 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tresult--;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\tif (vm(a[i], a[j], a[k]) == 0) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult -= pow2[cnt];\n\t\t\t}\n\t\t}\n\t\tout.println((result % mod + mod) % mod);\n\t\t\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int mod = 998244353;\n    static int add(int a, int b) {\n        int c = a + b;\n        if (c >= mod) return c - mod;\n        if (c < 0) return c + mod;\n        return c;\n    }\n    static int mult(int a, int b) {\n        long c = (long) a * b % mod;\n        return (int) c;\n    }\n    public static int pow(int a, int b) {\n        int ret = 1;\n        while (b != 0) {\n            if (b % 2 == 1) ret = mult(ret, a);\n            a = mult(a, a);\n            b >>= 1;\n        }\n        return ret;\n    }\n    static int count(int n) {\n        int ch = pow(2, n);\n        ch = add(ch, -1);\n        ch = add(ch, -n);\n        ch = add(ch, -n * (n - 1) / 2);\n        return ch;\n    }\n    static boolean coline(int a1, int a2, int b1, int b2, int c1, int c2) {\n        return (b1 - a1) * (c2 - a2) == (b2 - a2) * (c1 - a1);\n    }\n    static int segCount(int n) {\n        int ch = pow(2, n);\n        ch = add(ch, -1);\n        return ch;\n    }\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] points = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 2; j++) {\n                points[i][j] = sc.nextInt();\n            }\n        }\n        int tot = count(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int col = 0;\n                for (int k = j + 1; k < n; k++) {\n                    if (coline(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])) {\n                        col++;\n                    }\n                }\n                if (col > 0) {\n                    tot = add(tot, -segCount(col));\n                }\n            }\n        }\n        System.out.println(tot);\n    }\n\n    public static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n        public int nextInt() throws IOException{\n            return Integer.parseInt(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.HashMap;\n\nclass Main{\n\n    static long C=20000*20000;\n    static long B=20000;\n    static long A=1;\n\n    static long baseC = (long)1e8;\n    static long baseB = (long)1e4;\n    static long baseA = (long)1e4;\n\n    static long mod =998244353;\n\n    static int gcd(int x, int y){\n        if(x*y==0)return 1;\n        if(x%y==0)return x/y;\n        return gcd(y, x%y);\n    }\n\n    static long getVal(int a, int b,int c){\n        int m = gcd(a, gcd(b,c));\n        a/=m; b/=m; c/=m;\n        return ((long)c+baseC)*C + ((long)b + baseB)*B +((long)a + baseA)*A;\n    }\n\n    static long getLine(int x1,int y1,int x2, int y2){\n        if(x1==x2)return getVal(1, 0, -x1);\n        \n        if(y2-y1<0){\n            int tmp = y1;y1=y2;y2=tmp;\n            tmp=x1;x1=x2;x2=tmp;\n        }else if(y2-y1==0 && x2-x1<0){\n            int tmp = x1;x1=x2;x2=tmp;\n        }\n        return getVal(y2-y1, x2-x1, y2*x1-y1*x2);\n    }\n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        int[] x = new int[N];\n        int[] y = new int[N];\n        for(int i=0;i<N;++i){\n            x[i]=scan.nextInt();\n            y[i]= scan.nextInt();\n        }\n        long two[] = new long[N+1];\n        two[0]=1;\n        for(int i=1;i<=N;++i)two[i]=(two[i-1]*2)%mod;\n\n        long ans = two[N];\n        ans = (ans - (N*(N-1)/2) - N -1 +mod)%mod;\n\n        Set<Long> used = new HashSet<>();\n        for(int i=0;i<N;++i){\n            Map<Long, Integer> line = new HashMap<>();\n            for(int j=i+1;j<N;++j){\n                long l = getLine(x[i], y[i], x[j], y[j]);\n                if(used.contains(l))continue;\n                if(!line.containsKey(l))line.put(l,0);\n                line.put(l, line.get(l)+1);\n            }\n            for(Map.Entry<Long, Integer> entry : line.entrySet()){\n                if(entry.getValue() >1){\n                    int k = entry.getValue()+1;\n                    ans = (ans - (two[k] - (k*(k-1)/2 +k +1) +mod)%mod +mod)%mod;\n                    used.add(entry.getKey());\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int[][] pts = new int[n][2];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 2; j++) {\n                    pts[i][j] = in.readInt();\n                }\n            }\n\n            NumberTheory.Modular mod = new NumberTheory.Modular(998244353);\n            NumberTheory.Power pow = new NumberTheory.Power(mod);\n            int ans = pow.pow(2, n);\n            ans = mod.subtract(ans, 1);\n            ans = mod.subtract(ans, n);\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    boolean valid = true;\n                    for (int k = 0; k < j; k++) {\n                        if (k == i || k == j) {\n                            continue;\n                        }\n                        if (cross(pts[j][0] - pts[i][0], pts[j][1] - pts[i][1], pts[k][0] - pts[i][0],\n                                        pts[k][1] - pts[i][1]) == 0) {\n                            valid = false;\n                        }\n                    }\n                    if (!valid) {\n                        continue;\n                    }\n\n                    int cnt = 2;\n                    for (int k = j + 1; k < n; k++) {\n                        if (cross(pts[j][0] - pts[i][0], pts[j][1] - pts[i][1], pts[k][0] - pts[i][0],\n                                        pts[k][1] - pts[i][1]) == 0) {\n                            cnt++;\n                        }\n                    }\n\n                    int local = pow.pow(2, cnt);\n                    local = mod.subtract(local, 1);\n                    local = mod.subtract(local, cnt);\n                    ans = mod.subtract(ans, local);\n                }\n            }\n\n            out.println(ans);\n        }\n\n        int cross(int x1, int y1, int x2, int y2) {\n            return x1 * y2 - y1 * x2;\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class Power {\n            final NumberTheory.Modular modular;\n\n            public Power(NumberTheory.Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return modular.valueOf(1);\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n//\tstatic String INPUT = \"3 0 3 3 0 2 2\";\n//\tstatic String INPUT = \"3 3 2 1 0 1 3\";\n//\tstatic String INPUT = \"3 1 2 2 1 3 0\";\n\tstatic String INPUT = \"\";\n\t\n\tstatic long[] p2 = new long[1000];\n\tstatic long[] ip2 = new long[1000];\n\tstatic long p(int n)\n\t{\n\t\treturn n >= 0 ? p2[n] : ip2[-n];\n\t}\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 998244353;\n\t\tp2[0] = 1;\n\t\tip2[0] = 1;\n\t\tlong i2 = invl(2, mod);\n\t\tfor(int i = 1;i < 1000;i++){\n\t\t\tp2[i] = p2[i-1] * 2 % mod;\n\t\t\tip2[i] = ip2[i-1] * i2 % mod;\n\t\t}\n\t\t\n\t\tint n = ni();\n\t\tlong[][] co = new long[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tco[i] = new long[]{ni(), ni()};\n\t\t}\n\t\t\n\t\tArrays.sort(co, new Comparator<long[]>() {\n\t\t\tpublic int compare(long[] a, long[] b) {\n\t\t\t\tif(a[0] != b[0])return Long.compare(a[0], b[0]);\n\t\t\t\treturn Long.compare(a[1], b[1]);\n\t\t\t}\n\t\t});\n\t\tint ct = 0;\n\t\t\n\t\t\n\t\tlong[][] sums = new long[n][n];\n\t\t{\n\t\t\tint[][] under = new int[n][n];\n\t\t\t// o-x\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t\tif(co[i][0] < co[j][0]){\n\t\t\t\t\t\tfor(int k = 0;k < j;k++){\n\t\t\t\t\t\t\tif(co[i][0] <= co[k][0] && co[k][0] < co[j][0] && ccw(co[i], co[j], co[k]) > 0){\n\t\t\t\t\t\t\t\tunder[i][j]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tunder[i][j]++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int k = i+1;k < j;k++){\n\t\t\t\t\t\t\tif(co[i][0] == co[k][0] && co[k][1] < co[j][1]){\n\t\t\t\t\t\t\t\tunder[i][j]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tlong[][] sum = new long[n][n];\n\t\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t\tsum[j][i] = p(-under[i][j]);\n\t\t\t\t\tsums[i][j] += sum[j][i];\n\t\t\t\t\tfor(int k = i+1;k < j;k++){\n\t\t\t\t\t\tfor(int l = i;l < k;l++){ // l-k-j\n\t\t\t\t\t\t\tif(ccw(co[l], co[k], co[j]) < 0){\n\t\t\t\t\t\t\t\tsum[j][k] += sum[k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong q = p(-under[k][j]);\n\t\t\t\t\t\tsum[j][k] = sum[j][k] % mod * q % mod;\n\t\t\t\t\t\tsums[i][j] += sum[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tsums[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t{\n\t\t\tint[][] under = new int[n][n];\n\t\t\t// o-x\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t\tif(co[i][0] < co[j][0]){\n\t\t\t\t\t\tfor(int k = 0;k < j;k++){\n\t\t\t\t\t\t\tif(co[i][0] <= co[k][0] && co[k][0] < co[j][0] && ccw(co[i], co[j], co[k]) >= 0){\n\t\t\t\t\t\t\t\tunder[i][j]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tunder[i][j]--;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tunder[i][j]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\t\tlong[][] sum = new long[n][n];\n\t\t\t\tfor(int j = i-1;j >= 0;j--){\n\t\t\t\t\tsum[j][i] = p(under[j][i]+1);\n\t\t\t\t\tsums[i][j] += sum[j][i];\n\t\t\t\t\tfor(int k = i-1;k > j;k--){\n\t\t\t\t\t\tfor(int l = i;l > k;l--){ // i-l-k-j\n\t\t\t\t\t\t\tif(ccw(co[l], co[k], co[j]) < 0){\n\t\t\t\t\t\t\t\tsum[j][k] += sum[k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong q = p(under[j][k]);\n\t\t\t\t\t\tsum[j][k] = sum[j][k] % mod * q % mod;\n\t\t\t\t\t\tsums[i][j] += sum[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tsums[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tfor(long[] row : nums){\n//\t\t\ttr(row);\n//\t\t}\n//\t\ttr();\n//\t\tfor(long[] row : sums){\n//\t\t\ttr(row);\n//\t\t}\n//\t\ttr(co);\n\t\t\n\t\tlong ret = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\tret += sums[i][j] * sums[j][i];\n\t\t\t\tret %= mod;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\tint on = 0;\n\t\t\t\tfor(int k = i+1;k < j;k++){\n\t\t\t\t\tif(ccw(co[i], co[j], co[k]) == 0){\n\t\t\t\t\t\ton++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret -= p2[on];\n\t\t\t}\n\t\t}\n\t\tret %= mod;\n\t\tif(ret < 0)ret += mod;\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\t\n\tpublic static int ccw(long[] a, long[] b, long[] t) {\n\t\treturn Long.signum((t[0] - a[0]) * (b[1] - a[1]) - (b[0] - a[0]) * (t[1] - a[1]));\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n//\t\tint n = 200, m = 99999;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tsb.append(gen.nextInt(10000) + \" \");\n//\t\t\tsb.append(gen.nextInt(10000) + \" \");\n//\t\t}\n//\t\tINPUT = sb.toString();\n\n\t\t\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author anand.oza\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EConvexScore solver = new EConvexScore();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EConvexScore {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n\n            NumberTheory.ModM m = new NumberTheory.ModM(998244353L);\n\n            long answer = 0;\n            answer = m.add(answer, m.pow(2, n));\n            answer = m.subtract(answer, m.ncr(n, 0));\n            answer = m.subtract(answer, m.ncr(n, 1));\n            answer = m.subtract(answer, m.ncr(n, 2));\n\n            Point[] p = new Point[n];\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt(), y = in.nextInt();\n                p[i] = new Point(x, y);\n            }\n\n            HashSet<Line> lines = new HashSet<>();\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    Line l = new Line(p[i], p[j]);\n                    if (lines.contains(l))\n                        continue;\n                    lines.add(l);\n\n                    int count = 0;\n                    for (int k = 0; k < n; k++) {\n                        if (l.contains(p[k])) {\n                            count++;\n                        }\n                    }\n\n                    long overcount = m.pow(2, count);\n                    overcount = m.subtract(overcount, m.ncr(count, 0));\n                    overcount = m.subtract(overcount, m.ncr(count, 1));\n                    overcount = m.subtract(overcount, m.ncr(count, 2));\n\n                    answer = m.subtract(answer, overcount);\n                }\n            }\n\n            out.println(answer);\n        }\n\n    }\n\n    static class Point implements Comparable<Point> {\n        long x;\n        long y;\n\n        public Point(long x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Point point = (Point) o;\n            return x == point.x && y == point.y;\n        }\n\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n\n        public int compareTo(Point o) {\n            int ret = Long.compare(x, o.x);\n            if (ret != 0)\n                return ret;\n            return Long.compare(y, o.y);\n        }\n\n    }\n\n    static class Util {\n        public static void ASSERT(boolean assertion) {\n            if (!assertion)\n                throw new AssertionError();\n        }\n\n    }\n\n    static class Line {\n        final long a;\n        final long b;\n        final long c;\n\n        public Line(Point p1, Point p2) {\n            long a = p1.y - p2.y;\n            long b = -p1.x + p2.x;\n\n            Util.ASSERT(a != 0 || b != 0);\n            long c = -(a * p1.x + b * p1.y);\n\n            long g = NumberTheory.gcd(c, NumberTheory.gcd(a, b));\n            a /= g;\n            b /= g;\n            c /= g;\n\n            if (a < 0) {\n                a *= -1;\n                b *= -1;\n                c *= -1;\n            }\n            if (a == 0 && b < 0) {\n                b *= -1;\n                c *= -1;\n            }\n\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        public Line(long a, long b, long c) {\n            Util.ASSERT(a != 0 || b != 0);\n\n            long g = NumberTheory.gcd(c, NumberTheory.gcd(a, b));\n            a /= g;\n            b /= g;\n            c /= g;\n\n            if (a < 0) {\n                a *= -1;\n                b *= -1;\n                c *= -1;\n            }\n            if (a == 0 && b < 0) {\n                b *= -1;\n                c *= -1;\n            }\n\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        public boolean contains(Point p) {\n            return a * p.x + b * p.y + c == 0;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Line l = (Line) o;\n            return a == l.a && b == l.b && c == l.c;\n        }\n\n        public int hashCode() {\n            return Objects.hash(a, b, c);\n        }\n\n        public String toString() {\n            return String.format(\"[%dx + %dy + %d]\", a, b, c);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class NumberTheory {\n        public static long gcd(long a, long b) {\n            long c;\n            while (a != 0) {\n                c = a;\n                a = b % a;\n                b = c;\n            }\n            return b;\n        }\n\n        private static void ASSERT(boolean assertion) {\n            if (!assertion)\n                throw new AssertionError();\n        }\n\n        public abstract static class Modulus<M extends NumberTheory.Modulus<M>> {\n            ArrayList<Long> factorial = new ArrayList<>();\n            ArrayList<Long> invFactorial = new ArrayList<>();\n\n            public abstract long modulus();\n\n            public Modulus() {\n                super();\n                factorial.add(1L);\n                invFactorial.add(1L);\n            }\n\n            public long fact(int n) {\n                while (factorial.size() <= n) {\n                    factorial.add(mult(factorial.get(factorial.size() - 1), factorial.size()));\n                }\n\n                return factorial.get(n);\n            }\n\n            public long fInv(int n) {\n                while (invFactorial.size() <= n) {\n                    invFactorial.add(div(invFactorial.get(invFactorial.size() - 1), invFactorial.size()));\n                }\n\n                return invFactorial.get(n);\n            }\n\n            public long ncr(int n, int r) {\n                ASSERT(n >= 0);\n                if (r < 0 || n < r)\n                    return 0;\n                return mult(fact(n), mult(fInv(r), fInv(n - r)));\n            }\n\n            public long normalize(long x) {\n                x %= modulus();\n                if (x < 0)\n                    x += modulus();\n                return x;\n            }\n\n            public long add(long a, long b) {\n                return normalize(a + b);\n            }\n\n            public long subtract(long a, long b) {\n                return normalize(a - b);\n            }\n\n            public long mult(long a, long b) {\n                return normalize(a * b);\n            }\n\n            public long div(long a, long b) {\n                return mult(a, inv(b));\n            }\n\n            public long pow(long x, int e) {\n                if (e == 0)\n                    return 1;\n                if ((e & 1) > 0)\n                    return mult(x, pow(x, e - 1));\n                return pow(mult(x, x), e / 2);\n            }\n\n            public long inv(long value) {\n                long g = modulus(), x = 0, y = 1;\n                for (long r = value; r != 0; ) {\n                    long q = g / r;\n                    g %= r;\n\n                    long temp = g;\n                    g = r;\n                    r = temp;\n\n                    x -= q * y;\n\n                    temp = x;\n                    x = y;\n                    y = temp;\n                }\n\n                ASSERT(g == 1);\n                ASSERT(y == modulus() || y == -modulus());\n\n                return normalize(x);\n            }\n\n        }\n\n        public static class ModM extends NumberTheory.Modulus<NumberTheory.ModM> {\n            private final long modulus;\n\n            public ModM(long modulus) {\n                this.modulus = modulus;\n            }\n\n            public long modulus() {\n                return modulus;\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskE {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int MOD = 998244353;\n\t\t\tint n = in.nextInt();\n\t\t\tPoint[] p = new Point[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\t\t\t\tp[i] = new Point(x, y, i);\n\t\t\t}\n\t\t\tint[] p2 = new int[n + 1];\n\t\t\tp2[0] = 1;\n\t\t\tfor (int i = 1; i < p2.length; i++) {\n\t\t\t\tp2[i] = 2 * p2[i - 1] % MOD;\n\t\t\t}\n\n\t\t\tArrays.sort(p, (u, v) -> {\n\t\t\t\tif (u.x != v.x) {\n\t\t\t\t\treturn u.x - v.x;\n\t\t\t\t}\n\t\t\t\tif (u.y != v.y) {\n\t\t\t\t\treturn u.y - v.y;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tint ans = 0;\n\t\t\tfor (int s = 0; s < n; s++) {\n\t\t\t\tPoint[] r = new Point[n - s - 1];\n\t\t\t\tSystem.arraycopy(p, s + 1, r, 0, r.length);\n\t\t\t\tfinal Point o = p[s];\n\t\t\t\tArrays.sort(r, (u, v) -> {\n\t\t\t\t\tPoint u1 = u.sub(o);\n\t\t\t\t\tPoint v1 = v.sub(o);\n\t\t\t\t\treturn -Long.signum(cross(u1, v1));\n\t\t\t\t});\n\n\t\t\t\t// Number of points inside or on the borders of the triangle ij.\n\t\t\t\tint[][] u = new int[r.length][r.length];\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tPoint si = r[i].sub(o);\n\t\t\t\t\tfor (int j = i + 1; j < r.length; j++) {\n\t\t\t\t\t\tPoint sj = r[j].sub(o);\n\t\t\t\t\t\tPoint ij = r[j].sub(r[i]);\n\t\t\t\t\t\tfor (int k = 0; k < r.length; k++) {\n\t\t\t\t\t\t\tif (k == i || k == j) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tPoint sk = r[k].sub(o);\n\t\t\t\t\t\t\tif (cross(sk, sj) < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cross(sk, si) > 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cross(r[k].sub(r[i]), ij) >= 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++u[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint[][] d = new int[r.length][r.length];\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < r.length; j++) {\n\t\t\t\t\t\tif (cross(r[i].sub(o), r[j].sub(o)) <= 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\td[i][j] += p2[u[i][j]];\n\t\t\t\t\t\tif (d[i][j] >= MOD) {\n\t\t\t\t\t\t\td[i][j] -= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += d[i][j];\n\t\t\t\t\t\tif (ans >= MOD) {\n\t\t\t\t\t\t\tans -= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = j + 1; k < r.length; k++) {\n\t\t\t\t\t\t\tif (cross(r[k].sub(r[j]), r[k].sub(r[i])) >= 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\td[j][k] = (int) ((d[j][k] + (long) d[i][j] * p2[u[j][k]]) % MOD);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long cross(Point p1, Point p2) {\n\t\t\treturn p1.x * (long) p2.y - p1.y * (long) p2.x;\n\t\t}\n\n\t\tclass Point {\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint id;\n\n\t\t\tPoint(int x, int y, int id) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.id = id;\n\t\t\t}\n\n\t\t\tPoint sub(Point o) {\n\t\t\t\treturn new Point(x - o.x, y - o.y, -1);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tlong[][] co = new long[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tco[i] = new long[]{ni(), ni()};\n\t\t}\n\t\t\n\t\tint mod = 998244353;\n\t\tlong all = pow(2, n, mod) - n*(n-1)/2 - n - 1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tinner:\n\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\tint on = 0;\n\t\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\t\tif(onSameLine(co[i], co[j], co[k])){\n\t\t\t\t\t\tif(!isACB(co[i], co[j], co[k]))continue inner;\n\t\t\t\t\t\ton++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert on >= 2;\n\t\t\t\tall -= pow(2, on, mod) - on*(on-1)/2 - on - 1;\n\t\t\t}\n\t\t}\n\t\tall %= mod;\n\t\tif(all < 0)all += mod;\n\t\tout.println(all);\n\t}\n\tpublic static boolean isACB(long[] a, long[] b, long[] c) { return isACB(a[0], a[1], b[0], b[1], c[0], c[1]); }\n\t\n\tpublic static boolean isACB(long ax, long ay, long bx, long by, long cx, long cy)\n\t{\n\t\treturn (cx-ax)*(by-ay)-(cy-ay)*(bx-ax)==0 && (cx-ax)*(cx-bx)+(cy-ay)*(cy-by) <= 0;\n\t}\n\t\n\tpublic static boolean onSameLine(long[] a, long[] b, long[] c)\n\t{\n\t\treturn (c[0]-a[0])*(b[1]-a[1])-(c[1]-a[1])*(b[0]-a[0])==0;\n\t}\n\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n//\t\tint n = 200, m = 99999;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tsb.append(gen.nextInt(10000) + \" \");\n//\t\t\tsb.append(gen.nextInt(10000) + \" \");\n//\t\t}\n//\t\tINPUT = sb.toString();\n\n\t\t\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tlong[][] co = new long[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tco[i] = new long[]{ni(), ni()};\n\t\t}\n\t\t\n\t\tArrays.sort(co, new Comparator<long[]>() {\n\t\t\tpublic int compare(long[] a, long[] b) {\n\t\t\t\treturn Long.compare(a[0], b[0]);\n\t\t\t}\n\t\t});\n\t\tint mod = 998244353;\n\t\tint ct = 0;\n\t\t\n\t\tlong[] p2 = new long[1000];\n\t\tlong[] ip2 = new long[1000];\n\t\tp2[0] = 1;\n\t\tip2[0] = 1;\n\t\tlong i2 = invl(2, mod);\n\t\tfor(int i = 1;i < 1000;i++){\n\t\t\tp2[i] = p2[i-1] * 2 % mod;\n\t\t\tip2[i] = ip2[i-1] * i2 % mod;\n\t\t}\n\t\t\n\t\tlong[][] nums = new long[n][n];\n\t\tlong[][] sums = new long[n][n];\n\t\t{\n\t\t\tint[][] under = new int[n][n];\n\t\t\t// o-x\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t\tif(co[i][0] < co[j][0]){\n\t\t\t\t\t\tfor(int k = i+1;k < j;k++){\n\t\t\t\t\t\t\tif(co[i][0] <= co[k][0] && co[k][0] < co[j][0] && ccw(co[i], co[j], co[k]) > 0){\n\t\t\t\t\t\t\t\tunder[i][j]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tunder[i][j]++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int k = i+1;k < j;k++){\n\t\t\t\t\t\t\tif(co[i][0] == co[k][0] && co[k][1] < co[j][1]){\n\t\t\t\t\t\t\t\tunder[i][j]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\t\t\t\tif(co[i][0] < co[j][0])under[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tlong[][] num = new long[n][n];\n\t\t\t\tlong[][] sum = new long[n][n];\n\t\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t\tnum[j][i] = 1;\n\t\t\t\t\tsum[j][i] = ip2[under[i][j]];\n\t\t\t\t\tnums[i][j] += num[j][i];\n\t\t\t\t\tsums[i][j] += sum[j][i];\n\t\t\t\t\tfor(int k = i+1;k < j;k++){\n\t\t\t\t\t\tfor(int l = i;l < k;l++){ // l-k-j\n\t\t\t\t\t\t\tif(ccw(co[l], co[k], co[j]) < 0){\n\t\t\t\t\t\t\t\tnum[j][k] += num[k][l];\n\t\t\t\t\t\t\t\tsum[j][k] += sum[k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong q = ip2[under[k][j]];\n\t\t\t\t\t\tnum[j][k] = num[j][k] % mod;\n\t\t\t\t\t\tsum[j][k] = sum[j][k] % mod * q % mod;\n\t\t\t\t\t\tnums[i][j] += num[j][k];\n\t\t\t\t\t\tsums[i][j] += sum[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tnums[i][j] %= mod;\n\t\t\t\t\tsums[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t{\n\t\t\tint[][] under = new int[n][n];\n\t\t\t// o-x\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t\tif(co[i][0] < co[j][0]){\n\t\t\t\t\t\tfor(int k = i+1;k < j;k++){\n\t\t\t\t\t\t\tif(co[i][0] <= co[k][0] && co[k][0] < co[j][0] && ccw(co[i], co[j], co[k]) >= 0){\n\t\t\t\t\t\t\t\tunder[i][j]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tunder[i][j]++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int k = i+1;k < j;k++){\n\t\t\t\t\t\t\tif(co[i][0] == co[k][0] && co[k][1] < co[j][1]){\n\t\t\t\t\t\t\t\tunder[i][j]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\t\tlong[][] num = new long[n][n];\n\t\t\t\tlong[][] sum = new long[n][n];\n\t\t\t\tfor(int j = i-1;j >= 0;j--){\n\t\t\t\t\tnum[j][i] = 1;\n\t\t\t\t\tsum[j][i] = p2[under[j][i]];\n\t\t\t\t\tnums[i][j] += num[j][i];\n\t\t\t\t\tsums[i][j] += sum[j][i];\n\t\t\t\t\tfor(int k = i-1;k > j;k--){\n\t\t\t\t\t\tfor(int l = i;l > k;l--){ // i-l-k-j\n\t\t\t\t\t\t\tif(ccw(co[l], co[k], co[j]) < 0){\n\t\t\t\t\t\t\t\tnum[j][k] += num[k][l];\n\t\t\t\t\t\t\t\tsum[j][k] += sum[k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong q = p2[under[j][k]];\n\t\t\t\t\t\tnum[j][k] = num[j][k] % mod;\n\t\t\t\t\t\tsum[j][k] = sum[j][k] % mod * q % mod;\n\t\t\t\t\t\tnums[i][j] += num[j][k];\n\t\t\t\t\t\tsums[i][j] += sum[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tnums[i][j] %= mod;\n\t\t\t\t\tsums[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tfor(long[] row : nums){\n//\t\t\ttr(row);\n//\t\t}\n//\t\ttr();\n//\t\tfor(long[] row : sums){\n//\t\t\ttr(row);\n//\t\t}\n//\t\ttr(co);\n\t\t\n\t\tlong ret = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\tret += sums[i][j] * sums[j][i];\n\t\t\t\tret %= mod;\n\t\t\t}\n\t\t}\n\t\tret -= n*(n-1)/2;\n\t\tif(ret < 0)ret += mod;\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\t\n\tpublic static int ccw(long[] a, long[] b, long[] t) {\n\t\treturn Long.signum((t[0] - a[0]) * (b[1] - a[1]) - (b[0] - a[0]) * (t[1] - a[1]));\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n//\t\tint n = 200, m = 99999;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tsb.append(gen.nextInt(10000) + \" \");\n//\t\t\tsb.append(gen.nextInt(10000) + \" \");\n//\t\t}\n//\t\tINPUT = sb.toString();\n\n\t\t\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskE {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int MOD = 998244353;\n\t\t\tint n = in.nextInt();\n\t\t\tPoint[] p = new Point[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\t\t\t\tp[i] = new Point(x, y, i);\n\t\t\t}\n\t\t\tint[] p2 = new int[n + 1];\n\t\t\tp2[0] = 1;\n\t\t\tfor (int i = 1; i < p2.length; i++) {\n\t\t\t\tp2[i] = 2 * p2[i - 1] % MOD;\n\t\t\t}\n\n\t\t\tArrays.sort(p, (u, v) -> {\n\t\t\t\tif (u.x != v.x) {\n\t\t\t\t\treturn u.x - v.x;\n\t\t\t\t}\n\t\t\t\tif (u.y != v.y) {\n\t\t\t\t\treturn u.y - v.y;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tint ans = 0;\n\t\t\tint[][] d = new int[n][n];\n\t\t\tint[][] g = new int[n][n];\n\t\t\tfor (int s = 0; s < n; s++) {\n\t\t\t\tPoint[] r = new Point[n - s - 1];\n\t\t\t\tSystem.arraycopy(p, s + 1, r, 0, r.length);\n\t\t\t\tfinal Point o = p[s];\n\t\t\t\tArrays.sort(r, (u, v) -> -Long.signum(cross(u, v, o)));\n\t\t\t\t// Number of points inside or on the borders of the triangle ij.\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < r.length; j++) {\n\t\t\t\t\t\tg[i][j] = 0;\n\t\t\t\t\t\tfor (int k = i + 1; k < j; k++) {\n\t\t\t\t\t\t\tif (cross(r[k], r[j], r[i]) > 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++g[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int[] arr : d) {\n\t\t\t\t\tArrays.fill(arr, 0);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tint si = 0;\n\t\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t\tif (cross(r[i], r[j], o) == 0) {\n\t\t\t\t\t\t\t++si;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = i + 1; j < r.length; j++) {\n\t\t\t\t\t\tif (cross(r[i], r[j], o) <= 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\td[i][j] += p2[g[i][j] + si];\n\t\t\t\t\t\tif (d[i][j] >= MOD) {\n\t\t\t\t\t\t\td[i][j] -= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += d[i][j];\n\t\t\t\t\t\tif (ans >= MOD) {\n\t\t\t\t\t\t\tans -= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = j + 1; k < r.length; k++) {\n\t\t\t\t\t\t\tif (cross(r[i], r[j], r[k]) < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\td[j][k] = (int) ((d[j][k] + (long) d[i][j] * p2[g[j][k]]) % MOD);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long cross(Point p1, Point p2, Point o) {\n\t\t\tlong x1 = p1.x - o.x;\n\t\t\tlong x2 = p2.x - o.x;\n\t\t\tlong y1 = p1.y - o.y;\n\t\t\tlong y2 = p2.y - o.y;\n\t\t\treturn x1 * y2 - x2 * y1;\n\t\t}\n\n\t\tclass Point {\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint id;\n\n\t\t\tPoint(int x, int y, int id) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.id = id;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.HashMap;\n\nclass Main{\n\n    static long C=20000*20000;\n    static long B=20000;\n    static long A=1;\n\n    static long baseC = (long)1e8;\n    static long baseB = (long)1e4;\n    static long baseA = (long)1e4;\n\n    static long mod =998244353;\n\n    static int gcd(int x, int y){\n        return y==0 ? x : gcd( y, x%y);\n    }\n\n    static long getVal(int a, int b,int c){\n        int m = gcd(a, gcd(Math.abs(b),Math.abs(c)));\n        a/=m; b/=m; c/=m;\n        return ((long)c+baseC)*C + ((long)b + baseB)*B +((long)a + baseA)*A;\n    }\n\n    static long getLine(int x1,int y1,int x2, int y2){\n        if(x1==x2)return getVal(1, 0, -x1);\n        \n        if(y2-y1<0){\n            int tmp = y1;y1=y2;y2=tmp;\n            tmp=x1;x1=x2;x2=tmp;\n        }else if(y2-y1==0 && x2-x1<0){\n            int tmp = x1;x1=x2;x2=tmp;\n        }\n        return getVal(y2-y1, x2-x1, y2*x1-y1*x2);\n    }\n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        int[] x = new int[N];\n        int[] y = new int[N];\n        for(int i=0;i<N;++i){\n            x[i]=scan.nextInt();\n            y[i]= scan.nextInt();\n        }\n        long two[] = new long[N+1];\n        two[0]=1;\n        for(int i=1;i<=N;++i)two[i]=(two[i-1]*2)%mod;\n\n        long ans = two[N];\n        ans = (ans - (N*(N-1)/2) - N -1 +mod)%mod;\n\n        Set<Long> used = new HashSet<>();\n        for(int i=0;i<N;++i){\n            Map<Long, Integer> line = new HashMap<>();\n            for(int j=i+1;j<N;++j){\n                long l = getLine(x[i], y[i], x[j], y[j]);\n                if(used.contains(l))continue;\n                if(!line.containsKey(l))line.put(l,0);\n                line.put(l, line.get(l)+1);\n            }\n            for(Map.Entry<Long, Integer> entry : line.entrySet()){\n                if(entry.getValue() >1){\n                    int k = entry.getValue()+1;\n                    ans = (ans - (two[k] - (k*(k-1)/2 +k +1) +mod)%mod +mod)%mod;\n                    used.add(entry.getKey());\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Objects;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author anand.oza\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EConvexScore solver = new EConvexScore();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EConvexScore {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n\n            NumberTheory.ModM m = new NumberTheory.ModM(998244353L);\n\n            long answer = 0;\n            answer = m.add(answer, m.pow(2, n));\n            answer = m.subtract(answer, m.ncr(n, 0));\n            answer = m.subtract(answer, m.ncr(n, 1));\n\n            Geometry.Point[] p = new Geometry.Point[n];\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt(), y = in.nextInt();\n                p[i] = new Geometry.Point(x, y);\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    int count = 0;\n                    Geometry.Point[] polygon = {p[i],\n                                                p[j]};\n\n                    for (int k = 0; k < n; k++) {\n                        if (k == i || k == j)\n                            continue;\n\n                        if (p[k].classify(polygon) == Geometry.Point.Classification.ON) {\n                            count++;\n                        }\n                    }\n\n                    long overcount = m.pow(2, count);\n                    answer = m.subtract(answer, overcount);\n                }\n            }\n\n            out.println(answer);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class Geometry {\n        public static class Point implements Comparable<Geometry.Point> {\n            long x;\n            long y;\n\n            public Point(long x, long y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            public Geometry.Point copy() {\n                return new Geometry.Point(x, y);\n            }\n\n            public Geometry.Point subtract(Geometry.Point o) {\n                x -= o.x;\n                y -= o.y;\n                return this;\n            }\n\n            public static Geometry.Point subtract(Geometry.Point a, Geometry.Point b) {\n                return a.copy().subtract(b);\n            }\n\n            public boolean equals(Object o) {\n                if (this == o)\n                    return true;\n                if (o == null || getClass() != o.getClass())\n                    return false;\n                Geometry.Point point = (Geometry.Point) o;\n                return x == point.x && y == point.y;\n            }\n\n            public int hashCode() {\n                return Objects.hash(x, y);\n            }\n\n            public static long cross(Geometry.Point a, Geometry.Point b) {\n                return a.x * b.y - a.y * b.x;\n            }\n\n            public static long cross(Geometry.Point p, Geometry.Point a, Geometry.Point b) {\n                return cross(subtract(a, p), subtract(b, p));\n            }\n\n            public int compareTo(Geometry.Point o) {\n                int ret = Long.compare(x, o.x);\n                if (ret != 0)\n                    return ret;\n                return Long.compare(y, o.y);\n            }\n\n            public Geometry.Point.Classification classify(Geometry.Point[] polygon) {\n                boolean ans = false;\n                for (int i = 0; i < polygon.length; i++) {\n                    Geometry.Point a = polygon[i], b = polygon[(i + 1) % polygon.length];\n                    if (cross(a, b, this) == 0 && (a.compareTo(this) <= 0 || b.compareTo(this) <= 0) && (this.compareTo(a) <= 0 || this.compareTo(b) <= 0))\n                        return Geometry.Point.Classification.ON;\n                    if (a.y > b.y) {\n                        Geometry.Point t = a;\n                        a = b;\n                        b = t;\n                    }\n                    if (a.y <= y && y < b.y && cross(this, a, b) > 0)\n                        ans ^= true;\n                }\n                return ans ? Geometry.Point.Classification.IN : Geometry.Point.Classification.OUT;\n            }\n\n            public enum Classification {\n                ON, IN, OUT,\n                ;\n            }\n\n        }\n\n    }\n\n    static class NumberTheory {\n        private static void ASSERT(boolean assertion) {\n            if (!assertion)\n                throw new AssertionError();\n        }\n\n        public abstract static class Modulus<M extends NumberTheory.Modulus<M>> {\n            ArrayList<Long> factorial = new ArrayList<>();\n            ArrayList<Long> invFactorial = new ArrayList<>();\n\n            public abstract long modulus();\n\n            public Modulus() {\n                super();\n                factorial.add(1L);\n                invFactorial.add(1L);\n            }\n\n            public long fact(int n) {\n                while (factorial.size() <= n) {\n                    factorial.add(mult(factorial.get(factorial.size() - 1), factorial.size()));\n                }\n\n                return factorial.get(n);\n            }\n\n            public long fInv(int n) {\n                while (invFactorial.size() <= n) {\n                    invFactorial.add(div(invFactorial.get(invFactorial.size() - 1), invFactorial.size()));\n                }\n\n                return invFactorial.get(n);\n            }\n\n            public long ncr(int n, int r) {\n                ASSERT(n >= 0);\n                if (r < 0 || n < r)\n                    return 0;\n                return mult(fact(n), mult(fInv(r), fInv(n - r)));\n            }\n\n            public long normalize(long x) {\n                x %= modulus();\n                if (x < 0)\n                    x += modulus();\n                return x;\n            }\n\n            public long add(long a, long b) {\n                return normalize(a + b);\n            }\n\n            public long subtract(long a, long b) {\n                return normalize(a - b);\n            }\n\n            public long mult(long a, long b) {\n                return normalize(a * b);\n            }\n\n            public long div(long a, long b) {\n                return mult(a, inv(b));\n            }\n\n            public long pow(long x, int e) {\n                if (e == 0)\n                    return 1;\n                if ((e & 1) > 0)\n                    return mult(x, pow(x, e - 1));\n                return pow(mult(x, x), e / 2);\n            }\n\n            public long inv(long value) {\n                long g = modulus(), x = 0, y = 1;\n                for (long r = value; r != 0; ) {\n                    long q = g / r;\n                    g %= r;\n\n                    long temp = g;\n                    g = r;\n                    r = temp;\n\n                    x -= q * y;\n\n                    temp = x;\n                    x = y;\n                    y = temp;\n                }\n\n                ASSERT(g == 1);\n                ASSERT(y == modulus() || y == -modulus());\n\n                return normalize(x);\n            }\n\n        }\n\n        public static class ModM extends NumberTheory.Modulus<NumberTheory.ModM> {\n            private final long modulus;\n\n            public ModM(long modulus) {\n                this.modulus = modulus;\n            }\n\n            public long modulus() {\n                return modulus;\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n//\tstatic String INPUT = \"3 0 3 3 0 2 2\";\n//\tstatic String INPUT = \"3 3 2 1 0 1 3\";\n//\tstatic String INPUT = \"3 1 2 2 1 3 0\";\n//\tstatic String INPUT = \"3 3 0 3 2 3 3\";\n\tstatic String INPUT = \"\";\n\t\n\tstatic long[] p2 = new long[1000];\n\tstatic long[] ip2 = new long[1000];\n\tstatic long p(int n)\n\t{\n\t\treturn n >= 0 ? p2[n] : ip2[-n];\n\t}\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 998244353;\n\t\tp2[0] = 1;\n\t\tip2[0] = 1;\n\t\tlong i2 = invl(2, mod);\n\t\tfor(int i = 1;i < 1000;i++){\n\t\t\tp2[i] = p2[i-1] * 2 % mod;\n\t\t\tip2[i] = ip2[i-1] * i2 % mod;\n\t\t}\n\t\t\n\t\tint n = ni();\n\t\tlong[][] co = new long[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tco[i] = new long[]{ni(), ni()};\n\t\t}\n\t\t\n\t\tArrays.sort(co, new Comparator<long[]>() {\n\t\t\tpublic int compare(long[] a, long[] b) {\n\t\t\t\tif(a[0] != b[0])return Long.compare(a[0], b[0]);\n\t\t\t\treturn Long.compare(a[1], b[1]);\n\t\t\t}\n\t\t});\n\t\tint ct = 0;\n\t\t\n\t\t\n\t\tlong[][] nums = new long[n][n];\n\t\tlong[][] sums = new long[n][n];\n\t\t{\n\t\t\tint[][] under = new int[n][n];\n\t\t\t// o-x\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t\tif(co[i][0] < co[j][0]){\n\t\t\t\t\t\tfor(int k = 0;k < j;k++){\n\t\t\t\t\t\t\tif(co[i][0] <= co[k][0] && co[k][0] < co[j][0] && ccw(co[i], co[j], co[k]) > 0){\n\t\t\t\t\t\t\t\tunder[i][j]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tunder[i][j]++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int k = i+1;k < j;k++){\n\t\t\t\t\t\t\tif(co[i][0] == co[k][0] && co[k][1] < co[j][1]){\n\t\t\t\t\t\t\t\tunder[i][j]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tlong[][] num = new long[n][n];\n\t\t\t\tlong[][] sum = new long[n][n];\n\t\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t\tnum[j][i] = 1;\n\t\t\t\t\tsum[j][i] = p(-under[i][j]);\n\t\t\t\t\tnums[i][j] += num[j][i];\n\t\t\t\t\tsums[i][j] += sum[j][i];\n\t\t\t\t\tfor(int k = i+1;k < j;k++){\n\t\t\t\t\t\tfor(int l = i;l < k;l++){ // l-k-j\n\t\t\t\t\t\t\tif(ccw(co[l], co[k], co[j]) < 0){\n\t\t\t\t\t\t\t\tnum[j][k] += num[k][l];\n\t\t\t\t\t\t\t\tsum[j][k] += sum[k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong q = p(-under[k][j]);\n\t\t\t\t\t\tnum[j][k] = num[j][k] % mod;\n\t\t\t\t\t\tsum[j][k] = sum[j][k] % mod * q % mod;\n\t\t\t\t\t\tnums[i][j] += num[j][k];\n\t\t\t\t\t\tsums[i][j] += sum[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tnums[i][j] %= mod;\n\t\t\t\t\tsums[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t{\n\t\t\tint[][] under = new int[n][n];\n\t\t\t// o-x\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t\tif(co[i][0] < co[j][0]){\n\t\t\t\t\t\tfor(int k = 0;k < j;k++){\n\t\t\t\t\t\t\tif(co[i][0] <= co[k][0] && co[k][0] < co[j][0] && ccw(co[i], co[j], co[k]) >= 0){\n\t\t\t\t\t\t\t\tunder[i][j]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tunder[i][j]--;\n\t\t\t\t\t}else{\n//\t\t\t\t\t\tfor(int k = i+1;k < j;k++){\n//\t\t\t\t\t\t\tif(co[i][0] == co[k][0] && co[k][1] < co[j][1]){\n//\t\t\t\t\t\t\t\tunder[i][j]--;\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t}\n\t\t\t\t\t\tunder[i][j]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\t\tlong[][] num = new long[n][n];\n\t\t\t\tlong[][] sum = new long[n][n];\n\t\t\t\tfor(int j = i-1;j >= 0;j--){\n\t\t\t\t\tnum[j][i] = 1;\n\t\t\t\t\tsum[j][i] = p(under[j][i]+1);\n\t\t\t\t\tnums[i][j] += num[j][i];\n\t\t\t\t\tsums[i][j] += sum[j][i];\n\t\t\t\t\tfor(int k = i-1;k > j;k--){\n\t\t\t\t\t\tfor(int l = i;l > k;l--){ // i-l-k-j\n\t\t\t\t\t\t\tif(ccw(co[l], co[k], co[j]) < 0){\n\t\t\t\t\t\t\t\tnum[j][k] += num[k][l];\n\t\t\t\t\t\t\t\tsum[j][k] += sum[k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong q = p(under[j][k]);\n\t\t\t\t\t\tnum[j][k] = num[j][k] % mod;\n\t\t\t\t\t\tsum[j][k] = sum[j][k] % mod * q % mod;\n\t\t\t\t\t\tnums[i][j] += num[j][k];\n\t\t\t\t\t\tsums[i][j] += sum[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tnums[i][j] %= mod;\n\t\t\t\t\tsums[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tfor(long[] row : nums){\n//\t\t\ttr(row);\n//\t\t}\n//\t\ttr();\n//\t\tfor(long[] row : sums){\n//\t\t\ttr(row);\n//\t\t}\n//\t\ttr(co);\n\t\t\n\t\tlong ret = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\tret += sums[i][j] * sums[j][i];\n\t\t\t\tret %= mod;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\tint on = 0;\n\t\t\t\tfor(int k = i+1;k < j;k++){\n\t\t\t\t\tif(ccw(co[i], co[j], co[k]) == 0){\n\t\t\t\t\t\ton++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret -= p2[on];\n\t\t\t}\n\t\t}\n\t\tret %= mod;\n\t\tif(ret < 0)ret += mod;\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\t\n\tpublic static int ccw(long[] a, long[] b, long[] t) {\n\t\treturn Long.signum((t[0] - a[0]) * (b[1] - a[1]) - (b[0] - a[0]) * (t[1] - a[1]));\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n//\t\tint n = 200, m = 99999;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tsb.append(gen.nextInt(10000) + \" \");\n//\t\t\tsb.append(gen.nextInt(10000) + \" \");\n//\t\t}\n//\t\tINPUT = sb.toString();\n\n\t\t\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskE {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int MOD = 998244353;\n\t\t\tint n = in.nextInt();\n\t\t\tPoint[] p = new Point[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\t\t\t\tp[i] = new Point(x, y, i);\n\t\t\t}\n\t\t\tint[] p2 = new int[n + 1];\n\t\t\tp2[0] = 1;\n\t\t\tfor (int i = 1; i < p2.length; i++) {\n\t\t\t\tp2[i] = 2 * p2[i - 1] % MOD;\n\t\t\t}\n\n\t\t\tArrays.sort(p, (u, v) -> {\n\t\t\t\tif (u.x != v.x) {\n\t\t\t\t\treturn u.x - v.x;\n\t\t\t\t}\n\t\t\t\tif (u.y != v.y) {\n\t\t\t\t\treturn u.y - v.y;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tint ans = 0;\n\t\t\tint[][] d = new int[n][n];\n\t\t\tint[][] g = new int[n][n];\n\t\t\tfor (int s = 0; s < n; s++) {\n\t\t\t\tPoint[] r = new Point[n - s - 1];\n\t\t\t\tSystem.arraycopy(p, s + 1, r, 0, r.length);\n\t\t\t\tfinal Point o = p[s];\n\t\t\t\tArrays.sort(r, (u, v) -> -Long.signum(cross(u, v, o)));\n\t\t\t\t// Number of points inside or on the borders of the triangle ij.\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < r.length; j++) {\n\t\t\t\t\t\tg[i][j] = 0;\n\t\t\t\t\t\tfor (int k = i + 1; k < j; k++) {\n\t\t\t\t\t\t\tif (cross(r[k], r[j], r[i]) > 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++g[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int[] arr : d) {\n\t\t\t\t\tArrays.fill(arr, 0);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < r.length; j++) {\n\t\t\t\t\t\tif (cross(r[i], r[j], o) <= 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\td[i][j] += p2[g[i][j]];\n\t\t\t\t\t\tif (d[i][j] >= MOD) {\n\t\t\t\t\t\t\td[i][j] -= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += d[i][j];\n\t\t\t\t\t\tif (ans >= MOD) {\n\t\t\t\t\t\t\tans -= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = j + 1; k < r.length; k++) {\n\t\t\t\t\t\t\tif (cross(r[i], r[j], r[k]) < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\td[j][k] = (int) ((d[j][k] + (long) d[i][j] * p2[g[j][k]]) % MOD);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long cross(Point p1, Point p2, Point o) {\n\t\t\tlong x1 = p1.x - o.x;\n\t\t\tlong x2 = p2.x - o.x;\n\t\t\tlong y1 = p1.y - o.y;\n\t\t\tlong y2 = p2.y - o.y;\n\t\t\treturn x1 * y2 - x2 * y1;\n\t\t}\n\n\t\tclass Point {\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint id;\n\n\t\t\tPoint(int x, int y, int id) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.id = id;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    static final long MOD = 998244353;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        long[][] xy = new long[n][2];\n        for (int i = 0; i < n ; i++) {\n            for (int j = 0; j < 2 ; j++) {\n                xy[i][j] = in.nextInt();\n            }\n        }\n\n        long[][] C = new long[300][300];\n        for (int i = 0; i < C.length; i++) {\n            C[i][0] = C[i][i] = 1;\n            for (int j = 1; j < i ; j++) {\n                C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;\n            }\n        }\n\n\n        long all = 1;\n        for (int i = 0; i < n ; i++) {\n            all *= 2;\n            all %= MOD;\n        }\n\n        long one = n;\n        long two = n * (n - 1) / 2;\n        long three = 0;\n\n        boolean[][] done = new boolean[n][n];\n        for (int i = 0; i < n ; i++) {\n            for (int j = i+1 ; j < n ; j++) {\n                if (done[i][j]) {\n                    continue;\n                }\n                int cnt = 0;\n                List<Integer> on = new ArrayList<>();\n                for (int k = 0; k < n ; k++) {\n                    if (onLine(xy[i], xy[j], xy[k])) {\n                        on.add(k);\n                        cnt++;\n                    }\n                }\n\n                for (int l = 3 ; l <= cnt ; l++) {\n                    three += C[cnt][l];\n                    three %= MOD;\n                }\n\n                for (int a : on) {\n                    for (int b : on) {\n                        done[a][b] = true;\n                    }\n                }\n            }\n        }\n\n        debug(all, one, two, three);\n\n        out.println((all - one - two - three - 1 + MOD * 4) % MOD);\n        out.flush();\n    }\n\n    static boolean onLine(long[] a, long[] b, long[] c) {\n        return cross(b[0]-a[0], b[1]-a[1], c[0]-a[0], c[1]-a[1]) == 0;\n    }\n\n    static long cross(long ax, long ay, long bx, long by) {\n        return ax*by-ay*bx;\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tfinal long MODULO = 998244353L;\n\tlong[] fac = new long[400];\n\tlong[] invfac = new long[400];\n\tlong[] inv = new long[400];\n\tlong[][] C = new long[400][400];\n\tlong[] pow2 = new long[400];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i % MODULO;\n\t\t}\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = (MODULO - (MODULO / i) * inv[(int) (MODULO % i)] % MODULO) % MODULO;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MODULO;\n\t\t}\n\t\tC[0][0] = 1;\n\t\tfor (int i = 1; i < C.length; ++i) {\n\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\tC[i][j] = (j > 0 ? C[i - 1][j - 1] : 0) + C[i - 1][j];\n\t\t\t\tC[i][j] %= MODULO;\n\t\t\t}\n\t\t}\n\t\tpow2[0] = 1;\n\t\tfor (int i = 1; i < pow2.length; ++i) {\n\t\t\tpow2[i] = pow2[i - 1] * 2 % MODULO;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t}\n\t\tsolver(n, x, y);\n\t}\n\n\tvoid solver(int n, int[] x, int[] y) {\n\t\tlong ans = pow2[n];\n\n\t\tans = (ans - n + MODULO) % MODULO;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tvis[i] = true;\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tif (vis[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tvis[j] = true;\n\t\t\t\tint cnt = 1;\n\t\t\t\tfor (int k = j + 1; k < n; ++k) {\n\t\t\t\t\tif (vis[k]) {\n\t\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t\t}\n\t\t\t\t\tif ((x[i] - x[j]) * (y[k] - y[i]) == (y[i] - y[j]) * (x[k] - x[i])) {\n\t\t\t\t\t\tvis[k] = true;\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = (ans - (pow2[cnt] - 1) + MODULO) % MODULO;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans - 1);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskE {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int MOD = 998244353;\n\t\t\tint n = in.nextInt();\n\t\t\tPoint[] p = new Point[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\t\t\t\tp[i] = new Point(x, y, i);\n\t\t\t}\n\t\t\tint[] p2 = new int[n + 1];\n\t\t\tp2[0] = 1;\n\t\t\tfor (int i = 1; i < p2.length; i++) {\n\t\t\t\tp2[i] = 2 * p2[i - 1] % MOD;\n\t\t\t}\n\n\t\t\tArrays.sort(p, (u, v) -> {\n\t\t\t\tif (u.x != v.x) {\n\t\t\t\t\treturn u.x - v.x;\n\t\t\t\t}\n\t\t\t\tif (u.y != v.y) {\n\t\t\t\t\treturn u.y - v.y;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tint ans = 0;\n\t\t\tint[][] d = new int[n][n];\n\t\t\tint[][] g = new int[n][n];\n\t\t\tfor (int s = 0; s < n; s++) {\n\t\t\t\tPoint[] r = new Point[n - s - 1];\n\t\t\t\tSystem.arraycopy(p, s + 1, r, 0, r.length);\n\t\t\t\tfinal Point o = p[s];\n\t\t\t\tArrays.sort(r, (u, v) -> {\n\t\t\t\t\tPoint u1 = u.sub(o);\n\t\t\t\t\tPoint v1 = v.sub(o);\n\t\t\t\t\treturn -Long.signum(cross(u1, v1));\n\t\t\t\t});\n\n\t\t\t\t// Number of points inside or on the borders of the triangle ij.\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tPoint si = r[i].sub(o);\n\t\t\t\t\tfor (int j = i + 1; j < r.length; j++) {\n\t\t\t\t\t\tPoint sj = r[j].sub(o);\n\t\t\t\t\t\tPoint ij = r[j].sub(r[i]);\n\t\t\t\t\t\tg[i][j] = 0;\n\t\t\t\t\t\tfor (int k = 0; k < r.length; k++) {\n\t\t\t\t\t\t\tif (k == i || k == j) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tPoint sk = r[k].sub(o);\n\t\t\t\t\t\t\tif (cross(sk, sj) < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cross(sk, si) > 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cross(r[k].sub(r[i]), ij) > 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++g[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int[] arr : d) {\n\t\t\t\t\tArrays.fill(arr, 0);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < r.length; j++) {\n\t\t\t\t\t\tif (cross(r[i].sub(o), r[j].sub(o)) <= 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\td[i][j] += p2[g[i][j]];\n\t\t\t\t\t\tif (d[i][j] >= MOD) {\n\t\t\t\t\t\t\td[i][j] -= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += d[i][j];\n\t\t\t\t\t\tif (ans >= MOD) {\n\t\t\t\t\t\t\tans -= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = j + 1; k < r.length; k++) {\n\t\t\t\t\t\t\tif (cross(r[k].sub(r[j]), r[k].sub(r[i])) >= 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\td[j][k] = (int) ((d[j][k] + (long) d[i][j] * p2[g[j][k]]) % MOD);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long cross(Point p1, Point p2) {\n\t\t\treturn p1.x * (long) p2.y - p1.y * (long) p2.x;\n\t\t}\n\n\t\tclass Point {\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint id;\n\n\t\t\tPoint(int x, int y, int id) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.id = id;\n\t\t\t}\n\n\t\t\tPoint sub(Point o) {\n\t\t\t\treturn new Point(x - o.x, y - o.y, -1);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tconst long mod = 998244353;\n\tpublic void Solve(){\n\t\t\n\t\tlong tot = ModPow(2, N);\n\t\ttot += mod - N - 1; if(tot >= mod) tot -= mod;\n\t\ttot += mod - ((long) N * (long) (N - 1) / 2 ) % mod; if(tot >= mod) tot -= mod;\n\t\tHashSet<long> H = new HashSet<long>();\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\t\n\t\t\t\tList<int> L = new List<int>();\n\t\t\t\tL.Add(i);\n\t\t\t\tL.Add(j);\n\t\t\t\tlong vx = X[j] - X[i];\n\t\t\t\tlong vy = Y[j] - Y[i];\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(k == i || k == j) continue;\n\t\t\t\t\tlong wx = X[k] - X[i];\n\t\t\t\t\tlong wy = Y[k] - Y[i];\n\t\t\t\t\tif(vx * wy - vy * wx == 0){\n\t\t\t\t\t\tL.Add(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(L.Count == 2) continue;\n\t\t\t\tL.Sort();\n\t\t\t\tvar hash = L[0] * 1L + L[1] * 1000L + L[2] * 1000000L;\n\t\t\t\tif(H.Contains(hash)) continue;\n\t\t\t\t\n\t\t\t\tH.Add(hash);\n\t\t\t\tint NN = L.Count;\n\t\t\t\tlong three = ModPow(2, NN);\n\t\t\t\tthree += mod - NN - 1; if(three >= mod) three -= mod;\n\t\t\t\tthree += mod - ((long) NN * (long) (NN - 1) / 2 ) % mod; if(three >= mod) three -= mod;\n\t\t\t\t\n\t\t\t\ttot += mod - three; if(tot >= mod) tot -= mod;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tConsole.WriteLine(tot);\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tlong ModPow(long x, long k){\n\t\tif(k == 0) return 1;\n\t\tif(x == 0) return 0;\n\t\tlong ret = 1;\n\t\tlong v = x;\n\t\twhile(k > 0){\n\t\t\tif((k & 1) == 1){\n\t\t\t\tret *= v;\n\t\t\t\tif(ret >= mod) ret %= mod;\n\t\t\t}\n\t\t\tv *= v;\n\t\t\tif(v >= mod) v %= mod;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\t\n\tint N;\n\tlong[] X,Y;\n\tpublic Sol(){\n\t\tN = ri();\n\t\tX = new long[N];\n\t\tY = new long[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar d = rla();\n\t\t\tX[i] = d[0]; Y[i] = d[1];\n\t\t}\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\n\tstatic void Main()\n\t{\n\t\tlong n = long.Parse(Console.ReadLine());\n    long mod = 998244353;\n    long answer = DivideMod(2,n,mod);//2^n\n\n    long[,] vertexes = new long[n,2];//ここに受け取る\n    for(long i = 0; i < n; i++)\n    {\n      long[] nums = Array.ConvertAll(Console.ReadLine().Split(' '),long.Parse);//１行ごとに受け取る\n      vertexes[i,0] = nums[0];\n      vertexes[i,1] = nums[1];\n    }\n\n    Console.WriteLine(answer);\n    answer -= 1;//0個選択\n    //answer -= n;//1個選択\n    //answer -= n*(n-1)/2;//2個選択\n    Console.WriteLine(answer);\n\n      for(int i = 0; i < n; i++)\n      {\n        for(int j = i+1; j < n; j++)\n        {\n          long memo = 0;\n          for(int k = 0; k < n; k++)\n          {\n            Vector2 vecA = new Vector2(vertexes[i,0], vertexes[i,1]);\n            Vector2 vecB = new Vector2(vertexes[j,0], vertexes[j,1]);\n            Vector2 vecC = new Vector2(vertexes[k,0], vertexes[k,1]);\n            if(Vector2.WhereVector(vecA,vecB,vecC) == 3)//線分上の点\n            {\n              memo++;\n            }\n          }\n          if(memo >= 1)\n          {\n            memo += 2;\n            answer -= DivideMod(2,memo,mod) - memo - 1;\n            Console.WriteLine(answer);\n          }\n        }\n      }\n\n      answer %= mod;\n      if(answer < 0) answer += mod;\n\n\t\tConsole.WriteLine(answer);\n\t}\n\n  static long DivideMod(long x, long a, long p)//戻り値はx^a(mod p)\n  {\n    long num = 2;\n    long answer = 1;\n    long check = a;\n    long memo = x%p;\n    \n    while(check > 0)\n    {\n      if(check % num == num / 2)\n      {\n        check -= num / 2;\n        answer *= memo;\n        answer %= p;\n      }\n    memo *= memo;\n    memo %= p;\n    num *= 2;\n    }\n    return answer;\n  }\n}\n\nclass Vector2//2次元ベクトル\n{\n  static decimal EPS = 1e-10m;//小数誤差比較\n\n  public Vector2 (decimal X, decimal Y)\n  {\n    this.x = X;\n    this.y = Y;\n  }\n\n  public decimal x {private set; get;}\n  public decimal y {private set; get;}\n\n  public static Vector2 operator + (Vector2 ob1, Vector2 ob2)//ベクトルの基本演算\n  {\n    return new Vector2 (ob1.x + ob2.x, ob1.y + ob2.y);\n  }\n  public static Vector2 operator - (Vector2 ob1, Vector2 ob2)\n  {\n    return new Vector2 (ob1.x - ob2.x, ob1.y - ob2.y);\n  }\n  public static Vector2 operator * (Vector2 ob, decimal scalar)\n  {\n    return new Vector2 (ob.x * scalar, ob.y * scalar);\n  }\n  public static Vector2 operator * (decimal scalar, Vector2 ob)\n  {\n    return new Vector2 (ob.x * scalar, ob.y * scalar);\n  }\n  public static Vector2 operator / (Vector2 ob, decimal scalar)\n  {\n    return new Vector2 (ob.x / scalar, ob.y / scalar);\n  }\n\n  public decimal Length()//ベクトルの長さの2乗\n  {\n    return x * x + y * y;\n  }\n  public static decimal Distance(Vector2 ob1, Vector2 ob2)//2点間の距離\n  {\n    return (decimal)Math.Sqrt((double)((ob1.x-ob2.x) * (ob1.x-ob2.x) + (ob1.y-ob2.y) * (ob1.y-ob2.y)));\n  }\n  public static decimal DotProduct(Vector2 ob1, Vector2 ob2)//内積\n  {\n    return ob1.x * ob2.x + ob1.y * ob2.y;\n  }\n  public static decimal CrossProduct(Vector2 ob1, Vector2 ob2)//外積。第2引数が反時計回り側で正。\n  {\n    return ob1.x * ob2.y - ob1.y * ob2.x;\n  }\n  public static decimal Arg(Vector2 p)//x軸に対する偏角\n  {\n    return (decimal)Math.Atan2((double)p.y, (double)p.x);\n  }\n  public static Vector2 PoralCoordinate(decimal radius, decimal angle)//長さと座標から極座標にする\n  {\n    return new Vector2(radius * (decimal)Math.Cos((double)angle), radius * (decimal)Math.Sin((double)angle));\n  }\n\n  public static Vector2 Projection(Vector2 beginPoint, Vector2 endPoint, Vector2 point)//点の射影\n  {\n    Vector2 segment = endPoint - beginPoint;\n    decimal ratio = Vector2.DotProduct(point - beginPoint, segment) / segment.Length();\n    return beginPoint + segment * ratio;//始点にたす\n  }\n\npublic static long WhereVector(Vector2 beginPoint, Vector2 endPoint, Vector2 point)\n  {//ベクトルに対する点の位置\n    Vector2 segment = endPoint - beginPoint;\n    Vector2 aimVec = point - beginPoint;\n    if(Vector2.CrossProduct(segment, aimVec) > 0)\n      return 1;//反時計回り側\n    else if(Vector2.CrossProduct(segment, aimVec) < 0)\n      return 2;//時計回り側\n    else if(Vector2.DotProduct(segment, aimVec) < -1+EPS)\n      return 3;//ベクトル反対向きの側\n    else if(segment.Length() < aimVec.Length())\n      return 4;//ベクトル向きの側\n    else\n      return 5;//ベクトル上\n  }\n\n  public static long IsIntersect(Vector2 vecA, Vector2 vecB,\n    Vector2 vecAsub, Vector2 vecBsub)//2線分の交差判定\n  {\n    bool answer = false;\n\n    if(Vector2.WhereVector(vecA, vecB, vecAsub) + Vector2.WhereVector(vecA, vecB, vecBsub) == 3\n    && Vector2.WhereVector(vecAsub, vecBsub, vecA) + Vector2.WhereVector(vecAsub, vecBsub, vecB) == 3)\n      answer = true;\n    if(Vector2.WhereVector(vecA, vecB, vecAsub) == 5 || Vector2.WhereVector(vecA, vecB, vecBsub) == 5\n    || Vector2.WhereVector(vecAsub, vecBsub, vecA) == 5 || Vector2.WhereVector(vecAsub, vecBsub, vecB) == 5)\n      answer = true;\n    return((answer) ? 1 : 0);\n  }\n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\n\tstatic void Main()\n\t{\n\t\tlong n = long.Parse(Console.ReadLine());\n    long mod = 998244353;\n    long answer = DivideMod(2,n,mod);//2^n\n\n    long[,] vertexes = new long[n,2];//ここに受け取る\n    for(long i = 0; i < n; i++)\n    {\n      long[] nums = Array.ConvertAll(Console.ReadLine().Split(' '),long.Parse);//１行ごとに受け取る\n      vertexes[i,0] = nums[0];\n      vertexes[i,1] = nums[1];\n    }\n\n    //Console.WriteLine(answer);\n    answer -= 1;//0個選択\n    //answer -= n;//1個選択\n    //answer -= n*(n-1)/2;//2個選択\n    //Console.WriteLine(answer);\n\n      for(int i = 0; i < n; i++)\n      {\n        for(int j = i+1; j < n; j++)\n        {\n          long memo = 0;\n          for(int k = 0; k < n; k++)\n          {\n            Vector2 vecA = new Vector2(vertexes[i,0], vertexes[i,1]);\n            Vector2 vecB = new Vector2(vertexes[j,0], vertexes[j,1]);\n            Vector2 vecC = new Vector2(vertexes[k,0], vertexes[k,1]);\n            if(Vector2.WhereVector(vecA,vecB,vecC) == 3)//線分上の点\n            {\n              memo++;\n            }\n          }\n            memo += 2;\n            answer -= DivideMod(2,memo,mod) - memo - 1;\n            //Console.WriteLine(answer);\n        }\n      }\n\n      answer %= mod;\n      if(answer < 0) answer += mod;\n\n\t\tConsole.WriteLine(answer);\n\t}\n\n  static long DivideMod(long x, long a, long p)//戻り値はx^a(mod p)\n  {\n    long num = 2;\n    long answer = 1;\n    long check = a;\n    long memo = x%p;\n    \n    while(check > 0)\n    {\n      if(check % num == num / 2)\n      {\n        check -= num / 2;\n        answer *= memo;\n        answer %= p;\n      }\n    memo *= memo;\n    memo %= p;\n    num *= 2;\n    }\n    return answer;\n  }\n}\n\nclass Vector2//2次元ベクトル\n{\n  static decimal EPS = 1e-10m;//小数誤差比較\n\n  public Vector2 (decimal X, decimal Y)\n  {\n    this.x = X;\n    this.y = Y;\n  }\n\n  public decimal x {private set; get;}\n  public decimal y {private set; get;}\n\n  public static Vector2 operator + (Vector2 ob1, Vector2 ob2)//ベクトルの基本演算\n  {\n    return new Vector2 (ob1.x + ob2.x, ob1.y + ob2.y);\n  }\n  public static Vector2 operator - (Vector2 ob1, Vector2 ob2)\n  {\n    return new Vector2 (ob1.x - ob2.x, ob1.y - ob2.y);\n  }\n  public static Vector2 operator * (Vector2 ob, decimal scalar)\n  {\n    return new Vector2 (ob.x * scalar, ob.y * scalar);\n  }\n  public static Vector2 operator * (decimal scalar, Vector2 ob)\n  {\n    return new Vector2 (ob.x * scalar, ob.y * scalar);\n  }\n  public static Vector2 operator / (Vector2 ob, decimal scalar)\n  {\n    return new Vector2 (ob.x / scalar, ob.y / scalar);\n  }\n\n  public decimal Length()//ベクトルの長さの2乗\n  {\n    return x * x + y * y;\n  }\n  public static decimal Distance(Vector2 ob1, Vector2 ob2)//2点間の距離\n  {\n    return (decimal)Math.Sqrt((double)((ob1.x-ob2.x) * (ob1.x-ob2.x) + (ob1.y-ob2.y) * (ob1.y-ob2.y)));\n  }\n  public static decimal DotProduct(Vector2 ob1, Vector2 ob2)//内積\n  {\n    return ob1.x * ob2.x + ob1.y * ob2.y;\n  }\n  public static decimal CrossProduct(Vector2 ob1, Vector2 ob2)//外積。第2引数が反時計回り側で正。\n  {\n    return ob1.x * ob2.y - ob1.y * ob2.x;\n  }\n  public static decimal Arg(Vector2 p)//x軸に対する偏角\n  {\n    return (decimal)Math.Atan2((double)p.y, (double)p.x);\n  }\n  public static Vector2 PoralCoordinate(decimal radius, decimal angle)//長さと座標から極座標にする\n  {\n    return new Vector2(radius * (decimal)Math.Cos((double)angle), radius * (decimal)Math.Sin((double)angle));\n  }\n\n  public static Vector2 Projection(Vector2 beginPoint, Vector2 endPoint, Vector2 point)//点の射影\n  {\n    Vector2 segment = endPoint - beginPoint;\n    decimal ratio = Vector2.DotProduct(point - beginPoint, segment) / segment.Length();\n    return beginPoint + segment * ratio;//始点にたす\n  }\n\npublic static long WhereVector(Vector2 beginPoint, Vector2 endPoint, Vector2 point)\n  {//ベクトルに対する点の位置\n    Vector2 segment = endPoint - beginPoint;\n    Vector2 aimVec = point - beginPoint;\n    if(Vector2.CrossProduct(segment, aimVec) > 0)\n      return 1;//反時計回り側\n    else if(Vector2.CrossProduct(segment, aimVec) < 0)\n      return 2;//時計回り側\n    else if(Vector2.DotProduct(segment, aimVec) < -1+EPS)\n      return 3;//ベクトル反対向きの側\n    else if(segment.Length() < aimVec.Length())\n      return 4;//ベクトル向きの側\n    else\n      return 5;//ベクトル上\n  }\n\n  public static long IsIntersect(Vector2 vecA, Vector2 vecB,\n    Vector2 vecAsub, Vector2 vecBsub)//2線分の交差判定\n  {\n    bool answer = false;\n\n    if(Vector2.WhereVector(vecA, vecB, vecAsub) + Vector2.WhereVector(vecA, vecB, vecBsub) == 3\n    && Vector2.WhereVector(vecAsub, vecBsub, vecA) + Vector2.WhereVector(vecAsub, vecBsub, vecB) == 3)\n      answer = true;\n    if(Vector2.WhereVector(vecA, vecB, vecAsub) == 5 || Vector2.WhereVector(vecA, vecB, vecBsub) == 5\n    || Vector2.WhereVector(vecAsub, vecBsub, vecA) == 5 || Vector2.WhereVector(vecAsub, vecBsub, vecB) == 5)\n      answer = true;\n    return((answer) ? 1 : 0);\n  }\n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\n\tstatic void Main()\n\t{\n\t\tlong n = long.Parse(Console.ReadLine());\n    long mod = 998244353;\n    long answer = DivideMod(2,n,mod);//2^n\n\n    long[,] vertexes = new long[n,2];//ここに受け取る\n    for(long i = 0; i < n; i++)\n    {\n      long[] nums = Array.ConvertAll(Console.ReadLine().Split(' '),long.Parse);//１行ごとに受け取る\n      vertexes[i,0] = nums[0];\n      vertexes[i,1] = nums[1];\n    }\n\n    answer -= 1;//0個選択\n    answer -= n;//1個選択\n    answer -= n*(n-1)/2;//2個選択\n\n      for(int i = 0; i < n; i++)\n      {\n        for(int j = i+1; j < n; j++)\n        {\n          for(int k = j+1; k < n; k++)\n          {\n            Vector2 vecA = new Vector2(vertexes[i,0], vertexes[i,1]);\n            Vector2 vecB = new Vector2(vertexes[j,0], vertexes[j,1]);\n            Vector2 vecC = new Vector2(vertexes[k,0], vertexes[k,1]);\n            if(Vector2.WhereVector(vecA,vecB,vecC) >= 3)//3点が一直線上\n            {\n              answer--;\n            }\n          }\n        }\n      }\n\n      answer %= mod;\n      if(answer < 0) answer += mod;\n\n\t\tConsole.WriteLine(answer);\n\t}\n\n  static long DivideMod(long x, long a, long p)//戻り値はx^a(mod p)\n  {\n    long num = 2;\n    long answer = 1;\n    long check = a;\n    long memo = x%p;\n    \n    while(check > 0)\n    {\n      if(check % num == num / 2)\n      {\n        check -= num / 2;\n        answer *= memo;\n        answer %= p;\n      }\n    memo *= memo;\n    memo %= p;\n    num *= 2;\n    }\n    return answer;\n  }\n}\n\nclass Vector2//2次元ベクトル\n{\n  static decimal EPS = 1e-10m;//小数誤差比較\n\n  public Vector2 (decimal X, decimal Y)\n  {\n    this.x = X;\n    this.y = Y;\n  }\n\n  public decimal x {private set; get;}\n  public decimal y {private set; get;}\n\n  public static Vector2 operator + (Vector2 ob1, Vector2 ob2)//ベクトルの基本演算\n  {\n    return new Vector2 (ob1.x + ob2.x, ob1.y + ob2.y);\n  }\n  public static Vector2 operator - (Vector2 ob1, Vector2 ob2)\n  {\n    return new Vector2 (ob1.x - ob2.x, ob1.y - ob2.y);\n  }\n  public static Vector2 operator * (Vector2 ob, decimal scalar)\n  {\n    return new Vector2 (ob.x * scalar, ob.y * scalar);\n  }\n  public static Vector2 operator * (decimal scalar, Vector2 ob)\n  {\n    return new Vector2 (ob.x * scalar, ob.y * scalar);\n  }\n  public static Vector2 operator / (Vector2 ob, decimal scalar)\n  {\n    return new Vector2 (ob.x / scalar, ob.y / scalar);\n  }\n\n  public decimal Length()//ベクトルの長さの2乗\n  {\n    return x * x + y * y;\n  }\n  public static decimal Distance(Vector2 ob1, Vector2 ob2)//2点間の距離\n  {\n    return (decimal)Math.Sqrt((double)((ob1.x-ob2.x) * (ob1.x-ob2.x) + (ob1.y-ob2.y) * (ob1.y-ob2.y)));\n  }\n  public static decimal DotProduct(Vector2 ob1, Vector2 ob2)//内積\n  {\n    return ob1.x * ob2.x + ob1.y * ob2.y;\n  }\n  public static decimal CrossProduct(Vector2 ob1, Vector2 ob2)//外積。第2引数が反時計回り側で正。\n  {\n    return ob1.x * ob2.y - ob1.y * ob2.x;\n  }\n  public static decimal Arg(Vector2 p)//x軸に対する偏角\n  {\n    return (decimal)Math.Atan2((double)p.y, (double)p.x);\n  }\n  public static Vector2 PoralCoordinate(decimal radius, decimal angle)//長さと座標から極座標にする\n  {\n    return new Vector2(radius * (decimal)Math.Cos((double)angle), radius * (decimal)Math.Sin((double)angle));\n  }\n\n  public static Vector2 Projection(Vector2 beginPoint, Vector2 endPoint, Vector2 point)//点の射影\n  {\n    Vector2 segment = endPoint - beginPoint;\n    decimal ratio = Vector2.DotProduct(point - beginPoint, segment) / segment.Length();\n    return beginPoint + segment * ratio;//始点にたす\n  }\n\npublic static long WhereVector(Vector2 beginPoint, Vector2 endPoint, Vector2 point)\n  {//ベクトルに対する点の位置\n    Vector2 segment = endPoint - beginPoint;\n    Vector2 aimVec = point - beginPoint;\n    if(Vector2.CrossProduct(segment, aimVec) > EPS)\n      return 1;//反時計回り側\n    else if(Vector2.CrossProduct(segment, aimVec) < -EPS)\n      return 2;//時計回り側\n    else if(Vector2.DotProduct(segment, aimVec) < -1+EPS)\n      return 3;//ベクトル反対向きの側\n    else if(segment.Length() < aimVec.Length())\n      return 4;//ベクトル向きの側\n    else\n      return 5;//ベクトル上\n  }\n\n  public static long IsIntersect(Vector2 vecA, Vector2 vecB,\n    Vector2 vecAsub, Vector2 vecBsub)//2線分の交差判定\n  {\n    bool answer = false;\n\n    if(Vector2.WhereVector(vecA, vecB, vecAsub) + Vector2.WhereVector(vecA, vecB, vecBsub) == 3\n    && Vector2.WhereVector(vecAsub, vecBsub, vecA) + Vector2.WhereVector(vecAsub, vecBsub, vecB) == 3)\n      answer = true;\n    if(Vector2.WhereVector(vecA, vecB, vecAsub) == 5 || Vector2.WhereVector(vecA, vecB, vecBsub) == 5\n    || Vector2.WhereVector(vecAsub, vecBsub, vecA) == 5 || Vector2.WhereVector(vecAsub, vecBsub, vecB) == 5)\n      answer = true;\n    return((answer) ? 1 : 0);\n  }\n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var P = Enumerate(n, x => new int[] { ri, ri });\n            const long M = 998244353;\n            var ans = (long)BigInteger.ModPow(2, n, M);\n            ans = (ans + M - n - 1) % M;\n            var comb = new long[250, 250];\n            comb[0, 0] = 1;\n            foreach (var i in Rep(220))\n                foreach (var j in Rep(220)) {\n                    comb[i, j] %= M;\n                    comb[i + 1, j] += comb[i, j];\n                    comb[i + 1, j + 1] += comb[i, j];\n                }\n            Debug.WriteLine(ans);\n            for (int i = 0; i < n; i++)\n                for (int j = i + 1; j < n; j++) {\n                    var dx = P[j][0] - P[i][0];\n                    var dy = P[j][1] - P[i][1];\n                    Debug.WriteLine($\"{i} {j} {dx} {dy}\");\n                    var cnt = 2;\n                    var s = new List<int>() { i, j };\n                    for (int k = 0; k < n; k++) {\n                        if (k == i || k == j) continue;\n                        var ex = P[k][0] - P[i][0];\n                        var ey = P[k][1] - P[i][1];\n                        if (eq(dx, dy, ex, ey)) { cnt++; s.Add(k); }\n                    }\n                    s.Sort();\n                    var add = (long)(BigInteger.ModPow(2, cnt, M) + M - cnt - 1) % M;\n                    add = (long)(add * BigInteger.ModPow(comb[cnt, 2], M - 2, M) % M);\n                    Debug.WriteLine(add);\n                    Debug.WriteLine(s.AsJoinedString());\n                    ans = (ans + M - add) % M;\n                }\n            Console.WriteLine(ans);\n        }\n        bool eq(int dx, int dy, int ex, int ey) {\n            if (dx == 0) return ex == 0;\n            if (dy == 0) return ey == 0;\n            return ex * dy == ey * dx;\n        }\n\n\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n    Scanner cin;\n    \n    void calc()\n    {\n        cin = new Scanner();\n        int N = cin.nextInt();\n        int[] x = new int[N];\n        int[] y = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            x[i] = cin.nextInt();\n            y[i] = cin.nextInt();\n        }\n\n        long ans = 0;\n        long mod = 998244353;\n\n        int MAX2 = 300;\n        long[] pow2 = new long[MAX2];\n        pow2[0] = 0;\n        pow2[1] = 1;\n        for (int i = 2; i < MAX2; i++)\n        {\n            pow2[i] = (pow2[i - 1] * 2 + 1) % mod;\n        }\n\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = i + 1; j < N; j++)\n            {\n                long cnt = 0;\n                long cnt2 = 0;\n                for (int k = j + 1; k < N; k++)\n                {\n                    cnt++;\n                    if (calcT(x[i] - x[k], y[i] - y[k], x[j] - x[k], y[j] - y[k]) == 0)\n                    {\n                        cnt2++;\n                    }\n                }\n\n                ans += pow2[cnt];\n                ans -= pow2[cnt2];\n                ans %= mod;\n                ans += mod;\n                ans %= mod;\n            }\n        }\n        Console.WriteLine(ans);\n    }\n\n    long calcT(long ax, long ay, long bx, long by)\n    {\n        return (ax * by) - (bx * ay);\n    }\n\n        \n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n "
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        int[] X = new int[N];\n        int[] Y = new int[N];\n        for(int i=0;i<N;i++){\n            X[i] = re.i();\n            Y[i] = re.i();\n        }\n        long[] Po = new long[N+1];\n        Po[0] = 1;\n        for(int i=1;i<=N;i++){\n            Po[i] = Po[i-1] * 2 % Define.mod;\n        }\n        long count = Po[N];\n        count += Define.mod - (1 + N);\n        count %= Define.mod;\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                int c = 2;\n                int x1 = X[i] - X[j];\n                int y1 = Y[i] - Y[j];\n                for(int k=0;k<N;k++){\n                    if(k != i && k != j){\n                        int x2 = X[i] - X[k];\n                        int y2 = Y[i] - Y[k];\n                        if(x1*y2 == x2*y1){\n                            if(k < j){\n                                c = 0;\n                                break;\n                            }\n                            else{\n                                c++;\n                            }\n                        }\n                    }\n                }\n                count += Define.mod - Po[c] + 1 + c;\n                count %= Define.mod;\n            }\n        }\n        sb.Append(count+\"\\n\");\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 998244353;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\n\tstatic void Main()\n\t{\n\t\tlong n = long.Parse(Console.ReadLine());\n    long mod = 998244353;\n    long answer = DivideMod(2,n,mod);//2^n\n\n    long[,] vertexes = new long[n,2];//ここに受け取る\n    for(long i = 0; i < n; i++)\n    {\n      long[] nums = Array.ConvertAll(Console.ReadLine().Split(' '),long.Parse);//１行ごとに受け取る\n      vertexes[i,0] = nums[0];\n      vertexes[i,1] = nums[1];\n    }\n\n    answer -= 1;//0個選択\n    answer -= n;//1個選択\n    answer -= n*(n-1)/2;//2個選択\n\n      for(int i = 0; i < n; i++)\n      {\n        for(int j = i+1; j < n; j++)\n        {\n          for(int k = j+1; k < n; k++)\n          {\n            Vector2 vecA = new Vector2(vertexes[i,0], vertexes[i,1]);\n            Vector2 vecB = new Vector2(vertexes[j,0], vertexes[j,1]);\n            Vector2 vecC = new Vector2(vertexes[k,0], vertexes[k,1]);\n            if(Vector2.WhereVector(vecA,vecB,vecC) >= 3)//3点が一直線上\n            {\n              answer--;\n            }\n          }\n        }\n      }\n\n\t\tConsole.WriteLine(answer);\n\t}\n\n  static long DivideMod(long x, long a, long p)//戻り値はx^a(mod p)\n  {\n    long num = 2;\n    long answer = 1;\n    long check = a;\n    long memo = x%p;\n    \n    while(check > 0)\n    {\n      if(check % num == num / 2)\n      {\n        check -= num / 2;\n        answer *= memo;\n        answer %= p;\n      }\n    memo *= memo;\n    memo %= p;\n    num *= 2;\n    }\n    return answer;\n  }\n\n  class Vector2//2次元ベクトル\n{\nstatic decimal EPS = 1e-10m;//小数誤差比較\n\n  public Vector2 (decimal X, decimal Y)\n  {\n    this.x = X;\n    this.y = Y;\n  }\n\n  public decimal x {private set; get;}\n  public decimal y {private set; get;}\n\n  public static Vector2 operator + (Vector2 ob1, Vector2 ob2)//ベクトルの基本演算\n  {\n    return new Vector2 (ob1.x + ob2.x, ob1.y + ob2.y);\n  }\n  public static Vector2 operator - (Vector2 ob1, Vector2 ob2)\n  {\n    return new Vector2 (ob1.x - ob2.x, ob1.y - ob2.y);\n  }\n  public static Vector2 operator * (Vector2 ob, decimal scalar)\n  {\n    return new Vector2 (ob.x * scalar, ob.y * scalar);\n  }\n  public static Vector2 operator * (decimal scalar, Vector2 ob)\n  {\n    return new Vector2 (ob.x * scalar, ob.y * scalar);\n  }\n  public static Vector2 operator / (Vector2 ob, decimal scalar)\n  {\n    return new Vector2 (ob.x / scalar, ob.y / scalar);\n  }\n\n  public decimal Length()//ベクトルの長さの2乗\n  {\n    return x * x + y * y;\n  }\n  public static decimal Distance(Vector2 ob1, Vector2 ob2)//2点間の距離\n  {\n    return (decimal)Math.Sqrt((double)((ob1.x-ob2.x) * (ob1.x-ob2.x) + (ob1.y-ob2.y) * (ob1.y-ob2.y)));\n  }\n  public static decimal DotProduct(Vector2 ob1, Vector2 ob2)//内積\n  {\n    return ob1.x * ob2.x + ob1.y * ob2.y;\n  }\n  public static decimal CrossProduct(Vector2 ob1, Vector2 ob2)//外積。第2引数が反時計回り側で正。\n  {\n    return ob1.x * ob2.y - ob1.y * ob2.x;\n  }\n  public static decimal Arg(Vector2 p)//x軸に対する偏角\n  {\n    return (decimal)Math.Atan2((double)p.y, (double)p.x);\n  }\n  public static Vector2 PoralCoordinate(decimal radius, decimal angle)//長さと座標から極座標にする\n  {\n    return new Vector2(radius * (decimal)Math.Cos((double)angle), radius * (decimal)Math.Sin((double)angle));\n  }\n\n  public static Vector2 Projection(Vector2 beginPoint, Vector2 endPoint, Vector2 point)//点の射影\n  {\n    Vector2 segment = endPoint - beginPoint;\n    decimal ratio = Vector2.DotProduct(point - beginPoint, segment) / segment.Length();\n    return beginPoint + segment * ratio;//始点にたす\n  }\n\npublic static long WhereVector(Vector2 beginPoint, Vector2 endPoint, Vector2 point)\n  {//ベクトルに対する点の位置\n    Vector2 segment = endPoint - beginPoint;\n    Vector2 aimVec = point - beginPoint;\n    if(Vector2.CrossProduct(segment, aimVec) > EPS)\n      return 1;//反時計回り側\n    else if(Vector2.CrossProduct(segment, aimVec) < -EPS)\n      return 2;//時計回り側\n    else if(Vector2.DotProduct(segment, aimVec) < -1+EPS)\n      return 3;//ベクトル反対向きの側\n    else if(segment.Length() < aimVec.Length())\n      return 4;//ベクトル向きの側\n    else\n      return 5;//ベクトル上\n  }\n\n  public static long IsIntersect(Vector2 vecA, Vector2 vecB,\n    Vector2 vecAsub, Vector2 vecBsub)//2線分の交差判定\n  {\n    bool answer = false;\n\n    if(Vector2.WhereVector(vecA, vecB, vecAsub) + Vector2.WhereVector(vecA, vecB, vecBsub) == 3\n    && Vector2.WhereVector(vecAsub, vecBsub, vecA) + Vector2.WhereVector(vecAsub, vecBsub, vecB) == 3)\n      answer = true;\n    if(Vector2.WhereVector(vecA, vecB, vecAsub) == 5 || Vector2.WhereVector(vecA, vecB, vecBsub) == 5\n    || Vector2.WhereVector(vecAsub, vecBsub, vecA) == 5 || Vector2.WhereVector(vecAsub, vecBsub, vecB) == 5)\n      answer = true;\n    return((answer) ? 1 : 0);\n  }\n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        int[] X = new int[N];\n        int[] Y = new int[N];\n        for(int i=0;i<N;i++){\n            X[i] = re.i();\n            Y[i] = re.i();\n        }\n        long[] Po = new long[N+1];\n        Po[0] = 1;\n        for(int i=1;i<=N;i++){\n            Po[i] = Po[i-1] * 2 % Define.mod;\n        }\n        long count = Po[N];\n        count += Define.mod - (1 + N);\n        count %= Define.mod;\n        Data[] D = new Data[N*(N-1)/2];\n        int c = 0;\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                int x = X[i] - X[j];\n                int y = Y[i] - Y[j];\n                D[c] = new Data(x,y,i,j);\n                c++;\n            }\n        }\n        Array.Sort(D,(a,b)=>(a.x == 0 ? -100000000 : b.x*a.y) - (b.x == 0 ? -100000000 : a.x*b.y));\n        int[] A = new int[N];\n        int[] B = new int[N];\n        for(int i=0;i<N;i++){\n            A[i] = -1;\n            B[i] = -1;\n        }\n        for(int i=0;i<c;i++){\n            Data d = D[i];\n            int p = d.p1;\n            if(A[p] == -1){\n                A[p] = i;\n                B[p] = 1;\n            }\n            else if(SameR(d,D[A[p]])){\n                if(B[p] != -1){\n                    B[p]++;\n                }\n            }\n            else{\n                count += Define.mod - Po[B[p]+1] + (2 + B[p]);\n                count %= Define.mod;\n                A[p] = i;\n                B[p] = 1;\n            }\n            p = d.p2;\n            if(A[p] != -1 && !SameR(d,D[A[p]])){\n                count += Define.mod - Po[B[p]+1] + (2 + B[p]);\n                count %= Define.mod;\n            }\n            A[p] = i;\n            B[p] = -1;\n        }\n        for(int i=0;i<N;i++){\n            count += Define.mod - Po[B[i]+1] + (2 + B[i]);\n            count %= Define.mod;\n        }\n        sb.Append(count+\"\\n\");\n    }\n    bool SameR(Data a,Data b){\n        return (a.x == 0 ? -100000000 : b.x*a.y) == (b.x == 0 ? -100000000 : a.x*b.y);\n    }\n}\nclass Data{\n    public int x;\n    public int y;\n    public int p1;\n    public int p2;\n    public Data(int x0,int y0,int i,int j){\n        if(x0 > 0){\n            x = x0;\n            y = y0;\n        }\n        else{\n            x = -x0;\n            y = -y0;\n        }\n        p1 = i;\n        p2 = j;\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 998244353;\n}"
  },
  {
    "language": "Ruby",
    "code": "# https://beta.atcoder.jp/contests/arc082/submissions/1566776\n\nn = gets.chomp.to_i\n\nx = []\ny = []\n\nn.times do\n  a, b = gets.chomp.split(\" \").map(&:to_i)\n  x << a\n  y << b\nend\n\nmd = 998244353\n\nmaxN = 201\npow2 = Array.new(maxN)\npow2[0] = 0\npow2[1] = 1\n\n(2...maxN).each do |i|\n  pow2[i] = (pow2[i - 1] * 2 + 1) % md\nend\n\ndef line?(ix, iy, jx, jy, kx, ky)\n  x1 = ix - jx\n  y1 = iy - jy\n  x2 = ix - kx\n  y2 = ix - ky\n  return (y1 * x2) == (y2 * x1)\nend\n\nans = 0\n\n(0...n).each do |i|\n  ((i + 1)...n).each do |j|\n    cnt1 = 0\n    cnt2 = 0\n    ((j + 1)...n).each do |k|\n      cnt1 += 1\n      if line?(x[i], y[i], x[j], y[j], x[k], y[k])\n        cnt2 += 1\n      end\n    end\n\n    ans += pow2[cnt1]\n    ans -= pow2[cnt2]\n    ans %= md\n    ans += md\n    ans %= md\n  end\nend\nputs ans\n\n\n"
  },
  {
    "language": "Ruby",
    "code": "M=998244353;N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N+~N;[*0...N].combination(2){|i,j|h[x=[i,j]]||((j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag.abs<1e-9&&x<<k};r-=2**(l=x.size)+~l;x.combination(2){|a,b|h[[a,b]]=1})};p r%M"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N+~N;[*0...N].combination(2){|i,j|h[x=i,j]||(x+=(j+1...N).select{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag==0};r-=2**(l=x.size)+~l;x.combination(2){|e|h[e]=1})};p r%998244353"
  },
  {
    "language": "Ruby",
    "code": "M=998244353;N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N%M-N-1;N.times{|i|(i+1...N).map{|j|h[x=[i,j]]&&next;(j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag.abs<1e-12&&x<<k};x.size.times{|a|(a+1...x.size).map{|b|r=(r-2**(b+~a))%M;h[[x[a],x[b]]]=1}}}};p r%M"
  },
  {
    "language": "Ruby",
    "code": "M=998244353;N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N%M-N-1;N.times{|i|(i+1...N).map{|j|h[x=[i,j]]&&next;(j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag.abs<1e-12&&x<<k};x.size.times{|a|(a+1...x.size).map{|b|r=(r-2**(b+~a))%M;h[[x[a],x[b]]]=1}}}};p r%M"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N+~N;[*0...N].combination(2){|i,j|h[x=[i,j]]||((j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag.abs<1e-9&&x<<k};r-=2**(l=x.size)+~l;x.combination(2){|e|h[e]=1})};p r"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i\na=[]\nn.times do\n  a<< gets.split.map(&:to_i)\nend\nb=Array.new(n).map{[]}\nr=[]\n0.upto(n-3) do |i|\n  (i+1).upto(n-2) do |j|\n    g = 1.0*(a[i][0]-a[j][0])/(a[i][1]-a[j][1])\n    g=10**9 if a[i][1]-a[j][1] == 0\n    t=0\n    (j+1).upto(n-1) do |k|\n      c=false\n      2.times do |l|\n        if a[i][l]==a[j][l] && a[i][l]==a[k][l]\n          c=true\n        end\n      end\n      gg = 1.0*(a[i][0]-a[k][0])/(a[i][1]-a[k][1])\n      gg = 10**9 if a[i][1]-a[k][1] == 0\n      if g == gg\n        c=true\n      end\n      if c\n        if !b[k].include?(i) && !b[k].include?(j)\n          t+=1\n          b[k]<< i\n          b[k]<< j\n        end\n      end\n    end\n    r<< t+2 if t!=0\n  end\nend\ny=[1,1]\n2.upto(200) do |i|\n  y<< y[-1]*i\nend\n$y=y\ntt=0\ndef ncm n,m\n  $y[n]/$y[n-m]/$y[m]\nend\nif n>=3\n  tt+=(g=ncm n,3)\n  (n-3).times do |i|\n    tt+=(g=g*(n-3-i)/(4+i))\n  end\n  r.each do |e|\n    tt-=(g=ncm e,3)\n    (e-3).times do |i|\n      tt-=(g=g*(e-3-i)/(4+i))\n    end\n  end\nend\np tt%998244353\n  \n  "
  },
  {
    "language": "Ruby",
    "code": "M=998244353;N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N%M-N-1;N.times{|i|(i+1...N).map{|j|h[x=[i,j]]&&next;(j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag.abs<1e-9&&x<<k};x.size.times{|a|(a+1...x.size).map{|b|r=(r-2**(b+~a))%M;h[[x[a],x[b]]]=1}}}};p r"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N+~N;[*0...N].combination(2){|i,j|h[x=[i,j]]||((j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag==0&&x<<k};r-=2**(l=x.size)+~l;x.combination(2){|e|h[e]=1})};p r%998244353"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N+~N;[*0...N].combination(2){|i,j|h[x=[i,j]]||(x+=(j+1...N).select{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag==0};r-=2**(l=x.size)+~l;x.combination(2){|e|h[e]=1})};p r%998244353"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N+~N;[*0...N].send(*(z=:combination,2)){|i,j|h[x=[i,j]]||((j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag==0&&x<<k};r-=2**(l=x.size)+~l;x.send(*z){|e|h[e]=1})};p r%998244353"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N+~N;[*0...N].combination(2){|i,j|h[[i,j]]||(x=(0...N).select{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag==0};r-=2**(l=x.size)+~l;x.combination(2){|e|h[e]=1})};p r%998244353"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i\na=[]\nn.times do\n  a.push(gets.split.map(&:to_i))\nend\nb=Array.new(n).map{[nil]*n}\nr=[]\n0.upto(n-3) do |i|\n  (i+1).upto(n-2) do |j|\n    g = 1.0*(a[i][0]-a[j][0])/(a[i][1]-a[j][1])\n    g=10**9 if a[i][1]-a[j][1] == 0\n    t=0\n    (j+1).upto(n-1) do |k|\n      c=false\n      2.times do |l|\n        if a[i][l]==a[j][l] && a[i][l]==a[k][l]\n          c=true\n        end\n      end\n      gg = 1.0*(a[i][0]-a[k][0])/(a[i][1]-a[k][1])\n      gg = 10**9 if a[i][1]-a[k][1] == 0\n      if g == gg\n        c=true\n      end\n      if c\n        cc=true\n        if !b[k][i]\n          b[k][i]=true\n        else\n          cc=false\n        end\n        if !b[k][j]\n          b[k][j]=true\n        else\n          cc=false\n        end\n        if cc\n          t+=1\n        end\n      end\n    end\n    r.push(t+2) if t!=0\n  end\nend\ntt=0\nif n>=3\n  tt+=(g=n*(n-1)*(n-2)/6)\n  (n-3).times do |i|\n    tt+=(g=g*(n-3-i)/(4+i))\n  end\n  r.each do |e|\n    tt-=(g=e*(e-1)*(e-2)/6)\n    (e-3).times do |i|\n      tt-=(g=g*(e-3-i)/(4+i))\n    end\n  end\nend\np tt%998244353\n  \n  "
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N+~N;[*0...N].combination(2){|i,j|h[x=[i,j]]||((j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag.abs<1e-9&&x<<k};r-=2**(l=x.size)+~l;x.combination(2){|e|h[e]=1})};p r%998244353"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i\nc=1\nn.times do\nn.times do\nn.times do\nc+=1\nend\nend\nend\n#n^3"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\nxs, ys = [], []\nN.times do |i|\n    xs[i], ys[i] = gets.split.map(&:to_i)\nend\nMOD = 998244353\n\npmod2 = [1]\n(1..N).each do |i|\n    pmod2[i] = pmod2[i-1] * 2 % MOD\nend\n\nans = (pmod2[N] - N - 1) % MOD\nchecked = Array.new(N){Array.new(N)}\n\nN.times do |i|\n    ((i+1)...N).each do |j|\n        next if checked[i][j]\n        pts = [i, j]\n        ((j+1)...N).each do |k|\n            if (xs[j]-xs[i]) * (ys[k]-ys[i]) == (xs[k]-xs[i]) * (ys[j]-ys[i])\n                pts.push(k)\n            end\n        end\n        num = pts.length\n        ans = (ans - pmod2[num] + num + 1) % MOD\n        num.times do |a|\n            ((a+1)...num).each do |b|\n                checked[pts[a]][pts[b]] = true\n            end\n        end\n    end\nend\nputs ans"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i\na=[]\nn.times do\n  a<< gets.split.map(&:to_i)\nend\nb=Array.new(n).map{[]}\nr=[]\n0.upto(n-3) do |i|\n  (i+1).upto(n-2) do |j|\n    g = 1.0*(a[i][0]-a[j][0])/(a[i][1]-a[j][1])\n    g=10**9 if a[i][1]-a[j][1] == 0\n    t=0\n    (j+1).upto(n-1) do |k|\n      c=false\n      2.times do |l|\n        if a[i][l]==a[j][l] && a[i][l]==a[k][l]\n          c=true\n        end\n      end\n      gg = 1.0*(a[i][0]-a[k][0])/(a[i][1]-a[k][1])\n      gg = 10**9 if a[i][1]-a[k][1] == 0\n      if g == gg\n        c=true\n      end\n      if c\n        cc=true\n        if !b[k].include?(i)\n          b[k]<< i\n        else\n          cc=false\n        end\n        if !b[k].include?(j)\n          b[k]<< j\n        else\n          cc=false\n        end\n        if cc\n          t+=1\n        end\n      end\n    end\n    r<< t+2 if t!=0\n  end\nend\ntt=0\nif n>=3\n  tt+=(g=n*(n-1)*(n-2)/6)\n  (n-3).times do |i|\n    tt+=(g=g*(n-3-i)/(4+i))\n  end\n  r.each do |e|\n    tt-=(g=e*(e-1)*(e-2)/6)\n    (e-3).times do |i|\n      tt-=(g=g*(e-3-i)/(4+i))\n    end\n  end\nend\np tt%998244353\n  \n  "
  },
  {
    "language": "Ruby",
    "code": "M=998244353;N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N%M-N-1;N.times{|i|(i+1...N).map{|j|h[x=[i,j]]||(j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag.abs<1e-9&&x<<k}&&(l=x.size).times{|a|(a+1...l).map{|b|r=(r-2**(b+~a))%M;h[[x[a],x[b]]]=1}}}};p r"
  },
  {
    "language": "Ruby",
    "code": "M=998244353;N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N%M-N-1;N.times{|i|(i+1...N).map{|j|h[x=[i,j]]||(j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag.abs<1e-9&&x<<k}&&x.size.times{|a|(a+1...x.size).map{|b|r=(r-2**(b+~a))%M;h[[x[a],x[b]]]=1}}}};p r"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i\na=[]\nn.times do\n  a<< gets.split.map(&:to_i)\nend\nb=Array.new(n).map{[]}\nr=[]\nx=[]\n0.upto(n-3) do |i|\n  (i+1).upto(n-2) do |j|\n    g = 1.0*(a[i][0]-a[j][0])/(a[i][1]-a[j][1])\n    g=10**9 if a[i][1]-a[j][1] == 0\n    t=0\n    (j+1).upto(n-1) do |k|\n      c=false\n      2.times do |l|\n        if a[i][l]==a[j][l] && a[i][l]==a[k][l]\n          c=true\n        end\n      end\n      gg = 1.0*(a[i][0]-a[k][0])/(a[i][1]-a[k][1])\n      gg = 10**9 if a[i][1]-a[k][1] == 0\n      if g == gg\n        c=true\n      end\n      if c\n        x<< [j,k]\n        if !x.include?([i,k])\n        t+=1\n        x<< [i,k]\n        end\n      end\n    end\n    r<< t+2 if t!=0\n  end\nend\ny=[1,1]\n2.upto(200) do |i|\n  y<< y[-1]*i\nend\n$y=y\ntt=0\ndef ncm n,m\n  $y[n]/$y[n-m]/$y[m]\nend\nif n>=3\n  (n-2).times do |i|\n    tt+=ncm n,(3+i)\n  end\n  r.each do |e|\n    3.upto(e) do |ee|\n      tt-=ncm e,ee\n    end\n  end\nend\np tt\n  \n  "
  },
  {
    "language": "Ruby",
    "code": "M=998244353;N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N+~N;[*0...N].combination(2){|i,j|h[x=[i,j]]||((j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag.abs<1e-9&&x<<k};r-=2**(l=x.size)+~l;x.combination(2){|e|h[e]=1})};p r%M"
  },
  {
    "language": "Ruby",
    "code": "# https://beta.atcoder.jp/contests/arc082/submissions/1566776\n\nn = gets.chomp.to_i\n\nx = []\ny = []\n\nn.times do\n  a, b = gets.chomp.split(\" \").map(&:to_i)\n  x << a\n  y << b\nend\n\nmd = 998244353\n\nmaxN = 201\npow2 = Array.new(maxN)\npow2[0] = 0\npow2[1] = 1\n\n(2...maxN).each do |i|\n  pow2[i] = (pow2[i - 1] * 2 + 1) % md\nend\n\ndef line?(ix, iy, jx, jy, kx, ky)\n  x1 = ix - jx\n  y1 = iy - jy\n  x2 = ix - kx\n  y2 = iy - ky\n  return (y1 * x2) == (y2 * x1)\nend\n\nans = 0\n\n(0...n).each do |i|\n  ((i + 1)...n).each do |j|\n    cnt1 = 0\n    cnt2 = 0\n    ((j + 1)...n).each do |k|\n      cnt1 += 1\n      if line?(x[i], y[i], x[j], y[j], x[k], y[k])\n        cnt2 += 1\n      end\n    end\n\n    ans += pow2[cnt1]\n    ans -= pow2[cnt2]\n    ans %= md\n    ans += md\n    ans %= md\n  end\nend\nputs ans\n\n\n"
  },
  {
    "language": "Ruby",
    "code": "M=998244353;N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N%M-N-1;N.times{|i|(i+1...N).map{|j|h[x=[i,j]]&&next;(j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag.abs<1e-9&&x<<k};x.size.times{|a|(a+1...x.size).map{|b|r=(r-2**(b+~a))%M;h[[x[a],x[b]]]=1}}}};p r%M"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i\na=[]\nn.times do\n  a<< gets.split.map(&:to_i)\nend\nb=Array.new(n).map{[]}\nr=[]\n0.upto(n-3) do |i|\n  (i+1).upto(n-2) do |j|\n    g = 1.0*(a[i][0]-a[j][0])/(a[i][1]-a[j][1])\n    g=10**9 if a[i][1]-a[j][1] == 0\n    t=0\n    (j+1).upto(n-1) do |k|\n      c=false\n      2.times do |l|\n        if a[i][l]==a[j][l] && a[i][l]==a[k][l]\n          c=true\n        end\n      end\n      gg = 1.0*(a[i][0]-a[k][0])/(a[i][1]-a[k][1])\n      gg = 10**9 if a[i][1]-a[k][1] == 0\n      if g == gg\n        c=true\n      end\n      if c\n        cc=true\n        if !b[k].include?(i)\n          b[k]<< i\n        else\n          cc=false\n        end\n        if !b[k].include?(j)\n          b[k]<< j\n        else\n          cc=false\n        end\n        if cc\n          t+=1\n        end\n      end\n    end\n    r<< t+2 if t!=0\n  end\nend\ny=[1,1]\n2.upto(200) do |i|\n  y<< y[-1]*i\nend\n$y=y\ntt=0\ndef ncm n,m\n  $y[n]/$y[n-m]/$y[m]\nend\nif n>=3\n  tt+=(g=ncm n,3)\n  (n-3).times do |i|\n    tt+=(g=g*(n-3-i)/(4+i))\n  end\n  r.each do |e|\n    tt-=(g=ncm e,3)\n    (e-3).times do |i|\n      tt-=(g=g*(e-3-i)/(4+i))\n    end\n  end\nend\np tt%998244353\n  \n  "
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\nputs (2 ** n - (1 + n + (n * (n - 1) / 2))) % 998244353\n"
  },
  {
    "language": "Ruby",
    "code": "M=998244353;N=gets.to_i;v=$<.map{|e|Complex(*e.split.map(&:to_i))};h={};r=2**N%M+~N;[*0...N].combination(2){|i,j|h[x=[i,j]]||((j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag.abs<1e-9&&x<<k};r=(r-2**(l=x.size)-~l)%M;x.combination(2){|a,b|h[[a,b]]=1})};p r"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\nxs, ys = [], []\nN.times do |i|\n    xs[i], ys[i] = gets.split.map(&:to_i)\nend\nMOD = 998244353\n\npmod2 = [1]\n(1..N).each do |i|\n    pmod2[i] = pmod2[i-1] * 2 % MOD\nend\n\nans = (pmod2[N] - N - 1) % MOD\nchecked = Array.new(N){Array.new(N)}\n\nN.times do |i|\n    ((i+1)...N).each do |j|\n        next if checked[i][j]\n        pts = [i, j]\n        ((j+1)...N).each do |k|\n            if (xs[j]-xs[i]) * (ys[k]-ys[i]) == (xs[k]-xs[i]) * (ys[j]-ys[i])\n                pts.push(k)\n            end\n        end\n        num = pts.length\n        ans = (ans - pmod2[num] + num + 1) % MOD\n        num.times do |a|\n            ((a+1)...num).each do |b|\n                checked[a][b] = true\n            end\n        end\n    end\nend\nputs ans"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i\na=[]\nn.times do\n  a<< gets.split.map(&:to_i)\nend\nb=Array.new(n).map{[]}\nr=[]\nx=[]\n0.upto(n-3) do |i|\n  (i+1).upto(n-2) do |j|\n    g = 1.0*(a[i][0]-a[j][0])/(a[i][1]-a[j][1])\n    g=10**9 if a[i][1]-a[j][1] == 0\n    t=0\n    (j+1).upto(n-1) do |k|\n      c=false\n      2.times do |l|\n        if a[i][l]==a[j][l] && a[i][l]==a[k][l]\n          c=true\n        end\n      end\n      gg = 1.0*(a[i][0]-a[k][0])/(a[i][1]-a[k][1])\n      gg = 10**9 if a[i][1]-a[k][1] == 0\n      if g == gg\n        c=true\n      end\n      if c\n        x<< [j,k]\n        if !x.include?([i,k])\n          t+=1\n          x<< [i,k]\n        end\n      end\n    end\n    r<< t+2 if t!=0\n  end\nend\ny=[1,1]\n2.upto(200) do |i|\n  y<< y[-1]*i\nend\n$y=y\ntt=0\ndef ncm n,m\n  $y[n]/$y[n-m]/$y[m]\nend\nif n>=3\n  tt+=(g=ncm n,3)\n  (n-3).times do |i|\n    tt+=(g=g*(n-3-i)/(4+i))\n  end\n  r.each do |e|\n    tt-=(g=ncm e,3)\n    (e-3).times do |i|\n      tt-=(g=g*(e-3-i)/(4+i))\n    end\n  end\nend\np tt%998244353\n  \n  "
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i\na=[]\nn.times do\n  a.push(gets.split.map(&:to_i))\nend\nb=Array.new(n).map{[]}\nr=[]\n0.upto(n-3) do |i|\n  (i+1).upto(n-2) do |j|\n    g = 1.0*(a[i][0]-a[j][0])/(a[i][1]-a[j][1])\n    g=10**9 if a[i][1]-a[j][1] == 0\n    t=0\n    (j+1).upto(n-1) do |k|\n      c=false\n      2.times do |l|\n        if a[i][l]==a[j][l] && a[i][l]==a[k][l]\n          c=true\n        end\n      end\n      gg = 1.0*(a[i][0]-a[k][0])/(a[i][1]-a[k][1])\n      gg = 10**9 if a[i][1]-a[k][1] == 0\n      if g == gg\n        c=true\n      end\n      if c\n        cc=true\n        if !b[k].include?(i)\n          b[k].push i\n        else\n          cc=false\n        end\n        if !b[k].include?(j)\n          b[k].push j\n        else\n          cc=false\n        end\n        if cc\n          t+=1\n        end\n      end\n    end\n    r.push(t+2) if t!=0\n  end\nend\ntt=0\nif n>=3\n  tt+=(g=n*(n-1)*(n-2)/6)\n  (n-3).times do |i|\n    tt+=(g=g*(n-3-i)/(4+i))\n  end\n  r.each do |e|\n    tt-=(g=e*(e-1)*(e-2)/6)\n    (e-3).times do |i|\n      tt-=(g=g*(e-3-i)/(4+i))\n    end\n  end\nend\np tt%998244353\n  \n  "
  },
  {
    "language": "Ruby",
    "code": "M=998244353\nN=gets.to_i\nv=$<.map{|e|Complex(*e.split.map(&:to_i))}\nh={}\nr=2**N%M-N-1\nN.times{|i|(i+1...N).map{|j|\n\th[x=[i,j]]&&next\n\t(j+1...N).map{|k|((v[j]-v[k]).conj*(v[i]-v[k])).imag.abs<1e-12&&x<<k}\n\tx.size.times{|a|(a+1...x.size).map{|b|\n\t\tr=(r-2**(b+~a))%M\n\t\th[[x[a],x[b]]]=1\n\t}}\n}}\np r%M"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n \n \nlong powmod(long a, long x, long m) {\n    long ret = 1;\n    while (x) {\n        if (x % 2) ret = ret * a % m;\n        a = a * a % m;\n        x /= 2;\n    }\n    return ret;\n}\n \nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto X = new long[](N);\n    auto Y = new long[](N);\n    foreach (i; 0..N) {\n        auto s = readln.split.map!(to!long);\n        X[i] = s[0];\n        Y[i] = s[1];\n    }\n \n    bool line(int i, int j, int k) {\n        if (X[i] == X[j]) return X[i] == X[k];\n        if (Y[i] == Y[j]) return Y[i] == Y[k];\n        if (X[i] == X[k]) return X[i] == X[j];\n        if (Y[i] == Y[k]) return Y[i] == Y[j];\n        return (Y[k] - Y[i]) * (X[j] - X[i]) == (Y[j] - Y[i]) * (X[k] - X[i]);\n    }\n \n    const long MOD = 998244353;\n    auto used = new bool[][](N, N);\n    long ans = 1 + N;\n \n \n    foreach (i; 0..N) {\n        foreach (j; i+1..N) {\n            if (used[i][j])\n                continue;\n            \n            long cnt = 2;\n            int[] v = [i, j];\n \n            foreach (k; j+1..N) {\n                if (used[i][k] || !line(i, j, k))\n                    continue;\n                cnt += 1;\n                v ~= k;\n            }\n \n            foreach (a; 0..v.length)\n                foreach (b; a+1..v.length)\n                    used[v[a]][v[b]] = true;\n \n            ans += powmod(2, cnt, MOD) - cnt - 1;\n            ans %= MOD;\n        }\n    }\n \n    ans = powmod(2, N, MOD) - ans;\n    ans = (ans % MOD + MOD) % MOD;\n    ans.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm, std.container, std.conv, std.math, std.range, std.typecons, std.stdio, std.string;\nimport std.numeric;\n\nauto rdsp(){return readln.splitter;}\nvoid pick(R,T)(ref R r,ref T t){t=r.front.to!T;r.popFront;}\nvoid readV(T...)(ref T t){auto r=rdsp;foreach(ref v;t)pick(r,v);}\nvoid readC(T...)(size_t n,ref T t){foreach(ref v;t)v=new typeof(v)(n);foreach(i;0..n){auto r=rdsp;foreach(ref v;t)pick(r,v[i]);}}\n\nconst mod = 998244353;\nalias mint = FactorRing!mod;\n\nvoid main()\n{\n  int n; readV(n);\n  int[] x, y; readC(n, x, y);\n\n  int[][] l;\n  foreach (i; 0..n)\n    foreach (j; i+1..n)\n      l ~= line(x[i], y[i], x[j], y[j]);\n\n  auto ans = mint(2).repeatedSquare(n) - n*(n-1)/2 - n - 1;\n  foreach (li; l.sort.uniq) {\n    auto k = 0;\n    foreach (i; 0..n)\n      if (li[0]*x[i]+li[1]*y[i]+li[2] == 0) ++k;\n    if (k >= 3)\n      ans -= mint(2).repeatedSquare(k) - k*(k-1)/2 - k - 1;\n  }\n\n  writeln(ans);\n}\n\nauto line(int x1, int y1, int x2, int y2)\n{\n  auto a = y2-y1, b = x1-x2, c = (y1-y2)*x1+(x2-x1)*y1;\n  if (a < 0) {\n    a = -a; b = -b; c = -c;\n  }\n  auto g = a.gcd(b.abs).gcd(c.abs);\n  a /= g; b /= g; c /= g;\n\n  return [a, b, c];\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n)\n{\n  return repeatedSquare!(pred, T, U)(a, n, T(1));\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n, T init)\n{\n  import std.functional;\n  alias predFun = binaryFun!pred;\n\n  if (n == 0) return init;\n\n  auto r = init;\n  while (n > 0) {\n    if (n&1) r = predFun(r, a);\n    a = predFun(a, a);\n    n >>= 1;\n  }\n\n  return r;\n}\n\nstruct FactorRing(int m, bool pos = false)\n{\n  version(BigEndian) union { long vl; struct { int vi2; int vi; } } else union { long vl; int vi; }\n  alias FR = FactorRing!(m, pos);\n  @property static init() { return FR(0); }\n  @property int value() { return vi; }\n  @property void value(int v) { vi = mod(v); }\n  alias value this;\n\n  this(int v) { vi = v; }\n  this(int v, bool runMod) { vi = runMod ? mod(v) : v; }\n  this(long v) { vi = mod(v); }\n\n  ref auto opAssign(int v) { vi = v; return this; }\n\n  pure auto mod(int v) const { static if (pos) return v%m; else return (v%m+m)%m; }\n  pure auto mod(long v) const { static if (pos) return cast(int)(v%m); else return cast(int)((v%m+m)%m); }\n\n  static if (!pos) pure ref auto opUnary(string op: \"-\")() { return FR(mod(-vi)); }\n\n  static if (m < int.max / 2) {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vi\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vi\"~op~\"r\")); return this; }\n  } else {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vl\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vl\"~op~\"r\")); return this; }\n  }\n  pure ref auto opBinary(string op: \"*\")(int r) { return FR(mod(vl*r)); }\n  ref auto opOpAssign(string op: \"*\")(int r) { vi = mod(vl*r); return this; }\n\n  pure ref auto opBinary(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opBinary!op(r.vi); }\n  ref auto opOpAssign(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opOpAssign!op(r.vi); }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\n\nlong powmod(long a, long x, long m) {\n    long ret = 1;\n    while (x) {\n        if (x % 2) ret = ret * a % m;\n        a = a * a % m;\n        x /= 2;\n    }\n    return ret;\n}\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto X = new long[](N);\n    auto Y = new long[](N);\n    foreach (i; 0..N) {\n        auto s = readln.split.map!(to!long);\n        X[i] = s[0];\n        Y[i] = s[1];\n    }\n\n    bool line(int i, int j, int k) {\n        if (X[i] == X[j]) return X[i] == X[k];\n        if (Y[i] == Y[j]) return Y[i] == Y[k];\n        return (Y[k] - Y[i]) * (X[j] - X[i]) == (Y[j] - Y[i]) * (X[k] - X[i]);\n    }\n\n    const long MOD = 998244353;\n    auto used = new bool[][](N, N);\n    long ans = 1 + N;\n\n\n    foreach (i; 0..N) {\n        foreach (j; i+1..N) {\n            if (used[i][j])\n                continue;\n            long cnt = 2;\n            int[] v = [i, j];\n\n            foreach (k; j+1..N) {\n                if (used[i][k] || !line(i, j, k))\n                    continue;\n                cnt += 1;\n                v ~= k;\n            }\n\n            foreach (a; 0..v.length)\n                foreach (b; a+1..v.length)\n                    used[a][b] = true;\n\n            ans += powmod(2, cnt, MOD) - cnt - 1;\n            ans %= MOD;\n        }\n    }\n\n    ans = powmod(2, N, MOD) - ans;\n    ans = (ans % MOD + MOD) % MOD;\n    ans.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner, dcomp.numeric.primitive;\n// import dcomp.modint, dcomp.geo;\n\nalias Mint = ModInt!998244353;\nalias P = Point2D!int;\n\nimport std.typecons;\n\nMint[] fact, iFac;\nstatic this() {\n    fact = factTable!Mint(10000);\n    iFac = invFactTable!Mint(10000);\n}\nMint C(int n, int k) {\n    if (n < 0 || n < k) return Mint(0);\n    return Mint(0);\n}\nMint choose3(int n) {\n    if (n <= 2) return Mint(0);\n    Mint sm = pow(Mint(2), n);\n    sm -= Mint(n * (n-1) / 2);\n    sm -= Mint(n);\n    sm -= Mint(1);\n    return sm;\n}\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    P[] p = new P[n];\n    foreach (i; 0..n) {\n        sc.read(p[i].x, p[i].y);\n    }\n    Mint res = choose3(n);\n\n    bool[][] g = new bool[][](n, n);\n    foreach (i; 0..n) {\n        foreach (j; i+1..n) {\n            if (g[i][j]) continue;\n            int[] v = [i, j];\n            foreach (k; 0..n) {\n                if (i == k || j == k) continue;\n                if (cross(p[j]-p[i], p[k]-p[i]) == 0) {\n                    v ~= k;\n                }\n            }\n            res -= choose3(v.length.to!int);\n            foreach (d; v) {\n                foreach (e; v) {\n                    g[d][e] = g[e][d] = true;\n                }\n            }\n        }\n    }\n    writeln(res);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/geo.d */\n// module dcomp.geo;\n\nimport std.traits;\n\nstruct Point2D(T) {\n    T[2] d;\n    this(T x, T y) {this.d = [x, y];}\n    this(T[2] d) {this.d = d;}\n    @property ref inout(T) x() inout {return d[0];}\n    @property ref inout(T) y() inout {return d[1];}\n    ref inout(T) opIndex(size_t i) inout {return d[i];}\n    auto opBinary(string op:\"+\")(Point2D r) const {return Point2D(x+r.x, y+r.y);}\n    auto opBinary(string op:\"-\")(Point2D r) const {return Point2D(x-r.x, y-r.y);}\n    static if (isFloatingPoint!T) {\n        T abs() {\n            import std.math : sqrt;\n            return (x*x+y*y).sqrt;\n        }\n        T arg() {\n            import std.math : atan2;\n            return atan2(y, x);\n        }\n    }\n}\n\nT dot(T)(in Point2D!T l, in Point2D!T r) {\n    return l[0]*l[0] + l[1]*r[1];\n}\n\nT cross(T)(in Point2D!T l, in Point2D!T r) {\n    return l[0]*r[1] - l[1]*r[0];\n}\n\n \n\n \n \nint argcmp(T)(Point2D!T l, Point2D!T r) if (isIntegral!T) {\n    int sgn(Point2D!T p) {\n        if (p[1] < 0) return -1;\n        if (p[1] > 0) return 1;\n        if (p[0] < 0) return 2;\n        return 0;\n    }\n    int lsgn = sgn(l);\n    int rsgn = sgn(r);\n    if (lsgn < rsgn) return -1;\n    if (lsgn > rsgn) return 1;\n\n    T x = cross(l, r);\n    if (x > 0) return -1;\n    if (x < 0) return 1;\n\n    return 0;\n}\n\n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\nimport std.bigint;\n\n \nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nT pow(T, U)(T x, U n, T e) if (isIntegral!U || is(U == BigInt)) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\n \n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.concurrency;\nimport std.traits;\nimport std.uni;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nenum long INF = long.max/3;\nenum long MOD = 10L^^9+7;\n\nstruct P {\n    long x, y;\n}\nstruct L {\n    // ax + by + c = 0\n    long a, b, c;\n    this(long a, long b, long c) {\n        if (a<0 || (a==0&&b<0)) {\n            a *= -1;\n            b *= -1;\n            c *= -1;\n        }\n        long d = [a, b, c].map!abs.filter!\"a>0\".reduce!gcd;\n        a /= d;\n        b /= d;\n        c /= d;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n}\nvoid main() {\n    long N;\n    scanln(N);\n    P[] ps = N.rep!({\n        long x, y;\n        scanln(x, y);\n        return P(x, y);\n    });\n\n    long[L] aa;\n    foreach(i; 0..N) foreach(j; 0..i) {\n        P p = ps[i];\n        P q = ps[j];\n        aa[L(q.y-p.y, -(q.x-p.x), -p.x*q.y+p.y*q.x)]++;\n    }\n\n    ModNum ans = ModNum(2)^^N;\n    ans -= 1+N;\n    long[long] factInv; // factInv[n]! == n\n    long f(long n) {\n        long res = n==0 ? 1 : n*f(n-1);\n        factInv[res] = n;\n        return res;\n    }\n    f(N+1);\n    foreach(k, v; aa) {\n        ans -= ModNum(2)^^(factInv[v] + 1) - (factInv[v] + 1) - 1;\n    }\n    ans.writeln;\n}\n\nalias ModNum = ModNumber!(long, MOD);\n\nstruct ModNumber(T, T mod) if (__traits(isIntegral, T)) {\n    private enum FACT_MAX = 1000000;\n\n    T value;\n    this(T value) {\n        this.value = value;\n        this.value %= mod;\n        this.value += mod;\n        this.value %= mod;\n    }\n\n    ModNumber opAssign(T value) {\n        this.value = value;\n        return this;\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(this.value \"~op~\" that.value + mod) % mod\"));\n    }\n    ModNumber opBinary(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(this.value \"~op~\" that + mod) % mod\"));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(that \"~op~\" this.value + mod) % mod\"));\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op == \"/\") {\n        return this*getReciprocal(that);\n    }\n    ModNumber opBinary(string op)(T that) if (op == \"/\") {\n        return this*getReciprocal(ModNumber(that));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op == \"/\") {\n        return ModNumber(that)*getReciprocal(this);\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op == \"^^\") {\n        return ModNumber(modPow(this.value, that.value));\n    }\n    ModNumber opBinary(string op)(T that) if (op == \"^^\") {\n        return ModNumber(modPow(this.value, that));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op == \"^^\") {\n        return ModNumber(modPow(that, this.value));\n    }\n\n    void opOpAssign(string op)(ModNumber that) if (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\") {\n        this = mixin(\"this\" ~op~ \"that\");\n    }\n    void opOpAssign(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\") {\n        this = mixin(\"this\" ~op~ \"that\");\n    }\n\n    ModNumber getReciprocal(ModNumber x) in {\n        debug assert(isPrime(mod));\n    } body {\n        return ModNumber(modPow(x.value, mod-2));\n    }\n    T modPow(T base, T power)  {\n        T result = 1;\n        for (; power > 0; power >>= 1) {\n            if (power & 1) {\n                result = (result * base) % mod;\n            }\n            base = base*base % mod;\n        }\n        return result;\n    }\n\n    static bool isPrime(T n) {\n        if (n<2) {\n            return false;\n        } else if (n==2) {\n            return true;\n        } else if (n%2==0) {\n            return false;\n        } else {\n            for(T i=3; i*i<=n; i+=2) {\n                if (n%i==0) return false;\n            }\n            return true;\n        }\n    }\n\n    // n! : 階乗\n    static ModNumber fact(T n) {\n        assert(0<=n && n<=FACT_MAX);\n        static ModNumber[] memo;\n        if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n        if (memo[n] != ModNumber.init) {\n            return memo[n];\n        } else {\n            return memo[n] = n==0 ? ModNumber(1) : n*fact(n-1);\n        }\n    }\n\n    // 1/(n!) : 階乗の逆元 (逆元テーブルを用いる)\n    static ModNumber invFact(T n) {\n        assert(0<=n && n<=FACT_MAX);\n        static ModNumber inverse(T n) {\n            assert(1<=n && n<=FACT_MAX);\n            static ModNumber[] memo;\n            if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n            if (memo[n] != ModNumber.init) {\n                return memo[n];\n            } else {\n                return memo[n] = n==1 ? ModNumber(1) : ModNumber(-mod/n)*inverse(mod%n);\n            }\n        }\n        static ModNumber[] memo;\n        if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n        if (memo[n] != ModNumber.init) {\n            return memo[n];\n        } else {\n            return memo[n] = n==0 ? ModNumber(1) : inverse(n)*invFact(n-1);\n        }\n    }\n\n    // {}_n C_r: 組合せ\n    static ModNumber comb(T n, T r) {\n        import std.functional : memoize;\n        if (r<0 || r>n) return ModNumber(0);\n        if (r*2 > n) return comb(n, n-r);\n\n        if (n<=FACT_MAX) {\n            return fact(n) * invFact(r) * invFact(n-r); // 逆元テーブルを使用する\n            // return fact(n) / fact(r) / fact(n-r); // 逆元テーブルを使用しない\n        }\n\n        ModNum mul(T l, T r) {\n            return l>r ? ModNumber(1) : l * memoize!mul(l+1, r);\n        }\n        return memoize!mul(n-r+1, n) / memoize!mul(1, r);\n    }\n\n    // {}_n H_r: 重複組合せ (Homogeneous Combination)\n    static ModNumber hComb(T n, T r) {\n        return comb(n+r-1, r);\n    }\n\n    string toString() {\n        import std.conv;\n        return this.value.to!string;\n    }\n\n    invariant {\n        assert(this.value>=0);\n        assert(this.value<mod);\n    }\n}\n\n\n// ----------------------------------------------\n\nmixin template Constructor() {\n    import std.traits : FieldNameTuple;\n    this(Args...)(Args args) {\n        // static foreach(i, v; args) {\n        foreach(i, v; args) {\n            mixin(\"this.\" ~ FieldNameTuple!(typeof(this))[i]) = v;\n        }\n    }\n}\n\nvoid scanln(Args...)(auto ref Args args) {\n    import std.meta;\n    template getFormat(T) {\n        static if (isIntegral!T) {\n            enum getFormat = \"%d\";\n        } else static if (isFloatingPoint!T) {\n            enum getFormat = \"%g\";\n        } else static if (isSomeString!T || isSomeChar!T) {\n            enum getFormat = \"%s\";\n        } else {\n            static assert(false);\n        }\n    }\n    enum string str = [staticMap!(getFormat, Args)].join(\" \") ~ \"\\n\";\n    // readf!str(args);\n    mixin(\"str.readf(\" ~ Args.length.iota.map!(i => \"&args[%d]\".format(i)).join(\", \") ~ \");\");\n}\n\nvoid times(alias fun)(long n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(long n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\nT ceil(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n    // `(x+y-1)/y` will only work for positive numbers ...\n    T t = x / y;\n    if (t * y < x) t++;\n    return t;\n}\n\nT floor(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n    T t = x / y;\n    if (t * y > x) t--;\n    return t;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    private auto extremum(alias map, alias selector = \"a < b\", Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range &&\n        is(typeof(unaryFun!map(ElementType!(Range).init))))\n    in\n    {\n        assert(!r.empty, \"r is an empty range\");\n    }\n    body\n    {\n        alias Element = ElementType!Range;\n        Unqual!Element seed = r.front;\n        r.popFront();\n        return extremum!(map, selector)(r, seed);\n    }\n\n    private auto extremum(alias map, alias selector = \"a < b\", Range,\n                          RangeElementType = ElementType!Range)\n                         (Range r, RangeElementType seedElement)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n         is(typeof(unaryFun!map(ElementType!(Range).init))))\n    {\n        alias mapFun = unaryFun!map;\n        alias selectorFun = binaryFun!selector;\n\n        alias Element = ElementType!Range;\n        alias CommonElement = CommonType!(Element, RangeElementType);\n        Unqual!CommonElement extremeElement = seedElement;\n\n        alias MapType = Unqual!(typeof(mapFun(CommonElement.init)));\n        MapType extremeElementMapped = mapFun(extremeElement);\n\n        // direct access via a random access range is faster\n        static if (isRandomAccessRange!Range)\n        {\n            foreach (const i; 0 .. r.length)\n            {\n                MapType mapElement = mapFun(r[i]);\n                if (selectorFun(mapElement, extremeElementMapped))\n                {\n                    extremeElement = r[i];\n                    extremeElementMapped = mapElement;\n                }\n            }\n        }\n        else\n        {\n            while (!r.empty)\n            {\n                MapType mapElement = mapFun(r.front);\n                if (selectorFun(mapElement, extremeElementMapped))\n                {\n                    extremeElement = r.front;\n                    extremeElementMapped = mapElement;\n                }\n                r.popFront();\n            }\n        }\n        return extremeElement;\n    }\n    private auto extremum(alias selector = \"a < b\", Range)(Range r)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n    {\n        alias Element = ElementType!Range;\n        Unqual!Element seed = r.front;\n        r.popFront();\n        return extremum!selector(r, seed);\n    }\n    private auto extremum(alias selector = \"a < b\", Range,\n                          RangeElementType = ElementType!Range)\n                         (Range r, RangeElementType seedElement)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n            !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n    {\n        alias Element = ElementType!Range;\n        alias CommonElement = CommonType!(Element, RangeElementType);\n        Unqual!CommonElement extremeElement = seedElement;\n        alias selectorFun = binaryFun!selector;\n\n        // direct access via a random access range is faster\n        static if (isRandomAccessRange!Range)\n        {\n            foreach (const i; 0 .. r.length)\n            {\n                if (selectorFun(r[i], extremeElement))\n                {\n                    extremeElement = r[i];\n                }\n            }\n        }\n        else\n        {\n            while (!r.empty)\n            {\n                if (selectorFun(r.front, extremeElement))\n                {\n                    extremeElement = r.front;\n                }\n                r.popFront();\n            }\n        }\n        return extremeElement;\n    }\n    auto minElement(Range)(Range r)\n        if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum(r);\n    }\n    auto minElement(alias map, Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!map(r, seed);\n    }\n    auto minElement(Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum(r, seed);\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum!(map, \"a > b\")(r);\n    }\n    auto maxElement(Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum!`a > b`(r);\n    }\n    auto maxElement(alias map, Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!(map, \"a > b\")(r, seed);\n    }\n    auto maxElement(Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!`a > b`(r, seed);\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.concurrency;\nimport std.traits;\nimport std.uni;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nenum long INF = long.max/3;\nenum long MOD = 10L^^9+7;\n\nstruct P {\n    long x, y;\n}\nstruct L {\n    // ax + by + c = 0\n    long a, b, c;\n    this(long a, long b, long c) {\n        if (a<0 || (a==0&&b<0)) {\n            a *= -1;\n            b *= -1;\n            c *= -1;\n        }\n        long d = [a, b, c].filter!\"a>0\".reduce!gcd;\n        a /= d;\n        b /= d;\n        c /= d;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    // size_t toHash() const @safe pure nothrow {\n    //     return 0;\n    //     size_t hash = a.hashOf();\n    //     hash = b.hashOf(hash);\n    //     hash = c.hashOf(hash);\n    //     return hash;\n    // }\n    // bool opEquals(ref const L that) const @safe pure nothrow {\n    //     return this.a==that.b && this.b==that.b && this.c==that.c;\n    // }\n}\nvoid main() {\n    long N;\n    scanln(N);\n    P[] ps = N.rep!({\n        long x, y;\n        scanln(x, y);\n        return P(x, y);\n    });\n\n    long[L] aa;\n    foreach(i; 0..N) foreach(j; 0..i) {\n        P p = ps[i];\n        P q = ps[j];\n        aa[L(q.y-p.y, -(q.x-p.x), -p.x*q.y+p.y*q.x)]++;\n    }\n\n    ModNum ans = ModNum(2)^^N;\n    ans -= 1+N;\n    long[long] factInv; // factInv[n]! == n\n    long f(long n) {\n        long res = n==0 ? 1 : n*f(n-1);\n        factInv[res] = n;\n        return res;\n    }\n    f(N);\n    foreach(k, v; aa) {\n        ans -= ModNum(2)^^(factInv[v] + 1) - (factInv[v] + 1) - 1;\n    }\n    ans.writeln;\n}\n\nalias ModNum = ModNumber!(long, MOD);\n\nstruct ModNumber(T, T mod) if (__traits(isIntegral, T)) {\n    private enum FACT_MAX = 1000000;\n\n    T value;\n    this(T value) {\n        this.value = value;\n        this.value %= mod;\n        this.value += mod;\n        this.value %= mod;\n    }\n\n    ModNumber opAssign(T value) {\n        this.value = value;\n        return this;\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(this.value \"~op~\" that.value + mod) % mod\"));\n    }\n    ModNumber opBinary(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(this.value \"~op~\" that + mod) % mod\"));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(that \"~op~\" this.value + mod) % mod\"));\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op == \"/\") {\n        return this*getReciprocal(that);\n    }\n    ModNumber opBinary(string op)(T that) if (op == \"/\") {\n        return this*getReciprocal(ModNumber(that));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op == \"/\") {\n        return ModNumber(that)*getReciprocal(this);\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op == \"^^\") {\n        return ModNumber(modPow(this.value, that.value));\n    }\n    ModNumber opBinary(string op)(T that) if (op == \"^^\") {\n        return ModNumber(modPow(this.value, that));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op == \"^^\") {\n        return ModNumber(modPow(that, this.value));\n    }\n\n    void opOpAssign(string op)(ModNumber that) if (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\") {\n        this = mixin(\"this\" ~op~ \"that\");\n    }\n    void opOpAssign(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\") {\n        this = mixin(\"this\" ~op~ \"that\");\n    }\n\n    ModNumber getReciprocal(ModNumber x) in {\n        debug assert(isPrime(mod));\n    } body {\n        return ModNumber(modPow(x.value, mod-2));\n    }\n    T modPow(T base, T power)  {\n        T result = 1;\n        for (; power > 0; power >>= 1) {\n            if (power & 1) {\n                result = (result * base) % mod;\n            }\n            base = base*base % mod;\n        }\n        return result;\n    }\n\n    static bool isPrime(T n) {\n        if (n<2) {\n            return false;\n        } else if (n==2) {\n            return true;\n        } else if (n%2==0) {\n            return false;\n        } else {\n            for(T i=3; i*i<=n; i+=2) {\n                if (n%i==0) return false;\n            }\n            return true;\n        }\n    }\n\n    // n! : 階乗\n    static ModNumber fact(T n) {\n        assert(0<=n && n<=FACT_MAX);\n        static ModNumber[] memo;\n        if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n        if (memo[n] != ModNumber.init) {\n            return memo[n];\n        } else {\n            return memo[n] = n==0 ? ModNumber(1) : n*fact(n-1);\n        }\n    }\n\n    // 1/(n!) : 階乗の逆元 (逆元テーブルを用いる)\n    static ModNumber invFact(T n) {\n        assert(0<=n && n<=FACT_MAX);\n        static ModNumber inverse(T n) {\n            assert(1<=n && n<=FACT_MAX);\n            static ModNumber[] memo;\n            if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n            if (memo[n] != ModNumber.init) {\n                return memo[n];\n            } else {\n                return memo[n] = n==1 ? ModNumber(1) : ModNumber(-mod/n)*inverse(mod%n);\n            }\n        }\n        static ModNumber[] memo;\n        if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n        if (memo[n] != ModNumber.init) {\n            return memo[n];\n        } else {\n            return memo[n] = n==0 ? ModNumber(1) : inverse(n)*invFact(n-1);\n        }\n    }\n\n    // {}_n C_r: 組合せ\n    static ModNumber comb(T n, T r) {\n        import std.functional : memoize;\n        if (r<0 || r>n) return ModNumber(0);\n        if (r*2 > n) return comb(n, n-r);\n\n        if (n<=FACT_MAX) {\n            return fact(n) * invFact(r) * invFact(n-r); // 逆元テーブルを使用する\n            // return fact(n) / fact(r) / fact(n-r); // 逆元テーブルを使用しない\n        }\n\n        ModNum mul(T l, T r) {\n            return l>r ? ModNumber(1) : l * memoize!mul(l+1, r);\n        }\n        return memoize!mul(n-r+1, n) / memoize!mul(1, r);\n    }\n\n    // {}_n H_r: 重複組合せ (Homogeneous Combination)\n    static ModNumber hComb(T n, T r) {\n        return comb(n+r-1, r);\n    }\n\n    string toString() {\n        import std.conv;\n        return this.value.to!string;\n    }\n\n    invariant {\n        assert(this.value>=0);\n        assert(this.value<mod);\n    }\n}\n\n\n// ----------------------------------------------\n\nmixin template Constructor() {\n    import std.traits : FieldNameTuple;\n    this(Args...)(Args args) {\n        // static foreach(i, v; args) {\n        foreach(i, v; args) {\n            mixin(\"this.\" ~ FieldNameTuple!(typeof(this))[i]) = v;\n        }\n    }\n}\n\nvoid scanln(Args...)(auto ref Args args) {\n    import std.meta;\n    template getFormat(T) {\n        static if (isIntegral!T) {\n            enum getFormat = \"%d\";\n        } else static if (isFloatingPoint!T) {\n            enum getFormat = \"%g\";\n        } else static if (isSomeString!T || isSomeChar!T) {\n            enum getFormat = \"%s\";\n        } else {\n            static assert(false);\n        }\n    }\n    enum string str = [staticMap!(getFormat, Args)].join(\" \") ~ \"\\n\";\n    // readf!str(args);\n    mixin(\"str.readf(\" ~ Args.length.iota.map!(i => \"&args[%d]\".format(i)).join(\", \") ~ \");\");\n}\n\nvoid times(alias fun)(long n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(long n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\nT ceil(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n    // `(x+y-1)/y` will only work for positive numbers ...\n    T t = x / y;\n    if (t * y < x) t++;\n    return t;\n}\n\nT floor(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n    T t = x / y;\n    if (t * y > x) t--;\n    return t;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    private auto extremum(alias map, alias selector = \"a < b\", Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range &&\n        is(typeof(unaryFun!map(ElementType!(Range).init))))\n    in\n    {\n        assert(!r.empty, \"r is an empty range\");\n    }\n    body\n    {\n        alias Element = ElementType!Range;\n        Unqual!Element seed = r.front;\n        r.popFront();\n        return extremum!(map, selector)(r, seed);\n    }\n\n    private auto extremum(alias map, alias selector = \"a < b\", Range,\n                          RangeElementType = ElementType!Range)\n                         (Range r, RangeElementType seedElement)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n         is(typeof(unaryFun!map(ElementType!(Range).init))))\n    {\n        alias mapFun = unaryFun!map;\n        alias selectorFun = binaryFun!selector;\n\n        alias Element = ElementType!Range;\n        alias CommonElement = CommonType!(Element, RangeElementType);\n        Unqual!CommonElement extremeElement = seedElement;\n\n        alias MapType = Unqual!(typeof(mapFun(CommonElement.init)));\n        MapType extremeElementMapped = mapFun(extremeElement);\n\n        // direct access via a random access range is faster\n        static if (isRandomAccessRange!Range)\n        {\n            foreach (const i; 0 .. r.length)\n            {\n                MapType mapElement = mapFun(r[i]);\n                if (selectorFun(mapElement, extremeElementMapped))\n                {\n                    extremeElement = r[i];\n                    extremeElementMapped = mapElement;\n                }\n            }\n        }\n        else\n        {\n            while (!r.empty)\n            {\n                MapType mapElement = mapFun(r.front);\n                if (selectorFun(mapElement, extremeElementMapped))\n                {\n                    extremeElement = r.front;\n                    extremeElementMapped = mapElement;\n                }\n                r.popFront();\n            }\n        }\n        return extremeElement;\n    }\n    private auto extremum(alias selector = \"a < b\", Range)(Range r)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n    {\n        alias Element = ElementType!Range;\n        Unqual!Element seed = r.front;\n        r.popFront();\n        return extremum!selector(r, seed);\n    }\n    private auto extremum(alias selector = \"a < b\", Range,\n                          RangeElementType = ElementType!Range)\n                         (Range r, RangeElementType seedElement)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n            !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n    {\n        alias Element = ElementType!Range;\n        alias CommonElement = CommonType!(Element, RangeElementType);\n        Unqual!CommonElement extremeElement = seedElement;\n        alias selectorFun = binaryFun!selector;\n\n        // direct access via a random access range is faster\n        static if (isRandomAccessRange!Range)\n        {\n            foreach (const i; 0 .. r.length)\n            {\n                if (selectorFun(r[i], extremeElement))\n                {\n                    extremeElement = r[i];\n                }\n            }\n        }\n        else\n        {\n            while (!r.empty)\n            {\n                if (selectorFun(r.front, extremeElement))\n                {\n                    extremeElement = r.front;\n                }\n                r.popFront();\n            }\n        }\n        return extremeElement;\n    }\n    auto minElement(Range)(Range r)\n        if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum(r);\n    }\n    auto minElement(alias map, Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!map(r, seed);\n    }\n    auto minElement(Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum(r, seed);\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum!(map, \"a > b\")(r);\n    }\n    auto maxElement(Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum!`a > b`(r);\n    }\n    auto maxElement(alias map, Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!(map, \"a > b\")(r, seed);\n    }\n    auto maxElement(Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!`a > b`(r, seed);\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\n\nstruct Fraction {\n    long a;\n    long b;\n\n    this(long x, long y) {\n        a = x / gcd(x, y);\n        b = y / gcd(x, y);\n    }\n}\n\nlong powmod(long a, long x, long m) {\n    long ret = 1;\n    while (x) {\n        if (x % 2) ret = ret * a % m;\n        a = a * a % m;\n        x /= 2;\n    }\n    return ret;\n}\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto X = new long[](N);\n    auto Y = new long[](N);\n    foreach (i; 0..N) {\n        auto s = readln.split.map!(to!long);\n        X[i] = s[0];\n        Y[i] = s[1];\n    }\n\n    bool line(int i, int j, int k) {\n        return (Y[k] - Y[i]) * (X[j] - X[i]) == (Y[j] - Y[i]) * (X[k] - X[i]);\n    }\n\n    const long MOD = 998244353;\n    auto used = new bool[][](N, N);\n    long ans = 1 + N;\n\n\n    foreach (i; 0..N) {\n        foreach (j; i+1..N) {\n            if (used[i][j])\n                continue;\n            used[i][j] = true;\n            long cnt = 2;\n\n            foreach (k; j+1..N) {\n                if (used[i][k] || used[j][k] || !line(i, j, k))\n                    continue;\n                used[i][k] = used[j][k] = true;\n                cnt += 1;\n            }\n\n            ans += powmod(2, cnt, MOD) - cnt - 1;\n            ans %= MOD;\n        }\n    }\n\n    ans = powmod(2, N, MOD) - ans;\n    ans = (ans % MOD + MOD) % MOD;\n    ans.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\n\nlong powmod(long a, long x, long m) {\n    long ret = 1;\n    while (x) {\n        if (x % 2) ret = ret * a % m;\n        a = a * a % m;\n        x /= 2;\n    }\n    return ret;\n}\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto X = new long[](N);\n    auto Y = new long[](N);\n    foreach (i; 0..N) {\n        auto s = readln.split.map!(to!long);\n        X[i] = s[0];\n        Y[i] = s[1];\n    }\n\n    bool line(int i, int j, int k) {\n        if (X[i] == X[j]) return X[i] == X[k];\n        if (Y[i] == Y[j]) return Y[i] == Y[k];\n        if (X[i] == X[k]) return X[i] == X[j];\n        if (Y[i] == Y[k]) return Y[i] == Y[j];\n        return (Y[k] - Y[i]) * (X[j] - X[i]) == (Y[j] - Y[i]) * (X[k] - X[i]);\n    }\n\n    const long MOD = 998244353;\n    auto used = new bool[][](N, N);\n    long ans = 1 + N;\n\n\n    foreach (i; 0..N) {\n        foreach (j; i+1..N) {\n            if (used[i][j])\n                continue;\n            long cnt = 2;\n            int[] v = [i, j];\n\n            foreach (k; j+1..N) {\n                if (used[i][k] || !line(i, j, k))\n                    continue;\n                cnt += 1;\n                v ~= k;\n            }\n\n            foreach (a; 0..v.length)\n                foreach (b; a+1..v.length)\n                    used[a][b] = true;\n\n            ans += powmod(2, cnt, MOD) - cnt - 1;\n            ans %= MOD;\n        }\n    }\n\n    ans = powmod(2, N, MOD) - ans;\n    ans = (ans % MOD + MOD) % MOD;\n    ans.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm, std.container, std.conv, std.math, std.range, std.typecons, std.stdio, std.string;\nimport std.numeric;\n\nauto rdsp(){return readln.splitter;}\nvoid pick(R,T)(ref R r,ref T t){t=r.front.to!T;r.popFront;}\nvoid readV(T...)(ref T t){auto r=rdsp;foreach(ref v;t)pick(r,v);}\nvoid readC(T...)(size_t n,ref T t){foreach(ref v;t)v=new typeof(v)(n);foreach(i;0..n){auto r=rdsp;foreach(ref v;t)pick(r,v[i]);}}\n\nconst mod = 998244353;\nalias mint = FactorRing!mod;\nalias Line = Tuple!(int, \"a\", int, \"b\", int, \"c\");\n\nvoid main()\n{\n  int n; readV(n);\n  int[] x, y; readC(n, x, y);\n\n  bool[Line] h;\n  foreach (i; 0..n)\n    foreach (j; i+1..n) {\n      h[line(x[i], y[i], x[j], y[j])] = true;\n    }\n\n  auto ans = mint(2).repeatedSquare(n) - n*(n-1)/2 - n - 1;\n  foreach (li; h.byKey) {\n    auto k = 0;\n    foreach (i; 0..n)\n      if (li.a*x[i]+li.b*y[i]+li.c == 0) ++k;\n    if (k >= 3)\n      ans -= mint(2).repeatedSquare(k) - k*(k-1)/2 - k - 1;\n  }\n\n  writeln(ans);\n}\n\nauto line(int x1, int y1, int x2, int y2)\n{\n  auto a = y2-y1, b = x1-x2, c = (y1-y2)*x1+(x2-x1)*y1;\n  if (a < 0) {\n    a = -a; b = -b; c = -c;\n  }\n  auto g = a.gcd(b.abs).gcd(c.abs);\n  a /= g; b /= g; c /= g;\n\n  return Line(a, b, c);\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n)\n{\n  return repeatedSquare!(pred, T, U)(a, n, T(1));\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n, T init)\n{\n  import std.functional;\n  alias predFun = binaryFun!pred;\n\n  if (n == 0) return init;\n\n  auto r = init;\n  while (n > 0) {\n    if (n&1) r = predFun(r, a);\n    a = predFun(a, a);\n    n >>= 1;\n  }\n\n  return r;\n}\n\nstruct FactorRing(int m, bool pos = false)\n{\n  version(BigEndian) union { long vl; struct { int vi2; int vi; } } else union { long vl; int vi; }\n  alias FR = FactorRing!(m, pos);\n  @property static init() { return FR(0); }\n  @property int value() { return vi; }\n  @property void value(int v) { vi = mod(v); }\n  alias value this;\n\n  this(int v) { vi = v; }\n  this(int v, bool runMod) { vi = runMod ? mod(v) : v; }\n  this(long v) { vi = mod(v); }\n\n  ref auto opAssign(int v) { vi = v; return this; }\n\n  pure auto mod(int v) const { static if (pos) return v%m; else return (v%m+m)%m; }\n  pure auto mod(long v) const { static if (pos) return cast(int)(v%m); else return cast(int)((v%m+m)%m); }\n\n  static if (!pos) pure ref auto opUnary(string op: \"-\")() { return FR(mod(-vi)); }\n\n  static if (m < int.max / 2) {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vi\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vi\"~op~\"r\")); return this; }\n  } else {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vl\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vl\"~op~\"r\")); return this; }\n  }\n  pure ref auto opBinary(string op: \"*\")(int r) { return FR(mod(vl*r)); }\n  ref auto opOpAssign(string op: \"*\")(int r) { vi = mod(vl*r); return this; }\n\n  pure ref auto opBinary(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opBinary!op(r.vi); }\n  ref auto opOpAssign(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opOpAssign!op(r.vi); }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.concurrency;\nimport std.traits;\nimport std.uni;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nenum long INF = long.max/3;\nenum long MOD = 10L^^9+7;\n\nstruct P {\n    long x, y;\n}\nstruct L {\n    // ax + by + c = 0\n    long a, b, c;\n    this(long a, long b, long c) {\n        if (a<0 || (a==0&&b<0)) {\n            a *= -1;\n            b *= -1;\n            c *= -1;\n        }\n        long d = [a, b, c].filter!\"a>0\".reduce!gcd;\n        a /= d;\n        b /= d;\n        c /= d;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n}\nvoid main() {\n    long N;\n    scanln(N);\n    P[] ps = N.rep!({\n        long x, y;\n        scanln(x, y);\n        return P(x, y);\n    });\n\n    long[L] aa;\n    foreach(i; 0..N) foreach(j; 0..i) {\n        P p = ps[i];\n        P q = ps[j];\n        aa[L(q.y-p.y, -(q.x-p.x), -p.x*q.y+p.y*q.x)]++;\n    }\n\n    ModNum ans = ModNum(2)^^N;\n    ans -= 1+N;\n    long[long] factInv; // factInv[n]! == n\n    long f(long n) {\n        long res = n==0 ? 1 : n*f(n-1);\n        factInv[res] = n;\n        return res;\n    }\n    f(N+1);\n    foreach(k, v; aa) {\n        ans -= ModNum(2)^^(factInv[v] + 1) - (factInv[v] + 1) - 1;\n    }\n    ans.writeln;\n}\n\nalias ModNum = ModNumber!(long, MOD);\n\nstruct ModNumber(T, T mod) if (__traits(isIntegral, T)) {\n    private enum FACT_MAX = 1000000;\n\n    T value;\n    this(T value) {\n        this.value = value;\n        this.value %= mod;\n        this.value += mod;\n        this.value %= mod;\n    }\n\n    ModNumber opAssign(T value) {\n        this.value = value;\n        return this;\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(this.value \"~op~\" that.value + mod) % mod\"));\n    }\n    ModNumber opBinary(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(this.value \"~op~\" that + mod) % mod\"));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(that \"~op~\" this.value + mod) % mod\"));\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op == \"/\") {\n        return this*getReciprocal(that);\n    }\n    ModNumber opBinary(string op)(T that) if (op == \"/\") {\n        return this*getReciprocal(ModNumber(that));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op == \"/\") {\n        return ModNumber(that)*getReciprocal(this);\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op == \"^^\") {\n        return ModNumber(modPow(this.value, that.value));\n    }\n    ModNumber opBinary(string op)(T that) if (op == \"^^\") {\n        return ModNumber(modPow(this.value, that));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op == \"^^\") {\n        return ModNumber(modPow(that, this.value));\n    }\n\n    void opOpAssign(string op)(ModNumber that) if (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\") {\n        this = mixin(\"this\" ~op~ \"that\");\n    }\n    void opOpAssign(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\") {\n        this = mixin(\"this\" ~op~ \"that\");\n    }\n\n    ModNumber getReciprocal(ModNumber x) in {\n        debug assert(isPrime(mod));\n    } body {\n        return ModNumber(modPow(x.value, mod-2));\n    }\n    T modPow(T base, T power)  {\n        T result = 1;\n        for (; power > 0; power >>= 1) {\n            if (power & 1) {\n                result = (result * base) % mod;\n            }\n            base = base*base % mod;\n        }\n        return result;\n    }\n\n    static bool isPrime(T n) {\n        if (n<2) {\n            return false;\n        } else if (n==2) {\n            return true;\n        } else if (n%2==0) {\n            return false;\n        } else {\n            for(T i=3; i*i<=n; i+=2) {\n                if (n%i==0) return false;\n            }\n            return true;\n        }\n    }\n\n    // n! : 階乗\n    static ModNumber fact(T n) {\n        assert(0<=n && n<=FACT_MAX);\n        static ModNumber[] memo;\n        if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n        if (memo[n] != ModNumber.init) {\n            return memo[n];\n        } else {\n            return memo[n] = n==0 ? ModNumber(1) : n*fact(n-1);\n        }\n    }\n\n    // 1/(n!) : 階乗の逆元 (逆元テーブルを用いる)\n    static ModNumber invFact(T n) {\n        assert(0<=n && n<=FACT_MAX);\n        static ModNumber inverse(T n) {\n            assert(1<=n && n<=FACT_MAX);\n            static ModNumber[] memo;\n            if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n            if (memo[n] != ModNumber.init) {\n                return memo[n];\n            } else {\n                return memo[n] = n==1 ? ModNumber(1) : ModNumber(-mod/n)*inverse(mod%n);\n            }\n        }\n        static ModNumber[] memo;\n        if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n        if (memo[n] != ModNumber.init) {\n            return memo[n];\n        } else {\n            return memo[n] = n==0 ? ModNumber(1) : inverse(n)*invFact(n-1);\n        }\n    }\n\n    // {}_n C_r: 組合せ\n    static ModNumber comb(T n, T r) {\n        import std.functional : memoize;\n        if (r<0 || r>n) return ModNumber(0);\n        if (r*2 > n) return comb(n, n-r);\n\n        if (n<=FACT_MAX) {\n            return fact(n) * invFact(r) * invFact(n-r); // 逆元テーブルを使用する\n            // return fact(n) / fact(r) / fact(n-r); // 逆元テーブルを使用しない\n        }\n\n        ModNum mul(T l, T r) {\n            return l>r ? ModNumber(1) : l * memoize!mul(l+1, r);\n        }\n        return memoize!mul(n-r+1, n) / memoize!mul(1, r);\n    }\n\n    // {}_n H_r: 重複組合せ (Homogeneous Combination)\n    static ModNumber hComb(T n, T r) {\n        return comb(n+r-1, r);\n    }\n\n    string toString() {\n        import std.conv;\n        return this.value.to!string;\n    }\n\n    invariant {\n        assert(this.value>=0);\n        assert(this.value<mod);\n    }\n}\n\n\n// ----------------------------------------------\n\nmixin template Constructor() {\n    import std.traits : FieldNameTuple;\n    this(Args...)(Args args) {\n        // static foreach(i, v; args) {\n        foreach(i, v; args) {\n            mixin(\"this.\" ~ FieldNameTuple!(typeof(this))[i]) = v;\n        }\n    }\n}\n\nvoid scanln(Args...)(auto ref Args args) {\n    import std.meta;\n    template getFormat(T) {\n        static if (isIntegral!T) {\n            enum getFormat = \"%d\";\n        } else static if (isFloatingPoint!T) {\n            enum getFormat = \"%g\";\n        } else static if (isSomeString!T || isSomeChar!T) {\n            enum getFormat = \"%s\";\n        } else {\n            static assert(false);\n        }\n    }\n    enum string str = [staticMap!(getFormat, Args)].join(\" \") ~ \"\\n\";\n    // readf!str(args);\n    mixin(\"str.readf(\" ~ Args.length.iota.map!(i => \"&args[%d]\".format(i)).join(\", \") ~ \");\");\n}\n\nvoid times(alias fun)(long n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(long n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\nT ceil(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n    // `(x+y-1)/y` will only work for positive numbers ...\n    T t = x / y;\n    if (t * y < x) t++;\n    return t;\n}\n\nT floor(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n    T t = x / y;\n    if (t * y > x) t--;\n    return t;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    private auto extremum(alias map, alias selector = \"a < b\", Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range &&\n        is(typeof(unaryFun!map(ElementType!(Range).init))))\n    in\n    {\n        assert(!r.empty, \"r is an empty range\");\n    }\n    body\n    {\n        alias Element = ElementType!Range;\n        Unqual!Element seed = r.front;\n        r.popFront();\n        return extremum!(map, selector)(r, seed);\n    }\n\n    private auto extremum(alias map, alias selector = \"a < b\", Range,\n                          RangeElementType = ElementType!Range)\n                         (Range r, RangeElementType seedElement)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n         is(typeof(unaryFun!map(ElementType!(Range).init))))\n    {\n        alias mapFun = unaryFun!map;\n        alias selectorFun = binaryFun!selector;\n\n        alias Element = ElementType!Range;\n        alias CommonElement = CommonType!(Element, RangeElementType);\n        Unqual!CommonElement extremeElement = seedElement;\n\n        alias MapType = Unqual!(typeof(mapFun(CommonElement.init)));\n        MapType extremeElementMapped = mapFun(extremeElement);\n\n        // direct access via a random access range is faster\n        static if (isRandomAccessRange!Range)\n        {\n            foreach (const i; 0 .. r.length)\n            {\n                MapType mapElement = mapFun(r[i]);\n                if (selectorFun(mapElement, extremeElementMapped))\n                {\n                    extremeElement = r[i];\n                    extremeElementMapped = mapElement;\n                }\n            }\n        }\n        else\n        {\n            while (!r.empty)\n            {\n                MapType mapElement = mapFun(r.front);\n                if (selectorFun(mapElement, extremeElementMapped))\n                {\n                    extremeElement = r.front;\n                    extremeElementMapped = mapElement;\n                }\n                r.popFront();\n            }\n        }\n        return extremeElement;\n    }\n    private auto extremum(alias selector = \"a < b\", Range)(Range r)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n    {\n        alias Element = ElementType!Range;\n        Unqual!Element seed = r.front;\n        r.popFront();\n        return extremum!selector(r, seed);\n    }\n    private auto extremum(alias selector = \"a < b\", Range,\n                          RangeElementType = ElementType!Range)\n                         (Range r, RangeElementType seedElement)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n            !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n    {\n        alias Element = ElementType!Range;\n        alias CommonElement = CommonType!(Element, RangeElementType);\n        Unqual!CommonElement extremeElement = seedElement;\n        alias selectorFun = binaryFun!selector;\n\n        // direct access via a random access range is faster\n        static if (isRandomAccessRange!Range)\n        {\n            foreach (const i; 0 .. r.length)\n            {\n                if (selectorFun(r[i], extremeElement))\n                {\n                    extremeElement = r[i];\n                }\n            }\n        }\n        else\n        {\n            while (!r.empty)\n            {\n                if (selectorFun(r.front, extremeElement))\n                {\n                    extremeElement = r.front;\n                }\n                r.popFront();\n            }\n        }\n        return extremeElement;\n    }\n    auto minElement(Range)(Range r)\n        if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum(r);\n    }\n    auto minElement(alias map, Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!map(r, seed);\n    }\n    auto minElement(Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum(r, seed);\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum!(map, \"a > b\")(r);\n    }\n    auto maxElement(Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum!`a > b`(r);\n    }\n    auto maxElement(alias map, Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!(map, \"a > b\")(r, seed);\n    }\n    auto maxElement(Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!`a > b`(r, seed);\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm, std.container, std.conv, std.math, std.range, std.typecons, std.stdio, std.string;\nimport std.numeric;\n\nauto rdsp(){return readln.splitter;}\nvoid pick(R,T)(ref R r,ref T t){t=r.front.to!T;r.popFront;}\nvoid readV(T...)(ref T t){auto r=rdsp;foreach(ref v;t)pick(r,v);}\nvoid readC(T...)(size_t n,ref T t){foreach(ref v;t)v=new typeof(v)(n);foreach(i;0..n){auto r=rdsp;foreach(ref v;t)pick(r,v[i]);}}\n\nconst mod = 998244353;\nalias mint = FactorRing!mod;\nalias Line = Tuple!(int, \"a\", int, \"b\", int, \"c\");\n\nvoid main()\n{\n  int n; readV(n);\n  int[] x, y; readC(n, x, y);\n\n  bool[Line] h;\n  foreach (i; 0..n)\n    foreach (j; i+1..n) {\n      h[line(x[i], y[i], x[j], y[j])] = true;\n    }\n\n  auto ans = mint(2).repeatedSquare(n) - mint(n*(n-1)/2+n+1);\n  foreach (li; h.byKey) {\n    auto k = 0;\n    foreach (i; 0..n)\n      if (li.a*x[i]+li.b*y[i]+li.c == 0) ++k;\n    if (k >= 3)\n      ans -= mint(2).repeatedSquare(k) - mint(k*(k-1)/2+k+1);\n  }\n\n  writeln(ans);\n}\n\nauto line(int x1, int y1, int x2, int y2)\n{\n  auto a = y2-y1, b = x1-x2, c = (y1-y2)*x1+(x2-x1)*y1;\n  if (a < 0) {\n    a = -a; b = -b; c = -c;\n  }\n  auto g = a.gcd(b.abs).gcd(c.abs);\n  a /= g; b /= g; c /= g;\n\n  return Line(a, b, c);\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n)\n{\n  return repeatedSquare!(pred, T, U)(a, n, T(1));\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n, T init)\n{\n  import std.functional;\n  alias predFun = binaryFun!pred;\n\n  if (n == 0) return init;\n\n  auto r = init;\n  while (n > 0) {\n    if (n&1) r = predFun(r, a);\n    a = predFun(a, a);\n    n >>= 1;\n  }\n\n  return r;\n}\n\nstruct FactorRing(int m, bool pos = false)\n{\n  version(BigEndian) union { long vl; struct { int vi2; int vi; } } else union { long vl; int vi; }\n  alias FR = FactorRing!(m, pos);\n  @property static init() { return FR(0); }\n  @property int value() { return vi; }\n  @property void value(int v) { vi = mod(v); }\n  alias value this;\n\n  this(int v) { vi = v; }\n  this(int v, bool runMod) { vi = runMod ? mod(v) : v; }\n  this(long v) { vi = mod(v); }\n\n  ref auto opAssign(int v) { vi = v; return this; }\n\n  pure auto mod(int v) const { static if (pos) return v%m; else return (v%m+m)%m; }\n  pure auto mod(long v) const { static if (pos) return cast(int)(v%m); else return cast(int)((v%m+m)%m); }\n\n  static if (!pos) pure ref auto opUnary(string op: \"-\")() { return FR(mod(-vi)); }\n\n  static if (m < int.max / 2) {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vi\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vi\"~op~\"r\")); return this; }\n  } else {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vl\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vl\"~op~\"r\")); return this; }\n  }\n  pure ref auto opBinary(string op: \"*\")(int r) { return FR(mod(vl*r)); }\n  ref auto opOpAssign(string op: \"*\")(int r) { vi = mod(vl*r); return this; }\n\n  pure ref auto opBinary(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opBinary!op(r.vi); }\n  ref auto opOpAssign(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opOpAssign!op(r.vi); }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.concurrency;\nimport std.traits;\nimport std.uni;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nenum long INF = long.max/3;\nenum long MOD = 998244353;\n\nstruct P {\n    long x, y;\n}\nstruct L {\n    // ax + by + c = 0\n    long a, b, c;\n    this(long a, long b, long c) {\n        if (a<0 || (a==0&&b<0)) {\n            a *= -1;\n            b *= -1;\n            c *= -1;\n        }\n        long d = [a, b, c].map!abs.filter!\"a>0\".reduce!gcd;\n        a /= d;\n        b /= d;\n        c /= d;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n}\nvoid main() {\n    long N;\n    scanln(N);\n    P[] ps = N.rep!({\n        long x, y;\n        scanln(x, y);\n        return P(x, y);\n    });\n\n    long[L] aa;\n    foreach(i; 0..N) foreach(j; 0..i) {\n        P p = ps[i];\n        P q = ps[j];\n        aa[L(q.y-p.y, -(q.x-p.x), -p.x*q.y+p.y*q.x)]++;\n    }\n\n    ModNum ans = ModNum(2)^^N;\n    ans -= 1+N;\n    long[long] inv;\n    long f(long n) {\n        long res = n==0 ? 0 : n+f(n-1);\n        inv[res] = n;\n        return res;\n    }\n    f(N+1);\n    foreach(k, v; aa) {\n        ans -= ModNum(2)^^(inv[v] + 1) - (inv[v] + 1) - 1;\n    }\n    ans.writeln;\n}\n\nalias ModNum = ModNumber!(long, MOD);\n\nstruct ModNumber(T, T mod) if (__traits(isIntegral, T)) {\n    private enum FACT_MAX = 1000000;\n\n    T value;\n    this(T value) {\n        this.value = value;\n        this.value %= mod;\n        this.value += mod;\n        this.value %= mod;\n    }\n\n    ModNumber opAssign(T value) {\n        this.value = value;\n        return this;\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(this.value \"~op~\" that.value + mod) % mod\"));\n    }\n    ModNumber opBinary(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(this.value \"~op~\" that + mod) % mod\"));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(that \"~op~\" this.value + mod) % mod\"));\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op == \"/\") {\n        return this*getReciprocal(that);\n    }\n    ModNumber opBinary(string op)(T that) if (op == \"/\") {\n        return this*getReciprocal(ModNumber(that));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op == \"/\") {\n        return ModNumber(that)*getReciprocal(this);\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op == \"^^\") {\n        return ModNumber(modPow(this.value, that.value));\n    }\n    ModNumber opBinary(string op)(T that) if (op == \"^^\") {\n        return ModNumber(modPow(this.value, that));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op == \"^^\") {\n        return ModNumber(modPow(that, this.value));\n    }\n\n    void opOpAssign(string op)(ModNumber that) if (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\") {\n        this = mixin(\"this\" ~op~ \"that\");\n    }\n    void opOpAssign(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\") {\n        this = mixin(\"this\" ~op~ \"that\");\n    }\n\n    ModNumber getReciprocal(ModNumber x) in {\n        debug assert(isPrime(mod));\n    } body {\n        return ModNumber(modPow(x.value, mod-2));\n    }\n    T modPow(T base, T power)  {\n        T result = 1;\n        for (; power > 0; power >>= 1) {\n            if (power & 1) {\n                result = (result * base) % mod;\n            }\n            base = base*base % mod;\n        }\n        return result;\n    }\n\n    static bool isPrime(T n) {\n        if (n<2) {\n            return false;\n        } else if (n==2) {\n            return true;\n        } else if (n%2==0) {\n            return false;\n        } else {\n            for(T i=3; i*i<=n; i+=2) {\n                if (n%i==0) return false;\n            }\n            return true;\n        }\n    }\n\n    // n! : 階乗\n    static ModNumber fact(T n) {\n        assert(0<=n && n<=FACT_MAX);\n        static ModNumber[] memo;\n        if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n        if (memo[n] != ModNumber.init) {\n            return memo[n];\n        } else {\n            return memo[n] = n==0 ? ModNumber(1) : n*fact(n-1);\n        }\n    }\n\n    // 1/(n!) : 階乗の逆元 (逆元テーブルを用いる)\n    static ModNumber invFact(T n) {\n        assert(0<=n && n<=FACT_MAX);\n        static ModNumber inverse(T n) {\n            assert(1<=n && n<=FACT_MAX);\n            static ModNumber[] memo;\n            if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n            if (memo[n] != ModNumber.init) {\n                return memo[n];\n            } else {\n                return memo[n] = n==1 ? ModNumber(1) : ModNumber(-mod/n)*inverse(mod%n);\n            }\n        }\n        static ModNumber[] memo;\n        if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n        if (memo[n] != ModNumber.init) {\n            return memo[n];\n        } else {\n            return memo[n] = n==0 ? ModNumber(1) : inverse(n)*invFact(n-1);\n        }\n    }\n\n    // {}_n C_r: 組合せ\n    static ModNumber comb(T n, T r) {\n        import std.functional : memoize;\n        if (r<0 || r>n) return ModNumber(0);\n        if (r*2 > n) return comb(n, n-r);\n\n        if (n<=FACT_MAX) {\n            return fact(n) * invFact(r) * invFact(n-r); // 逆元テーブルを使用する\n            // return fact(n) / fact(r) / fact(n-r); // 逆元テーブルを使用しない\n        }\n\n        ModNum mul(T l, T r) {\n            return l>r ? ModNumber(1) : l * memoize!mul(l+1, r);\n        }\n        return memoize!mul(n-r+1, n) / memoize!mul(1, r);\n    }\n\n    // {}_n H_r: 重複組合せ (Homogeneous Combination)\n    static ModNumber hComb(T n, T r) {\n        return comb(n+r-1, r);\n    }\n\n    string toString() {\n        import std.conv;\n        return this.value.to!string;\n    }\n\n    invariant {\n        assert(this.value>=0);\n        assert(this.value<mod);\n    }\n}\n\n\n// ----------------------------------------------\n\nmixin template Constructor() {\n    import std.traits : FieldNameTuple;\n    this(Args...)(Args args) {\n        // static foreach(i, v; args) {\n        foreach(i, v; args) {\n            mixin(\"this.\" ~ FieldNameTuple!(typeof(this))[i]) = v;\n        }\n    }\n}\n\nvoid scanln(Args...)(auto ref Args args) {\n    import std.meta;\n    template getFormat(T) {\n        static if (isIntegral!T) {\n            enum getFormat = \"%d\";\n        } else static if (isFloatingPoint!T) {\n            enum getFormat = \"%g\";\n        } else static if (isSomeString!T || isSomeChar!T) {\n            enum getFormat = \"%s\";\n        } else {\n            static assert(false);\n        }\n    }\n    enum string str = [staticMap!(getFormat, Args)].join(\" \") ~ \"\\n\";\n    // readf!str(args);\n    mixin(\"str.readf(\" ~ Args.length.iota.map!(i => \"&args[%d]\".format(i)).join(\", \") ~ \");\");\n}\n\nvoid times(alias fun)(long n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(long n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\nT ceil(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n    // `(x+y-1)/y` will only work for positive numbers ...\n    T t = x / y;\n    if (t * y < x) t++;\n    return t;\n}\n\nT floor(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n    T t = x / y;\n    if (t * y > x) t--;\n    return t;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    private auto extremum(alias map, alias selector = \"a < b\", Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range &&\n        is(typeof(unaryFun!map(ElementType!(Range).init))))\n    in\n    {\n        assert(!r.empty, \"r is an empty range\");\n    }\n    body\n    {\n        alias Element = ElementType!Range;\n        Unqual!Element seed = r.front;\n        r.popFront();\n        return extremum!(map, selector)(r, seed);\n    }\n\n    private auto extremum(alias map, alias selector = \"a < b\", Range,\n                          RangeElementType = ElementType!Range)\n                         (Range r, RangeElementType seedElement)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n         is(typeof(unaryFun!map(ElementType!(Range).init))))\n    {\n        alias mapFun = unaryFun!map;\n        alias selectorFun = binaryFun!selector;\n\n        alias Element = ElementType!Range;\n        alias CommonElement = CommonType!(Element, RangeElementType);\n        Unqual!CommonElement extremeElement = seedElement;\n\n        alias MapType = Unqual!(typeof(mapFun(CommonElement.init)));\n        MapType extremeElementMapped = mapFun(extremeElement);\n\n        // direct access via a random access range is faster\n        static if (isRandomAccessRange!Range)\n        {\n            foreach (const i; 0 .. r.length)\n            {\n                MapType mapElement = mapFun(r[i]);\n                if (selectorFun(mapElement, extremeElementMapped))\n                {\n                    extremeElement = r[i];\n                    extremeElementMapped = mapElement;\n                }\n            }\n        }\n        else\n        {\n            while (!r.empty)\n            {\n                MapType mapElement = mapFun(r.front);\n                if (selectorFun(mapElement, extremeElementMapped))\n                {\n                    extremeElement = r.front;\n                    extremeElementMapped = mapElement;\n                }\n                r.popFront();\n            }\n        }\n        return extremeElement;\n    }\n    private auto extremum(alias selector = \"a < b\", Range)(Range r)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n    {\n        alias Element = ElementType!Range;\n        Unqual!Element seed = r.front;\n        r.popFront();\n        return extremum!selector(r, seed);\n    }\n    private auto extremum(alias selector = \"a < b\", Range,\n                          RangeElementType = ElementType!Range)\n                         (Range r, RangeElementType seedElement)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n            !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n    {\n        alias Element = ElementType!Range;\n        alias CommonElement = CommonType!(Element, RangeElementType);\n        Unqual!CommonElement extremeElement = seedElement;\n        alias selectorFun = binaryFun!selector;\n\n        // direct access via a random access range is faster\n        static if (isRandomAccessRange!Range)\n        {\n            foreach (const i; 0 .. r.length)\n            {\n                if (selectorFun(r[i], extremeElement))\n                {\n                    extremeElement = r[i];\n                }\n            }\n        }\n        else\n        {\n            while (!r.empty)\n            {\n                if (selectorFun(r.front, extremeElement))\n                {\n                    extremeElement = r.front;\n                }\n                r.popFront();\n            }\n        }\n        return extremeElement;\n    }\n    auto minElement(Range)(Range r)\n        if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum(r);\n    }\n    auto minElement(alias map, Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!map(r, seed);\n    }\n    auto minElement(Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum(r, seed);\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum!(map, \"a > b\")(r);\n    }\n    auto maxElement(Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum!`a > b`(r);\n    }\n    auto maxElement(alias map, Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!(map, \"a > b\")(r, seed);\n    }\n    auto maxElement(Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!`a > b`(r, seed);\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm, std.container, std.conv, std.math, std.range, std.typecons, std.stdio, std.string;\nimport std.numeric;\n\nauto rdsp(){return readln.splitter;}\nvoid pick(R,T)(ref R r,ref T t){t=r.front.to!T;r.popFront;}\nvoid readV(T...)(ref T t){auto r=rdsp;foreach(ref v;t)pick(r,v);}\nvoid readC(T...)(size_t n,ref T t){foreach(ref v;t)v=new typeof(v)(n);foreach(i;0..n){auto r=rdsp;foreach(ref v;t)pick(r,v[i]);}}\n\nconst mod = 998244353;\nalias mint = FactorRing!mod;\n\nvoid main()\n{\n  int n; readV(n);\n  int[] x, y; readC(n, x, y);\n\n  int[][] l;\n  foreach (i; 0..n)\n    foreach (j; i+1..n)\n      l ~= line(x[i], y[i], x[j], y[j]);\n\n  auto ans = mint(2).repeatedSquare(n) - n*(n-1)/2 - n - 1;\n  foreach (li; l.sort().uniq) {\n    auto k = 0;\n    foreach (i; 0..n)\n      if (li[0]*x[i]+li[1]*y[i]+li[2] == 0) ++k;\n    if (k >= 3)\n      ans -= mint(2).repeatedSquare(k) - k*(k-1)/2 - k - 1;\n  }\n\n  writeln(ans);\n}\n\nauto line(int x1, int y1, int x2, int y2)\n{\n  auto a = y2-y1, b = x1-x2, c = (y1-y2)*x1+(x2-x1)*y1;\n  if (a < 0) {\n    a = -a; b = -b; c = -c;\n  }\n  auto g = a.gcd(b.abs).gcd(c.abs);\n  a /= g; b /= g; c /= g;\n\n  return [a, b, c];\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n)\n{\n  return repeatedSquare!(pred, T, U)(a, n, T(1));\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n, T init)\n{\n  import std.functional;\n  alias predFun = binaryFun!pred;\n\n  if (n == 0) return init;\n\n  auto r = init;\n  while (n > 0) {\n    if (n&1) r = predFun(r, a);\n    a = predFun(a, a);\n    n >>= 1;\n  }\n\n  return r;\n}\n\nstruct FactorRing(int m, bool pos = false)\n{\n  version(BigEndian) union { long vl; struct { int vi2; int vi; } } else union { long vl; int vi; }\n  alias FR = FactorRing!(m, pos);\n  @property static init() { return FR(0); }\n  @property int value() { return vi; }\n  @property void value(int v) { vi = mod(v); }\n  alias value this;\n\n  this(int v) { vi = v; }\n  this(int v, bool runMod) { vi = runMod ? mod(v) : v; }\n  this(long v) { vi = mod(v); }\n\n  ref auto opAssign(int v) { vi = v; return this; }\n\n  pure auto mod(int v) const { static if (pos) return v%m; else return (v%m+m)%m; }\n  pure auto mod(long v) const { static if (pos) return cast(int)(v%m); else return cast(int)((v%m+m)%m); }\n\n  static if (!pos) pure ref auto opUnary(string op: \"-\")() { return FR(mod(-vi)); }\n\n  static if (m < int.max / 2) {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vi\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vi\"~op~\"r\")); return this; }\n  } else {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vl\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vl\"~op~\"r\")); return this; }\n  }\n  pure ref auto opBinary(string op: \"*\")(int r) { return FR(mod(vl*r)); }\n  ref auto opOpAssign(string op: \"*\")(int r) { vi = mod(vl*r); return this; }\n\n  pure ref auto opBinary(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opBinary!op(r.vi); }\n  ref auto opOpAssign(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opOpAssign!op(r.vi); }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm, std.container, std.conv, std.math, std.range, std.typecons, std.stdio, std.string;\nimport std.numeric;\n\nauto rdsp(){return readln.splitter;}\nvoid pick(R,T)(ref R r,ref T t){t=r.front.to!T;r.popFront;}\nvoid readV(T...)(ref T t){auto r=rdsp;foreach(ref v;t)pick(r,v);}\nvoid readC(T...)(size_t n,ref T t){foreach(ref v;t)v=new typeof(v)(n);foreach(i;0..n){auto r=rdsp;foreach(ref v;t)pick(r,v[i]);}}\n\nconst mod = 998244353;\nalias mint = FactorRing!mod;\n\nvoid main()\n{\n  int n; readV(n);\n  int[] x, y; readC(n, x, y);\n\n  long[][] l;\n  foreach (i; 0..n)\n    foreach (j; i+1..n)\n      l ~= line(x[i], y[i], x[j], y[j]);\n\n  auto ans = mint(2).repeatedSquare(n) - n*(n-1)/2 - n - 1;\n  foreach (li; l.sort().uniq) {\n    auto k = 0;\n    foreach (i; 0..n)\n      if (li[0]*x[i]+li[1]*y[i]+li[2] == 0) ++k;\n    if (k >= 3)\n      ans -= mint(2).repeatedSquare(k) - k*(k-1)/2 - k - 1;\n  }\n\n  writeln(ans);\n}\n\nauto line(int x1, int y1, int x2, int y2)\n{\n  auto a = y2-y1, b = x1-x2, c = (y1-y2)*x1+(x2-x1)*y1;\n  if (a < 0) {\n    a = -a; b = -b; c = -c;\n  }\n  auto g = a.gcd(b.abs).gcd(c.abs);\n  a /= g; b /= g; c /= g;\n\n  return [a.to!long, b, c];\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n)\n{\n  return repeatedSquare!(pred, T, U)(a, n, T(1));\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n, T init)\n{\n  import std.functional;\n  alias predFun = binaryFun!pred;\n\n  if (n == 0) return init;\n\n  auto r = init;\n  while (n > 0) {\n    if (n&1) r = predFun(r, a);\n    a = predFun(a, a);\n    n >>= 1;\n  }\n\n  return r;\n}\n\nstruct FactorRing(int m, bool pos = false)\n{\n  version(BigEndian) union { long vl; struct { int vi2; int vi; } } else union { long vl; int vi; }\n  alias FR = FactorRing!(m, pos);\n  @property static init() { return FR(0); }\n  @property int value() { return vi; }\n  @property void value(int v) { vi = mod(v); }\n  alias value this;\n\n  this(int v) { vi = v; }\n  this(int v, bool runMod) { vi = runMod ? mod(v) : v; }\n  this(long v) { vi = mod(v); }\n\n  ref auto opAssign(int v) { vi = v; return this; }\n\n  pure auto mod(int v) const { static if (pos) return v%m; else return (v%m+m)%m; }\n  pure auto mod(long v) const { static if (pos) return cast(int)(v%m); else return cast(int)((v%m+m)%m); }\n\n  static if (!pos) pure ref auto opUnary(string op: \"-\")() { return FR(mod(-vi)); }\n\n  static if (m < int.max / 2) {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vi\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vi\"~op~\"r\")); return this; }\n  } else {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vl\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vl\"~op~\"r\")); return this; }\n  }\n  pure ref auto opBinary(string op: \"*\")(int r) { return FR(mod(vl*r)); }\n  ref auto opOpAssign(string op: \"*\")(int r) { vi = mod(vl*r); return this; }\n\n  pure ref auto opBinary(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opBinary!op(r.vi); }\n  ref auto opOpAssign(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opOpAssign!op(r.vi); }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm, std.container, std.conv, std.math, std.range, std.typecons, std.stdio, std.string;\nimport std.numeric;\n\nauto rdsp(){return readln.splitter;}\nvoid pick(R,T)(ref R r,ref T t){t=r.front.to!T;r.popFront;}\nvoid readV(T...)(ref T t){auto r=rdsp;foreach(ref v;t)pick(r,v);}\nvoid readC(T...)(size_t n,ref T t){foreach(ref v;t)v=new typeof(v)(n);foreach(i;0..n){auto r=rdsp;foreach(ref v;t)pick(r,v[i]);}}\n\nconst mod = 998244353;\nalias mint = FactorRing!mod;\nalias Line = Tuple!(int, \"a\", int, \"b\", int, \"c\");\n\nvoid main()\n{\n  int n; readV(n);\n  int[] x, y; readC(n, x, y);\n\n  bool[Line] h;\n  foreach (i; 0..n)\n    foreach (j; i+1..n) {\n      h[line(x[i], y[i], x[j], y[j])] = true;\n    }\n\n  auto ans = mint(2).repeatedSquare(n) - mint(n+1);\n  foreach (li; h.byKey) {\n    auto k = 0;\n    foreach (i; 0..n)\n      if (li.a*x[i]+li.b*y[i]+li.c == 0) ++k;\n    if (k >= 2)\n      ans -= mint(2).repeatedSquare(k) - mint(k+1);\n  }\n\n  writeln(ans);\n}\n\nauto line(int x1, int y1, int x2, int y2)\n{\n  auto a = y2-y1, b = x1-x2, c = (y1-y2)*x1+(x2-x1)*y1;\n  if (a < 0 || (a == 0 && b < 0)) {\n    a = -a; b = -b; c = -c;\n  }\n  auto g = a.gcd(b.abs).gcd(c.abs);\n  a /= g; b /= g; c /= g;\n\n  return Line(a, b, c);\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n)\n{\n  return repeatedSquare!(pred, T, U)(a, n, T(1));\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n, T init)\n{\n  import std.functional;\n  alias predFun = binaryFun!pred;\n\n  if (n == 0) return init;\n\n  auto r = init;\n  while (n > 0) {\n    if (n&1) r = predFun(r, a);\n    a = predFun(a, a);\n    n >>= 1;\n  }\n\n  return r;\n}\n\nstruct FactorRing(int m, bool pos = false)\n{\n  version(BigEndian) union { long vl; struct { int vi2; int vi; } } else union { long vl; int vi; }\n  alias FR = FactorRing!(m, pos);\n  @property static init() { return FR(0); }\n  @property int value() { return vi; }\n  @property void value(int v) { vi = mod(v); }\n  alias value this;\n\n  this(int v) { vi = v; }\n  this(int v, bool runMod) { vi = runMod ? mod(v) : v; }\n  this(long v) { vi = mod(v); }\n\n  ref auto opAssign(int v) { vi = v; return this; }\n\n  pure auto mod(int v) const { static if (pos) return v%m; else return (v%m+m)%m; }\n  pure auto mod(long v) const { static if (pos) return cast(int)(v%m); else return cast(int)((v%m+m)%m); }\n\n  static if (!pos) pure ref auto opUnary(string op: \"-\")() { return FR(mod(-vi)); }\n\n  static if (m < int.max / 2) {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vi\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vi\"~op~\"r\")); return this; }\n  } else {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vl\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vl\"~op~\"r\")); return this; }\n  }\n  pure ref auto opBinary(string op: \"*\")(int r) { return FR(mod(vl*r)); }\n  ref auto opOpAssign(string op: \"*\")(int r) { vi = mod(vl*r); return this; }\n\n  pure ref auto opBinary(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opBinary!op(r.vi); }\n  ref auto opOpAssign(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opOpAssign!op(r.vi); }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\n\nstruct Fraction {\n    long a;\n    long b;\n\n    this(long x, long y) {\n        a = x / gcd(x, y);\n        b = y / gcd(x, y);\n    }\n}\n\nlong powmod(long a, long x, long m) {\n    long ret = 1;\n    while (x) {\n        if (x % 2) ret = ret * a % m;\n        a = a * a % m;\n        x /= 2;\n    }\n    return ret;\n}\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto X = new long[](N);\n    auto Y = new long[](N);\n    foreach (i; 0..N) {\n        auto s = readln.split.map!(to!long);\n        X[i] = s[0];\n        Y[i] = s[1];\n    }\n\n    bool line(int i, int j, int k) {\n        return (Y[k] - Y[i]) * (X[j] - X[i]) == (Y[j] - Y[i]) * (X[k] - X[i]);\n    }\n\n    const long MOD = 998244353;\n    auto used = new bool[][](N, N);\n    long ans = 1 + N;\n\n\n    foreach (i; 0..N) {\n        foreach (j; i+1..N) {\n            if (used[i][j])\n                continue;\n            long cnt = 2;\n            int[] v = [i, j];\n\n            foreach (k; j+1..N) {\n                if (used[i][k] || !line(i, j, k))\n                    continue;\n                cnt += 1;\n                v ~= k;\n            }\n\n            foreach (a; 0..v.length)\n                foreach (b; a+1..v.length)\n                    used[a][b] = true;\n\n            ans += powmod(2, cnt, MOD) - cnt - 1;\n            ans %= MOD;\n        }\n    }\n\n    ans = powmod(2, N, MOD) - ans;\n    ans = (ans % MOD + MOD) % MOD;\n    ans.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm, std.container, std.conv, std.math, std.range, std.typecons, std.stdio, std.string;\nimport std.numeric;\n\nauto rdsp(){return readln.splitter;}\nvoid pick(R,T)(ref R r,ref T t){t=r.front.to!T;r.popFront;}\nvoid readV(T...)(ref T t){auto r=rdsp;foreach(ref v;t)pick(r,v);}\nvoid readC(T...)(size_t n,ref T t){foreach(ref v;t)v=new typeof(v)(n);foreach(i;0..n){auto r=rdsp;foreach(ref v;t)pick(r,v[i]);}}\n\nconst mod = 998244353;\nalias mint = FactorRing!mod;\nalias Line = Tuple!(int, \"a\", int, \"b\", int, \"c\");\n\nvoid main()\n{\n  int n; readV(n);\n  int[] x, y; readC(n, x, y);\n\n  bool[Line] h;\n  foreach (i; 0..n)\n    foreach (j; i+1..n) {\n      h[line(x[i], y[i], x[j], y[j])] = true;\n    }\n\n  auto ans = mint(2).repeatedSquare(n) - mint(n+1);\n  foreach (li; h.byKey) {\n    auto k = 0;\n    foreach (i; 0..n)\n      if (li.a*x[i]+li.b*y[i]+li.c == 0) ++k;\n    if (k >= 2)\n      ans -= mint(2).repeatedSquare(k) - mint(k+1);\n  }\n\n  writeln(ans);\n}\n\nauto line(int x1, int y1, int x2, int y2)\n{\n  auto a = y2-y1, b = x1-x2, c = (y1-y2)*x1+(x2-x1)*y1;\n  if (a < 0) {\n    a = -a; b = -b; c = -c;\n  }\n  auto g = a.gcd(b.abs).gcd(c.abs);\n  a /= g; b /= g; c /= g;\n\n  return Line(a, b, c);\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n)\n{\n  return repeatedSquare!(pred, T, U)(a, n, T(1));\n}\n\npure T repeatedSquare(alias pred = \"a * b\", T, U)(T a, U n, T init)\n{\n  import std.functional;\n  alias predFun = binaryFun!pred;\n\n  if (n == 0) return init;\n\n  auto r = init;\n  while (n > 0) {\n    if (n&1) r = predFun(r, a);\n    a = predFun(a, a);\n    n >>= 1;\n  }\n\n  return r;\n}\n\nstruct FactorRing(int m, bool pos = false)\n{\n  version(BigEndian) union { long vl; struct { int vi2; int vi; } } else union { long vl; int vi; }\n  alias FR = FactorRing!(m, pos);\n  @property static init() { return FR(0); }\n  @property int value() { return vi; }\n  @property void value(int v) { vi = mod(v); }\n  alias value this;\n\n  this(int v) { vi = v; }\n  this(int v, bool runMod) { vi = runMod ? mod(v) : v; }\n  this(long v) { vi = mod(v); }\n\n  ref auto opAssign(int v) { vi = v; return this; }\n\n  pure auto mod(int v) const { static if (pos) return v%m; else return (v%m+m)%m; }\n  pure auto mod(long v) const { static if (pos) return cast(int)(v%m); else return cast(int)((v%m+m)%m); }\n\n  static if (!pos) pure ref auto opUnary(string op: \"-\")() { return FR(mod(-vi)); }\n\n  static if (m < int.max / 2) {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vi\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vi\"~op~\"r\")); return this; }\n  } else {\n    pure ref auto opBinary(string op)(int r) if (op == \"+\" || op == \"-\") { return FR(mod(mixin(\"vl\"~op~\"r\"))); }\n    ref auto opOpAssign(string op)(int r) if (op == \"+\" || op == \"-\") { vi = mod(mixin(\"vl\"~op~\"r\")); return this; }\n  }\n  pure ref auto opBinary(string op: \"*\")(int r) { return FR(mod(vl*r)); }\n  ref auto opOpAssign(string op: \"*\")(int r) { vi = mod(vl*r); return this; }\n\n  pure ref auto opBinary(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opBinary!op(r.vi); }\n  ref auto opOpAssign(string op)(ref FR r) if (op == \"+\" || op == \"-\" || op == \"*\") { return opOpAssign!op(r.vi); }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\n\nlong powmod(long a, long x, long m) {\n    long ret = 1;\n    while (x) {\n        if (x % 2) ret = ret * a % m;\n        a = a * a % m;\n        x /= 2;\n    }\n    return ret;\n}\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto X = new long[](N);\n    auto Y = new long[](N);\n    foreach (i; 0..N) {\n        auto s = readln.split.map!(to!long);\n        X[i] = s[0];\n        Y[i] = s[1];\n    }\n\n    const long MOD = 998244353;\n    const real INF = 1L << 59;\n\n    real slope(int i, int j) {\n        if (X[i] == X[j]) return 1L << 59;\n        return 1.0L * (Y[j] - Y[i]) / (X[j] - X[i]);\n    }\n\n    real intercept(int i, int j) {\n        if (X[i] == X[j]) return X[i];\n        return 1.0L * (X[i] * Y[j] - 2 * X[i] * Y[i] + X[j] * Y[i]) / (X[j] - X[i]);\n    }\n\n    bool[real][real] used;\n    long ans = 1 + N;\n\n\n    foreach (i; 0..N) {\n        foreach (j; i+1..N) {\n            auto a = slope(i, j);\n            auto b = intercept(i, j);\n            if (a in used && b in used[a])\n                continue;\n            used[a][b] = true;\n            long cnt = 2;\n\n            foreach (k; j+1..N) {\n                auto c = slope(i, k);\n                auto d = intercept(i, k);\n                if (a == c && b == d)\n                    cnt += 1;\n            }\n\n            ans += powmod(2, cnt, MOD) - cnt - 1;\n            ans %= MOD;\n        }\n    }\n\n    ans = powmod(2, N, MOD) - ans;\n    ans = (ans % MOD + MOD) % MOD;\n    ans.writeln;\n\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.concurrency;\nimport std.traits;\nimport std.uni;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nenum long INF = long.max/3;\nenum long MOD = 10L^^9+7;\n\nstruct P {\n    long x, y;\n}\nstruct L {\n    // ax + by + c = 0\n    long a, b, c;\n    this(long a, long b, long c) {\n        if (a<0 || (a==0&&b<0)) {\n            a *= -1;\n            b *= -1;\n            c *= -1;\n        }\n        long d = [a, b, c].map!abs.filter!\"a>0\".reduce!gcd;\n        a /= d;\n        b /= d;\n        c /= d;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n}\nvoid main() {\n    long N;\n    scanln(N);\n    P[] ps = N.rep!({\n        long x, y;\n        scanln(x, y);\n        return P(x, y);\n    });\n\n    long[L] aa;\n    foreach(i; 0..N) foreach(j; 0..i) {\n        P p = ps[i];\n        P q = ps[j];\n        aa[L(q.y-p.y, -(q.x-p.x), -p.x*q.y+p.y*q.x)]++;\n    }\n\n    ModNum ans = ModNum(2)^^N;\n    ans -= 1+N;\n    long[long] inv;\n    long f(long n) {\n        long res = n==0 ? 0 : n+f(n-1);\n        inv[res] = n;\n        return res;\n    }\n    f(N+1);\n    foreach(k, v; aa) {\n        ans -= ModNum(2)^^(inv[v] + 1) - (inv[v] + 1) - 1;\n    }\n    ans.writeln;\n}\n\nalias ModNum = ModNumber!(long, MOD);\n\nstruct ModNumber(T, T mod) if (__traits(isIntegral, T)) {\n    private enum FACT_MAX = 1000000;\n\n    T value;\n    this(T value) {\n        this.value = value;\n        this.value %= mod;\n        this.value += mod;\n        this.value %= mod;\n    }\n\n    ModNumber opAssign(T value) {\n        this.value = value;\n        return this;\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(this.value \"~op~\" that.value + mod) % mod\"));\n    }\n    ModNumber opBinary(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(this.value \"~op~\" that + mod) % mod\"));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\") {\n        return ModNumber(mixin(\"(that \"~op~\" this.value + mod) % mod\"));\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op == \"/\") {\n        return this*getReciprocal(that);\n    }\n    ModNumber opBinary(string op)(T that) if (op == \"/\") {\n        return this*getReciprocal(ModNumber(that));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op == \"/\") {\n        return ModNumber(that)*getReciprocal(this);\n    }\n\n    ModNumber opBinary(string op)(ModNumber that) if (op == \"^^\") {\n        return ModNumber(modPow(this.value, that.value));\n    }\n    ModNumber opBinary(string op)(T that) if (op == \"^^\") {\n        return ModNumber(modPow(this.value, that));\n    }\n    ModNumber opBinaryRight(string op)(T that) if (op == \"^^\") {\n        return ModNumber(modPow(that, this.value));\n    }\n\n    void opOpAssign(string op)(ModNumber that) if (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\") {\n        this = mixin(\"this\" ~op~ \"that\");\n    }\n    void opOpAssign(string op)(T that) if (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\") {\n        this = mixin(\"this\" ~op~ \"that\");\n    }\n\n    ModNumber getReciprocal(ModNumber x) in {\n        debug assert(isPrime(mod));\n    } body {\n        return ModNumber(modPow(x.value, mod-2));\n    }\n    T modPow(T base, T power)  {\n        T result = 1;\n        for (; power > 0; power >>= 1) {\n            if (power & 1) {\n                result = (result * base) % mod;\n            }\n            base = base*base % mod;\n        }\n        return result;\n    }\n\n    static bool isPrime(T n) {\n        if (n<2) {\n            return false;\n        } else if (n==2) {\n            return true;\n        } else if (n%2==0) {\n            return false;\n        } else {\n            for(T i=3; i*i<=n; i+=2) {\n                if (n%i==0) return false;\n            }\n            return true;\n        }\n    }\n\n    // n! : 階乗\n    static ModNumber fact(T n) {\n        assert(0<=n && n<=FACT_MAX);\n        static ModNumber[] memo;\n        if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n        if (memo[n] != ModNumber.init) {\n            return memo[n];\n        } else {\n            return memo[n] = n==0 ? ModNumber(1) : n*fact(n-1);\n        }\n    }\n\n    // 1/(n!) : 階乗の逆元 (逆元テーブルを用いる)\n    static ModNumber invFact(T n) {\n        assert(0<=n && n<=FACT_MAX);\n        static ModNumber inverse(T n) {\n            assert(1<=n && n<=FACT_MAX);\n            static ModNumber[] memo;\n            if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n            if (memo[n] != ModNumber.init) {\n                return memo[n];\n            } else {\n                return memo[n] = n==1 ? ModNumber(1) : ModNumber(-mod/n)*inverse(mod%n);\n            }\n        }\n        static ModNumber[] memo;\n        if (memo.length == 0) memo = new ModNumber[FACT_MAX+1];\n        if (memo[n] != ModNumber.init) {\n            return memo[n];\n        } else {\n            return memo[n] = n==0 ? ModNumber(1) : inverse(n)*invFact(n-1);\n        }\n    }\n\n    // {}_n C_r: 組合せ\n    static ModNumber comb(T n, T r) {\n        import std.functional : memoize;\n        if (r<0 || r>n) return ModNumber(0);\n        if (r*2 > n) return comb(n, n-r);\n\n        if (n<=FACT_MAX) {\n            return fact(n) * invFact(r) * invFact(n-r); // 逆元テーブルを使用する\n            // return fact(n) / fact(r) / fact(n-r); // 逆元テーブルを使用しない\n        }\n\n        ModNum mul(T l, T r) {\n            return l>r ? ModNumber(1) : l * memoize!mul(l+1, r);\n        }\n        return memoize!mul(n-r+1, n) / memoize!mul(1, r);\n    }\n\n    // {}_n H_r: 重複組合せ (Homogeneous Combination)\n    static ModNumber hComb(T n, T r) {\n        return comb(n+r-1, r);\n    }\n\n    string toString() {\n        import std.conv;\n        return this.value.to!string;\n    }\n\n    invariant {\n        assert(this.value>=0);\n        assert(this.value<mod);\n    }\n}\n\n\n// ----------------------------------------------\n\nmixin template Constructor() {\n    import std.traits : FieldNameTuple;\n    this(Args...)(Args args) {\n        // static foreach(i, v; args) {\n        foreach(i, v; args) {\n            mixin(\"this.\" ~ FieldNameTuple!(typeof(this))[i]) = v;\n        }\n    }\n}\n\nvoid scanln(Args...)(auto ref Args args) {\n    import std.meta;\n    template getFormat(T) {\n        static if (isIntegral!T) {\n            enum getFormat = \"%d\";\n        } else static if (isFloatingPoint!T) {\n            enum getFormat = \"%g\";\n        } else static if (isSomeString!T || isSomeChar!T) {\n            enum getFormat = \"%s\";\n        } else {\n            static assert(false);\n        }\n    }\n    enum string str = [staticMap!(getFormat, Args)].join(\" \") ~ \"\\n\";\n    // readf!str(args);\n    mixin(\"str.readf(\" ~ Args.length.iota.map!(i => \"&args[%d]\".format(i)).join(\", \") ~ \");\");\n}\n\nvoid times(alias fun)(long n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(long n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\nT ceil(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n    // `(x+y-1)/y` will only work for positive numbers ...\n    T t = x / y;\n    if (t * y < x) t++;\n    return t;\n}\n\nT floor(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n    T t = x / y;\n    if (t * y > x) t--;\n    return t;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    private auto extremum(alias map, alias selector = \"a < b\", Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range &&\n        is(typeof(unaryFun!map(ElementType!(Range).init))))\n    in\n    {\n        assert(!r.empty, \"r is an empty range\");\n    }\n    body\n    {\n        alias Element = ElementType!Range;\n        Unqual!Element seed = r.front;\n        r.popFront();\n        return extremum!(map, selector)(r, seed);\n    }\n\n    private auto extremum(alias map, alias selector = \"a < b\", Range,\n                          RangeElementType = ElementType!Range)\n                         (Range r, RangeElementType seedElement)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n         is(typeof(unaryFun!map(ElementType!(Range).init))))\n    {\n        alias mapFun = unaryFun!map;\n        alias selectorFun = binaryFun!selector;\n\n        alias Element = ElementType!Range;\n        alias CommonElement = CommonType!(Element, RangeElementType);\n        Unqual!CommonElement extremeElement = seedElement;\n\n        alias MapType = Unqual!(typeof(mapFun(CommonElement.init)));\n        MapType extremeElementMapped = mapFun(extremeElement);\n\n        // direct access via a random access range is faster\n        static if (isRandomAccessRange!Range)\n        {\n            foreach (const i; 0 .. r.length)\n            {\n                MapType mapElement = mapFun(r[i]);\n                if (selectorFun(mapElement, extremeElementMapped))\n                {\n                    extremeElement = r[i];\n                    extremeElementMapped = mapElement;\n                }\n            }\n        }\n        else\n        {\n            while (!r.empty)\n            {\n                MapType mapElement = mapFun(r.front);\n                if (selectorFun(mapElement, extremeElementMapped))\n                {\n                    extremeElement = r.front;\n                    extremeElementMapped = mapElement;\n                }\n                r.popFront();\n            }\n        }\n        return extremeElement;\n    }\n    private auto extremum(alias selector = \"a < b\", Range)(Range r)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n    {\n        alias Element = ElementType!Range;\n        Unqual!Element seed = r.front;\n        r.popFront();\n        return extremum!selector(r, seed);\n    }\n    private auto extremum(alias selector = \"a < b\", Range,\n                          RangeElementType = ElementType!Range)\n                         (Range r, RangeElementType seedElement)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n            !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n    {\n        alias Element = ElementType!Range;\n        alias CommonElement = CommonType!(Element, RangeElementType);\n        Unqual!CommonElement extremeElement = seedElement;\n        alias selectorFun = binaryFun!selector;\n\n        // direct access via a random access range is faster\n        static if (isRandomAccessRange!Range)\n        {\n            foreach (const i; 0 .. r.length)\n            {\n                if (selectorFun(r[i], extremeElement))\n                {\n                    extremeElement = r[i];\n                }\n            }\n        }\n        else\n        {\n            while (!r.empty)\n            {\n                if (selectorFun(r.front, extremeElement))\n                {\n                    extremeElement = r.front;\n                }\n                r.popFront();\n            }\n        }\n        return extremeElement;\n    }\n    auto minElement(Range)(Range r)\n        if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum(r);\n    }\n    auto minElement(alias map, Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!map(r, seed);\n    }\n    auto minElement(Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n        if (isInputRange!Range && !isInfinite!Range &&\n            !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum(r, seed);\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum!(map, \"a > b\")(r);\n    }\n    auto maxElement(Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        return extremum!`a > b`(r);\n    }\n    auto maxElement(alias map, Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!(map, \"a > b\")(r, seed);\n    }\n    auto maxElement(Range, RangeElementType = ElementType!Range)\n                   (Range r, RangeElementType seed)\n    if (isInputRange!Range && !isInfinite!Range &&\n        !is(CommonType!(ElementType!Range, RangeElementType) == void))\n    {\n        return extremum!`a > b`(r, seed);\n    }\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int mod=998244353;\nint x[2005],y[2005],tw[2100],n,num,ans;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>x[i]>>y[i];\n\ttw[0]=1;\n\tfor(int i=1;i<=2000;i++)\n\t\ttw[i]=(tw[i-1]<<1)%mod;\n\tans=tw[n]-n-1;\n\t//cout<<tw[n]<<endl;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tnum=0;\n\t\t\tfor(int k=j+1;k<=n;k++)\n\t\t\t\tif((x[j]-x[i])*(y[k]-y[j])==(x[k]-x[j])*(y[j]-y[i]))\n\t\t\t\t\tnum++;\n\t\t\tans=(ans-tw[num]+mod)%mod;\n\t\t//\tcout<<i<<\" \"<<j<<\" \"<<ans<<endl;\n\t\t}\n\t//ans-=(n+1);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<stdio.h>\n#include<queue>\n#define x first\n#define y second\nusing namespace std;\nconst int mod=998244353;\nint N;\ntypedef pair<int,int> Pair;\nPair pos[205];\nint x[205],y[205],power[205];\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tint ans=0;\n\tpower[0]=1;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tpower[i+1]=(power[i]*2+mod)%mod;\n\t}\n\tans=power[N]-N-1;\n\n\tfor(int i=0;i<N;i++)\n\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<j;k++)\n\t\t\tif((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))\n\t\t\tcnt++;\n\t\t\tans=(ans-power[cnt]+mod)%mod;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<stdio.h>\n#include<queue>\n#define x first\n#define y second\nusing namespace std;\nconst int mod=998244353;\nint N;\n\nint x[205],y[205],power[205];\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tint ans;\n\tpower[0]=1;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tpower[i+1]=(power[i]<<1)%mod;\n\t}\n\tans=power[N]-N-1;\n\n\tfor(int i=0;i<N;i++)\n\tfor(int j=0;j<i;j++)\n\t{\n\t\tint cnt=0;\n\t\tfor(int k=0;k<j;k++)\n\t\t{\n\t\t\tif((x[i]-x[j])*(y[i]-y[k])==(x[i]-x[k])*(y[i]-y[j]))\n\t\t\tcnt++;\n\t\t}\n\t\tans=(ans-power[cnt]+mod)%mod;\n\t}\n\t\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<string.h>\n#include<stdio.h>\n#include<algorithm>\n#define mod 998244353 \n#define maxn 505\nusing namespace std;\nint n, ans, x[maxn], y[maxn], pw[maxn];\n\nint main(){\n    scanf( \"%d\", &n );\n    pw[0] = 1;\n    for( int i = 1; i <= n; i ++ ) pw[i] = ( long long ) pw[i - 1] * 2 % mod;\n    for( int i = 1; i <= n; i ++ ) scanf( \"%d%d\", &x[i], &y[i] );\n    ans = ( pw[n] - n - 1 - n * ( n - 1 ) / 2 + mod ) % mod;\n    for( int i = 1; i <= n; i ++ ) {\n        for( int j = i + 1; j <= n; j ++ ) {\n            int tmp = 0;\n            for( int k = j + 1; k <= n; k ++ ) {\n                if( ( y[j] - y[i] ) * ( x[k] - x[j] ) == ( y[k] - y[j] ) * ( x[j] - x[i] ) ) tmp ++;\n            }\n            ans = ( ans + mod + 1 - pw[tmp] ) % mod;\n        }\n    }\n    printf( \"%d\", ans );\n}"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nwhen not defined(release):\n  addHandler(newFileLogger(stderr, lvlAll, \"[ $levelname ] \"))\n\nproc readInt1*(): int = stdin.readLine().strip().parseInt()\nproc readInt2*(): (int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1])\nproc readInt3*(): (int, int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1], v[2])\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\n#------------------------------------------------------------------------------#\nconst MOD = int(998244353)\n\ntype Op1[T] = proc(a: T, b: T): T\ntype Op2[T] = proc(a: T, b: T): T\n\nproc repeatedSquares[T](x: T, n: Natural, e: T, f: Op2[T]): T =\n    result = e\n    var xx = f(x, e)\n    var i = n\n    while i > 0:\n        if (i and 1) != 0:\n            result = f(result, xx)\n        xx = f(xx, xx)\n        i = i shr 1\n\n\nproc addM(a, b: Natural): Natural = (a + b) mod MOD\nproc subM(a, b: Natural): Natural = (a - b + MOD) mod MOD\nproc mulM(a, b: Natural): Natural = a * b mod MOD\nproc powM(a, b: Natural): Natural = repeatedSquares[Natural](a, b, 1, `mulM`)\nproc invM(a: Natural): Natural = a.powM(MOD - 2)\nproc divM(a, b: Natural): Natural = a.mulM(invM(b))\n\n\nvar memoFactM = @[Natural(1)]\nproc factM(n: Natural): Natural =\n    if n < memoFactM.len():\n        return memoFactM[n]\n    for i in memoFactM.len()..n:\n        memoFactM.add(memoFactM[i - 1].mulM(i))\n    return memoFactM[n]\n\n\nproc combM(n, r: Natural): Natural =\n    if r > n:\n        return 0\n    if r > n div 2:\n        return combM(n, n - r)\n\n    result = 1\n    for i in ((n - r) + 1)..n:\n        result = result.mulM(i)\n    result = result.divM(factM(r))\n\n\nproc multCombM(n, r: Natural): Natural = combM(n + r - 1, n - 1)\n\n#------------------------------------------------------------------------------#\n\n\n# ax + by + c = 0\ntype Line = tuple [ a, b, c: int ]\ntype Point = tuple [ y, x: int ]\n\nproc `$`(p: Point): string = \"(\" & $p.y & \", \" & $p.x & \")\"\n\nproc on(pp: Point; ll: Line): bool =\n  ll.a * pp.x + ll.b * pp.y + ll.c == 0\n\n\nproc normalizeLine(ll: Line): Line =\n  let d = gcd(abs(ll.a), gcd(abs(ll.b), abs(ll.c)))\n  let (a, b, c) = (ll.a div d, ll.b div d, ll.c div d)\n  if ll.a == 0:\n    return if ll.b >= 0: (a, b, c) else: (-a, -b, -c)\n  return if ll.a >= 0: (a, b, c) else: (-a, -b, -c)\n\nproc calcLine(p1, p2: Point): Line =\n  let ll = (p2.y - p1.y, p1.x - p2.x, -p1.x * p2.y + p1.y * p2.x)\n  return ll.normalizeLine()\n\nproc main() =\n  let n = readInt1()\n  var ps = newSeq[Point](n)\n  for i in 0..<n:\n    let (x, y) = readInt2()\n    ps[i] = (y, x)\n\n  var ls = initTable[Line, seq[Point]]()\n  for i in 0..<n:\n    for j in (i + 1)..<n:\n      let ll = calcLine(ps[i], ps[j])\n      if ll notin ls:\n        ls[ll] = @[]\n\n  for ll in ls.keys():\n    for i in 0..<n:\n      if ps[i].on(ll):\n        ls[ll].add(ps[i])\n\n  var ans = 2.powM(n)\n  ans = ans.subM(combM(n, 0))\n  ans = ans.subM(combM(n, 1))\n  ans = ans.subM(combM(n, 2))\n\n  for lps in ls.values():\n    let m = lps.len()\n    for i in 3..m:\n      ans = ans.subM(combM(m, i))\n\n  echo ans\n\nmain()\n\n"
  },
  {
    "language": "Nim",
    "code": "import sequtils,strutils\n\nproc powInt(n : int64, m : int64, k = 998_244_353):int64 =\n    if m == 0:\n        return 1\n    elif m == 1:\n        return (n mod k)\n    if (m mod 2) == 0:\n        return powInt((n * n) mod k,m div 2, k) mod k\n    else:\n        return (powInt((n * n) mod k,m div 2, k) * n) mod k\n\nconst\n    Max_num = 2_000_003\n    m : int64 = 998_244_353\n\nvar\n    kaizyou : array[Max_num + 1, int64]\n    gyakuKaizyou : array[Max_num + 1, int64]\nkaizyou[0] = 1\n\nfor i in 1..Max_num:\n    kaizyou[i] = ((kaizyou[i - 1] * i.int64) mod m)\ngyakuKaizyou[Max_num] = powInt(kaizyou[Max_num], 998_244_351, 998_244_353)\n\nfor i in countdown(Max_num - 1,0):\n    gyakuKaizyou[i] = (gyakuKaizyou[i + 1] * (i + 1)) mod m\n\nproc combination(n : int64, k : int64): int64 =\n    if n < k:\n        return 0\n    if n == k:\n        return 1\n    return (((kaizyou[n] * gyakuKaizyou[n - k]) mod m) * gyakuKaizyou[k]) mod m\n\ntype\n    node = tuple[x, y : int]\n\nvar\n    N = stdin.readline.parseInt\n    x,y : int\n    ans : int64\n    nodes = newSeq[node](N)\n    flag : array[201, bool]\n\nans = powInt(2, N.int64) - 1 - N.int64 - ((N - 1) * N div 2).int64\n\nans = (ans + m) mod m\n\nproc line(a, b, c, x, y : int) : bool =\n    if a * x + b * y + c == 0:\n        return true\n    else:\n        return false\n\n\nfor n in 0..<N:\n    (x, y) = stdin.readline.split.map(parseInt)\n    nodes[n] = (x, y)\n\nfor i in 0..<N:\n    if flag[i]:\n        continue\n    for j in (i + 1)..<N:\n        if flag[j]:\n            continue\n        var\n            cnt : int = 2\n            a = nodes[i].y - nodes[j].y\n            b = nodes[j].x - nodes[i].x\n            c = -(nodes[i].x * a + nodes[i].y * b)\n        for k in (j + 1)..<N:\n            if line(a, b, c, nodes[k].x, nodes[k].y):\n                cnt += 1\n                flag[k] = true\n                \n        if cnt > 2:\n            ans -= powInt(2, cnt.int64)\n            ans += 1 + cnt.int64 + ((cnt - 1) * cnt div 2).int64\n            ans = (ans + m * 20) mod m\n\necho ans"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar x:seq[int]\nvar y:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  x = newSeqWith(N, 0)\n  y = newSeqWith(N, 0)\n  for i in 0..<N:\n    x[i] = nextInt()\n    y[i] = nextInt()\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ complex class\n{.push checks: off, line_dir: off, stack_trace: off, debugger: off.}\n# the user does not want to trace a part of the standard library!\n\nimport math\n\ntype\n  Complex* = object\n    re*, im*: float\n\nproc complex*(re: float; im: float = 0.0): Complex =\n  result.re = re\n  result.im = im\n\ntemplate im*(arg: typedesc[float]): Complex = complex(0, 1)\ntemplate im*(arg: float): Complex = complex(0, arg)\n\nproc abs*(z: Complex): float =\n  ## Return the distance from (0,0) to ``z``.\n  result = hypot(z.re, z.im)\n\nproc abs2*(z: Complex): float =\n  ## Return the squared distance from (0,0) to ``z``.\n  result = z.re*z.re + z.im*z.im\n\nproc conjugate*(z: Complex): Complex =\n  ## Conjugate of complex number ``z``.\n  result.re = z.re\n  result.im = -z.im\n\nproc `==` *(x, y: Complex): bool =\n  ## Compare two complex numbers ``x`` and ``y`` for equality.\n  result = x.re == y.re and x.im == y.im\n\n#proc `+` *(x: float; y: Complex): Complex =\n#  ## Add a real number to a complex number.\n#  result.re = x + y.re\n#  result.im = y.im\n\nproc `+` *(x: Complex; y: float): Complex =\n  ## Add a complex number to a real number.\n  result.re = x.re + y\n  result.im = x.im\n\nproc `+` *(x, y: Complex): Complex =\n  ## Add two complex numbers.\n  result.re = x.re + y.re\n  result.im = x.im + y.im\n\nproc `-` *(z: Complex): Complex =\n  ## Unary minus for complex numbers.\n  result.re = -z.re\n  result.im = -z.im\n\n#proc `-` *(x: float; y: Complex): Complex =\n#  ## Subtract a complex number from a real number.\n#  x + (-y)\n\nproc `-` *(x: Complex; y: float): Complex =\n  ## Subtract a real number from a complex number.\n  result.re = x.re - y\n  result.im = x.im\n\nproc `-` *(x, y: Complex): Complex =\n  ## Subtract two complex numbers.\n  result.re = x.re - y.re\n  result.im = x.im - y.im\n\nproc `*` *(x, y: Complex): Complex =\n  ## Multiply ``x`` with ``y``.\n  result.re = x.re * y.re - x.im * y.im\n  result.im = x.im * y.re + x.re * y.im\n\n#proc `*` *(x: float; y: Complex): Complex =\n#  ## Multiply a real number and a complex number.\n#  result.re = x * y.re\n#  result.im = x * y.im\n\nproc `*` *(x: Complex; y: float): Complex =\n  ## Multiply a complex number with a real number.\n  result.re = x.re * y\n  result.im = x.im * y\n\nproc `/` *(x: Complex; y: float): Complex =\n  ## Divide complex number ``x`` by real number ``y``.\n  result.re = x.re / y\n  result.im = x.im / y\n\nproc inv*(z: Complex): Complex =\n  ## Multiplicative inverse of complex number ``z``.\n  conjugate(z) / abs2(z)\n\n#proc `/` *(x: float; y: Complex): Complex =\n#  ## Divide real number ``x`` by complex number ``y``.\n#  result = x * inv(y)\n\nproc `/` *(x, y: Complex): Complex =\n  ## Divide ``x`` by ``y``.\n  var r, den: float\n  if abs(y.re) < abs(y.im):\n    r = y.re / y.im\n    den = y.im + r * y.re\n    result.re = (x.re * r + x.im) / den\n    result.im = (x.im * r - x.re) / den\n  else:\n    r = y.im / y.re\n    den = y.re + r * y.im\n    result.re = (x.re + r * x.im) / den\n    result.im = (x.im - r * x.re) / den\n\nproc `+=` *(x: var Complex; y: Complex) =\n  ## Add ``y`` to ``x``.\n  x.re += y.re\n  x.im += y.im\n\nproc `-=` *(x: var Complex; y: Complex) =\n  ## Subtract ``y`` from ``x``.\n  x.re -= y.re\n  x.im -= y.im\n\nproc `*=` *(x: var Complex; y: Complex) =\n  ## Multiply ``y`` to ``x``.\n  let im = x.im * y.re + x.re * y.im\n  x.re = x.re * y.re - x.im * y.im\n  x.im = im\n\nproc `/=` *(x: var Complex; y: Complex) =\n  ## Divide ``x`` by ``y`` in place.\n  x = x / y\n\n\nproc sqrt*(z: Complex): Complex =\n  ## Square root for a complex number ``z``.\n  var x, y, w, r: float\n\n  if z.re == 0.0 and z.im == 0.0:\n    result = z\n  else:\n    x = abs(z.re)\n    y = abs(z.im)\n    if x >= y:\n      r = y / x\n      w = sqrt(x) * sqrt(0.5 * (1.0 + sqrt(1.0 + r * r)))\n    else:\n      r = x / y\n      w = sqrt(y) * sqrt(0.5 * (r + sqrt(1.0 + r * r)))\n\n    if z.re >= 0.0:\n      result.re = w\n      result.im = z.im / (w * 2.0)\n    else:\n      result.im = if z.im >= 0.0: w else: -w\n      result.re = z.im / (result.im + result.im)\n\nproc exp*(z: Complex): Complex =\n  ## ``e`` raised to the power ``z``.\n  var\n    rho = exp(z.re)\n    theta = z.im\n  result.re = rho * cos(theta)\n  result.im = rho * sin(theta)\n\nproc ln*(z: Complex): Complex =\n  ## Returns the natural log of ``z``.\n  result.re = ln(abs(z))\n  result.im = arctan2(z.im, z.re)\n\nproc log10*(z: Complex): Complex =\n  ## Returns the log base 10 of ``z``.\n  result = ln(z) / ln(10.0)\n\nproc log2*(z: Complex): Complex =\n  ## Returns the log base 2 of ``z``.\n  result = ln(z) / ln(2.0)\n\nproc pow*(x, y: Complex): Complex =\n  ## ``x`` raised to the power ``y``.\n  if x.re == 0.0 and x.im == 0.0:\n    if y.re == 0.0 and y.im == 0.0:\n      result.re = 1.0\n      result.im = 0.0\n    else:\n      result.re = 0.0\n      result.im = 0.0\n  elif y.re == 1.0 and y.im == 0.0:\n    result = x\n  elif y.re == -1.0 and y.im == 0.0:\n    result = complex(1.0) / x\n  else:\n    var\n      rho = abs(x)\n      theta = arctan2(x.im, x.re)\n      s = pow(rho, y.re) * exp(-y.im * theta)\n      r = y.re * theta + y.im * ln(rho)\n    result.re = s * cos(r)\n    result.im = s * sin(r)\n\nproc pow*(x: Complex; y: float): Complex =\n  ## Complex number ``x`` raised to the power ``y``.\n  pow(x, complex(y))\n\n\nproc sin*(z: Complex): Complex =\n  ## Returns the sine of ``z``.\n  result.re = sin(z.re) * cosh(z.im)\n  result.im = cos(z.re) * sinh(z.im)\n\nproc arcsin*(z: Complex): Complex =\n  ## Returns the inverse sine of ``z``.\n  result = -im(float) * ln(im(float) * z + sqrt(complex(1.0) - z*z))\n\nproc cos*(z: Complex): Complex =\n  ## Returns the cosine of ``z``.\n  result.re = cos(z.re) * cosh(z.im)\n  result.im = -sin(z.re) * sinh(z.im)\n\nproc arccos*(z: Complex): Complex =\n  ## Returns the inverse cosine of ``z``.\n  result = -im(float) * ln(z + sqrt(z*z - float(1.0)))\n\nproc tan*(z: Complex): Complex =\n  ## Returns the tangent of ``z``.\n  result = sin(z) / cos(z)\n\nproc arctan*(z: Complex): Complex =\n  ## Returns the inverse tangent of ``z``.\n  result = complex(0.5)*im(float) * (ln(complex(1.0) - im(float)*z) - ln(complex(1.0) + im(float)*z))\n\nproc cot*(z: Complex): Complex =\n  ## Returns the cotangent of ``z``.\n  result = cos(z)/sin(z)\n\nproc arccot*(z: Complex): Complex =\n  ## Returns the inverse cotangent of ``z``.\n  result = complex(0.5)*im(float) * (ln(complex(1.0) - im(float)/z) - ln(complex(1.0) + im(float)/z))\n\nproc sec*(z: Complex): Complex =\n  ## Returns the secant of ``z``.\n  result = complex(1.0) / cos(z)\n\nproc arcsec*(z: Complex): Complex =\n  ## Returns the inverse secant of ``z``.\n  result = -im(float) * ln(im(float) * sqrt(complex(1.0) - complex(1.0)/(z*z)) + complex(1.0)/z)\n\nproc csc*(z: Complex): Complex =\n  ## Returns the cosecant of ``z``.\n  result = complex(1.0) / sin(z)\n\nproc arccsc*(z: Complex): Complex =\n  ## Returns the inverse cosecant of ``z``.\n  result = -im(float) * ln(sqrt(complex(1.0) - complex(1.0)/(z*z)) + im(float)/z)\n\nproc sinh*(z: Complex): Complex =\n  ## Returns the hyperbolic sine of ``z``.\n  result = complex(0.5) * (exp(z) - exp(-z))\n\nproc arcsinh*(z: Complex): Complex =\n  ## Returns the inverse hyperbolic sine of ``z``.\n  result = ln(z + sqrt(z*z + 1.0))\n\nproc cosh*(z: Complex): Complex =\n  ## Returns the hyperbolic cosine of ``z``.\n  result = complex(0.5) * (exp(z) + exp(-z))\n\nproc arccosh*(z: Complex): Complex =\n  ## Returns the inverse hyperbolic cosine of ``z``.\n  result = ln(z + sqrt(z*z - float(1.0)))\n\nproc tanh*(z: Complex): Complex =\n  ## Returns the hyperbolic tangent of ``z``.\n  result = sinh(z) / cosh(z)\n\nproc arctanh*(z: Complex): Complex =\n  ## Returns the inverse hyperbolic tangent of ``z``.\n  result = complex(0.5) * (ln((complex(1.0)+z) / (complex(1.0)-z)))\n\nproc sech*(z: Complex): Complex =\n  ## Returns the hyperbolic secant of ``z``.\n  result = complex(2.0) / (exp(z) + exp(-z))\n\nproc arcsech*(z: Complex): Complex =\n  ## Returns the inverse hyperbolic secant of ``z``.\n  result = ln(1.0.complex/z + sqrt(complex(1.0)/z+float(1.0)) * sqrt(complex(1.0)/z-float(1.0)))\n\nproc csch*(z: Complex): Complex =\n  ## Returns the hyperbolic cosecant of ``z``.\n  result = complex(2.0) / (exp(z) - exp(-z))\n\nproc arccsch*(z: Complex): Complex =\n  ## Returns the inverse hyperbolic cosecant of ``z``.\n  result = ln(complex(1.0)/z + sqrt(complex(1.0)/(z*z) + float(1.0)))\n\nproc coth*(z: Complex): Complex =\n  ## Returns the hyperbolic cotangent of ``z``.\n  result = cosh(z) / sinh(z)\n\nproc arccoth*(z: Complex): Complex =\n  ## Returns the inverse hyperbolic cotangent of ``z``.\n  result = complex(0.5) * (ln(complex(1.0) + complex(1.0)/z) - ln(complex(1.0) - complex(1.0)/z))\n\nproc phase*(z: Complex): float =\n  ## Returns the phase of ``z``.\n  arctan2(z.im, z.re)\n\nproc polar*(z: Complex): tuple[r, phi: float] =\n  ## Returns ``z`` in polar coordinates.\n  (r: abs(z), phi: phase(z))\n\nproc rect*(r, phi: float): Complex =\n  ## Returns the complex number with polar coordinates ``r`` and ``phi``.\n  ##\n  ## | ``result.re = r * cos(phi)``\n  ## | ``result.im = r * sin(phi)``\n  complex(r * cos(phi), r * sin(phi))\n\n\nproc `$`*(z: Complex): string =\n  ## Returns ``z``'s string representation as ``\"(re, im)\"``.\n  result = \"(\" & $z.re & \", \" & $z.im & \")\"\n\n{.pop.}\n#}}}\n\nimport sets, sequtils\n\ntype\n  Real = float\n#  Point = Complex[float]\n  Point = Complex\n\nproc initPoint(re:float, im:float):Point = Point(re:re, im:im)\nproc nextPoint():Point = return initPoint(nextFloat(), nextFloat())\n\nproc `*`(p:Point, d:Real):Point =\n  return Point(re:p.re * d, im:p.im * d)\n\nproc toString(p:Point):string = $(p.re) & \" \" & $(p.im)\n\n# rotate point p counterclockwise by theta rad\nproc rotate(theta:Real, p:Point):Point =\n  return initPoint(cos(theta) * p.re - sin(theta) * p.im, sin(theta) * p.re + cos(theta) * p.im)\n\nproc radianToDegree(r:Real):Real = r * 180.Real / PI\nproc degreeToRadian(d:Real):Real = d * PI / 180.Real\n\n# smaller angle of the a-b-c\nproc getAngle(a,b,c:Point):Real =\n  let\n    v = b - a\n    w = c - b\n  var\n    alpha = arctan2(v.im, v.re)\n    beta = arctan2(w.im, w.re)\n  if alpha > beta: swap(alpha, beta)\n  let theta = beta - alpha\n  return min(theta, 2.Real * PI - theta)\n\n# float comp {{{\nconst EPS = 1e-9\n\nproc `==`(a,b:float):bool = system.`<`(abs(a - b), EPS)\nproc `!=`(a,b:float):bool = system.`>`(abs(a - b), EPS)\nproc `<`(a,b:float):bool = system.`<`(a + EPS, b)\nproc `>`(a,b:float):bool = system.`>`(a, b + EPS)\nproc `<=`(a,b:float):bool = system.`<`(a, b + EPS)\nproc `>=`(a,b:float):bool = system.`>`(a + EPS, b)\n# }}}\n\n# comparison functions {{{\n#proc eq(a,b:Real):bool = return abs(b - a) < EPS\nproc `==`(a,b:Point):bool =\n  return a.re == b.re and a.im == b.im\n#  return system.`<`(abs(b - a), EPS)\nproc `<`(a,b:Point):bool =\n  if a.re != b.re: return a.re < b.re\n  elif a.im != b.im: return a.im < b.im\n  return false\nproc `<=`(a,b:Point):bool =\n  if a.re != b.re: return a.re < b.re\n  elif a.im != b.im: return a.im < b.im\n  return true\n# }}}\n\n# Line and Segment {{{\ntype Line = object\n  a, b:Point\n\ntype Segment {.borrow: `.`.} = distinct Line\n\nproc initLine(a,b:Point):Line = Line(a:a, b:b)\nproc initLine(A, B, C:Real):Line = # Ax + By = C\n  var a, b: Point\n  if A == 0.Real: a = initPoint(0.Real, C / B); b = initPoint(1.Real, C / B)\n  elif B == 0.Real: b = initPoint(C / A, 0.Real); b = initPoint(C / A, 1.Real)\n  else: a = initPoint(0.Real, C / B); b = initPoint(C / A, 0.Real)\n  return initLine(a, b)\n\nproc `$`(p:Line):string =\n  return(p.a.toString & \" to \" & p.b.toString)\nproc nextLine():Line = initLine(nextPoint(), nextPoint())\n\nproc initSegment(a, b:Point):Segment = Segment(Line(a:a, b:b))\nproc nextSegment():Segment = initSegment(nextPoint(), nextPoint())\n# }}}\n\n# Circle {{{\ntype Circle = object\n  p:Point\n  r:Real\n\nproc initCircle(p:Point, r:Real):Circle = Circle(p:p, r:r)\n# }}}\n\nproc cross(a,b:Point):Real = a.re * b.im - a.im * b.re\nproc dot(a,b:Point):Real = a.re * b.re + a.im * b.im\n\nproc norm(a:Point):Real = dot(a,a)\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nproc ccw(a, b, c: Point):int =\n  var\n    b = b - a\n    c = c - a\n  if cross(b, c) > 0.Real: return +1  # \"COUNTER_CLOCKWISE\"\n  if cross(b, c) < -0.Real: return -1 # \"CLOCKWISE\"\n  if dot(b, c) < 0: return +2      # \"ONLINE_BACK\" c-a-b\n  if norm(b) < norm(c): return -2  # \"ONLINE_FRONT\" a-b-c\n  return 0                         # \"ON_SEGMENT\" a-c-b\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nproc parallel(a,b:Line):bool = cross(a.b - a.a, b.b - b.a) == 0.Real\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nproc orthogonal(a,b:Line):bool = dot(a.a - a.b, b.a - b.b) == 0.Real\n\n# projection reflection {{{\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nproc projection(p:Point, l:Line):Point =\n  let t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b)\n  return l.a + (l.a - l.b) * complex(t)\nproc projection(p:Point, l:Segment):Point =\n  let t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b)\n  return l.a + (l.a - l.b) * complex(t)\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nproc reflection(p:Point, l:Line):Point = return p + (p.projection(l) - p) * complex(2.0)\n# }}}\n\n# intersect function {{{\nproc intersect(l:Line, p:Point):bool = abs(ccw(l.a, l.b, p)) != 1\nproc intersect(l,m: Line):bool = abs(cross(l.b - l.a, m.b - m.a)) > 0.Real or abs(cross(l.b - l.a, m.b - l.a)) < 0.Real\n\nproc intersect(s:Segment, p:Point):bool =\n  ccw(s.a, s.b, p) == 0\nproc intersect(l:Line, s:Segment):bool =\n  cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < 0.Real\n\nproc distance(l:Line, p:Point):Real\nproc intersect(c:Circle, l:Line):bool = distance(l, c.p) <= c.r\n\nproc intersect(c:Circle, p:Point): bool = abs(abs(p - c.p) - c.r) < 0.Real\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nproc intersect(s, t: Segment):bool =\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 and ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0\n\nproc intersect(c:Circle, l:Segment):int =\n  if norm(c.p.projection(l) - c.p) - c.r * c.r > 0.Real: return 0\n  let\n    d1 = abs(c.p - l.a)\n    d2 = abs(c.p - l.b)\n  if d1 <= c.r and d2 <= c.r: return 0\n  if d1 < c.r and d2 > c.r or d1 > c.r and d2 < c.r: return 1\n  let h:Point = c.p.projection(l)\n  if dot(l.a - h, l.b - h) < 0: return 2\n  return 0\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A\n# number of common tangent\nproc intersect(c1, c2: Circle):int =\n  var (c1, c2) = (c1, c2)\n  if c1.r < c2.r: swap(c1, c2)\n  let d = abs(c1.p - c2.p)\n  if c1.r + c2.r < d: return 4\n  if c1.r + c2.r == d: return 3\n  if c1.r - c2.r < d: return 2\n  if c1.r - c2.r == d: return 1\n  return 0\n# }}}\n\n# distance function {{{\nproc distance(a, b:Point):Real = abs(a - b)\nproc distance(l:Line, p:Point):Real = abs(p - p.projection(l))\nproc distance(l, m: Line):Real = (if intersect(l, m): 0.Real else: distance(l, m.a))\n\nproc distance(s:Segment, p:Point):Real =\n  let r = p.projection(s)\n  if intersect(s, r): return abs(r - p)\n  return min(abs(s.a - p), abs(s.b - p))\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nproc distance(a, b:Segment):Real =\n  if intersect(a, b): return 0\n  return min(min(distance(a, b.a), distance(a, b.b)), min(distance(b, a.a), distance(b, a.b)))\nproc distance(l:Line, s:Segment):Real =\n  if intersect(l, s): return 0\n  return min(distance(l, s.a), distance(l, s.b));\n# }}}\n\n# crosspoint function {{{\nproc crosspoint(l,m:Line):Point =\n  let\n    A = cross(l.b - l.a, m.b - m.a)\n    B = cross(l.b - l.a, l.b - m.a)\n  if abs(A) == 0.Real and abs(B) == 0.Real: return m.a\n  return m.a + (m.b - m.a) * complex(B) / A\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nproc crosspoint(l,m:Segment):Point =\n  return crosspoint(Line(l), Line(m));\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\nproc crosspoint(c:Circle, l:Line):(Point,Point) =\n  let pr = c.p.projection(l)\n  let e = (l.b - l.a) / abs(l.b - l.a)\n  if distance(l, c.p) == c.r: return (pr, pr)\n  let base = sqrt(c.r * c.r - norm(pr - c.p))\n  return (pr - e * complex(base), pr + e * complex(base))\n\nproc crosspoint(c:Circle, l:Segment):(Point,Point) =\n  let\n    aa = cast[Line](l)\n  if intersect(c, l) == 2: return crosspoint(c, aa)\n  result = crosspoint(c, aa)\n  if dot(l.a - result[0], l.b - result[0]) < 0: result[1] = result[0]\n  else: result[0] = result[1]\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\nproc crosspoint(c1, c2: Circle):(Point,Point) =\n  let\n    d = abs(c1.p - c2.p)\n    a = arccos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d))\n    t = arctan2(c2.p.im - c1.p.im, c2.p.re - c1.p.re)\n  return (c1.p + initPoint(cos(t + a) * c1.r, sin(t + a) * c1.r),\n          c1.p + initPoint(cos(t - a) * c1.r, sin(t - a) * c1.r))\n# }}}\n\nproc main() =\n  p := newSeq[Point]()\n  for i in 0..<N:p.add(initPoint(x[i].float, y[i].float))\n  ans := initMint(2)^N\n  ans -= 1\n  ans -= N\n  for i in 0..<N:\n    for j in i+1..<N:\n      var valid = true\n      for k in 0..<j:\n        if k == i: continue\n        if cross(p[j] - p[i], p[k] - p[i]) == 0.0: valid = false\n      if not valid: continue\n      ct := 2\n      for k in j+1..<N:\n        if cross(p[j] - p[i], p[k] - p[i]) == 0.0: ct += 1\n#      echo i, \" \", j, \" \", ct\n      ans -= initMint(2)^ct - 1 - ct\n  print ans\n  return\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "import sequtils,strutils\n\nproc powInt(n : int64, m : int64, k = 998_244_353):int64 =\n    if m == 0:\n        return 1\n    elif m == 1:\n        return (n mod k)\n    if (m mod 2) == 0:\n        return powInt((n * n) mod k,m div 2, k) mod k\n    else:\n        return (powInt((n * n) mod k,m div 2, k) * n) mod k\n\nconst\n    Max_num = 2_000_003\n    m : int64 = 998_244_353\n\nvar\n    kaizyou : array[Max_num + 1, int64]\n    gyakuKaizyou : array[Max_num + 1, int64]\nkaizyou[0] = 1\n\nfor i in 1..Max_num:\n    kaizyou[i] = ((kaizyou[i - 1] * i.int64) mod m)\ngyakuKaizyou[Max_num] = powInt(kaizyou[Max_num], 998_244_351, 998_244_353)\n\nfor i in countdown(Max_num - 1,0):\n    gyakuKaizyou[i] = (gyakuKaizyou[i + 1] * (i + 1)) mod m\n\nproc combination(n : int64, k : int64): int64 =\n    if n < k:\n        return 0\n    if n == k:\n        return 1\n    return (((kaizyou[n] * gyakuKaizyou[n - k]) mod m) * gyakuKaizyou[k]) mod m\n\ntype\n    node = tuple[x, y : int]\n\nvar\n    N = stdin.readline.parseInt\n    x,y : int\n    ans : int64\n    nodes = newSeq[node](N)\n    flag : array[201, bool]\n\nans = powInt(2, N.int64) - 1 - N.int64 - ((N - 1) * N div 2).int64\necho ans\nans = (ans + m) mod m\n\nproc line(a, b, c, x, y : int) : bool =\n    if a * x + b * y + c == 0:\n        return true\n    else:\n        return false\n\n\nfor n in 0..<N:\n    (x, y) = stdin.readline.split.map(parseInt)\n    nodes[n] = (x, y)\n\nfor i in 0..<N:\n    if flag[i]:\n        continue\n    for j in (i + 1)..<N:\n        if flag[j]:\n            continue\n        var\n            cnt : int = 2\n            a = nodes[i].y - nodes[j].y\n            b = nodes[j].x - nodes[i].x\n            c = -(nodes[i].x * a + nodes[i].y * b)\n        for k in (j + 1)..<N:\n            if line(a, b, c, nodes[k].x, nodes[k].y):\n                cnt += 1\n                flag[k] = true\n                \n        if cnt > 2:\n            ans -= powInt(2, cnt.int64)\n            ans += 1 + cnt.int64 + ((cnt - 1) * cnt div 2).int64\n            ans = (ans + m * 20) mod m\n\necho ans\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar x:seq[int]\nvar y:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  x = newSeqWith(N, 0)\n  y = newSeqWith(N, 0)\n  for i in 0..<N:\n    x[i] = nextInt()\n    y[i] = nextInt()\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ complex class\n{.push checks: off, line_dir: off, stack_trace: off, debugger: off.}\n# the user does not want to trace a part of the standard library!\n\nimport math\n\ntype\n  Complex* = object\n    re*, im*: float\n\nproc complex*(re: float; im: float = 0.0): Complex =\n  result.re = re\n  result.im = im\n\ntemplate im*(arg: typedesc[float]): Complex = complex(0, 1)\ntemplate im*(arg: float): Complex = complex(0, arg)\n\nproc abs*(z: Complex): float =\n  ## Return the distance from (0,0) to ``z``.\n  result = hypot(z.re, z.im)\n\nproc abs2*(z: Complex): float =\n  ## Return the squared distance from (0,0) to ``z``.\n  result = z.re*z.re + z.im*z.im\n\nproc conjugate*(z: Complex): Complex =\n  ## Conjugate of complex number ``z``.\n  result.re = z.re\n  result.im = -z.im\n\nproc `==` *(x, y: Complex): bool =\n  ## Compare two complex numbers ``x`` and ``y`` for equality.\n  result = x.re == y.re and x.im == y.im\n\n#proc `+` *(x: float; y: Complex): Complex =\n#  ## Add a real number to a complex number.\n#  result.re = x + y.re\n#  result.im = y.im\n\nproc `+` *(x: Complex; y: float): Complex =\n  ## Add a complex number to a real number.\n  result.re = x.re + y\n  result.im = x.im\n\nproc `+` *(x, y: Complex): Complex =\n  ## Add two complex numbers.\n  result.re = x.re + y.re\n  result.im = x.im + y.im\n\nproc `-` *(z: Complex): Complex =\n  ## Unary minus for complex numbers.\n  result.re = -z.re\n  result.im = -z.im\n\n#proc `-` *(x: float; y: Complex): Complex =\n#  ## Subtract a complex number from a real number.\n#  x + (-y)\n\nproc `-` *(x: Complex; y: float): Complex =\n  ## Subtract a real number from a complex number.\n  result.re = x.re - y\n  result.im = x.im\n\nproc `-` *(x, y: Complex): Complex =\n  ## Subtract two complex numbers.\n  result.re = x.re - y.re\n  result.im = x.im - y.im\n\nproc `*` *(x, y: Complex): Complex =\n  ## Multiply ``x`` with ``y``.\n  result.re = x.re * y.re - x.im * y.im\n  result.im = x.im * y.re + x.re * y.im\n\n#proc `*` *(x: float; y: Complex): Complex =\n#  ## Multiply a real number and a complex number.\n#  result.re = x * y.re\n#  result.im = x * y.im\n\nproc `*` *(x: Complex; y: float): Complex =\n  ## Multiply a complex number with a real number.\n  result.re = x.re * y\n  result.im = x.im * y\n\nproc `/` *(x: Complex; y: float): Complex =\n  ## Divide complex number ``x`` by real number ``y``.\n  result.re = x.re / y\n  result.im = x.im / y\n\nproc inv*(z: Complex): Complex =\n  ## Multiplicative inverse of complex number ``z``.\n  conjugate(z) / abs2(z)\n\n#proc `/` *(x: float; y: Complex): Complex =\n#  ## Divide real number ``x`` by complex number ``y``.\n#  result = x * inv(y)\n\nproc `/` *(x, y: Complex): Complex =\n  ## Divide ``x`` by ``y``.\n  var r, den: float\n  if abs(y.re) < abs(y.im):\n    r = y.re / y.im\n    den = y.im + r * y.re\n    result.re = (x.re * r + x.im) / den\n    result.im = (x.im * r - x.re) / den\n  else:\n    r = y.im / y.re\n    den = y.re + r * y.im\n    result.re = (x.re + r * x.im) / den\n    result.im = (x.im - r * x.re) / den\n\nproc `+=` *(x: var Complex; y: Complex) =\n  ## Add ``y`` to ``x``.\n  x.re += y.re\n  x.im += y.im\n\nproc `-=` *(x: var Complex; y: Complex) =\n  ## Subtract ``y`` from ``x``.\n  x.re -= y.re\n  x.im -= y.im\n\nproc `*=` *(x: var Complex; y: Complex) =\n  ## Multiply ``y`` to ``x``.\n  let im = x.im * y.re + x.re * y.im\n  x.re = x.re * y.re - x.im * y.im\n  x.im = im\n\nproc `/=` *(x: var Complex; y: Complex) =\n  ## Divide ``x`` by ``y`` in place.\n  x = x / y\n\n\nproc sqrt*(z: Complex): Complex =\n  ## Square root for a complex number ``z``.\n  var x, y, w, r: float\n\n  if z.re == 0.0 and z.im == 0.0:\n    result = z\n  else:\n    x = abs(z.re)\n    y = abs(z.im)\n    if x >= y:\n      r = y / x\n      w = sqrt(x) * sqrt(0.5 * (1.0 + sqrt(1.0 + r * r)))\n    else:\n      r = x / y\n      w = sqrt(y) * sqrt(0.5 * (r + sqrt(1.0 + r * r)))\n\n    if z.re >= 0.0:\n      result.re = w\n      result.im = z.im / (w * 2.0)\n    else:\n      result.im = if z.im >= 0.0: w else: -w\n      result.re = z.im / (result.im + result.im)\n\nproc exp*(z: Complex): Complex =\n  ## ``e`` raised to the power ``z``.\n  var\n    rho = exp(z.re)\n    theta = z.im\n  result.re = rho * cos(theta)\n  result.im = rho * sin(theta)\n\nproc ln*(z: Complex): Complex =\n  ## Returns the natural log of ``z``.\n  result.re = ln(abs(z))\n  result.im = arctan2(z.im, z.re)\n\nproc log10*(z: Complex): Complex =\n  ## Returns the log base 10 of ``z``.\n  result = ln(z) / ln(10.0)\n\nproc log2*(z: Complex): Complex =\n  ## Returns the log base 2 of ``z``.\n  result = ln(z) / ln(2.0)\n\nproc pow*(x, y: Complex): Complex =\n  ## ``x`` raised to the power ``y``.\n  if x.re == 0.0 and x.im == 0.0:\n    if y.re == 0.0 and y.im == 0.0:\n      result.re = 1.0\n      result.im = 0.0\n    else:\n      result.re = 0.0\n      result.im = 0.0\n  elif y.re == 1.0 and y.im == 0.0:\n    result = x\n  elif y.re == -1.0 and y.im == 0.0:\n    result = complex(1.0) / x\n  else:\n    var\n      rho = abs(x)\n      theta = arctan2(x.im, x.re)\n      s = pow(rho, y.re) * exp(-y.im * theta)\n      r = y.re * theta + y.im * ln(rho)\n    result.re = s * cos(r)\n    result.im = s * sin(r)\n\nproc pow*(x: Complex; y: float): Complex =\n  ## Complex number ``x`` raised to the power ``y``.\n  pow(x, complex(y))\n\n\nproc sin*(z: Complex): Complex =\n  ## Returns the sine of ``z``.\n  result.re = sin(z.re) * cosh(z.im)\n  result.im = cos(z.re) * sinh(z.im)\n\nproc arcsin*(z: Complex): Complex =\n  ## Returns the inverse sine of ``z``.\n  result = -im(float) * ln(im(float) * z + sqrt(complex(1.0) - z*z))\n\nproc cos*(z: Complex): Complex =\n  ## Returns the cosine of ``z``.\n  result.re = cos(z.re) * cosh(z.im)\n  result.im = -sin(z.re) * sinh(z.im)\n\nproc arccos*(z: Complex): Complex =\n  ## Returns the inverse cosine of ``z``.\n  result = -im(float) * ln(z + sqrt(z*z - float(1.0)))\n\nproc tan*(z: Complex): Complex =\n  ## Returns the tangent of ``z``.\n  result = sin(z) / cos(z)\n\nproc arctan*(z: Complex): Complex =\n  ## Returns the inverse tangent of ``z``.\n  result = complex(0.5)*im(float) * (ln(complex(1.0) - im(float)*z) - ln(complex(1.0) + im(float)*z))\n\nproc cot*(z: Complex): Complex =\n  ## Returns the cotangent of ``z``.\n  result = cos(z)/sin(z)\n\nproc arccot*(z: Complex): Complex =\n  ## Returns the inverse cotangent of ``z``.\n  result = complex(0.5)*im(float) * (ln(complex(1.0) - im(float)/z) - ln(complex(1.0) + im(float)/z))\n\nproc sec*(z: Complex): Complex =\n  ## Returns the secant of ``z``.\n  result = complex(1.0) / cos(z)\n\nproc arcsec*(z: Complex): Complex =\n  ## Returns the inverse secant of ``z``.\n  result = -im(float) * ln(im(float) * sqrt(complex(1.0) - complex(1.0)/(z*z)) + complex(1.0)/z)\n\nproc csc*(z: Complex): Complex =\n  ## Returns the cosecant of ``z``.\n  result = complex(1.0) / sin(z)\n\nproc arccsc*(z: Complex): Complex =\n  ## Returns the inverse cosecant of ``z``.\n  result = -im(float) * ln(sqrt(complex(1.0) - complex(1.0)/(z*z)) + im(float)/z)\n\nproc sinh*(z: Complex): Complex =\n  ## Returns the hyperbolic sine of ``z``.\n  result = complex(0.5) * (exp(z) - exp(-z))\n\nproc arcsinh*(z: Complex): Complex =\n  ## Returns the inverse hyperbolic sine of ``z``.\n  result = ln(z + sqrt(z*z + 1.0))\n\nproc cosh*(z: Complex): Complex =\n  ## Returns the hyperbolic cosine of ``z``.\n  result = complex(0.5) * (exp(z) + exp(-z))\n\nproc arccosh*(z: Complex): Complex =\n  ## Returns the inverse hyperbolic cosine of ``z``.\n  result = ln(z + sqrt(z*z - float(1.0)))\n\nproc tanh*(z: Complex): Complex =\n  ## Returns the hyperbolic tangent of ``z``.\n  result = sinh(z) / cosh(z)\n\nproc arctanh*(z: Complex): Complex =\n  ## Returns the inverse hyperbolic tangent of ``z``.\n  result = complex(0.5) * (ln((complex(1.0)+z) / (complex(1.0)-z)))\n\nproc sech*(z: Complex): Complex =\n  ## Returns the hyperbolic secant of ``z``.\n  result = complex(2.0) / (exp(z) + exp(-z))\n\nproc arcsech*(z: Complex): Complex =\n  ## Returns the inverse hyperbolic secant of ``z``.\n  result = ln(1.0.complex/z + sqrt(complex(1.0)/z+float(1.0)) * sqrt(complex(1.0)/z-float(1.0)))\n\nproc csch*(z: Complex): Complex =\n  ## Returns the hyperbolic cosecant of ``z``.\n  result = complex(2.0) / (exp(z) - exp(-z))\n\nproc arccsch*(z: Complex): Complex =\n  ## Returns the inverse hyperbolic cosecant of ``z``.\n  result = ln(complex(1.0)/z + sqrt(complex(1.0)/(z*z) + float(1.0)))\n\nproc coth*(z: Complex): Complex =\n  ## Returns the hyperbolic cotangent of ``z``.\n  result = cosh(z) / sinh(z)\n\nproc arccoth*(z: Complex): Complex =\n  ## Returns the inverse hyperbolic cotangent of ``z``.\n  result = complex(0.5) * (ln(complex(1.0) + complex(1.0)/z) - ln(complex(1.0) - complex(1.0)/z))\n\nproc phase*(z: Complex): float =\n  ## Returns the phase of ``z``.\n  arctan2(z.im, z.re)\n\nproc polar*(z: Complex): tuple[r, phi: float] =\n  ## Returns ``z`` in polar coordinates.\n  (r: abs(z), phi: phase(z))\n\nproc rect*(r, phi: float): Complex =\n  ## Returns the complex number with polar coordinates ``r`` and ``phi``.\n  ##\n  ## | ``result.re = r * cos(phi)``\n  ## | ``result.im = r * sin(phi)``\n  complex(r * cos(phi), r * sin(phi))\n\n\nproc `$`*(z: Complex): string =\n  ## Returns ``z``'s string representation as ``\"(re, im)\"``.\n  result = \"(\" & $z.re & \", \" & $z.im & \")\"\n\n{.pop.}\n#}}}\n\nimport sets, sequtils\nimport sugar\n\ntype\n  Real = float\n#  Point = Complex[float]\n  Point = Complex\n\nproc initPoint(re:float, im:float):Point = Point(re:re, im:im)\nproc nextPoint():Point = return initPoint(nextFloat(), nextFloat())\n\nproc `*`(p:Point, d:Real):Point =\n  return Point(re:p.re * d, im:p.im * d)\n\nproc toString(p:Point):string = $(p.re) & \" \" & $(p.im)\n\n# rotate point p counterclockwise by theta rad\nproc rotate(theta:Real, p:Point):Point =\n  return initPoint(cos(theta) * p.re - sin(theta) * p.im, sin(theta) * p.re + cos(theta) * p.im)\n\nproc radianToDegree(r:Real):Real = r * 180.Real / PI\nproc degreeToRadian(d:Real):Real = d * PI / 180.Real\n\n# smaller angle of the a-b-c\nproc getAngle(a,b,c:Point):Real =\n  let\n    v = b - a\n    w = c - b\n  var\n    alpha = arctan2(v.im, v.re)\n    beta = arctan2(w.im, w.re)\n  if alpha > beta: swap(alpha, beta)\n  let theta = beta - alpha\n  return min(theta, 2.Real * PI - theta)\n\n# float comp {{{\nconst EPS = 1e-9\n\nproc `==`(a,b:float):bool = system.`<`(abs(a - b), EPS)\nproc `!=`(a,b:float):bool = system.`>`(abs(a - b), EPS)\nproc `<`(a,b:float):bool = system.`<`(a + EPS, b)\nproc `>`(a,b:float):bool = system.`>`(a, b + EPS)\nproc `<=`(a,b:float):bool = system.`<`(a, b + EPS)\nproc `>=`(a,b:float):bool = system.`>`(a + EPS, b)\n# }}}\n\n# comparison functions {{{\n#proc eq(a,b:Real):bool = return abs(b - a) < EPS\nproc `==`(a,b:Point):bool =\n  return a.re == b.re and a.im == b.im\n#  return system.`<`(abs(b - a), EPS)\nproc `<`(a,b:Point):bool =\n  if a.re != b.re: return a.re < b.re\n  elif a.im != b.im: return a.im < b.im\n  return false\nproc `<=`(a,b:Point):bool =\n  if a.re != b.re: return a.re < b.re\n  elif a.im != b.im: return a.im < b.im\n  return true\n# }}}\n\n# Line and Segment {{{\ntype Line = object\n  a, b:Point\n\ntype Segment {.borrow: `.`.} = distinct Line\n\nproc initLine(a,b:Point):Line = Line(a:a, b:b)\nproc initLine(A, B, C:Real):Line = # Ax + By = C\n  var a, b: Point\n  if A == 0.Real: a = initPoint(0.Real, C / B); b = initPoint(1.Real, C / B)\n  elif B == 0.Real: b = initPoint(C / A, 0.Real); b = initPoint(C / A, 1.Real)\n  else: a = initPoint(0.Real, C / B); b = initPoint(C / A, 0.Real)\n  return initLine(a, b)\n\nproc `$`(p:Line):string =\n  return(p.a.toString & \" to \" & p.b.toString)\nproc nextLine():Line = initLine(nextPoint(), nextPoint())\n\nproc initSegment(a, b:Point):Segment = Segment(Line(a:a, b:b))\nproc nextSegment():Segment = initSegment(nextPoint(), nextPoint())\n# }}}\n\n# Circle {{{\ntype Circle = object\n  p:Point\n  r:Real\n\nproc initCircle(p:Point, r:Real):Circle = Circle(p:p, r:r)\n# }}}\n\nproc cross(a,b:Point):Real = a.re * b.im - a.im * b.re\nproc dot(a,b:Point):Real = a.re * b.re + a.im * b.im\n\nproc norm(a:Point):Real = dot(a,a)\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nproc ccw(a, b, c: Point):int =\n  var\n    b = b - a\n    c = c - a\n  if cross(b, c) > 0.Real: return +1  # \"COUNTER_CLOCKWISE\"\n  if cross(b, c) < -0.Real: return -1 # \"CLOCKWISE\"\n  if dot(b, c) < 0: return +2      # \"ONLINE_BACK\" c-a-b\n  if norm(b) < norm(c): return -2  # \"ONLINE_FRONT\" a-b-c\n  return 0                         # \"ON_SEGMENT\" a-c-b\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nproc parallel(a,b:Line):bool = cross(a.b - a.a, b.b - b.a) == 0.Real\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nproc orthogonal(a,b:Line):bool = dot(a.a - a.b, b.a - b.b) == 0.Real\n\n# projection reflection {{{\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nproc projection(p:Point, l:Line):Point =\n  let t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b)\n  return l.a + (l.a - l.b) * complex(t)\nproc projection(p:Point, l:Segment):Point =\n  let t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b)\n  return l.a + (l.a - l.b) * complex(t)\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nproc reflection(p:Point, l:Line):Point = return p + (p.projection(l) - p) * complex(2.0)\n# }}}\n\n# intersect function {{{\nproc intersect(l:Line, p:Point):bool = abs(ccw(l.a, l.b, p)) != 1\nproc intersect(l,m: Line):bool = abs(cross(l.b - l.a, m.b - m.a)) > 0.Real or abs(cross(l.b - l.a, m.b - l.a)) < 0.Real\n\nproc intersect(s:Segment, p:Point):bool =\n  ccw(s.a, s.b, p) == 0\nproc intersect(l:Line, s:Segment):bool =\n  cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < 0.Real\n\nproc distance(l:Line, p:Point):Real\nproc intersect(c:Circle, l:Line):bool = distance(l, c.p) <= c.r\n\nproc intersect(c:Circle, p:Point): bool = abs(abs(p - c.p) - c.r) < 0.Real\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nproc intersect(s, t: Segment):bool =\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 and ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0\n\nproc intersect(c:Circle, l:Segment):int =\n  if norm(c.p.projection(l) - c.p) - c.r * c.r > 0.Real: return 0\n  let\n    d1 = abs(c.p - l.a)\n    d2 = abs(c.p - l.b)\n  if d1 <= c.r and d2 <= c.r: return 0\n  if d1 < c.r and d2 > c.r or d1 > c.r and d2 < c.r: return 1\n  let h:Point = c.p.projection(l)\n  if dot(l.a - h, l.b - h) < 0: return 2\n  return 0\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A\n# number of common tangent\nproc intersect(c1, c2: Circle):int =\n  var (c1, c2) = (c1, c2)\n  if c1.r < c2.r: swap(c1, c2)\n  let d = abs(c1.p - c2.p)\n  if c1.r + c2.r < d: return 4\n  if c1.r + c2.r == d: return 3\n  if c1.r - c2.r < d: return 2\n  if c1.r - c2.r == d: return 1\n  return 0\n# }}}\n\n# distance function {{{\nproc distance(a, b:Point):Real = abs(a - b)\nproc distance(l:Line, p:Point):Real = abs(p - p.projection(l))\nproc distance(l, m: Line):Real = (if intersect(l, m): 0.Real else: distance(l, m.a))\n\nproc distance(s:Segment, p:Point):Real =\n  let r = p.projection(s)\n  if intersect(s, r): return abs(r - p)\n  return min(abs(s.a - p), abs(s.b - p))\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nproc distance(a, b:Segment):Real =\n  if intersect(a, b): return 0\n  return min(min(distance(a, b.a), distance(a, b.b)), min(distance(b, a.a), distance(b, a.b)))\nproc distance(l:Line, s:Segment):Real =\n  if intersect(l, s): return 0\n  return min(distance(l, s.a), distance(l, s.b));\n# }}}\n\n# crosspoint function {{{\nproc crosspoint(l,m:Line):Point =\n  let\n    A = cross(l.b - l.a, m.b - m.a)\n    B = cross(l.b - l.a, l.b - m.a)\n  if abs(A) == 0.Real and abs(B) == 0.Real: return m.a\n  return m.a + (m.b - m.a) * complex(B) / A\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nproc crosspoint(l,m:Segment):Point =\n  return crosspoint(Line(l), Line(m));\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\nproc crosspoint(c:Circle, l:Line):(Point,Point) =\n  let pr = c.p.projection(l)\n  let e = (l.b - l.a) / abs(l.b - l.a)\n  if distance(l, c.p) == c.r: return (pr, pr)\n  let base = sqrt(c.r * c.r - norm(pr - c.p))\n  return (pr - e * complex(base), pr + e * complex(base))\n\nproc crosspoint(c:Circle, l:Segment):(Point,Point) =\n  let\n    aa = cast[Line](l)\n  if intersect(c, l) == 2: return crosspoint(c, aa)\n  result = crosspoint(c, aa)\n  if dot(l.a - result[0], l.b - result[0]) < 0: result[1] = result[0]\n  else: result[0] = result[1]\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\nproc crosspoint(c1, c2: Circle):(Point,Point) =\n  let\n    d = abs(c1.p - c2.p)\n    a = arccos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d))\n    t = arctan2(c2.p.im - c1.p.im, c2.p.re - c1.p.re)\n  return (c1.p + initPoint(cos(t + a) * c1.r, sin(t + a) * c1.r),\n          c1.p + initPoint(cos(t - a) * c1.r, sin(t - a) * c1.r))\n# }}}\n\nproc main() =\n  p := newSeq[Point]()\n  for i in 0..<N:p.add(initPoint(x[i].float, y[i].float))\n  ans := initMint(2)^N\n  ans -= 1\n  ans -= N\n  for i in 0..<N:\n    for j in i+1..<N:\n      var valid = true\n      for k in 0..<j:\n        if k == i: continue\n        if cross(p[j] - p[i], p[k] - p[i]) == 0.0: valid = false\n      if not valid: continue\n      ct := 2\n      for k in j+1..<N:\n        if cross(p[j] - p[i], p[k] - p[i]) == 0.0: ct += 1\n#      echo i, \" \", j, \" \", ct\n      ans -= initMint(2)^ct - 1 - ct\n  print ans\n  return\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nwhen not defined(release):\n  addHandler(newFileLogger(stderr, lvlAll, \"[ $levelname ] \"))\n\nproc readInt1*(): int = stdin.readLine().strip().parseInt()\nproc readInt2*(): (int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1])\nproc readInt3*(): (int, int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1], v[2])\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\n#------------------------------------------------------------------------------#\nconst MOD = int(998244353)\n\ntype Op1[T] = proc(a: T, b: T): T\ntype Op2[T] = proc(a: T, b: T): T\n\nproc repeatedSquares[T](x: T, n: Natural, e: T, f: Op2[T]): T =\n    result = e\n    var xx = f(x, e)\n    var i = n\n    while i > 0:\n        if (i and 1) != 0:\n            result = f(result, xx)\n        xx = f(xx, xx)\n        i = i shr 1\n\n\nproc addM(a, b: Natural): Natural = (a + b) mod MOD\nproc subM(a, b: Natural): Natural = (a - b + MOD) mod MOD\nproc mulM(a, b: Natural): Natural = a * b mod MOD\nproc powM(a, b: Natural): Natural = repeatedSquares[Natural](a, b, 1, `mulM`)\nproc invM(a: Natural): Natural = a.powM(MOD - 2)\nproc divM(a, b: Natural): Natural = a.mulM(invM(b))\n\n\nvar memoFactM = @[Natural(1)]\nproc factM(n: Natural): Natural =\n    if n < memoFactM.len():\n        return memoFactM[n]\n    for i in memoFactM.len()..n:\n        memoFactM.add(memoFactM[i - 1].mulM(i))\n    return memoFactM[n]\n\n\nproc combM(n, r: Natural): Natural =\n    if r > n:\n        return 0\n    if r > n div 2:\n        return combM(n, n - r)\n\n    result = 1\n    for i in ((n - r) + 1)..n:\n        result = result.mulM(i)\n    result = result.divM(factM(r))\n\n\nproc multCombM(n, r: Natural): Natural = combM(n + r - 1, n - 1)\n\n#------------------------------------------------------------------------------#\n\n\n# ax + by + c = 0\ntype Line = tuple [ a, b, c: int ]\ntype Point = tuple [ y, x: int ]\n\nproc `$`(p: Point): string = \"(\" & $p.y & \", \" & $p.x & \")\"\n\nproc on(pp: Point; ll: Line): bool =\n  ll.a * pp.x + ll.b * pp.y + ll.c == 0\n\n\nproc normalizeLine(ll: Line): Line =\n  let d = gcd(abs(ll.a), gcd(abs(ll.b), abs(ll.c)))\n  let (a, b, c) = (ll.a div d, ll.b div d, ll.c div d)\n  if ll.a == 0:\n    return if ll.b >= 0: (a, b, c) else: (-a, -b, -c)\n  if ll.b == 0:\n    return if ll.a >= 0: (a, b, c) else: (-a, -b, -c)\n  return (a, b, c)\n\nproc calcLine(p1, p2: Point): Line =\n  let ll = (p2.y - p1.y, p1.x - p2.x, -p1.x * p2.y + p1.y * p2.x)\n  return ll.normalizeLine()\n\nproc main() =\n  let n = readInt1()\n  var ps = newSeq[Point](n)\n  for i in 0..<n:\n    let (x, y) = readInt2()\n    ps[i] = (y, x)\n\n  var ls = initTable[Line, seq[Point]]()\n  for i in 0..<n:\n    for j in (i + 1)..<n:\n      let ll = calcLine(ps[i], ps[j])\n      if ll notin ls:\n        ls[ll] = @[]\n\n  for ll in ls.keys():\n    for i in 0..<n:\n      if ps[i].on(ll):\n        ls[ll].add(ps[i])\n\n  var ans = 2.powM(n)\n  ans = ans.subM(combM(n, 0))\n  ans = ans.subM(combM(n, 1))\n  ans = ans.subM(combM(n, 2))\n\n  for lps in ls.values():\n    let m = lps.len()\n    for i in 3..m:\n      ans = ans.subM(combM(m, i))\n\n  echo ans\n\nmain()\n\n"
  },
  {
    "language": "Nim",
    "code": "import sequtils,strutils\n\nproc powInt(n : int64, m : int64, k = 998_244_353):int64 =\n    if m == 0:\n        return 1\n    elif m == 1:\n        return (n mod k)\n    if (m mod 2) == 0:\n        return powInt((n * n) mod k,m div 2, k) mod k\n    else:\n        return (powInt((n * n) mod k,m div 2, k) * n) mod k\n\nconst\n    Max_num = 2_000_003\n    m : int64 = 998_244_353\n\nvar\n    kaizyou : array[Max_num + 1, int64]\n    gyakuKaizyou : array[Max_num + 1, int64]\nkaizyou[0] = 1\n\nfor i in 1..Max_num:\n    kaizyou[i] = ((kaizyou[i - 1] * i.int64) mod m)\ngyakuKaizyou[Max_num] = powInt(kaizyou[Max_num], 998_244_351, 998_244_353)\n\nfor i in countdown(Max_num - 1,0):\n    gyakuKaizyou[i] = (gyakuKaizyou[i + 1] * (i + 1)) mod m\n\nproc combination(n : int64, k : int64): int64 =\n    if n < k:\n        return 0\n    if n == k:\n        return 1\n    return (((kaizyou[n] * gyakuKaizyou[n - k]) mod m) * gyakuKaizyou[k]) mod m\n\ntype\n    node = tuple[x, y : int]\n\nvar\n    N = stdin.readline.parseInt\n    x,y : int\n    ans : int64\n    nodes = newSeq[node](N)\n    flag : array[201, bool]\n\nans = powInt(2, N.int64) - 1 - N.int64 - ((N - 1) * N div 2).int64\n\nans = (ans + m) mod m\n\nproc line(a, b, c, x, y : int) : bool =\n    if a * x + b * y + c == 0:\n        return true\n    else:\n        return false\n\n\nfor n in 0..<N:\n    (x, y) = stdin.readline.split.map(parseInt)\n    nodes[n] = (x, y)\n\nfor i in 0..<N:\n    for j in (i + 1)..<N:\n        if flag[j] and flag[i]:\n            continue\n        var\n            cnt : int = 2\n            a = nodes[i].y - nodes[j].y\n            b = nodes[j].x - nodes[i].x\n            c = -(nodes[i].x * a + nodes[i].y * b)\n        for k in (j + 1)..<N:\n            if line(a, b, c, nodes[k].x, nodes[k].y):\n                cnt += 1\n                flag[k] = true\n                \n        if cnt > 2:\n            ans -= powInt(2, cnt.int64)\n            ans += 1 + cnt.int64 + ((cnt - 1) * cnt div 2).int64\n            ans = (ans + m * 20) mod m\n\necho ans"
  },
  {
    "language": "Nim",
    "code": "import sequtils,strutils\n\nproc powInt(n : int64, m : int64, k = 998_244_353):int64 =\n    if m == 0:\n        return 1\n    elif m == 1:\n        return (n mod k)\n    if (m mod 2) == 0:\n        return powInt((n * n) mod k,m div 2, k) mod k\n    else:\n        return (powInt((n * n) mod k,m div 2, k) * n) mod k\n\nconst\n    Max_num = 2_000_003\n    m : int64 = 998_244_353\n\nvar\n    kaizyou : array[Max_num + 1, int64]\n    gyakuKaizyou : array[Max_num + 1, int64]\nkaizyou[0] = 1\n\nfor i in 1..Max_num:\n    kaizyou[i] = ((kaizyou[i - 1] * i.int64) mod m)\ngyakuKaizyou[Max_num] = powInt(kaizyou[Max_num], 998_244_351, 998_244_353)\n\nfor i in countdown(Max_num - 1,0):\n    gyakuKaizyou[i] = (gyakuKaizyou[i + 1] * (i + 1)) mod m\n\nproc combination(n : int64, k : int64): int64 =\n    if n < k:\n        return 0\n    if n == k:\n        return 1\n    return (((kaizyou[n] * gyakuKaizyou[n - k]) mod m) * gyakuKaizyou[k]) mod m\n\ntype\n    node = tuple[x, y : int]\n\nvar\n    N = stdin.readline.parseInt\n    x,y : int\n    ans : int64\n    nodes = newSeq[node](N)\n\nans = powInt(2, N.int64) - 1 - N.int64 - ((N - 1) * N div 2).int64\n\nans = (ans + m) mod m\n\nproc line(a, b, c, x, y : int) : bool =\n    if a * x + b * y + c == 0:\n        return true\n    else:\n        return false\n\n\nfor n in 0..<N:\n    (x, y) = stdin.readline.split.map(parseInt)\n    nodes[n] = (x, y)\n\nfor i in 0..<N:\n    for j in (i + 1)..<N:\n        var\n            cnt : int\n            a = nodes[i].y - nodes[j].y\n            b = nodes[j].x - nodes[i].x\n            c = -(nodes[i].x * a + nodes[i].y * b)\n        for k in (j + 1)..<N:\n            if line(a, b, c, nodes[k].x, nodes[k].y):\n                cnt += 1\n                \n        if cnt > 0:\n            ans -= powInt(2, cnt.int64)\n            ans += 1\n            ans = (ans + m) mod m\n\necho ans"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nwhen not defined(release):\n  addHandler(newFileLogger(stderr, lvlAll, \"[ $levelname ] \"))\n\nproc readInt1*(): int = stdin.readLine().strip().parseInt()\nproc readInt2*(): (int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1])\nproc readInt3*(): (int, int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1], v[2])\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\n#------------------------------------------------------------------------------#\nconst MOD = int(998244353)\n\ntype Op1[T] = proc(a: T, b: T): T\ntype Op2[T] = proc(a: T, b: T): T\n\nproc repeatedSquares[T](x: T, n: Natural, e: T, f: Op2[T]): T =\n    result = e\n    var xx = f(x, e)\n    var i = n\n    while i > 0:\n        if (i and 1) != 0:\n            result = f(result, xx)\n        xx = f(xx, xx)\n        i = i shr 1\n\n\nproc addM(a, b: Natural): Natural = (a + b) mod MOD\nproc subM(a, b: Natural): Natural = (a - b + MOD) mod MOD\nproc mulM(a, b: Natural): Natural = a * b mod MOD\nproc powM(a, b: Natural): Natural = repeatedSquares[Natural](a, b, 1, `mulM`)\nproc invM(a: Natural): Natural = a.powM(MOD - 2)\nproc divM(a, b: Natural): Natural = a.mulM(invM(b))\n\n\nvar memoFactM = @[Natural(1)]\nproc factM(n: Natural): Natural =\n    if n < memoFactM.len():\n        return memoFactM[n]\n    for i in memoFactM.len()..n:\n        memoFactM.add(memoFactM[i - 1].mulM(i))\n    return memoFactM[n]\n\n\nproc combM(n, r: Natural): Natural =\n    if r > n:\n        return 0\n    if r > n div 2:\n        return combM(n, n - r)\n\n    result = 1\n    for i in ((n - r) + 1)..n:\n        result = result.mulM(i)\n    result = result.divM(factM(r))\n\n\nproc multCombM(n, r: Natural): Natural = combM(n + r - 1, n - 1)\n\n#------------------------------------------------------------------------------#\n\n\n# ax + by + c = 0\ntype Line = tuple [ a, b, c: int ]\ntype Point = tuple [ y, x: int ]\n\nproc `$`(p: Point): string = \"(\" & $p.y & \", \" & $p.x & \")\"\n\nproc on(pp: Point; ll: Line): bool =\n  ll.a * pp.x + ll.b * pp.y + ll.c == 0\n\n\nproc normalizeLine(ll: Line): Line =\n  let d = gcd(abs(ll.a), gcd(abs(ll.b), abs(ll.c)))\n  result = (ll.a div d, ll.b div d, ll.c div d)\n  debug \"normalize\"\n  debug ll\n  debug result\n\nproc calcLine(p1, p2: Point): Line =\n  let ll = (p2.y - p1.y, p1.x - p2.x, -p1.x * p2.y + p1.y * p2.x)\n  return ll.normalizeLine()\n\nproc main() =\n  let n = readInt1()\n  var ps = newSeq[Point](n)\n  for i in 0..<n:\n    let (x, y) = readInt2()\n    ps[i] = (y, x)\n\n  var ls = initTable[Line, seq[Point]]()\n  for i in 0..<n:\n    for j in (i + 1)..<n:\n      let ll = calcLine(ps[i], ps[j])\n      if ll notin ls:\n        ls[ll] = @[]\n\n  for ll in ls.keys():\n    for i in 0..<n:\n      if ps[i].on(ll):\n        ls[ll].add(ps[i])\n\n  var ans = 2.powM(n)\n  ans = ans.subM(combM(n, 0))\n  ans = ans.subM(combM(n, 1))\n  ans = ans.subM(combM(n, 2))\n\n  for lps in ls.values():\n    let m = lps.len()\n    for i in 3..m:\n      ans = ans.subM(combM(m, i))\n\n  echo ans\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\ndef main():\n\n    N = int(input())\n    points = []\n    for i in range(N):\n        points.append(list(map(int, input().split())))\n\n    x = [p[0] for p in points]\n    y = [p[1] for p in points]\n\n    M = 998244353\n\n    c = 1 + N + N * (N - 1) // 2\n    for i in range(N):\n        xi = x[i]\n        yi = y[i]\n        dx = [xj - xi for xj in x]\n        dy = [yj - yi for yj in y]\n\n        for j in range(i + 1, N):\n            xj = dx[j]\n            yj = dy[j]\n            cc = 1\n            for k in range(j + 1, N):\n                if xj * dy[k] - dx[k] * yj == 0:\n                    cc *= 2\n                    cc %= M\n            c += cc - 1\n\n    r = 1\n    for i in range(N):\n        r *= 2\n        r %= M\n\n    r -= c\n    r %= M\n\n    print(r)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from fractions import Fraction\nfrom collections import defaultdict\nfrom itertools import combinations\nclass Combination:\n    \"\"\"\n    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる\n    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)\n    使用例：\n    comb = Combination(1000000)\n    print(comb(5, 3))  # 10\n    \"\"\"\n    def __init__(self, n_max, mod=10**9+7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def make_factorial_list(self, n):\n        # 階乗のリストと階乗のmod逆元のリストを返す O(n)\n        # self.make_modinv_list()が先に実行されている必要がある\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n+1):\n            fac.append(fac[i-1] * i % self.mod)\n            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0からnまでのmod逆元のリストを返す O(n)\n        modinv = [0] * (n+1)\n        modinv[1] = 1\n        for i in range(2, n+1):\n            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod\n        return modinv\n\nN = int(input())\nXY = [list(map(int, input().split())) for i in range(N)]\n\nD = defaultdict(int)\nfor (x1, y1), (x2, y2) in combinations(XY, 2):\n    if x1 != x2:\n        a = Fraction(y2-y1, x2-x1)\n        b = Fraction(y1) - a * Fraction(x1)\n        D[(a, b)] += 1\n    else:\n        D[(None, x1)] += 1\n\nmod = 998244353\ncomb = Combination(N+1, mod)\nA = [0] * (N+1)\ncoA = [0] * (N+1)\nans = 0\nfor i in range(3, N+1):\n    ans += comb(N, i)\n    ans %= mod\nfor i in range(3, N+1):\n    for j in range(i-2):\n        A[i] += (i-2-j)*(1<<j)\n    coA[i] = coA[i-1]+A[i]\nfor (a, b), n in D.items():\n    if n==1:\n        continue\n    n = int((n<<1)**0.5)+1\n    ans -= coA[n]\n    ans %= mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import math\nn = int(input())\ndat = [list(map(int, input().split())) for i in range(n)]\ndic = {}\nmod = 998244353\nmp = [(2**i) % mod for i in range(n + 1)]\nret = (mp[n] - 1 - n * (n + 1) / 2) % mod\nfor i in range(n):\n    for j in range(i):\n        a = 0\n        b = 0\n        if dat[i][0] == dat[j][0]:\n            a = 10**9\n            b = dat[i][0]\n        else:\n            a = (dat[i][1] - dat[j][1]) / (dat[i][0] - dat[j][0])\n            b = dat[i][1] - dat[i][0] * a\n        if (a, b) in dic:\n            dic[(a, b)] += 1\n        else:\n            dic[(a, b)] = 1\nfor v in dic.values():\n    x = int((math.sqrt(8 * v + 1) + 1) / 2)\n    ret = (ret + mod - mp[x] + 1 + x * (x + 1) / 2) % mod\nprint(int(ret))\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nM = 998244353\nN = 0\npoints = []\n\ndef calc(s, ap, dp):\n    global M, N, points\n\n    r = 0\n    s0, si = s[0], s[-1]\n    x0, y0 = points[s0]\n    xi, yi = points[si]\n    for j in ap:\n        if j < s0:\n            continue\n        sc = s.copy()\n        sc.append(j)\n        xj, yj = points[j]\n        apc = []\n        dpc = dp\n\n        for k in ap:\n            if k == j:\n                continue\n            xk, yk = points[k]\n            o1 = (xj - xi) * (yk - yi) - (xk - xi) * (yj - yi)\n            if o1 < 0:\n                continue\n            o2 = (x0 - xj) * (yk - yj) - (xk - xj) * (y0 - yj)\n            if o2 < 0:\n                apc.append(k)\n            else:\n                dpc += 1\n\n        r += 2 ** dpc\n        r %= M\n        if 0 < len(apc):\n            r += calc(sc, apc, dpc)\n            r %= M\n\n    return r\n\n\ndef main():\n    global M, N, points\n\n    N = int(input())\n    for i in range(N):\n        points.append(list(map(int, input().split())))\n\n    r = 0\n    for i in range(N):\n        xi, yi = points[i]\n        for j in range(i + 1, N):\n            xj, yj = points[j]\n            s = [i, j]\n            ap = []\n            for k in range(N):\n                if k == i or k == j:\n                    continue\n                xk, yk = points[k]\n                if 0 < (xj - xi) * (yk - yi) - (xk - xi) * (yj - yi):\n                    ap.append(k)\n            r += calc(s, ap, 0)\n            r %= M\n\n    print(r)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n\n    def same_line(p1, p2, p3):\n        eps = 10**-8\n        c1 = complex(p1[0], p1[1])\n        c2 = complex(p2[0], p2[1])\n        c3 = complex(p3[0], p3[1])\n        d = (c2-c1) / (c3-c1)\n        if abs(d.imag) < eps:\n            return 1\n        else:\n            return 0\n\n    mod = 998244353\n    N = int(input())\n\n    if N <= 2:\n        print(0)\n\n    xy = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        xy.append((x, y))\n\n    ans = pow(2, N, mod) - N - 1\n    used = [[0] * N for _ in range(N)]\n    for i in range(N-1):\n        for j in range(i+1, N):\n            if used[i][j]:\n                continue\n            tmp = [i, j]\n            cnt = 2\n            for k in range(N):\n                if k == i or k == j:\n                    continue\n                if same_line(xy[i], xy[j], xy[k]):\n                    cnt += 1\n                    tmp.append(k)\n            ans -= pow(2, cnt, mod) - cnt - 1\n            ans %= mod\n            for a in range(len(tmp)):\n                for b in range(a+1, len(tmp)):\n                    used[tmp[a]][tmp[b]] = 1\n                    used[tmp[b]][tmp[a]] = 1\n    print(ans%mod)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n\n    def same_line(p1, p2, p3):\n        eps = 10**-8\n        c1 = complex(p1[0], p1[1])\n        c2 = complex(p2[0], p2[1])\n        c3 = complex(p3[0], p3[1])\n        d = (c2-c1) / (c3-c1)\n        if abs(d.imag) < eps:\n            return 1\n        else:\n            return 0\n\n    mod = 998244353\n    N = int(input())\n    xy = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        xy.append((x, y))\n\n    ans = pow(2, N, mod) - N - 1\n    used = [[0] * N for _ in range(N)]\n    for i in range(N-1):\n        for j in range(i+1, N):\n            if used[i][j]:\n                continue\n            tmp = [i, j]\n            cnt = 2\n            for k in range(N):\n                if k == i or k == j:\n                    continue\n                if same_line(xy[i], xy[j], xy[k]):\n                    cnt += 1\n                    tmp.append(k)\n            ans -= pow(2, cnt, mod) - cnt - 1\n            ans %= mod\n            for a in range(len(tmp)):\n                for b in range(a+1, len(tmp)):\n                    used[tmp[a]][tmp[b]] = 1\n                    used[tmp[b]][tmp[a]] = 1\n    print(ans%mod)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import math\nfrom fractions import Fraction\nmod = 998244353\nn = int(input())\np = [list(map(int, input().split())) for i in range(n)]\npow2 = [2**i % mod for i in range(n + 1)]\ndic = {}\nfor i in range(n):\n    for j in range(i):\n        a = (p[i][1] - p[j][1]) / (p[i][0] - p[j]\n                                       [0]) if p[i][0] != p[j][0] else 10**9\n        b = p[i][1] - p[i][0] * a if p[i][0] != p[j][0] else p[i][0]\n        if (a, b) in dic:\n            dic[(a, b)] += 1\n        else:\n            dic[(a, b)] = 1\nret = (pow2[n] - 1 - n - n * (n - 1) / 2)\nfor v in dic.values():\n    x = int((math.sqrt(8 * v + 1) + 1) / 2)\n    ret = (ret + mod - pow2[x] + 1 + x + x * (x - 1) // 2) % mod\nprint(int(ret))\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n\n    def same_line(p1, p2, p3):\n        c1 = complex(p1[0], p1[1])\n        c2 = complex(p2[0], p2[1])\n        c3 = complex(p3[0], p3[1])\n        a = c2 - c1\n        b = c3 - c1\n        if a.real * b.imag == a.imag * b.real:\n            return 1\n        else:\n            return 0\n\n    mod = 998244353\n    N = int(input())\n\n    if N <= 2:\n        print(0)\n        exit()\n\n    xy = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        xy.append((x, y))\n\n    ans = pow(2, N, mod) - N - 1\n    ans %= mod\n    used = [[0] * N for _ in range(N)]\n    for i in range(N-1):\n        for j in range(i+1, N):\n            if used[i][j]:\n                continue\n            tmp = [i, j]\n            cnt = 2\n            for k in range(N):\n                if k == i or k == j:\n                    continue\n                if same_line(xy[i], xy[j], xy[k]):\n                    cnt += 1\n                    tmp.append(k)\n            ans -= pow(2, cnt, mod) - cnt - 1\n            ans %= mod\n            for a in range(len(tmp)):\n                for b in range(a+1, len(tmp)):\n                    used[tmp[a]][tmp[b]] = 1\n                    used[tmp[b]][tmp[a]] = 1\n    print(ans%mod)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b,a%b)\ndef inpl(): return [int(i) for i in input().split()]\nfrom collections import defaultdict\nH = defaultdict(lambda: 0)\nN = int(input())\ndot = [()]*N\nfor i in range(N):\n    x, y = inpl()\n    dot[i] = (x, y)\nfor i in range(N):\n    for j in range(i+1,N):\n        x1, y1 = dot[i]\n        x2, y2 = dot[j]\n        A = y1 - y2\n        B = x2 - x1\n        C = y1*x2 - x1*y2\n        if A < 0:\n            A *= -1\n            B *= -1\n            C *= -1\n        gcdabc = gcd(gcd(A,B), C)\n        A //= gcdabc\n        B //= gcdabc\n        C //= gcdabc\n        H[(A, B, C)] += 1\nans = 2**N - N - 1\nfor i in H.values():\n    i = int((1+(1+8*i)**(1/2))/2)\n    ans -= 2**i - i - 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nN = int(input())\nP = [list(map(int, input().split())) for i in range(N)]\n\nMOD = 998244353\n\nans = pow(2, N, MOD) - 1 - N\nu = set()\nfor i in range(N):\n    xi, yi = P[i]\n    for j in range(i+1, N):\n        xj, yj = P[j]\n        if (i, j) in u:\n            continue\n        cnt = 0\n        Q = {i, j}\n        for k in range(N):\n            xk, yk = P[k]\n            if (xj - xi)*(yk - yi) == (xk - xi)*(yj - yi):\n                cnt += 1\n                Q.add(k)\n        for p in Q:\n            for q in Q:\n                u.add((p, q))\n        ans -= pow(2, cnt, MOD) - cnt - 1\nprint(ans % MOD)"
  },
  {
    "language": "Python",
    "code": "4\n0 0\n0 1\n1 0\n1 1\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n\n    def same_line(p1, p2, p3):\n        eps = 10**-8\n        c1 = complex(p1[0], p1[1])\n        c2 = complex(p2[0], p2[1])\n        c3 = complex(p3[0], p3[1])\n        d = (c2-c1) / (c3-c1)\n        if abs(d.imag) < eps:\n            return 1\n        else:\n            return 0\n\n    mod = 998244353\n    N = int(input())\n    xy = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        xy.append((x, y))\n\n    ans = pow(2, N, mod) - N - 1\n    used = [[0] * N for _ in range(N)]\n    for i in range(N-1):\n        for j in range(i+1, N):\n            if used[i][j]:\n                continue\n            tmp = [i, j]\n            cnt = 2\n            for k in range(N):\n                if k == i or k == j:\n                    continue\n                if same_line(xy[i], xy[j], xy[k]):\n                    cnt += 1\n                    tmp.append(k)\n            ans -= pow(2, cnt, mod) - cnt - 1\n            ans %= mod\n            for a in range(len(tmp)):\n                for b in range(a+1, len(tmp)):\n                    used[tmp[a]][tmp[b]] = 1\n                    used[tmp[b]][tmp[a]] = 1\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import math\nmod = 998244353\nn = int(input())\np = [list(map(int, input().split())) for i in range(n)]\npow2 = [1]\nfor i in range(n):\n    pow2.append(pow2[-1] * 2 % mod)\nused = [[False] * n for i in range(n)]\nret = (pow2[n] - 1 - n - n * (n - 1) / 2) % mod\nfor i in range(n):\n    for j in range(i):\n        if used[i][j]:\n            continue\n        inline = [i, j]\n        for k in range(n):\n            if k == i or k == j:\n                continue\n            if (p[i][1] - p[k][1]) * (p[j][0] - p[k][0]) == (p[j][1] - p[k][1]) * (p[i][0] - p[k][0]):\n                inline.append(k)\n        for k in range(len(inline)):\n            for l in range(len(inline)):\n                used[inline[k]][inline[l]] = True\n        v = len(inline)\n        ret = (ret + mod - pow2[v] + 1 + v + v * (v - 1) // 2) % mod\nprint(int(ret))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict\n\n# sys.stdin = open('e1.in')\n\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_str_list():\n    return input().split()\n\n\ndef read_str():\n    return input()\n\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef solve():\n    def collinear(x0, y0, x1, y1):\n        return x0 * y1 == x1 * y0\n\n    def aligned(i, j, k):\n        return collinear(x[j] - x[i], y[j] - y[i], x[k] - x[i], y[k] - y[i])\n\n    n = read_int()\n    mod = 998244353\n    res = pow(2, n, mod) - n - 1\n    x, y = zip(*[read_int_list() for i in range(n)])\n    lines = defaultdict(set)\n    for i in range(n):\n        for j in range(i + 1, n):\n            a = y[i] - y[j]\n            b = x[j] - x[i]\n            g = gcd(a, b)\n            a //= g\n            b //= g\n            if a < 0 or (a == 0 and b < 0):\n                a, b = -a, -b\n            c = -(a * x[i] + b * y[i])\n            lines[(a, b, c)].add(i)\n            lines[(a, b, c)].add(j)\n    for k, v in lines.items():\n        m = len(v)\n        res -= pow(2, m, mod) - m - 1\n    res %= mod\n    return res\n\n\ndef main():\n    res = solve()\n    print(res)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from collections import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\ndef red(a, b, c):\n    if a == 0 and b < 0: b, c = -b, -c\n    if a < 0: a, b, c = -a, -b, -c\n    g = gcd(a, gcd(abs(b), abs(c)))\n    return a // g, b // g, c // g\n\ndef main():\n    md = 998244353\n    n = int(input())\n    xy = LLI(n)\n    cnt_online = {}\n    # 各２点を結ぶ直線をax+by+c=0の(a,b,c)で表し\n    # 各直線上にいくつの点があるかカウントする\n    for i in range(n):\n        x0, y0 = xy[i]\n        counted = set()\n        for j in range(i):\n            x1, y1 = xy[j]\n            a = y0 - y1\n            b = x1 - x0\n            c = -a * x0 - b * y0\n            a, b, c = red(a, b, c)\n            if (a, b, c) in counted: continue\n            counted.add((a, b, c))\n            cnt_online.setdefault((a, b, c), 1)\n            cnt_online[(a, b, c)] += 1\n    # print(cnt_online)\n    # 各直線上で、2点以上で多角形ができない点の選び方を数える\n    sum_online = 0\n    for plot_n in cnt_online.values():\n        sum_online += pow(2, plot_n, md) - 1 - plot_n\n        sum_online %= md\n    # すべての2点以上の選び方から、多角形ができないものを引く\n    ans = pow(2, n, md) - 1 - n - sum_online\n    print(ans % md)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b,a%b)\ndef inpl(): return [int(i) for i in input().split()]\nfrom collections import defaultdict\nH = defaultdict(lambda: 0)\nN = int(input())\ndot = [()]*N\nfor i in range(N):\n    x, y = inpl()\n    dot[i] = (x, y)\nfor i in range(N):\n    for j in range(i+1,N):\n        x1, y1 = dot[i]\n        x2, y2 = dot[j]\n        A = y1 - y2\n        B = x2 - x1\n        C = y1*x2 - x1*y2\n        if A < 0:\n            A *= -1\n            B *= -1\n            C *= -1\n        gcdabc = gcd(gcd(A,B), C)\n        A //= gcdabc\n        B //= gcdabc\n        C //= gcdabc\n        if A < 0:\n            A *= -1\n            B *= -1\n            C *= -1\n        H[(A, B, C)] += 1\nans = 2**N - N - 1\nfor i in H.values():\n    i = int((1+(1+8*i)**(1/2))/2)\n    ans -= 2**i - i - 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from fractions import Fraction\nfrom collections import defaultdict\nfrom itertools import combinations\nclass Combination:\n    \"\"\"\n    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる\n    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)\n    使用例：\n    comb = Combination(1000000)\n    print(comb(5, 3))  # 10\n    \"\"\"\n    def __init__(self, n_max, mod=10**9+7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def make_factorial_list(self, n):\n        # 階乗のリストと階乗のmod逆元のリストを返す O(n)\n        # self.make_modinv_list()が先に実行されている必要がある\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n+1):\n            fac.append(fac[i-1] * i % self.mod)\n            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0からnまでのmod逆元のリストを返す O(n)\n        modinv = [0] * (n+1)\n        modinv[1] = 1\n        for i in range(2, n+1):\n            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod\n        return modinv\n\nN = int(input())\nXY = [list(map(int, input().split())) for i in range(N)]\n\nD = defaultdict(int)\nfor (x1, y1), (x2, y2) in combinations(XY, 2):\n    if x1 != x2:\n        a = Fraction(y2-y1, x2-x1)\n        b = Fraction(y1) - a * Fraction(x1)\n        D[(a, b)] += 1\n    else:\n        D[(None, x1)] += 1\n\nmod = 998244353\ncomb = Combination(N+1, mod)\nA = [0] * (N+1)\ncoA = [0] * (N+1)\nans = 0\nfor i in range(3, N+1):\n    ans += comb(N, i)\n    ans %= mod\nfor i in range(3, N+1):\n    for j in range(i-2):\n        A[i] += (i-2-j)*(1<<j)\n    coA[i] = coA[i-1]+A[i]\nfor (a, b), n in D.items():\n    if n==1:\n        continue\n    n = int((n<<1)**0.5)+1\n    ans -= coA[n]\n    ans %= mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\n\n# sys.stdin = open('e1.in')\n\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_str_list():\n    return input().split()\n\n\ndef read_str():\n    return input()\n\n\ndef solve():\n    def collinear(x0, y0, x1, y1):\n        return x0 * y1 == x1 * y0\n\n    def aligned(i, j, k):\n        return collinear(x[j] - x[i], y[j] - y[i], x[k] - x[i], y[k] - y[i])\n\n    n = read_int()\n    mod = 998244353\n    res = pow(2, n, mod) - n - 1\n    x, y = zip(*[read_int_list() for i in range(n)])\n    done = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (i, j) not in done:\n                line = [i, j]\n                for k in range(n):\n                    if k not in [i, j]:\n                        if aligned(i, j, k):\n                            line.append(k)\n\n                for u in line:\n                    for v in line:\n                        if u != v:\n\n                            done.add((u, v))\n                m = len(line)\n                res -= pow(2, m, mod) - m - 1\n    res %= mod\n    return res\n\n\ndef main():\n    res = solve()\n    print(res)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom fractions import gcd\n\nn = int(input())\nxys = [tuple(map(int, input().split())) for _ in range(n)]\nMOD = 998244353\n\nexcludes = 0\nfor i, (x1, y1) in enumerate(xys):\n    slopes = []\n    for x2, y2 in xys[i + 1:]:\n        dx, dy = x2 - x1, y2 - y1\n        if dx == 0:\n            slopes.append(1j)\n        elif dy == 0:\n            slopes.append(1)\n        else:\n            m = gcd(dx, dy)\n            slopes.append(dx // m + dy // m * 1j)\n    for c in Counter(slopes).values():\n        if c > 1:\n            excludes += 2 ** c - c - 1\n    excludes %= MOD\n\nprint((pow(2, n, MOD) - excludes - (n * (n - 1) // 2) - n - 1) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n\n    def same_line(p1, p2, p3):\n        eps = 10**-8\n        c1 = complex(p1[0], p1[1])\n        c2 = complex(p2[0], p2[1])\n        c3 = complex(p3[0], p3[1])\n        d = (c2-c1) / (c3-c1)\n        if abs(d.imag) < eps:\n            return 1\n        else:\n            return 0\n\n    mod = 998244353\n    N = int(input())\n\n    if N <= 2:\n        print(0)\n        exit()\n\n    xy = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        xy.append((x, y))\n\n    ans = pow(2, N, mod) - N - 1\n    ans %= mod\n    used = [[0] * N for _ in range(N)]\n    for i in range(N-1):\n        for j in range(i+1, N):\n            if used[i][j]:\n                continue\n            tmp = [i, j]\n            cnt = 2\n            for k in range(N):\n                if k == i or k == j:\n                    continue\n                if same_line(xy[i], xy[j], xy[k]):\n                    cnt += 1\n                    tmp.append(k)\n            ans -= pow(2, cnt, mod) - cnt - 1\n            ans %= mod\n            for a in range(len(tmp)):\n                for b in range(a+1, len(tmp)):\n                    used[tmp[a]][tmp[b]] = 1\n                    used[tmp[b]][tmp[a]] = 1\n    print(ans%mod)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\n\nif __name__ == '__main__':\n    N = int(input())\n    xy_list = [list(map(int, input().split())) for _ in range(N)]\n\n    modulo_num = 998244353\n\n    duplicate_list = [0] * (N + 1)\n    for i in range(N):\n        xi, yi = xy_list[i]\n        gradient_list = []\n        for j in range(N):\n            xj, yj = xy_list[j]\n            if xi != xj:\n                gradient_list.append((yj - yi) / (xj - xi))\n            elif yi != yj:\n                gradient_list.append(100000)\n\n        counter = Counter(gradient_list)\n        for k in counter.values():\n            duplicate_list[k + 1] += 1\n\n    ans = pow(2, N, modulo_num)\n    ans -= 1\n    ans -= N\n    for i in range(2, N + 1):\n        cnt = duplicate_list[i] // i\n        ans -= cnt * (pow(2, i, modulo_num) - i - 1)\n    ans = ans % modulo_num\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n\n    def same_line(p1, p2, p3):\n        eps = 10**-8\n        c1 = complex(p1[0], p1[1])\n        c2 = complex(p2[0], p2[1])\n        c3 = complex(p3[0], p3[1])\n        d = (c2-c1) / (c3-c1)\n        if abs(d.imag) < eps:\n            return 1\n        else:\n            return 0\n\n    mod = 998244353\n    N = int(input())\n\n    if N <= 2:\n        print(0)\n        exit()\n\n    xy = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        xy.append((x, y))\n\n    ans = pow(2, N, mod) - N - 1\n    used = [[0] * N for _ in range(N)]\n    for i in range(N-1):\n        for j in range(i+1, N):\n            if used[i][j]:\n                continue\n            tmp = [i, j]\n            cnt = 2\n            for k in range(N):\n                if k == i or k == j:\n                    continue\n                if same_line(xy[i], xy[j], xy[k]):\n                    cnt += 1\n                    tmp.append(k)\n            ans -= pow(2, cnt, mod) - cnt - 1\n            ans %= mod\n            for a in range(len(tmp)):\n                for b in range(a+1, len(tmp)):\n                    used[tmp[a]][tmp[b]] = 1\n                    used[tmp[b]][tmp[a]] = 1\n    print(ans%mod)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom fractions import gcd\nfrom collections import Counter\n\n\"\"\"\n適当に部分集合Xをとり、凸包 S として、Sに1点計上すればよい\nこれだと2^N点得られる\nただし、凸包の面積が0となる場合が例外\n空集合、1点の場合と、線分の場合を除外する\n\n\"\"\"\n\nMOD = 998244353\nN = int(input())\nXY = [[int(x) for x in input().split()] for _ in range(N)]\n\nanswer = pow(2,N,MOD)\nanswer -= N + 1# 空、1点\nfor i,(x,y) in enumerate(XY):\n    # i を選び、i+1番目以上のうちいくつかを選んで線分とする\n    pts = []\n    for x1, y1 in XY[i+1:]:\n        dx, dy = x1-x, y1-y\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        # 標準化\n        if dx < 0:\n            dx, dy = -dx, -dy\n        elif dx == 0:\n            dy = 1\n        pts.append((dx,dy))\n    c = Counter(pts)\n    for v in c.values():\n        answer -= pow(2,v,MOD) - 1\n\nanswer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom math import gcd\n\nn = int(input())\nxys = [tuple(map(int, input().split())) for _ in range(n)]\nMOD = 998244353\n\nexcludes = 0\nfor i, (x1, y1) in enumerate(xys):\n    slopes = []\n    for x2, y2 in xys[i + 1:]:\n        dx, dy = x2 - x1, y2 - y1\n        if dx == 0:\n            slopes.append(1j)\n        elif dy == 0:\n            slopes.append(1)\n        else:\n            m = gcd(dx, dy)\n            slopes.append(dx // m + dy // m * 1j)\n    for c in Counter(slopes).values():\n        if c > 1:\n            excludes += 2 ** c - c - 1\n    excludes %= MOD\n\nprint((pow(2, n, MOD) - excludes - (n * (n - 1) // 2) - n - 1) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "import math\nimport itertools\n\ndef read_data():\n    try:\n        LOCAL_FLAG\n        import codecs\n        import os\n\n        lines = []\n        file_path = os.path.join(os.path.dirname(__file__), 'arc082-e.dat')\n        with codecs.open(file_path, 'r', 'utf-8') as f:\n            lines.append(f.readline().rstrip(\"\\r\\n\"))\n            N = int(lines[0])\n            for i in range(N):\n                lines.append(f.readline().rstrip(\"\\r\\n\"))\n\n    except NameError:\n        lines = []\n        lines.append(input())\n        N = int(lines[0])\n        for i in range(N):\n            lines.append(input())\n\n    return lines\n\ndef isIncluded(ref_points, ref):\n    min_y = ref_points[0]['y']\n    min_index = 0\n    for i in range(1, len(ref_points)):\n        if(min_y > ref_points[i]['y']):\n            min_y = ref_points[i]['y']\n            min_index = i\n\n    points = []\n    p = {}\n    for i in range(len(ref_points)):\n        data = {}\n        data['x'] = ref_points[i]['x'] - ref_points[min_index]['x']\n        data['y'] = ref_points[i]['y'] - ref_points[min_index]['y']\n        data['rad'] = math.atan2(data['y'], data['x'])\n        points.append(data)\n\n    p['x'] = ref['x'] - ref_points[min_index]['x']\n    p['y'] = ref['y'] - ref_points[min_index]['y']\n\n    points = sorted(points, key=lambda x: x['rad'])\n\n    lines = []\n    v1 = {}\n    v2 = {}\n    Included = True\n\n    lines = ((0,1), (1,2), (2,0))\n\n    for n in range(3):\n        v1['x'] = points[lines[n][1]]['x']   - points[lines[n][0]]['x']\n        v1['y'] = points[lines[n][1]]['y']   - points[lines[n][0]]['y']\n        v2['x'] = p['x'] - points[lines[n][1]]['x']\n        v2['y'] = p['y'] - points[lines[n][1]]['y']\n\n        cross = v1['x']*v2['y'] - v2['x']*v1['y']\n        # print(v1, v2)\n        # print(cross)\n        if(cross < 0):\n            return False\n\n    if(Included):\n        return True\n    else:\n        return False\n\n\ndef isConvex(xy, points):\n    lines = []\n    v1 = {}\n    v2 = {}\n    N = len(points)\n\n    for n in range(N-1):\n        lines.append((points[n], points[n+1]))\n    lines.append((points[n+1], points[0]))\n    lines.append(lines[0])\n\n    for n in range(N):\n        v1['x'] = xy[lines[n][1]]['x']   - xy[lines[n][0]]['x']\n        v1['y'] = xy[lines[n][1]]['y']   - xy[lines[n][0]]['y']\n        v2['x'] = xy[lines[n+1][1]]['x'] - xy[lines[n+1][0]]['x']\n        v2['y'] = xy[lines[n+1][1]]['y'] - xy[lines[n+1][0]]['y']\n\n        cross = v1['x']*v2['y'] - v2['x']*v1['y']\n        if(cross <= 0):\n            return False\n\n    return True\n\n\ndef sort_by_rad(xy, points):\n    min_y = xy[points[0]]['y']\n    min_index = 0\n    for i in range(1, len(points)):\n        if(min_y > xy[points[i]]['y']):\n            min_y = xy[points[i]]['y']\n            min_index = i\n\n    new_points = []\n    for i in range(len(points)):\n        data = {}\n        data['x'] = xy[points[i]]['x'] - xy[points[min_index]]['x']\n        data['y'] = xy[points[i]]['y'] - xy[points[min_index]]['y']\n        data['rad'] = math.atan2(data['y'], data['x'])\n        data['index'] = points[i]\n        new_points.append(data)\n\n    sort_points = sorted(new_points, key=lambda x: x['rad'])\n    results = []\n    for i in range(len(points)):\n        results.append(sort_points[i]['index'])\n\n    return results\n\n\ndef E_ConvexScore():\n    raw_data = read_data()\n\n    xy = []\n    N = int(raw_data[0])\n    key_list = [\"x\", \"y\"]\n    min_xy = dict(zip(key_list, list(map(int, raw_data[1].split()))))\n    max_xy = dict(zip(key_list, list(map(int, raw_data[1].split()))))\n    index_min = 0\n\n    for i in range(N):\n        xy.append(dict(zip(key_list, list(map(int, raw_data[i+1].split())))))\n        xy[i]['rad'] = math.atan2(xy[i]['y'], xy[i]['x'])\n        xy[i]['d'] = xy[i]['y'] + xy[i]['x']\n\n    xy_d = sorted(xy, key=lambda x: x['d'])\n    xy_rad = sorted(xy_d, key=lambda x: x['rad'])\n    xy = xy_rad\n\n    included = {}\n    total_rank = 0\n    for points in itertools.combinations(range(N), 3):\n        new_points = sort_by_rad(xy, points)\n        # print(new_points)\n        if(not isConvex(xy, new_points)):\n            included[points] = set([])\n            continue\n        count = 0\n        index_included = []\n        for i in range(points[0]+1, points[2]):\n            if(i in points):\n                continue\n            elif(isIncluded(list([xy[points[0]], xy[points[1]], xy[points[2]]]), xy[i])):\n                count += 1\n                index_included.append(i)\n        included[points] = set(index_included)\n        # print(count)\n        total_rank += pow(2, count)\n\n    # print(included)\n\n    for i in range(4, N+1):\n        for points in itertools.combinations(range(N), i):\n            new_points = sort_by_rad(xy, points)\n\n            if(not isConvex(xy, new_points)):\n                continue\n\n            # print(new_points)\n            count_set = set([])\n            for j in range(i-2):\n                triangle = (new_points[0], new_points[j+1], new_points[j+2])\n                count_set = count_set ^ included[triangle]\n\n            # print(count_set)\n            total_rank += pow(2, len(count_set))\n\n    print(total_rank)\n\nE_ConvexScore()\n"
  },
  {
    "language": "Python",
    "code": "def gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b,a%b)\ndef inpl(): return [int(i) for i in input().split()]\nfrom collections import defaultdict\nH = defaultdict(lambda: 0)\nN = int(input())\ndot = [()]*N\nmod = 998244353\nfor i in range(N):\n    x, y = inpl()\n    dot[i] = (x, y)\nfor i in range(N):\n    for j in range(i+1,N):\n        x1, y1 = dot[i]\n        x2, y2 = dot[j]\n        A = y1 - y2\n        B = x2 - x1\n        C = y1*x2 - x1*y2\n        if A < 0:\n            A *= -1\n            B *= -1\n            C *= -1\n        gcdabc = gcd(gcd(A,B), C)\n        A //= gcdabc\n        B //= gcdabc\n        C //= gcdabc\n        H[(A, B, C)] += 1\nans = (2**N - N - 1 )%mod\nfor i in H.values():\n    i = int((1+(1+8*i)**(1/2))/2)\n    ans -= (2**i - i - 1)%mod\nprint(ans%mod)"
  },
  {
    "language": "Python",
    "code": "import math\nfrom fractions import Fraction\nmod = 998244353\nn = int(input())\np = [list(map(int, input().split())) for i in range(n)]\npow2 = [2**i % mod for i in range(n + 1)]\nused = [[False] * n for i in range(n)]\nret = (pow2[n] - 1 - n - n * (n - 1) / 2) % mod\nfor i in range(n):\n    for j in range(i):\n        if used[i][j]:\n            continue\n        inline = [i, j]\n        for k in range(n):\n            if k == i or k == j:\n                continue\n            if (p[i][1] - p[k][1]) * (p[j][0] - p[k][0]) == (p[j][1] - p[k][1]) * (p[i][0] - p[k][0]):\n                inline.append(k)\n        for k in range(len(inline)):\n            for l in range(len(inline)):\n                used[inline[k]][inline[l]] = True\n        v = len(inline)\n        ret = (ret + mod - pow2[v] + 1 + v + v * (v - 1) // 2) % mod\nprint(int(ret))\n"
  },
  {
    "language": "Python",
    "code": "# E\nfrom collections import Counter\n\nN = int(input())\nxy_list = [list(map(int, input().split())) for _ in range(N)]\n\nM = 998244353\n\nres = pow(2, N, M)\n# 0 points\nres -= 1\n# 1 points\nres -= N\n\n# all lines\nline_cnt = [0]*(N+1)\n\nfor i in range(N):\n    xi, yi = xy_list[i]\n    angle_list = []\n    for j in range(N):\n        xj, yj = xy_list[j]\n        if xj != xi:\n            angle_list.append((yj-yi)/(xj-xi))\n        elif yj != xj:\n            angle_list.append(10000.0)\n        \n    # count points in same line\n    cnt_i = Counter(angle_list)\n    for k in cnt_i.values():\n        line_cnt[k+1] += 1\n\nfor i in range(2, N+1):\n    cnt = line_cnt[i] // i\n    res -= cnt*(pow(2, i, M)-i-1)\n\nres = res % M\nprint(res)"
  },
  {
    "language": "Python",
    "code": "# E\nfrom collections import Counter\n\nN = int(input())\nxy_list = [list(map(int, input().split())) for _ in range(N)]\n\nM = 998244353\n\nres = pow(2, N, M)\n# 0 points\nres -= 1\n# 1 points\nres -= N\n\n# all lines\nline_cnt = [0]*(N+1)\n\nfor i in range(N):\n    xi, yi = xy_list[i]\n    angle_list = []\n    for j in range(N):\n        xj, yj = xy_list[j]\n        if xj != xi:\n            angle_list.append((yj-yi)/(xj-xi))\n        elif yj != yi:\n            angle_list.append(10000.0)\n        \n    # count points in same line\n    cnt_i = Counter(angle_list)\n    for k in cnt_i.values():\n        line_cnt[k+1] += 1\n\nfor i in range(2, N+1):\n    cnt = line_cnt[i] // i\n    res -= cnt*(pow(2, i, M)-i-1)\n\nres = res % M\nprint(res)"
  },
  {
    "language": "Python",
    "code": "def gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b,a%b)\ndef inpl(): return [int(i) for i in input().split()]\nfrom collections import defaultdict\nH = defaultdict(lambda: 0)\nN = int(input())\ndot = [()]*N\nfor i in range(N):\n    x, y = inpl()\n    dot[i] = (x, y)\nfor i in range(N):\n    for j in range(i+1,N):\n        x1, y1 = dot[i]\n        x2, y2 = dot[j]\n        A = y1 - y2\n        B = x2 - x1\n        C = y1*x2 - x1*y2\n        if A < 0:\n            A *= -1\n            B *= -1\n            C *= -1\n        gcdabc = gcd(gcd(A,B), C)\n        A //= gcdabc\n        B //= gcdabc\n        C //= gcdabc\n        H[(A, B, C)] += 1\nans = 2**N - N - 1\nfor i in H.values():\n    i = int((1+(1+8*i)**(1/2))/2)\n    ans -= 2**i - i - 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b,a%b)\ndef inpl(): return [int(i) for i in input().split()]\nfrom collections import defaultdict\nH = defaultdict(lambda: 0)\nN = int(input())\ndot = [()]*N\nfor i in range(N):\n    x, y = inpl()\n    dot[i] = (x, y)\nfor i in range(N):\n    for j in range(i+1,N):\n        x1, y1 = dot[i]\n        x2, y2 = dot[j]\n        A = y1 - y2\n        B = x2 - x1\n        C = y1*x2 - x1*y2\n        if A < 0:\n            A *= -1\n            B *= -1\n            C *= -1\n        gcdabc = gcd(gcd(A,B), C)\n        A //= gcdabc\n        B //= gcdabc\n        C //= gcdabc\n        H[(A, B, C)] += 1\nans = 2**N - N - 1\nfor i in H.values():\n    i = int((1+(1+8*(i+10**(-5)))**(1/2))/2)\n    ans -= 2**i - i - 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b,a%b)\ndef inpl(): return [int(i) for i in input().split()]\nfrom collections import defaultdict\nH = defaultdict(lambda: 0)\nN = int(input())\ndot = [()]*N\nfor i in range(N):\n    x, y = inpl()\n    dot[i] = (x, y)\nfor i in range(N):\n    for j in range(i+1,N):\n        x1, y1 = dot[i]\n        x2, y2 = dot[j]\n        A = y1 - y2\n        B = x2 - x1\n        C = y1*x2 - x1*y2\n        if A < 0:\n            A *= -1\n            B *= -1\n            C *= -1\n        gcdabc = gcd(gcd(A,B), C)\n        A //= gcdabc\n        B //= gcdabc\n        C //= gcdabc\n        H[(A, B, C)] += 1\nans = 2**N - N - 1\nfor i in H.values():\n    i = int((1+(1.1+8*i)**(1/2))/2)\n    ans -= 2**i - i - 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom fractions import gcd\nfrom collections import Counter\n\n\"\"\"\n適当に部分集合Xをとり、凸包 S として、Sに1点計上すればよい\nこれだと2^N点得られる\nただし、凸包の面積が0となる場合が例外\n空集合、1点の場合と、線分の場合を除外する\n\n\"\"\"\n\nMOD = 998244353\nN = int(input())\nXY = [[int(x) for x in input().split()] for _ in range(N)]\n\nanswer = pow(2,N,MOD)\nanswer -= N + 1# 空、1点\nfor i,(x,y) in enumerate(XY):\n    # i を選び、i+1番目以上のうちいくつかを選んで線分とする\n    pts = []\n    for x1, y1 in XY[i+1:]:\n        dx, dy = x1-x, y1-y\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        # 標準化\n        if dx < 0:\n            dx, dy = -dx, -dy\n        elif dx == 0:\n            dy = 1\n        pts.append((dx,dy))\n    c = Counter(pts)\n    for v in c.values():\n        answer -= pow(2,v,MOD) - 1\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n\n    def same_line(p1, p2, p3):\n        eps = 10**-8\n        c1 = complex(p1[0], p1[1])\n        c2 = complex(p2[0], p2[1])\n        c3 = complex(p3[0], p3[1])\n        d = (c2-c1) / (c3-c1)\n        if abs(d.imag) < eps:\n            return 1\n        else:\n            return 0\n\n    mod = 998244353\n    N = int(input())\n    xy = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        xy.append((x, y))\n\n    ans = pow(2, N, mod) - N - 1\n    used = [[0] * N for _ in range(N)]\n    for i in range(N-1):\n        for j in range(i+1, N):\n            if used[i][j]:\n                continue\n            tmp = [i, j]\n            cnt = 2\n            for k in range(N):\n                if k == i or k == j:\n                    continue\n                if same_line(xy[i], xy[j], xy[k]):\n                    cnt += 1\n                    tmp.append(k)\n            ans -= pow(2, cnt, mod) - cnt - 1\n            for a in range(len(tmp)):\n                for b in range(a+1, len(tmp)):\n                    used[tmp[a]][tmp[b]] = 1\n                    used[tmp[b]][tmp[a]] = 1\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "# E\nN = int(input())\nxy_list = [list(map(int, input().split())) for _ in range(N)]\n\nM = 998244353\n\nres = pow(2, N, M)\n# 0 points\nres -= 1\n# 1 points\nres -= N\n\n# all lines\nfor i in range(N):\n    xi, yi = xy_list[i]\n    for j in range(i+1, N):\n        xj, yj = xy_list[j]\n        # count points in same line\n        cnt = 0\n        valid = 1\n        for k in range(N):\n            xk, yk = xy_list[k]\n            if ((xk-xi)*(xk-xj) + (yk-yi)*(yk-yj))**2 == ((xk-xi)**2 + (yk-yi)**2)*((xk-xj)**2 + (yk-yj)**2):\n                if k < j and k != i:\n                    valid = 0\n                else:\n                    cnt += 1\n        if cnt > 0 and valid == 1:\n            # print(i, j, cnt)\n            res -= (pow(2, cnt, M)-cnt-1)\n\nres = res % M\nprint(res)"
  },
  {
    "language": "Rust",
    "code": "use io::*;\nuse std::collections::HashSet;\nuse std::cmp;\n\nfn main() {\n    let input = read_string();\n    let mut sc = Scanner::new(&input);\n    let n: i64 = sc.next();\n    let ps: Vec<Vec<i64>> = sc.next_mat(2, n as usize);\n    let mut lines: HashSet<(i64,i64,i64)> = HashSet::new();\n    let M = 998244353;\n    let mut ans = count_m(n, M);\n    for i in 0..n as usize {\n        for j in i+1..n as usize {\n            let mut a = ps[j][1] - ps[i][1];\n            let mut b = ps[i][0] - ps[j][0];\n            let g = gcd(a,b);\n            a /= g;\n            b /= g;\n            let c = ps[i][0] * ps[j][1] - ps[j][0] * ps[i][1];\n            if lines.contains(&(a,b,c)) {\n                continue;\n            }\n            let mut cnt = 0;\n            for k in 0..n as usize {\n                if ps[k][0] * a + ps[k][1] * b == c {\n                    cnt += 1;\n                }\n            }\n            lines.insert((a,b,c));\n            ans = (ans + M - count_m(cnt, M)) % M;\n        }\n    }\n    println!(\"{}\",ans);\n}\n\nfn count_m(n: i64, M: i64) -> i64 {\n    if n < 3 {\n        0\n    } else {\n        (pow_m(2,n,M) + M - n * (n+1) / 2 - 1) % M\n    }\n}\n\nfn pow_m(a: i64, mut n: i64, M: i64) -> i64 {\n    let mut r = a % M;\n    let mut ret = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            ret = ret * r % M;\n            n -= 1;\n        } else {\n            r = r * r % M;\n            n /= 2;\n        }\n    }\n    ret\n}\n\nfn gcd(a: i64, b: i64) -> i64 {\n    let aa = a.abs();\n    let ba = b.abs();\n    let mut x = cmp::min(aa,ba);\n    let mut y = cmp::max(aa,ba);\n    while x > 0 {\n        let t = x;\n        x = y % x;\n        y = t;\n    }\n    y\n}\n\npub mod io {\n    use std;\n    use std::str::FromStr;\n\n    pub struct Scanner<'a> {\n        iter: std::str::SplitWhitespace<'a>,\n    }\n\n    impl<'a> Scanner<'a> {\n        pub fn new(s: &'a str) -> Scanner<'a> {\n            Scanner {\n                iter: s.split_whitespace(),\n            }\n        }\n\n        pub fn next<T: FromStr>(&mut self) -> T {\n            let s = self.iter.next().unwrap();\n            if let Ok(v) = s.parse::<T>() {\n                v\n            } else {\n                panic!(\"Parse error\")\n            }\n        }\n\n        pub fn next_vec_len<T: FromStr>(&mut self) -> Vec<T> {\n            let n: usize = self.next();\n            self.next_vec(n)\n        }\n\n        pub fn next_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n            (0..n).map(|_| self.next()).collect()\n        }\n\n        pub fn next_mat<T: FromStr>(&mut self, w: usize, h: usize) -> Vec<Vec<T>> {\n            (0..h).map(|_| self.next_vec(w)).collect()\n        }\n\n        pub fn next_vec_char(&mut self) -> Vec<char> {\n            self.next::<String>().chars().collect()\n        }\n\n        pub fn next_mat_char(&mut self, n: usize) -> Vec<Vec<char>> {\n            (0..n).map(|_| self.next_vec_char()).collect()\n        }\n    }\n\n    pub fn read_string() -> String {\n        use std::io::Read;\n\n        let mut s = String::new();\n        std::io::stdin().read_to_string(&mut s).unwrap();\n        s\n    }\n\n    pub fn read_line() -> String {\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        s.trim_right().to_owned()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\n#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n#[allow(dead_code)]\ntype Polygon = Vec<Point>;\n\nimpl std::cmp::Eq for Point {}\nimpl std::cmp::Ord for Point {\n    fn cmp(&self, rhs: &Point) -> std::cmp::Ordering {\n        (self.x, self.y).partial_cmp(&(rhs.x, rhs.y)).unwrap()\n    }\n}\nimpl std::ops::Add for Point {\n    type Output = Point;\n    fn add(self, rhs: Point) -> Point {\n        Point {\n            x: self.x + rhs.x,\n            y: self.y + rhs.y,\n        }\n    }\n}\nimpl std::ops::AddAssign for Point {\n    fn add_assign(&mut self, rhs: Point) {\n        self.x += rhs.x;\n        self.y += rhs.y;\n    }\n}\nimpl std::ops::Sub for Point {\n    type Output = Point;\n    fn sub(self, rhs: Point) -> Point {\n        Point {\n            x: self.x - rhs.x,\n            y: self.y - rhs.y,\n        }\n    }\n}\nimpl std::ops::SubAssign for Point {\n    fn sub_assign(&mut self, rhs: Point) {\n        self.x -= rhs.x;\n        self.y -= rhs.y;\n    }\n}\nimpl std::ops::Mul<Point> for f64 {\n    type Output = Point;\n    fn mul(self, rhs: Point) -> Point {\n        Point {\n            x: self * rhs.x,\n            y: self * rhs.y,\n        }\n    }\n}\nimpl std::ops::Mul<f64> for Point {\n    type Output = Point;\n    fn mul(self, rhs: f64) -> Point {\n        Point {\n            x: self.x * rhs,\n            y: self.y * rhs,\n        }\n    }\n}\nimpl std::ops::Div<f64> for Point {\n    type Output = Point;\n    fn div(self, rhs: f64) -> Point {\n        Point {\n            x: self.x / rhs,\n            y: self.y / rhs,\n        }\n    }\n}\n#[allow(dead_code)]\nimpl Point {\n    fn new(x: f64, y: f64) -> Point {\n        Point { x: x, y: y }\n    }\n    fn norm(&self) -> f64 {\n        (self.x * self.x + self.y * self.y).sqrt()\n    }\n}\n#[allow(dead_code)]\nfn cross(lhs: &Point, rhs: &Point) -> f64 {\n    lhs.x * rhs.y - lhs.y * rhs.x\n}\n#[allow(dead_code)]\nfn dot(lhs: &Point, rhs: &Point) -> f64 {\n    lhs.x * rhs.x + lhs.y * rhs.y\n}\n#[allow(dead_code)]\nfn ccw(a: &Point, b: &Point, c: &Point) -> i32 {\n    let b = *b - *a;\n    let c = *c - *a;\n    if cross(&b, &c) > 0f64 {\n        return 1; // ccw\n    }\n    if cross(&b, &c) < 0f64 {\n        return -1; // cw\n    }\n    if dot(&b, &c) < 0f64 {\n        return 2; // online & reverse direction\n    }\n    if b.norm() < c.norm() {\n        return -2; // online & same direction & |b| < |c|\n    }\n    0 // online & same direction & b| > |c|\n}\n\n#[allow(dead_code)]\n#[derive(Eq, PartialEq)]\nenum ContainState {\n    OUT,\n    ON,\n    IN,\n}\n#[allow(dead_code)]\nfn contain_point(poly: &Polygon, p: &Point) -> ContainState {\n    let mut inner = false;\n    for i in 0..poly.len() {\n        let mut a = poly[i] - *p;\n        let mut b = poly[(i + 1) % poly.len()] - *p;\n        if a.y > b.y {\n            std::mem::swap(&mut a, &mut b);\n        }\n        if a.y <= 0f64 && 0f64 < b.y {\n            if cross(&a, &b) < 0f64 {\n                inner = !inner;\n            }\n        }\n        if cross(&a, &b) == 0f64 && dot(&a, &b) <= 0f64 {\n            return ContainState::ON;\n        }\n    }\n    if inner {\n        ContainState::IN\n    } else {\n        ContainState::OUT\n    }\n}\n\n#[test]\nfn test_add_sub() {\n    let p1 = Point::new(1f64, 2f64);\n    let p2 = Point::new(10f64, 20f64);\n    let p3 = p1 + p2;\n    assert!(p3.x == 11f64);\n    assert!(p3.y == 22f64);\n    let p4 = p3 - p2;\n    assert!(p4 == p1);\n    let mut p5 = p1;\n    p5 += p2;\n    assert!(p3 == p5);\n    let mut p6 = p3;\n    p6 -= p2;\n    assert!(p6 == p1);\n}\n#[test]\nfn test_mul_div() {\n    let p1 = Point::new(1f64, 2f64);\n    let v = 10f64;\n    let p2 = v * p1;\n    assert!(p2.x == 10f64);\n    assert!(p2.y == 20f64);\n    let p3 = p2 / 10f64;\n    assert!(p3.x == 1f64);\n    assert!(p3.y == 2f64);\n}\n#[test]\nfn test_cross_dot() {\n    let p1 = Point::new(1f64, 2f64);\n    let p2 = Point::new(3f64, -7f64);\n    assert!(dot(&p1, &p2) == -11f64);\n    assert!(cross(&p1, &p2) == -13f64);\n}\n#[test]\nfn test_ccw() {\n    let p1 = Point::new(1f64, 1f64);\n    let p2 = Point::new(2f64, 1f64);\n    let p3 = Point::new(1f64, 2f64);\n    assert!(ccw(&p1, &p2, &p3) == 1);\n    assert!(ccw(&p1, &p3, &p2) == -1);\n    assert!(ccw(&p1, &p2, &p2) == 0);\n}\n#[test]\nfn test_contain_point() {\n    let p1 = Point::new(0f64, 0f64);\n    let p2 = Point::new(0f64, 3f64);\n    let p3 = Point::new(3f64, 0f64);\n    let poly: Polygon = vec![p1, p2, p3];\n    let p4 = Point::new(1f64, 1f64);\n    let p5 = Point::new(1f64, 0f64);\n    let p6 = Point::new(3f64, 3f64);\n    assert!(contain_point(&poly, &p4) == ContainState::IN);\n    assert!(contain_point(&poly, &p5) == ContainState::ON);\n    assert!(contain_point(&poly, &p6) == ContainState::OUT);\n}\n\nfn main() {\n    let n = read::<usize>();\n    let mut ps = vec![Point::new(0f64, 0f64); n];\n    for i in 0..n {\n        let x = read::<f64>();\n        let y = read::<f64>();\n        ps[i] = Point::new(x, y);\n    }\n    let mut cnts = vec![vec![vec![0; n]; n]; n];\n    for i in 0..n {\n        for j in i + 1..n {\n            for k in j + 1..n {\n                let poly = vec![ps[i], ps[j], ps[k]];\n                let mut cnt = 0;\n                for l in 0..n {\n                    if contain_point(&poly, &ps[l]) != ContainState::OUT {\n                        cnt += 1;\n                    }\n                }\n                cnt -= 3;\n                cnts[i][j][k] = cnt;\n                cnts[i][k][j] = cnt;\n                cnts[j][i][k] = cnt;\n                cnts[j][k][i] = cnt;\n                cnts[k][i][j] = cnt;\n                cnts[k][j][i] = cnt;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\nuse std::ops::{Div, MulAssign, RemAssign};\nconst MOD: usize = 998244353;\n\nfn mod_pow(x: usize, e: usize, modulo: usize) -> usize {\n    let mut result = 1;\n    let mut cur = x;\n    let mut e = e;\n    while e > 0 {\n        if e & 1 == 1 {\n            result *= cur;\n            result %= modulo;\n        }\n        cur *= cur;\n        cur %= modulo;\n        e >>= 1;\n    }\n    result\n}\n\nfn main() {\n    let mut sc = Scanner::new();\n\n    let n = sc.usize_read();\n    let v: Vec<(i64, i64)> = (0..n).map(|_| (sc.read(), sc.read())).collect();\n\n    let mut ans = mod_pow(2, n, MOD);\n    ans = (ans + MOD - 1 - n) % MOD;\n    for i in 0..n {\n        for j in (i + 1)..n {\n            let (x1, y1) = v[i];\n            let (x2, y2) = v[j];\n            let dx = x1 - x2;\n            let dy = y1 - y2;\n\n            let mut count = 0;\n            let mut left = i;\n            let mut right = j;\n            for k in 0..n {\n                let (xk, yk) = v[k];\n                let kx = xk - x1;\n                let ky = yk - y1;\n                if dx * ky == kx * dy {\n                    left = cmp::min(left, k);\n                    right = cmp::max(right, k);\n                    count += 1;\n                }\n            }\n\n            if left != i || right != j {\n                continue;\n            }\n\n            let subset = mod_pow(2, count, MOD);\n            ans = (ans + MOD - subset + count + 1) % MOD;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\n#[allow(dead_code)]\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner {\n            ptr: 0,\n            length: 0,\n            buf: vec![0; 1024],\n            small_cache: vec![0; 1024],\n        }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool {\n        b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' '\n    }\n\n    fn read_vec<T>(&mut self, n: usize) -> Vec<T>\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        (0..n).map(|_| self.read()).collect()\n    }\n\n    fn usize_read(&mut self) -> usize {\n        self.read()\n    }\n\n    fn read<T>(&mut self) -> T\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)])\n                    .parse()\n                    .unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\nuse std::ops::{MulAssign, RemAssign};\nconst MOD: usize = 998244353;\n\nfn mod_pow<T: Copy + MulAssign + RemAssign>(x: T, e: usize, modulo: T) -> T {\n    let mut cur = x;\n    let mut e = e;\n    while e > 0 {\n        if e & 1 == 1 {\n            cur *= cur;\n            cur %= modulo;\n        }\n        e >>= 1;\n    }\n    cur\n}\n\nfn main() {\n    let mut sc = Scanner::new();\n\n    let n = sc.usize_read();\n    let v: Vec<(i64, i64)> = (0..n).map(|_| (sc.read(), sc.read())).collect();\n\n    let mut ans = mod_pow(2, n, MOD);\n    ans = (ans + MOD - 1 - n) % MOD;\n    for i in 0..n {\n        for j in (i + 1)..n {\n            let (x1, y1) = v[i];\n            let (x2, y2) = v[j];\n            let dx = x1 - x2;\n            let dy = y1 - y2;\n\n            let mut count = 0;\n            let mut left = i;\n            let mut right = j;\n            for k in 0..n {\n                let (xk, yk) = v[k];\n                let kx = xk - x1;\n                let ky = yk - y1;\n                if dx * ky - kx * dy == 0 {\n                    left = cmp::min(left, k);\n                    right = cmp::max(right, k);\n                    count += 1;\n                }\n            }\n\n            if left != i || right != j {\n                continue;\n            }\n\n            let subset = mod_pow(2, count, MOD);\n            ans = (ans + MOD + subset - count - 1) % MOD;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\n#[allow(dead_code)]\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner {\n            ptr: 0,\n            length: 0,\n            buf: vec![0; 1024],\n            small_cache: vec![0; 1024],\n        }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool {\n        b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' '\n    }\n\n    fn read_vec<T>(&mut self, n: usize) -> Vec<T>\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        (0..n).map(|_| self.read()).collect()\n    }\n\n    fn usize_read(&mut self) -> usize {\n        self.read()\n    }\n\n    fn read<T>(&mut self) -> T\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)])\n                    .parse()\n                    .unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\nuse std::str;\nuse std::usize;\nuse std::cmp;\n\nfn mod_pow(x: i64, mut exp: i64, modulo: i64) -> i64 {\n    let mut result = 1;\n    let mut cur = x;\n    while exp > 0 {\n        if exp & 1 == 1 {\n            result = (result * cur) % modulo;\n        }\n        cur = (cur * cur) % modulo;\n        exp >>= 1;\n    }\n    result\n}\n\nfn main() {\n    let modulo = 998244353;\n    let n = read_values::<usize>()[0];\n    let (x, y) = {\n        let mut x = vec![0; n];\n        let mut y = vec![0; n];\n        for i in 0..n {\n            let v = read_values::<i64>();\n            x[i] = v[0];\n            y[i] = v[1];\n        }\n        (x, y)\n    };\n\n    let mut ans = mod_pow(2, n as i64, modulo);\n    ans -= 1;\n    ans -= n as i64;\n    ans = (ans + modulo) % modulo;\n\n    // 両端がそれぞれ i, j となるような線分に乗っている点の数を数える\n    for i in 0..n {\n        for j in (i + 1)..n {\n            let dx = x[i] - x[j];\n            let dy = y[i] - y[j];\n\n            let mut count = 0;\n            let mut left = i;\n            let mut right = j;\n            for k in 0..n {\n                let kx = x[i] - x[k];\n                let ky = y[i] - y[k];\n                if dx * ky - kx * dy == 0 {\n                    left = cmp::min(left, k);\n                    right = cmp::max(right, k);\n                    count += 1;\n                }\n            }\n\n            // 両端が i, j でない時はスルー\n            if left != i || right != j {\n                continue;\n            }\n\n            // 凸包の面積が 0 であるような部分集合のサイズ\n            let subset = mod_pow(2, count, modulo) - count - 1;\n            ans = (ans + modulo - subset) % modulo;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\nfn read_line() -> String {\n    let stdin = io::stdin();\n    let mut buf = String::new();\n    stdin.read_line(&mut buf).unwrap();\n    buf\n}\n\nfn read_values<T>() -> Vec<T>\n    where T: std::str::FromStr,\n          T::Err: std::fmt::Debug\n{\n    read_line()\n        .split(' ')\n        .map(|a| a.trim().parse().unwrap())\n        .collect()\n}"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst MOD: usize = 998244353;\n\nfn mod_pow(x: usize, e: usize) -> usize {\n    let mut cur = x;\n    let mut e = e;\n    let mut result = 1;\n    while e > 0 {\n        if e & 1 != 0 {\n            result = (result * cur) % MOD;\n        }\n        e >>= 1;\n        cur = (cur * cur) % MOD;\n    }\n    result\n}\n\nfn main() {\n    let mut sc = Scanner::new();\n    let n = sc.read();\n    let vertices: Vec<(i64, i64)> = (0..n).map(|_| (sc.read(), sc.read())).collect();\n    let mut ans = mod_pow(2, n);\n    ans = (ans + MOD - n - 1) % MOD;\n    for i in 0..n {\n        for j in (i + 1)..n {\n            let mut l_id = i;\n            let mut r_id = j;\n            let (lx, ly) = vertices[i];\n            let (rx, ry) = vertices[j];\n            let dx = lx - rx;\n            let dy = ly - ry;\n            let mut count = 0;\n            for (k, &(x, y)) in vertices.iter().enumerate() {\n                let tx = x - rx;\n                let ty = y - ry;\n                if dx * ty == dy * tx {\n                    count += 1;\n                    l_id = cmp::min(l_id, k);\n                    r_id = cmp::max(r_id, k);\n                }\n            }\n            if l_id != i || r_id != j {\n                continue;\n            }\n            ans = (ans + MOD - mod_pow(2, count) + count + 1) % MOD;\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\n#[allow(dead_code)]\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner {\n            ptr: 0,\n            length: 0,\n            buf: vec![0; 1024],\n            small_cache: vec![0; 1024],\n        }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool {\n        b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' '\n    }\n\n    fn read_vec<T>(&mut self, n: usize) -> Vec<T>\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        (0..n).map(|_| self.read()).collect()\n    }\n\n    fn usize_read(&mut self) -> usize {\n        self.read()\n    }\n\n    fn read<T>(&mut self) -> T\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)])\n                    .parse()\n                    .unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n// modint {{{\n#[allow(dead_code)]\nmod modint {\n    use std::{\n        cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd},\n        fmt::{Debug, Display},\n        iter::{Product, Sum},\n        mem::swap,\n        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n    };\n\n    pub type ModValue = i64;\n\n    #[derive(Debug, Clone, Copy)]\n    struct Rational {\n        num: ModValue,\n        den: ModValue,\n    }\n\n    #[allow(clippy::many_single_char_names)]\n    fn red(r: i64, p: i64) -> (i64, i64, i64) {\n        if r.abs() <= 10000 {\n            return (r, 1, 0);\n        }\n        let mut nxt_r = p % r;\n        let mut q = p / r;\n        if 2 * nxt_r >= r {\n            nxt_r -= r;\n            q += 1;\n        }\n        if 2 * nxt_r <= -r {\n            nxt_r += r;\n            q -= 1;\n        }\n        let (x, z, y) = red(nxt_r, r);\n        (x, y - q * z, z)\n    }\n\n    #[derive(Clone, Copy)]\n    pub struct Mint<Mod: ModTrait>(ModValue, std::marker::PhantomData<Mod>);\n\n    impl<Mod: ModTrait> Mint<Mod> {\n        fn from_value_unchecked(value: ModValue) -> Self {\n            Self(value, std::marker::PhantomData)\n        }\n        fn normalize(value: ModValue) -> ModValue {\n            let value = value % Mod::modulus();\n            if 0 <= value {\n                value\n            } else {\n                value + Mod::modulus()\n            }\n        }\n        fn guess(&self) -> Rational {\n            let (mut num, mut den, _) = red(self.0, Mod::modulus());\n            if den < 0 {\n                num = -num;\n                den = -den;\n            }\n            Rational { num, den }\n        }\n        pub fn from_i64(value: ModValue) -> Self {\n            Self::from_value_unchecked(Self::normalize(value))\n        }\n        pub fn from_frac(num: ModValue, den: ModValue) -> Self {\n            Self::from_i64(num) / Self::from_i64(den)\n        }\n        pub fn zero() -> Self {\n            Self::from_value_unchecked(0)\n        }\n        pub fn one() -> Self {\n            Self::from_value_unchecked(1)\n        }\n        #[allow(clippy::many_single_char_names)]\n        pub fn inv(self) -> Self {\n            assert_ne!(\n                self,\n                Self::zero(),\n                \"attempted to take the inverse of zero mint\"\n            );\n            let mut x = self.0;\n            let mut y = Mod::modulus();\n            let mut u = 1;\n            let mut v = 0;\n            while x != 0 {\n                let q = y / x;\n                y -= q * x;\n                v -= q * u;\n                swap(&mut x, &mut y);\n                swap(&mut u, &mut v);\n            }\n            assert!(x == 0 && y == 1 && u.abs() == Mod::modulus() && v.abs() < Mod::modulus());\n            Self::from_value_unchecked(if v < 0 { v + Mod::modulus() } else { v })\n        }\n        pub fn pow(mut self, mut p: u64) -> Self {\n            let mut ans = Self::one();\n            while 0 != p {\n                if p % 2 == 1 {\n                    ans *= self;\n                }\n                self *= self;\n                p /= 2;\n            }\n            ans\n        }\n        pub fn from_pow(a: ModValue, p: u64) -> Self {\n            Self::from_i64(a).pow(p)\n        }\n    }\n\n    impl<Mod: ModTrait> Debug for Mint<Mod> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            let Rational { num, den } = self.guess();\n            f.debug_tuple(\"Mint\")\n                .field(&if den == 1 {\n                    num.to_string()\n                } else {\n                    format!(\"{}/{}\", num, den)\n                })\n                .finish()\n        }\n    }\n\n    impl<Mod: ModTrait> Display for Mint<Mod> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    macro_rules! forward_ref_binop {\n        ($(impl $imp:ident, $method:ident)*) => {\n            $(\n                impl<'a, Mod: ModTrait> $imp<Mint<Mod>> for &'a Mint<Mod> {\n                    type Output = Mint<Mod>;\n\n                    #[inline]\n                    fn $method(self, other: Mint<Mod>) -> Self::Output {\n                        $imp::$method(*self, other)\n                    }\n                }\n\n                impl<'a, Mod: ModTrait> $imp<&'a Mint<Mod>> for Mint<Mod> {\n                    type Output = Mint<Mod>;\n\n                    #[inline]\n                    fn $method(self, other: &Mint<Mod>) -> Self::Output {\n                        $imp::$method(self, *other)\n                    }\n                }\n\n                impl<'a, Mod: ModTrait> $imp<&'a Mint<Mod>> for &'a Mint<Mod> {\n                    type Output = Mint<Mod>;\n\n                    #[inline]\n                    fn $method(self, other: &Mint<Mod>) -> Self::Output {\n                        $imp::$method(*self, *other)\n                    }\n                }\n            )*\n        };\n    }\n\n    macro_rules! forward_ref_op_assign {\n        ($(impl $imp:ident, $method:ident)*) => {\n            $(\n                impl<'a, Mod: ModTrait> $imp<&Mint<Mod>> for Mint<Mod> {\n                    #[inline]\n                    fn $method(&mut self, other: &Mint<Mod>) {\n                        $imp::$method(self, *other);\n                    }\n                }\n            )*\n        }\n    }\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    impl<Mod: ModTrait> Add for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn add(self, rhs: Self) -> Self {\n            let value = self.0 + rhs.0;\n            Self::from_value_unchecked(if value < Mod::modulus() {\n                value\n            } else {\n                value - Mod::modulus()\n            })\n        }\n    }\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    impl<Mod: ModTrait> Sub for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn sub(self, rhs: Self) -> Self {\n            let value = self.0 - rhs.0;\n            Self::from_value_unchecked(if 0 <= value {\n                value\n            } else {\n                value + Mod::modulus()\n            })\n        }\n    }\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    impl<Mod: ModTrait> Mul for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn mul(self, rhs: Self) -> Self {\n            Self::from_value_unchecked(self.0 * rhs.0 % Mod::modulus())\n        }\n    }\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    impl<Mod: ModTrait> Div for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn div(self, rhs: Self) -> Self {\n            self * rhs.inv()\n        }\n    }\n\n    impl<Mod: ModTrait> Neg for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn neg(self) -> Self {\n            if self.0 == 0 {\n                Self::zero()\n            } else {\n                Self::from_value_unchecked(Mod::modulus() - self.0)\n            }\n        }\n    }\n\n    impl<Mod: ModTrait> Neg for &Mint<Mod> {\n        type Output = Mint<Mod>;\n\n        #[inline]\n        fn neg(self) -> Self::Output {\n            (*self).neg()\n        }\n    }\n\n    macro_rules! forward_assign_biop {\n        ($(impl $trait: ident, $fn_assign: ident, $fn: ident)*) => {\n            $(\n                impl<Mod: ModTrait> $trait for Mint<Mod> {\n                    #[inline]\n                    fn $fn_assign(&mut self, rhs: Self) {\n                        *self = self.$fn(rhs);\n                    }\n                }\n            )*\n        };\n    }\n\n    forward_assign_biop! {\n        impl AddAssign, add_assign, add\n        impl SubAssign, sub_assign, sub\n        impl MulAssign, mul_assign, mul\n        impl DivAssign, div_assign, div\n    }\n\n    forward_ref_binop! {\n        impl Add, add\n        impl Sub, sub\n        impl Mul, mul\n        impl Div, div\n    }\n\n    forward_ref_op_assign! {\n        impl AddAssign, add_assign\n        impl SubAssign, sub_assign\n        impl MulAssign, mul_assign\n        impl DivAssign, div_assign\n    }\n\n    impl<Mod: ModTrait> PartialEq for Mint<Mod> {\n        fn eq(&self, other: &Self) -> bool {\n            self.0 == other.0\n        }\n    }\n    impl<Mod: ModTrait> Eq for Mint<Mod> {}\n    impl<Mod: ModTrait> Ord for Mint<Mod> {\n        fn cmp(&self, other: &Self) -> Ordering {\n            self.0.cmp(&other.0)\n        }\n    }\n    impl<Mod: ModTrait> PartialOrd for Mint<Mod> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            Some(self.cmp(other))\n        }\n    }\n\n    impl<Mod: ModTrait> From<ModValue> for Mint<Mod> {\n        fn from(value: ModValue) -> Self {\n            Self::from_i64(value)\n        }\n    }\n\n    impl<Mod: ModTrait> From<Mint<Mod>> for ModValue {\n        fn from(mint: Mint<Mod>) -> Self {\n            mint.0\n        }\n    }\n\n    impl<Mod: ModTrait> Sum for Mint<Mod> {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = Self>,\n        {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<'a, Mod: 'a + ModTrait> Sum<&'a Self> for Mint<Mod> {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = &'a Self>,\n        {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<Mod: ModTrait> Product for Mint<Mod> {\n        fn product<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = Self>,\n        {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<'a, Mod: 'a + ModTrait> Product<&'a Self> for Mint<Mod> {\n        fn product<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = &'a Self>,\n        {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n\n    #[macro_export]\n    macro_rules! mint {\n        ($value: expr) => {\n            Mint::from_i64($value)\n        };\n    }\n\n    #[macro_export]\n    macro_rules! from_frac {\n        ($num: expr, $den: expr) => {\n            Mint::from_frac($num, $den)\n        };\n    }\n\n    #[macro_export]\n    macro_rules! from_pow {\n        ($a: expr, $b: expr) => {\n            Mint::from_pow($a, $b)\n        };\n    }\n\n    pub trait ModTrait: Clone + Copy + Debug {\n        fn modulus() -> ModValue;\n    }\n\n    #[derive(Debug, Clone)]\n    pub struct Factorial<Mod: ModTrait> {\n        normal: Vec<Mint<Mod>>,\n        inverse: Vec<Mint<Mod>>,\n    }\n\n    impl<Mod: ModTrait> Factorial<Mod> {\n        pub fn is_empty(&self) -> bool {\n            self.normal.is_empty()\n        }\n        pub fn len(&self) -> usize {\n            self.normal.len()\n        }\n        pub fn with_len(len: usize) -> Self {\n            if len == 0 {\n                Self {\n                    normal: Vec::new(),\n                    inverse: Vec::new(),\n                }\n            } else {\n                let mut normal = vec![Mint::one(); len];\n                for i in 1..len {\n                    normal[i] = normal[i - 1] * Mint::from_i64(i as i64);\n                }\n                let mut inverse = vec![normal.last().unwrap().inv(); len];\n                for i in (1..len).rev() {\n                    inverse[i - 1] = inverse[i] * Mint::from_i64(i as i64);\n                }\n                Self { normal, inverse }\n            }\n        }\n        pub fn inv(&self, i: usize) -> Mint<Mod> {\n            self.inverse[i]\n        }\n        pub fn falling(&self, n: usize, p: usize) -> Mint<Mod> {\n            if p == 0 {\n                Mint::one()\n            } else if n < p {\n                Mint::zero()\n            } else {\n                self[n] * self.inv(n - p)\n            }\n        }\n        pub fn binom(&self, n: usize, k: usize) -> Mint<Mod> {\n            if k == 0 {\n                Mint::one()\n            } else if n < k {\n                Mint::zero()\n            } else {\n                self[n] * self.inv(n - k) * self.inv(k)\n            }\n        }\n    }\n\n    impl<Mod: ModTrait, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mod100000007 {}\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mod998244353 {}\n    impl ModTrait for Mod100000007 {\n        fn modulus() -> ModValue {\n            1_000_000_007\n        }\n    }\n    impl ModTrait for Mod998244353 {\n        fn modulus() -> ModValue {\n            998_244_353\n        }\n    }\n    pub type Mint100000007 = Mint<Mod100000007>;\n\n    pub type Mint998244353 = Mint<Mod998244353>;\n}\n// }}}\ntype Mint = modint::Mint100000007;\n\nfn main() {\n    input!(n: usize, xy: [(i32, i32); n]);\n    let max = 10_000;\n    let mut g = vec![vec![false; max + 1]; max + 1];\n    for &(x, y) in &xy {\n        g[x as usize][y as usize] = true;\n    }\n    let mut pow_of_two = vec![Mint::one(); n + 1];\n    for i in 0..n {\n        pow_of_two[i + 1] = pow_of_two[i] + pow_of_two[i];\n    }\n    let mut ans = pow_of_two[n] - Mint::from_i64(n as i64) - Mint::one();\n    for &(x, y) in &xy {\n        for &(x1, y1) in xy.iter().filter(|&p| p != &(x, y)) {\n            let mut pts = vec![(x, y), (x1, y1)];\n            for &(x2, y2) in xy.iter().filter(|&p| p != &(x, y) && p != &(x1, y1)) {\n                let det = (x1 - x) * (y2 - y) - (x2 - x) * (y1 - y);\n                if det == 0 {\n                    pts.push((x2, y2));\n                }\n            }\n            pts.sort();\n            if pts[0] == (x, y) && pts[1] == (x1, y1) {\n                let cnt = pts.len();\n                ans -= pow_of_two[cnt] - Mint::from_i64(cnt as i64) - Mint::one();\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n// modint {{{\n#[allow(dead_code)]\nmod modint {\n    use std::{\n        cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd},\n        fmt::{Debug, Display},\n        iter::{Product, Sum},\n        mem::swap,\n        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n    };\n\n    pub type ModValue = i64;\n\n    #[derive(Debug, Clone, Copy)]\n    struct Rational {\n        num: ModValue,\n        den: ModValue,\n    }\n\n    #[allow(clippy::many_single_char_names)]\n    fn red(r: i64, p: i64) -> (i64, i64, i64) {\n        if r.abs() <= 10000 {\n            return (r, 1, 0);\n        }\n        let mut nxt_r = p % r;\n        let mut q = p / r;\n        if 2 * nxt_r >= r {\n            nxt_r -= r;\n            q += 1;\n        }\n        if 2 * nxt_r <= -r {\n            nxt_r += r;\n            q -= 1;\n        }\n        let (x, z, y) = red(nxt_r, r);\n        (x, y - q * z, z)\n    }\n\n    #[derive(Clone, Copy)]\n    pub struct Mint<Mod: ModTrait>(ModValue, std::marker::PhantomData<Mod>);\n\n    impl<Mod: ModTrait> Mint<Mod> {\n        fn from_value_unchecked(value: ModValue) -> Self {\n            Self(value, std::marker::PhantomData)\n        }\n        fn normalize(value: ModValue) -> ModValue {\n            let value = value % Mod::modulus();\n            if 0 <= value {\n                value\n            } else {\n                value + Mod::modulus()\n            }\n        }\n        fn guess(&self) -> Rational {\n            let (mut num, mut den, _) = red(self.0, Mod::modulus());\n            if den < 0 {\n                num = -num;\n                den = -den;\n            }\n            Rational { num, den }\n        }\n        pub fn from_i64(value: ModValue) -> Self {\n            Self::from_value_unchecked(Self::normalize(value))\n        }\n        pub fn from_frac(num: ModValue, den: ModValue) -> Self {\n            Self::from_i64(num) / Self::from_i64(den)\n        }\n        pub fn zero() -> Self {\n            Self::from_value_unchecked(0)\n        }\n        pub fn one() -> Self {\n            Self::from_value_unchecked(1)\n        }\n        #[allow(clippy::many_single_char_names)]\n        pub fn inv(self) -> Self {\n            assert_ne!(\n                self,\n                Self::zero(),\n                \"attempted to take the inverse of zero mint\"\n            );\n            let mut x = self.0;\n            let mut y = Mod::modulus();\n            let mut u = 1;\n            let mut v = 0;\n            while x != 0 {\n                let q = y / x;\n                y -= q * x;\n                v -= q * u;\n                swap(&mut x, &mut y);\n                swap(&mut u, &mut v);\n            }\n            assert!(x == 0 && y == 1 && u.abs() == Mod::modulus() && v.abs() < Mod::modulus());\n            Self::from_value_unchecked(if v < 0 { v + Mod::modulus() } else { v })\n        }\n        pub fn pow(mut self, mut p: u64) -> Self {\n            let mut ans = Self::one();\n            while 0 != p {\n                if p % 2 == 1 {\n                    ans *= self;\n                }\n                self *= self;\n                p /= 2;\n            }\n            ans\n        }\n        pub fn from_pow(a: ModValue, p: u64) -> Self {\n            Self::from_i64(a).pow(p)\n        }\n    }\n\n    impl<Mod: ModTrait> Debug for Mint<Mod> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            let Rational { num, den } = self.guess();\n            f.debug_tuple(\"Mint\")\n                .field(&if den == 1 {\n                    num.to_string()\n                } else {\n                    format!(\"{}/{}\", num, den)\n                })\n                .finish()\n        }\n    }\n\n    impl<Mod: ModTrait> Display for Mint<Mod> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    macro_rules! forward_ref_binop {\n        ($(impl $imp:ident, $method:ident)*) => {\n            $(\n                impl<'a, Mod: ModTrait> $imp<Mint<Mod>> for &'a Mint<Mod> {\n                    type Output = Mint<Mod>;\n\n                    #[inline]\n                    fn $method(self, other: Mint<Mod>) -> Self::Output {\n                        $imp::$method(*self, other)\n                    }\n                }\n\n                impl<'a, Mod: ModTrait> $imp<&'a Mint<Mod>> for Mint<Mod> {\n                    type Output = Mint<Mod>;\n\n                    #[inline]\n                    fn $method(self, other: &Mint<Mod>) -> Self::Output {\n                        $imp::$method(self, *other)\n                    }\n                }\n\n                impl<'a, Mod: ModTrait> $imp<&'a Mint<Mod>> for &'a Mint<Mod> {\n                    type Output = Mint<Mod>;\n\n                    #[inline]\n                    fn $method(self, other: &Mint<Mod>) -> Self::Output {\n                        $imp::$method(*self, *other)\n                    }\n                }\n            )*\n        };\n    }\n\n    macro_rules! forward_ref_op_assign {\n        ($(impl $imp:ident, $method:ident)*) => {\n            $(\n                impl<'a, Mod: ModTrait> $imp<&Mint<Mod>> for Mint<Mod> {\n                    #[inline]\n                    fn $method(&mut self, other: &Mint<Mod>) {\n                        $imp::$method(self, *other);\n                    }\n                }\n            )*\n        }\n    }\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    impl<Mod: ModTrait> Add for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn add(self, rhs: Self) -> Self {\n            let value = self.0 + rhs.0;\n            Self::from_value_unchecked(if value < Mod::modulus() {\n                value\n            } else {\n                value - Mod::modulus()\n            })\n        }\n    }\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    impl<Mod: ModTrait> Sub for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn sub(self, rhs: Self) -> Self {\n            let value = self.0 - rhs.0;\n            Self::from_value_unchecked(if 0 <= value {\n                value\n            } else {\n                value + Mod::modulus()\n            })\n        }\n    }\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    impl<Mod: ModTrait> Mul for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn mul(self, rhs: Self) -> Self {\n            Self::from_value_unchecked(self.0 * rhs.0 % Mod::modulus())\n        }\n    }\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    impl<Mod: ModTrait> Div for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn div(self, rhs: Self) -> Self {\n            self * rhs.inv()\n        }\n    }\n\n    impl<Mod: ModTrait> Neg for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn neg(self) -> Self {\n            if self.0 == 0 {\n                Self::zero()\n            } else {\n                Self::from_value_unchecked(Mod::modulus() - self.0)\n            }\n        }\n    }\n\n    impl<Mod: ModTrait> Neg for &Mint<Mod> {\n        type Output = Mint<Mod>;\n\n        #[inline]\n        fn neg(self) -> Self::Output {\n            (*self).neg()\n        }\n    }\n\n    macro_rules! forward_assign_biop {\n        ($(impl $trait: ident, $fn_assign: ident, $fn: ident)*) => {\n            $(\n                impl<Mod: ModTrait> $trait for Mint<Mod> {\n                    #[inline]\n                    fn $fn_assign(&mut self, rhs: Self) {\n                        *self = self.$fn(rhs);\n                    }\n                }\n            )*\n        };\n    }\n\n    forward_assign_biop! {\n        impl AddAssign, add_assign, add\n        impl SubAssign, sub_assign, sub\n        impl MulAssign, mul_assign, mul\n        impl DivAssign, div_assign, div\n    }\n\n    forward_ref_binop! {\n        impl Add, add\n        impl Sub, sub\n        impl Mul, mul\n        impl Div, div\n    }\n\n    forward_ref_op_assign! {\n        impl AddAssign, add_assign\n        impl SubAssign, sub_assign\n        impl MulAssign, mul_assign\n        impl DivAssign, div_assign\n    }\n\n    impl<Mod: ModTrait> PartialEq for Mint<Mod> {\n        fn eq(&self, other: &Self) -> bool {\n            self.0 == other.0\n        }\n    }\n    impl<Mod: ModTrait> Eq for Mint<Mod> {}\n    impl<Mod: ModTrait> Ord for Mint<Mod> {\n        fn cmp(&self, other: &Self) -> Ordering {\n            self.0.cmp(&other.0)\n        }\n    }\n    impl<Mod: ModTrait> PartialOrd for Mint<Mod> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            Some(self.cmp(other))\n        }\n    }\n\n    impl<Mod: ModTrait> From<ModValue> for Mint<Mod> {\n        fn from(value: ModValue) -> Self {\n            Self::from_i64(value)\n        }\n    }\n\n    impl<Mod: ModTrait> From<Mint<Mod>> for ModValue {\n        fn from(mint: Mint<Mod>) -> Self {\n            mint.0\n        }\n    }\n\n    impl<Mod: ModTrait> Sum for Mint<Mod> {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = Self>,\n        {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<'a, Mod: 'a + ModTrait> Sum<&'a Self> for Mint<Mod> {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = &'a Self>,\n        {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<Mod: ModTrait> Product for Mint<Mod> {\n        fn product<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = Self>,\n        {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<'a, Mod: 'a + ModTrait> Product<&'a Self> for Mint<Mod> {\n        fn product<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = &'a Self>,\n        {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n\n    #[macro_export]\n    macro_rules! mint {\n        ($value: expr) => {\n            Mint::from_i64($value)\n        };\n    }\n\n    #[macro_export]\n    macro_rules! from_frac {\n        ($num: expr, $den: expr) => {\n            Mint::from_frac($num, $den)\n        };\n    }\n\n    #[macro_export]\n    macro_rules! from_pow {\n        ($a: expr, $b: expr) => {\n            Mint::from_pow($a, $b)\n        };\n    }\n\n    pub trait ModTrait: Clone + Copy + Debug {\n        fn modulus() -> ModValue;\n    }\n\n    #[derive(Debug, Clone)]\n    pub struct Factorial<Mod: ModTrait> {\n        normal: Vec<Mint<Mod>>,\n        inverse: Vec<Mint<Mod>>,\n    }\n\n    impl<Mod: ModTrait> Factorial<Mod> {\n        pub fn is_empty(&self) -> bool {\n            self.normal.is_empty()\n        }\n        pub fn len(&self) -> usize {\n            self.normal.len()\n        }\n        pub fn with_len(len: usize) -> Self {\n            if len == 0 {\n                Self {\n                    normal: Vec::new(),\n                    inverse: Vec::new(),\n                }\n            } else {\n                let mut normal = vec![Mint::one(); len];\n                for i in 1..len {\n                    normal[i] = normal[i - 1] * Mint::from_i64(i as i64);\n                }\n                let mut inverse = vec![normal.last().unwrap().inv(); len];\n                for i in (1..len).rev() {\n                    inverse[i - 1] = inverse[i] * Mint::from_i64(i as i64);\n                }\n                Self { normal, inverse }\n            }\n        }\n        pub fn inv(&self, i: usize) -> Mint<Mod> {\n            self.inverse[i]\n        }\n        pub fn falling(&self, n: usize, p: usize) -> Mint<Mod> {\n            if p == 0 {\n                Mint::one()\n            } else if n < p {\n                Mint::zero()\n            } else {\n                self[n] * self.inv(n - p)\n            }\n        }\n        pub fn binom(&self, n: usize, k: usize) -> Mint<Mod> {\n            if k == 0 {\n                Mint::one()\n            } else if n < k {\n                Mint::zero()\n            } else {\n                self[n] * self.inv(n - k) * self.inv(k)\n            }\n        }\n    }\n\n    impl<Mod: ModTrait, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mod100000007 {}\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mod998244353 {}\n    impl ModTrait for Mod100000007 {\n        fn modulus() -> ModValue {\n            1_000_000_007\n        }\n    }\n    impl ModTrait for Mod998244353 {\n        fn modulus() -> ModValue {\n            998_244_353\n        }\n    }\n    pub type Mint100000007 = Mint<Mod100000007>;\n\n    pub type Mint998244353 = Mint<Mod998244353>;\n}\n// }}}\ntype Mint = modint::Mint998244353;\n\nfn main() {\n    input!(n: usize, xy: [(i32, i32); n]);\n    let max = 10_000;\n    let mut g = vec![vec![false; max + 1]; max + 1];\n    for &(x, y) in &xy {\n        g[x as usize][y as usize] = true;\n    }\n    let mut pow_of_two = vec![Mint::one(); n + 1];\n    for i in 0..n {\n        pow_of_two[i + 1] = pow_of_two[i] + pow_of_two[i];\n    }\n    let mut ans = pow_of_two[n] - Mint::from_i64(n as i64) - Mint::one();\n    for &(x, y) in &xy {\n        for &(x1, y1) in xy.iter().filter(|&p| p != &(x, y)) {\n            let mut pts = vec![(x, y), (x1, y1)];\n            for &(x2, y2) in xy.iter().filter(|&p| p != &(x, y) && p != &(x1, y1)) {\n                let det = (x1 - x) * (y2 - y) - (x2 - x) * (y1 - y);\n                if det == 0 {\n                    pts.push((x2, y2));\n                }\n            }\n            pts.sort();\n            if pts[0] == (x, y) && pts[1] == (x1, y1) {\n                let cnt = pts.len();\n                ans -= pow_of_two[cnt] - Mint::from_i64(cnt as i64) - Mint::one();\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\nuse std::str;\nuse std::usize;\nuse std::cmp;\n\nfn mod_pow(x: i64, mut exp: i64, modulo: i64) -> i64 {\n    let mut result = 1;\n    let mut cur = x;\n    while exp > 0 {\n        if exp & 1 == 1 {\n            result = (result * cur) % modulo;\n        }\n        cur = (cur * cur) % modulo;\n        exp >>= 1;\n    }\n    result\n}\n\nfn main() {\n    let modulo = 998244353;\n    let n = read_values::<usize>()[0];\n    let (x, y) = {\n        let mut x = vec![0; n];\n        let mut y = vec![0; n];\n        for i in 0..n {\n            let v = read_values::<i64>();\n            x[i] = v[0];\n            y[i] = v[1];\n        }\n        (x, y)\n    };\n\n    let mut ans = mod_pow(2, n as i64, modulo);\n    ans -= 1;\n    ans -= n as i64;\n    ans = (ans + modulo) % modulo;\n\n    for i in 0..n {\n        for j in (i + 1)..n {\n            let dx = x[i] - x[j];\n            let dy = y[i] - y[j];\n\n            let mut count = 0;\n            let mut left = i;\n            let mut right = j;\n            for k in 0..n {\n                let kx = x[i] - x[k];\n                let ky = y[i] - y[k];\n                if dx * ky - kx * dy == 0 {\n                    left = cmp::min(left, k);\n                    right = cmp::max(right, k);\n                    count += 1;\n                }\n            }\n\n            if left == i && right == j {\n                let subset = mod_pow(2, count, modulo) - count - 1;\n                ans = (ans + modulo - subset) % modulo;\n            }\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\nfn read_line() -> String {\n    let stdin = io::stdin();\n    let mut buf = String::new();\n    stdin.read_line(&mut buf).unwrap();\n    buf\n}\n\nfn read_values<T>() -> Vec<T>\n    where T: std::str::FromStr,\n          T::Err: std::fmt::Debug\n{\n    read_line()\n        .split(' ')\n        .map(|a| a.trim().parse().unwrap())\n        .collect()\n}"
  },
  {
    "language": "Rust",
    "code": "use io::*;\nuse std::collections::HashSet;\nuse std::cmp;\n\nfn main() {\n    let input = read_string();\n    let mut sc = Scanner::new(&input);\n    let n: i64 = sc.next();\n    let ps: Vec<Vec<i64>> = sc.next_mat(2, n as usize);\n    let mut lines: HashSet<(i64,i64,i64)> = HashSet::new();\n    let M = 998244353;\n    let mut ans = count_m(n, M);\n    for i in 0..n as usize {\n        for j in i+1..n as usize {\n            let mut a = ps[j][1] - ps[i][1];\n            let mut b = ps[i][0] - ps[j][0];\n            let g = gcd(a,b);\n            a /= g;\n            b /= g;\n            let c = ps[i][0] * ps[j][1] - ps[j][0] * ps[i][1];\n            if lines.contains(&(a,b,c)) {\n                continue;\n            }\n            let mut cnt = 0;\n            for k in 0..n as usize {\n                if ps[k][0] * a + ps[k][1] * b == c {\n                    cnt += 1;\n                }\n            }\n            lines.insert((a,b,c));\n            ans = (ans + M - count_m(cnt, M)) % M;\n        }\n    }\n    println!(\"{}\",ans);\n}\n\nfn count_m(n: i64, M: i64) -> i64 {\n    (pow_m(2,n,M) + M - n * (n+1) / 2 - 1) % M\n}\n\nfn pow_m(a: i64, mut n: i64, M: i64) -> i64 {\n    let mut r = a % M;\n    let mut ret = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            ret = ret * r % M;\n            n -= 1;\n        } else {\n            r = r * r % M;\n            n /= 2;\n        }\n    }\n    ret\n}\n\nfn gcd(a: i64, b: i64) -> i64 {\n    let aa = a.abs();\n    let ba = b.abs();\n    let mut x = cmp::min(aa,ba);\n    let mut y = cmp::max(aa,ba);\n    while x > 0 {\n        let t = x;\n        x = y % x;\n        y = t;\n    }\n    y\n}\n\npub mod io {\n    use std;\n    use std::str::FromStr;\n\n    pub struct Scanner<'a> {\n        iter: std::str::SplitWhitespace<'a>,\n    }\n\n    impl<'a> Scanner<'a> {\n        pub fn new(s: &'a str) -> Scanner<'a> {\n            Scanner {\n                iter: s.split_whitespace(),\n            }\n        }\n\n        pub fn next<T: FromStr>(&mut self) -> T {\n            let s = self.iter.next().unwrap();\n            if let Ok(v) = s.parse::<T>() {\n                v\n            } else {\n                panic!(\"Parse error\")\n            }\n        }\n\n        pub fn next_vec_len<T: FromStr>(&mut self) -> Vec<T> {\n            let n: usize = self.next();\n            self.next_vec(n)\n        }\n\n        pub fn next_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n            (0..n).map(|_| self.next()).collect()\n        }\n\n        pub fn next_mat<T: FromStr>(&mut self, w: usize, h: usize) -> Vec<Vec<T>> {\n            (0..h).map(|_| self.next_vec(w)).collect()\n        }\n\n        pub fn next_vec_char(&mut self) -> Vec<char> {\n            self.next::<String>().chars().collect()\n        }\n\n        pub fn next_mat_char(&mut self, n: usize) -> Vec<Vec<char>> {\n            (0..n).map(|_| self.next_vec_char()).collect()\n        }\n    }\n\n    pub fn read_string() -> String {\n        use std::io::Read;\n\n        let mut s = String::new();\n        std::io::stdin().read_to_string(&mut s).unwrap();\n        s\n    }\n\n    pub fn read_line() -> String {\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        s.trim_right().to_owned()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\nuse std::str;\nuse std::usize;\nuse std::cmp;\n\nfn mod_pow(x: i64, mut exp: i64, modulo: i64) -> i64 {\n    let mut result = 1;\n    let mut cur = x;\n    while exp > 0 {\n        if exp & 1 == 1 {\n            result = (result * cur) % modulo;\n        }\n        cur = (cur * cur) % modulo;\n        exp >>= 1;\n    }\n    result\n}\n\nfn main() {\n    let modulo = 998244353;\n    let n = read_values::<usize>()[0];\n    let (x, y) = {\n        let mut x = vec![0; n];\n        let mut y = vec![0; n];\n        for i in 0..n {\n            let v = read_values::<i32>();\n            x[i] = v[0];\n            y[i] = v[1];\n        }\n        (x, y)\n    };\n\n    let mut ans = mod_pow(2, n as i64, modulo) - (n as i64) - 1;\n    for i in 0..n {\n        for j in (i + 1)..n {\n            let dx = x[j] - x[i];\n            let dy = y[j] - y[i];\n\n            let mut count = 0;\n            let mut min = n;\n            let mut max = 0;\n            for t in 0..n {\n                let tx = x[t] - x[i];\n                let ty = y[t] - y[i];\n                if (tx * dy - ty * dx).abs() != 0 {\n                    continue;\n                }\n\n                min = cmp::min(min, t);\n                max = cmp::max(max, t);\n                count += 1;\n            }\n\n            if min != i || max != j {\n                continue;\n            }\n\n            ans = (ans - (mod_pow(2, count, modulo) - count - 1) + modulo) % modulo;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\nfn read_line() -> String {\n    let stdin = io::stdin();\n    let mut buf = String::new();\n    stdin.read_line(&mut buf).unwrap();\n    buf\n}\n\nfn read_values<T>() -> Vec<T>\n    where T: std::str::FromStr,\n          T::Err: std::fmt::Debug\n{\n    read_line()\n        .split(' ')\n        .map(|a| a.trim().parse().unwrap())\n        .collect()\n}"
  },
  {
    "language": "Rust",
    "code": "use io::*;\nuse std::collections::HashSet;\nuse std::cmp;\n\nfn main() {\n    let input = read_string();\n    let mut sc = Scanner::new(&input);\n    let n: i64 = sc.next();\n    let ps: Vec<Vec<i64>> = sc.next_mat(2, n as usize);\n    let mut lines: HashSet<(i64,i64,i64)> = HashSet::new();\n    let M = 998244353;\n    let mut ans = count_m(n, M);\n    for i in 0..n as usize {\n        for j in i+1..n as usize {\n            let mut a = ps[j][1] - ps[i][1];\n            let mut b = ps[i][0] - ps[j][0];\n            let g = gcd(a,b);\n            a /= g;\n            b /= g;\n            let mut c = a * ps[i][0] + b * ps[i][1];\n            if a < 0 || (a == 0 && b < 0) {\n                a *= -1;\n                b *= -1;\n                c *= -1;\n            }\n            if lines.contains(&(a,b,c)) {\n                continue;\n            }\n            let mut cnt = 0;\n            for k in 0..n as usize {\n                if ps[k][0] * a + ps[k][1] * b == c {\n                    cnt += 1;\n                }\n            }\n            lines.insert((a,b,c));\n            ans = (ans + M - count_m(cnt, M)) % M;\n        }\n    }\n    println!(\"{}\",ans);\n}\n\nfn count_m(n: i64, M: i64) -> i64 {\n    if n < 3 {\n        0\n    } else {\n        (pow_m(2,n,M) + M - n * (n+1) / 2 - 1) % M\n    }\n}\n\nfn pow_m(a: i64, mut n: i64, M: i64) -> i64 {\n    let mut r = a % M;\n    let mut ret = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            ret = ret * r % M;\n            n -= 1;\n        } else {\n            r = r * r % M;\n            n /= 2;\n        }\n    }\n    ret\n}\n\nfn gcd(a: i64, b: i64) -> i64 {\n    let aa = a.abs();\n    let ba = b.abs();\n    let mut x = cmp::min(aa,ba);\n    let mut y = cmp::max(aa,ba);\n    while x > 0 {\n        let t = x;\n        x = y % x;\n        y = t;\n    }\n    y\n}\n\npub mod io {\n    use std;\n    use std::str::FromStr;\n\n    pub struct Scanner<'a> {\n        iter: std::str::SplitWhitespace<'a>,\n    }\n\n    impl<'a> Scanner<'a> {\n        pub fn new(s: &'a str) -> Scanner<'a> {\n            Scanner {\n                iter: s.split_whitespace(),\n            }\n        }\n\n        pub fn next<T: FromStr>(&mut self) -> T {\n            let s = self.iter.next().unwrap();\n            if let Ok(v) = s.parse::<T>() {\n                v\n            } else {\n                panic!(\"Parse error\")\n            }\n        }\n\n        pub fn next_vec_len<T: FromStr>(&mut self) -> Vec<T> {\n            let n: usize = self.next();\n            self.next_vec(n)\n        }\n\n        pub fn next_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n            (0..n).map(|_| self.next()).collect()\n        }\n\n        pub fn next_mat<T: FromStr>(&mut self, w: usize, h: usize) -> Vec<Vec<T>> {\n            (0..h).map(|_| self.next_vec(w)).collect()\n        }\n\n        pub fn next_vec_char(&mut self) -> Vec<char> {\n            self.next::<String>().chars().collect()\n        }\n\n        pub fn next_mat_char(&mut self, n: usize) -> Vec<Vec<char>> {\n            (0..n).map(|_| self.next_vec_char()).collect()\n        }\n    }\n\n    pub fn read_string() -> String {\n        use std::io::Read;\n\n        let mut s = String::new();\n        std::io::stdin().read_to_string(&mut s).unwrap();\n        s\n    }\n\n    pub fn read_line() -> String {\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        s.trim_right().to_owned()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n// modint {{{\n#[allow(dead_code)]\nmod modint {\n    use std::{\n        cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd},\n        fmt::{Debug, Display},\n        iter::{Product, Sum},\n        mem::swap,\n        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n    };\n\n    pub type ModValue = i64;\n\n    #[derive(Debug, Clone, Copy)]\n    struct Rational {\n        num: ModValue,\n        den: ModValue,\n    }\n\n    #[allow(clippy::many_single_char_names)]\n    fn red(r: i64, p: i64) -> (i64, i64, i64) {\n        if r.abs() <= 10000 {\n            return (r, 1, 0);\n        }\n        let mut nxt_r = p % r;\n        let mut q = p / r;\n        if 2 * nxt_r >= r {\n            nxt_r -= r;\n            q += 1;\n        }\n        if 2 * nxt_r <= -r {\n            nxt_r += r;\n            q -= 1;\n        }\n        let (x, z, y) = red(nxt_r, r);\n        (x, y - q * z, z)\n    }\n\n    #[derive(Clone, Copy)]\n    pub struct Mint<Mod: ModTrait>(ModValue, std::marker::PhantomData<Mod>);\n\n    impl<Mod: ModTrait> Mint<Mod> {\n        fn from_value_unchecked(value: ModValue) -> Self {\n            Self(value, std::marker::PhantomData)\n        }\n        fn normalize(value: ModValue) -> ModValue {\n            let value = value % Mod::modulus();\n            if 0 <= value {\n                value\n            } else {\n                value + Mod::modulus()\n            }\n        }\n        fn guess(&self) -> Rational {\n            let (mut num, mut den, _) = red(self.0, Mod::modulus());\n            if den < 0 {\n                num = -num;\n                den = -den;\n            }\n            Rational { num, den }\n        }\n        pub fn from_i64(value: ModValue) -> Self {\n            Self::from_value_unchecked(Self::normalize(value))\n        }\n        pub fn from_frac(num: ModValue, den: ModValue) -> Self {\n            Self::from_i64(num) / Self::from_i64(den)\n        }\n        pub fn zero() -> Self {\n            Self::from_value_unchecked(0)\n        }\n        pub fn one() -> Self {\n            Self::from_value_unchecked(1)\n        }\n        #[allow(clippy::many_single_char_names)]\n        pub fn inv(self) -> Self {\n            assert_ne!(\n                self,\n                Self::zero(),\n                \"attempted to take the inverse of zero mint\"\n            );\n            let mut x = self.0;\n            let mut y = Mod::modulus();\n            let mut u = 1;\n            let mut v = 0;\n            while x != 0 {\n                let q = y / x;\n                y -= q * x;\n                v -= q * u;\n                swap(&mut x, &mut y);\n                swap(&mut u, &mut v);\n            }\n            assert!(x == 0 && y == 1 && u.abs() == Mod::modulus() && v.abs() < Mod::modulus());\n            Self::from_value_unchecked(if v < 0 { v + Mod::modulus() } else { v })\n        }\n        pub fn pow(mut self, mut p: u64) -> Self {\n            let mut ans = Self::one();\n            while 0 != p {\n                if p % 2 == 1 {\n                    ans *= self;\n                }\n                self *= self;\n                p /= 2;\n            }\n            ans\n        }\n        pub fn from_pow(a: ModValue, p: u64) -> Self {\n            Self::from_i64(a).pow(p)\n        }\n    }\n\n    impl<Mod: ModTrait> Debug for Mint<Mod> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            let Rational { num, den } = self.guess();\n            f.debug_tuple(\"Mint\")\n                .field(&if den == 1 {\n                    num.to_string()\n                } else {\n                    format!(\"{}/{}\", num, den)\n                })\n                .finish()\n        }\n    }\n\n    impl<Mod: ModTrait> Display for Mint<Mod> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    macro_rules! forward_ref_binop {\n        ($(impl $imp:ident, $method:ident)*) => {\n            $(\n                impl<'a, Mod: ModTrait> $imp<Mint<Mod>> for &'a Mint<Mod> {\n                    type Output = Mint<Mod>;\n\n                    #[inline]\n                    fn $method(self, other: Mint<Mod>) -> Self::Output {\n                        $imp::$method(*self, other)\n                    }\n                }\n\n                impl<'a, Mod: ModTrait> $imp<&'a Mint<Mod>> for Mint<Mod> {\n                    type Output = Mint<Mod>;\n\n                    #[inline]\n                    fn $method(self, other: &Mint<Mod>) -> Self::Output {\n                        $imp::$method(self, *other)\n                    }\n                }\n\n                impl<'a, Mod: ModTrait> $imp<&'a Mint<Mod>> for &'a Mint<Mod> {\n                    type Output = Mint<Mod>;\n\n                    #[inline]\n                    fn $method(self, other: &Mint<Mod>) -> Self::Output {\n                        $imp::$method(*self, *other)\n                    }\n                }\n            )*\n        };\n    }\n\n    macro_rules! forward_ref_op_assign {\n        ($(impl $imp:ident, $method:ident)*) => {\n            $(\n                impl<'a, Mod: ModTrait> $imp<&Mint<Mod>> for Mint<Mod> {\n                    #[inline]\n                    fn $method(&mut self, other: &Mint<Mod>) {\n                        $imp::$method(self, *other);\n                    }\n                }\n            )*\n        }\n    }\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    impl<Mod: ModTrait> Add for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn add(self, rhs: Self) -> Self {\n            let value = self.0 + rhs.0;\n            Self::from_value_unchecked(if value < Mod::modulus() {\n                value\n            } else {\n                value - Mod::modulus()\n            })\n        }\n    }\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    impl<Mod: ModTrait> Sub for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn sub(self, rhs: Self) -> Self {\n            let value = self.0 - rhs.0;\n            Self::from_value_unchecked(if 0 <= value {\n                value\n            } else {\n                value + Mod::modulus()\n            })\n        }\n    }\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    impl<Mod: ModTrait> Mul for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn mul(self, rhs: Self) -> Self {\n            Self::from_value_unchecked(self.0 * rhs.0 % Mod::modulus())\n        }\n    }\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    impl<Mod: ModTrait> Div for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn div(self, rhs: Self) -> Self {\n            self * rhs.inv()\n        }\n    }\n\n    impl<Mod: ModTrait> Neg for Mint<Mod> {\n        type Output = Self;\n\n        #[inline]\n        fn neg(self) -> Self {\n            if self.0 == 0 {\n                Self::zero()\n            } else {\n                Self::from_value_unchecked(Mod::modulus() - self.0)\n            }\n        }\n    }\n\n    impl<Mod: ModTrait> Neg for &Mint<Mod> {\n        type Output = Mint<Mod>;\n\n        #[inline]\n        fn neg(self) -> Self::Output {\n            (*self).neg()\n        }\n    }\n\n    macro_rules! forward_assign_biop {\n        ($(impl $trait: ident, $fn_assign: ident, $fn: ident)*) => {\n            $(\n                impl<Mod: ModTrait> $trait for Mint<Mod> {\n                    #[inline]\n                    fn $fn_assign(&mut self, rhs: Self) {\n                        *self = self.$fn(rhs);\n                    }\n                }\n            )*\n        };\n    }\n\n    forward_assign_biop! {\n        impl AddAssign, add_assign, add\n        impl SubAssign, sub_assign, sub\n        impl MulAssign, mul_assign, mul\n        impl DivAssign, div_assign, div\n    }\n\n    forward_ref_binop! {\n        impl Add, add\n        impl Sub, sub\n        impl Mul, mul\n        impl Div, div\n    }\n\n    forward_ref_op_assign! {\n        impl AddAssign, add_assign\n        impl SubAssign, sub_assign\n        impl MulAssign, mul_assign\n        impl DivAssign, div_assign\n    }\n\n    impl<Mod: ModTrait> PartialEq for Mint<Mod> {\n        fn eq(&self, other: &Self) -> bool {\n            self.0 == other.0\n        }\n    }\n    impl<Mod: ModTrait> Eq for Mint<Mod> {}\n    impl<Mod: ModTrait> Ord for Mint<Mod> {\n        fn cmp(&self, other: &Self) -> Ordering {\n            self.0.cmp(&other.0)\n        }\n    }\n    impl<Mod: ModTrait> PartialOrd for Mint<Mod> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            Some(self.cmp(other))\n        }\n    }\n\n    impl<Mod: ModTrait> From<ModValue> for Mint<Mod> {\n        fn from(value: ModValue) -> Self {\n            Self::from_i64(value)\n        }\n    }\n\n    impl<Mod: ModTrait> From<Mint<Mod>> for ModValue {\n        fn from(mint: Mint<Mod>) -> Self {\n            mint.0\n        }\n    }\n\n    impl<Mod: ModTrait> Sum for Mint<Mod> {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = Self>,\n        {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<'a, Mod: 'a + ModTrait> Sum<&'a Self> for Mint<Mod> {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = &'a Self>,\n        {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<Mod: ModTrait> Product for Mint<Mod> {\n        fn product<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = Self>,\n        {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<'a, Mod: 'a + ModTrait> Product<&'a Self> for Mint<Mod> {\n        fn product<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = &'a Self>,\n        {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n\n    #[macro_export]\n    macro_rules! mint {\n        ($value: expr) => {\n            Mint::from_i64($value)\n        };\n    }\n\n    #[macro_export]\n    macro_rules! from_frac {\n        ($num: expr, $den: expr) => {\n            Mint::from_frac($num, $den)\n        };\n    }\n\n    #[macro_export]\n    macro_rules! from_pow {\n        ($a: expr, $b: expr) => {\n            Mint::from_pow($a, $b)\n        };\n    }\n\n    pub trait ModTrait: Clone + Copy + Debug {\n        fn modulus() -> ModValue;\n    }\n\n    #[derive(Debug, Clone)]\n    pub struct Factorial<Mod: ModTrait> {\n        normal: Vec<Mint<Mod>>,\n        inverse: Vec<Mint<Mod>>,\n    }\n\n    impl<Mod: ModTrait> Factorial<Mod> {\n        pub fn is_empty(&self) -> bool {\n            self.normal.is_empty()\n        }\n        pub fn len(&self) -> usize {\n            self.normal.len()\n        }\n        pub fn with_len(len: usize) -> Self {\n            if len == 0 {\n                Self {\n                    normal: Vec::new(),\n                    inverse: Vec::new(),\n                }\n            } else {\n                let mut normal = vec![Mint::one(); len];\n                for i in 1..len {\n                    normal[i] = normal[i - 1] * Mint::from_i64(i as i64);\n                }\n                let mut inverse = vec![normal.last().unwrap().inv(); len];\n                for i in (1..len).rev() {\n                    inverse[i - 1] = inverse[i] * Mint::from_i64(i as i64);\n                }\n                Self { normal, inverse }\n            }\n        }\n        pub fn inv(&self, i: usize) -> Mint<Mod> {\n            self.inverse[i]\n        }\n        pub fn falling(&self, n: usize, p: usize) -> Mint<Mod> {\n            if p == 0 {\n                Mint::one()\n            } else if n < p {\n                Mint::zero()\n            } else {\n                self[n] * self.inv(n - p)\n            }\n        }\n        pub fn binom(&self, n: usize, k: usize) -> Mint<Mod> {\n            if k == 0 {\n                Mint::one()\n            } else if n < k {\n                Mint::zero()\n            } else {\n                self[n] * self.inv(n - k) * self.inv(k)\n            }\n        }\n    }\n\n    impl<Mod: ModTrait, I: std::slice::SliceIndex<[Mint<Mod>]>> std::ops::Index<I> for Factorial<Mod> {\n        type Output = I::Output;\n\n        #[inline]\n        fn index(&self, index: I) -> &Self::Output {\n            &self.normal[index]\n        }\n    }\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mod100000007 {}\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mod998244353 {}\n    impl ModTrait for Mod100000007 {\n        fn modulus() -> ModValue {\n            1_000_000_007\n        }\n    }\n    impl ModTrait for Mod998244353 {\n        fn modulus() -> ModValue {\n            998_244_353\n        }\n    }\n    pub type Mint100000007 = Mint<Mod100000007>;\n\n    pub type Mint998244353 = Mint<Mod998244353>;\n}\n// }}}\ntype Mint = modint::Mint100000007;\n\nfn gcd(mut x: i32, mut y: i32) -> i32 {\n    if x > y {\n        std::mem::swap(&mut x, &mut y);\n    }\n    if x == 0 {\n        y\n    } else {\n        gcd(y % x, x)\n    }\n}\n\nfn main() {\n    input!(n: usize, xy: [(i32, i32); n]);\n    let max = 10_000;\n    let mut g = vec![vec![false; max + 1]; max + 1];\n    for &(x, y) in &xy {\n        g[x as usize][y as usize] = true;\n    }\n    let mut pow_of_two = vec![Mint::one(); n + 1];\n    for i in 0..n {\n        pow_of_two[i + 1] = pow_of_two[i] + pow_of_two[i];\n    }\n    let mut ans = pow_of_two[n] - Mint::from_i64(n as i64) - Mint::one();\n    for &(x, y) in &xy {\n        'nxt_pts: for &(x1, y1) in &xy {\n            let mut x = x;\n            let mut y = y;\n            let dx = x1 - x;\n            let dy = y1 - y;\n            if dx < 0 || dx == 0 && dy <= 0 {\n                continue;\n            }\n            let gcd = gcd(dx.abs(), dy.abs());\n            let dx = dx / gcd;\n            let dy = dy / gcd;\n            {\n                let orig_x = x;\n                let orig_y = y;\n                while (x + dx, y + dy) != (x1, y1) {\n                    x += dx;\n                    y += dy;\n                    if g[x as usize][y as usize] {\n                        continue 'nxt_pts;\n                    }\n                }\n                x = orig_x;\n                y = orig_y;\n            }\n            while 0 <= x - dx && 0 <= y - dy {\n                dbg!(x, y);\n                x -= dx;\n                y -= dy;\n                if g[x as usize][y as usize] {\n                    continue 'nxt_pts;\n                }\n            }\n            let mut cnt = 0;\n            loop {\n                if g[x as usize][y as usize] {\n                    cnt += 1;\n                }\n                let nx = x + dx;\n                let ny = y + dy;\n                if nx < 0 || (max as i32) < nx || ny < 0 || (max as i32) < ny {\n                    break;\n                }\n                x = nx;\n                y = ny;\n            }\n            ans -= pow_of_two[cnt] - Mint::from_i64(cnt as i64) - Mint::one();\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use io::*;\nuse std::collections::HashSet;\nuse std::cmp;\n\nfn main() {\n    let input = read_string();\n    let mut sc = Scanner::new(&input);\n    let n: i64 = sc.next();\n    let ps: Vec<Vec<i64>> = sc.next_mat(2, n as usize);\n    let mut lines: HashSet<(i64,i64,i64)> = HashSet::new();\n    let M = 998244353;\n    let mut ans = count_m(n, M);\n    for i in 0..n as usize {\n        for j in i+1..n as usize {\n            let mut a = ps[j][1] - ps[i][1];\n            let mut b = ps[i][0] - ps[j][0];\n            let g = gcd(a,b);\n            a /= g;\n            b /= g;\n            let mut c = ps[i][0] * ps[j][1] - ps[j][0] * ps[i][1];\n            if a < 0 {\n                a *= -1;\n                b *= -1;\n                c *= -1;\n            }\n            if lines.contains(&(a,b,c)) {\n                continue;\n            }\n            let mut cnt = 0;\n            for k in 0..n as usize {\n                if ps[k][0] * a + ps[k][1] * b == c {\n                    cnt += 1;\n                }\n            }\n            lines.insert((a,b,c));\n            ans = (ans + M - count_m(cnt, M)) % M;\n        }\n    }\n    println!(\"{}\",ans);\n}\n\nfn count_m(n: i64, M: i64) -> i64 {\n    if n < 3 {\n        0\n    } else {\n        (pow_m(2,n,M) + M - n * (n+1) / 2 - 1) % M\n    }\n}\n\nfn pow_m(a: i64, mut n: i64, M: i64) -> i64 {\n    let mut r = a % M;\n    let mut ret = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            ret = ret * r % M;\n            n -= 1;\n        } else {\n            r = r * r % M;\n            n /= 2;\n        }\n    }\n    ret\n}\n\nfn gcd(a: i64, b: i64) -> i64 {\n    let aa = a.abs();\n    let ba = b.abs();\n    let mut x = cmp::min(aa,ba);\n    let mut y = cmp::max(aa,ba);\n    while x > 0 {\n        let t = x;\n        x = y % x;\n        y = t;\n    }\n    y\n}\n\npub mod io {\n    use std;\n    use std::str::FromStr;\n\n    pub struct Scanner<'a> {\n        iter: std::str::SplitWhitespace<'a>,\n    }\n\n    impl<'a> Scanner<'a> {\n        pub fn new(s: &'a str) -> Scanner<'a> {\n            Scanner {\n                iter: s.split_whitespace(),\n            }\n        }\n\n        pub fn next<T: FromStr>(&mut self) -> T {\n            let s = self.iter.next().unwrap();\n            if let Ok(v) = s.parse::<T>() {\n                v\n            } else {\n                panic!(\"Parse error\")\n            }\n        }\n\n        pub fn next_vec_len<T: FromStr>(&mut self) -> Vec<T> {\n            let n: usize = self.next();\n            self.next_vec(n)\n        }\n\n        pub fn next_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n            (0..n).map(|_| self.next()).collect()\n        }\n\n        pub fn next_mat<T: FromStr>(&mut self, w: usize, h: usize) -> Vec<Vec<T>> {\n            (0..h).map(|_| self.next_vec(w)).collect()\n        }\n\n        pub fn next_vec_char(&mut self) -> Vec<char> {\n            self.next::<String>().chars().collect()\n        }\n\n        pub fn next_mat_char(&mut self, n: usize) -> Vec<Vec<char>> {\n            (0..n).map(|_| self.next_vec_char()).collect()\n        }\n    }\n\n    pub fn read_string() -> String {\n        use std::io::Read;\n\n        let mut s = String::new();\n        std::io::stdin().read_to_string(&mut s).unwrap();\n        s\n    }\n\n    pub fn read_line() -> String {\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        s.trim_right().to_owned()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\npub trait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\npub fn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\npub fn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\npub fn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nconst MOD: i64 = 998244353;\n\n#[derive(Debug)]\nstruct Point {\n    x: i32,\n    y: i32\n}\n\nstruct Vector {\n    dx: i32,\n    dy: i32\n}\n\nimpl Vector {\n    fn new(p0: &Point, p1: &Point) -> Vector {\n        Vector { dx: p1.x - p0.x, dy: p1.y - p0.y }\n    }\n}\n\nfn cross(v1: &Vector, v2: &Vector) -> i32 {\n    v1.dx * v2.dy - v1.dy * v2.dx\n}\n\nfn lined(p0: &Point, p1: &Point, p2: &Point) -> bool {\n    let v1 = Vector::new(p0, p1);\n    let v2 = Vector::new(p0, p2);\n    cross(&v1, &v2) == 0\n}\n\n\nfn powmod(a: i64, p: i64, m: i64) -> i64 {\n    let mut ret = 1i64;\n    let mut aa = a;\n    let mut pp = p;\n    while pp >= 1 {\n        if pp & 1 == 1 {\n            ret *= aa;\n            ret %= m;\n        }\n        aa = aa * aa % m;\n        pp >>= 1;\n    }\n    ret\n}\n\nfn inv(a: i64, m: i64) -> i64 {\n    powmod(a, m-2, m)\n}\n\nstruct Combination {\n    fact: Vec<i64>,\n    invfact: Vec<i64>,\n    modulo: i64\n}\n\nimpl Combination {\n    fn new(n: usize, modulo: i64) -> Self {\n        let mut fact: Vec<i64> = vec![0; n];\n        let mut invfact: Vec<i64> = vec![0; n];\n        fact[0] = 1;\n        for i in 1..n {\n            fact[i] = fact[i-1] * i as i64 % modulo;\n        }\n        invfact[n-1] = inv(fact[n-1], modulo);\n        for i in (0..n-1).rev() {\n            invfact[i] = (invfact[i+1] * (i+1) as i64) % modulo;\n        }\n\n        Combination { fact: fact, invfact: invfact, modulo: modulo }\n    }\n\n    fn combination(&self, n: usize, k: usize) -> i64 {\n        if n < k {\n            return 0;\n        }\n        self.fact[n] * self.invfact[n-k] % self.modulo * self.invfact[k] % self.modulo\n    }\n}\n\nfn main() {\n    let n: usize = read();\n    let points: Vec<(i32, i32)> = readn(n);\n    let points: Vec<Point> = points.into_iter().map(|(a, b)| Point {x: a, y: b }).collect();\n    let mut ans: i64 = 0;\n\n    let comb = Combination::new(n+10, MOD);\n    for i in 3..n+1 {\n        ans += comb.combination(n, i);\n        ans %= MOD;\n    }\n\n    let mut done: Vec<Vec<bool>> = vec![vec![false; n]; n];\n    for i in 0..n {\n        for j in i+1..n {\n            let ref a = points[i];\n            let ref b = points[j];\n            if done[i][j] {\n                continue;\n            }\n\n            let mut online: Vec<usize> = vec![];\n            for k in 0..n {\n                if lined(&a, &b, &points[k]) {\n                    online.push(k);\n                }\n            }\n            let same = online.len();\n            for nk in 3..same+1 {\n                ans += MOD;\n                ans -= comb.combination(same, nk);\n                ans %= MOD;\n            }\n            for &x in &online {\n                for &y in &online {\n                    done[x][y] = true;\n                }\n            }\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\n#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Hash)]\nstruct Point {\n    x: i64,\n    y: i64,\n}\n#[allow(dead_code)]\ntype Polygon = Vec<Point>;\n\nimpl std::cmp::Eq for Point {}\nimpl std::cmp::Ord for Point {\n    fn cmp(&self, rhs: &Point) -> std::cmp::Ordering {\n        (self.x, self.y).partial_cmp(&(rhs.x, rhs.y)).unwrap()\n    }\n}\nimpl std::ops::Add for Point {\n    type Output = Point;\n    fn add(self, rhs: Point) -> Point {\n        Point {\n            x: self.x + rhs.x,\n            y: self.y + rhs.y,\n        }\n    }\n}\nimpl std::ops::AddAssign for Point {\n    fn add_assign(&mut self, rhs: Point) {\n        self.x += rhs.x;\n        self.y += rhs.y;\n    }\n}\nimpl std::ops::Sub for Point {\n    type Output = Point;\n    fn sub(self, rhs: Point) -> Point {\n        Point {\n            x: self.x - rhs.x,\n            y: self.y - rhs.y,\n        }\n    }\n}\nimpl std::ops::SubAssign for Point {\n    fn sub_assign(&mut self, rhs: Point) {\n        self.x -= rhs.x;\n        self.y -= rhs.y;\n    }\n}\nimpl std::ops::Mul<Point> for i64 {\n    type Output = Point;\n    fn mul(self, rhs: Point) -> Point {\n        Point {\n            x: self * rhs.x,\n            y: self * rhs.y,\n        }\n    }\n}\nimpl std::ops::Mul<i64> for Point {\n    type Output = Point;\n    fn mul(self, rhs: i64) -> Point {\n        Point {\n            x: self.x * rhs,\n            y: self.y * rhs,\n        }\n    }\n}\nimpl std::ops::Div<i64> for Point {\n    type Output = Point;\n    fn div(self, rhs: i64) -> Point {\n        Point {\n            x: self.x / rhs,\n            y: self.y / rhs,\n        }\n    }\n}\n#[allow(dead_code)]\nimpl Point {\n    fn new(x: i64, y: i64) -> Point {\n        Point { x: x, y: y }\n    }\n}\n\nfn gcd(a: i64, b: i64) -> i64 {\n    if b == 0 {\n        return a;\n    }\n    gcd(b, a % b)\n}\n\n#[allow(dead_code)]\nfn pow_mod(base: i64, power: i64, modulo: i64) -> i64 {\n    let mut base = base;\n    let mut power = power;\n    let mut ans = 1;\n    while power > 0 {\n        if power & 1 == 1 {\n            ans = ans * base % modulo;\n        }\n        power >>= 1;\n        base = base * base % modulo;\n    }\n    ans\n}\n\nconst MOD: i64 = 998244353;\nfn main() {\n    let n = read::<usize>();\n    let mut ps = vec![Point::new(0i64, 0i64); n];\n    for i in 0..n {\n        let x = read::<i64>();\n        let y = read::<i64>();\n        ps[i] = Point::new(x, y);\n    }\n    let mut starts = HashMap::<((i64, i64), Point), usize>::new();\n    let mut cnts = HashMap::<((i64, i64), Point), i64>::new();\n    for i in 0..n {\n        for j in i + 1..n {\n            let mut vect = ps[j] - ps[i];\n            let g = gcd(vect.x.abs(), vect.y.abs());\n            vect = vect / g;\n            if vect.x == 0 {\n                vect = Point::new(0, 1);\n            } else if vect.x < 0 {\n                vect = vect * -1;\n            }\n            let mut yupper = ps[i].y * vect.x - ps[i].x * vect.y;\n            let mut ylower = vect.x;\n            if ylower != 0 {\n                let g = gcd(yupper.abs(), ylower.abs());\n                yupper /= g;\n                ylower /= g;\n            }\n            // println!(\"{} {} {:?} {}\", i, j, vect, g);\n            let key = ((yupper, ylower), vect);\n            if !starts.contains_key(&key) {\n                starts.insert(key.clone(), i);\n                cnts.insert(key.clone(), 2);\n            } else if starts[&key] == i {\n                *cnts.get_mut(&key).unwrap() += 1;\n            }\n        }\n    }\n    let mut ans = (pow_mod(2, n as i64, MOD) - 1 - n as i64 + MOD) % MOD;\n    for &cnt in cnts.values() {\n        // println!(\"{}\", cnt);\n        ans = (ans - pow_mod(2, cnt, MOD) + cnt + 1 + MOD) % MOD;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\nuse std::io::{Read, BufReader};\n\nmacro_rules! read {\n    ( $( $t:ty ),* ) => {\n        {\n            let mut buf = String::new();\n            io::stdin().read_line(&mut buf);\n            let mut sp = buf.trim().split(\" \");\n            ($(\n                {\n                    sp.next().unwrap().parse::<$t>().unwrap()\n                },\n            )*)\n        }\n    }\n}\nmacro_rules! read_vec {\n    ($t:ty) => {\n        {\n            let mut buf = String::new();\n            io::stdin().read_line(&mut buf);\n            let mut sp = buf.trim().split(\" \");\n            let mut ret = vec![];\n            for s in sp {\n                ret.push(s.parse::<$t>().unwrap());\n            }\n            ret\n        }\n    }\n}\n\nconst MOD: i64 = 998244353;\n\nfn line(a: (i64, i64), b: (i64, i64), c: (i64, i64)) -> bool {\n    let b = (b.0 - a.0, b.1 - a.1);\n    let c = (c.0 - a.0, c.1 - a.1);\n\n    b.1 * c.0 == b.0 * c.1\n}\n\nfn ctri(ni: i64) -> i64 {\n    let mut ret = 1i64;\n    for _ in 0..ni {\n        ret = ret * 2 % MOD;\n    }\n\n    ret = (ret + MOD - 1) % MOD;\n    ret = (ret + MOD - ni) % MOD;\n    ret = (ret + MOD - ni * (ni - 1) / 2) % MOD;\n\n    ret\n}\n\nfn main() {\n    let (n,) = read!(usize);\n    let mut pts = vec![];\n    for _ in 0..n {\n        pts.push(read!(i64, i64));\n    }\n    \n    let mut lin = vec![0i64; n + 1];\n\n    for i in 0..n {\n        for j in (i + 1)..n {\n            let mut cnt = 0;\n            for k in 0..n {\n                if line(pts[i], pts[j], pts[k]) {\n                    cnt += 1\n                }\n            }\n\n            lin[cnt] += 1\n        }\n    }\n\n    let mut ret = 1i64;\n    for _ in 0..n {\n        ret = ret * 2 % MOD;\n    }\n\n    let ni = n as i64;\n    ret = ctri(ni);\n\n    for i in 3..(n + 1) {\n        let act = lin[i] / ((i * (i - 1) / 2) as i64);\n        ret = (ret + MOD - ctri(i as i64) * act % MOD) % MOD;\n    }\n    println!(\"{}\", ret);\n}"
  }
]