[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.{immutable, mutable}\nobject Main extends App {\n  import scala.io.StdIn._\n\n  loop()\n  @tailrec def loop(): Unit = {\n    val n = readInt()\n    if (n == 0) return\n    val member = Array.fill(n) {\n      val prob :: m :: list = readLine.trim.split(' ').toList\n      (prob.toDouble, list.map(_.toInt - 1))\n    }\n    val inverseEdge = Array.fill(n) {Nil: List[Int]}\n    for (i ← member.indices; j ← member(i)._2) inverseEdge(j) ::= i\n    val lastTime = Array.fill(n) {0}\n    val isDiscovery = Array.fill(n) {false}\n    def setLastTIme(current: Int, time: Int = 0): Int = {\n      if (!isDiscovery(current)) {\n        isDiscovery(current) = true\n        lastTime(current) = member(current)._2.foldLeft(time) { case (t, next) ⇒ setLastTIme(next, t) } + 1\n        lastTime(current)\n      } else time\n    }\n    (0 until n).foldLeft(0){case (t, r) ⇒ setLastTIme(r, t)}\n    isDiscovery.indices.foreach(i ⇒ isDiscovery(i) = false)\n    val union = new UnionFind(n + 1)\n    def mergeStrongConnect(current: Int): Unit = {\n      isDiscovery(current) = true\n      for (next ← inverseEdge(current) if !isDiscovery(next)) {\n        union.merge(current, next)\n        mergeStrongConnect(next)\n      }\n    }\n    for (i ← lastTime.indices.sortBy(lastTime)(Ordering.Int.reverse) if !isDiscovery(i)) {\n      mergeStrongConnect(i)\n    }\n    var result = 1d\n    val inEdgeCount= inverseEdge.indices.map(i ⇒ inverseEdge(i).count(j ⇒ !union.isSame(i, j)))\n    for (i ← inverseEdge.indices if !union.isSame(i, n)) {\n      var res = 1d\n      var inEdge = 0\n      for (j ← 0 until n if union.isSame(i, j)) {\n        res *= member(j)._1\n        inEdge += inEdgeCount(j)\n      }\n      if (inEdge == 0) result *= (1 - res)\n      union.merge(i, n)\n    }\n    println(f\"$result%.9f\")\n    loop()\n  }\n}\nclass UnionFind(val size: Int) {\n  private[this] val array = Array.fill(size){-1}\n  def find(a: Int): Int = {\n    if (array(a) < 0) a\n    else {\n      array(a) = find(array(a))\n      array(a)\n    }\n  }\n  def isSame(a: Int, b: Int): Boolean = find(a) == find(b)\n  def merge(a: Int, b: Int): Unit = {\n    val ar = find(a)\n    val br = find(b)\n    if (ar != br){\n      if (array(ar) < array(br)) {\n        array(ar) += array(br)\n        array(br) = ar\n      }else {\n        array(br) += array(ar)\n        array(ar) = br\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n#define MAX_N 100\n\nint reached[MAX_N][MAX_N]={};\n\n\nint parent[MAX_N];\nint ran[MAX_N];\n\nvoid init(int n)\n{\n  int i;\n  rep(i,n){\n    parent[i]=i;\n    ran[i]=0;\n  }\n}\n\nint find(int x)\n{\n  if(parent[x]==x)\n    return x;\n  else\n    return parent[x]=find(parent[x]);\n}\n\nvoid unite(int x,int y)\n{\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n\n  if(ran[x]<ran[y])\n    parent[x]=y;\n  else{\n    parent[y]=x;\n    if(ran[x]==ran[y])ran[x]++;\n  }\n}\n\nvoid dfs(int s, int v, vector<vi> g){\n  reached[s][v]++;\n  int i;\n  rep(i,g[v].size())\n    if(reached[s][g[v][i]]==0)dfs(s,g[v][i],g);\n\n}\n\nint main(void) {\n  int i,j;\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n    vector<vi> g(n);\n    vector<double> p(n);\n    rep(i,n){\n      cin>>p[i];\n      int m;\n      cin>>m;\n      rep(j,m){\n\tint a;\n\tcin>>a;\n\ta--;\n\tg[i].push_back(a);\t\n      }\n    }\n\n    rep(i,n)rep(j,n)reached[i][j]=0;\n\n    rep(i,n)dfs(i,i,g); //reached[i][j]を埋める\n\n    init(100);//UF\n\n    rep(i,n)loop(j,i+1,n)\n      if(reached[i][j] && reached[j][i])unite(i,j);//UF\n\n    double ans=1;\n\n    int q;\n    rep(q,n){\n      bool c=true;//qに到達可能なものがない\n      double tmp=1;//強連結成分qの全体の確率\n\n      rep(i,n)if(find(parent[i])==q){//iがqに属する場合\n\n\ttmp*=p[i];\n\n\t//jがiと異なる強連結成分に属し、jがiに到達可能の場合\n\trep(j,n)if(find(parent[i])!=find(parent[j]) && reached[j][i]){\n\t  c=false;\n\t}\n\n      }\n\n      if(c && fabs(tmp-1)>EPS) ans*=1-tmp;\n  \n    }\n\n    cout<<shosu(10)<<ans<<endl;\n\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ld = long double;\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\n\nint main()\n{\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) {\n            break;\n        }\n        Graph g(N);\n        vector<ld> p(N, 0);\n        for (int i = 0; i < N; i++) {\n            cin >> p[i];\n            int M;\n            cin >> M;\n            for (int j = 0; j < M; j++) {\n                int from;\n                cin >> from;\n                from--;\n                g.addEdge(i, from);\n            }\n        }\n\n        vector<vector<bool>> reachable(N, vector<bool>(N, false));\n        for (int i = 0; i < N; i++) {\n            queue<int> q;\n            vector<bool> used(N, false);\n            q.push(i);\n            used[i] = true;\n            reachable[i][i] = true;\n            while (not q.empty()) {\n                const int s = q.front();\n                q.pop();\n                for (int to : g.edge[s]) {\n                    if (used[to]) {\n                        continue;\n                    }\n                    reachable[i][to] = true;\n                    used[to] = true;\n                    q.push(to);\n                }\n            }\n        }\n\n        vector<int> number(N);\n        for (int i = 0; i < N; i++) {\n            number[i] = i;\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (reachable[i][j] and reachable[j][i]) {\n                    number[j] = number[i];\n                }\n            }\n        }\n        vector<ld> prob(N, 0);\n        for (int i = 0; i < N; i++) {\n            prob[number[i]] = (prob[number[i]] == 0) ? p[i] : prob[number[i]] * p[i];\n        }\n\n        vector<int> indim(N, 0);\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) {\n                    continue;\n                }\n                if (reachable[i][j] and number[i] != number[j]) {\n                    indim[number[j]]++;\n                }\n            }\n        }\n        ld ans = 1;\n        for (int i = 0; i < N; i++) {\n            if (indim[i] == 0) {\n                ans *= (1 - prob[i]);\n            }\n        }\n        cout << fixed << setprecision(10) << ans << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define All(A) A.begin(),A.end()\n#define RAll(A) A.rbegin(),A.rend()\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<30;\n\ndouble p[101],P[101];\n\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n    const G &g;\n    G gg, rg;\n    vector< int > comp, order, used;\n\n    StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n        for(int i = 0; i < g.size(); i++) {\n            for(auto e : g[i]) {\n                gg[i].emplace_back((int) e);\n                rg[(int) e].emplace_back(i);\n            }\n        }\n    }\n\n    int operator[](int k) {\n        return (comp[k]);\n    }\n\n    void dfs(int idx) {\n        if(used[idx]) return;\n        used[idx] = true;\n        for(int to : gg[idx]) dfs(to);\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt) {\n        if(comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for(int to : rg[idx]) rdfs(to, cnt);\n    }\n\n    void build(G &t) {\n        for(int i = 0; i < gg.size(); i++) dfs(i);\n        reverse(begin(order), end(order));\n        int ptr = 0;\n        for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n        t.resize(ptr);\n        for(int i=0;i<g.size();i++) P[i]=1;\n        for(int i=0;i<g.size();i++) P[comp[i]]*=p[i];\n        for(int i = 0; i < g.size(); i++) {\n            for(auto &to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if(x == y) continue;\n                t[x].push_back(y);\n            }\n        }\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) break;\n        vector<vector<int>> G(N);\n        for(int i=0;i<N;i++){\n            int m;\n            cin >> p[i] >> m;\n            for(int j=0;j<m;j++){\n                int u;\n                cin >> u;\n                u--;\n                G[i].eb(u);\n            }\n        }\n        StronglyConnectedComponents<vector<vector<int>>> scc(G);\n        vector<vector<int>> h;\n        scc.build(h);\n        vector<int> s(h.size(),0);\n        for(int i=0;i<h.size();i++){\n            for(int j=0;j<h[i].size();j++){\n                s[h[i][j]]++;\n            }\n        }\n        double ans=1.0;\n        for(int i=0;i<h.size();i++){\n            if(!s[i]){\n                ans*=1-P[i];\n            }\n        }\n        cout <<fixed<<setprecision(9)<<ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string.h>\n#include <iomanip>\nusing namespace std;\n\nint N,M,s,t,Q;\nvector<vector<int>> v(110),rv(110),nv(110);\nvector<int> rs;\nint visited[110] = {},cmp[110] = {},in_cnt[110] = {};\ndouble p[110] = {},p_cmp[110] = {},dp[110] = {};\n\nvoid dfs(int n){\n    visited[n] = 1;\n    for(auto x:v[n]) if(!visited[x]) dfs(x);\n    rs.push_back(n);\n}\n\nvoid rdfs(int n,int cnt){\n    visited[n] = 1;\n    cmp[n] = cnt;\n    for(auto x:rv[n]) if(!visited[x]) rdfs(x,cnt);\n}\n\nint scc(){\n    memset(visited,0,sizeof(visited));\n    for(int i=1;i<=N;i++) if(!visited[i]) dfs(i);\n    memset(visited,0,sizeof(visited));\n    int now = 1;\n    for(int i=rs.size()-1;i>=0;i--) if(!visited[rs[i]]) rdfs(rs[i],now++);\n    for(int i=1;i<=N;i++){\n        for(auto x:v[i]){\n            if(cmp[i]!=cmp[x]){\n                nv[cmp[i]].push_back(cmp[x]);\n                in_cnt[cmp[x]]++;\n            }\n        }\n    }\n    return now-1;\n}\n\nint main(){\n    while(cin >> N && N>0){\n        for(int i=1;i<=N;i++){v[i].clear(); rv[i].clear(); nv[i].clear();}\n        rs.clear();\n        for(int i=1;i<=N;i++){\n            p_cmp[i] = 1;\n            dp[i] = 1;\n            visited[i] = 0;\n            cmp[i] = 0;\n            in_cnt[i] = 0;\n        }\n        int m,a;\n        for(int i=1;i<=N;i++){\n            cin >> p[i] >> m;\n            p[i] = 1-p[i];\n            for(int j=0;j<m;j++){\n                cin >> a;\n                v[i].push_back(a);\n                rv[a].push_back(i);\n            }\n        }\n        int cmp_size = scc();\n        for(int i=1;i<=N;i++){\n            p_cmp[cmp[i]] *= 1-p[i];\n        }\n        double ans = 1;\n        for(int i=1;i<=cmp_size;i++){\n            p_cmp[i] = 1-p_cmp[i];\n            if(in_cnt[i]==0) ans *= p_cmp[i];\n        }\n        cout << fixed;\n        cout << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define repn(i,n) for(int i=1;i<=n;i++)\n#define pb push_back\nbool u[105][105];\ndouble bad[105];\nint n;\nstruct uf{\n\tint par[105],ran[105];\n\tvoid init(){ for(int i=0;i<105;i++) par[i] = i, ran[i] = 0; }\n\tint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\n\tvoid unite(int x,int y){\n\t\tx = find(x); y = find(y); if(x==y) return;\n\t\tif(ran[x] < ran[y]) par[x] = y;\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tif(ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n\tbool same(int x,int y){ return find(x)==find(y); }\n}kaede;\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n == 0) return 0;\n\t\tmemset(u,0,sizeof(u));\n\t\tmemset(bad,0,sizeof(bad));\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lf\",&bad[i]);\n\t\t\tint cnt; scanf(\"%d\",&cnt);\n\t\t\trep(j,cnt){\n\t\t\t\tint a; cin>>a; u[i][a] = 1;\n\t\t\t}\n\t\t}\n\t\trepn(k,n) repn(i,n) repn(j,n){\n\t\t\tu[i][j] |= (u[i][k] & u[k][j]);\n\t\t}\n\t\tkaede.init();\n\t\trepn(i,n) repn(j,n){\n\t\t\tif(u[i][j] && u[j][i]){\n\t\t\t\tkaede.unite(i,j);\n\t\t\t}\n\t\t}\n\t\tint in[105]={};\n\t\trepn(i,n) repn(j,n){\n\t\t\tif(u[i][j] && kaede.same(i,j) == false){\n\t\t\t\tin[kaede.find(j)]++;\n\t\t\t}\n\t\t}\n\t\tvector<int>lst[105];\n\t\trepn(i,n){\n\t\t\tlst[kaede.find(i)].pb(i);\n\t\t}\n\t\tdouble ans = 1.0;\n\t\trepn(i,n){\n\t\t\tif(i != kaede.find(i)) continue;\n\t\t\tif(in[i]) continue;\n\t\t\tdouble prob = 1.0;\n\t\t\trep(j,lst[i].size()){\n\t\t\t\tint x = lst[i][j];\n\t\t\t\tprob *= bad[x];\n\t\t\t}\n\t\t\tans *= (1.0-prob);\n\t\t}\n\t\tprintf(\"%.12f\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n　　　∫ ∫ ∫\n　　　ノヽ\n　　（＿　 ）\n　（＿　　　 ）\n（＿＿＿＿＿＿ ）\n　ヽ(´･ω･)ﾉ　\n　　 |　 /\n　　 UU\n*/\n#pragma region macro\n#include <bits/stdc++.h>\ntypedef long long int64;\nusing namespace std;\nusing P = pair<int64, int64>;\ntypedef vector<int> vi;\nconst int MOD = (int)1e9 + 7;\nconst int64 INF = 1LL << 62;\nconst int inf = 1<<30;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i,s,n) for (int i = s; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end() //コンテナじゃないと使えない!!\n#define debug(x) cerr << #x << \": \" << x << \"\\n\";\n#define mp make_pair\n#define bn '\\n'\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T> &V){\n    int N = V.size();\n    REP(i,N){\n        os << V[i];\n        if (i!=N-1) os << \" \";\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T,typename S>\nostream& operator<<(ostream& os, pair<T,S> const&P){\n    os << \"(\";\n    os << P.first;\n    os << \" , \";\n    os << P.second;\n    os << \")\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T> &S){\n    auto it=S.begin();\n    while(it!=S.end()){\n        os << *it;\n        os << \" \";\n        it++;\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, deque<T> &q){\n    for(auto it=q.begin();it<q.end();it++){\n        os<<*it;\n        os<<\" \";\n    }\n     os<<endl;\n    return os;\n}\nvector<pair<int,int>> dxdy = {mp(0,1),mp(1,0),mp(-1,0),mp(0,-1)};\n#pragma endregion\n//fixed<<setprecision(10)<<ans<<endl;\n\nstruct StronglyConnectedComponents{\n    vector<int> topological_idx; //属する強連結成分のトポロジカル順序\n    vector<bool> visited;\n    vector<vector<int>> edge, edge_rev;\n    vector<int> post_order;\n    int N;\n    int scc_size = 0; //強連結成分の数\n    StronglyConnectedComponents(vector<vector<int>>& edge):edge(edge){\n        N = edge.size();\n        edge_rev.resize(N);\n        for(int v=0;v<N;v++){\n            for(auto to:edge[v]){\n                edge_rev[to].emplace_back(v);\n            }\n        }\n        visited.assign(N,false);\n        topological_idx.resize(N);\n        for(int i=0;i<N;i++){\n            if(not visited[i]) dfs(i);\n        }\n        visited.assign(N,false);\n        reverse(post_order.begin(), post_order.end());\n        for(auto v:post_order){\n            if(not visited[v]) dfs_rev(v,scc_size++);\n        }\n    }\n\n    void dfs(int v){\n        visited[v] = true;\n        for(auto to:edge[v]){\n            if(not visited[to]) dfs(to);\n        }\n        post_order.emplace_back(v);\n    }\n\n    void dfs_rev(int v, int idx){\n        visited[v] = true;\n        topological_idx[v] = idx;\n        for(auto to:edge_rev[v]){\n            if(not visited[to]) dfs_rev(to, idx);\n        }\n    }\n\n    //vが属している強連結成分のトポロジカル順序\n    int get_topological_idx(int v){\n        return topological_idx[v];\n    }\n\n    //強連結成分の数\n    int get_scc_size(){\n        return scc_size;\n    }\n\n\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true){\n        int N;\n        cin >> N;\n        if(N==0) break;\n        vector<long double> P(N);\n        vector<vector<int>> edge(N);\n        REP(i,N){\n            int M,to;\n            cin >> P[i] >> M;\n            REP(j,M){\n                cin >> to;\n                edge[i].emplace_back(--to);\n            }\n        }\n        StronglyConnectedComponents SCC(edge);\n        vector<long double> over_sleep(SCC.get_scc_size(),1);\n        vector<int> indegree(SCC.get_scc_size(),0);\n        REP(i,N){\n            int r = SCC.topological_idx[i];\n            over_sleep[r]*=P[i];\n            for(auto to:edge[i]){\n                int r_to = SCC.topological_idx[to];\n                if(r != r_to){\n                    indegree[r_to]++;\n                }\n            }\n        }\n        long double ans=1;\n        REP(i,SCC.get_scc_size()){\n            if(indegree[i]==0){\n                ans *= 1-over_sleep[i];\n            }\n        }\n        cout << fixed<<setprecision(10)<<ans<<bn;\n    }\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass SCC {\nprivate:\n    std::vector<std::vector<int>> gg, rg;\n    std::vector<std::pair<int, int>> edges;\n    std::vector<int> comp, order, used;\npublic:\n    SCC(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n    void addEdge(int x, int y)\n    {\n        gg[x].push_back(y);\n        rg[y].push_back(x);\n        edges.push_back({x, y});\n    }\n\n    int operator[](int k)\n    {\n        return comp[k];\n    }\n\n    void dfs(int idx)\n    {\n        if (used[idx]) return;\n        used[idx] = true;\n        for (auto& to: gg[idx]) dfs(to);\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt)\n    {\n        if (comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for (auto& to: rg[idx]) rdfs(to, cnt);\n    }\n\n    void build(std::vector<std::vector<int>> &t)\n    {\n        for (int i{}; i < (int)gg.size(); i++)\n            dfs(i);\n        std::reverse(order.begin(), order.end());\n        int ptr{};\n        for (auto& e: order)\n            if (comp[e] == -1)\n                rdfs(e, ptr), ptr++;\n        \n        t.resize(ptr);\n        std::set<std::pair<int, int>> connect;\n        for (auto& e: edges)\n        {\n            int x{comp[e.first]}, y{comp[e.second]};\n            if (x == y) continue;\n            if (connect.count({x, y})) continue;\n            t[x].push_back(y);\n            connect.emplace(x, y);\n        }\n    }\n};\n\nclass Solve {\nprivate:\npublic:\n    bool is_last_;\n    Solve()\n    {\n        int n;\n        std::cin >> n;\n        if (n == 0)\n        {\n            is_last_ = true;\n            return;\n        }\n        std::vector<long double> p(n);\n        SCC sc(n);\n        for (int i{}; i < n; i++)\n        {\n            std::cin >> p[i];\n            int m;\n            scanf(\"%d\", &m);\n            for (int j{}; j < m; j++)\n            {\n                int a;\n                scanf(\"%d\", &a);\n                sc.addEdge(i, a - 1);\n            }\n        }\n        std::vector<std::vector<int>> t;\n        sc.build(t);\n        std::vector<bool> isTop(t.size(), true);\n        for (auto& e: t)\n            for (auto& f: e)\n                isTop[f] = false;\n        std::vector<std::vector<int>> belong(t.size());\n        for (int i{}; i < n; i++)\n            belong[sc[i]].push_back(i);\n        long double ans{1};\n        for (int i{}; i < (int)t.size(); i++)\n        {\n            if (!isTop[i]) continue;\n            long double tmp{1};\n            for (auto& e: belong[i])\n                tmp *= p[e];\n            ans *= 1 - tmp;\n        }\n        printf(\"%.10Lf\\n\", ans);\n    }\n};\n\nint main()\n{\n    while (!Solve().is_last_);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2748&lang=jp\n\nvoid bfs(int n, vector<vector<int>>& G,vector<int>& used,vector<int>& t) {\n\tused[n] = 1;\n\tfor (auto e : G[n]) {\n\t\tif (used[e] != 0)continue;\n\t\tbfs(e, G, used, t);\n\t}\n\tt.push_back(n);\n}\n\nvector<int> search(int n, vector<vector<int>>& G, vector<vector<int>>& S) {\n\tvector<int> ret;\n\tfor (int i = 0; i < S[n].size(); i++) {\n\t\tfor (int j = 0; j < G[S[n][i]].size(); j++) {\n\t\t\tint next = G[S[n][i]][j];\n\t\t\tfor (int k = 0; k < S.size();k++) {\n\t\t\t\tif (find(S[k].begin(), S[k].end(),next) == S[k].end()) continue;\n\t\t\t\tif (k == n) break;\n\t\t\t\tret.push_back(k);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\tret.erase(unique(ret.begin(), ret.end()), ret.end());\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<double> p(N);\n\t\tvector<vector<int>> G(N),rG(N);\n\t\t/* input */\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tcin >> p[i];\n\t\t\tint m; cin >> m;\n\t\t\tfor (int j = 0; j < m;j++) {\n\t\t\t\tint a; cin >> a; a--;\n\t\t\t\tG[i].push_back(a);\n\t\t\t\trG[a].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\t/* SCC */\n\t\tvector<int> used(N, 0);\n\t\tvector<int> t;\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tif (used[i] != 0) continue;\n\t\t\tbfs(i, G, used, t);\n\t\t}\n\t\tfor (int i = 0; i < N;i++) used[i] = 0;\n\t\tvector<vector<int>> S;\n\t\tvector<double> Sp;\n\t\tfor (auto it = t.rbegin(); it != t.rend(); it++) {\n\t\t\tif (used[*it] != 0)continue;\n\t\t\tS.push_back(vector<int>());\n\t\t\tbfs(*it, rG, used, S[S.size() - 1]);\n\t\t\tdouble _Sp = 1;\n\t\t\tfor (int i = 0; i < S[S.size() - 1].size();i++) {\n\t\t\t\t_Sp *= p[S[S.size() - 1][i]];\n\t\t\t}\n\t\t\tSp.push_back(_Sp);\n\t\t}\n\n\t\t/* solve */\n\t\tvector<vector<int>> new_rG(S.size());\n\t\tfor (int i = 0; i < S.size();i++) {\n\t\t\tauto v = search(i, G, S);\n\t\t\tfor (auto V : v) new_rG[V].push_back(i);\n\t\t}\n\t\tdouble ans = 1;\n\t\tfor (int i = 0; i < S.size();i++) {\n\t\t\tif (new_rG[i].size() != 0) continue;\n\t\t\tans *= (1 - Sp[i]);\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define V 100001\nvector<int> G[V],rG[V],v;\nbool u[V];\nint n,cmp[V];\n\nvoid add_edge(int x, int y) {\n  G[x].push_back(y);\n  rG[y].push_back(x);\n}\nvoid dfs(int x) {\n  u[x]=1;\n  for(int i=0; i<G[x].size(); i++) {\n    if(!u[G[x][i]]) dfs(G[x][i]);\n  }\n  v.push_back(x);\n}\nvoid rdfs(int x, int k) {\n  u[x]=1;\n  cmp[x]=k;\n  for(int i=0; i<rG[x].size(); i++) {\n    if(!u[rG[x][i]]) rdfs(rG[x][i],k);\n  }\n}\nint scc() {\n  memset(u,0,sizeof(u));\n  v.clear();\n  for(int i=0; i<n; i++) {\n    if(!u[i]) dfs(i);\n  }\n  memset(u,0,sizeof(u));\n  int k = 0;\n  for(int i=v.size()-1; i>=0; i--) {\n    if(!u[v[i]]) rdfs(v[i],k++);\n  }\n  return k;\n}\nint main() {\n  while(cin >> n && n) {\n    for(int i=0; i<n; i++) G[i].clear(),rG[i].clear();\n    double p[n];\n    for(int i=0,m; i<n; i++) {\n      cin >> p[i] >> m;\n      for(int j=0; j<m; j++) {\n        int x;\n        cin >> x;\n        x--;\n        add_edge(i,x);\n      }\n    }\n    int cnt=scc();\n    int c[n],d[n];memset(c,0,sizeof(c));memset(d,0,sizeof(d));\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<G[i].size(); j++) {\n        if(cmp[G[i][j]]!=cmp[i]) c[cmp[G[i][j]]]=1;\n      }\n      d[cmp[i]]=1;\n    }\n    double ans=1;\n    for(int i=0; i<n; i++) {\n      if(!c[i]&&d[i]) {\n        double x=1;\n        for(int j=0; j<n; j++) {\n          if(cmp[j]==i) x*=p[j];\n        }\n        ans*=1.0-x;\n      }\n    }\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX_V 1000\nint V,cmp[MAX_V];\nvector<int> G[MAX_V],rG[MAX_V],vs,a,xx;\nint used[MAX_V];\nvoid addedge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n} \nvoid dfs(int v){\n  used[v]=1;\n  for(int i=0;i<G[v].size();i++)\n    if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\nvoid rdfs(int v,int k){\n  used[v]=1;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n}\nvoid dfs2(int v,int k){\n  used[v]=k;\n  for(int i=0;i<G[v].size();i++)\n    if(!used[G[v][i]])dfs(G[v][i]);\n  xx.push_back(v);\n}\nint scc(){\n  int pp=0;\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)\n    if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=1;\n  for(int i=vs.size()-1;i>=0;i--)\n    if(!used[vs[i]]){\n      rdfs(vs[i],k++);\n    }\n  k=1;\n  map<int,int>m;\n  memset(used,0,sizeof(used));\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]]){\n      dfs(vs[i]);\n      r(j,xx.size())if(used[xx[j]]!=k){\n        m[used[xx[j]]]=0;\n      }\n      xx.clear();\n      m[vs[i]]=cmp[vs[i]];\n      k++;\n    }\n  }\n  r(i,V)if(m[i])\n    a.push_back(m[i]);\n  return k;\n}\nint main(){\n  int x,y;\n  while(cin>>V,V){\n    double d[V],ans=0;\n    a.clear();\n    r(i,1000)G[i].clear(),rG[i].clear();\n    r(i,V){\n      cin>>d[i]>>x;\n      r(j,x){\n        cin>>y;\n        addedge(i,y-1);\n      }\n    }\n    scc();\n    int cnt=0;\n    r(i,a.size()){\n      double p=0;\n      int c=0;\n      r(j,V)if(cmp[j]==a[i]){\n        if(!c++)p+=d[j];\n        else p*=d[j];\n      }\n      if(!cnt++)ans+=(1.0-p);\n      else ans*=(1.0-p);\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\n#define endl '\\n'\n#define ALL(V) V.begin(),V.end()\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\n\nclass StronglyConnectedComponents {\n    VV<ll> E, inv_E;\n    V<ll> number;\n    V<bool> used_dfs;\n    ll to_write_num = 0;\n\n    void dfs(ll now) {\n        used_dfs[now] = 1;\n        for(ll next : E[now]) {\n            if(used_dfs[next]) {\n                continue;\n            }\n            dfs(next);\n        }\n        number[now] = to_write_num++;\n    }\n\n    void dfs(ll now, V<bool> &used, vector<ll> &ret) {\n        used[now] = 1;\n        ret.push_back(now);\n        for(ll next : inv_E[now]) {\n            if(used[next]) {\n                continue;\n            }\n            dfs(next, used, ret);\n        }\n    }\n\n    void write_num() {\n        for(ll i = 0; i < E.size(); i++) {\n            if(!used_dfs[i]) {\n                dfs(i);\n            }\n        }\n    }\n\npublic:\n    StronglyConnectedComponents(const VV<ll> &E) \n        : E(E),\n          inv_E(E.size(), V<ll>(0)),\n          number(E.size()),\n          used_dfs(E.size(), false)\n    {\n        for(ll i = 0; i < E.size(); i++) {\n            for(ll nxt : E[i]) {\n                inv_E[nxt].push_back(i);\n            }\n        }\n        write_num();\n    }\n\n    VV<ll> scc() {\n        VV<ll> ret;\n        V<ll> vertex_vec;\n        V<bool> used(E.size());\n        for(ll i = 0; i < E.size(); i++) {\n            vertex_vec.push_back(i);\n        }\n        sort(vertex_vec.begin(), vertex_vec.end(), [&](ll a, ll b) { return number[a] > number[b]; });\n        for(ll vertex : vertex_vec) {\n            if(used[vertex]) {\n                continue;\n            }\n            V<ll> to_insert;\n            dfs(vertex, used, to_insert);\n            ret.push_back(to_insert);\n        }\n        return ret;\n    }\n};\n\nbool solve() {\n    ll N;\n    cin >> N;\n    if(!N) return false;\n\n    VV<ll> edges(N);\n    V<double> pv(N);\n    for(ll i = 0; i < N; i++) {\n        double p;\n        cin >> p;\n        pv[i] = p;\n        ll m;\n        cin >> m;\n        while(m--) {\n            ll a;\n            cin >> a;\n            edges[a - 1].push_back(i);\n        }\n    }\n    \n    StronglyConnectedComponents scc(edges);\n    auto group = scc.scc();\n    \n    VV<ll> scc_edges(group.size());\n    V<ll> group_id(N);\n    for(ll i = 0; i < group.size(); i++) for(ll j : group[i]) group_id[j] = i;\n    for(ll i = 0; i < N; i++) {\n        for(ll j : edges[i]) {\n            if(group_id[i] == group_id[j]) continue;\n            scc_edges[group_id[i]].push_back(group_id[j]);\n        }\n    }\n\n    /*\n    for(auto &v : scc_edges) {\n        sort(ALL(v));\n        auto ite = unique(ALL(v));\n        v.erase(ite, v.end());\n    }\n    */\n\n    double ans = 1;\n\n    for(ll i = 0; i < scc_edges.size(); i++) {\n        if(scc_edges[i].size() > 0) continue;\n        double tmp = 1;\n        for(ll p : group[i]) tmp *= pv[p];\n        ans *= (1.0 - tmp);\n    }\n\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cout << fixed << setprecision(30);\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n//const value\n//const ll MOD = 1e9 + 7;\n//const int dx[] = {0,1,0,-1};//{0,0,1,1,1,-1,-1,-1};\n//const int dy[] = {1,0,-1,0};//{1,-1,0,1,-1,0,1,-1};\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\nstruct StronglyConnectedComponents\n{\n  int n;\n  vector<vector<int>> oG, rG;\n  vector<int> comp, order, used;\n  vector<pair<int, int>> edges;\n\n  StronglyConnectedComponents (int n) : n(n), oG(n), rG(n), comp(n, -1), used(n, 0) {}\n\n  int operator[] (int k)\n  {\n    return comp[k];\n  }\n\n  void add_edge(int u, int v)\n  {\n    oG[u].push_back(v);\n    rG[v].push_back(u);\n    edges.emplace_back(u, v);\n  }\n\n  void dfs(int v)\n  {\n    if (used[v]) return;\n    used[v] = true;\n    for (int to : oG[v]) dfs(to);\n    order.push_back(v);\n  }\n\n  void rdfs(int v, int k)\n  {\n    if (~comp[v]) return;\n    comp[v] = k;\n    for (int to : rG[v]) rdfs(to, k);\n  }\n\n  void build(vector<vector<int>> &t)\n  {\n    for (int i = 0; i < n; ++i) dfs(i);\n\n    reverse(order.begin(), order.end());\n    int k = 0;\n    for (int i : order) if (comp[i] == -1) rdfs(i, k++);\n\n    t.resize(k);\n    set<pair<int, int>> connect;\n    for (auto &e : edges) {\n      int u = comp[e.first], v = comp[e.second];\n      if (u == v || connect.count({u, v})) continue;\n      t[u].push_back(v);\n      connect.emplace(u, v);\n    }\n  }\n};\n\n/*\nStronglyConnectedComponents(g):= グラフ g で初期化する。\nbuild(t):= 強連結成分分解をする。強連結成分の番号はトポロジカル順に昇順にふられる。\ntには強連結成分ごとに縮約したグラフが格納される(多重辺が生えるので注意)。\n[k] := 頂点 k が属する強連結成分の番号を返す。\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  StronglyConnectedComponents scc(n);\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    scc.add_edge(u, v);\n  }\n\n  vector<vector<int>> G;\n  scc.build(G);\n\n  int q;\n  cin >> q;\n  while (q--) {\n    int s, t;\n    cin >> s >> t;\n    cout << (scc[s] == scc[t]) << endl;\n  }\n}\n*/\nvoid solve(int n){\n  double a[n];\n  StronglyConnectedComponents scc(n);\n\n  rep(i,n){\n    cin >> a[i];\n    int x;\n    cin >> x;\n    rep(j,x){\n      int y;\n      cin >> y;\n      y--;\n      scc.add_edge(i,y);\n    }\n  }\n\n  VVI G;\n  scc.build(G);\n  // rep(i,scc.comp.size()) cout << i << \": \" << scc.comp[i] << endl;\n  vector<double> p(G.size(),1.);\n  rep(i,scc.comp.size()){\n    p[scc.comp[i]] *= a[i];\n  }\n  double ans = 1.;\n  bool up[G.size()];\n  memset(up,true,sizeof(up));\n  rep(i,G.size()){\n    rep(j,G[i].size()){\n      up[G[i][j]] = false;\n    }\n  }\n\n  rep(i,G.size()) if(up[i]) ans *= (1. - p[i]);\n  printf(\"%0.9lf\\n\",ans);\n}\nint main(){\n\n  int n;\n  while(cin >> n, n){\n    solve(n);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n;++i)\nusing namespace std;\nusing R = long double;\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tbool graph[110][110];\n\t\trep(i,n)rep(j,n) graph[i][j]=false;\n\n\t\tR p[110];\n\t\trep(i,n){\n\t\t\tcin >> p[i];\n\t\t\tint m,tmp;\n\t\t\tcin >> m;\n\t\t\trep(j,m){\n\t\t\t\tcin >> tmp;\n\t\t\t\tgraph[i][tmp-1] = true;\n\t\t\t}\n\t\t}\n\n\t\trep(k,n)rep(i,n)rep(j,n) graph[i][j] |= (graph[i][k]&graph[k][j]);\n\n\t\tvector<int> group[110];\n\n\t\trep(i,n){\n\t\t\tint cmin = i;\n\t\t\tbool ok = true;\n\n\t\t\trep(j,n){\n\t\t\t\tif(j==i) continue;\n\n\t\t\t\tif(graph[i][j] == true and graph[j][i] == true) cmin = min(cmin,j);\n\t\t\t\tif(graph[i][j] == false and graph[j][i] == true) ok = false;\n\t\t\t}\n\n\t\t\tif(ok){\n\t\t\t\tgroup[cmin].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tR ans = 1.0;\n\t\trep(i,n){\n\t\t\tif(group[i].empty()) continue;\n\t\t\tR cur = 1.0;\n\t\t\tfor(auto &it:group[i]) cur *= p[it];\n\t\t\tans *= 1.0 - cur;\n\t\t}\n\n\t\tcout.precision(20);\n\t\tcout << fixed << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include \"../dump.hpp\"\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < int(n); i++)\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src_, int dst_, Weight weight_) :\n    src(src_), dst(dst_), weight(weight_) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid visit(const Graph &g, int v, vvi &scc,\n\t   stack<int> &S, vector<bool> &inS,\n\t   vi &low, vi &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  for(auto e : g[v]) {\n    int w = e.dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\n\n// おそらくトポロジカル順の逆\nvoid stronglyConnectedComponents(const Graph& g, vvi &scc) {\n  const int n = g.size();\n  vi num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nvoid createContractedGraph(const Graph &g, const vvi &scc, vvi & cg){\n  cg.resize(scc.size());\n  vi id(g.size()); // 縮約前の頂点が縮約後にどこにいるか\n  rep(i,scc.size()) rep(j,scc[i].size()){\n    id[scc[i][j]] = i;\n  }\n\n  rep(i,scc.size()){\n    set<int> to; // 各成分の要素の行き先から自分を引いたものが縮約後の行き先\n    rep(j,scc[i].size()){\n      int now = scc[i][j];\n      rep(k,g[now].size()){\n\tint next = g[now][k].dst;\n\tto.insert(id[next]);\n      }\n    }\n    to.erase(i);\n    cg[i] = move(vi(to.begin(),to.end()));\n  }\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<double> p(n);\n    Graph g(n);\n    rep(i,n){\n      cin >> p[i];\n      int m; cin >> m;\n      rep(j,m){\n\tint a; cin >> a; a--;\n\tg[i].push_back(Edge(i,a,0));\n      }\n    }\n    vvi scc;\n    stronglyConnectedComponents(g,scc);\n    //dump(scc);\n    vvi cg;\n    createContractedGraph(g,scc,cg);\n    //dump(cg);\n    vi used(cg.size()); // 入次数が0なら0\n    rep(i,cg.size()){\n      rep(j,cg[i].size()) used[cg[i][j]] = 1;\n    }\n    //dump(used);\n    \n    double tmpa = 1.0; // 全ての成分が起きる\n    rep(i,used.size()){\n      if(used[i] == 1) continue;\n      \n      double tmpb = 1.0; // 各成分の全員が寝坊する\n      for(auto k : scc[i]){\n    \ttmpb *= p[k];\n      }\n      tmpa *= (1.0 - tmpb); // 誰かが起きる\n    }\n    printf(\"%.10lf\\n\",tmpa);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\n\nvoid dfs(int x, vector<vector<int> > &g, vector<bool> &used, vector<int> &post, int& k){\n  used[x] = true;\n  for(size_t i = 0; i < g[x].size(); i++){\n    if(!used[g[x][i]]){\n      dfs(g[x][i], g, used, post, k);\n    }\n  }\n  post[x] = k;\n  k++;\n  \n  return;\n}\n\ndouble rdfs(int x, vector<vector<int> > &rg, vector<int> &id, vector<double>& p, int k, vector<set<int> >& newG){\n  id[x] = k;\n  \n  double ans = p[x];\n  for(size_t i = 0; i < rg[x].size(); i++){\n    if(id[rg[x][i]] < 0){\n      ans *= rdfs(rg[x][i], rg, id, p, k, newG);\n    }\n    else if(id[rg[x][i]] != k){\n      newG[k].insert(id[rg[x][i]]);\n    }\n  }\n  \n  return ans;\n}\n\n\nint main(void){\n  int n;\n  while(true){\n    cin >> n;\n    if(n == 0){ break; }\n\n    vector<double> p(n);\n    vector<vector<int> > g(n);\n    vector<vector<int> > rg(n);\n    int m, a;\n    for(int i = 0; i < n; i++){\n      cin >> p[i] >> m;\n      for(int j = 0; j < m; j++){\n        cin >> a;\n        --a;\n        g[i].push_back(a);\n        rg[a].push_back(i);\n      }\n    }\n\n    int k = 0;\n    vector<bool> used(n, false);\n    vector<int> post(n);\n    for(int i = 0; i < n; i++){\n      if(!used[i]){\n        dfs(i, g, used, post, k);\n      } \n    }\n    \n    k = 0;\n    vector<int> id(n, -1);\n    used = vector<bool>(n, false);\n    vector<set<int> > newG(n);\n    vector<double> newP(n, 0);\n    for(int i = n - 1; i >= 0; i--){\n      if(id[post[i]] < 0){\n        newP[k] = rdfs(post[i], rg, id, p, k, newG);\n        k++;\n      }\n    }\n    \n    double ans = 1.0;\n    for(int i = 0; i < n; i++){\n      if(newG[i].size() == 0){\n        ans *= (1.0 - newP[i]);\n      }\n    }\n    printf(\"%.9f\\n\", ans);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef complex<ld> Point;\nconst ll mod = 1000000007;\nconst ld INF = 1e+30;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n\nvector<ld> p;\nstruct graph {\nprivate:\n\tint n;\n\tvector<vector<int>> G, rG;\n\tvector<bool> used;\n\tvector<int> vs;\n\n\tint mk;\n\tvector<vector<int>> fG;\n\tvector<vector<int>> ori;\n\tvector<int> trans;\npublic:\n\tgraph(int sz) {\n\t\tn = sz;\n\t\tG.resize(n);\n\t\trG.resize(n);\n\t\tused.resize(n);\n\n\t\tfG.resize(n);\n\t\ttrans.resize(n,-1);\n\t\tori.resize(n);\n\t}\n\tvoid add_edge(int a, int b) {\n\t\tG[a].push_back(b);\n\t\trG[b].push_back(a);\n\t}\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\trep(i, G[v].size()) {\n\t\t\tif (!used[G[v][i]])dfs(G[v][i]);\n\t\t}\n\t\tvs.push_back(v);\n\t}\n\tvoid rdfs(int v,int k) {\n\t\tused[v] = true;\n\t\tqueue<int> q; q.push(v);\n\t\tvector<int> c;\n\t\twhile (!q.empty()) {\n\t\t\tint id = q.front(); q.pop();\n\t\t\tori[k].push_back(id);\n\t\t\trep(j, rG[id].size()) {\n\t\t\t\tint to = rG[id][j];\n\t\t\t\tif (used[to]) {\n\t\t\t\t\tif (trans[to] >= 0)c.push_back(trans[to]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[to] = true; q.push(to);\n\t\t\t}\n\t\t}\n\t\tsort(c.begin(), c.end());\n\t\tint len = unique(c.begin(), c.end()) - c.begin();\n\t\trep(i, len) {\n\t\t\tfG[c[i]].push_back(k);\n\t\t}\n\t\trep(i, ori[k].size()) {\n\t\t\ttrans[ori[k][i]] = k;\n\t\t}\n\t}\n\tvoid scc() {\n\t\tfill(used.begin(), used.end(), false);\n\t\trep(i, n) {\n\t\t\tif (!used[i])dfs(i);\n\t\t}\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tper(i, (int)vs.size()) {\n\t\t\tif (!used[vs[i]]) {\n\t\t\t\trdfs(vs[i], k); k++;\n\t\t\t}\n\t\t}\n\t\tmk = k;\n\t}\n\tld query() {\n\t\tscc();\n\t\tvector<int> num(mk,0);\n\t\trep(i, mk) {\n\t\t\trep(j, fG[i].size()) {\n\t\t\t\tnum[fG[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tld ret = 1;\n\t\trep(i, mk) {\n\t\t\tif (num[i])continue;\n\t\t\tld pro = 1;\n\t\t\trep(j, ori[i].size()) {\n\t\t\t\tint id = ori[i][j];\n\t\t\t\tpro *= p[id];\n\t\t\t}\n\t\t\tpro = 1 - pro;\n\t\t\tret *= pro;\n\t\t}\n\t\treturn ret;\n\t}\n};\nvoid solve() {\n\tcout << fixed << setprecision(6);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tgraph g(n);\n\t\tp.clear(); p.resize(n);\n\t\trep(i, n) {\n\t\t\tcin >> p[i];\n\t\t\tint m; cin >> m;\n\t\t\trep(j, m) {\n\t\t\t\tint a; cin >> a; a--;\n\t\t\t\tg.add_edge(i, a);\n\t\t\t}\n\t\t}\n\t\tld ans = g.query();\n\t\tcout << ans << endl;\n\t}\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX_V = 110;\n\nint V, cmp[MAX_V];\nbool used[MAX_V];\nvector<int> G[MAX_V], rG[MAX_V], vs;\n\nvoid add_edge(int from, int to)\n{\n    G[from].emplace_back(to);\n    rG[to].emplace_back(from);\n}\n\nvoid dfs(int v)\n{\n    used[v] = 1;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        if (!used[G[v][i]]) {\n            dfs(G[v][i]);\n        }\n    }\n    vs.emplace_back(v);\n}\n\nvoid rdfs(int v, int k)\n{\n    used[v] = 1;\n    cmp[v] = k;\n    for (int i = 0; i < (int)rG[v].size(); i++) {\n        if (!used[rG[v][i]]) {            \n            rdfs(rG[v][i], k);\n        }\n    }\n}\n\nint scc()\n{\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for (int v = 0; v < V; v++) {\n        if (!used[v]) {\n            dfs(v);\n        }\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for (int i = vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) {\n            rdfs(vs[i], k++);\n        }\n    }\n    return k;\n}\n\nvector<int> g[MAX_V];\n\nvoid init(int N)\n{\n    V = N;\n    for (int i = 0; i < N; i++) {\n        G[i].clear();\n        rG[i].clear();\n        g[i].clear();\n    }\n}\n\ndouble solve(int N, const vector<double>& P)\n{\n    int n = scc();\n    vector<double> p(n, 1);\n    \n    vector<int> out(n), in(n);\n    for (int i = 0; i < N; i++) {\n        for (const auto& to : G[i]) {\n            if (cmp[i] != cmp[to]) {\n                out[cmp[i]]++;\n            }            \n        }\n\n        for (const auto& from : rG[i]) {\n            if (cmp[i] != cmp[from]) {\n                in[cmp[i]]++;\n            }\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        p[cmp[i]] *= P[i];\n    }\n    double res = 1;\n    for (int i = 0; i < n; i++) {\n        if (out[i] >= 0 && in[i] == 0) {\n            res *= (1.0 - p[i]);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N, m;\n    while (cin >> N, N > 0) {\n        init(N);\n        vector<double> P(N);        \n        for (int i = 0; i < N; i++) {\n            cin >> P[i] >> m;\n            for (int j = 0; j < m; j++) {\n                int a;\n                cin >> a; a--;\n                add_edge(i, a);\n            }\n        }       \n        printf(\"%.10f\\n\", solve(N, P));\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\n\n#define _CRT_SECURE_NO_WARNINGS\n\nint N = 0;\ndouble p[110] = {};\nint m[110] = {};\nvector<int> know[110];\nvector<int> beKnown[110];\nbool waked[110] = {};\n\ndouble ans = 1;\nvoid SetWake(int n) {\n\tfor (int i = 0; i < know[n].size();i++) {\n\t\tif (!waked[know[n][i]] ) {\n\t\t\twaked[know[n][i]] = true;\n\t\t\tSetWake(i);\n\t\t}\n\t}\n}\n\ndouble semiAns=1;\nvoid CheckSameGroup(int n) {\n\tfor (int i = 0; i < beKnown[n].size(); i++) {\n\t\tif (!waked[beKnown[n][i]]) {\n\t\t\tsemiAns *= p[beKnown[n][i]];\n\t\t\twaked[beKnown[n][i]] = true;\n\t\t\tCheckSameGroup(beKnown[n][i]);\n\t\t}\n\t}\n}\n\nint main() {\n\n\twhile (scanf(\"%d\", &N), N != 0) {\n\t\tans = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tknow[i].clear();\n\t\t\tbeKnown[i].clear();\n\t\t\twaked[i] = false;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tscanf(\"%lf\", p + i);\n\t\t\tscanf(\"%d\", m + i);\n\t\t\tfor (int j = 0; j < m[i]; j++) {\n\t\t\t\tint c;\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tknow[i].push_back(c);\n\t\t\t\tbeKnown[c].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (beKnown[i].size()==0) {\n\t\t\t\twaked[i] = true;\n\t\t\t\tSetWake(i);\n\t\t\t\tans *= (1 - p[i]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (!waked[i]) {\n\t\t\t\twaked[i] = true;\n\t\t\t\tsemiAns = p[i];\n\t\t\t\tCheckSameGroup(i);\n\t\t\t\tans *= (1 - semiAns);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 110\n\nstruct SS{\n  bool visited1[SIZE], visited2[SIZE];\n  int num[SIZE],num_size,dic_num[SIZE];\n  int group[SIZE],group_size;\n  \n  SS(){\n    for(int i=0;i<SIZE;i++){\n      visited1[i] = visited2[i] = false;\n    }\n    num_size = 0;\n    group_size = 0;\n  }\n  \n  void dfs1(int now, vector<int> *way){\n\n    if(visited1[now]) return;\n    visited1[now] = true;\n    \n    for(int i=0;i<way[now].size();i++){\n      dfs1(way[now][i],way);\n    }\n\n    dic_num[now] = num_size;\n    num[num_size++] = now;\n  }\n\n  bool dfs2(int now, vector<int> *way_back){\n\n    if(visited2[now]) return false;\n    group[now] = group_size;\n    visited2[now] = true;\n    \n    for(int i=0;i<way_back[now].size();i++){\n      dfs2(way_back[now][i],way_back);\n    }\n\n    return true;\n  }\n  \n\n};\nvoid calc(int n){\n  double p[SIZE];\n  int m[SIZE],a[SIZE][SIZE];\n  vector<int> way[SIZE];\n  vector<int> way_back[SIZE];\n\n  for(int i=0;i<n;i++){\n    scanf(\"%lf%d\",p+i,m+i);\n\n    for(int j=0;j<m[i];j++){\n      scanf(\"%d\",a[i]+j);\n      a[i][j]--;\n      way[i].push_back(a[i][j]);\n      way_back[a[i][j]].push_back(i);\n    }\n  }\n\n  SS ss;\n\n  for(int i=0;i<n;i++){\n    ss.dfs1(i,way);\n  }\n\n  for(int j=0;j<n;j++){\n    ss.group_size += ss.dfs2(ss.num[n-j-1],way_back);\n  }\n\n  bool group_in[SIZE] = {0};\n  vector<int> group_list[SIZE];\n  \n  for(int i=0;i<n;i++){\n    group_list[ss.group[i]].push_back(i);\n    \n    for(int j=0;j<m[i];j++){\n      if(ss.group[i] != ss.group[a[i][j]])\n        group_in[ss.group[a[i][j]]] = true;\n    }\n  }\n\n  double ans = 1;\n  \n  for(int i=0;i<ss.group_size;i++){\n    if(group_in[i]) continue;\n\n    double calc_p = 1;\n\n    for(int j=0;j<group_list[i].size();j++){\n      calc_p *= p[group_list[i][j]];\n    }\n\n    ans *= 1 - calc_p;\n  }\n\n  printf(\"%.10lf\\n\",ans);\n}\n\nint main(){\n\n  int n;\n\n  while(1){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    calc(n);\n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nnamespace SCC{\n    void visit(const vector<vector<int>>&G,vector<int>&vs,vector<int>&used,int v){\n        used[v]=true;\n        for(auto u:G[v]){\n            if(!used[u])visit(G,vs,used,u);\n        }\n        vs.push_back(v);\n    }\n\n    void visit2(const vector<vector<int>>&T,vector<int>&used,vector<int>&comp,vector<int>&vec,int k,int v){\n        comp[v]=k;\n        used[v]=true;\n        vec.push_back(v);\n\n        for(auto u:T[v]){\n            if(!used[u])visit2(T,used,comp,vec,k,u);\n        }\n    }\n\n    //G:?????£?????????????§£???????????°??????\n    //H:?????£??????????????°??????1???????????????????´?????????°??????\n    //comp:G????????????????????????H?????????????±????????????????\n    void decompose(const vector<vector<int>>&G,vector<vector<int>>&H,vector<int>&comp){\n        vector<vector<int>>T(G.size());\n        for(int i=0;i<G.size();i++){\n            for(auto v:G[i]){\n                T[v].push_back(i);\n            }\n        }\n        comp.resize(G.size());\n\n        vector<int>vs(G.size());\n        vector<int>used(G.size());\n        for(int i=0;i<G.size();i++){\n            if(!used[i])visit(G,vs,used,i);\n        }\n        reverse(vs.begin(),vs.end());\n        fill(used.begin(),used.end(),0);\n\n        int K=0;\n        vector<vector<int>>S;\n        for(auto v:vs){\n            if(!used[v]){\n                S.push_back(vector<int>());\n                visit2(T,used,comp,S.back(),K++,v);\n            }\n        }\n\n        H.resize(K);\n        fill(used.begin(),used.end(),0);\n        for(int i=0;i<K;i++){\n            for(auto v:S[i]){\n                for(auto u:G[v]){\n                    if(used[comp[u]]||comp[v]==comp[u])continue;\n                    used[comp[u]]=true;\n                    H[comp[v]].push_back(comp[u]);\n                }\n            }\n            for(auto v:H[i])used[v]=false;\n        }\n\n    }\n}\n\nint N;\ndouble P[100];\nsigned main(){\n    while(cin>>N,N){\n        vector<vector<int>>G(N),H;\n        rep(i,N){\n            cin>>P[i];\n            int t;cin>>t;\n            rep(j,t){\n                int a;cin>>a;G[i].pb(a-1);\n            }\n        }\n\n        vint comp;\n        SCC::decompose(G,H,comp);\n        int deg[100]={};\n        double PP[100];rep(i,H.size())PP[i]=1.0;\n        rep(i,H.size())for(auto u:H[i])deg[u]++;\n        rep(i,N)PP[comp[i]]*=P[i];\n        double ans=1.0;\n        rep(i,H.size())if(deg[i]==0)ans*=1.0-PP[i];\n        printf(\"%.20f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\n\nvoid dfs(int x, vector<vector<int> > &g, vector<bool> &used, vector<int> &post, int& k){\n  used[x] = true;\n  for(size_t i = 0; i < g[x].size(); i++){\n    if(!used[g[x][i]]){\n      dfs(g[x][i], g, used, post, k);\n    }\n  }\n  post[x] = k;\n  k++;\n  \n  return;\n}\n\ndouble rdfs(int x, vector<vector<int> > &rg, vector<int> &id, vector<double>& p, int k, vector<set<int> >& newG){\n  id[x] = k;\n  \n  double ans = p[x];\n  for(size_t i = 0; i < rg[x].size(); i++){\n    if(id[rg[x][i]] < 0){\n      ans *= rdfs(rg[x][i], rg, id, p, k, newG);\n    }\n    else if(id[rg[x][i]] != k){\n      newG[k].insert(id[rg[x][i]]);\n    }\n  }\n  \n  return ans;\n}\n\n\nint main(void){\n  int n;\n  while(true){\n    cin >> n;\n    if(n == 0){ break; }\n\n    vector<double> p(n);\n    vector<vector<int> > g(n);\n    vector<vector<int> > rg(n);\n    int m, a;\n    for(int i = 0; i < n; i++){\n      cin >> p[i] >> m;\n      for(int j = 0; j < m; j++){\n        cin >> a;\n        --a;\n        g[i].push_back(a);\n        rg[a].push_back(i);\n      }\n    }\n\n    int k = 0;\n    vector<bool> used(n, false);\n    vector<int> post(n);\n    for(int i = 0; i < n; i++){\n      if(!used[i]){\n        dfs(i, g, used, post, k);\n      } \n    }\n    \n    k = 0;\n    vector<int> id(n, -1);\n    used = vector<bool>(n, false);\n    vector<set<int> > newG(n);\n    vector<double> newP(n, 0);\n    for(int i = n - 1; i >= 0; i--){\n      if(id[post[i]] < 0){\n        newP[k] = rdfs(post[i], rg, id, p, k, newG);\n        k++;\n      }\n    }\n\n    double ans = 1.0;\n    for(int i = 0; i < k; i++){\n      if(newG[i].size() == 0){\n        ans *= (1.0 - newP[i]);\n      }\n    }\n    printf(\"%.9f\\n\", ans);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\n#include<vector>\nstruct SCC{\n\tint n;\n\tvector<int>comp,order;\n\tvector<bool>used;\n\tvector<vector<int> >G,RG;\n\tSCC(int _n=0):n(_n),comp(_n,-1),used(_n,false),G(_n),RG(_n){}\n\tvoid add_edge(int from,int to)\n\t{\n\t\tG[from].push_back(to);\n\t\tRG[to].push_back(from);\n\t}\n\tvoid copy(vector<vector<int> >&H)\n\t{\n\t\tfor(int i=0;i<H.size();i++)\n\t\t{\n\t\t\tfor(int j=0;j<H[i].size();j++)\n\t\t\t{\n\t\t\t\tG[i].push_back(H[i][j]);\n\t\t\t\tRG[H[i][j]].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint operator[](int u){return comp[u];}\n\tvoid dfs(int u)\n\t{\n\t\tused[u]=true;\n\t\tfor(int i=0;i<G[u].size();i++)if(!used[G[u][i]])dfs(G[u][i]);\n\t\torder.push_back(u);\n\t}\n\tvoid rdfs(int u,int cnt)\n\t{\n\t\tcomp[u]=cnt;\n\t\tfor(int i=0;i<RG[u].size();i++)if(comp[RG[u][i]]==-1)rdfs(RG[u][i],cnt);\n\t}\n\tint build()\n\t{\n\t\tfor(int i=0;i<n;i++)if(!used[i])dfs(i);\n\t\tint cnt=0;\n\t\tfor(int i=n-1;i>=0;i--)if(comp[order[i]]==-1)rdfs(order[i],cnt++);\n\t\treturn cnt;\n\t}\n\tint build(vector<vector<int> >&H)\n\t{\n\t\tint ret=build();\n\t\tH.assign(ret,vector<int>());\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<G[i].size();j++)\n\t\t\t{\n\t\t\t\tif(comp[i]!=comp[G[i][j]])\n\t\t\t\t\tH[comp[i]].push_back(comp[G[i][j]]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\nmain()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tvector<double>p(n),P(n,1);\n\t\tSCC scc(n);\n\t\tvector<vector<int> >G(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>p[i];\n\t\t\tint k;cin>>k;\n\t\t\tfor(;k--;)\n\t\t\t{\n\t\t\t\tint a;cin>>a;\n\t\t\t\tG[i].push_back(a-1);\n\t\t\t}\n\t\t}\n\t\tscc.copy(G);\n\t\tint N=scc.build(G);\n\t\tfor(int i=0;i<n;i++)P[scc[i]]*=p[i];\n\t\tvector<int>H(N,0);\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=0;j<G[i].size();j++)\n\t\t\t{\n\t\t\t\tH[G[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tdouble ans=1;\n\t\tfor(int i=0;i<N;i++)if(H[i]==0)ans*=1-P[i];\n\t\tcout<<fixed<<setprecision(9)<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N, t[1 << 18], col[1 << 18], cnts, deg[1 << 18]; long double p[1 << 18];\nvector<int>X[1 << 18], Y[1 << 18], G[1 << 18], V; bool used[1 << 18];\n\nvoid init() {\n\tfor (int i = 0; i < (1 << 18); i++) {\n\t\tt[i] = 0; col[i] = 0; deg[i] = 0; p[i] = 0; X[i].clear(); Y[i].clear(); G[i].clear(); used[i] = false;\n\t}\n\tV.clear(); cnts = 0;\n}\n\nvoid dfs(int pos) {\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tdfs(X[pos][i]);\n\t}\n\tV.push_back(pos);\n}\n\nvoid dfs2(int pos) {\n\tcol[pos] = cnts; G[cnts].push_back(pos);\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (col[Y[pos][i]] >= 1) continue;\n\t\tdfs2(Y[pos][i]);\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> N; if (N == 0) break;\n\t\tinit();\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tcin >> p[i] >> t[i]; p[i] = 1.0L - p[i];\n\t\t\tfor (int j = 1; j <= t[i]; j++) { int a; cin >> a; X[i].push_back(a); Y[a].push_back(i); }\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (used[i] == true) continue;\n\t\t\tdfs(i);\n\t\t}\n\t\treverse(V.begin(), V.end());\n\t\tfor (int i = 0; i < V.size(); i++) {\n\t\t\tif (col[V[i]] >= 1) continue;\n\t\t\tcnts++; dfs2(V[i]);\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j < X[i].size(); j++) {\n\t\t\t\tif (col[i] != col[X[i][j]]) deg[col[X[i][j]]]++;\n\t\t\t}\n\t\t}\n\t\tlong double E = 1;\n\t\tfor (int i = 1; i <= cnts; i++) {\n\t\t\tif (deg[i] >= 1) continue;\n\t\t\tlong double F = 1;\n\t\t\tfor (int j = 0; j < G[i].size(); j++) F *= (1.0L - p[G[i][j]]);\n\t\t\tE *= (1.0L - F);\n\t\t}\n\t\tprintf(\"%.12Lf\\n\", E);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\n\nint V;\nvector<int> G[105], rG[105], vs;\nbool used[105];\nint cmp[105];\ndouble p[105];\ndouble P[105];\nbool g[105][105];\nvoid add_edge(int from, int to) {\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tif (!used[G[v][i]]) dfs(G[v][i]);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k) {\n\tused[v] = true;\n\tcmp[v] = k;\n\tP[k] *= p[v];\n\tfor (int i = 0; i < rG[v].size(); i++) {\n\t\tif (!used[rG[v][i]]) rdfs(rG[v][i], k);\n\t}\n}\n\nint scc() {\n\tmemset(used, 0, sizeof(used));\n\tvs.clear();\n\tfor (int v = 0; v < V; v++) {\n\t\tif (!used[v]) dfs(v);\n\t}\n\tmemset(used, 0, sizeof(used));\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--) {\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\n\nint main() {\n\twhile (cin >> V, V) {\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tG[i].clear();\n\t\t\trG[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tcin >> p[i];\n\t\t\tint m;\n\t\t\tcin >> m;\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a; a--;\n\t\t\t\tadd_edge(i, a);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tP[i] = 1;\n\t\t}\n\t\tint K=scc();\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tfor (int j = 0; j < V; j++) g[i][j] = 0;\n\t\t}\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tfor (int j = 0; j < G[i].size(); j++) {\n\t\t\t\tg[cmp[i]][cmp[G[i][j]]] = 1;\n\t\t\t}\n\t\t}\n\t\tdouble ans = 1;\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tbool in = 0;\n\t\t\tfor (int j = 0; j < K; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tif (g[j][i]) {\n\t\t\t\t\tin = 1; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!in) ans *= (1 - P[i]);\n\t\t}\n\t\tprintf(\"%.15lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 1000\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n\tused[v]=true;\n\tcmp[v]=k;\n\tfor(int i=0;i<rG[v].size();i++)\n\t\tif(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n\tmemset(used,0,sizeof(used));\n\tvs.clear();\n\tfor(int v=0;v<V;v++)\n\t\tif(!used[v])dfs(v);\n\n\tmemset(used,0,sizeof(used));\n\tint k=0;\n\tfor(int i=vs.size()-1;i>=0;i--)\n\t\tif(!used[vs[i]])rdfs(vs[i],k++);\n\n\treturn k;\n}\n\nint main(){\n\twhile(cin>>V,V){\n\t\tdouble p[101];\n\t\tfor(int i=0;i<V;i++){\n\t\t\tint a;\n\t\t\tcin>>p[i]>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tint k;\n\t\t\t\tcin>>k;\n\t\t\t\tk--;\n\t\t\t\tadd_edge(i,k);\n\t\t\t}\n\t\t}\n\t\tint use[101]={};\n\t\tint k=scc();\n\t\tcout<<k<<endl;\n\t\tvector<int> P[101];\n\t\n\t\tfor(int i=0;i<V;i++){\n\t\t\t//cout<<cmp[i]<<endl;\n\t\t\tP[cmp[i]].push_back(i);\n\t\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\t\tif(cmp[G[i][j]]!=cmp[i])use[cmp[G[i][j]]]=1;\n\t\t\t}\n\t\t}\n\t\n\t\tvector<double> ans;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tif(use[i])continue;\n\t\t\tdouble tt;\n\t\t\tfor(int j=0;j<P[i].size();j++){\n\t\t\t\tif(j==0)tt=p[P[i][j]];\n\t\t\t\telse{\n\t\t\t\t\ttt*=p[P[i][j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans.push_back(1-tt);\n\t\t}\n\t\n\t\tdouble sum;\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tif(i==0)sum=ans[i];\n\t\t\telse{\n\t\t\t\tsum*=ans[i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lf\\n\",sum);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 1000\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid init(){\n\tfor(int i=0;i<MAX_V;i++)G[i].clear();\n\tfor(int i=0;i<MAX_V;i++)rG[i].clear();\n\tfor(int i=0;i<MAX_V;i++){\n\t\tcmp[i]=0;\n\t\tused[i]=0;\n\t}\n}\n\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n\tused[v]=true;\n\tcmp[v]=k;\n\tfor(int i=0;i<rG[v].size();i++)\n\t\tif(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n\tmemset(used,0,sizeof(used));\n\tvs.clear();\n\tfor(int v=0;v<V;v++)\n\t\tif(!used[v])dfs(v);\n\n\tmemset(used,0,sizeof(used));\n\tint k=0;\n\tfor(int i=vs.size()-1;i>=0;i--)\n\t\tif(!used[vs[i]])rdfs(vs[i],k++);\n\n\treturn k;\n}\n\nint main(){\n\twhile(cin>>V,V){\n\t\tinit();\n\t\tdouble p[101];\n\t\tfor(int i=0;i<V;i++){\n\t\t\tint a;\n\t\t\tcin>>p[i]>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tint k;\n\t\t\t\tcin>>k;\n\t\t\t\tk--;\n\t\t\t\tadd_edge(i,k);\n\t\t\t}\n\t\t}\n\t\tint use[101]={};\n\t\tint k=scc();\n\t\t//cout<<k<<endl;\n\t\tvector<int> P[101];\n\t\n\t\tfor(int i=0;i<V;i++){\n\t\t\t//cout<<cmp[i]<<endl;\n\t\t\tP[cmp[i]].push_back(i);\n\t\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\t\tif(cmp[G[i][j]]!=cmp[i])use[cmp[G[i][j]]]=1;\n\t\t\t}\n\t\t}\n\t\n\t\tvector<double> ans;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tif(use[i])continue;\n\t\t\tdouble tt;\n\t\t\tfor(int j=0;j<P[i].size();j++){\n\t\t\t\tif(j==0)tt=p[P[i][j]];\n\t\t\t\telse{\n\t\t\t\t\ttt*=p[P[i][j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans.push_back(1-tt);\n\t\t}\n\t\n\t\tdouble sum;\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tif(i==0)sum=ans[i];\n\t\t\telse{\n\t\t\t\tsum*=ans[i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lf\\n\",sum);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass G {\npublic:\n  vector<vector<int>> p, inv, sp, sinv;\n  int n, m;\n  vector<int> b, c, depth;\n  vector<bool> a;\n  G(int nn, vector<vector<int>> &np, vector<vector<int>> &ninv) {\n    n = nn;\n    p = np;\n    inv = ninv;\n    a.resize(n);\n    c.resize(n);\n    for (int i = 0; i < n; i++) {\n      c[i] = -1;\n    }\n  }\n  void dfs(int i) {\n    if (a[i])\n      return;\n    a[i] = true;\n    for (int j = 0; j < p[i].size(); j++) {\n      if (a[p[i][j]]) {\n        continue;\n      }\n      dfs(p[i][j]);\n    }\n    b.push_back(i);\n  }\n  void dfs2(int i, int id) {\n    if (c[i] > -1)\n      return;\n    c[i] = id;\n    for (int j = 0; j < inv[i].size(); j++) {\n      if (c[inv[i][j]] > -1)\n        continue;\n      dfs2(inv[i][j], id);\n    }\n  }\n  void solve() {\n    for (int i = 0; i < n; i++) {\n      dfs(i);\n    }\n    int j = 0;\n    for (int i = n - 1; i >= 0; i--) {\n      if (c[b[i]] > 0)\n        continue;\n      dfs2(b[i], j++);\n    }\n    m = j;\n    sp.resize(m);\n    sinv.resize(m);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < p[i].size(); j++) {\n        if (c[i] == c[p[i][j]])\n          continue;\n        sp[c[i]].push_back(c[p[i][j]]);\n        sinv[c[p[i][j]]].push_back(c[i]);\n      }\n    }\n  }\n};\n\nbool solve() {\n  int n;\n  cin >> n;\n  if (n == 0)\n    return false;\n  vector<double> ps(n);\n  vector<vector<int>> p(n), inv(n);\n  for (int i = 0; i < n; i++) {\n    cin >> ps[i];\n    ps[i] = 1 - ps[i];\n    int m;\n    cin >> m;\n    for (int j = 0; j < m; j++) {\n      int to;\n      cin >> to;\n      to--;\n      p[i].push_back(to);\n      inv[to].push_back(i);\n    }\n  }\n  G g(n, p, inv);\n  g.solve();\n  vector<double> qs(g.m);\n  vector<bool> c(n);\n  for (int i = 0; i < qs.size(); i++)\n    qs[i] = 1.0;\n  for (int i = 0; i < n; i++) {\n    qs[g.c[i]] *= (1 - ps[i]);\n    c[g.c[i]] = true;\n  }\n  for (int i = 0; i < qs.size(); i++)\n    qs[i] = 1 - qs[i];\n  double ans = 1.0;\n  for (int i = 0; i < qs.size(); i++) {\n    if (g.sinv[i].size() == 0 && c[i])\n      ans *= qs[i];\n  }\n  printf(\"%.9lf\\n\", ans);\n  return true;\n}\n\nint main() {\n  while (solve())\n    ;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nvector<vector<int>> e;\nvector<vector<int>> re;\nvector<pair<int,int>> num;\nvector<int> aa;\n\nint dfs(int x,int id){\n  num[x].first=-2;\n  for(auto nx:e[x]){\n    if(num[nx].first==-1) id = dfs(nx, id);\n  }\n  num[x].first = id;\n  id++;\n  return id;\n}\n\nvoid dfs2(int x,int id){\n  aa[x]=id;\n  for(auto nx:re[x]){\n    if(aa[nx]==-1) dfs2(nx,id);\n  }\n}\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n    e=vector<vector<int>>(n);\n    re=vector<vector<int>>(n);\n    vector<double> p(n);\n    int m, a;\n    for(int i=0;i<n;i++){\n      cin >> p[i];\n      cin >> m;\n      for(int j=0;j<m;j++){\n        cin >> a;\n        a--;\n        e[i].push_back(a);\n        re[a].push_back(i);\n      }\n    }\n    \n    num=vector<pair<int,int>>(n);\n    for(int i=0;i<n;i++) num[i]={-1,i};\n    int id=0;\n    for(int i=0;i<n;i++){\n      if(num[i].first==-1) id = dfs(i, id);\n    }\n    sort(all(num),greater<pair<int,int>>());\n    aa = vector<int>(n,-1);\n    id=0;\n    for(int i=0;i<n;i++){\n      if(aa[num[i].second]==-1) dfs2(num[i].second,id++);\n    }\n    vector<bool> ok(id,true);\n    vector<double> pr(id,1);\n    for(int i=0;i<n;i++){\n      for(auto nx:e[i]){\n        if(aa[nx]!=aa[i]) ok[aa[nx]]=false;\n      }\n    }\n    for(int i=0;i<n;i++){\n      pr[aa[i]]*=p[i];\n    }\n    double ans=1;\n    for(int i=0;i<id;i++){\n      if(ok[i]) ans*=(1-pr[i]);\n    }\n    cout << fixed << setprecision(10) << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX_V 1000\nint V,cmp[MAX_V];\nvector<int> G[MAX_V],rG[MAX_V],vs,a,xx;\nint used[MAX_V];\nvoid addedge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n} \nvoid dfs(int v){\n  used[v]=1;\n  for(int i=0;i<G[v].size();i++)\n    if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\nvoid rdfs(int v,int k){\n  used[v]=1;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n}\nvoid dfs2(int v,int k){\n  used[v]=k;\n  for(int i=0;i<G[v].size();i++)\n    if(!used[G[v][i]])dfs2(G[v][i],k);\n  xx.push_back(v);\n}\nint scc(){\n  int pp=0;\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)\n    if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=1;\n  for(int i=vs.size()-1;i>=0;i--)\n    if(!used[vs[i]]){\n      rdfs(vs[i],k++);\n    }\n  k=1;\n  map<int,int>m;\n  memset(used,0,sizeof(used));\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]]){\n      dfs2(vs[i],k);\n      r(j,xx.size())if(used[xx[j]]!=k){\n        m[used[xx[j]]]=0;\n      }\n      xx.clear();\n      m[vs[i]]=cmp[vs[i]];\n      k++;\n    }\n  }\n  r(i,V)if(m[i])\n    a.push_back(m[i]);\n  return k;\n}\nint main(){\n  int x,y;\n  while(cin>>V,V){\n    double d[V],ans=0;\n    a.clear();\n    r(i,1000)G[i].clear(),rG[i].clear();\n    r(i,V){\n      cin>>d[i]>>x;\n      r(j,x){\n        cin>>y;\n        addedge(i,y-1);\n      }\n    }\n    scc();\n    int cnt=0;\n    r(i,a.size()){\n      double p=0;\n      int c=0;\n      r(j,V)if(cmp[j]==a[i]){\n        if(!c++)p+=d[j];\n        else p*=d[j];\n      }\n      if(!cnt++)ans+=(1.0-p);\n      else ans*=(1.0-p);\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cfloat>\n#include <cstring>\n#include <cmath>\n#include <utility>\nusing namespace std;\nusing llong = long long;\n\nllong n;\ndouble p[105];\nvector<vector<int>> g;\nvector<vector<int>> rg;\nvector<int> vs;\nint cmp[105];\nbool used[105];\ndouble pp[105];\ndouble mem[105];\nint indeg[105];\n\n//--- @see ant p.286\nvoid dfs(int v) {\n    used[v] = true;\n    for (int i = 0; i < g[v].size(); i++) {\n        if (!used[g[v][i]]) dfs(g[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for (int i = 0; i < rg[v].size(); i++) {\n        if (!used[rg[v][i]]) rdfs(rg[v][i], k);\n    }\n}\n\nint scc() {\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for (int v = 1; v <= n; v++) {\n        if (!used[v]) dfs(v);\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for (int i = vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    return k;\n}\n//===\n\ndouble solve() {\n    int m = scc();\n\n    for (int i = 1; i <= n; i++) {\n        pp[cmp[i]] *= p[i];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (auto u:g[i]) {\n            if (cmp[i] != cmp[u]) indeg[cmp[u]]++;\n        }\n    }\n\n    double ans = 1;\n    for (int i = 0; i < m; i++) {\n        if (indeg[i] == 0) ans *= (1 - pp[i]);\n    }\n\n    return ans;\n}\n\nint main() {\n    while (cin >> n, n) {\n        g.clear(); rg.clear();\n        g.resize(n + 1); rg.resize(n + 1);\n        for (int i = 0; i < 105; i++) pp[i] = 1;\n        for (int i = 0; i < 105; i++) indeg[i] = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            llong m;\n            llong a;\n            cin >> p[i];\n            cin >> m;\n            for (int j = 0; j < m; j++) {\n                cin >> a;\n                g[i].push_back(a);\n                rg[a].push_back(i);\n            }\n        }\n\n        printf(\"%.*lf\\n\", DBL_DIG, solve());\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n};\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nstruct SCC {\n    int sz, cnt, num;\n    vi post, comp;\n    vector<pair<int, int>> vp;\n    vector<bool> sel;\n    Graph<T> revg;\n    SCC(const Graph<T> &g) {\n        sz = g.size();\n        cnt = 0;\n        num = 0;\n        post.resize(sz, -1);\n        comp.resize(sz, -1);\n        sel.resize(sz, false);\n        revg.resize(sz);\n    }\n    void build(const Graph<T> &g) {\n        for(int i=0;i<sz;++i) {\n            if(sel[i]) continue;\n            sel[i] = true;\n            dfs1(g, i);\n        }\n        rev(g, revg);\n        for(int i=0;i<sz;++i) {\n            vp.emplace_back(make_pair(post[i], i));\n        }\n        sort(vp.begin(), vp.end());\n        reverse(vp.begin(), vp.end());\n        sel.clear();\n        sel.resize(sz, false);\n        for(int i=0;i<sz;++i) {\n            if(sel[vp[i].second]) continue;\n            sel[vp[i].second] = true;\n            comp[vp[i].second] = num;\n            dfs2(revg, vp[i].second);\n            num++;\n        }\n    }\n    vi get_comp() {return comp;}\n    Graph<T> build_graph(const Graph<T> &g) {\n        build(g);\n        vector<set<int>> s(sz);\n        Graph<T> res(sz);\n        for(int i=0;i<sz;++i) {\n            for(int j=0;j<(int)(g[i].size());++j) {\n                s[comp[i]].insert(comp[g[i][j].to]);\n            }\n        }\n        for(int i=0;i<sz;++i) {\n            for(auto j: s[i]) {\n                if(i != j) res[i].push_back(edge<int>({i, j, 1}));\n            }\n        }\n        return res;\n    }\n    void dfs1(const Graph<T> &g, int now) {\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int nxt = g[now][i].to;\n            if(sel[nxt]) continue;\n            sel[nxt] = true;\n            dfs1(g, nxt);\n        }\n        post[now] = cnt;\n        cnt++;\n    }\n    void rev(const Graph<T> &g, Graph<T> &revg) {\n        for(int i=0;i<sz;++i) {\n            for(int j=0;j<(int)(g[i].size());++j) {\n                revg[g[i][j].to].push_back({\n                        g[i][j].to, g[i][j].src, g[i][j].cost});\n            }\n        }\n    }\n    void dfs2(const Graph<T> &revg, int now) {\n        for(int i=0;i<(int)(revg[now].size());++i) {\n            int nxt = revg[now][i].to;\n            if(sel[nxt]) continue;\n            sel[nxt] = true;\n            comp[nxt] = num;\n            dfs2(revg, nxt);\n        }\n    }\n};\nbool solve() {\n  int n; cin >> n;\n  if(n == 0) return false;\n  vector<double> p(n);\n  Graph<int> g(n);\n  for(int i=0;i<n;++i) {\n    int m; cin >> p[i] >> m;\n    for(int j=0;j<m;++j) {\n      int to; cin >> to;\n      to--;\n      g[i].push_back({i, to, 1});\n    }\n  }\n  SCC<int> scc(g);\n  scc.build(g);\n  vi comp = scc.get_comp();\n  map<int, double> mp;\n  map<int, int> din;\n  for(int i=0;i<n;++i) {\n    if(mp.find(comp[i]) == mp.end()) {\n      mp[comp[i]] = p[i];\n    } else {\n      mp[comp[i]] *= p[i];\n    }\n    for(int j=0;j<(int)(g[i].size());++j) {\n      if(comp[g[i][j].to] != comp[i]) din[comp[g[i][j].to]]++;\n    }\n  }\n  double ans = 1;\n  for(auto &e: mp) {\n    if(din[e.first] == 0) ans *= 1 - e.second;\n  }\n  cout << ans << endl;\n  return true;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    if(!solve()) break;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int s = 0, const int d = 0, const Weight w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int i) const { return g[i]; }\n  void addArc(const int src, const int dst, const Weight w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int node1, const int node2, const Weight w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nclass SCC {\npublic:\n  std::vector<int> root;\n  Graph g;\n\n  SCC(const Graph &g) : g(g) {\n    int n = g.size();\n    std::vector<int> ord(n);\n    {\n      int k = n - 1;\n      std::vector<int> visited(n), ordered(n);\n      for (int i = 0; i < n; i++) {\n        if (visited[i]) continue;\n        std::stack<int> stk;\n        stk.push(i);\n        while (stk.size()) {\n          int v = stk.top();\n          visited[v] = true;\n          bool pushed = false;\n          for (auto &e : g[v]) {\n            if (!visited[e.dst]) {\n              stk.push(e.dst);\n              pushed = true;\n            }\n          }\n          if (pushed) continue;\n          if (!ordered[v]) {\n            ordered[v] = true;\n            ord[k--] = v;\n          }\n          stk.pop();\n        }\n      }\n    }\n    Graph rg(n);\n    for (auto &es : g) {\n      for (auto &e : es) rg.addArc(e.dst, e.src, e.weight);\n    }\n    root = std::vector<int>(n, -1);\n    int k = 0;\n    for (int u : ord) {\n      if (root[u] >= 0) continue;\n      std::stack<int> stk;\n      stk.push(u);\n      while (stk.size()) {\n        int v = stk.top();\n        stk.pop();\n        root[v] = k;\n        for (auto &e : rg[v]) {\n          if (root[e.dst] == -1) stk.push(e.dst);\n        }\n      }\n      ++k;\n    }\n  }\n\n  Graph makeDAG() {\n    Graph h(g.size());\n    for (auto &es : g) {\n      for (auto &e : es) {\n        if (root[e.src] == root[e.dst]) continue;\n        h.addArc(root[e.src], root[e.dst]);\n      }\n    }\n    return h;\n  }\n};\n\nmain {\n  int n;\n  while (cin >> n, n) {\n    vd p(n);\n    Graph g(n);\n    rep(i, n) {\n      cin >> p[i];\n      int m;\n      cin >> m;\n      rep(j, m) {\n        int a;\n        cin >> a;\n        g.addArc(i, --a);\n      }\n    }\n\n    SCC scc(g);\n    vi in(n, 0);\n    for (auto &es : scc.makeDAG()) {\n      for (auto &e : es) in[e.dst]++;\n    }\n    vd d(n, 1.0);\n    rep(i, n) d[scc.root[i]] *= p[i];\n\n    double ans = 1.0;\n    rep(i, n) if (in[i] == 0 && d[i] != 1.0) ans *= 1.0 - d[i];\n    cout << prec(32) << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nclass StronglyConnectedComponents{\n\tprivate:\n\t\tvector<bool> used;\n\t\tvector<int> vs; //帰りがけ順の並び\n\t\tvoid dfs(int v){\n\t\t\tused[v] = true;\n\t\t\trep(i,g[v].size()){\n\t\t\t\tif(not used[g[v][i]]) dfs(g[v][i]);\n\t\t\t}\n\t\t\tvs.emplace_back(v);\n\t\t}\n\t\tvoid rdfs(int v, int k){\n\t\t\tused[v] = true;\n\t\t\tcmp[v] = k;\n\t\t\trep(i,rg[v].size()){\n\t\t\t\tif(not used[rg[v][i]]) rdfs(rg[v][i], k);\n\t\t\t}\n\t\t}\n\tpublic:\n\t\ttypedef vector<vector<int>> graph;\n\t\tconst int v; // 頂点数\n\t\tint nv; // SCCした後の頂点数\n\t\tgraph g, rg; // グラフ、辺が逆になったグラフ\n\t\tvector<int> cmp; //属する強連結成分のトポロジカル順序\n\n\t\tStronglyConnectedComponents(int v) : used(v), v(v), g(v), rg(v), cmp(v) { }\n\n\t\tvoid addEdge(int from, int to){\n\t\t\tg[from].emplace_back(to);\n\t\t\trg[to].emplace_back(from);\n\t\t}\n\t\tint solve(){ // 強連結成分分解をしたあとのグラフの頂点数を返す\n\t\t\tfill(all(used),0);\n\t\t\tvs.clear();\n\t\t\trep(i,v){\n\t\t\t\tif(not used[i]) dfs(i);\n\t\t\t}\n\t\t\tfill(all(used),0);\n\t\t\tint k = 0;\n\t\t\tfor(int i = vs.size() - 1; i >= 0; i--){\n\t\t\t\tif(not used[vs[i]]) rdfs(vs[i], k++);\n\t\t\t}\n\t\t\treturn nv = k;\n\t\t}\n\t\tgraph getCssGraph(vector<vector<int>>& node){\n\t\t\tnode = vector<vector<int>>(nv); // node[i]:=SCCによって頂点iに同一視された頂点\n\t\t\tgraph res(nv); // CSSしたあとのグラフ\n\t\t\trep(i,v){\n\t\t\t\tnode[cmp[i]].emplace_back(i);\n\t\t\t\tfor(auto to : g[cmp[i]]){\n\t\t\t\t\tif(cmp[i] == cmp[to]) continue;\n\t\t\t\t\tres[cmp[i]].emplace_back(cmp[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tvoid out(){\n\t\t\trep(i,v){ cout << cmp[i] << ' '; } cout << endl;\n\t\t}\n};\n\nvoid dfs(int pos, vector<bool>& used, vector<vector<int>>& g){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tdfs(to, used, g);\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\n\t\tStronglyConnectedComponents scc(n);\n\t\tvector<double> p(n); // 寝坊する確率\n\t\trep(i,n){\n\t\t\tint m;\n\t\t\tcin >> p[i] >> m;\n\t\t\trep(j,m){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tscc.addEdge(i, a - 1);\n\t\t\t}\n\t\t}\n\t\tscc.solve();\n\n\t\tvector<vector<int>> node;\n\t\tStronglyConnectedComponents::graph g = scc.getCssGraph(node);\n\t\tdouble ans = 1;\n\n\t\tvector<bool> used(scc.nv,0);\n\t\trep(i,scc.nv){\n\t\t\tif(used[i]) continue;\n\n\t\t\tdouble tmp = 1.00;\n\t\t\trep(j,node[i].size()){\n\t\t\t\ttmp *= p[node[i][j]];\n\t\t\t}\n\t\t\tans *= 1.00 - tmp;\n\t\t\tdfs(i, used, g);\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 101\nusing namespace std;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\ndouble p[MAX_V];\n\nint main(){\n  while(cin>>V,V){\n    for(int i=0;i<V;i++) G[i].clear(),rG[i].clear();\n    \n    for(int i=0,m;i<V;i++){\n      cin>>p[i]>>m;\n      for(int j=0,a;j<m;j++)cin>>a,add_edge(i,a-1);\n    }\n    int n=scc();\n    vector<double> col(n,1);\n    vector<bool> root(n,1);\n\n    for(int i=0;i<V;i++){\n      col[cmp[i]]*=p[i];\n      for(int j=0;j<G[i].size();j++)\n\tif(cmp[G[i][j]]!=cmp[i]) root[cmp[G[i][j]]]=0;\n    }\n    double ans=1;\n    for(int i=0;i<n;i++)if(root[i])ans*=1-col[i];\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nvector<int> G[105],rG[105];\nvector<int> vs;\nint N;\nbool used[105];\nint cmp[105];\nvector<int> cmp_v[105];\nbool Gmat[105][105];\ndouble p[105];\ndouble q[105];\nint in[105];\nvoid add_edge(int from,int to){\n\t//cout << from << ' ' << to << endl;\n\tG[from].pb(to);\n\trG[to].pb(from);\n\treturn;\n}\nvoid dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t}\n\tvs.pb(v);\n}\nvoid rdfs(int v,int k){\n\tused[v]=true;\n\tcmp[v]=k;\n\tcmp_v[k].pb(v);\n\tfor(int i=0;i<rG[v].size();i++){\n\t\tif(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n}\nint scc(){\n\tmemset(used,false,sizeof(used));\n\tvs.clear();\n\tfor(int i=0;i<N;i++){\n\t\tif(!used[i])dfs(i);\n\t}\n\t/*for(int i=0;i<vs.size();i++){\n\t\tcout << vs[i] <<  ' ';\n\t}\n\tcout << endl;*/\n\tmemset(used,false,sizeof(used));\n\tint k = 0;\n\tfor(int i=vs.size()-1;i>=0;i--){\n\t\tif(!used[vs[i]])rdfs(vs[i],k++);\n\t}\n\treturn k;\n}\nbool conn(int a,int b){\n\tfor(int i=0;i<cmp_v[a].size();i++){\n\t\tfor(int j=0;j<cmp_v[b].size();j++){\n\t\t\tint u = cmp_v[a][i];\n\t\t\tint v = cmp_v[b][j];\n\t\t\tif(Gmat[u][v])return true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid dump(){\n\tfor(int i=0;i<N;i++){\n\t\tcout << cmp[i] << endl;\n\t}\n}\nbool solve(){\n\tcin >> N;\n\tif(N==0)return false;\n\tmemset(Gmat,false,sizeof(Gmat));\n\tmemset(in,0,sizeof(in));\n\tmemset(cmp,0,sizeof(cmp));\n\tfor(int i=0;i<105;i++){\n\t\tG[i].clear();\n\t\trG[i].clear();\n\t\tcmp_v[i].clear();\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tcin >> p[i];\n\t\tint m;\n\t\tcin >> m; \n\t\tfor(int j=0;j<m;j++){\n\t\t\tint to;\n\t\t\tcin >> to;\n\t\t\tto--;\n\t\t\tGmat[i][to]=true;\n\t\t\tadd_edge(i,to);\n\t\t}\n\t}\n\tint K = scc();\n\tfor(int i=0;i<K;i++){\n\t\tdouble res = 1.0;\n\t\tfor(int j=0;j<cmp_v[i].size();j++){\n\t\t\tres *= p[cmp_v[i][j]];\n\t\t}\n\t\tq[i] = 1.0-res;\n\t}\t\t\n\tfor(int i=0;i<K;i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(conn(j,i))in[i]++;\n\t\t}\n\t}\n\tdouble ans = 1.0;\n\tfor(int i=0;i<K;i++){\n\t\tif(in[i]==0){\n\t\t\tans *= q[i];\n\t\t}\n\t}\n\t//dump();\n\tprintf(\"%.12f\\n\",ans);\n\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\n\n#define _CRT_SECURE_NO_WARNINGS\n\nint N = 0;\ndouble p[110] = {};\nint m[110] = {};\nvector<int> know[110];\nvector<int> beKnown[110];\nbool waked[110] = {};\n\ndouble ans = 1;\nvoid SetWake(int n) {\n\tfor (int i = 0; i < know[n].size();i++) {\n\t\tif (!waked[know[n][i]] ) {\n\t\t\twaked[know[n][i]] = true;\n\t\t\tSetWake(know[n][i]);\n\t\t}\n\t}\n}\n\ndouble semiAns=1;\nvoid CheckSameGroup(int n) {\n\tfor (int i = 0; i < beKnown[n].size(); i++) {\n\t\tif (!waked[beKnown[n][i]]) {\n\t\t\tsemiAns *= p[beKnown[n][i]];\n\t\t\twaked[beKnown[n][i]] = true;\n\t\t\tCheckSameGroup(beKnown[n][i]);\n\t\t}\n\t}\n}\n\nint main() {\n\n\twhile (scanf(\"%d\", &N), N != 0) {\n\t\tans = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tknow[i].clear();\n\t\t\tbeKnown[i].clear();\n\t\t\twaked[i] = false;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tscanf(\"%lf\", p + i);\n\t\t\tscanf(\"%d\", m + i);\n\t\t\tfor (int j = 0; j < m[i]; j++) {\n\t\t\t\tint c;\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tknow[i].push_back(c);\n\t\t\t\tbeKnown[c].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (beKnown[i].size()==0) {\n\t\t\t\twaked[i] = true;\n\t\t\t\tSetWake(i);\n\t\t\t\tans *= (1 - p[i]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (!waked[i]) {\n\t\t\t\twaked[i] = true;\n\t\t\t\tsemiAns = p[i];\n\t\t\t\tCheckSameGroup(i);\n\t\t\t\tans *= (1 - semiAns);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nvoid dfs(int pos, vector<vector<int> > &graph, vector<bool> &arrived_flag, vector<int> &arrived_num) {\n\tif(arrived_flag[pos]) return;\n\tarrived_flag[pos] = true;\n\tfor(int i = 0; i < graph[pos].size(); i++) dfs(graph[pos][i],graph,arrived_flag,arrived_num);\n\tarrived_num.push_back(pos);\n}\n\nvector<int>& rdfs(int pos, vector<vector<int> > &graph, vector<bool> &arrived_flag, vector<int> &group) {\n\tif(arrived_flag[pos]) return group;\n\tarrived_flag[pos] = true;\n\tfor(int i = 0; i < graph[pos].size(); i++) rdfs(graph[pos][i],graph,arrived_flag,group);\n\tgroup.push_back(pos);\n\treturn group;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\",&n);\n\twhile(n>0) {\n\t\tvector<vector<int> > graph(n);\n\t\tvector<vector<int> > r_graph(n);\n\t\tvector<double> ps(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tgraph[i] = vector<int>();\n\t\t\tr_graph[i] = vector<int>();\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdouble p;\n\t\t\tint m;\n\t\t\tscanf(\"%lf%d\",&p,&m);\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tint a; scanf(\"%d\",&a);\n\t\t\t\ta--;\n\t\t\t\tgraph[i].push_back(a);\n\t\t\t\tr_graph[a].push_back(i);\n\t\t\t}\n\t\t\tps[i] = p;\n\t\t}\n\t\tvector<bool> arrived_flag(n);\n\t\tvector<int> arrived_num(0);\n\t\tfor(int i = 0; i < n; i++) dfs(i,graph,arrived_flag,arrived_num);\n\t\tfill(arrived_flag.begin(),arrived_flag.end(),false);\n\t\tdouble ans = 1.0;\n\t\tfor(int i = n-1; i >= 0; i--) {\n\t\t\tvector<int> group = rdfs(arrived_num[i],r_graph,arrived_flag, *(new vector<int>(0)));\n\t\t\tif(group.size()>0) {\n\t\t\t\tmap<int,bool> group_nums;\n\t\t\t\tfor(int j = 0; j < group.size(); j++) {\n\t\t\t\t\tgroup_nums[group[j]] = true;\n\t\t\t\t}\n\t\t\t\tbool is_final = true;\n\t\t\t\tfor(int j = 0; j < group.size(); j++) {\n\t\t\t\t\tint next = group[j];\n\t\t\t\t\tfor(int k = 0; k < r_graph[next].size(); k++) {\n\t\t\t\t\t\tis_final &= group_nums[r_graph[next][k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(is_final) {\n\t\t\t\t\tdouble all_p = 1.0;\n\t\t\t\t\tfor(int j = 0; j < group.size(); j++) {\n\t\t\t\t\t\tall_p *= ps[group[j]];\n\t\t\t\t\t}\n\t\t\t\t\tans *= (1-all_p);\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9lf\\n\",ans);\n\t\tscanf(\"%d\",&n);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\n\nvector<int> mae[200],gyaku[200];\nlong double percentage[200];\nint visited[200];\nlong double colorP[200];\nstack<int> tmp;\nvoid Fdfs(int now) {\n    for (auto x : mae[now]) {\n        if (visited[x] == 1) continue;\n        visited[x] = 1;\n        Fdfs(x);\n    }\n    tmp.push(now);\n}\nvoid Sdfs(int now) {\n    colorP[visited[now]] *= percentage[now];\n    for (auto x : gyaku[now]) {\n        if (visited[x] != 0) {\n            if (visited[x] < visited[now]) {\n                colorP[visited[now]] = 0.0L;\n            }\n            continue;\n        }\n        visited[x] = visited[now];\n        Sdfs(x);\n    }\n}\nvoid solve(){\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) return;\n        REP(i, n) {\n            mae[i].clear();\n            gyaku[i].clear();\n            visited[i] = 0;\n        }\n        REP(i, n) {\n            cin >> percentage[i];\n            int m;\n            cin >> m;\n            REP(q, m) {\n                int a;\n                cin >> a;\n                a--;\n                mae[i].push_back(a);\n                gyaku[a].push_back(i);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (visited[i] == 0) {\n                visited[i] = 1;\n                Fdfs(i);\n            }\n        }\n        REP(i, n+1) {\n            visited[i] = 0;\n            colorP[i] = 0;\n        }\n        REP(hoge, n){\n            int i = tmp.top();\n            tmp.pop();\n            if (visited[i] == 0) {\n                colorP[hoge+1] = 1.0L;\n                visited[i] = hoge + 1;\n                Sdfs(i);\n            }\n        }\n        long double ans = 1.0L;\n        for (int q = 0; q < n + 1; ++q) {\n            ans *= 1.0L - colorP[q];\n        }\n        cout << ans << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 200\nint n,m;\ndouble t[MAX_N];\nint G[MAX_N][MAX_N];\nbool visited[MAX_N];\nint par[MAX_N];\n\nvoid rdfs(int pos,int si){\n  visited[pos]=true;\n  par[pos]=si;\n  for(int i=0;i<n;i++){\n    if(G[i][pos]==0)continue;\n    if(visited[i])continue;\n    rdfs(i,si);\n  }\n}\n\nvoid dfs(int pos,vector<int> &v){\n  visited[pos]=true;\n  for(int i=0;i<n;i++){\n    if(G[pos][i]==0)continue;\n    if(visited[i])continue;\n    dfs(i,v);\n  }\n  v.push_back(pos);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(G,0,sizeof(G));\n    for(int i=0;i<n;i++){\n      cin>>t[i];\n      int k;\n      cin>>k;\n      for(int j=0;j<k;j++){\n        int a;\n        cin>>a;\n        a--;\n        G[i][a]=1;\n      }\n    }\n\n\n    vector<int> v;\n    memset(visited,false,sizeof(visited));\n    for(int i=0;i<n;i++){\n      if(visited[i])continue;\n      dfs(i,v);\n    }\n    \n    memset(visited,false,sizeof(visited));\n    reverse(v.begin(),v.end());\n    for(int i=0;i<(int)v.size();i++){\n      int si=v[i];\n      if(visited[si])continue;\n      rdfs(si,si);\n    }\n\n    vector<bool> flg(n,false);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(G[i][j]==0)continue;\n        if(par[i]!=par[j]){\n          flg[ par[j] ]=true;\n        }\n      }\n    }\n\n    double ans=1.0;\n    for(int i=0;i<n;i++){\n      if(par[i]!=i)continue;\n      if(flg[i])continue;\n      double p=1.0;\n      for(int j=0;j<n;j++){\n        if(par[j]!=i)continue;\n        p*=t[j];\n      }\n      ans*=(1.0-p);\n    }\n\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = long double;\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vector<R> p(n);\n        vector<vi> a(n);\n        vector<vi> adj(n, vi(n));\n        rep(i, n){\n            cin >> p[i]; p[i] = 1.0 - p[i];\n            int m; cin >> m;\n            a[i] = vi(m); for(auto& e : a[i]) cin >> e, e--, adj[i][e] = true;\n        }\n\n        vector<vi> cango(n, vi(n));\n        rep(i, n){\n            cango[i][i] = true;\n            for(auto& j : a[i]){\n                cango[i][j] = true;\n            }\n        }\n        rep(k, n) rep(i, n) rep(j, n) cango[i][j] |= (cango[i][k] & cango[k][j]);\n\n        int m = 0;\n        vi group(n, -1);\n        rep(i, n){\n            if(group[i] != -1) continue;\n            group[i] = m++;\n            rep(j, i + 1, n){\n                if(cango[i][j] && cango[j][i]){\n                    assert(group[j] == -1);\n                    group[j] = group[i];\n                }\n            }\n        }\n\n        vector<set<int>> edge(m);\n        rep(i, n){\n            rep(j, n){\n                if(group[i] == group[j]) continue;\n                if(adj[i][j]){\n                    edge[group[j]].insert(group[i]);\n                }\n            }\n        }\n\n        vector<R> q(m, 1.0);\n        rep(i, n){\n            q[group[i]] *= (1.0 - p[i]);\n        }\n        for(auto& e : q) e = 1.0 - e;\n\n        R res = 1.0;\n        cerr << m << endl;\n        rep(i, m){\n            if(edge[i].size() >= 1) continue;\n            res *= q[i];\n        }\n\n        cout.precision(20);\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ld = long double;\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\n\nint main()\n{\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) {\n            break;\n        }\n        Graph g(N);\n        vector<ld> p(N, 0);\n        for (int i = 0; i < N; i++) {\n            cin >> p[i];\n            int M;\n            cin >> M;\n            for (int j = 0; j < M; j++) {\n                int from;\n                cin >> from;\n                from--;\n                g.addEdge(i, from);\n            }\n        }\n\n        vector<vector<bool>> reachable(N, vector<bool>(N, false));\n        for (int i = 0; i < N; i++) {\n            queue<int> q;\n            vector<bool> used(N, false);\n            q.push(i);\n            used[i] = true;\n            reachable[i][i] = true;\n            while (not q.empty()) {\n                const int s = q.front();\n                q.pop();\n                for (int to : g.edge[s]) {\n                    reachable[i][to] = true;\n                    if (used[to]) {\n                        continue;\n                    }\n                    used[to] = true;\n                    q.push(to);\n                }\n            }\n        }\n\n        vector<int> number(N);\n        for (int i = 0; i < N; i++) {\n            number[i] = i;\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (reachable[i][j] and reachable[j][i]) {\n                    number[j] = number[i];\n                }\n            }\n        }\n        vector<ld> prob(N, -1);\n        for (int i = 0; i < N; i++) {\n            prob[number[i]] = (prob[number[i]] == -1) ? p[i] : prob[number[i]] * p[i];\n        }\n\n        vector<int> indim(N, 0);\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) {\n                    continue;\n                }\n                if (reachable[i][j] and number[i] != number[j]) {\n                    indim[number[j]]++;\n                }\n            }\n        }\n        ld ans = 1;\n        for (int i = 0; i < N; i++) {\n            if (indim[i] == 0 and prob[i] != -1) {\n                ans *= (1 - prob[i]);\n            }\n        }\n        cout << fixed << setprecision(10) << ans << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n#include <iomanip>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\n#include <functional>\nvector<int> StronglyConnectedComponent(vector<vector<int>> &G, vector<vector<int>> &rG) {\n    int n = G.size();\n    vector<bool> used(n, false);\n    vector<int> V;\n    vector<int> res(n, -1);\n    function<void(int)> dfs = [&](int v) {\n        if (used[v]) return;\n        used[v] = true;\n        for (auto &e : G[v]) {\n            dfs(e);\n        }\n        V.push_back(v);\n    };\n    function<void(int, int)> rdfs = [&](int v, int k) {\n        if (used[v]) return;\n        res[v] = k;\n        used[v] = true;\n        for (auto &e : rG[v]) {\n            rdfs(e, k);\n        }\n    };\n    for (int i = 0; i < n; i++) {\n        if (!used[i]) dfs(i);\n    }\n    used.assign(n, false);\n    int k = 0;\n    for (auto it = rbegin(V); it != rend(V); it++) {\n        if (!used[*it]) rdfs(*it, k++);\n    }\n    return res;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n, n) {\n        vector<double> p(n);\n        vector<vector<int>> G(n), rG(n);\n        REP(i, 0, n) {\n            cin >> p[i];\n            int m;\n            cin >> m;\n            REP(j, 0, m) {\n                int a;\n                cin >> a;\n                a--;\n                G[i].push_back(a);\n                rG[a].push_back(i);\n            }\n        }\n        auto res = StronglyConnectedComponent(G, rG);\n        int sz = *max_element(res.begin(), res.end()) + 1;\n        vector<double> pp(sz, 1.0);\n        REP(i, 0, n) {\n            pp[res[i]] *= p[i];\n        }\n        REP(i, 0, pp.size()) {\n            pp[i] = 1 - pp[i];\n        }\n        vector<int> DAG(sz, 0);\n        REP(i, 0, n) {\n            REP(j, 0, G[i].size()) {\n                if (res[i] == res[G[i][j]]) continue;\n                DAG[res[G[i][j]]]++;\n            }\n        }\n        double ans = 1.0;\n        REP (i, 0, sz) {\n            if (DAG[i] == 0) {\n                ans *= pp[i];\n            }\n        }\n        cout << fixed << setprecision(10) << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 105\nusing namespace std;\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint n,m,to;\ndouble p[MAX_V],ans[MAX_V];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    V=n;\n    for(int i=0;i<n;i++){\n      cin>>p[i]>>m;\n      for(int j=0;j<m;j++){\n\tcin>>to; to--;\n\tadd_edge(i,to);\n      }\n    }\n    int node=scc();\n    for(int i=0;i<node;i++)ans[i]=1;\n    for(int i=0;i<n;i++)\n      ans[cmp[i]]*=p[i];\n    for(int i=0;i<node;i++)\n      ans[i]=1-ans[i];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<G[i].size();j++){\n\tto=G[i][j];\n\tif(cmp[i]!=cmp[to])ans[cmp[to]]=-1;\n      }\n    double P=1;\n    for(int i=0;i<node;i++)\n      if(ans[i]!=-1)P*=ans[i];\n    printf(\"%.9f\\n\",P);\n    for(int i=0;i<n;i++){\n      G[i].clear();\n      rG[i].clear();\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n#define INF 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t\tstatic void print(std::ostream &os, const Tuple &t) {\n\t\t\t__TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t\t\tos << \", \" << std::get<N - 1>(t);\n\t\t}\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t\tstatic void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t\tos << '(';\n\t\t__TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t\tos << ')';\n\t\treturn os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t\treturn os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\tos << '[';                                \\\n\tfor (auto it = begin(c); it != end(c);) { \\\n\t\tos << *it;                            \\\n\t\tos << (++it != end(c) ? \", \" : \"\");   \\\n\t}                                         \\\n\treturn os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t\t__INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\t__INNER__                                               \\\n\t}\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t\t__INNER__                                                  \\\n\t}\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\tstd::deque<T> v;                                        \\\n\t\tfor (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t\t\treturn os << v;                                         \\\n\t}\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n\tconstexpr static signed MODULO = M;\n\tconstexpr static unsigned TABLE_SIZE = T;\n\n\tsigned x;\n\n\tmod_int() : x(0) {}\n\n\tmod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n\tmod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n\tmod_int &operator+=(const mod_int &rhs) {\n\t\tif ((x += rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator-=(const mod_int &rhs) {\n\t\tif ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator*=(const mod_int &rhs) {\n\t\tx = static_cast<signed>(1LL * x * rhs.x % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int &operator/=(const mod_int &rhs) {\n\t\tx = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int operator-() const { return mod_int(-x); }\n\n\tmod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n\tmod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n\tmod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n\tmod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n\tbool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n\tmod_int inv() const {\n\t\tassert(x != 0);\n\t\tif (x <= static_cast<signed>(TABLE_SIZE)) {\n\t\t\tif (_inv[1].x == 0) prepare();\n\t\t\treturn _inv[x];\n\t\t} else {\n\t\t\tsigned a = x, b = MODULO, u = 1, v = 0, t;\n\t\t\twhile (b) {\n\t\t\t\tt = a / b;\n\t\t\t\ta -= t * b;\n\t\t\t\tstd::swap(a, b);\n\t\t\t\tu -= t * v;\n\t\t\t\tstd::swap(u, v);\n\t\t\t}\n\t\t\treturn mod_int(u);\n\t\t}\n\t}\n\n\tmod_int pow(long long t) const {\n\t\tassert(!(x == 0 && t == 0));\n\t\tmod_int e = *this, res = mod_int(1);\n\t\tfor (; t; e *= e, t >>= 1)\n\t\t\tif (t & 1) res *= e;\n\t\treturn res;\n\t}\n\n\tmod_int fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _fact[x];\n\t}\n\n\tmod_int inv_fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _inv_fact[x];\n\t}\n\n\tmod_int choose(mod_int y) {\n\t\tassert(y.x <= x);\n\t\treturn this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n\t}\n\n\tstatic mod_int _inv[TABLE_SIZE + 1];\n\n\tstatic mod_int _fact[TABLE_SIZE + 1];\n\n\tstatic mod_int _inv_fact[TABLE_SIZE + 1];\n\n\tstatic void prepare() {\n\t\t_inv[1] = 1;\n\t\tfor (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n\t\t\t_inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n\t\t}\n\t\t_fact[0] = 1;\n\t\tfor (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n\t\t\t_fact[i] = _fact[i - 1] * int(i);\n\t\t}\n\t\t_inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n\t\tfor (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n\t\t\t_inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n\t\t}\n\t}\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n\treturn os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n\tlong long s;\n\tis >> s;\n\trhs = mod_int<M, F>(s);\n\treturn is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\nconst ll mod = 1000000007;\nconst int MAX_N = 10000;  // 400MB\n// const int MAX_N = 1024; // 4MB\n// nCr % mod\n\n//#define int long long\n#define double long double \n\ninline ll gcds(ll a, ll b) { return b ? gcds(b, a % b) : a; }\ninline ll lcms(ll a, ll b) { return a / gcd(a, b) * b; }\n\n#define RK 200000000000\n#define LK 300000000000\n#define PL 400000000000\n#define MI 500000000000\n#define KA 600000000000\n\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n    g[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\nstd::vector<int> kosaraju(const Graph &g) {\n    int n = g.size(), sz = 0;\n    Graph rg(n);\n    std::vector<int> stk, cmp(n, -1), added(n), visited(n), ord(n);\n    for (auto &es : g) {\n        for (auto e : es) {\n            std::swap(e.src, e.dst);\n            rg[e.src].emplace_back(e);\n        }\n        sz += es.size();\n    }\n    stk.resize(n + sz);\n    sz = 0;\n    for (int i = 0; i < n; i++) {\n        if (visited[i]) continue;\n        int s = 0;\n        stk[s++] = i;\n        while (s != 0) {\n            int v = stk[s - 1];\n            visited[v] = true;\n            bool pushed = false;\n            for (auto &e : g[v]) {\n                int dst = e.dst;\n                if (!visited[dst]) {\n                    stk[s++] = dst;\n                    pushed = true;\n                }\n            }\n            if (pushed) continue;\n            int t = stk[s - 1];\n            if (!added[t]) {\n                added[t] = true;\n                ord[n - ++sz] = t;\n            }\n            --s;\n        }\n    }\n    int k = 0;\n    for (int &u : ord) {\n        if (cmp[u] != -1) continue;\n        int s = 0;\n        stk[s++] = u;\n        while (s != 0) {\n            int v = stk[--s];\n            cmp[v] = k;\n            for (auto &e : rg[v]) {\n                int d = e.dst;\n                if (cmp[d] == -1) stk[s++] = d;\n            }\n        }\n        ++k;\n    }\n    return cmp;\n}\n\n\nsigned main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tGraph g(n);\n\t\tif(n==0)break;\n\n\t\tvector<bool> check(n,false);\n\t\tvector<double> p(n);\n\t\tvector<vector<int>> revg(n);\n\n\t\tlp(i,n){\n\t\t\tcin>>p[i];\n\t\t\tint m;\n\t\t\tcin>>m;\n\t\t\tlp(j,m){\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\trevg[a-1].push_back(i);\n\t\t\t\tadd_arc(g,i,a-1);\n\t\t\t\tcheck[a-1]=true;\n\t\t\t}\n\t\t}\n\n\t\tvector<int> cmp=kosaraju(g);\n\t\tint maxin=0;\n\t\tlp(i,cmp.size()){\n\t\t\tmaxin=max(cmp[i],maxin);\n\t\t}\n\t\tvector<bool> checks(maxin+1,true);\n\t\tlp(i,n){\n\t\t\tlp(j,revg[i].size()){\n\t\t\t\tint now = i;\n\t\t\t\tint to=revg[i][j];\n\t\t\t\tif(cmp[now]!=cmp[to]){\n\t\t\t\t\tchecks[cmp[now]]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tdouble ans=1;\n\t\tlp(i,checks.size()){\n\t\t\tdouble base=1;\n\t\t\tif(checks[i]){\n\t\t\t\tlp(j,cmp.size()){\n\t\t\t\t\tif(i==cmp[j]){\n\t\t\t\t\t\tbase*=p[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans*=1-base;\n\t\t\t}\n\t\t}\n\t\tcout<<fixed<<setprecision(15)<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 1000\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid init(){\n\tfor(int i=0;i<MAX_V;i++)G[i].clear();\n\tfor(int i=0;i<MAX_V;i++)rG[i].clear();\n\tfor(int i=0;i<MAX_V;i++){\n\t\tcmp[i]=0;\n\t\tused[i]=0;\n\t}\n}\n\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n\tused[v]=true;\n\tcmp[v]=k;\n\tfor(int i=0;i<rG[v].size();i++)\n\t\tif(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n\tmemset(used,0,sizeof(used));\n\tvs.clear();\n\tfor(int v=0;v<V;v++)\n\t\tif(!used[v])dfs(v);\n\n\tmemset(used,0,sizeof(used));\n\tint k=0;\n\tfor(int i=vs.size()-1;i>=0;i--)\n\t\tif(!used[vs[i]])rdfs(vs[i],k++);\n\n\treturn k;\n}\n\nint main(){\n\twhile(cin>>V,V){\n\t\tinit();\n\t\tdouble p[101];\n\t\tfor(int i=0;i<V;i++){\n\t\t\tint a;\n\t\t\tcin>>p[i]>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tint k;\n\t\t\t\tcin>>k;\n\t\t\t\tk--;\n\t\t\t\tadd_edge(i,k);\n\t\t\t}\n\t\t}\n\t\tint use[101]={};\n\t\tint k=scc();\n\t\t//cout<<k<<endl;\n\t\tvector<int> P[101];\n\t\n\t\tfor(int i=0;i<V;i++){\n\t\t\t//cout<<cmp[i]<<endl;\n\t\t\tP[cmp[i]].push_back(i);\n\t\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\t\tif(cmp[G[i][j]]!=cmp[i])use[cmp[G[i][j]]]=1;\n\t\t\t}\n\t\t}\n\t\n\t\tvector<double> ans;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tif(use[i])continue;\n\t\t\tdouble tt;\n\t\t\tfor(int j=0;j<P[i].size();j++){\n\t\t\t\tif(j==0)tt=p[P[i][j]];\n\t\t\t\telse{\n\t\t\t\t\ttt*=p[P[i][j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans.push_back(1-tt);\n\t\t}\n\t\n\t\tdouble sum;\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tif(i==0)sum=ans[i];\n\t\t\telse{\n\t\t\t\tsum*=ans[i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lf\\n\",sum);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 200\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.9f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nint V,m,a;\nvector<int> G[MAX];\nvector<int> rG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX];\ndouble p[MAX],ip[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    G[i].clear();\n    rG[i].clear();\n    p[i]=1.0;\n    ip[i]=0.0;\n  }\n}\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n  \nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < G[v].size();i++){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n  \nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0;i < rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n  \nvoid scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v = 0;v < V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size() - 1;i >= 0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  return;\n}\n\nvoid solve(){\n  double res=1.0;\n  map<int,vector<int> > mp;\n  FOR(i,0,V)mp[cmp[i]].pb(i);\n  FOR(i,0,V)FOR(j,0,V)if(cmp[i]==cmp[j])p[i]*=ip[j];\n  FOR(i,0,V){\n    vector<int> v=mp[i];\n    if(v.size()==0)continue;\n    bool flag=true;\n    FOR(j,0,v.size()){\n      int now=v[j];\n      FOR(k,0,rG[now].size()){\n        int next=rG[now][k];\n        if(cmp[next]!=i)flag=false;\n      }\n    }\n    if(flag)res*=(1.0-p[v[0]]);\n  }\n  pd(res);\n}\n\nint main()\n{\n  while(1){\n    cin>>V;\n    if(V==0)break;\n    init();\n    FOR(i,0,V){\n      cin>>ip[i]>>m;\n      FOR(j,0,m){\n        cin>>a;\n        add_edge(i,a-1);\n      }\n    }\n    scc();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i < (int)(b);++i)\n\nusing Long = long long;\ntemplate<typename W>\nusing Edge = pair<int, W>;\ntemplate<typename W>\nusing WeightedGraph = vector<vector<Edge<W>>>;\nusing UnWeightedGraph = vector< vector<int>>;\n\n// Strongly Connected Component\n// 時間計算量 : O(V+E)\ntemplate< typename G >\nstruct SCC {\n    // G : Unweighted Graph or Weighted Graph\n    // g : SCCを求める対象のグラフ\n    const G &g;\n    // forward : 順向きの辺\n    // backward : 逆向きの辺\n    UnWeightedGraph forward, backward;\n    // comp[i] : 頂点iが属す強連結成分のindex\n    // order : 1回目の順向きdfsの帰りがけ順を格納\n    // used : 1回目の順向きdfsで通ったかを記憶\n    vector< int > comp, order, used;\n\n    SCC(UnWeightedGraph &g) : g(g), forward(g.size()), backward(g.size()), comp(g.size(), -1), used(g.size()) {\n        for(int i = 0; i < g.size(); i++) {\n            for(auto& e : g[i]) {\n                forward[i].emplace_back((int) e);\n                backward[(int) e].emplace_back(i);\n            }\n        }\n    }\n\n    template<typename W>\n    SCC(WeightedGraph<W> &g) : g(g), forward(g.size()), backward(g.size()), comp(g.size(), -1), used(g.size()) {\n        for(int i = 0; i < g.size(); i++) {\n            for(auto& e : g[i]) {\n                forward[i].emplace_back((int) e.first);\n                backward[(int) e.first].emplace_back(i);\n            }\n        }\n    }\n\n    void dfs(int idx) {\n        if(used[idx]) return;\n        used[idx] = true;\n        for(int to : forward[idx]) \n            dfs(to);\n        // 帰りがけを記憶.\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt) {\n        if(comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for(int to : backward[idx]) rdfs(to, cnt);\n    }\n\n    UnWeightedGraph buildDAG() {\n        UnWeightedGraph DAG;\n        for(int i = 0; i < forward.size(); i++) \n            dfs(i);\n        // 帰りがけの遅かった頂点から探索\n        reverse(begin(order), end(order));\n        int ptr = 0;\n        for(int i : order) {\n            if(comp[i] == -1) {\n                // 強連結ごとに逆向きdfsが停止.\n                rdfs(i, ptr);\n                ptr++;\n            }\n        }\n        // DAG構築\n        DAG.resize(ptr);\n        for(int i = 0; i < g.size(); i++) {\n            for(auto &&to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if(x == y) continue;\n                DAG[x].push_back(y);\n            }\n        }\n        return DAG;\n    }\n\n    int build() {\n        for(int i = 0; i < forward.size(); i++) \n            dfs(i);\n        // 帰りがけの遅かった頂点から探索\n        reverse(begin(order), end(order));\n        int ptr = 0;\n        for(int i : order) {\n            if(comp[i] == -1) {\n                // 強連結ごとに逆向きdfsが停止.\n                rdfs(i, ptr);\n                ptr++;\n            }\n        }\n        return ptr;\n    }\n};\n\nint main(void) {\n    int N;\n    while(true) {\n        cin >> N;\n        if ( N == 0) break;\n        vector<double> p(N);\n        UnWeightedGraph G(N);\n        int m;\n        rep(i, N) {\n            cin >> p[i];\n            cin >> m;\n            rep(j, m) {\n                int a;\n                cin >> a;\n                G[i].emplace_back(a-1);\n            }\n        }\n\n        SCC<UnWeightedGraph> scc(G);\n        int scc_num = scc.build();\n        \n        vector<int> is_root(scc_num, true);\n        for(int i = 0; i < G.size(); i++) {\n            for(auto &&to : G[i]) {\n                int x = scc.comp[i], y = scc.comp[to];\n                if(x == y) continue;\n                is_root[y] = false;\n            }\n        }\n\n        double ans = 1.0;\n        for(int i = 0;i < scc_num;i++) {\n            if (is_root[i]) {\n                double gp = 1.0;\n                rep(j, N) {\n                    if (scc.comp[j] == i) \n                        gp *= p[j];\n                }\n                ans *= (1 - gp);\n            }\n        }\n        cout << fixed << setprecision(10);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define All(A) A.begin(),A.end()\n#define RAll(A) A.rbegin(),A.rend()\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<30;\n\ndouble p[101],P[101];\n\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n    const G &g;\n    G gg, rg;\n    vector< int > comp, order, used;\n\n    StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n        for(int i = 0; i < g.size(); i++) {\n            for(auto e : g[i]) {\n                gg[i].emplace_back((int) e);\n                rg[(int) e].emplace_back(i);\n            }\n        }\n    }\n\n    int operator[](int k) {\n        return (comp[k]);\n    }\n\n    void dfs(int idx) {\n        if(used[idx]) return;\n        used[idx] = true;\n        for(int to : gg[idx]) dfs(to);\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt) {\n        if(comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for(int to : rg[idx]) rdfs(to, cnt);\n    }\n\n    void build(G &t) {\n        for(int i = 0; i < gg.size(); i++) dfs(i);\n        reverse(begin(order), end(order));\n        int ptr = 0;\n        for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n        t.resize(ptr);\n        for(int i=0;i<g.size();i++) P[i]=1;\n        for(int i=0;i<g.size();i++) P[comp[i]]*=p[i];\n        for(int i = 0; i < g.size(); i++) {\n            for(auto &to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if(x == y) continue;\n                t[x].push_back(y);\n            }\n        }\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) break;\n        vector<vector<int>> G(N);\n        for(int i=0;i<N;i++){\n            int m;\n            cin >> p[i] >> m;\n            for(int j=0;j<m;j++){\n                int u;\n                cin >> u;\n                u--;\n                G[i].eb(u);\n            }\n        }\n        StronglyConnectedComponents<vector<vector<int>>> scc(G);\n        vector<vector<int>> h;\n        scc.build(h);\n        vector<int> s(N,0);\n        for(int i=0;i<h.size();i++){\n            for(int j=0;j<h[i].size();j++){\n                s[h[i][j]]++;\n            }\n        }\n        double ans=1;\n        for(int i=0;i<h.size();i++){\n            if(!s[i]){\n                ans*=1-P[i];\n            }\n        }\n        cout <<setprecision(10)<<ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = double;\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vector<R> p(n);\n        vector<vi> a(n);\n        vector<vi> adj(n, vi(n));\n        rep(i, n){\n            cin >> p[i]; p[i] = 1.0 - p[i];\n            int m; cin >> m;\n            a[i] = vi(m); for(auto& e : a[i]) cin >> e, e--, adj[i][e] = true;\n        }\n\n        vector<vi> cango(n, vi(n));\n        rep(i, n){\n            cango[i][i] = true;\n            for(auto& j : a[i]){\n                cango[i][j] = true;\n            }\n        }\n        rep(k, n) rep(i, n) rep(j, n) cango[i][j] |= (cango[i][k] & cango[k][j]);\n\n        int m = 0;\n        vi group(n, -1);\n        rep(i, n){\n            if(group[i] != -1) continue;\n            group[i] = m++;\n            rep(j, i + 1, n){\n                if(cango[i][j] && cango[j][i]) group[j] = group[i];\n            }\n        }\n\n        vector<set<int>> edge(m);\n        rep(i, n){\n            rep(j, n){\n                if(group[i] == group[j]) continue;\n                if(adj[i][j]){\n                    edge[group[j]].insert(group[i]);\n                }\n            }\n        }\n\n        vector<R> q(m, 1.0);\n        rep(i, n){\n            q[group[i]] *= (1.0 - p[i]);\n        }\n        for(auto& e : q) e = 1.0 - e;\n\n        R res = 1.0;\n        rep(i, m){\n            if(edge[i].size() >= 1) continue;\n            res *= q[i];\n        }\n\n        cout.precision(20);\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\ntemplate <typename T>\nstruct GraphSCC {\npublic:\n    const int n;\n    vector<bool> isthrough;\n    vector<int> vs, cmp;\n    vector< vector< Edge<T> > > G, rG;\n    vector< vector<int> > H;\n\n    GraphSCC(vector< vector< Edge<T> > > &_G) :\n        n(_G.size()), isthrough(n, false), cmp(n, 0), G(_G), rG(n) {\n            // ????????°??????\n            for(int i=0; i<n; i++) for(int j=0; j<G[i].size(); j++)\n                rG[ G[i][j].to ].push_back(Edge<T>(i, G[i][j].cost));\n        }\n\n    void SCC_dfsone(int cur) {\n        isthrough[cur] = true;\n        for(int i=0; i<G[cur].size(); i++) {\n            if(!isthrough[G[cur][i].to]) {\n                SCC_dfsone(G[cur][i].to);\n            }\n        }\n        vs.push_back(cur);\n    }\n\n    void SCC_dfstwo(vector<int> &vec, int cur, int k) {\n        cmp[cur] = k;\n        isthrough[cur] = true;\n        vec.push_back(cur);\n        for(int i=0; i<rG[cur].size(); i++) {\n            if(!isthrough[rG[cur][i].to]) {\n                SCC_dfstwo(vec, rG[cur][i].to, k);\n            }\n        }\n    }\n\n    pair<vector<int>, int> scc() {\n        // 1?????????DFS\n        for(int i=0; i<n; i++)\n            if(!isthrough[i]) SCC_dfsone(i);\n\n        fill(isthrough.begin(), isthrough.end(), false);\n        reverse(vs.begin(), vs.end());\n        int k = 0; vector< vector<int> > S;\n\n        // 2?????????DFS\n        for(int i=0; i<vs.size(); i++) {\n            if(!isthrough[vs[i]]) {\n                S.push_back(vector<int>());\n                SCC_dfstwo(S.back(), vs[i], k++);\n            }\n        }\n\n        H.resize(k);\n        fill(isthrough.begin(), isthrough.end(), false);\n        for(int i=0; i<k; i++) {\n            for(int j=0; j<S[i].size(); j++) {\n                int v = S[i][j];\n                for(int x=0; x<G[v].size(); x++) {\n                    int u = G[v][x].to;\n                    if(isthrough[cmp[u]] || cmp[v] == cmp[u]) continue;\n                    isthrough[cmp[u]] = true;\n                    H[cmp[v]].push_back(cmp[u]);\n                }\n            }\n            for(int j=0; j<H[i].size(); j++) isthrough[ H[i][j] ] = false;\n        }\n        return make_pair(cmp, k);\n    }\n};\n\nint N, M, deg[110];\ndouble p[110];\n\nsigned main() {\n    while(cin >> N, N) {\n        memset(deg, 0, sizeof(deg));\n        Graph<int> G(N);\n        rep(i,0,N) {\n            cin >> p[i] >> M;\n            rep(j,0,M) {\n                int v; cin >> v; v--;\n                G[i].push_back(Edge<int>(v, 1));\n            }\n        }\n\n        GraphSCC<int> gs(G);\n        // SCC ??????????????????????±?????????????SCC ??????????????°\n        pair< vector<int>, int > res = gs.scc();\n\n        // ??\\?¬???°????¨????\n        rep(i,0,res.second) for(auto x : gs.H[i]) deg[x]++;\n        double ans = 1.0;\n        rep(i,0,res.second) {\n            // ??\\?¬???° 0 ??????????????????????¨????\n            if(deg[i]) continue;\n            // printf(\"zero degree: node %lld\\n\", i);\n            double temp = 1.0;\n            rep(j,0,N) {\n                // ????????£?????????????±?????????´???????????????\n                if(res.first[j] == i) {\n                    // printf(\"same: %lld\\n\", j+1);\n                    temp *= p[j];\n                }\n            }\n            ans *= (1 - temp);\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = long double;\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vector<R> p(n);\n        vector<vi> a(n);\n        vector<vi> adj(n, vi(n));\n        rep(i, n){\n            cin >> p[i];\n            int m; cin >> m;\n            a[i] = vi(m); for(auto& e : a[i]) cin >> e, e--, adj[i][e] = true;\n        }\n\n        vector<vi> cango(n, vi(n));\n        rep(i, n){\n            cango[i][i] = true;\n            for(auto& j : a[i]){\n                cango[i][j] = true;\n            }\n        }\n        rep(k, n) rep(i, n) rep(j, n) cango[i][j] |= (cango[i][k] & cango[k][j]);\n\n        int m = 0;\n        vi group(n, -1);\n        rep(i, n){\n            if(group[i] != -1) continue;\n            rep(j, i, n){\n                if(cango[i][j] & cango[j][i]){\n                    assert(group[j] == -1);\n                    group[j] = m;\n                }\n            }\n            m++;\n        }\n\n        vector<set<int>> edge(m);\n        rep(i, n){\n            rep(j, n){\n                if(group[i] == group[j]) continue;\n                if(adj[i][j]){\n                    edge[group[j]].insert(group[i]);\n                }\n            }\n        }\n\n        vector<R> q(m, 1.0);\n        rep(i, n){\n            q[group[i]] *= p[i];\n        }\n\n        R res = 1.0;\n        rep(i, m){\n            if(edge[i].size() >= 1) continue;\n            res *= ((R)1.0 - q[i]);\n        }\n\n        cout.precision(10);\n        cout << fixed << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nvector<int> g[111],rg[111],ng[111],vs;\nbool used[111];\nint cmp[111];\ndouble p[111],np[111];\nvector<P> es;\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int nv:g[v]){\n    if(!used[nv])dfs(nv);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int nv:rg[v]){\n    if(!used[nv])rdfs(nv,k);\n  }\n}\n\nvoid ddfs(int v){\n  used[v]=true;\n  for(int nv:ng[v]){\n    if(!used[nv])dfs(nv);\n  }\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    rep(i,111){\n      g[i].clear();\n      rg[i].clear();\n      ng[i].clear();\n    }\n    vs.clear();\n    es.clear();\n    cin>>n;\n    if(n==0)break;\n    rep(i,n){\n      int m;\n      cin>>p[i]>>m;\n      rep(j,m){\n        int a;\n        cin>>a;\n        a--;\n        g[i].pb(a);\n        rg[a].pb(i);\n        es.pb(P(i,a));\n      }\n    }\n    memset(used,0,sizeof(used));\n    rep(i,n){\n      if(!used[i])dfs(i);\n    }\n    memset(used,0,sizeof(used));\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]])rdfs(vs[i],k++);\n    }\n    rep(i,111)np[i]=1.0;\n    rep(i,n){\n      np[cmp[i]]*=p[i];\n    }\n    rep(i,k)np[i]=1-np[i];\n    rep(i,es.size()){\n      int s=cmp[es[i].fi],t=cmp[es[i].se];\n      if(s!=t&&!exist(ng[s],t)){\n        ng[s].pb(t);\n      }\n    }\n    double res=1.0;\n    memset(used,0,sizeof(used));\n    rep(i,k){\n      if(!used[i]){\n        res*=np[i];\n        ddfs(i);\n      }\n    }\n    printf(\"%.10f\\n\", res);\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX_V 1000\nint V,cmp[MAX_V];\nvector<int> G[MAX_V],rG[MAX_V],vs,a,xx;\nint used[MAX_V];\nbool mm[1000];\nvoid addedge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n} \nvoid dfs(int v){\n  used[v]=1;\n  for(int i=0;i<G[v].size();i++)\n    if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\nvoid rdfs(int v,int k){\n  used[v]=1;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n}\nvoid dfs2(int v,int k){\n  mm[v]=1;\n  used[v]=k;\n  for(int i=0;i<G[v].size();i++)\n    if(!mm[G[v][i]])dfs2(G[v][i],k);\n  xx.push_back(v);\n}\nint scc(){\n  int pp=0;\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)\n    if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=1;\n  for(int i=vs.size()-1;i>=0;i--)\n    if(!used[vs[i]]){\n      rdfs(vs[i],k++);\n    }\n  k=1;\n  map<int,int>m;\n  memset(used,0,sizeof(used));\n  r(i,V){\n    if(!used[i]){\n      memset(mm,0,sizeof(mm));\n      dfs2(i,k);\n      r(j,xx.size())if(1){\n        m[xx[j]]=0;\n      }\n      xx.clear();\n      m[i]=cmp[i];\n      k++;\n    }\n  }\n  r(i,V)if(m[i])\n    a.push_back(m[i]);\n  return k;\n}\nint main(){\n  int x,y;\n  while(cin>>V,V){\n    double d[V],ans=0;\n    a.clear();\n    r(i,1000)G[i].clear(),rG[i].clear();\n    r(i,V){\n      cin>>d[i]>>x;\n      r(j,x){\n        cin>>y;\n        addedge(i,y-1);\n      }\n    }\n    scc();cout<<a.size()<<endl;\n    int cnt=0;\n    r(i,a.size()){\n      double p=0;\n      int c=0;\n      r(j,V)if(cmp[j]==a[i]){\n        if(!c++)p+=d[j];\n        else p*=d[j];\n      }\n      if(!cnt++)ans+=(1.0-p);\n      else ans*=(1.0-p);\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define allof(a) (a).begin(),(a).end()\n\nint N;\ndouble p[111];\nvector< vector< int > > adj, r_adj, dag;\nvector< int > rev_order, topol;\nvector< bool > used;\n\nvoid dfs(int v) {\n\tused[v] = true;\n\tfor (int u : adj[v]) if (!used[u]) dfs(u);\n\trev_order.push_back(v);\n}\n\nvoid revDFS(int v, int k) {\n\tused[v] = true;\n\ttopol[v] = k;\n\tfor (int u : r_adj[v]) if (!used[u]) revDFS(u, k);\n}\n\nvoid scc() {\n\trev_order.clear();\n\ttopol.assign(N, -1);\n\tused.assign(N, false);\n\t\n\tfor_(v,0,N) if (!used[v]) dfs(v);\n\t\n\tfill(allof(used), false);\n\tint k = 0;\n\treverse(allof(rev_order));\n\tfor (int v : rev_order) if (!used[v]) revDFS(v, k++);\n\t\n\tdag.assign(k, vector< int >());\n\tfor_(v,0,N) {\n\t\tint top_v = topol[v];\n\t\tfor (int u : adj[v]) if (top_v != topol[u]) dag[top_v].push_back(topol[u]);\n\t}\n\t\n\tfor_(i,0,k) {\n\t\tsort(allof(dag[i]));\n\t\tdag[i].erase(unique(allof(dag[i])), dag[i].end());\n\t}\n}\n\nvoid solve() {\n\tscc();\n\t\n\tint n = dag.size();\n\tvector< int > in_deg(n, 0);\n\tfor_(i,0,n) for (int x : dag[i]) ++in_deg[x];\n\t\n\tdouble ans = 1.0;\n\tfor_(i,0,n) {\n\t\tif (in_deg[i] == 0) {\n\t\t\tdouble rate = 1.0;\n\t\t\tfor_(v,0,N) if (topol[v] == i) rate *= p[v];\n\t\t\tans *= (1.0 - rate);\n\t\t}\n\t}\n\tprintf(\"%.9lf\\n\", ans);\n}\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tadj.assign(N, vector< int >());\n\t\tr_adj.assign(N, vector< int >());\n\t\tfor_(v,0,N) {\n\t\t\tint m; cin >> p[v] >> m;\n\t\t\tfor_(i,0,m) {\n\t\t\t\tint a; cin >> a; --a;\n\t\t\t\tadj[v].push_back(a);\n\t\t\t\tr_adj[a].push_back(v);\n\t\t\t}\n\t\t}\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto x : v){cout << x << \" \";} cout << endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(vv) for(auto v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nclass UnionFind {\nprivate:\n    int n;\n    vector<int> uni;\npublic:\n    UnionFind(int _n) {\n        n = _n;\n        uni.clear();\n        uni.resize(n, -1);\n    }\n    int root(int x) {\n        if (uni[x] < 0) return x;\n        return uni[x] = root(uni[x]);\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (uni[x] > uni[y]) swap(x, y);\n        uni[x] += uni[y];\n        uni[y] = x;\n    }\n    void print() {\n        for (auto x : uni) cout << x << \" \";\n        cout << endl;\n    }\n};\n\nbool reachable(const vvi &G, int s, int g) {\n    int N = G.size();\n    const int INF = 1e9;\n    vi d(N, INF);\n    queue<int> que;\n    que.push(s);\n    d[s] = 0;\n\n    while (!que.empty()) {\n        int pre = que.front(); que.pop();\n        if (pre == g)\n             break;\n\n        for (auto nxt: G[pre]) {\n            if (d[nxt] == INF) {\n                que.push(nxt);\n                d[nxt] = d[pre] + 1;\n            }\n        }\n    }\n\n    return d[g] < INF;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int N;\n    while (cin >> N, N) {\n        vector<double> pr(N);\n        vvi G(N);\n        rep(i, N) {\n            int m;\n            cin >> pr[i] >> m;\n            rep(j, m) {\n                int x;\n                cin >> x;\n                x--;\n                G[i].emplace_back(x);\n            }\n        }\n\n        UnionFind uf(N);\n        rep(j, N) {\n            rep(i, j) {\n                if (reachable(G, i, j) && reachable(G, j, i)) {\n                    uf.unite(i, j);\n                }\n            }\n        }\n\n        map<int, bool> existIn;\n        rep(i, N) existIn[uf.root(i)] = false;\n        rep(from, N) {\n            for (auto to : G[from]) {\n                if (!uf.same(from, to)) existIn[uf.root(to)] = true;\n            }\n        }\n\n        double ans = 1;\n        for (auto p : existIn) {\n            if (!p.second) {\n                double temp = 1;\n                rep(i, N) {\n                    if (uf.root(i) == p.first) {\n                        temp *= pr[i];\n                    }\n                }\n                ans *= 1. - temp;\n            }\n        }\n\n        printf(\"%.10f\\n\", ans);\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\n#define MAX_V 1000\n\nint V;\nvector<int> G[MAX_V]; // グラフの隣接リスト表現\nvector<int> rG[MAX_V];// 辺の向きを逆にしたグラフ\nvector<int> vs;       // 帰りがけ順の並び\nbool used[MAX_V];     // すでに調べたか\nint cmp[MAX_V];       // 属する強連結成分のトポロジカル順序\n\n// from から to への辺を張る関数\nvoid add_edge(int from, int to){\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor(int i = 0; i < rG[v].size(); i++){\n\t\tif(!used[rG[v][i]]){\n\t\t\trdfs(rG[v][i], k);\n\t\t}\n\t}\n}\n\n// 強連結成分分解を行う関数、返り値は強連結成分の個数\nint scc(){\n\tmemset(used, 0, sizeof(used));\n\tvs.clear();\n\tfor(int v = 0; v < V; v++){\n\t\tif(!used[v]){\n\t\t\tdfs(v);\n\t\t}\n\t}\n\tmemset(used, 0, sizeof(used));\n\tint k = 0;\n\tfor(int i = vs.size() - 1; i >= 0; i--){\n\t\tif(!used[vs[i]]){\n\t\t\trdfs(vs[i], k++);\n\t\t}\n\t}\n\treturn k;\n}\n\nint main(){\n\t\n\twhile(true){\n\t\tcin >> V;\n\t\tif(V == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdouble p[200], p_m[200];\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tG[i].clear();\n\t\t\trG[i].clear();\n\t\t\tp_m[i] = 1;\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tint m;\n\t\t\tcin >> p[i] >> m;\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tint num;\n\t\t\t\tcin >> num;\n\t\t\t\tadd_edge(i, num - 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = scc();\n\t\t\n\t\tbool flag[200] = {};\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tp_m[cmp[i]] *= p[i];\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tif(cmp[i] != cmp[G[i][j]]){\n\t\t\t\t\tflag[cmp[G[i][j]]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble ans = 1;\n\t\tfor(int i = 0; i < cnt; i++){\n\t\t\tif(!flag[i]){\n\t\t\t\tans *= (1 - p_m[i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct st {\n\tdouble late;\n\tvector<int> call;\n};\nvector<st> mem;\nmap<int, int> mpii;\nvb called;\nint cnt;\n\ndouble heiro(int first, int idx) {\n\tdouble ret = mem[idx].late;\n\tcalled[idx] = false;\n\tREP(i, mem[idx].call.size()) {\n\t\tif (called[mem[idx].call[i]]) {\n\t\t\tret *= heiro(first, mem[idx].call[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tmem.clear();\n\t\tmem.resize(n);\n\t\tmpii.clear();\n\t\tcalled.resize(n, false);\n\t\tREP(i, n) {\n\t\t\tint m;\n\t\t\tcin >> mem[i].late >> m;\n\t\t\tmem[i].call.resize(m);\n\t\t\tREP(j, m) {\n\t\t\t\tcin >> mem[i].call[j];\n\t\t\t\tmem[i].call[j]--;\n\t\t\t\tcalled[mem[i].call[j]] = true;\n\t\t\t}\n\t\t\tmpii[i] = i;\n\t\t}\n\t\tdouble ans = 1.0;\n\t\tqueue<int> Q;\n\t\tREP(i, n)\n\t\t\tif (called[i] == false) {\n\t\t\t\tans *= (1.0 - mem[i].late);\n\t\t\t\tREP(j, mem[i].call.size())\n\t\t\t\t\tQ.push(mem[i].call[j]);\n\t\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tint q = Q.front();Q.pop();\n\t\t\tcalled[q] = false;\n\t\t\tREP(i, mem[q].call.size())\n\t\t\t\tif (called[mem[q].call[i]])\n\t\t\t\t\tQ.push(mem[q].call[i]);\n\t\t}\n\t\tbool henka;\n\t\tdo {\n\t\t\thenka = false;\n\t\t\tREP(i, n) {\n\t\t\t\tif (!called[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tbool pass = true;\n\t\t\t\tREP(j, mem[i].call.size())\n\t\t\t\t\tif (called[mem[i].call[j]])\n\t\t\t\t\t\tpass = false;\n\t\t\t\tif (pass) {\n\t\t\t\t\tcalled[i] = false;\n\t\t\t\t\thenka = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (henka);\n\t\t\tREP(i, n) {\n\t\t\t\tif (called[i])\n\t\t\t\t\tans *= 1.0 - heiro(i, i);\n\t\t\t}\n\t\t\tprintf(\"%0.9lf\\n\", ans);\n\t\t}\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\n#include<vector>\nstruct SCC{\n\tint n;\n\tvector<int>comp,order;\n\tvector<bool>used;\n\tvector<vector<int> >G,RG;\n\tSCC(int _n=0):n(_n),comp(_n,-1),used(_n,false),G(_n),RG(_n){}\n\tvoid add_edge(int from,int to)\n\t{\n\t\tG[from].push_back(to);\n\t\tRG[to].push_back(from);\n\t}\n\tvoid copy(vector<vector<int> >&H)\n\t{\n\t\tfor(int i=0;i<H.size();i++)\n\t\t{\n\t\t\tfor(int j=0;j<H[i].size();j++)\n\t\t\t{\n\t\t\t\tG[i].push_back(H[i][j]);\n\t\t\t\tRG[H[i][j]].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint operator[](int u){return comp[u];}\n\tvoid dfs(int u)\n\t{\n\t\tused[u]=true;\n\t\tfor(int i=0;i<G[u].size();i++)if(!used[G[u][i]])dfs(G[u][i]);\n\t\torder.push_back(u);\n\t}\n\tvoid rdfs(int u,int cnt)\n\t{\n\t\tcomp[u]=cnt;\n\t\tfor(int i=0;i<RG[u].size();i++)if(comp[RG[u][i]]==-1)rdfs(RG[u][i],cnt);\n\t}\n\tint build()\n\t{\n\t\tfor(int i=0;i<n;i++)if(!used[i])dfs(i);\n\t\tint cnt=0;\n\t\tfor(int i=n-1;i>=0;i--)if(comp[order[i]]==-1)rdfs(order[i],cnt++);\n\t\treturn cnt;\n\t}\n\tint build(vector<vector<int> >&H)\n\t{\n\t\tint ret=build();\n\t\tH.assign(ret,vector<int>());\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<G[i].size();j++)\n\t\t\t{\n\t\t\t\tif(comp[i]!=comp[G[i][j]])\n\t\t\t\t\tH[comp[i]].push_back(comp[G[i][j]]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\nmain()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tvector<double>p(n),P(n,1);\n\t\tSCC scc(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>p[i];\n\t\t\tint k;cin>>k;\n\t\t\tfor(;k--;)\n\t\t\t{\n\t\t\t\tint a;cin>>a;\n\t\t\t\tscc.add_edge(i,a-1);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> >G;\n\t\tint N=scc.build(G);\n\t\tfor(int i=0;i<n;i++)P[scc[i]]*=p[i];\n\t\tvector<int>H(N,0);\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=0;j<G[i].size();j++)\n\t\t\t{\n\t\t\t\tH[G[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tdouble ans=1;\n\t\tfor(int i=0;i<N;i++)if(H[i]==0)ans*=1-P[i];\n\t\tcout<<fixed<<setprecision(9)<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\ntemplate <class Cost = int>\nstruct StronglyConnectedComponents {\n    Graph<Cost> graph, rgraph;\n    std::vector<bool> visited;\n    std::vector<int> stk;\n\n    // id[v] = 頂点vはgroups[id[v]]に属する\n    std::vector<int> id;\n    std::vector<std::vector<int>> groups;\n\n    explicit StronglyConnectedComponents(const Graph<Cost>& g)\n        : graph(g), visited(graph.size(), false), id(graph.size(), -1) {\n        revinit();\n\n        for (int v = 0; v < (int)graph.size(); ++v) dfs(v);\n\n        while (!stk.empty()) {\n            int v = stk.back();\n            stk.pop_back();\n            if (id[v] < 0) {\n                groups.emplace_back();\n                rdfs(v);\n            }\n        }\n    }\n\n    void revinit() {\n        rgraph = Graph<Cost>(graph.size());\n        for (int v = 0; v < (int)graph.size(); ++v) {\n            for (const auto& e : graph[v]) {\n                rgraph[e.dst].emplace_back(e.dst, v, e.cost);\n            }\n        }\n    }\n\n    void dfs(int v) {\n        if (visited[v]) return;\n        visited[v] = true;\n        for (const auto& e : graph[v]) dfs(e.dst);\n        stk.push_back(v);\n    }\n\n    void rdfs(int v) {\n        if (id[v] >= 0) return;\n        id[v] = groups.size() - 1;\n        groups.back().push_back(v);\n        for (const auto& e : rgraph[v]) rdfs(e.dst);\n    }\n};\n\nusing ldouble = long double;\n\nbool solve() {\n    int n;\n    std::cin >> n;\n    if (n == 0) return false;\n\n    std::vector<ldouble> ps(n);\n    Graph<> graph(n);\n    for (int u = 0; u < n; ++u) {\n        int m;\n        std::cin >> ps[u] >> m;\n\n        while (m--) {\n            int v;\n            std::cin >> v;\n            --v;\n            graph[u].emplace_back(u, v);\n        }\n    }\n\n    StronglyConnectedComponents<> scc(graph);\n    int nn = scc.groups.size();\n\n    std::vector<int> deg(nn, 0);\n    std::vector<ldouble> pro(nn, 1);  // 全員寝坊する確率\n\n    for (int u = 0; u < n; ++u) {\n        pro[scc.id[u]] *= ps[u];\n        for (auto e : graph[u]) {\n            if (scc.id[u] == scc.id[e.dst]) continue;\n            ++deg[scc.id[e.dst]];\n        }\n    }\n\n    ldouble ans = 1;\n    for (int v = 0; v < nn; ++v) {\n        if (deg[v] > 0) continue;\n        ans *= 1 - pro[v];\n    }\n    std::cout << std::fixed << std::setprecision(10)\n              << ans << std::endl;\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"tune=native\")\n#pragma GCC target(\"avx\")\n// #pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing namespace std;\n\n\nusing i64 = __int128;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = i64(1e18)+MOD;\n\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\nvector<int> scc(vector<vector<int>>& edges){\n    int n = edges.size();\n    vector<vector<int>> rev(n);\n\n    for(int i = 0; i < n; ++i)\n        for(auto& x : edges[i])\n            rev[x].emplace_back(i);\n\n    vector<i64> dfs_num(n, -1);\n    vector<i64> flag(n, 0);\n    int num = 0;\n    function<void(int)> dfs = [&](int pos){\n        flag[pos] = 1;\n        for(auto& xx : edges[pos])\n            if(!flag[xx]){\n                dfs(xx);\n        }\n        dfs_num[pos] = num++;\n    };\n\n    for(int i = 0; i < n; ++i)\n        if(!flag[i])\n            dfs(i);\n\n    vector<int> dfs_inv(n);\n    for(int i = 0; i < n; ++i)\n        dfs_inv[n - 1 - dfs_num[i]] = i;\n\n    num = 0;\n\n    vector<int> scc_vec(n, -1);\n\n    function<void(int)> rdfs = [&](int pos){\n        scc_vec[pos] = num;\n        for(auto t : rev[pos])\n            if(scc_vec[t] == -1)\n                rdfs(t);\n    };\n\n    for(int i = 0; i < n; ++i)\n        if(scc_vec[dfs_inv[i]] == -1){\n            rdfs(dfs_inv[i]);\n            ++num;\n        }\n\n    return scc_vec;\n}\n\n\nbool solve(){\n\n    int n;\n    input(n);\n    if(!n)\n        return false;\n    vector<double> p(n);\n    vector<vector<int>> v(n);\n    for(int i = 0; i < n; ++i){\n        int m;\n        input(p[i], m);\n        for(int j = 0; j < m; ++j){\n            int to;\n            input(to);\n            v[i].emplace_back(--to);\n        }\n    }\n    auto sc = scc(v);\n    int k = *max_element(sc.begin(), sc.end()) + 1;\n    bitset<100> bs;\n    for(int i = 0; i < n; ++i)\n        for(auto& x : v[i])\n            if(sc[i] != sc[x])\n                bs.set(sc[x]);\n    double ans = 1.0;\n    for(int i = 0; i < k; ++i){\n        if(bs[i])\n            continue;\n        double per = 0.0;\n        for(int j = 0; j < n; ++j)\n            if(sc[j] == i)\n                per += (1.0 - per) * (1.0 - p[j]);\n        ans *= per;\n    }\n    cout << ans << endl;\n\n    return true;\n}\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    while(solve());\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nstruct Dscc {\npublic:\n\n\t//fst:belongs , scd:newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\n\n\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<vector<int>>edges(N);\n\t\tvector<ld>sleeps;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld p;int  m; cin >> p >> m;\n\t\t\tsleeps.push_back(p);\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tint a; cin >> a; a--;\n\t\t\t\tedges[a].push_back(i);\n\t\t\t}\n\t\t}\n\t\tauto p = dscc.get(edges);\n\t\tauto nextedges(p.second);\n\t\tauto nextbelongs(p.first);\n\t\tvector<ld>nextsleeps(nextbelongs.size());\n\t\tfor (int i = 0; i < nextsleeps.size(); ++i) {\n\t\t\tld per = 1;\n\t\t\tfor (int j = 0; j < nextbelongs[i].size(); ++j) {\n\t\t\t\tper *= sleeps[nextbelongs[i][j]];\n\t\t\t}\n\t\t\tnextsleeps[i] = 1-per;\n\t\t}\n\t\tld ans = 1;\n\t\tfor (int i = 0; i < nextedges.size(); ++i) {\n\t\t\tif (nextedges[i].size() == 0)ans *= nextsleeps[i];\n\t\t}\n\t\tcout <<fixed<<setprecision(10)<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint n, m, a;\ndouble prob;\n\n// Strongly Connected Component\nclass SCC {\nprivate:\n    int n, cmpNum;\n    double p[110] = {0.0};\n    vector<vector<int> > g, rg, roots, set;\n    vector<int> cmp;\n    vector<bool> used;\n    stack<int> st;\n\npublic:\n    SCC(int V) : n(V), g(V), rg(V), cmp(V), used(V, false) {}\n\n    void addEdge(int from, int to) {\n        g[from].push_back(to);\n        rg[to].push_back(from);\n    }\n\n    void setProb(int id, double x) {\n        p[id] = x;\n    }\n\n    void dfs(int v) {\n        used[v] = true;\n        int size_ = g[v].size();\n\n        for (int i = 0; i < size_; ++i) {\n            if (!used[g[v][i]]) dfs(g[v][i]);\n        }\n\n        st.push(v);\n    }\n\n    void rdfs(int v, int k) {\n        used[v] = true;\n        cmp[v] = k;\n        int size_ = rg[v].size();\n\n        for (int i = 0; i < size_; ++i) {\n            if (!used[rg[v][i]]) rdfs(rg[v][i], k);\n        }\n\n        st.push(v);\n    }\n\n    int scc() {\n        for (int i = 0; i < n; ++i) if (!used[i]) dfs(i);\n\n        used.assign(n, false);\n\n        int k = 0;\n\n        while (!st.empty()) {\n            if (!used[st.top()]) rdfs(st.top(), k++);\n            st.pop();\n        }\n\n        cmpNum = k;\n        roots.resize(k);\n        set.resize(k);\n        return k;\n    }\n\n    bool same(int x, int y) {\n        return (cmp[x] == cmp[y]);\n    }\n\n    void splitSet() {\n        for (int i = 0; i < n; ++i) {\n            //cout << i << \"'s cmp is \" << cmp[i] << endl;\n            set[cmp[i]].push_back(i);\n        }\n    }\n\n    double solve() {\n        double ret = 1.0, tmp;\n        int size_;\n\n        splitSet();\n\n        for (int i = 0; i < n; ++i) {\n            used.assign(n, false);\n            if (!used[i]) rrdfs(i);\n        }\n\n        for (int i = 0; i < cmpNum; ++i) {\n            //cout << \"roots's size \" << roots[i].size() << endl;\n            if (roots[i].size() == 0) {\n                //cout << i << \"'s setsize is \" << set[i].size() << endl;\n                size_ = set[i].size();\n                tmp = 1.0;\n\n                for (int j = 0; j < size_; ++j) {\n                    //cout << \"vertex id is \" << set[cmp[i]][j] << endl;\n                    tmp *= p[set[i][j]];\n                    //cout << \"set[\" << i << \"][\" << j << \"] is \" << set[cmp[i]][j] << \" & p is \" << p[set[i][j]] << endl;\n                }\n                //cout << \"tmp is \" << tmp << endl;\n                ret *= (1.0 - tmp);\n            }\n        }\n\n        return ret;\n    }\n\n    void rrdfs(int v) {\n        //cout << \"now vertex is \" << v << endl;\n        used[v] = true;\n        int size_ = rg[v].size();\n        //cout << \"now vertex's size is \" << size_ << endl;\n\n        for (int i = 0; i < size_; ++i) {\n            //cout << \"used \" << used[rg[v][i]] << endl;\n            if (!used[rg[v][i]]) {\n                if (cmp[v] != cmp[rg[v][i]]) {\n                    roots[cmp[v]].push_back(cmp[rg[v][i]]);\n                    //cout << cmp[v] << \"'s root is \" << cmp[rg[v][i]] << endl;\n                }\n                //cout << v << \" to \" << rg[v][i] << endl;\n                rrdfs(rg[v][i]);\n            }\n        }\n    }\n\n    void print(int v) {\n        cout << cmp[v] << endl;\n    }\n};\n\nint main() {\n\n    while (scanf(\"%d\", &n), n) {\n        SCC s(n);\n\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%lf %d\", &prob, &m);\n            s.setProb(i, prob);\n            for (int j = 0; j < m; ++j) {\n                scanf(\"%d\", &a);\n                s.addEdge(i, a-1);\n            }\n        }\n\n        s.scc();\n\n        printf(\"%.10f\\n\", s.solve());\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nvector<double> p;\nvector< vector<int> > G, rG;\nvector<int> cmp;\n\nvoid dfs(int v, vector<bool>& used, vector<int>& order)\n{\n  if(used[v]) return;\n  used[v] = true;\n  for(int u : G[v]) dfs(u, used, order);\n  order.push_back(v);\n}\n\nvoid rdfs(int v, const int& cnt)\n{\n  cmp[v] = cnt;\n  for(int u : rG[v]) {\n    if(cmp[u] == -1) rdfs(u, cnt);\n  }\n}\n\nint scc()\n{\n  cmp.clear(); cmp.resize(N, -1);\n  vector<bool> used(N, false);\n  vector<int> order;\n  for(int v = 0; v < N; v++) dfs(v, used, order);\n  reverse(order.begin(), order.end());\n  int cnt = 0;\n  for(int i = 0; i < order.size(); i++) {\n    if(cmp[order[i]] == -1) rdfs(order[i], cnt++);\n  }\n  return cnt;\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    p.clear(); p.resize(N);\n    G.clear(); G.resize(N);\n    rG.clear(); rG.resize(N);\n    for(int i = 0; i < N; i++) {\n      int m; cin >> p[i] >> m;\n      for(int j = 0; j < m; j++) {\n\tint a; cin >> a; a--;\n\tG[i].push_back(a);\n\trG[a].push_back(i);\n      }\n    }\n    \n    int n = scc();\n\n    vector<double> P(n, 1.0);\n    for(int i = 0; i < N; i++) P[cmp[i]] *= p[i];\n\n    vector<bool> ine(n, false);\n    for(int u = 0; u < N; u++) {\n      for(int v : G[u]) ine[cmp[v]] = ine[cmp[v]] | (cmp[v] != cmp[u]);\n    }\n    \n    double ans = 1.0;\n    for(int i = 0; i < n; i++) {\n      if(!ine[i]) ans *= (1.0 - P[i]);\n    }    \n    printf(\"%.10f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nclass Edge\n{\n\tpublic:\n\tint to,cost;\n\tEdge(int t,int c)\n\t{\n\t\tto=t;\n\t\tcost=c;\n\t}\n};\n\nvector<Edge> g[100]; //辺を張る\nvector<Edge> rg[100]; //逆辺を張る\nvector<int> vs; //帰りがけ順の並び\nvector<int> tres;//トポロジカルソートの結果\ndouble p[100];\nbool used[100];\n\n//2つの関数でトポロジカルソート\nvoid visit(int k)\n{\n\tif(!used[k])\n\t{\n\t\tused[k]=true;\n\t\tfor(int j=0;j<g[k].size();j++)\n\t\t\tvisit(g[k][j].to);\n\t\ttres.push_back(k);\n\t}\n}\n\nvoid tsort(int n)\n{\n\tfor(int i=0;i<n;i++)\n\t\tvisit(i);\n\treverse(tres.begin(),tres.end());\n}\n\n//DFSで起きなければならない人から起こせる人を列挙する\nvoid dfs1(int now)\n{\n\tused[now]=true;\n\tfor(int i=0;i<g[now].size();i++)\n\t{\n\t\tEdge e=g[now][i];\n\t\tif(!used[e.to])\n\t\t\tdfs1(g[now][i].to);\n\t}\n\treturn;\n}\n\n//ループをdpで調べる\nvoid dfs2(int now)\n{\n\tused[now]=true;\n\tfor(int i=0;i<g[now].size();i++)\n\t{\n\t\tif(!used[g[now][i].to])\n\t\t\tdfs2(g[now][i].to);\n\t}\n\tvs.push_back(now);\n}\n\nvoid rdfs2(int now,int k)\n{\n\tused[now]=true;\n\ttres[now]=k;\n\tfor(int i=0;i<rg[now].size();i++)\n\t{\n\t\tif(!used[rg[now][i].to])\n\t\t\trdfs2(rg[now][i].to,k);\n\t}\n}\n\n//短縮後の要素数を返す\nint scc(int n)\n{\n\tfill(used,used+100,false);\n\tvs.clear();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(!used[i])\n\t\t\tdfs2(i);\n\t}\n\tfill(used,used+100,false);\n\tint k=0;\n\tfor(int i=vs.size()-1;i>-1;i--)\n\t{\n\t\tif(!used[vs[i]])\n\t\t\trdfs2(vs[i],k++);\n\t}\n\treturn k;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n;\n\t\tdouble ans=1.0;\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<100;i++)\n\t\t{\n\t\t\trg[i].clear();\n\t\t\tg[i].clear();\n\t\t}\n\t\ttres.clear();\n\t\tfill(used,used+100,false);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>p[i];\n\t\t\tint m;\n\t\t\tcin>>m;\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\ta--;\n\t\t\t\tg[i].push_back(Edge(a,1));\n\t\t\t\trg[a].push_back(Edge(i,1));\n\t\t\t}\n\t\t}\n\t\ttsort(n);\n\t\t/*\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcerr<<tres[i]<<\" \";\n\t\tcerr<<endl;*/\n\t\tscc(n);//トポロジカルソートして強連結成分分解\n\t\t/* \n\t\tfor(int i=0;i<n;i++)\n\t\t\tcerr<<tres[i]<<\" \";\n\t\tcerr<<endl;*/\n\t\tfill(used,used+100,false);\n\t\t//トポロジカルソート昇順で調べる\n\t\t//これにはO(N^2)かける\n\t\tfor(int cnt=0;cnt<n;cnt++)\n\t\t{\n\t\t\tvector<int> tmp;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(tres[j]==cnt && !used[j])\n\t\t\t\t\ttmp.push_back(j);\n\t\t\t}\n\t\t\tif(tmp.size()==0)\n\t\t\t\tcontinue;\n\t\t\t//tmpに同じ強連結成分が入っている\n\t\t\tdouble kari=1.0;\n\t\t\tfor(int j=0;j<tmp.size();j++)\n\t\t\t\tkari*=p[tmp[j]];\n\t\t\tans*=(1.0-kari);\n\t\t\tdfs1(tmp[0]);\n\t\t}\n\t\tcout<<fixed<<setprecision(12)<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\n\n#define _CRT_SECURE_NO_WARNINGS\n\nint N = 0;\ndouble p[110] = {};\nint m[110] = {};\nvector<int> know[110];\nvector<int> beKnown[110];\nbool waked[110] = {};\n\ndouble ans = 1;\nvoid SetWake(int n) {\n\tfor (int i = 0; i < know[n].size();i++) {\n\t\tif (!waked[know[n][i]] ) {\n\t\t\twaked[know[n][i]] = true;\n\t\t\tSetWake(i);\n\t\t}\n\t}\n}\n\ndouble semiAns=1;\nvoid CheckSameGroup(int n) {\n\tfor (int i = 0; i < beKnown[n].size(); i++) {\n\t\tif (!waked[beKnown[n][i]]) {\n\t\t\tsemiAns *= p[beKnown[n][i]];\n\t\t\twaked[beKnown[n][i]] = true;\n\t\t\tCheckSameGroup(beKnown[n][i]);\n\t\t}\n\t}\n}\n\nint main() {\n\n\twhile (scanf(\"%d\", &N), N != 0) {\n\t\tans = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tknow[i].clear();\n\t\t\tbeKnown[i].clear();\n\t\t\twaked[i] = false;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tscanf(\"%lf\", p + i);\n\t\t\tscanf(\"%d\", m + i);\n\t\t\tfor (int j = 0; j < m[i]; j++) {\n\t\t\t\tint c;\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tknow[i].push_back(c);\n\t\t\t\tbeKnown[c].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (beKnown[i].size()==0) {\n\t\t\t\twaked[i] = true;\n\t\t\t\tSetWake(i);\n\t\t\t\tans *= (1 - p[i]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (!waked[i]) {\n\t\t\t\twaked[i] = true;\n\t\t\t\tsemiAns = p[i];\n\t\t\t\tCheckSameGroup(i);\n\t\t\t\tans *= (1 - semiAns);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\n\nstruct edge {\n    int from, to;\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nvoid add_edge(graph& g, int from, int to) {\n    g[from].push_back((edge){from, to});\n}\n\nint scc(graph& G, std::vector<int>& cmp) {\n    int V = G.size();\n    std::vector<vector<int>> g(V), rg(V);\n    std::vector<bool> used(V, false);\n    std::vector<int> vs;\n    cmp.resize(V);\n    for(int i=0; i<V; ++i) {\n        for(auto e : G[i]) {\n            g[i].push_back(e.to);\n            rg[e.to].push_back(i);\n        }\n    }\n    std::function<void(int)> dfs = [&g, &vs, &used, &dfs](int v) {\n        used[v] = true;\n        for(auto i : g[v]) {\n            if(!used[i]) {\n                dfs(i);\n            }\n        }\n        vs.push_back(v);\n    };\n    std::function<void(int, int)> rdfs = [&rg, &cmp, &used, &rdfs](int v, int k) {\n        used[v] = true;\n        cmp[v] = k;\n        for(int i : rg[v]) {\n            if(!used[i]) {\n                rdfs(i, k);\n            }\n        }\n    };\n    for(int v=0; v<V; ++v) {\n        if(!used[v]) {\n            dfs(v);\n        }\n    }\n    std::fill(used.begin(), used.end(), false);\n    int k = 0;\n    for(int i=vs.size()-1; i>=0; --i) {\n        if(!used[vs[i]]) {\n            rdfs(vs[i], k++);\n        }\n    }\n    return k;\n}\n\nvector<vector<int>> build_graph(graph const& g, vector<int> const& cmp, int K) {\n    int V = g.size();\n    std::vector<std::set<int>> s(K);\n    std::vector<std::vector<int>> res(K);\n    for(int i=0; i<V; ++i) {\n        for(auto e : g[i]) {\n            s[cmp[i]].insert(cmp[e.to]);\n        }\n    }\n    for(int i=0; i<K; ++i) {\n        for(auto j : s[i]) {\n            if(i != j) {\n                res[i].push_back(j);\n            }\n        }\n    }\n    return res;\n}\n\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        graph g(N);\n        vector<double> p(N);\n        for(int i=0; i<N; ++i) {\n            int m;\n            cin >> p[i] >> m;\n            for(int j=0; j<m; ++j) {\n                int a;\n                cin >> a;\n                a--;\n                add_edge(g, i, a);\n            }\n        }\n        vector<int> cmp;\n        const int k = scc(g, cmp);\n        auto g2 = build_graph(g, cmp, k);\n        vector<bool> flag(k);\n        double res = 1;\n        for(auto& v : g2) {\n            for(auto to : v) {\n                flag[to] = true;\n            }\n        }\n        for(int i=0; i<k; ++i) {\n            if(!flag[i]) {\n                double t = 1;\n                for(int j=0; j<N; ++j) {\n                    if(cmp[j] == i) {\n                        t *= p[j];\n                    }\n                }\n                res *= (1 - t);\n            }\n        }\n        cout << fixed << setprecision(10) << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nusing UnWightedGraph = vector<vector<int> >;\ntemplate <typename G>\nstruct StronglyConnectedComponents {\n    const G &g;\n    UnWightedGraph gg, rg;\n    vector<int> comp, order, used;\n    StronglyConnectedComponents(G &g)\n        : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n        for (int i = 0; i < g.size(); i++) {\n            for (auto e : g[i]) {\n                gg[i].push_back((int)e);\n                rg[(int)e].push_back(i);\n            }\n        }\n    }\n    int operator[](int k) { return comp[k]; }\n\n    void dfs(int idx) {\n        if (used[idx]) return;\n        used[idx] = true;\n        for (int to : gg[idx]) dfs(to);\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt) {\n        if (comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for (int to : rg[idx]) rdfs(to, cnt);\n    }\n\n    void build(UnWightedGraph &t) {\n        for (int i = 0; i < gg.size(); i++) dfs(i);\n        reverse(order.begin(), order.end());\n        int ptr = 0;\n        for (int i : order) {\n            if (comp[i] == -1) rdfs(i, ptr), ptr++;\n        }\n        t.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            for (auto &to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if (x == y) continue;\n                t[x].push_back(y);\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m;\n    while (cin >> n, n) {\n        vector<double> p(n);\n        UnWightedGraph g(n), buff;\n        for (int i = 0; i < n; i++) {\n            cin >> p[i] >> m;\n            for (int j = 0; j < m; j++) {\n                int a;\n                cin >> a;\n                a--;\n                g[i].push_back(a);\n            }\n        }\n        StronglyConnectedComponents<UnWightedGraph> scc(g);\n        scc.build(buff);\n        int k = buff.size();\n        vector<bool> root(k, true);\n        for (int i = 0; i < n; i++) {\n            for (int j : g[i]) {\n                if (scc[i] != scc[j]) root[scc[j]] = false;\n            }\n        }\n        double ans = 1.0;\n        for (int i = 0; i < k; i++) {\n            if (root[i]) {\n                double q = 1.0;\n                for (int j = 0; j < n; j++) {\n                    if (scc[j] == i) {\n                        q *= p[j];\n                    }\n                }\n                ans *= 1 - q;\n            }\n        }\n        cout << fixed << setprecision(10) << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2748&lang=jp\n\nvoid bfs(int n, vector<vector<int>>& G,vector<int>& used,vector<int>& t) {\n\tused[n] = 1;\n\tfor (auto e : G[n]) {\n\t\tif (used[e] != 0)continue;\n\t\tbfs(e, G, used, t);\n\t}\n\tt.push_back(n);\n}\n\ndouble bfs2(int n, vector<vector<int>>& G, vector<int>& used, vector<int>& t,double Sp, vector<double>&p) {\n\tused[n] = 1;\n\tfor (auto e : G[n]) {\n\t\tif (used[e] != 0)continue;\n\t\tSp *= bfs2(e, G, used, t, Sp, p);\n\t}\n\tt.push_back(n);\n\treturn Sp*p[n];\n}\n\nvector<int> search(int n, vector<vector<int>>& G, vector<vector<int>>& S) {\n\tvector<int> ret;\n\tfor (int i = 0; i < S[n].size(); i++) {\n\t\tfor (int j = 0; j < G[S[n][i]].size(); j++) {\n\t\t\tint next = G[S[n][i]][j];\n\t\t\tfor (int k = 0; k < S.size();k++) {\n\t\t\t\tif (find(S[k].begin(), S[k].end(),next) == S[k].end()) continue;\n\t\t\t\tif (k == n) break;\n\t\t\t\tret.push_back(k);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\tret.erase(unique(ret.begin(), ret.end()), ret.end());\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<double> p(N);\n\t\tvector<vector<int>> G(N),rG(N);\n\t\t/* input */\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tcin >> p[i];\n\t\t\tint m; cin >> m;\n\t\t\tfor (int j = 0; j < m;j++) {\n\t\t\t\tint a; cin >> a; a--;\n\t\t\t\tG[i].push_back(a);\n\t\t\t\trG[a].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\t/* SCC */\n\t\tvector<int> used(N, 0);\n\t\tvector<int> t;\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tif (used[i] != 0) continue;\n\t\t\tbfs(i, G, used, t);\n\t\t}\n\t\tfill(used.begin(), used.end(), 0);\n\t\tvector<vector<int>> S;\n\t\tvector<double> Sp;\n\t\tfor (auto it = t.rbegin(); it != t.rend(); it++) {\n\t\t\tif (used[*it] != 0)continue;\n\t\t\tS.push_back(vector<int>());\n\t\t\tdouble _Sp = bfs2(*it, rG, used, S[S.size() - 1],1,p);\n\t\t\tSp.push_back(_Sp);\n\t\t}\n\n\t\t/* solve */\n\t\tvector<vector<int>> new_rG(S.size());\n\t\tfor (int i = 0; i < S.size();i++) {\n\t\t\tauto v = search(i, G, S);\n\t\t\tfor (auto V : v) new_rG[V].push_back(i);\n\t\t}\n\t\tdouble ans = 1;\n\t\tfor (int i = 0; i < S.size();i++) {\n\t\t\tif (new_rG[i].size() != 0) continue;\n\t\t\tans *= (1 - Sp[i]);\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 101\nusing namespace std;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\ndouble p[MAX_V];\n\nint main(){\n  while(cin>>V,V){\n    for(int i=0;i<V;i++) G[i].clear(),rG[i].clear();\n    \n    for(int i=0,m;i<V;i++){\n      cin>>p[i]>>m;\n      for(int j=0,a;j<m;j++)cin>>a,add_edge(i,a-1);\n    }\n    int n=scc();\n    vector<double> col(n,1);\n    vector<bool> root(n,1);\n\n    for(int i=0;i<V;i++){\n      col[cmp[i]]*=p[i];\n      for(int j=0;j<G[i].size();j++)\n\tif(cmp[G[i][j]]!=cmp[i]) root[cmp[G[i][j]]]=0;\n    }\n    double ans=1;\n    for(int i=0;i<n;i++)if(root[i])ans*=1-col[i];\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX_V 1000\nint V,cmp[MAX_V];\nvector<int> G[MAX_V],rG[MAX_V],vs,a,xx;\nint used[MAX_V];\nbool mm[1000];\nvoid addedge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n} \nvoid dfs(int v){\n  used[v]=1;\n  for(int i=0;i<G[v].size();i++)\n    if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\nvoid rdfs(int v,int k){\n  used[v]=1;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n}\nvoid dfs2(int v,int k){\n  mm[v]=1;\n  used[v]=k;\n  for(int i=0;i<G[v].size();i++)\n    if(!mm[G[v][i]])dfs2(G[v][i],k);\n  xx.push_back(v);\n}\nint scc(){\n  int pp=0;\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)\n    if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=1;\n  for(int i=vs.size()-1;i>=0;i--)\n    if(!used[vs[i]]){\n      rdfs(vs[i],k++);\n    }\n  k=1;\n  map<int,int>m;\n  memset(used,0,sizeof(used));\n  r(i,V){\n    if(!used[i]){\n      memset(mm,0,sizeof(mm));\n      dfs2(i,k);\n      r(j,xx.size())if(1){\n        m[xx[j]]=0;\n      }\n      xx.clear();\n      m[i]=cmp[i];\n      k++;\n    }\n  }\n  r(i,V)if(m[i])\n    a.push_back(m[i]);\n  return k;\n}\nint main(){\n  int x,y;\n  while(cin>>V,V){\n    double d[V],ans=0;\n    a.clear();\n    r(i,1000)G[i].clear(),rG[i].clear();\n    r(i,V){\n      cin>>d[i]>>x;\n      r(j,x){\n        cin>>y;\n        addedge(i,y-1);\n      }\n    }\n    scc();\n    int cnt=0;\n    r(i,a.size()){\n      double p=0;\n      int c=0;\n      r(j,V)if(cmp[j]==a[i]){\n        if(!c++)p+=d[j];\n        else p*=d[j];\n      }\n      if(!cnt++)ans+=(1.0-p);\n      else ans*=(1.0-p);\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nstruct Edge{ int src, dest; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to) {\n  g[from].push_back((Edge){from, to});\n}\n\nint scc(Graph &graph, vector<int> &cmp) {\n  int V = graph.size();\n  vector<vector<int>> g(V), rg(V);\n  vector<int> vs;\n  vector<bool> used(V, false);\n  cmp.resize(V);\n  REP(i,V) {\n    for (Edge e: graph[i]) {\n      g[i].push_back(e.dest);\n      rg[e.dest].push_back(i);\n    }\n  }\n  function<void(int)> dfs = [&g, &vs, &used, &dfs](int v) {\n    used[v] = true;\n    for (int i: g[v]) if (!used[i]) dfs(i);\n    vs.push_back(v);\n  };\n  function<void(int,int)> rdfs = [&rg, &cmp, &used, &rdfs](int v, int k) {\n    used[v] = true; cmp[v] = k;\n    for (int i: rg[v]) if (!used[i]) rdfs(i, k);\n  };\n  REP(v,V) if (!used[v]) dfs(v);\n  used = vector<bool>(V, false);\n  reverse(ALL(vs));\n  int k = 0;\n  for(int i: vs) if (!used[i]) rdfs(i, k++);\n  return k;\n}\n\nvector<vector<int>> buildRevGraph(const Graph &g, const vector<int> &cmp, int K) {\n  int V = g.size();\n  vector<set<int>> s(K);\n  vector<vector<int>> res(K);\n  REP(i,V) for (Edge e: g[i]) s[cmp[i]].insert(cmp[e.dest]);\n  REP(i,K) for (int j: s[i]) if (i != j) res[j].push_back(i);\n  return res;\n}\n\nusing ld = long double;\n\nint main() {\n  while(1) {\n    int n;\n    cin>>n;\n    if(!n) break;\n    Graph g(n);\n    vector<ld> prob(n);\n    REP(i,n) {\n      int m;\n      cin>>prob[i]>>m;\n      REP(j,m) {\n        int a;\n        cin>>a;\n        --a;\n        add_edge(g, i, a);\n      }\n    }\n    vector<int> cmp;\n    int k = scc(g, cmp);\n    auto dag = buildRevGraph(g, cmp, k);\n    vector<ld> vp(k, 1.0); \n    REP(i,n) {\n      vp[cmp[i]] *= prob[i];\n    }\n    ld res = 1.0;\n    REP(i,k) if (dag[i].empty()) res *= 1.0 - vp[i];\n    cout << fixed << setprecision(10) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 102;\n\ndouble p[MAX_N];\nvector<int> G[MAX_N];\nvector<int> rG[MAX_N];\nvector<int> vs; //??°?????????????????????\nbool used[MAX_N]; //?????§????????????????????????\nint cmp[MAX_N];\t//?±????????????£????????????????????????????????????(0????????????)\nvector<int> cmp_rev[MAX_N]; //???????????????????????????????????????\nbool flag[MAX_N];\n\nvoid add_edge(int from,int to)\n{\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\trep(i,G[v].size()){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v,int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n    cmp_rev[k].push_back(v);\n\trep(i,rG[v].size()){\n\t\tif(!used[rG[v][i]]){\n\t\t\trdfs(rG[v][i],k);\n\t\t}\n\t}\n}\n\nint scc(int n)\t//?????£??????????????°?????????\n{\n\tmemset(used,0,sizeof(used));\n\tvs.clear();\n\trep(v,n){\n\t\tif(!used[v]){\n\t\t\tdfs(v);\n\t\t}\n\t}\n\tmemset(used,0,sizeof(used));\n\tint k=0;\n\tfor(int i=vs.size()-1;i>=0;i--){\n\t\tif(!used[vs[i]]){\n\t\t\trdfs(vs[i],k++);\n\t\t}\n\t}\n\treturn k;\n}\n\nint main()\n{\n    while(1){\n        int n,m;\n    \tscanf(\"%d\",&n);\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear();\n            rG[i].clear();\n            cmp_rev[i].clear();\n        }\n        fill(flag,flag+n,false);\n    \trep(i,n){\n    \t\tscanf(\"%lf%d\",&p[i],&m);\n            rep(j,m){\n                int a;\n                scanf(\"%d\",&a);\n                add_edge(i,a-1);\n            }\n    \t}\n        int cnt = scc(n);\n        rep(i,n){\n            rep(j,G[i].size()){\n                if(cmp[i] != cmp[G[i][j]]){\n                    flag[cmp[G[i][j]]] = true;\n                }\n            }\n        }\n        double res = 1.0;\n        rep(i,cnt){\n            if(!flag[i]){\n                double t = 1.0;\n                rep(j,cmp_rev[i].size()){\n                     t *= p[cmp_rev[i][j]];\n                }\n                res *= 1.0 - t;\n            }\n        }\n        printf(\"%.10f\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\n\nvoid dfs(int x, vector<vector<int> > &g, vector<bool> &used, vector<int> &post, int& k){\n  used[x] = true;\n  for(size_t i = 0; i < g[x].size(); i++){\n    if(!used[g[x][i]]){\n      dfs(g[x][i], g, used, post, k);\n    }\n  }\n  post[x] = k;\n  k++;\n  \n  return;\n}\n\ndouble rdfs(int x, vector<vector<int> > &rg, vector<int> &id, vector<double>& p, int k, vector<set<int> >& newG){\n  id[x] = k;\n  \n  double ans = p[x];\n  for(size_t i = 0; i < rg[x].size(); i++){\n    if(id[rg[x][i]] < 0){\n      ans *= rdfs(rg[x][i], rg, id, p, k, newG);\n    }\n    else if(id[rg[x][i]] != k){\n      newG[k].insert(id[rg[x][i]]);\n    }\n  }\n  \n  return ans;\n}\n\n\nint main(void){\n  int n;\n  while(true){\n    cin >> n;\n    if(n == 0){ break; }\n\n    vector<double> p(n);\n    vector<vector<int> > g(n);\n    vector<vector<int> > rg(n);\n    int m, a;\n    for(int i = 0; i < n; i++){\n      cin >> p[i] >> m;\n      for(int j = 0; j < m; j++){\n        cin >> a;\n        --a;\n        g[i].push_back(a);\n        rg[a].push_back(i);\n      }\n    }\n\n    int k = 0;\n    vector<bool> used(n, false);\n    vector<int> post(n);\n    for(int i = 0; i < n; i++){\n      if(!used[i]){\n        dfs(i, g, used, post, k);\n      } \n    }\n    \n    k = 0;\n    vector<int> id(n, -1);\n    used = vector<bool>(n, false);\n    vector<set<int> > newG(n);\n    vector<double> newP(n, 0);\n    for(int i = n - 1; i >= 0; i--){\n      if(id[post[i]] < 0){\n        newP[k] = rdfs(post[i], rg, id, p, k, newG);\n        k++;\n      }\n    }\n\n    double ans = 1.0;\n    for(int i = 0; i < k; i++){\n      if(newG[i].size() == 0){\n        ans *= (1.0 - newP[i]);\n      }\n    }\n    printf(\"%.10f\\n\", ans);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\n\nusing Graph=vector<vector<int>>;\nvector<int> SSC(Graph& g){\n    int n=g.size();\n    Graph rg(n);\n    for(int i=0;i<n;i++) for(auto v:g[i]) rg[v].push_back(i);\n    vector<int> vs;\n    vector<int> used(n,false);\n    function<void(int)> dfs=[&](int v){\n        if(used[v]) return;\n        used[v]=true;\n        for(auto to:g[v]){\n            dfs(to);\n        }\n        vs.push_back(v);\n    };\n    for(int i=0;i<n;i++) dfs(i);\n    reverse(vs.begin(),vs.end());\n    vector<int> cmp(n);\n    int k=0;\n    fill(used.begin(),used.end(),false);\n    function<void(int)> rdfs=[&](int v){\n        if(used[v]) return;\n        used[v]=true;\n        cmp[v]=k;\n        for(auto to:rg[v]) rdfs(to);\n    };\n    for(auto v:vs) if(!used[v]) rdfs(v),k++;\n    return cmp;\n}\nld solve(int n){\n    vector<ld> p(n);\n    Graph g(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i];\n        int m;\n        cin>>m;\n        for(int j=0;j<m;j++){\n            int a;\n            cin>>a;\n            a--;\n            g[i].push_back(a);\n        }\n    }    \n    vector<int> cmp=SSC(g);\n    int k=(*max_element(cmp.begin(),cmp.end()))+1;\n    vector<int> root(k,true);\n    for(int i=0;i<n;i++){\n        for(auto to:g[i]){\n            if(cmp[i]!=cmp[to]) root[cmp[to]]=false;\n        }\n    }\n    ld res=1;\n    for(int i=0;i<k;i++){\n        if(root[i]){\n            ld sc=1;\n            for(int j=0;j<n;j++){\n                if(cmp[j]==i){\n                    sc*=p[j];\n                }\n            }\n            res*=(1-sc);\n        }\n    }\n    return res;\n}\nint main(){\n    int n;\n    cout<<fixed<<setprecision(10);\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, a, n) for(int i=(a);i < (n);i++)\n#define REP(i, n) rep(i,0,n)\n#define all(e) e.begin(),e.end()\n\n\n#ifdef LOCAL\n#define show(x) cerr<<__LINE__\" : \"<<#x<<\" = \"<<(x)<<endl\n#else\n#define show(x) true\n#endif\n\nusing namespace std;\nusing ll = long long;\ntemplate<class T>\nusing V=vector<T>;\n\ntemplate<class T, class U>\nvoid chmin(T &t, const U u) { if (t > u) t = u; }\n\ntemplate<class T, class U>\nvoid chmax(T &t, const U u) { if (t < u) t = u; }\n\nconst int INF = (1 << 30) - 1;\nconst ll INFL = (ll) 5e15;\nconst int MOD = 1e9 + 7;\n\nstruct SCC {\n    int V;\n    vector<vector<int>> G;\n    vector<vector<int>> rG;\n    vector<vector<int>> vG;\n    vector<int> vs;\n    vector<bool> used;\n    vector<int> cmp;\n\n    vector<int> used2;\n\n    SCC(int v) {\n        V = v;\n        G.resize(V);\n        rG.resize(V);\n        used.resize(V);\n        cmp.resize(V);\n\n        used2.resize(V);\n    }\n\n\n    void add_edge(int from, int to) {\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n\n    void dfs(int v) {\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); ++i) {\n            if (!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n\n    void rdfs(int v, int k) {\n        used[v] = true;\n        cmp[v] = k;\n        vG[k].push_back(v);\n        for (int i = 0; i < rG[v].size(); ++i) {\n            if (!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n\n    int scc() {\n        fill(used.begin(), used.end(), false);\n        vs.clear();\n        for (int v = 0; v < V; ++v) {\n            if (!used[v]) dfs(v);\n        }\n        fill(used.begin(), used.end(), false);\n        int k = 0;\n        for (int i = (int) vs.size() - 1; i >= 0; i--) {\n            vG.push_back(vector<int>());\n            if (!used[vs[i]]) rdfs(vs[i], k++);\n        }\n        return k;\n    }\n\n\n};\n\n\nstruct Solve {\n    int N;\n    vector<double> P;\n    vector<vector<int>> d;\n\n    vector<bool> used;\n    vector<bool> used2;\n    vector<vector<int>> G;\n    vector<vector<int>> rG;\n    vector<int> cmp;\n\n    void dfs(int v) {\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); ++i) {\n            if (!used[G[v][i]]) dfs(G[v][i]);\n        }\n    }\n\n    void rdfs(int v) {\n        used[v] = true;\n        for (int i = 0; i < rG[v].size(); ++i) {\n            if (!used[rG[v][i]]) rdfs(rG[v][i]);\n        }\n\n    }\n\n    int rdfs2(int v) {\n        int ret = cmp[v];\n        used2[v] = true;\n        for (int i = 0; i < rG[v].size(); ++i) {\n            if (!used2[rG[v][i]]) chmin(ret, rdfs2(rG[v][i]));\n        }\n\n        return ret;\n    }\n\n    bool solve() {\n\n        cin >> N;\n        if (N == 0) return false;\n        P.resize(N);\n        d.resize(N, vector<int>(N, INF));\n        for (int i = 0; i < N; ++i) {\n            d[i][i] = 0;\n        }\n\n        SCC scc(N);\n\n        for (int i = 0; i < N; ++i) {\n            cin >> P[i];\n            int m;\n            cin >> m;\n            int from = i;\n            for (int j = 0; j < m; ++j) {\n                int to;\n                cin >> to;\n                to--;\n                scc.add_edge(from, to);\n                d[from][to] = 1;\n            }\n        }\n\n\n//        for (int k = 0; k < N; ++k) {\n//            for (int i = 0; i < N; ++i) {\n//                for (int j = 0; j < N; ++j) {\n//                    chmin(d[i][j], d[i][k] + d[k][j]);\n//                }\n//            }\n//        }\n//        for (int i = 0; i < N; ++i) {\n//            for (int j = 0; j < N; ++j) {\n//                if (d[i][j] == INF) cerr << 1;\n//                else cerr << 0;\n//            }\n//            cerr << endl;\n//        }\n\n\n//        used = scc.used;\n//        used2 = scc.used;\n//        G = scc.G;\n//        rG = scc.rG;\n        int k = scc.scc();\n\n        double ans = 1.0;\n        for (int i = 0; i < k; ++i) {\n//            for (int j = 0; j < scc.vG[i]; ++j) {\n//                bool flag = true;\n//                for (auto e : scc.rG[vG[i][j]]) {\n//\n//                }\n//\n//            }\n            double zekki = 1.0;\n            bool flag = true;\n            for (auto v : scc.vG[i]) {\n                zekki *= P[v];\n                for (auto w : scc.rG[v]) {\n                    //scc.v : 普通のトポ順\n                    //scc.cmp[w] : 元の辺のトポ順\n                    if (scc.cmp[w] < scc.cmp[v]) {\n                        flag = false;\n                    }\n                }\n            }\n\n            if (flag) {\n                ans *= (1. - zekki);\n            }\n        }\n        cout << ans << endl;\n//        cmp = scc.cmp;\n//        set<int> sentou;\n//        vector<pair<int, int>> pp;\n//        for (int i = 0; i < N; ++i) {\n//            pp.emplace_back(scc.cmp[i], i);\n//        }\n//        sort(all(pp));\n//        for (int i = 0; i < N; ++i) {\n//            cerr << pp[i].first << \" \" << pp[i].second << endl;\n//            if (i > 0) {\n//                if (pp[i - 1].first != pp[i].first) {\n//                    if (d[pp[i - 1].second][pp[i].second] == INF) {\n//                        sentou.insert(pp[i].first);\n//                    }\n//                }\n//            } else if (i == 0) {\n//                sentou.insert(pp[i].first);\n//            }\n//        }\n//\n//        double ans = 1.0;\n//        for (auto gr : sentou) {\n//            cerr << gr << endl;\n//\n//            // cmp[i] == grとなるようなもの全て集める\n//            double zekki = 1.0;\n//\n//            for (int i = 0; i < N; ++i) {\n//                if (scc.cmp[i] == gr) {\n//                    zekki *= P[i];\n////                    cerr << P[i] << endl;\n//                }\n//            }\n//            ans *= 1.0 - zekki;\n//        }\n\n//        double ans = 1.0;\n//        set<int> usedg;\n//        for (int i = 0; i < N; ++i) {\n//            if (used[i]) continue;\n//            //rdfsしてグループを求める\n//            fill(used2.begin(), used2.end(), false);\n//            int g = rdfs2(i);\n////            cerr << i << \" \" << g << endl;\n//            //dfsして使用済みにする\n//            dfs(i);\n//            rdfs(i);\n//\n//            double zekki = 1.0;\n//            for (int j = 0; j < N; ++j) {\n//                if (usedg.count(g) == 0) {\n//                    if (scc.cmp[j] == g) {\n//                        zekki *= P[j];\n////                        cerr << j << \" \" << P[j] << endl;\n//                    }\n//                }\n//            }\n//            usedg.insert(g);\n//            ans *= 1.0 - zekki;\n//        }\n//        cout << ans << endl;\n\n//        for (int i = 0; i < N; ++i) {\n//            cout << scc.cmp[i] << endl;\n//        }\n\n        return true;\n    }\n\n\n};\n\n\nint main() {\n    cout << setprecision(9) << fixed;\n\n    while (Solve().solve());\n\n//    SCC scc(5);\n//    scc.add_edge(0, 1);\n//    scc.add_edge(1, 0);\n//    scc.add_edge(1, 2);\n//    scc.add_edge(2, 3);\n//    scc.scc();\n//\n//    for (int i = 0; i < 5; ++i) {\n//        cout << scc.cmp[i] << endl;\n//    }\n\n//    int N;\n//    cin >> N;\n//    SCC scc(N);\n//    for (int i = 0; i < N; ++i) {\n//        double uku;\n//        cin >> uku;\n//        int m;\n//        cin >> m;\n//        for (int j = 0; j < m; ++j) {\n//            int tmp;\n//            cin >> tmp;\n//            tmp--;\n//            scc.add_edge(i, tmp);\n//        }\n//    }\n\n//    scc.scc();\n//\n//    for (int i = 0; i < N; ++i) {\n//        cout << scc.cmp[i] << endl;\n//    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2748&lang=jp\n\nvoid bfs(int n, vector<vector<int>>& G,vector<int>& used,vector<int>& t) {\n\tused[n] = 1;\n\tfor (auto e : G[n]) {\n\t\tif (used[e] != 0)continue;\n\t\tbfs(e, G, used, t);\n\t}\n\tt.push_back(n);\n}\n\ndouble bfs2(int n, vector<vector<int>>& G, vector<int>& used, vector<int>& t,double Sp, vector<double>&p) {\n\tused[n] = 1;\n\tfor (auto e : G[n]) {\n\t\tif (used[e] != 0)continue;\n\t\tSp *= bfs2(e, G, used, t, Sp, p);\n\t}\n\tt.push_back(n);\n\treturn Sp*p[n];\n}\n\nvector<int> search(int n, vector<vector<int>>& G, vector<vector<int>>& S) {\n\tvector<int> ret;\n\tfor (int i = 0; i < S[n].size(); i++) {\n\t\tfor (int j = 0; j < G[S[n][i]].size(); j++) {\n\t\t\tint next = G[S[n][i]][j];\n\t\t\tfor (int k = 0; k < S.size();k++) {\n\t\t\t\tif (find(S[k].begin(), S[k].end(),next) == S[k].end()) continue;\n\t\t\t\tif (k == n) break;\n\t\t\t\tret.push_back(k);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\tret.erase(unique(ret.begin(), ret.end()), ret.end());\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<double> p(N);\n\t\tvector<vector<int>> G(N),rG(N);\n\t\t/* input */\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tcin >> p[i];\n\t\t\tint m; cin >> m;\n\t\t\tfor (int j = 0; j < m;j++) {\n\t\t\t\tint a; cin >> a; a--;\n\t\t\t\tG[i].push_back(a);\n\t\t\t\trG[a].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\t/* SCC */\n\t\tvector<int> used(N, 0);\n\t\tvector<int> t;\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tif (used[i] != 0) continue;\n\t\t\tbfs(i, G, used, t);\n\t\t}\n\t\tfill(used.begin(), used.end(), 0);\n\t\tvector<vector<int>> S;\n\t\tvector<double> Sp;\n\t\tfor (auto it = t.rbegin(); it != t.rend(); it++) {\n\t\t\tif (used[*it] != 0)continue;\n\t\t\tS.push_back(vector<int>());\n\t\t\tdouble _Sp = bfs2(*it, rG, used, S[S.size() - 1],1,p);\n\t\t\tSp.push_back(_Sp);\n\t\t}\n\n\t\t/* solve */\n\t\tvector<vector<int>> new_rG(S.size());\n\t\tfor (int i = 0; i < S.size();i++) {\n\t\t\tauto v = search(i, G, S);\n\t\t\tfor (auto V : v) new_rG[V].push_back(i);\n\t\t}\n\t\tdouble ans = 1;\n\t\tfor (int i = 0; i < S.size();i++) {\n\t\t\tif (new_rG[i].size() != 0) continue;\n\t\t\tans *= (1 - Sp[i]);\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define All(A) A.begin(),A.end()\n#define RAll(A) A.rbegin(),A.rend()\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<30;\n\ndouble p[101],P[101];\n\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n    const G &g;\n    G gg, rg;\n    vector< int > comp, order, used;\n\n    StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n        for(int i = 0; i < g.size(); i++) {\n            for(auto e : g[i]) {\n                gg[i].emplace_back((int) e);\n                rg[(int) e].emplace_back(i);\n            }\n        }\n    }\n\n    int operator[](int k) {\n        return (comp[k]);\n    }\n\n    void dfs(int idx) {\n        if(used[idx]) return;\n        used[idx] = true;\n        for(int to : gg[idx]) dfs(to);\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt) {\n        if(comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for(int to : rg[idx]) rdfs(to, cnt);\n    }\n\n    void build(G &t) {\n        for(int i = 0; i < gg.size(); i++) dfs(i);\n        reverse(begin(order), end(order));\n        int ptr = 0;\n        for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n        t.resize(ptr);\n        for(int i=0;i<g.size();i++) P[i]=1;\n        for(int i=0;i<g.size();i++) P[comp[i]]*=p[i];\n        for(int i = 0; i < g.size(); i++) {\n            for(auto &to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if(x == y) continue;\n                t[x].push_back(y);\n            }\n        }\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) break;\n        vector<vector<int>> G(N);\n        for(int i=0;i<N;i++){\n            int m;\n            cin >> p[i] >> m;\n            for(int j=0;j<m;j++){\n                int u;\n                cin >> u;\n                u--;\n                G[i].eb(u);\n            }\n        }\n        StronglyConnectedComponents<vector<vector<int>>> scc(G);\n        vector<vector<int>> h;\n        scc.build(h);\n        vector<int> s(N,0);\n        for(int i=0;i<h.size();i++){\n            for(int j=0;j<h[i].size();j++){\n                s[h[i][j]]++;\n            }\n        }\n        double ans=1.0;\n        for(int i=0;i<h.size();i++){\n            if(!s[i]){\n                ans*=1-P[i];\n            }\n        }\n        cout <<setprecision(10)<<ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nusing Graph = vector<vector<int>>;\n\n// O(|V| + |E|)\nstruct SCC\n{\n    int V, K;\n    Graph G, rG;\n    vector<int> vs;\n    vector<bool> used;\n    vector<int> cmp;\n    SCC(int _V) : V(_V), G(_V), rG(_V), used(_V, false), cmp(_V) {}\n    void add_edge(int from, int to)\n    {\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n    void dfs(int cur)\n    {\n        used[cur] = true;\n        for (const auto &v : G[cur])\n        {\n            if (!used[v])\n                dfs(v);\n        }\n        vs.push_back(cur);\n    }\n    void rdfs(int cur, int k)\n    {\n        used[cur] = true;\n        cmp[cur] = k;\n        for (const auto &v : rG[cur])\n        {\n            if (!used[v])\n                rdfs(v, k);\n        }\n    }\n    vector<int> scc()\n    {\n        for (int i = 0; i < V; i++)\n            used[i] = false;\n        vs.clear();\n        for (int v = 0; v < V; v++)\n        {\n            if (!used[v])\n                dfs(v);\n        }\n        for (int i = 0; i < V; i++)\n            used[i] = false;\n        int k = 0;\n        for (int i = (int)vs.size() - 1; i >= 0; i--)\n        {\n            if (!used[vs[i]])\n                rdfs(vs[i], k++);\n        }\n        K = k;\n        return cmp;\n    }\n    Graph buildGraph()\n    {\n        scc();\n        vector<set<int>> s(K);\n        Graph ret(K);\n        for (int v = 0; v < V; v++)\n        {\n            for (const auto to : G[v])\n            {\n                s[cmp[v]].insert(cmp[to]);\n            }\n        }\n        for (int i = 0; i < K; i++)\n        {\n            for (auto j : s[i])\n            {\n                if (i != j)\n                    ret[i].push_back(j);\n            }\n        }\n        return ret;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N)\n    {\n        SCC scc(N);\n        vector<double> p(N);\n        for (int i = 0; i < N; i++)\n        {\n            cin >> p[i];\n            int m;\n            cin >> m;\n            for (int j = 0; j < m; j++)\n            {\n                int a;\n                cin >> a;\n                a--;\n                scc.add_edge(i, a);\n            }\n        }\n        vector<int> cmp = scc.scc();\n        Graph g = scc.buildGraph();\n        int K = g.size();\n        vector<int> in(K);\n        for (int i = 0; i < K; i++)\n        {\n            for (const auto &next : g[i])\n            {\n                in[next]++;\n            }\n        }\n        vector<vector<int>> v(K);\n        for (int i = 0; i < N; i++)\n        {\n            v[cmp[i]].push_back(i);\n        }\n        double res = 1;\n        for (int i = 0; i < K; i++)\n        {\n            if (in[i])\n                continue;\n            double x = 1;\n            for (auto cur : v[i])\n            {\n                x *= p[cur];\n            }\n            res *= (1.0 - x);\n        }\n        cout << fixed << setprecision(10) << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n// edit\n\nstruct Solve {\n\n    int N;\n    vector<vector<int>> G;\n    vector<vector<int>> rG;\n    vector<double> p;\n    vector<bool> check;\n\n    double dfs(int n) {\n        if (check[n]) {\n            return 1;\n        }\n        check[n] = true;\n\n        double ret = 1.;\n        ret *= p[n];\n        for (auto e : G[n]) {\n            ret *= dfs(e);\n        }\n\n        return ret;\n    }\n\n    bool solve() {\n        cin >> N;\n        if (N == 0) return false;\n        G.resize(N, vector<int>());\n        rG.resize(N, vector<int>());\n        p.resize(N, 0.0);\n        check.resize(N, false);\n\n        REP(i, N) {\n            int n;\n            cin >> p[i];\n            cin >> n;\n            REP(j, n) {\n                int c;\n                cin >> c;\n                c--;\n                G[i].push_back(c);\n                rG[c].push_back(i);\n            }\n        }\n\n        double ans = 1.;\n\n        REP(i, N) {\n            if (SZ(rG[i]) == 0) {\n                ans *= 1. - p[i];\n                dfs(i);\n            }\n        }\n\n        REP(i, N) {\n            if (!check[i]) {\n                double tapu = dfs(i);\n                ans *= 1. - tapu;\n            }\n        }\n\n        cout << ans << endl;\n\n        return true;\n\n    }\n\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    while (Solve().solve());\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n\tint from, to;\n\tEdge(int f, int t) {\n\t\tfrom = f;\n\t\tto = t;\n\t}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvector<int> kosaraju(const Graph& g) {\n\tint n = g.size(), sz = 0;\n\tGraph rg(n);\n\tvector<int>stk, cmp(n, -1), added(n), visited(n), ord(n);\n\tfor (auto &es : g) {\n\t\tfor (auto &e : es)rg[e.to].emplace_back(e.to, e.from);\n\t\tsz += es.size();\n\t}\n\tstk.resize(n + sz);\n\tsz = 0;\n\tfor (int i = 0; i<n; ++i) {\n\t\tif (visited[i])continue;\n\t\tint s = 0;\n\t\tstk[s++] = i;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[s - 1];\n\t\t\tvisited[v] = true;\n\t\t\tbool pushed = false;\n\t\t\tfor (auto &e : g[v]) {\n\t\t\t\tint to = e.to;\n\t\t\t\tif (!visited[to]) {\n\t\t\t\t\tstk[s++] = to;\n\t\t\t\t\tpushed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pushed)continue;\n\t\t\tint t = stk[s - 1];\n\t\t\tif (!added[t]) {\n\t\t\t\tadded[t] = true;\n\t\t\t\tord[n - ++sz] = t;\n\t\t\t}\n\t\t\t--s;\n\t\t}\n\t}\n\tint k = 0;\n\tfor (int &u : ord) {\n\t\tif (cmp[u] != -1)continue;\n\t\tint s = 0;\n\t\tstk[s++] = u;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[--s];\n\t\t\tcmp[v] = k;\n\t\t\tfor (auto &e : rg[v]) {\n\t\t\t\tint t = e.to;\n\t\t\t\tif (cmp[t] == -1)stk[s++] = t;\n\t\t\t}\n\t\t}\n\t\t++k;\n\t}\n\treturn cmp;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(7);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<double> p(N);\n\t\tGraph G(N), rG(N);\n\t\tEdges es;\n\t\tfor (int i = 0, m; i < N; i++) {\n\t\t\tcin >> p[i];\n\t\t\tcin >> m;\n\t\t\tfor (int j = 0, a; j < m; j++) {\n\t\t\t\tcin >> a; a--;\n\t\t\t\tG[i].emplace_back(i, a);\n\t\t\t\trG[a].emplace_back(a, i);\n\t\t\t\tes.emplace_back(i, a);\n\t\t\t}\n\t\t}\n\t\tauto v = kosaraju(G);\n\t\tint V = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tV = max(V, v[i] + 1);\n\t\t}\n\t\tGraph rDAG(V);\n\t\tvector<double> pri(V, 1.0);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tpri[v[i]] *= p[i];\n\t\t}\n\t\tfor (auto e : es) {\n\t\t\tif (v[e.from] != v[e.to]) {\n\t\t\t\trDAG[v[e.to]].emplace_back(v[e.to], v[e.from]);\n\t\t\t}\n\t\t}\n\t\tdouble res = 1.0;\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (rDAG[i].empty()) {\n\t\t\t\tres *= 1.0 - pri[i];\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX_V = 110;\n\nint V, cmp[MAX_V];\nbool used[MAX_V];\nvector<int> G[MAX_V], rG[MAX_V], vs;\n\nvoid add_edge(int from, int to)\n{\n    G[from].emplace_back(to);\n    rG[to].emplace_back(from);\n}\n\nvoid dfs(int v)\n{\n    used[v] = 1;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        if (!used[G[v][i]]) {\n            dfs(G[v][i]);\n        }\n    }\n    vs.emplace_back(v);\n}\n\nvoid rdfs(int v, int k)\n{\n    used[v] = 1;\n    cmp[v] = k;\n    for (int i = 0; i < (int)rG[v].size(); i++) {\n        if (!used[rG[v][i]]) {            \n            rdfs(rG[v][i], k);\n        }\n    }\n}\n\nint scc()\n{\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for (int v = 0; v < V; v++) {\n        if (!used[v]) {\n            dfs(v);\n        }\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for (int i = vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) {\n            rdfs(vs[i], k++);\n        }\n    }\n    return k;\n}\n\nvoid init(int N)\n{\n    V = N;\n    for (int i = 0; i < N; i++) {\n        G[i].clear();\n        rG[i].clear();\n    }\n}\n\ndouble solve(int N, const vector<double>& P)\n{\n    int n = scc();\n    vector<double> p(n, 1);\n    \n    bool leaf[MAX_V] = {};\n    for (int i = 0; i < N; i++) {\n        if (G[i].size() == 0 && rG[i].size() != 0) {\n            leaf[cmp[i]] = 1;\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        p[cmp[i]] *= P[i];\n    }\n    double res = 1;\n    for (int i = 0; i < n; i++) {\n        if (!leaf[cmp[i]]) {\n            res *= (1 - p[cmp[i]]);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N, m;\n    while (cin >> N, N > 0) {\n        init(N);\n        vector<double> P(N);        \n        for (int i = 0; i < N; i++) {\n            cin >> P[i] >> m;\n            for (int j = 0; j < m; j++) {\n                int a;\n                cin >> a; a--;\n                add_edge(i, a);\n            }\n        }       \n        printf(\"%.10f\\n\", solve(N, P));\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Strongly_Connected_Component {\n  int vsize;\n  vector<vector<int>> G, reverseG;\n  vector<int> vs, cmp;\n  vector<bool> used;\n  Strongly_Connected_Component(int newv = 1) {\n    vsize = newv;\n    G.resize(vsize);\n    reverseG.resize(vsize);\n    used.resize(vsize, 0);\n    cmp.resize(vsize);\n  }\n\n  bool add(int from, int to) {\n    G[from].push_back(to);\n    reverseG[to].push_back(from);\n    return 1;\n  }\n  void dfs(int v) {\n    used[v] = true;\n    int gvsize = G[v].size();\n    for(int i = 0; i < gvsize; ++i)\n      if(!used[G[v][i]]) dfs(G[v][i]);\n    vs.push_back(v);\n  }\n  void rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    int rgvsize = reverseG[v].size();\n    for(int i = 0; i < rgvsize; ++i)\n      if(!used[reverseG[v][i]]) rdfs(reverseG[v][i], k);\n  }\n  int solve() {\n    used.assign(vsize, 0);\n    vs.clear();\n    for(int v = 0; v < vsize; ++v)\n      if(!used[v]) dfs(v);\n    used.assign(vsize, 0);\n    int k = 0;\n    for(int i = (int)vs.size() - 1; i >= 0; --i)\n      if(!used[vs[i]]) rdfs(vs[i], k++);\n    return k;\n  }\n  bool issame(int l, int r) { return cmp[l] == cmp[r]; }\n};\n\nlong long n;\nvector<long double> p, afterp;\nvector<vector<bool>> a;\nStrongly_Connected_Component scc;\n\nlong double solve();\n\nint main() {\n  cout << fixed << setprecision(10);\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    p.resize(n);\n    scc = Strongly_Connected_Component(n);\n    a.assign(n, vector<bool>(n, 0));\n    for(int i = 0; i < n; ++i) {\n      int m, to;\n      cin >> p[i] >> m;\n      for(int j = 0; j < m; ++j) {\n        cin >> to;\n        scc.add(i, --to);\n        a[i][to] = 1;\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nlong double solve() {\n  long double res = 1;\n  int apsize = scc.solve();\n  afterp.assign(apsize, 1.0);\n  for(int i = 0; i < n; ++i) afterp[scc.cmp[i]] *= p[i];\n  for(int i = 0; i < apsize; ++i) {\n    bool ch = 1;\n    for(int j = 0; j < n; ++j)\n      if(scc.cmp[j] == i)\n        for(int l = 0; l < n; ++l)\n          if(scc.cmp[l] != i && a[l][j]) ch = 0;\n    if(ch) res *= 1.0 - afterp[i];\n  }\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvoid dfs(int idx, bool *used, vector< int > &order, vector< int > *g)\n{\n  if(used[idx]++) return;\n  for(auto &to : g[idx]) dfs(to, used, order, g);\n  order.push_back(idx);\n};\n\nvoid rdfs(int idx, int k, int *cmp, vector< int > *rg)\n{\n  if(~cmp[idx]) return;\n  cmp[idx] = k;\n  for(auto &to : rg[idx]) rdfs(to, k, cmp, rg);\n};\n\nint main()\n{\n  int N;\n  double p[100];\n  int cmp[100];\n  bool used[100];\n  bool in[100];\n\n  while(scanf(\"%d\", &N), N) {\n    vector< int > g[100], rg[100];\n\n    for(int i = 0; i < N; i++) {\n      int M;\n      scanf(\"%lf %d\", &p[i], &M);\n      while(M--) {\n        int a;\n        scanf(\"%d\", &a);\n        g[i].push_back(--a);\n        rg[a].push_back(i);\n      }\n    }\n\n    vector< int > order;\n    memset(cmp, -1, sizeof(cmp));\n    memset(used, false, sizeof(used));\n    memset(in, 0, sizeof(in));\n    for(int i = 0; i < N; i++) dfs(i, used, order, g);\n    reverse(begin(order), end(order));\n    for(int i : order) rdfs(i, i, cmp, rg);\n\n    for(int i = 0; i < N; i++) {\n      for(int &to : g[i]) in[cmp[to]] += cmp[i] != cmp[to];\n    }\n    double ret = 1.0;\n    for(int i = 0; i < N; i++) {\n      if(cmp[i] == i && !in[cmp[i]]) {\n        double curr = 1.0;\n        for(int j = 0; j < N; j++) {\n          if(cmp[i] == cmp[j]) curr *= p[j];\n        }\n        ret *= 1 - curr;\n      }\n    }\n    cout << fixed << setprecision(10) << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nclass UnionFind {\n  vector<int> a;\npublic:\n  UnionFind(int n) { REP(i, 0, n) a.push_back(i); }\n  int find(int i) { return a[i] == i ? i : (a[i] = find(a[i])); }\n  bool unite(int i, int j) {\n    if(find(i) == find(j)) return false;\n    a[find(i)] = find(j);\n    return true;\n  }\n};\n\nint N, M, A;\ndouble P[100];\nbool r[100];\n\nint main(void) {\n  while(cin >> N, N) {\n    UnionFind uf(N);\n    REP(i, 0, N) r[i] = false;\n    REP(i, 0, N) {\n      cin >> P[i] >> M;\n      REP(j, 0, M) {\n        cin >> A;\n        uf.unite(i, A - 1);\n        r[A - 1] = true;\n      }\n    }\n\n    bool p[100];\n    REP(i, 0, N) p[i] = false;\n    vector<int> q[100];\n    vector<int> s[100];\n    REP(i, 0, N) {\n      p[uf.find(i)] = true;\n      if(!r[i]) q[uf.find(i)].push_back(i);\n      else s[uf.find(i)].push_back(i);\n    }\n\n    double ans = 1;\n    REP(i, 0, N) if(p[i]) {\n      if(q[i].size() == 0) {\n        double d = 1;\n        REP(j, 0, s[i].size()) d *= P[s[i][j]];\n        ans *= (1 - d);\n      } else {\n        REP(j, 0, q[i].size()) ans *= (1 - P[q[i][j]]);\n      }\n    }\n    printf(\"%.8lf\\n\", ans);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\n\n\nvoid dfs(int x, vector<vector<int> > &g, vector<bool> &used, vector<int> &post, int& k){\n  used[x] = true;\n  for(size_t i = 0; i < g[x].size(); i++){\n    if(!used[g[x][i]]){\n      dfs(g[x][i], g, used, post, k);\n    }\n  }\n  post[x] = k;\n  k++;\n  \n  return;\n}\n\ndouble rdfs(int x, vector<vector<int> > &rg, vector<int> &id, vector<double>& p, int k, vector<set<int> >& newG){\n  id[x] = k;\n  \n  double ans = p[x];\n  for(size_t i = 0; i < rg[x].size(); i++){\n    if(id[rg[x][i]] < 0){\n      ans *= rdfs(rg[x][i], rg, id, p, k, newG);\n    }\n    else if(id[rg[x][i]] != k){\n      newG[k].insert(id[rg[x][i]]);\n    }\n  }\n  \n  return ans;\n}\n\n\nint main(void){\n  int n;\n  while(true){\n    cin >> n;\n    if(n == 0){ break; }\n\n    vector<double> p(n);\n    vector<vector<int> > g(n);\n    vector<vector<int> > rg(n);\n    int m, a;\n    for(int i = 0; i < n; i++){\n      cin >> p[i] >> m;\n      for(int j = 0; j < m; j++){\n        cin >> a;\n        --a;\n        g[i].push_back(a);\n        rg[a].push_back(i);\n      }\n    }\n\n    int k = 0;\n    vector<bool> used(n, false);\n    vector<int> post(n);\n    for(int i = 0; i < n; i++){\n      if(!used[i]){\n        dfs(i, g, used, post, k);\n      } \n    }\n    \n    k = 0;\n    vector<int> id(n, -1);\n    used = vector<bool>(n, false);\n    vector<set<int> > newG(n);\n    vector<double> newP(n, 0);\n    for(int i = n - 1; i >= 0; i--){\n      if(id[post[i]] < 0){\n        newP[k] = rdfs(post[i], rg, id, p, k, newG);\n        //printf(\"[%.2f%c]\", newP[k], newG[k].size() == 0 ? '*' : '0');\n        k++;\n      }\n    }\n    //printf(\"\\n\");\n\n    double ans = 1.0;\n    for(int i = 0; i < n; i++){\n      if(newG[i].size() == 0){\n        ans *= (1.0 - newP[i]);\n      }\n    }\n    printf(\"%.10f\\n\", ans);\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nvoid dfs(int now, VI &f, VVI e){\n    f[now] = 1;\n    REP(i,e[now].size()){\n        int next = e[now][i];\n        if (!f[next]) dfs(next, f, e);\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n && n){\n        VVI e(n);\n        VI in(n), f(n);\n        vector<double> p(n);\n        REP(i,n){\n            int m;\n            cin >> p[i] >> m;\n            while (m--){\n                int x;\n                cin >> x;\n                x--;\n                e[i].push_back(x);\n                in[x] = 1;\n            }\n        }\n        double ans = 1.0;\n        REP(i,n){\n            if (!in[i]){\n                ans *= (1.0-p[i]);\n                dfs(i,f,e);\n            }\n        }\n        int r = 0;\n        REP(i,n) r += f[i];\n        double res = 1.0;\n        REP(i,n){\n            if (f[i] || e[i].size() == 0) continue;\n            res *= p[i];\n        }\n        if (r < n) ans *= (1.0-res);\n        printf(\"%.10f\\n\", ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = long double;\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vector<R> p(n);\n        vector<vi> a(n);\n        vector<vi> adj(n, vi(n));\n        rep(i, n){\n            cin >> p[i]; p[i] = 1.0 - p[i];\n            int m; cin >> m;\n            a[i] = vi(m); for(auto& e : a[i]) cin >> e, e--, adj[i][e] = true;\n        }\n\n        vector<vi> cango(n, vi(n));\n        rep(i, n){\n            cango[i][i] = true;\n            for(auto& j : a[i]){\n                cango[i][j] = true;\n            }\n        }\n        rep(k, n) rep(i, n) rep(j, n) cango[i][j] |= (cango[i][k] & cango[k][j]);\n\n        int m = 0;\n        vi group(n, -1);\n        rep(i, n){\n            if(group[i] != -1) continue;\n            group[i] = m++;\n            rep(j, i + 1, n){\n                if(cango[i][j] && cango[j][i]) group[j] = group[i];\n            }\n        }\n\n        vector<set<int>> edge(m);\n        rep(i, n){\n            rep(j, n){\n                if(group[i] == group[j]) continue;\n                if(adj[i][j]){\n                    edge[group[j]].insert(group[i]);\n                }\n            }\n        }\n\n        vector<R> q(m, 1.0);\n        rep(i, n){\n            q[group[i]] *= (1.0 - p[i]);\n        }\n        for(auto& e : q) e = 1.0 - e;\n\n        R res = 1.0;\n        rep(i, m){\n            if(edge[i].size() >= 1) continue;\n            res *= q[i];\n        }\n\n        cout.precision(20);\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 100\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nGROUP group[NUM];\nvector<int> G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM];\nint table[NUM],in_num[NUM];\ndouble sleep[NUM];\n\nint group_index;\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id);\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\n\nint main(){\n\n\tint N,num,to,next_group;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tG[i].clear();\n\t\t\treverse_G[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%lf %d\",&sleep[i],&num);\n\n\t\t\tfor(int k = 0; k < num; k++){\n\t\t\t\tscanf(\"%d\",&to);\n\t\t\t\tto--;\n\t\t\t\tG[i].push_back(to);\n\t\t\t\treverse_G[to].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++)check[i] = false;\n\n\t\tfor(int i = 0; i < N;i++){\n\t\t\tif(!check[i])dfs(i);\n\t\t}\n\n\t\tfor(int i = 0; i < N;i++)check[i] = false;\n\t\tfor(int i = 0; i < NUM; i++)group[i].nodes.clear();\n\n\t\tgroup_index = -1;\n\n\t\twhile(!S.empty()){\n\t\t\tif(!check[S.top()]){\n\t\t\t\tgroup_index++;\n\n\t\t\t\treverse_dfs(S.top());\n\t\t\t}\n\t\t\tS.pop();\n\t\t}\n\n\t\tfor(int i = 0; i <= group_index; i++)in_num[i] = 0;\n\n\t\tfor(int i = 0; i <= group_index; i++){\n\t\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\t\tfor(int p = 0; p < G[group[i].nodes[k]].size(); p++){\n\t\t\t\t\tnext_group = table[G[group[i].nodes[k]][p]];\n\t\t\t\t\tif(next_group != i){\n\t\t\t\t\t\tin_num[next_group]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = 1.0;\n\t\tfor(int i = 0; i <= group_index; i++){\n\t\t\tif(in_num[i] == 0){\n\t\t\t\tdouble all_sleep = 1.0;\n\n\t\t\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\t\t\tall_sleep *= sleep[group[i].nodes[k]];\n\t\t\t\t}\n\t\t\t\tans *= (1.0-all_sleep);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//夏合宿の朝は早い\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define MAX_V 500\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nvector<int> vG[MAX_V];\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid add_edge(int from, int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n    used[v] = true;\n    for(int i = 0; i < (int)G[v].size(); i++){\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n    used[v] = true;\n    cmp[v] = k;\n    vG[k].push_back(v);\n    for(int i = 0; i < (int)rG[v].size(); i++){\n        if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\n\nint scc(){\n    memset(used, false, sizeof(used));\n    vs.clear();\n    for(int v = 0; v < V; v++){\n        if(!used[v]) dfs(v);\n    }\n    memset(used, false, sizeof(used));\n    int k = 0;\n    for(int i = V - 1; i >= 0; i--){\n        if(!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    return k;\n}\n\nint main(){\n\n    while(cin >> V, V){\n\n        //初期化\n        for(int i = 0; i < MAX_V; i++){\n            G[i].clear();\n            rG[i].clear();\n            vG[i].clear();            \n        }\n\n        //入力受け取り\n        vector<double> p(V);\n        for(int i = 0; i < V; i++){\n            int m;\n            cin >> p[i] >> m;\n            for(int j = 0; j < m; j++){\n                int to; cin >> to; to--;\n                add_edge(i, to);\n            }\n        }\n\n        int k = scc();\n\n        /*cout << k << endl;\n        for(int i = 0; i < k; i++){\n            cout << i << endl;\n            for(int j = 0; j < vG[i].size(); j++){\n                cout << vG[i][j] << \" \";\n            }\n            cout << endl;\n        }*/\n\n        double ans = 1.0;\n        for(int i = 0; i < k; i++){\n            bool flag = true;              //入次数が0であるか\n            double res = 1.0;\n\n            //強連結成分をすべてなめる\n            for(int j = 0; j < (int)vG[i].size(); j++){\n                res *= p[vG[i][j]];\n\n                //その頂点は入り次数0ですか？(逆辺をすべてなめる)\n                for(int l = 0; l < (int)rG[vG[i][j]].size(); l++){\n                    flag &= (cmp[vG[i][j]] == cmp[rG[vG[i][j]][l]]);\n                }\n            }\n\n            if(flag){\n                //cout << ans << endl;\n                //cout << res << endl;\n                //cout << 1.0 - res << endl;\n                //cout << ans * (1.0 - res) << endl;                \n                ans *= (1.0 - res);\n                //cout << ans << endl;\n            }\n        }\n\n        printf(\"%.10lf\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n  int src, dst;\n  Edge(int f, int t) {\n    src = f;\n    dst = t;\n  }\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvector<int> tarjan(const Graph &g) {\n  int n = g.size(), idx = 0, k = 0, s = 0;\n  vector<int> ord(n, -1), low(n), onS(n), cmp(n), stk(n);\n  function<void(int)> dfs;\n  dfs = [&](int v) {\n    ord[v] = low[v] = idx++;\n    stk[s++] = v;\n    onS[v] = true;\n    for (auto &e : g[v]) {\n      int w = e.dst;\n      if (ord[w] == -1) {\n        dfs(w);\n        low[v] = min(low[v], low[w]);\n      } else if (onS[w]) {\n        low[v] = min(low[v], ord[w]);\n      }\n    }\n    if (low[v] == ord[v]) {\n      while (1) {\n        int w = stk[--s];\n        onS[w] = false;\n        cmp[w] = k;\n        if (w == v)\n          break;\n      }\n      ++k;\n    }\n  };\n  for (int v = 0; v < n; ++v)\n    if (ord[v] == -1)\n      dfs(v);\n  return cmp;\n}\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    vector<double> p(n);\n    Graph g(n);\n    for (int i = 0; i < n; ++i) {\n      int m;\n      cin >> p[i] >> m;\n      for (int j = 0; j < m; ++j) {\n        int a;\n        cin >> a;\n        --a;\n        g[i].emplace_back(i, a);\n      }\n    }\n    vector<int> SCC = tarjan(g);\n    set<int> se;\n    for (auto s : SCC) {\n      se.insert(s);\n    }\n    Graph gg(se.size());\n    vector<double> pp(se.size(), 1.0);\n    for (int i = 0; i < n; ++i) {\n      for (auto e : g[i]) {\n        if (SCC[e.src] == SCC[e.dst])\n          continue;\n        gg[SCC[e.src]].emplace_back(SCC[e.src], SCC[e.dst]);\n        pp[SCC[e.dst]] = -1.0;\n      }\n      pp[SCC[i]] *= p[i];\n    }\n    double ans = 1.0;\n    for (auto x : pp) {\n      if (x > 0.0)\n        ans *= 1 - x;\n    }\n    cout << fixed << setprecision(6) << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_V = 100;\nint V;\nvector<int>G[MAX_V];\nvector<int>rG[MAX_V];\nvector<int>vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nvector<int>sG[MAX_V];\nvector<int>SCC[MAX_V];\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid graph_clear(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  for(int i=0;i<MAX_V;i++) rG[i].clear();\n  for(int i=0;i<MAX_V;i++) sG[i].clear();\n  for(int i=0;i<MAX_V;i++) SCC[i].clear();\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for (int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n  }\n}\n\n\nint scc(){\n  memset(used, 0, sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++){\n    if(!used[v]) dfs(v);\n  }\n\n  memset(used, 0, sizeof(used));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]]) rdfs(vs[i], k++);\n  }\n  return k;\n}\n\nvector<double>P;\nvector<int>M;\n\nint main(){\n  while(1){\n    cin >> V;\n    if(V == 0) break;\n    graph_clear();\n    P.clear();\n    M.clear();\n    for(int i=0;i<V;i++){\n      double p; int m; cin >> p >> m;\n      P.push_back(p);\n      M.push_back(m);\n      for(int j=0;j<m;j++){\n\tint a; cin >> a; a--;\n\tadd_edge(i, a);\n      }\n    }\n    int k = scc();\n\n    for(int i=0;i<V;i++){\n      int c = cmp[i];\n      //      cout << c << endl;\n      SCC[c].push_back(i);\n      for(int j=0;j<rG[i].size();j++){\n\t// cout << c << \" \" << cmp[rG[i][j]] << endl;\n\tif(c != cmp[rG[i][j]])\n\t  sG[c].push_back(cmp[rG[i][j]]);\n      }\n    }\n    \n    double res = 1;\n    for(int i=0;i<k;i++){\n      if(sG[i].size()) continue;\n      //      cout << SCC[i].size() << endl;\n      double prob = 1;\n      for(int j=0;j<SCC[i].size();j++){\n\t//\tcout << P[SCC[i][j]] << endl;\n\tprob *= P[SCC[i][j]];\n      }\n      //      cout << prob << endl;\n      res *= 1-prob;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass SCC {\nprivate:\n    std::vector<std::vector<int>> gg, rg;\n    std::vector<std::pair<int, int>> edges;\n    std::vector<int> comp, order, used;\npublic:\n    SCC(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n    void addEdge(int x, int y)\n    {\n        gg[x].push_back(y);\n        rg[y].push_back(x);\n        edges.push_back({x, y});\n    }\n\n    int operator[](int k)\n    {\n        return comp[k];\n    }\n\n    void dfs(int idx)\n    {\n        if (used[idx]) return;\n        used[idx] = true;\n        for (auto& to: gg[idx]) dfs(to);\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt)\n    {\n        if (comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for (auto& to: rg[idx]) rdfs(to, cnt);\n    }\n\n    void build(std::vector<std::vector<int>> &t)\n    {\n        for (int i{}; i < (int)gg.size(); i++)\n            dfs(i);\n        std::reverse(order.begin(), order.end());\n        int ptr{};\n        for (auto& e: order)\n            if (comp[e] == -1)\n                rdfs(e, ptr), ptr++;\n        \n        t.resize(ptr);\n        std::set<std::pair<int, int>> connect;\n        for (auto& e: edges)\n        {\n            int x{comp[e.first]}, y{comp[e.second]};\n            if (x == y) continue;\n            if (connect.count({x, y})) continue;\n            t[x].push_back(y);\n            connect.emplace(x, y);\n        }\n    }\n};\n\nclass Solve {\nprivate:\npublic:\n    bool is_last_;\n    Solve()\n    {\n        int n;\n        std::cin >> n;\n        if (n == 0)\n        {\n            is_last_ = true;\n            return;\n        }\n        std::vector<long double> p(n);\n        SCC sc(n);\n        for (int i{}; i < n; i++)\n        {\n            std::cin >> p[i];\n            int m;\n            scanf(\"%d\", &m);\n            for (int j{}; j < m; j++)\n            {\n                int a;\n                scanf(\"%d\", &a);\n                sc.addEdge(i, a - 1);\n            }\n        }\n        std::vector<std::vector<int>> t;\n        sc.build(t);\n        std::vector<bool> isTop(t.size(), true);\n        for (auto& e: t)\n            for (auto& f: e)\n                isTop[f] = false;\n        std::vector<std::vector<int>> belong(t.size());\n        for (int i{}; i < n; i++)\n            belong[sc[i]].push_back(i);\n        long double ans{1};\n        for (int i{}; i < (int)t.size(); i++)\n        {\n            if (!isTop[i]) continue;\n            long double tmp{1};\n            for (auto& e: belong[i])\n                tmp *= p[e];\n            ans *= 1 - tmp;\n        }\n        printf(\"%.10Lf\\n\", ans);\n    }\n};\n\nint main()\n{\n    while (!Solve().is_last_);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\n\n#define _CRT_SECURE_NO_WARNINGS\n\nint N = 0;\ndouble p[110] = {};\nint m[110] = {};\nvector<int> know[110];\nvector<int> beKnown[110];\nbool waked[110] = {};\n\ndouble ans = 1;\nvoid SetWake(int n) {\n\tfor (int i = 0; i < know[n].size();i++) {\n\t\tif (!waked[know[n][i]] ) {\n\t\t\twaked[know[n][i]] = true;\n\t\t\tSetWake(know[n][i]);\n\t\t}\n\t}\n}\n\ndouble semiAns=1;\nvoid CheckSameGroup(int n) {\n\tfor (int i = 0; i < beKnown[n].size(); i++) {\n\t\tif (!waked[beKnown[n][i]]) {\n\t\t\tsemiAns *= p[beKnown[n][i]];\n\t\t\twaked[beKnown[n][i]] = true;\n\t\t\tCheckSameGroup(beKnown[n][i]);\n\t\t}\n\t}\n}\n\nint main() {\n\n\twhile (scanf(\"%d\", &N), N != 0) {\n\t\tans = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tknow[i].clear();\n\t\t\tbeKnown[i].clear();\n\t\t\twaked[i] = false;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tscanf(\"%lf\", p + i);\n\t\t\tscanf(\"%d\", m + i);\n\t\t\tfor (int j = 0; j < m[i]; j++) {\n\t\t\t\tint c;\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tknow[i].push_back(c);\n\t\t\t\tbeKnown[c].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (beKnown[i].size()==0) {\n\t\t\t\twaked[i] = true;\n\t\t\t\tSetWake(i);\n\t\t\t\tans *= (1 - p[i]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (!waked[i] && know[i].size()!=0) {\n\t\t\t\twaked[i] = true;\n\t\t\t\tsemiAns = p[i];\n\t\t\t\tCheckSameGroup(i);\n\t\t\t\tans *= (1 - semiAns);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//夏合宿の朝は早い\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define MAX_V 500\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nvector<int> vG[MAX_V];\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid add_edge(int from, int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n    used[v] = true;\n    for(int i = 0; i < (int)G[v].size(); i++){\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n    used[v] = true;\n    cmp[v] = k;\n    vG[k].push_back(v);\n    for(int i = 0; i < (int)rG[v].size(); i++){\n        if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\n\nint scc(){\n    memset(used, false, sizeof(used));\n    vs.clear();\n    for(int v = 0; v < V; v++){\n        if(!used[v]) dfs(v);\n    }\n    memset(used, false, sizeof(used));\n    int k = 0;\n    for(int i = V - 1; i >= 0; i--){\n        if(!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    return k;\n}\n\nint main(){\n\n    while(cin >> V, V){\n\n        //初期化\n        for(int i = 0; i < MAX_V; i++){\n            G[i].clear();\n            rG[i].clear();\n            vG[i].clear();            \n        }\n\n        //入力受け取り\n        vector<double> p(V);\n        for(int i = 0; i < V; i++){\n            int m;\n            cin >> p[i] >> m;\n            for(int j = 0; j < m; j++){\n                int to; cin >> to; to--;\n                add_edge(i, to);\n            }\n        }\n\n        int k = scc();\n\n        double ans = 1.0;\n        for(int i = 0; i < k; i++){\n            bool flag = true;              //入次数が0であるか\n            double res = 1.0;\n\n            //強連結成分をすべてなめる\n            for(int j = 0; j < (int)vG[i].size(); j++){\n                res *= p[vG[i][j]];\n\n                //その頂点は入り次数0ですか？(逆辺をすべてなめる)\n                for(int l = 0; l < (int)rG[vG[i][j]].size(); l++){\n                    flag &= (cmp[vG[i][j]] == cmp[rG[vG[i][j]][l]]);\n                }\n\n                if(flag) ans *= (1.0 - res);\n            }\n        }\n\n        printf(\"%.10lf\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct st {\n\tdouble late;\n\tvector<int> call;\n};\nvector<st> mem;\nmap<int, int> mpii;\nvb called;\nint cnt;\n\ndouble heiro(int first, int idx) {\n\tdouble ret = 1.0;\n\tcalled[idx] = false;\n\tbool hei = false;\n\tREP(i, mem[idx].call.size()) {\n\t\tif (mem[idx].call[i] == first)\n\t\t\thei = true;\n\t\tif (called[mem[idx].call[i]]) {\n\t\tdouble a=heiro(first, mem[idx].call[i]);\n\t\tif (abs(a - 1.0) > 1e-9) {\n\t\t\tret *= a;\n\t\t\thei = true;\n\t\t}\n\t\t}\n\t}\n\tif (hei)\n\t\tret *= mem[idx].late;\n\treturn ret;\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tmem.clear();\n\t\tmem.resize(n);\n\t\tmpii.clear();\n\t\tcalled.resize(n, false);\n\t\tREP(i, n) {\n\t\t\tint m;\n\t\t\tcin >> mem[i].late >> m;\n\t\t\tmem[i].call.resize(m);\n\t\t\tREP(j, m) {\n\t\t\t\tcin >> mem[i].call[j];\n\t\t\t\tmem[i].call[j]--;\n\t\t\t\tcalled[mem[i].call[j]] = true;\n\t\t\t}\n\t\t\tmpii[i] = i;\n\t\t}\n\t\tdouble ans = 1.0;\n\t\tqueue<int> Q;\n\t\tREP(i, n)\n\t\t\tif (called[i] == false) {\n\t\t\t\tans *= (1.0 - mem[i].late);\n\t\t\t\tREP(j, mem[i].call.size())\n\t\t\t\t\tQ.push(mem[i].call[j]);\n\t\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tint q = Q.front();Q.pop();\n\t\t\tcalled[q] = false;\n\t\t\tREP(i, mem[q].call.size())\n\t\t\t\tif (called[mem[q].call[i]])\n\t\t\t\t\tQ.push(mem[q].call[i]);\n\t\t}\n\t\tREP(i, n) {\n\t\t\tif(called[i])\n\t\t\t\tans *= 1.0 - heiro(i, i);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define All(A) A.begin(),A.end()\n#define RAll(A) A.rbegin(),A.rend()\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<30;\n\ndouble p[101],P[101];\n\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n    const G &g;\n    G gg, rg;\n    vector< int > comp, order, used;\n\n    StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n        for(int i = 0; i < g.size(); i++) {\n            for(auto e : g[i]) {\n                gg[i].emplace_back((int) e);\n                rg[(int) e].emplace_back(i);\n            }\n        }\n    }\n\n    int operator[](int k) {\n        return (comp[k]);\n    }\n\n    void dfs(int idx) {\n        if(used[idx]) return;\n        used[idx] = true;\n        for(int to : gg[idx]) dfs(to);\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt) {\n        if(comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for(int to : rg[idx]) rdfs(to, cnt);\n    }\n\n    void build(G &t) {\n        for(int i = 0; i < gg.size(); i++) dfs(i);\n        reverse(begin(order), end(order));\n        int ptr = 0;\n        for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n        t.resize(ptr);\n        for(int i=0;i<g.size();i++) P[i]=1;\n        for(int i=0;i<g.size();i++) P[comp[i]]*=p[i];\n        for(int i = 0; i < g.size(); i++) {\n            for(auto &to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if(x == y) continue;\n                t[x].push_back(y);\n            }\n        }\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) break;\n        vector<vector<int>> G(N);\n        for(int i=0;i<N;i++){\n            int m;\n            cin >> p[i] >> m;\n            for(int j=0;j<m;j++){\n                int u;\n                cin >> u;\n                u--;\n                G[i].eb(u);\n            }\n        }\n        StronglyConnectedComponents<vector<vector<int>>> scc(G);\n        vector<vector<int>> h;\n        scc.build(h);\n        vector<int> s(h.size(),0);\n        for(int i=0;i<h.size();i++){\n            for(int j=0;j<h[i].size();j++){\n                s[h[i][j]]++;\n            }\n        }\n        double ans=1.0;\n        for(int i=0;i<h.size();i++){\n            if(!s[i]){\n                ans*=1-P[i];\n            }\n        }\n        cout <<fixed<<setprecision(9)<<ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass SCC{//cmp(0 - kk-1) is scc's return. Same number is group. The number is no relatoin.\n\tpublic:\n\tint n;\n\tvvi G,rG,tG;\n\tvector<bool>used;\n\tvi vs,cmp;\n\tSCC(int size){\n\t\tn=size;\n\t\tG=rG=vvi(n);\n\t\tused=vector<bool>(n);\n\t\tcmp=vi(n);\n\t\tvs=vi(0);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\trG[t].pb(s);\n\t}\n\tvoid rdfs(int v,int k){\n\t\tused[v]=true;\n\t\tcmp[v]=k;\n\t\trep(i,rG[v].size())if(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n\tvoid dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size())if(!used[G[v][i]])dfs(G[v][i]);\n\t\tvs.pb(v);\n\t}\n\tint scc(){\n\t\trep(i,n)used[i]=false;\n\t\trep(v,n)if(!used[v])dfs(v);\n\t\trep(i,n)used[i]=false;\n\t\tint kk=0;\n\t\tfor(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],kk++);\n\t\treturn kk;  \n\t}\n\tvoid make(int size){\n\t\tint N=size;\n\t\ttG=vvi(N);\n\t\trep(i,n)rep(j,G[i].size())if(cmp[i]!=cmp[G[i][j]]){\n//\t\t\ttG[cmp[i]].pb(cmp[G[i][j]]);\n\t\t\ttG[cmp[G[i][j]]].pb(cmp[i]);\n\t\t}\n\t}\n};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvd d(n);\n//\t\tvvi G(n);\n\t\tSCC scc(n);\n\t\trep(i,n){\n\t\t\tcin>>d[i];\n\t\t\tint a;cin>>a;\n\t\t\trep(j,a){\n\t\t\t\tint b;cin>>b;\n\t\t\t\tb--;\n\t\t\t\tscc.add_edge(i,b);\n\t\t\t}\n\t\t}\n\t\tint N=scc.scc();\n\t\tscc.make(N);\n\t\tvvi rG=scc.tG;\n\t\tvi c=scc.cmp;\n\t\tvd nd(N);\n\t\trep(i,N){\n\t\t\tdouble t=1;\n\t\t\trep(j,n)if(c[j]==i)t*=d[j];\n\t\t\tnd[i]=t;\n\t\t}\n\t\tdouble out=1;\n\t\trep(i,N)if(!rG[i].size())\n\t\t\tout*=(1-nd[i]);\n\t\t\n\t\tcout<<shosu(9)<<out<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cstdio>\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile(cin >> n, n != 0) {\n\t\t\n\t\tvector<double> p(n);\n\t\tvector<vector<int>> rE(n);\n\t\tconst int inf = 1 << 20;\n\t\tvector<vector<int>> b(n, vector<int>(n, inf));\n\t\t\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> p[i];\n\t\t\t\n\t\t\tint m;\n\t\t\tcin >> m;\n\t\t\t\n\t\t\tfor(int j = 0; j < m; ++j) {\n\t\t\t\tint to;\n\t\t\t\tcin >> to;\n\t\t\t\tto--;\n\t\t\t\trE[to].push_back(i);\n\t\t\t\tb[i][to] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 0; k < n; ++k) {\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\t\tb[i][j] = min(b[i][j], b[i][k] + b[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> ids(n, -1);\n\t\t\n\t\tint nid = 0;\n\t\t\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(ids[i] != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tids[i] = nid;\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tif(ids[j] != -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(b[i][j] != inf && b[j][i] != inf) {\n\t\t\t\t\tids[j] = ids[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnid++;\n\t\t}\n\n\t\t//for(int i = 0; i < n; ++i) {\n\t\t//\tcout << i << \": \" << ids[i] << endl;\n\t\t//}\n\t\t\n\t\tdouble res = 1.0;\n\t\tfor(int id = 0; id < nid; ++id) {\n\t\t\tbool f = true;\n\t\t\t\n\t\t\tdouble pid = 1.0;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(ids[i] != id) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int from : rE[i]) {\n\t\t\t\t\tif(ids[from] != id) {\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!f) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpid *= p[i];\n\t\t\t}\n\t\t\t\n\t\t\tif(f) {\n\t\t\t\tres *= 1 - pid;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.10f\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 110\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nint V,m,a;\nvector<int> G[MAX];\nvector<int> rG[MAX];\nvector<int> vs;\nbool used[MAX]={};\nint cmp[MAX];\ndouble p[MAX],ip[MAX];;\n\nvoid init(){\n  FOR(i,0,MAX){\n    G[i].clear();\n    rG[i].clear();\n    cmp[i]=-1;\n    p[i]=1.0;\n  }\n  vs.clear();\n}\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n  \nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < G[v].size();i++){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n  \nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0;i < rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n  \nvoid scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v = 0;v < V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size() - 1;i >= 0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  return;\n}\n\nvoid solve(){\n  scc();\n  double res=1.0;\n  FOR(i,0,V)FOR(j,0,V)if(cmp[i]==cmp[j])p[i]*=ip[j];\n  FOR(i,0,V){\n    int index=-1;\n    FOR(j,0,V){\n      if(cmp[j]==i){\n        bool flag=true;\n        FOR(k,0,rG[j].size()){\n          int next=rG[j][k];\n          if(cmp[next]!=cmp[j])flag=false;\n        }\n        if(flag)index=j;\n      }\n    }\n    if(index!=-1)res*=(1.0-p[index]);\n  }\n  pd(res);\n  return;\n}\n\nint main()\n{\n  while(1){\n    cin>>V;\n    if(V==0)break;\n    init();\n    FOR(i,0,V){\n      cin>>ip[i]>>m;\n      FOR(j,0,m){\n        cin>>a;\n        add_edge(i,a-1);\n      }\n    }\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n/* AC check  copy */\n\n#include<bits/stdc++.h>\n#define MAX 200\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.9f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n \nint V,m,a;\nvector<int> G[MAX];\nvector<int> rG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX];\ndouble p[MAX],ip[MAX];\n \nvoid init(){\n  FOR(i,0,MAX){\n    G[i].clear();\n    rG[i].clear();\n    p[i]=1.0;\n    ip[i]=0.0;\n  }\n}\n \nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n   \nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < G[v].size();i++){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n   \nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0;i < rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n   \nvoid scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v = 0;v < V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size() - 1;i >= 0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  return;\n}\n \nvoid solve(){\n  double res=1.0;\n  map<int,vector<int> > mp;\n  FOR(i,0,V)mp[cmp[i]].pb(i);\n  FOR(i,0,V)FOR(j,0,V)if(cmp[i]==cmp[j])p[i]*=ip[j];\n  FOR(i,0,V){\n    vector<int> v=mp[i];\n    if(v.size()==0)continue;\n    bool flag=true;\n    FOR(j,0,v.size()){\n      int now=v[j];\n      FOR(k,0,rG[now].size()){\n        int next=rG[now][k];\n        if(cmp[next]!=i)flag=false;\n      }\n    }\n    if(flag)res*=(1.0-p[v[0]]);\n  }\n  pd(res);\n}\n \nint main()\n{\n  while(1){\n    cin>>V;\n    if(V==0)break;\n    init();\n    FOR(i,0,V){\n      cin>>ip[i]>>m;\n      FOR(j,0,m){\n        cin>>a;\n        add_edge(i,a-1);\n      }\n    }\n    scc();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n\nstruct SCC {\n    int N, p;\n    std::vector<std::vector<int> > g, gr, g2i, t, tr;\n    std::vector<bool> visited;\n    std::vector<int> i2g;\n    std::stack<int> order;\n\n    SCC(){}\n    SCC(int n){init(n);}\n    void init(int n){\n        N = n;\n        g.clear();\n        g.resize(N);\n        gr.clear();\n        gr.resize(N);\n        visited.resize(N);\n        i2g.resize(N);\n    }\n    void add_edge(int u, int v) {\n        g[u].emplace_back(v);\n        gr[v].emplace_back(u);\n    }\n\n    void dfs(int x) {\n        if (visited[x]) return;\n        visited[x] = true;\n        for (int i : g[x]) dfs(i);\n        order.push(x);\n    }\n\n    void rdfs(int x, int k) {\n        if (visited[x]) return;\n        visited[x] = true;\n        i2g[x] = k;\n        for (int i : gr[x]) rdfs(i, k);\n    }\n\n    void build() {\n        std::fill(visited.begin(), visited.end(), false);\n        std::fill(i2g.begin(), i2g.end(), -1);\n        for (int i = 0; i < N; i++) dfs(i);\n        p = 0;\n        std::fill(visited.begin(), visited.end(), false);\n        while (!order.empty()) {\n            int idx = order.top();\n            order.pop();\n            if(!visited[idx]) rdfs(idx, p++);\n        }\n        g2i.clear();\n        g2i.resize(p);\n        for(int i=0;i<N;i++){\n            g2i[i2g[i]].push_back(i);\n        }\n        t.resize(p);\n        tr.resize(p);\n        for(int i=0;i<N;i++){\n            for (auto &to : g[i]) {\n                int x = i2g[i], y = i2g[to];\n                if (x == y) continue;\n                t[x].push_back(y);\n                tr[y].push_back(x);\n            }\n        }\n        for(int i=0;i<p;i++){\n            sort(t[i].begin(), t[i].end());\n            t[i].erase(unique(t[i].begin(), t[i].end()),t[i].end());\n            sort(tr[i].begin(), tr[i].end());\n            tr[i].erase(unique(tr[i].begin(), tr[i].end()),tr[i].end());\n        }\n    }\n    int count() const {return p;}\n    int operator[](int k) const {return i2g[k];}\n};\n\nstruct TwoSAT {\n    int N;\n    SCC scc;\n    std::vector<int> v;\n    TwoSAT() = default;\n    TwoSAT(int n):N(n),scc(n*2){}\n    void init(int n){\n        N = n;\n        scc.init(N*2);\n    }\n    int neg(int a){return (a+N)%(N*2);}\n    void add_edge(int a, int b){\n        scc.add_edge(a, b);\n    }\n    void add_if(int a, int b){\n        // a -> b <=> !b -> !a\n        add_edge(a,b);\n        add_edge(neg(b), neg(a));\n    }\n    void add_iff(int a, int b){\n        // (a <=> b) <=> a -> b and b -> a\n        add_if(a, b);\n        add_if(b, a);\n    }\n    void add_or(int a, int b){\n        // a or b <=> !a -> b and !b -> a\n        add_if(neg(a), b);\n    }\n    void add_nand(int a, int b){\n        // a nand b <=> a -> !b and b -> !a\n        add_if(a, neg(b));\n    }\n    void add_xor(int a, int b){\n        add_nand(a, b);\n        add_or(a, b);\n    }\n    void set_true(int a){\n        // a <=> !a -> a\n        add_edge(neg(a), a);\n    }\n    void set_false(int a){\n        // !a <=> a -> !a\n        add_edge(a, neg(a));\n    }\n    bool build(){\n        scc.build();\n        bool ok = true;\n        for(int i=0;i<N;i++){\n            ok &= scc.i2g[i] != scc.i2g[neg(i)];\n        }\n        if(ok){\n            for(int i=0;i<N;i++){\n                v.push_back(scc[i] > scc[neg(i)]);\n            }\n        }\n        return ok;\n    }\n    int operator[](int k) const {return v[k];};\n};\n\n\nint main() {\n    while (1) {\n        int N;\n        double p[100];\n        std::cin >> N;\n        if (N == 0) break;\n        SCC G(N);\n        for(int i=0; i<N; i++) {\n            std::cin >> p[i];\n            int m;\n            std::cin >> m;\n            for(int j=0; j<m; j++) {\n                int a;\n                std::cin >> a;\n                a--;\n                G.add_edge(i, a);\n            }\n        }\n        G.build();\n        double ans = 1;\n        for (int i=0; i<G.count(); i++) {\n            if (G.tr[i].empty()) {\n                double q = 1;\n                for (int idx : G.g2i[i]) {\n                    q *= p[idx];\n                }\n                ans *= (1 - q);\n            }\n        }\n        printf(\"%.8lf\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define rrep(i,a) for(int i=(int)(a)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define chmax(a,b) (a) = max((a),(b))\n#define pb push_back\n#define sz size()\nusing namespace std;\ntypedef vector<int> vi;\n\nstruct SCC{\n  int V;\n  vector<vi> G,rG;\n  vi order;\n\n  int sccV;\n  vector<vi> sccG, group;\n  vi sccID;\n\n  SCC(const vector<vi> &graph):G(graph){\n    V = G.sz; rG.resize(V,vi());\n    rep(i,V)for(int to : G[i]) rG[to].pb(i);\n\n    vi use(V,0);\n    order.clear();\n    rep(i,V) if(!use[i]) fdfs(i,use);\n    \n    use = vi(V,0); sccID.resize(V);\n    sccV = 0;\n    rrep(i,order.sz) if(!use[order[i]]) rdfs(order[i], sccV++, use);\n\n    group.resize(sccV,vi());\n    rep(i,V) group[sccID[i]].pb(i);\n\n    sccG.resize(sccV,vi());\n    rep(i,V) for(int to : G[i]){\n      if(sccID[i] != sccID[to]) sccG[sccID[i]].pb(sccID[to]);\n    }\n    rep(i,sccV){\n      sort(all(sccG[i]));\n      sccG[i].erase(unique(all(sccG[i])), sccG[i].end());\n    }\n  }\n\n  void fdfs(int v, vi &use){\n    use[v] = 1;\n    for(int to : G[v]) if(!use[to]) fdfs(to,use);\n    order.pb(v);\n  }\n\n  void rdfs(int v, int k, vi &use){\n    use[v] = 1; sccID[v] = k;\n    for(int to : rG[v]) if(!use[to]) rdfs(to, k, use);\n  }\n};\n\nint main(){\n  int n;\n  while(cin >> n){\n    if(n==0)break;\n\n    vector<vi> g(n);\n    vector<double> p(n);\n    rep(i,n){\n      int m, a;\n      cin >> p[i] >> m;\n      rep(j,m){\n\tcin >> a; a--;\n\tg[i].pb(a);\n      }    \n    }\n    \n    SCC scc(g);\n    int nn = scc.sccV;\n    vi deg(nn,0);\n    rep(i,nn){\n      for(int to : scc.sccG[i]){\n\tdeg[to]++;\n      }\n    }\n\n    double ans = 1;\n    rep(i,nn){\n      if(deg[i] == 0){\n\tdouble x = 1;\n\tfor(int v : scc.group[i]){\n\t  x *= p[v];\n\t}\n\tans *= 1-x;\n      }\n    }\n    \n    cout << fixed << setprecision(9) << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int s = 0, const int d = 0, const Weight w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int i) const { return g[i]; }\n  void addArc(const int src, const int dst, const Weight w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int node1, const int node2, const Weight w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nclass SCC {\npublic:\n  std::vector<int> root;\n  Graph g;\n\n  SCC(const Graph &g) : g(g) {\n    int n = g.size();\n    std::vector<int> ord(n);\n    {\n      int k = n - 1;\n      std::vector<int> visited(n), ordered(n);\n      for (int i = 0; i < n; i++) {\n        if (visited[i]) continue;\n        std::stack<int> stk;\n        stk.push(i);\n        while (stk.size()) {\n          int v = stk.top();\n          visited[v] = true;\n          bool pushed = false;\n          for (auto &e : g[v]) {\n            if (!visited[e.dst]) {\n              stk.push(e.dst);\n              pushed = true;\n            }\n          }\n          if (pushed) continue;\n          if (!ordered[v]) {\n            ordered[v] = true;\n            ord[k--] = v;\n          }\n          stk.pop();\n        }\n      }\n    }\n    Graph rg(n);\n    for (auto &es : g) {\n      for (auto &e : es) rg.addArc(e.dst, e.src, e.weight);\n    }\n    root = std::vector<int>(n, -1);\n    int k = 0;\n    for (int u : ord) {\n      if (root[u] >= 0) continue;\n      std::stack<int> stk;\n      stk.push(u);\n      while (stk.size()) {\n        int v = stk.top();\n        stk.pop();\n        root[v] = k;\n        for (auto &e : rg[v]) {\n          if (root[e.dst] == -1) stk.push(e.dst);\n        }\n      }\n      ++k;\n    }\n  }\n\n  Graph makeDAG() {\n    Graph h(g.size());\n    for (auto &es : g) {\n      for (auto &e : es) {\n        if (root[e.src] == root[e.dst]) continue;\n        h.addArc(root[e.src], root[e.dst]);\n      }\n    }\n    return h;\n  }\n};\n\nmain {\n  int n;\n  while (cin >> n, n) {\n    vd p(n);\n    Graph g(n);\n    rep(i, n) {\n      cin >> p[i];\n      int m;\n      cin >> m;\n      rep(j, m) {\n        int a;\n        cin >> a;\n        g.addArc(i, --a);\n      }\n    }\n\n    SCC scc(g);\n    vi in(n);\n    for (auto &es : scc.makeDAG()) {\n      for (auto &e : es) in[e.dst]++;\n    }\n    vd d(n, 1.0);\n    rep(i, n) d[scc.root[i]] *= p[i];\n\n    double ans = 1.0;\n    rep(i, n) if (in[i] == 0 && d[i] != 1.0) ans *= 1.0 - d[i];\n    cout << prec(32) << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 100000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[101];\nvector<int> rG[101];\nvector<int> vs;\nbool used[101];\nint cmp[101];\ndouble pro[101];\nvector<int> uG[101];\nint data[101][101];\n\nvoid add(int f,int t){\n\tG[f].push_back(t);\n\trG[t].push_back(f);\n}\n\nvoid dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n\tused[v]=true;\n\tcmp[v]=k;\n\tfor(int i=0;i<rG[v].size();i++){\n\t\tif(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n}\n\nint scc(){\n\tmemset(used,0,sizeof(used));\n\tvs.clear();\n\tfor(int v=0;v<n;v++){\n\t\tif(!used[v])dfs(v);\n\t}\n\n\tmemset(used,0,sizeof(used));\n\tint k=0;\n\tfor(int i=vs.size()-1;i>=0;i--){\n\t\tif(!used[vs[i]])rdfs(vs[i],k++);\n\t}\n\treturn k;\n}\ndouble raw;\ndouble p[101];\nint m[101],a[101][101];\n\nvoid getdfs(int v){\n\tused[v]=true;\n\tbool flag=false;\n\tfor(int i=0;i<uG[v].size();i++){\n\t\tif(!used[uG[v][i]]){\n\t\t\tflag=true;\n\t\t\tgetdfs(uG[v][i]);\n\t\t}\n\t}\n\tif(uG[v].size()==0){\n\t\traw*=1.0-pro[v];\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t\trG[i].clear();\n\t\t\tuG[i].clear();\n\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%d\",&p[i],&m[i]);\n\t\t\tfor(int j=0;j<m[i];j++){\n\t\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\t\ta[i][j]--;\n\t\t\t\tG[i].push_back(a[i][j]);\n\t\t\t\trG[a[i][j]].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint k=scc();\n\t\tfor(int i=0;i<k;i++){\n\t\t\tpro[i]=1.0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(cmp[j]==i){\n\t\t\t\t\tpro[i]*=p[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(data,0,sizeof(data));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m[i];j++){\n\t\t\t\tif(data[cmp[i]][cmp[a[i][j]]]==0){\n\t\t\t\t\tdata[cmp[i]][cmp[a[i][j]]]=1;\n\t\t\t\t\tif(cmp[i]!=cmp[a[i][j]])uG[cmp[a[i][j]]].push_back(cmp[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(used,false,sizeof(used));\n\t\tdouble ans=1.0;\n\t\tfor(int i=k-1;i>=0;i--){\n\t\t\traw=1.0;\n\t\t\tif(!used[i])getdfs(i);\n\t\t\tans=ans*raw;\n\t\t}\n\t\tprintf(\"%.10f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <vector>\n#include <array>\n#include <tuple>\n#include <utility>\n#include <numeric>\n#include <iomanip>\n#include <cctype>\n#include <cmath>\n#include <assert.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\n\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n    return s << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n    s << \"[\";\n    for (int i = 0; i < v.size(); i++) s << (i == 0 ? \"\" : \", \") << v[i];\n    s << \"]\";\n    return s;\n}\n\n#define ALL(a) (a).begin(), (a).end()\n\nusing Weight = int;\n\n// ??????????????????\nstruct Edge {\n    int from, to;\n    Weight weight;\n\n    Edge() {}\n    Edge(int to) : from(-1), to(to), weight(-1) {}\n    Edge(int from, int to) : from(from), to(to), weight(-1) {}\n    Edge(int from, int to, Weight weight) : from(from), to(to), weight(weight) {}\n\n    bool operator<(const Edge& e) const {\n        return (weight != e.weight) ? (weight < e.weight) : (from < e.from);\n    }\n    bool operator>(const Edge& e) const {\n        return (weight != e.weight) ? (weight > e.weight) : (from > e.from);\n    }\n};\n\nusing Arc = Edge;\nusing Graph = vector<vector<Edge>>;\nusing DGraph = vector<vector<Arc>>;\n\nusing Tree = Graph;\n\n// ?????????????????????????????¨????????????????????????!\nusing GArray = vector<Weight>;\nusing GMatrix = vector<GArray>;\n\n// ??????4????????¢??°???????????°??????????????????????????§?????§?????????\nvoid add_edge(Graph& g, int u, int v, Weight w = -1) {\n    g[u].push_back(Edge(u, v, w));\n    g[v].push_back(Edge(v, u, w));\n}\n\nvoid add_arc(DGraph& dg, int u, int v, Weight w = -1) {\n    dg[u].push_back(Arc(u, v, w));\n}\n\nconst int GM_INF = (1LL << 25);\n\nvoid init_gmatrix(GMatrix& gm) {\n    for (int u = 0; u < gm.size(); u++) {\n        for (int v = 0; v < gm[u].size(); v++) {\n            gm[u][v] = GM_INF;\n        }\n    }\n}\n\nvoid add_edge(GMatrix& gm, int u, int v, Weight w = -1) {\n    gm[u][v] = w;\n    gm[v][u] = w;\n}\n\nvoid add_arc(GMatrix& gm, int u, int v, Weight w = -1) {\n    gm[u][v] = w;\n}\n\n// Kosaraju's algorithm\nnamespace SCC {\n    const int MAX_V = 110;\n\n    DGraph dgraph, rev_dgraph, new_dgraph;\n\n    array<bool, MAX_V> used;\n    array<int, MAX_V> new_id; // ????????????????????????????????£?????????????§£???????????????????????????\n\n    vector<double> attr;\n    vector<double> new_attr;\n\n    vector<int> po_nodes;   // ??°????????????(postorder)??????????????????\n\n    void dfs(int v) {\n        used[v] = true;\n        for (Arc e : dgraph[v]) {\n            if (!used[e.to]) {\n                dfs(e.to);\n            }\n        }\n        po_nodes.push_back(v);\n    }\n\n    void rev_dfs(int v, int id) {\n        used[v] = true;\n        new_id[v] = id;\n        for (Arc e : rev_dgraph[v]) {\n            if (!used[e.to]) {\n                rev_dfs(e.to, id);\n            }\n        }\n    }\n\n    // ?????????kosaraju????????¶?????¨!!\n    DGraph& compose_dgraph(int num) {\n        new_dgraph = DGraph(num);\n        new_attr = vector<double>(num, 1.0);\n\n        map<PII, int> map;\n\n        for (int v = 0; v < dgraph.size(); v++) {\n            int from_id = new_id[v];\n\n            new_attr[from_id] *= attr[v];\n\n            for (Arc e : dgraph[v]) {\n                int to_id = new_id[e.to];\n\n                PII ft = make_pair(from_id, to_id);\n\n                // ???????????????????????¶\n                if (from_id != to_id && map.count(ft) == 0) {\n                    map[ft] = true;\n                    new_dgraph[from_id].push_back(Arc(to_id));\n                }\n            }\n        }\n        return new_dgraph;\n    }\n\n    DGraph& kosaraju(DGraph& dg, vector<double>& p) {\n        used.fill(false);\n        po_nodes.clear();\n\n        dgraph = dg;\n        rev_dgraph = DGraph(dg.size());\n\n        attr = p;\n\n        // ????????????????????°??????????§????\n        for (int v = 0; v < dgraph.size(); v++) {\n            for (Arc e : dgraph[v]) {\n                rev_dgraph[e.to].push_back(Arc(v));\n            }\n        }\n\n        // ??°????????????????????????????????????\n        for (int v = 0; v < dgraph.size(); v++) {\n            if (!used[v]) {\n                dfs(v);\n            }\n        }\n\n        used.fill(false);\n\n        int num = 0;    // ?????£?????????????????°\n        for (int i = po_nodes.size() - 1; i >= 0; i--) {\n            int v = po_nodes[i];\n            if (!used[v]) {\n                rev_dfs(v, num);\n                num++;\n            }\n        }\n\n        return compose_dgraph(num);\n    }\n};\n\nconst int MAX_N = 110;\n\narray<bool, MAX_N> used;\n\nvoid dfs(DGraph& dg, int v) {\n    used[v] = true;\n    for (Arc a : dg[v]) {\n        if (!used[a.to]) {\n            dfs(dg, a.to);\n        }\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        DGraph dg(n);\n        vector<double> p(n);\n\n        for (int i = 0; i < n; i++) {\n            cin >> p[i];\n\n            int m;\n            cin >> m;\n            for (int j = 0; j < m; j++) {\n                int a;\n                cin >> a;\n                a--;\n\n                add_arc(dg, i, a);\n            }\n        }\n\n        used.fill(false);\n\n        auto new_dg = SCC::kosaraju(dg, p);\n        double ans = 1.0;\n        for (int v = 0; v < new_dg.size(); v++) {\n            if (!used[v]) {\n                dfs(new_dg, v);\n                ans *= (1 - SCC::new_attr[v]);\n            }\n        }\n        cout << fixed << setprecision(10) << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define All(A) A.begin(),A.end()\n#define RAll(A) A.rbegin(),A.rend()\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<30;\n\ndouble p[101],P[101];\n\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n    const G &g;\n    G gg, rg;\n    vector< int > comp, order, used;\n\n    StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n        for(int i = 0; i < g.size(); i++) {\n            for(auto e : g[i]) {\n                gg[i].emplace_back((int) e);\n                rg[(int) e].emplace_back(i);\n            }\n        }\n    }\n\n    int operator[](int k) {\n        return (comp[k]);\n    }\n\n    void dfs(int idx) {\n        if(used[idx]) return;\n        used[idx] = true;\n        for(int to : gg[idx]) dfs(to);\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt) {\n        if(comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for(int to : rg[idx]) rdfs(to, cnt);\n    }\n\n    void build(G &t) {\n        for(int i = 0; i < gg.size(); i++) dfs(i);\n        reverse(begin(order), end(order));\n        int ptr = 0;\n        for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n        t.resize(ptr);\n        for(int i=0;i<g.size();i++) P[i]=1;\n        for(int i=0;i<g.size();i++) P[comp[i]]*=p[i];\n        for(int i = 0; i < g.size(); i++) {\n            for(auto &to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if(x == y) continue;\n                t[x].push_back(y);\n            }\n        }\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) break;\n        vector<vector<int>> G(N);\n        for(int i=0;i<N;i++){\n            int m;\n            cin >> p[i] >> m;\n            for(int j=0;j<m;j++){\n                int u;\n                cin >> u;\n                u--;\n                G[i].eb(u);\n            }\n        }\n        StronglyConnectedComponents<vector<vector<int>>> scc(G);\n        vector<vector<int>> h;\n        scc.build(h);\n        vector<int> s(N,0);\n        for(int i=0;i<h.size();i++){\n            for(int j=0;j<h[i].size();j++){\n                s[h[i][j]]++;\n            }\n        }\n        double ans=1;\n        for(int i=0;i<h.size();i++){\n            if(!s[i]){\n                ans*=1-P[i];\n            }\n        }\n        cout <<setprecision(10)<<ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ndouble p[105];\nclass SCC {\npublic:\n  int V,K;    // 頂点数, scc後の頂点数\n  VVI G;      // グラフの隣接リストの表現\n  VVI rG;     // 辺の向きを逆にしたグラフ\n  VVI DAG;    // scc後のグラフの隣接リストの表現\n  VVI rDAG;   // scc後の辺の向きを逆にしたグラフ\n  VI vs;      // 帰りがけ順の並び\n  VI used;    // すでに調べたか\n  VI cmp;     // 属する強連結成分のトポロジカル順\n  VVI member; // scc後の同一ノードの集合\n  vector<double> weight;  // i番目の連結成分が持つ情報\n  // 初期化\n  SCC() { V=K=-1; }\n  SCC(int V_): V(V_) {\n    G.assign(V_, VI());\n    rG.assign(V_, VI());\n    used.assign(V_, false);\n    cmp.assign(V_, false);\n    weight.assign(V_, 1);   // !!!\n  }\n  // 辺を追加\n  void add_edge(int from,int to) {\n    assert(from<V && to<V);\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n  // dfs\n  void dfs(int v) {\n    used[v]=true;\n    for(int nx:G[v]) if(!used[nx]) dfs(nx);\n    vs.push_back(v);\n  }\n  // 逆順dfs\n  void rdfs(int v,int k) {\n    used[v]=true;\n    cmp[v]=k;\n    weight[k] *= p[v];  // !!!\n    for(int nx:rG[v]) if(!used[nx]) rdfs(nx,k);\n  }\n  // 2回dfsをする O(|V|+|E|)\n  int scc() {\n    // dfsする\n    used.assign(V,0);\n    vs.clear();\n    for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n    // 逆順でdfs\n    used.assign(V,0);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n    // i番目の連結成分の頂点、情報\n    member.resize(k); weight.resize(k);\n    for(int i=0;i<V;i++) member[cmp[i]].push_back(i);\n    return K=k;\n  }\n  // O(ElogE)\n  VVI getDAG() {\n    assert(K>=0);\n    VVI res(K);\n    for(int from=0;from<V;from++) {\n      for(int to:G[from]) if(cmp[from]!=cmp[to]) res[cmp[from]].push_back(cmp[to]);\n    }\n    for(int i=0;i<K;i++){\n      sort(res[i].begin(),res[i].end());\n      res[i].erase(unique(res[i].begin(),res[i].end()),res[i].end());\n    }\n    return res;\n  }\n};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    SCC scc(n);\n    REP(i, n) {\n      cin >> p[i];\n      int m; cin >> m;\n      REP(j, m) {\n        int a; cin >> a; a--;\n        scc.add_edge(i, a);\n      }\n    }\n\n    scc.scc();\n    VVI g = scc.getDAG();\n\n    // cout << scc.weight << endl;\n    // cout << g << endl;\n\n    VI d(g.size(), 0);\n    REP(i, g.size()) {\n      for(auto &j: g[i]) {\n        d[j]++;\n      }\n    }\n\n    // cout << d << endl;\n\n    double ans = 1;\n    REP(i, g.size()) {\n      if(d[i] == 0) {\n        ans *= 1-scc.weight[i];\n      }\n    }\n    cout << fixed << setprecision(9) << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 200\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.9f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nint V,m,a;\nvector<int> G[MAX];\nvector<int> rG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX];\ndouble p[MAX],ip[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    G[i].clear();\n    rG[i].clear();\n    p[i]=1.0;\n    ip[i]=0.0;\n  }\n}\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n  \nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < G[v].size();i++){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n  \nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0;i < rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n  \nvoid scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v = 0;v < V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size() - 1;i >= 0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  return;\n}\n\nvoid solve(){\n  double res=1.0;\n  map<int,vector<int> > mp;\n  FOR(i,0,V)mp[cmp[i]].pb(i);\n  FOR(i,0,V)FOR(j,0,V)if(cmp[i]==cmp[j])p[i]*=ip[j];\n  FOR(i,0,V){\n    vector<int> v=mp[i];\n    if(v.size()==0)continue;\n    bool flag=true;\n    FOR(j,0,v.size()){\n      int now=v[j];\n      FOR(k,0,rG[now].size()){\n        int next=rG[now][k];\n        if(cmp[next]!=i)flag=false;\n      }\n    }\n    if(flag)res*=(1.0-p[v[0]]);\n  }\n  pd(res);\n}\n\nint main()\n{\n  while(1){\n    cin>>V;\n    if(V==0)break;\n    init();\n    FOR(i,0,V){\n      cin>>ip[i]>>m;\n      FOR(j,0,m){\n        cin>>a;\n        add_edge(i,a-1);\n      }\n    }\n    scc();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\nusing namespace std;\nconst int INF = 1e9;\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int n) : data(n, -1) {}\n  bool unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x != y){\n      if(data[y] < data[x]) swap(x,y);\n      data[x] += data[y];//高さを更新\n      data[y] = x;//親を更新\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n};\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    vector< vector<int> > G(N, vector<int>(N, INF));\n    for(int i = 0; i < N; ++i) G[i][i] = 0;\n    vector<double> P(N);\n    int m;\n    for(int i = 0; i < N; ++i){\n      cin >> P[i] >> m;\n      int v;\n      for(int j = 0; j < m; ++j){\n        cin >> v;\n        G[i][v-1] = 1;\n      }\n    }\n    for(int k = 0; k < N; ++k){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n        }\n      }\n    }\n    UnionFind uf(N);\n    vector<int> d_in(N, 0);\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < i; ++j){\n        if(G[i][j] < INF && G[j][i] < INF){\n          uf.unite(i, j);\n        }\n      }\n    }\n    for(int i = 0; i < N; ++i){\n      if(i != uf.find(i)) P[uf.find(i)] *= P[i];\n    }\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n        if(G[i][j] == 1 && !uf.same(i, j)) ++d_in[j];\n      }\n    }\n    double ans = 1;\n    for(int i = 0; i < N; ++i){\n      if(uf.find(i) == i && d_in[i] == 0) ans *= 1 - P[i];\n    }\n    printf(\"%.12f\\n\", ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define REP(i, n) for (int i = 0; i < n; i++)\n\nint N;\ndouble p[105];\n\nstruct SCC {\n    vector<vector<int> > g, gr, ls;\n    vector<int> visited, num, d;\n    vector<P> es;\n    stack<int> st;\n\n    SCC(int n) : g(n), gr(n), visited(n, 0), num(n, -1), ls(n) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        gr[v].push_back(u);\n        es.push_back(P(u, v));\n    }\n\n    void dfs(int x) {\n        if (visited[x]) return;\n        visited[x] = 1;\n        for (int i : g[x]) dfs(i);\n        st.push(x);\n    }\n\n    void rdfs(int x, int k) {\n        if (num[x] != -1) return;\n        num[x] = k;\n        ls[k].push_back(x);\n        for (int i : gr[x]) rdfs(i, k);\n    }\n    void build() {\n        for (int i = 0; i < g.size(); i++) dfs(i);\n        int p = 0;\n        while (!st.empty()) {\n            int v = st.top();\n            st.pop();\n            if (num[v] == -1) {\n                rdfs(v, p);\n                p++;\n            }\n        }\n        d.resize(p);\n        for (auto &e : es) {\n            int x = num[e.first], y = num[e.second];\n            if (x == y) continue;\n            d[y]++;\n        }\n    }\n    double solve() {\n        double res = 1;\n        for (int i = 0; i < d.size(); i++) {\n            if (d[i] == 0) {\n                double q = 1;\n                for (int j = 0; j < ls[i].size(); j++) {\n                    q *= p[ls[i][j]];\n                }\n                res *= (1 - q);\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    while (1) {\n        cin >> N;\n        if (N == 0) break;\n        SCC G(N);\n        REP(i, N) {\n            cin >> p[i];\n            int m;\n            cin >> m;\n            REP(j, m) {\n                int a;\n                cin >> a;\n                a--;\n                G.add_edge(i, a);\n            }\n        }\n        G.build();\n        printf(\"%.8lf\\n\", G.solve());\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin,(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n\n#define MAX_V 100\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\n\nvector<double> p;\n\n\nvoid add_edge(int from, int to){\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v, bool used[MAX_V], vector<int> &vs){\n\tused[v] = true;\n\trep(i, G[v].size()){\n\t\tif(!used[G[v][i]]) dfs(G[v][i], used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<int> &sccs, vector<int> &cmp, bool used[MAX_V], vector<double> &elm){\n\tused[v] = true;\n\tsccs.push_back(v);\n\tcmp[v] = k;\n\telm[k] *= p[v];\n\trep(i, rG[v].size()){\n\t\tif(!used[rG[v][i]]) rdfs(rG[v][i], k, sccs, cmp, used, elm);\n\t}\n}\n\nint scc(int V, vector< vector<int> > &each_scc, vector<int> &cmp, vector<double> &elm) {\n\tvector<int> vs;\n\tbool used[MAX_V];\n\trep(i, MAX_V) used[i] = false;\n\tvs.clear();\n\trep(v, V){\n\t\tif(!used[v]) dfs((int)v, used, vs);\n\t}\n\trep(i, MAX_V) used[i] = false;\n\tint k=0;\n\tfor(int i=(int)vs.size()-1; i >=0; i--){\n\t\tvector<int> sccs;\n\t\tif(!used[vs[i]]){\n\t\t\trdfs(vs[i], k++, sccs, cmp, used, elm);\n\t\t\teach_scc.push_back(sccs);\n\t\t}\n\t}\n\treturn k;\n}\n\nvoid getSccedGraph(vector<vector<int>> each_scc, vector<int> cmp, vector<int> newGraph[MAX_V]){\n\trep(i, each_scc.size()){\n\t\tset<int> edges;\n\t\trep(j, each_scc[i].size()){\n\t\t\trep(k, G[each_scc[i][j]].size()){\n\t\t\t\tint to = G[each_scc[i][j]][k];\n\t\t\t\tif(cmp[to] != i) edges.insert(cmp[to]);\n\t\t\t}\n\t\t}\n\t\tfor(auto &edge:edges) newGraph[i].pb(edge);\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n&&n){\n\t\trep(i,MAX_V){\n\t\t\tG[i].clear();\n\t\t\trG[i].clear();\n\t\t}\n\t\t\n\t\tp.clear();\n\t\tp.resize(n);\n\t\trep(i,n){\n\t\t\tcin >> p[i];\n\t\t\tint m;\n\t\t\tcin >> m;\n\t\t\trep(j, m){\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\tadd_edge(i,a-1);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>> each_scc;\n\t\tvector<int> cmp(MAX_V);\n\t\tvector<double> elm(MAX_V,1.0);\n\t\tint k=scc(n,each_scc,cmp,elm);\n\t\t\n\t\tvector<int> newGraph[MAX_V];\n\t\tgetSccedGraph(each_scc,cmp,newGraph);\n\t\t\n\t\tvector<int> nyuuji(MAX_V,0);\n\t\trep(i,k){\n\t\t\trep(j,newGraph[i].size()){\n\t\t\t\tnyuuji[newGraph[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tdouble ans=1.0;\n\t\trep(i,k){\n\t\t\tif(nyuuji[i]==0){\n\t\t\t\tif(elm[i]==1)continue;\n\t\t\t\tans*=(1-elm[i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9lf\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nvector<int> g[111],rg[111],vs;\nbool used[111],is_chi[111];\nint cmp[111];\ndouble p[111],np[111];\nvector<P> es;\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int nv:g[v]){\n    if(!used[nv])dfs(nv);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int nv:rg[v]){\n    if(!used[nv])rdfs(nv,k);\n  }\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    rep(i,111){\n      g[i].clear();\n      rg[i].clear();\n    }\n    vs.clear();\n    es.clear();\n    cin>>n;\n    if(n==0)break;\n    rep(i,n){\n      int m;\n      cin>>p[i]>>m;\n      rep(j,m){\n        int a;\n        cin>>a;\n        a--;\n        g[i].pb(a);\n        rg[a].pb(i);\n        es.pb(P(i,a));\n      }\n    }\n    memset(used,0,sizeof(used));\n    rep(i,n){\n      if(!used[i])dfs(i);\n    }\n    memset(used,0,sizeof(used));\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]])rdfs(vs[i],k++);\n    }\n    rep(i,111)np[i]=1.0;\n    rep(i,n){\n      np[cmp[i]]*=p[i];\n    }\n    rep(i,k)np[i]=1-np[i];\n    memset(is_chi,0,sizeof(is_chi));\n    rep(i,es.size()){\n      int s=cmp[es[i].fi],t=cmp[es[i].se];\n      if(s!=t)is_chi[t]=true;\n    }\n    double res=1.0;\n    memset(used,0,sizeof(used));\n    rep(i,k){\n      if(!is_chi[i])res*=np[i];\n    }\n    printf(\"%.10f\\n\", res);\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os, const map<T,U>& mp){ os << \"{\"; for(auto& p : mp){ os << p << \",\"; } os << \"}\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nstruct SCC{/*{{{*/\n    int V; // # of node\n    vector<vector<int>> G,rG;\n    vector<int> vs,cmp; // vs:行きかけ順序の並び cmp:どの集合に属するか?\n    vector<bool> used;\n\n    SCC(){}\n    SCC(int v){ init(v); }\n\n    void init(int v){\n        V = v;\n        G.assign(V,vector<int>());\n        rG.assign(V,vector<int>());\n        vs.clear();\n        cmp.resize(V);\n    }\n\n    void add_edge(int from,int to){\n        G[from].emplace_back(to);\n        rG[to].emplace_back(from);\n    }\n\n    void dfs(int v){\n        used[v] = true;\n        for(const int& u : G[v]) if(!used[u]) dfs(u);\n        vs.push_back(v);\n    }\n\n    // @args k 何番目の成分か?\n    void rdfs(int v,int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(const int& u : rG[v]) if(!used[u]) rdfs(u,k);\n    }\n\n    // @return 強連結成分分解した後の成分の数\n    int scc(){\n        used.assign(V,false);\n        for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n        used.assign(V,false);\n        int k=0;\n        for(int i=vs.size()-1;i>=0;i--){\n            if(!used[vs[i]]) rdfs(vs[i],k++);\n        }\n        return k;\n    }\n\n    bool is_same(int i,int j){ return cmp[i] == cmp[j]; }\n};/*}}}*/\n\nvoid solve(int N){\n    vector<double> p(N);\n    vector<vector<int>> G(N);\n    rep(i,N){\n        cin >> p[i];\n        int m; cin >> m;\n        G[i].resize(m);\n        rep(j,m){\n            cin >> G[i][j];\n            G[i][j]--;\n        }\n    }\n\n    SCC graph(N);\n    rep(u,N){\n        for(int v:G[u]){\n            graph.add_edge(u,v);\n        }\n    }\n    int K = graph.scc();\n\n    /* cerr << \"K = \" << K << endl; */\n    /* cerr << \"cmp = \" << graph.cmp << endl; */\n\n    vector<double> p2(K,1);\n    for(int i=0;i<N;i++) p2[graph.cmp[i]] *= p[i];\n    /* cerr << \"p2 = \" << p2 << endl; */\n\n    vector<set<int>> rg(N);\n    rep(u,N){\n        int uu = graph.cmp[u];\n        for(int v:G[u]){\n            int vv = graph.cmp[v];\n            if(uu==vv) continue;\n            rg[vv].insert(uu);\n        }\n    }\n\n\n    double ans = 1.0;\n    for(int i=0;i<K;i++){\n        if(rg[i].size() == 0){\n            ans *= 1.0-p2[i];\n        }\n    }\n    cout << Double(ans) << endl;\n}\n\nint main(){\n    int N;\n    while(1){\n        cin >> N;\n        if(N==0) break;\n        solve(N);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass G {\npublic:\n  vector<vector<int>> p, inv, sp, sinv;\n  int n, m;\n  vector<int> b, c, depth;\n  vector<bool> a;\n  G(int nn, vector<vector<int>> &np, vector<vector<int>> &ninv) {\n    n = nn;\n    p = np;\n    inv = ninv;\n    a.resize(n);\n    c.resize(n);\n    for (int i = 0; i < n; i++)\n      c[i] = -1;\n  }\n  void dfs(int i) {\n    if (a[i])\n      return;\n    a[i] = true;\n    for (auto &j : p[i]) {\n      if (a[j])\n        continue;\n      dfs(j);\n    }\n    b.push_back(i);\n  }\n  void dfs2(int i, int id) {\n    if (c[i] > -1)\n      return;\n    c[i] = id;\n    for (auto &j : inv[i]) {\n      if (c[j] > -1)\n        continue;\n      dfs2(j, id);\n    }\n  }\n  void solve() {\n    for (int i = 0; i < n; i++)\n      dfs(i);\n    int j = 0;\n    for (int i = n - 1; i >= 0; i--) {\n      if (c[b[i]] > -1)\n        continue;\n      dfs2(b[i], j++);\n    }\n    m = j;\n    sp.resize(m);\n    sinv.resize(m);\n    vector<set<int>> sps(m);\n    for (int i = 0; i < n; i++) {\n      for (int &j : p[i]) {\n        if (c[i] == c[j])\n          continue;\n        sps[c[i]].insert(c[j]);\n      }\n    }\n    for (int i = 0; i < m; i++) {\n      for (auto &j : sps[i]) {\n        sp[i].push_back(j);\n        sinv[j].push_back(i);\n      }\n    }\n  }\n};\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0)\n      break;\n    vector<vector<int>> p(n), inv(n);\n    vector<double> z(n);\n    for (int i = 0; i < n; i++) {\n      cin >> z[i];\n      int m;\n      cin >> m;\n      for (int j = 0; j < m; j++) {\n        int k;\n        cin >> k;\n        k--;\n        p[i].push_back(k);\n        inv[k].push_back(i);\n      }\n    }\n    G g(n, p, inv);\n    g.solve();\n\n    int m = g.m;\n    vector<double> z2(m);\n    for (int i = 0; i < m; i++) {\n      z2[i] = 1.;\n    }\n    for (int i = 0; i < n; i++) {\n      z2[g.c[i]] *= z[i];\n    }\n    double ans = 1.;\n    for (int i = 0; i < m; i++) {\n      if (g.sinv[i].size() == 0) {\n        ans *= (1. - z2[i]);\n      }\n    }\n    printf(\"%.9lf\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nbool done[101];\n\nvector<double> p;\nvector<vector<int>> E, rE;\n\nvector<int> vs;\nint cmp[101];\n\nvoid dfs(int pos) {\n    done[pos] = true;\n\n    for (auto to : E[pos]) {\n        if (!done[to]) {\n            dfs(to);\n        }\n    }\n    vs.push_back(pos);\n}\n\nvoid rdfs(int pos, int k) {\n    done[pos] = true;\n    cmp[pos] = k;\n\n    for (auto e : rE[pos]) {\n        if (!done[e]) {\n            rdfs(e, k);\n        }\n    }\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        p = vector<double>(n);\n        E = vector<vector<int>>(n);\n        rE = vector<vector<int>>(n);\n\n        for (int i = 0; i < n; i++) {\n            int m;\n            cin >> p[i] >> m;\n\n            for (int j = 0; j < m; j++) {\n                int x; cin >> x;\n                x--;\n                E[i].push_back(x);\n                rE[x].push_back(i);\n            }\n        }\n\n        vs.clear();\n        memset(done, false, sizeof(done));\n        for (int i = 0; i < n; i++) {\n            if (!done[i]) {\n                dfs(i);\n            }\n        }\n\n        int k = 0;\n        memset(done, false, sizeof(done));\n        for (int i = vs.size() - 1; i >= 0; i--) {\n            if (!done[vs[i]]) {\n                rdfs(vs[i], k++);\n            }\n        }\n\n        vector<double> pscc(k, 1.0);\n        for (int i = 0; i < n; i++) {\n            pscc[cmp[i]] *= p[i];\n        }\n\n        double ans = 1.0;\n        memset(done, false, sizeof(done));\n        for (int i = vs.size() - 1; i >= 0; i--) {\n            if (!done[vs[i]]) {\n                dfs(vs[i]);\n                ans *= (1 - pscc[cmp[vs[i]]]);\n            }\n        }\n        printf(\"%.09lf\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nvd p;\nvvi g;\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(!n) break;\n\t\tp=vd(n);\n\t\tg=vvi(n);\n\t\tvi a(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint m;\n\t\t\tcin>>p[i]>>m;\n\t\t\tg[i]=vi(m);\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tint v;\n\t\t\t\tcin>>v;\n\t\t\t\tv--;\n\t\t\t\tg[i][j]=v;\n\t\t\t\ta[v]++;\n\t\t\t}\n\t\t}\n\t\tdouble res=1;\n\t\tqueue<int> q;\n\t\tfor(int i=0;i<n;i++) if(!a[i]){\n\t\t\tq.push(i);\n\t\t\tres*=(1-p[i]);\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tint v=q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\t\tint u=g[v][i];\n\t\t\t\tif(a[u]){\n\t\t\t\t\ta[u]=0;\n\t\t\t\t\tq.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) if(a[i]){\n\t\t\tq.push(i);\n\t\t\tdouble tmp=1;\n\t\t\ta[i]=0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tint v=q.front();\n\t\t\t\ttmp*=p[v];\n\t\t\t\tq.pop();\n\t\t\t\tfor(int j=0;j<g[v].size();j++){\n\t\t\t\t\tint u=g[v][j];\n\t\t\t\t\tif(a[u]){\n\t\t\t\t\t\ta[u]=0;\n\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres*=(1-tmp);\n\t\t}\n\t\tcout<<syosu(9)<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iomanip>\n#include <iostream>\nusing namespace std;\nint n, c, x; double p[109]; bool vis[109], vis2[109];\nint main() {\n\twhile (cin >> n, n) {\n\t\tvector<vector<int> > G(n), G2(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p[i] >> c;\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcin >> x; x--;\n\t\t\t\tG[i].push_back(x);\n\t\t\t\tG2[i].push_back(x);\n\t\t\t\tG2[x].push_back(i);\n\t\t\t}\n\t\t}\n\t\tfill(vis, vis + n, false);\n\t\tdouble ret = 1.0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (vis[i]) continue;\n\t\t\tvector<int> v;\n\t\t\tqueue<int> que1; que1.push(i); vis[i] = true;\n\t\t\twhile (!que1.empty()) {\n\t\t\t\tint u = que1.front(); que1.pop();\n\t\t\t\tv.push_back(u);\n\t\t\t\tfor (int i : G2[u]) {\n\t\t\t\t\tif (!vis[i]) {\n\t\t\t\t\t\tvis[i] = true;\n\t\t\t\t\t\tque1.push(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble res = 1.0;\n\t\t\tfor (int i : v) {\n\t\t\t\tfill(vis2, vis2 + n, false); vis2[i] = true;\n\t\t\t\tqueue<int> que2; que2.push(i);\n\t\t\t\tint cnt = 0;\n\t\t\t\twhile (!que2.empty()) {\n\t\t\t\t\tint u = que2.front(); que2.pop(); cnt++;\n\t\t\t\t\tfor (int i : G[u]) {\n\t\t\t\t\t\tif (!vis2[i]) {\n\t\t\t\t\t\t\tvis2[i] = true;\n\t\t\t\t\t\t\tque2.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt == v.size()) res *= p[i];\n\t\t\t}\n\t\t\tret *= 1.0 - res;\n\t\t}\n\t\tcout << fixed << setprecision(15) << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = long double;\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vector<R> p(n);\n        vector<vi> a(n);\n        vector<vi> adj(n, vi(n));\n        rep(i, n){\n            cin >> p[i]; p[i] = 1.0 - p[i];\n            int m; cin >> m;\n            a[i] = vi(m); for(auto& e : a[i]) cin >> e, e--, adj[i][e] = true;\n        }\n\n        vector<vi> cango(n, vi(n));\n        rep(i, n){\n            cango[i][i] = true;\n            for(auto& j : a[i]){\n                cango[i][j] = true;\n            }\n        }\n        rep(k, n) rep(i, n) rep(j, n) cango[i][j] |= (cango[i][k] & cango[k][j]);\n\n        int m = 0;\n        vi group(n, -1);\n        rep(i, n){\n            if(group[i] != -1) continue;\n            rep(j, i, n){\n                if(cango[i][j] && cango[j][i]){\n                    assert(group[j] == -1);\n                    group[j] = m;\n                }\n            }\n            m++;\n        }\n\n        vector<set<int>> edge(m);\n        rep(i, n){\n            rep(j, n){\n                if(group[i] == group[j]) continue;\n                if(adj[i][j]){\n                    edge[group[j]].insert(group[i]);\n                }\n            }\n        }\n\n        vector<R> q(m, 1.0);\n        rep(i, n){\n            q[group[i]] *= (1.0 - p[i]);\n        }\n        for(auto& e : q) e = 1.0 - e;\n\n        R res = 1.0;\n        rep(i, m){\n            if(edge[i].size() >= 1) continue;\n            res *= q[i];\n        }\n\n        cout.precision(20);\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define ll long long\nusing namespace std;\n//typedef vector<unsigned int>vec;\n//typedef vector<ll>vec;\n//typedef vector<vec> mat;\ntypedef pair<int, int> P;\ntypedef pair<ll,ll> LP;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int INF = 1000000000;\nconst ll LINF = 1000000000000000000;//1e18\nconst ll  MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-10;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n//template<class T> inline void add(T &a, T b){a = ((a+b) % MOD + MOD) % MOD;};\n\nclass StronglyConnectedComponents{\n    int nodeNum;\n    int size;\npublic:\n    vector<vector<int>> edge,revEdge;\n    vector<vector<int>> graph;\n    vector<int> label,visited,order;\n    // 帰りがけ順に番号を振っていく\n    void dfs(int cur){\n        visited[cur] = 1;\n        for(int next:edge[cur]) if(!visited[next]) dfs(next);\n        order.push_back(cur);\n    }\n    // 通ることが出来た頂点に番号を振っていく\n    void revDfs(int cur,int labelId){\n        visited[cur] = 1;\n        label[cur] = labelId;\n        for(int next:revEdge[cur]) if(!visited[next]) revDfs(next,labelId);\n    }\n\n\tStronglyConnectedComponents(const int& nodeNum) :\n    nodeNum(nodeNum), edge(nodeNum), revEdge(nodeNum), label(nodeNum), visited(nodeNum) {}\n\n    void make_edge(const int from,const int to) {\n        edge[from].push_back(to);\n        revEdge[to].push_back(from);\n    }\n\n    void solve(void) {\n        for(int i = 0; i < nodeNum; ++i) visited[i] = 0;\n        for(int i = 0; i < nodeNum; ++i) if(!visited[i]) dfs(i);\n        for(int i = 0; i < nodeNum; ++i) visited[i] = 0;\n        reverse(order.begin(),order.end());\n        int labelId = 0;\n        for(int i:order) if(!visited[i]) revDfs(i,labelId++);\n        size = labelId;\n        make_graph();\n    }\n\n    // 強連結成分で縮約したグラフを作る\n    void make_graph(){\n        graph.resize(size);\n        for(int i = 0; i < edge.size(); i++){\n            for(auto to : edge[i]){\n                if(getLabel(i) == getLabel(to)) continue;\n                graph[getLabel(i)].push_back(getLabel(to));\n            }\n        }\n    }\n\n    void print(void) {\n        for(auto labelId:label) cout << labelId << \" \";\n        cout << endl;\n    }\n    // vが属している強連結成分のラベル（トポロジカル順序）\n    int getLabel(int v){\n        return label[v];\n    }\n\n    int getSize(){\n        return size;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N, N){\n        StronglyConnectedComponents SCC(N);\n        vector<double> p(N);\n        REP(i,N){\n            int a;\n            cin >> p[i] >> a;\n            REP(j,a){\n                int b;\n                cin >> b;\n                SCC.make_edge(i, --b);\n            }\n        }\n        SCC.solve();\n        vector<int> indeg(SCC.getSize());\n        auto &g = SCC.edge;\n        REP(v,g.size()){\n            for(auto nv : g[v]){\n                if(SCC.getLabel(v) == SCC.getLabel(nv)) continue;\n                indeg[SCC.getLabel(nv)]++;\n            }\n        }\n        \n        vector<double> P(SCC.getSize(), 1.0);\n        REP(i, g.size()) P[SCC.getLabel(i)] *= p[i];\n\n        double ans = 1.0;\n        REP(i, SCC.getSize()){\n            if(indeg[i] != 0) continue;\n            ans *= (1 - P[i]);\n        }\n        printf(\"%.12lf\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e9)\nint N,M;\nint s[15];\nint d[100];\nint sum[(1<<15)];\nint dp[(1<<15)];\n\nvoid init(){\n  for(int i=0;i<(1<<N);i++){\n    sum[i]=0;\n    dp[i]=0;\n  }\n}\n\nint solve(){\n  for(int i=0;i<M;i++){\n    for(int bit=0;bit<(1<<N);bit++){\n      for(int j=0;j<N;j++){\n        int nbit=bit|(1<<j);\n        dp[nbit]=min(dp[nbit],dp[bit]);\n      }\n      dp[bit]+=abs(sum[bit]-d[i]);\n    }\n  }\n  int ans=INF;\n  for(int bit=0;bit<(1<<N);bit++){\n    ans=min(ans,dp[bit]);\n  }\n  return ans;\n}\n\nint main(){\n  while(1){\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    init();\n    for(int i=0;i<N;i++)cin>>s[i];\n    for(int i=0;i<M;i++)cin>>d[i];\n    sort(d,d+M);\n    for(int bit=0;bit<(1<<N);bit++)\n      for(int i=0;i<N;i++)\n        if(bit>>i&1)sum[bit]+=s[i];\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvoid dfs(int idx, bool *used, vector< int > &order, vector< int > *g)\n{\n  if(used[idx]++) return;\n  for(auto &to : g[idx]) dfs(to, used, order, g);\n  order.push_back(idx);\n};\n\nvoid rdfs(int idx, int k, int *cmp, vector< int > *rg)\n{\n  if(~cmp[idx]) return;\n  cmp[idx] = k;\n  for(auto &to : rg[idx]) rdfs(to, k, cmp, rg);\n};\n\nint main()\n{\n  int N;\n  double p[100];\n  int cmp[100];\n  bool used[100];\n  bool in[100];\n\n  while(scanf(\"%d\", &N), N) {\n    vector< int > g[100], rg[100];\n\n    for(int i = 0; i < N; i++) {\n      int M;\n      scanf(\"%lf %d\", &p[i], &M);\n      while(M--) {\n        int a;\n        scanf(\"%d\", &a);\n        g[i].push_back(--a);\n        rg[a].push_back(i);\n      }\n    }\n\n    vector< int > order;\n    memset(cmp, -1, sizeof(cmp));\n    memset(used, false, sizeof(used));\n    memset(in, 0, sizeof(in));\n    for(int i = 0; i < N; i++) dfs(i, used, order, g);\n    reverse(begin(order), end(order));\n    for(int i : order) rdfs(i, i, cmp, rg);\n\n    for(int i = 0; i < N; i++) {\n      for(int &to : g[i]) in[cmp[to]] += cmp[i] != cmp[to];\n    }\n    double ret = 1.0;\n    for(int i = 0; i < N; i++) {\n      if(cmp[i] == i && !in[cmp[i]]) {\n        double curr = 1.0;\n        for(int j = 0; j < N; j++) {\n          if(cmp[i] == cmp[j]) curr *= p[j];\n        }\n        ret *= 1 - curr;\n      }\n    }\n    printf(\"%.10lf\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass SCC{//cmp(0 - kk-1) is scc's return. Same number is group. The number is no relatoin.\n\tpublic:\n\tint n;\n\tvvi G,rG,tG;\n\tvector<bool>used;\n\tvi vs,cmp;\n\tSCC(int size){\n\t\tn=size;\n\t\tG=rG=vvi(n);\n\t\tused=vector<bool>(n);\n\t\tcmp=vi(n);\n\t\tvs=vi(0);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\trG[t].pb(s);\n\t}\n\tvoid rdfs(int v,int k){\n\t\tused[v]=true;\n\t\tcmp[v]=k;\n\t\trep(i,rG[v].size())if(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n\tvoid dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size())if(!used[G[v][i]])dfs(G[v][i]);\n\t\tvs.pb(v);\n\t}\n\tint scc(){\n\t\trep(i,n)used[i]=false;\n\t\trep(v,n)if(!used[v])dfs(v);\n\t\trep(i,n)used[i]=false;\n\t\tint kk=0;\n\t\tfor(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],kk++);\n\t\treturn kk;  \n\t}\n\tvoid make(int size){\n\t\tint N=size;\n\t\ttG=vvi(N);\n\t\trep(i,n)rep(j,G[i].size())if(cmp[i]!=cmp[G[i][j]]){\n//\t\t\ttG[cmp[i]].pb(cmp[G[i][j]]);\n\t\t\ttG[cmp[G[i][j]]].pb(cmp[i]);\n\t\t}\n\t}\n};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvd d(n);\n//\t\tvvi G(n);\n\t\tSCC scc(n);\n\t\trep(i,n){\n\t\t\tcin>>d[i];\n\t\t\tint a;cin>>a;\n\t\t\trep(j,a){\n\t\t\t\tint b;cin>>b;\n\t\t\t\tb--;\n\t\t\t\tscc.add_edge(i,b);\n\t\t\t}\n\t\t}\n\t\tint N=scc.scc();\n\t\tscc.make(N);\n\t\tvvi rG=scc.tG;\n\t\tvi c=scc.cmp;\n\t\tvd nd(N);\n\t\trep(i,N){\n\t\t\tdouble t=1;\n\t\t\trep(j,n)if(c[j]==i)t*=d[j];\n\t\t\tnd[i]=t;\n\t\t}\n\t\tdouble out=1;\n\t\trep(i,N)if(!rG[i].size())\n\t\t\tout*=(1-nd[i]);\n\t\t\n\t\tcout<<shosu(9)<<out<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = double;\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vector<R> p(n);\n        vector<vi> a(n);\n        rep(i, n){\n            cin >> p[i]; p[i] = 1.0 - p[i];\n            int m; cin >> m;\n            a[i] = vi(m); for(auto& e : a[i]) cin >> e, e--;\n        }\n\n        vector<vi> cango(n, vi(n));\n        rep(i, n){\n            cango[i][i] = true;\n            for(auto& j : a[i]){\n                cango[i][j] = true;\n            }\n        }\n        rep(k, n) rep(i, n) rep(j, n) cango[i][j] |= (cango[i][k] & cango[k][j]);\n\n        int m = 0;\n        vi group(n, -1);\n        rep(i, n){\n            if(group[i] != -1) continue;\n            group[i] = m++;\n            rep(j, i + 1, n){\n                if(cango[i][j] && cango[j][i]) group[j] = group[i];\n            }\n        }\n\n        vector<set<int>> edge(m);\n        rep(i, n){\n            rep(j, n){\n                if(group[i] == group[j]) continue;\n                if(cango[i][j]){\n                    edge[group[j]].insert(group[i]);\n                }\n            }\n        }\n\n        vector<R> q(m, 1.0);\n        rep(i, n){\n            q[group[i]] *= (1.0 - p[i]);\n        }\n        for(auto& e : q) e = 1.0 - e;\n\n        R res = 1.0;\n        rep(i, m){\n            if(edge[i].size() >= 1) continue;\n            res *= q[i];\n        }\n\n        cout.precision(20);\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nclass StronglyConnectedComponents{\n\tprivate:\n\t\tvector<bool> used;\n\t\tvector<int> vs; //帰りがけ順の並び\n\t\tvoid dfs(int v){\n\t\t\tused[v] = true;\n\t\t\trep(i,g[v].size()){\n\t\t\t\tif(not used[g[v][i]]) dfs(g[v][i]);\n\t\t\t}\n\t\t\tvs.emplace_back(v);\n\t\t}\n\t\tvoid rdfs(int v, int k){\n\t\t\tused[v] = true;\n\t\t\tcmp[v] = k;\n\t\t\trep(i,rg[v].size()){\n\t\t\t\tif(not used[rg[v][i]]) rdfs(rg[v][i], k);\n\t\t\t}\n\t\t}\n\tpublic:\n\t\ttypedef vector<vector<int>> graph;\n\t\tconst int v; // 頂点数\n\t\tint nv; // SCCした後の頂点数\n\t\tgraph g, rg; // グラフ、辺が逆になったグラフ\n\t\tvector<int> cmp; //属する強連結成分のトポロジカル順序\n\n\t\tStronglyConnectedComponents(int v) : used(v), v(v), g(v), rg(v), cmp(v) { }\n\n\t\tvoid addEdge(int from, int to){\n\t\t\tg[from].emplace_back(to);\n\t\t\trg[to].emplace_back(from);\n\t\t}\n\t\tint solve(){ // 強連結成分分解をしたあとのグラフの頂点数を返す\n\t\t\tfill(all(used),0);\n\t\t\tvs.clear();\n\t\t\trep(i,v){\n\t\t\t\tif(not used[i]) dfs(i);\n\t\t\t}\n\t\t\tfill(all(used),0);\n\t\t\tint k = 0;\n\t\t\tfor(int i = vs.size() - 1; i >= 0; i--){\n\t\t\t\tif(not used[vs[i]]) rdfs(vs[i], k++);\n\t\t\t}\n\t\t\treturn nv = k;\n\t\t}\n\t\tgraph getCssGraph(vector<vector<int>>& node){\n\t\t\tnode = vector<vector<int>>(nv); // node[i]:=SCCによって頂点iに同一視された頂点\n\t\t\tgraph res(nv); // CSSしたあとのグラフ\n\t\t\trep(i,v){\n\t\t\t\tnode[cmp[i]].emplace_back(i);\n\t\t\t\tfor(auto to : g[i]){\n\t\t\t\t\t//if(cmp[i] == cmp[to]) continue;\n\t\t\t\t\tres[cmp[i]].emplace_back(cmp[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tvoid out(){\n\t\t\trep(i,v){ cout << cmp[i] << ' '; } cout << endl;\n\t\t}\n};\n\nvoid dfs(int pos, vector<bool>& used, vector<vector<int>>& g){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tdfs(to, used, g);\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tStronglyConnectedComponents scc(n);\n\t\tvector<double> p(n); // 寝坊する確率\n\t\trep(i,n){\n\t\t\tint m;\n\t\t\tcin >> p[i] >> m;\n\t\t\trep(j,m){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tscc.addEdge(i, a - 1);\n\t\t\t}\n\t\t}\n\t\tscc.solve();\n\n\t\tvector<vector<int>> node;\n\t\tStronglyConnectedComponents::graph g = scc.getCssGraph(node);\n\t\tdouble ans = 1;\n\n\t\tvector<bool> used(scc.nv,0);\n\t\trep(i,scc.nv){\n\t\t\tif(used[i]) continue;\n\n\t\t\tdouble tmp = 1.00;\n\t\t\trep(j,node[i].size()){\n\t\t\t\ttmp *= p[node[i][j]];\n\t\t\t}\n\t\t\tans *= 1.00 - tmp;\n\t\t\tdfs(i, used, g);\n\t\t}\n\t\tcout << fixed << setprecision(9) << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ndouble p[105];\nint d[105][105], e[105][105], h[105];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    REP(i, n) REP(j, n) d[i][j] = i==j?0:INF;\n    memset(h, 0, sizeof(h));\n    REP(i, n) {\n      cin >> p[i];\n      int m; cin >> m;\n      REP(j, m) {\n        int a; cin >> a; a--;\n        d[i][a] = e[i][a] = 1;\n        h[a]++;\n      }\n    }\n\n    REP(k, n) REP(i, n) REP(j, n) chmin(d[i][j], d[i][k] + d[k][j]);\n\n    // REP(i, n) {\n    //   REP(j, n) {\n    //     cout << d[i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n\n    vector<bool> used(n, false);\n    double ans = 1;\n    REP(i, n) {\n      if(used[i]) continue;\n      used[i] = true;\n      double prob = p[i];\n      REP(j, n) {\n        if(i == j) continue;\n        // cout << d[i][j] << \",\" << d[j][i] << \" \";\n        if(d[i][j] < INF && d[j][i] < INF) {\n          used[j] = true;\n          prob *= p[j];\n          if(e[j][i] < INF) h[i]--;\n        }\n      }\n      // cout << endl;\n      // cout << \"i:\" << i << \" \" << prob << endl;\n      if(h[i]<=0) ans *= 1-prob;\n    }\n\n    cout << fixed << setprecision(9) << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint n;\ndouble p[100];\nvector<int> g[100];\nvector<int> rg[100];\nbool vis[100];\nvector<int> ord;\nint c[100];\ndouble d[100];\nvector<int> gg[100];\nint in[100];\n\nvoid dfs(int v){\n  vis[v] = true;\n  each(u, g[v]) if (!vis[u]) dfs(u);\n  ord.push_back(v);\n}\n\nvoid dfs(int v, int ii){\n  vis[v] = true;\n  c[v] = ii;\n  each(u, rg[v]) if (!vis[u]) dfs(u, ii);\n}\n\nint main(){\n  while (cin >> n, n){\n    rep(i, 100) g[i].clear();\n    rep(i, 100) rg[i].clear();\n    memset(vis, 0, sizeof(vis));\n    ord.clear();\n    rep(i, 100) gg[i].clear();\n    memset(in, 0, sizeof(in));\n\n    rep(i, n){\n      int m;\n      cin >> p[i] >> m;\n      //p[i] = 1.0 - p[i];\n      g[i].resize(m);\n      each(x, g[i]){\n        cin >> x, x--;\n        rg[x].push_back(i);\n      }\n    }\n    rep(i, n) if (!vis[i]) dfs(i);\n    reverse(all(ord));\n    memset(vis, 0, sizeof(vis));\n    int ii = 0;\n    each(i, ord) if (!vis[i]) dfs(i, ii++);\n    rep(i, ii) d[i] = 1.0;\n    rep(i, n){\n      d[c[i]] *= p[i];\n      each(j, g[i]) if (c[i] != c[j]) gg[c[i]].push_back(c[j]);\n    }\n    rep(i, ii){\n      sort(all(gg[i]));\n      gg[i].erase(unique(all(gg[i])), end(gg[i]));\n    }\n    /*\n    double res = 1.0;\n    rep(i, ii){\n      cout << i << \": \";\n      each(j, gg[i]) cout << j << \" \", d[j] *= d[i];\n      cout << endl;\n      if (gg[i].empty()) res *= d[i];\n    }\n    cout << 1.0 - res << endl;\n    */\n    rep(i, ii) each(j, gg[i]) in[j]++;\n    double res = 1.0;\n    rep(i, ii) if (in[i] == 0) res *= 1.0 - d[i];\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint INF = 10000000;\n\nint N;\ndouble p[100];\nint m[100], a[100][100];\n\nclass Tp{\npublic:\n  int V;\n  vector<int> G[100];\n  vector<int> rG[100];\n  vector<int> vs;\n  bool used[100];\n  int cmp[100];\n  double rsum[100];\n  void add(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n  void dfs(int v) {\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n      if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n  }\n  void rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for (int i = 0; i < rG[v].size(); i++) {\n      if (!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n  }\n\n  int scc() {\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for (int v = 0; v < V; v++)\n      if(!used[v]) dfs(v);\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for (int i = vs.size() - 1; i >= 0; i--)\n      if (!used[vs[i]]) rdfs(vs[i], k++);\n    return k;\n  }\n  double ans() {\n    int num = scc();\n    for (int i = 0; i < num; i++) rsum[i] = 1.0;\n    for (int i = 0; i < V; i++) rsum[cmp[i]] *= p[i];\n    bool isTop[num];\n    for (int i = 0; i < num; i++) isTop[i] = true;\n    for (int i = 0; i < V; i++)\n      for (int j = 0; j < m[i]; j++)\n        if (cmp[i] != cmp[a[i][j]]) isTop[cmp[a[i][j]]] = false;\n    double ans = 1.0;\n    for (int i = 0; i < num; i++)\n      if(isTop[i]) ans *= 1.0 - rsum[i];\n    return ans;\n  }\n};\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) break;\n\n    Tp t;\n    t.V = N;\n\n    for (int i = 0; i < N; i++) {\n      scanf(\"%lf%d\", &p[i], &m[i]);\n      for (int j = 0; j < m[i]; j++) {\n        scanf(\"%d\", &a[i][j]);\n        a[i][j]--;\n        t.add(i, a[i][j]);\n      }\n    }\n    printf(\"%f\\n\", t.ans());\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = double;\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vector<R> p(n);\n        vector<vi> a(n);\n        rep(i, n){\n            cin >> p[i]; p[i] = 1.0 - p[i];\n            int m; cin >> m;\n            a[i] = vi(m); for(auto& e : a[i]) cin >> e, e--;\n        }\n\n        vector<vi> cango(n, vi(n));\n        rep(i, n){\n            cango[i][i] = true;\n            for(auto& j : a[i]){\n                cango[i][j] = true;\n            }\n        }\n        rep(k, n) rep(i, n) rep(j, n) cango[i][j] |= (cango[i][k] & cango[k][j]);\n\n        int m = 0;\n        vi group(n, -1);\n        rep(i, n){\n            if(group[i] != -1) continue;\n            group[i] = m++;\n            rep(j, i + 1, n){\n                if(cango[i][j] && cango[j][i]) group[j] = group[i];\n            }\n        }\n\n        vector<set<int>> edge(m);\n        rep(i, n){\n            rep(j, n){\n                if(group[i] == group[j]) continue;\n                if(cango[i][j]){\n                    edge[j].insert(i);\n                }\n            }\n        }\n\n        vector<R> q(m, 1.0);\n        rep(i, n){\n            q[group[i]] *= (1.0 - p[i]);\n        }\n        for(auto& e : q) e = 1.0 - e;\n\n        R res = 1.0;\n        rep(i, m){\n            if(edge[i].size() >= 1) continue;\n            res *= q[i];\n        }\n\n        cout.precision(20);\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, double>;\n\nstruct StronglyConnectedComponents {\n  int n;\n  int time;\n  vector<vector<int>> g;\n  vector<int> num, low, group, prev;\n  vector<vector<int>> scc;\n  stack<int, deque<int>> S;\n  vector<bool> inS;\n\n  StronglyConnectedComponents(int n)\n    : n(n), g(n), num(n, -1), low(n, -1), inS(n, false),\n      group(n, 0), prev(n) {}\n\n  void addEdge(int u, int v) {\n    g[u].push_back(v);\n  }\n  void dfs(int u) {\n    num[u] = low[u] = time++;\n    S.push(u);\n    inS[u] = true;\n    for (auto&& v : g[u]) {\n      if (num[v] == -1) {\n        dfs(v);\n        low[u] = min(low[u], low[v]);\n      } else if (inS[v]) {\n        low[u] = min(low[u], num[v]);\n      }\n    }\n    if (low[u] == num[u]) {\n      scc.push_back({});\n      while (true) {\n        int v = S.top(); S.pop();\n        inS[v] = false;\n        scc.back().push_back(v);\n        group[v] = scc.size() - 1;\n        if (u == v) break;\n      }\n      for (int i = 0, m = scc.back().size(); i < m; ++i) {\n        prev[scc.back()[i]] = scc.back()[(i + 1) % m];\n      }\n    }\n  }\n  void build() {\n    for (int i = 0; i < n; ++i) {\n      if (num[i] == -1) dfs(i);\n    }\n  }\n};\n\nint main() {\n  int N;\n  while (cin >> N, N) {\n    auto p = vector<double>(N);\n    auto adj = vector<vector<int>>(N, vector<int>(N, 0));\n    auto g = StronglyConnectedComponents(N);\n    for (int i = 0; i < N; ++i) {\n      int m;\n      cin >> p[i] >> m;\n      for (int j = 0; j < m; ++j) {\n        int a; cin >> a; --a;\n        g.addEdge(i, a);\n        adj[a][i] = 1;\n      }\n    }\n    g.build();\n    auto v = vector<double>(g.scc.size(), 1.0);\n    for (int i = 0; i < g.scc.size(); ++i) {\n      for (auto&& x : g.scc[i]) v[i] *= p[x];\n      // for (auto&& x : g.scc[i]) cout << setw(3) << right << x; cout << endl;\n    }\n    // for (int i = 0; i < N; ++i) {\n    //   cout << i << ' ' << g.group[i] << endl;\n    // }\n    for (int i = 0; i < N; ++i) {\n      int cnt = 0;\n      for (int j = 0; j < N; ++j) {\n        if (g.group[i] != g.group[j] && adj[i][j]) ++cnt;\n      }\n      if (cnt) v[g.group[i]] = 0;\n    }\n    double ans = accumulate(begin(v), end(v), 1.0, [](double acc, double i) { return acc * (1.0 - i); });\n    cout << fixed << setprecision(6) << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdlib.h>\n#include <map>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <queue>\n#include <utility>\n#define llint long long\n#define inf 1e9\n#define eps 1e-8\n\nusing namespace std;\n\nint n;\ndouble p[105];\nvector<int> G[105], revG[105];\nvector<int> topo;\nbool used[105];\nint scc[105];\nbool come[105];\ndouble prob[105];\n\nvoid tpsort(int v)\n{\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    if(!used[G[v][i]]) tpsort(G[v][i]);\n  }\n  topo.push_back(v);\n}\nvoid sccdfs(int v, int id)\n{\n  used[v] = true;\n  scc[v] = id;\n  for(int i = 0; i < revG[v].size(); i++){\n    if(!used[revG[v][i]]) sccdfs(revG[v][i], id);\n  }\n}\n\nint main(void)\n{\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n\n    int m, x;\n    for(int i = 1; i <= n; i++) revG[i].clear();\n    for(int i = 1; i <= n; i++){\n      cin >> p[i];\n      cin >> m;\n      G[i].clear();\n      for(int j = 0; j < m; j++){\n        cin >> x;\n        G[i].push_back(x);\n        revG[x].push_back(i);\n      }\n    }\n\n    for(int i = 1; i <= n; i++) used[i] = false;\n    topo.clear();\n    for(int i = 1; i <= n; i++) if(!used[i]) tpsort(i);\n    reverse(topo.begin(), topo.end());\n\n    int id = 0;\n    for(int i = 1; i <= n; i++) used[i] = false;\n    for(int i = 0; i < topo.size(); i++) if(!used[topo[i]]) sccdfs(topo[i], id++);\n\n    //for(int i = 1; i <= n; i++) cout << scc[i] << \" \"; cout << endl;\n\n    int S = id;\n    for(int i = 0; i < S; i++) come[i] = false;\n    for(int i = 1; i <= n; i++){\n      for(int j = 0; j < G[i].size(); j++){\n        if(scc[i] != scc[G[i][j]]) come[scc[G[i][j]]] = true;\n      }\n    }\n    for(int i = 0; i < S; i++) prob[i] = 1;\n    for(int i = 1; i <= n; i++) prob[scc[i]] *= p[i];\n\n    double ans = 1;\n    for(int i = 0; i < S; i++){\n      if(come[i]) continue;\n      ans *= (1 - prob[i]);\n    }\n    printf(\"%.11f\\n\", ans);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\n\nvoid dfs(int x, vector<vector<int> > &g, vector<bool> &used, vector<int> &post, int& k){\n  used[x] = true;\n  for(size_t i = 0; i < g[x].size(); i++){\n    if(!used[g[x][i]]){\n      dfs(g[x][i], g, used, post, k);\n    }\n  }\n  post.push_back(x);\n  \n  return;\n}\n\ndouble rdfs(int x, vector<vector<int> > &rg, vector<int> &id, vector<double>& p, int k, vector<set<int> >& newG){\n  id[x] = k;\n  \n  double ans = p[x];\n  for(size_t i = 0; i < rg[x].size(); i++){\n    if(id[rg[x][i]] < 0){\n      ans *= rdfs(rg[x][i], rg, id, p, k, newG);\n    }\n    else if(id[rg[x][i]] != k){\n      newG[k].insert(id[rg[x][i]]);\n    }\n  }\n  \n  return ans;\n}\n\n\nint main(void){\n  int n;\n  while(true){\n    cin >> n;\n    if(n == 0){ break; }\n\n    vector<double> p(n);\n    vector<vector<int> > g(n);\n    vector<vector<int> > rg(n);\n    int m, a;\n    for(int i = 0; i < n; i++){\n      cin >> p[i] >> m;\n      for(int j = 0; j < m; j++){\n        cin >> a;\n        --a;\n        g[i].push_back(a);\n        rg[a].push_back(i);\n      }\n    }\n\n    int k = 0;\n    vector<bool> used(n, false);\n    vector<int> post;\n    for(int i = 0; i < n; i++){\n      if(!used[i]){\n        dfs(i, g, used, post, k);\n      } \n    }\n    \n    k = 0;\n    vector<int> id(n, -1);\n    used = vector<bool>(n, false);\n    vector<set<int> > newG(n);\n    vector<double> newP(n, 0);\n    for(int i = n - 1; i >= 0; i--){\n      if(id[post[i]] < 0){\n        newP[k] = rdfs(post[i], rg, id, p, k, newG);\n        //printf(\"[%.2f%c]\", newP[k], newG[k].size() == 0 ? '*' : '0');\n        k++;\n      }\n    }\n    \n    double ans = 1.0;\n    for(int i = 0; i < n; i++){\n      if(newG[i].size() == 0){\n        ans *= (1.0 - newP[i]);\n      }\n    }\n    printf(\"%.9f\\n\", ans);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_V = 100;\nint V;\nvector<int>G[MAX_V];\nvector<int>rG[MAX_V];\nvector<int>vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nvector<int>sG[MAX_V];\nvector<int>SCC[MAX_V];\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid graph_clear(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  for(int i=0;i<MAX_V;i++) rG[i].clear();\n  for(int i=0;i<MAX_V;i++) sG[i].clear();\n  for(int i=0;i<MAX_V;i++) SCC[i].clear();\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for (int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n  }\n}\n\n\nint scc(){\n  memset(used, 0, sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++){\n    if(!used[v]) dfs(v);\n  }\n\n  memset(used, 0, sizeof(used));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]]) rdfs(vs[i], k++);\n  }\n  return k;\n}\n\nvector<double>P;\nvector<int>M;\n\nint main(){\n  while(1){\n    cin >> V;\n    if(V == 0) break;\n    graph_clear();\n    P.clear();\n    M.clear();\n    for(int i=0;i<V;i++){\n      double p; int m; cin >> p >> m;\n      P.push_back(p);\n      M.push_back(m);\n      for(int j=0;j<m;j++){\n\tint a; cin >> a; a--;\n\tadd_edge(i, a);\n      }\n    }\n    int k = scc();\n\n    for(int i=0;i<V;i++){\n      int c = cmp[i];\n      //      cout << c << endl;\n      SCC[c].push_back(i);\n      for(int j=0;j<rG[i].size();j++){\n\t// cout << c << \" \" << cmp[rG[i][j]] << endl;\n\tif(c != cmp[rG[i][j]])\n\t  sG[c].push_back(cmp[rG[i][j]]);\n      }\n    }\n    \n    double res = 1;\n    for(int i=0;i<k;i++){\n      if(sG[i].size()) continue;\n      //      cout << SCC[i].size() << endl;\n      double prob = 1;\n      for(int j=0;j<SCC[i].size();j++){\n\t//\tcout << P[SCC[i][j]] << endl;\n\tprob *= P[SCC[i][j]];\n      }\n      //      cout << prob << endl;\n      res *= 1-prob;\n    }\n    printf(\"%.10f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,s,e) for (int i=s;i<(e);i++)\n#define All(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\nconst int MOD = (int)1e9 + 7;\nconst int INF = 1010101010;\ndouble p[100],P[100];\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n  const G &g;\n  vector<vector<int> > gg, rg;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n    for(int i = 0; i < g.size(); i++) {\n      for(auto e : g[i]) {\n        gg[i].emplace_back((int) e);\n        rg[(int) e].emplace_back(i);\n      }\n    }\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(vector<vector<int> > &t) {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n    for(int i=0;i<g.size();i++)P[i]=1;\n    for(int i=0;i<g.size();i++)P[comp[i]]*=p[i];\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      for(auto &to : g[i]) {\n        int x = comp[i], y = comp[to];\n        if(x == y) continue;\n        t[x].push_back(y);\n      }\n    }\n  }\n};\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin>>n,n)\n    {\n        vector<vector<int> >G(n);\n        for(int i=0;i<n;i++)\n        {\n            cin>>p[i];\n            int k;cin>>k;\n            for(int j=0;j<k;j++)\n            {\n                int a;cin>>a;a--;\n                G[i].push_back(a);\n            }\n        }\n        StronglyConnectedComponents<vector<vector<int> > >scc(G);\n        vector<vector<int> >h;\n        scc.build(h);\n        n=h.size();\n        vector<vector<int> >H(n);\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<h[i].size();j++)\n            {\n                H[h[i][j]].push_back(i);\n            }\n        }\n        double ans=1;\n        for(int i=0;i<n;i++)if(H[i].size()<1)ans*=1-P[i];\n        cout<<fixed<<setprecision(9)<<ans<<endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 200\nint n,m;\ndouble t[MAX_N];\nint G[MAX_N][MAX_N];\nbool visited[MAX_N];\nint par[MAX_N];\n \nvoid rdfs(int pos,int si){\n  visited[pos]=true;\n  par[pos]=si;\n  for(int i=0;i<n;i++){\n    if(G[i][pos]==0)continue;\n    if(visited[i])continue;\n    rdfs(i,si);\n  }\n}\n \nvoid dfs(int pos,vector<int> &v){\n  visited[pos]=true;\n  for(int i=0;i<n;i++){\n    if(G[pos][i]==0)continue;\n    if(visited[i])continue;\n    dfs(i,v);\n  }\n  v.push_back(pos);\n}\n \nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    memset(G,0,sizeof(G));\n    for(int i=0;i<n;i++){\n      cin>>t[i];\n      int k;\n      cin>>k;\n      for(int j=0;j<k;j++){\n        int a;\n        cin>>a;\n        a--;\n        G[i][a]=1;\n      }\n    }\n \n \n    vector<int> v;\n    memset(visited,false,sizeof(visited));\n    for(int i=0;i<n;i++){\n      if(visited[i])continue;\n      dfs(i,v);\n    }\n     \n    memset(visited,false,sizeof(visited));\n    reverse(v.begin(),v.end());\n    for(int i=0;i<(int)v.size();i++){\n      int si=v[i];\n      if(visited[si])continue;\n      rdfs(si,si);\n    }\n \n    vector<bool> flg(n,false);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(G[i][j]==0)continue;\n        if(par[i]!=par[j]){\n          flg[ par[j] ]=true;\n        }\n      }\n    }\n \n    double ans=1.0;\n    for(int i=0;i<n;i++){\n      if(par[i]!=i)continue;\n      if(flg[i])continue;\n      double p=1.0;\n      for(int j=0;j<n;j++){\n        if(par[j]!=i)continue;\n        p*=t[j];\n      }\n      ans*=(1.0-p);\n    }\n \n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct strongly_connected_components{\n  vector<vector<int>> scc;\n  vector<int> c;\n  void dfs1(vector<vector<int>> &E, vector<bool> &used, vector<int> &t, int v){\n    for (int w : E[v]){\n      if (!used[w]){\n        used[w] = true;\n        dfs1(E, used, t, w);\n      }\n    }\n    t.push_back(v);\n  }\n  void dfs2(vector<vector<int>> &E, vector<bool> &used, int v){\n    scc.back().push_back(v);\n    for (int w : E[v]){\n      if (!used[w]){\n        used[w] = true;\n        dfs2(E, used, w);\n      }\n    }\n  }\n  strongly_connected_components(vector<vector<int>> G){\n    int V = G.size();\n    vector<vector<int>> E1(V), E2(V);\n    for (int i = 0; i < V; i++){\n      for (int j : G[i]){\n        E1[i].push_back(j);\n        E2[j].push_back(i);\n      }\n    }\n    vector<bool> used(V, false);\n    vector<int> t;\n    for (int i = 0; i < V; i++){\n      if (!used[i]){\n        used[i] = true;\n        dfs1(E1, used, t, i);\n      }\n    }\n    reverse(t.begin(), t.end());\n    vector<bool> used2(V, false);\n    for (int i = 0; i < V; i++){\n      if (!used2[t[i]]){\n        used2[t[i]] = true;\n        scc.push_back(vector<int>());\n        dfs2(E2, used2, t[i]);\n      }\n    }\n    c = vector<int>(V);\n    int sz = scc.size();\n    for (int i = 0; i < sz; i++){\n      for (int j : scc[i]){\n        c[j] = i;\n      }\n    }\n  }\n  int size(){\n    return scc.size();\n  }\n  int operator [](int k){\n    return c[k];\n  }\n};\nint main(){\n  cout << fixed << setprecision(9);\n  while (1){\n    int N;\n    cin >> N;\n    if (N == 0){\n      break;\n    }\n    vector<double> p(N);\n    vector<vector<int>> E(N);\n    for (int i = 0; i < N; i++){\n      cin >> p[i];\n      int m;\n      cin >> m;\n      for (int j = 0; j < m; j++){\n        int a;\n        cin >> a;\n        a--;\n        E[i].push_back(a);\n      }\n    }\n    strongly_connected_components S(E);\n    int sz = S.size();\n    vector<bool> ok(sz, false);\n    vector<double> q(sz, 1);\n    for (int i = 0; i < N; i++){\n      for (int j : E[i]){\n        if (S[i] != S[j]){\n          ok[S[j]] = true;\n        }\n      }\n      q[S[i]] *= p[i];\n    }\n    double ans = 1;\n    for (int i = 0; i < sz; i++){\n      if (!ok[i]){\n        ans *= 1 - q[i];\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int>> G(110);\nbool used[110];\nint incnt[110];\ndouble nebou[110];\n\nvoid dfs(int p){\n    int vs = G[p].size();\n    int i;\n    for(i = 0; i < vs;i++){\n        if(used[G[p][i]]) continue;\n        used[G[p][i]] = 1;\n        dfs(G[p][i]);\n    }\n    return;\n}\n\ndouble dfs_heiro(int p,double ret){\n    ret *= nebou[p];\n    int vs = G[p].size();\n    int i;\n    for(i = 0; i < vs; i++) {\n        if(used[G[p][i]]) continue;\n        used[G[p][i]] = 1;\n        ret *= dfs_heiro(G[p][i], 1.0);\n    }\n    return ret;\n}\n\nint main() {\n    int N,i,j,k;\n    while(cin >> N,N){\n        for(i = 0; i < 110;i++){\n            G[i].clear();\n            used[i] = 0;\n            nebou[i] = 0.0;\n            incnt[i] = 0;\n        }\n        double ret = 1.0;\n        for(i = 1; i <= N; i++) {\n            cin >> nebou[i];\n            cin >> j;\n            for(k = 0; k < j;k++){\n                int to;\n                cin >> to;\n                G[i].push_back(to);\n                incnt[to]++;\n            }\n        }\n        for(i = 1; i <= N;i++){\n            if(incnt[i]==0){\n                used[i] = 1;\n                ret *= (1.0 - nebou[i]);\n                dfs(i);\n            }\n        }\n        for(i = 1; i <= N;i++){\n            int vs = G[i].size();\n            if(used[i] == 0 && vs==0){\n                used[i] = 1;\n            }\n        }\n        for(i = 1; i <= N;i++){\n            if(used[i]==0){\n                used[i] = 1;\n                ret *= (1.0-dfs_heiro(i, 1.0));\n            }\n        }\n        printf(\"%.8f\\n\", ret);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct SCC{\n    int V;\n    vector<vector<int>> G, rG;\n    vector<int> vs; // 帰りがけ順の並び\n    vector<int> cmp; //属する強連結成分トポロジカル順序\n    vector<bool> used;\n\n    SCC(){}\n    SCC(int n){\n        V = n;\n        G = vector<vector<int>>(n);\n        rG = vector<vector<int>>(n);\n    }\n\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n\n    void dfs(int v){\n        used[v] = true;\n        rep(i,G[v].size())if(!used[G[v][i]]) dfs(G[v][i]);\n        vs.push_back(v);\n    }\n\n    void rdfs(int v, int k){\n        used[v]=true;\n        cmp[v]=k;\n        rep(i,rG[v].size())if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n    }\n\n    int scc(){\n        used = vector<bool>(V,false);\n        vs.clear();\n        rep(i,V)if(!used[i]) dfs(i);\n\n        used = vector<bool>(V,false);\n        cmp = vector<int>(V);\n        int num_scc = 0;\n        for(int i=vs.size()-1; i>=0; --i)if(!used[vs[i]]) rdfs(vs[i],num_scc++);\n        return num_scc;\n    }\n};\n\nint main(){\n    int n;\n    while(scanf(\" %d\", &n),n){\n        vector<double> p(n);\n        SCC s(n);\n\n        rep(i,n){\n            scanf(\" %lf\", &p[i]);\n\n            int m;\n            scanf(\" %d\", &m);\n            rep(j,m){\n                int a;\n                scanf(\" %d\", &a);\n                --a;\n                s.add_edge(i,a);\n            }\n        }\n\n        int sz = s.scc();\n\n        vector<vector<int>> cc(sz);\n        vector<bool> have_inedge(sz,false);\n        rep(i,n){\n            cc[s.cmp[i]].pb(i);\n            for(int e:s.G[i]){\n                int v = s.cmp[e];\n                if(s.cmp[i] != v) have_inedge[v] = true;\n            }\n        }\n\n        double ans = 1;\n        rep(i,sz)if(!have_inedge[i]){\n            // グループ内の誰か一人が起きる\n            double all_sleep = 1;\n            for(int j:cc[i]) all_sleep *= p[j];\n            ans *= (1 - all_sleep);\n        }\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nstruct Edge { int from, to; };\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to) {\n\tg[from].push_back(Edge{ from, to });\n}\n\nvoid dfs(const Graph& g, int v, vector<bool>& used, vi& vs)\n{\n\tused[v] = true;\n\tfor (auto i : g[v])\n\t{\n\t\tif (!used[i.to]) dfs(g, i.to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(const Graph& rg, int v, vector<bool>& used, int k, vi& cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (auto i : rg[v])\n\t{\n\t\tif (!used[i.to]) rdfs(rg, i.to, used, k, cmp);\n\t}\n}\n\nint strongly_connected_component(Graph graph, vi& cmp)\n{\n\tint V = graph.size();\n\tGraph g(V), rg(V);\n\tvector<bool> used(V);\n\tvi vs;\n\tcmp.resize(V);\n\tREP(i, V)\n\t{\n\t\tfor (auto e : graph[i])\n\t\t{\n\t\t\tadd_edge(g, i, e.to);\n\t\t\tadd_edge(rg, e.to, i);\n\t\t}\n\t}\n\tREP(i, V)\n\t{\n\t\tif (!used[i]) dfs(g, i, used, vs);\n\t}\n\tused = vector<bool>(V);\n\treverse(ALL(vs));\n\tint k = 0;\n\tfor (auto i : vs)\n\t{\n\t\tif (!used[i]) rdfs(rg, i, used, k++, cmp);\n\t}\n\treturn k;\n}\n\nGraph buildGraph(const Graph& g, const vi& cmp, int K)\n{\n\tint V = g.size();\n\tvector<set<int>> s(K);\n\tGraph res(K);\n\tREP(i, V)\n\t{\n\t\tfor (auto e : g[i]) s[cmp[i]].insert(cmp[e.to]);\n\t}\n\tREP(i, K)\n\t{\n\t\tfor (auto j : s[i]) if (i != j) add_edge(res, i, j);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<ld> p(n);\n\t\tGraph g(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tcin >> p[i];\n\t\t\tint m; cin >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tint a; cin >> a; a--;\n\t\t\t\tadd_edge(g, i, a);\n\t\t\t}\n\t\t}\n\t\tvi cmp;\n\t\tint k = strongly_connected_component(g, cmp);\n\t\tGraph dag = buildGraph(g, cmp, k);\n\t\tset<int> src;\n\t\tREP(i, k) src.insert(i);\n\t\tREP(i, k)\n\t\t{\n\t\t\tfor (auto e : dag[i])\n\t\t\t{\n\t\t\t\tint u = e.to;\n\t\t\t\tif (src.count(u)) src.erase(u);\n\t\t\t}\n\t\t}\n\t\tld ans = 1.0;\n\t\tREP(i, k)\n\t\t{\n\t\t\tif (src.count(i))\n\t\t\t{\n\t\t\t\tld tmp = 1.0;\n\t\t\t\tREP(j, n)\n\t\t\t\t{\n\t\t\t\t\tif (cmp[j] == i)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp *= p[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans *= 1 - tmp;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Edge {\n\tint src, dst;\n\tEdge() : src(0), dst(0) {}\n\tEdge(int s, int d) : src(s), dst(d) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\n\nvector<int> SCC(const Graph &g) {\n\tint n = g.size(), sz = 0; Graph rg(n);\n\tvector<int> stk, cmp(n, -1), added(n), visited(n), ord(n);\n\tfor(auto &es : g) {\n\t\tsz += es.size();\n\t\tfor(const Edge &e : es) rg[e.dst].emplace_back(e.dst, e.src);\n\t}\n\tstk.resize(n + sz); sz = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(visited[i]) continue;\n\t\tint s = 0; stk[s++] = i;\n\t\twhile(s != 0) {\n\t\t\tint v = stk[s - 1]; visited[v] = true;\n\t\t\tbool pushed = false;\n\t\t\tfor(auto &e : g[v]) {\n\t\t\t\tint dst = e.dst;\n\t\t\t\tif(!visited[dst]) { stk[s++] = dst; pushed = true; }\n\t\t\t}\n\t\t\tif(pushed) continue;\n\t\t\tint t = stk[s - 1];\n\t\t\tif(!added[t]) { added[t] = true; ord[n - ++sz] = t; }\n\t\t\t--s;\n\t\t}\n\t}\n\tint k = 0;\n\tfor(int &u : ord) {\n\t\tif(cmp[u] != -1) continue;\n\t\tint s = 0; stk[s++] = u;\n\t\twhile(s != 0) {\n\t\t\tint v = stk[--s]; cmp[v] = k;\n\t\t\tfor(auto &e : rg[v]) {\n\t\t\t\tint d = e.dst;\n\t\t\t\tif(cmp[d] == -1) stk[s++] = d;\n\t\t\t}\n\t\t}\n\t\t++k;\n\t}\n\treturn cmp;\n}\n\n\ndouble pr[100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tGraph G(N);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> pr[i];\n\t\t\tint m, x;\n\t\t\tcin >> m;\n\t\t\twhile(m--) {\n\t\t\t\tcin >> x;\n\t\t\t\tx--;\n\t\t\t\tG[i].push_back({ i ,x });\n\t\t\t}\n\t\t}\n\t\tauto scc = SCC(G);\n\n\t\tint V = *max_element(scc.begin(), scc.end()) + 1;\n\t\tvector<vector<int>> vs(V);\n\t\tvector<int> deg(V);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tvs[scc[i]].push_back(i);\n\t\t\tfor(auto e : G[i]) {\n\t\t\t\tif(scc[i] != scc[e.dst]) {\n\t\t\t\t\tdeg[scc[e.dst]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = 1.0;\n\t\tfor(int i = 0; i < V; i++) {\n\t\t\tif(deg[i] > 0) continue;\n\t\t\tdouble all_sleep = 1.0;\n\t\t\tfor(auto v : vs[i]) {\n\t\t\t\tall_sleep *= pr[v];\n\t\t\t}\n\t\t\tans *= 1.0 - all_sleep;\n\t\t}\n\n\t\tcout << fixed << setprecision(15) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld EPS = 1e-9;\n\nstruct StronglyConnectedComponents {\n    vector<vector<int>> g, rg, t;\n    vector<int> comp, ord, used;\n\n    StronglyConnectedComponents(const vector<vector<int>>& g) :\n            g(g), rg(g.size()), comp(g.size(), -1), used(g.size())\n    {\n        for (int i = 0; i < g.size(); ++i) {\n            for (int to : g[i]) {\n                rg[to].push_back(i);\n            }\n        }\n    }\n\n    void dfs(int idx) {\n        if (used[idx]) return;\n        used[idx] = true;\n        for (int to : g[idx]) dfs(to);\n        ord.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt) {\n        if (comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for (int to : rg[idx]) rdfs(to, cnt);\n    }\n\n    void build() {\n        for (int i = 0; i < g.size(); ++i) dfs(i);\n        reverse(ord.begin(), ord.end());\n        int ptr = 0;\n        for (int i : ord) if (comp[i] == -1) rdfs(i, ptr), ptr++;\n\n        t.resize(ptr);\n        for (int i = 0; i < g.size(); ++i) {\n            for (int to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if (x == y) continue;\n                t[x].push_back(y);\n            }\n        }\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vvi G(n);\n        vector<double> p(n);\n        REP(i, n) {\n            cin >> p[i];\n            int m; cin >> m;\n            REP(j, m) {\n                int a; cin >> a; --a;\n                G[i].push_back(a);\n            }\n        }\n\n        StronglyConnectedComponents scc(G);\n        scc.build();\n\n        vi deg(SZ(scc.t));\n        REP(i, SZ(scc.t)) {\n            for (int u : scc.t[i]) {\n                ++deg[u];\n            }\n        }\n        vector<double> q(SZ(scc.t), 1.0);\n        REP(i, n) q[scc.comp[i]] *= p[i];\n\n        double ans = 1.0;\n        REP(i, SZ(scc.t)) {\n            if (deg[i] == 0) {\n                ans *= (1.0 - q[i]);\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\n\ntypedef vector<vector<int>> UnWeightedGraph;\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n  const G &g;\n  UnWeightedGraph gg, rg;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n    for(int i = 0; i < g.size(); i++) {\n      for(auto e : g[i]) {\n        gg[i].emplace_back((int) e);\n        rg[(int) e].emplace_back(i);\n      }\n    }\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(UnWeightedGraph &t) {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      for(auto &to : g[i]) {\n        int x = comp[i], y = comp[to];\n        if(x == y) continue;\n        t[x].push_back(y);\n      }\n    }\n  }\n};\n\nint N;\ndouble p[105];\n\nbool visited[105];\nvector<int> Nodes[105];\ndouble ans;\nvoid solve() {\n    ans = 1;\n    UnWeightedGraph g(N), t;\n    for(int i = 0; i < N; i++) {\n        visited[i] = false;\n        Nodes[i].clear();\n        cin >> p[i];\n        int m;\n        cin >> m;\n        while(m--) {\n            int a;\n            cin >> a;\n            a--;\n            g[i].push_back(a);\n        }\n    }\n    StronglyConnectedComponents<UnWeightedGraph> SCC(g);\n    SCC.build(t);\n    for(int i = 0; i < N; i++) {\n        Nodes[SCC[i]].push_back(i);\n    }\n    for(int i = 0; i < t.size(); i++) {\n        for(auto to : t[i]) {\n            visited[to] = true;\n        }\n        if(visited[i]) continue;\n        double now = 1;\n        for(auto person : Nodes[i]) {\n            now *= p[person];\n        }\n        ans *= 1 - now;\n    }\n    cout << fixed << setprecision(10) << ans << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> N;\n        if(N == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define All(A) A.begin(),A.end()\n#define RAll(A) A.rbegin(),A.rend()\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<30;\n\ndouble p[101],P[101];\n\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n    const G &g;\n    G gg, rg;\n    vector< int > comp, order, used;\n\n    StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n        for(int i = 0; i < g.size(); i++) {\n            for(auto e : g[i]) {\n                gg[i].emplace_back((int) e);\n                rg[(int) e].emplace_back(i);\n            }\n        }\n    }\n\n    int operator[](int k) {\n        return (comp[k]);\n    }\n\n    void dfs(int idx) {\n        if(used[idx]) return;\n        used[idx] = true;\n        for(int to : gg[idx]) dfs(to);\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt) {\n        if(comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for(int to : rg[idx]) rdfs(to, cnt);\n    }\n\n    void build(G &t) {\n        for(int i = 0; i < gg.size(); i++) dfs(i);\n        reverse(begin(order), end(order));\n        int ptr = 0;\n        for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n        t.resize(ptr);\n        for(int i=0;i<g.size();i++) P[i]=1;\n        for(int i=0;i<g.size();i++) P[comp[i]]*=p[i];\n        for(int i = 0; i < g.size(); i++) {\n            for(auto &to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if(x == y) continue;\n                t[x].push_back(y);\n            }\n        }\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) break;\n        vector<vector<int>> G(N);\n        for(int i=0;i<N;i++){\n            int m;\n            cin >> p[i] >> m;\n            for(int j=0;j<m;j++){\n                int u;\n                cin >> u;\n                u--;\n                G[i].eb(u);\n            }\n        }\n        StronglyConnectedComponents<vector<vector<int>>> scc(G);\n        vector<vector<int>> h;\n        scc.build(h);\n        vector<int> s(N,0);\n        for(int i=0;i<h.size();i++){\n            for(int j=0;j<h[i].size();j++){\n                s[h[i][j]]++;\n            }\n        }\n        double ans=1.0;\n        for(int i=0;i<h.size();i++){\n            if(!s[i]){\n                ans*=1-P[i];\n            }\n        }\n        cout <<setprecision(20)<<ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define All(A) A.begin(),A.end()\n#define RAll(A) A.rbegin(),A.rend()\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<30;\n\ndouble p[101],P[101];\n\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n    const G &g;\n    G gg, rg;\n    vector< int > comp, order, used;\n\n    StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n        for(int i = 0; i < g.size(); i++) {\n            for(auto e : g[i]) {\n                gg[i].emplace_back((int) e);\n                rg[(int) e].emplace_back(i);\n            }\n        }\n    }\n\n    int operator[](int k) {\n        return (comp[k]);\n    }\n\n    void dfs(int idx) {\n        if(used[idx]) return;\n        used[idx] = true;\n        for(int to : gg[idx]) dfs(to);\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt) {\n        if(comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for(int to : rg[idx]) rdfs(to, cnt);\n    }\n\n    void build(G &t) {\n        for(int i = 0; i < gg.size(); i++) dfs(i);\n        reverse(begin(order), end(order));\n        int ptr = 0;\n        for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n        t.resize(ptr);\n        for(int i=0;i<g.size();i++) P[i]=1;\n        for(int i=0;i<g.size();i++) P[comp[i]]*=p[i];\n        for(int i = 0; i < g.size(); i++) {\n            for(auto &to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if(x == y) continue;\n                t[x].push_back(y);\n            }\n        }\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) break;\n        vector<vector<int>> G(N);\n        for(int i=0;i<N;i++){\n            int m;\n            cin >> p[i] >> m;\n            for(int j=0;j<m;j++){\n                int u;\n                cin >> u;\n                u--;\n                G[i].eb(u);\n            }\n        }\n        StronglyConnectedComponents<vector<vector<int>>> scc(G);\n        vector<vector<int>> h;\n        scc.build(h);\n        vector<int> s(N,0);\n        for(int i=0;i<h.size();i++){\n            for(int j=0;j<h[i].size();j++){\n                s[h[i][j]]++;\n            }\n        }\n        double ans=1;\n        for(int i=0;i<h.size();i++){\n            if(!s[i]){\n                ans*=1-P[i];\n            }\n        }\n        cout <<setprecision(30)<<ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(X,Y) for(int X=0;X<(Y); ++X)\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD=1e9+7;\n\nint d[111][111];\n\nstruct UF{\n  vector<int> data;\n  UF(int size):data(size,-1){}\n  bool unite(int x,int y){\n    x=root(x); y=root(y);\n    if(x!=y){\n      if(data[y]<data[x]) swap(x,y);\n      data[x]+=data[y]; data[y]=x;\n    }\n    return x!=y;\n  }\n  bool findSet(int x,int y){return root(x)==root(y);}\n  int root(int x){return data[x]<0?x:data[x]=root(data[x]);}\n  int size(int x){return -data[root(x)];}\n};\n\nint main(){\n  cout<<fixed<<setprecision(10);\n  int n;\n  while(cin>>n,n){\n    fill(d[0],d[111],MOD);\n    vector<double> p(n);\n    rep(i,n){\n      int t;\n      cin>>p[i]>>t;\n      rep(_,t){\n\tint x;\n\tcin>>x; --x;\n\td[i][x]=1;\n      }\n    }\n    rep(i,n) d[i][i]=0;\n    rep(k,n)rep(i,n)rep(j,n) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    //rep(i,n){rep(j,n) cout<<d[i][j]<<\",\";cout<<endl;}\n    UF uf(n);\n    rep(i,n)rep(j,n)if(d[i][j]<MOD && d[j][i]<MOD) uf.unite(i,j);\n    vector<double> over(n,1);\n    vector<int> ind(n);\n    rep(i,n){\n      over[uf.root(i)]*=p[i];\n      if(uf.root(i)==i)\n\trep(j,n)if(i!=j && d[i][j]<MOD) ++ind[j];\n    }\n    double re=1;\n    rep(i,n)if(uf.root(i)==i && ind[i]==0) re*=1-over[i];\n    cout<<re<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// テァツァツサテ・ツ仰陛・ツ?ε」ツ?ィティツ。ツ古・ツ?暗」ツ?ィティツセツコテ」ツ?ョテ」ツつウテ」ツつケテ」ツδ暗」ツつ津ィツィツ佚ゥツ個イテ」ツ?凖」ツつ凝ヲツァツ凝ゥツ??、ツスツ?\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\ntemplate <typename T>\nstruct GraphSCC {\npublic:\n    const int n;\n    vector<bool> isthrough;\n    vector<int> vs, cmp;\n    vector< vector< Edge<T> > > G, rG;\n    vector< vector<int> > H;\n\n    GraphSCC(vector< vector< Edge<T> > > &_G) :\n        n(_G.size()), isthrough(n, false), cmp(n, 0), G(_G), rG(n) {\n            // テゥツ??ィツセツコテ」ツつーテ」ツδゥテ」ツδ?\n            for(int i=0; i<n; i++) for(int j=0; j<G[i].size(); j++)\n                rG[ G[i][j].to ].push_back(Edge<T>(i, G[i][j].cost));\n        }\n\n    void SCC_dfsone(int cur) {\n        isthrough[cur] = true;\n        for(int i=0; i<G[cur].size(); i++) {\n            if(!isthrough[G[cur][i].to]) {\n                SCC_dfsone(G[cur][i].to);\n            }\n        }\n        vs.push_back(cur);\n    }\n\n    void SCC_dfstwo(vector<int> &vec, int cur, int k) {\n        cmp[cur] = k;\n        isthrough[cur] = true;\n        vec.push_back(cur);\n        for(int i=0; i<rG[cur].size(); i++) {\n            if(!isthrough[rG[cur][i].to]) {\n                SCC_dfstwo(vec, rG[cur][i].to, k);\n            }\n        }\n    }\n\n    pair<vector<int>, int> scc() {\n        // 1テ・ツ崢榲」ツつ?」ツ?ョDFS\n        for(int i=0; i<n; i++)\n            if(!isthrough[i]) SCC_dfsone(i);\n\n        fill(isthrough.begin(), isthrough.end(), false);\n        reverse(vs.begin(), vs.end());\n        int k = 0; vector< vector<int> > S;\n\n        // 2テ・ツ崢榲」ツつ?」ツ?ョDFS\n        for(int i=0; i<vs.size(); i++) {\n            if(!isthrough[vs[i]]) {\n                S.push_back(vector<int>());\n                SCC_dfstwo(S.back(), vs[i], k++);\n            }\n        }\n\n        H.resize(k);\n        fill(isthrough.begin(), isthrough.end(), false);\n        for(int i=0; i<k; i++) {\n            for(int j=0; j<S[i].size(); j++) {\n                int v = S[i][j];\n                for(int x=0; x<G[v].size(); x++) {\n                    int u = G[v][x].to;\n                    if(isthrough[cmp[u]] || cmp[v] == cmp[u]) continue;\n                    isthrough[cmp[u]] = true;\n                    H[cmp[v]].push_back(cmp[u]);\n                }\n            }\n            for(int j=0; j<H[i].size(); j++) isthrough[ H[i][j] ] = false;\n        }\n        return make_pair(cmp, k);\n    }\n};\n\nint N, M, deg[110];\ndouble p[110];\n\nsigned main() {\n    while(cin >> N, N) {\n        memset(deg, 0, sizeof(deg));\n        Graph<int> G(N);\n        rep(i,0,N) {\n            cin >> p[i] >> M;\n            rep(j,0,M) {\n                int v; cin >> v; v--;\n                G[i].push_back(Edge<int>(v, 1));\n            }\n        }\n\n        GraphSCC<int> gs(G);\n        // SCC テ・ツセツ古」ツ?ォテ」ツ?ゥテ」ツ?ョテゥツ?づァツつケテ」ツ?ォテ・ツアツ榲」ツ?凖」ツつ凝」ツ?凝」ツ?ヾCC テ・ツセツ古」ツ?ョテゥツ?づァツつケテヲツ閉ー\n        pair< vector<int>, int > res = gs.scc();\n\n        // テ・ツ?・テヲツャツ。テヲツ閉ーテ」ツつ津ィツィツ暗ァツョツ?\n        rep(i,0,res.second) for(auto x : gs.H[i]) deg[x]++;\n        double ans = 1.0;\n        rep(i,0,res.second) {\n            // テ・ツ?・テヲツャツ。テヲツ閉ー 0 テ」ツ?ョテ」ツつづ」ツ?ョテ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲティツィツ暗ァツョツ?\n            if(deg[i]) continue;\n            // printf(\"zero degree: node %lld\\n\", i);\n            double temp = 1.0;\n            rep(j,0,N) {\n                // テ・ツ青古」ツ?佚ゥツ?」テァツオツ静ヲツ按静・ツ按?」ツ?ォテ・ツアツ榲」ツ?凖」ツつ凝・ツ?エテ・ツ青暗」ツ?ッテヲツ篠崚」ツ?妥」ツつ?\n                if(res.first[j] == i) {\n                    // printf(\"same: %lld\\n\", j+1);\n                    temp *= p[j];\n                }\n            }\n            ans *= (1 - temp);\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX_V 1000\nint V,cmp[MAX_V];\nvector<int> G[MAX_V],rG[MAX_V],vs,a,xx;\nint used[MAX_V];\nvoid addedge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n} \nvoid dfs(int v){\n  used[v]=1;\n  for(int i=0;i<G[v].size();i++)\n    if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\nvoid rdfs(int v,int k){\n  used[v]=1;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n}\nvoid dfs2(int v,int k){\n  used[v]=k;\n  for(int i=0;i<G[v].size();i++)\n    if(!used[G[v][i]])dfs(G[v][i]);\n  xx.push_back(v);\n}\nint scc(){\n  int pp=0;\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)\n    if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=1;\n  for(int i=vs.size()-1;i>=0;i--)\n    if(!used[vs[i]]){\n      rdfs(vs[i],k++);\n    }\n  k=1;\n  map<int,int>m;\n  memset(used,0,sizeof(used));\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]]){\n      dfs(vs[i]);\n      r(j,xx.size())if(used[xx[j]]!=k){\n        m[used[xx[j]]]=0;\n      }\n      m[vs[i]]=cmp[vs[i]];\n      k++;\n    }\n  }\n  r(i,V)if(m[i])\n    a.push_back(m[i]);\n  return k;\n}\nint main(){\n  int x,y;\n  while(cin>>V,V){\n    double d[V],ans=0;\n    a.clear();\n    r(i,1000)G[i].clear(),rG[i].clear();\n    r(i,V){\n      cin>>d[i]>>x;\n      r(j,x){\n        cin>>y;\n        addedge(i,y-1);\n      }\n    }\n    scc();\n    int cnt=0;\n    r(i,a.size()){\n      double p=0;\n      int c=0;\n      r(j,V)if(cmp[j]==a[i]){\n        if(!c++)p+=d[j];\n        else p*=d[j];\n      }\n      if(!cnt++)ans+=(1.0-p);\n      else ans*=(1.0-p);\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//夏合宿の朝は早い\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define MAX_V 500\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nvector<int> vG[MAX_V];\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid add_edge(int from, int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n    used[v] = true;\n    for(int i = 0; i < (int)G[v].size(); i++){\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n    used[v] = true;\n    cmp[v] = k;\n    vG[k].push_back(v);\n    for(int i = 0; i < (int)rG[v].size(); i++){\n        if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\n\nint scc(){\n    memset(used, false, sizeof(used));\n    vs.clear();\n    for(int v = 0; v < V; v++){\n        if(!used[v]) dfs(v);\n    }\n    memset(used, false, sizeof(used));\n    int k = 0;\n    for(int i = V - 1; i >= 0; i--){\n        if(!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    return k;\n}\n\nint main(){\n\n    while(cin >> V, V){\n\n        //初期化\n        for(int i = 0; i < MAX_V; i++){\n            G[i].clear();\n            rG[i].clear();\n            vG[i].clear();            \n        }\n\n        //入力受け取り\n        vector<double> p(V);\n        for(int i = 0; i < V; i++){\n            int m;\n            cin >> p[i] >> m;\n            for(int j = 0; j < m; j++){\n                int to; cin >> to; to--;\n                add_edge(i, to);\n            }\n        }\n\n        int k = scc();\n\n        double ans = 0.0;\n        for(int i = 0; i < k; i++){\n            bool flag = true;              //入次数が0であるか\n            double res = 0.0;\n\n            //強連結成分をすべてなめる\n            for(int j = 0; j < (int)vG[i].size(); j++){\n                res *= p[vG[i][j]];\n\n                //その頂点は入り次数0ですか？(逆辺をすべてなめる)\n                for(int l = 0; l < (int)rG[vG[i][j]].size(); l++){\n                    flag &= (cmp[vG[i][j]] == cmp[rG[vG[i][j]][l]]);\n                }\n\n                if(flag) ans *= (1.0 - res);\n            }\n        }\n\n        printf(\"%.10lf\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct edge{ int to; };\nvector<edge> G[100];\n\nint v, e;\n#define maxV 100\nvector<edge> sccrG[maxV];\nbool sccused[maxV] = {false};\nint sccr[maxV], sccrhd;\nint scctopo[maxV];\n\nvoid sccdfs(int now){\n  sccused[now] = true;\n  for(int i = 0;i < G[now].size();++i)if(!sccused[G[now][i].to])sccdfs(G[now][i].to);\n  sccr[sccrhd++] = now;\n  return;\n}\nvoid sccrdfs(int now, int num){\n  sccused[now] = true;\n  scctopo[now] = num;\n  for(int i = 0;i < sccrG[now].size();++i)if(!sccused[sccrG[now][i].to])sccrdfs(sccrG[now][i].to, num);\n  return;\n}\nvoid scc(void){\n  for(int i = 0;i < v;++i)for(int j = 0;j < G[i].size();++j)sccrG[G[i][j].to].push_back((edge){i});\n  for(int i = 0;i < v;++i)sccused[i] = false;\n  sccrhd = 0;\n  for(int i = 0;i < v;++i)if(!sccused[i])sccdfs(i);\n\n  int num = 0;\n  for(int i = 0;i < v;++i)sccused[i] = false;\n  for(;sccrhd--;)if(!sccused[sccr[sccrhd]])sccrdfs(sccr[sccrhd], num++);\n  for(int i = 0;i < v;++i)sccrG[i].clear();\n  return;\n}\n\ndouble p[100];\nint ord[100] = {0};\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    if(!n)break;\n    v = n;\n    rep(i, n){\n      int m;\n      cin >> p[i] >> m;\n      G[i].resize(m);\n      rep(j, m){\n        int(a); --a;\n        G[i][j] = (edge){a};\n      }\n    }\n\n    scc();\n\n    double res = 1.0;\n    rep(i, n)ord[i] = 0;\n    rep(i, n)ord[scctopo[i]] = 1;\n    rep(i, n)rep(j, G[i].size()){\n      if(scctopo[G[i][j].to] != scctopo[i])\n      ++ord[scctopo[G[i][j].to]];\n    }\n\n    rep(i, n)if(ord[i] == 1){\n      double tmp = 1.0;\n      rep(j, n)if(scctopo[j] == i)tmp *= p[j];\n      res *= 1.0 - tmp;\n    }\n\n    prid(res);\n\n    rep(i, n)G[i].clear();\n\n//*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = long double;\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vector<R> p(n);\n        vector<vi> a(n);\n        vector<vi> adj(n, vi(n));\n        rep(i, n){\n            cin >> p[i];\n            int m; cin >> m;\n            a[i] = vi(m); for(auto& e : a[i]) cin >> e, e--, adj[i][e] = true;\n        }\n\n        vector<vi> cango(n, vi(n));\n        rep(i, n){\n            cango[i][i] = true;\n            for(auto& j : a[i]){\n                cango[i][j] = true;\n            }\n        }\n        rep(k, n) rep(i, n) rep(j, n) cango[i][j] |= (cango[i][k] & cango[k][j]);\n\n        int m = 0;\n        vi group(n, -1);\n        rep(i, n){\n            if(group[i] != -1) continue;\n            rep(j, i, n){\n                if(cango[i][j] && cango[j][i]){\n                    assert(group[j] == -1);\n                    group[j] = m;\n                }\n            }\n            m++;\n        }\n\n        vector<set<int>> edge(m);\n        rep(i, n){\n            rep(j, n){\n                if(group[i] == group[j]) continue;\n                if(adj[i][j]){\n                    edge[group[j]].insert(group[i]);\n                }\n            }\n        }\n\n        vector<R> q(m, 1.0);\n        rep(i, n){\n            q[group[i]] *= p[i];\n        }\n\n        R res = 1.0;\n        rep(i, m){\n            if(edge[i].size() >= 1) continue;\n            res *= (1.0 - q[i]);\n        }\n\n        cout.precision(20);\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid dfs(int node, vector<int> &ord, vector<bool> &used, vector<vector<int> > &adj){\n\tif(used[node]) return;\n\tused[node] = true;\n\tfor(int to: adj[node]){\n\t\tdfs(to, ord, used, adj);\n\t}\n\tord.push_back(node);\n}\n\nvector<vector<int> > scc_decomposition(vector<vector<int> > &adj){\n\tint n = adj.size();\n\tvector<vector<int> > revadj(n);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int to: adj[i]){\n\t\t\trevadj[to].push_back(i);\n\t\t}\n\t}\n\t\n\tvector<bool> used(n, false);\n\tvector<int> ord;\n\tfor(int i=0; i<n; i++){\n\t\tif(used[i]) continue;\n\t\tdfs(i, ord, used, adj);\n\t}\n\tused = vector<bool>(n, false);\n\tvector<vector<int> > res;\n\tfor(int i=n-1; i>=0; i--){\n\t\tif(used[ord[i]]) continue;\n\t\tres.emplace_back();\n\t\tdfs(ord[i], res.back(), used, revadj);\n\t\tsort(res.back().begin(), res.back().end());\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<double> wake(n);\n\t\tvector<vector<int> > adj(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> wake[i];\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tadj[i].resize(k);\n\t\t\tfor(int j=0; j<k; j++){\n\t\t\t\tcin >> adj[i][j];\n\t\t\t\tadj[i][j]--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<vector<int> > scc = scc_decomposition(adj);\n\t\tvector<vector<int> > revadj(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int to: adj[i]){\n\t\t\t\trevadj[to].push_back(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble ans = 1;\n\t\tint m = scc.size();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tbool root = true;\n\t\t\tfor(int v: scc[i]){\n\t\t\t\tfor(int s: revadj[v]){\n\t\t\t\t\tauto f = lower_bound(scc[i].begin(), scc[i].end(), s);\n\t\t\t\t\tif(f == scc[i].end() || *f != s){\n\t\t\t\t\t\troot = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!root) continue;\n\t\t\tdouble w = 1;\n\t\t\tfor(int v: scc[i]) w *= wake[v];\n\t\t\tans *= 1-w;\n\t\t}\n\t\tcout << fixed;\n\t\tcout << setprecision(10);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <functional>\nusing namespace std;\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<double> p(N);\n\t\tvector<vector<int> > g(N), rg(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint l;\n\t\t\tcin >> p[i] >> l;\n\t\t\tfor (int j = 0; j < l; ++j) {\n\t\t\t\tint u;\n\t\t\t\tcin >> u; --u;\n\t\t\t\tg[i].push_back(u);\n\t\t\t\trg[u].push_back(i);\n\t\t\t}\n\t\t}\n\t\tvector<bool> vis(N);\n\t\tvector<int> ord(N, -1), invord(N, -1);\n\t\tint cnt = 0;\n\t\tfunction<void(int)> dfs1 = [&](int pos) {\n\t\t\tvis[pos] = true;\n\t\t\tfor (int i : g[pos]) {\n\t\t\t\tif (!vis[i]) dfs1(i);\n\t\t\t}\n\t\t\tord[pos] = cnt;\n\t\t\tinvord[cnt] = pos;\n\t\t\t++cnt;\n\t\t};\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (ord[i] == -1) {\n\t\t\t\tdfs1(i);\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tvector<int> col(N, -1);\n\t\tvector<int> vlist;\n\t\tfunction<bool(int)> dfs2 = [&](int pos) {\n\t\t\tcol[pos] = cnt;\n\t\t\tvlist.push_back(pos);\n\t\t\tbool ans = true;\n\t\t\tfor (int i : rg[pos]) {\n\t\t\t\tif (col[i] == -1) ans = ans && dfs2(i);\n\t\t\t\telse if (col[i] != cnt) ans = false;\n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\tdouble ans = 1.0;\n\t\tfor (int i = N - 1; i >= 0; --i) {\n\t\t\tif (col[invord[i]] != -1) continue;\n\t\t\tvlist.clear();\n\t\t\tbool res = dfs2(invord[i]);\n\t\t\tif (res) {\n\t\t\t\tdouble mul = 1.0;\n\t\t\t\tfor (int j : vlist) mul *= p[j];\n\t\t\t\tans *= 1.0 - mul;\n\t\t\t}\n\t\t\t++cnt;\n\t\t}\n\t\tcout.precision(15);\n\t\tcout << fixed << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct st {\n\tdouble late;\n\tvector<int> call;\n};\nvector<st> mem;\nmap<int, int> mpii;\nvb called;\nint cnt;\n\ndouble heiro(int first, int idx) {\n\tdouble ret = mem[idx].late;\n\tcalled[idx] = false;\n\tREP(i, mem[idx].call.size()) {\n\t\tif (called[mem[idx].call[i]]) {\n\t\t\tret *= heiro(first, mem[idx].call[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tmem.clear();\n\t\tmem.resize(n);\n\t\tmpii.clear();\n\t\tcalled.resize(n, false);\n\t\tREP(i, n) {\n\t\t\tint m;\n\t\t\tcin >> mem[i].late >> m;\n\t\t\tmem[i].call.resize(m);\n\t\t\tREP(j, m) {\n\t\t\t\tcin >> mem[i].call[j];\n\t\t\t\tmem[i].call[j]--;\n\t\t\t\tcalled[mem[i].call[j]] = true;\n\t\t\t}\n\t\t\tmpii[i] = i;\n\t\t}\n\t\tdouble ans = 1.0;\n\t\tqueue<int> Q;\n\t\tREP(i, n)\n\t\t\tif (called[i] == false) {\n\t\t\t\tans *= (1.0 - mem[i].late);\n\t\t\t\tREP(j, mem[i].call.size())\n\t\t\t\t\tQ.push(mem[i].call[j]);\n\t\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tint q = Q.front();Q.pop();\n\t\t\tcalled[q] = false;\n\t\t\tREP(i, mem[q].call.size())\n\t\t\t\tif (called[mem[q].call[i]])\n\t\t\t\t\tQ.push(mem[q].call[i]);\n\t\t}\n\t\tbool henka;\n\t\tdo {\n\t\t\thenka = false;\n\t\t\tREP(i, n) {\n\t\t\t\tif (!called[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tbool pass = true;\n\t\t\t\tREP(j, mem[i].call.size())\n\t\t\t\t\tif (called[mem[i].call[j]])\n\t\t\t\t\t\tpass = false;\n\t\t\t\tif (pass) {\n\t\t\t\t\tcalled[i] = false;\n\t\t\t\t\thenka = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (henka);\n\t\t\tREP(i, n) {\n\t\t\t\tif (called[i])\n\t\t\t\t\tans *= 1.0 - heiro(i, i);\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <iomanip>\nusing namespace std;\n\nint N,M,s,t,Q;\nvector<vector<int>> v(110),rv(110),nv(110);\nvector<int> rs;\nint visited[110] = {},cmp[110] = {},in_cnt[110] = {};\ndouble p[110] = {},p_cmp[110] = {},dp[110] = {};\n\nvoid dfs(int n){\n    visited[n] = 1;\n    for(auto x:v[n]) if(!visited[x]) dfs(x);\n    rs.push_back(n);\n}\n\nvoid rdfs(int n,int cnt){\n    visited[n] = 1;\n    cmp[n] = cnt;\n    for(auto x:rv[n]) if(!visited[x]) rdfs(x,cnt);\n}\n\nint scc(){\n    memset(visited,0,sizeof(visited));\n    for(int i=1;i<=N;i++) if(!visited[i]) dfs(i);\n    memset(visited,0,sizeof(visited));\n    int now = 1;\n    for(int i=rs.size()-1;i>=0;i--) if(!visited[rs[i]]) rdfs(rs[i],now++);\n    for(int i=1;i<=N;i++){\n        for(auto x:v[i]){\n            if(cmp[i]!=cmp[x]){\n                nv[cmp[i]].push_back(cmp[x]);\n                in_cnt[cmp[x]]++;\n            }\n        }\n    }\n    return now-1;\n}\n\nint main(){\n    while(cin >> N && N>0){\n        for(int i=1;i<=N;i++){v[i].clear(); rv[i].clear(); nv[i].clear();}\n        rs.clear();\n        for(int i=1;i<=N;i++){\n            p_cmp[i] = 1;\n            dp[i] = 1;\n            visited[i] = 0;\n            cmp[i] = 0;\n            in_cnt[i] = 0;\n        }\n        int m,a;\n        for(int i=1;i<=N;i++){\n            cin >> p[i] >> m;\n            p[i] = 1-p[i];\n            for(int j=0;j<m;j++){\n                cin >> a;\n                v[i].push_back(a);\n                rv[a].push_back(i);\n            }\n        }\n        int cmp_size = scc();\n        for(int i=1;i<=N;i++){\n            p_cmp[cmp[i]] *= 1-p[i];\n        }\n        queue<int> Q;\n        for(int i=1;i<=cmp_size;i++){\n            p_cmp[i] = 1-p_cmp[i];\n/*            if(in_cnt[i]==0){\n                Q.push(i);\n                dp[i] = p_cmp[i];\n            }\n*/        }\n/*        while(!Q.empty()){\n            int n = Q.front(); Q.pop();\n            for(auto x:nv[n]){\n                in_cnt[x]--;\n                dp[x] = dp[x]*dp[n];\n                if(in_cnt[x]==0) Q.push(x);\n            }\n        }\n*/        double ans = 1;\n        for(int i=1;i<=cmp_size;i++) if(in_cnt[i]==0) ans *= p_cmp[i];\n        cout << fixed;\n        cout << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1000000000\n#define INF 1000000000000000\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\nvoid init(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\n\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WG = vector< Edges< T > >;\nusing UG = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\n\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n  const G &g;\n  UG gg, rg;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n    for(int i = 0; i < g.size(); i++) {\n      for(auto e : g[i]) {\n        gg[i].emplace_back((int) e);\n        rg[(int) e].emplace_back(i);\n      }\n    }\n  }\n\n  int operator[](int k) {\n    return comp[k];\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(UG &t) {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      for(auto &to : g[i]) {\n        int x = comp[i], y = comp[to];\n        if(x == y) continue;\n        t[x].push_back(y);\n      }\n    }\n  }\n};\n\n\n\n\n\n\nvoid tsort_dfs(int u,vector<int> &graph,bool visited[],UG &g){\n\n  if(visited[u]) return;\n  visited[u] = true;\n  for(int i=0;i<g[u].size();i++){\n    tsort_dfs(g[u][i],graph,visited,g);\n  }\n  graph.PB(u);\n}\n\n\nvector<int> tsort(UG &g){\n  vector<int> graph;\n  bool visited[110000] = {};\n  for(int i=0;i<g.size();i++){\n    tsort_dfs(i,graph,visited,g);\n  }\n  reverse(all(graph));\n  return graph;\n}\n\n\nvoid dfs(int k,UG es,bool b[]){ \n  b[k]=true;\n  for(auto e:es[k]){\n    if(b[e]) continue;\n    dfs(e,es,b);\n  }\n}\n\n\nvoid f(int n){\n  \n  UG es(n);\n  double v[110];\n\n  rep(i,n){\n    double p;\n    int m;\n    cin>>p>>m;\n    v[i]=p;\n   \n    rep(j,m){\n      int a;\n      cin>>a;\n      a--;\n      es[i].PB(a);\n    }\n  }\n\n  StronglyConnectedComponents<UG> scc(es);\n  UG et;\n  scc.build(et);\n\n  double a[1100]={};\n \n\n  rep(i,n){\n    a[i]=1;\n  }\n\n  rep(i,n){\n    a[scc[i]]*=v[i];\n  }\n\n  double ans=1;\n  vector<int> w=tsort(es);\n  \n\n  bool b[1100]={};\n  rep(i,n){\n    int t=w[i];\n//    cout<<t<<endl;\n    if(b[t]) continue;\n    ans=ans*(1-a[scc[t]]);\n    dfs(t,es,b);\n  }\n\n \n  printf(\"%.20lf\\n\",ans);\n\n}\n\n\nmain(){\n  int n;\n  while(true){\n    cin>>n;\n    if(!n) break;\n    f(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\n#define en '\\n'\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\nconst int INF_INT = 1 << 25;\nconst long long MOD = (ll) 1e9 + 7;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nconst int loose = 0;\nconst int tight = 1;\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct Edge {\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));\n}\n\nclass UnionFind {\n vector<int> data;\n int num;\npublic:\n UnionFind(int size) : data(size, -1), num(size) { }\n bool unionSet(int x, int y) {\n  x = root(x); y = root(y);\n  if (x != y) {\n   if (data[y] < data[x]) swap(x, y);\n   data[x] += data[y]; data[y] = x;\n   num--;\n  }\n  return x != y;\n }\n bool findSet(int x, int y) {\n  return root(x) == root(y);\n }\n int root(int x) {\n  return data[x] < 0 ? x : data[x] = root(data[x]);\n }\n int size(int x) {\n  return -data[root(x)];\n }\n int numSet() {\n  return num;\n }\n};\n\n//強連結成分分解\nclass SCC{\n\tGraph g,rg;\n\tvector<int> cmp,used,vs;\n\tint size;\npublic:\n\tSCC(Graph _g):g(_g),rg(g.size()),cmp(g.size(),-1),used(g.size(),false){\n\t\tREP(i,g.size()){\n\t\t\tfor(auto e:g[i]){\n\t\t\t\tadd_edge(rg,e.to,i,1,false,0);//逆辺のグラフ\n\t\t\t}\n\t\t}\n\n\t\tREP(i,g.size()){\n\t\t\tif(!used[i]) dfs(i);\n\t\t}\n\t\tint k=0;\n\t\t\n\t\tREP(i,vs.size()){\n\t\t\tll v=vs[vs.size()-1-i];\n\t\t\tif(used[v]){\n\t\t\t\trdfs(v,k);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tsize=k;\n\t}\n\n\tvoid dfs(int v){\n\t\t//帰りがけ順に番号を振る\n\t\tused[v]=true;\n\t\tfor(auto e:g[v]){\n\t\t\tif(!used[e.to]) dfs(e.to);\n\t\t}\n\t\tvs.push_back(v);\n\t}\n\n\tvoid rdfs(int v, int k){\n\t\t//通ることができた頂点に番号を振る\n\t\tused[v]=false;\n\t\tcmp[v]=k;\n\t\tfor(auto e:rg[v]){\n\t\t\tif(used[e.to]) rdfs(e.to,k);\n\t\t}\n\t}\n\n\tint getSize(){\n\t\treturn size;\n\t}\n\n\tint group(int v){\n\t\treturn cmp[v];\n\t}\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n\twhile(true){\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tvector<double> p(n);\n\t\tGraph g(n);\n\t\tREP(i,n){\n\t\t\tcin>>p[i];\n\t\t\tll m;\n\t\t\tcin>>m;\n\n\t\t\tREP(j,m){\n\t\t\t\tll b;\n\t\t\t\tcin>>b;\n\t\t\t\tb--;\n\t\t\t\tadd_edge(g,i,b,1,false,1);\n\t\t\t}\n\t\t}\n\n\t\tSCC scc(g);\n\n\t\tvector<int> in(scc.getSize());//入次数\n\t\tREP(i,g.size()){\n\t\t\tint u=scc.group(i);\n\t\t\tfor(auto e:g[i]){\n\t\t\t\tint v=scc.group(e.to);\n\t\t\t\tif(u==v) continue;\n\t\t\t\tin[v]++;\n\t\t\t}\n\t\t}\n\n\t\tvector<double> dp(in.size(),1.0);//各グループことの寝坊率\n\t\tREP(i,g.size()){\n\t\t\tint u=scc.group(i);\n\t\t\tdp[u]*=p[i];\n\t\t}\n\n\t\tdouble ans=1.0;\n\t\tREP(i,in.size()){\n\t\t\tif(in[i]!=0) continue;\n\t\t\tans *= (1.0-dp[i]);\n\t\t}\n\n\t\tcout<<fixed<<setprecision(8)<<ans<<endl;\n\t}\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define uint unsigned int\n#define pii pair<int, int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORR(i,a,b) for(int i=(a);i>=(b);--i)\n#define REP(i,n) FOR(i,0,n)\n#define REPR(i,n) FORR(i,n,0)\n#define ALL(c) ((c).begin(),(c).end())\n#define PB(a) push_back(a)\n#define EMPB(...) emplace_back(__VA_ARGS__)\n#define EMP(...) emplace(__VA_ARGS__)\n#define MP(a,b) make_pair(a,b)\n#define MT(...) make_tuple(__VA_ARGS__)\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define PW(n) (1LL<<(n))\nusing namespace std;\ntemplate <class T> inline bool CHMIN(T& a, T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <class T> inline bool CHMAX(T& a, T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <class T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <class T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <class T> inline void UNI(T& a) { SORT(a); a.erase(unique(ALL(a)),a.end()); }\ntemplate <class S, class T> ostream& operator<<(ostream& os, const pair<S,T> a) {\n  return os << a.first << ' ' << a.second;\n}\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nstruct SCC {\n  int n;\n  vector<vector<int>> G, rG, nG, iG;\n  vector<bool> used;\n  vector<int> vs, cmp;\n  SCC() {}\n  SCC(int n) : n(n), G(n), rG(n), nG(n), iG(n), used(n), cmp(n) {}\n  void add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n  void dfs(int v) {\n    used[v] = true;\n    for (auto u : G[v]) {\n      if (!used[u]) dfs(u);\n    }\n    vs.push_back(v);\n  }\n  void rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for (auto u : rG[v]) {\n      if (!used[u]) rdfs(u, k);\n      else if (cmp[u] != cmp[v]) nG[cmp[u]].push_back(cmp[v]);\n    }\n  }\n  int doit() {\n    fill(used.begin(), used.end(), false);\n    vs.clear();\n    for (int i = 0; i < n; i++) {\n      if (!used[i]) dfs(i);\n    }\n    fill(used.begin(), used.end(), false);\n    int k = 0;\n    for (int i = vs.size() - 1; i >= 0; i--) {\n      if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    nG.resize(k);\n    for (int i = 0; i < k; i++) {\n      nG[i].erase(unique(nG[i].begin(), nG[i].end()), nG[i].end());\n    }\n    for (int i = 0; i < n; i++) {\n      iG[cmp[i]].push_back(i);\n    }\n    return k;\n  }\n};\n\nint N;\ndouble p[110];\nint m[110];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> N, N) {\n    SCC scc(N);\n    REP(i,N) {\n      cin >> p[i] >> m[i];\n      REP(j,m[i]) {\n        int a;\n        cin >> a;\n        scc.add_edge(i,a-1);\n      }\n    }\n    int k = scc.doit();\n    vector<vector<int>> g = scc.nG;\n    vector<int> indeg(k,0);\n    REP(i,k) {\n      for (int j = 0; j < g[i].size(); j++) {\n        indeg[g[i][j]]++;\n      }\n    }\n    double ans = 1.0;\n    REP(i,k) if (indeg[i] == 0) {\n      vector<int> g2 = scc.iG[i];\n      double sub = 1.0;\n      for (int j = 0; j < g2.size(); j++) {\n        sub *= p[g2[j]];\n      }\n      ans *= 1.0-sub;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\n\nvoid dfs(int v, VI &used, VVI &adj, VI &vs) {\n  used[v] = true;\n  for (int i = 0; i < adj[v].size(); i++) {\n    if (!used[adj[v][i]]) dfs(adj[v][i], used, adj, vs);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k, VI &used, VVI &adjv, VI &cmp) {\n  used[v] = true;\n  cmp[v] = k;\n  for (int i = 0; i < adjv[v].size(); i++) {\n    if (!used[adjv[v][i]]) rdfs(adjv[v][i], k, used, adjv, cmp);\n  }\n}\n\nvoid solve(int n) {\n  vector<double> ps;\n  VVI adj(n), adjv(n);\n  for (int i = 0; i < n; i++) {\n    double p;\n    cin >> p;\n    ps.push_back(p);\n    int m;\n    cin >> m;\n    for (int j = 0; j < m; j++) {\n      int k;\n      cin >> k;\n      k--;\n      adj[i].push_back(k);\n      adjv[k].push_back(i);\n    }\n  }\n  VI used(n, 0);\n  VI cmp(n, -1);\n  VI vs;\n\n  for (int i = 0; i < n; i++) {\n    if (!used[i]) dfs(i, used, adj, vs);\n  }\n  used = VI(n, 0);\n  int k = 0;\n  for (int i = vs.size() - 1; i >= 0; i--) {\n    if (!used[vs[i]]) rdfs(vs[i], k++, used, adjv, cmp);\n  }\n\n  double ans = 1;\n  VVI g(k, VI(k, 0));\n  for (int i = 0; i < n; i++) {\n    for (int j: adj[i]) {\n      // i -> j\n      if (cmp[i] != cmp[j]) {\n        g[cmp[i]][cmp[j]] = 1;\n      }\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    int deg = 0;\n    for (int j = 0; j < k; j++) {\n      if (g[j][i]) deg++;\n    }\n    if (deg == 0) {\n      double pp = 1.0;\n      for (int l = 0; l < n; l++) {\n        if (cmp[l] == i) {\n          pp *= ps[l];\n        }\n      }\n      ans *= (1.0 - pp);\n    }\n  }\n  printf(\"%.8f\\n\", ans);\n}\n\nint main() {\n  int n;\n  while (1) {\n    cin >> n;\n    if (n == 0) return 0;\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nclass StronglyConnectedComponents{\n\tprivate:\n\t\tvector<bool> used;\n\t\tvector<int> vs; //帰りがけ順の並び\n\t\tvoid dfs(int v){\n\t\t\tused[v] = true;\n\t\t\trep(i,g[v].size()){\n\t\t\t\tif(not used[g[v][i]]) dfs(g[v][i]);\n\t\t\t}\n\t\t\tvs.emplace_back(v);\n\t\t}\n\t\tvoid rdfs(int v, int k){\n\t\t\tused[v] = true;\n\t\t\tcmp[v] = k;\n\t\t\trep(i,rg[v].size()){\n\t\t\t\tif(not used[rg[v][i]]) rdfs(rg[v][i], k);\n\t\t\t}\n\t\t}\n\tpublic:\n\t\ttypedef vector<vector<int>> graph;\n\t\tconst int v; // 頂点数\n\t\tint nv; // SCCした後の頂点数\n\t\tgraph g, rg; // グラフ、辺が逆になったグラフ\n\t\tvector<int> cmp; //属する強連結成分のトポロジカル順序\n\n\t\tStronglyConnectedComponents(int v) : used(v), v(v), g(v), rg(v), cmp(v) { }\n\n\t\tvoid addEdge(int from, int to){\n\t\t\tg[from].emplace_back(to);\n\t\t\trg[to].emplace_back(from);\n\t\t}\n\t\tint solve(){ // 強連結成分分解をしたあとのグラフの頂点数を返す\n\t\t\tfill(all(used),0);\n\t\t\tvs.clear();\n\t\t\trep(i,v){\n\t\t\t\tif(not used[i]) dfs(i);\n\t\t\t}\n\t\t\tfill(all(used),0);\n\t\t\tint k = 0;\n\t\t\tfor(int i = vs.size() - 1; i >= 0; i--){\n\t\t\t\tif(not used[vs[i]]) rdfs(vs[i], k++);\n\t\t\t}\n\t\t\treturn nv = k;\n\t\t}\n\t\tgraph getCssGraph(vector<vector<int>>& node){\n\t\t\tnode = vector<vector<int>>(nv); // node[i]:=SCCによって頂点iに同一視された頂点\n\t\t\tgraph res(nv); // CSSしたあとのグラフ\n\t\t\trep(i,v){\n\t\t\t\tnode[cmp[i]].emplace_back(i);\n\t\t\t\tfor(auto to : g[cmp[i]]){\n\t\t\t\t\tif(cmp[i] == cmp[to]) continue;\n\t\t\t\t\tres[cmp[i]].emplace_back(cmp[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tvoid out(){\n\t\t\trep(i,v){ cout << cmp[i] << ' '; } cout << endl;\n\t\t}\n};\n\nvoid dfs(int pos, vector<bool>& used, vector<vector<int>>& g){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tdfs(to, used, g);\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tStronglyConnectedComponents scc(n);\n\t\tvector<double> p(n); // 寝坊する確率\n\t\trep(i,n){\n\t\t\tint m;\n\t\t\tcin >> p[i] >> m;\n\t\t\trep(j,m){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tscc.addEdge(i, a - 1);\n\t\t\t}\n\t\t}\n\t\tscc.solve();\n\n\t\tvector<vector<int>> node;\n\t\tStronglyConnectedComponents::graph g = scc.getCssGraph(node);\n\t\tdouble ans = 1;\n\n\t\tvector<bool> used(n,0);\n\t\trep(i,scc.nv){\n\t\t\tif(used[node[i][0]]) continue;\n\n\t\t\tdouble tmp = 1.00;\n\t\t\trep(j,node[i].size()){\n\t\t\t\ttmp *= p[node[i][j]];\n\t\t\t}\n\t\t\tans *= 1.00 - tmp;\n\t\t\tdfs(node[i][0], used, scc.g);\n\t\t}\n\t\tcout << fixed << setprecision(9) << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int s, int d, Weight w = 1) { g[s].emplace_back(s, d, w); }\n\n//テヲツ慊ェテヲツ篠「テァツエツ「, テヲツ篠「テァツエツ「テ、ツクツュ, テヲツ篠「テァツエツ「テヲツクツ?\nenum { WHITE, GRAY, BLACK };\n\n//テ・ツ債佚、ツクツ?・ツァツ凝ァツつケテヲツ慊?ァツ淞ュテァツオツ古ィツキツッ(ティツイツ?ゥツ鳴嘉ィツキツッテ」ツ?ェテ」ツ??\n//Dijkstra O((E+V)logV)\n//dist: テ・ツァツ凝ァツつケテ」ツ?凝」ツつ嘉・ツ青?ゥツ?づァツつケテ」ツ?セテ」ツ?ァテ」ツ?ョテヲツ慊?ァツ淞ュティツキツ敕ゥツ崢「\n//テヲツ按サテ」ツつ甘・ツ?、: テヲツ慊?ァツ淞ュテァツオツ古ィツキツッテヲツ慊ィテ」ツ?ョティツヲツェテゥツ?づァツつケ(テヲツ?ケテ」ツ?ッ-1)\nvector<int> dijkstra(const Graph &g, int s, vector<Weight> &dist) {\n\tint n = g.size();\n\tvector<int> color(n, WHITE); color[s] = GRAY;\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INF); dist[s] = 0;\n\tusing State = tuple<Weight, int, int>; //テ・ツァツ凝ァツつケテ」ツ?凝」ツつ嘉」ツ?ョテヲツ慊?ァツ淞ュティツキツ敕ゥツ崢「 テ・ツュツ?ティツヲツェ\n\tpriority_queue<State, vector<State>, greater<State>> pq; pq.emplace(0, s, -1);\n\twhile (pq.size()) {\n\t\tWeight d; int v, u; tie(d, v, u) = pq.top(); pq.pop(); //distテ」ツ?古ヲツ慊?・ツーツ湘」ツ?ィテ」ツ?ェテ」ツつ鬼tateテ」ツつ津・ツ渉姪」ツつ甘・ツ?コテ」ツ??\n\t\tif (dist[v] < d)continue; //テ」ツ?凖」ツ?ァテ」ツ?ォテヲツ慊?ァツ淞ュテ」ツ?ァテ」ツ?ェテ」ツ?妥」ツつ古」ツ?ーテァツ?。ティツヲツ?\n\t\tcolor[v] = BLACK; prev[v] = u;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (color[e.d] == BLACK)continue;\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tpq.emplace(dist[e.d], e.d, v);\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\n//テ・ツ?ィテァツつケテ・ツッツセテゥツ鳴禿ヲツ慊?ァツ淞ュテァツオツ古ィツキツッ \nvoid all_pairs_shortest_paths_by_dijkstra(const Graph &g, Matrix &dists) {\n\tint n = g.size();\n\tdists.resize(n);\n\tfor (int i = 0; i < n; i++)\n\t\tdijkstra(g, i, dists[i]);\n}\n\n//テァツエツ?ゥツ崢?・ツ青暗」ツδ?」ツδシテ」ツつソテヲツァツ凝ゥツ??\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (size_of(x) < size_of(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint size_of(int x) { return -parent[root(x)]; }\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(8);\n\tfor (int N; cin >> N&&N;) {\n\t\tvector<double> p(N);\n\t\tGraph g(N);\n\t\trep(i, 0, N) {\n\t\t\tcin >> p[i];\n\t\t\tint M; cin >> M;\n\t\t\trep(j, 0, M) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tadd_arc(g, i, a - 1);\n\t\t\t}\n\t\t}\n\t\tMatrix dists;\n\t\tall_pairs_shortest_paths_by_dijkstra(g, dists);\n\t\tUnionFind uf(N);\n\t\tvector<int> in(N);\n\t\tvector<double> pp(N, 1.0);\n\t\trep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (dists[i][j] != INF&&dists[j][i] != INF) {\n\t\t\t\tuf.unite(i, j);\n\t\t\t}\n\t\t\telse if (dists[i][j] != INF) {\n\t\t\t\tin[j]++;\n\t\t\t}\n\t\t\telse if (dists[j][i] != INF) {\n\t\t\t\tin[i]++;\n\t\t\t}\n\t\t}\n\t\trep(i, 0, N) {\n\t\t\tpp[uf.root(i)] *= p[i];\n\t\t}\n\t\tdump(pp);\n\t\tvector<bool> f(N);\n\t\tdouble ans = 1;\n\t\trep(i, 0, N) {\n\t\t\tif (in[i]) continue;\n\t\t\tif (f[uf.root(i)])continue;\n\t\t\tf[uf.root(i)] = true;\n\t\t\tans *= 1 - pp[uf.root(i)];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 500\nint V;\nvector<int> G[MAX_V],rG[MAX_V],vs,vG[MAX_V];\nbool used[MAX_V];\nint cmp[MAX_V];\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\nvoid dfs(int v){\n  used[v]=1;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\nvoid rdfs(int v,int k){\n  used[v]=1;\n  cmp[v]=k;\n  vG[k].push_back(v);\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]]) rdfs(vs[i],k++);\n  }\n  return k;\n}\nint main(){\n  while(cin>>V,V){\n    int i,j,k,l;\n    for(i=0;i<MAX_V;i++) G[i].clear(),rG[i].clear(),vG[i].clear();\n    double p[V];\n    for(i=0;i<V;i++){\n      cin>>p[i]>>k;\n      for(j=0;j<k;j++){\n\tcin>>l;\n\tadd_edge(i,l-1);\n      }\n    }\n    k=scc();\n    double ans=1.0,res;\n    for(i=0;i<k;i++){\n      bool f=1;\n      res = 1.0;\n      for(j=0;j<vG[i].size();j++){\n\tres*=p[vG[i][j]];\n\tfor(l=0;l<rG[vG[i][j]].size();l++)\n\t  f&=(cmp[vG[i][j]]==cmp[rG[vG[i][j]][l]]);\n      }\n      if(f) ans*=(1.0-res);\n    }\n    printf(\"%.10lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; (i) < int(n); ++ (i))\n#define loop(i,a,n) for (int i = (a); (i) < int(n); ++ (i))\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 0\n//#define int ll\nusing namespace std;\n// set of vertices\nusing vgrp_t = std::vector<int>;\n\n// graph (adjacency list)\nusing graph_t = std::vector<vgrp_t>;\n\ngraph_t reverse_graph(graph_t const &g) {\n    graph_t rg(g.size());\n    for (int i = 0; i < static_cast<int>(g.size()); i++) {\n        for (int to : g[i]) rg[to].push_back(i);\n    }\n    return rg;\n}\n\nstd::vector<std::pair<int, int>> make_numbering(graph_t const &g) {\n    // std::pair<int, int> = { order in postorder DFS, vertex number }\n    // order | -1 => not yet visited\n    //       | -2 => now searching\n    std::vector<std::pair<int, int>> numbering(g.size(),\n                                               std::make_pair(-1, 0));\n\n    std::function<int(int, int)> dfs = [&](int v, int num) {\n        // if v is already visited, do nothing.\n        if (numbering[v].first != -1) return num;\n        numbering[v].first = -2;\n        for (int to : g[v]) num = dfs(to, num);\n        numbering[v] = std::make_pair(num, v);\n        return num + 1;\n    };\n\n    int num = 0;\n    for (int i = 0; i < static_cast<int>(g.size()); i++) {\n        if (numbering[i].first == -1) num = dfs(i, num);\n    }\n\n    return numbering;\n}\n\nclass strongly_connected_components_t {\n  private:\n    std::vector<int> scc_of_;\n    int size_;\n\n  public:\n    strongly_connected_components_t(std::vector<int> scc_of, int size)\n        : scc_of_(scc_of)\n        , size_(size) {}\n    int size() const { return size_; }\n    int scc_of(int v) const { return scc_of_[v]; }\n};\n\nstrongly_connected_components_t\ndecompose_impl(graph_t const &rg,\n               std::vector<std::pair<int, int>> const &numbering) {\n    std::vector<int> scc_of(rg.size(), -1);\n\n    // mark a strongly connected components beginning from vertex v with\n    // `num`.\n    std::function<void(int, int)> dfs = [&](int v, int num) {\n        scc_of[v] = num;\n        // add not yet decomposed vertices in adjacent vertices\n        for (int to : rg[v]) {\n            if (scc_of[to] != -1) continue;\n            dfs(to, num);\n        }\n    };\n\n    int num = 0;\n    for (auto const &p : numbering) {\n        int v = p.second;\n        if (scc_of[v] == -1) dfs(v, num++);\n    }\n    return strongly_connected_components_t(scc_of, num);\n}\n\nstrongly_connected_components_t decompose_into_sccs(graph_t const &g) {\n    auto numbering = make_numbering(g);\n    std::sort(numbering.begin(), numbering.end(),\n              std::greater<std::pair<int, int>>());\n    return decompose_impl(reverse_graph(g), numbering);\n}\n\nsigned main() {\n    int N,fri,m;\n    while(1) {\n    cin >> N;\n    if(N==0) break;\n    vector<double> pos(N);\n    graph_t ss(N);\n    rep(i,N) {\n        cin >> pos[i] >> m;\n        rep(j,m) {\n            cin >> fri;\n            ss[i].push_back(fri-1);\n        }\n    }\n    auto setted = decompose_into_sccs(ss);\n    graph_t sg(setted.size());\n    graph_t fg(setted.size());\n\n    rep(i,N) sg[setted.scc_of(i)].push_back(i);\n\n    rep(i,N) {\n        rep(j,ss[i].size()) {\n            if(setted.scc_of(i) != setted.scc_of(ss[i][j])) {\n                fg[setted.scc_of(i)].push_back(setted.scc_of(ss[i][j]));\n            }\n        }\n    }\n    rep(i,fg.size()) {\n        sort(fg[i].begin(),fg[i].end());\n        fg[i].erase(unique(fg[i].begin(),fg[i].end()),fg[i].end());\n    }\n    double possibility;\n    vector<bool> pointed(fg.size(),false);\n    vector<double> possi(fg.size());\n    rep(i,fg.size()) {\n        possibility = 1;\n        rep(j,sg[i].size()) {\n            possibility *= pos[sg[i][j]];\n        }\n        rep(j,fg[i].size()) {\n            pointed[fg[i][j]] = true;\n        }\n        possi[i] = 1- possibility;\n    }\n    double ans = 1;\n    rep(i,pointed.size()) {\n        if(!pointed[i]) ans *= possi[i];\n    }\n    cout << fixed << setprecision(9) << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=105,INF=1<<30;\n\nint V,cmp[MAX];\nvector<int> G[MAX],rG[MAX],vs;//vsがトポソの逆順になってる\nbool used[MAX];\n\nvoid init(){\n    for(int i=0;i<V;i++){\n        G[i].clear();\n        rG[i].clear();\n        cmp[i]=0;\n        used[i]=0;\n    }\n    vs.clear();\n}\n\nvoid add_edge(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid DFS(int v){\n    used[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        if(used[G[v][i]]==0) DFS(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rDFS(int v,int k){\n    used[v]=1;\n    cmp[v]=k;\n    for(int i=0;i<rG[v].size();i++){\n        if(used[rG[v][i]]==0) rDFS(rG[v][i],k);\n    }\n}\n\nint scc(){\n    memset(used,0,sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++){\n        if(used[v]==0) DFS(v);\n    }\n    \n    memset(used,0,sizeof(used));\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n        if(used[vs[i]]==0) rDFS(vs[i],k++);\n    }\n    return k;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        V=N;\n        init();\n        vector<double> p(N),q;\n        for(int i=0;i<N;i++){\n            cin>>p[i];\n            int k;cin>>k;\n            for(int j=0;j<k;j++){\n                int a;cin>>a;\n                a--;\n                add_edge(i,a);\n            }\n        }\n        int k=scc();\n        set<int> need;\n        \n        for(int i=0;i<k;i++) need.insert(i);\n        \n        for(int i=0;i<N;i++){\n            for(int to:G[i]){\n                if(cmp[i]!=cmp[to]){\n                    if(need.count(cmp[to])) need.erase(cmp[to]);\n                }\n            }\n        }\n        \n        q.assign(k,1.0);\n        \n        for(int i=0;i<N;i++){\n            if(need.count(cmp[i])){\n                q[cmp[i]]*=p[i];\n            }\n        }\n        \n        double ans=1.0;\n        \n        for(int i=0;i<k;i++){\n            if(q[i]!=1.0) ans*=(1.0-q[i]);\n        }\n        \n        cout<<fixed<<setprecision(9)<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\nvector<int> gr[110];\ndouble p[110];\nint wf[110][110];\nint num[110];\n         signed main(){\n\t\n\tint n;\n         \twhile(1){\n         \tcin>>n;\n         \t\tif(n==0) return 0;\n         \t\tfor(int i=0;i<110;i++){\n         \t\t\tgr[i].clear();\n         \t\t\tp[i]=0.0;\n         \t\t\tnum[i]=0;\n         \t\t\tfor(int j=0;j<110;j++)wf[i][j]=inf;\n         \t\t}\n         \t\n         \t\n         \tfor(int i=0;i<n;i++){\n         \t\tcin>>p[i];\n         \t\tint r;\n         \t\tcin>>r;\n         \t\tfor(int j=0;j<r;j++){\n         \t\t\tint rr;\n         \t\t\tcin>>rr;\n         \t\t\trr--;\n         \t\t\twf[i][rr]=1;\n         \t\t}\n         \t}\n         \t\n         \tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n         \t\twf[i][j]=min(wf[i][j],wf[i][k]+wf[k][j]);\n         \t}\n         \tint cn=0;\n         \tfor(int i=0;i<n;i++){\n         \t\tbool bo=false;\n         \t\tfor(int j=0;j<i;j++){\n         \t\t\tif(wf[i][j]<inf && wf[j][i]<inf){\n         \t\t\t\tbo=1;\n         \t\t\t\tnum[i]=num[j];\n         \t\t\t\tgr[num[i]].pb(i);\n         \t\t\t\tbreak;\n         \t\t\t} \n         \t\t\t\n         \t\t}\n         \t\tif(!bo){\n         \t\t\tnum[i]=cn;\n         \t\t\tgr[cn].pb(i);\n         \t\t\tcn++;\n         \t\t}\n         \t}\n         \tdouble ans=1;\n         \tfor(int i=0;i<cn;i++){\n         \t\tbool bo=false;\n         \t\tfor(int j=0;j<cn;j++)if(i!=j)if(wf[gr[j][0]][gr[i][0]]<inf)bo=1;\n         \t\tif(!bo){\n         \t\t\tdouble r=1;\n         \t\t\tfor(auto v:gr[i]) r*= p[v];\n         \t\t\tr=1-r;\n         \t\t\t\n         \t\t\tans*=r;\n         \t\t}\n         \t}\n         \tprintf(\"%.10lf\\n\",ans);\n         \t}\n         \t//cout<<ans<<endl;\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nusing Graph = vector<vector<int>>;\n\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n\t\t   stack<int> &S, vector<bool> &inS,\n\t\t   vector<int> &low, vector<int> &num, int& time){\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  for(auto& e: g[v]) {\n    int w = e;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid SCC(const Graph& g,\n\t\t vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  REP(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tvector<double> ps(N);\n\tGraph G(N);\n\tREP(i,N){\n\t  cin >> ps[i];\n\t  int m; cin >> m;\n\t  REP(j,m){\n\t\tint a; cin >> a;\n\t\t--a;\n\t\tG[i].PB(a);\n\t  }\n\t}\n\tVVI scc;\n\tSCC(G, scc);\n\tVI gr(N);\n\tint M = SZ(scc);\n\tREP(i,M){\n\t  for(int u: scc[i])\n\t\tgr[u] = i;\n\t}\n\tvector<set<int>> G_(M);\n\tREP(i,N){\n\t  for(int to: G[i])\n\t\tif(gr[i] != gr[to])\n\t\t  G_[gr[i]].insert(gr[to]);\n\t}\n\tVI in(M);\n\tREP(i,M) for(int to: G_[i]) in[to]++;\n\tdouble ans = 1.;\n\tREP(i,M){\n\t  if(in[i] == 0){\n\t\tdouble prod = 1.;\n\t\tREP(j,N) if(gr[j] == i) prod *= ps[j];\n\t\tans *= 1. - prod;\n\t  }\n\t}\n\tcout << fixed << setprecision(9) << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct st {\n\tdouble late;\n\tvector<int> call;\n};\nvector<st> mem;\nmap<int, int> mpii;\nvb called;\nint cnt;\n\ndouble heiro(int first, int idx) {\n\tdouble ret = 1.0;\n\tcalled[idx] = false;\n\tbool hei = false;\n\tREP(i, mem[idx].call.size()) {\n\t\tif (!called[idx])\n\t\t\thei = true;\n\t\tif (called[mem[idx].call[i]]) {\n\t\tdouble a=heiro(first, mem[idx].call[i]);\n\t\tif (abs(a - 1.0) > 1e-9) {\n\t\t\tret *= a;\n\t\t\thei = true;\n\t\t}\n\t\t}\n\t}\n\tif (hei)\n\t\tret *= mem[idx].late;\n\treturn ret;\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tmem.clear();\n\t\tmem.resize(n);\n\t\tmpii.clear();\n\t\tcalled.resize(n, false);\n\t\tREP(i, n) {\n\t\t\tint m;\n\t\t\tcin >> mem[i].late >> m;\n\t\t\tmem[i].call.resize(m);\n\t\t\tREP(j, m) {\n\t\t\t\tcin >> mem[i].call[j];\n\t\t\t\tmem[i].call[j]--;\n\t\t\t\tcalled[mem[i].call[j]] = true;\n\t\t\t}\n\t\t\tmpii[i] = i;\n\t\t}\n\t\tdouble ans = 1.0;\n\t\tqueue<int> Q;\n\t\tREP(i, n)\n\t\t\tif (called[i] == false) {\n\t\t\t\tans *= (1.0 - mem[i].late);\n\t\t\t\tREP(j, mem[i].call.size())\n\t\t\t\t\tQ.push(mem[i].call[j]);\n\t\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tint q = Q.front();Q.pop();\n\t\t\tcalled[q] = false;\n\t\t\tREP(i, mem[q].call.size())\n\t\t\t\tif (called[mem[q].call[i]])\n\t\t\t\t\tQ.push(mem[q].call[i]);\n\t\t}\n\t\tREP(i, n) {\n\t\t\tif(called[i])\n\t\t\t\tans *= 1.0 - heiro(i, i);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n#define MAX 110\n\nstruct UnionFind {\n  int par[MAX];\n  void init() {\n    rep(i,MAX) par[i] = i;\n  }\n  int find(int x) {\n    if( x == par[x] ) return x;\n    return par[x] = find(par[x]);\n  }\n  void unit(int x,int y) {\n    x = find(x), y = find(y);\n    if(x!=y) par[x] = y;\n  }\n};\n\n\n\n//\nstruct SCC{\npublic:\n  int V;\n  vector<vector<int> > G, rG;\n  vector<bool> used;\n  vector<int> cmp, vs;\n  \n  SCC(int V=0):V(V) {\n    G.resize(V,vector<int>()), rG.resize(V,vector<int>());\n    cmp.resize(V), used.resize(V);\n  }\n\n  void add_edge(int s,int t) {\n    G[s].push_back(t);\n    rG[t].push_back(s);\n  }\n\n  void dfs(int v) {\n    used[v] = true;\n    rep(i,(int)G[v].size()) if( !used[G[v][i]] ) dfs(G[v][i]);\n    vs.push_back(v);\n  }\n\n  void rdfs(int v,int k) {\n    used[v] = true;\n    cmp[v] = k;\n    rep(i,(int)rG[v].size()) if( !used[rG[v][i]] ) rdfs(rG[v][i],k);\n  }\n\n  int scc() {\n    rep(i,V) used[i] = false;\n    vs.clear();\n    rep(v,V) if( !used[v] ) dfs(v);\n    rep(i,V) used[i] = false;\n    int k = 0;\n    for(int i=(int)vs.size()-1;i>=0;--i) if( !used[vs[i]] ) {\n\trdfs(vs[i],k++);\n      }\n    return k;\n  }\n  \n};\n\n//\n\nint N;\ndouble p[MAX];\nvector<int> G[MAX];\nint in_degree[MAX];\nbool used[MAX];\n\ndouble getProb(vector<vector<int> > newG,vector<double> newp,int newN) {\n  memset(in_degree, 0, sizeof in_degree);\n  UnionFind uf;\n  uf.init();\n  rep(i,newN) {\n    rep(j,(int)newG[i].size()) {\n      uf.unit(i,newG[i][j]);\n      ++in_degree[newG[i][j]];\n    }\n  }\n  vector<double> ps;\n  rep(i,newN) uf.find(i);\n  set<int> group;\n  rep(i,newN) group.insert(uf.find(i));\n  for(set<int>::iterator it=group.begin();it!=group.end();it++) {\n    int gid = *it;\n    vector<int> vec;\n    rep(i,newN) if( uf.find(i) == gid ) {\n      if( in_degree[i] == 0 ) {\n\tvec.push_back(i);\n      }\n    }\n    if( (int)vec.size() ) {\n      // the other\n      double tmp = 1.0;\n      rep(i,(int)vec.size()) {\n\ttmp *= ( 1.0 - newp[vec[i]] );\n      }\n      ps.push_back(tmp);\n    } else assert(false);\n    \n  }\n  double answer = 1.0;\n  rep(i,(int)ps.size()) answer *= ps[i];\n  return answer;\n}\n\nvoid compute() {\n  UnionFind uf;\n  uf.init();\n  rep(i,N) {\n    rep(j,(int)G[i].size()) {\n      uf.unit(i,G[i][j]);\n      ++in_degree[G[i][j]];\n    }\n  }\n  vector<double> ps;\n  rep(i,N) uf.find(i);\n  set<int> group;\n  rep(i,N) group.insert(uf.find(i));\n  for(set<int>::iterator it=group.begin();it!=group.end();it++) {\n    int gid = *it;\n    //cout << \"gid = \" << gid << endl;\n    vector<int> vec;\n    rep(i,N) if( uf.find(i) == gid ) {\n      if( in_degree[i] == 0 ) {\n\tvec.push_back(i);\n      }\n    }\n    if( (int)vec.size() ) {\n      // the other\n      double tmp = 1.0;\n      rep(i,(int)vec.size()) {\n\ttmp *= ( 1.0 - p[vec[i]] );\n      }\n      ps.push_back(tmp);\n    } else {\n      //cout << \"group \" << gid << \" is loop\" << endl;\n      // loop  \n      \n      {\n\tvector<int> cand;\n\trep(i,N) if( uf.find(i) == gid ) {\n\t  cand.push_back(i);\n\t}\n\tmap<int,int> toIndex; // ?????????i??????scc??????????????????????????????\n\tmap<int,int> rtoIndex;\n\trep(i,(int)cand.size()) {\n\t  toIndex[cand[i]] = i;\n\t  rtoIndex[i] = cand[i];\n\t  //cout << cand[i] << \" =toIndex=> \" << i << endl;\n\t}\n\tSCC scc = SCC((int)cand.size());\n\n\trep(i,N) if( uf.find(i) == gid ) {\n\t  rep(j,(int)G[i].size()) {\n\t    assert( uf.find(i) == uf.find(G[i][j]) );\n\t    assert( toIndex.count(i) );\n\t    assert( toIndex.count(G[i][j]) );\n\t    scc.add_edge(toIndex[i],toIndex[G[i][j]]);\n\t    //cout << \"add edge \" << toIndex[i] << \",\" << toIndex[G[i][j]] << endl;\n\t  }\n\t}\n      \n\tint newN = scc.scc();\n\tvector<vector<int> > newG(newN,vector<int>());\n\tvector<double> newp(newN,1.0);\n\n\t//cout << \"newN = \" << newN << endl;\n\n\trep(i,(int)scc.G.size()) {\n\t  rep(j,(int)scc.G[i].size()) {\n\t    if( scc.cmp[i] != scc.cmp[scc.G[i][j]] ) {\n\t      newG[scc.cmp[i]].push_back(scc.cmp[scc.G[i][j]]);\n\t      //cout << \"(\" << scc.cmp[i] << \"=>\" << scc.cmp[scc.G[i][j]] << \")\" << endl;\n\t    }\n\t  }\n\t}\n\t//rep(i,(int)scc.G.size()) cout << \"cmp[\" << i << \"] = \" << scc.cmp[i] << endl;\n\t\n\trep(i,(int)scc.G.size()) {\n\t  newp[scc.cmp[i]] *= p[rtoIndex[i]];\n\t  //cout << \"newp[\"  << scc.cmp[i] << \"] *= p[\" << rtoIndex[i] << \"]\" << endl;\n\t  //cout << \"=>\" << newp[scc.cmp[i]] << endl;\n\t}\n\tps.push_back(getProb(newG,newp,newN));\n      }\n    }\n  }\n  double answer = 1.0;\n  rep(i,(int)ps.size()) answer *= ps[i];\n  printf(\"%.10f\\n\",answer);\n}\n\nint main() {\n  while( cin >> N, N ) {\n  memset(in_degree,0,sizeof in_degree);\n  memset(used,0,sizeof used);\n    rep(i,MAX) G[i].clear();\n\n\n    rep(i,N) {\n      cin >> p[i];\n      int M, tmp;\n      cin >> M;\n      rep(j,M) {\n\tcin >> tmp;\n\t--tmp;\n\tG[i].push_back(tmp);\n      }\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntemplate<class T>\nstruct Edge{\n\tint from,to;\n\tT cost;\n\tEdge(int to,T cost) : to(to),cost(cost){}\n\tEdge(int from,int to,T cost) : from(from),to(to),cost(cost){}\n\toperator int() const noexcept { return to; }\n};\n\ntemplate<class T>\nusing WeightedGraph = vector<vector<Edge<T>>>;\nusing Graph = vector<vector<int>>;\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\ntemplate<class T>\nstruct SCC{\n\tT g;\n\tGraph G,rG,nG;\n\tvector<vector<int>> scc;\n\tvector<int> cmp,used,vs;\n\n\tint operator[](int i) const{ return cmp[i]; }\n\t\n\tSCC(T g) : g(g),G(g.size()),rG(g.size()),cmp(g.size(),-1),used(g.size()){\n\t\tfor(int i = 0;i < g.size();i++){\n\t\t\tfor(const auto &e : g[i]){\n\t\t\t\tG[i].push_back((int)e);\n\t\t\t\trG[(int)e].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(int v){\n\t\tused[v] = true;\n\t\tfor(int to : G[v]) if(!used[to]) dfs(to);\n\t\tvs.push_back(v);\n\t}\n\n\tvoid rdfs(int v,int cnt){\n\t\tscc[cnt].push_back(v);\n\t\tcmp[v] = cnt;\n\t\tfor(int to : rG[v]) if(cmp[to] == -1) rdfs(to,cnt);\n\t}\n\n\tvoid build(){\n\t\tint n = g.size(),cnt = 0;\n\t\tfor(int i = 0;i < n;i++) if(!used[i]) dfs(i);\n\t\treverse(vs.begin(),vs.end());\n\t\tfor(int v : vs){\n\t\t\tif(cmp[v] == -1){\n\t\t\t\tscc.emplace_back();\n\t\t\t\trdfs(v,cnt++);\n\t\t\t}\n\t\t}\n\t\tnG.resize(cnt);\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(const auto &e : g[i]){\n\t\t\t\tint u = cmp[i],v = cmp[(int)e];\n\t\t\t\tif(u != v) nG[u].push_back(v);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < cnt;i++){\n\t\t\tsort(nG[i].begin(),nG[i].end());\n\t\t\tnG[i].erase(unique(nG[i].begin(),nG[i].end()),nG[i].end());\n\t\t}\n\t}\n};\n\nint n;\n\nvoid solve(){\n\tGraph G(n);\n\tdouble p[110];\n\tfor(int i = 0;i < n;i++){\n\t\tint m;\n\t\tcin >> p[i] >> m;\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tint a;\n\t\t\tcin >> a; a--;\n\t\t\tG[i].push_back(a);\n\t\t}\n\t}\n\tSCC<Graph> scc(G);\n\tscc.build();\n\tint in[110] = {};\n\tfor(int i = 0;i < scc.nG.size();i++){\n\t\tfor(int to : scc.nG[i]) in[to]++;\n\t}\n\tdouble ans = 1;\n\tfor(int i = 0;i < scc.nG.size();i++){\n\t\tif(!in[i]){\n\t\t\tdouble tmp = 1;\n\t\t\tfor(int v : scc.scc[i]) tmp *= p[v];\n\t\t\tans *= 1.0 - tmp;\n\t\t}\n\t}\n\tprintf(\"%.14lf\\n\",ans);\n}\n\nsigned main(){\n\twhile(cin >> n,n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX_V 1000\nint V,cmp[MAX_V];\nvector<int> G[MAX_V],rG[MAX_V],vs,a,xx;\nint used[MAX_V];\nvoid addedge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n} \nvoid dfs(int v){\n  used[v]=1;\n  for(int i=0;i<G[v].size();i++)\n    if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\nvoid rdfs(int v,int k){\n  used[v]=1;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n}\nvoid dfs2(int v,int k){\n  used[v]=k;\n  for(int i=0;i<G[v].size();i++)\n    if(!used[G[v][i]])dfs(G[v][i]);\n  xx.push_back(v);\n}\nint scc(){\n  int pp=0;\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)\n    if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=1;\n  for(int i=vs.size()-1;i>=0;i--)\n    if(!used[vs[i]]){\n      rdfs(vs[i],k++);\n    }\n  k=1;\n  map<int,int>m;\n  memset(used,0,sizeof(used));\n  r(i,V){\n    if(!used[i]){\n      dfs(i);\n      xx.clear();\n      r(j,xx.size())if(used[xx[j]]!=k){\n        m[used[xx[j]]]=0;\n      }\n      m[i]=cmp[i];\n      k++;\n    }\n  }\n  r(i,V)if(m[i])\n    a.push_back(m[i]);\n  return k;\n}\nint main(){\n  int x,y;\n  while(cin>>V,V){\n    double d[V],ans=0;\n    a.clear();\n    r(i,1000)G[i].clear(),rG[i].clear();\n    r(i,V){\n      cin>>d[i]>>x;\n      r(j,x){\n        cin>>y;\n        addedge(i,y-1);\n      }\n    }\n    scc();\n    int cnt=0;\n    r(i,a.size()){\n      double p=0;\n      int c=0;\n      r(j,V)if(cmp[j]==a[i]){\n        if(!c++)p+=d[j];\n        else p*=d[j];\n      }\n      if(!cnt++)ans+=(1.0-p);\n      else ans*=(1.0-p);\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define min(p,q)((p)<(q)?(p):(q))\n\ndouble p[110];\n\n//辺の情報を個別に持つタイプ\ntypedef struct edge{ll s,g;}E;\ntypedef struct graph{\n\tint vcnt,ecnt;\n\tE  e[10010];//適宜変える(ecnt)\n\tint id[110];//適宜変える(vcnt)\n}G;\nG g;\n\nint esort(const void*a,const void*b){\n\tE*p=(E*)a,*q=(E*)b;\n\tif((*p).s<(*q).s)return -1;\n\tif((*p).s>(*q).s)return  1;\n\tif((*p).g<(*q).g)return -1;\n\treturn 1;\n}\nvoid readgraph(ll n){\n\t//適宜変える\n\tint ecnt=0;\n\trep(i,0,n){\n\t\tint k;\n\t\tscanf(\"%lf%d\",p+i,&k);\n\t\twhile(k--){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tx--;\n\t\t\tg.e[ecnt].s=i;\n\t\t\tg.e[ecnt].g=x;\n\t\t\tecnt++;\n\t\t}\n\t}\n\tg.vcnt=n;\n\tg.ecnt=ecnt;\n\tqsort(g.e,g.ecnt,sizeof(E),esort);\n\n\tint p=0;\n\trep(i,0,g.vcnt){\n\t\twhile(p<g.ecnt&&g.e[p].s<i)p++;\n\t\tg.id[i]=p;\n\t}\n\tg.id[g.vcnt]=g.ecnt;//番兵\n}\n\n#define VCNT 110\nint SCC[VCNT],SCCcnt;//SCC[i]=頂点iが属する強連結成分の番号\nint SCCi[VCNT],SCCidx[VCNT];//SCCi[SCCidx[i]:SCCidx[i+1]]=強連結成分iに属する頂点の番号\nint adv[VCNT],back[VCNT];\nint sccs[VCNT],sccscnt;\nint isin[VCNT],scct;\n#undef VCNT\nvoid sccdfs(int v){\n\tadv[v]=back[v]=++scct;\n\tsccs[sccscnt++]=v;\n\tisin[v]=1;\n\trep(i,g.id[v],g.id[v+1]){\n\t\tint u=g.e[i].g;\n\t\tif(isin[u]!=2){\n\t\t\tif(isin[u]==0)sccdfs(u);\n\t\t\tback[v]=min(back[v],back[u]);\n\t\t}\n\t}\n\tif(back[v]==adv[v]){\n\t\tint u;\n\t\tdo{\n\t\t\tu=sccs[--sccscnt];\n\t\t\tisin[u]=2;\n\t\t\tSCC[u]=SCCcnt;\n\t\t}while(u!=v);\n\t\tSCCcnt++;\n\t}\n}\nint sccc(const void*p,const void*q){\n\tif(SCC[*(int*)p]<SCC[*(int*)q])return -1;\n\tif(SCC[*(int*)p]>SCC[*(int*)q])return 1;\n\tif(*(int*)p<*(int*)q)return -1;\n\treturn 1;\n}\nvoid scc(){\n\tSCCcnt=0;\n\trep(i,0,g.vcnt)isin[i]=adv[i]=0;\n\trep(i,0,g.vcnt)if(!adv[i])sccdfs(i);\n\trep(i,0,g.vcnt)SCCi[i]=i;\n\tqsort(SCCi,g.vcnt,sizeof(int),sccc);\n\n\tSCCidx[0]=0;\n\tSCCidx[SCCcnt]=g.vcnt;\n\trep(i,1,g.vcnt)if(SCC[SCCi[i-1]]!=SCC[SCCi[i]])SCCidx[SCC[SCCi[i]]]=i;\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n),n){\n\t\treadgraph(n);\n\t\tscc();\n\t\tint deg[110]={};\n\t\trep(i,0,g.ecnt)if(SCC[g.e[i].s]!=SCC[g.e[i].g])deg[SCC[g.e[i].g]]++;\n\t\tdouble pp[110]={};\n\t\trep(i,0,SCCcnt)pp[i]=deg[i]?0:1;\n\t\trep(i,0,g.vcnt)pp[SCC[i]]*=p[i];\n\t\tdouble ans=1;\n\t\trep(i,0,SCCcnt)ans*=1-pp[i];\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint cmp[100010],r=0,f[10010];\nvoid sdfs(int e,int s,int k,int *ta,int *to,int *nt,int *id){\n  int i;\n  f[s]++;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(i<e&&k<0&&f[to[i]]<0||i>=e&&k>=0&&!f[to[i]])sdfs(e,to[i],k,ta,to,nt,id);\n  }\n  k<0?(id[r++]=s):(cmp[s]=k);\n}\nvoid scc(int v,int e,int *a,int *b){\n  int ta[10010],to[60010],nt[60010],id[10010],i,k;\n  for(i=0;i<v;i++)f[i]=ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ta[a[i]]=i;\n    ta[b[i]]=i+e;\n  }\n  for(i=k=0;i<v;i++){\n    if(f[i]==-1)sdfs(e,i,-1,ta,to,nt,id);\n  }\n  for(i=r;i;i--){\n    if(f[id[i-1]]==0)sdfs(e,id[i-1],id[i-1],ta,to,nt,id);\n  }\n}\nint main(){\n  int n,i,j,l,e,a[100010],b[100010];\n  double d[100010],ans;\n  while(scanf(\"%d\",&n),n){\n    for(i=e=0;i<n;i++){\n      scanf(\"%lf %d\",&d[i],&l);\n      while(l--){\n\tscanf(\"%d\",&j);\n\ta[e]=i;\n\tb[e++]=j-1;\n      }\n    }\n    scc(n,e,a,b);\n    for(i=0;i<n;i++){\n      if(cmp[i]-i)d[cmp[i]]*=d[i];\n    }\n    //for(i=0;i<n;i++)printf(\"%d\\n\",cmp[i]);\n    for(i=0;i<e;i++){\n      if(a[i]-cmp[a[i]])continue;\n      d[b[i]]=0;\n    }\n    //for(i=0;i<n;i++)printf(\"%lf\\n\",d[i]);\n    ans=1;\n    for(i=0;i<n;i++){\n      if(cmp[i]==i)ans*=(1-d[i]);\n    }\n    printf(\"%.10lf\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint cmp[100010],r=0,f[10010];\nvoid sdfs(int e,int s,int k,int *ta,int *to,int *nt,int *id){\n  int i;\n  f[s]++;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(i<e&&k<0&&f[to[i]]<0||i>=e&&k>=0&&!f[to[i]])sdfs(e,to[i],k,ta,to,nt,id);\n  }\n  k<0?(id[r++]=s):(cmp[s]=k);\n}\nvoid scc(int v,int e,int *a,int *b){\n  int ta[10010],to[60010],nt[60010],id[10010],i,k;\n  for(i=0;i<v;i++)f[i]=ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ta[a[i]]=i;\n    ta[b[i]]=i+e;\n  }\n  for(i=k=0;i<v;i++){\n    if(f[i]==-1)sdfs(e,i,-1,ta,to,nt,id);\n  }\n  for(i=r;i;i--){\n    if(f[id[i-1]]==0)sdfs(e,id[i-1],id[i-1],ta,to,nt,id);\n  }\n}\nint main(){\n  int n,i,j,l,e,a[100010],b[100010];\n  double d[100010],ans;\n  while(scanf(\"%d\",&n),n){\n    for(i=e=0;i<n;i++){\n      scanf(\"%lf %d\",&d[i],&l);\n      while(l--){\n\tscanf(\"%d\",&j);\n\ta[e]=i;\n\tb[e++]=j-1;\n      }\n    }\n    //for(i=0;i<e;i++)printf(\"%d %d\\n\",a[i],b[i]);\n    scc(n,e,a,b);\n    for(i=0;i<n;i++){\n      if(cmp[i]-i)d[cmp[i]]*=d[i];\n    }\n    //for(i=0;i<n;i++)printf(\"%d %d %lf\\n\",i,cmp[i],d[i]);\n    for(i=0;i<e;i++){\n      if(cmp[a[i]]==cmp[b[i]])continue;\n      d[b[i]]=0;\n    }\n    //for(i=0;i<n;i++)printf(\"%lf\\n\",d[i]);\n    ans=1;\n    for(i=0;i<n;i++){\n      if(cmp[i]==i)ans*=(1-d[i]);\n    }\n    printf(\"%.9lf\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2748 Early Morning Work at Summer Camp\n// 2018.4.26 bal4u\n\n#include <stdio.h>\n#include <malloc.h>\n#include <string.h>\n\n#define MAX_V 102\nint  V;    // 頂点数\nint  to[MAX_V][MAX_V], hi[MAX_V];\nint  r_to[MAX_V][MAX_V], r_hi[MAX_V];\nint  g_to[MAX_V][MAX_V], g_hi[MAX_V];\nint  vs[MAX_V], vsz;\nchar used[MAX_V];\nint  cmp[MAX_V];    // 属する強連結成分のトポロジカル順序\n\nvoid add_edge(int _from, int _to)\n{\n\tto[_from][hi[_from]++] = _to;\n\tr_to[_to][r_hi[_to]++] = _from;\n}\n\nvoid dfs(int v)\n{\n\tint i;\n\tused[v] = 1;\n\tfor (i = 0; i < hi[v]; i++) {\n\t\tif (!used[to[v][i]]) dfs(to[v][i]);\n\t}\n\tvs[vsz++] = v;\n}\n\nvoid rdfs(int v, int k)\n{\n\tint i;\n\tused[v] = 1;\n\tcmp[v] = k;\n\tg_to[k][g_hi[k]++] = v;\n\tfor (i = 0; i < r_hi[v]; i++) {\n\t\tif (!used[r_to[v][i]]) rdfs(r_to[v][i], k);\n\t}\n}\n\n// 強連結成分への分解\nint scc()\n{\n\tint v, i, k;\n\tmemset(used, 0, V);\n\tvsz = 0;\n\tfor (v = 0; v < V; v++) if (!used[v]) dfs(v);\n\tmemset(used, 0, V);\n\tk = 0;\n\tfor (i = vsz-1; i >= 0; i--) {\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;       // 得られた強連結成分の数\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\n// 実数対応\ndouble getdbl()\n{\n\tdouble x, y;\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\tif (c == '.') {\n\t\tx = 0;\n\t\ty = 1, c = getchar_unlocked();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t\tx += n;\n\t} else x = n;\n\treturn x;\n}\n\ndouble p[102];\n\nint main()\n{\n\tint N, m, i, j, k, f, v;\n\tdouble a, ans;\n\n\twhile (N = in()) {\n\t\tV = N;\n\t\tmemset(hi, 0, V<<2), memset(r_hi, 0, V<<2);\n\t\tmemset(g_hi, 0, V<<2);\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tp[i] = getdbl();\n\t\t\tm = in();\n\t\t\twhile (m--) add_edge(i, in()-1);\n\t\t}\n\n\t\tk = scc();\n\t\tans = 1;\n\t\tfor (i = 0; i < k; i++) {\n\t\t\tf = 1, a = 1;\n\t\t\tfor (j = 0; j < g_hi[i]; j++) {\n\t\t\t\ta *= p[g_to[i][j]];\n\t\t\t\tfor (v = 0; v < r_hi[g_to[i][j]]; v++) {\n\t\t\t\t\tf &= (cmp[g_to[i][j]] == cmp[r_to[g_to[i][j]][v]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) ans *= 1.0-a;\n\t\t}\n\t\tprintf(\"%.10lf\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#define N 1000\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef struct{\n    int num;\n    int post;\n}Data;\nint comp(const void *a,const void *b){\n    Data c = *(Data *)a;\n    Data d = *(Data *)b;\n    return d.post-c.post;\n}\nData d[N];\nint used[N]={0};\ndouble map[N][N]={0};\nint g[N][N]={0};\nint len[N];\nint n,m,cnt;\nvoid init(){\n    rep(i,n){\n        used[i]=len[i]=0;\n        rep(j,n){\n            map[i][j]=g[i][j]=0;\n        }\n    }\n}\n\nvoid init2(){\n    rep(i,n){\n        used[i]=0;\n    }\n}\n\nvoid dfs(int pos){//ラベル\n    if(used[pos]) return;\n    used[pos]=1;\n    rep(i,n){\n        if(used[i]) continue;\n        if(map[pos][i]){\n            dfs(i);\n        }\n    }\n    d[pos].post=++cnt;\n}\nvoid dfs_init(){\n    cnt=0;\n    rep(i,n){\n        dfs(i);\n    }\n}\n\nvoid dfs2(int j,int pos){//強連結分解\n    if(used[pos]) return;\n    used[pos]=1; g[j][cnt++]=pos;\n    len[j]=cnt;\n    rep(i,n){\n        if(used[i]) continue;\n        if(map[i][pos]){\n            dfs2(j,i);\n        }\n    }\n}\nvoid dfs2_init(){\n    init2();\n    int idx=0;\n    rep(i,n){\n        cnt=0;\n        if(used[d[i].num]);\n        else{\n            dfs2(idx,d[i].num);\n            idx++;\n        }\n    }\n}\nint wake(int i){\n    int used2[N]={0};\n    rep(j,len[i]) used2[g[i][j]]=1;\n    rep(j,len[i]){\n        rep(k,n){\n            if(used2[k]) continue;\n            if(map[k][g[i][j]]) return 0;\n        }\n    }\n    return 1;\n}\nint main(void){\n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        init();\n        double p[N]={0};\n        rep(i,n){\n            double p_;\n            int x,y;\n            scanf(\"%lf%d\",&p_,&x);\n            p[i]=p_;\n            rep(j,x){\n                scanf(\"%d\",&y);\n                map[i][y-1]=1;\n            }\n        }\n        rep(i,n){\n            d[i].num=i;\n            d[i].post=1;\n        }\n        dfs_init();\n        //printf(\"%d\\n\",cnt); rep(i,n) printf(\"%d \",d[i].post); puts(\"\\n\");\n        qsort(d,n,sizeof(Data),comp);\n        dfs2_init();\n        /*rep(i,n){\n            if(len[i]==0) continue;\n            rep(j,len[i]){\n                printf(\"%d \",g[i][j]);\n            }puts(\"\");\n        }puts(\"\");*/\n        /*rep(i,n){\n            rep(j,n){\n                printf(\"%6f \",map[i][j]);\n            }puts(\"\");\n        }puts(\"\");*/\n        double sum=1;\n        rep(i,n){\n            if(len[i]==0) continue;\n            double tmp=1;\n            if(wake(i)){\n                rep(j,len[i])\n                tmp*=p[g[i][j]];\n                sum*=(1-tmp);\n            }\n        }\n        printf(\"%.9f\\n\",sum);\n    }\n    \n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint cmp[100010],r=0,f[10010];\nvoid sdfs(int e,int s,int k,int *ta,int *to,int *nt,int *id){\n  int i;\n  f[s]++;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(i<e&&k<0&&f[to[i]]<0||i>=e&&k>=0&&!f[to[i]])sdfs(e,to[i],k,ta,to,nt,id);\n  }\n  k<0?(id[r++]=s):(cmp[s]=k);\n}\nvoid scc(int v,int e,int *a,int *b){\n  int ta[10010],to[60010],nt[60010],id[10010],i,k;\n  for(i=0;i<v;i++)f[i]=ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ta[a[i]]=i;\n    ta[b[i]]=i+e;\n  }\n  for(i=k=0;i<v;i++){\n    if(f[i]==-1)sdfs(e,i,-1,ta,to,nt,id);\n  }\n  for(i=r;i;i--){\n    if(f[id[i-1]]==0)sdfs(e,id[i-1],id[i-1],ta,to,nt,id);\n  }\n}\nint main(){\n  int n,i,j,l,e,a[100010],b[100010];\n  double d[100010],ans;\n  while(scanf(\"%d\",&n),n){\n    for(i=e=0;i<n;i++){\n      scanf(\"%lf %d\",&d[i],&l);\n      while(l--){\n\tscanf(\"%d\",&j);\n\ta[e]=i;\n\tb[e++]=j-1;\n      }\n    }\n    scc(n,e,a,b);\n    for(i=0;i<n;i++){\n      if(cmp[i]-i)d[cmp[i]]*=d[i];\n    }\n    //for(i=0;i<n;i++)printf(\"%d\\n\",cmp[i]);\n    for(i=0;i<e;i++){\n      if(a[i]-cmp[a[i]])continue;\n      d[b[i]]=0;\n    }\n    //for(i=0;i<n;i++)printf(\"%lf\\n\",d[i]);\n    ans=1;\n    for(i=0;i<n;i++){\n      if(cmp[i]==i)ans*=(1-d[i]);\n    }\n    printf(\"%lf\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int n;\n  double[] p;\n  ArrayList<LinkedList<Integer>> adj;\n\n  class Node {\n    ArrayList<Integer> vertexes = new ArrayList<>();\n    LinkedList<Integer> adj = new LinkedList<>();\n\n    @Override\n    public String toString() {\n      return vertexes.toString();\n    }\n  }\n\n  int[] counts;\n  int count;\n  boolean[] done;\n\n  void dfs(int v) {\n    if (done[v]) {\n      return;\n    }\n    done[v] = true;\n    for (int next : adj.get(v)) {\n      dfs(next);\n    }\n    counts[v] = count++;\n  }\n\n  ArrayList<LinkedList<Integer>> gyaku;\n\n  Node dfs2(int v) {\n    if (done[v]) {\n      return null;\n    }\n    done[v] = true;\n    Node node = new Node();\n    for (int next : gyaku.get(v)) {\n      Node ret = dfs2(next);\n      if (ret == null) {\n        continue;\n      }\n      node.vertexes.addAll(ret.vertexes);\n    }\n    node.vertexes.add(v);\n    return node;\n  }\n\n  ArrayList<Node> bunkai() {\n    counts = new int[n];\n    Arrays.fill(counts, -1);\n    count = 0;\n    done = new boolean[n];\n    for (int i = 0; i < n; ++i) {\n      if (counts[i] != -1) {\n        continue;\n      }\n      dfs(i);\n    }\n    gyaku = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      gyaku.add(new LinkedList<>());\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int v : adj.get(i)) {\n        gyaku.get(v).add(i);\n      }\n    }\n    Arrays.fill(done, false);\n    ArrayList<Node> list = new ArrayList<>();\n    int number = 0;\n    int[] numbers = new int[n];\n    for (; ; ) {\n      int index = -1;\n      int max = -1;\n      for (int i = 0; i < n; ++i) {\n        if (done[i]) {\n          continue;\n        }\n        if (max < counts[i]) {\n          max = counts[i];\n          index = i;\n        }\n      }\n      if (index == -1) {\n        break;\n      }\n      Node node = dfs2(index);\n      list.add(node);\n      for (int v : node.vertexes) {\n        numbers[v] = number;\n      }\n      ++number;\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int v : gyaku.get(i)) {\n        int x = numbers[i];\n        int y = numbers[v];\n        if (x == y) {\n          continue;\n        }\n        list.get(x).adj.add(y);\n      }\n    }\n    return list;\n  }\n\n  void run() {\n    for (; ; ) {\n      n = ni();\n      if (n == 0) {\n        break;\n      }\n      p = new double[n];\n      adj = new ArrayList<>();\n      for (int i = 0; i < n; ++i) {\n        adj.add(new LinkedList<>());\n      }\n      for (int i = 0; i < n; ++i) {\n        p[i] = sc.nextDouble();\n        int m = ni();\n        for (int j = 0; j < m; ++j) {\n          int a = ni() - 1;\n          adj.get(i).add(a);\n        }\n      }\n      ArrayList<Node> list = bunkai();\n      double ans = 1;\n      for (Node node : list) {\n        if (node.adj.size() > 0) {\n          continue;\n        }\n        double sub = 1;\n        for (int v : node.vertexes) {\n          sub *= p[v];\n        }\n        ans *= 1 - sub;\n      }\n      System.out.printf(\"%.9f\\n\", ans);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main(string[] args)\n    {\n        while (true) {\n            int n = sc.Int;\n            if (n == 0) break;\n            var p = new double[n];\n            var edge = new List<int>[n];\n            for (int i = 0; i < n; i++)\n            {\n                var inp = sc.StrArr;\n                p[i] = Double.Parse(inp[0]);\n                edge[i] = new List<int>();\n                for (int j = 2; j < inp.Length; j++)\n                {\n                    edge[i].Add(int.Parse(inp[j]) - 1);\n                }\n            }\n            List<int>[] newedge;\n            var cmp = Scc.scc(edge, out newedge);\n            int k = newedge.Length;\n            var ic = new int[k];\n            var pp = new double[k];\n            for (int i = 0; i < k; i++)\n            {\n                pp[i] = 1;\n                foreach (var item in newedge[i])\n                {\n                    ++ic[item];\n                }\n            }\n            for (int i = 0; i < n; i++)\n            {\n                pp[cmp[i]] *= p[i];\n            }\n            double ans = 1;\n            for (int i = 0; i < k; i++)\n            {\n                if (ic[i] == 0) {\n                    ans *= 1 - pp[i];\n                }\n            }\n            Prt(ans.ToString(\"F9\"));\n        }\n        sw.Flush();\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nstatic class Scc\n{\n    public static int[] scc(List<int>[] edge, out List<int>[] cmped_edge) {\n        int n = edge.Length;\n        var vis = new bool[n];\n        var st = new Stack<int>();\n        var cmp = new int[n];\n        for (int i = 0; i < n; i++) if (!vis[i]) dfs(i, -1, vis, st, cmp, edge);\n\n        vis = new bool[n];\n        var rev = new List<int>[n];\n        for (int i = 0; i < n; i++) rev[i] = new List<int>();\n        for (int i = 0; i < n; i++) foreach (int j in edge[i]) rev[j].Add(i);\n        int k = 0;\n        while (st.Any()) {\n            int i = st.Pop();\n            if (!vis[i]) dfs(i, k++, vis, new Stack<int>(), cmp, rev);\n        }\n        var cmped_edge_set = new HashSet<int>[k];\n        for (int i = 0; i < k; i++) cmped_edge_set[i] = new HashSet<int>();\n        for (int i = 0; i < n; i++)\n            foreach (var item in edge[i])\n                if (cmp[i] != cmp[item])\n                    cmped_edge_set[cmp[i]].Add(cmp[item]);\n\n        cmped_edge = new List<int>[k];\n        for (int i = 0; i < k; i++) cmped_edge[i] = cmped_edge_set[i].ToList();\n\n        return cmp;\n    }\n    static void dfs(int v, int k, bool[] vis, Stack<int> st, int[] cmp, List<int>[] edge) {\n        vis[v] = true;\n        cmp[v] = k;\n        foreach (int i in edge[v]) if (!vis[i]) dfs(i, k, vis, st, cmp, edge);\n        st.Push(v);\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main(string[] args)\n    {\n        while (true) {\n            int n = sc.Int;\n            if (n == 0) break;\n            var p = new double[n];\n            var edge = new List<int>[n];\n            for (int i = 0; i < n; i++)\n            {\n                var inp = sc.StrArr;\n                p[i] = Double.Parse(inp[0]);\n                edge[i] = new List<int>();\n                for (int j = 2; j < inp.Length; j++)\n                {\n                    edge[i].Add(int.Parse(inp[j]) - 1);\n                }\n            }\n            List<int>[] newedge;\n            var cmp = Scc.scc(edge, out newedge);\n            int k = newedge.Length;\n            var ic = new int[k];\n            var pp = new double[k];\n            for (int i = 0; i < k; i++)\n            {\n                pp[i] = 1;\n                foreach (var item in newedge[i])\n                {\n                    ++ic[item];\n                }\n            }\n            for (int i = 0; i < n; i++)\n            {\n                pp[cmp[i]] *= p[i];\n            }\n            double ans = 1;\n            for (int i = 0; i < k; i++)\n            {\n                if (ic[i] == 0) {\n                    ans *= 1 - pp[i];\n                }\n            }\n            Prt(ans);\n        }\n        sw.Flush();\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nstatic class Scc\n{\n    public static int[] scc(List<int>[] edge, out List<int>[] cmped_edge) {\n        int n = edge.Length;\n        var vis = new bool[n];\n        var st = new Stack<int>();\n        var cmp = new int[n];\n        for (int i = 0; i < n; i++) if (!vis[i]) dfs(i, -1, vis, st, cmp, edge);\n\n        vis = new bool[n];\n        var rev = new List<int>[n];\n        for (int i = 0; i < n; i++) rev[i] = new List<int>();\n        for (int i = 0; i < n; i++) foreach (int j in edge[i]) rev[j].Add(i);\n        int k = 0;\n        while (st.Any()) {\n            int i = st.Pop();\n            if (!vis[i]) dfs(i, k++, vis, new Stack<int>(), cmp, rev);\n        }\n        var cmped_edge_set = new HashSet<int>[k];\n        for (int i = 0; i < k; i++) cmped_edge_set[i] = new HashSet<int>();\n        for (int i = 0; i < n; i++)\n            foreach (var item in edge[i])\n                if (cmp[i] != cmp[item])\n                    cmped_edge_set[cmp[i]].Add(cmp[item]);\n\n        cmped_edge = new List<int>[k];\n        for (int i = 0; i < k; i++) cmped_edge[i] = cmped_edge_set[i].ToList();\n\n        return cmp;\n    }\n    static void dfs(int v, int k, bool[] vis, Stack<int> st, int[] cmp, List<int>[] edge) {\n        vis[v] = true;\n        cmp[v] = k;\n        foreach (int i in edge[v]) if (!vis[i]) dfs(i, k, vis, st, cmp, edge);\n        st.Push(v);\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'tsort'\nrequire 'set'\n\nclass Hash\n    include TSort\n    alias tsort_each_node each_key\n    def tsort_each_child(u)\n        self[u].each do |v|\n            yield(v)\n        end\n    end\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    g = {}\n    sleep_prob = []\n    n.times do |i|\n        g[i] = Set.new\n        q, _, *neighbours = gets.split.map(&:to_f)\n        sleep_prob[i] = q\n        neighbours.each do |j|\n            g[i] << j.to_i - 1\n        end\n    end\n    scc = g.strongly_connected_components\n    dict = {}\n    scc.each.with_index do |a, i|\n        a.each do |j|\n            dict[j] = i\n        end\n    end\n\n    roots = Set[*(0..scc.size-1).to_a]\n    g.each_key do |i|\n        g[i].each do |j|\n            next if dict[i] == dict[j]\n            roots.delete(dict[j])\n        end\n    end\n\n    ans = roots.map {|i| 1 - scc[i].map {|j| sleep_prob[j]}.inject(:*)}.inject(:*)\n    printf(\"%.9f\\n\", ans)\nend"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nclass Graph {\n    int V;\n    int[][] g, rg;\n    this(int V) {\n        g = new int[][V];\n        rg = new int[][V];\n        this.V = V;\n    }\n    void addEdge(int from, int to) {\n        g[from] ~= to;\n        rg[to] ~= from;\n    }\n    /* ????????????????????????????????????????????? */\n    int[] scc() {\n        auto used = new bool[V];\n        int[] vs;\n        void dfs1(int v) {\n            used[v] = true;\n            foreach (u; g[v]) {\n                if (used[u]) continue;\n                dfs1(u);\n            }\n            vs ~= v;\n        }\n        void dfs2(int v, int k, int[] order) {\n            used[v] = true;\n            order[v] = k;\n            foreach (u; rg[v]) {\n                if (used[u]) continue;\n                dfs2(u, k, order);\n            }\n        }\n        foreach (v; 0 .. V) {\n            if (used[v]) continue;\n            dfs1(v);\n        }\n        used[] = false;\n        int k = 0;\n        auto ord = new int[V]; ord[] = -1;\n        foreach_reverse (v; vs) {\n            if (used[v]) continue;\n            dfs2(v, k++, ord);\n        }\n        return ord;\n    }\n}\n\nvoid main() {\n    while (true) {\n        int N; readf(\"%d\\n\", &N);\n        if (N == 0) break;\n        auto P = new real[N];\n        auto g = new Graph(N);\n        foreach (i; 0 .. N) {\n            real p; int m; readf(\"%s %d\", &p, &m);\n            auto a = readln.strip.split(\" \").map!((s) => s.to!int - 1);\n            P[i] = p;\n            foreach (x; a) {\n                g.addEdge(i, x);\n            }\n        }\n        auto ord = g.scc();\n        auto used = new bool[N];\n        void dfs(int v) {\n            foreach (u; g.g[v]) {\n                if (used[u]) continue;\n                used[u] = true;\n                dfs(u);\n            }\n        }\n        real ans = 1.0;\n        foreach (int k; 0 .. ord.reduce!max + 1) {\n            foreach (i; 0 .. N) {\n                if (ord[i] != k) continue;\n                real p = 1.0;\n                if (used[i]) continue;\n                foreach (j; 0 .. N) {\n                    if (ord[i] == ord[j]) {\n                        p *= P[j];\n                    }\n                }\n                ans *= 1.0 - p;\n                used[i] = true;\n                dfs(i);\n            }\n        }\n        writefln(\"%.9f\", ans);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "\ndef dfs(s):\n    for t in G[s]:\n        if not used[t]:\n            used[t] = 1\n            dfs(t)\n    res.append(s)\ndef rdfs(s, l):\n    for t in RG[s]:\n        if label[t] is None:\n            label[t] = l\n            rdfs(t, l)\n\nwhile 1:\n    n = int(input())\n    if n == 0:\n        break\n    G = [[] for i in range(n)]\n    RG = [[] for i in range(n)]\n    P = []\n    for i in range(n):\n        p, m, *A = input().split()\n        P.append(float(p))\n        for t in map(int, A):\n            G[i].append(t-1)\n            RG[t-1].append(i)\n    used = [0]*n\n    res = []\n    for i in range(n):\n        if not used[i]:\n            used[i] = 1\n            dfs(i)\n    label = [None]*n; k = 0\n    for i in reversed(res):\n        if label[i] is None:\n            label[i] = k\n            rdfs(i, k)\n            k += 1\n    GP = [1.]*k; GF = [0]*k\n    for s in range(n):\n        l = label[s]\n        GP[l] *= P[s]\n        for t in G[s]:\n            if label[s] != label[t]:\n                GF[label[t]] += 1\n    ans = 1.\n    for i in range(k):\n        if GF[i] == 0:\n            ans *= 1.-GP[i]\n    print(\"%.9f\" % (ans))"
  },
  {
    "language": "Python",
    "code": "def fix(c):\n  return int(c) - 1\n\ndef bfs(x, order, visited):\n  if visited[x]:\n    return\n  visited[x] = True\n  for to in edges[x]:\n    bfs(to, order, visited)\n  order.append(x)\n\ndef bfs_rev(x, visited):\n  if visited[x]:\n    return []\n  visited[x] = True\n  ret = [x]\n  for to in rev_edges[x]:\n    ret = ret + bfs_rev(to, visited)\n  return ret\n\ndef bfs2(x, visited):\n  if visited[x]:\n    return\n  visited[x] = True\n  for to in edges[x]:\n    bfs2(to, visited)\n\nwhile True:\n  n = int(input())\n  if n == 0:\n    break\n  edges = []\n  score = []\n  for _ in range(n):\n    lst = input().split()\n    score.append(float(lst[0]))\n    edges.append(list(map(fix, lst[2:])))\n  rev_edges = [[] for _ in range(n)]\n  for i in range(n):\n    for e in edges[i]:\n      rev_edges[e].append(i)\n  \n  #帰りがけ順取得\n  visited = [False] * n\n  order = []\n  for x in range(n):\n    bfs(x, order, visited)\n  order.reverse()\n  \n  #強連結成分分解\n  visited = [False] * n\n  cycles = []\n  for x in order:\n    if not visited[x]:\n      cycle = bfs_rev(x, visited)\n      cycles.append(cycle)\n\n  visited = [False] * n\n  ans = 1\n  for x in order:\n    if not visited[x]:\n      for cycle in cycles:\n        if x in cycle:\n          acc = 1\n          for node in cycle:\n            bfs2(node, visited)\n            acc *= score[node]\n          ans *= (1 - acc)\n  print(\"{0:.7f}\".format(ans))\n"
  },
  {
    "language": "Python",
    "code": "def fix(c):\n  return int(c) - 1\n\ndef bfs(x, order, visited):\n  if visited[x]:\n    return\n  visited[x] = True\n  for to in edges[x]:\n    bfs(to, order, visited)\n  order.append(x)\n\ndef bfs_rev(x, visited):\n  if visited[x]:\n    return []\n  visited[x] = True\n  ret = [x]\n  for to in rev_edges[x]:\n    ret = ret + bfs_rev(to, visited)\n  return ret\n\ndef bfs2(x, visited):\n  if visited[x]:\n    return\n  visited[x] = True\n  for to in edges[x]:\n    bfs2(to, visited)\n\nwhile True:\n  n = int(input())\n  if n == 0:\n    break\n  edges = []\n  score = []\n  for _ in range(n):\n    lst = input().split()\n    score.append(float(lst[0]))\n    edges.append(list(map(fix, lst[2:])))\n  rev_edges = [[] for _ in range(n)]\n  for i in range(n):\n    for e in edges[i]:\n      rev_edges[e].append(i)\n  \n  #帰りがけ順取得\n  visited = [False] * n\n  order = []\n  for x in range(n):\n    bfs(x, order, visited)\n  order.reverse()\n  \n  #強連結成分分解\n  visited = [False] * n\n  cycles = []\n  for x in order:\n    if not visited[x]:\n      cycle = bfs_rev(x, visited)\n      cycles.append(cycle)\n\n  visited = [False] * n\n  ans = 1\n  for x in order:\n    if not visited[x]:\n      for cycle in cycles:\n        if x in cycle:\n          acc = 1\n          for node in cycle:\n            bfs2(node, visited)\n            acc *= score[node]\n          ans *= (1 - acc)\n\n  print(ans)\n"
  }
]