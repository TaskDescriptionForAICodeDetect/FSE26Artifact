[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, m, k, i, j;\n    double probability;\n\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n\n        double* oversleep_prob = malloc(n * sizeof(double));\n        int** contacts = malloc(n * sizeof(int*));\n        int* contact_count = malloc(n * sizeof(int));\n\n        for (i = 0; i < n; i++) {\n            scanf(\"%lf\", &oversleep_prob[i]);\n            scanf(\"%d\", &contact_count[i]);\n            contacts[i] = malloc(contact_count[i] * sizeof(int));\n            for (j = 0; j < contact_count[i]; j++) {\n                scanf(\"%d\", &contacts[i][j]);\n            }\n        }\n\n        probability = 1.0;\n        for (i = 0; i < n; i++) {\n            double wake_prob = 1.0 - oversleep_prob[i];\n            for (j = 0; j < contact_count[i]; j++) {\n                int contact = contacts[i][j] - 1;\n                wake_prob += oversleep_prob[i] * (1.0 - oversleep_prob[contact]);\n            }\n            wake_prob = wake_prob > 1.0 ? 1.0 : wake_prob;\n            probability *= wake_prob;\n        }\n\n        printf(\"%.5f\\n\", probability);\n\n        for (i = 0; i < n; i++) {\n            free(contacts[i]);\n        }\n        free(contacts);\n        free(contact_count);\n        free(oversleep_prob);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:56:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    double p_oversleep;\n    int *contacts;\n    int num_contacts;\n    int visited;\n} Participant;\n\ndouble calculateProbability(Participant *participants, int n, int index) {\n    if (participants[index].visited) {\n        return 1.0;\n    }\n    participants[index].visited = 1;\n    double prob = participants[index].p_oversleep;\n    for (int i = 0; i < participants[index].num_contacts; ++i) {\n        int contact = participants[index].contacts[i];\n        prob *= calculateProbability(participants, n, contact);\n    }\n    return prob;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Participant *participants = (Participant *)malloc(n * sizeof(Participant));\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%lf\", &participants[i].p_oversleep);\n            participants[i].p_oversleep = 1.0 - participants[i].p_oversleep;\n            participants[i].num_contacts = 0;\n            participants[i].contacts = NULL;\n            participants[i].visited = 0;\n            \n            int contact;\n            while (scanf(\"%d\", &contact) == 1 && contact != 0) {\n                participants[i].contacts = (int *)realloc(participants[i].contacts, (participants[i].num_contacts + 1) * sizeof(int));\n                participants[i].contacts[participants[i].num_contacts++] = contact - 1;\n            }\n        }\n        \n        double total_prob = 1.0;\n        for (int i = 0; i < n; ++i) {\n            if (!participants[i].visited) {\n                total_prob *= calculateProbability(participants, n, i);\n            }\n        }\n        \n        printf(\"%.6lf\\n\", total_prob);\n        \n        for (int i = 0; i < n; ++i) {\n            free(participants[i].contacts);\n        }\n        free(participants);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:56:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cstring>\n\nusing namespace std;\n\ndouble dfs(int u, const vector<vector<int>>& adj, const vector<double>& prob, vector<bool>& visited) {\n    visited[u] = true;\n    double res = 1.0 - prob[u];\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            res *= dfs(v, adj, prob, visited);\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    while (cin >> n, n != 0) {\n        vector<double> prob(n);\n        vector<vector<int>> adj(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> prob[i];\n            int m;\n            cin >> m;\n            adj[i].resize(m);\n            for (int j = 0; j < m; ++j) {\n                cin >> adj[i][j];\n                --adj[i][j];\n            }\n        }\n\n        vector<bool> visited(n, false);\n        double result = 1.0;\n        for (int i = 0; i < n; ++i) {\n            if (!visited[i]) {\n                result *= dfs(i, adj, prob, visited);\n            }\n        }\n\n        cout << fixed << setprecision(5) << result << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:57:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int n;\n    static double[] p;\n    static List<List<Integer>> adj;\n    static boolean[] visited;\n    static double res;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            n = sc.nextInt();\n            if (n == 0) break;\n            p = new double[n];\n            adj = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                adj.add(new ArrayList<>());\n            }\n            for (int i = 0; i < n; i++) {\n                p[i] = sc.nextDouble();\n                int m = sc.nextInt();\n                for (int j = 0; j < m; j++) {\n                    int a = sc.nextInt() - 1;\n                    adj.get(i).add(a);\n                }\n            }\n            visited = new boolean[n];\n            res = 1.0;\n            for (int i = 0; i < n; i++) {\n                if (!visited[i]) {\n                    dfs(i, true);\n                }\n            }\n            System.out.printf(\"%.9f\\n\", res);\n        }\n        sc.close();\n    }\n\n    static void dfs(int u, boolean isRoot) {\n        visited[u] = true;\n        double prob = 1.0 - p[u];\n        for (int v : adj.get(u)) {\n            if (!visited[v]) {\n                dfs(v, false);\n            }\n            prob *= (1 - p[v]);\n        }\n        if (isRoot) {\n            res *= (1 - prob);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:58:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WakeUpProbability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            \n            double[] probs = new double[n];\n            List<List<Integer>> contacts = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                probs[i] = scanner.nextDouble();\n                int k = scanner.nextInt();\n                List<Integer> personContacts = new ArrayList<>();\n                for (int j = 0; j < k; j++) {\n                    personContacts.add(scanner.nextInt() - 1);\n                }\n                contacts.add(personContacts);\n            }\n            \n            System.out.printf(\"%.6f\\n\", calculateProbability(n, probs, contacts));\n        }\n        \n        scanner.close();\n    }\n    \n    static double calculateProbability(int n, double[] probs, List<List<Integer>> contacts) {\n        return calculateProbabilityRecursive(n, probs, contacts, 0, new boolean[n]);\n    }\n    \n    static double calculateProbabilityRecursive(int n, double[] probs, List<List<Integer>> contacts, \n                                                int person, boolean[] wokenUp) {\n        if (person == n) {\n            return 1.0;\n        }\n        \n        if (wokenUp[person]) {\n            return calculateProbabilityRecursive(n, probs, contacts, person + 1, wokenUp);\n        }\n        \n        double totalProb = 0.0;\n        \n        // Person wakes up on time\n        wokenUp[person] = true;\n        double wakeUpProb = 1.0 - probs[person];\n        double wakeUpScenario = wakeUpProb * calculateProbabilityRecursive(n, probs, contacts, person + 1, wokenUp);\n        totalProb += wakeUpScenario;\n        wokenUp[person] = false;\n        \n        // Person oversleeps but gets a wake-up call\n        double oversleepProb = probs[person];\n        for (int contact : contacts.get(person)) {\n            if (!wokenUp[contact]) {\n                wokenUp[contact] = true;\n                double scenarioProb = oversleepProb * calculateProbabilityRecursive(n, probs, contacts, person + 1, wokenUp);\n                totalProb += scenarioProb;\n                wokenUp[contact] = false;\n            }\n        }\n        \n        return totalProb;\n    }\n}",
    "timestamp": "2025-08-05 21:58:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin >> n && n != 0) {\n        vector<double> p(n);\n        vector<vector<int>> contacts(n);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> p[i];\n        }\n\n        for (int i = 0; i < n; ++i) {\n            int m;\n            cin >> m;\n            contacts[i].resize(m);\n            for (int j = 0; j < m; ++j) {\n                cin >> contacts[i][j];\n                contacts[i][j]--;\n            }\n        }\n\n        double total_prob = 0.0;\n        for (int mask = 0; mask < (1 << n); ++mask) {\n            double prob = 1.0;\n            vector<bool> wakeup(n, false);\n\n            for (int i = 0; i < n; ++i) {\n                if (mask & (1 << i)) {\n                    wakeup[i] = true;\n                    for (int contact : contacts[i]) {\n                        wakeup[contact] = true;\n                    }\n                }\n            }\n\n            for (int i = 0; i < n; ++i) {\n                if (wakeup[i]) {\n                    prob *= 1.0;\n                } else {\n                    prob *= (1.0 - p[i]);\n                }\n            }\n\n            total_prob += prob;\n        }\n\n        cout << fixed << setprecision(6) << total_prob << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:58:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_wake_up_probability():\n    import sys\n    from functools import reduce\n\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    # Helper function to use DFS for wake-up call network\n    def dfs(wake_up, contacts, v):\n        stack = [v]\n        while stack:\n            u = stack.pop()\n            if not wake_up[u]:\n                wake_up[u] = True\n                stack.extend(contacts[u])\n\n    idx = 0\n    results = []\n\n    while data[idx] != '0':\n        n = int(data[idx])\n        idx += 1\n\n        oversleep_prob = list(map(float, data[idx].split()))\n        idx += 1\n        \n        contacts = []\n        for i in range(n):\n            contact_list = list(map(int, data[idx].split()))\n            idx += 1\n            contacts.append(contact_list)\n\n        # Calculate wake-up probability for each participant\n        wake_up = [False] * n\n        total_prob = 1.0\n\n        for i in range(n):\n            if not wake_up[i]:\n                # Try to wake up with contact\n                dfs(wake_up, contacts, i)\n            # Multiply by their probability of being awake on their own\n            total_prob *= (1 - oversleep_prob[i])\n\n        results.append(total_prob)\n\n    for result in results:\n        print(f\"{result:.6f}\")\n\ncalculate_wake_up_probability()",
    "timestamp": "2025-08-13 08:16:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class WakeUpProbability {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n\n            double[] oversleepProb = new double[n];\n            Map<Integer, List<Integer>> contacts = new HashMap<>();\n\n            for (int i = 0; i < n; i++) {\n                oversleepProb[i] = scanner.nextDouble();\n                contacts.put(i, new ArrayList<>());\n                int c = scanner.nextInt();\n                for (int j = 0; j < c; j++) {\n                    contacts.get(i).add(scanner.nextInt());\n                }\n            }\n\n            double wakeUpProb = 1.0;\n\n            boolean[] awake = new boolean[n];\n            Arrays.fill(awake, false);\n\n            for (int i = 0; i < n; i++) {\n                if (!awake[i]) {\n                    Set<Integer> awakeParticipants = new HashSet<>();\n                    Queue<Integer> queue = new LinkedList<>();\n                    queue.offer(i);\n\n                    while (!queue.isEmpty()) {\n                        int current = queue.poll();\n                        if (awakeParticipants.contains(current) || awake[current]) continue;\n                        awakeParticipants.add(current);\n\n                        for (int contact : contacts.get(current)) {\n                            if (!awakeParticipants.contains(contact)) {\n                                queue.offer(contact);\n                            }\n                        }\n                    }\n\n                    double pGroupOverSleep = 1.0;\n                    for (int participant : awakeParticipants) {\n                        pGroupOverSleep *= oversleepProb[participant];\n                    }\n\n                    wakeUpProb *= (1.0 - pGroupOverSleep);\n                    for (int participant : awakeParticipants) {\n                        awake[participant] = true;\n                    }\n                }\n            }\n\n            System.out.printf(\"%.6f\\n\", wakeUpProb);\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 08:17:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PARTICIPANTS 100\n\ndouble probabilities[MAX_PARTICIPANTS];\nint contacts[MAX_PARTICIPANTS][MAX_PARTICIPANTS];\nint numContacts[MAX_PARTICIPANTS];\nint numParticipants;\n\nvoid readInput() {\n    scanf(\"%d\", &numParticipants);\n    for (int i = 0; i < numParticipants; i++) {\n        scanf(\"%lf\", &probabilities[i]);\n        numContacts[i] = 0;\n        int contact;\n        while (scanf(\"%d\", &contact) && contact != 0) {\n            contacts[i][numContacts[i]++] = contact - 1;\n        }\n    }\n}\n\nint isAwake[MAX_PARTICIPANTS];\n\ndouble calculateWakeupProbability(int state) {\n    memset(isAwake, 0, sizeof(isAwake));\n    for (int i = 0; i < numParticipants; i++) {\n        if ((state & (1 << i)) == 0) {\n            isAwake[i] = 1;\n            for (int j = 0; j < numContacts[i]; j++) {\n                isAwake[contacts[i][j]] = 1;\n            }\n        }\n    }\n    double probability = 1.0;\n    for (int i = 0; i < numParticipants; i++) {\n        if (!isAwake[i]) {\n            probability *= probabilities[i];\n        }\n    }\n    return probability;\n}\n\ndouble computeTotalProbability() {\n    double totalProbability = 0.0;\n    int totalStates = 1 << numParticipants;\n    for (int state = 0; state < totalStates; state++) {\n        double prob = calculateWakeupProbability(state);\n        totalProbability += prob;\n    }\n    return totalProbability;\n}\n\nint main() {\n    while (1) {\n        readInput();\n        if (numParticipants == 0) break;\n        double result = computeTotalProbability();\n        printf(\"%.9f\\n\", result);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 08:17:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_wake_up_probability():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        # Store individual oversleeping probabilities\n        probs = list(map(float, input().split()))\n        \n        # Store contact lists for each participant\n        contacts = [list(map(lambda x: int(x)-1, input().split()[1:])) for _ in range(n)]\n        \n        # Compute all possible wake-up scenarios using bit manipulation\n        max_state = 1 << n\n        total_prob = 0\n        \n        for state in range(max_state):\n            curr_prob = 1.0\n            \n            # Check each participant's status in current scenario\n            for i in range(n):\n                if state & (1 << i):  # If participant wakes up\n                    if state & (1 << i):  # Naturally or via contact\n                        curr_prob *= (1 - probs[i])\n                    else:\n                        # Check if contacted by someone awake\n                        contacted = False\n                        for contact in contacts[i]:\n                            if state & (1 << contact):\n                                contacted = True\n                                break\n                        if contacted:\n                            curr_prob *= (1 - probs[i])\n                        else:\n                            curr_prob *= probs[i]\n            \n            # Sum probability of scenarios where everyone is awake\n            if bin(state).count('1') == n:\n                total_prob += curr_prob\n        \n        print(f\"{total_prob:.5f}\")\n\nsolve_wake_up_probability()",
    "timestamp": "2025-08-13 08:17:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    while True:\n        line = sys.stdin.readline().strip()\n        if line == '0':\n            break\n        n = int(line)\n        participants = []\n        adj = [[] for _ in range(n)]\n        for i in range(n):\n            parts = sys.stdin.readline().split()\n            p = float(parts[0])\n            m = int(parts[1])\n            contacts = list(map(int, parts[2:2+m]))\n            for contact in contacts:\n                adj[i].append(contact - 1)\n            participants.append(p)\n        \n        # BFS to find all reachable nodes from i (including i)\n        reachable = [set() for _ in range(n)]\n        for i in range(n):\n            q = deque()\n            q.append(i)\n            visited = set()\n            visited.add(i)\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if v not in visited:\n                        visited.add(v)\n                        q.append(v)\n            reachable[i] = visited\n        \n        total_prob = 1.0\n        for i in range(n):\n            # Probability that at least one in reachable[i] does not oversleep\n            prob_all_oversleep = 1.0\n            for j in reachable[i]:\n                prob_all_oversleep *= participants[j]\n            prob_at_least_one_awake = 1.0 - prob_all_oversleep\n            total_prob *= prob_at_least_one_awake\n        \n        print(\"{0:.4f}\".format(total_prob))\n\nsolve()",
    "timestamp": "2025-08-13 08:17:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <iomanip>\n\ndouble calculateProbability(\n    std::vector<double>& oversleepingProb, \n    std::vector<std::vector<int>>& contacts,\n    std::vector<bool>& visited, \n    int idx) {\n    if (visited[idx]) return 0.0;\n    visited[idx] = true;\n\n    double prob = 1.0 - oversleepingProb[idx];\n\n    for (int contact : contacts[idx]) {\n        if (!visited[contact]) {\n            prob = std::max(prob, (1.0 - oversleepingProb[idx]) + (oversleepingProb[idx] * calculateProbability(oversleepingProb, contacts, visited, contact)));\n        }\n    }\n    return prob;\n}\n\nint main() {\n    std::string line;\n    while (true) {\n        std::getline(std::cin, line);\n        if (line == \"0\") break;\n\n        std::stringstream ss(line);\n        int n;\n        ss >> n;\n\n        std::vector<double> oversleepingProb(n);\n        std::vector<std::vector<int>> contacts(n);\n\n        for (int i = 0; i < n; ++i) {\n            std::cin >> oversleepingProb[i];\n            std::getline(std::cin, line);\n            std::stringstream contactStream(line);\n            int contact;\n            while (contactStream >> contact) {\n                contacts[i].push_back(contact - 1);\n            }\n        }\n\n        std::vector<bool> visited(n, false);\n        double overallProbability = 1.0;\n\n        for (int i = 0; i < n; ++i) {\n            if (!visited[i]) {\n                overallProbability *= calculateProbability(oversleepingProb, contacts, visited, i);\n            }\n        }\n\n        std::cout << std::fixed << std::setprecision(8) << overallProbability << std::endl;\n\n        // Clear input buffer for the next dataset\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:44:35"
  }
]