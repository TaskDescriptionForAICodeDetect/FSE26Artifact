[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn._\nobject Main extends App {\n  val Array(n, m, s, t) = readLine.trim.split(' ').map(_.toInt)\n  val dimensions = Array.fill(n){Nil: List[Int]}\n  val damages = readLine.trim.split(' ').map(_.toInt)\n  val minDamage = Array.fill(n){Int.MaxValue}\n  for (_ ← 0 until m){\n    val Array(a, b) = readLine.trim.split(' ').map(_.toInt - 1)\n    dimensions(a) ::= b\n  }\n  val minBit = MinBit(n).reversed\n  minBit.decrease(s - 1, 0)\n  minDamage(s - 1) = 0\n  for (d ← 0 until t) {\n    minDamage(d) = minBit(d)\n    for (to ← dimensions(d)) {\n      if (minDamage(to) > damages(to) + minDamage(d)) {\n        minDamage(to) = damages(to) + minDamage(d)\n        minBit.decrease(to, minDamage(to))\n      }\n    }\n  }\n  println(minDamage(t - 1))\n\n\n}\ntrait MinBit {\n  def apply(position: Int): Int\n  def decrease(position: Int, newValue: Int): Unit\n  def reversed: MinBit\n  def size: Int\n}\nobject MinBit {\n  def apply(size: Int): MinBit = new MinBitImpl(size)\n  private class MinBitImpl(val size: Int) extends MinBit {\n    private val array = Array.fill(size){Int.MaxValue}\n    def apply(position: Int): Int = {\n      if (position >= 0) {\n        Math.min(array(position), apply(position - ((position + 1) & ~position)))\n      }else {\n        Int.MaxValue\n      }\n    }\n    def decrease(position: Int, newValue: Int): Unit = {\n      if (position < size && array(position) > newValue) {\n        array(position) = newValue\n        decrease(position + ((position + 1) & ~position), newValue)\n      }\n    }\n    override def reversed: MinBit = new Reversed(this)\n  }\n  private class Reversed(private val bit: MinBit) extends MinBit {\n    def size = bit.size\n    def apply(position: Int): Int = bit(size - position - 1)\n    def decrease(position: Int, newValue: Int) = bit.decrease(size - position - 1, newValue)\n    override def reversed: MinBit = bit\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<cstring>\n#include<climits>\n#include<sstream>\n#include<deque>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<bitset>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\n\n#define MAX 100010\nint V,E,s,t;\nvector<int> G[MAX];\nvector<ll> d;\n\n\nclass RMQ{\nprivate:\n  int limit,N;\n  vector<ll> dat;\npublic:\n  void init(int n_){\n    N = n_;\n    limit = 1;\n    while(limit<n_)limit*=2;\n    dat.clear();\n    dat.resize(2*limit,LLONG_MAX);\n  }\n  \n  ll _build(int cur,int L,int R,const vector<ll> &buf){\n    if( !( 0 <= cur && cur < 2*limit ) ) return LLONG_MAX;\n    if( L == R-1 ) {\n      if( L >= N ) return LLONG_MAX;\n      dat[cur] = buf[L];\n    } else {\n      ll vl = _build(cur*2+1,L,(L+R)/2,buf);\n      ll vr = _build(cur*2+2,(L+R)/2,R,buf);\n      dat[cur] = min(vl,vr);\n    }\n    return dat[cur];\n  }\n\n  void build(const vector<ll> &buf){ _build(0,0,limit,buf); };\n\n  void update(int k,ll a){\n    k += limit-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n \n  ll _query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return LLONG_MAX;\n    else if(a<=l && r<=b)return dat[k];\n    ll vl = _query(a,b,k*2+1,l,(l+r)/2);\n    ll vr = _query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n\n  ll query(int a,int b){ return _query(a,b,0,0,limit); }\n};\n\n\n\nint main(){\n  /*\n  RMQ rmq2;\n  rmq2.init(10);\n  rmq2.build(vector<ll>(10,LLONG_MAX));\n  while(1) {\n    int t;\n    int a,b;\n    cout << \"t = \";\n    cin >> t;\n    if( t == 0 ) {\n      cin >> a >> b;\n      cout << rmq2.query(a,b) << endl;\n    } else {\n      cin >> a >> b;\n      rmq2.update(a,(ll)b);\n    }\n  }\n  puts(\"--\");\n  */\n\n  \n  cin >> V >> E >> s >> t;\n  --s, --t;\n  d = vector<ll>(V,0);\n  rep(i,V) cin >> d[i];\n  rep(i,E) {\n    int a,b;\n    cin >> a >> b;\n    --a, --b;\n    if( a < s ) a = s;\n    G[a].push_back(b);\n  }\n  if( t <= s ) {\n    puts(\"0\");\n    return 0;\n  }\n\n  RMQ rmq;\n  rmq.init(V+1);\n  rmq.build(vector<ll>(V+1,LLONG_MAX));\n  rmq.update(s,0LL);\n  REP(i,s,V) {\n    ll mini = rmq.query(i,V+1);\n    rmq.update(i,mini);\n    rep(j,(int)G[i].size()) {\n      int nex = G[i][j];\n      if( nex == i ) continue;\n      ll v = rmq.query(nex,nex+1);\n      if( v > mini + d[nex]) {\n\t//cout << mini << \" + \" << d[nex] << endl;\n\trmq.update(nex,mini+d[nex]);\n      }\n    }\n  }\n  cout << rmq.query(t,t+1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 40)\nusing namespace std;\ntypedef long long ll;\n\nstruct state {\n  ll v, d;\n\npublic:\n  bool operator<(const state &s) const { return d > s.d; };\n};\n\nll N, M, S, T, D[100000], A, B;\nvector<ll> E[100000];\n\nint main(void) {\n  cin >> N >> M >> S >> T; S--; T--;\n  REP(i, 0, N) cin >> D[i];\n  REP(i, 0, M) {\n    cin >> A >> B; A--; B--;\n    if(A < B) E[A].push_back(B);\n    if(B < A) E[B].push_back(A);\n  }\n\n  vector<ll> dp(N, INF);\n  priority_queue<state> q;\n  q.push((state) { S, 0 });\n\n  while(q.size()) {\n    state c = q.top();\n    q.pop();\n\n    // cout << c.v << \" \" << c.d << endl;\n\n    if(c.d >= dp[c.v]) continue;\n    dp[c.v] = c.d;\n\n    if(c.v == T) {\n      cout << c.d << endl;\n      return 0;\n    }\n\n    REP(u, 0, c.v) if(dp[u] > c.d) q.push((state) { u, c.d });\n    for(ll u : E[c.v]) if(dp[u] > c.d + D[u]) q.push((state) { u, c.d + D[u] });\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<28\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\t// first ??????????????¢ second ???????????????\n\nconst int MAX_V = (int)1e5;\n\nclass edge{\npublic:\n\tint to;\n\tint cost;\n\tedge(){}\n\tedge(int _to, int _cost):to(_to),cost(_cost){}\n};\n\nint D[MAX_V];\t\t\t\t\t// ?????????:s ????????????????????¢\n\nvector<edge> G[MAX_V];\n\nbool used[MAX_V];\n\n// ?????????:s ????????????????????¢????±???????\nvoid dijkstra (int s)\n{\n\t// greater<P> ????????????????????¨??§first????°???????????????????????????????????????????\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill (D,  D + MAX_V, INF);\n\tD[s] = 0;\n\tque.push (P (0, s));\n\t\n\tmemset(used, false, sizeof(used));\n\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (D[v] < p.first) continue;\n\n\t\trep (i, G[v].size()){\n\t\t\tedge e = G[v][i];\n\t\t\tused[e.to] |= true;\n\t\t\tif (D[e.to] > D[v] + e.cost){\n\t\t\t\tD[e.to] = D[v] + e.cost;\n\t\t\t\tque.push(P(D[e.to], e.to));\n\t\t\t} // end if\n\t\t} // end rep\n\n\n\t} // end while\n}\n\n\nint main()\n{\n\trep (i, MAX_V) G[i].clear();\n\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint N,M,s,t; cin >> N >> M >> s >> t;\n\t--s, --t;\n\tvector<int> d(N, 0);\n\trep (i, N) cin >> d[i];\n\n\trep (i, M){\n\t\tint a, b; cin >> a >> b;  // a < b\n\t\t--a, --b;\n\t\tG[a].push_back(edge(b,d[b]));\n\t\tG[b].push_back(edge(a,0));\n\t} // end rep\n\n\tfor (int i = 0; i < N; ++i){\n\t\tfor (int j = i + 1;j < N; ++j){\n\t\t\tG[j].push_back(edge(i,0));\n\t\t} // end for\n\t} // end for\n\n\tdijkstra(s);\n\tcout << D[t] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REP2(i,m,n) for (int i=m;i<(n);i++)\ntypedef long long ll;\n\nclass SegmentTree {\npublic:\n    vector<ll> table;\n    int size;\n\n    SegmentTree(int n) {\n        size = 1;\n        while (size <= n * 2) size *= 2;\n        size *= 2;\n        table = vector<ll>(size, 1LL << 59);\n    }\n\n    void assign(int pos, ll num) {\n        return assign(pos, num, 0, 0, size/2-1);\n    }\n\n    void assign(int pos, ll num, int i, int left, int right) {\n        if (left == right) {\n            table[i] = num;\n            return;\n        }\n        auto mid = (left + right) / 2;\n        if (pos <= mid)\n            assign(pos, num, i*2+1, left, mid);\n        else\n            assign(pos, num, i*2+2, mid+1, right);\n        table[i] = min(table[2*i+1], table[2*i+2]);\n    }\n\n    ll query(int pl, int pr) {\n        return query(pl, pr, 0, 0, size/2-1);\n    }\n\n    ll query(int pl, int pr, int i, int left, int right) {\n        if (pl > right || pr < left)\n            return 1LL << 59;\n        else if (pl <= left && right <= pr)\n            return table[i];\n        else\n            return\n                min(query(pl, pr, i*2+1, left, (left+right)/2),\n                    query(pl, pr, i*2+2, (left+right)/2+1, right));\n    }\n};\n\n\nint N, M, s, t;\nint D[101010];\nvector<int> edges[101010];\nll dist[101010];\n\n\nint main() {\n    cin >> N >> M >> s >> t;\n    s--, t--;\n\n    REP(i, N) cin >> D[i];\n    REP(i, s+1) D[i] = 0;\n\n    REP(i, M) {\n        int a, b; cin >> a >> b;\n        edges[a - 1].push_back(b - 1);\n    }\n\n    SegmentTree st = SegmentTree(N);\n    REP(i, N) st.assign(s, 0);\n\n    REP(i, N) {\n        ll d = st.query(i, N);\n        for (auto m: edges[i])\n            st.assign(m, min(st.query(m, m), d + D[m]));\n    }\n\n    ll ans = 1LL << 59;\n    REP2(i, t, N) ans = min(ans, st.query(i, i));\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\nconst int inf = 1e9;\ntypedef long long ll;\ntypedef pair<int, int> P;\nstruct edge{\n  int to, cost;\n  edge(int t, int c) {\n    to = t, cost = c;\n  }\n};\nint N, M;\nint d[100005];\nvector<edge> G[100005];\nvoid dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  FOR(i,1,N+1) d[i] = inf;\n  d[s] = 0;\n  que.push(P(0, s));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(auto &e : G[v]){\n      if(d[e.to] > d[v] + e.cost){\n        d[e.to] = d[v] + e.cost;\n        que.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int s, t; cin >> N >> M >> s >> t;\n  int dd[N]; FOR(i,0,N) cin >> dd[i];\n  FOR(i,0,M) {\n    int a, b; cin >> a >> b;\n    G[a].push_back(edge(b, dd[b-1]));\n  }\n  FOR(i,1,s) {\n    G[s].push_back(edge(i, 0));\n  }\n  if(s > t) {\n    cout << 0 << endl;\n    return 0;\n  }\n  dijkstra(s);\n  int ans = 1e9;\n  FOR(i,t,N+1) {\n    ans = min(ans, d[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n//verified AOJ GRL_1\n#define MAX_V 100000\nstruct edge{int to,cost;};\n\nvoid dijkstra(int s, vector<int> &d, vector<edge> G[MAX_V]){\n    priority_queue< pii,vector<pii>,greater<pii> > que;\n    rep( i,d.size() )d[i]=INF;\n    d[s] = 0;\n    que.push( pii(0,s) );\n    \n    while( que.size() ){\n        pii p=que.top();\n        que.pop();\n        \n        int v=p.second;\n        if(d[v]<p.first)continue;\n        \n        rep(i,G[v].size()){\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost){\n                d[e.to]=d[v]+e.cost;\n                que.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n}\n\nint main(){\n    int v,e;\n    cin>>v>>e;\n    \n    int s,t;\n    cin>>s>>t;\n    s--,t--;\n    \n    vector<int> d(v);\n    rep(i,v)cin>>d[i];\n    \n    vector<edge> G[MAX_V];\n    \n    rep(i,e){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        G[a].pb(edge{b,d[b]});\n    }\n    \n    for(int i=v-1;i>0;i--){\n        G[i].pb(edge{i-1,0});\n    }\n    \n    vector<int> dir(v);\n    dijkstra(s, dir, G);\n    \n    cout<<dir[t]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n//\n//using Graph = vector<vector<int>>;\n//\n//int dfs(const Graph&g, const int now, vector<int>&ch_cnts) {\n//  ch_cnts[now]++;\n//  for (auto&& e : g[now]) {\n//      ch_cnts[now] += dfs(g, e, ch_cnts);\n//  }\n//  return ch_cnts[now];\n//}\n//\n//struct HL_Edge {\n//  int from;\n//  int to;\n//  bool heavy;\n//};\n//\n//void dfs2(const Graph&g, vector<vector<HL_Edge>>&hl_tree, const int now, const vector<int>&ch_cnts) {\n//\n//  int max_ch_id = 1;\n//  {\n//      int max_ch_num = -1;\n//      for (auto&&e : g[now]) {\n//          if (max_ch_num < ch_cnts[e]) {\n//              max_ch_num = ch_cnts[e];\n//              max_ch_id = e;\n//          }\n//      }\n//  }\n//  for (auto e : g[now]) {\n//      bool heavy = (e == max_ch_id);\n//\n//      hl_tree[now].push_back(HL_Edge{ now,e,heavy });\n//  }\n//  return;\n//}\n//\n//void HL(const vector<vector<int>>&ro_tree) {\n//  vector<int>ch_cnts(ro_tree.size());\n//\n//  dfs(ro_tree, 0, ch_cnts);\n//\n//  vector<vector<HL_Edge>>hl_tree(ro_tree.size());\n//\n//  dfs2(ro_tree, hl_tree, 0, ch_cnts);\n//}\n//\n//namespace FastFourierTransform\n//{\n//  using C = complex< double >;\n//\n//  void DiscreteFourierTransform(vector< C > &F, bool rev)\n//  {\n//      const int N = (int)F.size();\n//      const double PI = (rev ? -1 : 1) * acos(-1);\n//      for (int i = 0, j = 1; j + 1 < N; j++) {\n//          for (int k = N >> 1; k > (i ^= k); k >>= 1);\n//          if (i > j) swap(F[i], F[j]);\n//      }\n//      C w, s, t;\n//      for (int i = 1; i < N; i <<= 1) {\n//          for (int k = 0; k < i; k++) {\n//              w = polar(1.0, PI / i * k);\n//              for (int j = 0; j < N; j += i * 2) {\n//                  s = F[j + k];\n//                  t = C(F[j + k + i].real() * w.real() - F[j + k + i].imag() * w.imag(),\n//                      F[j + k + i].real() * w.imag() + F[j + k + i].imag() * w.real());\n//                  F[j + k] = s + t, F[j + k + i] = s - t;\n//              }\n//          }\n//      }\n//      if (rev) for (int i = 0; i < N; i++) F[i] /= N;\n//  }\n//\n//  vector< int> Multiply(const vector<int > &A, const vector<int > &B)\n//  {\n//      int sz = 1;\n//      while (sz <= A.size() + B.size()) sz <<= 1;\n//      vector< C > F(sz), G(sz);\n//      for (int i = 0; i < A.size(); i++) F[i] = A[i];\n//      for (int i = 0; i < B.size(); i++) G[i] = B[i];\n//      DiscreteFourierTransform(F, false);\n//      DiscreteFourierTransform(G, false);\n//      for (int i = 0; i < sz; i++) F[i] *= G[i];\n//      DiscreteFourierTransform(F, true);\n//      vector< int > X(A.size() + B.size() - 1);\n//      for (int i = 0; i < A.size() + B.size() - 1; i++) X[i] = F[i].real() + 0.5;\n//      return (X);\n//  }\n//};\n\n#define Seg_Max_N (1<<19) \n\nusing Value = int;\nconst Value ini = 1e9;\nstruct segtree {\n\tint N;\n\tvector<Value>dat;\n\n\tsegtree() {}\n\tsegtree(int n) :dat(2 * Seg_Max_N) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\t\tdat[i] = ini;\n\t\t}\n\t}\n\tValue connect(const Value&l, const Value&r) {\n\t\treturn min(l,r);\n\t}\n\t// update k th element\n\tvoid update(int k, Value a) {\n\t\tk += N - 1;\n\t\tdat[k] = a;\n\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tconst Value al(dat[k * 2 + 1]);\n\t\t\tconst Value ar(dat[k * 2 + 2]);\n\t\t\tdat[k] = connect(al, ar);\n\t\t}\n\t}\n\t// min [a, b)\n\tValue  query(int a, int b) { return query(a, b, 0, 0, N); }\n\tValue  query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return ini;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tconst int m = (l + r) / 2;\n\t\tconst Value al(query(a, b, k * 2 + 1, l, m));\n\t\tconst Value ar(query(a, b, k * 2 + 2, m, r));\n\t\treturn connect(al, ar);\n\t}\n};\n\n\n\nint main() {\n\tint N,M,S,T;cin>>N>>M>>S>>T;\n\tS--;\n\tT--;\n\tvector<int>ds(N);\n\tfor(int i=0;i<N;++i)cin>>ds[i];\n\tvector<pair<int,int>>ps;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tps.emplace_back(a,b);\n\t}\n\tsort(ps.begin(),ps.end());\n\n\tsegtree seg(N);\n\tseg.update(S,0);\n\tfor (auto p : ps) {\n\t\tint from=p.first;\n\t\tint to=p.second;\n\n\t\tint x=seg.query(from,N);\n\t\tseg.update(to,x+ds[to]);\n\t}\n\n\tint ans=seg.query(T,N);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint main(){\n  int n,m,s,g,d[SIZE],a,b;\n  vector<int> way[SIZE];\n  \n  scanf(\"%d%d%d%d\",&n,&m,&s,&g);\n\n  s--; g--;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d\",d+i);\n  }\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",&a,&b);\n    a--;\n    b--;\n    way[a].push_back(b);\n  }\n\n  queue<pair<int,int> > que;\n\n  int dp[SIZE];\n\n  for(int i=0;i<n;i++){\n    dp[i] = INF;\n  }\n\n  dp[s] = 0;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<way[i].size();j++){\n      que.push({i, way[i][j]});\n    }\n\n    while(que.size()){\n      auto p = que.front();\n      que.pop();\n\n      dp[p.second] = min(dp[p.second], dp[i] + d[p.second]);\n\n      cerr << p.first << p.second << endl;\n    }\n  }\n\n  int ans = INF;\n  \n  for(int i=g;i<n;i++){\n    ans = min(ans, dp[g]);\n  }\n\n  printf(\"%d\\n\",ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<28\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\t// first ??????????????¢ second ???????????????\n\nconst int MAX_V = (int)1e5;\n\nclass edge{\npublic:\n\tint to;\n\tint cost;\n\tedge(){}\n\tedge(int _to, int _cost):to(_to),cost(_cost){}\n};\n\nint D[MAX_V];\t\t\t\t\t// ?????????:s ????????????????????¢\n\nvector<edge> G[MAX_V];\n\nbool used[MAX_V];\n\n// ?????????:s ????????????????????¢????±???????\nvoid dijkstra (int s)\n{\n\t// greater<P> ????????????????????¨??§first????°???????????????????????????????????????????\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill (D,  D + MAX_V, INF);\n\tD[s] = 0;\n\tque.push (P (0, s));\n\t\n\tmemset(used, false, sizeof(used));\n\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (D[v] < p.first) continue;\n\n\t\tfor (int i = 0; i < v; ++i){\n\t\t\tif (D[i] > D[v]){\n\t\t\t\tD[i] = D[v];\n\t\t\t\tque.push(P(D[i],i));\n\t\t\t} // end if\n\t\t} // end for\n\n\t\trep (i, G[v].size()){\n\t\t\tedge e = G[v][i];\n//\t\t\tused[e.to] |= true;\n\t\t\tif (D[e.to] > D[v] + e.cost){\n\t\t\t\tD[e.to] = D[v] + e.cost;\n\t\t\t\tque.push(P(D[e.to], e.to));\n\t\t\t} // end if\n\t\t} // end rep\n\n\n\t} // end while\n}\n\n\nint main()\n{\n\trep (i, MAX_V) G[i].clear();\n\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint N,M,s,t; cin >> N >> M >> s >> t;\n\t--s, --t;\n\tvector<int> d(N, 0);\n\trep (i, N) cin >> d[i];\n\n\trep (i, M){\n\t\tint a, b; cin >> a >> b;  // a < b\n\t\t--a, --b;\n\t\tG[a].push_back(edge(b,d[b]));\n\t\tG[b].push_back(edge(a,0));\n\t} // end rep\n\n\tfor (int i = 0; i < N; ++i){\n\t\tfor (int j = i + 1;j < N; ++j){\n\t\t\tG[j].push_back(edge(i,0));\n\t\t} // end for\n\t} // end for\n\n\tdijkstra(s);\n\tcout << D[t] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REP2(i,m,n) for (int i=m;i<(n);i++)\ntypedef long long ll;\n\nint N, M, s, t;\nint D[101010];\nvector<int> edges[101010];\nint dist[101010];\n\n\nint main() {\n    cin >> N >> M >> s >> t;\n    s--, t--;\n\n    REP(i, N) cin >> D[i];\n    REP(i, s+1) D[i] = 0;\n\n    REP(i, M) {\n        int a, b; cin >> a >> b;\n        edges[b - 1].push_back(a - 1);\n    }\n    REP2(i, t+1, N)\n        edges[t].push_back(i);\n\n\n    REP(i, N) dist[i] = 1 << 29;\n    priority_queue<pair<int, int>> pq;\n    pq.push({t, 0});\n\n    while (!pq.empty()) {\n        auto p = pq.top();\n        int n = p.first;\n        int d = -p.second;\n        pq.pop();\n\n        if (d >= dist[n])\n            continue;\n        dist[n] = d;\n\n        for (auto m: edges[n]) {\n            int md = m < n ? d + D[n] : d;\n            if (md >= dist[m])\n                continue;\n            pq.push({m, -md});\n        }\n    }\n\n    int ans = dist[s];\n    REP(i, s) ans = min(ans, dist[i]);\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n//\n//using Graph = vector<vector<int>>;\n//\n//int dfs(const Graph&g, const int now, vector<int>&ch_cnts) {\n//  ch_cnts[now]++;\n//  for (auto&& e : g[now]) {\n//      ch_cnts[now] += dfs(g, e, ch_cnts);\n//  }\n//  return ch_cnts[now];\n//}\n//\n//struct HL_Edge {\n//  int from;\n//  int to;\n//  bool heavy;\n//};\n//\n//void dfs2(const Graph&g, vector<vector<HL_Edge>>&hl_tree, const int now, const vector<int>&ch_cnts) {\n//\n//  int max_ch_id = 1;\n//  {\n//      int max_ch_num = -1;\n//      for (auto&&e : g[now]) {\n//          if (max_ch_num < ch_cnts[e]) {\n//              max_ch_num = ch_cnts[e];\n//              max_ch_id = e;\n//          }\n//      }\n//  }\n//  for (auto e : g[now]) {\n//      bool heavy = (e == max_ch_id);\n//\n//      hl_tree[now].push_back(HL_Edge{ now,e,heavy });\n//  }\n//  return;\n//}\n//\n//void HL(const vector<vector<int>>&ro_tree) {\n//  vector<int>ch_cnts(ro_tree.size());\n//\n//  dfs(ro_tree, 0, ch_cnts);\n//\n//  vector<vector<HL_Edge>>hl_tree(ro_tree.size());\n//\n//  dfs2(ro_tree, hl_tree, 0, ch_cnts);\n//}\n//\n//namespace FastFourierTransform\n//{\n//  using C = complex< double >;\n//\n//  void DiscreteFourierTransform(vector< C > &F, bool rev)\n//  {\n//      const int N = (int)F.size();\n//      const double PI = (rev ? -1 : 1) * acos(-1);\n//      for (int i = 0, j = 1; j + 1 < N; j++) {\n//          for (int k = N >> 1; k > (i ^= k); k >>= 1);\n//          if (i > j) swap(F[i], F[j]);\n//      }\n//      C w, s, t;\n//      for (int i = 1; i < N; i <<= 1) {\n//          for (int k = 0; k < i; k++) {\n//              w = polar(1.0, PI / i * k);\n//              for (int j = 0; j < N; j += i * 2) {\n//                  s = F[j + k];\n//                  t = C(F[j + k + i].real() * w.real() - F[j + k + i].imag() * w.imag(),\n//                      F[j + k + i].real() * w.imag() + F[j + k + i].imag() * w.real());\n//                  F[j + k] = s + t, F[j + k + i] = s - t;\n//              }\n//          }\n//      }\n//      if (rev) for (int i = 0; i < N; i++) F[i] /= N;\n//  }\n//\n//  vector< int> Multiply(const vector<int > &A, const vector<int > &B)\n//  {\n//      int sz = 1;\n//      while (sz <= A.size() + B.size()) sz <<= 1;\n//      vector< C > F(sz), G(sz);\n//      for (int i = 0; i < A.size(); i++) F[i] = A[i];\n//      for (int i = 0; i < B.size(); i++) G[i] = B[i];\n//      DiscreteFourierTransform(F, false);\n//      DiscreteFourierTransform(G, false);\n//      for (int i = 0; i < sz; i++) F[i] *= G[i];\n//      DiscreteFourierTransform(F, true);\n//      vector< int > X(A.size() + B.size() - 1);\n//      for (int i = 0; i < A.size() + B.size() - 1; i++) X[i] = F[i].real() + 0.5;\n//      return (X);\n//  }\n//};\n\n#define Seg_Max_N (1<<19) \n\nusing Value = int;\nconst Value ini = 1e9;\nstruct segtree {\n\tint N;\n\tvector<Value>dat;\n\n\tsegtree() {}\n\tsegtree(int n) :dat(2 * Seg_Max_N) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\t\tdat[i] = ini;\n\t\t}\n\t}\n\tValue connect(const Value&l, const Value&r) {\n\t\treturn min(l,r);\n\t}\n\t// update k th element\n\tvoid update(int k, Value a) {\n\t\tk += N - 1;\n\t\tdat[k] = a;\n\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tconst Value al(dat[k * 2 + 1]);\n\t\t\tconst Value ar(dat[k * 2 + 2]);\n\t\t\tdat[k] = connect(al, ar);\n\t\t}\n\t}\n\t// min [a, b)\n\tValue  query(int a, int b) { return query(a, b, 0, 0, N); }\n\tValue  query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return ini;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tconst int m = (l + r) / 2;\n\t\tconst Value al(query(a, b, k * 2 + 1, l, m));\n\t\tconst Value ar(query(a, b, k * 2 + 2, m, r));\n\t\treturn connect(al, ar);\n\t}\n};\n\n\n\nint main() {\n\tint N,M,S,T;cin>>N>>M>>S>>T;\n\tS--;\n\tT--;\n\tvector<int>ds(N);\n\tfor(int i=0;i<N;++i)cin>>ds[i];\n\tvector<pair<int,int>>ps;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tps.emplace_back(a,b);\n\t}\n\tsort(ps.begin(),ps.end());\n\n\tsegtree seg(N);\n\tseg.update(S,0);\n\tfor (auto p : ps) {\n\t\tint from=p.first;\n\t\tint to=p.second;\n\n\t\tint x=seg.query(from,N);\n\t\tseg.update(to,min(seg.query(to,to+1),x+ds[to]));\n\t}\n\n\tint ans=seg.query(T,N);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll inf = 1e15;\nstruct edge{\n  ll to, cost;\n  edge(ll t, ll c) {\n    to = t, cost = c;\n  }\n};\nint N, M;\nll d[100005];\nvector<edge> G[100005];\nvoid dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  FOR(i,1,N+1) d[i] = inf;\n  d[s] = 0;\n  que.push(P(0, s));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(auto &e : G[v]){\n      if(d[e.to] > d[v] + e.cost){\n        d[e.to] = d[v] + e.cost;\n        que.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int s, t; cin >> N >> M >> s >> t;\n  ll dd[N]; FOR(i,0,N) cin >> dd[i];\n  FOR(i,0,M) {\n    int a, b; cin >> a >> b;\n    if(b < s) dd[b-1] = 0;\n    G[a].push_back(edge(b, dd[b-1]));\n  }\n  FOR(i,1,s) {\n    G[s].push_back(edge(i, 0));\n  }\n  if(s >= t) {\n    cout << 0 << endl;\n    return 0;\n  }\n  dijkstra(s);\n  ll ans = 1e15;\n  FOR(i,t,N+1) {\n    ans = min(ans, d[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntemplate<class V, int NV> struct LazySegTree { // [L,R)\n    vector<V> dat, lazy; LazySegTree() { dat.resize(NV * 2, def); lazy.resize(NV * 2, ldef); }\n    void update(int a, int b, V v, int k, int l, int r) { push(k, l, r); if (r <= a || b <= l) return;\n        if (a <= l && r <= b) { setLazy(k, v); push(k, l, r); } else {\n        update(a, b, v, k * 2 + 1, l, (l + r) / 2); update(a, b, v, k * 2 + 2, (l + r) / 2, r);\n        dat[k] = comp(dat[k * 2 + 1], dat[k * 2 + 2]);}}\n    V get(int a, int b, int k, int l, int r) { push(k, l, r); if (r <= a || b <= l) return def;\n        if (a <= l && r <= b) return dat[k]; auto x = get(a, b, k * 2 + 1, l, (l + r) / 2);\n        auto y = get(a, b, k * 2 + 2, (l + r) / 2, r); return comp(x, y);}\n    void update(int a, int b, V v) { update(a, b, v, 0, 0, NV); }\n    V get(int a, int b) { return get(a, b, 0, 0, NV); }\n    // ---- Template ---------------------------------------------------------------------------------\n    // ??????min??£??\\,??????min\n    #define INF INT_MAX/2\n    const V def = INF, ldef = INF;\n    V comp(V l, V r) { return min(l, r); }\n    void setLazy(int i, V v) { lazy[i] = min(lazy[i], v); }\n    void push(int k, int l, int r) {\n        if (lazy[k] != ldef) {\n            // modify------------------------------\n            dat[k] = min(dat[k], lazy[k]);\n            // ------------------------------------\n            if (r - l > 1) { setLazy(k * 2 + 1, lazy[k]); setLazy(k * 2 + 2, lazy[k]); }\n            lazy[k] = ldef;\n        }\n    }\n};\n\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint N, M, S, T, D[101010];\nvector<pair<int,int>> v;\nLazySegTree<int, 1 << 17> st;\n//--------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M >> S >> T;\n    S--; T--;\n    rep(i, 0, N) cin >> D[i];\n    rep(i, 0, M) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        v.push_back({a, b});\n    }\n    sort(v.begin(), v.end(), [&](pair<int, int> a, pair<int, int> b) {\n        if (a.second != b.second) return a.second < b.second;\n        else return a.first < a.first;\n    });\n\n    st.update(0, S + 1, 0);\n    fore(p, v) {\n        int L = p.first;\n        int R = p.second;\n        int c = st.get(0, L + 1) + D[R];\n        st.update(0, R + 1, c);\n    }\n\n    int ans = st.get(T, T + 1);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G){  \n  const T INF = numeric_limits<T>::max();    \n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n        d[u]=d[v]+c;\n        b[u]=v;\n        q.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  Int s,t;\n  cin>>s>>t;\n  s--;t--;\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++) cin>>d[i];\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(n);\n  for(Int i=0;i<m;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b,d[b]);\n  }\n  for(Int i=0;i+1<n;i++) G[i+1].emplace_back(i,0);\n  cout<<dijkstra(s,G)[t]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, n) for(int i = 0; i < (n); i++)\n#define MEM(a, x) memset(a, x, sizeof(a))\n#define ALL(a) a.begin(), a.end()\n#define UNIQUE(a) a.erase(unique(ALL(a)), a.end())\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint n, m, s, t, a[100005], dist[100005];\nvector<P> g[100005];\nbool used[100005];\nconst int INF = 1e9;\n\nvoid dijkstra(int s) {\n\tfill(dist, dist+n, INF);\n\tfill(used, used+n, false);\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tint d, t;\n\t\ttie(d, t) = que.top();\n\t\tque.pop();\n\t\tif (used[t]) continue;\n\t\tused[t] = true;\n\t\tdist[t] = d;\n\t\tfor (P e : g[t]) {\n\t\t\tif (dist[e.second] > d + e.first) que.push(P(d+e.first, e.second));\n\t\t}\n\t}\n}\n\nint main(int argc, char const *argv[]) {\n\tios_base::sync_with_stdio(false);\n\tcin >> n >> m >> s >> t;\n\ts--;\n\tt--;\n\tFOR(i, n) {\n\t\tcin >> a[i];\n\t\tif (i <= s) a[i] = 0;\n\t\tif (i > 0) g[i].push_back({0, i-1});\n\t}\n\tFOR(i, m) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tg[x].push_back({a[y], y});\n\t}\n\tdijkstra(s);\n\tcout << dist[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\ntemplate<class T, class ...Tail>\nvoid tiedSort(vector<T> &a, vector<Tail>&... tail) {\n\tint n = a.size();\n\tusing S = tuple<T, Tail...>;\n\tvector<S> s(n);\n\tfor (int i = 0; i < n; i++)\n\t\ts[i] = make_tuple(a[i], tail[i]...);\n\tsort(s.begin(), s.end());\n\tfor (int i = 0; i < n; i++)\n\t\ttie(a[i], tail[i]...) = s[i];\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M, s, t; cin >> N >> M >> s >> t; s--, t--;\n\tvector<int> d(N); rep(i, 0, N) {\n\t\tcin >> d[i];\n\t}\n\tvector<vector<int>> g(N);\n\tvector<int> a(M), b(M); rep(i, 0, M) {\n\t\tcin >> a[i] >> b[i];\n\t\ta[i]--, b[i]--;\n\t\tg[a[i]].push_back(b[i]);\n\t}\n\tusing State = tuple<int, int, int>;\n\tpriority_queue<State> pq;\n\tvector<int> dist(N, INF);\n\trep(i, 0, s + 1)dist[i] = 0;\n\n\trep(i, 0, M) {\n\t\tif (a[i] <= s)\n\t\t\tpq.emplace(-d[b[i]], a[i], b[i]);\n\t}\n\tdump(g);\n\tdump(pq);\n\twhile (pq.size()) {\n\t\tdump(dist);\n\t\tint c, ca, cb; tie(c, ca, cb) = pq.top(); pq.pop();\n\t\tc *= -1;\n\t\tdump(c, ca, cb);\n\t\trrep(i, 0, cb + 1) {\n\t\t\tif (dist[i] != INF)\n\t\t\t\tbreak;\n\t\t\tdist[i] = c;\n\t\t\trep(j, 0, g[i].size()) {\n\t\t\t\tpq.emplace(-(d[g[i][j]] + c), i, g[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tdump(dist);\n\tcout << dist[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,s,t;\nint d[100005];\nvector<int> G[100005];\nint dist[100005];\npriority_queue<P,vector<P>,greater<P> > que;\nbool used[100005];\n\nvoid dfs(int v,int c,int vv){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]<vv && dist[G[v][i]]>c){\n\t\t\tdist[G[v][i]]=c;\n\t\t\tque.push(P(c,G[v][i]));\n\t\t\tdfs(G[v][i],c,vv);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d%d\",&n,&m,&s,&t);\n\ts--;\n\tt--;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&d[i]);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;\n\t\tv--;\n\t\tG[u].push_back(v);\n\t}\n\tif(s>=t){\n\t\tprintf(\"0\\n\");\n\t}else{\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdist[i]=1e9;\n\t\t}\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\tint prev=0;\n\t\twhile(que.size()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tif(dist[p.second]<p.first)continue;\n\t\t\twhile(prev<=p.second){\n\t\t\t\tif(dist[prev]>dist[p.second]){\n\t\t\t\t\tdist[prev]=dist[p.second];\n\t\t\t\t\tque.push(P(dist[p.second],prev));\n\t\t\t\t}\n\t\t\t\tprev++;\n\t\t\t}\n\t\t\tfor(int i=0;i<G[p.second].size();i++){\n\t\t\t\tif(G[p.second][i]>p.second){\n\t\t\t\t\tint nec=G[p.second][i];\n\t\t\t\t\tif(dist[nec]>dist[p.second]+d[nec]){\n\t\t\t\t\t\tdist[nec]=dist[p.second]+d[nec];\n\t\t\t\t\t\tque.push(P(dist[nec],nec));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dist[t]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <queue>\n#include <tuple>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) {\n  for (T &x : v) is >> x;\n  return is;\n}\nusing namespace std;\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int s = 0, const int d = 0, const Weight w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\n\nclass Graph {\n  std::vector<Edges> g;\n\npublic:\n  Graph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int i) const { return g[i]; }\n  void addArc(const int src, const int dst, const Weight w) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int node1, const int node2, const Weight w) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> std::vector<Weight> dijkstra(const Graph &g, const int src) {\n  using state = std::pair<Weight, int>;\n  std::priority_queue<state, std::vector<state>, std::greater<state>> q;\n  std::vector<Weight> dist(g.size(), inf);\n  dist[src] = 0;\n  q.emplace(0, src);\n  while (q.size()) {\n    Weight d;\n    int v;\n    std::tie(d, v) = q.top();\n    q.pop();\n    if (dist[v] < d) continue;\n    for (auto &e : g[v]) {\n      if (cmin(dist[e.dst], dist[v] + e.weight)) q.emplace(dist[e.dst], e.dst);\n    }\n  }\n  return dist;\n}\n\nint main() {\n  int n, m, s, t;\n  cin >> n >> m >> s >> t;\n  --s, --t;\n  vector<int> d(n);\n  cin >> d;\n  Graph g(n);\n  while (m--) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g.addArc(a, b, d[b]);\n  }\n  loop(i, 1, n) g.addArc(i, i - 1, 0);\n  cout << dijkstra(g, s)[t] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nint mn[100010];\n\ntemplate <typename monoid_trait> struct segment_tree {\n\tusing M = monoid_trait;\n\tusing T = typename M::value_type;\n\n\t// monoid m;\n\tstd::size_t sz;\n\tstd::vector<T> x;\n\n\tsegment_tree(std::size_t n = 0) {\n\t\tsz = 1;\n\t\twhile (sz < n)\n\t\t\tsz *= 2;\n\t\tx.assign(sz * 2, M::id());\n\t\tinitialize();\n\t}\n\n\ttemplate <typename iterator>\n\tsegment_tree(iterator first, iterator last) {\n\t\tsz = 1;\n\t\tstd::size_t n = std::distance(first, last);\n\t\twhile (sz < n)\n\t\t\tsz *= 2;\n\t\tx.assign(sz * 2, M::id());\n\t\tstd::copy(first, last, x.begin() + sz);\n\t\tinitialize();\n\t}\n\n\tvoid initialize() {\n\t\tfor (int i = (int)sz - 1; i >= 1; --i) {\n\t\t\tx[i] = M::op(x[i * 2 + 0], x[i * 2 + 1]);\n\t\t}\n\t}\n\n\tT query(std::size_t l, std::size_t r) const {\n\t\tT res = M::id();\n\t\tfor (l += sz, r += sz; l < r; l >>= 1, r >>= 1) {\n\t\t\tif (l & 1)\n\t\t\t\tres = M::op(res, x[l++]);\n\t\t\tif (r & 1)\n\t\t\t\tres = M::op(res, x[--r]);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid update(std::size_t i, const T &val) {\n\t\tx[i += sz] = val;\n\t\twhile (i > 1) {\n\t\t\tx[i / 2] = M::op(x[i], x[i ^ 1]);\n\t\t\ti /= 2;\n\t\t}\n\t}\n\n\tT operator[](std::size_t i) const { return x[sz + i]; }\n};\n\ntemplate <typename T> struct zero_sum_monoid {\n\tusing value_type = T;\n\tstatic constexpr T id() { return 0; }\n\tstatic T op(const T &a, const T &b) { return a + b; }\n};\n\ntemplate <typename T> struct inf_min_monoid {\n\tusing value_type = T;\n\tstatic constexpr T id() { return std::numeric_limits<T>::max(); }\n\tstatic T op(const T &a, const T &b) { return std::min(a, b); }\n};\n\ntemplate <typename T> using rmq = segment_tree<inf_min_monoid<T>>;\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M, S, T;\n\t\n\tcin >> N >> M >> S >> T;\n\tsegment_tree<inf_min_monoid<int>> st(N);\n\t//st.update(N - 1, 0);\n\t//cerr << st.query(0, N) << endl;\n\tS--;\n\tT--;\n\tvector<int> D(N);\n\tint res = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tmn[i] = -1;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> D[i];\n\t}\n\tint a, b;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tif (mn[b] == -1 || mn[b] > a) {\n\t\t\tmn[b] = a;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i <= S) {\n\t\t\tst.update(i, 0);\n\t\t}\n\t\telse {\n\t\t\tif (mn[i] != -1) {\n\t\t\t\tint t;\n\t\t\t\tt = st.query(mn[i], i + 1);\n\t\t\t\tst.update(i, t + D[i]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << st.query(T, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, n) for(int i = 0; i < (n); i++)\n#define MEM(a, x) memset(a, x, sizeof(a))\n#define ALL(a) a.begin(), a.end()\n#define UNIQUE(a) a.erase(unique(ALL(a)), a.end())\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint n, m, s, t, a[100005], dist[100005];\nvector<P> g[100005];\nbool used[100005];\nconst int INF = 1e9;\n\nvoid dijkstra(int s) {\n\tfill(dist, dist+n, INF);\n\tfill(used, used+n, false);\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tint d, t;\n\t\ttie(d, t) = que.top();\n\t\tque.pop();\n\t\tif (used[t]) continue;\n\t\tused[t] = true;\n\t\tdist[t] = d;\n\t\tfor (P e : g[t]) {\n\t\t\tif (dist[e.second] > d + e.first) que.push(P(d+e.first, e.second));\n\t\t}\n\t}\n}\n\nint main(int argc, char const *argv[]) {\n\tios_base::sync_with_stdio(false);\n\tcin >> n >> m >> s >> t;\n\ts--;\n\tt--;\n\tFOR(i, n) {\n\t\tcin >> a[i];\n\t\tif (i <= s) a[i] = 0;\n\t\tif (i > 0) g[i].push_back({0, i-1});\n\t}\n\tFOR(i, m) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tg[x].push_back({a[y], y});\n\t}\n\tdijkstra(s);\n\tcout << dist[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\n\nint N, M, S, T, D[100000];\nvector< edge > g[100000];\n\nint Dijkstra(int s, int t)\n{\n  typedef pair< int, int > Pi;\n\n  vector< int > min_cost(N, 1 << 30);\n  priority_queue< Pi, vector< Pi >, greater<> > que;\n  que.emplace(0, s);\n  min_cost[s] = 0;\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.second == t) return (p.first);\n    if(p.first > min_cost[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost >= min_cost[e.to]) continue;\n      min_cost[e.to] = p.first + e.cost;\n      que.emplace(min_cost[e.to], e.to);\n    }\n  }\n  return (-1);\n}\n\nint main()\n{\n  cin >> N >> M >> S >> T;\n  --S, --T;\n  for(int i = 0; i < N; i++) cin >> D[i];\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].emplace_back((edge) {b, D[b]});\n  }\n  for(int i = 1; i < N; i++) {\n    g[i].emplace_back((edge) {i - 1, 0});\n  }\n  cout << Dijkstra(S, T) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n#define INF 1<<30\n\ntypedef pair<int, int> P;\n\nvector<P>G[100005];\nint N, M;\nint damage[100005];\nint d[100005];\n\nvoid dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >Q;\n  fill(d, d + N, INF);\n  d[s] = 0;\n  Q.push(P(0, s));\n\n  while(!Q.empty()){\n    P p = Q.top(); Q.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(int i=0; i < G[v].size();i++){\n      P e = G[v][i];\n      if(d[e.first] > d[v] + e.second){\n\td[e.first] = d[v] + e.second;\n\tQ.push(P(d[e.first], e.first));\n\t//\tcout << e.first << \" \" << d[e.first] << endl;\n      }\n    }\n  }\n}\n\nint main()\n{\n  int s, t;\n  cin >> N >> M >> s >> t; s--; t--;\n  for(int i=0;i<N;i++){\n    cin >> damage[i];\n  }\n  for(int i=0;i<M;i++){\n    int a, b;\n    cin >> a >> b; a--; b--;\n    G[a].push_back(make_pair(b, damage[b]));\n  }\n\n  for(int i=0;i<N-1;i++){\n    G[i+1].push_back(make_pair(i, 0));\n  }\n\n  /*  for(int i=0;i<N;i++){\n    for(int j=0;j<G[i].size();j++){\n      cout << G[i][j].first << \" \" ;\n    }\n    cout << endl;\n    }*/\n\n  dijkstra(s);\n\n  cout << d[t] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\n// #define int ll\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\n// const int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __print__(std::ostream &os, const char *, const char *tail, const T &fst) {\n    os << fst << tail;\n}\ntemplate <typename Fst, typename... Rst>\nvoid __print__(std::ostream &os, const char *del, const char *tail, const Fst &fst,\n               const Rst &... rst) {\n    os << fst << del;\n    __print__(os, del, tail, rst...);\n}\n\n#ifdef LOCAL\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __print__(os, \", \", \"\\n\", __VA_ARGS__);           \\\n        std::cerr << os.str();                            \\\n    } while (0)\n#else\n#define dump(...)\n#endif\n\ntemplate <typename Fst, typename... Rst>\nvoid println(const Fst &fst, const Rst &... rst) {\n    __print__(std::cout, \"\\n\", \"\\n\", fst, rst...);\n}\ntemplate <typename Fst, typename... Rst>\nvoid print(const Fst &fst, const Rst &... rst) {\n    __print__(std::cout, \" \", \"\\n\", fst, rst...);\n}\n\ntemplate <typename iter>\nvoid println_(iter bgn, iter end) {\n    while (bgn != end) println(*bgn++);\n}\n\ntemplate <typename iter>\nvoid print_(iter bgn, iter end) {\n    while (bgn != end) {\n        std::cout << *bgn++;\n        std::cout << (bgn == end ? \"\\n\" : \" \");\n    }\n}\n\nint _ = (std::cout.precision(10), std::cout.setf(std::ios::fixed), std::cin.tie(0),\n         std::ios::sync_with_stdio(0), 0);\n\ntemplate <typename T>\nstd::vector<T> ndarray(int n, T v) {\n    return std::vector<T>(n, v);\n}\ntemplate <typename... Args>\nauto ndarray(int n, Args... args) {\n    auto val = ndarray(args...);\n    return std::vector<decltype(val)>(n, move(val));\n}\n\ntemplate <typename T>\nbool umax(T &a, const T &b) {\n    return a < b ? a = b, true : false;\n}\n\ntemplate <typename T>\nbool umin(T &a, const T &b) {\n    return a > b ? a = b, true : false;\n}\n\nusing namespace std;\n\ntemplate <typename monoid>\nstruct segment_tree {\n    using M = monoid;\n    using T = typename M::value_type;\n\n    std::size_t sz;\n    std::vector<T> x;\n\n    segment_tree(std::size_t n = 0) {\n        sz = 1;\n        while (sz < n) sz *= 2;\n        x.assign(sz * 2, M::id());\n        initialize();\n    }\n\n    template <typename iterator>\n    segment_tree(iterator first, iterator last) {\n        sz = 1;\n        std::size_t n = std::distance(first, last);\n        while (sz < n) sz *= 2;\n        x.assign(sz * 2, M::id());\n        std::copy(first, last, x.begin() + sz);\n        initialize();\n    }\n\n    void fill(const T& val) {\n        std::fill(x.begin() + sz, x.end(), val);\n        initialize();\n    }\n\n    void initialize() {\n        for (int i = (int)sz - 1; i >= 1; --i) {\n            x[i] = M::op(x[i * 2 + 0], x[i * 2 + 1]);\n        }\n    }\n\n    T accumulate(std::size_t l, std::size_t r) const {\n        T al = M::id(), ar = M::id();\n        for (l += sz, r += sz; l < r; l /= 2, r /= 2) {\n            if (l & 1) al = M::op(al, x[l++]);\n            if (r & 1) ar = M::op(x[--r], ar);\n        }\n        return M::op(al, ar);\n    }\n\n    void update(std::size_t i, const T &val) {\n        x[i += sz] = val;\n        while (i > 1) {\n            x[i / 2] = M::op(x[i], x[i ^ 1]);\n            i /= 2;\n        }\n    }\n\n    T operator[](std::size_t i) const { return x[sz + i]; }\n};\n\ntemplate <typename T>\nstruct min_monoid {\n    using value_type = T;\n    static constexpr T id() { return std::numeric_limits<T>::max(); }\n    static T op(const T &a, const T &b) { return std::min(a, b); }\n};\n\ntemplate <typename T>\nstruct max_monoid {\n    using value_type = T;\n    static constexpr value_type id() { return std::numeric_limits<value_type>::min(); }\n    static value_type op(const value_type &a, const value_type &b) { return std::max(a, b); }\n};\n\ntemplate <typename T>\nstruct sum_monoid {\n    using value_type = T;\n    static constexpr value_type id() { return 0; }\n    static value_type op(const value_type &a, const value_type &b) { return a + b; }\n};\n\ntemplate <typename value_type>\nusing rmq = segment_tree<min_monoid<value_type>>;\n\ntemplate <typename value_type>\nusing rsq = segment_tree<sum_monoid<value_type>>;\n\nusing pii = pair<int, int>;\nint N, M, s, t;\nint d[100010];\nvector<pii> es;\n\nsigned main() {\n    while (cin >> N >> M >> s >> t) {\n        --s, --t;\n        rep(i, N) cin >> d[i];\n        es.resize(M);\n        rep(i, M) {\n            cin >> es[i].first >> es[i].second;\n            --es[i].first, --es[i].second;\n        }\n        sort(all(es), [](pii a, pii b) {\n                return a.second < b.second;\n            });\n        int ans;\n        if (t < s) {\n            ans = 0;\n        } else {\n            rmq<ll> dp(N + 1);\n            rep(i, s + 1) {\n                dp.update(i, 0);\n            }\n            for (auto &e : es) {\n                int l, r;\n                tie(l, r) = e;\n                int x = dp.accumulate(l, r) + d[r];\n                dp.update(r, x);\n                // rep(i, N) {\n                //     cout << dp.accumulate(i, i + 1) << ' ';\n                // }\n                // cout << endl;\n            }\n            ans = dp.accumulate(t, N + 1);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/cdescription.jsp?cid=ACPC2017Day1&pid=D\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n \nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int N, M, s, t; cin >> N >> M >> s >> t;\n    s--; t--;\n    vector<int> d(N);\n    vector<vector<int>> G(N);\n    for (int i = 0; i < N;i++) cin >> d[i];\n    for (int i = 0; i < M;i++) {\n        int a, b; cin >> a >> b; a--; b--;\n        G[a].push_back(b);\n    }\n    for (int i = 1; i < N;i++)G[i].push_back(i - 1);\n    vector<ll> dist(N, INF);\n    queue<pair<int, int>> q;\n    q.push({ s,s });\n    dist[s] = 0;\n    while (!q.empty()) {\n        auto p = q.front(); q.pop();\n        int n = p.first, max_n = p.second;\n        for (auto next : G[n]) {\n            int cost = d[next];\n            if (next < max_n) cost = 0;\n            if (dist[next] > dist[n] + cost) {\n                dist[next] = dist[n] + cost;\n                q.push({ next,max(max_n,next) });\n            }\n        }\n    }\n    cout << dist[t] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;(i)<(n);(i)++)\n#define ll long long\n\nvector<pair<int, int>> adj[100005];\n\nstatic const int MAX = 100005;\nstatic const int INFTY = (1 << 28);\nstatic const int WHITE = 0;\nstatic const int GRAY = 1;\nstatic const int BLACK = 2;\n\nint s, t;\nint n;\n\nint dist[MAX];\n\nvoid dijkstra() {\n\tpriority_queue<pair<int, int>> PQ;\n\tint color[MAX];\n\t\n\tREP(i, n) {\n\t\tdist[i+1] = INFTY;\n\t\tcolor[i+1] = WHITE;\n\t}\n\n\tdist[s] = 0;\n\tPQ.push(make_pair(0, s));\n\tcolor[s] = GRAY;\n\n\twhile (!PQ.empty()) {\n\t\tpair<int, int> f = PQ.top(); PQ.pop();\n\t\tint u = f.second;\n\t\tcolor[u] = BLACK;\n\n\t\t//????°???????????????????????????????????????§???????????°??????\n\t\tif (dist[u] < f.first*(-1)) continue;\n\n\t\tREP(j, adj[u].size()) {\n\t\t\tint v = adj[u][j].first;\n\t\t\tif (color[v] == BLACK) continue;\n\t\t\tif (dist[v] > dist[u] + adj[u][j].second) {\n\t\t\t\tdist[v] = dist[u] + adj[u][j].second;\n\t\t\t\tPQ.push(make_pair(dist[v] * (-1), v));\n\t\t\t\tcolor[v] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tREP(i, n) {\n\t\tcout << i+1 << \" \" << (dist[i+1] == INFTY ? -1 : dist[i+1]) << endl;\n\t}\n\t*/\n}\n\nint main() {\n\tint M;\n\tcin >> n >> M >> s >>t;\n\n\tint dam[100005];\n\tREP(i, n) {\n\t\tcin >> dam[i + 1];//1-indexed\n\t}\n\n\tREP(i, n) {\n\t\tif (i == 0) continue;\n\t\tadj[i+1].push_back(make_pair(i, 0));//1-indexed\n\t}\n\tint a, b;\n\tREP(i, M) {\n\t\tcin >> a >> b;\n\t\tadj[a].push_back(make_pair(b, dam[b]));\n\t}\n\n\t/*\n\tREP(i, n) {\n\t\tfor (auto u : adj[i + 1]) {\n\t\t\tcout << u.first << \":\" << u.second << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\n\tdijkstra();\n\n\tcout << dist[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 40)\nusing namespace std;\ntypedef long long ll;\n\nstruct state {\n  ll v, d;\n\npublic:\n  bool operator<(const state &s) const { return d > s.d; };\n};\n\nll N, M, S, T, D[100000], A, B;\nvector<ll> E[100000];\n\nint main(void) {\n  cin >> N >> M >> S >> T; S--; T--;\n  REP(i, 0, N) cin >> D[i];\n  REP(i, 0, M) {\n    cin >> A >> B; A--; B--;\n    if(A < B) E[A].push_back(B);\n    if(B < A) E[B].push_back(A);\n  }\n\n  vector<ll> dp(N, INF);\n  priority_queue<state> q;\n  q.push((state) { S, 0 });\n\n  while(q.size()) {\n    state c = q.top();\n    q.pop();\n\n    // cout << c.v << \" \" << c.d << endl;\n\n    if(c.d >= dp[c.v]) continue;\n    dp[c.v] = c.d;\n\n    if(c.v == T) {\n      cout << c.d << endl;\n      return 0;\n    }\n\n    if(c.v - 1 >= 0 && dp[c.v - 1] > c.d) q.push((state) { c.v - 1, c.d });\n    for(ll u : E[c.v]) if(dp[u] > c.d + D[u]) q.push((state) { u, c.d + D[u] });\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF 1<<30\nstruct edge {\n\tint u;\n\tint v;\n\tint cost;\n\tedge() {}\n\tedge(int u, int v, int cost) :u(u), v(v), cost(cost) {}\n};\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M, s, t; cin >> N >> M >> s >> t;\n\ts--; t--;\n\tvector<ll> d(N);\n\tfor (int i = 0; i < N;i++) cin >> d[i];\n\tvector<vector<edge>> G(N);\n\tfor (int i = 0; i < M;i++) {\n\t\tll a, b;cin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].push_back(edge(a, min(b, t), d[b]));\n\t}\n\tfor (int i = t; i > 0;i--) {\n\t\tG[i].push_back(edge(i, i - 1, 0));\n\t}\n\n\tvector<ll> dist(t + 1, INF);\n\tqueue<pair<int,int>> q;\n\tq.push({ s,s });\n\tdist[s] = 0;\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tint n = p.first; int maxn = p.second;\n\t\tfor (auto e : G[n]) {\n\t\t\tif (e.v < maxn) {\n\t\t\t\tif (dist[e.v] > dist[e.u]) {\n\t\t\t\t\tdist[e.v] = dist[e.u];\n\t\t\t\t\tq.push({ e.v, maxn });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist[e.v] > dist[e.u] + e.cost) {\n\t\t\t\t\tdist[e.v] = dist[e.u] + e.cost;\n\t\t\t\t\tq.push({ e.v, max(maxn, e.v) });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nint mn[100010];\n\ntemplate <typename monoid_trait> struct segment_tree {\n\tusing M = monoid_trait;\n\tusing T = typename M::value_type;\n\n\t// monoid m;\n\tstd::size_t sz;\n\tstd::vector<T> x;\n\n\tsegment_tree(std::size_t n = 0) {\n\t\tsz = 1;\n\t\twhile (sz < n)\n\t\t\tsz *= 2;\n\t\tx.assign(sz * 2, M::id());\n\t\tinitialize();\n\t}\n\n\ttemplate <typename iterator>\n\tsegment_tree(iterator first, iterator last) {\n\t\tsz = 1;\n\t\tstd::size_t n = std::distance(first, last);\n\t\twhile (sz < n)\n\t\t\tsz *= 2;\n\t\tx.assign(sz * 2, M::id());\n\t\tstd::copy(first, last, x.begin() + sz);\n\t\tinitialize();\n\t}\n\n\tvoid initialize() {\n\t\tfor (int i = (int)sz - 1; i >= 1; --i) {\n\t\t\tx[i] = M::op(x[i * 2 + 0], x[i * 2 + 1]);\n\t\t}\n\t}\n\n\tT query(std::size_t l, std::size_t r) const {\n\t\tT res = M::id();\n\t\tfor (l += sz, r += sz; l < r; l >>= 1, r >>= 1) {\n\t\t\tif (l & 1)\n\t\t\t\tres = M::op(res, x[l++]);\n\t\t\tif (r & 1)\n\t\t\t\tres = M::op(res, x[--r]);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid update(std::size_t i, const T &val) {\n\t\tx[i += sz] = val;\n\t\twhile (i > 1) {\n\t\t\tx[i / 2] = M::op(x[i], x[i ^ 1]);\n\t\t\ti /= 2;\n\t\t}\n\t}\n\n\tT operator[](std::size_t i) const { return x[sz + i]; }\n};\n\ntemplate <typename T> struct zero_sum_monoid {\n\tusing value_type = T;\n\tstatic constexpr T id() { return 0; }\n\tstatic T op(const T &a, const T &b) { return a + b; }\n};\n\ntemplate <typename T> struct inf_min_monoid {\n\tusing value_type = T;\n\tstatic constexpr T id() { return std::numeric_limits<T>::max(); }\n\tstatic T op(const T &a, const T &b) { return std::min(a, b); }\n};\n\ntemplate <typename T> using rmq = segment_tree<inf_min_monoid<T>>;\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M, S, T;\n\t\n\tcin >> N >> M >> S >> T;\n\tsegment_tree<inf_min_monoid<int>> st(N);\n\t//st.update(N - 1, 0);\n\t//cerr << st.query(0, N) << endl;\n\tS--;\n\tT--;\n\tvector<int> D(N);\n\tint res = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tmn[i] = -1;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> D[i];\n\t}\n\tint a, b;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tif ((mn[b] == -1) || (mn[b] > a)) {\n\t\t\tmn[b] = a;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i <= S) {\n\t\t\tst.update(i, 0);\n\t\t}\n\t\telse {\n\t\t\tif (mn[i] != -1) {\n\t\t\t\tint t;\n\t\t\t\tt = st.query(mn[i], i + 1);\n\t\t\t\tif (t < 10000000000) {\n\t\t\t\t\tst.update(i, t + D[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << st.query(T, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nstruct S{\n    int to, cost;\n    // S(int to, int cost): to(to), cost(cost){}\n    bool operator>(const S &s) const{\n        return cost > s.cost;\n    }\n};\n\nint n, m, s, t;\nint p[100010];\nvector<S> G[100010];\nint d[100010];\n\nvoid dijkstra(int s){\n    fill(d, d + n, INF);//V, INF\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(d[s], s));\n    while(!q.empty()){\n        P p = q.top(); q.pop();\n        int from = p.second;\n        int cost = p.first;\n        if(d[from] < cost) continue;\n        rep(i, 0, G[from].size()){\n            S e = G[from][i];\n            int next = e.to;\n            int newCost = e.cost + cost;\n            if(d[next] > newCost){\n                d[next] = newCost;\n                q.push(P(newCost, next));\n            }\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m >> s >> t;\n    s--; t--;\n    rep(i, 0, n){\n        cin >> p[i];\n    }\n    rep(i, 0, m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        G[a].push_back(S{b, p[b]});\n    }\n    rep(i, 1, n){\n        G[i].push_back(S{i - 1, 0});\n    }\n    dijkstra(s);\n    // for(int ii = 0; ii < n; ii++){\n    //     if(ii) cout << ' ';\n    //     cout << d[ii];\n    // }\n    // cout << endl;\n    cout << d[t] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF 1<<30\nstruct edge {\n\tint u;\n\tint v;\n\tint cost;\n\tedge() {}\n\tedge(int u, int v, int cost) :u(u), v(v), cost(cost) {}\n};\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M, s, t; cin >> N >> M >> s >> t;\n\ts--; t--;\n\tvector<ll> d(N);\n\tfor (int i = 0; i < N;i++) cin >> d[i];\n\tvector<vector<edge>> G(N);\n\tfor (int i = 0; i < M;i++) {\n\t\tll a, b;cin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].push_back(edge(a, min(b, t), d[b]));\n\t}\n\tfor (int i = t; i > 0;i--) {\n\t\tG[i].push_back(edge(i, i - 1, 0));\n\t}\n\n\tvector<ll> dist(t + 1, INF);\n\tqueue<int> q;\n\tq.push(s);\n\tdist[s] = 0;\n\twhile (!q.empty()) {\n\t\tauto n = q.front(); q.pop();\n\t\tfor (auto e : G[n]) {\n\t\t\tif (dist[e.v] > dist[e.u] + e.cost) {\n\t\t\t\tdist[e.v] = dist[e.u] + e.cost;\n\t\t\t\tq.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 40)\nusing namespace std;\ntypedef long long ll;\n\nll N, M, S, T, D[100000], A, B;\nvector<ll> E[100000];\n\nint main(void) {\n  cin >> N >> M >> S >> T; S--; T--;\n  REP(i, 0, N) cin >> D[i];\n  REP(i, 0, M) {\n    cin >> A >> B; A--; B--;\n    if(A < B) E[A].push_back(B);\n    if(B < A) E[B].push_back(A);\n  }\n\n  vector<ll> dp(N, INF);\n  priority_queue<state> q;\n  q.push((state) { S, 0 });\n\n  while(q.size()) {\n    state c = q.top();\n    q.pop();\n\n    // cout << c.v << \" \" << c.d << endl;\n\n    if(c.d >= dp[c.v]) continue;\n    dp[c.v] = c.d;\n\n    if(c.v == T) {\n      cout << c.d << endl;\n      return 0;\n    }\n\n    if(c.v - 1 >= 0 && dp[c.v - 1] > c.d) q.push((state) { c.v - 1, c.d });\n    for(ll u : E[c.v]) if(dp[u] > c.d + D[u]) q.push((state) { u, c.d + D[u] });\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pairInt;\n#define FOR(i, n) for (int i = 0; i < int(n); i++)\n#define FOR1(i, m, n) for (int i = int(m); i < int(n); i++)\n#define MAX(a, b) ((a) >= (b) ? (a) : (b))\n#define MIN(a, b) ((a) <= (b) ? (a) : (b))\n\nint N, M;\nvector<int> d;\nmultimap<int, int> path;\n\n\ntemplate <>\nbool less<pairInt>::operator()(const pairInt& x, const pairInt& y) const {\n  return x.second < y.second;\n}\n\nint solve(int s, int t) {\n  vector<int> dist;\n  set<int> Q;\n  int ret = 0;\n  dist.resize(N + 1, INT_MAX);\n  dist[s] = 0;\n  FOR1(i, 1, N+1) Q.insert(i);\n\n  while (!Q.empty()) {\n    auto it = min_element(Q.begin(), Q.end(), [&](int a, int b) { return dist[a] < dist[b]; });\n    int u = *it;\n    Q.erase(it);\n\n    if (u == t) {\n      ret = dist[u];\n      break;\n    }\n\n    using iterator = decltype(path)::iterator;\n    pair<iterator, iterator> ret = path.equal_range(u);\n    for (auto it = ret.first; it != ret.second; it++) {\n      dist[it->second] = MIN(dist[it->second], dist[u] + d[it->second]);\n    }\n    FOR1(i, 1, u) {\n      dist[i] = MIN(dist[i], dist[u]);\n    }\n  }\n\n  return ret;\n}\n\nint main(int argc, char* argv[]) {\n  int s, t;\n\n  scanf(\"%d%d%d%d\", &N, &M, &s, &t);\n\n  d.resize(N + 1);\n\n  FOR1(i, 1, N + 1) scanf(\"%d\", &d[i]);\n  FOR(i, M) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    path.insert(make_pair(a, b));\n  }\n\n  printf(\"%d\\n\", solve(s, t));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF ((long long)1e18)\n#define MOD ((int)1e9+7)\n#define endl \"\\n\"\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX\n\nsigned main(){\n\t// cin.tie(0);\n\t// ios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint N, M, s, t, min_ = 0;\n\tint a, b;\n\tvector<int> d;\n\tvector<vector<int>> graph;\n\tpriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> Q;\n\t\n\tcin>>N>>M>>s>>t;\n\t\n\td.resize(N+1);\n\tgraph.resize(N+1);\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tcin>>d[i];\n\t}\n\t\n\tfor(int i = 0; i < M; i++){\n\t\tcin>>a>>b;\n\t\tgraph[a].push_back(b);\n\t}\n\t\n\tfor(int i = 0; i < t; i++){ //cout<<i<<endl;\n\t\tmin_ = 0;\n\t\tif(i >= s && Q.size()){\n\t\t\tpair<int,int> temp = Q.top();\n\t\t\t\n\t\t\twhile(temp.second <= i){ //cout<<\"roop \"<<endl;\n\t\t\t\tQ.pop();\n\t\t\t\t temp = Q.top();\n\t\t\t}\n\t\t\tmin_ = temp.first;\n\t\t}\n\t\t//cout<<\"END \"<<endl;\n\t\tfor(int j = 0; j < graph[i+1].size(); j++){\n\t\t\tQ.push(make_pair(min_+d[graph[i+1][j]], graph[i+1][j]));\n\t\t\t// cout<<\"push \"<<min_+d[graph[i+1][j]]<<\" \"<<graph[i+1][j]<<endl;\n\t\t}\n\t}\n\t\n\tcout<<min_<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,s,t;\nint d[100005];\nvector<int> G[100005];\nint dist[100005];\npriority_queue<P,vector<P>,greater<P> > que;\nbool used[100005];\n\nvoid dfs(int v,int c,int vv){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]<vv && dist[G[v][i]]>c){\n\t\t\tdist[G[v][i]]=c;\n\t\t\tque.push(P(c,G[v][i]));\n\t\t\tdfs(G[v][i],c,vv);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d%d\",&n,&m,&s,&t);\n\ts--;\n\tt--;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&d[i]);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;\n\t\tv--;\n\t\tG[u].push_back(v);\n\t}\n\tif(s>=t){\n\t\tprintf(\"0\\n\");\n\t}else{\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdist[i]=1e9;\n\t\t}\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\tint prev=0;\n\t\twhile(que.size()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tif(dist[p.second]<p.first)continue;\n\t\t\twhile(prev<=p.second){\n\t\t\t\tif(dist[prev]>dist[p.second]){\n\t\t\t\t\tdist[prev]=dist[p.second];\n\t\t\t\t\tque.push(P(dist[p.second],prev));\n\t\t\t\t}\n\t\t\t\tprev++;\n\t\t\t}\n\t\t\tfor(int i=0;i<G[p.second].size();i++){\n\t\t\t\tif(G[p.second][i]>p.second){\n\t\t\t\t\tint nec=G[p.second][i];\n\t\t\t\t\tif(dist[nec]>dist[p.second]+d[nec]){\n\t\t\t\t\t\tdist[nec]=dist[p.second]+d[nec];\n\t\t\t\t\t\tque.push(P(dist[nec],nec));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dist[t]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll inf = 1e15;\nstruct edge{\n  ll to, cost;\n  edge(ll t, ll c) {\n    to = t, cost = c;\n  }\n};\nint N, M;\nll d[100005];\nvector<edge> G[100005];\nvoid dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  FOR(i,1,N+1) d[i] = inf;\n  d[s] = 0;\n  que.push(P(0, s));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(auto &e : G[v]){\n      if(d[e.to] > d[v] + e.cost){\n        d[e.to] = d[v] + e.cost;\n        que.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int s, t; cin >> N >> M >> s >> t;\n  ll dd[N]; FOR(i,0,N) cin >> dd[i];\n  FOR(i,0,M) {\n    int a, b; cin >> a >> b;\n    G[a].push_back(edge(b, dd[b-1]));\n  }\n  FOR(i,1,s) {\n    G[s].push_back(edge(i, 0));\n  }\n  if(s > t) {\n    cout << 0 << endl;\n    return 0;\n  }\n  dijkstra(s);\n  ll ans = 1e15;\n  FOR(i,t,N+1) {\n    ans = min(ans, d[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\n#define int ll\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\n// const int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __print__(std::ostream &os, const char *, const char *tail, const T &fst) {\n    os << fst << tail;\n}\ntemplate <typename Fst, typename... Rst>\nvoid __print__(std::ostream &os, const char *del, const char *tail, const Fst &fst,\n               const Rst &... rst) {\n    os << fst << del;\n    __print__(os, del, tail, rst...);\n}\n\n#ifdef LOCAL\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __print__(os, \", \", \"\\n\", __VA_ARGS__);           \\\n        std::cerr << os.str();                            \\\n    } while (0)\n#else\n#define dump(...)\n#endif\n\ntemplate <typename Fst, typename... Rst>\nvoid println(const Fst &fst, const Rst &... rst) {\n    __print__(std::cout, \"\\n\", \"\\n\", fst, rst...);\n}\ntemplate <typename Fst, typename... Rst>\nvoid print(const Fst &fst, const Rst &... rst) {\n    __print__(std::cout, \" \", \"\\n\", fst, rst...);\n}\n\ntemplate <typename iter>\nvoid println_(iter bgn, iter end) {\n    while (bgn != end) println(*bgn++);\n}\n\ntemplate <typename iter>\nvoid print_(iter bgn, iter end) {\n    while (bgn != end) {\n        std::cout << *bgn++;\n        std::cout << (bgn == end ? \"\\n\" : \" \");\n    }\n}\n\nint _ = (std::cout.precision(10), std::cout.setf(std::ios::fixed), std::cin.tie(0),\n         std::ios::sync_with_stdio(0), 0);\n\ntemplate <typename T>\nstd::vector<T> ndarray(int n, T v) {\n    return std::vector<T>(n, v);\n}\ntemplate <typename... Args>\nauto ndarray(int n, Args... args) {\n    auto val = ndarray(args...);\n    return std::vector<decltype(val)>(n, move(val));\n}\n\ntemplate <typename T>\nbool umax(T &a, const T &b) {\n    return a < b ? a = b, true : false;\n}\n\ntemplate <typename T>\nbool umin(T &a, const T &b) {\n    return a > b ? a = b, true : false;\n}\n\nusing namespace std;\n\ntemplate <typename monoid>\nstruct segment_tree {\n    using M = monoid;\n    using T = typename M::value_type;\n\n    std::size_t sz;\n    std::vector<T> x;\n\n    segment_tree(std::size_t n = 0) {\n        sz = 1;\n        while (sz < n) sz *= 2;\n        x.assign(sz * 2, M::id());\n        initialize();\n    }\n\n    template <typename iterator>\n    segment_tree(iterator first, iterator last) {\n        sz = 1;\n        std::size_t n = std::distance(first, last);\n        while (sz < n) sz *= 2;\n        x.assign(sz * 2, M::id());\n        std::copy(first, last, x.begin() + sz);\n        initialize();\n    }\n\n    void fill(const T& val) {\n        std::fill(x.begin() + sz, x.end(), val);\n        initialize();\n    }\n\n    void initialize() {\n        for (int i = (int)sz - 1; i >= 1; --i) {\n            x[i] = M::op(x[i * 2 + 0], x[i * 2 + 1]);\n        }\n    }\n\n    T accumulate(std::size_t l, std::size_t r) const {\n        T al = M::id(), ar = M::id();\n        for (l += sz, r += sz; l < r; l /= 2, r /= 2) {\n            if (l & 1) al = M::op(al, x[l++]);\n            if (r & 1) ar = M::op(x[--r], ar);\n        }\n        return M::op(al, ar);\n    }\n\n    void update(std::size_t i, const T &val) {\n        x[i += sz] = val;\n        while (i > 1) {\n            x[i / 2] = M::op(x[i], x[i ^ 1]);\n            i /= 2;\n        }\n    }\n\n    T operator[](std::size_t i) const { return x[sz + i]; }\n};\n\ntemplate <typename T>\nstruct min_monoid {\n    using value_type = T;\n    static constexpr T id() { return std::numeric_limits<T>::max(); }\n    static T op(const T &a, const T &b) { return std::min(a, b); }\n};\n\ntemplate <typename T>\nstruct max_monoid {\n    using value_type = T;\n    static constexpr value_type id() { return std::numeric_limits<value_type>::min(); }\n    static value_type op(const value_type &a, const value_type &b) { return std::max(a, b); }\n};\n\ntemplate <typename T>\nstruct sum_monoid {\n    using value_type = T;\n    static constexpr value_type id() { return 0; }\n    static value_type op(const value_type &a, const value_type &b) { return a + b; }\n};\n\ntemplate <typename value_type>\nusing rmq = segment_tree<min_monoid<value_type>>;\n\ntemplate <typename value_type>\nusing rsq = segment_tree<sum_monoid<value_type>>;\n\nusing pii = pair<int, int>;\nint N, M, s, t;\nint d[100010];\nvector<pii> es;\n\nsigned main() {\n    while (cin >> N >> M >> s >> t) {\n        --s, --t;\n        rep(i, N) cin >> d[i];\n        es.resize(M);\n        rep(i, M) {\n            cin >> es[i].first >> es[i].second;\n            --es[i].first, --es[i].second;\n        }\n        sort(all(es), [](pii a, pii b) {\n                return a.second < b.second;\n            });\n        int ans;\n        if (t < s) {\n            ans = 0;\n        } else {\n            rmq<ll> dp(N + 1);\n            rep(i, s + 1) {\n                dp.update(i, 0);\n            }\n            for (auto &e : es) {\n                int l, r;\n                tie(l, r) = e;\n                int x = dp.accumulate(l, N + 1) + d[r];\n                dp.update(r, x);\n                // rep(i, N) {\n                //     cout << dp.accumulate(i, i + 1) << ' ';\n                // }\n                // cout << endl;\n            }\n            ans = dp.accumulate(t, N + 1);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\n\nint N, M, S, T, D[100000];\nvector< edge > g[100000];\n\nint Dijkstra(int s, int t)\n{\n  typedef pair< int, int > Pi;\n\n  vector< int > min_cost(N, 1 << 30);\n  priority_queue< Pi, vector< Pi >, greater<> > que;\n  que.emplace(0, s);\n  min_cost[s] = 0;\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.second == t) return (p.first);\n    if(p.first > min_cost[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost >= min_cost[e.to]) continue;\n      min_cost[e.to] = p.first + e.cost;\n      que.emplace(min_cost[e.to], e.to);\n    }\n  }\n  return (-1);\n}\n\nint main()\n{\n  cin >> N >> M >> S >> T;\n  --S, --T;\n  for(int i = 0; i < N; i++) cin >> D[i];\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].emplace_back((edge) {b, D[b]});\n  }\n  for(int i = 1; i < N; i++) {\n    g[i].emplace_back((edge) {i - 1, 0});\n  }\n  cout << Dijkstra(S, T) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr,greater<pr> > PQ;\nconst int SIZE=2*1e5;\nconst LL INF=1LL<<60;\nconst LL p=7+1e9;\nLL N,M,s,t,a,b,d[SIZE];\nLL DP[SIZE];\nVpr edges[SIZE];\nLL solve(){\n\tcin >> N >> M >> s >> t;\n\n\tFOR(i,1,N+1){\n\t\tcin >> d[i];\n\t\tedges[i].PB(pr(0,i-1));\n\t\tif(i==s) DP[i]=0;\n\t\telse DP[i]=INF;\n\t}\n\tPQ qu;\n\tREP(i,M){\n\t\tcin >> a >> b;\n\t\tedges[a].PB(pr(d[b],b));\n\t}\n\tqu.push(pr(0,s));\n\twhile(!qu.empty()){\n\t\tint now=qu.top().second,dists=qu.top().first;\n\t\tqu.pop();\n\t\tif(dists>DP[now]) continue;\n\t\tREP(i,edges[now].size()){\n\t\t\tint next=edges[now][i].second;\n\t\t\tint ndist=dists+edges[now][i].first;\n\t\t\tif(DP[next]>ndist){\n\t\t\t\tDP[next]=ndist;\n\t\t\t\tqu.push(pr(ndist,next));\n\t\t\t}\n\t\t}\n\t}\n\treturn DP[t];\n}\nint main(){\n\tcout << solve() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pairInt;\n#define FOR(i, n) for (int i = 0; i < int(n); i++)\n#define FOR1(i, m, n) for (int i = int(m); i < int(n); i++)\n#define MAX(a, b) ((a) >= (b) ? (a) : (b))\n#define MIN(a, b) ((a) <= (b) ? (a) : (b))\n\nint N, M;\nvector<int> d;\nmultimap<int, int> ab;\n\nint solve(int s, int t, int lower, int limit) {\n  int ans = limit;\n  for (auto it = ab.lower_bound(lower); it != ab.end() && it->first <= s;\n       it++) {\n    if (it->second >= t) {\n      ans = MIN(ans, d[it->second]);\n    } else if (it->second > s && d[it->second] < limit) {\n      int temp = solve(it->second, t, s + 1, ans - d[it->second]);\n      if (temp != -1) {\n        ans = MIN(ans, temp);\n      }\n    }\n  }\n\n  return ans == limit ? -1 : ans;\n}\n\nint main(int argc, char *argv[]) {\n  int s, t;\n\n  scanf(\"%d%d%d%d\", &N, &M, &s, &t);\n\n  d.resize(N + 1);\n\n  FOR1(i, 1, N + 1) scanf(\"%d\", &d[i]);\n  FOR(i, M) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    ab.insert(make_pair(a, b));\n  }\n\n  printf(\"%d\\n\", solve(s, t, 0, INT_MAX));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\n#define int ll\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\n// const int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __print__(std::ostream &os, const char *, const char *tail, const T &fst) {\n    os << fst << tail;\n}\ntemplate <typename Fst, typename... Rst>\nvoid __print__(std::ostream &os, const char *del, const char *tail, const Fst &fst,\n               const Rst &... rst) {\n    os << fst << del;\n    __print__(os, del, tail, rst...);\n}\n\n#ifdef LOCAL\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __print__(os, \", \", \"\\n\", __VA_ARGS__);           \\\n        std::cerr << os.str();                            \\\n    } while (0)\n#else\n#define dump(...)\n#endif\n\ntemplate <typename Fst, typename... Rst>\nvoid println(const Fst &fst, const Rst &... rst) {\n    __print__(std::cout, \"\\n\", \"\\n\", fst, rst...);\n}\ntemplate <typename Fst, typename... Rst>\nvoid print(const Fst &fst, const Rst &... rst) {\n    __print__(std::cout, \" \", \"\\n\", fst, rst...);\n}\n\ntemplate <typename iter>\nvoid println_(iter bgn, iter end) {\n    while (bgn != end) println(*bgn++);\n}\n\ntemplate <typename iter>\nvoid print_(iter bgn, iter end) {\n    while (bgn != end) {\n        std::cout << *bgn++;\n        std::cout << (bgn == end ? \"\\n\" : \" \");\n    }\n}\n\nint _ = (std::cout.precision(10), std::cout.setf(std::ios::fixed), std::cin.tie(0),\n         std::ios::sync_with_stdio(0), 0);\n\ntemplate <typename T>\nstd::vector<T> ndarray(int n, T v) {\n    return std::vector<T>(n, v);\n}\ntemplate <typename... Args>\nauto ndarray(int n, Args... args) {\n    auto val = ndarray(args...);\n    return std::vector<decltype(val)>(n, move(val));\n}\n\ntemplate <typename T>\nbool umax(T &a, const T &b) {\n    return a < b ? a = b, true : false;\n}\n\ntemplate <typename T>\nbool umin(T &a, const T &b) {\n    return a > b ? a = b, true : false;\n}\n\nusing namespace std;\n\ntemplate <typename monoid>\nstruct segment_tree {\n    using M = monoid;\n    using T = typename M::value_type;\n\n    std::size_t sz;\n    std::vector<T> x;\n\n    segment_tree(std::size_t n = 0) {\n        sz = 1;\n        while (sz < n) sz *= 2;\n        x.assign(sz * 2, M::id());\n        initialize();\n    }\n\n    template <typename iterator>\n    segment_tree(iterator first, iterator last) {\n        sz = 1;\n        std::size_t n = std::distance(first, last);\n        while (sz < n) sz *= 2;\n        x.assign(sz * 2, M::id());\n        std::copy(first, last, x.begin() + sz);\n        initialize();\n    }\n\n    void fill(const T& val) {\n        std::fill(x.begin() + sz, x.end(), val);\n        initialize();\n    }\n\n    void initialize() {\n        for (int i = (int)sz - 1; i >= 1; --i) {\n            x[i] = M::op(x[i * 2 + 0], x[i * 2 + 1]);\n        }\n    }\n\n    T accumulate(std::size_t l, std::size_t r) const {\n        T al = M::id(), ar = M::id();\n        for (l += sz, r += sz; l < r; l /= 2, r /= 2) {\n            if (l & 1) al = M::op(al, x[l++]);\n            if (r & 1) ar = M::op(x[--r], ar);\n        }\n        return M::op(al, ar);\n    }\n\n    void update(std::size_t i, const T &val) {\n        x[i += sz] = val;\n        while (i > 1) {\n            x[i / 2] = M::op(x[i], x[i ^ 1]);\n            i /= 2;\n        }\n    }\n\n    T operator[](std::size_t i) const { return x[sz + i]; }\n};\n\ntemplate <typename T>\nstruct min_monoid {\n    using value_type = T;\n    static constexpr T id() { return 1e18; }\n    static T op(const T &a, const T &b) { return std::min(a, b); }\n};\n\ntemplate <typename T>\nstruct max_monoid {\n    using value_type = T;\n    static constexpr value_type id() { return std::numeric_limits<value_type>::min(); }\n    static value_type op(const value_type &a, const value_type &b) { return std::max(a, b); }\n};\n\ntemplate <typename T>\nstruct sum_monoid {\n    using value_type = T;\n    static constexpr value_type id() { return 0; }\n    static value_type op(const value_type &a, const value_type &b) { return a + b; }\n};\n\ntemplate <typename value_type>\nusing rmq = segment_tree<min_monoid<value_type>>;\n\ntemplate <typename value_type>\nusing rsq = segment_tree<sum_monoid<value_type>>;\n\nusing pii = pair<int, int>;\nint N, M, s, t;\nint d[100010];\nvector<pii> es;\n\nsigned main() {\n    while (cin >> N >> M >> s >> t) {\n        --s, --t;\n        rep(i, N) cin >> d[i];\n        es.resize(M);\n        for (auto &e : es) {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            e = {a, b};\n        }\n        sort(all(es), [](pii a, pii b) {\n                return a.second < b.second;\n            });\n        int ans;\n        if (t < s) {\n            ans = 0;\n            assert(false);\n        } else {\n            rmq<ll> dp(N + 1);\n            rep(i, s + 1) {\n                dp.update(i, 0);\n            }\n            for (auto &e : es) {\n                int l, r;\n                tie(l, r) = e;\n                int x = dp.accumulate(l, r) + d[r];\n                dp.update(r, x);\n                // rep(i, N) {\n                //     cout << dp.accumulate(i, i + 1) << ' ';\n                // }\n                // cout << endl;\n            }\n            ans = dp.accumulate(t, N + 1);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REP2(i,m,n) for (int i=m;i<(n);i++)\ntypedef long long ll;\n\nint N, M, s, t;\nint D[101010];\nvector<int> edges[101010];\nll dist[101010];\n\n\nint main() {\n    cin >> N >> M >> s >> t;\n    s--, t--;\n\n    REP(i, N) cin >> D[i];\n    REP(i, s+1) D[i] = 0;\n\n    REP(i, M) {\n        int a, b; cin >> a >> b;\n        edges[a - 1].push_back(b - 1);\n    }\n\n    REP(i, N) dist[i] = 1LL << 59;\n\n    REP(i, N) {\n        if (i <= s) dist[i] = 0;\n        for (auto m: edges[i])\n            dist[m] = min(dist[m], dist[i] + D[m]);\n    }\n\n    ll ans = 1LL << 59;\n    REP2(i, t, N) ans = min(ans, dist[i]);\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<28\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\t// first ??????????????¢ second ???????????????\n\nconst int MAX_V = (int)1e5;\n\nclass edge{\npublic:\n\tint to;\n\tint cost;\n\tedge(){}\n\tedge(int _to, int _cost):to(_to),cost(_cost){}\n};\n\nint D[MAX_V];\t\t\t\t\t// ?????????:s ????????????????????¢\n\nvector<edge> G[MAX_V];\n\nbool used[MAX_V];\n\n// ?????????:s ????????????????????¢????±???????\nvoid dijkstra (int s)\n{\n\t// greater<P> ????????????????????¨??§first????°???????????????????????????????????????????\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill (D,  D + MAX_V, INF);\n\tD[s] = 0;\n\tque.push (P (0, s));\n\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (D[v] < p.first) continue;\n\t\tmemset(used, false, sizeof(used));\n\t\tused[v] |= true;\n\t\trep (i, G[v].size()){\n\t\t\tedge e = G[v][i];\n\t\t\tused[e.to] |= true;\n\t\t\tif (D[e.to] > D[v] + e.cost){\n\t\t\t\tD[e.to] = D[v] + e.cost;\n\t\t\t\tque.push(P(D[e.to], e.to));\n\t\t\t} // end if\n\t\t} // end rep\n\n\t\tfor (int i = 0; i < v; ++i){\n\t\t\tif (used[i]) continue;\n\t\t\tif (D[i] > D[v]){\n\t\t\t\tD[i] = D[v];\n\t\t\t\tque.push (P(D[i],i));\n\t\t\t} // end if\n\t\t} // end for\n\n\t} // end while\n}\n\n\nint main()\n{\n\trep (i, MAX_V) G[i].clear();\n\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint N,M,s,t; cin >> N >> M >> s >> t;\n\t--s, --t;\n\tvector<int> d(N, 0);\n\trep (i, N) cin >> d[i];\n\n\trep (i, M){\n\t\tint a, b; cin >> a >> b;  // a < b\n\t\t--a, --b;\n\t\tG[a].push_back(edge(b,d[b]));\n\t\tG[b].push_back(edge(a,0));\n\t} // end rep\n\n\tfor (int i = 0; i < N; ++i){\n\t\tfor (int j = i + 1; j < N; ++j){\n\t\t\tG[j].push_back(edge(i,0));\n\t\t} // end for\n\t} // end for\n\n\tdijkstra(s);\n\tcout << D[t] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint n,m,s,g,d[SIZE],a,b;\nvector<int> way[SIZE];\n\nint main(){\n  \n  scanf(\"%d%d%d%d\",&n,&m,&s,&g);\n\n  s--; g--;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d\",d+i);\n  }\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",&a,&b);\n    a--;\n    b--;\n    way[a].push_back(b);\n  }\n\n  queue<int> que;\n\n  int dp[SIZE];\n  \n  for(int i=0;i<n;i++){\n    dp[i] = INF;\n  }\n\n  dp[s] = 0;\n\n  priority_queue<pair<int,int> > pq;\n  \n  pq.push({0, s});\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<way[i].size();j++){\n      que.push(way[i][j]);\n    }\n\n    while(pq.size() && pq.top().second < i){\n      pq.pop();\n    }\n\n    while(pq.size() && que.size()){\n      auto p = que.front();\n      que.pop();\n\n      if(dp[p] > -pq.top().first + d[p]){\n        dp[p] = min(dp[p], -pq.top().first + d[p]);\n        pq.push({-dp[p], p});\n      }\n    }\n  }\n\n  int ans = INF;\n  \n  for(int i=g;i<n;i++){\n    ans = min(ans, dp[i]);\n  }\n\n  printf(\"%d\\n\",ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\ntemplate <class T>\nostream& operator<<(ostream& s, vector<T>& d) {\n    REP(i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \");\n    return s;\n}\nusing Int = long long;\n\nstruct DirectedGraph {\n    struct Edge {\n        Int to, cost;\n    };\n    vector<vector<Edge>> G;\n    Int V;\n    DirectedGraph(Int V_) : G(V_), V(V_) {}\n    void add_edge(Int u, Int v, Int cost) { G[u].push_back({v, cost}); }\n    vector<Int> dijkstra(Int s) {\n        vector<Int> d(V, 1e18);\n        d[s] = 0;\n        using ii = pair<Int, Int>;\n        priority_queue<ii, vector<ii>, greater<ii>> q;\n        q.push({0, s});\n        while (!q.empty()) {\n            ii p = q.top();\n            q.pop();\n            Int v = p.second;\n            if (d[v] < p.first) continue;\n            for (auto& e : G[v]) {\n                Int tmp = d[v] + e.cost;\n                if (d[e.to] <= tmp) continue;\n                d[e.to] = tmp;\n                q.push({tmp, e.to});\n            }\n        }\n        return d;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    Int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--, t--;\n    vector<Int> d(n);\n    REP(i, n) cin >> d[i];\n    DirectedGraph g(n);\n    REP(i, n - 1) { g.add_edge(i + 1, i, 0); }\n    REP(i, m) {\n        Int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g.add_edge(a, b, d[b]);\n    }\n    auto dist = g.dijkstra(s);\n    // cerr << dist << endl;\n    cout << dist[t] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define int long long\nusing namespace std;\ntypedef pair<int,int>P;\n\nint s,t,n,m,a[100009],d[100009];\npriority_queue<P,vector<P>,greater<P> >q;\nvector<P>v[100009];\n\nsigned main(){\n  r(i,100009)d[i]=1e15;\n  cin>>n>>m>>s>>t; s--; t--;\n  r(i,n)cin>>a[i];\n  r(i,n-1)v[i+1].push_back(P(i,0));\n  r(i,m){\n    int q,w;\n    cin>>q>>w; q--; w--;\n    v[q].push_back(P(w,a[w]));\n  }\n  q.push(P(0,s));\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    int now=p.second;\n    int cost=p.first;\n    if(d[now]<cost)continue;\n    r(i,v[now].size()){\n      int nex=v[now][i].first;\n      int ncos=cost+v[now][i].second;\n      if(d[nex]<=ncos)continue;\n      d[nex]=ncos;\n      q.push(P(ncos,nex));\n    }\n  }\n  cout<<d[t]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\n#define int ll\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\n// const int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __print__(std::ostream &os, const char *, const char *tail, const T &fst) {\n    os << fst << tail;\n}\ntemplate <typename Fst, typename... Rst>\nvoid __print__(std::ostream &os, const char *del, const char *tail, const Fst &fst,\n               const Rst &... rst) {\n    os << fst << del;\n    __print__(os, del, tail, rst...);\n}\n\n#ifdef LOCAL\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __print__(os, \", \", \"\\n\", __VA_ARGS__);           \\\n        std::cerr << os.str();                            \\\n    } while (0)\n#else\n#define dump(...)\n#endif\n\ntemplate <typename Fst, typename... Rst>\nvoid println(const Fst &fst, const Rst &... rst) {\n    __print__(std::cout, \"\\n\", \"\\n\", fst, rst...);\n}\ntemplate <typename Fst, typename... Rst>\nvoid print(const Fst &fst, const Rst &... rst) {\n    __print__(std::cout, \" \", \"\\n\", fst, rst...);\n}\n\ntemplate <typename iter>\nvoid println_(iter bgn, iter end) {\n    while (bgn != end) println(*bgn++);\n}\n\ntemplate <typename iter>\nvoid print_(iter bgn, iter end) {\n    while (bgn != end) {\n        std::cout << *bgn++;\n        std::cout << (bgn == end ? \"\\n\" : \" \");\n    }\n}\n\nint _ = (std::cout.precision(10), std::cout.setf(std::ios::fixed), std::cin.tie(0),\n         std::ios::sync_with_stdio(0), 0);\n\ntemplate <typename T>\nstd::vector<T> ndarray(int n, T v) {\n    return std::vector<T>(n, v);\n}\ntemplate <typename... Args>\nauto ndarray(int n, Args... args) {\n    auto val = ndarray(args...);\n    return std::vector<decltype(val)>(n, move(val));\n}\n\ntemplate <typename T>\nbool umax(T &a, const T &b) {\n    return a < b ? a = b, true : false;\n}\n\ntemplate <typename T>\nbool umin(T &a, const T &b) {\n    return a > b ? a = b, true : false;\n}\n\nusing namespace std;\n\ntemplate <typename monoid>\nstruct segment_tree {\n    using M = monoid;\n    using T = typename M::value_type;\n\n    std::size_t sz;\n    std::vector<T> x;\n\n    segment_tree(std::size_t n = 0) {\n        sz = 1;\n        while (sz < n) sz *= 2;\n        x.assign(sz * 2, M::id());\n        initialize();\n    }\n\n    template <typename iterator>\n    segment_tree(iterator first, iterator last) {\n        sz = 1;\n        std::size_t n = std::distance(first, last);\n        while (sz < n) sz *= 2;\n        x.assign(sz * 2, M::id());\n        std::copy(first, last, x.begin() + sz);\n        initialize();\n    }\n\n    void fill(const T& val) {\n        std::fill(x.begin() + sz, x.end(), val);\n        initialize();\n    }\n\n    void initialize() {\n        for (int i = (int)sz - 1; i >= 1; --i) {\n            x[i] = M::op(x[i * 2 + 0], x[i * 2 + 1]);\n        }\n    }\n\n    T accumulate(std::size_t l, std::size_t r) const {\n        T al = M::id(), ar = M::id();\n        for (l += sz, r += sz; l < r; l /= 2, r /= 2) {\n            if (l & 1) al = M::op(al, x[l++]);\n            if (r & 1) ar = M::op(x[--r], ar);\n        }\n        return M::op(al, ar);\n    }\n\n    void update(std::size_t i, const T &val) {\n        x[i += sz] = val;\n        while (i > 1) {\n            x[i / 2] = M::op(x[i], x[i ^ 1]);\n            i /= 2;\n        }\n    }\n\n    T operator[](std::size_t i) const { return x[sz + i]; }\n};\n\ntemplate <typename T>\nstruct min_monoid {\n    using value_type = T;\n    static constexpr T id() { return 1e18; }\n    static T op(const T &a, const T &b) { return std::min(a, b); }\n};\n\ntemplate <typename T>\nstruct max_monoid {\n    using value_type = T;\n    static constexpr value_type id() { return std::numeric_limits<value_type>::min(); }\n    static value_type op(const value_type &a, const value_type &b) { return std::max(a, b); }\n};\n\ntemplate <typename T>\nstruct sum_monoid {\n    using value_type = T;\n    static constexpr value_type id() { return 0; }\n    static value_type op(const value_type &a, const value_type &b) { return a + b; }\n};\n\ntemplate <typename value_type>\nusing rmq = segment_tree<min_monoid<value_type>>;\n\ntemplate <typename value_type>\nusing rsq = segment_tree<sum_monoid<value_type>>;\n\nusing pii = pair<int, int>;\nint N, M, s, t;\nint d[100010];\nvector<pii> es;\n\nsigned main() {\n    while (cin >> N >> M >> s >> t) {\n        --s, --t;\n        rep(i, N) cin >> d[i];\n        es.resize(M);\n        for (auto &e : es) {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            e = {a, b};\n        }\n        sort(all(es), [](pii a, pii b) {\n                return a.second < b.second;\n            });\n        int ans;\n        if (t < s) {\n            ans = 0;\n        } else {\n            rmq<ll> dp(N + 1);\n            rep(i, s + 1) {\n                dp.update(i, 0);\n            }\n            for (auto &e : es) {\n                int l, r;\n                tie(l, r) = e;\n                int x = dp.accumulate(0, r) + d[r];\n                dp.update(r, x);\n                // rep(i, N) {\n                //     cout << dp.accumulate(i, i + 1) << ' ';\n                // }\n                // cout << endl;\n            }\n            ans = dp.accumulate(t, N + 1);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 2834.cc: Dimension travel\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\nconst int MAX_E2 = 1 << 18; // = 262144\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\n\ntemplate <typename T, const int MAX_E2>\nstruct SegTreeMin {\n  int n, e2;\n  T inf, nodes[MAX_E2];\n  SegTreeMin() {}\n\n  void init(int _n, T _inf) {\n    n = _n; inf = _inf;\n    for (e2 = 1; e2 < n; e2 <<= 1);\n    fill(nodes, nodes + MAX_E2, inf);\n  }\n\n  T get(int i) { return nodes[e2 - 1 + i]; }\n\n  void set(int i, T v) {\n    int j = e2 - 1 + i;\n    nodes[j] = v;\n\n    while (j > 0) {\n      j = (j - 1) / 2;\n      nodes[j] = min(nodes[j * 2 + 1], nodes[j * 2 + 2]);\n    }\n  }\n\n  T min_range(int r0, int r1, int k, int i0, int i1) {\n    if (r1 <= i0 || i1 <= r0) return inf;\n    if (r0 <= i0 && i1 <= r1) return nodes[k];\n\n    int im = (i0 + i1) / 2;\n    T v0 = min_range(r0, r1, k * 2 + 1, i0, im);\n    T v1 = min_range(r0, r1, k * 2 + 2, im, i1);\n\n    return min(v0, v1);\n  }\n  T min_range(int r0, int r1) { return min_range(r0, r1, 0, 0, e2); }\n};\n\n/* global variables */\n\nint ds[MAX_N];\npii es[MAX_N];\nSegTreeMin<int,MAX_E2> stm;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, m, s, t;\n  scanf(\"%d%d%d%d\", &n, &m, &s, &t);\n  s--, t--;\n\n  for (int i = 0; i < n; i++) scanf(\"%d\", ds + i);\n\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    a--, b--;\n    es[i] = pii(a, b);\n  }\n  sort(es, es + m);\n\n  stm.init(n, INF);\n  stm.set(s, 0);\n\n  for (int i = 0; i < m; i++) {\n    int &a = es[i].first, &b = es[i].second;\n\n    int da = stm.min_range(a, n);\n    int db = stm.min_range(b, n);\n    int vd = da + ds[b];\n    if (db > vd) stm.set(b, vd);\n  }\n\n  printf(\"%d\\n\", stm.min_range(t, n));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> P;\n#define M 1000000007\n#define F first\n#define S second\n#define PB push_back\n#define INF 100000000000000000\nint n,m,s,t,p[100005],d[100005];\nvector<P>g[100005];\nint main(void){\n    cin>>n>>m>>s>>t;\n    s--;\n    t--;\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",p+i);\n        d[i]=100000001;\n        if(i!=n-1){\n            g[i+1].PB(P(i,0));\n        }\n    }\n    for(int i=0;i<m;i++){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        b--;\n        g[--a].PB(P(b,p[b]));\n    }\n    priority_queue<P,vector<P>,greater<P> >dik;\n    dik.push(P(0,s));\n    d[s]=0;\n    while(!dik.empty()){\n        int v=dik.top().S,c=dik.top().F;\n        dik.pop();\n        if(d[v]<c)continue;\n        for(int i=0;i<g[v].size();i++){\n            int u=g[v][i].F,q=g[v][i].S;\n            if(d[u]>c+q){\n                d[u]=c+q;\n                dik.push(P(c+q,u));\n            }\n        }\n    }\n    cout<<d[t]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pairInt;\n#define FOR(i, n) for (int i = 0; i < int(n); i++)\n#define FOR1(i, m, n) for (int i = int(m); i < int(n); i++)\n#define MAX(a, b) ((a) >= (b) ? (a) : (b))\n#define MIN(a, b) ((a) <= (b) ? (a) : (b))\n\nint N, M;\nvector<int> d;\nmultimap<int, int> path;\n\n\nint solve(int s, int t) {\n  vector<int> dist;\n  set<int> Q;\n  int ret = 0;\n  dist.resize(N + 1, INT_MAX);\n  dist[s] = 0;\n  FOR1(i, 1, N+1) Q.insert(i);\n\n  while (!Q.empty()) {\n    auto it = min_element(Q.begin(), Q.end(), [&](int a, int b) { return dist[a] < dist[b]; });\n    int u = *it;\n    Q.erase(it);\n\n    if (u == t) {\n      ret = dist[u];\n      break;\n    }\n\n    using iterator = decltype(path)::iterator;\n    pair<iterator, iterator> ret = path.equal_range(u);\n    for (auto it = ret.first; it != ret.second; it++) {\n      dist[it->second] = MIN(dist[it->second], dist[u] + d[it->second]);\n    }\n    FOR1(i, 1, u) {\n      dist[i] = MIN(dist[i], dist[u]);\n    }\n  }\n\n  return ret;\n}\n\nint main(int argc, char* argv[]) {\n  int s, t;\n\n  scanf(\"%d%d%d%d\", &N, &M, &s, &t);\n\n  d.resize(N + 1);\n\n  FOR1(i, 1, N + 1) scanf(\"%d\", &d[i]);\n  FOR(i, M) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    path.insert(make_pair(a, b));\n  }\n\n  printf(\"%d\\n\", solve(s, t));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n\nusing pi = pair<int,int>;\n\nconst int INF = 123456789;\n\nstruct edge{int to,cost;};\nconst int V = 100000;\nvector<edge> G[V];\n\nint main()\n{\n    int n,m,s,t;\n    cin >>n >>m >>s >>t;\n    --s;\n    --t;\n\n    vector<int> d(n);\n    rep(i,n) cin >>d[i];\n\n    rep(i,m)\n    {\n        int a,b;\n        cin >>a >>b;\n        --a;\n        --b;\n        G[a].push_back({b,d[b]});\n    }\n    // back edge\n    rep(i,n-1) G[i+1].push_back({i,0});\n\n    priority_queue<pi,vector<pi>,greater<pi>> pq;\n    vector<int> dist(n,INF);\n    pq.push({0,s});\n    dist[s] = 0;\n    while(!pq.empty())\n    {\n        pi p = pq.top();\n        pq.pop();\n        int v = p.second;\n        if(p.first>dist[v]) continue;\n        for(const auto &e:G[v])\n        {\n            if(dist[e.to]>dist[v]+e.cost)\n            {\n                dist[e.to] = dist[v]+e.cost;\n                pq.push({dist[e.to],e.to});\n            }\n        }\n    }\n\n    assert(dist[t]<INF);\n    cout << dist[t] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF 1<<30\nstruct edge {\n\tint u;\n\tint v;\n\tint cost;\n\tedge() {}\n\tedge(int u, int v, int cost) :u(u), v(v), cost(cost) {}\n};\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M, s, t; cin >> N >> M >> s >> t;\n\ts--; t--;\n\tvector<ll> d(N);\n\tfor (int i = 0; i < N;i++) cin >> d[i];\n\tvector<vector<edge>> G(N);\n\tfor (int i = 0; i < M;i++) {\n\t\tll a, b;cin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].push_back(edge(a, min(b, t), d[b]));\n\t}\n\tfor (int i = t; i > 0;i--) {\n\t\tG[i].push_back(edge(i, i - 1, 0));\n\t}\n\n\tvector<ll> dist(t + 1, INF);\n\tqueue<pair<int,int>> q;\n\tq.push({ s,s });\n\tdist[s] = 0;\n\tif (t < s) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tint n = p.first; int maxn = p.second;\n\t\tfor (auto e : G[n]) {\n\t\t\tif (e.v < maxn) {\n\t\t\t\tif (dist[e.v] > dist[e.u]) {\n\t\t\t\t\tdist[e.v] = dist[e.u];\n\t\t\t\t\tq.push({ e.v, maxn });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist[e.v] > dist[e.u] + e.cost) {\n\t\t\t\t\tdist[e.v] = dist[e.u] + e.cost;\n\t\t\t\t\tq.push({ e.v, max(maxn, e.v) });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; ++i)\nusing namespace std;\n\nusing ll = long long;\n\nconst int offset = 1 << 17;\nconst int inf =  1 << 29;\nint data[2 * offset];\n\n\nvoid updata(int k, int x) {\n\tk += offset - 1;\n\tdata[k] = x;\n\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdata[k] = min(data[2 * k + 1], data[2 * k + 2]);\n\t}\n}\n\nint query(int a, int b, int k, int l, int r) {\n\tif (b <= l or r <= a) return inf;\n\tif (a <= l and r <= b) return data[k];\n\tconst int m  = (l + r) / 2;\n\treturn min(query(a, b, 2 * k + 1, l, m), query(a, b, 2 * k + 2, m, r));\n}\n\nint cmin[offset];\nint d[offset];\n\nint main(void) {\n\tint n, m, s, t;\n\tcin >> n >> m >> s >> t;\n\ts--,t--;\n\n\trep(i,n) cin >> d[i];\n\trep(i,n) cmin[i] = i;\n\n\trep(i,m){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--,b--;\n\t\tcmin[b] = min(cmin[b],a);\n\t}\n\n\trep(i,s+1) updata(i,0);\n\n\tfor(int i = s + 1; i < n; ++i) updata(i,query(cmin[i],i,0,0,offset) + d[i]);\n\n\tcout << query(t,n,0,0,offset) << endl; \n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 40)\nusing namespace std;\ntypedef long long ll;\n\nstruct state {\n  ll v, d;\n\npublic:\n  bool operator<(const state &s) const { return d > s.d; };\n};\n\nll N, M, S, T, D[100000], A, B;\nvector<ll> E[100000];\n\nint main(void) {\n  cin >> N >> M >> S >> T; S--; T--;\n  REP(i, 0, N) cin >> D[i];\n  REP(i, 0, M) {\n    cin >> A >> B; A--; B--;\n    E[A].push_back(B);\n    E[B].push_back(A);\n  }\n\n  vector<ll> dp(N, INF);\n  priority_queue<state> q;\n  q.push((state) { S, 0 });\n\n  while(q.size()) {\n    state c = q.top();\n    q.pop();\n\n    // cout << c.v << \" \" << c.d << endl;\n\n    if(c.d >= dp[c.v]) continue;\n    dp[c.v] = c.d;\n\n    if(c.v == T) {\n      cout << c.d << endl;\n      return 0;\n    }\n\n    REP(i, 0, c.v) q.push((state) { i, c.d });\n    for(ll u : E[c.v]) {\n      if(u > c.v) q.push((state) { u, c.d + D[u] });\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntemplate<class V, int NV> struct LazySegTree { // [L,R)\n    vector<V> dat, lazy; LazySegTree() { dat.resize(NV * 2, def); lazy.resize(NV * 2, ldef); }\n    void update(int a, int b, V v, int k, int l, int r) { push(k, l, r); if (r <= a || b <= l) return;\n        if (a <= l && r <= b) { setLazy(k, v); push(k, l, r); } else {\n        update(a, b, v, k * 2 + 1, l, (l + r) / 2); update(a, b, v, k * 2 + 2, (l + r) / 2, r);\n        dat[k] = comp(dat[k * 2 + 1], dat[k * 2 + 2]);}}\n    V get(int a, int b, int k, int l, int r) { push(k, l, r); if (r <= a || b <= l) return def;\n        if (a <= l && r <= b) return dat[k]; auto x = get(a, b, k * 2 + 1, l, (l + r) / 2);\n        auto y = get(a, b, k * 2 + 2, (l + r) / 2, r); return comp(x, y);}\n    void update(int a, int b, V v) { update(a, b, v, 0, 0, NV); }\n    V get(int a, int b) { return get(a, b, 0, 0, NV); }\n    // ---- Template ---------------------------------------------------------------------------------\n    // ??????min??£??\\,??????min\n    #define INF INT_MAX/2\n    const V def = INF, ldef = INF;\n    V comp(V l, V r) { return min(l, r); }\n    void setLazy(int i, V v) { lazy[i] = min(lazy[i], v); }\n    void push(int k, int l, int r) {\n        if (lazy[k] != ldef) {\n            // modify------------------------------\n            dat[k] = min(dat[k], lazy[k]);\n            // ------------------------------------\n            if (r - l > 1) { setLazy(k * 2 + 1, lazy[k]); setLazy(k * 2 + 2, lazy[k]); }\n            lazy[k] = ldef;\n        }\n    }\n};\n\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint N, M, S, T, D[101010];\nvector<pair<int,int>> v;\nLazySegTree<int, 1 << 17> st;\n//--------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M >> S >> T;\n    S--; T--;\n    rep(i, 0, N) cin >> D[i];\n    rep(i, 0, M) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        v.push_back({a, b});\n    }\n    sort(v.begin(), v.end(), [&](pair<int, int> a, pair<int, int> b) {\n        if (a.second != b.second) return a.second < b.second;\n        else return a.first < a.first;\n    });\n\n    st.update(0, S + 1, 0);\n    fore(p, v) {\n        int L = p.first;\n        int R = p.second;\n        //printf(\"%d %d\\n\", L, R);\n        int c = st.get(0, L + 1) + D[R];\n        st.update(L, R + 1, c);\n    }\n\n    int ans = st.get(T, T + 1);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define fordebug int hoge;cin>>hoge;\n#define DEKAI 1000000007;\n#define INF (1<<28)\n#define int long long\n#define double long double\n#define floot10 cout<<fixed<<setprecision(10)\nint dp[100100];\n\nsigned main(){\n  int n,m,s,t;\n  cin>>n>>m>>s>>t;\n  int cost[100100];\n  lp(i,n){\n    dp[i+1]=DEKAI;\n    cin>>cost[i+1];\n  }\n  vector<int> go[100100];\n  lp(i,m){\n    int a,b;\n    cin>>a>>b;\n    for(int i=a;i<b;i++){\n      go[i].push_back(b);\n    }\n  }\n  dp[s]=0;\n  priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> > q;\n  q.push({0,s});\n  while(!q.empty()){\n    int now=q.top().second;\n    int nowc=q.top().first;\n    //cout<<now<<endl;\n    q.pop();\n    if(now>=t){\n      cout<<nowc<<endl;\n      return 0;\n    }/*\n    for(int i=now-1;i>0;i--){\n      int next=i;\n      int nexc=nowc+cost[next];\n      if(dp[next]<=nexc) continue;\n      dp[next]=nexc;\n      q.push({nexc,next});\n      }*/\n    lp(i,go[now].size()){\n      int next=go[now][i];\n      int nexc=nowc+cost[next];\n      if(dp[next]<=nexc) continue;\n      dp[next]=nexc;\n      q.push({nexc,next});\n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nint mn[100010];\n\ntemplate <typename monoid_trait> struct segment_tree {\n\tusing M = monoid_trait;\n\tusing T = typename M::value_type;\n\n\t// monoid m;\n\tstd::size_t sz;\n\tstd::vector<T> x;\n\n\tsegment_tree(std::size_t n = 0) {\n\t\tsz = 1;\n\t\twhile (sz < n)\n\t\t\tsz *= 2;\n\t\tx.assign(sz * 2, M::id());\n\t\tinitialize();\n\t}\n\n\ttemplate <typename iterator>\n\tsegment_tree(iterator first, iterator last) {\n\t\tsz = 1;\n\t\tstd::size_t n = std::distance(first, last);\n\t\twhile (sz < n)\n\t\t\tsz *= 2;\n\t\tx.assign(sz * 2, M::id());\n\t\tstd::copy(first, last, x.begin() + sz);\n\t\tinitialize();\n\t}\n\n\tvoid initialize() {\n\t\tfor (int i = (int)sz - 1; i >= 1; --i) {\n\t\t\tx[i] = M::op(x[i * 2 + 0], x[i * 2 + 1]);\n\t\t}\n\t}\n\n\tT query(std::size_t l, std::size_t r) const {\n\t\tT res = M::id();\n\t\tfor (l += sz, r += sz; l < r; l >>= 1, r >>= 1) {\n\t\t\tif (l & 1)\n\t\t\t\tres = M::op(res, x[l++]);\n\t\t\tif (r & 1)\n\t\t\t\tres = M::op(res, x[--r]);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid update(std::size_t i, const T &val) {\n\t\tx[i += sz] = val;\n\t\twhile (i > 1) {\n\t\t\tx[i / 2] = M::op(x[i], x[i ^ 1]);\n\t\t\ti /= 2;\n\t\t}\n\t}\n\n\tT operator[](std::size_t i) const { return x[sz + i]; }\n};\n\ntemplate <typename T> struct zero_sum_monoid {\n\tusing value_type = T;\n\tstatic constexpr T id() { return 0; }\n\tstatic T op(const T &a, const T &b) { return a + b; }\n};\n\ntemplate <typename T> struct inf_min_monoid {\n\tusing value_type = T;\n\tstatic constexpr T id() { return std::numeric_limits<T>::max(); }\n\tstatic T op(const T &a, const T &b) { return std::min(a, b); }\n};\n\ntemplate <typename T> using rmq = segment_tree<inf_min_monoid<T>>;\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M, S, T;\n\t\n\tcin >> N >> M >> S >> T;\n\tsegment_tree<inf_min_monoid<int>> st(N);\n\t//st.update(N - 1, 0);\n\t//cerr << st.query(0, N) << endl;\n\tS--;\n\tT--;\n\tvector<int> D(N);\n\tint res = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tmn[i] = -1;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> D[i];\n\t}\n\tint a, b;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tif ((mn[b] == -1) || (mn[b] > a)) {\n\t\t\tmn[b] = a;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i <= S) {\n\t\t\tst.update(i, 0);\n\t\t}\n\t\telse {\n\t\t\tif (mn[i] != -1) {\n\t\t\t\tint t;\n\t\t\t\tt = st.query(mn[i], i + 1);\n\t\t\t\tst.update(i, t + D[i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = S + 1; i < N; i++) {\n\t\tif (i <= S) {\n\t\t\tst.update(i, 0);\n\t\t}\n\t\telse {\n\t\t\tif (mn[i] != -1) {\n\t\t\t\tint t;\n\t\t\t\tt = st.query(mn[i], N);\n\t\t\t\tst.update(i, t + D[i]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << st.query(T, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF ((long long)1e18)\n#define MOD ((int)1e9+7)\n#define endl \"\\n\"\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint N, K, ans = 0;\n\tvector<int> A, used, con;\n\tqueue<pair<int,int>> Q;\n\t\n\tcin>>N>>K;\n\t\n\tA.resize(N+1);\n\tused.resize(N+1);\n\tcon.resize(N+1);\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tcin>>A[i];\n\t\t\n\t\tcon[A[i]]++;\n\t\t\n\t\tif(!A[i]){\n\t\t\tused[i] = true;\n\t\t\tans++;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(!con[i]){\n\t\t\tQ.push(make_pair(i,K));\n\t\t\t// cout<<i<<\" Q \"<<endl;\n\t\t}\n\t}\n\t// cout<<\"ans -> \"<<ans<<endl;\n\t\n\twhile(!Q.empty()){\n\t\tpair<int,int> t = Q.front(); Q.pop();\n\t\t\n\t\tif(used[t.first] || t.second == 0) continue;\n\t\t\n\t\tused[t.first] = true;\n\t\t\n\t\t// cout<<t.first<<endl;\n\t\t\n\t\tans++;\n\t\tQ.push(make_pair(A[t.first],t.second-1));\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<28\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\t// first ??????????????¢ second ???????????????\n\nconst int MAX_V = (int)1e5;\n\nclass edge{\npublic:\n\tint to;\n\tint cost;\n\tedge(){}\n\tedge(int _to, int _cost):to(_to),cost(_cost){}\n};\n\nint D[MAX_V];\t\t\t\t\t// ?????????:s ????????????????????¢\n\nvector<edge> G[MAX_V];\n\nbool used[MAX_V];\n\n// ?????????:s ????????????????????¢????±???????\nvoid dijkstra (int s)\n{\n\t// greater<P> ????????????????????¨??§first????°???????????????????????????????????????????\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill (D,  D + MAX_V, INF);\n\tD[s] = 0;\n\tque.push (P (0, s));\n\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (D[v] < p.first) continue;\n\t\t\n\t\tmemset(used, false, sizeof(used));\n\t\tused[v] |= true;\n\t\trep (i, G[v].size()){\n\t\t\tedge e = G[v][i];\n\t\t\tused[e.to] |= true;\n\t\t\tif (D[e.to] > D[v] + e.cost){\n\t\t\t\tD[e.to] = D[v] + e.cost;\n\t\t\t\tque.push(P(D[e.to], e.to));\n\t\t\t} // end if\n\t\t} // end rep\n\n\t\tfor (int i = 0; i < v; ++i){\n\t\t\tif (used[i]) continue;\n\t\t\tif (D[i] > D[v]){\n\t\t\t\tD[i] = D[v];\n\t\t\t\tque.push (P(D[i],i));\n\t\t\t} // end if\n\t\t} // end for\n\n\t} // end while\n}\n\n\nint main()\n{\n\trep (i, MAX_V) G[i].clear();\n\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint N,M,s,t; cin >> N >> M >> s >> t;\n\t--s, --t;\n\tvector<int> d(N, 0);\n\trep (i, N) cin >> d[i];\n\n\trep (i, M){\n\t\tint a, b; cin >> a >> b;  // a < b\n\t\t--a, --b;\n\t\tG[a].push_back(edge(b,d[b]));\n\t\tG[b].push_back(edge(a,0));\n\t} // end rep\n\n\tdijkstra(s);\n\tcout << D[t] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<28\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\t// first ??????????????¢ second ???????????????\n\nconst int MAX_V = (int)1e5;\n\nclass edge{\npublic:\n\tint to;\n\tint cost;\n\tedge(){}\n\tedge(int _to, int _cost):to(_to),cost(_cost){}\n};\n\nint D[MAX_V];\t\t\t\t\t// ?????????:s ????????????????????¢\n\nvector<edge> G[MAX_V];\n\nbool used[MAX_V];\n\n// ?????????:s ????????????????????¢????±???????\nvoid dijkstra (int s)\n{\n\t// greater<P> ????????????????????¨??§first????°???????????????????????????????????????????\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill (D,  D + MAX_V, INF);\n\tD[s] = 0;\n\tque.push (P (0, s));\n\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (D[v] < p.first) continue;\n\t\n\t\tmemset(used, false, sizeof(used));\n\n\t\tfor (int i = 0; i < v; ++i){\n\t\t\tif (used[i]) continue;\n\t\t\tif (D[i] > D[v]){\n\t\t\t\tD[i] = D[v];\n\t\t\t\tque.push (P(D[i],i));\n\t\t\t} // end if\n\t\t} // end for\n\n\t\trep (i, G[v].size()){\n\t\t\tedge e = G[v][i];\n\t\t\tused[e.to] |= true;\n\t\t\tif (D[e.to] > D[v] + e.cost){\n\t\t\t\tD[e.to] = D[v] + e.cost;\n\t\t\t\tque.push(P(D[e.to], e.to));\n\t\t\t} // end if\n\t\t} // end rep\n\n\n\t} // end while\n}\n\n\nint main()\n{\n\trep (i, MAX_V) G[i].clear();\n\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint N,M,s,t; cin >> N >> M >> s >> t;\n\t--s, --t;\n\tvector<int> d(N, 0);\n\trep (i, N) cin >> d[i];\n\n\trep (i, M){\n\t\tint a, b; cin >> a >> b;  // a < b\n\t\t--a, --b;\n\t\tG[a].push_back(edge(b,d[b]));\n\t\tG[b].push_back(edge(a,0));\n\t} // end rep\n\n\tdijkstra(s);\n\tcout << D[t] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<climits>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nint main(){\n    int n, m, s, t;\n    cin >> n >> m >> s >> t;\n    s--, t--;\n    if(s > t){\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<int> d(n);\n    for(int i = 0; i < n; i++)  cin >> d[i];\n    vector<int> v[n];\n    for(int i = 0; i < m; i++){\n        int a, b;\n        cin >> a >> b;\n        v[--a].push_back(--b);\n    }\n    vector<int> dp(n, INF);\n    priority_queue<pair<int,int>> pq;\n    for(int i = 0; i <= s; i++){\n        for(int next : v[i])    pq.push({-d[next],next});\n    }\n    int to = s;\n    while(!pq.empty()){\n        auto p = pq.top();  pq.pop();\n        int cost = -p.first, pos = p.second;\n        if(cost >= dp[pos] || pos <= to) continue;\n        dp[pos] = cost;\n        if(pos >= t){\n            cout << dp[pos] << endl;\n            return 0;\n        }\n        while(to < pos){\n            to++;\n            for(int next : v[to]){\n                int ncost = cost + d[next];\n                if(dp[next] > ncost) pq.push({-ncost, next});\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REP2(i,m,n) for (int i=m;i<(n);i++)\ntypedef long long ll;\n\nint N, M, s, t;\nint D[101010];\nvector<int> edges[101010];\nint dist[101010];\n\n\nint main() {\n    cin >> N >> M >> s >> t;\n    s--, t--;\n\n    REP(i, N) cin >> D[i];\n    REP(i, s+1) D[i] = 0;\n\n    REP(i, M) {\n        int a, b; cin >> a >> b;\n        edges[a - 1].push_back(b - 1);\n    }\n\n    REP(i, N) dist[i] = 1 << 29;\n\n    REP(i, N) {\n        if (i <= s) dist[i] = 0;\n        for (auto m: edges[i])\n            dist[m] = min(dist[m], dist[i] + D[m]);\n    }\n\n    int ans = 1 << 29;\n    REP2(i, t, N) ans = min(ans, dist[i]);\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n//\n//using Graph = vector<vector<int>>;\n//\n//int dfs(const Graph&g, const int now, vector<int>&ch_cnts) {\n//  ch_cnts[now]++;\n//  for (auto&& e : g[now]) {\n//      ch_cnts[now] += dfs(g, e, ch_cnts);\n//  }\n//  return ch_cnts[now];\n//}\n//\n//struct HL_Edge {\n//  int from;\n//  int to;\n//  bool heavy;\n//};\n//\n//void dfs2(const Graph&g, vector<vector<HL_Edge>>&hl_tree, const int now, const vector<int>&ch_cnts) {\n//\n//  int max_ch_id = 1;\n//  {\n//      int max_ch_num = -1;\n//      for (auto&&e : g[now]) {\n//          if (max_ch_num < ch_cnts[e]) {\n//              max_ch_num = ch_cnts[e];\n//              max_ch_id = e;\n//          }\n//      }\n//  }\n//  for (auto e : g[now]) {\n//      bool heavy = (e == max_ch_id);\n//\n//      hl_tree[now].push_back(HL_Edge{ now,e,heavy });\n//  }\n//  return;\n//}\n//\n//void HL(const vector<vector<int>>&ro_tree) {\n//  vector<int>ch_cnts(ro_tree.size());\n//\n//  dfs(ro_tree, 0, ch_cnts);\n//\n//  vector<vector<HL_Edge>>hl_tree(ro_tree.size());\n//\n//  dfs2(ro_tree, hl_tree, 0, ch_cnts);\n//}\n//\n//namespace FastFourierTransform\n//{\n//  using C = complex< double >;\n//\n//  void DiscreteFourierTransform(vector< C > &F, bool rev)\n//  {\n//      const int N = (int)F.size();\n//      const double PI = (rev ? -1 : 1) * acos(-1);\n//      for (int i = 0, j = 1; j + 1 < N; j++) {\n//          for (int k = N >> 1; k > (i ^= k); k >>= 1);\n//          if (i > j) swap(F[i], F[j]);\n//      }\n//      C w, s, t;\n//      for (int i = 1; i < N; i <<= 1) {\n//          for (int k = 0; k < i; k++) {\n//              w = polar(1.0, PI / i * k);\n//              for (int j = 0; j < N; j += i * 2) {\n//                  s = F[j + k];\n//                  t = C(F[j + k + i].real() * w.real() - F[j + k + i].imag() * w.imag(),\n//                      F[j + k + i].real() * w.imag() + F[j + k + i].imag() * w.real());\n//                  F[j + k] = s + t, F[j + k + i] = s - t;\n//              }\n//          }\n//      }\n//      if (rev) for (int i = 0; i < N; i++) F[i] /= N;\n//  }\n//\n//  vector< int> Multiply(const vector<int > &A, const vector<int > &B)\n//  {\n//      int sz = 1;\n//      while (sz <= A.size() + B.size()) sz <<= 1;\n//      vector< C > F(sz), G(sz);\n//      for (int i = 0; i < A.size(); i++) F[i] = A[i];\n//      for (int i = 0; i < B.size(); i++) G[i] = B[i];\n//      DiscreteFourierTransform(F, false);\n//      DiscreteFourierTransform(G, false);\n//      for (int i = 0; i < sz; i++) F[i] *= G[i];\n//      DiscreteFourierTransform(F, true);\n//      vector< int > X(A.size() + B.size() - 1);\n//      for (int i = 0; i < A.size() + B.size() - 1; i++) X[i] = F[i].real() + 0.5;\n//      return (X);\n//  }\n//};\n\n#define Seg_Max_N (1<<19) \n\nusing Value = int;\nconst Value ini = 1e9;\nstruct segtree {\n\tint N;\n\tvector<Value>dat;\n\n\tsegtree() {}\n\tsegtree(int n) :dat(2 * Seg_Max_N) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\t\tdat[i] = ini;\n\t\t}\n\t}\n\tValue connect(const Value&l, const Value&r) {\n\t\treturn min(l,r);\n\t}\n\t// update k th element\n\tvoid update(int k, Value a) {\n\t\tk += N - 1;\n\t\tdat[k] = a;\n\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tconst Value al(dat[k * 2 + 1]);\n\t\t\tconst Value ar(dat[k * 2 + 2]);\n\t\t\tdat[k] = connect(al, ar);\n\t\t}\n\t}\n\t// min [a, b)\n\tValue  query(int a, int b) { return query(a, b, 0, 0, N); }\n\tValue  query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return ini;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tconst int m = (l + r) / 2;\n\t\tconst Value al(query(a, b, k * 2 + 1, l, m));\n\t\tconst Value ar(query(a, b, k * 2 + 2, m, r));\n\t\treturn connect(al, ar);\n\t}\n};\n\n\n\nint main() {\n\tint N,M,S,T;cin>>N>>M>>S>>T;\n\tS--;\n\tT--;\n\tvector<int>ds(N);\n\tfor(int i=0;i<N;++i)cin>>ds[i];\n\tvector<pair<int,int>>ps;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tps.emplace_back(a,b);\n\t}\n\tsort(ps.begin(),ps.end());\n\n\tsegtree seg(N);\n\tseg.update(S,0);\n\tfor (auto p : ps) {\n\t\tint from=p.first;\n\t\tint to=p.second;\n\n\t\tint x=seg.query(0,from+1);\n\t\tseg.update(to,x+ds[to]);\n\t}\n\n\tint ans=seg.query(T,N);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nll d[100010];\nll n,m,s,t;\n\nclass Dijkstra {\npublic:\n    struct edge { long long v, dist; };\n\n    struct state {\n        long long v, cost;\n        bool operator>(const state s) const { return cost > s.cost; }\n    };\n\n    const long long INF = (1LL << 60);\n    long long N;\n    vector< vector<edge> > E;\n\n    Dijkstra(long long n): N(n), E(n) {}\n\n    //有効グラフの時はこっち。u→vに距離dで結ぶ\n    void add_directed_edge(long long u, long long v, long long d) {\n        E[u].push_back((edge) { v, d });\n    }\n\n    //無向グラフの時はこっち。uとvを双方向に距離dで結ぶ\n    void add_undirected_edge(long long u, long long v, long long d) {\n        E[u].push_back((edge) { v, d });\n        E[v].push_back((edge) { u, d });\n    }\n\n    //Sを始点として、他の頂点への最短経路を探す\n    vector<long long> shortest_path(long long S) {\n        vector<long long> dp(E.size(), INF);\n        priority_queue<state, vector<state>, greater<state> > q;\n        q.push((state) { S, 0 });\n        while(!q.empty()) {\n            long long v = q.top().v, cost = q.top().cost;\n            q.pop();\n            if(dp[v] <= cost) continue;\n            dp[v] = cost;\n            for(int i=0;i < E[v].size() ; i++) {\n            long long nv = E[v][i].v, ncost = cost + E[v][i].dist;\n            if(dp[nv] > ncost) q.push((state) { nv, ncost });\n            }\n        }\n        return dp;\n    }\n};\n\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n \n    cin>>n>>m>>s>>t;\n    for(int i=0;i<n;i++){\n        cin>>d[i];\n    }\n    if(s>t){\n        cout << 0 << endl;\n        return 0;\n    }\n    Dijkstra di(n);\n    s--,t--;\n    vector<array<ll,2>> x;\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        int g=b;\n        if(a<=s) a=s;\n        if(b>=t) b=t;\n        if(b==t) x.push_back({a,d[g]});\n        di.add_directed_edge(a,b,d[g]);\n    }\n    ll ans = 1e15;\n    vector<ll> v = di.shortest_path(s);\n    vector<ll> y(n,1e15);\n    ll mi = 1e18;\n    sort(x.begin(),x.end());\n    for(int i=1;i<x.size();i++){\n        mi = min(mi,x[i-1][1]);\n        for(int j=x[i-1][0];j<=x[i][0];j++){\n            y[j] = mi;\n        }\n    }\n    mi = min(mi,x[x.size()-1][1]);\n    for(int j=x[x.size()-1][0];j<=t;j++){\n        y[j] = mi;\n    }\n    y[t] = 0;\n    for(int i=s;i<=t;i++){\n        ans = min(ans, v[i] + y[i]);\n        //cerr << v[i] << \" \" << y[i] << endl;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nvector<pint> vp[100001];\nint d[100001];\nint INF=1000100010;\nint n;\nint dijkstra(int st){\n    priority_queue<pint,vector<pint>,greater<pint> > pq;\n    rep(i,n) d[i]=INF;\n    d[st]=0;\n    pq.push(make_pair(0,st));\n    while(!pq.empty()){\n        pint pi=pq.top();pq.pop();\n        int t=pi.second;\n        if(d[t]<pi.first) continue;\n        for(auto it:vp[t]){\n            if(d[it.second]>d[t]+it.first){\n                d[it.second]=d[t]+it.first;\n                pq.push(make_pair(d[it.second],it.second));\n            }\n        }\n    }\n}\nint dmg[100001];\nint main(){\n    int m,s,t,a,b;\n    cin>>n>>m>>s>>t;\n    --s,--t;\n    rep(i,n) cin>>dmg[i];\n    rep(i,m){\n        cin>>a>>b;\n        --a,--b;\n        vp[a].pb(dmg[b],b);\n    }\n    rep(i,n-1){\n        vp[i+1].pb(0,i);\n    }\n    dijkstra(s);\n    cout<<d[t]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pairInt;\n#define FOR(i, n) for (int i = 0; i < int(n); i++)\n#define FOR1(i, m, n) for (int i = int(m); i < int(n); i++)\n#define MAX(a, b) ((a) >= (b) ? (a) : (b))\n#define MIN(a, b) ((a) <= (b) ? (a) : (b))\n\nint N, M;\nvector<int> d;\nmultimap<int, int> ab;\n\nint solve(int s, int t, int lower, int limit) {\n  int ans = limit;\n\n  if (t <= s) {\n    return 0;\n  }\n  \n  for (auto it = ab.lower_bound(lower); it != ab.end() && it->first <= s;\n       it++) {\n    if (it->second > s && d[it->second] < ans) {\n      int temp = solve(it->second, t, s + 1, ans - d[it->second]);\n      if (temp != -1) {\n        ans = MIN(ans, temp + d[it->second]);\n      }\n    }\n  }\n\n  return ans == limit ? -1 : ans;\n}\n\nint main(int argc, char *argv[]) {\n  int s, t;\n\n  scanf(\"%d%d%d%d\", &N, &M, &s, &t);\n\n  d.resize(N + 1);\n\n  FOR1(i, 1, N + 1) scanf(\"%d\", &d[i]);\n  FOR(i, M) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    ab.insert(make_pair(a, b));\n  }\n\n  printf(\"%d\\n\", solve(s, t, 0, INT_MAX));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main(){\n\tint n,m,s,t,d,a,b;\n\tcin >> n >> m >> s >> t;\n\tvector<int> dlst, table;\n\ttable.assign(n,0);\n\n\tfor(unsigned int i = 0; i < n; i++){\n\t\tcin >> d;\n\t\tdlst.push_back(d);\n\t}\n\n\tfor(unsigned int i = 0; i < m; i++){\n\t\tcin >> a >> b;\n\t\tif(a <= s && b > s){\n\t\t\tfor(unsigned int j = s-1; j < b; j++){\n\t\t\t\tif(table[j] == 0)\n\t\t\t\t\ttable[j] = dlst[b-1];\n\t\t\t\telse if(table[j] != 0 && table[j] > dlst[b-1])\n\t\t\t\t\ttable[j] = dlst[b-1];\n\t\t\t}\n\t\t}else if(a > s){\n\t\t\tfor(unsigned int j = a-1; j < b; j++){\n\t\t\t\tif(table[j] == 0)\n\t\t\t\t\ttable[j] = dlst[a-2]+dlst[b-1];\n\t\t\t\telse if(table[j] != 0 && table[j] > (dlst[a-2] + dlst[b-1]))\n\t\t\t\t\ttable[j] = dlst[a-2]+dlst[b-1];\n\t\t\t}\n\t\t}\n\t}\n\tcout << table[t-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define LINF 1LL<<60\nstruct edge {\n\tll u;\n\tll v;\n\tll cost;\n\tedge() {}\n\tedge(ll u, ll v, ll cost) :u(u), v(v), cost(cost) {}\n};\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M, s, t; cin >> N >> M >> s >> t;\n\ts--; t--;\n\tvector<ll> d(N);\n\tfor (int i = 0; i < N;i++) cin >> d[i];\n\tvector<vector<edge>> G(N);\n\tfor (int i = 0; i < M;i++) {\n\t\tll a, b;cin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].push_back(edge(a, min(b, t), d[b]));\n\t}\n\tfor (int i = t; i >= 1;i--) {\n\t\tG[i].push_back(edge(i, i - 1, 0));\n\t}\n\n\tvector<ll> dist(N, LINF);\n\tqueue<pair<ll,ll>> q;\n\tq.push({ s,s });\n\tdist[s] = 0;\n\tif (t < s) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tll n = p.first; ll maxn = p.second;\n\t\tfor (auto e : G[n]) {\n\t\t\tif (e.v < maxn) {\n\t\t\t\tif (dist[e.v] > dist[e.u]) {\n\t\t\t\t\tdist[e.v] = dist[e.u];\n\t\t\t\t\tq.push({ e.v, maxn });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist[e.v] > dist[e.u] + e.cost) {\n\t\t\t\t\tdist[e.v] = dist[e.u] + e.cost;\n\t\t\t\t\tq.push({ e.v, max(maxn, e.v) });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\n#define int ll\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\n// const int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __print__(std::ostream &os, const char *, const char *tail, const T &fst) {\n    os << fst << tail;\n}\ntemplate <typename Fst, typename... Rst>\nvoid __print__(std::ostream &os, const char *del, const char *tail, const Fst &fst,\n               const Rst &... rst) {\n    os << fst << del;\n    __print__(os, del, tail, rst...);\n}\n\n#ifdef LOCAL\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __print__(os, \", \", \"\\n\", __VA_ARGS__);           \\\n        std::cerr << os.str();                            \\\n    } while (0)\n#else\n#define dump(...)\n#endif\n\ntemplate <typename Fst, typename... Rst>\nvoid println(const Fst &fst, const Rst &... rst) {\n    __print__(std::cout, \"\\n\", \"\\n\", fst, rst...);\n}\ntemplate <typename Fst, typename... Rst>\nvoid print(const Fst &fst, const Rst &... rst) {\n    __print__(std::cout, \" \", \"\\n\", fst, rst...);\n}\n\ntemplate <typename iter>\nvoid println_(iter bgn, iter end) {\n    while (bgn != end) println(*bgn++);\n}\n\ntemplate <typename iter>\nvoid print_(iter bgn, iter end) {\n    while (bgn != end) {\n        std::cout << *bgn++;\n        std::cout << (bgn == end ? \"\\n\" : \" \");\n    }\n}\n\nint _ = (std::cout.precision(10), std::cout.setf(std::ios::fixed), std::cin.tie(0),\n         std::ios::sync_with_stdio(0), 0);\n\ntemplate <typename T>\nstd::vector<T> ndarray(int n, T v) {\n    return std::vector<T>(n, v);\n}\ntemplate <typename... Args>\nauto ndarray(int n, Args... args) {\n    auto val = ndarray(args...);\n    return std::vector<decltype(val)>(n, move(val));\n}\n\ntemplate <typename T>\nbool umax(T &a, const T &b) {\n    return a < b ? a = b, true : false;\n}\n\ntemplate <typename T>\nbool umin(T &a, const T &b) {\n    return a > b ? a = b, true : false;\n}\n\nusing namespace std;\n\ntemplate <typename monoid>\nstruct segment_tree {\n    using M = monoid;\n    using T = typename M::value_type;\n\n    std::size_t sz;\n    std::vector<T> x;\n\n    segment_tree(std::size_t n = 0) {\n        sz = 1;\n        while (sz < n) sz *= 2;\n        x.assign(sz * 2, M::id());\n        initialize();\n    }\n\n    template <typename iterator>\n    segment_tree(iterator first, iterator last) {\n        sz = 1;\n        std::size_t n = std::distance(first, last);\n        while (sz < n) sz *= 2;\n        x.assign(sz * 2, M::id());\n        std::copy(first, last, x.begin() + sz);\n        initialize();\n    }\n\n    void fill(const T& val) {\n        std::fill(x.begin() + sz, x.end(), val);\n        initialize();\n    }\n\n    void initialize() {\n        for (int i = (int)sz - 1; i >= 1; --i) {\n            x[i] = M::op(x[i * 2 + 0], x[i * 2 + 1]);\n        }\n    }\n\n    T accumulate(std::size_t l, std::size_t r) const {\n        T al = M::id(), ar = M::id();\n        for (l += sz, r += sz; l < r; l /= 2, r /= 2) {\n            if (l & 1) al = M::op(al, x[l++]);\n            if (r & 1) ar = M::op(x[--r], ar);\n        }\n        return M::op(al, ar);\n    }\n\n    void update(std::size_t i, const T &val) {\n        x[i += sz] = val;\n        while (i > 1) {\n            x[i / 2] = M::op(x[i], x[i ^ 1]);\n            i /= 2;\n        }\n    }\n\n    T operator[](std::size_t i) const { return x[sz + i]; }\n};\n\ntemplate <typename T>\nstruct min_monoid {\n    using value_type = T;\n    static constexpr T id() { return 1e18; }\n    static T op(const T &a, const T &b) { return std::min(a, b); }\n};\n\ntemplate <typename T>\nstruct max_monoid {\n    using value_type = T;\n    static constexpr value_type id() { return std::numeric_limits<value_type>::min(); }\n    static value_type op(const value_type &a, const value_type &b) { return std::max(a, b); }\n};\n\ntemplate <typename T>\nstruct sum_monoid {\n    using value_type = T;\n    static constexpr value_type id() { return 0; }\n    static value_type op(const value_type &a, const value_type &b) { return a + b; }\n};\n\ntemplate <typename value_type>\nusing rmq = segment_tree<min_monoid<value_type>>;\n\ntemplate <typename value_type>\nusing rsq = segment_tree<sum_monoid<value_type>>;\n\nusing pii = pair<int, int>;\nint N, M, s, t;\nint d[100010];\nvector<pii> es;\n\nsigned main() {\n    while (cin >> N >> M >> s >> t && N) {\n        --s, --t;\n        rep(i, N) cin >> d[i];\n        es.resize(M);\n        for (auto &e : es) {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            e = {a, b};\n        }\n\n        sort(all(es), [](pii a, pii b) {\n                return a.second < b.second;\n            });\n\n        rmq<ll> dp(N);\n        rep(i, s + 1) {\n            dp.update(i, 0);\n        }\n        for (auto &e : es) {\n            int l, r;\n            tie(l, r) = e;\n            int x = dp.accumulate(l, r) + d[r];\n            if (dp.accumulate(r, r + 1) > x) {\n                dp.update(r, x);\n            }\n            // rep(i, N) {\n            //     cout << dp.accumulate(i, i + 1) << ' ';\n            // }\n            // cout << endl;\n        }\n        int ans = dp.accumulate(t, N);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pairInt;\n#define FOR(i, n) for (int i = 0; i < int(n); i++)\n#define FOR1(i, m, n) for (int i = int(m); i < int(n); i++)\n#define MAX(a, b) ((a) >= (b) ? (a) : (b))\n#define MIN(a, b) ((a) <= (b) ? (a) : (b))\n\nint N, M;\nvector<int> d;\nmultimap<int, int> path;\n\n\nint solve(int s, int t) {\n  vector<int> dist;\n  set<int> Q;\n  int ret = 0;\n  dist.resize(N + 1, INT_MAX);\n  dist[s] = 0;\n  FOR1(i, 1, N+1) Q.insert(i);\n\n  int temp = 0;\n  while (!Q.empty()) {\n    auto it = min_element(Q.begin(), Q.end(), [&](int a, int b) { return dist[a] < dist[b]; });\n    int u = *it;\n    Q.erase(it);\n\n    if (u == t) {\n      ret = dist[u];\n      break;\n    }\n\n    using iterator = decltype(path)::iterator;\n    pair<iterator, iterator> ret = path.equal_range(u);\n    for (auto it = ret.first; it != ret.second; it++) {\n      dist[it->second] = MIN(dist[it->second], dist[u] + d[it->second]);\n    }\n    for (int i = u - 1; dist[i] > dist[u] && i > 0; i--) {\n      dist[i] = dist[u];\n    }\n  }\n\n  return ret;\n}\n\nint main(int argc, char* argv[]) {\n  int s, t;\n\n  scanf(\"%d%d%d%d\", &N, &M, &s, &t);\n\n  d.resize(N + 1);\n\n  FOR1(i, 1, N + 1) scanf(\"%d\", &d[i]);\n  FOR(i, M) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    path.insert(make_pair(a, b));\n  }\n\n  printf(\"%d\\n\", solve(s, t));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntemplate<class V, int NV> struct LazySegTree { // [L,R)\n    vector<V> dat, lazy; LazySegTree() { dat.resize(NV * 2, def); lazy.resize(NV * 2, ldef); }\n    void update(int a, int b, V v, int k, int l, int r) { push(k, l, r); if (r <= a || b <= l) return;\n        if (a <= l && r <= b) { setLazy(k, v); push(k, l, r); } else {\n        update(a, b, v, k * 2 + 1, l, (l + r) / 2); update(a, b, v, k * 2 + 2, (l + r) / 2, r);\n        dat[k] = comp(dat[k * 2 + 1], dat[k * 2 + 2]);}}\n    V get(int a, int b, int k, int l, int r) { push(k, l, r); if (r <= a || b <= l) return def;\n        if (a <= l && r <= b) return dat[k]; auto x = get(a, b, k * 2 + 1, l, (l + r) / 2);\n        auto y = get(a, b, k * 2 + 2, (l + r) / 2, r); return comp(x, y);}\n    void update(int a, int b, V v) { update(a, b, v, 0, 0, NV); }\n    V get(int a, int b) { return get(a, b, 0, 0, NV); }\n    // ---- Template ---------------------------------------------------------------------------------\n    // ??????min??£??\\,??????min\n    #define INF INT_MAX/2\n    const V def = INF, ldef = INF;\n    V comp(V l, V r) { return min(l, r); }\n    void setLazy(int i, V v) { lazy[i] = min(lazy[i], v); }\n    void push(int k, int l, int r) {\n        if (lazy[k] != ldef) {\n            // modify------------------------------\n            dat[k] = min(dat[k], lazy[k]);\n            // ------------------------------------\n            if (r - l > 1) { setLazy(k * 2 + 1, lazy[k]); setLazy(k * 2 + 2, lazy[k]); }\n            lazy[k] = ldef;\n        }\n    }\n};\n\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint N, M, S, T, D[101010];\nvector<pair<int,int>> v;\nLazySegTree<int, 1 << 17> st;\n//--------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M >> S >> T;\n    S--; T--;\n    rep(i, 0, N) cin >> D[i];\n    rep(i, 0, M) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        v.push_back({a, b});\n    }\n    sort(v.begin(), v.end(), [&](pair<int, int> a, pair<int, int> b) {\n        if (a.second != b.second) return a.second < b.second;\n        else return a.first < a.first;\n    });\n\n    st.update(0, S + 1, 0);\n    fore(p, v) {\n        int L = p.first;\n        int R = p.second;\n        //printf(\"%d %d\\n\", L, R);\n        int c = st.get(L, N) + D[R];\n        st.update(0, R + 1, c);\n    }\n\n    int ans = st.get(T, T + 1);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF (1 << 30)\nusing namespace std;\n\nstruct state {\n  int v, d;\n\npublic:\n  bool operator<(const state &s) const { return d > s.d; };\n};\n\nint N, M, S, T, D[100000], A, B;\nvector<int> E[100000];\n\nint main(void) {\n  cin >> N >> M >> S >> T; S--; T--;\n  REP(i, 0, N) cin >> D[i];\n  REP(i, 0, M) {\n    cin >> A >> B; A--; B--;\n    if(A < B) E[A].push_back(B);\n    if(B < A) E[B].push_back(A);\n  }\n\n  vector<int> dp(N, INF);\n  priority_queue<state> q;\n  q.push((state) { S, 0 });\n\n  while(q.size()) {\n    state c = q.top();\n    q.pop();\n\n    // cout << c.v << \" \" << c.d << endl;\n\n    if(c.d >= dp[c.v]) continue;\n    dp[c.v] = c.d;\n\n    if(c.v == T) {\n      cout << c.d << endl;\n      return 0;\n    }\n\n    REP(u, 0, c.v) if(dp[u] > c.d) q.push((state) { u, c.d });\n    for(int u : E[c.v]) if(dp[u] > c.d + D[u]) q.push((state) { u, c.d + D[u] });\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\n/**\n * Dijkstra's algorithm.\n * First, call add_edge() to add edges.\n * Second, call solve() to calculate the length of the shortest path from source to each vertex.\n * Header requirement: algorithm, queue, vector\n * Verified by AtCoder ARC026-C (http://arc026.contest.atcoder.jp/submissions/604231)\n */\n template<class Len = int>\nclass Dijkstra {\nprivate:\n  int n;\n  std::vector<std::vector<std::pair<int, Len> > > edges;\npublic:\n  /**\n   * n: the number of vertices\n   */\n  Dijkstra(int n) : n(n), edges(n) {}\n  /*\n   * from: the source of edge to add\n   * to: the target of edge to add\n   * cost: the cost of edge to add\n   */\n  void add_edge(int from, int to, Len cost) {\n    edges[from].push_back(std::pair<int, Len>(to, cost));\n  }\n  /*\n   * This function returns an array consisting of the distances from vertex source.\n   */\n  std::vector<Len> solve(int source) {\n    const Len inf = 1e16;\n    typedef std::pair<Len, int> pi;\n    std::vector<Len> d(n, inf);\n    std::priority_queue<pi, std::vector<pi>, std::greater<pi> > que;\n    que.push(pi(0, source));\n    while (!que.empty()) {\n      pi p = que.top(); que.pop();\n      int idx = p.second;\n      if (d[idx] <= p.first) {\n\tcontinue;\n      }\n      d[idx] = p.first;\n      for(int j = 0; j < edges[idx].size(); ++j) {\n\tque.push(pi(p.first + edges[idx][j].second, edges[idx][j].first));\n      }\n    }\n    return d;\n  }\n};\n\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, s, t;\n  cin >> n >> m >> s >> t;\n  s--, t--;\n  VI d(n);\n  REP(i, 0, n) {\n    cin >> d[i];\n  }\n  Dijkstra<ll> dijk(n);\n  REP(i, 0, n - 1) {\n    dijk.add_edge(i + 1, i, 0);\n  }\n  REP(inmulieribus, 0, m) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    dijk.add_edge(a, b, d[b]);\n  }\n  cout << dijk.solve(s)[t] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX_N 100005\nstruct edge{ int to,cost; };\nint N,M,si,ti;\nvector< edge > G[MAX_N];\nint A[MAX_N];\n\nint main(){\n  cin>>N>>M>>si>>ti;\n  si--,ti--;\n  \n  for(int i=0;i<N;i++){\n    cin>>A[i];\n    if(i){\n      G[i].push_back( (edge){i-1,0} );\n    }\n  }\n  for(int i=0;i<M;i++){\n    int x,y;\n    cin>>x>>y;\n    x--,y--;\n    G[x].push_back( (edge){y,A[y]} );\n  }\n\n  priority_queue< P , vector<P> , greater<P> > Q;\n  int d[MAX_N];\n  for(int i=0;i<MAX_N;i++)d[i]=1e9;\n  \n  Q.push( P(0,si) );\n  d[si]=0;\n  while(!Q.empty()){\n    P p=Q.top();Q.pop();\n    int pos=p.second;\n    int cost=p.first;\n    if(d[pos]<cost)continue;\n    \n    for(int i=0;i<(int)G[pos].size();i++){\n      edge e=G[pos][i];\n      if(e.cost+cost < d[e.to]){\n        d[e.to]=e.cost+cost;\n        Q.push( P(d[e.to],e.to) );\n      }\n    }\n  }\n  cout<< d[ti] <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nstruct cww{cww(){\n    ios::sync_with_stdio(false);cin.tie(0);\n}}star;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l,T r)\n{bool a=l>r;if(a)l=r;return a;}\ntemplate <typename T>inline bool chmax(T &l,T r)\n{bool a=l<r;if(a)l=r;return a;}\n\n\ntypedef vector<LL> V;\ntypedef vector<V> VV;\nconst LL INF=1e15;\nint a[112345];\nint b[112345];\nLL c[112345];\nLL d[112345];\nint main(){\n    int N,M,s,t;\n    cin>>N>>M>>s>>t;s--;t--;\n    V dist(N,INF);\n    VV g(N);\n    REP(i,N)cin>>d[i];\n    REP(i,M){\n        cin>>a[i]>>b[i];\n        a[i]--;b[i]--;\n        c[i]=d[b[i]];\n        g[a[i]].pb(i);\n    }\n    REP(i,N-1){\n        a[i+M]=i+1;\n        b[i+M]=i;\n        c[i+M]=0;\n        g[a[i+M]].pb(i+M);\n    }\n    dist[s]=0;\n    priority_queue<pair<LL,int>> Q;\n    Q.push({0ll,s});\n    while(Q.size()){\n        auto q=Q.top();Q.pop();\n        LL cost=-q.fi;\n        int v=q.se;\n        if(cost>dist[v])continue;\n        for(auto &e:g[v]){\n            int u=b[e];\n            LL nxtcost=c[e]+cost;\n            if(chmin(dist[u],nxtcost)){\n                Q.push({-nxtcost,u});\n            }\n        }\n    }\n    cout<<dist[t]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 999999999999999\n\nstruct Info{\n\tInfo(int arg_dimension,ll arg_total_damage,int arg_pre_dimension){\n\t\tdimension = arg_dimension;\n\t\ttotal_damage = arg_total_damage;\n\t\tpre_dimension = arg_pre_dimension;\n\t}\n\tint dimension,pre_dimension;\n\tll total_damage;\n};\n\nint main(){\n\n\tint N,M,start,goal;\n\n\tscanf(\"%d %d %d %d\",&N,&M,&start,&goal);\n\tll* damage = new ll[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%lld\",&damage[i]);\n\t}\n\n\tvector<int> V[N+1];\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tV[from].push_back(to);\n\t}\n\n\tll* min_damage = new ll[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tmin_damage[i] = NUM;\n\t}\n\n\tqueue<Info> Q;\n\n\tQ.push(Info(start,0,0));\n\tmin_damage[start] = 0;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().dimension == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.front().total_damage > min_damage[Q.front().dimension]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tif(Q.front().pre_dimension > Q.front().dimension){\n\n\t\t\t\tfor(int i = 0; i < V[Q.front().dimension].size(); i++){\n\t\t\t\t\tif(V[Q.front().dimension][i] > Q.front().pre_dimension){ //????????°??????????????????????????´?????????????§?\n \t\t\t\t\t\tif(min_damage[V[Q.front().dimension][i]] > Q.front().total_damage+damage[V[Q.front().dimension][i]]){\n \t\t\t\t\t\t\tmin_damage[V[Q.front().dimension][i]] = Q.front().total_damage+damage[V[Q.front().dimension][i]];\n \t\t\t\t\t\t\tQ.push(Info(V[Q.front().dimension][i],min_damage[V[Q.front().dimension][i]],Q.front().pre_dimension));\n \t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\n\t\t\t\tfor(int i = Q.front().pre_dimension+1; i <= Q.front().dimension-1;i++){\n\t\t\t\t\tif(min_damage[i] > Q.front().total_damage){\n\t\t\t\t\t\tmin_damage[i] = Q.front().total_damage;\n\t\t\t\t\t\tQ.push(Info(i,Q.front().total_damage,Q.front().dimension));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < V[Q.front().dimension].size(); i++){\n\t\t\t\t\tif(min_damage[V[Q.front().dimension][i]] > Q.front().total_damage+damage[V[Q.front().dimension][i]]){\n\t\t\t\t\t\tmin_damage[V[Q.front().dimension][i]] = Q.front().total_damage+damage[V[Q.front().dimension][i]];\n\t\t\t\t\t\tQ.push(Info(V[Q.front().dimension][i],min_damage[V[Q.front().dimension][i]],Q.front().dimension));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",min_damage[goal]);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nconst int MAX_N = 1<<17;\n\nint n, dat[2*MAX_N-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_) n*=2;\n  for(int i=0;i<2*n-1;i++) dat[i] = INT_MAX;\n}\n\nvoid update(int k,int a){\n  k+=n-1;\n  dat[k]=a;\n  while(k>0){\n    k=(k-1)/2;\n    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\nint query(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l) return INT_MAX;\n  if(a<=l&&r<=b) return dat[k];\n  else{\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n}\n\nint m, s, t, d[MAX_N];\nP ab[MAX_N];\n\nint main(){\n\n  cin>>n>>m>>s>>t;\n  \n  s--, t--;\n  \n  for(int i=0;i<n;i++) cin>>d[i];\n    \n  for(int i=0;i<m;i++){\n    cin>>ab[i].first>>ab[i].second;\n    ab[i].first--;\n    ab[i].second--;\n  }\n\n  sort(ab,ab+m);\n  \n  init(n);\n  \n  update(s,0);\n\n  for(int i=0;i<m;i++){\n\n    int A=ab[i].first;\n    int B=ab[i].second;\n\n    int cost=query(A,n,0,0,n)+d[B];\n    \n    if(query(B,B+1,0,0,n)>cost) update(B,cost);\n    \n  }\n  \n  cout<<query(t,n,0,0,n)<<endl;\n  \n  return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100001;\n\nint n,m,s,t,d[MAX_N],a[MAX_N],b[MAX_N],dist[MAX_N];\nvector<int> e[MAX_N];\n\ntypedef pair<int,int> P;\n\nint cal(){\n\n  priority_queue<P,vector<P>,greater<P> > Q;\n  \n  for(int i=0;i<n;i++)dist[i]=1e9;\n\n  Q.push(P(0,s));\n  dist[s]=0;\n\n\n  int head=0;\n  \n  while(!Q.empty()){\n\n    P tmp=Q.top();\n\n    int pos=tmp.second,ct=tmp.first;\n\n    //    cout<<pos<<\" \"<<ct<<endl;\n    \n    Q.pop();\n\n    if(pos==t)return ct;\n\n    for(int i=head;i<pos;i++){\n\n     \n      \n      int nct=ct;\n      \n      if(nct<dist[i]){\n\tdist[i]=nct;\n\tQ.push(P(nct,i));\n      }\n    }\n    \n    head=max(head,pos);\n    \n    for(int i=0;i<e[pos].size();i++){\n\n      int npos=e[pos][i];\n      int nct=ct+d[npos];\n      \n      if(nct<dist[npos]){\n\tdist[npos]=nct;\n\tQ.push(P(nct,npos));\n      }\n    }\n  \n    \n  }\n  \n  return -1;\n}\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  \n  cin>>n>>m>>s>>t;\n\n  s--,t--;\n  \n  for(int i=0;i<n;i++)cin>>d[i];\n\n  for(int i=0;i<m;i++){\n\n    cin>>a[i]>>b[i],a[i]--,b[i]--;\n\n    e[a[i]].push_back(b[i]);\n\n  }\n  \n  cout<<cal()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/cdescription.jsp?cid=ACPC2017Day1&pid=D\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N, M, s, t; cin >> N >> M >> s >> t;\n\ts--; t--;\n\tvector<int> d(N);\n\tvector<vector<int>> G(N);\n\tfor (int i = 0; i < N;i++) cin >> d[i];\n\tfor (int i = 0; i < M;i++) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t}\n\tfor (int i = 1; i < N;i++)G[i].push_back(i - 1);\n\tvector<ll> dist(N, INF);\n\tqueue<pair<int, int>> q;\n\tq.push({ s,s });\n\tdist[s] = 0;\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tint n = p.first, max_n = p.second;\n\t\tfor (auto next : G[n]) {\n\t\t\tint cost = d[next];\n\t\t\tif (next < max_n) cost = 0;\n\t\t\tif (dist[next] > dist[n] + cost) {\n\t\t\t\tdist[next] = dist[n] + cost;\n\t\t\t\tq.push({ next,max(max_n,next) });\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tcout << dist[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i, b, e) for (auto i = b; i < e; ++i)\n\nint n, m, s, t;\n\ntypedef pair<int, int> P;\n\nstruct Edge {\n    Edge(int to, int cost) : to(to), cost(cost) {}\n\n    int to, cost;\n};\n\nvector<vector<Edge>> graph;\n\nconst int inf = 1 << 28;\n\nint dijkstra(int s, int t) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> d(n, inf);\n    d[s] = 0;\n    que.emplace(0, s);\n\n    while (!que.empty()) {\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if (d[v] < p.first) continue;\n        for (auto& e : graph[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.emplace(d[e.to], e.to);\n            }\n        }\n    }\n\n    return d[t];\n}\n\nint main() {\n    cin >> n >> m >> s >> t;\n\n    s--;\n    t--;\n\n    graph.assign(n, {});\n\n    vector<int> d(n);\n    for (auto& x : d) {\n        cin >> x;\n    }\n\n    REP(i, 0, m) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n\n        graph[a].emplace_back(b, d[b]);\n    }\n\n    REP(i, 1, n) { graph[i].emplace_back(i - 1, 0); }\n\n    cout << dijkstra(s, t) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint n,m,s,g,d[SIZE],a,b;\nvector<int> way[SIZE];\n\nint main(){\n  \n  scanf(\"%d%d%d%d\",&n,&m,&s,&g);\n\n  s--; g--;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d\",d+i);\n  }\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",&a,&b);\n    a--;\n    b--;\n    way[a].push_back(b);\n  }\n\n  queue<pair<int,int> > que;\n\n  int dp[SIZE];\n\n  for(int i=0;i<n;i++){\n    dp[i] = INF;\n  }\n\n  dp[s] = 0;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<way[i].size();j++){\n      que.push({i, way[i][j]});\n    }\n\n    while(que.size()){\n      auto p = que.front();\n      que.pop();\n\n      dp[p.second] = min(dp[p.second], dp[i] + d[p.second]);\n\n      cerr << p.first << p.second << endl;\n    }\n  }\n\n  int ans = INF;\n  \n  for(int i=g;i<n;i++){\n    ans = min(ans, dp[g]);\n  }\n\n  printf(\"%d\\n\",ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nstruct cww{cww(){\n    ios::sync_with_stdio(false);cin.tie(0);\n}}star;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l,T r)\n{bool a=l>r;if(a)l=r;return a;}\ntemplate <typename T>inline bool chmax(T &l,T r)\n{bool a=l<r;if(a)l=r;return a;}\n\n\ntypedef vector<LL> V;\ntypedef vector<V> VV;\nconst LL INF=1e15;\nint a[212345];\nint b[212345];\nLL c[212345];\nLL d[212345];\nint main(){\n    int N,M,s,t;\n    cin>>N>>M>>s>>t;s--;t--;\n    V dist(N,INF);\n    VV g(N);\n    REP(i,N)cin>>d[i];\n    REP(i,M){\n        cin>>a[i]>>b[i];\n        a[i]--;b[i]--;\n        c[i]=d[b[i]];\n        g[a[i]].pb(i);\n    }\n    REP(i,N-1){\n        a[i+M]=i+1;\n        b[i+M]=i;\n        c[i+M]=0;\n        g[a[i+M]].pb(i+M);\n    }\n    dist[s]=0;\n    priority_queue<pair<LL,int>> Q;\n    Q.push({0ll,s});\n    while(Q.size()){\n        auto q=Q.top();Q.pop();\n        LL cost=-q.fi;\n        int v=q.se;\n        if(cost>dist[v])continue;\n        for(auto &e:g[v]){\n            int u=b[e];\n            LL nxtcost=c[e]+cost;\n            if(chmin(dist[u],nxtcost)){\n                Q.push({-nxtcost,u});\n            }\n        }\n    }\n    cout<<dist[t]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint n,m,s,g,d[SIZE],a,b;\nvector<int> way[SIZE];\n\nint main(){\n  \n  scanf(\"%d%d%d%d\",&n,&m,&s,&g);\n\n  s--; g--;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d\",d+i);\n  }\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",&a,&b);\n    a--;\n    b--;\n    way[a].push_back(b);\n  }\n\n  queue<pair<int,int> > que;\n\n  int dp[SIZE];\n\n  for(int i=0;i<n;i++){\n    dp[i] = INF;\n  }\n\n  dp[s] = 0;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<way[i].size();j++){\n      que.push({i, way[i][j]});\n    }\n\n    while(que.size()){\n      auto p = que.front();\n      que.pop();\n\n      dp[p.second] = min(dp[p.second], dp[i] + d[p.second]);\n    }\n  }\n\n  int ans = INF;\n  \n  for(int i=g;i<n;i++){\n    ans = min(ans, dp[i]);\n  }\n\n  printf(\"%d\\n\",ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/cdescription.jsp?cid=ACPC2017Day1&pid=D\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N, M, s, t; cin >> N >> M >> s >> t;\n\ts--; t--;\n\tvector<int> d(N);\n\tvector<vector<int>> G(N);\n\tfor (int i = 0; i < N;i++) cin >> d[i];\n\tfor (int i = 0; i < M;i++) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t}\n\tfor (int i = 1; i < N;i++)G[i].push_back(i - 1);\n\tvector<ll> dist(N, INF);\n\tqueue<pair<int, int>> q;\n\tq.push({ s,s });\n\tdist[s] = 0;\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tint n = p.first, max_n = p.second;\n\t\tfor (auto next : G[n]) {\n\t\t\tint cost = d[next];\n\t\t\tif (next < max_n) cost = 0;\n\t\t\tif (dist[next] > dist[n] + cost) {\n\t\t\t\tdist[next] = dist[n] + cost;\n\t\t\t\tq.push({ next,max(max_n,next) });\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll inf = 1e15;\nstruct edge{\n  ll to, cost;\n  edge(ll t, ll c) {\n    to = t, cost = c;\n  }\n};\nint N, M;\nll d[100005];\nvector<edge> G[100005];\nvoid dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  FOR(i,1,N+1) d[i] = inf;\n  d[s] = 0;\n  que.push(P(0, s));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(auto &e : G[v]){\n      if(d[e.to] > d[v] + e.cost){\n        d[e.to] = d[v] + e.cost;\n        que.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int s, t; cin >> N >> M >> s >> t;\n  ll dd[N]; FOR(i,0,N) cin >> dd[i];\n  FOR(i,0,M) {\n    int a, b; cin >> a >> b;\n    if(b < s) dd[b-1] = 0;\n    G[a].push_back(edge(b, dd[b-1]));\n  }\n  FOR(i,1,s) {\n    G[s].push_back(edge(i, 0));\n  }\n  if(s >= t) {\n    cout << 0 << endl;\n    return 0;\n  }\n  dijkstra(s);\n  ll ans = 1e15;\n  FOR(i,t,N+1) {\n    ans = min(ans, d[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define fordebug int hoge;cin>>hoge;\n#define DEKAI 1000000007;\n#define INF (1<<28)\n#define int long long\n#define double long double\n#define floot10 cout<<fixed<<setprecision(10)\nint dp[100100];\n\nsigned main(){\n  int n,m,s,t;\n  cin>>n>>m>>s>>t;\n  priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> > q;\n  int cost[100100];\n  lp(i,n){\n    cin>>cost[i+1];\n  }\n  vector<pair<int,int> > v;\n  lp(i,m){\n    int a,b;\n    cin>>a>>b;\n    if(a>t) continue;\n    if(a<s) a=s;\n    v.push_back({a,b});\n  }\n  sort(v.begin(),v.end());\n  q.push({0,s});\n  lp(i,v.size()){\n    int fr=v[i].first;\n    int to=v[i].second;\n    while(1){\n      if(q.top().second<fr) q.pop();\n      else break;\n    }\n    q.push({q.top().first+cost[to],to});\n  }\n  while(1){\n    if(q.top().second<t) q.pop();\n    else break;\n  }\n  cout<<q.top().first<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll inf = 1e15;\nstruct edge{\n  ll to, cost;\n  edge(ll t, ll c) {\n    to = t, cost = c;\n  }\n};\nint N, M;\nll d[100005];\nvector<edge> G[100005];\nvoid dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  FOR(i,1,N+1) d[i] = inf;\n  d[s] = 0;\n  que.push(P(0, s));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(auto &e : G[v]){\n      if(d[e.to] > d[v] + e.cost){\n        d[e.to] = d[v] + e.cost;\n        que.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int s, t; cin >> N >> M >> s >> t;\n  ll dd[N]; FOR(i,0,N) cin >> dd[i];\n  FOR(i,0,M) {\n    int a, b; cin >> a >> b;\n    if(b <= s) dd[b-1] = 0;\n    G[a].push_back(edge(b, dd[b-1]));\n  }\n  FOR(i,1,N) {\n    G[i+1].push_back(edge(i, 0));\n  }\n  if(s >= t) {\n    cout << 0 << endl;\n    return 0;\n  }\n  dijkstra(s);\n  ll ans = 1e15;\n  FOR(i,t,N+1) {\n    ans = min(ans, d[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint main(){\n  int n,m,s,g,d[SIZE],a,b;\n  vector<int> way[SIZE];\n  \n  scanf(\"%d%d%d%d\",&n,&m,&s,&g);\n\n  s--; g--;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d\",d+i);\n  }\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",&a,&b);\n    a--;\n    b--;\n    way[a].push_back(b);\n  }\n\n  queue<pair<int,int> > que;\n\n  int dp[SIZE];\n\n  for(int i=0;i<n;i++){\n    dp[i] = INF;\n  }\n\n  dp[s] = 0;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<way[i].size();j++){\n      que.push({i, way[i][j]});\n    }\n\n    while(que.size()){\n      auto p = que.front();\n      que.pop();\n\n      dp[p.second] = min(dp[p.second], dp[i] + d[p.second]);\n\n      cerr << p.first << p.second << endl;\n    }\n  }\n\n  int ans = INF;\n  \n  for(int i=g;i<n;i++){\n    ans = min(ans, dp[g]);\n  }\n\n  printf(\"%d\\n\",ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\n/**\n * Dijkstra's algorithm.\n * First, call add_edge() to add edges.\n * Second, call solve() to calculate the length of the shortest path from source to each vertex.\n * Header requirement: algorithm, queue, vector\n * Verified by AtCoder ARC026-C (http://arc026.contest.atcoder.jp/submissions/604231)\n */\n template<class Len = int>\nclass Dijkstra {\nprivate:\n  int n;\n  std::vector<std::vector<std::pair<int, Len> > > edges;\npublic:\n  /**\n   * n: the number of vertices\n   */\n  Dijkstra(int n) : n(n), edges(n) {}\n  /*\n   * from: the source of edge to add\n   * to: the target of edge to add\n   * cost: the cost of edge to add\n   */\n  void add_edge(int from, int to, Len cost) {\n    edges[from].push_back(std::pair<int, Len>(to, cost));\n  }\n  /*\n   * This function returns an array consisting of the distances from vertex source.\n   */\n  std::vector<Len> solve(int source) {\n    const Len inf = 1e16;\n    typedef std::pair<Len, int> pi;\n    std::vector<Len> d(n, inf);\n    std::priority_queue<pi, std::vector<pi>, std::greater<pi> > que;\n    que.push(pi(0, source));\n    while (!que.empty()) {\n      pi p = que.top(); que.pop();\n      int idx = p.second;\n      if (d[idx] <= p.first) {\n\tcontinue;\n      }\n      d[idx] = p.first;\n      for(int j = 0; j < edges[idx].size(); ++j) {\n\tque.push(pi(p.first + edges[idx][j].second, edges[idx][j].first));\n      }\n    }\n    return d;\n  }\n};\n\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, s, t;\n  cin >> n >> m >> s >> t;\n  s--, t--;\n  VI d(n);\n  REP(i, 0, n) {\n    cin >> d[i];\n  }\n  Dijkstra<ll> dijk(n);\n  REP(i, 0, n - 1) {\n    dijk.add_edge(i + 1, i, 0);\n  }\n  REP(inmulieribus, 0, m) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    dijk.add_edge(a, b, d[b]);\n  }\n  cout << dijk.solve(s)[t] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pairInt;\n#define FOR(i, n) for (int i = 0; i < int(n); i++)\n#define FOR1(i, m, n) for (int i = int(m); i < int(n); i++)\n#define MAX(a, b) ((a) >= (b) ? (a) : (b))\n#define MIN(a, b) ((a) <= (b) ? (a) : (b))\n\nint N, M;\nvector<int> d;\nmultimap<int, int> ab;\n\nint solve(int s, int t, int lower, int limit) {\n  int ans = limit;\n\n  if (t <= s) {\n    return 0;\n  }\n  \n  for (auto it = ab.lower_bound(lower); it != ab.end() && it->first <= s;\n       it++) {\n    if (it->second > s && d[it->second] <= ans) {\n      int temp = solve(it->second, t, s + 1, ans - d[it->second]);\n      if (temp != -1) {\n        ans = MIN(ans, temp + d[it->second]);\n      }\n    }\n  }\n\n  return ans == limit ? -1 : ans;\n}\n\nint main(int argc, char *argv[]) {\n  int s, t;\n\n  scanf(\"%d%d%d%d\", &N, &M, &s, &t);\n\n  d.resize(N + 1);\n\n  FOR1(i, 1, N + 1) scanf(\"%d\", &d[i]);\n  FOR(i, M) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    ab.insert(make_pair(a, b));\n  }\n\n  printf(\"%d\\n\", solve(s, t, 0, INT_MAX));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <set>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long int ll;\n\nstruct Edge{\n\tint to; ll dist;\n\tEdge(){}\n\tEdge(int to,ll dist):to(to),dist(dist){}\n};\n\ntemplate <class E>\nusing Graph = vector<vector<E>>;\n \ntemplate<class D, D INF>\nstruct Dijkstra {\n    vector<D> res; //res[i] = sからiまでの最短距離\n    \n    template<class E>\n    Dijkstra(const Graph<E> &g, int s) {\n        int V = (int)g.size();\n        res = vector<D>(V, INF);\n        \n        using P = pair<D, int>;\n        priority_queue<P, vector<P>, greater<P>> q;\n        q.push(P(0, s));\n        res[s] = 0;\n        while (!q.empty()) {\n            P p = q.top(); q.pop();\n            if (res[p.second] < p.first) continue;\n            for (E e: g[p.second]) {\n                if (p.first+e.dist < res[e.to]) {\n                    res[e.to] = p.first+e.dist;\n                    q.push(P(res[e.to], e.to));\n                }\n            }\n        }\n    }\n};\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint n,m; cin >> n >> m;\n\tint s,t; cin >> s >> t;\n\ts--; t--;\n\tGraph<Edge> g(n);\n\tvector<int> d(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> d[i];\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint l,r; cin >> l >> r ;\n\t\tl--; r--;\n\t\tg[l].push_back(Edge(r,d[r]));\n\t}\n\tfor(int i=0;i<n-1;i++){\n\t\tg[i+1].push_back(Edge(i,0));\n\t}\n\tDijkstra<ll,(ll)1e15> di(g,s);\n\tif(di.res[t]==1e15){\n\t\tcout << -1 << endl;\n\t}\n\telse{\n\t\tcout << di.res[t] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<cstring>\n#include<climits>\n#include<sstream>\n#include<deque>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<bitset>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\n\n#define MAX 100010\nint V,E,s,t;\nvector<int> G[MAX];\nvector<ll> d;\n\n\nclass RMQ{\nprivate:\n  int limit,N;\n  vector<ll> dat;\npublic:\n  void init(int n_){\n    N = n_;\n    limit = 1;\n    while(limit<n_)limit*=2;\n    dat.clear();\n    dat.resize(2*limit,LLONG_MAX);\n  }\n  \n  ll _build(int cur,int L,int R,const vector<ll> &buf){\n    if( !( 0 <= cur && cur < 2*limit ) ) return LLONG_MAX;\n    if( L == R-1 ) {\n      if( L >= N ) return LLONG_MAX;\n      dat[cur] = buf[L];\n    } else {\n      ll vl = _build(cur*2+1,L,(L+R)/2,buf);\n      ll vr = _build(cur*2+2,(L+R)/2,R,buf);\n      dat[cur] = min(vl,vr);\n    }\n    return dat[cur];\n  }\n\n  void build(const vector<ll> &buf){ _build(0,0,limit,buf); };\n\n  void update(int k,ll a){\n    k += limit-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n \n  ll _query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return LLONG_MAX;\n    else if(a<=l && r<=b)return dat[k];\n    ll vl = _query(a,b,k*2+1,l,(l+r)/2);\n    ll vr = _query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n\n  ll query(int a,int b){ return _query(a,b,0,0,limit); }\n};\n\n\n\nint main(){\n  /*\n  RMQ rmq2;\n  rmq2.init(10);\n  rmq2.build(vector<ll>(10,LLONG_MAX));\n  while(1) {\n    int t;\n    int a,b;\n    cout << \"t = \";\n    cin >> t;\n    if( t == 0 ) {\n      cin >> a >> b;\n      cout << rmq2.query(a,b) << endl;\n    } else {\n      cin >> a >> b;\n      rmq2.update(a,(ll)b);\n    }\n  }\n  puts(\"--\");\n  */\n\n  \n  cin >> V >> E >> s >> t;\n  --s, --t;\n  d = vector<ll>(V,0);\n  rep(i,V) cin >> d[i];\n  rep(i,E) {\n    int a,b;\n    cin >> a >> b;\n    --a, --b;\n    if( a < s ) a = s;\n    G[a].push_back(b);\n  }\n  if( t <= s ) {\n    puts(\"0\");\n    return 0;\n  }\n\n  RMQ rmq;\n  rmq.init(V+1);\n  rmq.build(vector<ll>(V+1,LLONG_MAX));\n  rmq.update(s,0LL);\n  REP(i,s,V) {\n    ll mini = rmq.query(i,V+1);\n    rmq.update(i,mini);\n    rep(j,(int)G[i].size()) {\n      int nex = G[i][j];\n      if( nex == i ) continue;\n      ll v = rmq.query(nex,nex+1);\n      if( v > mini + d[nex]) {\n\t//cout << mini << \" + \" << d[nex] << endl;\n\trmq.update(nex,mini+d[nex]);\n      }\n    }\n  }\n  cout << rmq.query(t,t+1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REP2(i,m,n) for (int i=m;i<(n);i++)\ntypedef long long ll;\n\nclass SegmentTree {\npublic:\n    vector<ll> table;\n    int size;\n\n    SegmentTree(int n) {\n        size = 1;\n        while (size <= n * 2) size *= 2;\n        size *= 2;\n        table = vector<ll>(size, 1LL << 59);\n    }\n\n    void assign(int pos, ll num) {\n        return assign(pos, num, 0, 0, size/2-1);\n    }\n\n    void assign(int pos, ll num, int i, int left, int right) {\n        if (left == right) {\n            table[i] = num;\n            return;\n        }\n        auto mid = (left + right) / 2;\n        if (pos <= mid)\n            assign(pos, num, i*2+1, left, mid);\n        else\n            assign(pos, num, i*2+2, mid+1, right);\n        table[i] = min(table[2*i+1], table[2*i+2]);\n    }\n\n    ll query(int pl, int pr) {\n        return query(pl, pr, 0, 0, size/2-1);\n    }\n\n    ll query(int pl, int pr, int i, int left, int right) {\n        if (pl > right || pr < left)\n            return 1LL << 59;\n        else if (pl <= left && right <= pr)\n            return table[i];\n        else\n            return\n                min(query(pl, pr, i*2+1, left, (left+right)/2),\n                    query(pl, pr, i*2+2, (left+right)/2+1, right));\n    }\n};\n\n\nint N, M, s, t;\nint D[101010];\nvector<int> edges[101010];\nll dist[101010];\n\n\nint main() {\n    cin >> N >> M >> s >> t;\n    s--, t--;\n\n    REP(i, N) cin >> D[i];\n    REP(i, s+1) D[i] = 0;\n\n    REP(i, M) {\n        int a, b; cin >> a >> b;\n        edges[a - 1].push_back(b - 1);\n    }\n\n    SegmentTree st = SegmentTree(N);\n    REP(i, N) st.assign(s, 0);\n\n    REP(i, N) {\n        ll d = st.query(i, N);\n        cout << i << \" \" << d << endl;\n        for (auto m: edges[i])\n            st.assign(m, min(st.query(m, m), d + D[m]));\n    }\n\n    ll ans = 1LL << 59;\n    REP2(i, t, N) ans = min(ans, st.query(i, i));\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//????¬????????????????????????§?????????, ??????????????????, ????°??????????????????¬.\n//dp[i] = ??????i+1??\\????????????????????´????????????i?????§???????°??????????, ??¨????????¨\n//??????i?????§???????°??????????dp2[i] = min(dp[i], ???, dp[n])????????????\n//dp2[i]????????????????¢???????????????? dp[i] = dp2[?§??????????i???????????????????§???????id???????°????] + d[i]????????????(i > s?????¨???)\n//i ??? s?????¨??????, dp[i] = 0????????????\n//?????£??????dp??¨???RMQ????????°????????????????????§?????£????????????????????´??°??????????????°?????????\n//O(M + NlogN)\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int DEPTH = 17;\nclass SegTree {\n\tint d[1 << (DEPTH + 1)];\npublic:\n\n\tSegTree() { for (int i = 0; i < (1 << (DEPTH + 1)); i++) { d[i] = 1145141919; } }\n\t\n\t//?????????pos(??§0)?????????????????????x????????????\n\tvoid update(int pos, int x) {\n\t\tpos += (1 << DEPTH) - 1;\n\t\td[pos] = x;\n\t\twhile (pos > 0) {\n\t\t\tpos = (pos - 1) / 2;\n\t\t\td[pos] = min(d[pos * 2 + 1], d[pos * 2 + 2]);\n\t\t}\n\t}\n\t\n\t//?????????l, ???, r-1?????????????????????????°?????±???????.\n\tint getMin(int l, int r, int a = 0, int b = (1 << DEPTH), int id = 0) {\n\t\tif (a >= r || b <= l) return 1145141919;\n\t\tif (l <= a && b <= r) return d[id];\n\t\tint u = getMin(l, r, a, a + (b - a) / 2, id * 2 + 1);\n\t\tint v = getMin(l, r, a + (b - a) / 2, b, id * 2 + 2);\n\t\treturn min(u, v);\n\t}\n};\n\nint n, m, s, t;\nint d[100000];\nint minId[100000];\nSegTree dp;\n\nint main() {\n\tint i;\n\t\n\tcin >> n >> m >> s >> t; s--; t--;\n\tfor (i = 0; i < n; i++) { cin >> d[i]; minId[i] = i; }\n\tfor (i = 0; i < m; i++) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tminId[b] = min(minId[b], a);\n\t}\n\t\n\tfor (i = 0; i <= s; i++) {\n\t\tdp.update(i, 0);\n\t}\n\tfor (i = s + 1; i < n; i++) {\n\t\tdp.update(i, dp.getMin(minId[i], n) + d[i]);\n\t}\n\tcout << dp.getMin(t, n) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint n,m,s,g,d[SIZE],a,b;\nvector<int> way[SIZE];\n\nint main(){\n  \n  scanf(\"%d%d%d%d\",&n,&m,&s,&g);\n\n  s--; g--;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d\",d+i);\n  }\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",&a,&b);\n    a--;\n    b--;\n    way[a].push_back(b);\n  }\n\n  queue<pair<int,int> > que;\n\n  int dp[SIZE];\n\n  for(int i=0;i<n;i++){\n    dp[i] = INF;\n  }\n\n  dp[s] = 0;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<way[i].size();j++){\n      que.push({i, way[i][j]});\n    }\n\n    while(que.size()){\n      auto p = que.front();\n      que.pop();\n\n      dp[p.second] = min(dp[p.second], dp[i] + d[p.second]);\n    }\n  }\n\n  int ans = INF;\n  \n  for(int i=g;i<n;i++){\n    ans = min(ans, dp[g]);\n  }\n\n  printf(\"%d\\n\",ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct edge{ int to,cost; };\nconst int N = 2e5+10;\nvector< edge > G[N];\n\nvoid dikstra(int s,int t){\n  typedef pair<int, int> P;\n  const int INF = 1 << 30;\n\n  priority_queue<P,vector<P>,greater<P>> que;\n  vector<int> d(N,INF); //sからの最短距離\n  d[s] = 0;\n  que.push({0,s}); //{最短距離,頂点}\n\n  while( !que.empty() ){\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(auto e : G[v]){\n      if(d[e.to] > d[v] + e.cost){\n        d[e.to] = d[v] + e.cost;\n        que.push( {d[e.to],e.to} );\n      }\n    }\n  }\n  cout << d[t] << endl;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n,m,s,t; cin >> n >> m >> s >> t;\n  s--,t--;\n  vector<int> d(n);\n  for(int i = 0; i < n; i++){\n    cin >> d[i];\n    G[i+1].push_back({i,0});\n  }\n  for(int i = 0; i < m; i++){\n    int a,b; cin >> a >> b;\n    a--,b--;\n    G[a].push_back({b,d[b]});\n  }\n\n  dikstra(s,t);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntypedef long long W;\n\nconst W INF = 1LL << 50;\n\nstruct edge{\n\tint to;\n\tW cost;\n};\ntypedef vector<vector <edge > > Graph;\n\nvector<W> dijkstra(int s, const Graph& G){\n\ttypedef pair<W, int> P;\n\tvector<W> d(G.size(), INF);\n\td[s] = 0;\n\tpriority_queue< P, vector<P>, greater<P> > que;\n\tque.push(P(0, s));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\n\nint d[100000];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint N, M, s, t;\n\tcin >> N >> M >> s >> t;\n\ts--, t--;\n\tGraph G(N);\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> d[i];\n\t\tif(i) G[i].push_back({ i - 1, 0 });\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tG[a].push_back({ b, d[b] });\n\t}\n\n\tauto res = dijkstra(s, G);\n\tcout << res[t] << endl;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2834 Dimension travel\n// 2018.4.14 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 500000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\n#define INF 0x50505050\nint d[100002];\nint hi[100002], *to[100002];\nint dist[100002];\n\nint dijkstra(int n, int start, int goal)\n{\n\tint i, s, e, t, nt;\n\n\tmemset(dist, INF, n << 2);\n\tqsize = 0;\n\tdist[start] = 0, enq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, t = que[0].t, deq();\n\t\tif (s == goal) break;\n\t\tif (dist[s] < t) continue;\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], nt = t;\n\t\t\tif (e > s) nt = t + d[e];\n\t\t\tif (dist[e] <= nt) continue;\n\t\t\tdist[e] = nt, enq(e, nt);\n\t\t}\n\t}\n\treturn t;\n}\n\nint main()\n{\n\tint N, M, s, t, a, b, i, j;\n\tint *memo;\n\n\tN = in(), M = in(), s = in()-1, t = in()-1;\n\tif (s >= t) { puts(\"0\"); return 0; }\n\n\tfor (i = 0; i < N; i++) d[i] = in();\n\tmemo = malloc(M << 3);\n\tj = 0; for (i = 0; i < M; i++) {\n\t\tmemo[j++] = a = in()-1, memo[j++] = in()-1;\n\t\thi[a]++;\n\t}\n\tfor (i = 0; i < N; i++) to[i] = malloc((1+hi[i])<<2);\n\tfor (i = 0; i < N; i++) hi[i] = 1, to[i][0] = i-1;\n\tj = 0; for (i = 0; i < M; i++) {\n\t\ta = memo[j++], b = memo[j++];\n\t\tto[a][hi[a]++] = b;\n\t}\n\tprintf(\"%d\\n\", dijkstra(N, s, t));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define min(p,q)((p)<(q)?(p):(q))\n#define INF ((1LL<<62)-(1LL<<31))\n\n//辺の情報を個別に持つタイプ\ntypedef struct edge{ll s,g;}E;\nint esort(const void*a,const void*b){\n\tE*p=(E*)a,*q=(E*)b;\n\tif((*p).s<(*q).s)return -1;\n\tif((*p).s>(*q).s)return  1;\n\tif((*p).g<(*q).g)return -1;\n\treturn 1;\n}\n\n//*\n//遅延セグ木ここから\n//↓ここを変える\ntypedef struct sayouso{ll k;}sayouso;\ntypedef struct atai{ll a;}atai;\n//↑ここを変える\n\ntypedef struct node{sayouso T;atai x;}node;\nnode *lsegN,*lseg;\nll lsegNUM;\n\n//↓ここから変える\nsayouso sid={INF};\natai aid={INF};\natai xx(atai x,atai y){\n\tatai ret;\n\tret.a=min(x.a,y.a);\n\treturn ret;\n}\natai Tx(sayouso T,atai x){\n\tatai ret;\n\tret.a=min(T.k,x.a);\n\treturn ret;\n}\nsayouso TT(sayouso S,sayouso T){\n\tsayouso ret;\n\tret.k=min(S.k,T.k);\n\treturn ret;\n}\n//↑ここまで変える\n\n//要素数(2ベキ)でこれを呼ぶ\nvoid lseguse(ll n){\n\tlsegN=(node*)calloc(2*n,sizeof(node));\n\tlsegNUM=n;\n\tlseg=lsegN+lsegNUM;\n\trep(i,0,lsegNUM){\n\t\tlseg[i].x=aid;\n\t\tlseg[i].T=sid;\n\t}\n\tfor(int i=lsegNUM-1;i>0;i--){\n\t\tlsegN[i].x=xx(lsegN[2*i].x,lsegN[2*i+1].x);\n\t\tlsegN[i].T=sid;\n\t}\n}\n//lseg[i].xに値を与えてから初期化\nvoid lseginit(){\n\tfor(int i=lsegNUM-1;i>0;i--)lsegN[i].x=xx(lsegN[2*i].x,lsegN[2*i+1].x);\n}\nvoid lsegupdatesub(ll l,ll r,sayouso T,ll i,ll cl,ll cr){\n\tif(l>=r)return;\n\t//disjointなとき\n\tif(cr<=l||r<=cl)return;\n\t//完全に含むとき\n\tif(l<=cl&&cr<=r){\n\t\tlsegN[i].T=TT(T,lsegN[i].T);\n\t\treturn;\n\t}\n\t//どちらでもないとき\n\t//遅延伝播\n\tlsegN[2*i  ].T=TT(lsegN[i].T,lsegN[2*i  ].T);\n\tlsegN[2*i+1].T=TT(lsegN[i].T,lsegN[2*i+1].T);\n\t//再帰的に更新\n\tll cm=(cl+cr)/2;\n\tlsegupdatesub(l,r,T,2*i  ,cl,cm);\n\tlsegupdatesub(l,r,T,2*i+1,cm,cr);\n\t//自身のnodeを更新\n\tlsegN[i].x=xx(Tx(lsegN[2*i].T,lsegN[2*i].x),Tx(lsegN[2*i+1].T,lsegN[2*i+1].x));\n\tlsegN[i].T=sid;\n}\nvoid lsegupdate(ll l,ll r,sayouso T){lsegupdatesub(l,r,T,1,0,lsegNUM);}\natai lsegcalcsub(ll l,ll r,ll i,ll cl,ll cr){\n\tif(l>=r)return aid;\n\t//完全に含むとき\n\tif(l<=cl&&cr<=r)return Tx(lsegN[i].T,lsegN[i].x);\n\n\tll cm=(cl+cr)/2;\n\t//遅延伝播(変更はないので配るだけで良い)\n\tlsegN[2*i  ].T=TT(lsegN[i].T,lsegN[2*i  ].T);\n\tlsegN[2*i+1].T=TT(lsegN[i].T,lsegN[2*i+1].T);\n\tlsegN[i].x=Tx(lsegN[i].T,lsegN[i].x);\n\tlsegN[i].T=sid;\n\n\t//左側だけ\n\tif(r<=cm)return lsegcalcsub(l,r,2*i  ,cl,cm);\n\t//右側だけ\n\tif(cm<=l)return lsegcalcsub(l,r,2*i+1,cm,cr);\n\t//両方\n\treturn xx(lsegcalcsub(l,r,2*i,cl,cm),lsegcalcsub(l,r,2*i+1,cm,cr));\n}\natai lsegcalc(ll l,ll r){return lsegcalcsub(l,r,1,0,lsegNUM);}\n//遅延セグ木ここまで\n//*/\n\nE e[100010];\nll d[100010];\nint main(){\n\tint n,m,s,t;\n\tscanf(\"%d%d%d%d\",&n,&m,&s,&t);\n\trep(i,1,n+1)scanf(\"%d\",d+i);\n\trep(i,0,m){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\te[i].s=x;\n\t\te[i].g=y;\n\t}\n\tqsort(e,m,sizeof(E),esort);\n\t\n\tlseguse(1<<17);\n\tsayouso T={0};\n\tlsegupdate(1,s+1,T);\n\trep(i,0,m){\n\t\tll x=lsegcalc(e[i].s,e[i].s+1).a;\n\t\tsayouso T={x+d[e[i].g]};\n\t\tlsegupdate(e[i].s,e[i].g+1,T);\n\t}\n\tprintf(\"%lld\\n\",lsegcalc(t,t+1).a);\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n    static final int INF = (int)1e9 + 7;\n    int N,M,s,t;\n    int[] d;\n    ArrayList<Integer>[] G;\n\n    private class D implements Comparable<D>{\n        int now;\n        int dime;\n        int cost;\n        public D(int now,int dime,int cost) {\n            this.now = now;\n            this.dime = dime;\n            this.cost = cost;\n        }\n\n        public int compareTo(D d) {\n            return this.cost - d.cost;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void solve() {\n        N = nextInt();\n        M = nextInt();\n        s = nextInt()-1;\n        t = nextInt()-1;\n\n        d = new int[N];\n\n        for(int i = 0;i < N;i++) {\n            d[i] = nextInt();\n        }\n\n        G = new ArrayList[N];\n        for(int i = 0;i < N;i++) {\n            G[i] = new ArrayList<>();\n        }\n\n        for(int i = 0;i < M;i++) {\n            int a = nextInt()-1;\n            int b = nextInt()-1;\n            G[a].add(b);\n        }\n\n        int[] minCost = new int[N];\n        Arrays.fill(minCost,INF);\n        PriorityQueue<D> pq = new PriorityQueue<>();\n        pq.add(new D(s, s,0));\n\n        while(pq.size() > 0) {\n\n            D data = pq.poll();\n            if(minCost[data.now] <= data.cost)continue;\n            minCost[data.now] = data.cost;\n\n            for(int next : G[data.now]) {\n                if (minCost[next] > data.cost + d[next]) {\n                    pq.add(new D(next, next, data.cost + d[next]));\n                }\n            }\n            for(int next = 0;next < data.now;next++) {\n                pq.add(new D(next,data.now,data.cost));\n            }\n        }\n\n        out.println(minCost[t]);\n    }\n\n    public static void main(String[] args) {\n        out.flush();\n        new Main().solve();\n        out.close();\n    }\n\n    /* Input */\n    private static final InputStream in = System.in;\n    private static final PrintWriter out = new PrintWriter(System.out);\n    private final byte[] buffer = new byte[2048];\n    private int p = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (p < buflen)\n            return true;\n        p = 0;\n        try {\n            buflen = in.read(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if (buflen <= 0)\n            return false;\n        return true;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrint(buffer[p])) {\n            p++;\n        }\n        return hasNextByte();\n    }\n\n    private boolean isPrint(int ch) {\n        if (ch >= '!' && ch <= '~')\n            return true;\n        return false;\n    }\n\n    private int nextByte() {\n        if (!hasNextByte())\n            return -1;\n        return buffer[p++];\n    }\n\n    public String next() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = -1;\n        while (isPrint((b = nextByte()))) {\n            sb.appendCodePoint(b);\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n    static final int INF = (int)1e9 + 7;\n    int N,M,s,t;\n    int[] d;\n    ArrayList<Integer>[] G;\n\n    private class D implements Comparable<D>{\n        int now;\n        int dime;\n        int cost;\n        public D(int now,int dime,int cost) {\n            this.now = now;\n            this.dime = dime;\n            this.cost = cost;\n        }\n\n        public int compareTo(D d) {\n            return this.cost - d.cost;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void solve() {\n        N = nextInt();\n        M = nextInt();\n        s = nextInt()-1;\n        t = nextInt()-1;\n\n        d = new int[N];\n\n        for(int i = 0;i < N;i++) {\n            d[i] = nextInt();\n        }\n\n        G = new ArrayList[N];\n        for(int i = 0;i < N;i++) {\n            G[i] = new ArrayList<>();\n        }\n\n        for(int i = 0;i < M;i++) {\n            int a = nextInt()-1;\n            int b = nextInt()-1;\n            G[a].add(b);\n        }\n\n        int[] minCost = new int[N];\n        Arrays.fill(minCost,INF);\n        PriorityQueue<D> pq = new PriorityQueue<>();\n        pq.add(new D(s, s,0));\n\n        while(pq.size() > 0) {\n\n            D data = pq.poll();\n            if(minCost[data.now] <= data.cost)continue;\n            minCost[data.now] = data.cost;\n\n            for(int next : G[data.now]) {\n                if (minCost[next] >= data.cost + d[next]) {\n                    pq.add(new D(next, next, data.cost + d[next]));\n                }\n            }\n            for(int next = 0;next < data.now;next++) {\n                pq.add(new D(next,data.now,data.cost));\n            }\n        }\n\n        out.println(minCost[t]);\n    }\n\n    public static void main(String[] args) {\n        out.flush();\n        new Main().solve();\n        out.close();\n    }\n\n    /* Input */\n    private static final InputStream in = System.in;\n    private static final PrintWriter out = new PrintWriter(System.out);\n    private final byte[] buffer = new byte[2048];\n    private int p = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (p < buflen)\n            return true;\n        p = 0;\n        try {\n            buflen = in.read(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if (buflen <= 0)\n            return false;\n        return true;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrint(buffer[p])) {\n            p++;\n        }\n        return hasNextByte();\n    }\n\n    private boolean isPrint(int ch) {\n        if (ch >= '!' && ch <= '~')\n            return true;\n        return false;\n    }\n\n    private int nextByte() {\n        if (!hasNextByte())\n            return -1;\n        return buffer[p++];\n    }\n\n    public String next() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = -1;\n        while (isPrint((b = nextByte()))) {\n            sb.appendCodePoint(b);\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n    static final int INF = (int)1e9 + 7;\n    int N,M,s,t;\n    int[] d;\n    ArrayList<Integer>[] G;\n\n    private class D implements Comparable<D>{\n        int now;\n        int dime;\n        int cost;\n        public D(int now,int dime,int cost) {\n            this.now = now;\n            this.dime = dime;\n            this.cost = cost;\n        }\n\n        public int compareTo(D d) {\n            return this.cost - d.cost;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void solve() {\n        N = nextInt();\n        M = nextInt();\n        s = nextInt()-1;\n        t = nextInt()-1;\n\n        d = new int[N];\n\n        for(int i = 0;i < N;i++) {\n            d[i] = nextInt();\n        }\n\n        G = new ArrayList[N];\n        for(int i = 0;i < N;i++) {\n            G[i] = new ArrayList<>();\n        }\n\n        for(int i = 0;i < M;i++) {\n            int a = nextInt()-1;\n            int b = nextInt()-1;\n            G[a].add(b);\n        }\n\n        int[] minCost = new int[N];\n        Arrays.fill(minCost,INF);\n        PriorityQueue<D> pq = new PriorityQueue<>();\n        pq.add(new D(s, s,0));\n\n        while(pq.size() > 0) {\n\n            D data = pq.poll();\n            if(minCost[data.now] <= data.cost)continue;\n            minCost[data.now] = data.cost;\n\n            for(int next : G[data.now]) {\n                if (minCost[next] > data.cost + d[next]) {\n                    pq.add(new D(next, Math.max(next,data.dime), data.cost + d[next]));\n                }\n            }\n            if (data.now -1 >= 0 && minCost[data.now-1] > data.cost){\n                pq.add(new D(data.now-1,data.dime,data.cost));\n            }\n        }\n\n        out.println(minCost[t]);\n    }\n\n    public static void main(String[] args) {\n        out.flush();\n        new Main().solve();\n        out.close();\n    }\n\n    /* Input */\n    private static final InputStream in = System.in;\n    private static final PrintWriter out = new PrintWriter(System.out);\n    private final byte[] buffer = new byte[2048];\n    private int p = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (p < buflen)\n            return true;\n        p = 0;\n        try {\n            buflen = in.read(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if (buflen <= 0)\n            return false;\n        return true;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrint(buffer[p])) {\n            p++;\n        }\n        return hasNextByte();\n    }\n\n    private boolean isPrint(int ch) {\n        if (ch >= '!' && ch <= '~')\n            return true;\n        return false;\n    }\n\n    private int nextByte() {\n        if (!hasNextByte())\n            return -1;\n        return buffer[p++];\n    }\n\n    public String next() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = -1;\n        while (isPrint((b = nextByte()))) {\n            sb.appendCodePoint(b);\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tint m = io.nextInt();\n\t\tint s = io.nextInt() - 1;\n\t\tint t = io.nextInt() - 1;\n\t\tint[] d = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\td[i] = io.nextInt();\n\t\t}\n\t\tGraph g = new Graph(n);\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tg.addEdge(i+1, i, 0);\n\t\t}\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint a = io.nextInt() - 1;\n\t\t\tint b = io.nextInt() - 1;\n\t\t\tg.addEdge(a, b, d[b]);\n\t\t}\n\t\tSystem.out.println(g.minDistDijkstra(s)[t]);\n\t}\n\n}\nclass Graph {\n\tpublic static final int INF = 1000000000;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from, int to, int cost) {\n\t\taddEdge(from, to, cost);\n\t\taddEdge(to, from, cost);\n\t}\n\tpublic void addEdge(int from, int to, int cost) {\n\t\tgraph[from].add(new Edge(to,cost));\n\t}\n\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<>();\n\t\tq.offer(new Node(0,s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e: graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\tclass Edge {\n\t\tint to,cost;\n\t\tpublic Edge(int to, int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tclass Node implements Comparable<Node> {\n\t\tint dist,id;\n\t\tpublic Node(int dist, int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn Integer.compare(dist, o.dist);\n\t\t}\n\t}\n}\nclass IO extends PrintWriter {\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer st = null;\n\tpublic IO() { super (System.out); };\n\tpublic String next() {\n\t\twhile( st== null || !st.hasMoreTokens()) {\n\t\t\tString s;\n\t\t\ttry {\n\t\t\t\ts = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (s == null) return null;\n\t\t\tst = new StringTokenizer(s);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tint m = io.nextInt();\n\t\tint s = io.nextInt() - 1;\n\t\tint t = io.nextInt() - 1;\n\t\tint[] d = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\td[i] = io.nextInt();\n\t\t}\n\t\tGraph g = new Graph(n);\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tg.addEdge(i+1, i, 0);\n\t\t}\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint a = io.nextInt() - 1;\n\t\t\tint b = io.nextInt() - 1;\n\t\t\tg.addEdge(a, b, d[b]);\n\t\t}\n\t\tSystem.out.println(g.minDistDijkstra(s)[t]);\n\t}\n\n}\nclass Graph {\n\tpublic static final int INF = 1000000000;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from, int to, int cost) {\n\t\taddEdge(from, to, cost);\n\t\taddEdge(to, from, cost);\n\t}\n\tpublic void addEdge(int from, int to, int cost) {\n\t\tgraph[from].add(new Edge(to,cost));\n\t}\n\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<>();\n\t\tq.offer(new Node(0,s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e: graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\tclass Edge {\n\t\tint to,cost;\n\t\tpublic Edge(int to, int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tclass Node implements Comparable<Node> {\n\t\tint dist,id;\n\t\tpublic Node(int dist, int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn Integer.compare(dist, o.dist);\n\t\t}\n\t}\n}\nclass IO extends PrintWriter {\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer st = null;\n\tpublic IO() { super (System.out); };\n\tpublic String next() {\n\t\twhile( st== null || !st.hasMoreTokens()) {\n\t\t\tString s;\n\t\t\ttry {\n\t\t\t\ts = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (s == null) return null;\n\t\t\tst = new StringTokenizer(s);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n    static final int INF = (int)1e9 + 7;\n    int N,M,s,t;\n    int[] d;\n    ArrayList<Integer>[] G;\n\n    private class D implements Comparable<D>{\n        int now;\n        int dime;\n        int cost;\n        public D(int now,int dime,int cost) {\n            this.now = now;\n            this.dime = dime;\n            this.cost = cost;\n        }\n\n        public int compareTo(D d) {\n            return this.cost - d.cost;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void solve() {\n        N = nextInt();\n        M = nextInt();\n        s = nextInt()-1;\n        t = nextInt()-1;\n\n        d = new int[N];\n\n        for(int i = 0;i < N;i++) {\n            d[i] = nextInt();\n        }\n\n        G = new ArrayList[N];\n        for(int i = 0;i < N;i++) {\n            G[i] = new ArrayList<>();\n        }\n\n        for(int i = 0;i < M;i++) {\n            int a = nextInt()-1;\n            int b = nextInt()-1;\n            G[a].add(b);\n        }\n\n        int[] minCost = new int[N];\n        Arrays.fill(minCost,INF);\n        PriorityQueue<D> pq = new PriorityQueue<>();\n        pq.add(new D(s, s,0));\n\n        while(pq.size() > 0) {\n\n            D data = pq.poll();\n            if(minCost[data.now] <= data.cost)continue;\n            minCost[data.now] = data.cost;\n\n            for(int next : G[data.now]) {\n                if (minCost[next] > data.cost + d[next]) {\n                    pq.add(new D(next, next, data.cost + d[next]));\n                }\n            }\n            for(int next = 0;next < data.now;next++) {\n                if (minCost[next] > data.cost){\n                    pq.add(new D(next,data.now,data.cost));\n                }\n            }\n        }\n\n        out.println(minCost[t]);\n    }\n\n    public static void main(String[] args) {\n        out.flush();\n        new Main().solve();\n        out.close();\n    }\n\n    /* Input */\n    private static final InputStream in = System.in;\n    private static final PrintWriter out = new PrintWriter(System.out);\n    private final byte[] buffer = new byte[2048];\n    private int p = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (p < buflen)\n            return true;\n        p = 0;\n        try {\n            buflen = in.read(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if (buflen <= 0)\n            return false;\n        return true;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrint(buffer[p])) {\n            p++;\n        }\n        return hasNextByte();\n    }\n\n    private boolean isPrint(int ch) {\n        if (ch >= '!' && ch <= '~')\n            return true;\n        return false;\n    }\n\n    private int nextByte() {\n        if (!hasNextByte())\n            return -1;\n        return buffer[p++];\n    }\n\n    public String next() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = -1;\n        while (isPrint((b = nextByte()))) {\n            sb.appendCodePoint(b);\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint s = sc.nextInt() - 1;\n\t\tint t = sc.nextInt() - 1;\n\t\tint[] damage = new int[n];\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tdamage[i] = sc.nextInt();\n\t\t}\n\t\tArrayList<ArrayList<Integer>> magic = new ArrayList<ArrayList<Integer>>();\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tArrayList<Integer> lst = new ArrayList<Integer>();\n\t\t\tmagic.add(lst);\n\t\t}\n\t\tfor (int i=0;i<m;i++) {\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tmagic.get(a).add(b);\n\t\t}\n\t\tint[] dist = new int[n];\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tdist[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tPriorityQueue<Node> que = new PriorityQueue<Node>();\n\t\tfor (int i=0;i<=s;i++){\n\t\t\tque.add(new Node(0, i));\n\t\t\tdist[i] = 0;\n\t\t}\n\t\tint limit = s + 1;\n\t\twhile (!que.isEmpty()) {\n\t\t\tNode node = que.poll();\n\t\t\tif (node.id == t) {\n\t\t\t\tSystem.out.println(node.cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tArrayList<Integer> lst = magic.get(node.id);\n\t\t\tfor (int to: lst) {\n\t\t\t\tif (node.cost + damage[to] < dist[to]) {\n\t\t\t\t\tdist[to] = node.cost + damage[to];\n\t\t\t\t\tque.add(new Node(node.cost + damage[to], to));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i=limit;i<node.id;i++) {\n\t\t\t\tif (dist[i] > node.cost) {\n\t\t\t\t\tdist[i] = node.cost;\n\t\t\t\t\tque.add(new Node(node.cost, i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (limit < node.id) limit = node.id;\n\t\t}\n\t}\n}\nclass Node implements Comparable<Node> {\n\tint cost, id;\n\tNode (int cost, int id) {\n\t\tthis.cost = cost;\n\t\tthis.id = id;\n\t}\n\tpublic int compareTo(Node node) {\n\t\treturn Integer.compare(cost, node.cost);\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n    Scanner cin;\n\n    void calc()\n    {\n        cin = new Scanner();\n        int N = cin.nextInt();\n        int M = cin.nextInt();\n        int s = cin.nextInt() - 1;\n        int t = cin.nextInt() - 1;\n        int[] d = cin.ArrayInt(N);\n        int[] a = new int[M];\n        int[] b = new int[M];\n        long[] ab = new long[M];\n\n        for (int i = 0; i < M; i++)\n        {\n            a[i] = cin.nextInt() - 1;\n            b[i] = cin.nextInt() - 1;\n            ab[i] = a[i] * (long)N + b[i];\n        }\n\n        Array.Sort(ab);\n\n        Heap<long> h = new Heap<long>();\n        h.push(s);\n\n        long ans = long.MaxValue / 2;\n        if (s >= t) ans = 0;\n\n        for (int i = 0; i < ab.Length; i++)\n        {\n            int A = (int)(ab[i] / N);\n            int B = (int)(ab[i] % N);\n            long C = d[B];\n            while (true)\n            {\n                var now = h.top.val;\n                int pos = (int)(now % N);\n                long damage = now / N;\n                if (pos < A)\n                {\n                    h.pop();\n                    continue;\n                }\n                C += damage;\n                break;\n            }\n            if (B >= t) ans = Math.Min(C, ans);\n            h.push((C * N) + B);\n        }\n        Console.WriteLine(ans);\n    }\n\n    class Heap<T> where T : IComparable\n    {\n        public HeapNode<T> top;\n\n        public Heap() { }\n\n        public void push(T val)\n        {\n            top = HeapNode<T>.meld(top, new HeapNode<T>(val));\n        }\n\n        public T pop()\n        {\n            T ret = top.val;\n            top = HeapNode<T>.meld(top.r, top.l);\n            return ret;\n        }\n\n        public void merge(Heap<T> h2)\n        {\n            top = HeapNode<T>.meld(top, h2.top);\n        }\n\n        public class HeapNode<NT> where NT : IComparable\n        {\n            public HeapNode<NT> l, r;\n            public NT val;\n\n            public HeapNode(NT _val)\n            {\n                val = _val;\n            }\n\n            public static HeapNode<NT> meld(HeapNode<NT> a, HeapNode<NT> b)\n            {\n                if (a == null) return b;\n                if (b == null) return a;\n                if (a.val.CompareTo(b.val) > 0)\n                {\n                    HeapNode<NT> temp = a;\n                    a = b;\n                    b = temp;\n                }\n                a.r = meld(a.r, b);\n                HeapNode<NT> temph = a.l;\n                a.l = a.r;\n                a.r = temph;\n                return a;\n            }\n        }\n    }\n\n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "# AOJ 2834 Dimension travel\n# Python3 2018.7.12 bal4u\n\nINF = 0x7fffffff\nimport heapq\ndef dijkstra(V, to, start, goal):\n\tdist = [INF]*V\n\tQ = []\n\tdist[start] = 0\n\theapq.heappush(Q, (0, start))\n\twhile Q:\n\t\tt, s = heapq.heappop(Q)\n\t\tif s == goal: break\n\t\tif dist[s] < t: continue\n\t\tfor e in to[s]:\n\t\t\tnt = t\n\t\t\tif e > s: nt += d[e]\n\t\t\tif dist[e] > nt:\n\t\t\t\tdist[e] = nt\n\t\t\t\theapq.heappush(Q, (nt, e))\n\treturn t\n\nimport sys\nN, M, s, t = map(int, input().split())\ns, t = s-1, t-1\nif s >= t: print(0); sys.exit(0)\nd = list(map(int, input().split()))\nto = [[i-1] if i > 0 else [] for i in range(N)]\nfor i in range(M):\n\ta, b = map(int, input().split())\n\tto[a-1].append(b-1)\nprint(dijkstra(N, to, s, t))\n\n"
  }
]