[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\ntypedef struct {\n    int from;\n    int to;\n} Magic;\n\nint dijkstra(int N, int s, int t, int* damages, Magic* magics, int M) {\n    int* dist = malloc((N+1) * sizeof(int));\n    int* visited = malloc((N+1) * sizeof(int));\n    \n    for (int i = 1; i <= N; i++) {\n        dist[i] = INT_MAX;\n        visited[i] = 0;\n    }\n    dist[s] = 0;\n    \n    for (int count = 0; count < N; count++) {\n        int u = -1, min_dist = INT_MAX;\n        for (int v = 1; v <= N; v++) {\n            if (!visited[v] && dist[v] < min_dist) {\n                min_dist = dist[v];\n                u = v;\n            }\n        }\n        \n        if (u == -1) break;\n        visited[u] = 1;\n        \n        for (int i = 0; i < M; i++) {\n            if (magics[i].from == u) {\n                int v = magics[i].to;\n                if (u > v && !visited[v] && dist[u] != INT_MAX) {\n                    int new_dist = dist[u] + damages[v];\n                    dist[v] = MIN(dist[v], new_dist);\n                }\n            }\n        }\n    }\n    \n    int result = dist[t];\n    free(dist);\n    free(visited);\n    return result;\n}\n\nint main() {\n    int N, M, s, t;\n    scanf(\"%d %d %d %d\", &N, &M, &s, &t);\n    \n    int* damages = malloc((N+1) * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &damages[i]);\n    }\n    \n    Magic* magics = malloc(M * sizeof(Magic));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &magics[i].from, &magics[i].to);\n    }\n    \n    int result = dijkstra(N, s, t, damages, magics, M);\n    printf(\"%d\\n\", result);\n    \n    free(damages);\n    free(magics);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:01:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge *edges;\nint *head;\nint edge_count = 0;\n\nvoid add_edge(int from, int to) {\n    edges[edge_count].to = to;\n    edges[edge_count].next = head[from];\n    head[from] = edge_count++;\n}\n\nint main() {\n    int N, M, s, t;\n    scanf(\"%d %d %d %d\", &N, &M, &s, &t);\n\n    int *d = (int *)malloc((N + 1) * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &d[i]);\n    }\n\n    edges = (Edge *)malloc(M * sizeof(Edge));\n    head = (int *)malloc((N + 1) * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        head[i] = -1;\n    }\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        add_edge(a, b);\n    }\n\n    int *dp = (int *)malloc((N + 1) * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        dp[i] = INT_MAX;\n    }\n    dp[t] = 0;\n\n    for (int i = t; i >= 1; i--) {\n        if (dp[i] == INT_MAX) continue;\n        for (int j = head[i]; j != -1; j = edges[j].next) {\n            int from = edges[j].to;\n            if (dp[from] > dp[i] + d[i]) {\n                dp[from] = dp[i] + d[i];\n            }\n        }\n    }\n\n    printf(\"%d\\n\", dp[s]);\n    \n    free(d);\n    free(edges);\n    free(head);\n    free(dp);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:01:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, int>;\nconst ll INF = 1LL << 60;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, M, s, t;\n    cin >> N >> M >> s >> t;\n    vector<int> d(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        cin >> d[i];\n    }\n\n    vector<vector<int>> magic(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        magic[a].push_back(b);\n    }\n\n    vector<ll> dist(N + 2, INF);\n    dist[t] = 0;\n    priority_queue<P, vector<P>, greater<P>> pq;\n    pq.emplace(0, t);\n\n    while (!pq.empty()) {\n        auto [current_dist, u] = pq.top();\n        pq.pop();\n        if (current_dist > dist[u]) continue;\n\n        // Move to lower dimensions (j < u)\n        if (u > 1) {\n            if (dist[u - 1] > dist[u] + d[u - 1]) {\n                dist[u - 1] = dist[u] + d[u - 1];\n                pq.emplace(dist[u - 1], u - 1);\n            }\n        }\n\n        // Use magic\n        for (int v : magic[u]) {\n            if (dist[v] > dist[u]) {\n                dist[v] = dist[u];\n                pq.emplace(dist[v], v);\n            }\n        }\n    }\n\n    cout << dist[s] << '\\n';\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:01:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] firstLine = br.readLine().split(\" \");\n        int N = Integer.parseInt(firstLine[0]);\n        int M = Integer.parseInt(firstLine[1]);\n        int s = Integer.parseInt(firstLine[2]);\n        int t = Integer.parseInt(firstLine[3]);\n\n        int[] d = new int[N + 1];\n        String[] dLine = br.readLine().split(\" \");\n        for (int i = 1; i <= N; i++) {\n            d[i] = Integer.parseInt(dLine[i - 1]);\n        }\n\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            String[] ab = br.readLine().split(\" \");\n            int a = Integer.parseInt(ab[0]);\n            int b = Integer.parseInt(ab[1]);\n            adj.get(a).add(b);\n        }\n\n        long[] dp = new long[N + 1];\n        Arrays.fill(dp, Long.MAX_VALUE);\n        dp[t] = 0;\n\n        for (int i = t; i >= 1; i--) {\n            if (dp[i] == Long.MAX_VALUE) continue;\n            for (int j = 1; j < i; j++) {\n                if (dp[j] > dp[i] + d[i]) {\n                    dp[j] = dp[i] + d[i];\n                }\n            }\n            for (int b : adj.get(i)) {\n                if (dp[b] > dp[i]) {\n                    dp[b] = dp[i];\n                }\n            }\n        }\n\n        System.out.println(dp[s]);\n    }\n}",
    "timestamp": "2025-08-05 22:02:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class DimensionalTravel {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        int s = Integer.parseInt(st.nextToken());\n        int t = Integer.parseInt(st.nextToken());\n        \n        int[] damages = new int[N + 1];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 1; i <= N; i++) {\n            damages[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            graph.get(a).add(b);\n        }\n        \n        int[] minDamage = new int[N + 1];\n        Arrays.fill(minDamage, Integer.MAX_VALUE);\n        minDamage[s] = 0;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        pq.offer(new int[]{s, 0});\n        \n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int currDim = curr[0];\n            int currDamage = curr[1];\n            \n            if (currDim == t) {\n                System.out.println(currDamage);\n                return;\n            }\n            \n            if (currDamage > minDamage[currDim]) continue;\n            \n            for (int i = 1; i <= N; i++) {\n                if (currDim > i) {\n                    int newDamage = currDamage + (currDim != s ? damages[i] : 0);\n                    if (newDamage < minDamage[i]) {\n                        minDamage[i] = newDamage;\n                        pq.offer(new int[]{i, newDamage});\n                    }\n                }\n            }\n            \n            for (int nextDim : graph.get(currDim)) {\n                int newDamage = currDamage + (currDim != s ? damages[nextDim] : 0);\n                if (newDamage < minDamage[nextDim]) {\n                    minDamage[nextDim] = newDamage;\n                    pq.offer(new int[]{nextDim, newDamage});\n                }\n            }\n        }\n        \n        System.out.println(-1);\n    }\n}",
    "timestamp": "2025-08-05 22:02:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    int N, M, s, t;\n    cin >> N >> M >> s >> t;\n\n    vector<int> damage(N + 1);\n    for (int i = 1; i <= N; i++) {\n        cin >> damage[i];\n    }\n\n    vector<vector<int>> magic(N + 1);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        magic[a].push_back(b);\n    }\n\n    vector<int> dist(N + 1, INF);\n    vector<int> curses(N + 1, INF);\n    dist[s] = 0;\n    curses[s] = 0;\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push({0, s});\n\n    while (!pq.empty()) {\n        auto [total_damage, curr] = pq.top();\n        pq.pop();\n\n        if (total_damage > dist[curr]) continue;\n\n        for (int next : magic[curr]) {\n            if (next <= curr) continue;\n\n            int new_damage = total_damage;\n            if (curses[next] == INF) {\n                new_damage += damage[next];\n            }\n\n            if (new_damage < dist[next]) {\n                dist[next] = new_damage;\n                curses[next] = min(curses[next], damage[next]);\n                pq.push({new_damage, next});\n            }\n        }\n\n        for (int next = curr + 1; next <= N; next++) {\n            int new_damage = total_damage;\n            if (curses[next] == INF) {\n                new_damage += damage[next];\n            }\n\n            if (new_damage < dist[next]) {\n                dist[next] = new_damage;\n                curses[next] = min(curses[next], damage[next]);\n                pq.push({new_damage, next});\n            }\n        }\n    }\n\n    cout << dist[t] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:02:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\n\nN = int(data[index])\nindex += 1\nM = int(data[index])\nindex += 1\ns = int(data[index])\nindex += 1\nt = int(data[index])\nindex += 1\n\nd = [0] * (N + 1)\nfor i in range(1, N + 1):\n    d[i] = int(data[index])\n    index += 1\n\nmagic = defaultdict(list)\n\nfor _ in range(M):\n    a = int(data[index])\n    index += 1\n    b = int(data[index])\n    index += 1\n    magic[a].append(b)\n\n# Dijkstra's algorithm\npq = [(0, s)]\ndistances = {i: float('inf') for i in range(1, N + 1)}\ndistances[s] = 0\nvisited = [False] * (N + 1)\n\nwhile pq:\n    current_damage, current_dimension = heapq.heappop(pq)\n\n    if visited[current_dimension]:\n        continue\n\n    visited[current_dimension] = True\n\n    for adj_dimension in magic[current_dimension]:\n        new_damage = current_damage + d[adj_dimension]\n        if new_damage < distances[adj_dimension]:\n            distances[adj_dimension] = new_damage\n            heapq.heappush(pq, (new_damage, adj_dimension))\n\n    for lower_dimension in range(1, current_dimension):\n        if not visited[lower_dimension]:\n            new_damage = current_damage + d[lower_dimension]\n            if new_damage < distances[lower_dimension]:\n                distances[lower_dimension] = new_damage\n                heapq.heappush(pq, (new_damage, lower_dimension))\n\nprint(distances[t])",
    "timestamp": "2025-08-13 08:34:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\nimport java.util.*;\n\npublic class DimensionalTravel {\n\n    static class Pair {\n        int dimension;\n        int damage;\n\n        Pair(int dimension, int damage) {\n            this.dimension = dimension;\n            this.damage = damage;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        int s = Integer.parseInt(st.nextToken()) - 1;\n        int t = Integer.parseInt(st.nextToken()) - 1;\n\n        int[] damage = new int[N];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            damage[i] = Integer.parseInt(st.nextToken());\n        }\n\n        List<List<Pair>> graph = new ArrayList<>();\n\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken()) - 1;\n            int b = Integer.parseInt(st.nextToken()) - 1;\n            if (a > b) {\n                graph.get(a).add(new Pair(b, 0));\n            }\n        }\n\n        for (int i = N - 1; i >= 0; i--) {\n            for (int j = i - 1; j >= 0; j--) {\n                graph.get(i).add(new Pair(j, 0));\n            }\n        }\n\n        int[] minDamage = new int[N];\n        Arrays.fill(minDamage, Integer.MAX_VALUE);\n        minDamage[s] = 0;\n\n        PriorityQueue<Pair> pq = new PriorityQueue<>(Comparator.comparingInt(p -> p.damage));\n        pq.add(new Pair(s, 0));\n\n        while (!pq.isEmpty()) {\n            Pair current = pq.poll();\n            int currentDimension = current.dimension;\n            int currentDamage = current.damage;\n\n            if (currentDamage > minDamage[currentDimension]) continue;\n\n            for (Pair neighbor : graph.get(currentDimension)) {\n                int nextDimension = neighbor.dimension;\n                int newDamage = currentDamage + (currentDimension != s ? damage[nextDimension] : 0);\n                if (newDamage < minDamage[nextDimension]) {\n                    minDamage[nextDimension] = newDamage;\n                    pq.add(new Pair(nextDimension, newDamage));\n                }\n            }\n        }\n\n        System.out.println(minDamage[t]);\n    }\n}",
    "timestamp": "2025-08-13 08:35:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int from;\n    int to;\n} Magic;\n\nint compare(const void *a, const void *b) {\n    return ((Magic *)a)->from - ((Magic *)b)->from;\n}\n\nint main() {\n    int N, M, s, t;\n    scanf(\"%d %d %d %d\", &N, &M, &s, &t);\n    \n    int *d = (int *)malloc((N + 1) * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &d[i]);\n    }\n\n    Magic *magics = (Magic *)malloc(M * sizeof(Magic));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &magics[i].from, &magics[i].to);\n    }\n\n    qsort(magics, M, sizeof(Magic), compare);\n\n    int *minDamage = (int *)malloc((N + 1) * sizeof(int));\n    for (int i = 0; i <= N; i++) {\n        minDamage[i] = INT_MAX;\n    }\n    \n    minDamage[s] = 0;\n\n    for (int i = s; i >= t; i--) {\n        if (minDamage[i] == INT_MAX) continue;\n        for (int j = i - 1; j >= t; j--) {\n            minDamage[j] = minDamage[i] + d[j];\n        }\n        for (int k = 0; k < M; k++) {\n            int from = magics[k].from;\n            int to = magics[k].to;\n            if (from == i && to <= i) {\n                if (minDamage[to] > minDamage[i] + d[to]) {\n                    minDamage[to] = minDamage[i] + d[to];\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", minDamage[t]);\n    \n    free(d);\n    free(magics);\n    free(minDamage);\n    return 0;\n}",
    "timestamp": "2025-08-13 08:35:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\n\ndef solve_dimensional_travel():\n    N, M, s, t = map(int, input().split())\n    damages = list(map(int, input().split()))\n    \n    # Create adjacency list for magic teleports\n    graph = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n    \n    # Priority queue for Dijkstra's algorithm\n    pq = [(0, s)]\n    \n    # Track minimum damage to each dimension with curse status tracking\n    dist = [[float('inf')] * (N+1) for _ in range(N+1)]\n    dist[s][s] = 0\n    \n    while pq:\n        total_damage, current = heappop(pq)\n        \n        if current == t:\n            return total_damage\n        \n        # Try moving to lower dimensions\n        for j in range(1, current):\n            if dist[current][j] > total_damage + damages[j-1]:\n                dist[current][j] = total_damage + damages[j-1]\n                heappush(pq, (dist[current][j], j))\n        \n        # Try magic teleports\n        for next_dim in graph[current]:\n            if next_dim >= current:\n                continue\n            \n            new_damage = total_damage + damages[next_dim-1]\n            if dist[current][next_dim] > new_damage:\n                dist[current][next_dim] = new_damage\n                heappush(pq, (new_damage, next_dim))\n    \n    return -1  # Unreachable\n\nprint(solve_dimensional_travel())",
    "timestamp": "2025-08-13 08:35:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    s = int(data[idx])\n    idx += 1\n    t = int(data[idx])\n    idx += 1\n    \n    d = list(map(int, data[idx:idx+N]))\n    idx += N\n    \n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a = int(data[idx])\n        idx += 1\n        b = int(data[idx])\n        idx += 1\n        adj[a].append(b)\n    \n    # Dijkstra's algorithm\n    INF = 1 << 60\n    dist = [INF] * (N + 1)\n    dist[s] = 0\n    heap = []\n    heapq.heappush(heap, (0, s))\n    \n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if u == t:\n            break\n        if current_dist > dist[u]:\n            continue\n        \n        # Normal moves (i to j where i > j)\n        for v in range(1, u):\n            if dist[v] > current_dist + d[v-1]:\n                dist[v] = current_dist + d[v-1]\n                heapq.heappush(heap, (dist[v], v))\n        \n        # Magic moves\n        for v in adj[u]:\n            if dist[v] > current_dist + d[v-1]:\n                dist[v] = current_dist + d[v-1]\n                heapq.heappush(heap, (dist[v], v))\n    \n    print(dist[t])\n\nsolve()",
    "timestamp": "2025-08-13 08:35:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, M, s, t;\n    cin >> N >> M >> s >> t;\n    s--; // Convert to 0-based index\n    t--;\n\n    vector<int> d(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> d[i];\n    }\n\n    vector<vector<pair<int, int>>> graph(N);\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--; // Convert to 0-based index\n        graph[a].push_back({b, d[b]});\n    }\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    vector<int> min_damage(N, INT_MAX);\n\n    pq.push({0, s});\n    min_damage[s] = 0;\n\n    while (!pq.empty()) {\n        int curr_damage = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (curr_damage > min_damage[u]) continue;\n\n        for (auto &[v, damage_at_v] : graph[u]) {\n            if (min_damage[v] > curr_damage + damage_at_v) {\n                min_damage[v] = curr_damage + damage_at_v;\n                pq.push({min_damage[v], v});\n            }\n        }\n    }\n\n    cout << min_damage[t] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:47:00"
  }
]