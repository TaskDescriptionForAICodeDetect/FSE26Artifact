[
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n    short table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nshort first_table[10][10],max_size[10][10];\n\n\nbool rangeCheck(int row,int col){\n    if(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n    else{\n        return false;\n    }\n}\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n    if(info.num == ans)return;\n\n    if(base_row == H){\n        ans = info.num;\n        return;\n    }\n\n    if(info.table[base_row][base_col] == -1){\n\n        if(base_col == W-1){\n            recursive(info,base_row+1,0,pre_must_add);\n        }else{\n            recursive(info,base_row,base_col+1,pre_must_add);\n        }\n        return;\n    }\n\n    int new_num = 0;\n    int add = max_size[base_row][base_col]-1;\n    if(info.table[base_row+add][base_col+add] == 0){\n        new_num = 1;\n    }\n\n    if(new_num == 0){\n\n        if(base_col != W-1){\n            recursive(info,base_row,base_col+1,pre_must_add);\n        }else{\n            recursive(info,base_row+1,0,pre_must_add);\n        }\n    }else{\n\n        if(info.table[base_row][base_col] != 0){\n\n            if(base_col != W-1){\n                recursive(info,base_row,base_col+1,pre_must_add);\n            }else{\n                recursive(info,base_row+1,0,pre_must_add);\n            }\n        }\n\n        for(int i = 0; i < max_size[base_row][base_col]; i++){\n            for(int k = 0; k < max_size[base_row][base_col]; k++){\n                info.table[base_row+i][base_col+k]++;\n            }\n        }\n\n        int must_add = 0;\n        bool FLG = false;\n\n        for(int row = base_row; row <= base_row; row++){\n            for(int col = base_col+add; col < W; col++){\n                if(info.table[row][col] == 0 && first_table[row][col] == 1){\n                    must_add++;\n                }else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n                    FLG = true;\n                }\n            }\n        }\n\n        for(int row = base_row+1; row < H; row++){\n            for(int col = 0; col < W; col++){\n                if(info.table[row][col] == 0 && first_table[row][col] == 1){\n                    must_add++;\n                }else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n                    FLG = true;\n                }\n            }\n        }\n\n\n        if(FLG)must_add++;\n\n        info.num++;\n\n        if(info.num+must_add < ans){\n            if(base_col != W-1){\n                recursive(info,base_row,base_col+1,must_add);\n            }else{\n                recursive(info,base_row+1,0,must_add);\n            }\n        }\n    }\n}\n\n\nvoid func(){\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            scanf(\"%d\",&first_table[row][col]);\n            first_table[row][col] -= 1;\n        }\n    }\n\n    bool FLG;\n    int size;\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            if(first_table[row][col] == -1){\n                max_size[row][col] = 0;\n            }else{\n                size = 1;\n\n                FLG = true;\n\n                while(true){\n                    for(int i = 0; i < size; i++){\n                        for(int k = 0; k < size; k++){\n                            if(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n                                FLG = false;\n                                break;\n                            }\n                        }\n                        if(!FLG)break;\n                    }\n                    if(!FLG){\n                        size -= 1;\n                        break;\n                    }\n                    size++;\n                }\n\n                max_size[row][col] = size;\n\n                for(int calc_size = 1; calc_size <= size; calc_size++){\n                    for(int i = 0; i < calc_size; i++){\n                        for(int k = 0; k < size; k++){\n                            first_table[row+i][col+k]++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    Info start;\n    start.num = 0;\n    int pre_must_add = 0;\n    FLG = false;\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            if(first_table[row][col] == -1){\n                start.table[row][col] = -1;\n            }else{\n                if(first_table[row][col] == 1){\n                    pre_must_add++;\n                }else{\n                    FLG = true;\n                }\n                start.table[row][col] = 0;\n            }\n        }\n    }\n\n    if(FLG)pre_must_add++;\n\n    ans = BIG_NUM;\n\n    recursive(start,0,0,pre_must_add);\n\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n\n    for(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n    while(true){\n        scanf(\"%d %d\",&W,&H);\n        if(W == 0 && H == 0)break;\n\n        func();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<map>\n#define MAX_W 10\n#define INF 1E9\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nconst ull B = 100000007;\nint w, h; \nint s[MAX_W][MAX_W]; //可延伸的最大正方形邊長\nint contain[MAX_W][MAX_W];\nbool same[MAX_W][MAX_W][MAX_W][MAX_W];\nint limit;\nint ct;\n\nstruct P{\n\tint x, y, size;\n\tP() {}\n\tP(int x, int y, int size) : x(x), y(y), size(size) {}\n\tbool operator < (const P& other) const{\n\t\treturn size < other.size;\n\t}\n};\nvoid init(vector<int>& f){\n\tmemset(contain, 0, sizeof(contain));\n\tmemset(same, false, sizeof(same));\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\ts[i][j] = (f[i] >> (w - 1 - j)) & 1;\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tfor(int k = 0;; k++){\n\t\t\t\tbool ok = true;\n\t\t\t\tif(i + k < h && j + k < w){\n\t\t\t\t\tfor(int l = 0; ok && l <= k; l++){\n\t\t\t\t\t\tif(s[i + k][j + l] == 0 || s[i + l][j + k] == 0) ok = false;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\ts[i][j] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int a = 0; a < s[i][j]; a++){\n\t\t\t\tfor(int b = 0; b < s[i][j]; b++){\n\t\t\t\t\tcontain[i + a][j + b]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int a = 0; a < s[i][j] * s[i][j]; a++){\n\t\t\t\tint x1 = i + a / s[i][j], y1 = j + a % s[i][j];\n\t\t\t\tfor(int b = 0; b < s[i][j] * s[i][j]; b++){\n\t\t\t\t\tint x2 = i + b / s[i][j], y2 = j + b % s[i][j];\n\t\t\t\t\tsame[x1][y1][x2][y2] = same[x2][y2][x1][y1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint hstar(vector<int> f){\n\t//選取盡量多的點，其中每個集合最多只能有一個點被選中\n\tvector<P> ps, X;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif((f[i] >> (w - 1 - j)) & 1){\n\t\t\t\tps.push_back(P(i, j, contain[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(ps.begin(), ps.end());\n\tfor(int i = 0; i < ps.size(); i++){\n\t\tbool ok = true;\n\t\tint x1 = ps[i].x, y1 = ps[i].y;\n\t\tfor(int j = 0; j < X.size() && ok; j++){\n\t\t\tint x2 = X[j].x, y2 = X[j].y;\n\t\t\tif(same[x1][y1][x2][y2]) ok = false;\n\t\t}\n\t\tif(ok) X.push_back(ps[i]);\n\t}\n\treturn X.size();\n}\nint dfs(int num, vector<int> f, int idx){\n\tif(num + hstar(f) > limit) return INF;\n\t\n\tct++;\n\tvector<int> reset(f.begin(), f.end());\n\tfor(; idx < w * h; idx++){\n\t\tint i = idx / w, j = idx % w;\n\t\tint k = s[i][j];\n\t\tif(k > 0){\n\t\t\tint tmp = ((1 << k) - 1) << (w - j - k), n = 0;\n\t\t\tfor(int m = 0; m < k; m++){\n\t\t\t\tif((f[i + m] & (~tmp)) == f[i + m]) n++;\n\t\t\t\tf[i + m] &= ~tmp;\n\t\t\t}\n\t\t\tif(n < k){\n\t\t\t\tif(dfs(num + 1, f, idx + 1) < INF) return num;\n\t\t\t}\n\t\t\tfor(int m = 0; m < k; m++) f[i + m] = reset[i + m];\n\t\t\tif(((f[i] >> (w - 1 - j)) & 1) && n < k) break;\n\t\t}\n\t}\t\n\tbool check = true;\n\tfor(int i = 0; i < h && check; i++) check &= (f[i] == 0);\n\treturn (check ? num : INF);\n}\nint solve(vector<int>& f){\n\tinit(f);\n\tct = 0;\n\tfor(limit = hstar(f);; limit++){\n\t\tif(dfs(0, f, 0) < INF) return limit;\n\t}\n}\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tvector<int> f(h, 0);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tf[i] = 0;\n\t\t\tint a;\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> a;\n\t\t\t\tf[i] = (f[i] << 1) | a;\n\t\t\t}\n\t\t}\n\t\tcout << solve(f) << endl;\n\t\t// cout << \"ct = \" << ct << \"\\n\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct state {\n\tvector<short> b;\n\tint dist, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.dist + s1.cost > s2.dist + s2.cost;\n}\nint H, W, a[12][12], cnt, xa[10009], ya[10009], xb[10009], yb[10009], popcount[1033];\nint main() {\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tpopcount[j] = popcount[j - (1 << i)] + 1;\n\t\t}\n\t}\n\twhile (cin >> W >> H, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) {\n\t\t\t\t\t\tif (k - i != l - j) continue;\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor (int x = i; x < k; x++) {\n\t\t\t\t\t\t\tfor (int y = j; y < l; y++) {\n\t\t\t\t\t\t\t\tif (a[x][y] == 0) flag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\txa[cnt] = i;\n\t\t\t\t\t\t\tya[cnt] = j;\n\t\t\t\t\t\t\txb[cnt] = k;\n\t\t\t\t\t\t\tyb[cnt] = l;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> que;\n\t\tint scnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (a[i][j] == 1) scnt++;\n\t\t\t}\n\t\t}\n\t\tque.push(state{ vector<short>(H, 0), 0, scnt });\n\t\tbool flag = false;\n\t\twhile (!que.empty() && !flag) {\n\t\t\tstate u = que.top(); que.pop();\n\t\t\tfor (int i = 0; i < cnt && !flag; i++) {\n\t\t\t\tvector<short> z = u.b;\n\t\t\t\tfor (int j = xa[i]; j < xb[i]; j++) {\n\t\t\t\t\tz[j] |= (1 << yb[i]) - (1 << ya[i]);\n\t\t\t\t}\n\t\t\t\tint rcnt = 0;\n\t\t\t\tfor (int j = 0; j < H; j++) rcnt += popcount[z[j]];\n\t\t\t\trcnt = scnt - rcnt;\n\t\t\t\tif (rcnt == 0) {\n\t\t\t\t\tcout << u.dist + 1 << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tque.push(state{ z, u.dist + 1, rcnt });\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint dx[] = {-1, -1, 0};\nint dy[] = {-1, 0, 0};\n\ntypedef bitset<100> Panels;\n\nint W, H, field[10][10];\nvector<Panels> carpets[10][10];\nint dp[10][10];\n\nbool canCover(int x, int y, int s)\n{\n\tfor(int i=y; i<y+s; i++)\n\tfor(int j=x; j<x+s; j++)\n\t\tif(field[j][i] == 0) return false;\n\n\treturn true;\n}\n\nPanels calcCovered(int x, int y, int s)\n{\n\tPanels res;\n\tfor(int i=y; i<y+s; i++)\n\tfor(int j=x; j<x+s; j++) {\n\t\tres.set(j + i * W, 1);\n\t}\n\n\treturn res;\n}\n\npair<Panels, int> calcInit(Panels& flawless)\n{\n\tint num = 0;\n\tPanels res = flawless;\n\n\tint cnt[100] = {0};\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++) {\n\t\tif(carpets[j][i].size() == 0) continue;\n\t\tfor(int k=0; k<100; k++)\n\t\t\tif(carpets[j][i][0][k]) cnt[k]++;\n\t}\n\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++) {\n\t\tif(carpets[j][i].size() == 0) continue;\n\t\tfor(int k=0; k<100; k++) {\n\t\t\tif(carpets[j][i][0][k] && cnt[k] == 1) {\n\t\t\t\tres |= carpets[j][i][0];\n\t\t\t\tcarpets[j][i].clear();\n\t\t\t\t++num;\n\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n\t}\n\n\treturn make_pair(res, num);\n}\n\n\nvoid remove(int x, int y)\n{\n\tif(carpets[x][y].size() == 0) return;\n\n\tint S = (int)sqrt(carpets[x][y][0].count());\n\tfor(int i=y; i<y+S; i++)\n\tfor(int j=x; j<x+S; j++) {\n\t\tif(j == x && i == y) continue;\n\t\tif(carpets[j][i].size() == 0) continue;\n\n\t\tint T = (int)sqrt(carpets[j][i][0].count());\n\t\tif(x + S >= j + T && y + S >= i + T) {\n\t\t\tcarpets[j][i].clear();\n\t\t}\n\t\t\n\t}\n}\n\nint ans;\nvoid dfs(int x, int y, int u, Panels f)\n{\n\tif(f.count() == W*H) {\n\t\tans = u;\n\t\treturn;\n\t}\n\n\tif(u + 1 >= ans) return;\n\n\tif(y == H) return;\n\n\tint tx = x + 1;\n\tint ty = y;\n\n\tif(tx == W) { tx = 0; ty++; }\n\tint S = carpets[x][y].size();\n\n\tif(f[x + y * W]) dfs(tx, ty, u, f);\n\t\n\tfor(int i=0; i<S; i++) {\n\t\tPanels& c = carpets[x][y][i];\n\t\tPanels t = f;\n\t\tt |= c;\n\n\t\tif(t != f) {\n\t\t\tdfs(tx, ty, u + 1, t);\n\t\t}\n\t\telse break;\n\t}\n}\n\nint main()\n{\n\twhile(cin >> W >> H, (W||H)) {\n\t\tPanels init;\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++) {\n\t\t\tcin >> field[j][i];\n\t\t\tcarpets[j][i].clear();\n\t\t\tdp[j][i] = 1;\n\n\t\t\tif(field[j][i] == 0) init.set(j + i * W, 1);\n\t\t}\n\n\t\tint S = min(W, H);\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++) {\n\t\t\tint M = 1;\n\t\t\tfor(int k=0; k<3; k++) {\n\t\t\t\tint tx = j + dx[k] , ty = i + dy[k];\n\t\t\t\tif(tx < 0 || ty < 0) continue;\n\t\t\t\tdp[j][i] = max(dp[j][i], dp[tx][ty] - 1);\n\n\t\t\t\tif(carpets[tx][ty].size() != 0) \n\t\t\t\tdp[j][i] = max(dp[j][i], (int)sqrt(carpets[tx][ty][0].count()) - 1);\n\t\t\t}\n\t\t\tfor(int k=S; k>=dp[j][i]; k--) {\n\t\t\t\tif(i + k > H || j + k > W) continue;\n\t\t\t\tif(canCover(j, i, k)) {\n\t\t\t\t\tcarpets[j][i].push_back(calcCovered(j, i, k));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++) {\n\t\t\tremove(j, i);\n\t\t}\n\n\t\tpair<Panels, int> in = calcInit(init);\n\t\t\n\t\tinit = in.first;\n\t\tans = (1<<24);\n\t\tdfs(0, 0, in.second, init);\n\n\t\tcout << ans << endl;\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Carpet {\n  int y, x, size;\n  bool contain(const auto& c) const {\n    if(c.x < x) return false;\n    if(x + size < c.x + c.size) return false;\n    if(c.y < y) return false;\n    if(y + size < c.y + c.size) return false;\n    return true;\n  }\n};\n\nint W, H;\nint P[12][12];\nint S[12][12];\nint L[12][12];\n\nint sum(int y1, int x1, int y2, int x2) {\n  return S[y2][x2] - S[y2][x1-1] - S[y1-1][x2] + S[y1-1][x1-1];\n}\n\nbool full(auto y1, auto x1, auto y2, auto x2) {\n  return sum(y1, x1, y2, x2) == (y2 - y1 + 1) * (x2 - x1 + 1);\n};\n\nint greedy() {\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] = P[i][j];\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] += S[i][j-1];\n  for(auto j = 1; j <= W; ++j) for(auto i = 1; i <= H; ++i) S[i][j] += S[i-1][j];\n\n  vector<Carpet> carpet;\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) {\n    auto size = -1;\n    for(auto k = 0; k < 10; ++k) {\n      if(H < i+k || W < j+k) break;\n      if(!full(i, j, i+k, j+k)) break;\n      size = k;\n    }\n    if(~size) carpet.push_back({i, j, size});\n  }\n\n  vector<bool> removed(carpet.size());\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) for(auto j = 0; j < carpet.size(); ++j) if(!removed[j]) if(i != j) if(carpet[i].contain(carpet[j])) removed[j] = true;\n\n  int res = 0;\n\n  vector<vector<int>> cnt(H+2, vector<int>(W+2));\n  vector<vector<int>> id(H+2, vector<int>(W+2));\n  for(auto k = 0; k < carpet.size(); ++k) if(!removed[k]) {\n    auto c = carpet[k];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) {\n      ++cnt[i][j];\n      id[i][j] = k;\n    }\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(cnt[i][j] == 1) if(!removed[id[i][j]]) {\n    removed[id[i][j]] = true;\n    ++res;\n    auto c = carpet[id[i][j]];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) P[i][j] = 0;\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) L[i][j] = 0;\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) L[carpet[i].y][carpet[i].x] = carpet[i].size + 1;\n\n  return res;\n}\n\nbool dfs(int sy, int sx, int depth, int limit) {\n  int y, x;\n  for(y = sy; y <= H; ++y) {\n    for(x = (y==sy ? sx : 1); x <= W; ++x) {\n      if(L[y][x]) break;\n      if(P[y][x] == 1) return false;\n    }\n    if(L[y][x]) break;\n  }\n  if(y == H+1 || x == W+1) return true;\n  if(depth > limit) return false;\n  int dup[12][12];\n  memcpy(dup, P, 12*12*sizeof(int));\n  if(P[y][x] == 0) {\n    auto ny = y, nx = x + 1;\n    if(W < x) {++ny; nx = 1;}\n    if(dfs(ny, nx, depth, limit)) return true;\n  }\n  auto cnt = 0;\n  for(auto i = y; i < y + L[y][x]; ++i) for(auto j = x; j < x + L[y][x]; ++j) if(P[i][j] == 1) {\n    P[i][j] = 0;\n    ++cnt;\n  }\n  if(cnt == 0) return false;\n  if(dfs(y, x, depth + 1, limit)) return true;\n  memcpy(P, dup, 12*12*sizeof(int));\n  return false;\n}\n\nint solve() {\n  auto fix = greedy();\n  for(auto i = 0; i <= 100; ++i) {\n    if(dfs(1, 1, 0, i)) return fix + i;\n  }\n  assert(false);\n}\n\nint main() {\n  while(cin >> W >> H, W | H) {\n    for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> P[i][j];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<functional>\n\n#define N 16\n#define INF (1<<27)\n\nusing namespace std;\n\nint maxSizes[N][N];\nint oneCount;\nmultimap<int,int,greater<int> > squareSizes;\nint bestAns = INF;\nint minHW;\nbool bGreedy;\n\nint getHeuristic(int H, int W, int M[N][N])\n{\n  if(squareSizes.empty())return 0;\n  multimap<int,int>::iterator it=squareSizes.begin();\n  int maxSize = it->first;\n  if(maxSize==0)return 0;\n  maxSize *= maxSize;\n  return (oneCount / maxSize) + (oneCount%maxSize>0);\n}\n\nvoid calc(int H, int W, int M[N][N]){\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 1) oneCount++;\n      int size = 0;\n      for(size = 1; size <= minHW; ++size){\n\tfor(int m = i; m<i+size; m++){\n\t  for(int n = j; n<j+size; n++){\n\t    if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t      --size;\n\t      goto next;\n\t    }\n\t  }\n\t}\n\tif(i+size>=H||j+size>=W)break;\n      }\n      next:;\n      maxSizes[i][j] = size;\n      squareSizes.insert(make_pair(size,0));\n    }\n  }\n  return ;\n}\n\nvoid solve(int H, int W, int pos, int M[N][N], int depth){\n  /*\n  printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W, getHeuristic(H,W,M));\n  for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n      if(l>0)putchar(' ');\n      printf(\"%2d\", M[k][l]);\n    }\n    putchar('\\n');\n  }\n  putchar('\\n');\n  */\n\n  // completed.\n  if(oneCount==0){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic(H,W,M)>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < H*W; ++p){\n    int i = p / W;\n    int j = p % W;\n    if( M[i][j] == 0 ){\n      continue;\n    }else if( bGreedy ? (M[i][j] == 1) : (M[i][j] >= 1) ){\n      int size = maxSizes[i][j];\n      bool valid=false;\n      for(int m = i; m<size+i; m++){\n\tfor(int n = j; n<size+j; n++){\n\t  if(M[m][n]==1){\n\t    valid=true;\n\t    --oneCount;\n\t    M[m][n]=depth;\n\t  }\n\t}\n      }\n      if( valid ){\n\tsquareSizes.erase( squareSizes.find( size ) );\n\tsolve(H,W,p+1,M,depth+1);\n\tsquareSizes.insert(make_pair(size,0));\n      }\n      for(int m = i; m<size+i; m++){\n\tfor(int n = j; n<size+j; n++){\n\t  if( M[m][n] == depth ){\n\t    ++oneCount;\n\t    M[m][n]=1;\n\t  }\n\t}\n      }\n      if( M[i][j] > 1 )\n\tsolve(H,W,p+1,M,depth);\n      return ;\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int W,H;\n    int M[N][N];\n\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    oneCount = 0;\n    squareSizes.clear();\n    calc(H,W,M);\n\n    bGreedy=true;\n    solve(H,W,0,M,2);\n    bGreedy=false;\n    solve(H,W,0,M,2);\n\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\t\t\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\tint remain=0;\n\t\trep(i,h) remain+=popcount(board[i]);\n\t\tmin_res=min(20,remain);\n\t\tint ans=dfs(0,0,0,remain);\n\t\tif(ans==inf) ans=21;\t\t\n\t\tprintf(\"%d\\n\",ans+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<unordered_set>\n#include<bitset>\n\nusing namespace std;\n\nint main(){\n  for(int W,H;cin>>W>>H,W|H;){\n    int P[12][12]={};\n    bitset<100> is;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>P[i][j];\n\tis[i*10+j]=P[i][j];\n      }\n    }\n    bitset<100>b[100];\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tb[i*10+j].set();\n\tint k;\n\tfor(k=0;k+i<=10&&k+j<=10;k++){\n\t  for(int l=0;l<k;l++){\n\t    for(int m=0;m<k;m++){\n\t      if(!P[i+l][j+m]){\n\t\tgoto end;\n\t      }\n\t    }\n\t  }\n\t}\n      end:\n\tfor(int n=0;n<k-1;n++){\n\t  for(int o=0;o<k-1;o++){\n\t    b[i*10+j][(i+n)*10+j+o]=false;\n\t  }\n\t}\n      }\n    }\n    unordered_set<bitset<100> > s[123][123];\n    s[0][0].insert(is);\n    for(int i=0;;i++){\n      for(int j=0;j<=100;j++){\n\tfor(auto e:s[i][j]){\n\t  if(e.none()){\n\t    cout<<i<<endl;\n\t    goto next;\n\t  }\n\t  if(j<100){\n\t    s[i+1][j+1].insert(e&b[j]);\n\t    if(e[j]==false){\n\t      s[i][j+1].insert(e);\n\t    }\n\t  }\n\t}\n      }\n    }\n  next:\n    ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint board[111][111];\nbool used[11111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    rep(i,h)rep(j,w){\n      cin>>board[i][j];\n    }\n    vector<int> g[30101];\n    rep(ti,h)rep(tj,w)rep(si,ti+1)rep(sj,tj+1){\n      if((ti-si)!=(tj-sj))continue;\n      bool ok=true;\n      repl(i,si,ti+1)repl(j,sj,tj+1){\n        if(!board[i][j])ok=false;\n      }\n      if(ok){\n        int cv=si*1111+sj*111+ti*11+tj;\n        repl(i,si,ti+1)repl(j,sj,tj+1){\n          int bv=12345+i*11+j;\n          g[cv].pb(bv); g[bv].pb(cv);\n        }\n      }\n    }\n    memset(used,0,sizeof(used));\n    int res=0;\n    rep(i,h)rep(j,w){\n      if(board[i][j]==1&&!used[i*11+j]){\n        res++;\n        int maxv=-1,maxc=0;\n        each(v,g[i*11+j+12345]){\n          int cnt=0;\n\n          each(nv,g[v]){\n            if(!used[nv-12345])cnt++;\n          }\n          if(maxc<cnt){\n            maxc=cnt;\n            maxv=v;\n          }\n        }\n  \n        each(v,g[maxv]){\n          used[v-12345]=true;\n        }\n      }\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans;\nint first_table[10][10],max_size[10][10];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10]){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\t//printf(\"ans:%d\\n\",ans);\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\tcopyTable(next_info,info.table);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tcopyTable(next_info,info.table);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\t\t\tInfo next_not;\n\n\t\t\tcopyTable(next_not,info.table);\n\t\t\tnext_not.num = info.num;\n\n\t\t\tint must_add = 0;\n\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next_not.num+must_add < ans){\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcopyTable(next_info,info.table);\n\t\tnext_info.num = info.num+1;\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(next_info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_info,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint w, h, d[12][12], ans;\n\nvoid solve(int x, int y, int c){\n\tif(ans <= c) return;\n\tif(16 < ans && ans < INF) return;\n\tif(x == w && y == h-1){\n\t\tchmin(ans, c);\n\t\treturn ;\n\t}\n\tif(x == w){\n\t\ty ++;\n\t\tx = 0;\n\t}\n\tif(d[y][x] != 1) solve(x+1, y, c);\n\tif(ans <= c) return;\n\tif(16 < ans && ans < INF) return;\n\tif(d[y][x] != 0){\n\t\tint r = 1;\n\t\tfor(;;r++){\n\t\t\tint f = 1;\n\t\t\tREP(i, r)REP(j, r) if(d[y+i][x+j] == 0) f = 0;\n\t\t\tif(!f) break;\n\t\t}\n\t\tr --;\n\t\t\n\t\t// check pruning\n\t\tint pos[3][2] = {{y-1,x-1},{y-1,x},{y,x-1}};\n\t\tREP(k, 3){\n\t\t\tif(pos[k][0] < 0 || pos[k][1] < 0) continue;\n\t\t\tint f = 1;\n\t\t\tREP(i, r+1)REP(j, r+1) if(d[pos[k][0]+i][pos[k][1]+j] == 0) f = 0;\n\t\t\tif(f) return;\n\t\t}\n\t\tvector<pii> ch;\n\t\tREP(i, r)REP(j, r){\n\t\t\tif(d[y+i][x+j] == 1) ch.push_back(pii(y+i, x+j));\n\t\t\td[y+i][x+j] = -1;\n\t\t}\n\t\tif(ch.empty()) return ;\n\t\tsolve(x+1, y, c+1);\n\t\tREP(i, ch.size()) d[ch[i].first][ch[i].second] = 1;\n\t}\n\t\n}\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> w >> h, w){\n\t\tmemset(d, 0, sizeof(d));\n\t\tREP(i, h)REP(j, w) cin >> d[i][j];\n\t\tans = INF;\n\t\tsolve(0, 0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d){\n\t\n\tif(y==h && x==0){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d>min_res) return inf;\n\n\tint ny=y,nx=x+1;\n\tif(nx==w) ny++,nx=0;\t\n\n\tif(len[y][x]==0) return dfs(ny,nx,d);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(ny,nx,d));\n\n\tint tboard[10];\n\trep(i,y,y+len[y][x]) tboard[i]=board[i];\n\n\tbool ok=false;\n\tint mask=((1<<len[y][x])-1)<<x;\n\trep(a,y,y+len[y][x]){\n\t\tif((board[a]&mask)!=0) ok=true;\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(ok) chmin(ret,dfs(ny,nx,d+1));\n\t\n\trep(i,y,y+len[y][x]) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(cin >> w >> h,w){\n\t\tclr(board,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tboard[i]|=(tmp<<j);\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\trep(a,i,h)rep(b,j,w) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w)rep(a,i,i+len[i][j])rep(b,j,j+len[i][j]) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\t//while(dfs(0,0,0)==inf) min_res++;\n\t\tcout << dfs(0,0,0)+add << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\n\nint H, W;\nvector<pair<int, int> > P;\nmap<pair<int, int>, vector<int> > M;\nvector<vector<int> > B;\nvector<tuple<int, int, int> > S;\n\nvoid dfs(int pos, int sum, int &res){\n  // cout << P[pos] <<\" \" << B << \" \" << pos << \" \" << sum << endl;\n  if (pos == int(P.size())){\n    // if (sum < res) cout << sum << endl;\n    res = min(res, sum);\n  } else if (sum >= res){\n    return;\n  } else if (B[P[pos].first][P[pos].second] == 0){\n    dfs(pos + 1, sum, res);      \n  } else {\n    int count   = 0;\n    int largest = get<2>(S[0]);\n    REP(h, H) REP(w, W) count += B[h][w];\n    if (sum + (count + largest * largest - 1) / (largest * largest) >= res) return;\n    \n    vector<vector<int> > OLD_B = B;\n    for (int ind : M[P[pos]]){\n      int h, w, d;\n      tie(h, w, d) = S[ind];\n      REP(i, d) REP(j, d) B[h + i][w + j] = 0;\n      dfs(pos + 1, sum + 1, res);\n      REP(i, d) REP(j, d) B[h + i][w + j] = OLD_B[h + i][w + j];\n    }\n  }\n}\n\nint main(){\n  while (cin >> W >> H && W + H){\n    vector<vector<int> > board(H, vector<int>(W));\n    vector<tuple<int, int, int> > squares;\n\n    REP(h, H) REP(w, W) cin >> board[h][w];\n    REP(h, H) REP(w, W) REP2(d, 1, H + 1) if (h + d <= H && w + d <= W){\n      bool ok = true;\n      REP(i, d) REP(j, d) if (board[h + i][w + j] == 0) ok = false;\n      if (ok) squares.push_back(make_tuple(h, w, d));\n    }\n    \n    vector<int> use(squares.size(), true);\n    REP(i, squares.size()) {\n      REP(j, squares.size()) if (use[i] && use[j] && i != j){\n        int h1, h2, w1, w2, d1, d2;\n        tie(h1, w1, d1) = squares[j];\n        tie(h2, w2, d2) = squares[i];\n        if (h1 <= h2 && w1 <= w2 && h2 + d2 <= h1 + d1 && w2 + d2 <= w1 + d1){\n          use[i] = false;\n        }\n      }\n    }\n    S.clear();\n    P.clear();\n    M.clear();\n    B = board;\n    REP(i, squares.size()) if (use[i]) S.push_back(squares[i]);\n    REP(h, H) REP(w, W) if (board[h][w] == 1) P.push_back(make_pair(h, w));\n    REP(i, S.size()) REP(j, S.size()) if (j > 0){\n      if (get<2>(S[j - 1]) < get<2>(S[j])) swap(S[j - 1], S[j]);\n    }\n    \n    REP(i, S.size()){\n      int h, w, d;\n      tie(h, w, d)  = S[i];\n      REP(j, d) REP(k, d) M[make_pair(h + j, w + k)].push_back(i);\n    }\n    int res = S.size();\n    dfs(0, 0, res);\n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nint H,W,mincost;\nint P[10][10],bin[10],bc[(1<<10)];\nint put[10][10],weight[10][10],counter[10][10];\n\nbool can_put(int len,int x,int y){\n  REP(i,y,y+len)REP(j,x,x+len) if( !P[i][j] ) return false;\n  return true;\n}\n\nvoid dfs(int cur,int cost,int remain){\n\n  if( cost >= mincost ) return;\n  //if( cost + ((remain>0)?1:0) >= mincost ) return;\n\n\n  if( cur >= H*W ) {\n    mincost = min(mincost,cost);\n    return;\n  }\n\n  int x = cur % W, y = cur / W;\n  //if( cost + max(0,weight[y][x]-2) >= mincost ) return;\n\n  if( !P[y][x] || counter[y][x] == 1 ) {\n    dfs(cur+1,cost,remain);\n    return;\n  }\n\n  if( (bin[y]>>x) & 1 ) dfs(cur+1,cost,remain);\n\n  int len = put[y][x];\n  int bitmask = ((1<<len)-1)<<x;\n  int buf[len];\n  int add = 0, nremain = remain;\n  rep(j,len) {\n    buf[j] = bin[y+j];\n    add += len - bc[((1<<len)-1)&(bin[y+j]>>x)];\n    bin[y+j] |= bitmask;\n  }\n  nremain -= add;\n  if( add ) dfs(cur+1,cost+1,nremain);\n  rep(j,len) bin[y+j] = buf[j];\n\n}\n\nint par[110];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint find(int x){\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\ninline void unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = par[y];\n}\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\nint main(){\n\n  rep(i,(1<<10)) bc[i] = __builtin_popcount(i);\n\n  while( scanf(\"%d%d\",&W,&H), W | H ){\n\n    rep(i,H){\n      bin[i] = 0;\n      rep(j,W){\n        cin >> P[i][j];\n        put[i][j] = 0;\n      }\n    }\n\n\n    rep(i,H*W) par[i] = i;\n\n    rep(i,H)rep(j,W)if(!P[i][j])rep(k,4){\n      int nx = j + dx[k], ny = i + dy[k];\n      if( !isValid(nx,ny) ) continue;\n      if( !P[ny][nx] ) unit(j+i*W,nx+ny*W);\n    }\n\n    rep(i,H)rep(j,W)weight[i][j] = 0;\n\n    set<int> S;\n    bool first = false;\n    for(int i=H-1;i>=0;i--) for(int j=W-1;j>=0;j--) {\n        if( P[i][j] ) first = true;\n        if( first && !P[i][j] ) S.insert(find(j+i*W));\n        weight[i][j] = S.size();\n      }\n\n    rep(y,H) rep(x,W) if( P[y][x] ) {\n      for(int len=min(H,W);len>=1;len--){\n        if( x + len - 1 < W && y + len - 1 < H ) {\n          if( can_put(len,x,y) ){\n            put[y][x] = len;\n            break;\n          }\n        }\n      }\n    }\n\n    rep(i,H)rep(j,W) counter[i][j] = 0;\n    rep(i,H)rep(j,W)if(P[i][j]){\n      REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n        counter[y][x]++;\n      }\n    }\n\n    rep(i,H){\n      rep(j,W){\n        if( counter[i][j] == 1 ){\n          REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n            bin[y] |= (1<<x);\n          }\n        }\n      }\n    }\n\n    int add = 0;\n    int remain = 0;\n    mincost = 0;\n    rep(i,H)rep(j,W)remain += ((bin[i]>>j)&1),mincost += P[i][j];\n\n    dfs(0,0,remain);\n\n    rep(i,H)rep(j,W)if(counter[i][j]==1)add++;\n    cout << mincost+add << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define N 11\n#define INF (1<<29)\n\nusing namespace std;\n\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\nint bestAns = INF;\nint minHW;\n\nvoid solve(int H, int W, int M[N][N], int depth){\n  /*\n    for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n    if(l>0)putchar(' ');\n    printf(\"%d\", M[k][l]);\n    }\n    putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // back\n  if(depth>=bestAns){\n    return ;\n  }\n\n  // completed.\n  bool bComp=true;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j]==1){\n\tbComp=false;\n      }\n    }\n  }\n  if(bComp){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // embed carpet\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if( M[i][j] == 0 ){\n\tcontinue;\n      }else if( M[i][j] == 1 ){\n\tint maxOneCount=-1;\n\tvector< pair<int,int> > vk;\n\tfor(int k = 0; k < 4; ++k){\n\t  int size = 0;\n\t  for(size = 1; size <= minHW; ++size){\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t  --size;\n\t\t  goto next1;\n\t\t}\n\t      }\n\t    }\n\t    if(k==0){\n\t      if(i-size<0||j+size>=W)break;\n\t    }else if(k==1){\n\t      if(i+size>=H||j+size>=W)break;\n\t    }else if(k==2){\n\t      if(i+size>=H||j-size<0)break;\n\t    }else{\n\t      if(i-size<0||j-size<0)break;\n\t    }\n\t  }\n\tnext1:;\n\t  int oneCount=0;\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( M[m][n] == 1 ){\n\t\t++oneCount;\n\t      }\n\t    }\n\t  }\n\t  vk.push_back( make_pair(size,oneCount) );\n\t  maxOneCount = max( maxOneCount, oneCount );\n\t}\n\tfor(int k = 0; k < 4; ++k){\n\t  if(vk[k].second==maxOneCount){\n\t    int size = vk[k].first;\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif(M[m][n]==1){\n\t\t  M[m][n]=depth;\n\t\t}\n\t      }\n\t    }\n\t    solve(H,W,M,depth+1);\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( M[m][n] == depth ){\n\t\t  M[m][n]=1;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\treturn ;\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[N][N];\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    solve(H,W,M,2);\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nint H,W,mincost;\nint P[10][10],bin[10],bc[(1<<10)];\nint put[10][10],weight[10][10];\n\nbool can_put(int len,int x,int y){\n  REP(i,y,y+len)REP(j,x,x+len) if( !P[i][j] ) return false;\n  return true;\n}\n\nvoid dfs(int cur,int cost,int remain){\n\n  if( remain == 0 ) {\n    mincost = min(cost,mincost);\n    return;\n  }\n\n  if( cost >= mincost ) return;\n  if( cost + ((remain>0)?1:0) >= mincost ) return;\n\n\n  if( cur >= H*W ) {\n    mincost = min(mincost,cost);\n    return;\n  }\n\n  int x = cur % W, y = cur / W;\n  if( cost + max(0,weight[y][x]-1) >= mincost ) return;\n\n  if( !P[y][x] ) {\n    dfs(cur+1,cost,remain);\n    return;\n  }\n\n  if( (bin[y]>>x) & 1 ) dfs(cur+1,cost,remain);\n\n  int len = put[y][x];\n  int bitmask = ((1<<len)-1)<<x;\n  int buf[len];\n  int add = 0, nremain = remain;\n  rep(j,len) {\n    buf[j] = bin[y+j];\n    add += len - bc[((1<<len)-1)&(bin[y+j]>>x)];\n    bin[y+j] |= bitmask;\n  }\n  nremain -= add;\n  if( add ) dfs(cur+1,cost+1,nremain);\n  rep(j,len) bin[y+j] = buf[j];\n\n}\n\nint par[110];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint find(int x){\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\ninline void unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = par[y];\n}\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\nint main(){\n\n  rep(i,(1<<10)) bc[i] = __builtin_popcount(i);\n\n  while( scanf(\"%d%d\",&W,&H), W | H ){\n\n    rep(i,H){\n      bin[i] = 0;\n      rep(j,W){\n        cin >> P[i][j];\n        put[i][j] = 0;\n      }\n    }\n\n    rep(i,H*W) par[i] = i;\n\n    rep(i,H)rep(j,W)if(!P[i][j])rep(k,4){\n      int nx = j + dx[k], ny = i + dy[k];\n      if( !isValid(nx,ny) ) continue;\n      if( !P[ny][nx] ) unit(j+i*W,nx+ny*W);\n    }\n\n    rep(i,H)rep(j,W)weight[i][j] = 0;\n\n    set<int> S;\n    bool first = false;\n    for(int i=H-1;i>=0;i--) for(int j=W-1;j>=0;j--) {\n        if( P[i][j] ) first = true;\n        if( first && !P[i][j] ) S.insert(find(j+i*W));\n        weight[i][j] = S.size();\n      }\n\n    rep(y,H) rep(x,W) if( P[y][x] ) {\n      for(int len=min(H,W);len>=1;len--){\n        if( x + len - 1 < W && y + len - 1 < H ) {\n          if( can_put(len,x,y) ){\n            put[y][x] = len;\n            break;\n          }\n        }\n      }\n    }\n\n    int remain = 0;\n    rep(i,H)rep(j,W)remain += P[i][j];\n    mincost = remain;\n    dfs(0,0,remain);\n\n    cout << mincost << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct state {\n\tvector<short> b;\n\tint dist, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.dist + s1.cost > s2.dist + s2.cost;\n}\nint H, W, a[12][12], cnt, xa[10009], ya[10009], xb[10009], yb[10009], popcount[1033];\nint main() {\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tpopcount[j] = popcount[j - (1 << i)] + 1;\n\t\t}\n\t}\n\twhile (cin >> W >> H, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) {\n\t\t\t\t\t\tif (k - i != l - j) continue;\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor (int x = i; x < k; x++) {\n\t\t\t\t\t\t\tfor (int y = j; y < l; y++) {\n\t\t\t\t\t\t\t\tif (a[x][y] == 0) flag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\txa[cnt] = i;\n\t\t\t\t\t\t\tya[cnt] = j;\n\t\t\t\t\t\t\txb[cnt] = k;\n\t\t\t\t\t\t\tyb[cnt] = l;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> que;\n\t\tint scnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (a[i][j] == 1) scnt++;\n\t\t\t}\n\t\t}\n\t\tque.push(state{ vector<short>(H, 0), 0, scnt });\n\t\tbool flag = false;\n\t\twhile (!que.empty() && !flag) {\n\t\t\tstate u = que.top(); que.pop();\n\t\t\tfor (int i = 0; i < cnt && !flag; i++) {\n\t\t\t\tvector<short> z = u.b;\n\t\t\t\tfor (int j = xa[i]; j < xb[i]; j++) {\n\t\t\t\t\tz[j] |= (1 << yb[i]) - (1 << ya[i]);\n\t\t\t\t}\n\t\t\t\tint rcnt = 0;\n\t\t\t\tfor (int j = 0; j < H; j++) rcnt += popcount[z[j]];\n\t\t\t\trcnt = scnt - rcnt;\n\t\t\t\tif (rcnt == 0) {\n\t\t\t\t\tcout << u.dist + 1 << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tif (u.cost == rcnt) continue;\n\t\t\t\tque.push(state{ z, u.dist + 1, rcnt });\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nint makeCode(int table[10]){\n\tint ret = 0;\n\n\tfor(int col = 0; col < W; col++){\n\t\tif(table[col] == 0){\n\t\t\tret += POW[col];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\tif(base_row == H-2 && base_col == 0){ //?????????2?????§??????????????\\??????\n\n\t\tint code1 = makeCode(info.table[H-2]);\n\t\tint code2 = makeCode(info.table[H-1]);\n\n\t\tif(check[code1][code2] <= info.num)return;\n\n\t\tcheck[code1][code2] = info.num;\n\t}\n\n\t//printf(\"ans:%d\\n\",ans);\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t/*copyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;*/\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\t//recursive(next_info,base_row+1,0);\n\t\t\trecursive(info,base_row+1,0);\n\t\t}else{\n\t\t\t//recursive(next_info,base_row,base_col+1);\n\t\t\trecursive(info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\t/*copyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n*/\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\t//recursive(next_info,base_row+1,0);\n\t\t\trecursive(info,base_row+1,0);\n\t\t}else{\n\t\t\t//recursive(next_info,base_row,base_col+1);\n\t\t\trecursive(info,base_row,base_col+1);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\t\t\t/*Info next_not;\n\n\t\t\tcopyTable(next_not,info.table,base_row);\n\t\t\tnext_not.num = info.num;*/\n\n\t\t\tint must_add = 0;\n\t\t\tbool FLG = false;\n\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\tfor(int row = base_row; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\t//if(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t//}else if(next_not.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)must_add++;\n\n\t\t\t/*if(next_not.num+must_add < ans){\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tif(info.num+must_add < ans){\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(info,base_row+1,0);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(info,base_row,base_col+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*copyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num+1;\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(next_info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tif(next_info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_info,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t\t}\n\t\t}*/\n\n\n\t\t\t\t//????????????????????????\n\t\t\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint must_add = 0;\n\t\t\t\tbool FLG = false;\n\t\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\t\tfor(int row = base_row; row < H; row++){\n\t\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(FLG)must_add++;\n\n\t\t\t\tinfo.num++;\n\n\t\t\t\tif(info.num+must_add < ans){\n\t\t\t\t\tif(base_col == W-1){\n\t\t\t\t\t\trecursive(info,base_row+1,0);\n\t\t\t\t\t}else{\n\t\t\t\t\t\trecursive(info,base_row,base_col+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < POW[W]; i++){\n\t\tfor(int k = 0; k < POW[W]; k++)check[i][k] = BIG_NUM;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n  int W, H;\n  while(cin >> W >> H, W) {\n\n    int p[10][10];\n    bitset< 100 > mat;\n\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        cin >> p[i][j];\n        mat[i * W + j] = p[i][j];\n      }\n    }\n\n    vector< bitset< 100 > > st;\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        for(int k = min(H - i, W - j); k >= 1; k--) {\n          bool flag = true;\n          for(int l = 0; l < k; l++) {\n            for(int m = 0; m < k; m++) flag &= p[i + l][j + m];\n          }\n          if(flag) {\n            bitset< 100 > beet;\n            for(int l = 0; l < k; l++) {\n              for(int m = 0; m < k; m++) beet[(i + l) * W + (j + m)] = 1;\n            }\n            st.emplace_back(beet);\n            break;\n          }\n        }\n      }\n    }\n\n\n    vector< bitset< 100 > > sq;\n    for(auto &p : st) {\n      bool flag = false;\n      for(auto &q : st) {\n        if(p == q) continue;\n        if((p & q) == p) {\n          flag = true;\n          break;\n        }\n      }\n      if(!flag) sq.emplace_back(p);\n    }\n\n    int initial = 0;\n    bool update = true;\n    while(update) {\n      int sg[100] = {};\n      update = false;\n      for(auto &q : sq) {\n        for(int i = 0; i < 100; i++) if(mat[i]) sg[i] += q[i];\n      }\n      vector< bitset< 100 > > nextQ;\n      vector< int > fg(sq.size(), 1);\n      for(int j = 0; j < sq.size(); j++) {\n        for(int i = 0; i < 100; i++) {\n          if(sq[j][i] && sg[i] == 1) {\n            mat &= ~sq[j];\n            ++initial;\n            fg[j] = false;\n            update = true;\n            goto beet;\n          }\n        }\n      }\n      beet:;\n      for(int i = 0; i < sq.size(); i++) {\n        if(fg[i]) nextQ.emplace_back(sq[i]);\n      }\n      sq.swap(nextQ);\n    }\n\n    cout << initial << endl;\n    for(int i = 0; i < H; i++) {\n      for(int j = 0 ; j < W; j++) {\n        cout << mat[i * W+ j];\n      }\n      cout << endl;\n    }\n    continue;\n\n    queue< bitset< 100 > > que;\n    unordered_map< bitset< 100 >, int > cost;\n    cost[mat] = 0;\n    que.emplace(mat);\n    while(!que.empty()) {\n      auto p = que.front();\n      int now = cost[p];\n      que.pop();\n      if(p.none()) {\n        cout << initial + now << endl;\n        break;\n      }\n      for(auto &that : sq) {\n        if((p & that).any()) {\n          auto q = p & ~that;\n          if(cost.count(q)) continue;\n          cost[q] = now + 1;\n          que.emplace(q);\n        }\n      }\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,n,A[11][11],ans,cnt;\nbitset<100> B[11][11],p;\n\nvoid dfs(int d,bitset<100> s,int sco){\n  if(d==n){\n    ans=min(ans,sco);\n    return;\n  }\n  cnt++;\n  if(cnt>=20000000)return;\n  if(ans<=sco)return;\n  if(!A[d/w][d%w])dfs(d+1,s,sco);\n  else{\n    int y=d/w;\n    int x=d%w;\n    if((B[y][x]&s).any()){\n      p&=0;\n      p.set(y*10+x);//(y*100+x);\n      if(!(s&p).any())dfs(d+1,s,sco);\n      dfs(d+1,(B[y][x]|s)^B[y][x],sco+1);\n    }\n    else dfs(d+1,s,sco);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    memset(A,0,sizeof(A));\n    r(i,11)r(j,11)B[i][j]&=0;\n    n=h*w;\n    bitset<100> b;\n    r(i,h)r(j,w)cin>>A[i][j];\n    r(i,h)r(j,w)if(A[i][j]){\n      int sum=1;\n      for(;;sum++){\n        int f=0;\n        for(int y=i;y<i+sum;y++){\n          for(int x=j;x<j+sum;x++){\n            if(A[y][x]==0)f++;\n          }\n        }\n        if(f){\n          sum--;\n          break;\n        }\n      }\n      bitset<100>tmp;\n      for(int y=i,k=0;k<sum;k++,y++){\n        for(int x=j,l=0;l<sum;l++,x++){\n          tmp.set(y*10+x);\n        }\n      }\n      b.set(i*10+j);\n      B[i][j]=tmp;\n    }\n    ans=100;\n    cnt=0;\n    dfs(0,b,0);\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct State {\n\tint a[10][10];\n};\n\nchar c[10][10]; int p[10][10], H, W, mindep;\n\nint range(int sx, int sy, int gx, int gy) {\n\tint cnt = 0;\n\tfor (int i = sx; i < gx; i++) {\n\t\tfor (int j = sy; j < gy; j++) {\n\t\t\tif (c[i][j] == '0') cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\nint range2(int sx, int sy, int gx, int gy, State G) {\n\tint cnt = 0;\n\tfor (int i = sx; i < gx; i++) {\n\t\tfor (int j = sy; j < gy; j++) {\n\t\t\tif (G.a[i][j] == 0) cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nState nurie(State P, int cx, int cy) {\n\tfor (int i = cx; i < cx + p[cx][cy]; i++) {\n\t\tfor (int j = cy; j < cy + p[cx][cy]; j++) P.a[i][j] = 1;\n\t}\n\treturn P;\n}\n\nvoid dfs(int cx, int cy, int depth, State S) {\n\tif (depth == mindep) return;\n\tif (cx == H) {\n\t\tmindep = min(mindep, depth);\n\t\treturn;\n\t}\n\tint nx = cx, ny = cy + 1; if (ny == W) { ny = 0; nx++; }\n\tif (c[cx][cy] == '0') {\n\t\tdfs(nx, ny, depth, S);\n\t}\n\telse {\n\t\tif (S.a[cx][cy] == 0) {\n\t\t\tState V = nurie(S, cx, cy);\n\t\t\tdfs(nx, ny, depth + 1, V);\n\t\t}\n\t\telse if (range2(cx, cy, cx + p[cx][cy], cy + p[cx][cy], S) == 0) {\n\t\t\tdfs(nx, ny, depth, S);\n\t\t}\n\t\telse {\n\t\t\tdfs(nx, ny, depth, S);\n\t\t\tState V = nurie(S, cx, cy);\n\t\t\tdfs(nx, ny, depth + 1, V);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H; mindep = (1 << 30); if (H == 0 && W == 0) break;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> c[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 1; k <= min(H - i, W - j); k++) {\n\t\t\t\t\tif (range(i, j, i + k, j + k) >= 1) break;\n\t\t\t\t\tp[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState S; for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) S.a[i][j] = 0; }\n\t\tdfs(0, 0, 0, S);\n\t\tcout << mindep << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ninline bool chmax(int &a, const int &b) { return (a<b)?(a=b,1):0;}\ninline bool chmin(int &a, const int &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\t\t\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\tint remain=0;\n\t\trep(i,h) remain+=popcount(board[i]);\n\t\tmin_res=min(21,remain);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,remain)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\nint W, H;\nint P[20][20];\nint cover[10][10];\nint width[10][10];\nint left_h[10][10];\nint right_h[10][10];\nint top_h[10][10];\nint bottom_h[10][10];\nint ans;\nclock_t start_time;\nint h(int Y, int X){\n    int res = 0;\n    bool tmp[10][10];\n    for(int y = Y; y < H; y++)\n        for(int x = (y == Y ? X : 0); x < W; x++)\n            tmp[y][x] = !cover[y][x];\n    for(int y = Y; y < H; y++){\n        for(int x = (y == Y ? X : 0); x < W; x++){\n            if(tmp[y][x]){\n                res++;\n                for(int by = top_h[y][x]; by <= bottom_h[y][x]; by++){\n                    for(int bx = left_h[y][x]; bx <= right_h[y][x]; bx++){\n                        tmp[by][bx] = false;\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\nint dfs(int x, int y, int sum){\n    //cout << x << \" \" << y << \" \" << sum + h(y, x) << \" \" << ans << endl;\n    if((clock() - start_time) > CLOCKS_PER_SEC * 0.12) return ans;\n    if(sum + h(y, x) >= ans) return INF;\n    if(x == W) return dfs(0, y + 1, sum);\n    if(y == H){\n        return ans = sum;\n    }\n    int res = (cover[y][x] ? dfs(x + 1, y, sum) : INF);\n\n    bool tmp[10][10];\n    int max_w = 0;\n    REP(dx, width[y][x]) REP(dy, width[y][x]){\n        tmp[y + dy][x + dx] = cover[y + dy][x + dx];\n        if(!cover[y + dy][x + dx]) max_w = max(max_w, max(dx + 1, dy + 1));\n    }\n    REP(dx, width[y][x]) REP(dy, width[y][x]) cover[y + dy][x + dx] = true;\n    if(max_w > 0) res = min(res, dfs(x + 1, y, sum + 1));\n    REP(dx, max_w) REP(dy, max_w) cover[y + dy][x + dx] = tmp[y + dy][x + dx];\n    return res;\n}\n\nint main(){\n    while(cin >> W >> H && (W > 0 && H > 0)){\n        REP(y, H) REP(x, W) cin >> P[y][x];\n        REP(y, H) REP(x, W) {\n            width[y][x] = 0;\n            for(int w = 1; x + w <= W && y + w <= H; w++){\n                bool ok = true;\n                REP(dx, w) REP(dy, w) if(!P[y + dy][x + dx]) ok = false;\n                if(!ok) break;\n                width[y][x] = w;\n            }\n        }\n        REP(y, H) REP(x, W) {\n            left_h[y][x] = x;\n            while(left_h[y][x] - 1 >= 0 && P[y][left_h[y][x] - 1]) left_h[y][x]--;\n            right_h[y][x] = x;\n            while(right_h[y][x] + 1 < W && P[y][right_h[y][x] + 1]) right_h[y][x]++;\n            top_h[y][x] = y;\n            while(top_h[y][x] - 1 >= 0 && P[top_h[y][x] - 1][x]) top_h[y][x]--;\n            bottom_h[y][x] = y;\n            while(bottom_h[y][x] + 1 < H && P[bottom_h[y][x] + 1][x]) bottom_h[y][x]++;\n        }\n\n        ans = INF;\n        REP(y, H) REP(x, W) cover[y][x] = !P[y][x];\n        start_time = clock();\n        dfs(0, 0, 0);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\trep(a,i,h)rep(b,j,w) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w)rep(a,i,i+len[i][j])rep(b,j,j+len[i][j]) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\t//while(dfs(0,0,0)==inf) min_res++;\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[12][12];\nint h[12][12][200];\nint w[12][12][200];\nint n[12][12][200];\nint sz[12][12];\nint H,W;\nint valid(int a,int b,int t){\n\tif(a<0||b<0||a+t>H||b+t>W)return 0;\n\tfor(int i=0;i<t;i++)for(int j=0;j<t;j++)if(!c[a+i][b+j])return 0;\n\treturn 1;\n}\nint lim;\nint dfs(int a,int b,int v){\n\tif(a==H)return 1;\n\tif(b==W)return dfs(a+1,0,v);\n\tif(c[a][b]!=1)return dfs(a,b+1,v);\n\tif(v==lim)return 0;\n\tint last[12][12];\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)last[i][j]=c[i][j];\n\tfor(int i=0;i<sz[a][b];i++){\n\t\tfor(int j=0;j<n[a][b][i];j++)for(int k=0;k<n[a][b][i];k++){\n\t\t\tc[h[a][b][i]+j][w[a][b][i]+k]=2;\n\t\t}\n\t\tif(dfs(a,b+1,v+1))return 1;\n\t\tfor(int j=0;j<n[a][b][i];j++)for(int k=0;k<n[a][b][i];k++)c[h[a][b][i]+j][w[a][b][i]+k]=last[h[a][b][i]+j][w[a][b][i]+k];\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%d\",&c[i][j]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)sz[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tfor(int k=1;k<=min(a,b);k++){\n\t\t\t\tif(valid(i,j,k)&&!valid(i-1,j-1,k+1)&&!valid(i-1,j,k+1)&&!valid(i,j-1,k+1)&&!valid(i,j,k+1)){\n\t\t\t\t\tfor(int l=0;l<k;l++)for(int m=0;m<k;m++){\n\t\t\t\t\t\th[i+l][j+m][sz[i+l][j+m]]=i;\n\t\t\t\t\t\tw[i+l][j+m][sz[i+l][j+m]]=j;\n\t\t\t\t\t\tn[i+l][j+m][sz[i+l][j+m]]=k;\n\t\t\t\t\t\tsz[i+l][j+m]++;\n\t\t\t\t\t//\tprintf(\"%d %d %d %d %d\\n\",i,j,k,i+l,j+m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<b;j++)for(int k=0;k<sz[i][j];k++);\n\t\t//\tprintf(\"%d %d: %d %d %d\\n\",i,j,h[i][j][k],w[i][j][k],n[i][j][k]);\n\t\tint ad=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint M=0;\n\t\t\tfor(int k=0;k<sz[i][j];k++)M=max(M,n[i][j][k]);\n\t\t\tif(M==1){\n\t\t\t\tad++;\n\t\t\t\tc[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;;i++){\n\t\t\tlim=i;\n\t\t\tif(dfs(0,0,0)){\n\t\t\t\tprintf(\"%d\\n\",ad+i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\n\nint H,W;\nvec t;\nmap< vec , int > dp[10][10];\n\nint mem[10][10][10][10];\n\nbool check(int ay,int ax,int by,int bx){\n  if(mem[ay][ax][by][bx]!=-1)\n    return mem[ay][ax][by][bx];\n\n  mem[ay][ax][by][bx]=false;\n  for(int y=ay;y<=by;y++)\n    for(int x=ax;x<=bx;x++)\n      if( (t[y]>>x&1)==0 )return false;\n\n  mem[ay][ax][by][bx]=true;\n  return true;\n}\n\nint solve(vec p,int y,int x){\n  if(y==H)return 0;\n  \n  if(x==W){\n    return solve(p,y+1,0);\n  }\n  \n  if(dp[y][x].count(p))return dp[y][x][p];\n  int sum=0;\n  for(int i=0;i<H;i++)sum+=p[i];\n  if(sum==0)return 0;\n  \n\n  int res=1e9;\n  if((p[y]>>x&1)==0)res=solve(p,y,x+1);\n\n  for(int i=0;;i++){\n    if(y+i>=H||x+i>=W)break;\n    if(!check(y,x,y+i,x+i))break;\n    if( y+i+1<H && x+i+1<W &&check(y,x,y+i+1,x+i+1))continue;\n    int ma=(1<<(i+1))-1;\n    vec next=p;\n    for(int j=0;j<=i;j++){\n      next[y+j]|=(ma<<x);\n      next[y+j]-=(ma<<x);\n    }\n\n    if(p==next)continue;\n    res=min(res,solve(next,y,x+1)+1);\n  }\n\n  return dp[y][x][p]=res;\n}\n\nint main(){\n  while(1){\n    cin>>W>>H;\n    if(H==0&&W==0)break;\n    memset( mem, -1, sizeof(mem) );\n    vec si;\n    for(int i=0;i<H;i++){\n      int bit=0,a;\n      for(int j=0;j<W;j++){\n        dp[i][j].clear();\n        \n        cin>>a;\n        if(a==1)bit|=(1<<j);\n      }\n      si.push_back(bit);\n    }\n    t=si;\n    cout<<solve(si,0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint p[10][10], s[10][10];\nvector< vector< int > > st;\nmap< vector< int >, int > dp;\nint W, H;\n\nint dfs(int x, int y)\n{\n  if(dp.count(st)) return (dp[st]);\n  if(y == H) return (0);\n  if(x == W) return (dfs(0, y + 1));\n  if(p[y][x] == 0) return (dfs(x + 1, y));\n  int ret = 1 << 30;\n  if(st[y][x] == 0) ret = min(ret, dfs(x + 1, y));\n  vector< pair< int, int > > beet;\n  for(int i = 0; i < s[y][x]; i++) {\n    for(int j = 0; j < s[y][x]; j++) {\n      if(st[y + i][x + j] == 1) {\n        beet.emplace_back(y + i, x + j);\n        st[y + i][x + j] = 0;\n      }\n    }\n  }\n  if(beet.size()) {\n    ret = min(ret, dfs(x + 1, y) + 1);\n    for(auto &p : beet) st[p.first][p.second] = 1;\n  }\n  return (dp[st] = ret);\n}\n\nint main()\n{\n  while(cin >> W >> H, W) {\n    st.resize(H);\n    for(int i = 0; i < H; i++) {\n      st[i].resize(W);\n      for(int j = 0; j < W; j++) {\n        cin >> p[i][j];\n        st[i][j] = p[i][j];\n      }\n    }\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        for(int k = min(H - i, W - j); k >= 1; k--) {\n          bool flag = true;\n          for(int l = 0; l < k; l++) {\n            for(int m = 0; m < k; m++) flag &= p[i + l][j + m];\n          }\n          if(flag) {\n            s[i][j] = k;\n            break;\n          }\n        }\n      }\n    }\n    cout << dfs(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\t//ans = min(ans,info.num);\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(FLG == false && info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n    short table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nshort first_table[10][10],max_size[10][10];\n\n\nbool rangeCheck(int row,int col){\n    if(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n    else{\n        return false;\n    }\n}\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n    if(info.num == ans)return;\n\n    if(base_row == H){\n        ans = info.num;\n        return;\n    }\n\n    if(info.table[base_row][base_col] == -1){\n\n        if(base_col == W-1){\n            recursive(info,base_row+1,0,pre_must_add);\n        }else{\n            recursive(info,base_row,base_col+1,pre_must_add);\n        }\n        return;\n    }\n\n    int new_num = 0;\n   /* for(int i = 0; i < max_size[base_row][base_col]; i++){\n        for(int k = 0; k < max_size[base_row][base_col]; k++){\n            if(info.table[base_row+i][base_col+k] == 0){\n                new_num = 1;\n                goto SHISHIMARU;\n            }\n        }\n    }\n\nSHISHIMARU:*/\n\n    int add = max_size[base_row][base_col]-1;\n    if(info.table[base_row+add][base_col+add] == 0){\n    \tnew_num = 1;\n    }\n\n    if(new_num == 0){\n\n        if(base_col == W-1){\n            recursive(info,base_row+1,0,pre_must_add);\n        }else{\n            recursive(info,base_row,base_col+1,pre_must_add);\n        }\n    }else{\n\n        if(info.table[base_row][base_col] != 0){\n\n            if(base_col == W-1){\n                recursive(info,base_row+1,0,pre_must_add);\n            }else{\n                recursive(info,base_row,base_col+1,pre_must_add);\n            }\n        }\n\n        for(int i = 0; i < max_size[base_row][base_col]; i++){\n            for(int k = 0; k < max_size[base_row][base_col]; k++){\n                info.table[base_row+i][base_col+k]++;\n            }\n        }\n\n        int must_add = 0;\n        bool FLG = false;\n\n        for(int row = base_row; row <= base_row; row++){\n            for(int col = base_col; col < W; col++){\n                if(info.table[row][col] == 0 && first_table[row][col] == 1){\n                    must_add++;\n                }else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n                    FLG = true;\n                }\n            }\n        }\n\n        for(int row = base_row+1; row < H; row++){\n            for(int col = 0; col < W; col++){\n                if(info.table[row][col] == 0 && first_table[row][col] == 1){\n                    must_add++;\n                }else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n                    FLG = true;\n                }\n            }\n        }\n\n\n        if(FLG)must_add++;\n\n        info.num++;\n\n        if(info.num+must_add < ans){\n            if(base_col == W-1){\n                recursive(info,base_row+1,0,must_add);\n            }else{\n                recursive(info,base_row,base_col+1,must_add);\n            }\n        }\n    }\n}\n\n\nvoid func(){\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            scanf(\"%d\",&first_table[row][col]);\n            first_table[row][col] -= 1;\n        }\n    }\n\n    bool FLG;\n    int size;\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            if(first_table[row][col] == -1){\n                max_size[row][col] = 0;\n            }else{\n                size = 1;\n\n                FLG = true;\n\n                while(true){\n                    for(int i = 0; i < size; i++){\n                        for(int k = 0; k < size; k++){\n                            if(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n                                FLG = false;\n                                break;\n                            }\n                        }\n                        if(!FLG)break;\n                    }\n                    if(!FLG){\n                        size -= 1;\n                        break;\n                    }\n                    size++;\n                }\n\n                max_size[row][col] = size;\n\n                for(int calc_size = 1; calc_size <= size; calc_size++){\n                    for(int i = 0; i < calc_size; i++){\n                        for(int k = 0; k < size; k++){\n                            first_table[row+i][col+k]++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    Info start;\n    start.num = 0;\n    int pre_must_add = 0;\n    FLG = false;\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            if(first_table[row][col] == -1){\n                start.table[row][col] = -1;\n            }else{\n                if(first_table[row][col] == 1){\n                    pre_must_add++;\n                }else{\n                    FLG = true;\n                }\n                start.table[row][col] = 0;\n            }\n        }\n    }\n\n    if(FLG)pre_must_add++;\n\n    ans = BIG_NUM;\n\n    recursive(start,0,0,pre_must_add);\n\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n\n    for(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n    while(true){\n        scanf(\"%d %d\",&W,&H);\n        if(W == 0 && H == 0)break;\n\n        func();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "struct Info{\n\tshort table[10][10],num;\n};\n\nshort W,H,ans,POW[11];\nshort first_table[10][10],max_size[10][10];\n\nbool rangeCheck(short row,short col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\ninline void copyTable(Info& to,short from[10][10],short base_row){\n\n\tfor(short row = base_row; row < H; row++){\n\t\tfor(short col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,short base_row,short base_col,short pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\t//ans = min(ans,info.num);\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tshort new_num = 0;\n\tfor(short i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(short k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(short i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(short k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tshort must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(short row = base_row; row < H; row++){\n\t\t\tfor(short col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(short row = 0; row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tshort size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(short row = 0; row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(short i = 0; i < size; i++){\n\t\t\t\t\t\tfor(short k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(short calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(short i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(short k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tshort pre_must_add = 0;\n\tFLG = false;\n\n\tfor(short row = 0; row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprshortf(\"%d\\n\",ans);\n}\n\nshort main(){\n\n\tfor(short i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nchar board[11][11];\nbool used[111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    rep(i,h)rep(j,w){\n      cin>>board[i][j];\n      board[i][j]-='0';\n    }\n    vector<int> g[10101];\n    // 0-9999 / 10000-10100\n    rep(ti,h)rep(tj,w)rep(si,ti)rep(sj,tj){\n      int sum=0;\n      repl(i,si,ti+1)repl(j,sj,tj+1){\n        sum+=board[i][j];\n      }\n      if(sum==(ti-si+1)*(tj-sj+1)&&(ti-si)==(tj-sj)){\n        int cv=si*1000+sj*100+ti*10+tj;\n        repl(i,si,ti+1)repl(j,sj,tj+1){\n          int bv=10000+i*10+j;\n          g[cv].pb(bv); g[bv].pb(cv);\n        }\n      }\n    }\n    memset(used,0,sizeof(used));\n    int res=0;\n    rep(i,h)rep(j,w){\n      if(board[i][j]==1&&!used[i*10+j]){\n        res++;\n        int maxv=-1,maxc=0;\n        each(v,g[i*10+j+10000]){\n          int cnt=0;\n          each(nv,g[v]){\n            if(!used[nv-10000])cnt++;\n          }\n          if(maxc<cnt){\n            maxc=cnt;\n            maxv=v;\n          }\n        }\n        rep(k,g[maxv].size()){\n          used[g[maxv][k]-10000]=true;\n        }\n      }\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint getsize(const vvi& grid,int i0,int j0)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tint res=0;\n\tfor(int k=1;k<=min(h-i0,w-j0);k++){\n\t\tbool ok=true;\n\t\trep(i,k) rep(j,k) if(grid[i0+i][j0+j]==0)\n\t\t\tok=false;\n\t\tif(!ok) break;\n\t\tres=k;\n\t}\n\treturn res;\n}\n\nbool ok(const vvi& grid,const vvi& cur)\n{\n\tint h=grid.size(),w=grid[0].size();\n\trep(i,h) rep(j,w) if(grid[i][j]!=!!cur[i][j]) return false;\n\treturn true;\n}\n\n//void dfs(const vvi& grid,const vvi& size,vvi& cur,int i,int j,int cnt,int& res)\n//{\n//\tif(cnt>=res) return;\n//\t\n//\tint h=grid.size(),w=grid[0].size();\n//\tif(i==h){\n//\t\t//cout<<\"--------------------\"<<endl;\n//\t\t//rep(k,h) dump(cur[k]);\n//\t\tif(ok(grid,cur))\n//\t\t\tres=min(res,cnt);\n//\t\treturn;\n//\t}\n//\t\n//\tif(size[i][j]==-1){\n//\t\tif(grid[i][j]==0 || cur[i][j])\n//\t\t\tdfs(grid,size,cur,i+(j+1)/w,(j+1)%w,cnt,res);\n//\t}\n//\telse{\n//\t\tif(cur[i][j])\n//\t\t\tdfs(grid,size,cur,i+(j+1)/w,(j+1)%w,cnt,res);\n//\t\tint sz=size[i][j];\n//\t\trep(k,sz) rep(l,sz) cur[i+k][j+l]++;\n//\t\tdfs(grid,size,cur,i+(j+1)/w,(j+1)%w,cnt+1,res);\n//\t\trep(k,sz) rep(l,sz) cur[i+k][j+l]--;\n//\t}\n//}\n\nvoid dfs(const vvi& grid,const vvi& size,const vector<pii>& cand,vvi& cur,int i,int j,int cnt,int& res)\n{\n\tif(cnt>=res) return;\n\t\n\tint h=grid.size(),w=grid[0].size();\n\tif(i==h){\n\t\t//cout<<\"--------------------\"<<endl;\n\t\t//rep(k,h) dump(cur[k]);\n\t\tif(ok(grid,cur))\n\t\t\tres=min(res,cnt);\n\t\treturn;\n\t}\n\t\n\tif(binary_search(all(cand),mp(i,j))){\n\t\tif(cur[i][j])\n\t\t\tdfs(grid,size,cand,cur,i+(j+1)/w,(j+1)%w,cnt,res);\n\t\tint sz=size[i][j];\n\t\trep(k,sz) rep(l,sz) cur[i+k][j+l]++;\n\t\tdfs(grid,size,cand,cur,i+(j+1)/w,(j+1)%w,cnt+1,res);\n\t\trep(k,sz) rep(l,sz) cur[i+k][j+l]--;\n\t}\n\telse{\n\t\tif(grid[i][j]==0 || cur[i][j]>0)\n\t\t\tdfs(grid,size,cand,cur,i+(j+1)/w,(j+1)%w,cnt,res);\n\t}\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h && w|h;){\n\t\t//dump(mp(h,w));\n\t\tvvi grid(h,vi(w));\n\t\trep(i,h) rep(j,w) cin>>grid[i][j];\n\t\t\n\t\t// size[i][j]:(i,j)を左上とする正方形が極大であるとき，一辺の長さ\n\t\tvvi size(h,vi(w));\n\t\trep(i,h) rep(j,w){\n\t\t\tint sz=getsize(grid,i,j);\n\t\t\tif(sz==size[i][j])\n\t\t\t\tsize[i][j]=-1;\n\t\t\telse{\n\t\t\t\trep(k,sz) rep(l,sz)\n\t\t\t\t\tsize[i+k][j+l]=max(size[i+k][j+l],min(sz-k,sz-l));\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<vector<vector<pii>>> cover(h,vector<vector<pii>>(w));\n\t\trep(i,h) rep(j,w) if(size[i][j]!=-1){\n\t\t\tint sz=size[i][j];\n\t\t\trep(k,sz) rep(l,sz)\n\t\t\t\tcover[i+k][j+l].emplace_back(i,j);\n\t\t}\n\t\t\n\t\tvector<pii> must;\n\t\trep(i,h) rep(j,w) if(cover[i][j].size()==1)\n\t\t\tmust.push_back(cover[i][j][0]);\n\t\tsort(all(must));\n\t\tmust.erase(unique(all(must)),end(must));\n\t\t\n\t\tvvi cur(h,vi(w));\n\t\tfor(auto p:must){\n\t\t\tint i,j; tie(i,j)=p;\n\t\t\tint sz=size[i][j];\n\t\t\trep(k,sz) rep(l,sz) cur[i+k][j+l]=1;\n\t\t}\n\t\t\n\t\tvector<pii> cand;\n\t\trep(i,h) rep(j,w) if(cover[i][j].size() && !cur[i][j])\n\t\t\tfor(auto p:cover[i][j]) if(!binary_search(all(must),p))\n\t\t\t\tcand.push_back(p);\n\t\tsort(all(cand));\n\t\tcand.erase(unique(all(cand)),end(cand));\n\t\t\n\t\tint res=INF;\n\t\tdfs(grid,size,cand,cur,0,0,0,res);\n\t\t//dump(must.size()); dump(res);\n\t\tcout<<must.size()+res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add,int calc_table[10][10]){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\t//ans = min(ans,info.num);\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add,calc_table);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add,calc_table);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add,calc_table);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add,calc_table);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add,calc_table);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add,calc_table);\n\t\t\t}\n\t\t}\n\n\t\tint next_calc_table[10][10];\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tnext_calc_table[row][col] = calc_table[row][col];\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t\tnext_calc_table[base_row+i][base_col+k]--;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && next_calc_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && next_calc_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add,next_calc_table);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add,next_calc_table);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add,first_table);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ninline bool chmax(int &a, const int &b) { return (a<b)?(a=b,1):0;}\ninline bool chmin(int &a, const int &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx];\n\t\t\trep(a,cy,cy+l)rep(b,cx,cx+l) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[H][W];\n    int minHW = min(H,W);\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif( M[i][j] == 0 ){\n\t  continue;\n\t}else if( M[i][j] == 1 ){\n\t  int maxK=-1;\n\t  int maxSize=-1;\n\t  int maxOneCount=-1;\n\t  for(int k = 0; k < 4; ++k){\n\t    int size = 0;\n\t    int oneCount=0;\n\t    for(size = 1; size <= minHW; ++size){\n\t      for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t\tfor(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\t  if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t    --size;\n\t\t    goto next1;\n\t\t  }\n\t\t}\n\t      }\n\t      if(k==0){\n\t\tif(i-size<0||j+size>=W)break;\n\t      }else if(k==1){\n\t\tif(i+size>=H||j+size>=W)break;\n\t      }else if(k==2){\n\t\tif(i+size>=H||j-size<0)break;\n\t      }else{\n\t\tif(i-size<0||j-size<0)break;\n\t      }\n\t    }\n\t  next1:;\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( M[m][n] == 1 ){\n\t\t  oneCount++;\n\t\t}\n\t      }\n\t    }\n\t    //printf(\"OneCount=%d\\n\",oneCount);\n\t    if(oneCount > maxOneCount){\n\t      maxOneCount = oneCount;\n\t      maxSize = size;\n\t      maxK = k;\n\t    }\n\t  }\n\t  //printf(\"i=%d,j=%d,maxSize=%d,maxK=%d\\n\",i,j,maxSize,maxK);\n\t  for(int m = i; (maxK==0||maxK==3)?(m>i-maxSize):(m<maxSize+i); m+=di[maxK]){\n\t    for(int n = j; (maxK==2||maxK==3)?(n>j-maxSize):(n<maxSize+j); n+=dj[maxK]){\n\t      if( M[m][n] >= 1 ){\n\t\tM[m][n] = 2;\n\t      }\n\t    }\n\t  }\n\t  ++cnt;\n\t}\n\n\t/*\n\tfor(int k = 0; k < H; ++k){\n\t  for(int l = 0; l < W; ++l){\n\t    if(l>0)putchar(' ');\n\t    printf(\"%d\", M[k][l]);\n\t  }\n\t  putchar('\\n');\n\t}\n\tputchar('\\n');\n\t*/\n\n      }\n    }\n    printf(\"%d\\n\", cnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> tri;\n\nint w,h;\nint g[20][20];\nint rem[20][20];\nvector<tri> carpet[20][20];\nint depth;\n\nvoid search(int d){\n  if(d==depth)return;\n\n  int y=-1, x=-1, mink = h*w;\n  vector<tri> priority;\n  rep(i,h)rep(j,w){\n    if(rem[i][j] && mink > (int)carpet[i][j].size()){\n      y = i; x = j;\n    }\n  }\n\n  if(y<0){\n    depth = d;\n    return;\n  }\n\n  rep(k,carpet[y][x].size()){\n    tri t = carpet[y][x][k];\n    \n    int tmp[20][20];\n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\ttmp[i][j] = rem[i][j];\n      }\n    }\n\n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\trem[i][j] = 0;\n      }\n    }\n    \n    search(d+1);\n\n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\trem[i][j] = tmp[i][j];\n      }\n    }\n    if(depth == d+1)return;\n  }\n}\n\nint main(){\n  while(cin >> w >> h, w){\n    memset(g,0,sizeof(g));\n    rep(i,h)rep(j,w){\n      cin >> g[i][j];\n      rem[i][j] = g[i][j];\n      carpet[i][j].clear();\n    }\n\n    vector<tri> c;\n    rep(i,h)rep(j,w){\n      int k = 0;\n      while(true){\n\tif(!range(i+k,0,h) || !range(j+k,0,w))break;\n\tint f = 1;\n\tfor(int y=i;y<=i+k;y++)f &= g[y][j+k];\n\tfor(int x=j;x<=j+k;x++)f &= g[i+k][x];\n\tif(!f)break;\n\tk++;\n      }\n      if(k)c.push_back( tri(pii(i,j), k) );\n    }\n    \n    rep(i,c.size()){\n      bool f = false;\n      rep(j,c.size()){\n\tif(i==j)continue;\n\tif( range(c[i].fs.fs, c[j].fs.fs, c[j].fs.fs + c[j].sc) &&\n\t    range(c[i].fs.fs + c[i].sc, c[j].fs.fs, c[j].fs.fs + c[j].sc+1) &&\n\t    range(c[i].fs.sc, c[j].fs.sc, c[j].fs.sc + c[j].sc) &&\n\t    range(c[i].fs.sc + c[i].sc, c[j].fs.sc, c[j].fs.sc + c[j].sc+1) ){\n\t  f = true;\n\t  break;\n\t}\n      }\n\n      if(f){\n\tc.erase(c.begin()+i);\n\ti--;\n      }\n    }\n\n    rep(i,c.size()){\n      for(int y=c[i].fs.fs;y<c[i].fs.fs+c[i].sc;y++){\n\tfor(int x=c[i].fs.sc;x<c[i].fs.sc+c[i].sc;x++){\n\t  carpet[y][x].push_back(c[i]);\n\t}\n      }\n    }\n\n    int ans = 0;\n\n    depth = h*w;\n    search(0);\n    \n    cout << ans + depth  << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\ninline void chmin(int &a, const int &b) { (b<a)?(a=b):0;}\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int W, H;\n    while(cin >> W >> H) {\n        if(W == 0 && H == 0) break;\n        vector<vector<int>> v(H, vector<int>(W));\n        rep(i, H) rep(j, W) cin >> v[i][j];\n        int ans = 0;\n        vector<vector<int>> cur(H, vector<int>(W));\n        auto isNecessary = [&](int y, int x, int len) {\n            bool ret = false;\n            REP(i, y, y + len) REP(j, x, x + len) {\n                if(v[i][j] == 0) return false;\n                else if(cur[i][j] == 0) ret = true;\n            }\n            if(!ret) return false;\n            REP(i, y, y + len) REP(j, x, x + len) {\n                ++cur[i][j];\n            };\n            return true;\n        };\n        auto isErase = [&](int y, int x, int len) {\n            REP(i, y, y + len) REP(j, x, x + len) {\n                if(cur[i][j] <= 1) return false;\n            }\n            REP(i, y, y + len) REP(j, x, x + len) {\n                --cur[i][j];\n            }\n            return true;\n        };\n        using P = pair<int, pii>; // len, y, x\n        set<P> used;\n        for(int len = min(H, W); len > 0; --len) {\n            for(int y = 0; y + len <= H; ++y) {\n                for(int x = 0; x + len <= W; ++ x) {\n                    if(isNecessary(y, x, len)) {\n                        // cout << \" \" << y << \" \" << x << \" \" << len << '\\n';\n                        ++ans;\n                        used.insert({len, {y, x}});\n                    }\n                }\n            }\n        }\n        for(auto p : used) {\n            int len = p.fi;\n            int y = p.se.fi, x = p.se.se;\n            if(isErase(y, x, len)) {\n                --ans;\n            }\n        }\n\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans;\nint first_table[10][10],max_size[10][10];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\t//printf(\"ans:%d\\n\",ans);\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\t\t\tInfo next_not;\n\n\t\t\tcopyTable(next_not,info.table,base_row);\n\t\t\tnext_not.num = info.num;\n\n\t\t\tint must_add = 0;\n\t\t\tbool FLG = false;\n\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\tfor(int row = base_row; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}else if(next_not.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)must_add++;\n\n\t\t\tif(next_not.num+must_add < ans){\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcopyTable(next_info,info.table);\n\t\tnext_info.num = info.num+1;\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(next_info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tif(next_info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_info,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint board[111][111];\nbool used[11111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    rep(i,h)rep(j,w){\n      cin>>board[i][j];\n    }\n    vector<int> g[60000];\n    rep(ti,h+1)rep(tj,w+1)rep(si,ti)rep(sj,tj){\n      if((ti-si)!=(tj-sj))continue;\n      bool ok=true;\n      repl(i,si,ti)repl(j,sj,tj){\n        if(!board[i][j])ok=false;\n      }\n      if(ok){\n        //dbg(si); dbg(sj); dbg(ti);dbg(tj);\n        int cv=si*4000+sj*300+ti*20+tj;\n        repl(i,si,ti)repl(j,sj,tj){\n          int bv=50000+i*11+j;\n          g[cv].pb(bv); g[bv].pb(cv);\n        }\n      }\n    }\n    memset(used,0,sizeof(used));\n    int res=0;\n    rep(i,h)rep(j,w){\n      if(board[i][j]==1&&!used[i*11+j]){\n        res++;\n        int maxv=-1,maxc=0;\n        each(v,g[i*11+j+50000]){\n          int cnt=0;\n          each(nv,g[v]){\n            if(!used[nv-50000])cnt++;\n          }\n          if(maxc<cnt){\n            maxc=cnt;\n            maxv=v;\n          }\n        }\n        each(v,g[maxv]){\n          used[v-50000]=true;\n        }\n      }\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d){\n\t\n\tif(y==h && x==0){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d>min_res) return inf;\n\n\tint ny=y,nx=x+1;\n\tif(nx==w) ny++,nx=0;\t\n\n\tif(len[y][x]==0) return dfs(ny,nx,d);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(ny,nx,d));\n\n\tint tboard[10];\n\trep(i,h) tboard[i]=board[i];\n\n\tbool ok=false;\n\tint mask=0;\n\trep(b,x,x+len[y][x]) mask|=bit(b);\n\trep(a,y,y+len[y][x]){\n\t\tif((board[a]&mask)!=0) ok=true;\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(ok) chmin(ret,dfs(ny,nx,d+1));\n\t\n\trep(i,h) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(cin >> w >> h,w){\n\t\tclr(board,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tboard[i]|=(tmp<<j);\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\trep(a,i,h)rep(b,j,w) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w)rep(a,i,i+len[i][j])rep(b,j,j+len[i][j]) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\tmin_res=0;\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\t//while(dfs(0,0,0)==inf) min_res++;\n\t\tcout << dfs(0,0,0)+add << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint w,h;\nint p[11][11];\nint cnt[11][11];\nint res;\n\nstruct square{\n\tint x,y,si;\n\tsquare(){}\n\tsquare(int xx,int yy,int ss){\n\t\tx=xx;\n\t\ty=yy;\n\t\tsi=ss;\n\t}\n\tbool operator<(const square &s)const{\n\t\treturn si<s.si;\n\t}\n};\n\nvector<square> sq; \nvector<square> usq;\n\nbool check(int s,int y,int x){\n\tfor(int i=y;i<y+s;i++){\n\t\tfor(int j=x;j<x+s;j++){\n\t\t\tif(i>=h || j>=w)return false;\n\t\t\tif(p[i][j]==0)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool cover(square a,square b){\n\tbool flag=false;\n\tbool flag2=false;\n\tif(a.x<=b.x && b.x+b.si<=a.x+a.si)flag=true;\n\tif(a.y<=b.y && b.y+b.si<=a.y+a.si)flag2=true;\n\treturn (flag && flag2);\n}\n\nint hstar(int v){\n\tint n=0;\n\tint val[101];\n\tint c=0;\n\tfor(;v<usq.size();v++){\n\t\tval[c]=0;\n\t\tfor(int i=usq[v].x;i<usq[v].x+usq[v].si;i++){\n\t\t\tfor(int j=usq[v].y;j<usq[v].y+usq[v].si;j++){\n\t\t\t\tif(p[j][i]==1)val[c]++;\n\t\t\t}\n\t\t}\n\t\tc++;\n\t}\n\tint rest=0;\n\tsort(val,val+c,greater<int>());\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\trest+=p[i][j];\n\t\t}\n\t}\n\tint l=0;\n\tfor(l=0;rest>0;l++){\n\t\trest-=val[l];\n\t}\n\treturn l;\n}\n\nbool empty(){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(p[i][j]==1)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid update(int v,int c){\n\tfor(int i=usq[v].x;i<usq[v].x+usq[v].si;i++){\n\t\tfor(int j=usq[v].y;j<usq[v].y+usq[v].si;j++){\n\t\t\tcnt[j][i]+=c;\n\t\t}\n\t}\n}\n\nvoid dfs(int v,int sum){\n\tif(empty()){\n\t\tres=min(sum,res);\n\t\treturn;\n\t}\n\tif(v==(int)usq.size())return;\n\tif(sum+hstar(v)>=res)return;\n\tbool ok1=false,ok2=false;\n\tfor(int i=usq[v].x;i<usq[v].x+usq[v].si;i++){\n\t\tfor(int j=usq[v].y;j<usq[v].y+usq[v].si;j++){\n\t\t\tif(p[j][i]==1){\n\t\t\t\tok1=true;\n\t\t\t\tif(cnt[j][i]==1)ok2=true;\n\t\t\t}\n\t\t}\n\t}\n\tupdate(v,-1);\n\tif(ok1){\n\t\tint tmp[11][11];\n\t\tmemcpy(tmp,p,sizeof(p));\n\t\tfor(int i=usq[v].x;i<usq[v].x+usq[v].si;i++){\n\t\t\tfor(int j=usq[v].y;j<usq[v].y+usq[v].si;j++){\n\t\t\t\tp[j][i]=0;\n\t\t\t}\n\t\t}\n\t\tdfs(v+1,sum+1);\n\t\tmemcpy(p,tmp,sizeof(p));\n\t}\n\tif(!ok2){\n\t\tdfs(v+1,sum);\n\t}\n\tupdate(v,1);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tsq.clear();\n\t\tusq.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tscanf(\"%d\",&p[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=min(w,h);i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tif(check(i,j,k)){\n\t\t\t\t\t\tsq.push_back(square(k,j,i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(sq.begin(),sq.end());\n\t\tfor(int i=(int)sq.size()-1;i>=0;i--){\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<usq.size();j++){\n\t\t\t\tif(cover(usq[j],sq[i]))flag=false;\n\t\t\t}\n\t\t\tif(flag)usq.push_back(sq[i]);\n\t\t}\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tfor(int i=0;i<usq.size();i++){\n\t\t\tupdate(i,1);\n\t\t}\n\t\tres=usq.size();\n\t\tsort(usq.begin(),usq.end());\n\t\tdfs(0,0);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nconst int N = 16;\nconst int inf = 1<<27;\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\n\nusing namespace std;\n\n\nint H,W;\nint M[N][N];\nint maxSizes[N][N][4];\nint oneCount;\nint minHW;\nint ans;\nint greedy_ans;\nint depth;\nmultimap<int,int,greater<int> > maxS;\n\ninline int getHeuristic();\nvoid calc();\nvoid solve(int pos);\n\ninline int getHeuristic()\n{\n  int msz=1;\n  if(!maxS.empty())msz = maxS.begin()->first;\n  msz *= msz;\n  return oneCount/msz + (oneCount%msz>0);\n}\n\nstruct Cand{\n  int i,j;\n  Cand():i(0),j(0){}\n  Cand(int ci, int cj):i(ci),j(cj){}\n  bool operator<(const Cand& t)const{\n    return (i==t.i)?(j<t.j):(i<t.i);\n  }\n};\n\nint cand_num;\nCand cands[N*N];\n\nvoid calc(){\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 1){\n\toneCount++;\n\tcands[cand_num++] = Cand(i,j);\n      }\n      for(int k = 0; k < 4; ++k){\n\tint size = 0;\n\tfor(size = 1; size <= minHW; ++size){\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t--size;\n\t\tgoto next;\n\t      }\n\t    }\n\t  }\n\t  if(k==0){\n\t    if(i-size<0||j+size>=W)break;\n\t  }else if(k==1){\n\t    if(i+size>=H||j+size>=W)break;\n\t  }else if(k==2){\n\t    if(i+size>=H||j-size<0)break;\n\t  }else{\n\t    if(i-size<0||j-size<0)break;\n\t  }\n\t}\n      next:;\n\tmaxSizes[i][j][k] = size;\n\tif(k==1){\n\t  if(size>1){\n\t    maxS.insert( make_pair(size,0) );\n\t  }\n\t}\n      }\n    }\n  }\n  sort(cands,cands+cand_num);\n  return ;\n}\n\nvoid solve_greedy(int pos)\n{\n  // completed.\n  if(oneCount==0){\n    greedy_ans = min(greedy_ans, depth);\n    return ;\n  }\n\n  // embed carpet greedy\n  int maxOneCount = -1;\n  pair<int,int> mem[cand_num][4];\n  for(int p = 0; p < cand_num; ++p){\n    int i = cands[p].i;\n    int j = cands[p].j;\n    if( M[i][j] == 1 ){\n      for(int k = 0; k < 4; ++k){\n\tint cnt = 0;\n\tint size = maxSizes[i][j][k];\n\tfor(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t  for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t    if(M[m][n]==1){\n\t      ++cnt;\n\t    }\n\t  }\n\t}\n\tmem[p][k] = make_pair(size,cnt);\n\tmaxOneCount = max( maxOneCount, cnt );\n      }\n    }\n  }\n  for(int p = 0; p < cand_num; ++p){\n    for(int k = 0; k < 4; ++k){\n      if( mem[p][k].second == maxOneCount ){\n\tint i = cands[p].i;\n\tint j = cands[p].j;\n\tint size = mem[p][k].first;\n\tfor(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t  for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t    if(M[m][n]==1){\n\t      M[m][n]=depth;\n\t      --oneCount;\n\t    }\n\t  }\n\t}\n\t++depth;\n\tsolve_greedy(p+1);\n\t--depth;\n\tfor(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t  for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t    if( M[m][n] == depth ){\n\t      M[m][n]=1;\n\t      ++oneCount;\n\t    }\n\t  }\n\t}\n\treturn ;\n      }\n    }\n  }\n}\n\nvoid solve(int pos){\n  /*\n    printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W, getHeuristic());\n    for(int k = 0; k < H; ++k){\n      for(int l = 0; l < W; ++l){\n\tif(l>0)putchar(' ');\n\tprintf(\"%2d\", M[k][l]);\n      }\n      putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  if(oneCount==0){\n    ans = min(ans, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic()>=ans){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < cand_num; ++p){\n    int i = cands[p].i;\n    int j = cands[p].j;\n    int size = maxSizes[i][j][1];\n    int valid=0;\n    for(int m = i; m<size+i; m++){\n      for(int n = j; n<size+j; n++){\n\tif(M[m][n]==1){\n\t  valid=1;\n\t  --oneCount;\n\t  M[m][n]=depth;\n\t}\n      }\n    }\n    if( valid ){\n      ++depth;\n      if(size>1)\n\tmaxS.erase( maxS.find(size) );\n      solve(p+1);\n      if(size>1)\n\tmaxS.insert( make_pair(size,0) );\n      --depth;\n    }\n    for(int m = i; m<size+i; m++){\n      for(int n = j; n<size+j; n++){\n\tif( M[m][n] == depth ){\n\t  ++oneCount;\n\t  M[m][n]=1;\n\t}\n      }\n    }\n    if( M[i][j] > 1 )\n      solve(p+1);\n    return ;\n  }\n}\n\nint main()\n{\n  while(true){\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    minHW = min(H,W);\n    oneCount = 0;\n    cand_num = 0;\n    ans=inf;\n    greedy_ans = inf;\n    depth=2;\n    maxS.clear();\n\n    \n    calc();\n\n    solve_greedy(0);\n    ans = greedy_ans;\n    solve(0);\n\n    printf(\"%d\\n\", ans-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint p[10][10], s[10][10];\nvector< vector< int > > st;\nmap< vector< int >, int > dp;\nint W, H;\n\nint dfs(int x, int y)\n{\n  if(dp.count(st)) return (dp[st]);\n  if(y == H) return (0);\n  if(x == W) return (dfs(0, y + 1));\n  if(p[y][x] == 0) return (dfs(x + 1, y));\n  int ret = 1 << 30;\n  if(st[y][x] == 0) ret = min(ret, dfs(x + 1, y));\n  vector< pair< int, int > > beet;\n  for(int i = 0; i < s[y][x]; i++) {\n    for(int j = 0; j < s[y][x]; j++) {\n      if(st[y + i][x + j] == 1) {\n        beet.emplace_back(y + i, x + j);\n        st[y + i][x + j] = 0;\n      }\n    }\n  }\n  if(beet.size()) {\n    ret = min(ret, dfs(x + 1, y) + 1);\n    for(auto &p : beet) st[p.first][p.second] = 1;\n  }\n  return (dp[st] = ret);\n}\n\nint main()\n{\n  while(cin >> W >> H, W) {\n    st.resize(H);\n    for(int i = 0; i < H; i++) {\n      st[i].resize(W);\n      for(int j = 0; j < W; j++) {\n        cin >> p[i][j];\n        st[i][j] = p[i][j];\n      }\n    }\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        for(int k = min(H - i, W - j); k >= 1; k--) {\n          bool flag = true;\n          for(int l = 0; l < k; l++) {\n            for(int m = 0; m < k; m++) flag &= p[i + l][j + m];\n          }\n          if(flag) {\n            s[i][j] = k;\n            break;\n          }\n        }\n      }\n    }\n    cout << dfs(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tif(d+(remain?1:0)>min_res) return ret;\n\n\tint tboard[10];\n\trep(i,y,y+len[y][x]) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<len[y][x])-1)<<x;\n\trep(a,y,y+len[y][x]){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+len[y][x]) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(cin >> w >> h,w){\n\t\tclr(board,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tboard[i]|=(tmp<<j);\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\trep(a,i,h)rep(b,j,w) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w)rep(a,i,i+len[i][j])rep(b,j,j+len[i][j]) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\t//while(dfs(0,0,0)==inf) min_res++;\n\t\tcout << dfs(0,0,0,min_res)+add << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define FOR(i, b, e) for ( int i = b; i <= e; i++ )\n#define rep(i, n) for ( int i = 0; i < (int)n; i++)\n#define MAX 10\n\nint cnt, H, W, limit, maxw;\nint T[MAX][MAX], K[MAX][MAX], C[MAX][MAX], X[MAX][MAX];\nvector<pair<int, int> > v;\n\nint MD(){\n  int sum = 0;\n  rep(i, H) rep(j, W){\n    if ( C[i][j] && X[i][j] == 0 ) sum++;\n  }\n  return sum/(maxw*maxw);\n}\n\nbool dfs(int pos, int cost){\n  bool solved = true;\n  rep(i, H) rep(j, W) if ( C[i][j] && X[i][j] == 0 ) solved = false;\n  if ( solved ) return true;\n  if ( pos >= v.size() ) return false;\n  if ( cost + MD() >= limit ) return false;\n\n  for ( int i = v[pos].first+1; i < H; i++ ) rep(j, W){\n      if ( C[i][j] && X[i][j] == 0 ) return false;\n    }\n\n  int tmp[MAX][MAX];\n\n  if ( dfs(pos+1, cost) ) return true;\n\n  rep(i, H) rep(j, W) tmp[i][j] = X[i][j];\n  int pi = v[pos].first;\n  int pj = v[pos].second;\n  int w = T[pi][pj];\n  FOR(y, pi-w+1, pi) FOR(x, pj-w+1, pj) X[y][x]++;\n\n  if ( dfs(pos+1, cost+1) ) return true;\n  rep(i, H) rep(j, W) X[i][j] = tmp[i][j];\n\n  return false;\n}\n\nint idp(){\n  if ( maxw == 0 ) return 0;\n  for ( limit = MD(); limit < 100; limit++){\n    if ( dfs(0, 0) ) return limit;\n  }\n}\n\nvoid compute(){\n\n  bool U[MAX][MAX], V[MAX][MAX];\n\n  rep(i, H) rep(j, W) U[i][j] = true;\n  rep(i, H) rep(j, W) V[i][j] = false;\n  rep(i, H) rep(j, W) T[i][j] = K[i][j] = X[i][j] = 0;\n  rep(i, H) T[i][0] = (C[i][0])?1:0;\n  rep(j, W) T[0][j] = (C[0][j])?1:0;\n\n  FOR(i, 1, H-1) FOR(j, 1, W-1){\n    if ( C[i][j] ){\n      T[i][j] = min(T[i-1][j-1], min(T[i-1][j], T[i][j-1])) +1;\n    } else T[i][j] = 0;\n  }\n\n  rep(i, H) rep(j, W){\n    int w = T[i][j];\n    FOR(pi, i-(w-1), i) FOR(pj, j-(w-1), j) {\n      if ( i == pi && j == pj ) continue;\n      int l = max(i-pi, j-pj);\n      if ( w-l >= T[pi][pj] ) U[pi][pj] = false;\n    }\n  }\n\n  rep(i, H) rep(j, W){\n    if ( U[i][j] && T[i][j] ){\n      FOR(y, i-T[i][j]+1, i) FOR(x, j-T[i][j]+1, j) K[y][x]++;\n    }\n  }\n\n  v.clear();\n  rep(i, H) rep(j, W){\n    if ( U[i][j] && T[i][j] ){\n      bool f = false;\n      FOR(y, i-T[i][j]+1, i) FOR(x, j-T[i][j]+1, j){\n\tif ( K[y][x] == 1 ) f = true;\n      }\n      if ( f ){\n\tFOR(y, i-T[i][j]+1, i) FOR(x, j-T[i][j]+1, j) X[y][x]++;\n\tcnt++;\n\tT[i][j] = 0;\n      }\n    }\n  }\n  maxw = 0;\n  rep(i, H) rep(j, W){\n    if ( T[i][j] > 0 && U[i][j]){\n      maxw = max(maxw, T[i][j]);\n      v.push_back(make_pair(i, j));\n    }\n  }\n\n  reverse(v.begin(), v.end());\n}\n\nmain(){\n  while( cin >> W >> H ){\n    if ( W == 0 && H == 0 ) break;\n    rep(i, H) rep(j, W) cin >> C[i][j];\n    cnt = 0;\n    compute();\n    cout << idp() + cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// * template\n\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntemplate<class T, class U> inline void fill_array(T &e, const U &v) { e = v; }\ntemplate<class T, class U, size_t s> inline void fill_array(T (&a)[s], const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U, size_t s> inline void fill_array(array<T, s> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U> inline void fill_array(vector<T> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\n\n// * solve\n\nconstexpr int MAX_H = 10;\nconstexpr int MAX_W = 10;\n\ntypedef bitset<MAX_H * MAX_W> Bitset;\n\nint w, h;\nint ans;\n\ninline int index(const int x, const int y) {\n\treturn x + y * w;\n}\n\nvoid print(const Bitset &b) {\n\tcout << string(50, '-') << endl;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tcout << b[index(j, i)] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << string(50, '-') << endl;\n}\n\ninline void erase_subset(vector<Bitset> &bits) {\n\tfor(int i = static_cast<int>(bits.size()) - 1; i >= 0; --i) {\n\t\tfor(int j = 0; j < bits.size(); ++j) {\n\t\t\tif(i == j) continue;\n\n\t\t\tif((bits[i] & bits[j]) == bits[i]) {\n\t\t\t\tbits.erase(begin(bits) + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<Bitset> init(const vector<vector<int>> &p) {\n\tvector<vector<int>> sum(h + 2, vector<int>(w + 2, 0));\n\tfor(int y = 1; y <= h + 1; ++y) {\n\t\tfor(int x = 1; x <= w + 1; ++x) {\n\t\t\tsum[y][x] = p[y][x] + sum[y - 1][x] + sum[y][x - 1] - sum[y - 1][x - 1];\n\t\t}\n\t}\n\n\tconst auto calc = [&](int x1, int y1, int x2, int y2) -> int {\n\t\t--x1; --y1;\n\t\treturn x1 < 0 || y1 < 0 ? 0 : sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n\t};\n\n\tvector<Bitset> carpets;\n\tfor(int y = 1; y <= h; ++y) {\n\t\tfor(int x = 1; x <= w; ++x) {\n\t\t\tif(p[y][x] == 0) continue;\n\n\t\t\tfor(int dx : {-1, 1}) {\n\t\t\t\tfor(int dy : {-1, 1}) {\n\t\t\t\t\tif(p[y][x - dx] && p[y - dy][x] && p[y - dy][x - dx]) continue;\n\n\t\t\t\t\tint cx = x, cy = y;\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tconst int min_x = min(x, cx + dx);\n\t\t\t\t\t\tconst int min_y = min(y, cy + dy);\n\t\t\t\t\t\tconst int max_x = max(x, cx + dx);\n\t\t\t\t\t\tconst int max_y = max(y, cy + dy);\n\n\t\t\t\t\t\tif(calc(min_x, min_y, max_x, max_y) < (max_x - min_x + 1) * (max_y - min_y + 1)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcx += dx;\n\t\t\t\t\t\tcy += dy;\n\t\t\t\t\t}\n\n\t\t\t\t\tBitset tmp;\n\t\t\t\t\tfor(int i = min(y, cy); i <= max(y, cy); ++i) {\n\t\t\t\t\t\tfor(int j = min(x, cx); j <= max(x, cx); ++j) {\n\t\t\t\t\t\t\ttmp[index(j - 1, i - 1)] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcarpets.emplace_back(move(tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\terase_subset(carpets);\n\treturn carpets;\n}\n\nvoid dfs(Bitset current, int num, vector<Bitset> carpets) {\n\tfor(int i = 0; i < carpets.size(); ++i) {\n\t\tBitset tmp(carpets[i] & current);\n\t\tfor(int j = 0; j < carpets.size(); ++j) {\n\t\t\tif(i == j) continue;\n\t\t\ttmp &= ~carpets[j];\n\t\t}\n\n\t\tif(tmp.any()) {\n\t\t\tcurrent &= ~carpets[i];\n\t\t\t++num;\n\t\t}\n\t}\n\n\tif(num >= ans) return;\n\tif(current.none()) {\n\t\tans = num;\n\t\treturn;\n\t}\n\n\tfor(auto &e : carpets) e &= current;\n\terase_subset(carpets);\n\n\tfor(const auto &e : carpets) {\n\t\tconst Bitset next = current & ~e;\n\t\tif(next != current) {\n\t\t\tdfs(move(next), num + 1, carpets);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h && w) {\n\t\tBitset scratched;\n\t\tvector<vector<int>> p(h + 2, vector<int>(w + 2));\n\n\t\tfor(int y = 1; y <= h; ++y) {\n\t\t\tfor(int x = 1; x <= w; ++x) {\n\t\t\t\tcin >> p[y][x];\n\t\t\t\tif(p[y][x] == 1) scratched.set(index(x - 1, y - 1));\n\t\t\t}\n\t\t}\n\n\t\tconst vector<Bitset> carpets = init(p);\n\t\tans = h * w;\n\t\tdfs(scratched, 0, move(carpets));\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconstexpr int MAX = 10;\nconstexpr int INF = (1 << 29);\n\nint W, H;\nbool f[MAX][MAX], closed[MAX][MAX];\n\nbool poss_remove(int h, int w, int t)\n{\n    bool rem = 0;\n    for (int i = h; i < h + t; i++) {\n        for (int j = w; j < w + t; j++) {\n            if (!f[i][j]) {\n                return false;\n            }\n            if (!closed[i][j]) {\n                rem = 1;\n            }\n        }\n    }\n    return rem;\n}\n\nvoid fill_col(int h, int w, int t, int col)\n{\n    for (int i = h; i < h + t; i++) {\n        for (int j = w; j < w + t; j++) {\n            closed[i][j] = col;\n        }\n    }\n}\n\nbool reach(int h)\n{\n    for (int i = h; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (!closed[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool unreach(int h)\n{\n    for (int i = 0; i < h - 1; i++) {\n        for (int j = 0; j < W; j++) {\n            if (!closed[i][j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid print()\n{\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cout << !closed[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint res;\n\nvoid dfs(int h, int w, int c)\n{\n    if (reach(h)) {\n        res = min(res, c);\n        return;\n    }    \n\n    if (res <= c || unreach(h)) return;\n    \n    if (w == W) {\n        dfs(h + 1, 0, c);\n        return;\n    }\n    \n    if (!f[h][w]) {\n        dfs(h, w + 1, c);\n        return;\n    }\n\n    if (closed[h][w]) {\n        dfs(h, w + 1, c);\n    }\n    \n    for (int i = min(H - h, W - w); i >= 1; i--) {\n        if (!poss_remove(h, w, i)) continue;\n        //   cout << h << \" \" << w << \" \" << c << \" \" << i << endl;\n        fill_col(h, w, i, 1);\n        dfs(h, w + 1, c + 1);\n        fill_col(h, w, i, 0);\n    }    \n}\n\nint main()\n{\n    while (cin >> W >> H, W) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> f[i][j];\n                closed[i][j] = !f[i][j];\n            }\n        }\n        \n        res = INF;\n        dfs(0, 0, 0);\n        cout << res << endl;\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,n,dp[11][11],A[11][11],ans,cnt;\nbitset<100> B[11][11],C[11][11];\n\nvoid dfs(int d,bitset<100> s,int sco){\n  if(d==n){\n    ans=min(ans,sco);\n    return;\n  }\n  cnt++;\n  if(cnt>=10000000)return;\n  if(ans<=sco)return;\n  if(!A[d/w][d%w])dfs(d+1,s,sco);\n  else{\n    int y=d/w;\n    int x=d%w;\n    if((B[y][x]&s).any()){\n      bitset<100>p;\n      p.set(y*10+x);//(y*100+x);\n      if(!(s&p).any())dfs(d+1,s,sco);\n      dfs(d+1,(B[y][x]|s)^B[y][x],sco+1);\n    }\n    else dfs(d+1,s,sco);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    n=h*w;\n    memset(dp,0,sizeof(dp));\n    bitset<100> b;\n    r(i,h)r(j,w)cin>>A[i][j];//A[i][j]=dp[i][j];\n    r(i,h)r(j,w)if(A[i][j]){\n      int sum=1;\n      for(;;sum++){\n        int f=0;\n        for(int y=i;y<i+sum;y++){\n          for(int x=j;x<j+sum;x++){\n            if(A[y][x]==0)f++;\n          }\n        }\n        if(f){\n          sum--;\n          break;\n        }\n      }\n      bitset<100>tmp;\n      for(int y=i,k=0;k<sum;k++,y++){\n        for(int x=j,l=0;l<sum;l++,x++){\n          tmp.set(y*10+x);\n        }\n      }\n      b.set(i*10+j);\n      B[i][j]=tmp;\n    }\n    ans=100;\n    cnt=0;\n    dfs(0,b,0);\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Carpet {\n  int y, x, size;\n  bool contain(const auto& c) const {\n    if(c.x < x) return false;\n    if(x + size < c.x + c.size) return false;\n    if(c.y < y) return false;\n    if(y + size < c.y + c.size) return false;\n    return true;\n  }\n};\n\nint W, H;\nint P[12][12];\nint S[12][12];\nint L[12][12];\n\nint sum(int y1, int x1, int y2, int x2) {\n  return S[y2][x2] - S[y2][x1-1] - S[y1-1][x2] + S[y1-1][x1-1];\n}\n\nbool full(auto y1, auto x1, auto y2, auto x2) {\n  return sum(y1, x1, y2, x2) == (y2 - y1 + 1) * (x2 - x1 + 1);\n};\n\nint greedy() {\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] = P[i][j];\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] += S[i][j-1];\n  for(auto j = 1; j <= W; ++j) for(auto i = 1; i <= H; ++i) S[i][j] += S[i-1][j];\n\n  vector<Carpet> carpet;\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) {\n    auto size = -1;\n    for(auto k = 0; k < 10; ++k) {\n      if(H < i+k || W < j+k) break;\n      if(!full(i, j, i+k, j+k)) break;\n      size = k;\n    }\n    if(~size) carpet.push_back({i, j, size});\n  }\n\n  vector<bool> removed(carpet.size());\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) for(auto j = 0; j < carpet.size(); ++j) if(!removed[j]) if(i != j) if(carpet[i].contain(carpet[j])) removed[j] = true;\n\n  int res = 0;\n\n  vector<vector<int>> cnt(H+2, vector<int>(W+2));\n  vector<vector<int>> id(H+2, vector<int>(W+2));\n  for(auto k = 0; k < carpet.size(); ++k) if(!removed[k]) {\n    auto c = carpet[k];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) {\n      ++cnt[i][j];\n      id[i][j] = k;\n    }\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(cnt[i][j] == 1) if(!removed[id[i][j]]) {\n    removed[id[i][j]] = true;\n    ++res;\n    auto c = carpet[id[i][j]];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) P[i][j] = 0;\n  }\n\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) L[carpet[i].y][carpet[i].x] = carpet[i].size + 1;\n\n  return res;\n}\n\nbool dfs(int sy, int sx, int depth, int limit) {\n  int y, x;\n  for(y = sy; y <= H; ++y) {\n    for(x = (y==sy ? sx : 1); x <= W; ++x) {\n      if(L[y][x]) break;\n      if(P[y][x] == 1) return false;\n    }\n    if(L[y][x]) break;\n  }\n  if(y == H+1 || x == W+1) return true;\n  if(depth > limit) return false;\n  int dup[12][12];\n  memcpy(dup, P, 12*12*sizeof(int));\n  if(P[y][x] == 0) {\n    auto ny = y, nx = x + 1;\n    if(W < x) {++ny; nx = 1;}\n    if(dfs(ny, nx, depth, limit)) return true;\n  }\n  auto cnt = 0;\n  for(auto i = y; i < y + L[y][x]; ++i) for(auto j = x; j < x + L[y][x]; ++j) if(P[i][j] == 1) {\n    P[i][j] = 0;\n    ++cnt;\n  }\n  if(cnt == 0) return false;\n  if(dfs(y, x, depth + 1, limit)) return true;\n  memcpy(P, dup, 12*12*sizeof(int));\n  return false;\n}\n\nint solve() {\n  auto fix = greedy();\n  for(auto i = 0; i <= 100; ++i) {\n    if(dfs(1, 1, 0, i)) return fix + i;\n  }\n  assert(false);\n}\n\nint main() {\n  while(cin >> W >> H, W | H) {\n    memset(P, 0, 12*12*sizeof(int));\n    memset(S, 0, 12*12*sizeof(int));\n    memset(L, 0, 12*12*sizeof(int));\n    for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> P[i][j];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Carpet {\n  int y, x, size;\n  bool contain(const auto& c) const {\n    if(c.x < x) return false;\n    if(x + size < c.x + c.size) return false;\n    if(c.y < y) return false;\n    if(y + size < c.y + c.size) return false;\n    return true;\n  }\n};\n\nint W, H;\nint S[12][12];\nint L[12][12];\n\nint sum(int y1, int x1, int y2, int x2) {\n  return S[y2][x2] - S[y2][x1-1] - S[y1-1][x2] + S[y1-1][x1-1];\n}\n\nbool full(auto y1, auto x1, auto y2, auto x2) {\n  return sum(y1, x1, y2, x2) == (y2 - y1 + 1) * (x2 - x1 + 1);\n};\n\nint greedy(auto& P) {\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] = P[i][j];\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] += S[i][j-1];\n  for(auto j = 1; j <= W; ++j) for(auto i = 1; i <= H; ++i) S[i][j] += S[i-1][j];\n\n  vector<Carpet> carpet;\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) {\n    auto size = -1;\n    for(auto k = 0; k < 10; ++k) {\n      if(H < i+k || W < j+k) break;\n      if(!full(i, j, i+k, j+k)) break;\n      size = k;\n    }\n    if(~size) carpet.push_back({i, j, size});\n  }\n\n  vector<bool> removed(carpet.size());\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) for(auto j = 0; j < carpet.size(); ++j) if(!removed[j]) if(i != j) {\n    if(!carpet[i].contain(carpet[j])) continue;\n    removed[j] = true;\n    break;\n  }\n\n  int res = 0;\n\n  vector<vector<int>> cnt(H+2, vector<int>(W+2));\n  vector<vector<int>> id(H+2, vector<int>(W+2));\n  for(auto k = 0; k < carpet.size(); ++k) if(!removed[k]) {\n    auto c = carpet[k];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) {\n      ++cnt[i][j];\n      id[i][j] = k;\n    }\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(cnt[i][j] == 1) if(!removed[id[i][j]]) {\n    removed[id[i][j]] = true;\n    ++res;\n    auto c = carpet[id[i][j]];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) P[i][j] = 0;\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) L[i][j] = 0;\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) L[carpet[i].y][carpet[i].x] = carpet[i].size + 1;\n\n  return res;\n}\n\nbool dfs(auto P, int sy, int sx, int depth, int limit) {\n  int y, x;\n  for(y = sy; y <= H; ++y) {\n    for(x = (y==sy ? sx : 1); x <= W; ++x) {\n      if(L[y][x]) break;\n      if(P[y][x] == 1) return false;\n    }\n    if(L[y][x]) break;\n  }\n  if(y == H+1 || x == W+1) return true;\n  if(depth > limit) return false;\n  if(P[y][x] == 0) {\n    auto ny = y, nx = x + 1;\n    if(W < x) {++ny; nx = 1;}\n    if(dfs(P, ny, nx, depth, limit)) return true;\n  }\n  auto cnt = 0;\n  for(auto i = y; i < y + L[y][x]; ++i) for(auto j = x; j < x + L[y][x]; ++j) if(P[i][j] == 1) {\n    P[i][j] = 0;\n    ++cnt;\n  }\n  return cnt ? dfs(P, y, x, depth + 1, limit) : false;\n}\n\nint solve(auto P) {\n  auto fix = greedy(P);\n  for(auto i = 0; i <= 100; ++i) {\n    if(dfs(P, 1, 1, 0, i)) return fix + i;\n  }\n  assert(false);\n}\n\nint main() {\n  while(cin >> W >> H, W | H) {\n    vector<vector<int>> P(H+2, vector<int>(W+2));\n    for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> P[i][j];\n    cout << solve(P) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint w, h, d[12][12], ans;\n\nvoid solve(int x, int y, int c){\n\tif(ans <= c) return;\n\tif(17 < ans && ans < INF) return;\n\tif(x == w && y == h-1){\n\t\tchmin(ans, c);\n\t\treturn ;\n\t}\n\tif(x == w){\n\t\ty ++;\n\t\tx = 0;\n\t}\n\tif(d[y][x] != 1) solve(x+1, y, c);\n\tif(ans <= c) return;\n\tif(17 < ans && ans < INF) return;\n\tif(d[y][x] != 0){\n\t\tint r = 1;\n\t\tfor(;;r++){\n\t\t\tint f = 1;\n\t\t\tREP(i, r)REP(j, r) if(d[y+i][x+j] == 0) f = 0;\n\t\t\tif(!f) break;\n\t\t}\n\t\tr --;\n\t\t\n\t\t// check pruning\n\t\tint pos[3][2] = {{y-1,x-1},{y-1,x},{y,x-1}};\n\t\tREP(k, 3){\n\t\t\tif(pos[k][0] < 0 || pos[k][1] < 0) continue;\n\t\t\tint f = 1;\n\t\t\tREP(i, r+1)REP(j, r+1) if(d[pos[k][0]+i][pos[k][1]+j] == 0) f = 0;\n\t\t\tif(f) return;\n\t\t}\n\t\tvector<pii> ch;\n\t\tREP(i, r)REP(j, r){\n\t\t\tif(d[y+i][x+j] == 1) ch.push_back(pii(y+i, x+j));\n\t\t\td[y+i][x+j] = -1;\n\t\t}\n\t\tif(ch.empty()) return ;\n\t\tsolve(x+1, y, c+1);\n\t\tREP(i, ch.size()) d[ch[i].first][ch[i].second] = 1;\n\t}\n\t\n}\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> w >> h, w){\n\t\tmemset(d, 0, sizeof(d));\n\t\tREP(i, h)REP(j, w) cin >> d[i][j];\n\t\tans = INF;\n\t\tsolve(0, 0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#define MAX_W 10\n#define INF 1E9\n\nusing namespace std;\n\nint w, h; \nint s[MAX_W][MAX_W]; //可延伸的最大正方形邊長\nint limit;\nint ct;\n\nvoid show(vector<int>& cover){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tprintf(\"%d \", (cover[i] >> (w - 1 - j)) & 1);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\nvoid init(vector<int>& f){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\ts[i][j] = (f[i] >> (w - 1 - j)) & 1;\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tfor(int k = 0;; k++){\n\t\t\t\tbool ok = true;\n\t\t\t\tif(i + k < h && j + k < w){\n\t\t\t\t\tfor(int l = 0; ok && l <= k; l++){\n\t\t\t\t\t\tif(s[i + k][j + l] == 0 || s[i + l][j + k] == 0) ok = false;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\ts[i][j] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint hstar(vector<int> f){\n\t//選取盡量多的點，其中每個集合最多只能有一個點被選中\n\tint res = 0;\n\tbool update;\n\tdo{\n\t\tupdate = false;\n\t\tint m_i, m_j, max = 0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(s[i][j] > 0){\n\t\t\t\t\tint tmp = 0, m = ((1 << s[i][j]) - 1) <<  (w - j - s[i][j]);\n\t\t\t\t\tfor(int k = 0; k < s[i][j]; k++){\n\t\t\t\t\t\ttmp += __builtin_popcount(f[i + k] & m);\n\t\t\t\t\t}\n\t\t\t\t\tif(max < tmp){\n\t\t\t\t\t\tmax = tmp;\n\t\t\t\t\t\tm_i = i, m_j = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max > 0){\n\t\t\tint m = ((1 << s[m_i][m_j]) - 1) << (w - m_j - s[m_i][m_j]);\n\t\t\tfor(int i = 0; i < s[m_i][m_j]; i++) f[m_i + i] &= ~m;\n\t\t\tres++;\n\t\t\tupdate = true;\n\t\t}\n\t}while(update);\n\treturn res;\n}\n\nint dfs(int num, vector<int> f){\n\tif(num + hstar(f) > limit) return INF;\n\n\tct++;\n\tbool check = true;\n\tvector<int> reset(f.begin(), f.end());\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tint k = s[i][j];\n\t\t\tif(k > 0){\n\t\t\t\tint tmp = ((1 << k) - 1) << (w - j - k), n = 0;\n\t\t\t\tfor(int m = 0; m < k; m++){\n\t\t\t\t\tif((f[i + m] & ~tmp) == f[i + m]) n++;\n\t\t\t\t\tf[i + m] &= ~tmp;\n\t\t\t\t}\n\t\t\t\tif(n < k){\n\t\t\t\t\tcheck = false;\n\t\t\t\t\tif(dfs(num + 1, f) < INF) return num;\n\t\t\t\t}\n\t\t\t\tf.assign(reset.begin(), reset.end());\n\t\t\t}\n\t\t}\n\t}\n\treturn (check ? num : INF);\n}\nint solve(vector<int>& f){\n\tinit(f);\n\tct = 0;\n\tfor(limit = hstar(f);; limit++){\n\t\t// printf(\"limit = %d\\n\", limit);\n\t\tif(dfs(0, f) < INF) return limit;\n\t}\n\t// cout << hstar(cover) << endl;\n}\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tvector<int> f(h, 0);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tf[i] = 0;\n\t\t\tint a;\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> a;\n\t\t\t\tf[i] = (f[i] << 1) | a;\n\t\t\t}\n\t\t}\n\t\tcout << solve(f) << endl;\n\t\t// cout << \"ct = \" << ct << \"\\n\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nint makeCode(int table[10]){\n\tint ret = 0;\n\n\tfor(int col = 0; col < W; col++){\n\t\tif(table[col] == 0){\n\t\t\tret += POW[col];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\tif(base_row == H-2 && base_col == 0){ //?????????2?????§??????????????\\??????\n\n\t\tint code1 = makeCode(info.table[H-2]);\n\t\tint code2 = makeCode(info.table[H-1]);\n\n\t\tif(check[code1][code2] <= info.num)return;\n\n\t\tcheck[code1][code2] = info.num;\n\t}\n\n\t//printf(\"ans:%d\\n\",ans);\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\t\t\tInfo next_not;\n\n\t\t\tcopyTable(next_not,info.table,base_row);\n\t\t\tnext_not.num = info.num;\n\n\t\t\tint must_add = 0;\n\t\t\tbool FLG = false;\n\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\tfor(int row = base_row; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}else if(next_not.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)must_add++;\n\n\t\t\tif(next_not.num+must_add < ans){\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num+1;\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(next_info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tif(next_info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_info,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < POW[W]; i++){\n\t\tfor(int k = 0; k < POW[W]; k++)check[i][k] = BIG_NUM;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nint H,W,mincost;\nint P[10][10],bin[10],bc[(1<<10)];\nint put[10][10],weight[10][10],counter[10][10];\n\nbool can_put(int len,int x,int y){\n  REP(i,y,y+len)REP(j,x,x+len) if( !P[i][j] ) return false;\n  return true;\n}\n\nvoid dfs(int cur,int cost,int remain){\n\n  if( cost >= mincost ) return;\n  if( cost + ((remain>0)?1:0) >= mincost ) return;\n\n  if( cur >= H*W ) {\n    mincost = min(mincost,cost);\n    return;\n  }\n\n  int x = cur % W, y = cur / W;\n  if( cost + max(0,weight[y][x]-4) >= mincost ) return;\n\n  if( !P[y][x] || counter[y][x] == 1 ) {\n    dfs(cur+1,cost,remain);\n    return;\n  }\n\n  if( (bin[y]>>x) & 1 ) dfs(cur+1,cost,remain);\n\n  int len = put[y][x];\n  int bitmask = ((1<<len)-1)<<x;\n  int buf[len];\n  int add = 0, nremain = remain;\n  rep(j,len) {\n    buf[j] = bin[y+j];\n    add += len - bc[((1<<len)-1)&(bin[y+j]>>x)];\n    bin[y+j] |= bitmask;\n  }\n  nremain -= add;\n  if( add ) dfs(cur+1,cost+1,nremain);\n  rep(j,len) bin[y+j] = buf[j];\n\n}\n\nint par[110];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint find(int x){\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\ninline void unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = par[y];\n}\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\nint main(){\n\n  rep(i,(1<<10)) bc[i] = __builtin_popcount(i);\n\n  while( scanf(\"%d%d\",&W,&H), W | H ){\n\n    rep(i,H){\n      bin[i] = 0;\n      rep(j,W){\n        cin >> P[i][j];\n        put[i][j] = 0;\n      }\n    }\n\n\n    rep(i,H*W) par[i] = i;\n\n    rep(i,H)rep(j,W)if(!P[i][j])rep(k,4){\n      int nx = j + dx[k], ny = i + dy[k];\n      if( !isValid(nx,ny) ) continue;\n      if( !P[ny][nx] ) unit(j+i*W,nx+ny*W);\n    }\n\n    rep(i,H)rep(j,W)weight[i][j] = 0;\n\n    set<int> S;\n    bool first = false;\n    for(int i=H-1;i>=0;i--) for(int j=W-1;j>=0;j--) {\n        if( P[i][j] ) first = true;\n        if( first && !P[i][j] ) S.insert(find(j+i*W));\n        weight[i][j] = S.size();\n      }\n\n    rep(y,H) rep(x,W) if( P[y][x] ) {\n      for(int len=min(H,W);len>=1;len--){\n        if( x + len - 1 < W && y + len - 1 < H ) {\n          if( can_put(len,x,y) ){\n            put[y][x] = len;\n            break;\n          }\n        }\n      }\n    }\n\n    rep(i,H)rep(j,W) counter[i][j] = 0;\n    rep(i,H)rep(j,W)if(P[i][j]){\n      REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n        counter[y][x]++;\n      }\n    }\n\n    rep(i,H){\n      rep(j,W){\n        if( counter[i][j] == 1 ){\n          REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n            bin[y] |= (1<<x);\n          }\n        }\n      }\n    }\n\n    int add = 0;\n    int remain = 0;\n    mincost = 0;\n    rep(i,H)rep(j,W)remain += ((bin[i]>>j)&1),mincost += P[i][j];\n    remain = mincost - remain;\n    dfs(0,0,remain);\n\n    rep(i,H)rep(j,W)if(counter[i][j]==1)add++;\n    cout << mincost+add << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nstruct state\n{\n\tvector<vector<int> > v;\n\n\tint dist1;\n\tint dist2;\n\n\tstate(vector<vector<int> > v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 < s2.dist1 + s2.dist2; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 > s2.dist1 + s2.dist2; }\n\nint W, H; vector<vector<int> > start;\n\nmap<vector<vector<int> >, bool> M;\n\nint getdistance(vector<vector<int> > v)\n{\n\tint ret = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (v[i][j] == 1)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tM.clear();\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tstart = vector<vector<int> >(H, vector<int>(W));\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &start[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<state, vector<state>, greater<state> > que;\n\n\t\tque.push(state(start, 0, getdistance(start))); M[start] = true;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tstate s1 = que.top(); que.pop();\n\n\t\t\tif (s1.dist2 == 0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", s1.dist1); break;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= 10; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= H - i; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= W - i; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > v2 = s1.v;\n\n\t\t\t\t\t\tbool flag = true;\n\n\t\t\t\t\t\tfor (int l = j; l < j + i; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = k; m < k + i; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (v2[l][m] == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflag = true; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tv2[l][m] = 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flag) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!M[v2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tM[v2] = true;\n\n\t\t\t\t\t\t\tque.push(state(v2, s1.dist1 + 1, getdistance(v2)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint w, h, p[10][10], cnt;\nbool scrach[10][10];\n\nbool check2(int y, int x){\n  if(y<0||x<0||h<=y||w<=x) return true;\n  return (!scrach[y][x])||(scrach[y][x]&&!p[y][x]);\n}\n\nint check(int y, int x, int l){\n  \n  if(h<=y+l||w<=x+l) return 0;\n  \n  int y1=y, x1=x;\n  int y2=y+l, x2=x;\n  int y3=y, x3=x+l;\n  int y4=y+l, x4=x+l;\n  \n  bool flag=false;\n  \n  flag|=(check2(y1-1,x1)&&check2(y1,x1-1)&&p[y1][x1]);\n  flag|=(check2(y2+1,x2)&&check2(y2,x2-1)&&p[y2][x2]);\n  flag|=(check2(y3-1,x3)&&check2(y3,x3+1)&&p[y3][x3]);\n  flag|=(check2(y4+1,x4)&&check2(y4,x4+1)&&p[y4][x4]);\n  \n  bool f=true;\n\n  int res=0;\n  \n  for(int i=y;i<=y+l;i++)\n    for(int j=x;j<=x+l;j++){\n      if(!scrach[i][j]) f=false;\n      res+=p[i][j];\n    }\n  \n  flag&=f;\n  \n  if(flag) return res;  \n  \n  return 0;\n}\n\nvoid solve(){\n\n  int ans=0;\n  \n  for(int l=9;l>=0;l--){\n\n    int flag=1;\n    \n    while(flag&&cnt){\n      \n      flag=0;\n      \n      int maxr=0, y, x;\n      \n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  int r=check(i,j,l);\n\t  \n\t  if(maxr<r){\n\t    flag=1;\n\t    maxr=r;\n\t    y=i;\n\t    x=j;\n\t  }\n\t}\n\t\n      }\n\n      if(flag){\n\t\n\tfor(int i=y;i<=y+l;i++)\n\t  for(int j=x;j<=x+l;j++) p[i][j]=0;\n\t\n\tcnt-=maxr;\n\tans++;\t\n      }\n      \n    }\n    \n  }\n\n  cout<<ans<<endl;\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>w>>h;\n    if(!w&&!h) break;\n    \n    cnt=0;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin>>p[i][j];\n\tcnt+=p[i][j];\n\tscrach[i][j]=p[i][j];\n      }\n\n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint p[10][10], s[10][10];\nvector< vector< int > > st;\nmap< vector< vector< int > >, int > dp;\nint W, H;\n\nint dfs(int x, int y)\n{\n  if(dp.count(st)) return (dp[st]);\n  if(y == H) return (0);\n  if(x == W) return (dfs(0, y + 1));\n  if(p[y][x] == 0) return (dfs(x + 1, y));\n  int ret = 1 << 30;\n  if(st[y][x] == 0) ret = min(ret, dfs(x + 1, y));\n  vector< pair< int, int > > beet;\n  for(int i = 0; i < s[y][x]; i++) {\n    for(int j = 0; j < s[y][x]; j++) {\n      if(st[y + i][x + j] == 1) {\n        beet.emplace_back(y + i, x + j);\n        st[y + i][x + j] = 0;\n      }\n    }\n  }\n  if(beet.size()) {\n    ret = min(ret, dfs(x + 1, y) + 1);\n    for(auto &p : beet) st[p.first][p.second] = 1;\n  }\n  return (dp[st] = ret);\n}\n\nint main()\n{\n  while(cin >> W >> H, W) {\n    st.resize(H);\n    for(int i = 0; i < H; i++) {\n      st[i].resize(W);\n      for(int j = 0; j < W; j++) {\n        cin >> p[i][j];\n        st[i][j] = p[i][j];\n      }\n    }\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        for(int k = min(H - i, W - j); k >= 1; k--) {\n          bool flag = true;\n          for(int l = 0; l < k; l++) {\n            for(int m = 0; m < k; m++) flag &= p[i + l][j + m];\n          }\n          if(flag) {\n            s[i][j] = k;\n            break;\n          }\n        }\n      }\n    }\n    cout << dfs(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num = 1;\n\t\t\t\tgoto SHISHIMARU;\n\t\t\t}\n\t\t}\n\t}\n\nSHISHIMARU:\n\tif(new_num == 0){\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\n\t\tfor(int row = base_row; row <= base_row; row++){\n\t\t\tfor(int col = base_col; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = base_row+1; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nint makeCode(int table[10]){\n\tint ret = 0;\n\n\tfor(int col = 0; col < W; col++){\n\t\tif(table[col] == 0){\n\t\t\tret += POW[col];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\tif(base_row == H-2 && base_col == 0){ //?????????2?????§??????????????\\??????\n\n\t\tint code1 = makeCode(info.table[H-2]);\n\t\tint code2 = makeCode(info.table[H-1]);\n\n\t\tif(check[code1][code2] <= info.num)return;\n\n\t\tcheck[code1][code2] = info.num;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < POW[W]; i++){\n\t\tfor(int k = 0; k < POW[W]; k++)check[i][k] = BIG_NUM;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx];\n\t\t\trep(a,cy,cy+l)rep(b,cx,cx+l) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n    short table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\n\n\nbool rangeCheck(int row,int col){\n    if(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n    else{\n        return false;\n    }\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n    if(info.num == ans)return;\n\n    if(base_row == H){\n        ans = info.num;\n        return;\n    }\n\n    if(info.table[base_row][base_col] == -1){\n\n        if(base_col == W-1){\n            recursive(info,base_row+1,0);\n        }else{\n            recursive(info,base_row,base_col+1);\n        }\n        return;\n    }\n\n\n    int new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n    if(new_num == 0){\n\n        if(base_col != W-1){\n            recursive(info,base_row,base_col+1);\n        }else{\n            recursive(info,base_row+1,0);\n        }\n    }else{\n\n        if(info.table[base_row][base_col] != 0){\n\n            if(base_col != W-1){\n                recursive(info,base_row,base_col+1);\n            }else{\n                recursive(info,base_row+1,0);\n            }\n        }\n\n        for(int i = 0; i < max_size[base_row][base_col]; i++){\n            for(int k = 0; k < max_size[base_row][base_col]; k++){\n                info.table[base_row+i][base_col+k]++;\n            }\n        }\n\n        int must_add = 0;\n        bool FLG = false;\n\n        for(int row = base_row; row <= base_row; row++){\n            for(int col = base_col; col < W; col++){\n               if(info.table[row][col] == 0 && first_table[row][col] > 1){\n                    FLG = true;\n                    goto SHISHIMARU;\n               }\n            }\n        }\n\n        for(int row = base_row+1; row < H; row++){\n            for(int col = 0; col < W; col++){\n                if(info.table[row][col] == 0 && first_table[row][col] > 1){\n                    FLG = true;\n                    goto SHISHIMARU;\n                }\n            }\n        }\n\nSHISHIMARU:\n\n        if(FLG)must_add++;\n\n        info.num++;\n\n        if(info.num+must_add < ans){\n            if(base_col != W-1){\n                recursive(info,base_row,base_col+1);\n            }else{\n                recursive(info,base_row+1,0);\n            }\n        }\n    }\n}\n\n\nvoid func(){\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            scanf(\"%d\",&first_table[row][col]);\n            first_table[row][col] -= 1;\n        }\n    }\n\n    bool FLG;\n    int size;\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            if(first_table[row][col] == -1){\n                max_size[row][col] = 0;\n            }else{\n                size = 1;\n\n                FLG = true;\n\n                while(true){\n                    for(int i = 0; i < size; i++){\n                        for(int k = 0; k < size; k++){\n                            if(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n                                FLG = false;\n                                break;\n                            }\n                        }\n                        if(!FLG)break;\n                    }\n                    if(!FLG){\n                        size -= 1;\n                        break;\n                    }\n                    size++;\n                }\n\n                max_size[row][col] = size;\n\n                for(int calc_size = 1; calc_size <= size; calc_size++){\n                    for(int i = 0; i < calc_size; i++){\n                        for(int k = 0; k < size; k++){\n                            first_table[row+i][col+k]++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    Info start;\n    start.num = 0;\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            if(first_table[row][col] == -1){\n            \tstart.table[row][col] = -1;\n            }else{\n                if(first_table[row][col] == 1){\n                \t start.num++;\n                \t start.table[row][col] = 1;\n                }else{\n                     start.table[row][col] = 0;\n                }\n            }\n        }\n    }\n\n    ans = BIG_NUM;\n\n    recursive(start,0,0);\n\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n\n    for(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n    while(true){\n        scanf(\"%d %d\",&W,&H);\n        if(W == 0 && H == 0)break;\n\n        func();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nchar board[11][11];\nbool used[111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    rep(i,h)rep(j,w){\n      cin>>board[i][j];\n      board[i][j]-='0';\n    }\n    vector<int> g[10101];\n    // 0-9999 / 10000-10100\n    rep(ti,h)rep(tj,w)rep(si,ti)rep(sj,tj){\n      int sum=0;\n      repl(i,si,ti+1)repl(j,sj,tj+1){\n        sum+=board[i][j];\n      }\n      if(sum==(ti-si+1)*(tj-sj+1)&&(ti-si)==(tj-sj)){\n        int cv=si*1000+sj*100+ti*10+tj;\n        repl(i,si,ti+1)repl(j,sj,tj+1){\n          int bv=10000+i*10+j;\n          g[cv].pb(bv); g[bv].pb(cv);\n        }\n      }\n    }\n    memset(used,0,sizeof(used));\n    int res=0;\n    rep(i,h)rep(j,w){\n      if(board[i][j]==1&&!used[i*10+j]){\n        res++;\n        int maxv=-1,maxc=0;\n        each(v,g[i*10+j+10000]){\n          int cnt=0;\n          each(nv,g[v]){\n            if(!used[nv-10000])cnt++;\n          }\n          if(maxc<cnt){\n            maxc=cnt;\n            maxv=v;\n          }\n        }\n        rep(k,g[maxv].size()){\n          used[g[maxv][k]-10000]=true;\n        }\n      }\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<map>\n\n#define N 16\n#define INF (1<<27)\n\nusing namespace std;\n\nint H,W;\nint M[N][N];\nint maxSizes[N][N];\nint oneCount;\nint minHW;\nbool bGreedy;\nint ans;\nmultimap<int,int,greater<int> > maxS;\n\nint getHeuristic();\nvoid calc();\nvoid solve(int pos, int depth);\n\nint getHeuristic()\n{\n  int msz;\n  if( maxS.empty() ) msz = 1;\n  else msz = maxS.begin()->first;\n  msz *= msz;\n  return oneCount/msz + (oneCount%msz>0);\n}\n\nvoid calc(){\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 1) oneCount++;\n      int size = 0;\n      for(size = 1; size <= minHW; ++size){\n\tfor(int m = i; m<i+size; m++){\n\t  for(int n = j; n<j+size; n++){\n\t    if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t      --size;\n\t      goto next;\n\t    }\n\t  }\n\t}\n\tif(i+size>=H||j+size>=W)break;\n      }\n      next:;\n      maxSizes[i][j] = size;\n      if(size>1){\n\tmaxS.insert( make_pair(size,0) );\n      }\n    }\n  }\n  return ;\n}\n\nvoid solve(int pos, int depth){\n  /*\n    printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W, getHeuristic());\n    for(int k = 0; k < H; ++k){\n      for(int l = 0; l < W; ++l){\n\tif(l>0)putchar(' ');\n\tprintf(\"%2d\", M[k][l]);\n      }\n      putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  if(oneCount==0){\n    ans = min(ans, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic()>=ans){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < H*W; ++p){\n    int i = p / W;\n    int j = p % W;\n    if( bGreedy ? (M[i][j] == 1) : (M[i][j] >= 1) ){\n      int size = maxSizes[i][j];\n      bool valid=false;\n      for(int m = i; m<size+i; m++){\n\tfor(int n = j; n<size+j; n++){\n\t  if(M[m][n]==1){\n\t    valid=true;\n\t    --oneCount;\n\t    M[m][n]=depth;\n\t  }\n\t}\n      }\n      if( valid ){\n\tif(size>1){\n\t  maxS.erase( maxS.find( size ) );\n\t}\n\tsolve(p+1,depth+1);\n\tif(size>1){\n\t  maxS.insert( make_pair(size,0) );\n\t}\n      }\n      for(int m = i; m<size+i; m++){\n\tfor(int n = j; n<size+j; n++){\n\t  if( M[m][n] == depth ){\n\t    ++oneCount;\n\t    M[m][n]=1;\n\t  }\n\t}\n      }\n      if( M[i][j] > 1 )\n\tsolve(p+1,depth);\n      return ;\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    minHW = min(H,W);\n    oneCount = 0;\n    maxS.clear();\n    ans=INF;\n    calc();\n\n    bGreedy=true;\n    solve(0,2);\n    bGreedy=false;\n    solve(0,2);\n\n    printf(\"%d\\n\", ans-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntemplate<class T> T gcd( T a, T b ) {\n\treturn !b ? a : gcd( b, a % b );\n}\ntemplate<class T> T lcm( T a, T b ) {\n\treturn a / gcd( a, b ) * b;\n}\ntemplate<class T> string print_v( vector<T> v ) {\n\tOSS oss;\n\tfor ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end();\n          ++it_i ) {\n\t\toss << *it_i << \", \";\n\t}\n\treturn oss.str();\n}\n\nconst int ks = 1;\nconst int kr[ks] = { -1 };\nconst int kc[ks] = { -1 };\nint w, h;\n\nvoid print( VVI T ) {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j] << \",\";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint main() {\n    while ( cin >> w >> h && w ) {\n        VVI T( h, VI( w ) );\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                cin >> T[i][j];\n            }\n        }\n        VVI dp = T;\n        for ( int i = h - 1 - 1; i >= 0; -- i ) {\n            for ( int j = w - 1 - 1; j >= 0; -- j ) {\n                if ( dp[i][j] == 0 ) continue;\n                dp[i][j] = min( dp[i+1][j+1], min( dp[i+1][j], dp[i][j+1] ) ) + 1;\n            }\n        }\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                // cout << dp[i][j] << \", \";\n            }\n            // cout << endl;\n        }\n        // cout << endl;\n        VVI used = T;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                used[i][j] = used[i][j] == 1 ? 0 : 1;\n                // cout << used[i][j] << \", \";\n            }\n            // cout << endl;\n        }\n        int res = 0;\n        for ( int r = h - 1; r >= 0; -- r ) {\n            for ( int c = w - 1; c >= 0; -- c ) {\n                if ( used[r][c] != 0 ) continue;\n                res ++;\n                for ( int i = 0; i < h; ++ i ) {\n                    for ( int j = 0; j < w; ++ j ) {\n                        if ( i <= r && r <= i + dp[i][j] - 1 && j <= c && c <= j + dp[i][j] - 1 ) {\n                            for ( int dr = 0; dr < dp[i][j]; ++ dr ) {\n                                for ( int dc = 0; dc < dp[i][j]; ++ dc ) {\n                                    used[i+dr][j+dc] = 1;\n                                }\n                            }\n                            goto out;\n                        }\n                    }\n                }\n            out:;\n                // cout << \"used change 2\" << endl;\n                for ( int i = 0; i < h; ++ i ) {\n                    for ( int j = 0; j < w; ++ j ) {\n                        // cout << used[i][j] << \", \";\n                    }\n                    // cout << endl;\n                }\n            }\n        }\n        cout << res << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\t//ans = min(ans,info.num);\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tbool FLG = false;\n\t\tint must_add = 0;\n\n\t\t//????????????????????????????????????\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(info.table[H-1][col] == 0 && first_table[H-1][col] > 1){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<functional>\n\n#define N 16\n#define INF (1<<27)\n\nusing namespace std;\n\nint H,W;\nint M[N][N];\nint maxSizes[N][N];\nint oneCount;\nmultimap<int,int,greater<int> > squareSizes;\nint bestAns = INF;\nint minHW;\nbool bGreedy;\n\nint getHeuristic()\n{\n  if(squareSizes.empty())return 0;\n  multimap<int,int>::iterator it=squareSizes.begin();\n  int maxSize = it->first;\n  if(maxSize==0)return 0;\n  maxSize *= maxSize;\n  return (oneCount / maxSize) + (oneCount%maxSize>0);\n}\n\nvoid calc(){\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 1) oneCount++;\n      int size = 0;\n      for(size = 1; size <= minHW; ++size){\n\tfor(int m = i; m<i+size; m++){\n\t  for(int n = j; n<j+size; n++){\n\t    if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t      --size;\n\t      goto next;\n\t    }\n\t  }\n\t}\n\tif(i+size>=H||j+size>=W)break;\n      }\n      next:;\n      maxSizes[i][j] = size;\n      squareSizes.insert(make_pair(size,0));\n    }\n  }\n  return ;\n}\n\nvoid solve(int pos, int depth){\n  /*\n  printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W, getHeuristic(H,W,M));\n  for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n      if(l>0)putchar(' ');\n      printf(\"%2d\", M[k][l]);\n    }\n    putchar('\\n');\n  }\n  putchar('\\n');\n  */\n\n  // completed.\n  if(oneCount==0){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic()>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < H*W; ++p){\n    int i = p / W;\n    int j = p % W;\n    if( M[i][j] == 0 ){\n      continue;\n    }else if( bGreedy ? (M[i][j] == 1) : (M[i][j] >= 1) ){\n      int size = maxSizes[i][j];\n      bool valid=false;\n      for(int m = i; m<size+i; m++){\n\tfor(int n = j; n<size+j; n++){\n\t  if(M[m][n]==1){\n\t    valid=true;\n\t    --oneCount;\n\t    M[m][n]=depth;\n\t  }\n\t}\n      }\n      if( valid ){\n\tsquareSizes.erase( squareSizes.find( size ) );\n\tsolve(p+1,depth+1);\n\tsquareSizes.insert(make_pair(size,0));\n      }\n      for(int m = i; m<size+i; m++){\n\tfor(int n = j; n<size+j; n++){\n\t  if( M[m][n] == depth ){\n\t    ++oneCount;\n\t    M[m][n]=1;\n\t  }\n\t}\n      }\n      if( M[i][j] > 1 )\n\tsolve(p+1,depth);\n      return ;\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    oneCount = 0;\n    squareSizes.clear();\n    calc();\n\n    bGreedy=true;\n    solve(0,2);\n    bGreedy=false;\n    solve(0,2);\n\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tshort table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nshort first_table[10][10],max_size[10][10];\n\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num = 1;\n\t\t\t\tgoto SHISHIMARU;\n\t\t\t}\n\t\t}\n\t}\n\nSHISHIMARU:\n\tif(new_num == 0){\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\n\t\tfor(int row = base_row; row <= base_row; row++){\n\t\t\tfor(int col = base_col; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = base_row+1; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[12][12];\nint C[12];\nint h[12][12][200];\nint w[12][12][200];\nint n[12][12][200];\nint sz[12][12];\nint P[12][12];\nint H,W;\nint valid(int a,int b,int t){\n\tif(a<0||b<0||a+t>H||b+t>W)return 0;\n\tfor(int i=0;i<t;i++)for(int j=0;j<t;j++)if(!c[a+i][b+j])return 0;\n\treturn 1;\n}\nint lim;\nint dfs(int a,int b,int v){\n\tif(a==H)return 1;\n\tif(b==W)return dfs(a+1,0,v);\n\tif(((C[a]>>(b*2))&3)!=1)return dfs(a,b+1,v);\n\tif(v==lim)return 0;\n\tint last[12];\n\tfor(int i=0;i<H;i++)last[i]=C[i];\n\tfor(int i=0;i<sz[a][b];i++){\n\t\tfor(int j=0;j<n[a][b][i];j++)C[h[a][b][i]+j]|=P[w[a][b][i]][w[a][b][i]+n[a][b][i]-1];\n\t\tif(dfs(a,b+1,v+1))return 1;\n\t\tfor(int j=0;j<n[a][b][i];j++)C[h[a][b][i]+j]=last[h[a][b][i]+j];\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\t\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%d\",&c[i][j]);\n\t\tfor(int i=0;i<a;i++)C[i]=0;\n\t\t\n\t\tfor(int i=0;i<b;i++)for(int j=i;j<b;j++){\n\t\t\tP[i][j]=0;\n\t\t\tfor(int k=i;k<=j;k++){\n\t\t\t\tP[i][j]+=1<<(k*2+1);\n\t\t\t}\n\t//\t\tprintf(\"%d %d: %d\\n\",i,j,P[i][j]);\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)sz[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tfor(int k=1;k<=min(a,b);k++){\n\t\t\t\tif(valid(i,j,k)&&!valid(i-1,j-1,k+1)&&!valid(i-1,j,k+1)&&!valid(i,j-1,k+1)&&!valid(i,j,k+1)){\n\t\t\t\t\tfor(int l=0;l<k;l++)for(int m=0;m<k;m++){\n\t\t\t\t\t\th[i+l][j+m][sz[i+l][j+m]]=i;\n\t\t\t\t\t\tw[i+l][j+m][sz[i+l][j+m]]=j;\n\t\t\t\t\t\tn[i+l][j+m][sz[i+l][j+m]]=k;\n\t\t\t\t\t\tsz[i+l][j+m]++;\n\t\t\t\t\t//\tprintf(\"%d %d %d %d %d\\n\",i,j,k,i+l,j+m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<b;j++)for(int k=0;k<sz[i][j];k++);\n\t\t//\tprintf(\"%d %d: %d %d %d\\n\",i,j,h[i][j][k],w[i][j][k],n[i][j][k]);\n\t\tint ad=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint M=0;\n\t\t\tfor(int k=0;k<sz[i][j];k++)M=max(M,n[i][j][k]);\n\t\t\tif(M==1){\n\t\t\t\tad++;\n\t\t\t\tc[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)C[i]+=(c[i][j]<<(j*2));\n\t\tfor(int i=0;;i++){\n\t\t\tlim=i;\n\t\t\tif(dfs(0,0,0)){\n\t\t\t\tprintf(\"%d\\n\",ad+i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint w, h, d[12][12], ans;\n\nvoid solve(int x, int y, int c){\n\tif(ans <= c) return;\n\tif(20 < ans && ans < INF) return;\n\tif(x == w && y == h-1){\n\t\tchmin(ans, c);\n\t\treturn ;\n\t}\n\tif(x == w){\n\t\ty ++;\n\t\tx = 0;\n\t}\n\tif(d[y][x] != 1) solve(x+1, y, c);\n\tif(ans <= c) return;\n\tif(20 < ans && ans < INF) return;\n\tif(d[y][x] != 0){\n\t\tint r = 1;\n\t\tfor(;;r++){\n\t\t\tint f = 1;\n\t\t\tREP(i, r)REP(j, r) if(d[y+i][x+j] == 0) f = 0;\n\t\t\tif(!f) break;\n\t\t}\n\t\tr --;\n\t\t\n\t\t// check pruning\n\t\tint pos[3][2] = {{y-1,x-1},{y-1,x},{y,x-1}};\n\t\tREP(k, 3){\n\t\t\tif(pos[k][0] < 0 || pos[k][1] < 0) continue;\n\t\t\tint f = 1;\n\t\t\tREP(i, r+1)REP(j, r+1) if(d[pos[k][0]+i][pos[k][1]+j] == 0) f = 0;\n\t\t\tif(f) return;\n\t\t}\n\t\tvector<pii> ch;\n\t\tREP(i, r)REP(j, r){\n\t\t\tif(d[y+i][x+j] == 1) ch.push_back(pii(y+i, x+j));\n\t\t\td[y+i][x+j] = -1;\n\t\t}\n\t\tif(ch.empty()) return ;\n\t\tsolve(x+1, y, c+1);\n\t\tREP(i, ch.size()) d[ch[i].first][ch[i].second] = 1;\n\t}\n\t\n}\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> w >> h, w){\n\t\tmemset(d, 0, sizeof(d));\n\t\tREP(i, h)REP(j, w) cin >> d[i][j];\n\t\tans = INF;\n\t\tsolve(0, 0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Carpet {\n  int y, x, size;\n  bool contain(const auto& c) const {\n    if(c.x < x) return false;\n    if(x + size < c.x + c.size) return false;\n    if(c.y < y) return false;\n    if(y + size < c.y + c.size) return false;\n    return true;\n  }\n};\n\nint W, H;\nint S[12][12];\nint L[12][12];\n\nint sum(int y1, int x1, int y2, int x2) {\n  return S[y2][x2] - S[y2][x1-1] - S[y1-1][x2] + S[y1-1][x1-1];\n}\n\nbool full(auto y1, auto x1, auto y2, auto x2) {\n  return sum(y1, x1, y2, x2) == (y2 - y1 + 1) * (x2 - x1 + 1);\n};\n\nint greedy(auto& P) {\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] = P[i][j];\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] += S[i][j-1];\n  for(auto j = 1; j <= W; ++j) for(auto i = 1; i <= H; ++i) S[i][j] += S[i-1][j];\n\n  vector<Carpet> carpet;\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) {\n    auto size = -1;\n    for(auto k = 0; k < 10; ++k) {\n      if(H < i+k || W < j+k) break;\n      if(!full(i, j, i+k, j+k)) break;\n      size = k;\n    }\n    if(~size) carpet.push_back({i, j, size});\n  }\n\n  vector<bool> removed(carpet.size());\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) for(auto j = 0; j < carpet.size(); ++j) if(!removed[j]) if(i != j) if(carpet[i].contain(carpet[j])) removed[j] = true;\n\n  int res = 0;\n\n  vector<vector<int>> cnt(H+2, vector<int>(W+2));\n  vector<vector<int>> id(H+2, vector<int>(W+2));\n  for(auto k = 0; k < carpet.size(); ++k) if(!removed[k]) {\n    auto c = carpet[k];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) {\n      ++cnt[i][j];\n      id[i][j] = k;\n    }\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(cnt[i][j] == 1) if(!removed[id[i][j]]) {\n    removed[id[i][j]] = true;\n    ++res;\n    auto c = carpet[id[i][j]];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) P[i][j] = 0;\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) L[i][j] = 0;\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) L[carpet[i].y][carpet[i].x] = carpet[i].size + 1;\n\n  return res;\n}\n\nint ans;\nvoid dfs(auto P, int sy, int sx, int depth) {\n  int y, x;\n  for(y = sy; y <= H; ++y) {\n    for(x = (y==sy ? sx : 1); x <= W; ++x) {\n      if(L[y][x]) break;\n      if(P[y][x] == 1) return;\n    }\n    if(L[y][x]) break;\n  }\n  if(y == H+1 || x == W+1) {\n    ans = min(ans, depth);\n    return;\n  }\n  if(depth >= ans) return;\n  if(P[y][x] == 0) {\n    auto ny = y, nx = x + 1;\n    if(W < x) {++ny; nx = 1;}\n    dfs(P, ny, nx, depth);\n  }\n  auto cnt = 0;\n  for(auto i = y; i < y + L[y][x]; ++i) for(auto j = x; j < x + L[y][x]; ++j) if(P[i][j] == 1) {\n    P[i][j] = 0;\n    ++cnt;\n  }\n  if(cnt == 0) return;\n  dfs(P, y, x, depth + 1);\n}\n\nint solve(auto P) {\n  auto fix = greedy(P);\n  ans = 100;\n  dfs(P, 1, 1, 0);\n  return fix + ans;\n}\n\nint main() {\n  while(cin >> W >> H, W | H) {\n    vector<vector<int>> P(H+2, vector<int>(W+2));\n    for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> P[i][j];\n    cout << solve(P) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Carpet {\n  int y, x, size;\n  bool contain(const auto& c) const {\n    if(c.x < x) return false;\n    if(x + size < c.x + c.size) return false;\n    if(c.y < y) return false;\n    if(y + size < c.y + c.size) return false;\n    return true;\n  }\n};\n\nint W, H;\nint S[12][12];\nint L[12][12];\n\nint sum(int y1, int x1, int y2, int x2) {\n  return S[y2][x2] - S[y2][x1-1] - S[y1-1][x2] + S[y1-1][x1-1];\n}\n\nbool full(auto y1, auto x1, auto y2, auto x2) {\n  return sum(y1, x1, y2, x2) == (y2 - y1 + 1) * (x2 - x1 + 1);\n};\n\nint greedy(auto& P) {\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] = P[i][j];\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] += S[i][j-1];\n  for(auto j = 1; j <= W; ++j) for(auto i = 1; i <= H; ++i) S[i][j] += S[i-1][j];\n\n  vector<Carpet> carpet;\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) {\n    auto size = -1;\n    for(auto k = 0; k < 10; ++k) {\n      if(H < i+k || W < j+k) break;\n      if(!full(i, j, i+k, j+k)) break;\n      size = k;\n    }\n    if(~size) carpet.push_back({i, j, size});\n  }\n\n  vector<bool> removed(carpet.size());\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) for(auto j = 0; j < carpet.size(); ++j) if(!removed[j]) if(i != j) if(carpet[i].contain(carpet[j])) removed[j] = true;\n\n  int res = 0;\n\n  vector<vector<int>> cnt(H+2, vector<int>(W+2));\n  vector<vector<int>> id(H+2, vector<int>(W+2));\n  for(auto k = 0; k < carpet.size(); ++k) if(!removed[k]) {\n    auto c = carpet[k];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) {\n      ++cnt[i][j];\n      id[i][j] = k;\n    }\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(cnt[i][j] == 1) if(!removed[id[i][j]]) {\n    removed[id[i][j]] = true;\n    ++res;\n    auto c = carpet[id[i][j]];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) P[i][j] = 0;\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) L[i][j] = 0;\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) L[carpet[i].y][carpet[i].x] = carpet[i].size + 1;\n\n  return res;\n}\n\nint ans;\nint dfs(auto P, int sy, int sx, int depth) {\n  int y, x;\n  for(y = sy; y <= H; ++y) {\n    for(x = (y==sy ? sx : 1); x <= W; ++x) {\n      if(L[y][x]) break;\n      if(P[y][x] == 1) return false;\n    }\n    if(L[y][x]) break;\n  }\n  if(y == H+1 || x == W+1) {\n    ans = min(ans, depth);\n    return true;\n  }\n  if(depth >= ans) return false;\n  if(P[y][x] == 0) {\n    auto ny = y, nx = x + 1;\n    if(W < x) {++ny; nx = 1;}\n    if(dfs(P, ny, nx, depth)) return true;\n  }\n  auto cnt = 0;\n  for(auto i = y; i < y + L[y][x]; ++i) for(auto j = x; j < x + L[y][x]; ++j) if(P[i][j] == 1) {\n    P[i][j] = 0;\n    ++cnt;\n  }\n  if(cnt == 0) return false;\n  return dfs(P, y, x, depth + 1);\n}\n\nint solve(auto P) {\n  auto fix = greedy(P);\n  ans = 100;\n  dfs(P, 1, 1, 0);\n  return fix + ans;\n}\n\nint main() {\n  while(cin >> W >> H, W | H) {\n    vector<vector<int>> P(H+2, vector<int>(W+2));\n    for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> P[i][j];\n    cout << solve(P) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nint makeCode(int table[10]){\n\tint ret = 0;\n\n\tfor(int col = 0; col < W; col++){\n\t\tif(table[col] == 0){\n\t\t\tret += POW[col];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\tif(base_row == H-2 && base_col == 0){ //?????????2?????§??????????????\\??????\n\n\t\tint code1 = makeCode(info.table[H-2]);\n\t\tint code2 = makeCode(info.table[H-1]);\n\n\t\tif(check[code1][code2] <= info.num)return;\n\n\t\tcheck[code1][code2] = info.num;\n\t}\n\n\t//printf(\"ans:%d\\n\",ans);\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\t\t\tInfo next_not;\n\n\t\t\tcopyTable(next_not,info.table,base_row);\n\t\t\tnext_not.num = info.num;\n\n\t\t\tint must_add = 0;\n\t\t\tbool FLG = false;\n\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\tfor(int row = base_row; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}else if(next_not.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)must_add++;\n\n\t\t\tif(next_not.num+must_add < ans){\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num+1;\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(next_info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tif(next_info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_info,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < POW[W]; i++){\n\t\tfor(int k = 0; k < POW[W]; k++)check[i][k] = BIG_NUM;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nstruct state\n{\n\tvector<string> v;\n\n\tint dist1;\n\tint dist2;\n\n\tstate(vector<string> v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 < s2.dist1 + s2.dist2; }\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 < s2.dist1 + s2.dist2; }\n\nint W, H; vector<string> start;\n\nmap<vector<string>, bool> M;\n\nint getdistance(vector<string> v)\n{\n\tint ret = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (v[i][j] == '.')\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tM.clear();\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tstart = vector<string>(H);\n\n\t\tfor (int i = 0; i < H; i++) cin >> start[i];\n\n\t\tpriority_queue<state, vector<state>, greater<state> > que;\n\n\t\tque.push(state(start, 0, getdistance(start))); M[start] = true;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tstate s1 = que.top(); que.pop();\n\n\t\t\tif (s1.dist2 == 0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", s1.dist1); break;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= 10; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= H - i; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= W - i; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<string> v2 = s1.v;\n\n\t\t\t\t\t\tbool flag = true;\n\n\t\t\t\t\t\tfor (int l = j; l < j + i; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = k; m < k + i; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (v2[i][j] == '*')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflag = true; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tv2[i][j] = '+';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flag) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!M[v2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tM[v2] = true;\n\n\t\t\t\t\t\t\tque.push(state(v2, s1.dist1 + 1, getdistance(v2)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\nint W, H;\nint P[20][20];\nint cover[10][10];\nint width[10][10];\nint left_h[10][10];\nint right_h[10][10];\nint top_h[10][10];\nint bottom_h[10][10];\nint ans;\nclock_t start_time;\nint h(int Y, int X){\n    int res = 0;\n    bool tmp[10][10];\n    for(int y = Y; y < H; y++)\n        for(int x = (y == Y ? X : 0); x < W; x++)\n            tmp[y][x] = !cover[y][x];\n    for(int y = Y; y < H; y++){\n        for(int x = (y == Y ? X : 0); x < W; x++){\n            if(tmp[y][x]){\n                res++;\n                for(int by = top_h[y][x]; by <= bottom_h[y][x]; by++){\n                    for(int bx = left_h[y][x]; bx <= right_h[y][x]; bx++){\n                        tmp[by][bx] = false;\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\nint dfs(int x, int y, int sum){\n    //cout << x << \" \" << y << \" \" << sum + h(y, x) << \" \" << ans << endl;\n    if((clock() - start_time) > CLOCKS_PER_SEC * 0.10) return ans;\n    if(sum + h(y, x) >= ans) return INF;\n    if(x == W) return dfs(0, y + 1, sum);\n    if(y == H){\n        return ans = sum;\n    }\n    int res = (cover[y][x] ? dfs(x + 1, y, sum) : INF);\n\n    bool tmp[10][10];\n    int max_w = 0;\n    REP(dx, width[y][x]) REP(dy, width[y][x]){\n        tmp[y + dy][x + dx] = cover[y + dy][x + dx];\n        if(!cover[y + dy][x + dx]) max_w = max(max_w, max(dx + 1, dy + 1));\n    }\n    REP(dx, width[y][x]) REP(dy, width[y][x]) cover[y + dy][x + dx] = true;\n    if(max_w > 0) res = min(res, dfs(x + 1, y, sum + 1));\n    REP(dx, max_w) REP(dy, max_w) cover[y + dy][x + dx] = tmp[y + dy][x + dx];\n    return res;\n}\n\nint main(){\n    while(cin >> W >> H && (W > 0 && H > 0)){\n        REP(y, H) REP(x, W) cin >> P[y][x];\n        REP(y, H) REP(x, W) {\n            width[y][x] = 0;\n            for(int w = 1; x + w <= W && y + w <= H; w++){\n                bool ok = true;\n                REP(dx, w) REP(dy, w) if(!P[y + dy][x + dx]) ok = false;\n                if(!ok) break;\n                width[y][x] = w;\n            }\n        }\n        REP(y, H) REP(x, W) {\n            left_h[y][x] = x;\n            while(left_h[y][x] - 1 >= 0 && P[y][left_h[y][x] - 1]) left_h[y][x]--;\n            right_h[y][x] = x;\n            while(right_h[y][x] + 1 < W && P[y][right_h[y][x] + 1]) right_h[y][x]++;\n            top_h[y][x] = y;\n            while(top_h[y][x] - 1 >= 0 && P[top_h[y][x] - 1][x]) top_h[y][x]--;\n            bottom_h[y][x] = y;\n            while(bottom_h[y][x] + 1 < H && P[bottom_h[y][x] + 1][x]) bottom_h[y][x]++;\n        }\n\n        ans = INF;\n        REP(y, H) REP(x, W) cover[y][x] = !P[y][x];\n        start_time = clock();\n        dfs(0, 0, 0);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ninline bool chmax(int &a, const int &b) { return (a<b)?(a=b,1):0;}\ninline bool chmin(int &a, const int &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx];\n\t\t\trep(a,cy,cy+l)rep(b,cx,cx+l) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\n\t\tfor(int row = base_row; row <= base_row; row++){\n\t\t\tfor(int col = base_col; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = base_row+1; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nint W, H;\nint grid[10][10];\nint len[10][10];\nvector<int> xs, ys;\nint ub;\nbool used[10][10];\nbool found;\nconst int INF = 1000000000;\nint dfs(int k, int use, int fill){\n    if(found) return INF;\n    vector<int> l;\n    for(int i = k; i < xs.size(); i++){\n        l.push_back(len[ys[i]][xs[i]] * len[ys[i]][xs[i]]);\n    }\n    sort(l.begin(), l.end(), greater<int>());\n    int hstar = 0;\n    for(int i = 0, s = fill; s > 0 && i <= l.size(); i++){\n        if(i == l.size()) return INF;\n        hstar++;\n        s -= l[i];\n    }\n    if(use + hstar > ub) return INF;\n    if(fill == 0){\n        found = true;\n        return ub;\n    }\n    if(k == xs.size()) return INF;\n    int res = INF;\n    int x = xs[k];\n    int y = ys[k];\n    bool used_d[10][10];\n    memcpy(used_d, used, sizeof(used));\n    int nfill = fill;\n    REP(dy, len[y][x]) REP(dx, len[y][x]){\n        if(!used[y + dy][x + dx] && grid[y + dy][x + dx]){\n            used[y + dy][x + dx] = true;\n            nfill--;\n        }\n    }\n    if(nfill < fill){\n        res = min(res, dfs(k + 1, use + 1, nfill));\n    }\n    memcpy(used, used_d, sizeof(used));\n    if(used[y][x]){\n        res = min(res, dfs(k + 1, use, fill));\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> W >> H && W){\n        REP(y, H) REP(x, W) cin >> grid[y][x];\n        // 最大の正方形を計算\n        REP(y, H) REP(x, W){\n            len[y][x] = 0;\n            for(int d = 1; x + d <= W && y + d <= W; d++){\n                bool ok = true;\n                REP(dy, d) REP(dx, d) if(!grid[y + dy][x + dx]) ok = false;\n                if(ok) len[y][x] = d;\n            }\n        }\n        // 包含されている正方形をチェック\n        REP(y, H) REP(x, W) {\n            REP(ly, y + 1) REP(lx, x + 1){\n                if(ly == y && lx == x) continue;\n                if(ly + len[ly][lx] >= y + len[y][x] && lx + len[ly][lx] >= x + len[y][x]){\n                    len[y][x] = 0;\n                }\n            }\n        }\n\n        xs.clear();\n        ys.clear();\n        int erase = 0;\n        REP(y, H) REP(x, W){\n            if(len[y][x] > 1) {\n                xs.push_back(x);\n                ys.push_back(y);\n            }\n            if(len[y][x] == 1){\n                grid[y][x] = 0;\n                erase++;\n            }\n        }\n        // REP(y, H) {\n        //     REP(x, W) cout << grid[y][x] << \" \";\n        //     cout << endl;\n        // }\n\n\n        int count = 0;\n        REP(y, H) REP(x, W) count += grid[y][x];\n        int ans;\n        for(ub = 0, found = false; ; ub++){\n            ans = dfs(0, 0, count);\n            if(ans < INF) break;\n        }\n        cout << ans + erase << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\t\t\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min(25,min_res))+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int W, H;\n    while(cin >> W >> H) {\n        if(W == 0 && H == 0) break;\n        vector<vector<int>> v(H, vector<int>(W));\n        rep(i, H) rep(j, W) cin >> v[i][j];\n        int ans = 0;\n        vector<vector<int>> cur(H, vector<int>(W));\n        auto isNecessary = [&](int y, int x, int len) {\n            bool ret = false;\n            REP(i, y, y + len) REP(j, x, x + len) {\n                if(v[i][j] == 0) return false;\n                else if(cur[i][j] == 0) ret = true;\n            }\n            if(!ret) return false;\n            REP(i, y, y + len) REP(j, x, x + len) {\n                ++cur[i][j];\n            };\n            return true;\n        };\n        auto isErase = [&](int y, int x, int len) {\n            REP(i, y, y + len) REP(j, x, x + len) {\n                if(cur[i][j] <= 1) return false;\n            }\n            REP(i, y, y + len) REP(j, x, x + len) {\n                --cur[i][j];\n            }\n            return true;\n        };\n        using P = pair<int, pii>; // len, y, x\n        set<P> used;\n        for(int len = min(H, W); len > 0; --len) {\n            for(int y = 0; y + len <= H; ++y) {\n                for(int x = 0; x + len <= W; ++ x) {\n                    if(isNecessary(y, x, len)) {\n                        // cout << \" \" << y << \" \" << x << \" \" << len << '\\n';\n                        ++ans;\n                        used.insert({len, {y, x}});\n                    }\n                }\n            }\n        }\n        for(auto p : used) {\n            int len = p.fi;\n            int y = p.se.fi, x = p.se.se;\n            if(isErase(y, x, len)) {\n                --ans;\n            }\n        }\n\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntemplate<class T> T gcd( T a, T b ) {\n\treturn !b ? a : gcd( b, a % b );\n}\ntemplate<class T> T lcm( T a, T b ) {\n\treturn a / gcd( a, b ) * b;\n}\ntemplate<class T> string print_v( vector<T> v ) {\n\tOSS oss;\n\tfor ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end();\n          ++it_i ) {\n\t\toss << *it_i << \", \";\n\t}\n\treturn oss.str();\n}\n\nconst int ks = 1;\nconst int kr[ks] = { -1, -1, 1, -1 };\nconst int kc[ks] = { -1, -1, -1, -1 };\nint w, h;\n\nvoid print( VVI T ) {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j] << \",\";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nVVI flip( VVI T, int r, int c ) {\n    VVI NT = T;\n    int cand = 0;\n    int cl = 0;\n    int ck;\n    for ( int L = min( w, h ); L > 0; -- L ) {\n        for ( int k = 0; k < ks; ++ k ) {\n            int cnt = 0;\n            for ( int i = 0; i < L; ++ i ) {\n                for ( int j = 0; j < L; ++ j ) {\n                    int nr = r + i * kr[k];\n                    int nc = c + j * kc[k];\n                    if ( nr < 0 || nr >= h ) goto IGNORE;\n                    if ( nc < 0 || nc >= w ) goto IGNORE;\n                    if ( T[nr][nc] == 0 ) goto IGNORE;\n                    if ( T[nr][nc] == 1 ) cnt ++;\n                }\n            }\n            if ( cnt > cand ) {\n                cand = cnt;\n                ck = k;\n                cl = L;\n            }\n        IGNORE:;\n        }\n    }\n    for ( int i = 0; i < cl; ++ i ) {\n        for ( int j = 0; j < cl; ++ j ) {\n            int nr = r + i * kr[ck];\n            int nc = c + j * kc[ck];\n            NT[nr][nc] = 2;\n        }\n    }\n    return NT;\n}\n\nint main() {\n    while ( cin >> w >> h && w ) {\n        VVI T( h, VI( w ) );\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                cin >> T[i][j];\n            }\n        }\n        int res = 0;\n        for ( int i = h - 1; i >= 0; -- i ) {\n            for ( int j = w - 1; j >= 0; -- j ) {\n                if ( T[i][j] != 1 ) continue;\n                T = flip( T, i, j );\n                // cout << i << \", \" << j << \": \" << ret.first << endl;\n                res ++;\n                // cout << \"before: \" << endl;\n                // print( T );\n                // cout << \"after: \" << endl;\n                // print( ret.second );\n                // cout << endl;\n            }\n        }\n        cout << res << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ninline bool chmax(int &a, const int &b) { return (a<b)?(a=b,1):0;}\ninline bool chmin(int &a, const int &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\t//while(dfs(0,0,0)==inf) min_res++;\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> tri;\n\nint w,h;\nint g[20][20];\nint rem[20][20];\nvector<tri> carpet[20][20];\nint depth;\n\nvoid search(int d){\n  if(d==depth)return;\n\n  vector<tri> priority;\n  rep(i,h)rep(j,w){\n    if(rem[i][j]){\n      priority.push_back(tri(pii(carpet[i][j].size(),i),j));\n    }\n  }\n\n  if(priority.size()==0){\n    depth = d;\n    return;\n  }\n\n  int y = priority[0].fs.sc, x = priority[0].sc;\n\n  rep(k,carpet[y][x].size()){\n    tri t = carpet[y][x][k];\n    \n    int tmp[20][20];\n    rep(i,h)rep(j,w)tmp[i][j] = rem[i][j];\n    \n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\trem[i][j] = 0;\n      }\n    }\n    \n    search(d+1);\n    if(depth == d+1)return;\n\n    rep(i,h)rep(j,w)rem[i][j] = tmp[i][j];\n  }\n}\n\nint main(){\n  while(cin >> w >> h, w){\n    memset(g,0,sizeof(g));\n    rep(i,h)rep(j,w){\n      cin >> g[i][j];\n      rem[i][j] = g[i][j];\n      carpet[i][j].clear();\n    }\n\n    vector<tri> c;\n    rep(i,h)rep(j,w){\n      int k = 0;\n      while(true){\n\tif(!range(i+k,0,h) || !range(j+k,0,w))break;\n\tint f = 1;\n\tfor(int y=i;y<=i+k;y++)f &= g[y][j+k];\n\tfor(int x=j;x<=j+k;x++)f &= g[i+k][x];\n\tif(!f)break;\n\tk++;\n      }\n      if(k)c.push_back( tri(pii(i,j), k) );\n    }\n    \n    rep(i,c.size()){\n      bool f = false;\n      rep(j,c.size()){\n\tif(i==j)continue;\n\tif( range(c[i].fs.fs, c[j].fs.fs, c[j].fs.fs + c[j].sc) &&\n\t    range(c[i].fs.fs + c[i].sc, c[j].fs.fs, c[j].fs.fs + c[j].sc+1) &&\n\t    range(c[i].fs.sc, c[j].fs.sc, c[j].fs.sc + c[j].sc) &&\n\t    range(c[i].fs.sc + c[i].sc, c[j].fs.sc, c[j].fs.sc + c[j].sc+1) ){\n\t  f = true;\n\t  break;\n\t}\n      }\n\n      if(f){\n\tc.erase(c.begin()+i);\n\ti--;\n      }\n    }\n\n    rep(i,c.size()){\n      for(int y=c[i].fs.fs;y<c[i].fs.fs+c[i].sc;y++){\n\tfor(int x=c[i].fs.sc;x<c[i].fs.sc+c[i].sc;x++){\n\t  carpet[y][x].push_back(c[i]);\n\t}\n      }\n    }\n\n    int ans = 0;\n    while(true){\n      bool f = false;\n      rep(i,h)rep(j,w){\n\tif(rem[i][j] && carpet[i][j].size()==1){\n\t  f = true;\n\t  ans++;\n\t  tri t = carpet[i][j][0];\n\t  for(int y=t.fs.fs;y<t.fs.fs+t.sc;y++){\n\t    for(int x=t.fs.sc;x<t.fs.sc+t.sc;x++){\n\t      rem[y][x] = 0;\n\t    }\n\t  }\n\t}\n      }\n      if(!f)break;\n    }\n\n    depth = h*w;\n    search(0);\n    \n    cout << ans + depth  << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(cin >> w >> h,w){\n\t\tclr(board,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tboard[i]|=(tmp<<j);\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\trep(a,i,h)rep(b,j,w) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w)rep(a,i,i+len[i][j])rep(b,j,j+len[i][j]) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\t//while(dfs(0,0,0)==inf) min_res++;\n\t\tcout << dfs(0,0,0,min_res)+add << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ninline bool chmax(int &a, const int &b) { return (a<b)?(a=b,1):0;}\ninline bool chmin(int &a, const int &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint ans=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,ans++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tif(min_res!=0) ans+=dfs(0,0,0,min_res);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<functional>\n\n#define N 11\n#define INF (1<<27)\n\nusing namespace std;\n\nint maxSizes[N][N];\nint oneCount;\nmultimap<int,int,greater<int> > squareSizes;\nint bestAns = INF;\nint minHW;\n\nint getHeuristic(int H, int W, int M[N][N])\n{\n  if(squareSizes.empty())return 0;\n  multimap<int,int>::iterator it=squareSizes.begin();\n  int maxSize = it->first;\n  if(maxSize==0)return 0;\n  maxSize *= maxSize;\n  return (oneCount / maxSize) + (oneCount%maxSize>0);\n}\n\nvoid calc(int H, int W, int M[N][N]){\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 1) oneCount++;\n      int size = 0;\n      for(size = 1; size <= minHW; ++size){\n\tfor(int m = i; m<i+size; m++){\n\t  for(int n = j; n<j+size; n++){\n\t    if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t      --size;\n\t      goto next;\n\t    }\n\t  }\n\t}\n\tif(i+size>=H||j+size>=W)break;\n      }\n      next:;\n      maxSizes[i][j] = size;\n      squareSizes.insert(make_pair(size,0));\n    }\n  }\n  return ;\n}\n\nvoid solve(int H, int W, int pos, int M[N][N], int depth){\n  /*\n  printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W, getHeuristic(H,W,M));\n  for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n      if(l>0)putchar(' ');\n      printf(\"%d\", M[k][l]);\n    }\n    putchar('\\n');\n  }\n  putchar('\\n');\n  */\n\n  // completed.\n  if(oneCount==0){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic(H,W,M)>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < H*W; ++p){\n    int i = p / W;\n    int j = p % W;\n    if( M[i][j] == 0 ){\n      continue;\n    }else if( M[i][j] >= 1 ){\n      int size = maxSizes[i][j];\n      bool valid=false;\n      for(int m = i; m<size+i; m++){\n\tfor(int n = j; n<size+j; n++){\n\t  if(M[m][n]==1){\n\t    valid=true;\n\t    --oneCount;\n\t    M[m][n]=depth;\n\t  }\n\t}\n      }\n      if( valid ){\n\tsquareSizes.erase( squareSizes.find( size ) );\n\tsolve(H,W,p+1,M,depth+1);\n\tsquareSizes.insert(make_pair(size,0));\n      }\n      for(int m = i; m<size+i; m++){\n\tfor(int n = j; n<size+j; n++){\n\t  if( M[m][n] == depth ){\n\t    ++oneCount;\n\t    M[m][n]=1;\n\t  }\n\t}\n      }\n      if( M[i][j] > 1 )\n\tsolve(H,W,p+1,M,depth);\n      return ;\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[N][N];\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    oneCount = 0;\n    squareSizes.clear();    \n    calc(H,W,M);\n    solve(H,W,0,M,2);\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <functional>\n \n#pragma warning(disable : 4996)\n \nusing namespace std;\n \nstruct state\n{\n    vector<vector<int> > v;\n \n    int dist1;\n    int dist2;\n \n    int r;\n \n    state(vector<vector<int> > v1, int d1, int d2, int r1) : v(v1), dist1(d1), dist2(d2), r(r1) { }\n};\n \nint W, H;\n \nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 / s1.r / s1.r < s2.dist1 + s2.dist2 / s2.r / s2.r; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 / s2.r / s2.r > s2.dist1 + s2.dist2 / s2.r / s2.r; }\n \nvector<vector<int> > start;\n \nmap<vector<vector<int> >, bool> M;\n \nint getdistance(vector<vector<int> > v)\n{\n    int ret = 0;\n \n    for (int i = 0; i < H; i++)\n    {\n        for (int j = 0; j < W; j++)\n        {\n            if (v[i][j] == 1)\n            {\n                ret++;\n            }\n        }\n    }\n \n    return ret;\n}\n \nint main()\n{\n    while (true)\n    {\n        scanf(\"%d\", &W);\n        scanf(\"%d\", &H);\n \n        int reps = min(W, H);\n \n        M.clear();\n \n        if (W == 0 && H == 0) break;\n \n        start = vector<vector<int> >(H, vector<int>(W));\n \n        for (int i = 0; i < H; i++)\n        {\n            for (int j = 0; j < W; j++)\n            {\n                scanf(\"%d\", &start[i][j]);\n            }\n        }\n \n        priority_queue<state, vector<state>, greater<state> > que;\n \n        que.push(state(start, 0, getdistance(start), reps)); M[start] = true;\n \n        while (!que.empty())\n        {\n            state s1 = que.top(); que.pop();\n \n            if (s1.dist2 == 0)\n            {\n                printf(\"%d\\n\", s1.dist1); break;\n            }\n \n            for (int i = 1; i <= s1.r; i++)\n            {\n                for (int j = 0; j <= H - i; j++)\n                {\n                    for (int k = 0; k <= W - i; k++)\n                    {\n                        vector<vector<int> > v2 = s1.v;\n \n                        bool flag = false;\n \n                        for (int l = j; l < j + i; l++)\n                        {\n                            for (int m = k; m < k + i; m++)\n                            {\n                                if (v2[l][m] == 0)\n                                {\n                                    flag = true; break;\n                                }\n                                else\n                                {\n                                    v2[l][m] = 2;\n                                }\n                            }\n \n                            if (flag) break;\n                        }\n \n                        if (!flag)\n                        {\n                            if (!M[v2])\n                            {\n                                M[v2] = true;\n \n                                que.push(state(v2, s1.dist1 + 1, getdistance(v2), i));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nint makeCode(int table[10]){\n\tint ret = 0;\n\n\tfor(int col = 0; col < W; col++){\n\t\tif(table[col] == 0){\n\t\t\tret += POW[col];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\tif(base_row == H-2 && base_col == 0){ //?????????2?????§??????????????\\??????\n\n\t\tint code1 = makeCode(info.table[H-2]);\n\t\tint code2 = makeCode(info.table[H-1]);\n\n\t\tif(check[code1][code2] <= info.num)return;\n\n\t\tcheck[code1][code2] = info.num;\n\t}\n\n\t//printf(\"ans:%d\\n\",ans);\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\t\t\tInfo next_not;\n\n\t\t\tcopyTable(next_not,info.table,base_row);\n\t\t\tnext_not.num = info.num;\n\n\t\t\tint must_add = 0;\n\t\t\tbool FLG = false;\n\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\tfor(int row = base_row; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}else if(next_not.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)must_add++;\n\n\t\t\tif(next_not.num+must_add < ans){\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num+1;\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(next_info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tif(next_info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_info,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < POW[W]; i++){\n\t\tfor(int k = 0; k < POW[W]; k++)check[i][k] = BIG_NUM;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define N 11\n#define INF (1<<29)\n\nusing namespace std;\n\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\nint bestAns = INF;\nint minHW;\n\nvoid solve(int H, int W, int M[N][N], int depth){\n  /*\n    for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n    if(l>0)putchar(' ');\n    printf(\"%d\", M[k][l]);\n    }\n    putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  bool bComp=true;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j]==1){\n\tbComp=false;\n      }\n    }\n  }\n  if(bComp){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(depth>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if( M[i][j] == 0 ){\n\tcontinue;\n      }else if( M[i][j] == 1 ){\n\tint maxOneCount=-1;\n\tint maxSize=-1;\n\tvector< pair<int,int> > vk;\n\tfor(int k = 0; k < 4; ++k){\n\t  int size = 0;\n\t  for(size = 1; size <= minHW; ++size){\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t  --size;\n\t\t  goto next1;\n\t\t}\n\t      }\n\t    }\n\t    if(k==0){\n\t      if(i-size<0||j+size>=W)break;\n\t    }else if(k==1){\n\t      if(i+size>=H||j+size>=W)break;\n\t    }else if(k==2){\n\t      if(i+size>=H||j-size<0)break;\n\t    }else{\n\t      if(i-size<0||j-size<0)break;\n\t    }\n\t  }\n\tnext1:;\n\t  int oneCount=0;\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( M[m][n] == 1 ){\n\t\t++oneCount;\n\t      }\n\t    }\n\t  }\n\t  vk.push_back( make_pair(size,oneCount) );\n\t  maxOneCount = max( maxOneCount, oneCount );\n\t  maxSize = max( maxSize, size );\n\t}\n\tfor(int k = 0; k < 4; ++k){\n\t  if(maxOneCount==vk[k].second){\n\t    int size = vk[k].first;\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif(M[m][n]==1){\n\t\t  M[m][n]=depth;\n\t\t}\n\t      }\n\t    }\n\t    solve(H,W,M,depth+1);\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( M[m][n] == depth ){\n\t\t  M[m][n]=1;\n\t\t}\n\t      }\n\t    }\n\t    if(maxSize==1)break;\n\t  }\n\t}\n\treturn ;\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[N][N];\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    solve(H,W,M,2);\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define N 11\n#define INF (1<<27)\n\nusing namespace std;\n\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\nint bestAns = INF;\nint minHW;\n\nint getHeuristic(int H, int W, int M[N][N])\n{\n  //  return 0;\n  int maxSize = 1;\n  int size[N][N] = {{0,},};\n  int oneCount = 0;\n\n  for(int i = H-1; i >= 0; --i){\n    if( M[i][W-1] >= 1 ){\n      size[i][W-1] = 1;\n      if( M[i][W-1] == 1 )\n\t++oneCount;\n    }\n  }\n\n  for(int j = W-1; j >= 0; --j){\n    if( M[H-1][j] >= 1 ){\n      size[H-1][j] = 1;\n      if( M[H-1][j] == 1 )\n\t++oneCount;\n    }\n  }\n\n  if( M[H-1][W-1] == 1 ) --oneCount;\n\n  for(int i = H-2; i >= 0; --i){\n    for(int j = W-2; j >= 0; --j){\n      if( M[i][j] >= 1 ){\n\tsize[i][j] = 1+min( size[i+1][j], min( size[i+1][j+1], size[i][j+1] ) );\n\tmaxSize = max( maxSize, size[i][j] );\n\tif(M[i][j] == 1){\n\t  ++oneCount;\n\t}\n      }\n    }\n  }\n  \n  //if(maxSize>1){\n  //printf(\"MaxSize = %d\\n\", maxSize);\n  //}\n  maxSize *= maxSize;\n  return (oneCount / maxSize) + (oneCount%maxSize==0?0:1);\n}\n\nvoid solve(int H, int W, int pos, int M[N][N], int depth){\n \n  /*\n  printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W,getHeuristic(H,W,M));\n  for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n      if(l>0)putchar(' ');\n      printf(\"%d\", M[k][l]);\n    }\n    putchar('\\n');\n  }\n  putchar('\\n');\n  */\n\n  // completed.\n  bool bComp=true;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j]==1){\n\tbComp=false;\n\tgoto end;\n      }\n    }\n  }\n end:;\n  if(bComp){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic(H,W,M)>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < H*W; ++p){\n    int i = p / W;\n    int j = p % W;\n    if( M[i][j] == 0 ){\n      continue;\n    }else if( M[i][j] == 1 ){\n      int maxSize=-1;\n      int maxOneCount = -1;\n      pair<int,int> vk[4];\n      for(int k = 0; k < 4; ++k){\n\tint size = 0;\n\tfor(size = 1; size <= minHW; ++size){\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t--size;\n\t\tgoto next;\n\t      }\n\t    }\n\t  }\n\t  if(k==0){\n\t    if(i-size<0||j+size>=W)break;\n\t  }else if(k==1){\n\t    if(i+size>=H||j+size>=W)break;\n\t  }else if(k==2){\n\t    if(i+size>=H||j-size<0)break;\n\t  }else{\n\t    if(i-size<0||j-size<0)break;\n\t  }\n\t}\n      next:;\n\tint oneCount = 0;\n\tfor(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t  for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t    if(M[m][n]==1){\n\t      ++oneCount;\n\t    }\n\t  }\n\t}\n\tvk[k]=make_pair(size, oneCount);\n\tmaxSize = max( maxSize, size );\n\tmaxOneCount = max( maxOneCount, oneCount );\n      }\n      for(int k = 0; k < 4; ++k){\n\tif(maxSize==vk[k].first && maxOneCount == vk[k].second){\n\t  int size = vk[k].first;\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if(M[m][n]==1){\n\t\tM[m][n]=depth;\n\t      }\n\t    }\n\t  }\n\t  solve(H,W,p+1,M,depth+1);\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( M[m][n] == depth ){\n\t\tM[m][n]=1;\n\t      }\n\t    }\n\t  }\n\t  if(maxSize==1)break;\n\t}\n      }\n      solve(H,W,p+1,M,depth+1);\n      return ;\n    }   \n  }\n}\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[N][N];\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    solve(H,W,0,M,2);\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ninline bool chmax(int &a, const int &b) { return (a<b)?(a=b,1):0;}\ninline bool chmin(int &a, const int &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x==w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint ans=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,ans++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tans+=dfs(0,0,0,min_res);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Carpet {\n  int y, x, size;\n  bool contain(const auto& c) const {\n    if(c.x < x) return false;\n    if(x + size < c.x + c.size) return false;\n    if(c.y < y) return false;\n    if(y + size < c.y + c.size) return false;\n    return true;\n  }\n};\n\nint W, H;\nint P[12][12];\nint S[12][12];\nint L[12][12];\n\nint sum(int y1, int x1, int y2, int x2) {\n  return S[y2][x2] - S[y2][x1-1] - S[y1-1][x2] + S[y1-1][x1-1];\n}\n\nbool full(auto y1, auto x1, auto y2, auto x2) {\n  return sum(y1, x1, y2, x2) == (y2 - y1 + 1) * (x2 - x1 + 1);\n};\n\nint greedy(auto& P) {\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] = P[i][j];\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] += S[i][j-1];\n  for(auto j = 1; j <= W; ++j) for(auto i = 1; i <= H; ++i) S[i][j] += S[i-1][j];\n\n  vector<Carpet> carpet;\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) {\n    auto size = -1;\n    for(auto k = 0; k < 10; ++k) {\n      if(H < i+k || W < j+k) break;\n      if(!full(i, j, i+k, j+k)) break;\n      size = k;\n    }\n    if(~size) carpet.push_back({i, j, size});\n  }\n\n  vector<bool> removed(carpet.size());\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) for(auto j = 0; j < carpet.size(); ++j) if(!removed[j]) if(i != j) if(carpet[i].contain(carpet[j])) removed[j] = true;\n\n  int res = 0;\n\n  vector<vector<int>> cnt(H+2, vector<int>(W+2));\n  vector<vector<int>> id(H+2, vector<int>(W+2));\n  for(auto k = 0; k < carpet.size(); ++k) if(!removed[k]) {\n    auto c = carpet[k];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) {\n      ++cnt[i][j];\n      id[i][j] = k;\n    }\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(cnt[i][j] == 1) if(!removed[id[i][j]]) {\n    removed[id[i][j]] = true;\n    ++res;\n    auto c = carpet[id[i][j]];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) P[i][j] = 0;\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) L[i][j] = 0;\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) L[carpet[i].y][carpet[i].x] = carpet[i].size + 1;\n\n  return res;\n}\n\nint ans;\nvoid dfs(int sy, int sx, int depth) {\n  if(depth >= ans) return;\n  int y, x;\n  for(y = sy; y <= H; ++y) {\n    for(x = (y==sy ? sx : 1); x <= W; ++x) {\n      if(L[y][x]) break;\n      if(P[y][x] == 1) return;\n    }\n    if(L[y][x]) break;\n  }\n  if(y == H+1 || x == W+1) {\n    ans = min(ans, depth);\n    return;\n  }\n  if(P[y][x] == 0) {\n    auto ny = y, nx = x + 1;\n    if(W < x) {++ny; nx = 1;}\n    dfs(ny, nx, depth);\n  }\n  int dup[12][12];\n  memcpy(dup, P, 12*12*sizeof(int));\n  auto cnt = 0;\n  for(auto i = y; i < y + L[y][x]; ++i) for(auto j = x; j < x + L[y][x]; ++j) if(P[i][j] == 1) {\n    P[i][j] = 0;\n    ++cnt;\n  }\n  if(cnt == 0) return;\n  dfs(y, x, depth + 1);\n  memcpy(P, dup, 12*12*sizeof(int));\n}\n\nint solve(auto P) {\n  auto fix = greedy(P);\n  ans = 100;\n  dfs(1, 1, 0);\n  return fix + ans;\n}\n\nint main() {\n  while(cin >> W >> H, W | H) {\n    for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> P[i][j];\n    cout << solve(P) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\t\t\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\tint remain=0;\n\t\trep(i,h) remain+=popcount(board[i]);\n\t\tmin_res=min(21,remain);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,remain)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\ntypedef bitset<100> bits;\n\nint solve(int pos, bits covered, bits goal, vector<bits> &c){\n    if(covered == goal){\n        return 0;\n    }\n    // 使う意味がない\n    if((covered|c[pos]) == covered){\n        return solve(pos+1, covered, goal, c);\n    }\n    // 必ず使う\n    if(goal[pos]==1 and covered[pos]==0){\n        return solve(pos+1, covered|c[pos], goal, c) +1;\n    }\n    // 自分以降の誰かに完全包含されている\n    for(int i=pos+1; i<(int)c.size(); i++){\n        if((covered|c[i]|c[pos]) == (covered|c[i])){\n            return solve(pos+1, covered, goal, c);\n        }\n    }\n    return min(solve(pos+1, covered, goal, c),\n                solve(pos+1, covered|c[pos], goal, c) +1);\n}\n\nint main(){\n    while(1){\n        int w,h;\n        cin >> w >> h;\n        if(h == 0) break;\n\n        bits goal;\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                int a;\n                cin >> a;\n                goal[i*w+j] = a;\n            }\n        }\n        // 各地点を左上にしたときの最大カーペットのビット表現\n        vector<bits> carpet; \n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                bits a;\n                for(int k=1; k+i<h+1 and k+j<w+1; k++){\n                    bool ok = true;\n                    bits b;\n                    for(int s=i; s<i+k; s++){\n                        for(int t=j; t<j+k; t++){\n                            b[s*w+t] = 1;\n                            if(goal[s*w+t] == 0) ok = false;\n                        }\n                    }\n                    if(!ok) break;\n                    a = b;\n                }\n                carpet.push_back(a);\n            }\n        }\n        // 必ず敷かなければいけない\n        vector<bits> must;\n        bits covered;\n        for(int i=0; i<(int)carpet.size(); i++){\n            bits other;\n            for(int j=0; j<(int)carpet.size(); j++){\n                if(i == j) continue;\n                other |= carpet[j];\n            }\n            if((carpet[i]|other) != other){\n                must.push_back(carpet[i]);\n                covered |= carpet[i];\n            }\n        }\n        cout << solve(0, covered, goal, carpet) +(int)must.size() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,n,dp[11][11],A[11][11],ans,cnt;\nbitset<100> B[11][11],C[11][11];\n\nvoid dfs(int d,bitset<100> s,int sco){\n  if(d==n){\n    ans=min(ans,sco);\n    return;\n  }\n  cnt++;\n  if(cnt>=10000000)return;\n  if(ans<=sco)return;\n  if(!A[d/w][d%w])dfs(d+1,s,sco);\n  else{\n    int y=d/w;\n    int x=d%w;\n    if((B[y][x]&s).any()){\n      bitset<100>p;\n      p.set(y*10+x);//(y*100+x);\n      if(!(s&p).any())dfs(d+1,s,sco);\n      dfs(d+1,(B[y][x]|s)^B[y][x],sco+1);\n    }\n    else dfs(d+1,s,sco);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    n=h*w;\n    memset(dp,0,sizeof(dp));\n    bitset<100> b;\n    r(i,h)r(j,w)cin>>A[i][j];//A[i][j]=dp[i][j];\n    r(i,h)r(j,w)if(A[i][j]){\n      int sum=1;\n      for(;;sum++){\n        int f=0;\n        for(int y=i;y<i+sum;y++){\n          for(int x=j;x<j+sum;x++){\n            if(A[y][x]==0)f++;\n          }\n        }\n        if(f){\n          sum--;\n          break;\n        }\n      }\n      bitset<100>tmp;\n      for(int y=i,k=0;k<sum;k++,y++){\n        for(int x=j,l=0;l<sum;l++,x++){\n          tmp.set(y*10+x);\n        }\n      }\n      b.set(i*10+j);\n      B[i][j]=tmp;\n    }\n    ans=100;\n    cnt=0;\n    dfs(0,b,0);\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d){\n\t\n\tif(y==h && x==0) return d;\n\n\tif(d>min_res) return inf;\n\n\tint ny=y,nx=x+1;\n\tif(nx==w) ny++,nx=0;\t\n\n\tif(len[y][x]==0) return dfs(ny,nx,d);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(ny,nx,d));\n\n\tint tboard[10];\n\trep(i,h) tboard[i]=board[i];\n\n\tbool ok=false;\n\n\tint mask=0;\n\trep(b,x,x+len[y][x]) mask|=bit(b);\n\trep(a,y,y+len[y][x]){\n\t\tif((board[a]&mask)!=0) ok=true;\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(ok) chmin(ret,dfs(ny,nx,d+1));\n\t\n\trep(i,h) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(cin >> w >> h,w){\n\t\tclr(board,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tboard[i]|=(tmp<<j);\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\trep(a,i,h)rep(b,j,w) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w)rep(a,i,i+len[i][j])rep(b,j,j+len[i][j]) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\tmin_res=0;\n\t\twhile(dfs(0,0,0)==inf) min_res++;\n\t\tcout << min_res+add << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntemplate<class T> T gcd( T a, T b ) {\n\treturn !b ? a : gcd( b, a % b );\n}\ntemplate<class T> T lcm( T a, T b ) {\n\treturn a / gcd( a, b ) * b;\n}\ntemplate<class T> string print_v( vector<T> v ) {\n\tOSS oss;\n\tfor ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end();\n          ++it_i ) {\n\t\toss << *it_i << \", \";\n\t}\n\treturn oss.str();\n}\n\nconst int kr[4] = { 1, -1, 1, -1 };\nconst int kc[4] = { 1, 1, -1, -1 };\nint w, h;\n\nvoid print( VVI T ) {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j] << \",\";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nVVI flip( VVI T, int r, int c ) {\n    VVI NT = T;\n    int cand = 0;\n    int cl = 0;\n    int ck;\n    for ( int L = min( w, h ); L > 0; -- L ) {\n        for ( int k = 0; k < 4; ++ k ) {\n            int cnt = 0;\n            for ( int i = 0; i < L; ++ i ) {\n                for ( int j = 0; j < L; ++ j ) {\n                    int nr = r + i * kr[k];\n                    int nc = c + j * kc[k];\n                    if ( nr < 0 || nr >= h ) goto IGNORE;\n                    if ( nc < 0 || nc >= w ) goto IGNORE;\n                    if ( T[nr][nc] == 0 ) goto IGNORE;\n                    if ( T[nr][nc] == 1 ) cnt ++;\n                }\n            }\n            if ( cnt > cand ) {\n                cand = cnt;\n                ck = k;\n                cl = L;\n            }\n        IGNORE:;\n        }\n    }\n    for ( int i = 0; i < cl; ++ i ) {\n        for ( int j = 0; j < cl; ++ j ) {\n            int nr = r + i * kr[ck];\n            int nc = c + j * kc[ck];\n            NT[nr][nc] = 2;\n        }\n    }\n    return NT;\n}\n\nint main() {\n    while ( cin >> w >> h && w ) {\n        VVI T( h, VI( w ) );\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                cin >> T[i][j];\n            }\n        }\n        int res = 0;\n        for ( int i = h - 1; i >= 0; -- i ) {\n            for ( int j = w - 1; j >= 0; -- j ) {\n                if ( T[i][j] != 1 ) continue;\n                T = flip( T, i, j );\n                // cout << i << \", \" << j << \": \" << ret.first << endl;\n                res ++;\n                // cout << \"before: \" << endl;\n                // print( T );\n                // cout << \"after: \" << endl;\n                // print( ret.second );\n                // cout << endl;\n            }\n        }\n        cout << res << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct state {\n\tvector<short> b;\n\tshort dist, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.dist + s1.cost > s2.dist + s2.cost;\n}\nint H, W, a[12][12], cnt, xa[10009], ya[10009], xb[10009], yb[10009], popcount[1033];\nint main() {\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tpopcount[j] = popcount[j - (1 << i)] + 1;\n\t\t}\n\t}\n\twhile (cin >> W >> H, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) {\n\t\t\t\t\t\tif (k - i != l - j) continue;\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor (int x = i; x < k; x++) {\n\t\t\t\t\t\t\tfor (int y = j; y < l; y++) {\n\t\t\t\t\t\t\t\tif (a[x][y] == 0) flag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\txa[cnt] = i;\n\t\t\t\t\t\t\tya[cnt] = j;\n\t\t\t\t\t\t\txb[cnt] = k;\n\t\t\t\t\t\t\tyb[cnt] = l;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> que;\n\t\tint scnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (a[i][j] == 1) scnt++;\n\t\t\t}\n\t\t}\n\t\tque.push(state{ vector<short>(H, 0), 0, scnt });\n\t\tbool flag = false;\n\t\twhile (!que.empty() && !flag) {\n\t\t\tstate u = que.top(); que.pop();\n\t\t\tfor (int i = 0; i < cnt && !flag; i++) {\n\t\t\t\tvector<short> z = u.b;\n\t\t\t\tfor (int j = xa[i]; j < xb[i]; j++) {\n\t\t\t\t\tz[j] |= (1 << yb[i]) - (1 << ya[i]);\n\t\t\t\t}\n\t\t\t\tint rcnt = 0;\n\t\t\t\tfor (int j = 0; j < H; j++) rcnt += popcount[z[j]];\n\t\t\t\trcnt = scnt - rcnt;\n\t\t\t\tif (rcnt == 0) {\n\t\t\t\t\tcout << u.dist + 1 << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tque.push(state{ z, u.dist + 1, rcnt });\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint board[111][111];\nbool used[11111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    rep(i,h)rep(j,w){\n      cin>>board[i][j];\n    }\n    vector<int> g[30101];\n    rep(ti,h+1)rep(tj,w+1)rep(si,ti)rep(sj,tj){\n      if((ti-si)!=(tj-sj))continue;\n      bool ok=true;\n      repl(i,si,ti)repl(j,sj,tj){\n        if(!board[i][j])ok=false;\n      }\n      if(ok){\n        //dbg(si); dbg(sj); dbg(ti);dbg(tj);\n        int cv=si*1111+sj*111+ti*11+tj;\n        repl(i,si,ti)repl(j,sj,tj){\n          int bv=12345+i*11+j;\n          g[cv].pb(bv); g[bv].pb(cv);\n        }\n      }\n    }\n    memset(used,0,sizeof(used));\n    int res=0;\n    rep(i,h)rep(j,w){\n      if(board[i][j]==1&&!used[i*11+j]){\n        res++;\n        int maxv=-1,maxc=0;\n        each(v,g[i*11+j+12345]){\n          int cnt=0;\n          each(nv,g[v]){\n            if(!used[nv-12345])cnt++;\n          }\n          if(maxc<cnt){\n            maxc=cnt;\n            maxv=v;\n          }\n        }\n        each(v,g[maxv]){\n          used[v-12345]=true;\n        }\n      }\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\n\nint H,W;\nvec t;\nmap< vec , int > dp[10][10];\n\nbool check(int ay,int ax,int by,int bx){\n  for(int y=ay;y<=by;y++)\n    for(int x=ax;x<=bx;x++)\n      if( (t[y]>>x&1)==0 )return false;\n  return true;\n}\n\nint solve(vec p,int y,int x){\n  if(y==H)return 0;\n  \n  if(x==W){\n    return solve(p,y+1,0);\n  }\n  \n  if(dp[y][x].count(p))return dp[y][x][p];\n  int sum=0;\n  for(int i=0;i<H;i++)sum+=p[i];\n  if(sum==0)return 0;\n  \n\n  int res=1e9;\n  if((p[y]>>x&1)==0)res=solve(p,y,x+1);\n\n  for(int i=0;;i++){\n    if(y+i>=H||x+i>=W)break;\n    if(!check(y,x,y+i,x+i))break;\n    int ma=(1<<(i+1))-1;\n    vec next=p;\n    for(int j=0;j<=i;j++){\n      next[y+j]|=(ma<<x);\n      next[y+j]-=(ma<<x);\n    }\n\n    if(p==next)continue;\n    res=min(res,solve(next,y,x+1)+1);\n  }\n\n  return dp[y][x][p]=res;\n}\n\nint main(){\n  while(1){\n    cin>>W>>H;\n    if(H==0&&W==0)break;\n\n    vec si;\n    for(int i=0;i<H;i++){\n      int bit=0,a;\n      for(int j=0;j<W;j++){\n        dp[i][j].clear();\n        \n        cin>>a;\n        if(a==1)bit|=(1<<j);\n      }\n      si.push_back(bit);\n    }\n    t=si;\n    cout<<solve(si,0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Carpet {\n  int y, x, size;\n  bool contain(const auto& c) const {\n    if(c.x < x) return false;\n    if(x + size < c.x + c.size) return false;\n    if(c.y < y) return false;\n    if(y + size < c.y + c.size) return false;\n    return true;\n  }\n};\n\nint W, H;\nint S[12][12];\nint L[12][12];\n\nint sum(int y1, int x1, int y2, int x2) {\n  return S[y2][x2] - S[y2][x1-1] - S[y1-1][x2] + S[y1-1][x1-1];\n}\n\nbool full(auto y1, auto x1, auto y2, auto x2) {\n  return sum(y1, x1, y2, x2) == (y2 - y1 + 1) * (x2 - x1 + 1);\n};\n\nint greedy(auto& P) {\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] = P[i][j];\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] += S[i][j-1];\n  for(auto j = 1; j <= W; ++j) for(auto i = 1; i <= H; ++i) S[i][j] += S[i-1][j];\n\n  vector<Carpet> carpet;\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) {\n    auto size = -1;\n    for(auto k = 0; k < 10; ++k) {\n      if(H < i+k || W < j+k) break;\n      if(!full(i, j, i+k, j+k)) break;\n      size = k;\n    }\n    if(~size) carpet.push_back({i, j, size});\n  }\n\n  vector<bool> removed(carpet.size());\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) for(auto j = 0; j < carpet.size(); ++j) if(!removed[j]) if(i != j) if(carpet[i].contain(carpet[j])) removed[j] = true;\n\n  int res = 0;\n\n  vector<vector<int>> cnt(H+2, vector<int>(W+2));\n  vector<vector<int>> id(H+2, vector<int>(W+2));\n  for(auto k = 0; k < carpet.size(); ++k) if(!removed[k]) {\n    auto c = carpet[k];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) {\n      ++cnt[i][j];\n      id[i][j] = k;\n    }\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(cnt[i][j] == 1) if(!removed[id[i][j]]) {\n    removed[id[i][j]] = true;\n    ++res;\n    auto c = carpet[id[i][j]];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) P[i][j] = 0;\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) L[i][j] = 0;\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) L[carpet[i].y][carpet[i].x] = carpet[i].size + 1;\n\n  return res;\n}\n\nbool dfs(auto P, int sy, int sx, int depth, int limit) {\n  int y, x;\n  for(y = sy; y <= H; ++y) {\n    for(x = (y==sy ? sx : 1); x <= W; ++x) {\n      if(L[y][x]) break;\n      if(P[y][x] == 1) return false;\n    }\n    if(L[y][x]) break;\n  }\n  if(y == H+1 || x == W+1) return true;\n  if(depth > limit) return false;\n  if(P[y][x] == 0) {\n    auto ny = y, nx = x + 1;\n    if(W < x) {++ny; nx = 1;}\n    if(dfs(P, ny, nx, depth, limit)) return true;\n  }\n  auto cnt = 0;\n  for(auto i = y; i < y + L[y][x]; ++i) for(auto j = x; j < x + L[y][x]; ++j) if(P[i][j] == 1) {\n    P[i][j] = 0;\n    ++cnt;\n  }\n  return cnt ? dfs(P, y, x, depth + 1, limit) : false;\n}\n\nint solve(auto P) {\n  auto fix = greedy(P);\n  for(auto i = 0; i <= 100; ++i) {\n    if(dfs(P, 1, 1, 0, i)) return fix + i;\n  }\n  assert(false);\n}\n\nint main() {\n  while(cin >> W >> H, W | H) {\n    vector<vector<int>> P(H+2, vector<int>(W+2));\n    for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> P[i][j];\n    cout << solve(P) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[12][12];\nint h[12][12][200];\nint w[12][12][200];\nint n[12][12][200];\nint sz[12][12];\nint H,W;\nint valid(int a,int b,int t){\n\tif(a<0||b<0||a+t>H||b+t>W)return 0;\n\tfor(int i=0;i<t;i++)for(int j=0;j<t;j++)if(!c[a+i][b+j])return 0;\n\treturn 1;\n}\nint lim;\nint dfs(int a,int b,int v){\n\tif(a==H)return 1;\n\tif(b==W)return dfs(a+1,0,v);\n\tif(c[a][b]!=1)return dfs(a,b+1,v);\n\tif(v==lim)return 0;\n\tint last[12][12];\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)last[i][j]=c[i][j];\n\tfor(int i=0;i<sz[a][b];i++){\n\t\tfor(int j=0;j<n[a][b][i];j++)for(int k=0;k<n[a][b][i];k++){\n\t\t\tc[h[a][b][i]+j][w[a][b][i]+k]=2;\n\t\t}\n\t\tif(dfs(a,b+1,v+1))return 1;\n\t\tfor(int j=0;j<n[a][b][i];j++)for(int k=0;k<n[a][b][i];k++)c[h[a][b][i]+j][w[a][b][i]+k]=last[h[a][b][i]+j][w[a][b][i]+k];\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%d\",&c[i][j]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)sz[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tfor(int k=1;k<=min(a,b);k++){\n\t\t\t\tif(valid(i,j,k)&&!valid(i-1,j-1,k+1)&&!valid(i-1,j,k+1)&&!valid(i,j-1,k+1)&&!valid(i,j,k+1)){\n\t\t\t\t\tfor(int l=0;l<k;l++)for(int m=0;m<k;m++){\n\t\t\t\t\t\th[i+l][j+m][sz[i+l][j+m]]=i;\n\t\t\t\t\t\tw[i+l][j+m][sz[i+l][j+m]]=j;\n\t\t\t\t\t\tn[i+l][j+m][sz[i+l][j+m]]=k;\n\t\t\t\t\t\tsz[i+l][j+m]++;\n\t\t\t\t\t//\tprintf(\"%d %d %d %d %d\\n\",i,j,k,i+l,j+m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<b;j++)for(int k=0;k<sz[i][j];k++);\n\t\t//\tprintf(\"%d %d: %d %d %d\\n\",i,j,h[i][j][k],w[i][j][k],n[i][j][k]);\n\t\tint ad=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint M=0;\n\t\t\tfor(int k=0;k<sz[i][j];k++)M=max(M,n[i][j][k]);\n\t\t\tif(M==1){\n\t\t\t\tad++;\n\t\t\t\tc[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;;i++){\n\t\t\tlim=i;\n\t\t\tif(dfs(0,0,0)){\n\t\t\t\tprintf(\"%d\\n\",ad+i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\t\t\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min(29,min_res))+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nstruct aa {\n\tvector<vector<int>>field;\n\tint sx;\n\tint sy;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nmap<vector<vector<int>>, int>mp;\nint main() {\n\twhile (1) {\n\t\tint X, Y; cin >> X >> Y;\n\t\tif (!X)break;\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\t{\n\t\t\tint sx=-1, sy=-1;\n\t\t\tvector<vector<int>>sfield(Y + 2, vector<int>(X + 2));\n\t\t\tbool flag = true;\n\t\t\tfor (int i = 0; i < Y; ++i) {\n\t\t\t\tfor (int j = 0; j < X; ++j) {\n\t\t\t\t\tcin >> sfield[i + 1][j + 1];\n\t\t\t\t\tif (flag&&sfield[i + 1][j + 1]) {\n\t\t\t\t\t\tsx = j + 1;\n\t\t\t\t\t\tsy = i + 1;\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tque.push(aa{ sfield, sx, sy, 0 });\n\t\t\tmp[sfield] = 0;\n\t\t}\n\t\tint ans = -1;\n\t\twhile (que.size()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (atop.sx == -1) {\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int nsy = atop.sy; atop.field[nsy][atop.sx];--nsy)\n\t\t\t{\n\t\t\t\tint nsx = atop.sx;\n\t\t\t\twhile (atop.field[nsy][nsx]) {\n\t\t\t\t\tint nsize = atop.sx - nsx + 1;\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ay = nsy; ay < nsy + nsize; ++ay) {\n\t\t\t\t\t\t\tfor (int ax = nsx; ax < nsx + nsize; ++ax) {\n\t\t\t\t\t\t\t\tif (!atop.field[ay][ax]) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!ok)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\t\tnsize--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnsize++;\n\t\t\t\t\t}\n\t\t\t\t\tif (nsize == atop.sx - nsx)break;\n\t\t\t\t\telse {\n\t\t\t\t\t\tvector<vector<int>>nfield(atop.field);\n\t\t\t\t\t\tfor (int ay = nsy; ay < nsy + nsize; ++ay) {\n\t\t\t\t\t\t\tfor (int ax = nsx; ax < nsx + nsize; ++ax) {\n\t\t\t\t\t\t\t\tif (nfield[ay][ax] == 0)assert(false);\n\t\t\t\t\t\t\t\tnfield[ay][ax] = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!mp.count(nfield)) {\n\t\t\t\t\t\t\tint asx = -1, asy = -1;\n\t\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\t\tfor (int i = 0; i < Y + 2; ++i) {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < X + 2; ++j) {\n\t\t\t\t\t\t\t\t\tif (flag&&nfield[i][j] == 1) {\n\t\t\t\t\t\t\t\t\t\tasx = j; asy = i;\n\t\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmp[nfield] = atop.time + 1;\n\t\t\t\t\t\t\tque.push(aa{ nfield,asx,asy,atop.time + 1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnsx--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//{\n\t\t\t//\tconst int nsx = atop.sx;\n\t\t\t//\tint nsy = atop.sy;\n\t\t\t//\twhile (atop.field[nsy][nsx]) {\n\t\t\t//\t\tint nsize = atop.sy - nsy + 1;\n\t\t\t//\t\twhile (1) {\n\t\t\t//\t\t\tbool ok = true;\n\t\t\t//\t\t\tfor (int ay = nsy; ay < nsy + nsize; ++ay) {\n\t\t\t//\t\t\t\tfor (int ax = nsx; ax < nsx + nsize; ++ax) {\n\t\t\t//\t\t\t\t\tif (!atop.field[ay][ax]) {\n\t\t\t//\t\t\t\t\t\tok = false;\n\t\t\t//\t\t\t\t\t\tbreak;\n\t\t\t//\t\t\t\t\t}\n\t\t\t//\t\t\t\t}\n\t\t\t//\t\t\t\tif (!ok)break;\n\t\t\t//\t\t\t}\n\t\t\t//\t\t\tif (!ok) {\n\t\t\t//\t\t\t\tnsize--;\n\t\t\t//\t\t\t\tbreak;\n\t\t\t//\t\t\t}\n\t\t\t//\t\t\tnsize++;\n\t\t\t//\t\t}\n\t\t\t//\t\tif (nsize == atop.sy - nsy)break;\n\t\t\t//\t\telse {\n\t\t\t//\t\t\tvector<vector<int>>nfield(atop.field);\n\t\t\t//\t\t\tfor (int ay = nsy; ay < nsy + nsize; ++ay) {\n\t\t\t//\t\t\t\tfor (int ax = nsx; ax < nsx + nsize; ++ax) {\n\t\t\t//\t\t\t\t\tif (nfield[ay][ax] == 0)assert(false);\n\t\t\t//\t\t\t\t\tnfield[ay][ax] = 2;\n\t\t\t//\t\t\t\t}\n\t\t\t//\t\t\t}\n\t\t\t//\t\t\tif (!mp.count(nfield)) {\n\t\t\t//\t\t\t\tint asx = -1, asy = -1;\n\t\t\t//\t\t\t\tbool flag = true;\n\t\t\t//\t\t\t\tfor (int i = 0; i < Y + 2; ++i) {\n\t\t\t//\t\t\t\t\tfor (int j = 0; j < X + 2; ++j) {\n\t\t\t//\t\t\t\t\t\tif (flag&&nfield[i][j] == 1) {\n\t\t\t//\t\t\t\t\t\t\tasx = j; asy = i;\n\t\t\t//\t\t\t\t\t\t\tflag = false;\n\t\t\t//\t\t\t\t\t\t}\n\t\t\t//\t\t\t\t\t}\n\t\t\t//\t\t\t\t}\n\t\t\t//\t\t\t\tmp[nfield] = atop.time + 1;\n\t\t\t//\t\t\t\tque.push(aa{ nfield,asx,asy,atop.time + 1 });\n\t\t\t//\t\t\t}\n\t\t\t//\t\t}\n\t\t\t//\t\tnsy--;\n\t\t\t//\t}\n\t\t\t//}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint dx[] = {-1, -1, 0};\nint dy[] = {-1, 0, 0};\n\ntypedef bitset<100> Panels;\n\nint W, H, field[100][100];\nvector<Panels> carpets[100][100];\nint dp[100][100];\n\nbool canCover(int x, int y, int s)\n{\n\tfor(int i=y; i<y+s; i++)\n\tfor(int j=x; j<x+s; j++)\n\t\tif(field[j][i] == 0) return false;\n\n\treturn true;\n}\n\nPanels calcCovered(int x, int y, int s)\n{\n\tPanels res;\n\tfor(int i=y; i<y+s; i++)\n\tfor(int j=x; j<x+s; j++) {\n\t\tres.set(j + i * W, 1);\n\t}\n\n\treturn res;\n}\n\n\nvoid remove(int x, int y)\n{\n\tif(carpets[x][y].size() == 0) return;\n\n\tint S = (int)sqrt(carpets[x][y][0].count());\n\tfor(int i=y; i<y+S; i++)\n\tfor(int j=x; j<x+S; j++) {\n\t\tif(j == x && i == y) continue;\n\t\tif(carpets[j][i].size() == 0) continue;\n\n\t\tint T = (int)sqrt(carpets[j][i][0].count());\n\t\tif(x + S >= j + T && y + S >= i + T) {\n\t\t\tcarpets[j][i].clear();\n\t\t}\n\t\t\n\t}\n}\n\nint ans;\nvoid dfs(int x, int y, int u, Panels f)\n{\n\tif(f.count() == W*H) {\n\t\tans = u;\n\t\treturn;\n\t}\n\n\tif(u + 1 >= ans) return;\n\n\tif(y == H) return;\n\n\tint tx = x + 1;\n\tint ty = y;\n\n\tif(tx == W) { tx = 0; ty++; }\n\tint S = carpets[x][y].size();\n\n\tif(f[x + y * W]) dfs(tx, ty, u, f);\n\t\n\tfor(int i=0; i<S; i++) {\n\t\tPanels& c = carpets[x][y][i];\n\t\tPanels t = f;\n\t\tt |= c;\n\n\t\tif(t != f) {\n\t\t\tdfs(tx, ty, u + 1, t);\n\t\t}\n\t\telse break;\n\t}\n}\n\nint main()\n{\n\twhile(cin >> W >> H, (W||H)) {\n\t\tPanels init;\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++) {\n\t\t\tcin >> field[j][i];\n\t\t\tcarpets[j][i].clear();\n\t\t\tdp[j][i] = 1;\n\n\t\t\tif(field[j][i] == 0) init.set(j + i * W, 1);\n\t\t}\n\n\t\tint S = min(W, H);\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++) {\n\t\t\tint M = 1;\n\t\t\tfor(int k=0; k<3; k++) {\n\t\t\t\tint tx = j + dx[k] , ty = i + dy[k];\n\t\t\t\tif(tx < 0 || ty < 0) continue;\n\t\t\t\tdp[j][i] = max(dp[j][i], dp[tx][ty] - 1);\n\n\t\t\t\tif(carpets[tx][ty].size() != 0) \n\t\t\t\tdp[j][i] = max(dp[j][i], (int)sqrt(carpets[tx][ty][0].count()) - 1);\n\t\t\t}\n\t\t\tfor(int k=S; k>=dp[j][i]; k--) {\n\t\t\t\tif(i + k > H || j + k > W) continue;\n\t\t\t\tif(canCover(j, i, k)) {\n\t\t\t\t\tcarpets[j][i].push_back(calcCovered(j, i, k));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++) {\n\t\t\tremove(j, i);\n\t\t}\n\n\t\tans = (1<<24);\n\t\tdfs(0, 0, 0, init);\n\n\t\tcout << ans << endl;\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nint W, H;\nint grid[10][10];\nint len[10][10];\nvector<int> xs, ys;\nint ub;\nbool used[10][10];\nbool found;\nconst int INF = 1000000000;\nint dfs(int k, int use, int fill){\n    if(found) return INF;\n    if(use > ub) return INF;\n    if(fill == 0){\n        found = true;\n        return ub;\n    }\n    if(k == xs.size()) return INF;\n    int res = INF;\n    int x = xs[k];\n    int y = ys[k];\n    if(used[y][x]){\n        res = min(res, dfs(k + 1, use, fill));\n    }\n    bool used_d[10][10];\n    memcpy(used_d, used, sizeof(used));\n    int nfill = fill;\n    REP(dy, len[y][x]) REP(dx, len[y][x]){\n        if(!used[y + dy][x + dx] && grid[y + dy][x + dx]){\n            used[y + dy][x + dx] = true;\n            nfill--;\n        }\n    }\n    if(nfill < fill){\n        res = min(res, dfs(k + 1, use + 1, nfill));\n    }\n    memcpy(used, used_d, sizeof(used));\n    return res;\n}\n\nint main(){\n    while(cin >> W >> H && W){\n        REP(y, H) REP(x, W) cin >> grid[y][x];\n        // 最大の正方形を計算\n        REP(y, H) REP(x, W){\n            len[y][x] = 0;\n            for(int d = 1; x + d <= W && y + d <= W; d++){\n                bool ok = true;\n                REP(dy, d) REP(dx, d) if(!grid[y + dy][x + dx]) ok = false;\n                if(ok) len[y][x] = d;\n            }\n        }\n        // 包含されている正方形をチェック\n        REP(y, H) REP(x, W) {\n            REP(ly, y + 1) REP(lx, x + 1){\n                if(ly == y && lx == x) continue;\n                if(ly + len[ly][lx] >= y + len[y][x] && lx + len[ly][lx] >= x + len[y][x]){\n                    len[y][x] = 0;\n                }\n            }\n        }\n\n        xs.clear();\n        ys.clear();\n        int erase = 0;\n        REP(y, H) REP(x, W){\n            if(len[y][x] > 1) {\n                xs.push_back(x);\n                ys.push_back(y);\n            }\n            if(len[y][x] == 1){\n                grid[y][x] = 0;\n                erase++;\n            }\n        }\n        // REP(y, H) {\n        //     REP(x, W) cout << grid[y][x] << \" \";\n        //     cout << endl;\n        // }\n\n\n        int count = 0;\n        REP(y, H) REP(x, W) count += grid[y][x];\n        int ans;\n        for(ub = 0, found = false; ; ub++){\n            ans = dfs(0, 0, count);\n            if(ans < INF) break;\n        }\n        cout << ans + erase << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE=100;\nusing F=bitset<SIZE>;\n\nauto comp=[](const F& lhs,const F& rhs){\n    return lhs.count()<rhs.count();\n};\n\nint dfs(int pos,vector<vector<F>> &bigSq,F state,unordered_map<F,int>& dp){\n    if(pos==bigSq.size()){\n        return 0;\n    }\n    if(!state[pos]){\n        auto ret=dfs(pos+1,bigSq,state,dp);\n        return ret;\n    }\n    \n    vector<F> toS;\n    for(int i=0;i<bigSq[pos].size();i++){\n        toS.push_back(state & (~bigSq[pos][i]));\n    }\n    int res=1e6;\n    sort(toS.begin(),toS.end(),comp);\n    for(int i=0;i<toS.size();i++){\n        bool isok=true;\n        for(int j=0;j<i;j++){\n            isok&=!((toS[i]&toS[j])==toS[j]);\n        }\n        if(isok){\n            res=min(res,dfs(pos+1,bigSq,toS[i],dp)+1);\n        }\n    }\n    return res;\n}\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        vector<vector<int>> f(h,vector<int>(w,0));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>f[i][j];\n            }\n        }\n        \n        F state=0;\n        vector<vector<F>> bigSq(h*w);\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(!f[i][j]) continue;\n                state.set(i*w+j);\n                int s=0;\n                for(int k=1;k<=10;k++){\n                    bool isok=true;\n                    for(int ii=0;ii<k;ii++){\n                        for(int jj=0;jj<k;jj++){\n                            isok&=(i+ii<h && j+jj<w && f[i+ii][j+jj]);\n                        }\n                    }\n                    if(!isok) break;\n                    s++;\n                }\n                F sq=0;\n                for(int ii=0;ii<s;ii++){\n                    for(int jj=0;jj<s;jj++){\n                        sq.set((ii+i)*w+j+jj);\n                    }\n                }\n                for(int ii=0;ii<s;ii++){\n                    for(int jj=0;jj<s;jj++){\n                        bigSq[(i+ii)*w+j+jj].push_back(sq);\n                    }\n                }\n                sort(bigSq[i*w+j].begin(),bigSq[i*w+j].end(),comp);\n            }\n        }\n\n        for(int i=0;i<h*w;i++){\n            vector<F> newBigSq;\n            for(int j=0;j<bigSq[i].size();j++){\n                bool isok=true;\n                for(int k=j+1;k<bigSq[i].size();k++){\n                    isok&=((bigSq[i][j] & bigSq[i][k])!=bigSq[i][j]);\n                }\n                if(isok) newBigSq.push_back(bigSq[i][j]);\n            }\n            bigSq[i]=newBigSq;\n        }\n        \n        unordered_map<F,int> dp;\n\n        int res=dfs(0,bigSq,state,dp);\n        cout<<res<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <tuple>\nusing namespace std;\n\nstruct State {\n\tint a[10][10];\n};\n\nchar c[10][10]; int p[10][10], H, W, mindep, cnts;\n\nint range(int sx, int sy, int gx, int gy) {\n\tint cnt = 0;\n\tfor (int i = sx; i < gx; i++) {\n\t\tfor (int j = sy; j < gy; j++) {\n\t\t\tif (c[i][j] == '0') cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\nint range2(int sx, int sy, int gx, int gy, State G) {\n\tint cnt = 0;\n\tfor (int i = sx; i < gx; i++) { if (G.a[i][sy] == 0) cnt++; }\n\tfor (int i = sy; i < gy; i++) { if (G.a[sx][i] == 0) cnt++; }\n\treturn cnt;\n}\n\nState nurie(State P, int cx, int cy) {\n\tfor (int i = cx; i < cx + p[cx][cy]; i++) {\n\t\tfor (int j = cy; j < cy + p[cx][cy]; j++) P.a[i][j] = 1;\n\t}\n\treturn P;\n}\n\nlong long hash_value(State I) {\n\tlong long mod = 2555555555555555555LL, II = 0, J = 1;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (I.a[i][j] == 1) II += J; J *= 2;\n\t\t\tif (II >= mod) II -= mod;\n\t\t\tif (J >= mod) J -= mod;\n\t\t}\n\t}\n\treturn II;\n}\n\nmap<tuple<int, int, int, long long>, int>M;\n\nvoid dfs(int cx, int cy, int depth, State S) {\n\tlong long K = hash_value(S);\n\tif (M[make_tuple(cx, cy, depth, K)] == 1) return;\n\tM[make_tuple(cx, cy, depth, K)] = 1;\n\tcnts++;\n\tif (depth == mindep) return;\n\tif (cx == H) {\n\t\tmindep = min(mindep, depth);\n\t\treturn;\n\t}\n\tint nx = cx, ny = cy + 1; if (ny == W) { ny = 0; nx++; }\n\tif (c[cx][cy] == '0') {\n\t\tdfs(nx, ny, depth, S);\n\t}\n\telse {\n\t\tif (S.a[cx][cy] == 0) {\n\t\t\tState V = nurie(S, cx, cy);\n\t\t\tdfs(nx, ny, depth + 1, V);\n\t\t}\n\t\telse if (range2(cx, cy, cx + p[cx][cy], cy + p[cx][cy], S) == 0) {\n\t\t\tdfs(nx, ny, depth, S);\n\t\t}\n\t\telse {\n\t\t\tdfs(nx, ny, depth, S);\n\t\t\tState V = nurie(S, cx, cy);\n\t\t\tdfs(nx, ny, depth + 1, V);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H; mindep = (1 << 30); if (H == 0 && W == 0) break;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> c[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 1; k <= min(H - i, W - j); k++) {\n\t\t\t\t\tif (range(i, j, i + k, j + k) >= 1) break;\n\t\t\t\t\tp[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState S; for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) S.a[i][j] = 0; }\n\t\tdfs(0, 0, 0, S);\n\t\tcout << mindep << endl;\n\t}\n\t//cout << \"Totalcount : \" << cnts << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define EPS 1e-8\n\n#define DEB 0\n\nint dp[16][16],memo[16][16];\nint field[16][16];\nint check[16][16];\n\nint main(){\n\tint w,h;\n\twhile(scanf(\"%d%d\",&w,&h),w|h){\n\t\trep(i,16)rep(j,16)dp[i][j]=check[i][j]=memo[i][j]=0;\n\t\t\n\t\trep(i,h)rep(j,w)scanf(\"%d\",&field[i+1][j+1]);\n\t\tREP(i,1,h+1){\n\t\t\tREP(j,1,w+1)if( field[i][j] ){\n\t\t\t\tdp[i][j] = min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=h; i>0; i--){\n\t\t\tfor(int j=w; j>0; j--){\n\t\t\t\tint mx = dp[i][j];\n\t\t\t\tint x = max(1,j-mx+1);\n\t\t\t\tint y = max(1,i-mx+1);\n\t\t\t\tfor(int k=y; k<=i; k++){\n\t\t\t\t\tfor(int l=x; l<=j; l++){\n\t\t\t\t\t\tmemo[k][l] = max(memo[k][l], mx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#if DEB\n\t\trep(i,h+1){\n\t\t\trep(j,w+1){\n\t\t\t\tprintf(\"%d \",memo[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tputs(\"\");\n#endif\n\n\t\tint cnt = 0;\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++)if( !check[i][j] && memo[i][j]>0 ){\n\t\t\t\tint mx = memo[i][j];\n\t\t\t\tint x = min(w,j+mx-1);\n\t\t\t\tint y = min(h,i+mx-1);\n\t\t\t\tbool f = false;\n\n#if DEB\n\t\t\t\tprintf(\"init: m:%d, (x,y)=%d,%d  ,(j,i)=%d,%d\\n\",mx,x,y,j,i);\n#endif\t\t\t\t\n\t\t\t\tfor(int k=0; k<mx; k++)if( dp[y][x-k]==mx ){\n\t\t\t\t\tf = true;\n\t\t\t\t\tx -= k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( !f ){\n\t\t\t\t\tfor(int k=0; k<mx; k++)if( dp[y-k][x]==mx ){\n\t\t\t\t\t\ty -= k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n#if DEB\t\t\t   \n\t\t\t\tprintf(\"%d,%d  --  %d,%d\\n\\n\",j,i,x,y);\n#endif\n\t\t\t\t\n\t\t\t\tfor(int k=0; k<mx; k++){\n\t\t\t\t\tfor(int l=0; l<mx; l++){\n\t\t\t\t\t\tcheck[y-k][x-l] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n#if DEB\n\t\t\t\trep(i,h+1){\n\t\t\t\t\trep(j,w+1){\n\t\t\t\t\t\tprintf(\"%d \",check[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tputs(\"\");\n\t\t\t\t}\n\t\t\t\tputs(\"\");\n#endif \t\t\t\t\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// * template\n\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntemplate<class T, class U> inline void fill_array(T &e, const U &v) { e = v; }\ntemplate<class T, class U, size_t s> inline void fill_array(T (&a)[s], const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U, size_t s> inline void fill_array(array<T, s> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U> inline void fill_array(vector<T> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\n\n// * solve\n\nconstexpr int MAX_H = 10;\nconstexpr int MAX_W = 10;\n\ntypedef bitset<MAX_H * MAX_W> Bitset;\n\nint w, h;\nint ans;\n\ninline int index(const int x, const int y) {\n\treturn x + y * w;\n}\n\nvoid print(const Bitset &b) {\n\tcout << string(50, '-') << endl;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tcout << b[index(j, i)] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << string(50, '-') << endl;\n}\n\ninline void erase_subset(vector<Bitset> &bits) {\n\tfor(int i = static_cast<int>(bits.size()) - 1; i >= 0; --i) {\n\t\tfor(int j = 0; j < bits.size(); ++j) {\n\t\t\tif(i == j) continue;\n\n\t\t\tif((bits[i] & bits[j]) == bits[i]) {\n\t\t\t\tbits.erase(begin(bits) + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<Bitset> init(const vector<vector<int>> &p) {\n\tvector<vector<int>> sum(h + 2, vector<int>(w + 2, 0));\n\tfor(int y = 1; y <= h + 1; ++y) {\n\t\tfor(int x = 1; x <= w + 1; ++x) {\n\t\t\tsum[y][x] = p[y][x] + sum[y - 1][x] + sum[y][x - 1] - sum[y - 1][x - 1];\n\t\t}\n\t}\n\n\tconst auto calc = [&](int x1, int y1, int x2, int y2) -> int {\n\t\t--x1; --y1;\n\t\treturn x1 < 0 || y1 < 0 ? 0 : sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n\t};\n\n\tvector<Bitset> carpets;\n\tfor(int y = 1; y <= h; ++y) {\n\t\tfor(int x = 1; x <= w; ++x) {\n\t\t\tif(p[y][x] == 0) continue;\n\n\t\t\tfor(int dx : {-1, 1}) {\n\t\t\t\tfor(int dy : {-1, 1}) {\n\t\t\t\t\tint cx = x, cy = y;\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tconst int min_x = min(x, cx + dx);\n\t\t\t\t\t\tconst int min_y = min(y, cy + dy);\n\t\t\t\t\t\tconst int max_x = max(x, cx + dx);\n\t\t\t\t\t\tconst int max_y = max(y, cy + dy);\n\n\t\t\t\t\t\tif(calc(min_x, min_y, max_x, max_y) < (max_x - min_x + 1) * (max_y - min_y + 1)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcx += dx;\n\t\t\t\t\t\tcy += dy;\n\t\t\t\t\t}\n\n\t\t\t\t\tBitset tmp;\n\t\t\t\t\tfor(int i = min(y, cy); i <= max(y, cy); ++i) {\n\t\t\t\t\t\tfor(int j = min(x, cx); j <= max(x, cx); ++j) {\n\t\t\t\t\t\t\ttmp[index(j - 1, i - 1)] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcarpets.emplace_back(move(tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\terase_subset(carpets);\n\treturn carpets;\n}\n\nvoid dfs(Bitset current, int num, vector<Bitset> carpets) {\n\tfor(int i = 0; i < carpets.size(); ++i) {\n\t\tBitset tmp(carpets[i] & current);\n\t\tfor(int j = 0; j < carpets.size(); ++j) {\n\t\t\tif(i == j) continue;\n\t\t\ttmp &= ~carpets[j];\n\t\t}\n\n\t\tif(tmp.any()) {\n\t\t\tcurrent &= ~carpets[i];\n\t\t\t++num;\n\t\t}\n\t}\n\n\tif(num >= ans) return;\n\tif(current.none()) {\n\t\tans = num;\n\t\treturn;\n\t}\n\n\tfor(auto &e : carpets) e &= current;\n\terase_subset(carpets);\n\n\tfor(const auto &e : carpets) {\n\t\tconst Bitset next = current & ~e;\n\t\tif(next != current) {\n\t\t\tdfs(move(next), num + 1, carpets);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h && w) {\n\t\tBitset scratched;\n\t\tvector<vector<int>> p(h + 2, vector<int>(w + 2));\n\n\t\tfor(int y = 1; y <= h; ++y) {\n\t\t\tfor(int x = 1; x <= w; ++x) {\n\t\t\t\tcin >> p[y][x];\n\t\t\t\tif(p[y][x] == 1) scratched.set(index(x - 1, y - 1));\n\t\t\t}\n\t\t}\n\n\t\tconst vector<Bitset> carpets = init(p);\n\t\tans = h * w;\n\t\tdfs(scratched, 0, move(carpets));\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nint makeCode(int table[10]){\n\tint ret = 0;\n\n\tfor(int col = 0; col < W; col++){\n\t\tif(table[col] == 0){\n\t\t\tret += POW[col];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\t/*if(base_row == H-2 && base_col == 0){ //?????????2?????§??????????????\\??????\n\n\t\tint code1 = makeCode(info.table[H-2]);\n\t\tint code2 = makeCode(info.table[H-1]);\n\n\t\tif(check[code1][code2] <= info.num)return;\n\n\t\tcheck[code1][code2] = info.num;\n\t}*/\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < POW[W]; i++){\n\t\tfor(int k = 0; k < POW[W]; k++)check[i][k] = BIG_NUM;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tgoto SHISHIMARU;\n\t\t\t}\n\t\t}\n\t}\n\nSHISHIMARU:\n\tif(new_num == 0){\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\n\t\tfor(int row = base_row; row <= base_row; row++){\n\t\t\tfor(int col = base_col; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = base_row+1; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[12][12];\nint h[12][12][200];\nint w[12][12][200];\nint n[12][12][200];\nint sz[12][12];\nint H,W;\nint valid(int a,int b,int t){\n\tif(a<0||b<0||a+t>H||b+t>W)return 0;\n\tfor(int i=0;i<t;i++)for(int j=0;j<t;j++)if(!c[a+i][b+j])return 0;\n\treturn 1;\n}\nint lim;\nint dfs(int a,int b,int v){\n\tif(a==H)return 1;\n\tif(b==W)return dfs(a+1,0,v);\n\tif(c[a][b]!=1)return dfs(a,b+1,v);\n\tif(v==lim)return 0;\n\tint last[12][12];\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)last[i][j]=c[i][j];\n\tfor(int i=0;i<sz[a][b];i++){\n\t\tfor(int j=0;j<n[a][b][i];j++)for(int k=0;k<n[a][b][i];k++){\n\t\t\tc[h[a][b][i]+j][w[a][b][i]+k]=2;\n\t\t}\n\t\tif(dfs(a,b+1,v+1))return 1;\n\t\tfor(int j=0;j<n[a][b][i];j++)for(int k=0;k<n[a][b][i];k++)c[h[a][b][i]+j][w[a][b][i]+k]=last[h[a][b][i]+j][w[a][b][i]+k];\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%d\",&c[i][j]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)sz[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tfor(int k=1;k<=min(a,b);k++){\n\t\t\t\tif(valid(i,j,k)&&!valid(i-1,j-1,k+1)&&!valid(i-1,j,k+1)&&!valid(i,j-1,k+1)&&!valid(i,j,k+1)){\n\t\t\t\t\tfor(int l=0;l<k;l++)for(int m=0;m<k;m++){\n\t\t\t\t\t\th[i+l][j+m][sz[i+l][j+m]]=i;\n\t\t\t\t\t\tw[i+l][j+m][sz[i+l][j+m]]=j;\n\t\t\t\t\t\tn[i+l][j+m][sz[i+l][j+m]]=k;\n\t\t\t\t\t\tsz[i+l][j+m]++;\n\t\t\t\t\t//\tprintf(\"%d %d %d %d %d\\n\",i,j,k,i+l,j+m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<b;j++)for(int k=0;k<sz[i][j];k++);\n\t\t//\tprintf(\"%d %d: %d %d %d\\n\",i,j,h[i][j][k],w[i][j][k],n[i][j][k]);\n\t\tint ad=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint M=0;\n\t\t\tfor(int k=0;k<sz[i][j];k++)M=max(M,n[i][j][k]);\n\t\t\tif(M==1){\n\t\t\t\tad++;\n\t\t\t\tc[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;;i++){\n\t\t\tlim=i;\n\t\t\tif(dfs(0,0,0)){\n\t\t\t\tprintf(\"%d\\n\",ad+i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nint H,W,mincost;\nint P[10][10],bin[10],bc[(1<<10)];\nint put[10][10];\n\nbool can_put(int len,int x,int y){\n  REP(i,y,y+len)REP(j,x,x+len) if( !P[i][j] ) return false;\n  return true;\n}\n\nvoid dfs(int cur,int cost,int remain){\n\n  if( remain == 0 ) {\n    mincost = min(cost,mincost);\n    return;\n  }\n\n  if( cost >= mincost ) return;\n  if( cost + ((remain>0)?1:0) >= mincost ) return;\n\n  if( cur >= H*W ) {\n    mincost = min(mincost,cost);\n    return;\n  }\n\n  int x = cur % W, y = cur / W;\n\n  if( !P[y][x] ) {\n    dfs(cur+1,cost,remain);\n    return;\n  }\n\n  if( (bin[y]>>x) & 1 ) dfs(cur+1,cost,remain);\n\n  int len = put[y][x];\n  int bitmask = ((1<<len)-1)<<x;\n  int buf[len];\n  int add = 0, nremain = remain;\n  rep(j,len) {\n    buf[j] = bin[y+j];\n    add += len - bc[((1<<len)-1)&(bin[y+j]>>x)];\n    bin[y+j] |= bitmask;\n  }\n  nremain -= add;\n  if( add ) dfs(cur+1,cost+1,nremain);\n  rep(j,len) bin[y+j] = buf[j];\n\n}\n\nint main(){\n\n  rep(i,(1<<10)) bc[i] = __builtin_popcount(i);\n\n  while( scanf(\"%d%d\",&W,&H), W | H ){\n\n    rep(i,H){\n      bin[i] = 0;\n      rep(j,W){\n        cin >> P[i][j];\n        put[i][j] = 0;\n      }\n    }\n\n\n    rep(y,H) rep(x,W) if( P[y][x] ) {\n      for(int len=min(H,W);len>=1;len--){\n        if( x + len - 1 < W && y + len - 1 < H ) {\n          if( can_put(len,x,y) ){\n            put[y][x] = len;\n            break;\n          }\n        }\n      }\n    }\n\n    int remain = 0;\n    rep(i,H)rep(j,W)remain += P[i][j];\n    mincost = remain;\n    dfs(0,0,remain);\n\n    cout << mincost << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nstruct state\n{\n\tvector<vector<int> > v;\n\n\tint dist1;\n\tint dist2;\n\n\tstate(vector<vector<int> > v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nint W, H;\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 < s2.dist1 + s2.dist2; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 > s2.dist1 + s2.dist2; }\n\nvector<vector<int> > start;\n\nmap<vector<vector<int> >, bool> M;\n\nint getdistance(vector<vector<int> > v)\n{\n\tint ret = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (v[i][j] == 1)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tint reps = min(W, H);\n\n\t\tM.clear();\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tstart = vector<vector<int> >(H, vector<int>(W));\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &start[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<state, vector<state>, greater<state> > que;\n\n\t\tque.push(state(start, 0, getdistance(start))); M[start] = true;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tstate s1 = que.top(); que.pop();\n\n\t\t\tif (s1.dist2 == 0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", s1.dist1); break;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= reps; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= H - i; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= W - i; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > v2 = s1.v;\n\n\t\t\t\t\t\tbool flag = false;\n\n\t\t\t\t\t\tfor (int l = j; l < j + i; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = k; m < k + i; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (v2[l][m] == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflag = true; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tv2[l][m] = 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flag) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!M[v2])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tM[v2] = true;\n\n\t\t\t\t\t\t\t\tque.push(state(v2, s1.dist1 + 1, getdistance(v2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint h, w;\nbool ba[10][10];\n\nstruct Rect {\n  int y,x,d;\n  Rect(int y, int x, int d) :\n    y(y),x(x),d(d) {}\n};\nvector<Rect> rs;\nbool covered[100][10][10];\n\nbool contain(const Rect &a, const Rect &b) {\n  if (a.y<=b.y && a.x<=b.x &&\n      b.y+b.d<=a.y+a.d && b.x+b.d<=a.x+a.d) return 1;\n  return 0;\n}\nint ans;\n\nvoid dfs(int cnt, int num) {\n  // cout << cnt << \" \" << num << endl;\n  // REP(i,h) {\n  //   REP(j,w) cout << ba[i][j] << \" \";\n  //   cout << endl;\n  // }\n  if (ans <= num) return;\n  if (cnt == rs.size()) {\n    REP(i,h)REP(j,w) {\n      if (ba[i][j]) return;\n    }\n    ans = num;\n    return;\n  }\n  int tmp[h][w];\n  REP(i,h)REP(j,w)tmp[i][j]=ba[i][j];\n  if (ba[rs[cnt].y][rs[cnt].x] == 0) {   \n    dfs(cnt+1, num);\n  }\n  REP(i,rs[cnt].d) REP(j,rs[cnt].d)\n    ba[i+rs[cnt].y][j+rs[cnt].x] = 0;\n\n  dfs(cnt+1,num+1);\n\n  REP(i,rs[cnt].d) REP(j,rs[cnt].d) {\n    int y = i+rs[cnt].y;\n    int x = j+rs[cnt].x;\n    ba[y][x] = tmp[y][x];\n  }\n}\n\nint main() {\n  while(cin>>w>>h,h||w) {\n    REP(i,h)REP(j,w)cin>>ba[i][j];\n    vector<Rect> v;\n    REP(y,h)REP(x,w) {\n      for (int d=1; y+d<=h&&x+d<=w; ++d) {\n        bool ok = 1;\n        for (int yy=y; yy<y+d; ++yy) {\n          for (int xx=x; xx<x+d; ++xx) {\n            if (ba[yy][xx] == 0) ok = 0;\n          }\n        }\n        if (ok) v.push_back(Rect(y,x,d));\n      }\n    }\n    vector<Rect> trs;\n    REP(i,v.size()) {\n      bool ok = 1;\n      REP(j,v.size()) {\n        if (i == j) continue;\n        if (contain(v[j], v[i])) ok = 0;\n      }\n      if (ok) trs.push_back(v[i]);\n    }\n    int cnt[10][10] = {};\n    FOR(it, trs) {\n      for (int y=it->y; y<it->y+it->d; ++y)\n        for (int x=it->x; x<it->x+it->d; ++x)\n          cnt[y][x]++;\n    }\n    rs.clear();\n    int base = 0;\n    FOR(it, trs) {\n      bool flag = 0;\n      for (int y=it->y; y<it->y+it->d; ++y)\n        for (int x=it->x; x<it->x+it->d; ++x)\n          if (cnt[y][x] == 1) {\n            flag = 1;\n          }\n      if (flag) {\n        for (int y=it->y; y<it->y+it->d; ++y)\n          for (int x=it->x; x<it->x+it->d; ++x)\n            ba[y][x] = 0;\n        base++;\n      } else {\n        rs.push_back(*it);\n      }\n    }\n    // cout << base << endl;\n    // cout << rs.size() << endl;\n    // FOR(it, rs) {\n    //   cout << it->y << \" \" << it->x << \" \" << it->d << endl;\n    // }\n    \n    ans = INF;\n    dfs(0,0);\n    cout << ans+base << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nstruct state\n{\n\tvector<vector<int> > v;\n\n\tint dist1;\n\tint dist2;\n\n\tint r;\n\n\tstate(vector<vector<int> > v1, int d1, int d2, int r1) : v(v1), dist1(d1), dist2(d2), r(r1) { }\n};\n\nint W, H;\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 < s2.dist1 + s2.dist2; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 > s2.dist1 + s2.dist2; }\n\nvector<vector<int> > start;\n\nmap<vector<vector<int> >, bool> M;\n\nint getdistance(vector<vector<int> > v)\n{\n\tint ret = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (v[i][j] == 1)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tint reps = min(W, H);\n\n\t\tM.clear();\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tstart = vector<vector<int> >(H, vector<int>(W));\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &start[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<state, vector<state>, greater<state> > que;\n\n\t\tque.push(state(start, 0, getdistance(start), reps)); M[start] = true;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tstate s1 = que.top(); que.pop();\n\n\t\t\tif (s1.dist2 == 0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", s1.dist1); break;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= s1.r; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= H - i; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= W - i; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > v2 = s1.v;\n\n\t\t\t\t\t\tbool flag = false;\n\n\t\t\t\t\t\tfor (int l = j; l < j + i; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = k; m < k + i; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (v2[l][m] == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflag = true; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tv2[l][m] = 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flag) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!M[v2])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tM[v2] = true;\n\n\t\t\t\t\t\t\t\tque.push(state(v2, s1.dist1 + 1, getdistance(v2), i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,POW[11];\nint first_table[10][10],max_size[10][10];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nbool all_covered;\n\nvoid recursive(Info info,int base_row,int base_col,int depth,int max_depth,int rest){\n\n\t/*printf(\"\\ndepth:%d max_depth:%d base_row:%d base_col:%d\\n\",depth,max_depth,base_row,base_col);\n\tprintf(\"max_size[base_row][base_col]:%d\\n\",max_size[base_row][base_col]);*/\n\n\tif(base_row == H || rest == 0){ //??¨???????????????????????§?????£?????´???\n\n\t\tall_covered = true;\n\t\treturn;\n\t}\n\n\tif(depth == max_depth)return;\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0,depth,max_depth,rest);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1,depth,max_depth,rest);\n\t\t}\n\t\treturn;\n\t}\n\n\tint count = 0; //??????????????§????§????????????°\n\n\tfor(int size = max_size[base_row][base_col]; size >=1; size--){\n\n\t\t//printf(\"size:%d\\n\",size);\n\n\t\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\t\tint new_num = 0;\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\t\tnew_num++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\t\tif(count == 0){\n\n\t\t\t\t//printf(\"??°??????????????????????????????\\n\");\n\n\t\t\t\tcount++;\n\n\t\t\t\tcopyTable(next_info,info.table,base_row);\n\t\t\t\tnext_info.num = info.num;\n\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_info,base_row+1,0,depth,max_depth,rest);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_info,base_row,base_col+1,depth,max_depth,rest);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\n\t\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\t\tif(info.table[base_row][base_col] != 0 && count == 0){\n\n\t\t\t\t//printf(\"?????????????????????????????§????????????\\n\");\n\n\t\t\t\tcount++;\n\n\t\t\t\tInfo next_not;\n\n\t\t\t\tcopyTable(next_not,info.table,base_row);\n\t\t\t\tnext_not.num = info.num;\n\n\t\t\t\tint must_add = 0,next_rest = 0;\n\t\t\t\tbool FLG = false;\n\t\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\t\tfor(int row = base_row; row < H; row++){\n\t\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\t\tif(next_not.table[row][col] == 0)next_rest++;\n\n\t\t\t\t\t\tif(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t\t}else if(next_not.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(FLG)must_add++;\n\n\t\t\t\tif(next_not.num+must_add <= max_depth){\n\t\t\t\t\tif(base_col == W-1){\n\t\t\t\t\t\trecursive(next_not,base_row+1,0,depth,max_depth,next_rest);\n\t\t\t\t\t}else{\n\t\t\t\t\t\trecursive(next_not,base_row,base_col+1,depth,max_depth,next_rest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcopyTable(next_info,info.table,base_row);\n\t\t\tnext_info.num = info.num+1;\n\n\t\t\t//????????????????????????\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint must_add = 0,next_rest = 0;\n\t\t\tbool FLG = false;\n\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\tfor(int row = base_row; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_info.table[row][col] == 0)next_rest++;\n\n\t\t\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}else if(next_info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)must_add++;\n\n\t\t\tif(next_info.num+must_add <= max_depth){\n\n\t\t\t\t//???????????????????????????????§?\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_info,base_row+1,0,depth+1,max_depth,next_rest);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_info,base_row,base_col+1,depth+1,max_depth,next_rest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????(?????????1???size?????§!!???)\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*printf(\"first_table\\n\");\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tprintf(\"%d \",first_table[row][col]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");*/\n\n\tint ans;\n\n\tall_covered = false;\n\tint max_depth = 1,rest = 0;\n\n\twhile(max_depth <= 40){\n\n\t\tInfo start;\n\t\tstart.num = 0;\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(first_table[row][col] == -1){\n\t\t\t\t\trest++;\n\t\t\t\t\tstart.table[row][col] = -1;\n\t\t\t\t}else{\n\t\t\t\t\tstart.table[row][col] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trecursive(start,0,0,0,max_depth,rest);\n\t\tif(all_covered){\n\t\t\tans = max_depth;\n\t\t\tbreak;\n\t\t}\n\t\tmax_depth++;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct state {\n\tvector<short> b;\n\tshort dist, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.dist + s1.cost > s2.dist + s2.cost;\n}\nint H, W, a[12][12], cnt, xa[10009], ya[10009], xb[10009], yb[10009], popcount[1033];\nint main() {\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tpopcount[j] = popcount[j - (1 << i)] + 1;\n\t\t}\n\t}\n\twhile (cin >> W >> H, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) {\n\t\t\t\t\t\tif (k - i != l - j) continue;\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor (int x = i; x < k; x++) {\n\t\t\t\t\t\t\tfor (int y = j; y < l; y++) {\n\t\t\t\t\t\t\t\tif (a[x][y] == 0) flag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\txa[cnt] = i;\n\t\t\t\t\t\t\tya[cnt] = j;\n\t\t\t\t\t\t\txb[cnt] = k;\n\t\t\t\t\t\t\tyb[cnt] = l;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> que;\n\t\tshort scnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (a[i][j] == 1) scnt++;\n\t\t\t}\n\t\t}\n\t\tque.push(state{ vector<short>(H, 0), (short)(0), scnt });\n\t\tbool flag = false;\n\t\twhile (!que.empty() && !flag) {\n\t\t\tstate u = que.top(); que.pop();\n\t\t\tfor (int i = 0; i < cnt && !flag; i++) {\n\t\t\t\tvector<short> z = u.b;\n\t\t\t\tfor (int j = xa[i]; j < xb[i]; j++) {\n\t\t\t\t\tz[j] |= (1 << yb[i]) - (1 << ya[i]);\n\t\t\t\t}\n\t\t\t\tshort rcnt = 0;\n\t\t\t\tfor (int j = 0; j < H; j++) rcnt += popcount[z[j]];\n\t\t\t\trcnt = scnt - rcnt;\n\t\t\t\tif (rcnt == 0) {\n\t\t\t\t\tcout << u.dist + 1 << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tque.push(state{ z, (short)(u.dist + 1), rcnt });\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <bitset>\n#include <vector>\nusing namespace std;\n\nconst int MAX_W = 10;\nconst int MAX = MAX_W * MAX_W;\n\ntypedef bitset<MAX> bit;\n\nbit mask;\nint W, H;\nint board[MAX_W][MAX_W];\nint accum[MAX_W + 1][MAX_W + 1];\nint best;\n\nbool included(const bit& a, const bit& b){\n\treturn (a&b) == a;\n}\n\nbool init(){\n\tscanf(\"%d%d\", &W, &H);\n\tfor(int i=0; i<H; ++i){\n\t\tfor(int j=0; j<W; ++j){\n\t\t\tscanf(\"%d\", board[i]+j);\n\t\t}\n\t}\n\treturn H > 0;\n}\n\nvoid dfs(int score, bit brd, vector<bit> bs){\n\tfor(int i=0; i<H*W; ++i)if(!brd[i]){\n\t\tint cnt = 0, key = -1;\n\t\tfor(int j=0; j<(int)bs.size(); ++j){\n\t\t\tif(bs[j][i]){\n\t\t\t\t++cnt;\n\t\t\t\tkey = j;\n\t\t\t}\n\t\t}\n\t\tif(cnt == 1){\n\t\t\t++score;\n\t\t\tbrd |= bs[key];\n\t\t}\n\t}\n\n\tif(brd == mask){\n\t\tbest = min(best, score);\n\t\treturn ;\n\t}\n\n\tif(score >= best - 1){\n\t\treturn ;\n\t}\n\n\tfor(int i=0; i<(int)bs.size(); ++i){\n\t\tbs[i] &= mask & (~brd);\n\t}\n\n\tvector<bit> ts;\n\tfor(int i=0; i<(int)bs.size(); ++i)if(bs[i].any()){\n\t\tfor(int j=i+1; j<(int)bs.size(); ++j){\n\t\t\tif(bs[i]==bs[j]){\n\t\t\t\tbs[j].reset();\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0; i<(int)bs.size(); ++i){\n\t\tbool ok = true;\n\t\tfor(int j=0; j<(int)bs.size(); ++j)if(i!=j){\n\t\t\tif(included(bs[i], bs[j])){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tts.push_back(bs[i]);\n\t\t}\n\t}\n\n\tfor(int i=0; i<(int)ts.size(); ++i){\n\t\tbit t = ts[i];\n\t\tts[i].reset();\n\t\tdfs(score+1, brd | t, ts);\n\t\tts[i] = t;\n\t}\n}\n\nint solve(){\n\tmask.reset();\n\tfor(int i=0; i<W*H; ++i){\n\t\tmask.set(i, true);\n\t}\n\tfor(int i=0; i<H; ++i){\n\t\tfor(int j=0; j<W; ++j){\n\t\t\taccum[i+1][j+1] = accum[i+1][j] + accum[i][j+1] - accum[i][j] + (1 - board[i][j]);\n\t\t}\n\t}\n\n\tbit brd;\n\tvector<bit> bs;\n\tfor(int i=0; i<H; ++i){\n\t\tfor(int j=0; j<W; ++j){\n\t\t\tif(board[i][j] == 0){\n\t\t\t\tbrd.set(i*W+j);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint sz = 0;\n\t\t\t\tfor(int k=1; i+k<=H && j+k<=W; ++k){\n\t\t\t\t\tif(accum[i+k][j+k] - (accum[i+k][j] + accum[i][j+k]) + accum[i][j] == 0){\n\t\t\t\t\t\tsz = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbit bt;\n\t\t\t\tfor(int a=0; a<sz; ++a){\n\t\t\t\t\tfor(int b=0; b<sz; ++b){\n\t\t\t\t\t\tbt.set((i+a)*W+(j+b), true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbs.push_back(bt);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<bit> ts;\n\tfor(int i=0; i<(int)bs.size(); ++i){\n\t\tbool ok = true;\n\t\tfor(int j=0; j<(int)bs.size(); ++j)if(i!=j){\n\t\t\tok &= !included(bs[i], bs[j]);\n\t\t}\n\t\tif(ok){\n\t\t\tts.push_back(bs[i]);\n\t\t}\n\t}\n\n\tbest = MAX;\n\tdfs(0, brd, ts);\n\n\treturn best;\n}\n\nint main(){\n\tfor(;init();){\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#define INF 0x3f3f3f3f\n#define EPS 10e-5\n\ntypedef long long ll;\nconst int dx[]={-1,0,0,1,0},dy[]={0,1,-1,0,0};\nusing namespace std;\nint w,h,ecnt;\nint mps[10][10];    // record used square\nint cnts[10][10][2];// record the square size\nint scts[10][10];\nbool badc[10][10];\nint upbound,bcnt,mxsqus,res;\nbool reach,needf[10][10];\n\nint vps[250];\nint vsct[250][250],vl[250];\n\nvoid dfs(int now,int cost){\n\n    if(ecnt==0) {\n        if(cost==res)\n            reach = true;\n        upbound = min(upbound,cost);\n        return;\n    }\n\n    if(cost+round(1.0*ecnt/mxsqus)>res||reach) return;\n\n    if(now==bcnt) return;\n\n    bool cover = false;\n    int bs = vl[now],*vct=vsct[now];\n\n    for(int i=0;i<bs;++i){\n        if(vps[vct[i]]==0){\n            cover = true;break;\n        }\n    }\n\n    if(!cover) {\n        return dfs(now+1,cost);\n    }\n\n    for(int i=0;i<bs;++i){\n        if(++vps[vct[i]]==1) --ecnt;\n    }\n    dfs(now+1,cost+1);\n    for(int i=0;i<bs;++i){\n        if(--vps[vct[i]]==0) ++ecnt;\n    }\n\n    if(vps[vsct[now][0]]==0) return;\n    dfs(now+1,cost);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);cout.tie(0);\n    while(scanf(\"%d%d\",&w,&h)){\n        if(w==0&&h==0)break;\n        memset(mps,0,sizeof(mps));\n        memset(cnts,0,sizeof(cnts));\n        memset(badc,0,sizeof(badc));\n        memset(needf,0,sizeof(needf));\n        memset(vl,0,sizeof(vl));\n\n        ecnt = mxsqus = 0;\n        int tmp;\n        for(int i=0;i<h;++i)\n            for(int j=0;j<w;++j){\n                scanf(\"%d\",&tmp);\n                if(tmp) {\n                    mps[i][j] = 1;++ecnt;\n                    needf[i][j] = true;\n                }\n            }\n        if(ecnt==0){\n            printf(\"0\\n\");\n            continue;\n        }\n        for(int i=0;i<w;++i){\n            int last = 0;\n            for(int j=h-1;j>=0;--j){\n                if(mps[j][i]) cnts[j][i][1] = ++last;\n                else last = 0;\n            }\n        }\n        for(int i=0;i<h;++i)\n        {\n            int last = 0;\n            for(int j=w-1;j>=0;--j){\n                if(mps[i][j]) cnts[i][j][0] = ++last;\n                else last = 0;\n            }\n        }\n\n        for(int i=0;i<h;++i)\n            for(int j=0;j<w;++j)\n            {\n                int k=j,last = INF;\n                for(;k<w;++k){\n                    last = min(cnts[i][k][1],last);\n                    if(k+1-j>last) break;\n                }\n                mxsqus = max(scts[i][j] = k-j,mxsqus);\n            }\n        mxsqus*=mxsqus;\n        bcnt = 0;\n\n        for(int i=0;i<h;++i)\n            for(int j=0;j<w;++j){\n                if(badc[i][j]) continue;\n                for(int i2=0;i2<scts[i][j];++i2){\n                    for(int j2=0;j2<scts[i][j];++j2){\n                        if(i2==0&&j2==0) continue;\n                        if(scts[i+i2][j+j2]<=min(scts[i][j]-i2,scts[i][j]-j2)){\n                            badc[i+i2][j+j2] = true;\n                        }\n                    }\n                }\n            }\n\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                if(!badc[i][j]){\n                    for(int i2=0;i2<scts[i][j];++i2){\n                        for(int j2=0;j2<scts[i][j];++j2){\n                            vsct[bcnt][vl[bcnt]++] = (i+i2)*w+j+j2;\n                        }\n                    }\n                    bcnt++;\n                }\n            }\n        }\n\n        memset(mps,0,sizeof(mps));\n        upbound = INF;\n        res = ecnt/mxsqus;reach = false;\n        while(!reach&&res!=upbound){\n            dfs(0,0);\n            ++res;\n        }\n        printf(\"%d\\n\",upbound);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\nint W, H;\nint P[20][20];\nint cover[10][10];\nint width[10][10];\nint left_h[10][10];\nint right_h[10][10];\nint top_h[10][10];\nint bottom_h[10][10];\nint ans;\nclock_t start_time;\nint h(int Y, int X){\n    int res = 0;\n    bool tmp[10][10];\n    for(int y = Y; y < H; y++)\n        for(int x = (y == Y ? X : 0); x < W; x++)\n            tmp[y][x] = !cover[y][x];\n    for(int y = Y; y < H; y++){\n        for(int x = (y == Y ? X : 0); x < W; x++){\n            if(tmp[y][x]){\n                res++;\n                for(int by = top_h[y][x]; by <= bottom_h[y][x]; by++){\n                    for(int bx = left_h[y][x]; bx <= right_h[y][x]; bx++){\n                        tmp[by][bx] = false;\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\nint dfs(int x, int y, int sum){\n    //cout << x << \" \" << y << \" \" << sum + h(y, x) << \" \" << ans << endl;\n    if((clock() - start_time) > CLOCKS_PER_SEC * 0.15) return ans;\n    if(sum + h(y, x) >= ans) return INF;\n    if(x == W) return dfs(0, y + 1, sum);\n    if(y == H){\n        return ans = sum;\n    }\n    int res = (cover[y][x] ? dfs(x + 1, y, sum) : INF);\n\n    bool tmp[10][10];\n    int max_w = 0;\n    REP(dx, width[y][x]) REP(dy, width[y][x]){\n        tmp[y + dy][x + dx] = cover[y + dy][x + dx];\n        if(!cover[y + dy][x + dx]) max_w = max(max_w, max(dx + 1, dy + 1));\n    }\n    REP(dx, width[y][x]) REP(dy, width[y][x]) cover[y + dy][x + dx] = true;\n    if(max_w > 0) res = min(res, dfs(x + 1, y, sum + 1));\n    REP(dx, max_w) REP(dy, max_w) cover[y + dy][x + dx] = tmp[y + dy][x + dx];\n    return res;\n}\n\nint main(){\n    while(cin >> W >> H && (W > 0 && H > 0)){\n        REP(y, H) REP(x, W) cin >> P[y][x];\n        REP(y, H) REP(x, W) {\n            width[y][x] = 0;\n            for(int w = 1; x + w <= W && y + w <= H; w++){\n                bool ok = true;\n                REP(dx, w) REP(dy, w) if(!P[y + dy][x + dx]) ok = false;\n                if(!ok) break;\n                width[y][x] = w;\n            }\n        }\n        REP(y, H) REP(x, W) {\n            left_h[y][x] = x;\n            while(left_h[y][x] - 1 >= 0 && P[y][left_h[y][x] - 1]) left_h[y][x]--;\n            right_h[y][x] = x;\n            while(right_h[y][x] + 1 < W && P[y][right_h[y][x] + 1]) right_h[y][x]++;\n            top_h[y][x] = y;\n            while(top_h[y][x] - 1 >= 0 && P[top_h[y][x] - 1][x]) top_h[y][x]--;\n            bottom_h[y][x] = y;\n            while(bottom_h[y][x] + 1 < H && P[bottom_h[y][x] + 1][x]) bottom_h[y][x]++;\n        }\n\n        ans = INF;\n        REP(y, H) REP(x, W) cover[y][x] = !P[y][x];\n        start_time = clock();\n        dfs(0, 0, 0);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct state {\n\tvector<short> b;\n\tshort dist, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.dist + s1.cost > s2.dist + s2.cost;\n}\nint H, W, a[12][12], cnt, xa[10009], ya[10009], xb[10009], yb[10009], popcount[1033];\nint main() {\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tpopcount[j] = popcount[j - (1 << i)] + 1;\n\t\t}\n\t}\n\twhile (cin >> W >> H, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) {\n\t\t\t\t\t\tif (k - i != l - j) continue;\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor (int x = i; x < k; x++) {\n\t\t\t\t\t\t\tfor (int y = j; y < l; y++) {\n\t\t\t\t\t\t\t\tif (a[x][y] == 0) flag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\txa[cnt] = i;\n\t\t\t\t\t\t\tya[cnt] = j;\n\t\t\t\t\t\t\txb[cnt] = k;\n\t\t\t\t\t\t\tyb[cnt] = l;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> que;\n\t\tint scnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (a[i][j] == 1) scnt++;\n\t\t\t}\n\t\t}\n\t\tque.push(state{ vector<short>(H, 0), 0, scnt });\n\t\tbool flag = false;\n\t\twhile (!que.empty() && !flag) {\n\t\t\tstate u = que.top(); que.pop();\n\t\t\tfor (int i = 0; i < cnt && !flag; i++) {\n\t\t\t\tvector<short> z = u.b;\n\t\t\t\tfor (int j = xa[i]; j < xb[i]; j++) {\n\t\t\t\t\tz[j] |= (1 << yb[i]) - (1 << ya[i]);\n\t\t\t\t}\n\t\t\t\tshort rcnt = 0;\n\t\t\t\tfor (int j = 0; j < H; j++) rcnt += popcount[z[j]];\n\t\t\t\trcnt = scnt - rcnt;\n\t\t\t\tif (rcnt == 0) {\n\t\t\t\t\tcout << u.dist + 1 << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tque.push(state{ z, u.dist + 1, rcnt });\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntemplate<class T> T gcd( T a, T b ) {\n\treturn !b ? a : gcd( b, a % b );\n}\ntemplate<class T> T lcm( T a, T b ) {\n\treturn a / gcd( a, b ) * b;\n}\ntemplate<class T> string print_v( vector<T> v ) {\n\tOSS oss;\n\tfor ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end();\n          ++it_i ) {\n\t\toss << *it_i << \", \";\n\t}\n\treturn oss.str();\n}\n\nconst int kr[4] = { 1, -1, 1, -1 };\nconst int kc[4] = { 1, 1, -1, -1 };\nint w, h;\n\nvoid print( VVI T ) {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j] << \",\";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nVVI flip( VVI T, int r, int c ) {\n    VVI NT = T;\n    int cand = 0;\n    int cl = 0;\n    int ck;\n    for ( int L = min( w, h ); L > 0; -- L ) {\n        for ( int k = 0; k < 4; ++ k ) {\n            int cnt = 0;\n            for ( int i = 0; i < L; ++ i ) {\n                for ( int j = 0; j < L; ++ j ) {\n                    int nr = r + i * kr[k];\n                    int nc = c + j * kc[k];\n                    if ( nr < 0 || nr >= h ) goto IGNORE;\n                    if ( nc < 0 || nc >= w ) goto IGNORE;\n                    if ( T[nr][nc] == 0 ) goto IGNORE;\n                    if ( T[nr][nc] == 1 ) cnt ++;\n                }\n            }\n            if ( cnt > cand ) {\n                cand = cnt;\n                ck = k;\n                cl = L;\n            }\n        IGNORE:;\n        }\n    }\n    for ( int i = 0; i < cl; ++ i ) {\n        for ( int j = 0; j < cl; ++ j ) {\n            int nr = r + i * kr[ck];\n            int nc = c + j * kc[ck];\n            NT[nr][nc] = 2;\n        }\n    }\n    return NT;\n}\n\nint main() {\n    while ( cin >> w >> h && w ) {\n        VVI T( h, VI( w ) );\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                cin >> T[i][j];\n            }\n        }\n        int res = 0;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                if ( T[i][j] != 1 ) continue;\n                T = flip( T, i, j );\n                // cout << i << \", \" << j << \": \" << ret.first << endl;\n                res ++;\n                // cout << \"before: \" << endl;\n                // print( T );\n                // cout << \"after: \" << endl;\n                // print( ret.second );\n                // cout << endl;\n            }\n        }\n        cout << res << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 10;\nconst int INF = 19191919;\n\nint w,h;\n\nint p[N][N];\nint sq[N][N];\nint need[N][N];\nint ct[N][N];\n\nbool can_place(int y, int x, int sz){\n    for(int i=y; i<y+sz; ++i)for(int j=x; j<x+sz; ++j)if(!p[i][j]) return false;\n    return true;\n}\n\nint check_need(int y, int x){\n    int LY = y, RY = y+sq[y][x];\n    int LX = x, RX = x+sq[y][x];\n    rep(i,h)rep(j,w){\n        if(i==y && j==x) continue;\n        int ly = i, ry = i+sq[i][j];\n        int lx = j, rx = j+sq[i][j];\n        if(ly<=LY && RY<=ry && lx<=LX && RX<=rx) return 0;\n    }\n    return 1;\n}\n\nint ans;\nint now;\nbool ret;\nvoid dfs(int y, int x){\n    if(y==h-1 && x==w-1){\n        rep(i,h)rep(j,w){\n            if(p[i][j]){\n                if(!ct[i][j]) return;\n            }\n            else{\n                if(ct[i][j]) return;\n            }\n        }\n        ret = true;\n        return;\n    }\n\n    int ny = y, nx = x+1;\n    if(nx==w){\n        ++ny;\n        nx = 0;\n    }\n\n    if(!need[y][x]) dfs(ny,nx);\n    else{\n        if(!ct[y][x]){\n            for(int i=y; i<y+sq[y][x]; ++i)for(int j=x; j<x+sq[y][x]; ++j) ++ct[i][j];\n            if(now<ans){\n                ++now;\n                dfs(ny,nx);\n                --now;\n            }\n            for(int i=y; i<y+sq[y][x]; ++i)for(int j=x; j<x+sq[y][x]; ++j) --ct[i][j];\n        }\n        else{\n            dfs(ny,nx);\n            if(ret) return;\n\n            // bool worth = false;\n            // for(int i=y; i<y+sq[y][x]; ++i)for(int j=x; j<x+sq[y][x]; ++j){\n            //     if(ct[i][j]==0) worth = true;\n            // }\n\n            for(int i=y; i<y+sq[y][x]; ++i)for(int j=x; j<x+sq[y][x]; ++j) ++ct[i][j];\n            if(now<ans){\n                ++now;\n                dfs(ny,nx);\n                --now;\n            }\n            for(int i=y; i<y+sq[y][x]; ++i)for(int j=x; j<x+sq[y][x]; ++j) --ct[i][j];\n        }\n    }\n}\n\nint main(){\n    while(scanf(\" %d %d\", &w, &h),w){\n        rep(i,h)rep(j,w) scanf(\" %d\", &p[i][j]);\n\n        memset(sq,0,sizeof(sq));\n        rep(i,h)rep(j,w)if(p[i][j]){\n            for(int k=min(w-j,h-i); k>=1; --k){\n                if(can_place(i,j,k)){\n                    sq[i][j] = k;\n                    break;\n                }\n            }\n        }\n\n        memset(need,0,sizeof(need));\n        rep(i,h)rep(j,w)if(p[i][j]){\n            need[i][j] = check_need(i,j);\n        }\n\n        memset(ct,0,sizeof(ct));\n        int must = 0;\n        vector<pair<int,int>> ppp;\n        rep(i,h)rep(j,w){\n            if(!need[i][j]) continue;\n\n            bool flg = false;\n            for(int y=i; y<i+sq[i][j]; ++y)for(int x=j; x<j+sq[i][j]; ++x){\n                int covered = 0;\n                rep(li,h)rep(lj,w){\n                    if(!need[li][lj]) continue;\n\n                    if(li<=y && y<li+sq[li][lj] && lj<=x && x<lj+sq[li][lj]) ++covered;\n                }\n                if(covered == 1){\n                    flg = true;\n                    break;\n                }\n            }\n\n            if(flg){\n                ppp.pb({i,j});\n                ++must;\n                for(int y=i; y<i+sq[i][j]; ++y)for(int x=j; x<j+sq[i][j]; ++x) ++ct[y][x];\n            }\n        }\n        for(const auto &pp:ppp) need[pp.fi][pp.se] = 0;\n\n        // rep(i,h){\n        //     rep(j,w) printf(\" %d\", need[i][j]);\n        //     puts(\"\");\n        // }\n\n        ans = must;\n        while(1){\n            // dbg(ans);\n            ret = false;\n            now = must;\n            dfs(0,0);\n            if(ret) break;\n            ++ans;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\n\nint H,W;\nvec t;\nmap< vec , int > dp[10][10];\n\nint mem[10][10][10][10];\n\nbool check(int ay,int ax,int by,int bx){\n  if(mem[ay][ax][by][bx]!=-1)\n    return mem[ay][ax][by][bx];\n\n  mem[ay][ax][by][bx]=false;\n  for(int y=ay;y<=by;y++)\n    for(int x=ax;x<=bx;x++)\n      if( (t[y]>>x&1)==0 )return false;\n\n  mem[ay][ax][by][bx]=true;\n  return true;\n}\n\nint solve(vec p,int y,int x){\n  if(y==H)return 0;\n  \n  if(x==W){\n    return solve(p,y+1,0);\n  }\n  \n  if(dp[y][x].count(p))return dp[y][x][p];\n  int sum=0;\n  for(int i=0;i<H;i++)sum+=p[i];\n  if(sum==0)return 0;\n  \n\n  int res=1e9;\n  if((p[y]>>x&1)==0)res=solve(p,y,x+1);\n\n  for(int i=0;;i++){\n    if(y+i>=H||x+i>=W)break;\n    if(!check(y,x,y+i,x+i))break;\n    if(check(y,x,y+i+1,x+i+1))continue;\n    int ma=(1<<(i+1))-1;\n    vec next=p;\n    for(int j=0;j<=i;j++){\n      next[y+j]|=(ma<<x);\n      next[y+j]-=(ma<<x);\n    }\n\n    if(p==next)continue;\n    res=min(res,solve(next,y,x+1)+1);\n  }\n\n  return dp[y][x][p]=res;\n}\n\nint main(){\n  while(1){\n    cin>>W>>H;\n    if(H==0&&W==0)break;\n    memset( mem, -1, sizeof(mem) );\n    vec si;\n    for(int i=0;i<H;i++){\n      int bit=0,a;\n      for(int j=0;j<W;j++){\n        dp[i][j].clear();\n        \n        cin>>a;\n        if(a==1)bit|=(1<<j);\n      }\n      si.push_back(bit);\n    }\n    t=si;\n    cout<<solve(si,0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\n\nint H,W;\nvec t;\nmap< vec , int > dp[10][10];\n\nbool check(int ay,int ax,int by,int bx){\n  for(int y=ay;y<=by;y++)\n    for(int x=ax;x<=bx;x++)\n      if( (t[y]>>x&1)==0 )return false;\n  return true;\n}\n\nint solve(vec p,int y,int x){\n  if(dp[y][x].count(p))return dp[y][x][p];\n  int sum=0;\n  for(int i=0;i<H;i++)sum+=p[i];\n  if(sum==0)return 0;\n  if(x==W){\n    return solve(p,y+1,0);\n  }\n\n  int res=1e9;\n  if((p[y]>>x&1)==0)res=solve(p,y,x+1);\n\n  for(int i=0;;i++){\n    if(y+i>=H||x+i>=W)break;\n    if(!check(y,x,y+i,x+i))break;\n    int ma=(1<<(i+1))-1;\n    vec next=p;\n    for(int j=0;j<=i;j++){\n      next[y+j]|=(ma<<x);\n      next[y+j]-=(ma<<x);\n    }\n\n    if(p==next)continue;\n    res=min(res,solve(next,y,x+1)+1);\n  }\n\n  return dp[y][x][p]=res;\n}\n\nint main(){\n  while(1){\n    cin>>W>>H;\n    if(H==0&&W==0)break;\n\n    vec si;\n    for(int i=0;i<H;i++){\n      int bit=0,a;\n      for(int j=0;j<W;j++){\n        dp[i][j].clear();\n        \n        cin>>a;\n        if(a==1)bit|=(1<<j);\n      }\n      si.push_back(bit);\n    }\n    t=si;\n    cout<<solve(si,0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans;\nint first_table[10][10],max_size[10][10];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\t//printf(\"ans:%d\\n\",ans);\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\tif(info.table[base_row][base_col] != 0){\n\t\tInfo next_not;\n\n\t\tcopyTable(next_not,info.table,base_row);\n\t\tnext_not.num = info.num;\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(next_not.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tif(next_not.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t}\n\t\t}\n\t}\n\n\tcopyTable(next_info,info.table,base_row);\n\tnext_info.num = info.num+1;\n\n\t//????????????????????????\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t}\n\t}\n\n\tint must_add = 0;\n\tbool FLG = false;\n\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\tmust_add++;\n\t\t\t}else if(next_info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\tFLG = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)must_add++;\n\n\tif(next_info.num+must_add < ans){\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int pos,int d,int remain){\n\t\n\tif(pos==h*w){\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tconst int y=pos/w,x=pos%w;\n\tif(len[y][x]==0) return dfs(pos+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(pos+1,d,remain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(pos+1,d+1,nremain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx];\n\t\t\trep(a,cy,cy+l)rep(b,cx,cx+l) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define N 11\n#define INF (1<<29)\n\nusing namespace std;\n\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\nint bestAns = INF;\nint minHW;\n\nvoid solve(int H, int W, int M[N][N], int depth){\n  /*\n    for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n    if(l>0)putchar(' ');\n    printf(\"%d\", M[k][l]);\n    }\n    putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  bool bComp=true;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j]==1){\n\tbComp=false;\n      }\n    }\n  }\n  if(bComp){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(1+depth>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if( M[i][j] == 0 ){\n\tcontinue;\n      }else if( M[i][j] == 1 ){\n\tint maxOneCount=-1;\n\tvector< pair<int,int> > vk;\n\tfor(int k = 0; k < 4; ++k){\n\t  int size = 0;\n\t  for(size = 1; size <= minHW; ++size){\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t  --size;\n\t\t  goto next1;\n\t\t}\n\t      }\n\t    }\n\t    if(k==0){\n\t      if(i-size<0||j+size>=W)break;\n\t    }else if(k==1){\n\t      if(i+size>=H||j+size>=W)break;\n\t    }else if(k==2){\n\t      if(i+size>=H||j-size<0)break;\n\t    }else{\n\t      if(i-size<0||j-size<0)break;\n\t    }\n\t  }\n\tnext1:;\n\t  int oneCount=0;\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( M[m][n] == 1 ){\n\t\t++oneCount;\n\t      }\n\t    }\n\t  }\n\t  vk.push_back( make_pair(size,oneCount) );\n\t  maxOneCount = max( maxOneCount, oneCount );\n\t}\n\tfor(int k = 0; k < 4; ++k){\n\t  if(vk[k].second==maxOneCount){\n\t    int size = vk[k].first;\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif(M[m][n]==1){\n\t\t  M[m][n]=depth;\n\t\t}\n\t      }\n\t    }\n\t    solve(H,W,M,depth+1);\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( M[m][n] == depth ){\n\t\t  M[m][n]=1;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\treturn ;\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[N][N];\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    solve(H,W,M,2);\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d){\n\tif(x>=w) return dfs(y+1,0,d);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d));\n\n\tint tboard[10];\n\trep(i,y,y+len[y][x]) tboard[i]=board[i];\n\n\tint add=0;\n\tint mask=((1<<len[y][x])-1)<<x;\n\trep(a,y,y+len[y][x]){\n\t\tadd+=(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(add) chmin(ret,dfs(y,x+1,d+1));\n\t\n\trep(i,y,y+len[y][x]) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(cin >> w >> h,w){\n\t\tclr(board,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tboard[i]|=(tmp<<j);\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\trep(a,i,h)rep(b,j,w) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w)rep(a,i,i+len[i][j])rep(b,j,j+len[i][j]) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\t//while(dfs(0,0,0)==inf) min_res++;\n\t\tcout << dfs(0,0,0)+add << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nconst int N = 16;\nconst int inf = 1<<27;\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\n\nusing namespace std;\n\n\nint H,W;\nint M[N][N];\nint maxSizes[N][N][4];\nint oneCount;\nint minHW;\nint ans;\nint greedy_ans;\nint depth;\nmultimap<int,int,greater<int> > maxS;\n\ninline int getHeuristic();\nvoid calc();\nvoid solve(int pos);\n\ninline int getHeuristic()\n{\n  int msz=1;\n  if(!maxS.empty())msz = maxS.begin()->first;\n  msz *= msz;\n  return oneCount/msz + (oneCount%msz>0);\n}\n\nstruct Cand{\n  int i,j;\n  Cand():i(0),j(0){}\n  Cand(int ci, int cj):i(ci),j(cj){}\n  bool operator<(const Cand& t)const{\n    return (i==t.i)?(j<t.j):(i<t.i);\n  }\n};\n\nint cand_num;\nCand cands[N*N];\n\nvoid calc(){\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 1){\n\toneCount++;\n\tcands[cand_num++] = Cand(i,j);\n      }\n      for(int k = 0; k < 4; ++k){\n\tint size = 0;\n\tfor(size = 1; size <= minHW; ++size){\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t--size;\n\t\tgoto next;\n\t      }\n\t    }\n\t  }\n\t  if(k==0){\n\t    if(i-size<0||j+size>=W)break;\n\t  }else if(k==1){\n\t    if(i+size>=H||j+size>=W)break;\n\t  }else if(k==2){\n\t    if(i+size>=H||j-size<0)break;\n\t  }else{\n\t    if(i-size<0||j-size<0)break;\n\t  }\n\t}\n      next:;\n\tmaxSizes[i][j][k] = size;\n\tif(k==1){\n\t  if(size>1){\n\t    maxS.insert( make_pair(size,0) );\n\t  }\n\t}\n      }\n    }\n  }\n  sort(cands,cands+cand_num);\n  return ;\n}\n\nvoid solve_greedy(int pos)\n{\n  // completed.\n  if(oneCount==0){\n    greedy_ans = min(greedy_ans, depth);\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < cand_num; ++p){\n    int i = cands[p].i;\n    int j = cands[p].j;\n    if( M[i][j] == 1 ){\n      int maxOneCount = -1;\n      pair<int,int> vk[4];\n      for(int k = 0; k < 4; ++k){\n\tint cnt = 0;\n\tint size = maxSizes[i][j][k];\n\tfor(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t  for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t    if(M[m][n]==1){\n\t      ++cnt;\n\t    }\n\t  }\n\t}\n\tvk[k] = make_pair( size, cnt );\n\tmaxOneCount = max( maxOneCount, cnt );\n      }\n      for(int k = 0; k < 4; ++k){\n\tif( vk[k].second == maxOneCount ){\n\t  int size = vk[k].first;\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if(M[m][n]==1){\n\t\tM[m][n]=depth;\n\t\t--oneCount;\n\t      }\n\t    }\n\t  }\n\t  ++depth;\n\t  solve_greedy(p+1);\n\t  --depth;\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( M[m][n] == depth ){\n\t\tM[m][n]=1;\n\t\t++oneCount;\n\t      }\n\t    }\n\t  }\n\t  return ;\n\t}\n      }\n    }\n  }\n}\n\nvoid solve(int pos){\n  /*\n    printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W, getHeuristic());\n    for(int k = 0; k < H; ++k){\n      for(int l = 0; l < W; ++l){\n\tif(l>0)putchar(' ');\n\tprintf(\"%2d\", M[k][l]);\n      }\n      putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  if(oneCount==0){\n    ans = min(ans, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic()>=ans){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < cand_num; ++p){\n    int i = cands[p].i;\n    int j = cands[p].j;\n    int size = maxSizes[i][j][1];\n    int valid=0;\n    for(int m = i; m<size+i; m++){\n      for(int n = j; n<size+j; n++){\n\tif(M[m][n]==1){\n\t  valid=1;\n\t  --oneCount;\n\t  M[m][n]=depth;\n\t}\n      }\n    }\n    if( valid ){\n      ++depth;\n      if(size>1)\n\tmaxS.erase( maxS.find(size) );\n      solve(p+1);\n      if(size>1)\n\tmaxS.insert( make_pair(size,0) );\n      --depth;\n    }\n    for(int m = i; m<size+i; m++){\n      for(int n = j; n<size+j; n++){\n\tif( M[m][n] == depth ){\n\t  ++oneCount;\n\t  M[m][n]=1;\n\t}\n      }\n    }\n    if( M[i][j] > 1 )\n      solve(p+1);\n    return ;\n  }\n}\n\nint main()\n{\n  while(true){\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    minHW = min(H,W);\n    oneCount = 0;\n    cand_num = 0;\n    ans=inf;\n    greedy_ans = inf;\n    depth=2;\n    maxS.clear();\n\n    \n    calc();\n\n    solve_greedy(0);\n    ans = greedy_ans;\n    solve(0);\n\n    printf(\"%d\\n\", ans-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nstruct state\n{\n\tvector<vector<int> > v;\n\n\tint dist1;\n\tint dist2;\n\n\tstate(vector<vector<int> > v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 < s2.dist1 + s2.dist2; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 > s2.dist1 + s2.dist2; }\n\nint W, H; vector<vector<int> > start;\n\nmap<vector<vector<int> >, bool> M;\n\nint getdistance(vector<vector<int> > v)\n{\n\tint ret = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (v[i][j] == 1)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tM.clear();\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tstart = vector<vector<int> >(H, vector<int>(W));\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &start[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<state, vector<state>, greater<state> > que;\n\n\t\tque.push(state(start, 0, getdistance(start))); M[start] = true;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tstate s1 = que.top(); que.pop();\n\n\t\t\tif (s1.dist2 == 0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", s1.dist1); break;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= 10; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= H - i; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= W - i; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > v2 = s1.v;\n\n\t\t\t\t\t\tbool flag = true;\n\n\t\t\t\t\t\tfor (int l = j; l < j + i; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = k; m < k + i; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (v2[i][j] == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflag = true; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tv2[i][j] = 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flag) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!M[v2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tM[v2] = true;\n\n\t\t\t\t\t\t\tque.push(state(v2, s1.dist1 + 1, getdistance(v2)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Carpet {\n  int y, x, size;\n  bool contain(const auto& c) const {\n    if(c.x < x) return false;\n    if(x + size < c.x + c.size) return false;\n    if(c.y < y) return false;\n    if(y + size < c.y + c.size) return false;\n    return true;\n  }\n};\n\nint W, H;\nint S[12][12];\nint L[12][12];\n\nint sum(int y1, int x1, int y2, int x2) {\n  return S[y2][x2] - S[y2][x1-1] - S[y1-1][x2] + S[y1-1][x1-1];\n}\n\nbool full(auto y1, auto x1, auto y2, auto x2) {\n  return sum(y1, x1, y2, x2) == (y2 - y1 + 1) * (x2 - x1 + 1);\n};\n\nint greedy(auto& P) {\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] = P[i][j];\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] += S[i][j-1];\n  for(auto j = 1; j <= W; ++j) for(auto i = 1; i <= H; ++i) S[i][j] += S[i-1][j];\n\n  vector<Carpet> carpet;\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) {\n    auto size = -1;\n    for(auto k = 0; k < 10; ++k) {\n      if(H < i+k || W < j+k) break;\n      if(!full(i, j, i+k, j+k)) break;\n      size = k;\n    }\n    if(~size) carpet.push_back({i, j, size});\n  }\n\n  vector<bool> removed(carpet.size());\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) for(auto j = 0; j < carpet.size(); ++j) if(!removed[j]) if(i != j) if(carpet[i].contain(carpet[j])) removed[j] = true;\n\n  int res = 0;\n\n  vector<vector<int>> cnt(H+2, vector<int>(W+2));\n  vector<vector<int>> id(H+2, vector<int>(W+2));\n  for(auto k = 0; k < carpet.size(); ++k) if(!removed[k]) {\n    auto c = carpet[k];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) {\n      ++cnt[i][j];\n      id[i][j] = k;\n    }\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(cnt[i][j] == 1) if(!removed[id[i][j]]) {\n    removed[id[i][j]] = true;\n    ++res;\n    auto c = carpet[id[i][j]];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) P[i][j] = 0;\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) L[i][j] = 0;\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) L[carpet[i].y][carpet[i].x] = carpet[i].size + 1;\n\n  return res;\n}\n\nint ans;\nvoid dfs(auto P, int sy, int sx, int depth) {\n  int y, x;\n  for(y = sy; y <= H; ++y) {\n    for(x = (y==sy ? sx : 1); x <= W; ++x) {\n      if(L[y][x]) break;\n      if(P[y][x] == 1) return;\n    }\n    if(L[y][x]) break;\n  }\n  if(y == H+1 || x == W+1) {\n    ans = min(ans, depth);\n    return;\n  }\n  if(depth >= ans) return;\n  if(P[y][x] == 0) {\n    auto ny = y, nx = x + 1;\n    if(W < x) {++ny; nx = 1;}\n    dfs(P, ny, nx, depth);\n    if(depth >= ans) return;\n  }\n  auto cnt = 0;\n  for(auto i = y; i < y + L[y][x]; ++i) for(auto j = x; j < x + L[y][x]; ++j) if(P[i][j] == 1) {\n    P[i][j] = 0;\n    ++cnt;\n  }\n  if(cnt == 0) return;\n  dfs(P, y, x, depth + 1);\n}\n\nint solve(auto P) {\n  auto fix = greedy(P);\n  ans = 100;\n  dfs(P, 1, 1, 0);\n  return fix + ans;\n}\n\nint main() {\n  while(cin >> W >> H, W | H) {\n    vector<vector<int>> P(H+2, vector<int>(W+2));\n    for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> P[i][j];\n    cout << solve(P) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\t\t\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tif(min_res>30) min_res=30;\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint w, h;\nvector<vi> p, len, fld;\ntypedef tuple<vector<vi>, int, int> Data;\nmap<Data, int> mp;\n\nbool check(int x,int y,int l)\n{\n\tREP(i, l)REP(j, l)\n\t{\n\t\tint tx = x + i, ty = y + j;\n\t\tif (!valid(tx, ty, h, w)) return false;\n\t\tif (!p[tx][ty]) return false;\n\t}\n\treturn true;\n}\n\nint dfs(int x, int y)\n{\n\tData tmp = make_tuple(fld, x, y);\n\tif (mp.count(tmp)) return mp[tmp];\n\t//if (mp.count(fld)) return mp[fld];\n\tint res = INF;\n\tif (y == w) res = dfs(x + 1, 0);\n\telse if (x == h) return 0;\n\telse if (!p[x][y]) res = dfs(x, y + 1);\n\telse if (!fld[x][y])\n\t{\n\t\tvector<pii> v;\n\t\tint l = len[x][y];\n\t\tREP(i, l)REP(j, l)\n\t\t{\n\t\t\tint tx = x + i, ty = y + j;\n\t\t\tif (!fld[tx][ty]) v.emplace_back(tx, ty);\n\t\t}\n\t\tif (v.size())\n\t\t{\n\t\t\tREP(i, v.size())\n\t\t\t{\n\t\t\t\tfld[v[i].first][v[i].second] = 1;\n\t\t\t}\n\t\t\tres = dfs(x, y + 1) + 1;\n\t\t\tREP(i, v.size())\n\t\t\t{\n\t\t\t\tfld[v[i].first][v[i].second] = 0;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tchmin(res, dfs(x, y + 1));\n\t\tvector<pii> v;\n\t\tint l = len[x][y];\n\t\tREP(i, l)REP(j, l)\n\t\t{\n\t\t\tint tx = x + i, ty = y + j;\n\t\t\tif (!fld[tx][ty]) v.emplace_back(tx, ty);\n\t\t}\n\t\tif (v.size())\n\t\t{\n\t\t\tREP(i, v.size())\n\t\t\t{\n\t\t\t\tfld[v[i].first][v[i].second] = 1;\n\t\t\t}\n\t\t\tchmin(res, dfs(x, y + 1) + 1);\n\t\t\tREP(i, v.size())\n\t\t\t{\n\t\t\t\tfld[v[i].first][v[i].second] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t//REP(i, h)\n\t//{\n\t//\tREP(j, w) cout << fld[i][j] << \" \";\n\t//\tcout  << endl;\n\t//}\n\treturn mp[tmp] = res;\n\t//return mp[fld] = res;\n\t//return res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\twhile (cin >> w >> h, w)\n\t{\n\t\tp.clear(), len.clear(), fld.clear(), mp.clear();\n\t\tp.resize(h, vi(w)), len.resize(h, vi(w)), fld.resize(h, vi(w));\n\t\tREP(i,h)REP(j,w)\n\t\t{\n\t\t\tcin >> p[i][j];\n\t\t\tif (!p[i][j]) fld[i][j] = 1;\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (!p[i][j]) continue;\n\t\t\tfor (int k = min(h, w); k >= 0; k--)\n\t\t\t{\n\t\t\t\tif (check(i, j, k))\n\t\t\t\t{\n\t\t\t\t\tlen[i][j] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << dfs(0, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <bitset>\n#include <vector>\nusing namespace std;\n\nconst int MAX_W = 10;\nconst int MAX = MAX_W * MAX_W;\n\ntypedef bitset<MAX> bit;\n\nbit mask;\nint W, H;\nint board[MAX_W][MAX_W];\nint accum[MAX_W + 1][MAX_W + 1];\nint best;\n\nbool included(const bit& a, const bit& b){\n\treturn (a&b) == a;\n}\n\nbool init(){\n\tscanf(\"%d%d\", &W, &H);\n\tfor(int i=0; i<H; ++i){\n\t\tfor(int j=0; j<W; ++j){\n\t\t\tscanf(\"%d\", board[i]+j);\n\t\t}\n\t}\n\treturn H > 0;\n}\n\nvoid dfs(int score, bit brd, vector<bit> bs){\n\tfor(int i=0; i<H*W; ++i)if(!brd[i]){\n\t\tint cnt = 0, key = -1;\n\t\tfor(int j=0; j<(int)bs.size(); ++j){\n\t\t\tif(bs[j][i]){\n\t\t\t\t++cnt;\n\t\t\t\tkey = j;\n\t\t\t}\n\t\t}\n\t\tif(cnt == 1){\n\t\t\t++score;\n\t\t\tbrd |= bs[key];\n\t\t}\n\t}\n\n\tif(brd == mask){\n\t\tbest = min(best, score);\n\t\treturn ;\n\t}\n\n\tif(score >= best - 1){\n\t\treturn ;\n\t}\n\n\tfor(int i=0; i<(int)bs.size(); ++i){\n\t\tbs[i] &= mask & (~brd);\n\t}\n\n\tvector<bit> ts;\n\tfor(int i=0; i<(int)bs.size(); ++i){\n\t\tbool ok = true;\n\t\tfor(int j=0; j<(int)bs.size(); ++j)if(i!=j){\n\t\t\tif(included(bs[i], bs[j])){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tts.push_back(bs[i]);\n\t\t}\n\t}\n\n\tfor(int i=0; i<(int)ts.size(); ++i){\n\t\tbit t = ts[i];\n\t\tts[i].reset();\n\t\tdfs(score+1, brd | t, ts);\n\t\tts[i] = t;\n\t}\n}\n\nint solve(){\n\tmask.reset();\n\tfor(int i=0; i<W*H; ++i){\n\t\tmask.set(i, true);\n\t}\n\tfor(int i=0; i<H; ++i){\n\t\tfor(int j=0; j<W; ++j){\n\t\t\taccum[i+1][j+1] = accum[i+1][j] + accum[i][j+1] - accum[i][j] + (1 - board[i][j]);\n\t\t}\n\t}\n\n\tbit brd;\n\tvector<bit> bs;\n\tfor(int i=0; i<H; ++i){\n\t\tfor(int j=0; j<W; ++j){\n\t\t\tif(board[i][j] == 0){\n\t\t\t\tbrd.set(i*W+j);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint sz = 0;\n\t\t\t\tfor(int k=1; i+k<=H && j+k<=W; ++k){\n\t\t\t\t\tif(accum[i+k][j+k] - (accum[i+k][j] + accum[i][j+k]) + accum[i][j] == 0){\n\t\t\t\t\t\tsz = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbit bt;\n\t\t\t\tfor(int a=0; a<sz; ++a){\n\t\t\t\t\tfor(int b=0; b<sz; ++b){\n\t\t\t\t\t\tbt.set((i+a)*W+(j+b), true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbs.push_back(bt);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<bit> ts;\n\tfor(int i=0; i<(int)bs.size(); ++i){\n\t\tbool ok = true;\n\t\tfor(int j=0; j<(int)bs.size(); ++j)if(i!=j){\n\t\t\tok &= !included(bs[i], bs[j]);\n\t\t}\n\t\tif(ok){\n\t\t\tts.push_back(bs[i]);\n\t\t}\n\t}\n\n\tbest = MAX;\n\tdfs(0, brd, ts);\n\treturn best;\n}\n\nint main(){\n\tfor(;init();){\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nint makeCode(int table[10]){\n\tint ret = 0;\n\n\tfor(int col = 0; col < W; col++){\n\t\tif(table[col] == 0){\n\t\t\tret += POW[col];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\tif(base_row == H-2 && base_col == 0){ //?????????2?????§??????????????\\??????\n\n\t\tint code1 = makeCode(info.table[H-2]);\n\t\tint code2 = makeCode(info.table[H-1]);\n\n\t\tif(check[code1][code2] <= info.num)return;\n\n\t\tcheck[code1][code2] = info.num;\n\t}\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tvector<Data> V;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tV.push_back(Data(base_row+i,base_col+k));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(V.size() == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\t/*for(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}*/\n\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\tinfo.table[V[i].row][V[i].col]++;\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < POW[W]; i++){\n\t\tfor(int k = 0; k < POW[W]; k++)check[i][k] = BIG_NUM;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[12][12];\nint h[12][12][200];\nint w[12][12][200];\nint n[12][12][200];\nint sz[12][12];\nint H,W;\nint valid(int a,int b,int t){\n\tif(a<0||b<0||a+t>H||b+t>W)return 0;\n\tfor(int i=0;i<t;i++)for(int j=0;j<t;j++)if(!c[a+i][b+j])return 0;\n\treturn 1;\n}\nint lim;\nint last[100][12][12];\nint dfs(int a,int b,int v){\n\tif(a==H)return 1;\n\tif(b==W)return dfs(a+1,0,v);\n\tif(c[a][b]!=1)return dfs(a,b+1,v);\n\tif(v==lim)return 0;\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)last[v][i][j]=c[i][j];\n\tfor(int i=0;i<sz[a][b];i++){\n\t\tfor(int j=0;j<n[a][b][i];j++)for(int k=0;k<n[a][b][i];k++){\n\t\t\tc[h[a][b][i]+j][w[a][b][i]+k]=2;\n\t\t}\n\t\tif(dfs(a,b+1,v+1))return 1;\n\t\tfor(int j=0;j<n[a][b][i];j++)for(int k=0;k<n[a][b][i];k++)c[h[a][b][i]+j][w[a][b][i]+k]=last[v][h[a][b][i]+j][w[a][b][i]+k];\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%d\",&c[i][j]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)sz[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tfor(int k=1;k<=min(a,b);k++){\n\t\t\t\tif(valid(i,j,k)&&!valid(i-1,j-1,k+1)&&!valid(i-1,j,k+1)&&!valid(i,j-1,k+1)&&!valid(i,j,k+1)){\n\t\t\t\t\tfor(int l=0;l<k;l++)for(int m=0;m<k;m++){\n\t\t\t\t\t\th[i+l][j+m][sz[i+l][j+m]]=i;\n\t\t\t\t\t\tw[i+l][j+m][sz[i+l][j+m]]=j;\n\t\t\t\t\t\tn[i+l][j+m][sz[i+l][j+m]]=k;\n\t\t\t\t\t\tsz[i+l][j+m]++;\n\t\t\t\t\t//\tprintf(\"%d %d %d %d %d\\n\",i,j,k,i+l,j+m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<b;j++)for(int k=0;k<sz[i][j];k++);\n\t\t//\tprintf(\"%d %d: %d %d %d\\n\",i,j,h[i][j][k],w[i][j][k],n[i][j][k]);\n\t\tint ad=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint M=0;\n\t\t\tfor(int k=0;k<sz[i][j];k++)M=max(M,n[i][j][k]);\n\t\t\tif(M==1){\n\t\t\t\tad++;\n\t\t\t\tc[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;;i++){\n\t\t\tlim=i;\n\t\t\tif(dfs(0,0,0)){\n\t\t\t\tprintf(\"%d\\n\",ad+i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define N 11\n#define INF (1<<27)\n\nusing namespace std;\n\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\nint maxSizes[N][N][4];\nint bestAns = INF;\nint minHW;\n\nint getHeuristic(int H, int W, int M[N][N])\n{\n  int maxSize = 1;\n  int size[N][N] = {{0,},};\n  int oneCount = 0;\n\n  for(int i = H-1; i >= 0; --i){\n    if( M[i][W-1] >= 1 ){\n      size[i][W-1] = 1;\n      if( M[i][W-1] == 1 )\n\t++oneCount;\n    }\n  }\n\n  for(int j = W-1; j >= 0; --j){\n    if( M[H-1][j] >= 1 ){\n      size[H-1][j] = 1;\n      if( M[H-1][j] == 1 )\n\t++oneCount;\n    }\n  }\n\n  if( M[H-1][W-1] == 1 ) --oneCount;\n\n  for(int i = H-2; i >= 0; --i){\n    for(int j = W-2; j >= 0; --j){\n      if( M[i][j] >= 1 ){\n\tsize[i][j] = 1+min( size[i+1][j], min( size[i+1][j+1], size[i][j+1] ) );\n\tmaxSize = max( maxSize, size[i][j] );\n\tif(M[i][j] == 1){\n\t  ++oneCount;\n\t}\n      }\n    }\n  }\n  \n  maxSize *= maxSize;\n  return (oneCount / maxSize) + (oneCount%maxSize>0);\n}\n\nvoid calc(int H, int W, int M[N][N]){\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      for(int k = 0; k < 4; ++k){\n\tint size = 0;\n\tfor(size = 1; size <= minHW; ++size){\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t--size;\n\t\tgoto next;\n\t      }\n\t    }\n\t  }\n\t  if(k==0){\n\t    if(i-size<0||j+size>=W)break;\n\t  }else if(k==1){\n\t    if(i+size>=H||j+size>=W)break;\n\t  }else if(k==2){\n\t    if(i+size>=H||j-size<0)break;\n\t  }else{\n\t    if(i-size<0||j-size<0)break;\n\t  }\n\t}\n      next:;\n\tmaxSizes[i][j][k] = size;\n      }\n    }\n  }\n  return ;\n}\n\nvoid solve(int H, int W, int pos, int M[N][N], int depth){\n \n  /*\n  printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W,getHeuristic(H,W,M));\n  for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n      if(l>0)putchar(' ');\n      printf(\"%d\", M[k][l]);\n    }\n    putchar('\\n');\n  }\n  putchar('\\n');\n  */\n\n  // completed.\n  bool bComp=true;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j]==1){\n\tbComp=false;\n\tgoto end;\n      }\n    }\n  }\n end:;\n  if(bComp){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic(H,W,M)>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < H*W; ++p){\n    int i = p / W;\n    int j = p % W;\n    if( M[i][j] == 0 ){\n      continue;\n    }else if( M[i][j] == 1 ){\n      int maxSize = -1;\n      int maxOneCount = -1;\n      pair<int,int> vk[4];\n      for(int k = 0; k < 4; ++k){\n\tint oneCount = 0;\n\tint size = maxSizes[i][j][k];\n\tfor(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t  for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t    if(M[m][n]==1){\n\t      ++oneCount;\n\t    }\n\t  }\n\t}\n\tvk[k] = make_pair( size, oneCount );\n\tmaxSize = max( maxSize, size );\n\tmaxOneCount = max( maxOneCount, oneCount );\n      }\n      for(int k = 0; k < 4; ++k){\n\tif(maxSize == vk[k].first && maxOneCount == vk[k].second ){\n\t  int size = vk[k].first;\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if(M[m][n]==1){\n\t\tM[m][n]=depth;\n\t      }\n\t    }\n\t  }\n\t  solve(H,W,p+1,M,depth+1);\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( M[m][n] == depth ){\n\t\tM[m][n]=1;\n\t      }\n\t    }\n\t  }\n\t  if(maxSize==1)break;\n\t}\n      }\n      solve(H,W,p+1,M,depth+1);\n      return ;\n    }   \n  }\n}\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[N][N];\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    calc(H,W,M);\n    solve(H,W,0,M,2);\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\nint W, H;\nint P[20][20];\nint cover[10][10];\nint width[10][10];\nint left_h[10][10];\nint right_h[10][10];\nint top_h[10][10];\nint bottom_h[10][10];\nint ans;\nclock_t start_time;\nint h(int Y, int X){\n    int res = 0;\n    bool tmp[10][10];\n    for(int y = Y; y < H; y++)\n        for(int x = (y == Y ? X : 0); x < W; x++)\n            tmp[y][x] = !cover[y][x];\n    for(int y = Y; y < H; y++){\n        for(int x = (y == Y ? X : 0); x < W; x++){\n            if(tmp[y][x]){\n                res++;\n                for(int by = top_h[y][x]; by <= bottom_h[y][x]; by++){\n                    for(int bx = left_h[y][x]; bx <= right_h[y][x]; bx++){\n                        tmp[by][bx] = false;\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\nint dfs(int x, int y, int sum){\n    //cout << x << \" \" << y << \" \" << sum + h(y, x) << \" \" << ans << endl;\n    if((clock() - start_time) > CLOCKS_PER_SEC * 0.5) return ans;\n    if(sum + h(y, x) >= ans) return INF;\n    if(x == W) return dfs(0, y + 1, sum);\n    if(y == H){\n        return ans = sum;\n    }\n    int res = (cover[y][x] ? dfs(x + 1, y, sum) : INF);\n\n    bool tmp[10][10];\n    int max_w = 0;\n    REP(dx, width[y][x]) REP(dy, width[y][x]){\n        tmp[y + dy][x + dx] = cover[y + dy][x + dx];\n        if(!cover[y + dy][x + dx]) max_w = max(max_w, max(dx + 1, dy + 1));\n    }\n    REP(dx, width[y][x]) REP(dy, width[y][x]) cover[y + dy][x + dx] = true;\n    if(max_w > 0) res = min(res, dfs(x + 1, y, sum + 1));\n    REP(dx, max_w) REP(dy, max_w) cover[y + dy][x + dx] = tmp[y + dy][x + dx];\n    return res;\n}\n\nint main(){\n    while(cin >> W >> H && (W > 0 && H > 0)){\n        REP(y, H) REP(x, W) cin >> P[y][x];\n        REP(y, H) REP(x, W) {\n            width[y][x] = 0;\n            for(int w = 1; x + w <= W && y + w <= H; w++){\n                bool ok = true;\n                REP(dx, w) REP(dy, w) if(!P[y + dy][x + dx]) ok = false;\n                if(!ok) break;\n                width[y][x] = w;\n            }\n        }\n        REP(y, H) REP(x, W) {\n            left_h[y][x] = x;\n            while(left_h[y][x] - 1 >= 0 && P[y][left_h[y][x] - 1]) left_h[y][x]--;\n            right_h[y][x] = x;\n            while(right_h[y][x] + 1 < W && P[y][right_h[y][x] + 1]) right_h[y][x]++;\n            top_h[y][x] = y;\n            while(top_h[y][x] - 1 >= 0 && P[top_h[y][x] - 1][x]) top_h[y][x]--;\n            bottom_h[y][x] = y;\n            while(bottom_h[y][x] + 1 < H && P[bottom_h[y][x] + 1][x]) bottom_h[y][x]++;\n        }\n\n        ans = INF;\n        REP(y, H) REP(x, W) cover[y][x] = !P[y][x];\n        start_time = clock();\n        dfs(0, 0, 0);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE=100;\nusing F=bitset<SIZE>;\n\nauto comp=[](const F& lhs,const F& rhs){\n    return lhs.count()<rhs.count();\n};\n\nint dfs(int pos,vector<vector<F>> &bigSq,F state,unordered_map<F,int>& dp){\n    if(pos==bigSq.size()){\n        return 0;\n    }\n    if(dp.count(state)){\n        return dp[state];\n    }\n    if(!state[pos]){\n        auto ret=dfs(pos+1,bigSq,state,dp);\n        dp[state]=ret;\n        return ret;\n    }\n    \n    vector<F> toS;\n    for(int i=0;i<bigSq[pos].size();i++){\n        toS.push_back(state & (~bigSq[pos][i]));\n    }\n    int res=1e6;\n    sort(toS.begin(),toS.end(),comp);\n    for(int i=0;i<toS.size();i++){\n        bool isok=true;\n        for(int j=0;j<i;j++){\n            isok&=!((toS[i]&toS[j])==toS[j]);\n        }\n        if(isok){\n            res=min(res,dfs(pos+1,bigSq,toS[i],dp)+1);\n        }\n    }\n    return dp[state]=res;\n}\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        vector<vector<int>> f(h,vector<int>(w,0));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>f[i][j];\n            }\n        }\n        \n        F state=0;\n        vector<vector<F>> bigSq(h*w);\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(!f[i][j]) continue;\n                state.set(i*w+j);\n                int s=0;\n                for(int k=1;k<=10;k++){\n                    bool isok=true;\n                    for(int ii=0;ii<k;ii++){\n                        for(int jj=0;jj<k;jj++){\n                            isok&=(i+ii<h && j+jj<w && f[i+ii][j+jj]);\n                        }\n                    }\n                    if(!isok) break;\n                    s++;\n                }\n                F sq=0;\n                for(int ii=0;ii<s;ii++){\n                    for(int jj=0;jj<s;jj++){\n                        sq.set((ii+i)*w+j+jj);\n                    }\n                }\n                for(int ii=0;ii<s;ii++){\n                    for(int jj=0;jj<s;jj++){\n                        bigSq[(i+ii)*w+j+jj].push_back(sq);\n                    }\n                }\n                sort(bigSq[i*w+j].begin(),bigSq[i*w+j].end(),comp);\n            }\n        }\n\n        for(int i=0;i<h*w;i++){\n            vector<F> newBigSq;\n            for(int j=0;j<bigSq[i].size();j++){\n                bool isok=true;\n                for(int k=j+1;k<bigSq[i].size();k++){\n                    isok&=((bigSq[i][j] & bigSq[i][k])!=bigSq[i][j]);\n                }\n                if(isok) newBigSq.push_back(bigSq[i][j]);\n            }\n            bigSq[i]=newBigSq;\n        }\n        \n        unordered_map<F,int> dp;\n\n        int res=dfs(0,bigSq,state,dp);\n        cout<<res<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<map>\n#include<vector>\n#include<algorithm>\n\n#define N 16\n#define INF (1<<27)\n\nusing namespace std;\n\nint H,W;\nint M[N][N];\nint maxSizes[N][N];\nint oneCount;\nint minHW;\nbool bGreedy;\nint ans;\nint depth;\nmultimap<int,int,greater<int> > maxS;\n\ninline int getHeuristic();\nvoid calc();\nvoid solve(int pos);\n\ninline int getHeuristic()\n{\n  int msz=1;\n  if(!maxS.empty())msz = maxS.begin()->first;\n  msz *= msz;\n  return oneCount/msz + (oneCount%msz>0);\n}\n\nstruct Cand{\n  int i,j;\n  Cand():i(0),j(0){}\n  Cand(int ci, int cj):i(ci),j(cj){}\n  bool operator<(const Cand& t)const{\n    return (i==t.i)?(j<t.j):(i<t.i);\n  }\n};\nint cand_num;\nCand cands[N*N];\n\nvoid calc(){\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 1) oneCount++;\n      int size = 0;\n      for(size = 1; size <= minHW; ++size){\n\tfor(int m = i; m<i+size; m++){\n\t  for(int n = j; n<j+size; n++){\n\t    if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t      --size;\n\t      goto next;\n\t    }\n\t  }\n\t}\n\tif(i+size>=H||j+size>=W)break;\n      }\n      next:;\n      maxSizes[i][j] = size;\n      if(M[i][j]==1){\n\tcands[cand_num++] = Cand(i,j);\n      }\n      if(size>1){\n\tmaxS.insert( make_pair(size,0) );\n      }\n    }\n  }\n  sort(cands,cands+cand_num);\n  return ;\n}\n\nvoid solve(int pos){\n  /*\n    printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W, getHeuristic());\n    for(int k = 0; k < H; ++k){\n      for(int l = 0; l < W; ++l){\n\tif(l>0)putchar(' ');\n\tprintf(\"%2d\", M[k][l]);\n      }\n      putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  if(oneCount==0){\n    ans = min(ans, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic()>=ans){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < cand_num; ++p){\n    int i = cands[p].i;\n    int j = cands[p].j;\n    if( bGreedy ? (M[i][j] == 1) : (M[i][j] >= 1) ){\n      int size = maxSizes[i][j];\n      int valid=0;\n      for(int m = i; m<size+i; m++){\n\tfor(int n = j; n<size+j; n++){\n\t  if(M[m][n]==1){\n\t    valid=1;\n\t    --oneCount;\n\t    M[m][n]=depth;\n\t  }\n\t}\n      }\n      if( valid ){\n\t++depth;\n\tif(size>1)\n\t  maxS.erase( maxS.find(size) );\n\tsolve(p+1);\n\tif(size>1)\n\t  maxS.insert( make_pair(size,0) );\n\t--depth;\n      }\n      for(int m = i; m<size+i; m++){\n\tfor(int n = j; n<size+j; n++){\n\t  if( M[m][n] == depth ){\n\t    ++oneCount;\n\t    M[m][n]=1;\n\t  }\n\t}\n      }\n      if( M[i][j] > 1 )\n\tsolve(p+1);\n      return ;\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    minHW = min(H,W);\n    oneCount = 0;\n    cand_num = 0;\n    ans=INF;\n    depth=2;\n    maxS.clear();\n\n    calc();\n\n    bGreedy=true;\n    solve(0);\n    bGreedy=false;\n    solve(0);\n\n    printf(\"%d\\n\", ans-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint w, h, p[10][10], cnt;\nbool scrach[10][10];\n\nbool check2(int y, int x){\n  if(y<0||x<0||h<=y||w<=x) return true;\n  return (!scrach[y][x])||(scrach[y][x]&&!p[y][x]);\n}\n\nint check(int y, int x, int l){\n  \n  if(h<=y+l||w<=x+l) return 0;\n  \n  int y1=y, x1=x;\n  int y2=y+l, x2=x;\n  int y3=y, x3=x+l;\n  int y4=y+l, x4=x+l;\n  \n  bool flag=false;\n  \n  flag|=(check2(y1-1,x1)&&check2(y1,x1-1)&&p[y1][x1]);\n  flag|=(check2(y2+1,x2)&&check2(y2,x2-1)&&p[y2][x2]);\n  flag|=(check2(y3-1,x3)&&check2(y3,x3+1)&&p[y3][x3]);\n  flag|=(check2(y4+1,x4)&&check2(y4,x4+1)&&p[y4][x4]);\n  \n  bool f=true;\n  \n  int res=0;\n  \n  for(int i=y;i<=y+l;i++)\n    for(int j=x;j<=x+l;j++){\n      if(!scrach[i][j]) f=false;\n      res+=p[i][j];\n    }\n  \n  flag&=f;\n  \n  if(flag) return res;  \n  \n  return 0;\n}\n\nvoid solve(){\n\n  int ans=0;\n  \n  for(int l=9;l>=0;l--){\n\n    int flag=1;\n    \n    while(flag&&cnt){\n      \n      flag=0;\n      \n      int maxr=0, y, x;\n      \n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  int r=check(i,j,l);\n\t  \n\t  if(maxr<r){\n\t    flag=1;\n\t    maxr=r;\n\t    y=i;\n\t    x=j;\n\t  }\n\t  \n\t}\n\t\n      }\n\n      if(flag){\n\t\n\tfor(int i=y;i<=y+l;i++)\n\t  for(int j=x;j<=x+l;j++) p[i][j]=0;\n\t\n\tcnt-=maxr;\n\tans++;\t\n      }\n      \n    }\n    \n  }\n\n  cout<<ans<<endl;\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>w>>h;\n    if(!w&&!h) break;\n    \n    cnt=0;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin>>p[i][j];\n\tcnt+=p[i][j];\n\tscrach[i][j]=p[i][j];\n      }\n    \n    solve();\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\t\t\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min(20,min_res))+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nint makeCode(int table[10]){\n\tint ret = 0;\n\n\tfor(int col = 0; col < W; col++){\n\t\tif(table[col] == 0){\n\t\t\tret += POW[col];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\tif(base_row == H-2 && base_col == 0){ //?????????2?????§??????????????\\??????\n\n\t\tint code1 = makeCode(info.table[H-2]);\n\t\tint code2 = makeCode(info.table[H-1]);\n\n\t\tcheck[code1][code2] = info.num;\n\t}\n\n\t//printf(\"ans:%d\\n\",ans);\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\t\t\tInfo next_not;\n\n\t\t\tcopyTable(next_not,info.table,base_row);\n\t\t\tnext_not.num = info.num;\n\n\t\t\tint must_add = 0;\n\t\t\tbool FLG = false;\n\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\tfor(int row = base_row; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}else if(next_not.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)must_add++;\n\n\t\t\tif(next_not.num+must_add < ans){\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num+1;\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(next_info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tif(next_info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_info,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < POW[W]; i++){\n\t\tfor(int k = 0; k < POW[W]; k++)check[i][k] = BIG_NUM;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d){\n\t\n\tif(y==h && x==0){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d>min_res) return inf;\n\n\tint ny=y,nx=x+1;\n\tif(nx==w) ny++,nx=0;\t\n\n\tif(len[y][x]==0) return dfs(ny,nx,d);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(ny,nx,d));\n\n\tint tboard[10];\n\trep(i,y,h) tboard[i]=board[i];\n\n\tbool ok=false;\n\tint mask=0;\n\trep(b,x,x+len[y][x]) mask|=bit(b);\n\trep(a,y,y+len[y][x]){\n\t\tif((board[a]&mask)!=0) ok=true;\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(ok) chmin(ret,dfs(ny,nx,d+1));\n\t\n\trep(i,y,h) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(cin >> w >> h,w){\n\t\tclr(board,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tboard[i]|=(tmp<<j);\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\trep(a,i,h)rep(b,j,w) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w)rep(a,i,i+len[i][j])rep(b,j,j+len[i][j]) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\t//while(dfs(0,0,0)==inf) min_res++;\n\t\tcout << dfs(0,0,0)+add << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,n,A[11][11],ans,cnt;\nbitset<100> B[11][11],p;\n\nvoid dfs(int d,bitset<100> s,int sco){\n  if(d==n){\n    ans=min(ans,sco);\n    return;\n  }\n  cnt++;\n  if(cnt>=19000000)return;\n  if(ans<=sco)return;\n  if(!A[d/w][d%w])dfs(d+1,s,sco);\n  else{\n    int y=d/w;\n    int x=d%w;\n    if((B[y][x]&s).any()){\n      p&=0;\n      p.set(y*10+x);//(y*100+x);\n      if(!(s&p).any())dfs(d+1,s,sco);\n      dfs(d+1,(B[y][x]|s)^B[y][x],sco+1);\n    }\n    else dfs(d+1,s,sco);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    memset(A,0,sizeof(A));\n    r(i,11)r(j,11)B[i][j]&=0;\n    n=h*w;\n    bitset<100> b;\n    r(i,h)r(j,w)cin>>A[i][j];\n    r(i,h)r(j,w)if(A[i][j]){\n      int sum=1;\n      for(;;sum++){\n        int f=0;\n        for(int y=i;y<i+sum;y++){\n          for(int x=j;x<j+sum;x++){\n            if(A[y][x]==0)f++;\n          }\n        }\n        if(f){\n          sum--;\n          break;\n        }\n      }\n      bitset<100>tmp;\n      for(int y=i,k=0;k<sum;k++,y++){\n        for(int x=j,l=0;l<sum;l++,x++){\n          tmp.set(y*10+x);\n        }\n      }\n      b.set(i*10+j);\n      B[i][j]=tmp;\n    }\n    ans=100;\n    cnt=0;\n    dfs(0,b,0);\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define N 11\n#define INF (1<<29)\n\nusing namespace std;\n\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\nint bestAns = INF;\nint minHW;\n\nvoid solve(int H, int W, int M[N][N], int depth){\n  /*\n    for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n    if(l>0)putchar(' ');\n    printf(\"%d\", M[k][l]);\n    }\n    putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  bool bComp=true;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j]==1){\n\tbComp=false;\n      }\n    }\n  }\n  if(bComp){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(1+depth>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if( M[i][j] == 0 ){\n\tcontinue;\n      }else if( M[i][j] == 1 ){\n\tint maxOneCount=-1;\n\tint maxSize=-1;\n\tvector< pair<int,int> > vk;\n\tfor(int k = 0; k < 4; ++k){\n\t  int size = 0;\n\t  for(size = 1; size <= minHW; ++size){\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t  --size;\n\t\t  goto next1;\n\t\t}\n\t      }\n\t    }\n\t    if(k==0){\n\t      if(i-size<0||j+size>=W)break;\n\t    }else if(k==1){\n\t      if(i+size>=H||j+size>=W)break;\n\t    }else if(k==2){\n\t      if(i+size>=H||j-size<0)break;\n\t    }else{\n\t      if(i-size<0||j-size<0)break;\n\t    }\n\t  }\n\tnext1:;\n\t  int oneCount=0;\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( M[m][n] == 1 ){\n\t\t++oneCount;\n\t      }\n\t    }\n\t  }\n\t  vk.push_back( make_pair(size,oneCount) );\n\t  maxOneCount = max( maxOneCount, oneCount );\n\t  maxSize = max( maxSize, size );\n\t}\n\tfor(int k = 0; k < 4; ++k){\n\t  if(vk[k].second==maxOneCount){\n\t    int size = vk[k].first;\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif(M[m][n]==1){\n\t\t  M[m][n]=depth;\n\t\t}\n\t      }\n\t    }\n\t    solve(H,W,M,depth+1);\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( M[m][n] == depth ){\n\t\t  M[m][n]=1;\n\t\t}\n\t      }\n\t    }\n\t    if(maxSize==1&&maxOneCount==1)break;\n\t  }\n\t}\n\treturn ;\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[N][N];\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    solve(H,W,M,2);\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n    short table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nshort first_table[10][10],max_size[10][10];\n\n\nbool rangeCheck(int row,int col){\n    if(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n    else{\n        return false;\n    }\n}\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n    if(info.num == ans)return;\n\n    if(base_row == H){\n        ans = info.num;\n        return;\n    }\n\n    if(info.table[base_row][base_col] == -1){\n\n        if(base_col == W-1){\n            recursive(info,base_row+1,0,pre_must_add);\n        }else{\n            recursive(info,base_row,base_col+1,pre_must_add);\n        }\n        return;\n    }\n\n    int new_num = 0;\n    int add = max_size[base_row][base_col]-1;\n    if(info.table[base_row+add][base_col+add] == 0){\n    \tnew_num = 1;\n    }\n\n    if(new_num == 0){\n\n        if(base_col != W-1){\n            recursive(info,base_row,base_col+1,pre_must_add);\n        }else{\n            recursive(info,base_row+1,0,pre_must_add);\n        }\n    }else{\n\n        if(info.table[base_row][base_col] != 0){\n\n            if(base_col != W-1){\n                recursive(info,base_row,base_col+1,pre_must_add);\n            }else{\n                recursive(info,base_row+1,0,pre_must_add);\n            }\n        }\n\n        for(int i = 0; i < max_size[base_row][base_col]; i++){\n            for(int k = 0; k < max_size[base_row][base_col]; k++){\n                info.table[base_row+i][base_col+k]++;\n            }\n        }\n\n        int must_add = 0;\n        bool FLG = false;\n\n        for(int row = base_row; row <= base_row; row++){\n            for(int col = base_col; col < W; col++){\n                if(info.table[row][col] == 0 && first_table[row][col] == 1){\n                    must_add++;\n                }else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n                    FLG = true;\n                }\n            }\n        }\n\n        for(int row = base_row+1; row < H; row++){\n            for(int col = 0; col < W; col++){\n                if(info.table[row][col] == 0 && first_table[row][col] == 1){\n                    must_add++;\n                }else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n                    FLG = true;\n                }\n            }\n        }\n\n\n        if(FLG)must_add++;\n\n        info.num++;\n\n        if(info.num+must_add < ans){\n            if(base_col != W-1){\n                recursive(info,base_row,base_col+1,must_add);\n            }else{\n                recursive(info,base_row+1,0,must_add);\n            }\n        }\n    }\n}\n\n\nvoid func(){\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            scanf(\"%d\",&first_table[row][col]);\n            first_table[row][col] -= 1;\n        }\n    }\n\n    bool FLG;\n    int size;\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            if(first_table[row][col] == -1){\n                max_size[row][col] = 0;\n            }else{\n                size = 1;\n\n                FLG = true;\n\n                while(true){\n                    for(int i = 0; i < size; i++){\n                        for(int k = 0; k < size; k++){\n                            if(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n                                FLG = false;\n                                break;\n                            }\n                        }\n                        if(!FLG)break;\n                    }\n                    if(!FLG){\n                        size -= 1;\n                        break;\n                    }\n                    size++;\n                }\n\n                max_size[row][col] = size;\n\n                for(int calc_size = 1; calc_size <= size; calc_size++){\n                    for(int i = 0; i < calc_size; i++){\n                        for(int k = 0; k < size; k++){\n                            first_table[row+i][col+k]++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    Info start;\n    start.num = 0;\n    int pre_must_add = 0;\n    FLG = false;\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            if(first_table[row][col] == -1){\n                start.table[row][col] = -1;\n            }else{\n                if(first_table[row][col] == 1){\n                    pre_must_add++;\n                }else{\n                    FLG = true;\n                }\n                start.table[row][col] = 0;\n            }\n        }\n    }\n\n    if(FLG)pre_must_add++;\n\n    ans = BIG_NUM;\n\n    recursive(start,0,0,pre_must_add);\n\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n\n    for(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n    while(true){\n        scanf(\"%d %d\",&W,&H);\n        if(W == 0 && H == 0)break;\n\n        func();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nstruct state\n{\n\tvector<vector<int> > v;\n\n\tint dist1;\n\tint dist2;\n\n\tint r;\n\n\tstate(vector<vector<int> > v1, int d1, int d2, int r1) : v(v1), dist1(d1), dist2(d2), r(r1) { }\n};\n\nint W, H;\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 - s1.r * s1.r < s2.dist1 + s2.dist2 - s2.r * s2.r; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 - s1.r * s1.r > s2.dist1 + s2.dist2 - s2.r * s2.r; }\n\nvector<vector<int> > start;\n\nmap<vector<vector<int> >, bool> M;\n\nint getdistance(vector<vector<int> > v)\n{\n\tint ret = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (v[i][j] == 1)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tint reps = min(W, H);\n\n\t\tM.clear();\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tstart = vector<vector<int> >(H, vector<int>(W));\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &start[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<state, vector<state>, greater<state> > que;\n\n\t\tque.push(state(start, 0, getdistance(start), reps)); M[start] = true;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tstate s1 = que.top(); que.pop();\n\n\t\t\tif (s1.dist2 == 0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", s1.dist1); break;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= s1.r; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= H - i; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= W - i; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > v2 = s1.v;\n\n\t\t\t\t\t\tbool flag = false;\n\n\t\t\t\t\t\tfor (int l = j; l < j + i; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = k; m < k + i; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (v2[l][m] == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflag = true; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tv2[l][m] = 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flag) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!M[v2])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tM[v2] = true;\n\n\t\t\t\t\t\t\t\tque.push(state(v2, s1.dist1 + 1, getdistance(v2), i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,n,A[11][11],ans,cnt;\nbitset<100> B[11][11],p;\n\nvoid dfs(int d,bitset<100> s,int sco){\n  if(d==n){\n    ans=min(ans,sco);\n    return;\n  }\n  cnt++;\n  if(cnt>=17000000)return;\n  if(ans<=sco)return;\n  if(!A[d/w][d%w])dfs(d+1,s,sco);\n  else{\n    int y=d/w;\n    int x=d%w;\n    if((B[y][x]&s).any()){\n      p&=0;\n      p.set(y*10+x);//(y*100+x);\n      if(!(s&p).any())dfs(d+1,s,sco);\n      dfs(d+1,(B[y][x]|s)^B[y][x],sco+1);\n    }\n    else dfs(d+1,s,sco);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    memset(A,0,sizeof(A));\n    r(i,11)r(j,11)B[i][j]&=0;\n    n=h*w;\n    bitset<100> b;\n    r(i,h)r(j,w)cin>>A[i][j];\n    r(i,h)r(j,w)if(A[i][j]){\n      int sum=1;\n      for(;;sum++){\n        int f=0;\n        for(int y=i;y<i+sum;y++){\n          for(int x=j;x<j+sum;x++){\n            if(A[y][x]==0)f++;\n          }\n        }\n        if(f){\n          sum--;\n          break;\n        }\n      }\n      bitset<100>tmp;\n      for(int y=i,k=0;k<sum;k++,y++){\n        for(int x=j,l=0;l<sum;l++,x++){\n          tmp.set(y*10+x);\n        }\n      }\n      b.set(i*10+j);\n      B[i][j]=tmp;\n    }\n    ans=100;\n    cnt=0;\n    dfs(0,b,0);\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nconst int N = 11;\nconst int inf = 1<<27;\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\n\nusing namespace std;\n\nint H,W;\nstatic int M[N][N];\nstatic int maxSizes[N][N][4];\nint oneCount;\nint minHW;\nint ans;\nint greedy_ans;\nint depth;\nmultimap<int,int,greater<int> > maxS;\n\ninline int getHeuristic();\nvoid calc();\nvoid solve(int pos);\n\ninline int getHeuristic()\n{\n  int msz=1;\n  if(!maxS.empty())msz = maxS.begin()->first;\n  msz *= msz;\n  return oneCount/msz + (oneCount%msz>0);\n}\n\nstruct Cand{\n  int i,j;\n  Cand():i(0),j(0){}\n  Cand(int ci, int cj):i(ci),j(cj){}\n  bool operator<(const Cand& t)const{\n    return (i==t.i)?(j<t.j):(i<t.i);\n  }\n};\n\nint cand_num;\nCand cands[N*N];\n\nvoid calc(){\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 1){\n\toneCount++;\n\tcands[cand_num++] = Cand(i,j);\n      }\n      for(int k = 0; k < 4; ++k){\n\tint size = 0;\n\tfor(size = 1; size <= minHW; ++size){\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t--size;\n\t\tgoto next;\n\t      }\n\t    }\n\t  }\n\t  if(k==0){\n\t    if(i-size<0||j+size>=W)break;\n\t  }else if(k==1){\n\t    if(i+size>=H||j+size>=W)break;\n\t  }else if(k==2){\n\t    if(i+size>=H||j-size<0)break;\n\t  }else{\n\t    if(i-size<0||j-size<0)break;\n\t  }\n\t}\n      next:;\n\tmaxSizes[i][j][k] = size;\n\tif(k==1){\n\t  if(size>1){\n\t    maxS.insert( make_pair(size,0) );\n\t  }\n\t}\n      }\n    }\n  }\n  sort(cands,cands+cand_num);\n  return ;\n}\n\nvoid solve_greedy()\n{\n  // completed.\n  if(oneCount==0){\n    greedy_ans = min(greedy_ans, depth);\n    return ;\n  }\n\n  // embed carpet greedy\n  int maxOneCount = -1;\n  int maxp,maxk,maxsz;\n  for(int p = 0; p < cand_num; ++p){\n    int i = cands[p].i;\n    int j = cands[p].j;\n    if( M[i][j] == 1 ){\n      for(int k = 0; k < 4; ++k){\n\tint cnt = 0;\n\tint size = maxSizes[i][j][k];\n\tfor(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t  for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t    if(M[m][n]==1){\n\t      ++cnt;\n\t    }\n\t  }\n\t}\n\tif(maxOneCount<cnt){\n\t  maxp = p;\n\t  maxk = k;\n\t  maxsz = size;\n\t  maxOneCount = cnt;\n\t}\n      }\n    }\n  }\n  int i = cands[maxp].i;\n  int j = cands[maxp].j;\n  int k = maxk;\n  int size = maxsz;\n  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n      if(M[m][n]==1){\n\tM[m][n]=depth;\n\t--oneCount;\n      }\n    }\n  }\n  ++depth;\n  solve_greedy();\n  --depth;\n  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n      if( M[m][n] == depth ){\n\tM[m][n]=1;\n\t++oneCount;\n      }\n    }\n  }\n  return ;\n}\n\nvoid solve(int pos){\n  /*\n    printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W, getHeuristic());\n    for(int k = 0; k < H; ++k){\n      for(int l = 0; l < W; ++l){\n\tif(l>0)putchar(' ');\n\tprintf(\"%2d\", M[k][l]);\n      }\n      putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  if(oneCount==0){\n    ans = min(ans, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic()>=ans){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < cand_num; ++p){\n    int i = cands[p].i;\n    int j = cands[p].j;\n    int size = maxSizes[i][j][1];\n    int valid=0;\n    for(int m = i; m<size+i; m++){\n      for(int n = j; n<size+j; n++){\n\tif(M[m][n]==1){\n\t  valid=1;\n\t  --oneCount;\n\t  M[m][n]=depth;\n\t}\n      }\n    }\n    if( valid ){\n      ++depth;\n      if(size>1)\n\t;//maxS.erase( maxS.find(size) );\n      solve(p+1);\n      if(size>1)\n\t;//maxS.insert( make_pair(size,0) );\n      --depth;\n    }\n    for(int m = i; m<size+i; m++){\n      for(int n = j; n<size+j; n++){\n\tif( M[m][n] == depth ){\n\t  ++oneCount;\n\t  M[m][n]=1;\n\t}\n      }\n    }\n    if( M[i][j] > 1 )\n      solve(p+1);\n    return ;\n  }\n}\n\nint main()\n{\n  while(true){\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    minHW = min(H,W);\n    oneCount = 0;\n    cand_num = 0;\n    ans=inf;\n    greedy_ans = inf;\n    depth=2;\n    maxS.clear();\n\n    calc();\n\n    solve_greedy();\n    ans = greedy_ans;\n    solve(0);\n\n    printf(\"%d\\n\", ans-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 11\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nstruct dat{\n  int x,y,X,Y;\n  bool contain(dat b){return (x<=b.x && b.X<=X) && (y<=b.y && b.Y<=Y);}\n};\n\nint h,w;\nvector<dat> A;\ntypedef vector<vector<int> > V;\nvector<vector<int> > mp;\n\nbool contain0(int x,int y,int X,int Y){\n  for(int i=y;i<=Y;i++)\n    for(int j=x;j<=X;j++) if(mp[i][j] == 0) return 1;\n  return 0;\n}\n\nbool compare(const dat &a,const dat &b){\n  int cntA = 0,cntB = 0;\n  for(int i=a.y;i<=a.Y;i++) cntA += count(mp[i].begin()+a.x,mp[i].begin()+a.X+1,1);\n  for(int i=b.y;i<=b.Y;i++) cntB += count(mp[i].begin()+b.x,mp[i].begin()+b.X+1,1);\n  return cntA!=cntB? cntA>cntB:(a.x!=b.x? a.x<b.x:a.y<b.y);\n}\n\nbool equal(const dat &a,const dat &b){return !compare(a,b)&&!compare(b,a);}\n\nstruct dat2{\n  V mp;\n  int cnt,cost;\n};\n\ndat2 getNx(V mp,int cnt,int cost,dat a){\n  for(int i=a.y;i<=a.Y;i++)\n    for(int j=a.x;j<=a.X;j++){\n      cnt -= mp[i][j];\n      mp[i][j] = 0;\n    }\n  return (dat2){mp,cnt,cost+1};\n}\n\nint bfs(V start){\n  int cnt = 0;\n  for(vector<int> &v:start) cnt += count(v.begin(),v.end(),1);\n\n  set<V> used;\n  queue<dat2> Q;\n  Q.push((dat2){start,cnt,0});\n  used.insert(start);\n  \n  while(!Q.empty()){\n    dat2 t = Q.front();Q.pop();\n    if(t.cnt == 0) return t.cost;\n    mp = t.mp;\n    sort(A.begin(),A.end(),compare);\n    dat2 nt = getNx(t.mp,t.cnt,t.cost,A[0]);\n      \n    if(used.count(nt.mp)) continue;\n    used.insert(nt.mp);\n    Q.push(nt);\n\n  }\n  assert(!\"error\");\n}\n\nsigned main(){\n  while(1){\n    cin>>w>>h;\n    if(w == 0 && h == 0)break;\n\n    mp = V(h,vector<int>(w));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>mp[i][j];\n    \n    A.clear();\n    for(int y=0;y<h;y++)\n      for(int x=0;x<w;x++){\n        dat a = (dat){-1,-1,-1,-1};\n        for(int Y=y, X=x; Y<h && X<w ;Y++, X++) if(!contain0(x,y,X,Y)) a = (dat){x,y,X,Y};\n        if(a.x != -1) A.push_back(a);\n      }\n\n    for(int i=0;i<(int)A.size();i++)\n      for(int j=0;j<(int)A.size();j++) if(i!=j && A[i].contain(A[j]))A.erase(A.begin()+j--);\n    cout<<bfs(mp)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ninline bool chmax(int &a, const int &b) { return (a<b)?(a=b,1):0;}\ninline bool chmin(int &a, const int &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nstruct state\n{\n\tvector<vector<int> > v;\n\n\tint dist1;\n\tint dist2;\n\n\tstate(vector<vector<int> > v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nint W, H;\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 < s2.dist1 + s2.dist2; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 > s2.dist1 + s2.dist2; }\n\nvector<vector<int> > start;\n\nmap<vector<vector<int> >, bool> M;\n\nint getdistance(vector<vector<int> > v)\n{\n\tint ret = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (v[i][j] == 1)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tM.clear();\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tstart = vector<vector<int> >(H, vector<int>(W));\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &start[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<state, vector<state>, greater<state> > que;\n\n\t\tque.push(state(start, 0, getdistance(start))); M[start] = true;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tstate s1 = que.top(); que.pop();\n\n\t\t\tif (s1.dist2 == 0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", s1.dist1); break;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= 10; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= H - i; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= W - i; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > v2 = s1.v;\n\n\t\t\t\t\t\tbool flag = false;\n\n\t\t\t\t\t\tfor (int l = j; l < j + i; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = k; m < k + i; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (v2[l][m] == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflag = true; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tv2[l][m] = 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flag) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!M[v2])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tM[v2] = true;\n\n\t\t\t\t\t\t\t\tque.push(state(v2, s1.dist1 + 1, getdistance(v2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<queue>\nusing namespace std;\nstruct State { int x[10][10]; };\nint W, H; map<State, int>M;\nbool operator<(State S1, State S2) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (S1.x[i][j] < S2.x[i][j])return true;\n\t\t\tif (S1.x[i][j] > S2.x[i][j])return false;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\twhile (true) {\n\t\tqueue<pair<State, int>>Q;\n\t\tState U; cin >> W >> H; if (H == 0 && W == 0)break;\n\t\tfor (int i = 0; i < H; i++) { for (int j = 0; j < W; j++)cin >> U.x[i][j]; }\n\t\tQ.push(make_pair(U, 0)); M[U] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\tState V = Q.front().first; int a1 = Q.front().second; Q.pop();\n\t\t\tbool OK = true;\n\t\t\tfor (int i = 0; i < H; i++) { for (int j = 0; j < W; j++) { if (V.x[i][j] == 1)OK = false; } }\n\t\t\tif (OK == true) {\n\t\t\t\tcout << a1 << endl; break;\n\t\t\t}\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (V.x[i][j] != 1)continue;\n\t\t\t\t\tint p[10]; for (int k = 0; k < 10; k++)p[k] = 0;\n\t\t\t\t\tfor (int k = i; k < H; k++) {\n\t\t\t\t\t\tfor (int l = j; l < W; l++) {\n\t\t\t\t\t\t\tif (V.x[k][l] == 0)p[max(k - i, l - j)]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\t\tif (p[k] == 1 || (i + k) == (H + 1) || (j + k) == (W + 1)) {\n\t\t\t\t\t\t\tint o = k - 1;\n\t\t\t\t\t\t\tState W = V;\n\t\t\t\t\t\t\tfor (int l = i; l < i + o; l++) {\n\t\t\t\t\t\t\t\tfor (int m = j; m < j + o; m++)W.x[l][m] = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (M[W] >= 1)continue; M[W] = a1 + 1;\n\t\t\t\t\t\t\tQ.push(make_pair(W, a1 + 1));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\t//ans = min(ans,info.num);\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,n,A[11][11],ans,cnt;\nbitset<100> B[11][11],p;\n\nvoid dfs(int d,bitset<100> s,int sco){\n  if(d==n){\n    ans=min(ans,sco);\n    return;\n  }\n  cnt++;\n  if(cnt>=9000000)return;\n  if(ans<=sco)return;\n  if(!A[d/w][d%w])dfs(d+1,s,sco);\n  else{\n    int y=d/w;\n    int x=d%w;\n    if((B[y][x]&s).any()){\n      p&=0;\n      p.set(y*10+x);//(y*100+x);\n      if(!(s&p).any())dfs(d+1,s,sco);\n      dfs(d+1,(B[y][x]|s)^B[y][x],sco+1);\n    }\n    else dfs(d+1,s,sco);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    memset(A,0,sizeof(A));\n    r(i,11)r(j,11)B[i][j]&=0;\n    n=h*w;\n    bitset<100> b;\n    r(i,h)r(j,w)cin>>A[i][j];\n    r(i,h)r(j,w)if(A[i][j]){\n      int sum=1;\n      for(;;sum++){\n        int f=0;\n        for(int y=i;y<i+sum;y++){\n          for(int x=j;x<j+sum;x++){\n            if(A[y][x]==0)f++;\n          }\n        }\n        if(f){\n          sum--;\n          break;\n        }\n      }\n      bitset<100>tmp;\n      for(int y=i,k=0;k<sum;k++,y++){\n        for(int x=j,l=0;l<sum;l++,x++){\n          tmp.set(y*10+x);\n        }\n      }\n      b.set(i*10+j);\n      B[i][j]=tmp;\n    }\n    ans=100;\n    cnt=0;\n    dfs(0,b,0);\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntemplate<class T> T gcd( T a, T b ) {\n\treturn !b ? a : gcd( b, a % b );\n}\ntemplate<class T> T lcm( T a, T b ) {\n\treturn a / gcd( a, b ) * b;\n}\ntemplate<class T> string print_v( vector<T> v ) {\n\tOSS oss;\n\tfor ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end();\n          ++it_i ) {\n\t\toss << *it_i << \", \";\n\t}\n\treturn oss.str();\n}\n\nconst int ks = 1;\nconst int kr[ks] = { -1 };\nconst int kc[ks] = { -1 };\nint w, h;\n\nvoid print( VVI T ) {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j] << \",\";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nVVI flip( VVI T, int r, int c ) {\n    VVI NT = T;\n    int cand = 0;\n    int cl = 0;\n    int ck;\n    for ( int L = min( w, h ); L > 0; -- L ) {\n        for ( int k = 0; k < ks; ++ k ) {\n            int cnt = 0;\n            for ( int i = 0; i < L; ++ i ) {\n                for ( int j = 0; j < L; ++ j ) {\n                    int nr = r + i * kr[k];\n                    int nc = c + j * kc[k];\n                    if ( nr < 0 || nr >= h ) goto IGNORE;\n                    if ( nc < 0 || nc >= w ) goto IGNORE;\n                    if ( T[nr][nc] == 0 ) goto IGNORE;\n                    if ( T[nr][nc] == 1 ) cnt ++;\n                }\n            }\n            if ( cnt > cand ) {\n                cand = cnt;\n                ck = k;\n                cl = L;\n            }\n        IGNORE:;\n        }\n    }\n    for ( int i = 0; i < cl; ++ i ) {\n        for ( int j = 0; j < cl; ++ j ) {\n            int nr = r + i * kr[ck];\n            int nc = c + j * kc[ck];\n            NT[nr][nc] = 2;\n        }\n    }\n    return NT;\n}\n\nint main() {\n    while ( cin >> w >> h && w ) {\n        VVI T( h, VI( w ) );\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                cin >> T[i][j];\n            }\n        }\n        int res = 0;\n        for ( int i = h - 1; i >= 0; -- i ) {\n            for ( int j = w - 1; j >= 0; -- j ) {\n                if ( T[i][j] != 1 ) continue;\n                T = flip( T, i, j );\n                // cout << i << \", \" << j << \": \" << ret.first << endl;\n                res ++;\n                // cout << \"before: \" << endl;\n                // print( T );\n                // cout << \"after: \" << endl;\n                // print( ret.second );\n                // cout << endl;\n            }\n        }\n        cout << res << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,n,A[11][11],ans,cnt;\nbitset<100> B[11][11],p;\n\nvoid dfs(int d,bitset<100> s,int sco){\n  if(d==n){\n    ans=min(ans,sco);\n    return;\n  }\n  cnt++;\n  if(cnt>=1000000)return;\n  if(ans<=sco)return;\n  if(!A[d/w][d%w])dfs(d+1,s,sco);\n  else{\n    int y=d/w;\n    int x=d%w;\n    if((B[y][x]&s).any()){\n      p&=0;\n      p.set(y*10+x);//(y*100+x);\n      if(!(s&p).any())dfs(d+1,s,sco);\n      dfs(d+1,(B[y][x]|s)^B[y][x],sco+1);\n    }\n    else dfs(d+1,s,sco);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    memset(A,0,sizeof(A));\n    r(i,11)r(j,11)B[i][j]&=0;\n    n=h*w;\n    bitset<100> b;\n    r(i,h)r(j,w)cin>>A[i][j];\n    r(i,h)r(j,w)if(A[i][j]){\n      int sum=1;\n      for(;;sum++){\n        int f=0;\n        for(int y=i;y<i+sum;y++){\n          for(int x=j;x<j+sum;x++){\n            if(A[y][x]==0)f++;\n          }\n        }\n        if(f){\n          sum--;\n          break;\n        }\n      }\n      bitset<100>tmp;\n      for(int y=i,k=0;k<sum;k++,y++){\n        for(int x=j,l=0;l<sum;l++,x++){\n          tmp.set(y*10+x);\n        }\n      }\n      b.set(i*10+j);\n      B[i][j]=tmp;\n    }\n    ans=100;\n    cnt=0;\n    dfs(0,b,0);\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans;\nint first_table[10][10],max_size[10][10];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10]){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tint must_add = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\tmust_add++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(info.num+must_add >= ans)return;\n\n\tif(base_row == H){\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){\n\n\t\tcopyTable(next_info,info.table);\n\t\tnext_info.num = info.num;\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(new_num == 0){\n\n\t\tcopyTable(next_info,info.table);\n\t\tnext_info.num = info.num;\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t}else{\n\n\t\tcopyTable(next_info,info.table);\n\t\tnext_info.num = info.num+1;\n\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\n\t\tif(info.table[base_row][base_col] != 0){\n\t\t\tInfo next_not;\n\n\t\t\tcopyTable(next_not,info.table);\n\t\t\tnext_not.num = info.num;\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcount(n))\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx];\n\t\t\trep(a,cy,cy+l)rep(b,cx,cx+l) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,n,A[11][11],ans,cnt;\nbitset<100> B[11][11];\n\nvoid dfs(int d,bitset<100> s,int sco){\n  if(d==n){\n    ans=min(ans,sco);\n    return;\n  }\n  cnt++;\n  if(cnt>=30000000)return;\n  if(ans<=sco)return;\n  if(!A[d/w][d%w])dfs(d+1,s,sco);\n  else{\n    int y=d/w;\n    int x=d%w;\n    if((B[y][x]&s).any()){\n      bitset<100>p;\n      p.set(y*10+x);//(y*100+x);\n      if(!(s&p).any())dfs(d+1,s,sco);\n      dfs(d+1,(B[y][x]|s)^B[y][x],sco+1);\n    }\n    else dfs(d+1,s,sco);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    memset(A,0,sizeof(A));\n    r(i,11)r(j,11)B[i][j]&=0;\n    n=h*w;\n    bitset<100> b;\n    r(i,h)r(j,w)cin>>A[i][j];\n    r(i,h)r(j,w)if(A[i][j]){\n      int sum=1;\n      for(;;sum++){\n        int f=0;\n        for(int y=i;y<i+sum;y++){\n          for(int x=j;x<j+sum;x++){\n            if(A[y][x]==0)f++;\n          }\n        }\n        if(f){\n          sum--;\n          break;\n        }\n      }\n      bitset<100>tmp;\n      for(int y=i,k=0;k<sum;k++,y++){\n        for(int x=j,l=0;l<sum;l++,x++){\n          tmp.set(y*10+x);\n        }\n      }\n      b.set(i*10+j);\n      B[i][j]=tmp;\n    }\n    ans=100;\n    cnt=0;\n    dfs(0,b,0);\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define N 11\n#define INF (1<<27)\n\nusing namespace std;\n\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\nint bestAns = INF;\nint minHW;\n\nint getHeuristic(int H, int W, int M[N][N])\n{\n  //  return 0;\n  int maxSize = 1;\n  int size[N][N] = {{0,},};\n  int oneCount = 0;\n\n  for(int i = H-1; i >= 0; --i){\n    if( M[i][W-1] >= 1 ){\n      size[i][W-1] = 1;\n      if( M[i][W-1] == 1 )\n\t++oneCount;\n    }\n  }\n\n  for(int j = W-1; j >= 0; --j){\n    if( M[H-1][j] >= 1 ){\n      size[H-1][j] = 1;\n      if( M[H-1][j] == 1 )\n\t++oneCount;\n    }\n  }\n\n  if( M[H-1][W-1] == 1 ) --oneCount;\n\n  for(int i = H-2; i >= 0; --i){\n    for(int j = W-2; j >= 0; --j){\n      if( M[i][j] >= 1 ){\n\tsize[i][j] = 1+min( size[i+1][j], min( size[i+1][j+1], size[i][j+1] ) );\n\tmaxSize = max( maxSize, size[i][j] );\n\tif(M[i][j] == 1){\n\t  ++oneCount;\n\t}\n      }\n    }\n  }\n  \n  //if(maxSize>1){\n  //printf(\"MaxSize = %d\\n\", maxSize);\n  //}\n  \n  return oneCount / (maxSize*maxSize);\n}\n\nvoid solve(int H, int W, int pos, int M[N][N], int depth){\n \n  /*\n  printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W,getHeuristic(H,W,M));\n  for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n      if(l>0)putchar(' ');\n      printf(\"%d\", M[k][l]);\n    }\n    putchar('\\n');\n  }\n  putchar('\\n');\n  */\n\n  // completed.\n  bool bComp=true;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j]==1){\n\tbComp=false;\n\tgoto end;\n      }\n    }\n  }\n end:;\n  if(bComp){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic(H,W,M)>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < H*W; ++p){\n    int i = p / W;\n    int j = p % W;\n    if( M[i][j] == 0 ){\n      continue;\n    }else if( M[i][j] == 1 ){\n      int maxSize=-1;\n      int maxOneCount = -1;\n      pair<int,int> vk[4];\n      for(int k = 0; k < 4; ++k){\n\tint size = 0;\n\tfor(size = 1; size <= minHW; ++size){\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t--size;\n\t\tgoto next;\n\t      }\n\t    }\n\t  }\n\t  if(k==0){\n\t    if(i-size<0||j+size>=W)break;\n\t  }else if(k==1){\n\t    if(i+size>=H||j+size>=W)break;\n\t  }else if(k==2){\n\t    if(i+size>=H||j-size<0)break;\n\t  }else{\n\t    if(i-size<0||j-size<0)break;\n\t  }\n\t}\n      next:;\n\tint oneCount = 0;\n\tfor(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t  for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t    if(M[m][n]==1){\n\t      ++oneCount;\n\t    }\n\t  }\n\t}\n\tvk[k]=make_pair(size, oneCount);\n\tmaxSize = max( maxSize, size );\n\tmaxOneCount = max( maxOneCount, oneCount );\n      }\n      for(int k = 0; k < 4; ++k){\n\tif(maxSize==vk[k].first && maxOneCount == vk[k].second){\n\t  int size = vk[k].first;\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if(M[m][n]==1){\n\t\tM[m][n]=depth;\n\t      }\n\t    }\n\t  }\n\t  solve(H,W,p+1,M,depth+1);\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( M[m][n] == depth ){\n\t\tM[m][n]=1;\n\t      }\n\t    }\n\t  }\n\t  if(maxSize==1)break;\n\t}\n      }\n      solve(H,W,p+1,M,depth+1);\n      return ;\n    }   \n  }\n}\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[N][N];\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    solve(H,W,0,M,2);\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 10;\nint w, h;\nint of[N][N];\nvi field;\n\nint p2w[N][N];\nint res;\n\ninline bool calcnp(int & y, int & x){\n    do {\n        if(p2w[y][x] == 0 and (field[y] & (1 << x))) return false;\n\n        y = y + (x == w - 1 ? 1 : 0);\n        x = (x == w - 1 ? 0 : x + 1);\n    } while(p2w[y][x] == 0);\n\n    return true;\n}\n\nvoid dfs(int cy, int cx, int cost){\n    if(cost > res) return;\n\n    if((field[cy] & (1 << cx)) == 0){\n        int ny = cy, nx = cx;\n        if(calcnp(ny, nx)){\n            dfs(ny, nx, cost);\n        }\n    }\n\n    int ww = p2w[cy][cx];\n\n    int mask = 0;\n    rep(loop, ww){\n        mask <<= 1;\n        mask  |= (1 << cx);\n    }\n\n    bool correct = false;\n    rep(y, cy, cy + ww){\n        if(not correct and (field[y] & mask) != 0){\n            correct = true;\n        }\n        field[y] &= ~mask;\n    }\n\n    if(not correct) return;\n\n    bool end = true;\n    rep(y, h){\n        if(field[y] != 0){\n            end = false;\n        }\n    }\n    if(end){\n        chmin(res, cost);\n    }\n    else {\n        int ny = cy, nx = cx;\n        if(calcnp(ny, nx)){\n            dfs(ny, nx, cost + 1);\n        }\n    }\n\n    rep(y, cy, cy + ww){\n        field[y] |= mask;\n    }\n}\n\ninline int calc(int sy, int sx, int ww){\n    int ret = 0;\n\n    rep(y, sy, h){\n        rep(x, sx, sx + ww){\n            if(of[y][x] == 0){\n                return ret;\n            }\n        }\n        ret++;\n    }\n\n    return ret;\n}\n\nint main(void){\n    for(; cin >> w >> h, w;){\n        rep(y, h){\n            rep(x, w){\n                p2w[y][x] = 0;\n            }\n        }\n\n        int sy = -1, sx;\n        rep(y, h){\n            rep(x, w){\n                cin >> of[y][x];\n\n                if(sy == -1 and of[y][x] == 1){\n                    sy = y;\n                    sx = x;\n                }\n            }\n        }\n\n        rep(y, h){\n            rep(x, w){\n                if(of[y][x] == 0) continue;\n\n                rep(ww, 1, w - x + 1){\n                    int hh = min(ww, calc(y, x, ww));\n\n                    if(hh == ww){\n                        p2w[y][x] = ww;\n                    }\n                }\n            }\n        }\n\n        rrep(y, h - 1){\n            rrep(x, w - 1){\n                if(p2w[y][x] > p2w[y + 1][x]) p2w[y + 1][x] = 0;\n                if(p2w[y][x] > p2w[y][x + 1]) p2w[y][x + 1] = 0;\n                if(p2w[y][x] > p2w[y + 1][x + 1]) p2w[y + 1][x + 1] = 0;\n            }\n        }\n\n        int fst = 0;\n        //rep(y, h){\n        //    rep(x, w){\n        //        if(p2w[y][x] == 1){\n        //            of[y][x] = 0;\n        //            fst++;\n        //        }\n        //    }\n        //}\n\n        field = vi(h);\n        rep(y, h){\n            int & cur = field[y] = 0;\n            rep(x, w){\n                if(of[y][x]){\n                    cur |= (1 << x);\n                }\n            }\n        }\n\n//        rep(y, h){\n//            rep(x, w){\n//                cout << \"y = \" << y << \", x = \" << x << \": \" << p2w[y][x] << endl;\n//            }\n//        }\n\n        if(sy == -1){\n            res = 0;\n        }\n        else {\n            res = 1000;\n            dfs(sy, sx, fst + 1);\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define N 11\n#define INF (1<<29)\n\nusing namespace std;\n\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\nint bestAns = INF;\nint minHW;\n\nvoid solve(int H, int W, int M[N][N], int depth){\n  /*\n    for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n    if(l>0)putchar(' ');\n    printf(\"%d\", M[k][l]);\n    }\n    putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  bool bComp=true;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j]==1){\n\tbComp=false;\n      }\n    }\n  }\n  if(bComp){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(1+depth>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if( M[i][j] == 0 ){\n\tcontinue;\n      }else if( M[i][j] == 1 ){\n\tint maxOneCount=-1;\n\tvector< pair<int,int> > vk;\n\tfor(int k = 0; k < 4; ++k){\n\t  int size = 0;\n\t  for(size = 1; size <= minHW; ++size){\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t  --size;\n\t\t  goto next1;\n\t\t}\n\t      }\n\t    }\n\t    if(k==0){\n\t      if(i-size<0||j+size>=W)break;\n\t    }else if(k==1){\n\t      if(i+size>=H||j+size>=W)break;\n\t    }else if(k==2){\n\t      if(i+size>=H||j-size<0)break;\n\t    }else{\n\t      if(i-size<0||j-size<0)break;\n\t    }\n\t  }\n\tnext1:;\n\t  int oneCount=0;\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( M[m][n] == 1 ){\n\t\t++oneCount;\n\t      }\n\t    }\n\t  }\n\t  vk.push_back( make_pair(size,oneCount) );\n\t  maxOneCount = max( maxOneCount, oneCount );\n\t}\n\tfor(int k = 0; k < 4; ++k){\n\t  if(vk[k].second==maxOneCount){\n\t    int size = vk[k].first;\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif(M[m][n]==1){\n\t\t  M[m][n]=depth;\n\t\t}\n\t      }\n\t    }\n\t    solve(H,W,M,depth+1);\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( M[m][n] == depth ){\n\t\t  M[m][n]=1;\n\t\t}\n\t      }\n\t    }\n\t    if(size==1)break;\n\t  }\n\t}\n\treturn ;\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[N][N];\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    solve(H,W,M,2);\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint H, W;\nbitset<100> field;\nbitset<100> zeros;\nint carpet[15][15];\nint baseans;\nint ans;\nvector<bitset<100>> bits;\n\nvoid print(bitset<100> a) {\n    for(int h = 0; h < H; h++) {\n        for(int w = 0; w < W; w++) {\n            cerr << a[h*10+w];\n        }\n        cerr << endl;\n    }\n}\n\nvoid dfs(int index, int nowans, bitset<100> nowfield) {\n    if(index == bits.size()) {\n        if(nowfield == (~zeros)) {\n            ans = min(ans, nowans);\n        }\n        return;\n    }\n    dfs(index + 1, nowans, nowfield);\n    dfs(index + 1, nowans + 1, nowfield |= bits[index]);\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        bits.clear();\n        baseans = 0;\n        ans = INF;\n        cin >> W >> H;\n        if(H == 0) break;\n        for(int h = 0; h < H; h++) {\n            for(int w = 0; w < W; w++) {\n                cin >> carpet[h][w];\n            }\n        }\n        field &= zeros;\n        /*\n        for(int h = H; h < 10; h++) {\n            for(int w = W; w < 10; w++) {\n                field[h * 10 + w] = true;\n            }\n        }*/\n        for(int h = 0; h < 10; h++) {\n            for(int w = 0; w < 10; w++) {\n                if(h >= H || w >= W) {\n                    field[h * 10 + w] = true;\n                    continue;\n                }\n                if(carpet[h][w] == 0) field[h * 10 + w] = true;\n            }\n        }\n        for(int h = 0; h < H; h++) {\n            for(int w = 0; w < W; w++) {\n                if(carpet[h][w] == 0) continue;\n                int SIZE = 1;\n                while(true) {\n                    //cerr << h << \" \" << w << \" \" << SIZE << endl;\n                    if(h + SIZE == H) break;\n                    if(w + SIZE == W) break;\n                    bool ok = true;\n                    for(int noww = w; noww <= w + SIZE; noww++) {\n                        if(carpet[h+SIZE][noww] == 0) ok = false;\n                    }\n                    for(int nowh = h; nowh <= h + SIZE; nowh++) {\n                        if(carpet[nowh][w+SIZE] == 0) ok = false;\n                    }\n                    if(!ok) break;\n                    SIZE++;\n                }\n                bitset<100> now;\n                for(int nowh = h; nowh < h + SIZE; nowh++) {\n                    for(int noww = w; noww < w + SIZE; noww++) {\n                        now[nowh * 10 + noww] = true;\n                    }\n                }\n                bits.push_back(now);\n            }\n        }\n        for(int timer = 0; timer <= 10; timer++) {\n        for(int i = 0; i < bits.size(); i++) {\n            //cerr << i << endl;\n            for(int j = 0; j < bits.size(); j++) {\n                if(i == j) continue;\n                if((bits[i] & bits[j]) == bits[i]) {\n                    //cerr << i << \" \" << bits[i] << endl;\n                    //cerr << j << \" \" << bits[j] << endl;\n                    bits.erase(bits.begin() + i);\n                    i--;\n                    break;\n                }\n            }\n        }\n        for(int i = 0; i < bits.size(); i++) {\n            //cerr << endl << i << endl;\n            //print(bits[i]);\n        }\n        for(int i = 0; i < bits.size(); i++) {\n            //cerr << \"others \" << i << endl;\n            bitset<100> others;\n            for(int j = 0; j < bits.size(); j++) {\n                if(i == j) continue;\n                others |= bits[j];\n            }\n            if((bits[i] | others) != others) {\n                field |= bits[i];\n                for(int k = 0; k < bits.size(); k++) {\n                    if(i == k) continue;\n                    bits[k] &= (~bits[i]);\n                }\n                baseans++;\n                bits.erase(bits.begin() + i);\n                i--;\n                continue;\n            }\n        }\n        }\n        /*\n        cerr << baseans << endl;\n        for(int i = 0; i < bits.size(); i++) cerr << bits[i] << endl;\n        */\n        for(int i = 0; i < bits.size(); i++) {\n            if(bits[i] == zeros) {\n                bits.erase(bits.begin() + i);\n                i--;\n            }\n        }\n        //cerr << baseans << endl;\n        //cerr << bits.size() << endl;\n        //print(field);\n        //cerr << field << endl;\n        dfs(0, 0, field);\n        cout << ans + baseans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tshort table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nshort first_table[10][10],max_size[10][10];\n\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(Info info,short base_row,short base_col,short pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\tshort new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num = 1;\n\t\t\t\tgoto SHISHIMARU;\n\t\t\t}\n\t\t}\n\t}\n\nSHISHIMARU:\n\tif(new_num == 0){\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tshort must_add = 0;\n\t\tbool FLG = false;\n\n\t\tfor(int row = base_row; row <= base_row; row++){\n\t\t\tfor(int col = base_col; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = base_row+1; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tshort pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long lli;\n\nconst int MAXH = 11;\nconst int MAXW = 11;\nint W, H, N;\nint P[MAXH][MAXW];\nint dp[MAXH][MAXW];\nint T[MAXH][MAXW];\nint ans;\n\nvoid rec(int i, int j, int c) {\n  if(j == W+1) {\n    rec(i+1, 0, c);\n    return;\n  }\n\n  if(c >= ans) return;\n  if(N == 0) {\n    ans = c;\n    return;\n  }\n\n  if(i == H+1) {\n    return;\n  }\n\n  if(T[i][j]) {\n    for(int a = 0; a < T[i][j]; ++a) {\n      for(int b = 0; b < T[i][j]; ++b) {\n        P[i+a][j+b] -= 1;\n        if(P[i+a][j+b] == 0) --N;\n      }\n    }\n    rec(i, j+1, c+1);\n    for(int a = 0; a < T[i][j]; ++a) {\n      for(int b = 0; b < T[i][j]; ++b) {\n        if(P[i+a][j+b] == 0) ++N;\n        P[i+a][j+b] += 1;\n      }\n    }\n  }\n  if(P[i][j] <= 0) {\n    rec(i, j+1, c);\n  }\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    N = 0;\n    for(int i = 1; i <= H; ++i) {\n      for(int j = 1; j <= W; ++j) {\n        cin >> P[i][j];\n        N += P[i][j];\n      }\n    }\n    fill(dp[0], dp[MAXH], 0);\n    fill(T[0], T[MAXH], 0);\n    for(int i = 1; i <= H; ++i) {\n      for(int j = 1; j <= W; ++j) {\n        if(P[i][j]) {\n          dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1;\n        } else {\n          dp[i][j] = 0;\n        }\n        int ni = i-dp[i][j]+1;\n        int nj = j-dp[i][j]+1;\n        T[ni][nj] = max(T[ni][nj], dp[i][j]);\n      }\n    }\n    for(int i = H; i >= 1; --i) {\n      for(int j = W; j >= 1; --j) {\n        if(max(max(T[i-1][j], T[i][j-1]), T[i-1][j-1]) == T[i][j]+1) {\n          T[i][j] = 0;\n        }\n      }\n    }\n\n    ans = H*W;\n    rec(1, 1, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nint W, H;\nint grid[10][10];\nint len[10][10];\nvector<int> xs, ys;\nint ub;\nbool used[10][10];\nbool found;\nconst int INF = 1000000000;\nint dfs(int k, int use, int fill){\n    if(found) return INF;\n    vector<int> l;\n    for(int i = k; i < xs.size(); i++){\n        l.push_back(len[ys[i]][xs[i]] * len[ys[i]][xs[i]]);\n    }\n    sort(l.begin(), l.end(), greater<int>());\n    int hstar = 0;\n    for(int i = 0, s = fill; s > 0 && i <= l.size(); i++){\n        if(i == l.size()) return INF;\n        hstar++;\n        s -= l[i];\n    }\n    if(use + hstar > ub) return INF;\n    if(fill == 0){\n        found = true;\n        return ub;\n    }\n    if(k == xs.size()) return INF;\n    int res = INF;\n    int x = xs[k];\n    int y = ys[k];\n    if(used[y][x]){\n        res = min(res, dfs(k + 1, use, fill));\n    }\n    bool used_d[10][10];\n    memcpy(used_d, used, sizeof(used));\n    int nfill = fill;\n    REP(dy, len[y][x]) REP(dx, len[y][x]){\n        if(!used[y + dy][x + dx] && grid[y + dy][x + dx]){\n            used[y + dy][x + dx] = true;\n            nfill--;\n        }\n    }\n    if(nfill < fill){\n        res = min(res, dfs(k + 1, use + 1, nfill));\n    }\n    memcpy(used, used_d, sizeof(used));\n    return res;\n}\n\nint main(){\n    while(cin >> W >> H && W){\n        REP(y, H) REP(x, W) cin >> grid[y][x];\n        // 最大の正方形を計算\n        REP(y, H) REP(x, W){\n            len[y][x] = 0;\n            for(int d = 1; x + d <= W && y + d <= W; d++){\n                bool ok = true;\n                REP(dy, d) REP(dx, d) if(!grid[y + dy][x + dx]) ok = false;\n                if(ok) len[y][x] = d;\n            }\n        }\n        // 包含されている正方形をチェック\n        REP(y, H) REP(x, W) {\n            REP(ly, y + 1) REP(lx, x + 1){\n                if(ly == y && lx == x) continue;\n                if(ly + len[ly][lx] >= y + len[y][x] && lx + len[ly][lx] >= x + len[y][x]){\n                    len[y][x] = 0;\n                }\n            }\n        }\n\n        xs.clear();\n        ys.clear();\n        int erase = 0;\n        REP(y, H) REP(x, W){\n            if(len[y][x] > 1) {\n                xs.push_back(x);\n                ys.push_back(y);\n            }\n            if(len[y][x] == 1){\n                grid[y][x] = 0;\n                erase++;\n            }\n        }\n        // REP(y, H) {\n        //     REP(x, W) cout << grid[y][x] << \" \";\n        //     cout << endl;\n        // }\n\n\n        int count = 0;\n        REP(y, H) REP(x, W) count += grid[y][x];\n        int ans;\n        for(ub = 0, found = false; ; ub++){\n            ans = dfs(0, 0, count);\n            if(ans < INF) break;\n        }\n        cout << ans + erase << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct square{\n\tint x,y,a; // 左上の座標, 幅\n\tbool operator<(const square &S)const{ return a<S.a; }\n};\n\nint h,w;\nint B[10][10];\n\nvector<square> S;\nint cnt[10][10]; // マス (i, j) を覆うことのできる正方形の個数\n\n#define update_cnt(i,d) for(int y=S[i].y;y<S[i].y+S[i].a;y++) for(int x=S[i].x;x<S[i].x+S[i].a;x++) cnt[y][x]+=d\n\nint res;\nvoid dfs(int i,int sum,int ub){\n\tif(sum==ub) return;\n\tif(sum>=res) return;\n\n\tif(i==S.size()){\n\t\tres=sum;\n\t\treturn;\n\t}\n\n\tbool ok1=false,ok2=false;\n\tfor(int y=S[i].y;y<S[i].y+S[i].a;y++) for(int x=S[i].x;x<S[i].x+S[i].a;x++) {\n\t\tif(B[y][x]==1) ok1=true;\n\t\tif(B[y][x]==1 && cnt[y][x]==1) ok2=true;\n\t}\n\n\tbool use=true,notuse=true;\n\t// 正方形 i を使うことで新たに覆えるマスがないなら使わない\n\tif(!ok1) use=false;\n\t// 正方形 i を使わないと絶対に覆えないマスができるようなら使う\n\tif(ok2) notuse=false;\n\n\t// いずれでもなければ両方試す\n\tupdate_cnt(i,-1);\n\tif(use){\n\t\tint tmp[10][10];\n\t\tmemcpy(tmp,B,sizeof B);\n\t\tfor(int y=S[i].y;y<S[i].y+S[i].a;y++) for(int x=S[i].x;x<S[i].x+S[i].a;x++) B[y][x]=i+2;\n\t\tdfs(i+1,sum+1,ub);\n\t\tmemcpy(B,tmp,sizeof B);\n\t}\n\tif(notuse){\n\t\tdfs(i+1,sum,ub);\n\t}\n\tupdate_cnt(i,+1);\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) rep(j,w) scanf(\"%d\",B[i]+j);\n\n\t\tS.clear();\n\t\trep(i,h) rep(j,w) if(B[i][j]==1) {\n\t\t\tint a;\n\t\t\tfor(a=1;i+a<=h&&j+a<=w;a++){\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int y=i;y<i+a;y++) for(int x=j;x<j+a;x++) if(B[y][x]==0) ok=false;\n\t\t\t\tif(!ok) break;\n\t\t\t}\n\t\t\tS.push_back((square){j,i,a-1});\n\t\t}\n\n\t\t// 他の正方形に完全に覆われるような正方形を削除\n\t\trep(i,S.size()){\n\t\t\tbool covered=false;\n\t\t\trep(j,S.size()) if(i!=j) {\n\t\t\t\tif(S[j].x<=S[i].x\n\t\t\t\t&& S[j].y<=S[i].y\n\t\t\t\t&& S[i].x+S[i].a<=S[j].x+S[j].a\n\t\t\t\t&& S[i].y+S[i].a<=S[j].y+S[j].a) covered=true;\n\t\t\t}\n\t\t\tif(covered){\n\t\t\t\tS.erase(S.begin()+i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tsort(S.begin(),S.end()); // 小さい正方形から順に調べる\n\n\t\trep(i,h) rep(j,w) cnt[i][j]=0;\n\t\trep(i,S.size()){\n\t\t\tfor(int y=S[i].y;y<S[i].y+S[i].a;y++) for(int x=S[i].x;x<S[i].x+S[i].a;x++) {\n\t\t\t\tcnt[y][x]++;\n\t\t\t}\n\t\t}\n\n\t\tres=S.size()+1;\n\t\tfor(int ub=1;;ub++){\n\t\t\tdfs(0,0,ub);\n\t\t\tif(res<S.size()+1) break;\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\t//ans = min(ans,info.num);\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcount(n))\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx];\n\t\t\trep(a,cy,cy+l)rep(b,cx,cx+l) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx];\n\t\t\trep(a,cy,cy+l)rep(b,cx,cx+l) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct state {\n\tvector<short> b;\n\tint dist, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.dist + s1.cost > s2.dist + s2.cost;\n}\nint H, W, a[12][12], cnt, xa[10009], ya[10009], xb[10009], yb[10009], popcount[1033];\nint main() {\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tpopcount[j] = popcount[j - (1 << i)] + 1;\n\t\t}\n\t}\n\twhile (cin >> W >> H, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) {\n\t\t\t\t\t\tif (k - i != l - j) continue;\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor (int x = i; x < k; x++) {\n\t\t\t\t\t\t\tfor (int y = j; y < l; y++) {\n\t\t\t\t\t\t\t\tif (a[x][y] == 0) flag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\txa[cnt] = i;\n\t\t\t\t\t\t\tya[cnt] = j;\n\t\t\t\t\t\t\txb[cnt] = k;\n\t\t\t\t\t\t\tyb[cnt] = l;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> que;\n\t\tint scnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (a[i][j] == 1) scnt++;\n\t\t\t}\n\t\t}\n\t\tque.push(state{ vector<short>(H, 0), 0, scnt });\n\t\tbool flag = false;\n\t\twhile (!que.empty() && !flag) {\n\t\t\tstate u = que.top(); que.pop();\n\t\t\tfor (int i = 0; i < cnt && !flag; i++) {\n\t\t\t\tvector<short> z = u.b;\n\t\t\t\tfor (int j = xa[i]; j < xb[i]; j++) {\n\t\t\t\t\tz[j] |= (1 << yb[i]) - (1 << ya[i]);\n\t\t\t\t}\n\t\t\t\tint rcnt = 0;\n\t\t\t\tfor (int j = 0; j < H; j++) rcnt += popcount[z[j]];\n\t\t\t\trcnt = scnt - rcnt;\n\t\t\t\tif (rcnt == 0) {\n\t\t\t\t\tcout << u.dist + 1 << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tque.push(state{ z, u.dist + 1, rcnt });\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10];\n\trep(i,y,y+len[y][x]) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<len[y][x])-1)<<x;\n\trep(a,y,y+len[y][x]){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+len[y][x]) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(cin >> w >> h,w){\n\t\tclr(board,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tboard[i]|=(tmp<<j);\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\trep(a,i,h)rep(b,j,w) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w)rep(a,i,i+len[i][j])rep(b,j,j+len[i][j]) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\t//while(dfs(0,0,0)==inf) min_res++;\n\t\tcout << dfs(0,0,0,min_res)+add << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\t\t\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tif(min_res>29) min_res=29;\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d){\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d>min_res) return inf;\n\n\tif(x>=w) return dfs(y+1,0,d);\n\n\tif(len[y][x]==0) return dfs(y,x+1,d);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d));\n\n\tint tboard[10];\n\trep(i,y,y+len[y][x]) tboard[i]=board[i];\n\n\tbool ok=false;\n\tint mask=((1<<len[y][x])-1)<<x;\n\trep(a,y,y+len[y][x]){\n\t\tif((board[a]&mask)!=0) ok=true;\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(ok) chmin(ret,dfs(y,x+len[y][x],d+1));\n\t\n\trep(i,y,y+len[y][x]) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(cin >> w >> h,w){\n\t\tclr(board,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tboard[i]|=(tmp<<j);\n\t\t}\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\trep(a,i,h)rep(b,j,w) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w)rep(a,i,i+len[i][j])rep(b,j,j+len[i][j]) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\t//while(dfs(0,0,0)==inf) min_res++;\n\t\tcout << dfs(0,0,0)+add << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\ninline void copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\t//ans = min(ans,info.num);\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nint H,W,mincost;\nint P[10][10],bin[10],bc[(1<<10)];\nint put[10][10],counter[10][10];\n\nbool can_put(int len,int x,int y){\n  REP(i,y,y+len)REP(j,x,x+len) if( !P[i][j] ) return false;\n  return true;\n}\n\nvoid dfs(int cur,int cost,int remain){\n\n  if( cost >= mincost ) return;\n//  if( cost + ((remain>0)?1:0) >= mincost ) return;\n\n  if( cur >= H*W ) {\n    mincost = min(mincost,cost);\n    return;\n  }\n\n  int x = cur % W, y = cur / W;\n\n  if( !P[y][x] || counter[y][x] == 1 ) {\n    dfs(cur+1,cost,remain);\n    return;\n  }\n\n  if( (bin[y]>>x) & 1 ) dfs(cur+1,cost,remain);\n\n  int len = put[y][x];\n  int bitmask = ((1<<len)-1)<<x;\n  int buf[len];\n  int add = 0, nremain = remain;\n  rep(j,len) {\n    buf[j] = bin[y+j];\n    add += len - bc[((1<<len)-1)&(bin[y+j]>>x)];\n    bin[y+j] |= bitmask;\n  }\n  nremain -= add;\n  if( add ) dfs(cur+1,cost+1,nremain);\n  rep(j,len) bin[y+j] = buf[j];\n\n}\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\nint main(){\n\n  rep(i,(1<<10)) bc[i] = __builtin_popcount(i);\n\n  while( scanf(\"%d%d\",&W,&H), W | H ){\n\n    rep(i,H){\n      bin[i] = 0;\n      rep(j,W){\n        cin >> P[i][j];\n        put[i][j] = 0;\n      }\n    }\n    rep(y,H) rep(x,W) if( P[y][x] ) {\n      for(int len=min(H,W);len>=1;len--){\n        if( x + len - 1 < W && y + len - 1 < H ) {\n          if( can_put(len,x,y) ){\n            put[y][x] = len;\n            break;\n          }\n        }\n      }\n    }\n\n    rep(i,H)rep(j,W) counter[i][j] = 0;\n    rep(i,H)rep(j,W)if(P[i][j]){\n      REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n        counter[y][x]++;\n      }\n    }\n\n    rep(i,H){\n      rep(j,W){\n        if( counter[i][j] == 1 ){\n          REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n            bin[y] |= (1<<x);\n          }\n        }\n      }\n    }\n\n    int add = 0;\n    int remain = 0;\n    mincost = 0;\n    rep(i,H)rep(j,W)remain += ((bin[i]>>j)&1),mincost += P[i][j];\n    remain = mincost - remain;\n    dfs(0,0,remain);\n\n    rep(i,H)rep(j,W)if(counter[i][j]==1)add++;\n    cout << mincost+add << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\t//ans = min(ans,info.num);\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tbool FLG = false;\n\t\tint must_add = 0;\n\n\t\t//????????????????????????????????????\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(info.table[H-1][col] == 0 && first_table[H-1][col] > 1){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx];\n\t\t\trep(a,cy,cy+l)rep(b,cx,cx+l) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool data[10][10];\nchar input[10][10];\nbool vis[10][10];\nint w, h;\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> input[i][j];\n      }\n    }\n    int ans = 0;\n    fill(data[0], data[10], false);\n    for(int k=10;k>=1;k--){\n      fill(vis[0], vis[10], false);\n      for(int l=0;l<=k*k;l++){\n        for(int i=0;i+k<=h;i++){\n          for(int j=0;j+k<=w;j++){\n            if(vis[i][j])continue;\n            bool f1 = true;\n            bool f2 = false;\n            int cnt = 0;\n            for(int i1=0;i1<k;i1++){\n              for(int j1=0;j1<k;j1++){\n                if(input[i+i1][j+j1] == '0'){\n                  f1 = false;\n                  break;\n                }\n                if(!data[i+i1][j+j1]) f2 = true;\n                else cnt++;\n              }\n            }\n            if(!f1 || !f2){\n              vis[i][j] = true;\n              continue;\n            }\n            if(cnt > l) continue;\n            ans++;\n            vis[i][j] = true;\n            for(int i1=0;i1<k;i1++){\n              for(int j1=0;j1<k;j1++){\n                data[i+i1][j+j1] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 11\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nstruct dat{\n  int x,y,X,Y;\n  bool contain(dat b){return (x<=b.x && b.X<=X) && (y<=b.y && b.Y<=Y);}\n};\n\nint h,w;\nvector<dat> A;\ntypedef vector<vector<int> > V;\n\n\nint count(const V &mp,dat a){\n  int cnt = 0;\n  for(int i=a.y;i<=a.Y;i++) cnt += count(mp[i].begin()+a.x,mp[i].begin()+a.X+1,1);\n  return cnt;\n}\n\nbool contain0(V &mp,int x,int y,int X,int Y){return count(mp,(dat){x,y,X,Y}) == (X-x+1)*(Y-y+1);}\n\nstruct dat2{\n  V mp;\n  int cnt,cost;\n};\n\ndat2 getNx(dat2 t,dat a){\n  t.cost++;\n  for(int i=a.y;i<=a.Y;i++)\n    for(int j=a.x;j<=a.X;j++){\n      t.cnt -= t.mp[i][j];\n      t.mp[i][j] = 0;\n    }\n  return t;\n}\n\ndat2 erase(dat2 t){\n  int update = 1;\n  while(update--){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n        if(t.mp[i][j] == 0)continue;\n        int cnt = 0;\n        dat tmp;\n        for(dat a:A) if(a.contain((dat){j,i,j,i})) cnt++, tmp = a;\n        if(cnt == 1) t = getNx(t,tmp),update = 1;\n      }\n  }\n  return t;\n}\n\ntypedef pair<int,int> P;\nset<P> getErased(const V &mp,const dat &a){\n  set<P> res;\n  for(int i=a.y;i<=a.Y;i++)\n    for(int j=a.x;j<=a.X;j++)\n      if(mp[i][j]) res.insert(P(i,j));\n  return res;\n}\n\nint bfs(V start){\n  queue<dat2> Q;\n  set<V> used;\n  Q.push((dat2){start,count(start,(dat){0,0,w-1,h-1}),0});\n\n  while(1){\n    dat2 t = erase(Q.front());Q.pop();\n    if(t.cnt == 0) return t.cost;\n    if(used.count(t.mp))continue;\n    used.insert(t.mp);\n\n    dat nx;\n    for(dat a:A) if(count(t.mp,a)) nx = a;\n    set<P> S = getErased(t.mp,nx);\n    for(dat a:A){\n      set<P> s = getErased(t.mp,a);\n      int cnt = 0;\n      for(P p:s) cnt += S.count(p);\n      if(cnt) Q.push(getNx(t,a));\n    }\n  }\n}\n\nsigned main(){\n  while(1){\n    cin>>w>>h;\n    if(w == 0 && h == 0)break;\n\n    V mp = V(h,vector<int>(w));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>mp[i][j];\n    \n    A.clear();\n    for(int y=0;y<h;y++)\n      for(int x=0;x<w;x++){\n        dat a = (dat){-1,-1,-1,-1};\n        for(int Y=y, X=x; Y<h && X<w ;Y++, X++) if(contain0(mp,x,y,X,Y)) a = (dat){x,y,X,Y};\n        if(a.x != -1) A.push_back(a);\n      }\n    \n    for(int i=0;i<(int)A.size();i++)\n      for(int j=0;j<(int)A.size();j++) if(i!=j && A[i].contain(A[j]))A.erase(A.begin()+j--);\n    cout<<bfs(mp)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntemplate<class T> T gcd( T a, T b ) {\n\treturn !b ? a : gcd( b, a % b );\n}\ntemplate<class T> T lcm( T a, T b ) {\n\treturn a / gcd( a, b ) * b;\n}\ntemplate<class T> string print_v( vector<T> v ) {\n\tOSS oss;\n\tfor ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end();\n          ++it_i ) {\n\t\toss << *it_i << \", \";\n\t}\n\treturn oss.str();\n}\n\nconst int ks = 1;\nconst int kr[ks] = { -1 };\nconst int kc[ks] = { -1 };\nint w, h;\n\nvoid print( VVI T ) {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j] << \",\";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint main() {\n    while ( cin >> w >> h && w ) {\n        VVI T( h, VI( w ) );\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                cin >> T[i][j];\n            }\n        }\n        VVI dp = T;\n        for ( int i = h - 1 - 1; i >= 0; -- i ) {\n            for ( int j = w - 1 - 1; j >= 0; -- j ) {\n                if ( dp[i][j] == 0 ) continue;\n                dp[i][j] = min( dp[i+1][j+1], min( dp[i+1][j], dp[i][j+1] ) ) + 1;\n            }\n        }\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                // cout << dp[i][j] << \", \";\n            }\n            // cout << endl;\n        }\n        // cout << endl;\n        VVI used = T;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                used[i][j] = used[i][j] == 1 ? 0 : 1;\n                // cout << used[i][j] << \", \";\n            }\n            // cout << endl;\n        }\n        int res = 0;\n        for ( int r = h - 1; r >= 0; -- r ) {\n            for ( int c = w - 1; c >= 0; -- c ) {\n                if ( used[r][c] != 0 ) continue;\n                res ++;\n                for ( int i = 0; i < h; ++ i ) {\n                    for ( int j = 0; j < w; ++ j ) {\n                        if ( i <= r && r <= i + dp[i][j] - 1 && j <= c && c <= j + dp[i][j] - 1 ) {\n                            for ( int dr = 0; dr < dp[i][j]; ++ dr ) {\n                                for ( int dc = 0; dc < dp[i][j]; ++ dc ) {\n                                    used[i+dr][j+dc] = 1;\n                                }\n                            }\n                            goto out;\n                        }\n                    }\n                }\n            out:;\n                // cout << \"used change 2\" << endl;\n                for ( int i = 0; i < h; ++ i ) {\n                    for ( int j = 0; j < w; ++ j ) {\n                        // cout << used[i][j] << \", \";\n                    }\n                    // cout << endl;\n                }\n            }\n        }\n        cout << res << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\n\t\tfor(int row = base_row; row <= base_row; row++){\n\t\t\tfor(int col = base_col; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG){\n\t\t\tfor(int row = base_row+1; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tfor(int row = base_row+1; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntemplate<class T> T gcd( T a, T b ) {\n\treturn !b ? a : gcd( b, a % b );\n}\ntemplate<class T> T lcm( T a, T b ) {\n\treturn a / gcd( a, b ) * b;\n}\ntemplate<class T> string print_v( vector<T> v ) {\n\tOSS oss;\n\tfor ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end();\n          ++it_i ) {\n\t\toss << *it_i << \", \";\n\t}\n\treturn oss.str();\n}\n\nconst int ks = 1;\nconst int kr[ks] = { -1 };\nconst int kc[ks] = { -1 };\nint w, h;\n\nvoid print( VVI T ) {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j] << \",\";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint main() {\n    while ( cin >> w >> h && w ) {\n        VVI T( h, VI( w ) );\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                cin >> T[i][j];\n            }\n        }\n        VVI dp = T;\n        for ( int i = h - 1 - 1; i >= 0; -- i ) {\n            for ( int j = w - 1 - 1; j >= 0; -- j ) {\n                if ( dp[i][j] == 0 ) continue;\n                dp[i][j] = min( dp[i+1][j+1], min( dp[i+1][j], dp[i][j+1] ) ) + 1;\n            }\n        }\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                // cout << dp[i][j] << \", \";\n            }\n            // cout << endl;\n        }\n        // cout << endl;\n        VVI used = T;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                used[i][j] = used[i][j] == 1 ? 0 : 1;\n                // cout << used[i][j] << \", \";\n            }\n            // cout << endl;\n        }\n        int res = 0;\n        for ( int r = h - 1; r >= 0; -- r ) {\n            for ( int c = w - 1; c >= 0; -- c ) {\n                if ( used[r][c] == 1 ) continue;\n                // cout << \"pos: \" << r << \", \" << c << endl;\n                int cnt = 0;\n                for ( int i = 0; i < h; ++ i ) {\n                    for ( int j = 0; j < w; ++ j ) {\n                        if ( i <= r && r <= i + dp[i][j] - 1 && j <= c && c <= j + dp[i][j] - 1 ) {\n                            // cout << i << \", \" << j << \"から\" << dp[i][j] << endl;\n                            for ( int dr = 0; dr < dp[i][j]; ++ dr ) {\n                                for ( int dc = 0; dc < dp[i][j]; ++ dc ) {\n                                    if ( used[i+dr][j+dc] == 0 ) cnt ++;\n                                    used[i+dr][j+dc] = 1;\n                                }\n                            }\n                            goto out;\n                        }\n                    }\n                }\n            out:;\n                // cout << \"pos: \" << r << \", \" << c << \": \" << cnt << endl;\n                if ( cnt > 0 ) {\n                    res ++;\n                    // cout << \"used change 2\" << endl;\n                    for ( int i = 0; i < h; ++ i ) {\n                        for ( int j = 0; j < w; ++ j ) {\n                            // cout << used[i][j] << \", \";\n                        }\n                        // cout << endl;\n                    }\n                }\n            }\n        }\n        cout << res << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<functional>\n\n#define N 11\n#define INF (1<<27)\n\nusing namespace std;\n\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\nint maxSizes[N][N];\nint oneCount;\nset<int,greater<int> > squareSizes;\nint bestAns = INF;\nint minHW;\n\nint getHeuristic(int H, int W, int M[N][N])\n{\n  int maxSize = *(squareSizes.begin());  \n  maxSize *= maxSize;\n  return (oneCount / maxSize) + (oneCount%maxSize>0);\n}\n\nvoid calc(int H, int W, int M[N][N]){\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 1) oneCount++;\n      int size = 0;\n      for(size = 1; size <= minHW; ++size){\n\tfor(int m = i; m<size+i; m++){\n\t  for(int n = j; n<size+j; n++){\n\t    if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t      --size;\n\t      goto next;\n\t    }\n\t  }\n\t}\n\tif(i+size>=H||j+size>=W)break;\n      next:;\n\tmaxSizes[i][j] = size;\n\tsquareSizes.insert( size );\n      }\n    }\n  }\n  return ;\n}\n\nvoid solve(int H, int W, int pos, int M[N][N], int depth){\n \n  /*\n  printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W,getHeuristic(H,W,M));\n  for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n      if(l>0)putchar(' ');\n      printf(\"%d\", M[k][l]);\n    }\n    putchar('\\n');\n  }\n  putchar('\\n');\n  */\n\n  // completed.\n  bool bComp=true;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j]==1){\n\tbComp=false;\n\tgoto end;\n      }\n    }\n  }\n end:;\n  if(bComp){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic(H,W,M)>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < H*W; ++p){\n    int i = p / W;\n    int j = p % W;\n    if( M[i][j] == 0 ){\n      continue;\n    }else if( M[i][j] >= 1 ){\n      int size = maxSizes[i][j];\n      bool valid=false;\n      for(int m = i; m<size+i; m++){\n\tfor(int n = j; n<size+j; n++){\n\t  if(M[m][n]==1){\n\t    valid=true;\n\t    M[m][n]=depth;\n\t  }\n\t}\n      }\n      if( valid ){\n\tsquareSize.erase( squareSize.find( size ) );\n\tsolve(H,W,p+1,M,depth+1);\n\tsquareSize.insert( size );\n      }\n      for(int m = i; m<size+i; m++){\n\tfor(int n = j; n<size+j; n++){\n\t  if(M[m][n]==depth){\n\t    M[m][n]=1;\n\t  }\n\t}\n      }\n      if( M[i][j] > 1 )\n\tsolve(H,W,p+1,M,depth+1);\n      return ;\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[N][N];\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    oneCount = 0;\n    squareSizes.clear();    \n    calc(H,W,M);\n    solve(H,W,0,M,2);\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\nusing state=array<array<int,10>,10>;\n\nint len[15][15];\n\nint min_res=0;\nint dfs(state board,int y,int x,int d){\n\t\n\tif(y==h && x==0) return d;\n\n\tif(d>min_res) return inf;\n\n\tint ny=y,nx=x+1;\n\tif(nx==w) ny++,nx=0;\t\n\n\tif(len[y][x]==0) return dfs(board,ny,nx,d);\n\n\tint ret=inf;\n\tif(board[y][x]<=0) chmin(ret,dfs(board,ny,nx,d));\n\n\tstate nboard=board;\n\tbool ok=false;\n\trep(a,y,y+len[y][x])rep(b,x,x+len[y][x]){\n\t\tif(nboard[a][b]==1) ok=true;\n\t\tnboard[a][b]--;\n\t}\n\tif(ok) chmin(ret,dfs(nboard,ny,nx,d+1));\n\t\n\treturn ret;\n}\n\nint main(void){\n\twhile(cin >> w >> h,w){\n\t\tstate board;\n\t\trep(i,h)rep(j,w) cin >> board[i][j];\n\n\t\tclr(len,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tif(board[i][j]==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\trep(a,i,h)rep(b,j,w) if(board[a][b]==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w)rep(a,i,i+len[i][j])rep(b,j,j+len[i][j]) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a][b]--;\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\tmin_res=0;\n\t\twhile(dfs(board,0,0,0)==inf) min_res++;\n\t\tcout << min_res+add << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn num > arg.num;\n\t}\n\tint table[10][10],num,row,col;\n};\n\n\nint W,H,POW[11];\nint first_table[10][10],max_size[10][10];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,const int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tstart.row = 0;\n\tstart.col = 0;\n\n\tpriority_queue<Info> Q;\n\tQ.push(start);\n\n\t//int debug = 0;\n\n\twhile(!Q.empty()){\n\n\t\t/*debug++;\n\t\tif(debug == 20){\n\t\t\tprintf(\"LOOOP!!\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t\tprintf(\"base_row:%d base_col:%d\\n\",Q.top().row,Q.top().col);\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tprintf(\" %d\",Q.top().table[row][col]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\tFLG = true;\n\n\t\tfor(int row = Q.top().row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(Q.top().table[row][col] == 0){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)break;\n\t\t}\n\n\t\tif(FLG){\n\t\t\tprintf(\"%d\\n\",Q.top().num);\n\t\t\treturn;\n\t\t}\n\n\n\n\t\tInfo next_info;\n\n\t\tif(Q.top().table[Q.top().row][Q.top().col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t\t//printf(\"?¶????\\n\");\n\n\t\t\tcopyTable(next_info,Q.top().table,Q.top().row);\n\t\t\tnext_info.num = Q.top().num;\n\n\t\t\t//???????????????????????????????§?\n\t\t\tif(Q.top().col == W-1){\n\t\t\t\tnext_info.row = Q.top().row+1;\n\t\t\t\tnext_info.col = 0;\n\t\t\t}else{\n\t\t\t\tnext_info.row = Q.top().row;\n\t\t\t\tnext_info.col = Q.top().col+1;\n\t\t\t}\n\t\t\tQ.push(next_info);\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\tint count = 0;\n\n\t\tfor(int size = 1; size <= max_size[Q.top().row][Q.top().col]; size++){\n\n\t\t\t//printf(\"size:%d\\n\",size);\n\n\t\t\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\t\t\tint new_num = 0;\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\tif(Q.top().table[Q.top().row+i][Q.top().col+k] == 0){\n\t\t\t\t\t\tnew_num++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\t\t\tif(size == 1){ //1?????????????????°??????\n\n\t\t\t\t\t//printf(\"????????????????????????\\n\");\n\n\t\t\t\t\tcopyTable(next_info,Q.top().table,Q.top().row);\n\t\t\t\t\tnext_info.num = Q.top().num;\n\n\t\t\t\t\t//???????????????????????????????§?\n\t\t\t\t\tif(Q.top().col == W-1){\n\t\t\t\t\t\tnext_info.row = Q.top().row+1;\n\t\t\t\t\t\tnext_info.col = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_info.row = Q.top().row;\n\t\t\t\t\t\tnext_info.col = Q.top().col+1;\n\t\t\t\t\t}\n\t\t\t\t\tQ.push(next_info);\n\t\t\t\t}\n\t\t\t}else{\n\n\t\t\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\t\t\tif(Q.top().table[Q.top().row][Q.top().col] != 0 && count == 0){\n\t\t\t\t\t//printf(\"????????????\\n\");\n\t\t\t\t\tcount++; //1?????????????????°??????\n\n\t\t\t\t\tInfo next_not;\n\n\t\t\t\t\tcopyTable(next_not,Q.top().table,Q.top().row);\n\t\t\t\t\tnext_not.num = Q.top().num;\n\n\t\t\t\t\tif(Q.top().col == W-1){\n\t\t\t\t\t\tnext_not.row = Q.top().row+1;\n\t\t\t\t\t\tnext_not.col = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_not.row = Q.top().row;\n\t\t\t\t\t\tnext_not.col = Q.top().col+1;\n\t\t\t\t\t}\n\t\t\t\t\tQ.push(next_not);\n\t\t\t\t}\n\n\t\t\t\tcopyTable(next_info,Q.top().table,Q.top().row);\n\t\t\t\tnext_info.num = Q.top().num+1;\n\n\t\t\t\t//????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tnext_info.table[Q.top().row+i][Q.top().col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(Q.top().col == W-1){\n\t\t\t\t\tnext_info.row = Q.top().row+1;\n\t\t\t\t\tnext_info.col = 0;\n\t\t\t\t}else{\n\t\t\t\t\tnext_info.row = Q.top().row;\n\t\t\t\t\tnext_info.col = Q.top().col+1;\n\t\t\t\t}\n\t\t\t\tQ.push(next_info);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\t\t\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nstruct aa {\n\tvector<vector<int>>field;\n\tint sx;\n\tint sy;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nmap<vector<vector<int>>, int>mp;\nint main() {\n\twhile (1) {\n\t\tint X, Y; cin >> X >> Y;\n\t\tif (!X)break;\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\t{\n\t\t\tint sx=-1, sy=-1;\n\t\t\tvector<vector<int>>sfield(Y + 2, vector<int>(X + 2));\n\t\t\tbool flag = true;\n\t\t\tfor (int i = 0; i < Y; ++i) {\n\t\t\t\tfor (int j = 0; j < X; ++j) {\n\t\t\t\t\tcin >> sfield[i + 1][j + 1];\n\t\t\t\t\tif (flag&&sfield[i + 1][j + 1]) {\n\t\t\t\t\t\tsx = j + 1;\n\t\t\t\t\t\tsy = i + 1;\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tque.push(aa{ sfield, sx, sy, 0 });\n\t\t\tmp[sfield] = 0;\n\t\t}\n\t\tint ans = -1;\n\t\twhile (que.size()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (atop.sx == -1) {\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t{\n\t\t\t\tint nsx = atop.sx;\n\t\t\t\tconst int nsy = atop.sy;\n\t\t\t\twhile (atop.field[nsy][nsx]) {\n\t\t\t\t\tint nsize = atop.sx - nsx + 1;\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ay = nsy; ay < nsy + nsize; ++ay) {\n\t\t\t\t\t\t\tfor (int ax = nsx; ax < nsx + nsize; ++ax) {\n\t\t\t\t\t\t\t\tif (!atop.field[ay][ax]) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!ok)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\t\tnsize--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnsize++;\n\t\t\t\t\t}\n\t\t\t\t\tif (nsize == atop.sx - nsx)break;\n\t\t\t\t\telse {\n\t\t\t\t\t\tvector<vector<int>>nfield(atop.field);\n\t\t\t\t\t\tfor (int ay = nsy; ay < nsy + nsize; ++ay) {\n\t\t\t\t\t\t\tfor (int ax = nsx; ax < nsx + nsize; ++ax) {\n\t\t\t\t\t\t\t\tif (nfield[ay][ax] == 0)assert(false);\n\t\t\t\t\t\t\t\tnfield[ay][ax] = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!mp.count(nfield)) {\n\t\t\t\t\t\t\tint asx = -1, asy = -1;\n\t\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\t\tfor (int i = 0; i < Y + 2; ++i) {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < X + 2; ++j) {\n\t\t\t\t\t\t\t\t\tif (flag&&nfield[i][j] == 1) {\n\t\t\t\t\t\t\t\t\t\tasx = j; asy = i;\n\t\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmp[nfield] = atop.time + 1;\n\t\t\t\t\t\t\tque.push(aa{ nfield,asx,asy,atop.time + 1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnsx--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tconst int nsx = atop.sx;\n\t\t\t\tint nsy = atop.sy;\n\t\t\t\twhile (atop.field[nsy][nsx]) {\n\t\t\t\t\tint nsize = atop.sy - nsy + 1;\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ay = nsy; ay < nsy + nsize; ++ay) {\n\t\t\t\t\t\t\tfor (int ax = nsx; ax < nsx + nsize; ++ax) {\n\t\t\t\t\t\t\t\tif (!atop.field[ay][ax]) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!ok)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\t\tnsize--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnsize++;\n\t\t\t\t\t}\n\t\t\t\t\tif (nsize == atop.sy - nsy)break;\n\t\t\t\t\telse {\n\t\t\t\t\t\tvector<vector<int>>nfield(atop.field);\n\t\t\t\t\t\tfor (int ay = nsy; ay < nsy + nsize; ++ay) {\n\t\t\t\t\t\t\tfor (int ax = nsx; ax < nsx + nsize; ++ax) {\n\t\t\t\t\t\t\t\tif (nfield[ay][ax] == 0)assert(false);\n\t\t\t\t\t\t\t\tnfield[ay][ax] = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!mp.count(nfield)) {\n\t\t\t\t\t\t\tint asx = -1, asy = -1;\n\t\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\t\tfor (int i = 0; i < Y + 2; ++i) {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < X + 2; ++j) {\n\t\t\t\t\t\t\t\t\tif (flag&&nfield[i][j] == 1) {\n\t\t\t\t\t\t\t\t\t\tasx = j; asy = i;\n\t\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmp[nfield] = atop.time + 1;\n\t\t\t\t\t\t\tque.push(aa{ nfield,asx,asy,atop.time + 1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnsy--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nstruct carpet {\n    int y, x;\n    int len;\n    bool use;\n    carpet(int y, int x, int len) : y(y), x(x), len(len), use(true) {}\n};\n\nbool contain(carpet const& c1, carpet const& c2) {\n    const int lx1 = c1.x, ly1 = c1.y;\n    const int lx2 = c2.x, ly2 = c2.y;\n    const int len1 = c1.len, len2 = c2.len;\n    return lx1 <= lx2 && ly1 <= ly2 && \n           lx2 + len2 <= lx1 + len1 && ly2 + len2 <= ly1 + len1;\n}\n\nbool check_clear(vector<vector<int>> const& fld) {\n    const int H = fld.size(), W = fld[0].size();\n    for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n            if(fld[i][j] == 1) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int W, H;\n    while(cin >> W >> H, W) {\n        vector<vector<int>> fld(H, vector<int>(W));\n        for(int i = 0; i < H; ++i) {\n            for(int j = 0; j < W; ++j) {\n                cin >> fld[i][j];\n            }\n        }\n\n        auto can_put = [&](int y, int x, int len) {\n            if(y + len > H || x + len > W) return false;\n            bool res = true;\n            for(int i = y; i < y + len; ++i) {\n                for(int j = x; j < x + len; ++j) {\n                    res &= fld[i][j] == 1;\n                }\n            }\n            return res;\n        };\n\n        vector<carpet> cs;\n        for(int i = 0; i < H; ++i) {\n            for(int j = 0; j < W; ++j) {\n                if(fld[i][j] == 1) {\n                    int lb = 1, ub = max(H, W) + 1;\n                    while(ub - lb > 1) {\n                        const int mid = (ub + lb) / 2;\n                        if(can_put(i, j, mid)) lb = mid;\n                        else                   ub = mid;\n                    }\n                    cs.emplace_back(i, j, lb);\n                }\n            }\n        }\n\n        int n = cs.size();\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(i == j) continue;\n                if(contain(cs[i], cs[j])) {\n                    cs[j].use = false;\n                }\n            }\n        }\n\n        auto remove_unuse = [&]() {\n            cs.erase(remove_if(begin(cs), end(cs), [&](const auto& c) { return !c.use; }), end(cs));\n            n = cs.size();\n        };\n        remove_unuse();\n\n        int ans = 0;\n        bool update = true;\n        while(update) {\n            update = false;\n\n            vector<vector<vector<int>>> v(H, vector<vector<int>>(W));\n            for(int i = 0; i < n; ++i) {\n                for(int j = cs[i].y; j < cs[i].y + cs[i].len; ++j) {\n                    for(int k = cs[i].x; k < cs[i].x + cs[i].len; ++k) {\n                        v[j][k].push_back(i);\n                    }\n                }\n            }\n\n            bool update2 = true;\n            while(update2) {\n                update2 = false;\n                for(int i = 0; i < H; ++i) {\n                    for(int j = 0; j < W; ++j) {\n                        if(v[i][j].size() == 1 && fld[i][j] == 1) {\n                            const int idx = v[i][j][0];\n                            cs[idx].use = false;\n                            update = update2 = true;\n                            ans += 1;\n                            for(int k = cs[idx].y; k < cs[idx].y + cs[idx].len; ++k) {\n                                for(int l = cs[idx].x; l < cs[idx].x + cs[idx].len; ++l) {\n                                    v[k][l].erase(find(begin(v[k][l]), end(v[k][l]), idx));\n                                    fld[k][l] = 0;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            remove_unuse();\n\n\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    if(i == j) continue;\n                    if(!cs[i].use || !cs[j].use) continue;\n                    vector<int> vs1, vs2;\n                    for(int y = cs[i].y; y < cs[i].y + cs[i].len; ++y) {\n                        for(int x = cs[i].x; x < cs[i].x + cs[i].len; ++x) {\n                            if(fld[y][x] == 1) {\n                                vs1.push_back(y * W + x);\n                            }\n                        }\n                    }\n                    for(int y = cs[j].y; y < cs[j].y + cs[j].len; ++y) {\n                        for(int x = cs[j].x; x < cs[j].x + cs[j].len; ++x) {\n                            if(fld[y][x] == 1) {\n                                vs2.push_back(y * W + x);\n                            }\n                        }\n                    }\n                    bool f = true;\n                    for(int i = 0; i < (int)vs2.size(); ++i) {\n                        f &= find(begin(vs1), end(vs1), vs2[i]) != end(vs1);\n                    }\n                    if(f) {\n                        cs[j].use = false;\n                        update = true;\n                    }\n                }\n            }\n            remove_unuse();\n        }\n\n        int add = 1000;\n        for(int S = 0; S < (1 << n); ++S) {\n            if(__builtin_popcount(S) >= add) continue;\n            auto fld2 = fld;\n            for(int i = 0; i < n; ++i) {\n                if(S & (1LL << i)) {\n                    for(int j = cs[i].y; j < cs[i].y + cs[i].len; ++j) {\n                        for(int k = cs[i].x; k < cs[i].x + cs[i].len; ++k) {\n                            fld2[j][k] -= 1;\n                        }\n                    }\n                }\n            }\n            if(check_clear(fld2)) {\n                add = min(add, __builtin_popcount(S));\n            }\n        }\n\n        cout << ans + add << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//???????????????\n//???mnway=cnt???????????????cnt=mnway?????????????????????\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nconst int MX=100;\ntypedef bitset<MX> BS;\nint H,W,N;\nint ans;\nbool used[MX];\nvector<BS> cs;\nbool incl(BS& a,BS& b){return (a&b)==b;}\nvoid dfs(BS now,int t){\n\tif(ans<=t) return;\n\tif(now.none()){\n\t\tchmin(ans,t);\n\t\treturn;\n\t}\n\tint mnway=MX,arg=-1;\n\trep(i,H*W) if(now[i]){\n\t\tint cnt=0;\n\t\trep(j,N) if(!used[j]){\n\t\t\tif(cs[j][i]) cnt++;\n\t\t}\n\t\tif(cnt<mnway){\n\t\t\tmnway=cnt;\n\t\t\targ=i;\n\t\t}\n\t}\n\tassert(arg>=0);\n\trep(i,N) if(!used[i]&&cs[i][arg]){\n\t\tused[i]=1;\n\t\tdfs(now&(~cs[i]),t+1);\n\t\tused[i]=0;\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>H;\n\t\tif(H==0) break;\n\t\tcs.clear();\n\t\tBS s;\n\t\trep(i,H) rep(j,W){\n\t\t\tbool x;\n\t\t\tcin>>x;\n\t\t\ts.set(i*W+j,x);\n\t\t}\n\t\trep(i,H) rep(j,W){\n\t\t\tfor(int d=10;d>=1;d--){\n\t\t\t\tbool can=1;\n\t\t\t\tif(i+d-1>=H||j+d-1>=W) can=0;\n\t\t\t\tif(can){\n\t\t\t\t\trep(x,d) rep(y,d) if(!s[(i+x)*W+j+y]) can=0;\n\t\t\t\t}\n\t\t\t\tif(can){\n\t\t\t\t\tBS b;\n\t\t\t\t\trep(x,d) rep(y,d) b.set((i+x)*W+j+y);\n\t\t\t\t\tcs.pb(b);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tN=cs.size();\n\t\tbool gomi[MX]={};\n\t\trep(i,N) rep(j,N) if(i!=j){\n\t\t\tif(incl(cs[i],cs[j])) gomi[j]=1;\n\t\t}\n\t\tvector<BS> tmp;\n\t\trep(i,N) if(!gomi[i]) tmp.pb(cs[i]);\n\t\tcs=tmp;\n\t\tN=cs.size();\n//\t\trep(i,N) show(cs[i]);\n\t\tans=N;\n\t\trep(i,N) used[i]=0;\n\t\tdfs(s,0);\n//\t\tshow(cnt);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define N 11\n#define INF (1<<29)\n\nusing namespace std;\n\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\nint bestAns = INF;\nint minHW;\n\nvoid solve(int H, int W, int M[N][N], int depth){\n  /*\n    for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n    if(l>0)putchar(' ');\n    printf(\"%d\", M[k][l]);\n    }\n    putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  bool bComp=true;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j]==1){\n\tbComp=false;\n      }\n    }\n  }\n  if(bComp){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(depth>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if( M[i][j] == 0 ){\n\tcontinue;\n      }else if( M[i][j] == 1 ){\n\tint maxOneCount=-1;\n\tint maxSize=-1;\n\tvector< pair<int,int> > vk;\n\tfor(int k = 0; k < 4; ++k){\n\t  int size = 0;\n\t  for(size = 1; size <= minHW; ++size){\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t  --size;\n\t\t  goto next1;\n\t\t}\n\t      }\n\t    }\n\t    if(k==0){\n\t      if(i-size<0||j+size>=W)break;\n\t    }else if(k==1){\n\t      if(i+size>=H||j+size>=W)break;\n\t    }else if(k==2){\n\t      if(i+size>=H||j-size<0)break;\n\t    }else{\n\t      if(i-size<0||j-size<0)break;\n\t    }\n\t  }\n\tnext1:;\n\t  int oneCount=0;\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( M[m][n] == 1 ){\n\t\t++oneCount;\n\t      }\n\t    }\n\t  }\n\t  vk.push_back( make_pair(size,oneCount) );\n\t  maxOneCount = max( maxOneCount, oneCount );\n\t  maxSize = max( maxSize, size );\n\t}\n\tfor(int k = 0; k < 4; ++k){\n\t  if(vk[k].second==maxOneCount){\n\t    int size = vk[k].first;\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif(M[m][n]==1){\n\t\t  M[m][n]=depth;\n\t\t}\n\t      }\n\t    }\n\t    solve(H,W,M,depth+1);\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( M[m][n] == depth ){\n\t\t  M[m][n]=1;\n\t\t}\n\t      }\n\t    }\n\t    if(maxSize==1&&maxOneCount==1)break;\n\t  }\n\t}\n\treturn ;\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[N][N];\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    solve(H,W,M,2);\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans;\nint first_table[10][10],max_size[10][10];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10]){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\t//printf(\"ans:%d\\n\",ans);\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\tcopyTable(next_info,info.table);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tcopyTable(next_info,info.table);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\t\t\tInfo next_not;\n\n\t\t\tcopyTable(next_not,info.table);\n\t\t\tnext_not.num = info.num;\n\n\t\t\tint must_add = 0;\n\t\t\tbool FLG = false;\n\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}else if(next_not.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)must_add++;\n\n\t\t\tif(next_not.num+must_add < ans){\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcopyTable(next_info,info.table);\n\t\tnext_info.num = info.num+1;\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(next_info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tif(next_info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_info,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024],check2[1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nint makeCode(int table[10]){\n\tint ret = 0;\n\n\tfor(int col = 0; col < W; col++){\n\t\tif(table[col] == 0){\n\t\t\tret += POW[col];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\tif(base_row == H-2 && base_col == 0){ //?????????2?????§??????????????\\??????\n\n\t\tint code1 = makeCode(info.table[H-2]);\n\t\tint code2 = makeCode(info.table[H-1]);\n\n\t\tif(check[code1][code2] <= info.num)return;\n\n\t\tcheck[code1][code2] = info.num;\n\t}else if(base_row == H-1 && base_col == 0){\n\n\t\tint code = makeCode(info.table[H-1]);\n\n\t\tif(check2[code] <= info.num)return;\n\n\t\tcheck2[code] = info.num;\n\t}\n\n\t//printf(\"ans:%d\\n\",ans);\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\t\t\tInfo next_not;\n\n\t\t\tcopyTable(next_not,info.table,base_row);\n\t\t\tnext_not.num = info.num;\n\n\t\t\tint must_add = 0;\n\t\t\tbool FLG = false;\n\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\tfor(int row = base_row; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}else if(next_not.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)must_add++;\n\n\t\t\tif(next_not.num+must_add < ans){\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num+1;\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(next_info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tif(next_info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_info,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < POW[W]; i++){\n\t\tcheck2[i] = false;\n\t\tfor(int k = 0; k < POW[W]; k++)check[i][k] = BIG_NUM;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> tri;\n\nint w,h;\nint g[10][10];\nint rem[10][10];\nvector<tri> carpet[10][10];\nint depth;\n\nvoid search(int d){\n  if(d==depth)return;\n\n  int y=-1, x=-1, mink = h*w;\n  vector<tri> priority;\n  rep(i,h)rep(j,w){\n    if(rem[i][j] && mink > (int)carpet[i][j].size()){\n      y = i; x = j;\n    }\n  }\n\n  if(y<0){\n    depth = d;\n    return;\n  }\n\n  for(tri t : carpet[y][x]){\n    int tmp[10][10];\n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\ttmp[i][j] = rem[i][j];\n      }\n    }\n\n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\trem[i][j] = 0;\n      }\n    }\n    \n    search(d+1);\n\n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\trem[i][j] = tmp[i][j];\n      }\n    }\n    if(depth == d+1)return;\n  }\n}\n\nint main(){\n  while(cin >> w >> h, w){\n    memset(g,0,sizeof(g));\n    rep(i,h)rep(j,w){\n      cin >> g[i][j];\n      rem[i][j] = g[i][j];\n      carpet[i][j].clear();\n    }\n\n    vector<tri> c;\n    rep(i,h)rep(j,w){\n      int k = 0;\n      while(true){\n\tif(!range(i+k,0,h) || !range(j+k,0,w))break;\n\tint f = 1;\n\tfor(int y=i;y<=i+k;y++)f &= g[y][j+k];\n\tfor(int x=j;x<=j+k;x++)f &= g[i+k][x];\n\tif(!f)break;\n\tk++;\n      }\n      if(k)c.push_back( tri(pii(i,j), k) );\n    }\n    \n    rep(i,c.size()){\n      bool f = false;\n      rep(j,c.size()){\n\tif(i==j)continue;\n\tif( range(c[i].fs.fs, c[j].fs.fs, c[j].fs.fs + c[j].sc) &&\n\t    range(c[i].fs.fs + c[i].sc, c[j].fs.fs, c[j].fs.fs + c[j].sc+1) &&\n\t    range(c[i].fs.sc, c[j].fs.sc, c[j].fs.sc + c[j].sc) &&\n\t    range(c[i].fs.sc + c[i].sc, c[j].fs.sc, c[j].fs.sc + c[j].sc+1) ){\n\t  f = true;\n\t  break;\n\t}\n      }\n\n      if(f){\n\tc.erase(c.begin()+i);\n\ti--;\n      }\n    }\n\n    rep(i,c.size()){\n      for(int y=c[i].fs.fs;y<c[i].fs.fs+c[i].sc;y++){\n\tfor(int x=c[i].fs.sc;x<c[i].fs.sc+c[i].sc;x++){\n\t  carpet[y][x].push_back(c[i]);\n\t}\n      }\n    }\n\n    int ans = 0;\n    while(true){\n      bool f = false;\n      rep(i,h)rep(j,w){\n\tif(rem[i][j] && carpet[i][j].size()==1){\n\t  f = true;\n\t  ans++;\n\t  tri t = carpet[i][j][0];\n\t  for(int y=t.fs.fs;y<t.fs.fs+t.sc;y++){\n\t    for(int x=t.fs.sc;x<t.fs.sc+t.sc;x++){\n\t      rem[y][x] = 0;\n\t    }\n\t  }\n\t}\n      }\n      if(!f)break;\n    }\n\n    depth = h*w;\n    search(0);\n    \n    cout << ans + depth  << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\n#include<map>\n#define MAX_W 10\n#define INF 1E9\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nconst ull B = 100000007;\nint w, h; \nint s[MAX_W][MAX_W]; //可延伸的最大正方形邊長\nint contain[MAX_W][MAX_W];\nbool same[MAX_W][MAX_W][MAX_W][MAX_W];\nint limit;\nint ct;\nunordered_map<ull, int> mp;\n\nstruct P{\n\tint x, y, size;\n\tP() {}\n\tP(int x, int y, int size) : x(x), y(y), size(size) {}\n\tbool operator < (const P& other) const{\n\t\treturn size < other.size;\n\t}\n};\nvoid show(vector<int>& cover){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tprintf(\"%d \", (cover[i] >> (w - 1 - j)) & 1);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\nvoid init(vector<int>& f){\n\tmemset(contain, 0, sizeof(contain));\n\tmemset(same, false, sizeof(same));\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\ts[i][j] = (f[i] >> (w - 1 - j)) & 1;\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tfor(int k = 0;; k++){\n\t\t\t\tbool ok = true;\n\t\t\t\tif(i + k < h && j + k < w){\n\t\t\t\t\tfor(int l = 0; ok && l <= k; l++){\n\t\t\t\t\t\tif(s[i + k][j + l] == 0 || s[i + l][j + k] == 0) ok = false;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\ts[i][j] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int a = 0; a < s[i][j]; a++){\n\t\t\t\tfor(int b = 0; b < s[i][j]; b++){\n\t\t\t\t\tcontain[i + a][j + b]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int a = 0; a < s[i][j] * s[i][j]; a++){\n\t\t\t\tint x1 = i + a / s[i][j], y1 = j + a % s[i][j];\n\t\t\t\tfor(int b = 0; b < s[i][j] * s[i][j]; b++){\n\t\t\t\t\tint x2 = i + b / s[i][j], y2 = j + b % s[i][j];\n\t\t\t\t\tsame[x1][y1][x2][y2] = same[x2][y2][x1][y1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\null calc_hash(vector<int>& f){\n\tull t = 0;\n\tfor(int i = 0; i < f.size(); i++){\n\t\tt = t * B + f[i];\n\t}\n\treturn t;\n}\nint greedy(vector<int> f){\n\tint res = 0;\n\tbool update;\n\tdo{\n\t\tupdate = false;\n\t\tint m_i, m_j, max = 0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(s[i][j] > 0){\n\t\t\t\t\tint tmp = 0, m = ((1 << s[i][j]) - 1) <<  (w - j - s[i][j]);\n\t\t\t\t\tfor(int k = 0; k < s[i][j]; k++){\n\t\t\t\t\t\ttmp += __builtin_popcount(f[i + k] & m);\n\t\t\t\t\t}\n\t\t\t\t\tif(max < tmp){\n\t\t\t\t\t\tmax = tmp;\n\t\t\t\t\t\tm_i = i, m_j = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max > 0){\n\t\t\tint m = ((1 << s[m_i][m_j]) - 1) << (w - m_j - s[m_i][m_j]);\n\t\t\tfor(int i = 0; i < s[m_i][m_j]; i++) f[m_i + i] &= ~m;\n\t\t\tres++;\n\t\t\tupdate = true;\n\t\t}\n\t}while(update);\n\treturn res;\n}\nint hstar(vector<int> f){\n\t//選取盡量多的點，其中每個集合最多只能有一個點被選中\n\tvector<P> ps, X;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif((f[i] >> (w - 1 - j)) & 1){\n\t\t\t\tps.push_back(P(i, j, contain[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(ps.begin(), ps.end());\n\tfor(int i = 0; i < ps.size(); i++){\n\t\tbool ok = true;\n\t\tint x1 = ps[i].x, y1 = ps[i].y;\n\t\tfor(int j = 0; j < X.size() && ok; j++){\n\t\t\tint x2 = X[j].x, y2 = X[j].y;\n\t\t\tif(same[x1][y1][x2][y2]) ok = false;\n\t\t}\n\t\tif(ok) X.push_back(ps[i]);\n\t}\n\treturn X.size();\n}\nint dfs(int num, vector<int> f, int idx){\n\tif(num + hstar(f) > limit) return INF;\n\t\n\t// printf(\"num = %2d  hstar = %2d   greedy = %2d\\n\", num,  hstar(f), greedy(f));\n\t// ull t = calc_hash(f);\n\t// if(mp.find(t) != mp.end() && mp[t] <= num) return INF;\n\t// mp[t] = num;\n\tct++;\n\t// if(ct % 10000 == 0) cout << ct << endl;\n\t\n\tvector<int> reset(f.begin(), f.end());\n\tfor(; idx < w * h; idx++){\n\t\tint i = idx / w, j = idx % w;\n\t\tint k = s[i][j];\n\t\tif(k > 0){\n\t\t\tint tmp = ((1 << k) - 1) << (w - j - k), n = 0;\n\t\t\tfor(int m = 0; m < k; m++){\n\t\t\t\tif((f[i + m] & (~tmp)) == f[i + m]) n++;\n\t\t\t\tf[i + m] &= ~tmp;\n\t\t\t}\n\t\t\tif(n < k){\n\t\t\t\tif(dfs(num + 1, f, idx + 1) < INF) return num;\n\t\t\t}\n\t\t\t//f.assign(reset.begin(), reset.end());\n\t\t\tfor(int m = 0; m < k; m++) f[i + m] = reset[i + m];\n\t\t\tif(((f[i] >> (w - 1 - j)) & 1) && n < k) break;\n\t\t}\n\t}\t\n\tbool check = true;\n\tfor(int i = 0; i < h && check; i++) check &= (f[i] == 0);\n\treturn (check ? num : INF);\n}\nint solve(vector<int>& f){\n\tinit(f);\n\tct = 0;\n\tfor(limit = greedy(f);; limit--){\n\t\t// printf(\"limit = %d\\n\", limit);\n\t\tmp.clear();\n\t\tif(dfs(0, f, 0) == INF) return limit + 1;\n\t}\n}\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tvector<int> f(h, 0);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tf[i] = 0;\n\t\t\tint a;\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> a;\n\t\t\t\tf[i] = (f[i] << 1) | a;\n\t\t\t}\n\t\t}\n\t\tcout << solve(f) << endl;\n\t\t// cout << \"ct = \" << ct << \"\\n\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ninline bool chmax(int &a, const int &b) { return (a<b)?(a=b,1):0;}\ninline bool chmin(int &a, const int &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x==w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint ans=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tint cy=sy[i][j],cx=sx[i][j];\n\t\t\trep(a,cy,cy+len[cy][cx])rep(b,cx,cx+len[cy][cx]) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,ans++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tans+=dfs(0,0,0,min_res);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint W, H;\n\nusing Carpet = map<pair<int, int>, int>;\n\nbool contain(auto l, auto r) {\n  auto y1 = l.first.first;\n  auto x1 = l.first.second;\n  auto s1 = l.second;\n  auto y2 = r.first.first;\n  auto x2 = r.first.second;\n  auto s2 = r.second;\n  if(x2 < x1) return false;\n  if(x1 + s1 < x2 + s2) return false;\n  if(y2 < y1) return false;\n  if(y1 + s1 < y2 + s2) return false;\n  return true;\n}\n\nCarpet maximal(auto carpet) {\n  Carpet res;\n  for(auto i: carpet) {\n    bool ok = true;\n    for(auto j: carpet) if(i != j) if(contain(j, i)) ok = false;\n    auto y = i.first.first;\n    auto x = i.first.second;\n    if(ok) res[make_pair(y, x)] = i.second;\n  }\n  return res;\n}\n\nint greedy(auto& P, auto& carpet) {\n  int res = 0;\n  vector<vector<int>> floor(H+2, vector<int>(W+2));\n  for(auto c: carpet) {\n    auto y = c.first.first;\n    auto x = c.first.second;\n    auto s = c.second;\n    for(auto i = y; i <= y + s; ++i) for(auto j = x; j <= x + s; ++j) ++floor[i][j];\n  }\n  set<pair<int, int>> uniq;\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(floor[i][j] == 1) uniq.emplace(i, j);\n  for(auto p: uniq) {\n    for(auto c = begin(carpet); c != end(carpet); ++c) {\n      auto y = c->first.first;\n      auto x = c->first.second;\n      auto s = c->second;\n      if(!contain(*c, make_pair(p, 0))) continue;\n      for(auto i = y; i <= y + s; ++i) for(auto j = x; j <= x + s; ++j) P[i][j] = 0;\n      carpet.erase(c);\n      ++res;\n      break;\n    }\n  }\n  return res;\n}\n\nbool dfs(int sy, int sx, auto P, const auto& carpet, int depth, int limit) {\n  int y, x;\n  for(y = sy; y <= H; ++y) {\n    for(x = (y==sy ? sx : 1); x <= W; ++x) {\n      if(carpet.count(make_pair(y, x))) break;\n      if(P[y][x] == 1) return false;\n    }\n    if(carpet.count(make_pair(y, x))) break;\n  }\n  if(y == H+1 || x == W+1) return true;\n  if(depth > limit) return false;\n  if(P[y][x] == 0) {\n    auto ny = y, nx = x + 1;\n    if(W < x) ++ny, nx = 1;\n    if(dfs(ny, nx, P, carpet, depth, limit)) return true;\n  }\n  auto cnt = 0;\n  for(auto i = y; i <= y + carpet.at(make_pair(y, x)); ++i) for(auto j = x; j <= x + carpet.at(make_pair(y, x)); ++j) if(P[i][j]) {\n    P[i][j] = 0;\n    ++cnt;\n  }\n  if(cnt == 0) return false;\n  return dfs(y, x, P, carpet, depth + 1, limit);\n}\n\nint main() {\n  while(cin >> W >> H, W | H) {\n    vector<vector<int>> P(H+2, vector<int>(W+2));\n    for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> P[i][j];\n\n    auto S = P;\n    for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] += S[i][j-1];\n    for(auto j = 1; j <= W; ++j) for(auto i = 1; i <= H; ++i) S[i][j] += S[i-1][j];\n\n    auto sum = [&](auto y1, auto x1, auto y2, auto x2) {return S[y2][x2] - S[y2][x1-1] - S[y1-1][x2] + S[y1-1][x1-1];};\n    auto full = [&](auto y1, auto x1, auto y2, auto x2) {return sum(y1, x1, y2, x2) == (y2 - y1 + 1) * (x2 - x1 + 1);};\n\n    Carpet carpet;\n    for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) {\n      for(auto k = 0; k < max(H, W); ++k) {\n        if(H < i+k || W < j+k) break;\n        if(!full(i, j, i+k, j+k)) break;\n        carpet[make_pair(i, j)] = k;\n      }\n    }\n\n    carpet = maximal(carpet);\n    auto invariant = greedy(P, carpet);\n\n    for(auto i = 0; i <= 100; ++i) {\n      if(!dfs(1, 1, P, carpet, 0, i)) continue;\n      cout << invariant + i << endl;\n      break;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\t\t\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(i-1>=0 && j-1>=0 && len[i][j] !=1 && len[i][j]+1 == len[i-1][j-1]) len[i][j]=0;\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\tint remain=0;\n\t\trep(i,h) remain+=popcount(board[i]);\n\t\tmin_res=remain;\n\t\tprintf(\"%d\\n\",dfs(0,0,0,remain)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#define MAX_W 10\n#define INF 1E9\n\nusing namespace std;\n\nint w, h; \nint f[MAX_W];\nint s[MAX_W][MAX_W]; //可延伸的最大正方形邊長\nint limit;\nint ct;\n\nvoid show(vector<int>& cover){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tprintf(\"%d \", ((f[i] ^ cover[i]) >> (w - 1 - j)) & 1);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\nvoid init(){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\ts[i][j] = (f[i] >> (w - 1 - j)) & 1;\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tfor(int k = 0;; k++){\n\t\t\t\tbool ok = true;\n\t\t\t\tif(i + k < h && j + k < w){\n\t\t\t\t\tfor(int l = 0; ok && l <= k; l++){\n\t\t\t\t\t\tif(s[i + k][j + l] == 0 || s[i + l][j + k] == 0) ok = false;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\ts[i][j] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint hstar(vector<int> cover){\n\tint res = 0;\n\tbool update;\n\tdo{\n\t\tupdate = false;\n\t\tint m_i, m_j, max = 0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(s[i][j] > 0){\n\t\t\t\t\tint tmp = 0, m = ((1 << s[i][j]) - 1) <<  (w - j - s[i][j]);\n\t\t\t\t\tfor(int k = 0; k < s[i][j]; k++){\n\t\t\t\t\t\ttmp += __builtin_popcount((f[i + k] ^ cover[i + k]) & m);\n\t\t\t\t\t}\n\t\t\t\t\tif(max < tmp){\n\t\t\t\t\t\tmax = tmp;\n\t\t\t\t\t\tm_i = i, m_j = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max > 0){\n\t\t\tint m = ((1 << s[m_i][m_j]) - 1) << (w - m_j - s[m_i][m_j]);\n\t\t\tfor(int i = 0; i < s[m_i][m_j]; i++) cover[m_i + i] |= m;\n\t\t\tres++;\n\t\t\tupdate = true;\n\t\t}\n\t}while(update);\n\treturn res;\n}\n\nint dfs(int num, vector<int> cover){\n\tif(num + hstar(cover) > limit) return INF;\n\n\n\tct++;\n\tbool check = true;\n\tvector<int> reset(cover.begin(), cover.end());\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tint k = s[i][j];\n\t\t\tif(k > 0){\n\t\t\t\tint tmp = ((1 << k) - 1) << (w - j - k), n = 0;\n\t\t\t\tfor(int m = 0; m < k; m++){\n\t\t\t\t\tif((cover[i + m] | tmp) == cover[i + m]) n++;\n\t\t\t\t\tcover[i + m] |= tmp;\n\t\t\t\t}\n\t\t\t\tif(n < k){\n\t\t\t\t\tcheck = false;\n\t\t\t\t\tif(dfs(num + 1, cover) < INF) return num;\n\t\t\t\t}\n\t\t\t\tcover.assign(reset.begin(), reset.end());\n\t\t\t}\n\t\t}\n\t}\n\treturn (check ? num : INF);\n}\nint solve(){\n\tinit();\n\tct = 0;\n\tvector<int> cover(h, 0);\n\tfor(limit = hstar(cover);; limit++){\n\t\t// printf(\"limit = %d\\n\", limit);\n\t\tif(dfs(0, cover) < INF) return limit;\n\t}\n\t// cout << hstar(cover) << endl;\n}\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tmemset(f, 0, sizeof(f));\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tf[i] = 0;\n\t\t\tint a;\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> a;\n\t\t\t\tf[i] = (f[i] << 1) | a;\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t\t// cout << \"ct = \" << ct << \"\\n\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ninline bool chmax(int &a, const int &b) { return (a<b)?(a=b,1):0;}\ninline bool chmin(int &a, const int &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+len[cy][cx]) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct state {\n\tvector<int> b;\n\tint dist, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.dist + s1.cost > s2.dist + s2.cost;\n}\nint H, W, a[12][12], cnt, xa[10009], ya[10009], xb[10009], yb[10009], popcount[1033];\nint main() {\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tpopcount[j] = popcount[j - (1 << i)] + 1;\n\t\t}\n\t}\n\twhile (cin >> W >> H, H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = i + 1; k <= H; k++) {\n\t\t\t\t\tfor (int l = j + 1; l <= W; l++) {\n\t\t\t\t\t\tif (k - i != l - j) continue;\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor (int x = i; x < k; x++) {\n\t\t\t\t\t\t\tfor (int y = j; y < l; y++) {\n\t\t\t\t\t\t\t\tif (a[x][y] == 0) flag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\txa[cnt] = i;\n\t\t\t\t\t\t\tya[cnt] = j;\n\t\t\t\t\t\t\txb[cnt] = k;\n\t\t\t\t\t\t\tyb[cnt] = l;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> que;\n\t\tvector<int> sbit(H, 0); int scnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (a[i][j] == 1) scnt++;\n\t\t\t}\n\t\t}\n\t\tque.push(state{ sbit, 0, scnt });\n\t\tbool flag = false;\n\t\twhile (!que.empty() && !flag) {\n\t\t\tstate u = que.top(); que.pop();\n\t\t\tfor (int i = 0; i < cnt && !flag; i++) {\n\t\t\t\tvector<int> z = u.b;\n\t\t\t\tfor (int j = xa[i]; j < xb[i]; j++) {\n\t\t\t\t\tz[j] |= (1 << yb[i]) - (1 << ya[i]);\n\t\t\t\t}\n\t\t\t\tint rcnt = 0;\n\t\t\t\tfor (int j = 0; j < H; j++) rcnt += popcount[z[j]];\n\t\t\t\trcnt = scnt - rcnt;\n\t\t\t\tif (rcnt == 0) {\n\t\t\t\t\tcout << u.dist + 1 << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tque.push(state{ z, u.dist + 1, rcnt });\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint w, h, d[12][12], ans;\n\nvoid solve(int x, int y, int c){\n\tif(ans < INF) return;\n\tif(x == w && y == h-1){\n\t\tchmin(ans, c);\n\t\treturn ;\n\t}\n\tif(x == w){\n\t\ty ++;\n\t\tx = 0;\n\t}\n\tif(d[y][x] != 1) solve(x+1, y, c);\n\tif(ans < INF) return;\n\tif(d[y][x] != 0){\n\t\tint r = 1;\n\t\tfor(;;r++){\n\t\t\tint f = 1;\n\t\t\tREP(i, r)REP(j, r) if(d[y+i][x+j] == 0) f = 0;\n\t\t\tif(!f) break;\n\t\t}\n\t\tr --;\n\t\t\n\t\t// check pruning\n\t\tint pos[3][2] = {{y-1,x-1},{y-1,x},{y,x-1}};\n\t\tREP(k, 3){\n\t\t\tif(pos[k][0] < 0 || pos[k][1] < 0) continue;\n\t\t\tint f = 1;\n\t\t\tREP(i, r+1)REP(j, r+1) if(d[pos[k][0]+i][pos[k][1]+j] == 0) f = 0;\n\t\t\tif(f) return;\n\t\t}\n\t\tvector<pii> ch;\n\t\tREP(i, r)REP(j, r){\n\t\t\tif(d[y+i][x+j] == 1) ch.push_back(pii(y+i, x+j));\n\t\t\td[y+i][x+j] = -1;\n\t\t}\n\t\tif(ch.empty()) return ;\n\t\tsolve(x+1, y, c+1);\n\t\tREP(i, ch.size()) d[ch[i].first][ch[i].second] = 1;\n\t}\n\t\n}\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> w >> h, w){\n\t\tmemset(d, 0, sizeof(d));\n\t\tREP(i, h)REP(j, w) cin >> d[i][j];\n\t\tans = INF;\n\t\tsolve(0, 0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<algorithm>\n\nconst int N = 11;\nconst int inf = 1<<27;\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\n\nusing namespace std;\n\nint H,W;\nstatic int M[N][N];\nstatic int maxSizes[N][N][4];\nint oneCount;\nint minHW;\nint ans;\nint greedy_ans;\nint depth;\nint maxSize;\n\ninline int getHeuristic();\nvoid calc();\nvoid solve(int pos);\n\ninline int getHeuristic()\n{\n  int msz=maxSize;\n  msz *= msz;\n  return oneCount/msz + (oneCount%msz>0);\n}\n\nstruct Cand{\n  int i,j;\n  Cand():i(0),j(0){}\n  Cand(int ci, int cj):i(ci),j(cj){}\n  bool operator<(const Cand& t)const{\n    return (i==t.i)?(j<t.j):(i<t.i);\n  }\n};\n\nint cand_num;\nCand cands[N*N];\n\nvoid calc(){\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 1){\n\toneCount++;\n\tcands[cand_num++] = Cand(i,j);\n      }\n      for(int k = 0; k < 4; ++k){\n\tint size = 0;\n\tfor(size = 1; size <= minHW; ++size){\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t--size;\n\t\tgoto next;\n\t      }\n\t    }\n\t  }\n\t  if(k==0){\n\t    if(i-size<0||j+size>=W)break;\n\t  }else if(k==1){\n\t    if(i+size>=H||j+size>=W)break;\n\t  }else if(k==2){\n\t    if(i+size>=H||j-size<0)break;\n\t  }else{\n\t    if(i-size<0||j-size<0)break;\n\t  }\n\t}\n      next:;\n\tmaxSizes[i][j][k] = size;\n\tif(k==1){\n\t  if(size>1){\n\t    maxSize = max( maxSize, size );\n\t  }\n\t}\n      }\n    }\n  }\n  sort(cands,cands+cand_num);\n  return ;\n}\n\nvoid solve_greedy()\n{\n  // completed.\n  if(oneCount==0){\n    greedy_ans = min(greedy_ans, depth);\n    return ;\n  }\n\n  // embed carpet greedy\n  int maxOneCount = -1;\n  int maxp,maxk,maxsz;\n  for(int p = 0; p < cand_num; ++p){\n    int i = cands[p].i;\n    int j = cands[p].j;\n    if( M[i][j] == 1 ){\n      for(int k = 0; k < 4; ++k){\n\tint cnt = 0;\n\tint size = maxSizes[i][j][k];\n\tfor(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t  for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t    if(M[m][n]==1){\n\t      ++cnt;\n\t    }\n\t  }\n\t}\n\tif(maxOneCount<cnt){\n\t  maxp = p;\n\t  maxk = k;\n\t  maxsz = size;\n\t  maxOneCount = cnt;\n\t}\n      }\n    }\n  }\n  int i = cands[maxp].i;\n  int j = cands[maxp].j;\n  int k = maxk;\n  int size = maxsz;\n  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n      if(M[m][n]==1){\n\tM[m][n]=depth;\n\t--oneCount;\n      }\n    }\n  }\n  ++depth;\n  solve_greedy();\n  --depth;\n  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n      if( M[m][n] == depth ){\n\tM[m][n]=1;\n\t++oneCount;\n      }\n    }\n  }\n  return ;\n}\n\nvoid solve(int pos){\n  /*\n    printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W, getHeuristic());\n    for(int k = 0; k < H; ++k){\n      for(int l = 0; l < W; ++l){\n\tif(l>0)putchar(' ');\n\tprintf(\"%2d\", M[k][l]);\n      }\n      putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  if(oneCount==0){\n    ans = min(ans, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic()>=ans){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < cand_num; ++p){\n    int i = cands[p].i;\n    int j = cands[p].j;\n    int size = maxSizes[i][j][1];\n    int valid=0;\n    for(int m = i; m<size+i; m++){\n      for(int n = j; n<size+j; n++){\n\tif(M[m][n]==1){\n\t  valid=1;\n\t  --oneCount;\n\t  M[m][n]=depth;\n\t}\n      }\n    }\n    if( valid ){\n      ++depth;\n      solve(p+1);\n      --depth;\n    }\n    for(int m = i; m<size+i; m++){\n      for(int n = j; n<size+j; n++){\n\tif( M[m][n] == depth ){\n\t  ++oneCount;\n\t  M[m][n]=1;\n\t}\n      }\n    }\n    if( M[i][j] > 1 )\n      solve(p+1);\n    return ;\n  }\n}\n\nint main()\n{\n  while(true){\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    minHW = min(H,W);\n    oneCount = 0;\n    cand_num = 0;\n    ans=inf;\n    greedy_ans = inf;\n    depth=2;\n    maxSize = 1;\n\n    calc();\n\n    solve_greedy();\n    ans = greedy_ans;\n    solve(0);\n\n    printf(\"%d\\n\", ans-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nint H,W,mincost;\nint P[10][10],bin[10],bc[(1<<10)];\nint put[10][10],weight[10][10],counter[10][10];\n\nbool can_put(int len,int x,int y){\n  REP(i,y,y+len)REP(j,x,x+len) if( !P[i][j] ) return false;\n  return true;\n}\n\nvoid dfs(int cur,int cost,int remain){\n\n  if( cost >= mincost ) return;\n  if( cost + ((remain>0)?1:0) >= mincost ) return;\n\n  if( cur >= H*W ) {\n    mincost = min(mincost,cost);\n    return;\n  }\n\n  int x = cur % W, y = cur / W;\n//  if( cost + max(0,weight[y][x]-4) >= mincost ) return;\n\n  if( !P[y][x] || counter[y][x] == 1 ) {\n    dfs(cur+1,cost,remain);\n    return;\n  }\n\n  if( (bin[y]>>x) & 1 ) dfs(cur+1,cost,remain);\n\n  int len = put[y][x];\n  int bitmask = ((1<<len)-1)<<x;\n  int buf[len];\n  int add = 0, nremain = remain;\n  rep(j,len) {\n    buf[j] = bin[y+j];\n    add += len - bc[((1<<len)-1)&(bin[y+j]>>x)];\n    bin[y+j] |= bitmask;\n  }\n  nremain -= add;\n  if( add ) dfs(cur+1,cost+1,nremain);\n  rep(j,len) bin[y+j] = buf[j];\n\n}\n\nint par[110];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint find(int x){\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\ninline void unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = par[y];\n}\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\nint main(){\n\n  rep(i,(1<<10)) bc[i] = __builtin_popcount(i);\n\n  while( scanf(\"%d%d\",&W,&H), W | H ){\n\n    rep(i,H){\n      bin[i] = 0;\n      rep(j,W){\n        cin >> P[i][j];\n        put[i][j] = 0;\n      }\n    }\n\n\n    rep(i,H*W) par[i] = i;\n\n    rep(i,H)rep(j,W)if(!P[i][j])rep(k,4){\n      int nx = j + dx[k], ny = i + dy[k];\n      if( !isValid(nx,ny) ) continue;\n      if( !P[ny][nx] ) unit(j+i*W,nx+ny*W);\n    }\n\n    rep(i,H)rep(j,W)weight[i][j] = 0;\n\n    set<int> S;\n    bool first = false;\n    for(int i=H-1;i>=0;i--) for(int j=W-1;j>=0;j--) {\n        if( P[i][j] ) first = true;\n        if( first && !P[i][j] ) S.insert(find(j+i*W));\n        weight[i][j] = S.size();\n      }\n\n    rep(y,H) rep(x,W) if( P[y][x] ) {\n      for(int len=min(H,W);len>=1;len--){\n        if( x + len - 1 < W && y + len - 1 < H ) {\n          if( can_put(len,x,y) ){\n            put[y][x] = len;\n            break;\n          }\n        }\n      }\n    }\n\n    rep(i,H)rep(j,W) counter[i][j] = 0;\n    rep(i,H)rep(j,W)if(P[i][j]){\n      REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n        counter[y][x]++;\n      }\n    }\n\n    rep(i,H){\n      rep(j,W){\n        if( counter[i][j] == 1 ){\n          REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n            bin[y] |= (1<<x);\n          }\n        }\n      }\n    }\n\n    int add = 0;\n    int remain = 0;\n    mincost = 0;\n    rep(i,H)rep(j,W)remain += ((bin[i]>>j)&1),mincost += P[i][j];\n    remain = mincost - remain;\n    dfs(0,0,remain);\n\n    rep(i,H)rep(j,W)if(counter[i][j]==1)add++;\n    cout << mincost+add << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nstruct state\n{\n\tvector<string> v;\n\n\tint dist1;\n\tint dist2;\n\n\tstate(vector<string> v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 < s2.dist1 + s2.dist2; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 > s2.dist1 + s2.dist2; }\n\nint W, H; vector<string> start;\n\nmap<vector<string>, bool> M;\n\nint getdistance(vector<string> v)\n{\n\tint ret = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (v[i][j] == '.')\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tM.clear();\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tstart = vector<string>(H);\n\n\t\tfor (int i = 0; i < H; i++) cin >> start[i];\n\n\t\tpriority_queue<state, vector<state>, greater<state> > que;\n\n\t\tque.push(state(start, 0, getdistance(start))); M[start] = true;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tstate s1 = que.top(); que.pop();\n\n\t\t\tif (s1.dist2 == 0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", s1.dist1); break;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= 10; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= H - i; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= W - i; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<string> v2 = s1.v;\n\n\t\t\t\t\t\tbool flag = true;\n\n\t\t\t\t\t\tfor (int l = j; l < j + i; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = k; m < k + i; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (v2[i][j] == '*')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflag = true; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tv2[i][j] = '+';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flag) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!M[v2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tM[v2] = true;\n\n\t\t\t\t\t\t\tque.push(state(v2, s1.dist1 + 1, getdistance(v2)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n#define FOR(i, b, e) for ( int i = b; i <= e; i++ )\n#define rep(i, n) for ( int i = 0; i < (int)n; i++)\n#define MAX 10\n\nint cnt, H, W, limit, maxw;\nint T[MAX][MAX], K[MAX][MAX], C[MAX][MAX], X[MAX][MAX];\nvector<pair<int, int> > v;\n\nint MD(){\n  int sum = 0;\n  rep(i, H) rep(j, W){\n    if ( C[i][j] && X[i][j] == 0 ) sum++;\n  }\n  return sum/(maxw*maxw);\n}\n\nbool dfs(int pos, int cost){\n  bool solved = true;\n  rep(i, H) rep(j, W) if ( C[i][j] && X[i][j] == 0 ) solved = false;\n  if ( solved ) return true;\n  if ( pos >= v.size() ) return false;\n  if ( cost + MD() >= limit ) return false;\n\n  for ( int i = v[pos].first+1; i < H; i++ ) rep(j, W){\n      if ( C[i][j] && X[i][j] == 0 ) return false;\n    }\n\n  int tmp[MAX][MAX];\n\n  if ( dfs(pos+1, cost) ) return true;\n\n  rep(i, H) rep(j, W) tmp[i][j] = X[i][j];\n  int pi = v[pos].first;\n  int pj = v[pos].second;\n  int w = T[pi][pj];\n  FOR(y, pi-w+1, pi) FOR(x, pj-w+1, pj) X[y][x]++;\n\n  if ( dfs(pos+1, cost+1) ) return true;\n  rep(i, H) rep(j, W) X[i][j] = tmp[i][j];\n\n  return false;\n}\n\nint idp(){\n  if ( maxw == 0 ) return 0;\n  for ( limit = MD(); limit < 100; limit++){\n    if ( dfs(0, 0) ) return limit;\n  }\n}\n\nvoid compute(){\n\n  bool U[MAX][MAX], V[MAX][MAX];\n\n  rep(i, H) rep(j, W) U[i][j] = true;\n  rep(i, H) rep(j, W) V[i][j] = false;\n  rep(i, H) rep(j, W) T[i][j] = K[i][j] = X[i][j] = 0;\n  rep(i, H) T[i][0] = (C[i][0])?1:0;\n  rep(j, W) T[0][j] = (C[0][j])?1:0;\n\n  FOR(i, 1, H-1) FOR(j, 1, W-1){\n    if ( C[i][j] ){\n      T[i][j] = min(T[i-1][j-1], min(T[i-1][j], T[i][j-1])) +1;\n    } else T[i][j] = 0;\n  }\n\n  rep(i, H) rep(j, W){\n    int w = T[i][j];\n    FOR(pi, i-(w-1), i) FOR(pj, j-(w-1), j) {\n      if ( i == pi && j == pj ) continue;\n      int l = max(i-pi, j-pj);\n      if ( w-l >= T[pi][pj] ) U[pi][pj] = false;\n    }\n  }\n\n  rep(i, H) rep(j, W){\n    if ( U[i][j] && T[i][j] ){\n      FOR(y, i-T[i][j]+1, i) FOR(x, j-T[i][j]+1, j) K[y][x]++;\n    }\n  }\n\n  v.clear();\n  rep(i, H) rep(j, W){\n    if ( U[i][j] && T[i][j] ){\n      bool f = false;\n      FOR(y, i-T[i][j]+1, i) FOR(x, j-T[i][j]+1, j){\n\tif ( K[y][x] == 1 ) f = true;\n      }\n      if ( f ){\n\tFOR(y, i-T[i][j]+1, i) FOR(x, j-T[i][j]+1, j) X[y][x]++;\n\tcnt++;\n\tT[i][j] = 0;\n      }\n    }\n  }\n  maxw = 0;\n  rep(i, H) rep(j, W){\n    if ( T[i][j] > 0 && U[i][j]){\n      maxw = max(maxw, T[i][j]);\n      v.push_back(make_pair(i, j));\n    }\n  }\n\n  reverse(v.begin(), v.end());\n}\n\nmain(){\n  while( cin >> W >> H ){\n    if ( W == 0 && H == 0 ) break;\n    rep(i, H) rep(j, W) cin >> C[i][j];\n    cnt = 0;\n    compute();\n    cout << idp() + cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n  int W, H;\n  while(cin >> W >> H, W) {\n\n    int p[10][10];\n    bitset< 100 > mat;\n\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        cin >> p[i][j];\n        mat[i * W + j] = p[i][j];\n      }\n    }\n\n    vector< bitset< 100 > > st;\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        for(int k = min(H - i, W - j); k >= 1; k--) {\n          bool flag = true;\n          for(int l = 0; l < k; l++) {\n            for(int m = 0; m < k; m++) flag &= p[i + l][j + m];\n          }\n          if(flag) {\n            bitset< 100 > beet;\n            for(int l = 0; l < k; l++) {\n              for(int m = 0; m < k; m++) beet[(i + l) * W + (j + m)] = 1;\n            }\n            st.emplace_back(beet);\n            break;\n          }\n        }\n      }\n    }\n\n\n    vector< bitset< 100 > > sq;\n    for(auto &p : st) {\n      bool flag = false;\n      for(auto &q : st) {\n        if(p == q) continue;\n        if((p & q) == p) {\n          flag = true;\n          break;\n        }\n      }\n      if(!flag) sq.emplace_back(p);\n    }\n\n    int initial = 0;\n    bool update = true;\n    while(update) {\n      int sg[100] = {};\n      update = false;\n      for(auto &q : sq) {\n        for(int i = 0; i < 100; i++) if(mat[i]) sg[i] += q[i];\n      }\n      vector< bitset< 100 > > nextQ;\n      vector< int > fg(sq.size(), 1);\n      for(int j = 0; j < sq.size(); j++) {\n        for(int i = 0; i < 100; i++) {\n          if(sq[j][i] && sg[i] == 1) {\n            mat &= ~sq[j];\n            ++initial;\n            fg[j] = false;\n            update = true;\n            goto beet;\n          }\n        }\n      }\n      beet:;\n      for(int i = 0; i < sq.size(); i++) {\n        if(fg[i]) nextQ.emplace_back(sq[i]);\n      }\n      sq.swap(nextQ);\n    }\n\n    cout << initial << endl;\n    for(int i = 0; i < H; i++) {\n      for(int j = 0 ; j < W; j++) {\n        cout << mat[i * W+ j];\n      }\n      cout << endl;\n    }\n    continue;\n\n    queue< bitset< 100 > > que;\n    unordered_map< bitset< 100 >, int > cost;\n    cost[mat] = 0;\n    que.emplace(mat);\n    while(!que.empty()) {\n      auto p = que.front();\n      int now = cost[p];\n      que.pop();\n      if(p.none()) {\n        cout << initial + now << endl;\n        break;\n      }\n      for(auto &that : sq) {\n        if((p & that).any()) {\n          auto q = p & ~that;\n          if(cost.count(q)) continue;\n          cost[q] = now + 1;\n          que.emplace(q);\n        }\n      }\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//???????????????\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nconst int MX=100;\ntypedef bitset<MX> BS;\nint H,W,N;\nint ans;\nbool used[MX];\nvector<BS> cs;\nbool incl(BS& a,BS& b){return (a&b)==b;}\n\nvoid dfs(BS now,int t){\n//\tprintf(\"dfs\");\n//\tshow(now);\n//\tshow(t);\n\tif(ans<=t) return;\n\tif(now.none()){\n\t\tchmin(ans,t);\n\t\treturn;\n\t}\n\tint mnway=MX,arg=-1;\n\trep(i,H*W) if(now[i]){\n\t\tint cnt=0;\n\t\trep(j,N) if(!used[j]){\n\t\t\tif(cs[j][i]) cnt++;\n\t\t}\n\t\tif(cnt<mnway){\n\t\t\tcnt=mnway;\n\t\t\targ=i;\n\t\t}\n\t}\n\tassert(arg>=0);\n\trep(i,N) if(!used[i]&&cs[i][arg]){\n\t\tdfs(now&(~cs[i]),t+1);\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>H;\n\t\tif(H==0) break;\n\t\tcs.clear();\n\t\tBS s;\n\t\trep(i,H) rep(j,W){\n\t\t\tbool x;\n\t\t\tcin>>x;\n\t\t\ts.set(i*W+j,x);\n\t\t}\n\t\trep(i,H) rep(j,W){\n\t\t\tfor(int d=10;d>=1;d--){\n\t\t\t\tbool can=1;\n\t\t\t\tif(i+d-1>=H||j+d-1>=W) can=0;\n\t\t\t\tif(can){\n\t\t\t\t\trep(x,d) rep(y,d) if(!s[(i+x)*W+j+y]) can=0;\n\t\t\t\t}\n\t\t\t\tif(can){\n\t\t\t\t\tBS b;\n\t\t\t\t\trep(x,d) rep(y,d) b.set((i+x)*W+j+y);\n\t\t\t\t\tcs.pb(b);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tN=cs.size();\n\t\tbool gomi[MX]={};\n\t\trep(i,N) rep(j,N) if(i!=j){\n\t\t\tif(incl(cs[i],cs[j])) gomi[j]=1;\n\t\t}\n\t\tvector<BS> tmp;\n\t\trep(i,N) if(!gomi[i]) tmp.pb(cs[i]);\n\t\tcs=tmp;\n\t\tN=cs.size();\n//\t\trep(i,N) show(cs[i]);\n\t\tans=N;\n\t\trep(i,N) used[i]=0;\n\t\tdfs(s,0);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,n,A[11][11],ans,cnt;\nbitset<100> B[11][11],p;\n\nvoid dfs(int d,bitset<100> s,int sco){\n  if(d==n){\n    ans=min(ans,sco);\n    return;\n  }\n  cnt++;\n  if(cnt>=15000000)return;\n  if(ans<=sco)return;\n  if(!A[d/w][d%w])dfs(d+1,s,sco);\n  else{\n    int y=d/w;\n    int x=d%w;\n    if((B[y][x]&s).any()){\n      p&=0;\n      p.set(y*10+x);//(y*100+x);\n      if(!(s&p).any())dfs(d+1,s,sco);\n      dfs(d+1,(B[y][x]|s)^B[y][x],sco+1);\n    }\n    else dfs(d+1,s,sco);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    memset(A,0,sizeof(A));\n    r(i,11)r(j,11)B[i][j]&=0;\n    n=h*w;\n    bitset<100> b;\n    r(i,h)r(j,w)cin>>A[i][j];\n    r(i,h)r(j,w)if(A[i][j]){\n      int sum=1;\n      for(;;sum++){\n        int f=0;\n        for(int y=i;y<i+sum;y++){\n          for(int x=j;x<j+sum;x++){\n            if(A[y][x]==0)f++;\n          }\n        }\n        if(f){\n          sum--;\n          break;\n        }\n      }\n      bitset<100>tmp;\n      for(int y=i,k=0;k<sum;k++,y++){\n        for(int x=j,l=0;l<sum;l++,x++){\n          tmp.set(y*10+x);\n        }\n      }\n      b.set(i*10+j);\n      B[i][j]=tmp;\n    }\n    ans=100;\n    cnt=0;\n    dfs(0,b,0);\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint field[10][10];\nint maxsize[10][10];\n\nint main(){\n\twhile(true){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){ break; }\n\t\tint remains = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tremains += field[i][j];\n\t\t\t\tmaxsize[i][j] = field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = h - 2; i >= 0; --i){\n\t\t\tfor(int j = w - 2; j >= 0; --j){\n\t\t\t\tif(maxsize[i][j]){\n\t\t\t\t\tmaxsize[i][j] += min(\n\t\t\t\t\t\tmin(maxsize[i + 1][j], maxsize[i][j + 1]), maxsize[i + 1][j + 1]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\twhile(remains > 0){\n\t\t\tint x = 0, y = 0, num = 0;\n\t\t\tfor(int i = 0; i < h; ++i){\n\t\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\t\tint fill = 0;\n\t\t\t\t\tfor(int k = i + maxsize[i][j] - 1; k >= i; --k){\n\t\t\t\t\t\tfor(int l = j + maxsize[i][j] - 1; l >= j; --l){\n\t\t\t\t\t\t\tfill += field[k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(fill > num){\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tnum = fill;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = y + maxsize[y][x] - 1; k >= y; --k){\n\t\t\t\tfor(int l = x + maxsize[y][x] - 1; l >= x; --l){\n\t\t\t\t\tfield[k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tremains -= num;\n\t\t\t++answer;\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <tuple>\nusing namespace std;\n\nstruct State {\n\tint a[10][10];\n};\n\nchar c[10][10]; int p[10][10], H, W, mindep, cnts;\n\nint range(int sx, int sy, int gx, int gy) {\n\tint cnt = 0;\n\tfor (int i = sx; i < gx; i++) {\n\t\tfor (int j = sy; j < gy; j++) {\n\t\t\tif (c[i][j] == '0') cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\nint range2(int sx, int sy, int gx, int gy, State G) {\n\tint cnt = 0;\n\tfor (int i = sx; i < gx; i++) { if (G.a[i][sy] == 0) cnt++; }\n\tfor (int i = sy; i < gy; i++) { if (G.a[sx][i] == 0) cnt++; }\n\treturn cnt;\n}\n\nState nurie(State P, int cx, int cy) {\n\tfor (int i = cx; i < cx + p[cx][cy]; i++) {\n\t\tfor (int j = cy; j < cy + p[cx][cy]; j++) P.a[i][j] = 1;\n\t}\n\treturn P;\n}\n\nlong long hash_value(State I) {\n\tlong long mod = 2555555555555555555LL, II = 0, J = 1;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (I.a[i][j] == 1) II += J; J *= 2;\n\t\t\tif (II >= mod) II -= mod;\n\t\t\tif (J >= mod) J -= mod;\n\t\t}\n\t}\n\treturn II;\n}\n\nmap<tuple<int, int, int, long long>, int>M;\n\nvoid dfs(int cx, int cy, int depth, State S) {\n\tlong long K = hash_value(S);\n\tif (M[make_tuple(cx, cy, depth, K)] == 1) return;\n\tM[make_tuple(cx, cy, depth, K)] = 1;\n\tcnts++;\n\tif (depth == mindep) return;\n\tif (cx == H) {\n\t\tmindep = min(mindep, depth);\n\t\treturn;\n\t}\n\tint nx = cx, ny = cy + 1; if (ny == W) { ny = 0; nx++; }\n\tif (c[cx][cy] == '0') {\n\t\tdfs(nx, ny, depth, S);\n\t}\n\telse {\n\t\tif (S.a[cx][cy] == 0) {\n\t\t\tState V = nurie(S, cx, cy);\n\t\t\tdfs(nx, ny, depth + 1, V);\n\t\t}\n\t\telse if (range2(cx, cy, cx + p[cx][cy], cy + p[cx][cy], S) == 0) {\n\t\t\tdfs(nx, ny, depth, S);\n\t\t}\n\t\telse {\n\t\t\tdfs(nx, ny, depth, S);\n\t\t\tState V = nurie(S, cx, cy);\n\t\t\tdfs(nx, ny, depth + 1, V);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H; M.clear(); mindep = (1 << 30); if (H == 0 && W == 0) break;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> c[i][j];\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 1; k <= min(H - i, W - j); k++) {\n\t\t\t\t\tif (range(i, j, i + k, j + k) >= 1) break;\n\t\t\t\t\tp[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState S; for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) S.a[i][j] = 0; }\n\t\tdfs(0, 0, 0, S);\n\t\tcout << mindep << endl;\n\t}\n\t//cout << \"Totalcount : \" << cnts << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\ninline void copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\ninline void recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\t//ans = min(ans,info.num);\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\ninline void func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt w,h;\nInt cnt,sum,ans,tmp;\nInt a[20][20];\nInt us[20][20];\nInt dp[20][20];\nInt pn[20][20];\nvoid inc(Int y,Int x){\n  cnt+=!us[y][x];\n  us[y][x]++;\n}\nvoid dec(Int y,Int x){\n  us[y][x]--;\n  cnt-=!us[y][x];\n}\nvoid show(){\n  cout<<cnt<<\" \"<<sum<<\":\"<<tmp<<endl;\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      cout<<us[i][j]<<\" \\n\"[j==w-1];\n  cout<<endl;\n}\n\nvoid dfs(Int y,Int x){\n  Int ny=y+(x+1)/w,nx=(x+1)%w;\n  if(ny==h||tmp+1>=ans) return;\n  \n  if(us[y][x]) dfs(ny,nx);\n  if(!dp[y][x]) return;\n  \n  Int bc=cnt,k=dp[y][x];\n  for(Int i=0;i<k;i++)\n    for(Int j=0;j<k;j++)\n      inc(y+i,x+j);\n\n  if(bc<cnt){\n    tmp++;\n    if(cnt==sum) ans=min(ans,tmp);\n    else if(tmp+1<ans)  dfs(ny,nx);\n    tmp--;\n  }\n  \n  for(Int i=0;i<k;i++)\n    for(Int j=0;j<k;j++)\n      dec(y+i,x+j);\n}\n\nsigned main(){\n  while(cin>>w>>h,w){\n    \n    cnt=sum=0;\n    memset(a,0,sizeof(a));\n    memset(us,0,sizeof(us));\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tcin>>a[i][j];\n\tsum+=a[i][j];\n\tus[i][j]=!a[i][j];\n      }\n    }\n    \n    memset(dp,0,sizeof(dp));\n    for(Int i=h-1;i>=0;i--)\n      for(Int j=w-1;j>=0;j--)\n\tdp[i][j]=a[i][j]*(min({dp[i][j+1],dp[i+1][j],dp[i+1][j+1]})+1);\n    \n    for(Int i=h-1;i>=0;i--)\n      for(Int j=w-1;j>=0;j--)\n\tif(dp[i][j]==dp[i+1][j+1]+1)\n\t  dp[i+1][j+1]=0;\n    \n    memset(pn,0,sizeof(pn));\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tfor(Int k=0;k<dp[i][j];k++)\n\t  for(Int l=0;l<dp[i][j];l++)\n\t    pn[i+k][j+l]++;\n\n    Int pre=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tif(dp[i][j]&&pn[i][j]==1){\n\t  pre++;\n\t  for(Int k=0;k<dp[i][j];k++)\n\t    for(Int l=0;l<dp[i][j];l++)\n\t      inc(i+k,j+l);\n\t}\n      }\n    }\n\n    if(0){\n      cout<<pre<<\" \"<<sum<<endl;\n      for(Int i=0;i<h;i++)\n\tfor(Int j=0;j<w;j++)\n\t  cout<<dp[i][j]<<\" \\n\"[j==w-1];\n      cout<<flush;\n\n      show();\n    }\n\n    ans=w*h*(cnt!=sum);tmp=0;\n    dfs(0,0);\n    \n    cout<<pre+ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\n\nint H, W, C, L;\nvector<pair<int, int> > P;\nmap<pair<int, int>, vector<int> > M;\nvector<vector<int> > B;\nvector<tuple<int, int, int> > S;\n\nvoid dfs(int pos, int sum, int &res){\n  // cout << P[pos] <<\" \" << B << \" \" << pos << \" \" << sum << endl;\n  if (pos == int(P.size())){\n    // if (sum < res) cout << sum << endl;\n    res = min(res, sum);\n  } else if (sum + (C + L * L - 1) / (L * L) >= res){\n    return;\n  } else if (B[P[pos].first][P[pos].second] == 0){\n    dfs(pos + 1, sum, res);      \n  } else {\n    vector<vector<int> > OLD_B = B;\n    vector<pair<int, int> > order;\n    for (int ind : M[P[pos]]){\n      int score = 0;\n      int h, w, d;\n      tie(h, w, d) = S[ind];\n      REP(i, d) REP(j, d) if (B[h + i][w + j] == 1) score++;\n      order.push_back(make_pair(-score, ind));\n    }\n    sort(ALL(order));\n    \n    for (auto p : order){\n      int ind = p.second;\n      int h, w, d;\n      tie(h, w, d) = S[ind];\n      REP(i, d) REP(j, d) if (B[h + i][w + j] == 1){\n        B[h + i][w + j] = 0;\n        C--;\n      }\n      \n      dfs(pos + 1, sum + 1, res);\n      \n      REP(i, d) REP(j, d) if (OLD_B[h + i][w + j] == 1){\n        B[h + i][w + j] = OLD_B[h + i][w + j];\n        C++;\n      }\n    }\n  }\n}\n\nint main(){\n  while (cin >> W >> H && W + H){\n    vector<vector<int> > board(H, vector<int>(W));\n    vector<tuple<int, int, int> > squares;\n\n    REP(h, H) REP(w, W) cin >> board[h][w];\n    REP(h, H) REP(w, W) REP2(d, 1, H + 1) if (h + d <= H && w + d <= W){\n      bool ok = true;\n      REP(i, d) REP(j, d) if (board[h + i][w + j] == 0) ok = false;\n      if (ok) squares.push_back(make_tuple(h, w, d));\n    }\n    \n    vector<int> use(squares.size(), true);\n    REP(i, squares.size()) {\n      REP(j, squares.size()) if (use[i] && use[j] && i != j){\n        int h1, h2, w1, w2, d1, d2;\n        tie(h1, w1, d1) = squares[j];\n        tie(h2, w2, d2) = squares[i];\n        if (h1 <= h2 && w1 <= w2 && h2 + d2 <= h1 + d1 && w2 + d2 <= w1 + d1){\n          use[i] = false;\n        }\n      }\n    }\n    S.clear();\n    P.clear();\n    M.clear();\n    B = board;\n    C = 0;\n    REP(i, squares.size()) if (use[i]) S.push_back(squares[i]);    \n\n    REP(h, H) REP(w, W) if (board[h][w] == 1) {\n      P.push_back(make_pair(h, w));\n      C++;\n    }\n    REP(i, S.size()) REP(j, S.size()) if (j > 0){\n      if (get<2>(S[j - 1]) < get<2>(S[j])) swap(S[j - 1], S[j]);\n    }\n    \n    REP(i, S.size()){\n      int h, w, d;\n      tie(h, w, d)  = S[i];\n      REP(j, d) REP(k, d) M[make_pair(h + j, w + k)].push_back(i);\n    }\n    int res = S.size();\n    L = get<2>(S[0]);\n    dfs(0, 0, res);\n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tshort table[10][10],num;\n};\n\nshort W,H,ans,POW[11];\nshort first_table[10][10],max_size[10][10];\n\nbool rangeCheck(short row,short col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\ninline void copyTable(Info& to,short from[10][10],short base_row){\n\n\tfor(short row = base_row; row < H; row++){\n\t\tfor(short col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,short base_row,short base_col,short pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\t//ans = min(ans,info.num);\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tshort new_num = 0;\n\tfor(short i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(short k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(short i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(short k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tshort must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(short row = base_row; row < H; row++){\n\t\t\tfor(short col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(short row = 0; row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tshort size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(short row = 0; row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(short i = 0; i < size; i++){\n\t\t\t\t\t\tfor(short k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(short calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(short i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(short k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tshort pre_must_add = 0;\n\tFLG = false;\n\n\tfor(short row = 0; row < H; row++){\n\t\tfor(short col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = 50;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(short i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans;\nint first_table[10][10],max_size[10][10];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\t//printf(\"ans:%d\\n\",ans);\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\t\t\tInfo next_not;\n\n\t\t\tcopyTable(next_not,info.table,base_row);\n\t\t\tnext_not.num = info.num;\n\n\t\t\tint must_add = 0;\n\t\t\tbool FLG = false;\n\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\tfor(int row = base_row; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}else if(next_not.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)must_add++;\n\n\t\t\tif(next_not.num+must_add < ans){\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num+1;\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(next_info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tif(next_info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_info,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\t\t\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\tint remain=0;\n\t\trep(i,h) remain+=popcount(board[i]);\n\t\tmin_res=min(21,remain);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,remain)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nint H,W,mincost;\nint P[10][10],bin[10],bc[(1<<10)];\nint put[10][10],counter[10][10];\n\nbool can_put(int len,int x,int y){\n  REP(i,y,y+len)REP(j,x,x+len) if( !P[i][j] ) return false;\n  return true;\n}\n\nvoid dfs(int cur,int cost,int remain){\n\n  if( cost >= mincost ) return;\n  if( cost + ((remain>0)?1:0) >= mincost ) return;\n\n  if( cur >= H*W ) {\n    mincost = min(mincost,cost);\n    return;\n  }\n\n  int x = cur % W, y = cur / W;\n\n  if( !P[y][x] || counter[y][x] == 1 ) {\n    dfs(cur+1,cost,remain);\n    return;\n  }\n\n  if( (bin[y]>>x) & 1 ) dfs(cur+1,cost,remain);\n\n  int len = put[y][x];\n  int bitmask = ((1<<len)-1)<<x;\n  int buf[len];\n  int add = 0, nremain = remain;\n  rep(j,len) {\n    buf[j] = bin[y+j];\n    add += len - bc[((1<<len)-1)&(bin[y+j]>>x)];\n    bin[y+j] |= bitmask;\n  }\n  nremain -= add;\n  if( add ) dfs(cur+1,cost+1,nremain);\n  rep(j,len) bin[y+j] = buf[j];\n\n}\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\nint main(){\n\n  rep(i,(1<<10)) bc[i] = __builtin_popcount(i);\n\n  while( scanf(\"%d%d\",&W,&H), W | H ){\n\n    rep(i,H){\n      bin[i] = 0;\n      rep(j,W){\n        cin >> P[i][j];\n        put[i][j] = 0;\n      }\n    }\n    rep(y,H) rep(x,W) if( P[y][x] ) {\n      for(int len=min(H,W);len>=1;len--){\n        if( x + len - 1 < W && y + len - 1 < H ) {\n          if( can_put(len,x,y) ){\n            put[y][x] = len;\n            break;\n          }\n        }\n      }\n    }\n\n    rep(i,H)rep(j,W) counter[i][j] = 0;\n    rep(i,H)rep(j,W)if(P[i][j]){\n      REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n        counter[y][x]++;\n      }\n    }\n\n    rep(i,H){\n      rep(j,W){\n        if( counter[i][j] == 1 ){\n          REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n            bin[y] |= (1<<x);\n          }\n        }\n      }\n    }\n\n    int add = 0;\n    int remain = 0;\n    mincost = 0;\n    rep(i,H)rep(j,W)remain += ((bin[i]>>j)&1),mincost += P[i][j];\n    remain = mincost - remain;\n    dfs(0,0,remain);\n\n    rep(i,H)rep(j,W)if(counter[i][j]==1)add++;\n    cout << mincost+add << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\t//ans = min(ans,info.num);\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = base_col; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = base_row+1; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> tri;\n\nint w,h;\nint g[20][20];\nint rem[20][20];\nvector<tri> carpet[20][20];\nint depth;\n\nvoid search(int d){\n  if(d==depth)return;\n\n  int y=-1, x=-1, mink = h*w;\n  vector<tri> priority;\n  rep(i,h)rep(j,w){\n    if(rem[i][j] && mink > (int)carpet[i][j].size()){\n      y = i; x = j;\n    }\n  }\n\n  if(y<0){\n    depth = d;\n    return;\n  }\n\n  rep(k,carpet[y][x].size()){\n    tri t = carpet[y][x][k];\n    \n    int tmp[20][20];\n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\ttmp[i][j] = rem[i][j];\n      }\n    }\n\n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\trem[i][j] = 0;\n      }\n    }\n    \n    search(d+1);\n\n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\trem[i][j] = tmp[i][j];\n      }\n    }\n    if(depth == d+1)return;\n  }\n}\n\nint main(){\n  while(cin >> w >> h, w){\n    memset(g,0,sizeof(g));\n    rep(i,h)rep(j,w){\n      cin >> g[i][j];\n      rem[i][j] = g[i][j];\n      carpet[i][j].clear();\n    }\n\n    vector<tri> c;\n    rep(i,h)rep(j,w){\n      int k = 0;\n      while(true){\n\tif(!range(i+k,0,h) || !range(j+k,0,w))break;\n\tint f = 1;\n\tfor(int y=i;y<=i+k;y++)f &= g[y][j+k];\n\tfor(int x=j;x<=j+k;x++)f &= g[i+k][x];\n\tif(!f)break;\n\tk++;\n      }\n      if(k)c.push_back( tri(pii(i,j), k) );\n    }\n    \n    rep(i,c.size()){\n      bool f = false;\n      rep(j,c.size()){\n\tif(i==j)continue;\n\tif( range(c[i].fs.fs, c[j].fs.fs, c[j].fs.fs + c[j].sc) &&\n\t    range(c[i].fs.fs + c[i].sc, c[j].fs.fs, c[j].fs.fs + c[j].sc+1) &&\n\t    range(c[i].fs.sc, c[j].fs.sc, c[j].fs.sc + c[j].sc) &&\n\t    range(c[i].fs.sc + c[i].sc, c[j].fs.sc, c[j].fs.sc + c[j].sc+1) ){\n\t  f = true;\n\t  break;\n\t}\n      }\n\n      if(f){\n\tc.erase(c.begin()+i);\n\ti--;\n      }\n    }\n\n    rep(i,c.size()){\n      for(int y=c[i].fs.fs;y<c[i].fs.fs+c[i].sc;y++){\n\tfor(int x=c[i].fs.sc;x<c[i].fs.sc+c[i].sc;x++){\n\t  carpet[y][x].push_back(c[i]);\n\t}\n      }\n    }\n\n    int ans = 0;\n    while(true){\n      bool f = false;\n      rep(i,h)rep(j,w){\n\tif(rem[i][j] && carpet[i][j].size()==1){\n\t  f = true;\n\t  ans++;\n\t  tri t = carpet[i][j][0];\n\t  for(int y=t.fs.fs;y<t.fs.fs+t.sc;y++){\n\t    for(int x=t.fs.sc;x<t.fs.sc+t.sc;x++){\n\t      rem[y][x] = 0;\n\t    }\n\t  }\n\t}\n      }\n      if(!f)break;\n    }\n\n    depth = h*w;\n    search(0);\n    \n    cout << ans + depth  << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ninline bool chmax(int &a, const int &b) { return (a<b)?(a=b,1):0;}\ninline bool chmin(int &a, const int &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nchar board[11][11];\nbool used[111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    rep(i,h)rep(j,w){\n      cin>>board[i][j];\n      board[i][j]-='0';\n    }\n    vector<int> g[10101];\n    // 0-9999 / 10000-10100\n    rep(ti,h)rep(tj,w)rep(si,ti)rep(sj,tj){\n      int sum=0;\n      repl(i,si,ti+1)repl(j,sj,tj+1){\n        sum+=board[i][j];\n      }\n      if(sum==(ti-si+1)*(tj-sj+1)&&(ti-si)==(tj-sj)){\n        int cv=si*1000+sj*100+ti*10+tj;\n        repl(i,si,ti+1)repl(j,sj,tj+1){\n          int bv=10000+i*10+j;\n          g[cv].pb(bv); g[bv].pb(cv);\n        }\n      }\n    }\n    memset(used,0,sizeof(used));\n    int res=0;\n    rep(i,h)rep(j,w){\n      if(board[i][j]==1&&!used[i*10+j]){\n        res++;\n        int maxv=-1,maxc=0;\n        each(v,g[i*10+j+10000]){\n          int cnt=0;\n          each(nv,g[v]){\n            if(!used[nv-10000])cnt++;\n          }\n          if(maxc<cnt){\n            maxc=cnt;\n            maxv=v;\n          }\n        }\n        rep(k,g[maxv].size()){\n          used[g[maxv][k]-10000]=true;\n        }\n      }\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nconst int N = 16;\nconst int inf = 1<<27;\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\n\nusing namespace std;\n\n\nint H,W;\nint M[N][N];\nint maxSizes[N][N][4];\nint oneCount;\nint minHW;\nint ans;\nint greedy_ans;\nint depth;\nmultimap<int,int,greater<int> > maxS;\n\ninline int getHeuristic();\nvoid calc();\nvoid solve(int pos);\n\ninline int getHeuristic()\n{\n  int msz=1;\n  if(!maxS.empty())msz = maxS.begin()->first;\n  msz *= msz;\n  return oneCount/msz + (oneCount%msz>0);\n}\n\nstruct Cand{\n  int i,j;\n  Cand():i(0),j(0){}\n  Cand(int ci, int cj):i(ci),j(cj){}\n  bool operator<(const Cand& t)const{\n    return (i==t.i)?(j<t.j):(i<t.i);\n  }\n};\n\nint cand_num;\nCand cands[N*N];\n\nvoid calc(){\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 1){\n\toneCount++;\n\tcands[cand_num++] = Cand(i,j);\n      }\n      for(int k = 0; k < 4; ++k){\n\tint size = 0;\n\tfor(size = 1; size <= minHW; ++size){\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t--size;\n\t\tgoto next;\n\t      }\n\t    }\n\t  }\n\t  if(k==0){\n\t    if(i-size<0||j+size>=W)break;\n\t  }else if(k==1){\n\t    if(i+size>=H||j+size>=W)break;\n\t  }else if(k==2){\n\t    if(i+size>=H||j-size<0)break;\n\t  }else{\n\t    if(i-size<0||j-size<0)break;\n\t  }\n\t}\n      next:;\n\tmaxSizes[i][j][k] = size;\n\tif(k==1){\n\t  if(size>1){\n\t    maxS.insert( make_pair(size,0) );\n\t  }\n\t}\n      }\n    }\n  }\n  sort(cands,cands+cand_num);\n  return ;\n}\n\nvoid solve_greedy(int pos)\n{\n  // completed.\n  if(oneCount==0){\n    greedy_ans = min(greedy_ans, depth);\n    return ;\n  }\n\n  // embed carpet greedy\n  int maxOneCount = -1;\n  int maxp,maxk,maxsz;\n  for(int p = 0; p < cand_num; ++p){\n    int i = cands[p].i;\n    int j = cands[p].j;\n    if( M[i][j] == 1 ){\n      for(int k = 0; k < 4; ++k){\n\tint cnt = 0;\n\tint size = maxSizes[i][j][k];\n\tfor(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t  for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t    if(M[m][n]==1){\n\t      ++cnt;\n\t    }\n\t  }\n\t}\n\tif(maxOneCount<cnt){\n\t  maxp = p;\n\t  maxk = k;\n\t  maxsz = size;\n\t  maxOneCount = cnt;\n\t}\n      }\n    }\n  }\n  int i = cands[maxp].i;\n  int j = cands[maxp].j;\n  int k = maxk;\n  int size = maxsz;\n  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n      if(M[m][n]==1){\n\tM[m][n]=depth;\n\t--oneCount;\n      }\n    }\n  }\n  ++depth;\n  solve_greedy(0);\n  --depth;\n  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n      if( M[m][n] == depth ){\n\tM[m][n]=1;\n\t++oneCount;\n      }\n    }\n  }\n  return ;\n}\n\nvoid solve(int pos){\n  /*\n    printf(\"now i = %d, now j = %d, h = %d\\n\", pos/W, pos%W, getHeuristic());\n    for(int k = 0; k < H; ++k){\n      for(int l = 0; l < W; ++l){\n\tif(l>0)putchar(' ');\n\tprintf(\"%2d\", M[k][l]);\n      }\n      putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  if(oneCount==0){\n    ans = min(ans, depth);\n    return ;\n  }\n\n  // back\n  if(depth+getHeuristic()>=ans){\n    return ;\n  }\n\n  // embed carpet\n  for(int p = pos; p < cand_num; ++p){\n    int i = cands[p].i;\n    int j = cands[p].j;\n    int size = maxSizes[i][j][1];\n    int valid=0;\n    for(int m = i; m<size+i; m++){\n      for(int n = j; n<size+j; n++){\n\tif(M[m][n]==1){\n\t  valid=1;\n\t  --oneCount;\n\t  M[m][n]=depth;\n\t}\n      }\n    }\n    if( valid ){\n      ++depth;\n      if(size>1)\n\tmaxS.erase( maxS.find(size) );\n      solve(p+1);\n      if(size>1)\n\tmaxS.insert( make_pair(size,0) );\n      --depth;\n    }\n    for(int m = i; m<size+i; m++){\n      for(int n = j; n<size+j; n++){\n\tif( M[m][n] == depth ){\n\t  ++oneCount;\n\t  M[m][n]=1;\n\t}\n      }\n    }\n    if( M[i][j] > 1 )\n      solve(p+1);\n    return ;\n  }\n}\n\nint main()\n{\n  while(true){\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    minHW = min(H,W);\n    oneCount = 0;\n    cand_num = 0;\n    ans=inf;\n    greedy_ans = inf;\n    depth=2;\n    maxS.clear();\n\n    \n    calc();\n\n    solve_greedy(0);\n    ans = greedy_ans;\n    solve(0);\n\n    printf(\"%d\\n\", ans-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct square{\n\tint x,y,a; // 左上の座標, 幅\n\tbool operator<(const square &S)const{ return a<S.a; }\n};\n\nint h,w;\nint B[10][10];\n\nvector<square> S;\nint cnt[10][10]; // マス (i, j) を覆うことのできる正方形の個数\n\n#define update_cnt(i,d) for(int y=S[i].y;y<S[i].y+S[i].a;y++) for(int x=S[i].x;x<S[i].x+S[i].a;x++) cnt[y][x]+=d\n\nint hstar(int i){\n\tint n=0;\n\tstatic int val[100]; // i 番目以降の正方形で新たに覆えるマスの個数を大きい順に並べたもの\n\tfor(;i<S.size();i++){\n\t\tval[n]=0;\n\t\tfor(int y=S[i].y;y<S[i].y+S[i].a;y++) for(int x=S[i].x;x<S[i].x+S[i].a;x++) {\n\t\t\tif(B[y][x]==1) val[n]++;\n\t\t}\n\t\tn++;\n\t}\n\tsort(val,val+n,greater<int>());\n\n\tint a=0; // まだ覆っていないマスの数\n\trep(y,h) rep(x,w) if(B[y][x]==1) a++;\n\n\tint res=0;\n\tfor(i=0;a>0;i++){\n\t\ta-=val[i];\n\t\tres++;\n\t}\n\treturn res;\n}\n\nint res;\nvoid dfs(int i,int sum){\n\tif(sum+hstar(i)>=res) return;\n\n\tif(i==S.size()){\n\t\tres=sum;\n\t\treturn;\n\t}\n\n\tbool ok1=false,ok2=false;\n\tfor(int y=S[i].y;y<S[i].y+S[i].a;y++) for(int x=S[i].x;x<S[i].x+S[i].a;x++) {\n\t\tif(B[y][x]==1) ok1=true;\n\t\tif(B[y][x]==1 && cnt[y][x]==1) ok2=true;\n\t}\n\n\tbool use=true,notuse=true;\n\t// 正方形 i を使うことで新たに覆えるマスがないなら使わない\n\tif(!ok1) use=false;\n\t// 正方形 i を使わないと絶対に覆えないマスができるようなら使う\n\tif(ok2) notuse=false;\n\n\t// いずれでもなければ両方試す\n\tupdate_cnt(i,-1);\n\tif(use){\n\t\tint tmp[10][10];\n\t\tmemcpy(tmp,B,sizeof B);\n\t\tfor(int y=S[i].y;y<S[i].y+S[i].a;y++) for(int x=S[i].x;x<S[i].x+S[i].a;x++) B[y][x]=i+2;\n\t\tdfs(i+1,sum+1);\n\t\tmemcpy(B,tmp,sizeof B);\n\t}\n\tif(notuse){\n\t\tdfs(i+1,sum);\n\t}\n\tupdate_cnt(i,+1);\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) rep(j,w) scanf(\"%d\",B[i]+j);\n\n\t\tS.clear();\n\t\trep(i,h) rep(j,w) if(B[i][j]==1) {\n\t\t\tint a;\n\t\t\tfor(a=1;i+a<=h&&j+a<=w;a++){\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int y=i;y<i+a;y++) for(int x=j;x<j+a;x++) if(B[y][x]==0) ok=false;\n\t\t\t\tif(!ok) break;\n\t\t\t}\n\t\t\tS.push_back((square){j,i,a-1});\n\t\t}\n\n\t\t// 他の正方形に完全に覆われるような正方形を削除\n\t\trep(i,S.size()){\n\t\t\tbool covered=false;\n\t\t\trep(j,S.size()) if(i!=j) {\n\t\t\t\tif(S[j].x<=S[i].x\n\t\t\t\t&& S[j].y<=S[i].y\n\t\t\t\t&& S[i].x+S[i].a<=S[j].x+S[j].a\n\t\t\t\t&& S[i].y+S[i].a<=S[j].y+S[j].a) covered=true;\n\t\t\t}\n\t\t\tif(covered){\n\t\t\t\tS.erase(S.begin()+i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tsort(S.begin(),S.end()); // 小さい正方形から順に調べる\n\n\t\trep(i,h) rep(j,w) cnt[i][j]=0;\n\t\trep(i,S.size()) update_cnt(i,1);\n\n\t\tres=S.size();\n\t\tdfs(0,0);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\n\nint H,W;\nvec t;\nmap< vec , int > dp[10][10];\n\nint mem[10][10][10][10];\n\nbool check(int ay,int ax,int by,int bx){\n  if(mem[ay][ax][by][bx]!=-1)\n    return mem[ay][ax][by][bx];\n\n  mem[ay][ax][by][bx]=false;\n  for(int y=ay;y<=by;y++)\n    for(int x=ax;x<=bx;x++)\n      if( (t[y]>>x&1)==0 )return false;\n\n  mem[ay][ax][by][bx]=true;\n  return true;\n}\n\nint solve(vec p,int y,int x){\n  if(y==H)return 0;\n  \n  if(x==W){\n    return solve(p,y+1,0);\n  }\n  \n  if(dp[y][x].count(p))return dp[y][x][p];\n  int sum=0;\n  for(int i=0;i<H;i++)sum+=p[i];\n  if(sum==0)return 0;\n  \n\n  int res=1e9;\n  if((p[y]>>x&1)==0)res=solve(p,y,x+1);\n\n  for(int i=0;;i++){\n    if(y+i>=H||x+i>=W)break;\n    if(!check(y,x,y+i,x+i))break;\n    int ma=(1<<(i+1))-1;\n    vec next=p;\n    for(int j=0;j<=i;j++){\n      next[y+j]|=(ma<<x);\n      next[y+j]-=(ma<<x);\n    }\n\n    if(p==next)continue;\n    res=min(res,solve(next,y,x+1)+1);\n  }\n\n  return dp[y][x][p]=res;\n}\n\nint main(){\n  while(1){\n    cin>>W>>H;\n    if(H==0&&W==0)break;\n    memset( mem, -1, sizeof(mem) );\n    vec si;\n    for(int i=0;i<H;i++){\n      int bit=0,a;\n      for(int j=0;j<W;j++){\n        dp[i][j].clear();\n        \n        cin>>a;\n        if(a==1)bit|=(1<<j);\n      }\n      si.push_back(bit);\n    }\n    t=si;\n    cout<<solve(si,0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,n,A[11][11],ans,cnt;\nbitset<100> B[11][11];\n\nvoid dfs(int d,bitset<100> s,int sco){\n  if(d==n){\n    ans=min(ans,sco);\n    return;\n  }\n  cnt++;\n  if(cnt>=100000000)return;\n  if(ans<=sco)return;\n  if(!A[d/w][d%w])dfs(d+1,s,sco);\n  else{\n    int y=d/w;\n    int x=d%w;\n    if((B[y][x]&s).any()){\n      bitset<100>p;\n      p.set(y*10+x);//(y*100+x);\n      if(!(s&p).any())dfs(d+1,s,sco);\n      dfs(d+1,(B[y][x]|s)^B[y][x],sco+1);\n    }\n    else dfs(d+1,s,sco);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    memset(A,0,sizeof(A));\n    r(i,11)r(j,11)B[i][j]&=0;\n    n=h*w;\n    bitset<100> b;\n    r(i,h)r(j,w)cin>>A[i][j];\n    r(i,h)r(j,w)if(A[i][j]){\n      int sum=1;\n      for(;;sum++){\n        int f=0;\n        for(int y=i;y<i+sum;y++){\n          for(int x=j;x<j+sum;x++){\n            if(A[y][x]==0)f++;\n          }\n        }\n        if(f){\n          sum--;\n          break;\n        }\n      }\n      bitset<100>tmp;\n      for(int y=i,k=0;k<sum;k++,y++){\n        for(int x=j,l=0;l<sum;l++,x++){\n          tmp.set(y*10+x);\n        }\n      }\n      b.set(i*10+j);\n      B[i][j]=tmp;\n    }\n    ans=100;\n    cnt=0;\n    dfs(0,b,0);\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<utility>\n#include<stack>\n#include<bitset>\n#include<map>\n#include<numeric>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define stop char nyaa;cin>>nyaa;\nconst ll mod = 1000000007;\nconst long double eps = 1e-8;\ntypedef pair<ll, ll> LP;\n\n#define int short int\ntypedef pair<int, int> P;\n\ntypedef long double ld;\n\nint h, w;\n\ntypedef pair<vector<int>, P> speP;\n\nvoid solve() {\n\tvector<vector<int>> v(h),sz;\n\tmap<speP, bool> mp;\n\tsz.resize(h);\n\trep(i, h) {\n\t\tv[i].resize(w); sz[i].resize(w,0);\n\t\trep(j, w)cin >> v[i][j];\n\t}\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tif (v[i][j] == 0)continue;\n\t\t\trep1(k, 11) {\n\t\t\t\tbool f = true;\n\t\t\t\tRep(x, i, i + k) {\n\t\t\t\t\tRep(y, j, j + k) {\n\t\t\t\t\t\tif (x >= h || y >= w) {\n\t\t\t\t\t\t\tf = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (v[x][y] == 0) {\n\t\t\t\t\t\t\tf = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tsz[i][j] = k;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> sta;\n\trep(i, h)rep(j, w)sta.push_back(v[i][j]);\n\tdeque<speP> q;\n\tmap<speP, int> ans;\n\tq.push_back({ sta,{0,0} }); ans[{sta, { 0,0 }}] = 0; mp[{sta, { 0,0 }}] = true;\n\twhile (!q.empty()) {\n\t\t\tspeP p = q.front(); q.pop_front();\n\t\t\tif (p.second == P{ h,0 }) {\n\t\t\t\tcout << ans[p] << endl; return;\n\t\t\t}\n\t\t\tvector<int> &v = p.first;\n\t\t\tint& x = p.second.first, y = p.second.second;\n\t\t\t//cout << x << \" \" << y << endl;\n\t\t\tint nd = ans[p];\n\t\t\tint nx = x, ny = y + 1;\n\t\t\tif (ny == w) {\n\t\t\t\tnx++; ny = 0;\n\t\t\t}\n\t\t\t\n\t\t\tspeP nex; nex.second = { nx,ny };\n\t\t\tif (v[x*w+y] == 0) {\n\t\t\t\t//cout << nx << \" \" << ny << endl;\n\t\t\t\tnex.first = v;\n\t\t\t\tif (!mp[nex]) {\n\t\t\t\t\tmp[nex] = true;\n\t\t\t\t\tans[nex] = nd;\n\t\t\t\t\tq.push_front(nex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (nd < ans[nex]) {\n\t\t\t\t\t\tans[nex] = nd;\n\t\t\t\t\t\tq.push_front(nex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (v[x*w+y] == 1) {\n\t\t\t\tint len = sz[x][y];\n\t\t\t\tRep(i, x, x + len) {\n\t\t\t\t\tRep(j, y, y + len) {\n\t\t\t\t\t\tv[i*w+j] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnex.first = v;\n\t\t\t\tif (!mp[nex]) {\n\t\t\t\t\tmp[nex] = true;\n\t\t\t\t\tans[nex] = nd + 1;\n\t\t\t\t\tq.push_back(nex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//non\n\t\t\t\tnex.first = v;\n\t\t\t\tif (!mp[nex]) {\n\t\t\t\t\tmp[nex] = true;\n\t\t\t\t\tans[nex] = nd;\n\t\t\t\t\tq.push_front(nex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (nd < ans[nex]) {\n\t\t\t\t\t\tans[nex] = nd;\n\t\t\t\t\t\tq.push_front(nex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbool exi = false;\n\t\t\t\tint len = sz[x][y];\n\t\t\t\tRep(i, x, x + len) {\n\t\t\t\t\tRep(j, y, y + len) {\n\t\t\t\t\t\tif (v[i*w+j] != 2)exi = true;\n\t\t\t\t\t\tv[i*w+j] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (exi) {\n\t\t\t\t\tnex.first = v;\n\t\t\t\t\tif (!mp[nex]) {\n\t\t\t\t\t\tmp[nex] = true;\n\t\t\t\t\t\tans[nex] = nd+1;\n\t\t\t\t\t\tq.push_back(nex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\t//cout << dfs(v, 0, 0) << endl;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//string s = \"-0=0\";\n\t//cout << valid(s) << endl;\n\t//cout << fixed << setprecision(10);\n\twhile (cin >> w >> h, w) {\n\t\tsolve();\n\t\t//cout << \"end\" << endl;\n\t}\n\t//solve();\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\nusing namespace std;\nusing ll = int64_t;\n\nint solve(const vector<bitset<100>>& v, const bitset<100>& rem) {\n  if (rem.none()) return 0;\n  bitset<100> b;\n  int mx = 0;\n  vector<int> cnt(100, 0);\n  for(auto&& t : v) {\n    int n = (rem & t).count();\n    if (n > mx) {\n      b = t;\n      mx = n;\n    }\n    REP(i,100) {\n      if (t[i]) ++cnt[i];\n    }\n  }\n  set<int> s;\n  REP(i,100) {\n    if (rem[i]) {\n      if (cnt[i] == 0) return 10000;\n      if (cnt[i] == 1) s.insert(i);\n    }\n  }\n  if (s.empty()) {\n    vector<bitset<100>> tmp;\n    for(auto&& t : v) {\n      if (t != b) tmp.push_back(t);\n    }\n    return min(solve(tmp, rem & ~b) + 1, solve(tmp, rem));\n  } else {\n    vector<bitset<100>> tmp;\n    bitset<100> next = rem;\n    for(auto&& t : v) {\n      bool use = false;\n      for(auto&& i : s) {\n        if (t[i]) {\n          next &= ~t;\n          use = true;\n          break;\n        }\n      }\n      if (use) continue;\n      tmp.push_back(t);\n    }\n    return solve(tmp, next) + (v.size() - tmp.size());\n  }\n}\n\nint main() {\n  while(1) {\n    int w,h;\n    cin>>w>>h;\n    if (!w) break;\n    vector<vector<int>> t(h, vector<int>(w));\n    REP(i,h)REP(j,w) cin>>t[i][j];\n    REP(i,h)REP(j,w) {\n      int m=min(h-i, w-j);\n      FOR(k,1,m+1) {\n        bool ok = true;\n        REP(p,k)REP(q,k) {\n          if (t[i+p][j+q]==0) ok=false;\n        }\n        if (ok) t[i][j] = k;\n      }\n    }\n    vector<vector<bool>> maxi(h, vector<bool>(w, true));\n    REP(i,h)REP(j,w) {\n      if (t[i][j] == 0) maxi[i][j] = false;\n      REP(p,i+1)REP(q,j+1) {\n        if (p==i && q==j) continue;\n        int d=max(i-p,j-q);\n        if (t[p][q] >= t[i][j] + d) maxi[i][j] = false;\n      }\n    }\n    vector<bitset<100>> v;\n    REP(i,h)REP(j,w) {\n      if (maxi[i][j]) {\n        bitset<100> b;\n        REP(p,t[i][j])REP(q,t[i][j]) {\n          b[(i+p)*10+(j+q)] = true;\n        }\n        v.push_back(b);\n      }\n    }\n    bitset<100> rem;\n    REP(i,h)REP(j,w) {\n      if (t[i][j]) rem[i*10+j] = true;\n    }\n    cout << solve(v, rem) << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint w,h;\nint p[11][11];\nint cnt[11][11];\nint res;\n\nstruct square{\n\tint x,y,si;\n\tsquare(){}\n\tsquare(int xx,int yy,int ss){\n\t\tx=xx;\n\t\ty=yy;\n\t\tsi=ss;\n\t}\n\tbool operator<(const square &s)const{\n\t\treturn si<s.si;\n\t}\n};\n\nvector<square> sq; \nvector<square> usq;\n\nbool check(int s,int y,int x){\n\tfor(int i=y;i<y+s;i++){\n\t\tfor(int j=x;j<x+s;j++){\n\t\t\tif(i>=h || j>=w)return false;\n\t\t\tif(p[i][j]==0)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool cover(square a,square b){\n\tbool flag=false;\n\tbool flag2=false;\n\tif(a.x<=b.x && b.x+b.si<=a.x+a.si)flag=true;\n\tif(a.y<=b.y && b.y+b.si<=a.y+a.si)flag2=true;\n\treturn (flag && flag2);\n}\n\nint hstar(int v){\n\tint n=0;\n\tint val[101];\n\tint c=0;\n\tfor(;v<usq.size();v++){\n\t\tval[c]=0;\n\t\tfor(int i=usq[v].x;i<usq[v].x+usq[v].si;i++){\n\t\t\tfor(int j=usq[v].y;j<usq[v].y+usq[v].si;j++){\n\t\t\t\tif(p[j][i]==1)val[c]++;\n\t\t\t}\n\t\t}\n\t\tc++;\n\t}\n\tint rest=0;\n\tsort(val,val+c,greater<int>());\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\trest+=p[i][j];\n\t\t}\n\t}\n\tint l=0;\n\tfor(l=0;rest>0;l++){\n\t\trest-=val[l];\n\t}\n\treturn l;\n}\n\nbool empty(){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(p[i][j]==1)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid update(int v,int c){\n\tfor(int i=usq[v].x;i<usq[v].x+usq[v].si;i++){\n\t\tfor(int j=usq[v].y;j<usq[v].y+usq[v].si;j++){\n\t\t\tcnt[j][i]+=c;\n\t\t}\n\t}\n}\n\nvoid dfs(int v,int sum){\n\tif(empty()){\n\t\tres=min(sum,res);\n\t\treturn;\n\t}\n\tif(v==(int)usq.size())return;\n\tif(sum+hstar(v)>=res)return;\n\tbool ok1=false,ok2=false;\n\tfor(int i=usq[v].x;i<usq[v].x+usq[v].si;i++){\n\t\tfor(int j=usq[v].y;j<usq[v].y+usq[v].si;j++){\n\t\t\tif(p[j][i]==1){\n\t\t\t\tok1=true;\n\t\t\t\tif(cnt[j][i]==1)ok2=true;\n\t\t\t}\n\t\t}\n\t}\n\tupdate(v,-1);\n\tif(ok1){\n\t\tint tmp[11][11];\n\t\tmemcpy(tmp,p,sizeof(p));\n\t\tfor(int i=usq[v].x;i<usq[v].x+usq[v].si;i++){\n\t\t\tfor(int j=usq[v].y;j<usq[v].y+usq[v].si;j++){\n\t\t\t\tp[j][i]=0;\n\t\t\t}\n\t\t}\n\t\tdfs(v+1,sum+1);\n\t\tmemcpy(p,tmp,sizeof(p));\n\t}\n\tif(!ok2){\n\t\tdfs(v+1,sum);\n\t}\n\tupdate(v,1);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tsq.clear();\n\t\tusq.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tscanf(\"%d\",&p[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=min(w,h);i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tif(check(i,j,k)){\n\t\t\t\t\t\tsq.push_back(square(k,j,i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(sq.begin(),sq.end());\n\t\tfor(int i=(int)sq.size()-1;i>=0;i--){\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<usq.size();j++){\n\t\t\t\tif(cover(usq[j],sq[i]))flag=false;\n\t\t\t}\n\t\t\tif(flag)usq.push_back(sq[i]);\n\t\t}\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tfor(int i=0;i<usq.size();i++){\n\t\t\tupdate(i,1);\n\t\t}\n\t\tres=usq.size();\n\t\tdfs(0,0);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> tri;\n\nint w,h;\nint g[20][20];\nint rem[20][20];\nvector<tri> carpet[20][20];\nint depth;\n\nvoid search(int d){\n  if(d==depth)return;\n\n  vector<tri> priority;\n  rep(i,h)rep(j,w){\n    if(rem[i][j]){\n      priority.push_back(tri(pii(carpet[i][j].size(),i),j));\n    }\n  }\n\n  if(priority.size()==0){\n    depth = d;\n    return;\n  }\n\n  int y = priority[0].fs.sc, x = priority[0].sc;\n\n  rep(k,carpet[y][x].size()){\n    tri t = carpet[y][x][k];\n    \n    int tmp[20][20];\n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\ttmp[i][j] = rem[i][j];\n      }\n    }\n\n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\trem[i][j] = 0;\n      }\n    }\n    \n    search(d+1);\n\n    for(int i=t.fs.fs;i<t.fs.fs+t.sc;i++){\n      for(int j=t.fs.sc;j<t.fs.sc+t.sc;j++){\n\trem[i][j] = tmp[i][j];\n      }\n    }\n    if(depth == d+1)return;\n  }\n}\n\nint main(){\n  while(cin >> w >> h, w){\n    memset(g,0,sizeof(g));\n    rep(i,h)rep(j,w){\n      cin >> g[i][j];\n      rem[i][j] = g[i][j];\n      carpet[i][j].clear();\n    }\n\n    vector<tri> c;\n    rep(i,h)rep(j,w){\n      int k = 0;\n      while(true){\n\tif(!range(i+k,0,h) || !range(j+k,0,w))break;\n\tint f = 1;\n\tfor(int y=i;y<=i+k;y++)f &= g[y][j+k];\n\tfor(int x=j;x<=j+k;x++)f &= g[i+k][x];\n\tif(!f)break;\n\tk++;\n      }\n      if(k)c.push_back( tri(pii(i,j), k) );\n    }\n    \n    rep(i,c.size()){\n      bool f = false;\n      rep(j,c.size()){\n\tif(i==j)continue;\n\tif( range(c[i].fs.fs, c[j].fs.fs, c[j].fs.fs + c[j].sc) &&\n\t    range(c[i].fs.fs + c[i].sc, c[j].fs.fs, c[j].fs.fs + c[j].sc+1) &&\n\t    range(c[i].fs.sc, c[j].fs.sc, c[j].fs.sc + c[j].sc) &&\n\t    range(c[i].fs.sc + c[i].sc, c[j].fs.sc, c[j].fs.sc + c[j].sc+1) ){\n\t  f = true;\n\t  break;\n\t}\n      }\n\n      if(f){\n\tc.erase(c.begin()+i);\n\ti--;\n      }\n    }\n\n    rep(i,c.size()){\n      for(int y=c[i].fs.fs;y<c[i].fs.fs+c[i].sc;y++){\n\tfor(int x=c[i].fs.sc;x<c[i].fs.sc+c[i].sc;x++){\n\t  carpet[y][x].push_back(c[i]);\n\t}\n      }\n    }\n\n    int ans = 0;\n    while(true){\n      bool f = false;\n      rep(i,h)rep(j,w){\n\tif(rem[i][j] && carpet[i][j].size()==1){\n\t  f = true;\n\t  ans++;\n\t  tri t = carpet[i][j][0];\n\t  for(int y=t.fs.fs;y<t.fs.fs+t.sc;y++){\n\t    for(int x=t.fs.sc;x<t.fs.sc+t.sc;x++){\n\t      rem[y][x] = 0;\n\t    }\n\t  }\n\t}\n      }\n      if(!f)break;\n    }\n\n    depth = h*w;\n    search(0);\n    \n    cout << ans + depth  << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//???????????????\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nconst int MX=100;\ntypedef bitset<MX> BS;\nint H,W,N;\nint ans;\nbool used[MX];\nvector<BS> cs;\nbool incl(BS& a,BS& b){return (a&b)==b;}\nint cnt;\nvoid dfs(BS now,int t){\n//\tcnt++;\n//\tprintf(\"dfs\");\n//\tshow(now);\n//\tshow(t);\n\tif(ans<=t) return;\n\tif(now.none()){\n\t\tchmin(ans,t);\n\t\treturn;\n\t}\n\tint mnway=MX,arg=-1;\n\trep(i,H*W) if(now[i]){\n\t\tint cnt=0;\n\t\trep(j,N) if(!used[j]){\n\t\t\tif(cs[j][i]) cnt++;\n\t\t}\n\t\tif(cnt<mnway){\n\t\t\tcnt=mnway;\n\t\t\targ=i;\n\t\t}\n\t}\n\tassert(arg>=0);\n\trep(i,N) if(!used[i]&&cs[i][arg]){\n\t\tused[i]=1;\n\t\tdfs(now&(~cs[i]),t+1);\n\t\tused[i]=0;\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>H;\n\t\tif(H==0) break;\n\t\tcs.clear();\n\t\tBS s;\n\t\trep(i,H) rep(j,W){\n\t\t\tbool x;\n\t\t\tcin>>x;\n\t\t\ts.set(i*W+j,x);\n\t\t}\n\t\trep(i,H) rep(j,W){\n\t\t\tfor(int d=10;d>=1;d--){\n\t\t\t\tbool can=1;\n\t\t\t\tif(i+d-1>=H||j+d-1>=W) can=0;\n\t\t\t\tif(can){\n\t\t\t\t\trep(x,d) rep(y,d) if(!s[(i+x)*W+j+y]) can=0;\n\t\t\t\t}\n\t\t\t\tif(can){\n\t\t\t\t\tBS b;\n\t\t\t\t\trep(x,d) rep(y,d) b.set((i+x)*W+j+y);\n\t\t\t\t\tcs.pb(b);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tN=cs.size();\n\t\tbool gomi[MX]={};\n\t\trep(i,N) rep(j,N) if(i!=j){\n\t\t\tif(incl(cs[i],cs[j])) gomi[j]=1;\n\t\t}\n\t\tvector<BS> tmp;\n\t\trep(i,N) if(!gomi[i]) tmp.pb(cs[i]);\n\t\tcs=tmp;\n\t\tN=cs.size();\n//\t\trep(i,N) show(cs[i]);\n\t\tans=N;\n\t\trep(i,N) used[i]=0;\n\t\tdfs(s,0);\n//\t\tshow(cnt);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Carpet {\n  int y, x, size;\n  bool contain(const auto& c) const {\n    if(c.x < x) return false;\n    if(x + size < c.x + c.size) return false;\n    if(c.y < y) return false;\n    if(y + size < c.y + c.size) return false;\n    return true;\n  }\n};\n\nint W, H;\nint S[12][12];\nint L[12][12];\n\nint sum(int y1, int x1, int y2, int x2) {\n  return S[y2][x2] - S[y2][x1-1] - S[y1-1][x2] + S[y1-1][x1-1];\n}\n\nbool full(auto y1, auto x1, auto y2, auto x2) {\n  return sum(y1, x1, y2, x2) == (y2 - y1 + 1) * (x2 - x1 + 1);\n};\n\nint greedy(auto& P) {\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] = P[i][j];\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) S[i][j] += S[i][j-1];\n  for(auto j = 1; j <= W; ++j) for(auto i = 1; i <= H; ++i) S[i][j] += S[i-1][j];\n\n  vector<Carpet> carpet;\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) {\n    auto size = -1;\n    for(auto k = 0; k < 10; ++k) {\n      if(H < i+k || W < j+k) break;\n      if(!full(i, j, i+k, j+k)) break;\n      size = k;\n    }\n    if(~size) carpet.push_back({i, j, size});\n  }\n\n  vector<bool> removed(carpet.size());\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) for(auto j = 0; j < carpet.size(); ++j) if(!removed[j]) if(i != j) if(carpet[i].contain(carpet[j])) removed[j] = true;\n\n  int res = 0;\n\n  vector<vector<int>> cnt(H+2, vector<int>(W+2));\n  vector<vector<int>> id(H+2, vector<int>(W+2));\n  for(auto k = 0; k < carpet.size(); ++k) if(!removed[k]) {\n    auto c = carpet[k];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) {\n      ++cnt[i][j];\n      id[i][j] = k;\n    }\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(cnt[i][j] == 1) if(!removed[id[i][j]]) {\n    removed[id[i][j]] = true;\n    ++res;\n    auto c = carpet[id[i][j]];\n    for(auto i = c.y; i <= c.y + c.size; ++i) for(auto j = c.x; j <= c.x + c.size; ++j) P[i][j] = 0;\n  }\n\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) L[i][j] = 0;\n  for(auto i = 0; i < carpet.size(); ++i) if(!removed[i]) L[carpet[i].y][carpet[i].x] = carpet[i].size + 1;\n\n  return res;\n}\n\nint ans;\nvoid dfs(auto P, int sy, int sx, int depth) {\n  if(depth >= ans) return;\n  int y, x;\n  for(y = sy; y <= H; ++y) {\n    for(x = (y==sy ? sx : 1); x <= W; ++x) {\n      if(L[y][x]) break;\n      if(P[y][x] == 1) return;\n    }\n    if(L[y][x]) break;\n  }\n  if(y == H+1 || x == W+1) {\n    ans = min(ans, depth);\n    return;\n  }\n  if(P[y][x] == 0) {\n    auto ny = y, nx = x + 1;\n    if(W < x) {++ny; nx = 1;}\n    dfs(P, ny, nx, depth);\n  }\n  auto cnt = 0;\n  for(auto i = y; i < y + L[y][x]; ++i) for(auto j = x; j < x + L[y][x]; ++j) if(P[i][j] == 1) {\n    P[i][j] = 0;\n    ++cnt;\n  }\n  if(cnt == 0) return;\n  dfs(P, y, x, depth + 1);\n}\n\nint solve(auto P) {\n  auto fix = greedy(P);\n  ans = 100;\n  dfs(P, 1, 1, 0);\n  return fix + ans;\n}\n\nint main() {\n  while(cin >> W >> H, W | H) {\n    vector<vector<int>> P(H+2, vector<int>(W+2));\n    for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> P[i][j];\n    cout << solve(P) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ninline bool chmax(int &a, const int &b) { return (a<b)?(a=b,1):0;}\ninline bool chmin(int &a, const int &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tchmin(min_res,d);\n\t\treturn d;\n\t}\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0) chmin(ret,dfs(y,x+1,d,remain));\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\tif(remain!=nremain) chmin(ret,dfs(y,x+1,d+1,nremain));\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) chmin(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\n\nint W,H,ans;\nint first_table[10][10],max_size[10][10];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\tans = min(ans,info.num);\n\t\treturn;\n\t}\n\n\t//printf(\"ans:%d\\n\",ans);\n\n\tInfo next_info;\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num;\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(next_info,base_row+1,0);\n\t\t}else{\n\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\t\t\tInfo next_not;\n\n\t\t\tcopyTable(next_not,info.table,base_row);\n\t\t\tnext_not.num = info.num;\n\n\t\t\tint must_add = 0;\n\t\t\tbool FLG = false;\n\t\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\t\tfor(int row = base_row; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(next_not.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\t\tmust_add++;\n\t\t\t\t\t}else if(next_not.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)must_add++;\n\n\t\t\tif(next_not.num+must_add < ans){\n\t\t\t\tif(base_col == W-1){\n\t\t\t\t\trecursive(next_not,base_row+1,0);\n\t\t\t\t}else{\n\t\t\t\t\trecursive(next_not,base_row,base_col+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcopyTable(next_info,info.table,base_row);\n\t\tnext_info.num = info.num+1;\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tnext_info.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(next_info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(next_info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tif(next_info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(next_info,base_row+1,0);\n\t\t\t}else{\n\t\t\t\trecursive(next_info,base_row,base_col+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long lli;\n\nconst int MAXH = 11;\nconst int MAXW = 11;\nint W, H, N;\nint P[MAXH][MAXW];\nint dp[MAXH][MAXW];\nvector<pair<lli,lli> > V;\nint ans;\n\nvoid rec(int p, int c, pair<lli,lli> s) {\n  if(c >= ans) return;\n  if(s.first == 0 && s.second == 0) {\n    ans = c;\n    return;\n  }\n  for(; p < V.size(); ++p) {\n    pair<lli,lli> ns = s;\n    ns.first &= ~V[p].first;\n    ns.second &= ~V[p].second;\n    if(s != ns) {\n      rec(p+1, c+1, ns);\n    }\n  }\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    N = 0;\n    for(int i = 1; i <= H; ++i) {\n      for(int j = 1; j <= W; ++j) {\n        cin >> P[i][j];\n        N += P[i][j];\n      }\n    }\n\n    fill(dp[0], dp[MAXH], 0);\n    for(int i = 1; i <= H; ++i) {\n      for(int j = 1; j <= W; ++j) {\n        if(P[i][j]) {\n          dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1;\n        } else {\n          dp[i][j] = 0;\n        }\n      }\n    }\n\n    vector<pair<lli,lli> > u;\n    for(int i = 1; i <= H; ++i) {\n      for(int j = 1; j <= W; ++j) {\n        if(dp[i][j]) {\n          pair<lli,lli> p(0,0);\n          for(int k = 0; k < dp[i][j]; ++k) {\n            for(int l = 0; l < dp[i][j]; ++l) {\n              int ni = i-k-1;\n              int nj = j-l-1;\n              lli b = ni*W+nj;\n              if(b < 50) p.first |= 1LL<<b;\n              else p.second |= 1LL<<(b-50);\n            }\n          }\n          u.push_back(p);\n        }\n      }\n    }\n\n    vector<pair<lli,lli> > v;\n    for(int i = 0; i < u.size(); ++i) {\n      bool flag = true;\n      for(int j = 0; j < u.size(); ++j) {\n        if(i == j) continue;\n        if((u[i].first & u[j].first) == u[i].first &&\n           (u[i].second & u[j].second) == u[i].second) {\n          flag = false;\n          break;\n        }\n      }\n      if(flag) v.push_back(u[i]);\n    }\n\n    pair<lli,lli> begin(0,0);\n    for(int i = 1; i <= H; ++i) {\n      for(int j = 1; j <= W; ++j) {\n        if(P[i][j]) {\n          lli b = (i-1)*W + j-1;\n          if(b < 50) begin.first |= 1LL<<b;\n          else begin.second |= 1LL<<(b-50);\n        }\n      }\n    }\n\n    int base = 0;\n    vector<int> used(v.size(), 0);\n    while(1) {\n      bool update = false;\n      for(int i = 0; i < v.size(); ++i) {\n        if(used[i]) continue;\n        pair<lli,lli> p = begin;\n        p.first &= v[i].first;\n        p.second &= v[i].second;\n        for(int j = 0; j < v.size(); ++j) {\n          if(used[j]) continue;\n          if(i == j) continue;\n          p.first &= ~v[j].first;\n          p.second &= ~v[j].second;\n        }\n        if(p.first != 0 || p.second != 0) {\n          ++base;\n          update = true;\n          used[i] = 1;\n          begin.first &= ~v[i].first;\n          begin.second &= ~v[i].second;\n        }\n      }\n      if(!update) break;\n    }\n    V.clear();\n    for(int i = 0; i < v.size(); ++i) {\n      if(!used[i]) V.push_back(v[i]);\n    }\n    ans = H*W;\n    rec(0, 0, begin);\n    cout << base+ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcount(n))\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[15][15],sy[15][15],sx[15][15];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx];\n\t\t\trep(a,cy,cy+l)rep(b,cx,cx+l) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n    short table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nshort first_table[10][10],max_size[10][10];\n\n\nbool rangeCheck(int row,int col){\n    if(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n    else{\n        return false;\n    }\n}\n\nvoid recursive(Info info,int base_row,int base_col){\n\n    if(info.num == ans)return;\n\n    if(base_row == H){\n        ans = info.num;\n        return;\n    }\n\n    if(info.table[base_row][base_col] == -1){\n\n        if(base_col == W-1){\n            recursive(info,base_row+1,0);\n        }else{\n            recursive(info,base_row,base_col+1);\n        }\n        return;\n    }\n\n    int new_num = 0;\n    int add = max_size[base_row][base_col]-1;\n    if(info.table[base_row+add][base_col+add] == 0){\n        new_num = 1;\n    }\n\n    if(new_num == 0){\n\n        if(base_col != W-1){\n            recursive(info,base_row,base_col+1);\n        }else{\n            recursive(info,base_row+1,0);\n        }\n    }else{\n\n        if(info.table[base_row][base_col] != 0){\n\n            if(base_col != W-1){\n                recursive(info,base_row,base_col+1);\n            }else{\n                recursive(info,base_row+1,0);\n            }\n        }\n\n        for(int i = 0; i < max_size[base_row][base_col]; i++){\n            for(int k = 0; k < max_size[base_row][base_col]; k++){\n                info.table[base_row+i][base_col+k]++;\n            }\n        }\n\n        int must_add = 0;\n        bool FLG = false;\n\n        for(int row = base_row; row <= base_row; row++){\n            for(int col = base_col+add; col < W; col++){\n               if(info.table[row][col] == 0 && first_table[row][col] > 1){\n                    FLG = true;\n                    goto SHISHIMARU;\n               }\n            }\n        }\n\n        for(int row = base_row+1; row < H; row++){\n            for(int col = 0; col < W; col++){\n                if(info.table[row][col] == 0 && first_table[row][col] > 1){\n                    FLG = true;\n                    goto SHISHIMARU;\n                }\n            }\n        }\n\nSHISHIMARU:\n\n        if(FLG)must_add++;\n\n        info.num++;\n\n        if(info.num+must_add < ans){\n            if(base_col != W-1){\n                recursive(info,base_row,base_col+1);\n            }else{\n                recursive(info,base_row+1,0);\n            }\n        }\n    }\n}\n\n\nvoid func(){\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            scanf(\"%d\",&first_table[row][col]);\n            first_table[row][col] -= 1;\n        }\n    }\n\n    bool FLG;\n    int size;\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            if(first_table[row][col] == -1){\n                max_size[row][col] = 0;\n            }else{\n                size = 1;\n\n                FLG = true;\n\n                while(true){\n                    for(int i = 0; i < size; i++){\n                        for(int k = 0; k < size; k++){\n                            if(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n                                FLG = false;\n                                break;\n                            }\n                        }\n                        if(!FLG)break;\n                    }\n                    if(!FLG){\n                        size -= 1;\n                        break;\n                    }\n                    size++;\n                }\n\n                max_size[row][col] = size;\n\n                for(int calc_size = 1; calc_size <= size; calc_size++){\n                    for(int i = 0; i < calc_size; i++){\n                        for(int k = 0; k < size; k++){\n                            first_table[row+i][col+k]++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    Info start;\n    start.num = 0;\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            if(first_table[row][col] == -1){\n            \tstart.table[row][col] = -1;\n            }else{\n                if(first_table[row][col] == 1){\n                \t start.num++;\n                \t start.table[row][col] = 1;\n                }else{\n                     start.table[row][col] = 0;\n                }\n            }\n        }\n    }\n\n    ans = BIG_NUM;\n\n    recursive(start,0,0);\n\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n\n    for(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n    while(true){\n        scanf(\"%d %d\",&W,&H);\n        if(W == 0 && H == 0)break;\n\n        func();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct square{\n\tint x,y,a; // 左上の座標, 幅\n\tbool operator<(const square &S)const{ return a<S.a; }\n};\n\nint h,w;\nint B[10][10];\n\nvector<square> S;\nint cnt[10][10]; // マス (i, j) を覆うことのできる正方形の個数\n\n#define update_cnt(i,d) for(int y=S[i].y;y<S[i].y+S[i].a;y++) for(int x=S[i].x;x<S[i].x+S[i].a;x++) cnt[y][x]+=d\n\nint hstar(int i){\n\tint n=0;\n\tstatic int val[100]; // i 番目以降の正方形で新たに覆えるマスの個数を大きい順に並べたもの\n\tfor(;i<S.size();i++){\n\t\tval[n]=0;\n\t\tfor(int y=S[i].y;y<S[i].y+S[i].a;y++) for(int x=S[i].x;x<S[i].x+S[i].a;x++) {\n\t\t\tif(B[y][x]==1) val[n]++;\n\t\t}\n\t\tn++;\n\t}\n\tsort(val,val+n,greater<int>());\n\n\tint a=0; // まだ覆っていないマスの数\n\trep(y,h) rep(x,w) if(B[y][x]==1) a++;\n\n\tint res=0;\n\tfor(i=0;a>0;i++){\n\t\ta-=val[i];\n\t\tres++;\n\t}\n\treturn res;\n}\n\nint res;\nvoid dfs(int i,int sum,int ub){\n\tif(sum+hstar(i)==ub) return;\n\tif(sum+hstar(i)>=res) return;\n\n\tif(i==S.size()){\n\t\tres=sum;\n\t\treturn;\n\t}\n\n\tbool ok1=false,ok2=false;\n\tfor(int y=S[i].y;y<S[i].y+S[i].a;y++) for(int x=S[i].x;x<S[i].x+S[i].a;x++) {\n\t\tif(B[y][x]==1) ok1=true;\n\t\tif(B[y][x]==1 && cnt[y][x]==1) ok2=true;\n\t}\n\n\tbool use=true,notuse=true;\n\t// 正方形 i を使うことで新たに覆えるマスがないなら使わない\n\tif(!ok1) use=false;\n\t// 正方形 i を使わないと絶対に覆えないマスができるようなら使う\n\tif(ok2) notuse=false;\n\n\t// いずれでもなければ両方試す\n\tupdate_cnt(i,-1);\n\tif(use){\n\t\tint tmp[10][10];\n\t\tmemcpy(tmp,B,sizeof B);\n\t\tfor(int y=S[i].y;y<S[i].y+S[i].a;y++) for(int x=S[i].x;x<S[i].x+S[i].a;x++) B[y][x]=i+2;\n\t\tdfs(i+1,sum+1,ub);\n\t\tmemcpy(B,tmp,sizeof B);\n\t}\n\tif(notuse){\n\t\tdfs(i+1,sum,ub);\n\t}\n\tupdate_cnt(i,+1);\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) rep(j,w) scanf(\"%d\",B[i]+j);\n\n\t\tS.clear();\n\t\trep(i,h) rep(j,w) if(B[i][j]==1) {\n\t\t\tint a;\n\t\t\tfor(a=1;i+a<=h&&j+a<=w;a++){\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int y=i;y<i+a;y++) for(int x=j;x<j+a;x++) if(B[y][x]==0) ok=false;\n\t\t\t\tif(!ok) break;\n\t\t\t}\n\t\t\tS.push_back((square){j,i,a-1});\n\t\t}\n\n\t\t// 他の正方形に完全に覆われるような正方形を削除\n\t\trep(i,S.size()){\n\t\t\tbool covered=false;\n\t\t\trep(j,S.size()) if(i!=j) {\n\t\t\t\tif(S[j].x<=S[i].x\n\t\t\t\t&& S[j].y<=S[i].y\n\t\t\t\t&& S[i].x+S[i].a<=S[j].x+S[j].a\n\t\t\t\t&& S[i].y+S[i].a<=S[j].y+S[j].a) covered=true;\n\t\t\t}\n\t\t\tif(covered){\n\t\t\t\tS.erase(S.begin()+i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tsort(S.begin(),S.end()); // 小さい正方形から順に調べる\n\n\t\trep(i,h) rep(j,w) cnt[i][j]=0;\n\t\trep(i,S.size()) update_cnt(i,1);\n\n\t\tres=S.size()+1;\n\t\tfor(int ub=1;;ub++){\n\t\t\tdfs(0,0,ub);\n\t\t\tif(res<S.size()+1) break;\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[12][12];\nint h[12][12][200];\nint w[12][12][200];\nint n[12][12][200];\nint sz[12][12];\nint H,W;\nint valid(int a,int b,int t){\n\tif(a<0||b<0||a+t>H||b+t>W)return 0;\n\tfor(int i=0;i<t;i++)for(int j=0;j<t;j++)if(!c[a+i][b+j])return 0;\n\treturn 1;\n}\nint lim;\nint last[100][12][12];\nint dfs(int a,int b,int v){\n\tif(a==H)return 1;\n\tif(b==W)return dfs(a+1,0,v);\n\tif(c[a][b]!=1)return dfs(a,b+1,v);\n\tif(v==lim)return 0;\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)last[v][i][j]=c[i][j];\n\tfor(int i=0;i<sz[a][b];i++){\n\t\tfor(int j=0;j<n[a][b][i];j++)for(int k=0;k<n[a][b][i];k++){\n\t\t\tc[h[a][b][i]+j][w[a][b][i]+k]=2;\n\t\t}\n\t\tif(dfs(a,b+1,v+1))return 1;\n\t\tfor(int j=0;j<n[a][b][i];j++)for(int k=0;k<n[a][b][i];k++)c[h[a][b][i]+j][w[a][b][i]+k]=last[v][h[a][b][i]+j][w[a][b][i]+k];\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%d\",&c[i][j]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)sz[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tfor(int k=1;k<=min(a,b);k++){\n\t\t\t\tif(valid(i,j,k)&&!valid(i-1,j-1,k+1)&&!valid(i-1,j,k+1)&&!valid(i,j-1,k+1)&&!valid(i,j,k+1)){\n\t\t\t\t\tfor(int l=0;l<k;l++)for(int m=0;m<k;m++){\n\t\t\t\t\t\th[i+l][j+m][sz[i+l][j+m]]=i;\n\t\t\t\t\t\tw[i+l][j+m][sz[i+l][j+m]]=j;\n\t\t\t\t\t\tn[i+l][j+m][sz[i+l][j+m]]=k;\n\t\t\t\t\t\tsz[i+l][j+m]++;\n\t\t\t\t\t//\tprintf(\"%d %d %d %d %d\\n\",i,j,k,i+l,j+m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<b;j++)for(int k=0;k<sz[i][j];k++);\n\t\t//\tprintf(\"%d %d: %d %d %d\\n\",i,j,h[i][j][k],w[i][j][k],n[i][j][k]);\n\t\tint ad=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint M=0;\n\t\t\tfor(int k=0;k<sz[i][j];k++)M=max(M,n[i][j][k]);\n\t\t\tif(M==1){\n\t\t\t\tad++;\n\t\t\t\tc[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;;i++){\n\t\t\tlim=i;\n\t\t\tif(dfs(0,0,0)){\n\t\t\t\tprintf(\"%d\\n\",ad+i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long lli;\n\nconst int MAXH = 11;\nconst int MAXW = 11;\nint W, H, N;\nint P[MAXH][MAXW];\nint dp[MAXH][MAXW];\nint dp2[MAXH][MAXW];\nvector<pair<lli,lli> > V;\nint ans;\n\nvoid rec(int p, int c, pair<lli,lli> s) {\n  if(ans <= c) return;\n  if(s.first == 0 && s.second == 0) {\n    ans = c;\n    return;\n  }\n  for(; p < V.size(); ++p) {\n    pair<lli,lli> ns = s;\n    ns.first &= ~V[p].first;\n    ns.second &= ~V[p].second;\n    rec(p+1, c+1, ns);\n  }\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    N = 0;\n    for(int i = 1; i <= H; ++i) {\n      for(int j = 1; j <= W; ++j) {\n        cin >> P[i][j];\n        N += P[i][j];\n      }\n    }\n\n    fill(dp[0], dp[MAXH], 0);\n    for(int i = 1; i <= H; ++i) {\n      for(int j = 1; j <= W; ++j) {\n        if(P[i][j]) {\n          dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1;\n        } else {\n          dp[i][j] = 0;\n        }\n      }\n    }\n    copy(dp[0], dp[MAXH], dp2[0]);\n    for(int i = 1; i <= H; ++i) {\n      for(int j = 1; j <= W; ++j) {\n        if(dp[i][j] == dp[i-1][j]+1) {\n          dp2[i-1][j] = 0;\n        }\n        if(dp[i][j] == dp[i][j-1]+1) {\n          dp2[i][j-1] = 0;\n        }\n        if(dp[i][j] == dp[i-1][j-1]+1) {\n          dp2[i-1][j-1] = 0;\n        }\n      }\n    }\n    pair<lli,lli> begin(0,0);\n    for(int i = 1; i <= H; ++i) {\n      for(int j = 1; j <= W; ++j) {\n        if(P[i][j]) {\n          lli b = (i-1)*W + j-1;\n          if(b < 50) begin.first |= 1LL<<b;\n          else begin.second |= 1LL<<(b-50);\n        }\n      }\n    }\n    V.clear();\n    for(int i = 1; i <= H; ++i) {\n      for(int j = 1; j <= W; ++j) {\n        if(dp2[i][j]) {\n          pair<lli,lli> p(0,0);\n          for(int k = 0; k < dp2[i][j]; ++k) {\n            for(int l = 0; l < dp2[i][j]; ++l) {\n              int ni = i-k-1;\n              int nj = j-l-1;\n              lli b = ni*W+nj;\n              if(b < 50) p.first |= 1LL<<b;\n              else p.second |= 1LL<<(b-50);\n            }\n          }\n          V.push_back(p);\n        }\n      }\n    }\n\n    ans = H*W;\n    rec(0, 0, begin);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\nint W, H;\nint P[20][20];\nint cover[10][10];\nint width[10][10];\nint left_h[10][10];\nint right_h[10][10];\nint top_h[10][10];\nint bottom_h[10][10];\nint ans;\nclock_t start_time;\nint h(int Y, int X){\n    int res = 0;\n    bool tmp[10][10];\n    for(int y = Y; y < H; y++)\n        for(int x = (y == Y ? X : 0); x < W; x++)\n            tmp[y][x] = !cover[y][x];\n    for(int y = Y; y < H; y++){\n        for(int x = (y == Y ? X : 0); x < W; x++){\n            if(tmp[y][x]){\n                res++;\n                for(int by = top_h[y][x]; by <= bottom_h[y][x]; by++){\n                    for(int bx = left_h[y][x]; bx <= right_h[y][x]; bx++){\n                        tmp[by][bx] = false;\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\nint dfs(int x, int y, int sum){\n    //cout << x << \" \" << y << \" \" << sum + h(y, x) << \" \" << ans << endl;\n    if((clock() - start_time) > CLOCKS_PER_SEC * 0.2) return ans;\n    if(sum + h(y, x) >= ans) return INF;\n    if(x == W) return dfs(0, y + 1, sum);\n    if(y == H){\n        return ans = sum;\n    }\n    int res = (cover[y][x] ? dfs(x + 1, y, sum) : INF);\n\n    bool tmp[10][10];\n    int max_w = 0;\n    REP(dx, width[y][x]) REP(dy, width[y][x]){\n        tmp[y + dy][x + dx] = cover[y + dy][x + dx];\n        if(!cover[y + dy][x + dx]) max_w = max(max_w, max(dx + 1, dy + 1));\n    }\n    REP(dx, width[y][x]) REP(dy, width[y][x]) cover[y + dy][x + dx] = true;\n    if(max_w > 0) res = min(res, dfs(x + 1, y, sum + 1));\n    REP(dx, max_w) REP(dy, max_w) cover[y + dy][x + dx] = tmp[y + dy][x + dx];\n    return res;\n}\n\nint main(){\n    while(cin >> W >> H && (W > 0 && H > 0)){\n        REP(y, H) REP(x, W) cin >> P[y][x];\n        REP(y, H) REP(x, W) {\n            width[y][x] = 0;\n            for(int w = 1; x + w <= W && y + w <= H; w++){\n                bool ok = true;\n                REP(dx, w) REP(dy, w) if(!P[y + dy][x + dx]) ok = false;\n                if(!ok) break;\n                width[y][x] = w;\n            }\n        }\n        REP(y, H) REP(x, W) {\n            left_h[y][x] = x;\n            while(left_h[y][x] - 1 >= 0 && P[y][left_h[y][x] - 1]) left_h[y][x]--;\n            right_h[y][x] = x;\n            while(right_h[y][x] + 1 < W && P[y][right_h[y][x] + 1]) right_h[y][x]++;\n            top_h[y][x] = y;\n            while(top_h[y][x] - 1 >= 0 && P[top_h[y][x] - 1][x]) top_h[y][x]--;\n            bottom_h[y][x] = y;\n            while(bottom_h[y][x] + 1 < H && P[bottom_h[y][x] + 1][x]) bottom_h[y][x]++;\n        }\n\n        ans = INF;\n        REP(y, H) REP(x, W) cover[y][x] = !P[y][x];\n        start_time = clock();\n        dfs(0, 0, 0);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst int MAX = 10;\nint w, h;\nbool scratch[MAX][MAX];\nbool cover[MAX][MAX];\n\ninline int square(int x) {\n\treturn x * x;\n}\n\nint sum(int sx, int sy, int gx, int gy) {\n\tif(sx > gx)\n\t\tswap(sx, gx);\n\n\tif(sy > gy)\n\t\tswap(sy, gy);\n\n\tint res = 0;\n\tfor(int i = sy; i <= gy; ++i) {\n\t\tfor(int j = sx; j <= gx; ++j) {\n\t\t\tres += scratch[i][j];\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint count_cover(int sx, int sy, int gx, int gy) {\n\tif(sx > gx)\n\t\tswap(sx, gx);\n\n\tif(sy > gy)\n\t\tswap(sy, gy);\n\n\tint res = 0;\n\tfor(int i = sy; i <= gy; ++i) {\n\t\tfor(int j = sx; j <= gx; ++j) {\n\t\t\tres += (scratch[i][j] && !cover[i][j]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\nint init() {\n\tint res = 0;\n\tmemset(cover, false, sizeof(cover));\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(!scratch[i][j] || cover[i][j])\n\t\t\t\tcontinue;\n\n\t\t\tbool up, down, left, right;\n\t\t\tup = (i == 0 || !scratch[i - 1][j]);\n\t\t\tdown = (i == h - 1 || !scratch[i + 1][j]);\n\t\t\tleft = (j == 0 || !scratch[i][j - 1]);\n\t\t\tright = (j == w - 1 || !scratch[i][j + 1]);\n\n\t\t\tif((up && down) || (left && right)) {\n\t\t\t\tcover[i][j] = true;\n\t\t\t\t++res;\n\t\t\t}\n\n\t\t\telse if(up && left) {\n\t\t\t\tint size = 1;\n\t\t\t\tfor(int k = 1;; ++k) {\n\t\t\t\t\tconst int gx = j + k, gy = i + k;\n\t\t\t\t\tif(gx >= w || gy >= h || sum(j, i, gx, gy) < square(k + 1)) {\n\t\t\t\t\t\tsize = k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t++res;\n\t\t\t\tfor(int x = j; x < j + size; ++x)\n\t\t\t\t\tfor(int y = i; y < i + size; ++y)\n\t\t\t\t\t\tcover[y][x] = true;\n\t\t\t}\n\t\t\telse if(up && right) {\n\t\t\t\tint size = 1;\n\t\t\t\tfor(int k = 1;; ++k) {\n\t\t\t\t\tconst int gx = j - k, gy = i + k;\n\t\t\t\t\tif(gx < 0 || gy >= h || sum(gx, i, j, gy) < square(k + 1)) {\n\t\t\t\t\t\tsize = k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t++res;\n\t\t\t\tfor(int x = j; x > j - size; --x)\n\t\t\t\t\tfor(int y = i; y < i + size; ++y)\n\t\t\t\t\t\tcover[y][x] = true;\n\t\t\t}\n\t\t\telse if(down && left) {\n\t\t\t\tint size = 1;\n\t\t\t\tfor(int k = 1;; ++k) {\n\t\t\t\t\tconst int gx = j + k, gy = i - k;\n\t\t\t\t\tif(gx >= w || gy < 0 || sum(j, gy, gx, i) < square(k + 1)) {\n\t\t\t\t\t\tsize = k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t++res;\n\t\t\t\tfor(int x = j; x < j + size; ++x)\n\t\t\t\t\tfor(int y = i; y > i - size; --y)\n\t\t\t\t\t\tcover[y][x] = true;\n\t\t\t}\n\t\t\telse if(down && right) {\n\t\t\t\tint size = 1;\n\t\t\t\tfor(int k = 1;; ++k) {\n\t\t\t\t\tconst int gx = j - k, gy = i - k;\n\t\t\t\t\tif(gx < 0 || gy < 0 || sum(gx, gy, j, i) < square(k + 1)) {\n\t\t\t\t\t\tsize = k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t++res;\n\t\t\t\tfor(int x = j; x > j - size; --x)\n\t\t\t\t\tfor(int y = i; y > i - size; --y)\n\t\t\t\t\t\tcover[y][x] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t\tcin >> scratch[i][j];\n\n\t\tint ans = init();\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(scratch[i][j] && !cover[i][j]) {\n\t\t\t\t\t++ans;\n\t\t\t\t\tbool right = true;\n\n\t\t\t\t\tint rsize = 1;\n\t\t\t\t\tfor(int k = 1;; ++k) {\n\t\t\t\t\t\tconst int gx = j + k, gy = i + k;\n\t\t\t\t\t\tif(gx >= w || gy >= h || sum(j, i, gx, gy) < square(k + 1)) {\n\t\t\t\t\t\t\trsize = k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint rcover = count_cover(j, i, j + (rsize - 1), i + (rsize - 1));\n\n\t\t\t\t\tint lsize = 1;\n\t\t\t\t\tfor(int k = 1;; ++k) {\n\t\t\t\t\t\tconst int gx = j - k, gy = i + k;\n\t\t\t\t\t\tif(gx < 0 || gy >= h || sum(gx, i, j, gy) < square(k + 1)) {\n\t\t\t\t\t\t\tlsize = k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint lcover = count_cover(j, i, j - (lsize - 1), i + (lsize - 1));\n\t\t\t\t\tif(rsize > lsize || (rsize == lsize && rcover > lcover)) {\n\t\t\t\t\t\tfor(int x = j; x < j + rsize; ++x)\n\t\t\t\t\t\t\tfor(int y = i; y < i + rsize; ++y)\n\t\t\t\t\t\t\t\tcover[y][x] = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor(int x = j; x > j - lsize; --x)\n\t\t\t\t\t\t\tfor(int y = i; y < i + lsize; ++y)\n\t\t\t\t\t\t\t\tcover[y][x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n/*\n\t\tcout << \"scratch\" << endl;\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t\tcout << scratch[i][j] << (j == w - 1 ? \"\\n\" : \" \");\n\t\tcout << endl;\n\n\t\tcout << \"cover\" << endl;\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t\tcout << cover[i][j] << (j == w - 1 ? \"\\n\" : \" \");\n\t\tcout << endl;\n*/\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <random>\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 11\n\n#define P3(a,b,c) make_pair(make_pair(a,b),c)\n\nint h, w;\nint t[SIZE][SIZE], t2[SIZE][SIZE];\nint max_size[11][11] = {};\nint covered[11][11] = {};\nmap<pair<pair<ll,ll>,int>,int> visited;\n\nint ans;\n\nvoid dfs(int y, int x, int counter = 0, ll hash = 0, ll hash2 = 0){\n  //debug(ans);\n  int diff[11][11] = {};\n  if(ans <= counter) return;\n  auto it = visited.find(P3(hash,hash2,y*w+x));\n  if(it != visited.end() && it->second <= counter) return;\n  \n  if(y == h){\n    ans = min(ans, counter);\n    return;\n  }\n\n  if(max_size[y][x] == 0 || covered[y][x])\n    dfs(y + (x == w-1), (x + 1)%w, counter, hash, hash2);\n  \n  if(max_size[y][x] != 0){\n    ll newhash = hash, newhash2 = hash2;\n    int diffcounter = 0;\n    for(int i=0;i<max_size[y][x];i++)\n      for(int j=0;j<max_size[y][x];j++)\n        if(covered[y+i][x+j] == 0){\n          diff[y+i][x+j] = covered[y+i][x+j] = 1;\n          newhash ^= t[y+i][x+j];\n          newhash2 ^= t2[y+i][x+j];\n          diffcounter++;\n        }\n\n    if(diffcounter)\n      dfs(y + (x == w-1), (x + 1)%w, counter+1, newhash, newhash2);\n\n    for(int i=0;i<max_size[y][x];i++)\n      for(int j=0;j<max_size[y][x];j++)\n        if(diff[y+i][x+j] == 1){\n          covered[y+i][x+j] = 0;\n        }\n  }\n  \n  visited[P3(hash,hash2,y*w+x)] = counter;\n}\n\nbool solve(){\n  int sp[11][11] = {};\n  int p[11][11];\n  //debug(clock());\n  \n  scanf(\"%d%d\", &w, &h);\n\n  if(h == 0) return false;\n\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      scanf(\"%d\", p[i]+j);\n      sp[i][j] = p[i][j];\n    }\n  }\n\n  for(int i=h;i>0;i--)\n    for(int j=0;j<=w;j++)\n      sp[i-1][j] += sp[i][j];\n\n  for(int i=0;i<=h;i++)\n    for(int j=w;j>0;j--)\n      sp[i][j-1] += sp[i][j];\n\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      int p = min(h-i, w-j);\n      max_size[i][j] = 0;\n      for(int k=1;k<=p;k++){\n        if(sp[i][j] + sp[i+k][j+k] - sp[i+k][j] - sp[i][j+k] == k*k) max_size[i][j] = k;\n        //debug(sp[i][j] + sp[i+k][j+k] - sp[i+k][j] - sp[i][j+k]);\n      }\n      //debug(max_size[i][j]);\n    }\n  }\n\n  //debug(clock());\n\n  visited = map<pair<pair<ll,ll>,int>,int >();\n  ans = INF;\n  dfs(0,0,0,0,0);\n  printf(\"%d\\n\", ans);\n\n  return true;\n}\n\nint main(){\n  std::random_device rd;\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      t[i][j] = ((ll)rd() << 32) + rd(); \n      t2[i][j] = ((ll)rd() << 32) + rd(); \n    }\n  }\n\n  //debug(clock());\n  \n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nstruct state\n{\n\tvector<vector<int> > v;\n\n\tint dist1;\n\tint dist2;\n\n\tint r;\n\n\tstate(vector<vector<int> > v1, int d1, int d2, int r1) : v(v1), dist1(d1), dist2(d2), r(r1) { }\n};\n\nint W, H;\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 + s1.r * s1.r < s2.dist1 + s2.dist2 + s2.r * s2.r; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 + s1.r * s1.r > s2.dist1 + s2.dist2 + s2.r * s2.r; }\n\nvector<vector<int> > start;\n\nmap<vector<vector<int> >, bool> M;\n\nint getdistance(vector<vector<int> > v)\n{\n\tint ret = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (v[i][j] == 1)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tint reps = min(W, H);\n\n\t\tM.clear();\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tstart = vector<vector<int> >(H, vector<int>(W));\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &start[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<state, vector<state>, greater<state> > que;\n\n\t\tque.push(state(start, 0, getdistance(start), reps)); M[start] = true;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tstate s1 = que.top(); que.pop();\n\n\t\t\tif (s1.dist2 == 0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", s1.dist1); break;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= s1.r; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= H - i; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= W - i; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > v2 = s1.v;\n\n\t\t\t\t\t\tbool flag = false;\n\n\t\t\t\t\t\tfor (int l = j; l < j + i; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = k; m < k + i; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (v2[l][m] == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflag = true; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tv2[l][m] = 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flag) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!M[v2])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tM[v2] = true;\n\n\t\t\t\t\t\t\t\tque.push(state(v2, s1.dist1 + 1, getdistance(v2), i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <random>\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nint h, w;\nint t[SIZE][SIZE], t2[SIZE][SIZE];\nint max_size[11][11] = {};\nint covered[11][11] = {};\nset<pair<pair<ll,ll>,int> > visited;\n\nint ans;\n\nvoid dfs(int y, int x, int counter = 0, ll hash = 0, ll hash2 = 0){\n  //debug(ans);\n  int diff[11][11] = {};\n  if(ans <= counter) return;\n  if(visited.find({{hash,hash2},y*w+x}) != visited.end()) return;\n  \n  if(y == h){\n    ans = min(ans, counter);\n    return;\n  }\n\n  if(max_size[y][x] == 0 || covered[y][x])\n     dfs(y + (x == w-1), (x + 1)%w, counter, hash);\n  \n  if(max_size[y][x] != 0){\n    ll newhash = hash, newhash2 = hash2;\n    int diffcounter = 0;\n    for(int i=0;i<max_size[y][x];i++)\n      for(int j=0;j<max_size[y][x];j++)\n        if(covered[y+i][x+j] == 0){\n          diff[y+i][x+j] = covered[y+i][x+j] = 1;\n          newhash ^= t[y+i][x+j];\n          newhash2 ^= t2[y+i][x+j];\n          diffcounter++;\n        }\n\n    if(diffcounter)\n      dfs(y + (x == w-1), (x + 1)%w, counter+1, newhash);\n\n    for(int i=0;i<max_size[y][x];i++)\n      for(int j=0;j<max_size[y][x];j++)\n        if(diff[y+i][x+j] == 1){\n          covered[y+i][x+j] = 0;\n        }\n  }\n  \n  visited.insert({{hash,hash2},y*w+x});\n}\n\nbool solve(){\n  int sp[11][11] = {};\n  int p[11][11];\n  debug(clock());\n  \n  scanf(\"%d%d\", &w, &h);\n\n  if(h == 0) return false;\n\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      scanf(\"%d\", p[i]+j);\n      sp[i][j] = p[i][j];\n    }\n  }\n\n  for(int i=h;i>0;i--)\n    for(int j=0;j<=w;j++)\n      sp[i-1][j] += sp[i][j];\n\n  for(int i=0;i<=h;i++)\n    for(int j=w;j>0;j--)\n      sp[i][j-1] += sp[i][j];\n\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      int p = min(h-i, w-j);\n      max_size[i][j] = 0;\n      for(int k=1;k<=p;k++){\n        if(sp[i][j] + sp[i+k][j+k] - sp[i+k][j] - sp[i][j+k] == k*k) max_size[i][j] = k;\n        //debug(sp[i][j] + sp[i+k][j+k] - sp[i+k][j] - sp[i][j+k]);\n      }\n      //debug(max_size[i][j]);\n    }\n  }\n\n  debug(clock());\n\n  visited = set<pair<pair<ll,ll>,int> >();\n  ans = INF;\n  dfs(0,0);\n  printf(\"%d\\n\", ans);\n\n  return true;\n}\n\nint main(){\n  std::random_device rd;\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      t[i][j] = ((ll)rd() << 32) + rd(); \n      t2[i][j] = ((ll)rd() << 32) + rd(); \n    }\n  }\n\n  debug(clock());\n  \n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nint H,W,mincost;\nint P[10][10],bin[10],bc[(1<<10)];\nint put[10][10],weight[10][10],counter[10][10];\n\nbool can_put(int len,int x,int y){\n  REP(i,y,y+len)REP(j,x,x+len) if( !P[i][j] ) return false;\n  return true;\n}\n\nvoid dfs(int cur,int cost,int remain){\n\n  if( cost >= mincost ) return;\n  if( cost + ((remain>0)?1:0) >= mincost ) return;\n\n\n  if( cur >= H*W ) {\n    mincost = min(mincost,cost);\n    return;\n  }\n\n  int x = cur % W, y = cur / W;\n  if( cost + max(0,weight[y][x]-5) >= mincost ) return;\n\n  if( !P[y][x] || counter[y][x] == 1 ) {\n    dfs(cur+1,cost,remain);\n    return;\n  }\n\n  if( (bin[y]>>x) & 1 ) dfs(cur+1,cost,remain);\n\n  int len = put[y][x];\n  int bitmask = ((1<<len)-1)<<x;\n  int buf[len];\n  int add = 0, nremain = remain;\n  rep(j,len) {\n    buf[j] = bin[y+j];\n    add += len - bc[((1<<len)-1)&(bin[y+j]>>x)];\n    bin[y+j] |= bitmask;\n  }\n  nremain -= add;\n  if( add ) dfs(cur+1,cost+1,nremain);\n  rep(j,len) bin[y+j] = buf[j];\n\n}\n\nint par[110];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint find(int x){\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\ninline void unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = par[y];\n}\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\nint main(){\n\n  rep(i,(1<<10)) bc[i] = __builtin_popcount(i);\n\n  while( scanf(\"%d%d\",&W,&H), W | H ){\n\n    rep(i,H){\n      bin[i] = 0;\n      rep(j,W){\n        cin >> P[i][j];\n        put[i][j] = 0;\n      }\n    }\n\n\n    rep(i,H*W) par[i] = i;\n\n    rep(i,H)rep(j,W)if(!P[i][j])rep(k,4){\n      int nx = j + dx[k], ny = i + dy[k];\n      if( !isValid(nx,ny) ) continue;\n      if( !P[ny][nx] ) unit(j+i*W,nx+ny*W);\n    }\n\n    rep(i,H)rep(j,W)weight[i][j] = 0;\n\n    set<int> S;\n    bool first = false;\n    for(int i=H-1;i>=0;i--) for(int j=W-1;j>=0;j--) {\n        if( P[i][j] ) first = true;\n        if( first && !P[i][j] ) S.insert(find(j+i*W));\n        weight[i][j] = S.size();\n      }\n\n    rep(y,H) rep(x,W) if( P[y][x] ) {\n      for(int len=min(H,W);len>=1;len--){\n        if( x + len - 1 < W && y + len - 1 < H ) {\n          if( can_put(len,x,y) ){\n            put[y][x] = len;\n            break;\n          }\n        }\n      }\n    }\n\n    rep(i,H)rep(j,W) counter[i][j] = 0;\n    rep(i,H)rep(j,W)if(P[i][j]){\n      REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n        counter[y][x]++;\n      }\n    }\n\n    rep(i,H){\n      rep(j,W){\n        if( counter[i][j] == 1 ){\n          REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n            bin[y] |= (1<<x);\n          }\n        }\n      }\n    }\n\n    int add = 0;\n    int remain = 0;\n    mincost = 0;\n    rep(i,H)rep(j,W)remain += ((bin[i]>>j)&1),mincost += P[i][j];\n\n    dfs(0,0,remain);\n\n    rep(i,H)rep(j,W)if(counter[i][j]==1)add++;\n    cout << mincost+add << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint w, h;\nint A[10][10], B[10][10], used[10][10][10][10];\n\nint update(int y, int x){\n  \n  if( A[y][x] == 0 ) return 0;\n  \n  for(int i=y;i<h;i++)\n    for(int j=x;j<w;j++) used[y][x][i][j] = 0;\n  \n  int L;\n  \n  for(int l=min(h-y-1, w-x-1);l>=0;l--){\n\n    int flag = 1, cnt = 0;\n    \n    for(int i=y;i<=y+l;i++){\n      \n      for(int j=x;j<=x+l;j++){\n\t\n\tif( A[i][j] == 0 ) flag = 0;\n\tif( B[i][j] ) cnt++;\n\t\n\tif( !flag ) break;\n\t\n      }\n      \n      if( !flag ) break;\n      \n    }\n    \n    if( flag ){\n      \n      if( cnt == 0 ) return 0;\n      L = l;\n      \n      break;\n    }\n    \n  }\n  \n  for(int i=y;i<=y+L;i++){\n    for(int j=x;j<=x+L;j++){\n      used[y][x][i][j] = B[i][j];\n      B[i][j] = 0;\n    }\n  }\n  \n  return 1;\n}\n\nvoid add(int y, int x){\n  \n  for(int i=y;i<h;i++)\n    for(int j=x;j<w;j++) B[i][j] += used[y][x][i][j];\n  \n}\n\ntypedef unsigned long long ull;\n\nmap<ull,int> memo[10][10];\n\null Hash(int y, int x){\n  \n  ull res = 0;\n  ull base = 1777771;\n  \n  for(int i=y;i<h;i++){\n    int s = 0;\n    if( i == y ) s = x;\n    for(int j=s;j<w;j++){\n      res = res * base + ( B[i][j] + 1 );\n    }\n  }\n  \n  return res;\n}\n\nint dfs(int y, int x){\n\n  if( y == h - 1 && x == w - 1 ) return B[y][x];\n  \n  ull H = Hash( y, x );\n  \n  if( memo[y][x].count( H ) ) return memo[y][x][H];\n  \n  int res = INF;\n  \n  int ny = y, nx = x + 1;\n  if( nx == w ) ny++, nx = 0;\n  \n  if( B[y][x] == 0 ) res = dfs( ny, nx );\n  \n  int r = update( y, x );\n  \n  res = min( res, r + dfs( ny, nx ) );\n  \n  add( y, x );\n  \n  return memo[y][x][H] = res;\n}\n\nsigned main(){\n\n  while(1){\n    \n    cin>>w>>h;\n    if( !w && !h ) break;\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) memo[i][j].clear();\n    \n    memset(used,0,sizeof(used));\n    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>A[i][j];\n\tB[i][j] = A[i][j];\n      }\n    }\n  \n    cout << dfs( 0, 0 ) << endl;\n  \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nint H,W,mincost;\nint P[10][10],bin[10],bc[(1<<10)];\nint put[10][10],weight[10][10],counter[10][10];\n\nbool can_put(int len,int x,int y){\n  REP(i,y,y+len)REP(j,x,x+len) if( !P[i][j] ) return false;\n  return true;\n}\n\nvoid dfs(int cur,int cost,int remain){\n\n  if( cost >= mincost ) return;\n  if( cost + ((remain>0)?1:0) >= mincost ) return;\n\n\n  if( cur >= H*W ) {\n    mincost = min(mincost,cost);\n    return;\n  }\n\n  int x = cur % W, y = cur / W;\n  if( cost + max(0,weight[y][x]-3) >= mincost ) return;\n\n  if( !P[y][x] || counter[y][x] == 1 ) {\n    dfs(cur+1,cost,remain);\n    return;\n  }\n\n  if( (bin[y]>>x) & 1 ) dfs(cur+1,cost,remain);\n\n  int len = put[y][x];\n  int bitmask = ((1<<len)-1)<<x;\n  int buf[len];\n  int add = 0, nremain = remain;\n  rep(j,len) {\n    buf[j] = bin[y+j];\n    add += len - bc[((1<<len)-1)&(bin[y+j]>>x)];\n    bin[y+j] |= bitmask;\n  }\n  nremain -= add;\n  if( add ) dfs(cur+1,cost+1,nremain);\n  rep(j,len) bin[y+j] = buf[j];\n\n}\n\nint par[110];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint find(int x){\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\ninline void unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = par[y];\n}\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\nint main(){\n\n  rep(i,(1<<10)) bc[i] = __builtin_popcount(i);\n\n  while( scanf(\"%d%d\",&W,&H), W | H ){\n\n    rep(i,H){\n      bin[i] = 0;\n      rep(j,W){\n        cin >> P[i][j];\n        put[i][j] = 0;\n      }\n    }\n\n\n    rep(i,H*W) par[i] = i;\n\n    rep(i,H)rep(j,W)if(!P[i][j])rep(k,4){\n      int nx = j + dx[k], ny = i + dy[k];\n      if( !isValid(nx,ny) ) continue;\n      if( !P[ny][nx] ) unit(j+i*W,nx+ny*W);\n    }\n\n    rep(i,H)rep(j,W)weight[i][j] = 0;\n\n    set<int> S;\n    bool first = false;\n    for(int i=H-1;i>=0;i--) for(int j=W-1;j>=0;j--) {\n        if( P[i][j] ) first = true;\n        if( first && !P[i][j] ) S.insert(find(j+i*W));\n        weight[i][j] = S.size();\n      }\n\n    rep(y,H) rep(x,W) if( P[y][x] ) {\n      for(int len=min(H,W);len>=1;len--){\n        if( x + len - 1 < W && y + len - 1 < H ) {\n          if( can_put(len,x,y) ){\n            put[y][x] = len;\n            break;\n          }\n        }\n      }\n    }\n\n    rep(i,H)rep(j,W) counter[i][j] = 0;\n    rep(i,H)rep(j,W)if(P[i][j]){\n      REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n        counter[y][x]++;\n      }\n    }\n\n    rep(i,H){\n      rep(j,W){\n        if( counter[i][j] == 1 ){\n          REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n            bin[y] |= (1<<x);\n          }\n        }\n      }\n    }\n\n    int add = 0;\n    int remain = 0;\n    mincost = 0;\n    rep(i,H)rep(j,W)remain += ((bin[i]>>j)&1),mincost += P[i][j];\n\n    dfs(0,0,remain);\n\n    rep(i,H)rep(j,W)if(counter[i][j]==1)add++;\n    cout << mincost+add << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n    short table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nshort first_table[10][10],max_size[10][10];\n\n\nbool rangeCheck(int row,int col){\n    if(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n    else{\n        return false;\n    }\n}\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n    if(info.num == ans)return;\n\n    if(base_row == H){\n        ans = info.num;\n        return;\n    }\n\n    if(info.table[base_row][base_col] == -1){\n\n        if(base_col == W-1){\n            recursive(info,base_row+1,0,pre_must_add);\n        }else{\n            recursive(info,base_row,base_col+1,pre_must_add);\n        }\n        return;\n    }\n\n    int new_num = 0;\n    int add = max_size[base_row][base_col]-1;\n    if(info.table[base_row+add][base_col+add] == 0 || info.table[base_row+add][base_col+add-1] == 0){\n        new_num = 1;\n    }\n\n    if(new_num == 0){\n\n        if(base_col != W-1){\n            recursive(info,base_row,base_col+1,pre_must_add);\n        }else{\n            recursive(info,base_row+1,0,pre_must_add);\n        }\n    }else{\n\n        if(info.table[base_row][base_col] != 0){\n\n            if(base_col != W-1){\n                recursive(info,base_row,base_col+1,pre_must_add);\n            }else{\n                recursive(info,base_row+1,0,pre_must_add);\n            }\n        }\n\n        for(int i = 0; i < max_size[base_row][base_col]; i++){\n            for(int k = 0; k < max_size[base_row][base_col]; k++){\n                info.table[base_row+i][base_col+k]++;\n            }\n        }\n\n        int must_add = 0;\n        bool FLG = false;\n\n        for(int row = base_row; row <= base_row; row++){\n            for(int col = base_col+add; col < W; col++){\n                if(info.table[row][col] == 0 && first_table[row][col] == 1){\n                    must_add++;\n                }else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n                    FLG = true;\n                }\n            }\n        }\n\n        for(int row = base_row+1; row < H; row++){\n            for(int col = 0; col < W; col++){\n                if(info.table[row][col] == 0 && first_table[row][col] == 1){\n                    must_add++;\n                }else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n                    FLG = true;\n                }\n            }\n        }\n\n\n        if(FLG)must_add++;\n\n        info.num++;\n\n        if(info.num+must_add < ans){\n            if(base_col != W-1){\n                recursive(info,base_row,base_col+1,must_add);\n            }else{\n                recursive(info,base_row+1,0,must_add);\n            }\n        }\n    }\n}\n\n\nvoid func(){\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            scanf(\"%d\",&first_table[row][col]);\n            first_table[row][col] -= 1;\n        }\n    }\n\n    bool FLG;\n    int size;\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            if(first_table[row][col] == -1){\n                max_size[row][col] = 0;\n            }else{\n                size = 1;\n\n                FLG = true;\n\n                while(true){\n                    for(int i = 0; i < size; i++){\n                        for(int k = 0; k < size; k++){\n                            if(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n                                FLG = false;\n                                break;\n                            }\n                        }\n                        if(!FLG)break;\n                    }\n                    if(!FLG){\n                        size -= 1;\n                        break;\n                    }\n                    size++;\n                }\n\n                max_size[row][col] = size;\n\n                for(int calc_size = 1; calc_size <= size; calc_size++){\n                    for(int i = 0; i < calc_size; i++){\n                        for(int k = 0; k < size; k++){\n                            first_table[row+i][col+k]++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    Info start;\n    start.num = 0;\n    int pre_must_add = 0;\n    FLG = false;\n\n    for(int row = 0; row < H; row++){\n        for(int col = 0; col < W; col++){\n            if(first_table[row][col] == -1){\n                start.table[row][col] = -1;\n            }else{\n                if(first_table[row][col] == 1){\n                    pre_must_add++;\n                }else{\n                    FLG = true;\n                }\n                start.table[row][col] = 0;\n            }\n        }\n    }\n\n    if(FLG)pre_must_add++;\n\n    ans = BIG_NUM;\n\n    recursive(start,0,0,pre_must_add);\n\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n\n    for(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n    while(true){\n        scanf(\"%d %d\",&W,&H);\n        if(W == 0 && H == 0)break;\n\n        func();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nstruct state\n{\n\tvector<vector<int> > v;\n\n\tint dist1;\n\tint dist2;\n\n\tstate(vector<vector<int> > v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 < s2.dist1 + s2.dist2; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 > s2.dist1 + s2.dist2; }\n\nint W, H; vector<vector<int> > start;\n\nmap<vector<vector<int> >, bool> M;\n\nint getdistance(vector<vector<int> > v)\n{\n\tint ret = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (v[i][j] == 1)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tM.clear();\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tstart = vector<vector<int> >(H);\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &start[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<state, vector<state>, greater<state> > que;\n\n\t\tque.push(state(start, 0, getdistance(start))); M[start] = true;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tstate s1 = que.top(); que.pop();\n\n\t\t\tif (s1.dist2 == 0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", s1.dist1); break;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= 10; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= H - i; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= W - i; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > v2 = s1.v;\n\n\t\t\t\t\t\tbool flag = true;\n\n\t\t\t\t\t\tfor (int l = j; l < j + i; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = k; m < k + i; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (v2[i][j] == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflag = true; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tv2[i][j] = 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flag) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!M[v2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tM[v2] = true;\n\n\t\t\t\t\t\t\tque.push(state(v2, s1.dist1 + 1, getdistance(v2)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 11\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nstruct dat{\n  int x,y,X,Y;\n  bool contain(dat b){return (x<=b.x && b.X<=X) && (y<=b.y && b.Y<=Y);}\n};\n\nint h,w;\nvector<dat> A;\ntypedef vector<vector<int> > V;\n\n\nint count(const V &mp,dat a){\n  int cnt = 0;\n  for(int i=a.y;i<=a.Y;i++) cnt += count(mp[i].begin()+a.x,mp[i].begin()+a.X+1,1);\n  return cnt;\n}\n\nbool contain0(V &mp,int x,int y,int X,int Y){return count(mp,(dat){x,y,X,Y}) == (X-x+1)*(Y-y+1);}\n\nstruct dat2{\n  V mp;\n  int cnt,cost;\n};\n\ndat2 getNx(dat2 t,dat a){\n  t.cost++;\n  for(int i=a.y;i<=a.Y;i++)\n    for(int j=a.x;j<=a.X;j++){\n      t.cnt -= t.mp[i][j];\n      t.mp[i][j] = 0;\n    }\n  return t;\n}\n\ndat2 erase(dat2 t){\n  int update = 1;\n  while(update--){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n        if(t.mp[i][j] == 0)continue;\n        int cnt = 0;\n        dat tmp;\n        for(dat a:A) if(a.contain((dat){j,i,j,i})) cnt++, tmp = a;\n        if(cnt == 1) t = getNx(t,tmp),update = 1;\n      }\n  }\n  return t;\n}\n\ntypedef pair<int,int> P;\nset<P> getErased(const V &mp,const dat &a){\n  set<P> res;\n  for(int i=a.y;i<=a.Y;i++)\n    for(int j=a.x;j<=a.X;j++)\n      if(mp[i][j]) res.insert(P(i,j));\n  return res;\n}\n\nint bfs(V start){\n  queue<dat2> Q;\n  set<V> used;\n  Q.push((dat2){start,count(start,(dat){0,0,w-1,h-1}),0});\n\n  while(1){\n    dat2 t = erase(Q.front());Q.pop();\n    if(t.cnt == 0) return t.cost;\n    if(used.count(t.mp))continue;\n    used.insert(t.mp);\n\n    dat nx;\n    for(dat a:A) if(count(t.mp,a)) nx = a;\n    set<P> S = getErased(t.mp,nx);\n    for(dat a:A){\n      set<P> s = getErased(t.mp,a);\n      int cnt = 0;\n      for(P p:s) cnt += S.count(p);\n      if(cnt) Q.push(getNx(t,a));\n    }\n  }\n}\n\nsigned main(){\n  while(1){\n    cin>>w>>h;\n    if(w == 0 && h == 0)break;\n\n    V mp = V(h,vector<int>(w));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>mp[i][j];\n    \n    A.clear();\n    for(int y=0;y<h;y++)\n      for(int x=0;x<w;x++){\n        dat a = (dat){-1,-1,-1,-1};\n        for(int Y=y, X=x; Y<h && X<w ;Y++, X++) if(contain0(mp,x,y,X,Y)) a = (dat){x,y,X,Y};\n        if(a.x != -1) A.push_back(a);\n      }\n    \n    for(int i=0;i<(int)A.size();i++)\n      for(int j=0;j<(int)A.size();j++) if(i!=j && A[i].contain(A[j]))A.erase(A.begin()+j--);\n    cout<<bfs(mp)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nint W, H;\nint grid[10][10];\nint len[10][10];\nvector<int> xs, ys;\nint ub;\nbool used[10][10];\nconst int INF = 1000000000;\nint dfs(int k, int use, int fill){\n    if(use >= ub) return INF;\n    if(fill == 0){\n        return ub = use;\n    }\n    if(k == xs.size()) return INF;\n    int res = INF;\n    int x = xs[k];\n    int y = ys[k];\n    bool used_d[10][10];\n    memcpy(used_d, used, sizeof(used));\n    REP(sy, y) REP(sx, W) if(!used[sy][sx] && grid[sy][sx]) return INF;\n    int nfill = fill;\n    REP(dy, len[y][x]) REP(dx, len[y][x]){\n        if(!used[y + dy][x + dx] && grid[y + dy][x + dx]){\n            used[y + dy][x + dx] = true;\n            nfill--;\n        }\n    }\n    if(nfill < fill){\n        res = min(res, dfs(k + 1, use + 1, nfill));\n    }\n    memcpy(used, used_d, sizeof(used));\n    if(used[y][x]){\n        res = min(res, dfs(k + 1, use, fill));\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> W >> H && W){\n        REP(y, H) REP(x, W) cin >> grid[y][x];\n        // 最大の正方形を計算\n        REP(y, H) REP(x, W){\n            len[y][x] = 0;\n            for(int d = 1; x + d <= W && y + d <= W; d++){\n                bool ok = true;\n                REP(dy, d) REP(dx, d) if(!grid[y + dy][x + dx]) ok = false;\n                if(ok) len[y][x] = d;\n            }\n        }\n        // 包含されている正方形をチェック\n        REP(y, H) REP(x, W) {\n            REP(ly, y + 1) REP(lx, x + 1){\n                if(ly == y && lx == x) continue;\n                if(ly + len[ly][lx] >= y + len[y][x] && lx + len[ly][lx] >= x + len[y][x]){\n                    len[y][x] = 0;\n                }\n            }\n        }\n\n        xs.clear();\n        ys.clear();\n        int erase = 0;\n        REP(y, H) REP(x, W){\n            if(len[y][x] > 1) {\n                xs.push_back(x);\n                ys.push_back(y);\n            }\n            if(len[y][x] == 1){\n                grid[y][x] = 0;\n                erase++;\n            }\n        }\n        //cout << xs.size() << \" \" << ys.size() << endl;\n\n\n        int count = 0;\n        REP(y, H) REP(x, W) count += grid[y][x];\n        int ans;\n        for(ub = 0; ; ub++){\n            ans = dfs(0, 0, count);\n            if(ans < INF) break;\n        }\n        cout << ans + erase << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 11\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nstruct dat{\n  int x,y,X,Y;\n  bool contain(dat b){return (x<=b.x && b.X<=X) && (y<=b.y && b.Y<=Y);}\n};\n\nint h,w;\nvector<dat> A;\ntypedef vector<vector<int> > V;\nvector<vector<int> > mp;\n\nbool contain0(int x,int y,int X,int Y){\n  for(int i=y;i<=Y;i++)\n    for(int j=x;j<=X;j++) if(mp[i][j] == 0) return 1;\n  return 0;\n}\n\nbool compare(const dat &a,const dat &b){\n  int cntA = 0,cntB = 0;\n  for(int i=a.y;i<=a.Y;i++) cntA += count(mp[i].begin()+a.x,mp[i].begin()+a.X+1,1);\n  for(int i=b.y;i<=b.Y;i++) cntB += count(mp[i].begin()+b.x,mp[i].begin()+b.X+1,1);\n  return cntA!=cntB? cntA>cntB:(a.y!=b.y? a.y<b.y:a.x<b.x);\n}\n\nbool equal(const dat &a,const dat &b){return !compare(a,b)&&!compare(b,a);}\n\nstruct dat2{\n  V mp;\n  int cnt,cost;\n};\n\ndat2 getNx(V mp,int cnt,int cost,dat a){\n  for(int i=a.y;i<=a.Y;i++)\n    for(int j=a.x;j<=a.X;j++){\n      cnt -= mp[i][j];\n      mp[i][j] = 0;\n    }\n  return (dat2){mp,cnt,cost+1};\n}\n\nint bfs(V start){\n  int cnt = 0;\n  for(vector<int> &v:start) cnt += count(v.begin(),v.end(),1);\n\n  set<V> used;\n  queue<dat2> Q;\n  Q.push((dat2){start,cnt,0});\n  used.insert(start);\n  \n  while(!Q.empty()){\n    dat2 t = Q.front();Q.pop();\n    if(t.cnt == 0) return t.cost;\n    mp = t.mp;\n    sort(A.begin(),A.end(),compare);\n    dat2 nt = getNx(t.mp,t.cnt,t.cost,A[0]);\n    \n    if(used.count(nt.mp)) continue;\n    used.insert(nt.mp);\n    Q.push(nt);\n\n  }\n  assert(!\"error\");\n}\n\nsigned main(){\n  while(1){\n    cin>>w>>h;\n    if(w == 0 && h == 0)break;\n\n    mp = V(h,vector<int>(w));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>mp[i][j];\n    \n    A.clear();\n    for(int y=0;y<h;y++)\n      for(int x=0;x<w;x++){\n        dat a = (dat){-1,-1,-1,-1};\n        for(int Y=y, X=x; Y<h && X<w ;Y++, X++) if(!contain0(x,y,X,Y)) a = (dat){x,y,X,Y};\n        if(a.x != -1) A.push_back(a);\n      }\n\n    for(int i=0;i<(int)A.size();i++)\n      for(int j=0;j<(int)A.size();j++) if(i!=j && A[i].contain(A[j]))A.erase(A.begin()+j--);\n    cout<<bfs(mp)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\n#include<map>\n#define MAX_W 10\n#define INF 1E9\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nconst ull B = 100000007;\nint w, h; \nint s[MAX_W][MAX_W]; //可延伸的最大正方形邊長\nint contain[MAX_W][MAX_W];\nint limit;\nint ct;\nunordered_map<ull, int> mp;\n\nstruct P{\n\tint x, y, size;\n\tP() {}\n\tP(int x, int y, int size) : x(x), y(y), size(size) {}\n\tbool operator < (const P& other) const{\n\t\treturn size < other.size;\n\t}\n};\nvoid show(vector<int>& cover){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tprintf(\"%d \", (cover[i] >> (w - 1 - j)) & 1);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\nvoid init(vector<int>& f){\n\tmemset(contain, 0, sizeof(contain));\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\ts[i][j] = (f[i] >> (w - 1 - j)) & 1;\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tfor(int k = 0;; k++){\n\t\t\t\tbool ok = true;\n\t\t\t\tif(i + k < h && j + k < w){\n\t\t\t\t\tfor(int l = 0; ok && l <= k; l++){\n\t\t\t\t\t\tif(s[i + k][j + l] == 0 || s[i + l][j + k] == 0) ok = false;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\ts[i][j] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int a = 0; a < s[i][j]; a++){\n\t\t\t\tfor(int b = 0; b < s[i][j]; b++){\n\t\t\t\t\tcontain[i + a][j + b]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\null calc_hash(vector<int>& f){\n\tull t = 0;\n\tfor(int i = 0; i < f.size(); i++){\n\t\tt = t * B + f[i];\n\t}\n\treturn t;\n}\nint hstar(vector<int> f, bool first){\n\t//選取盡量多的點，其中每個集合最多只能有一個點被選中\n\tif(!first){\n\t\tint res = 0;\n\t\tbool update;\n\t\tvector<int> reset(f.begin(), f.end());\n\t\tdo{\n\t\t\tupdate = false;\n\t\t\tint m_i, m_j, max = 0;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(s[i][j] > 0){\n\t\t\t\t\t\tint tmp = 0, m = ((1 << s[i][j]) - 1) <<  (w - j - s[i][j]);\n\t\t\t\t\t\tfor(int k = 0; k < s[i][j]; k++){\n\t\t\t\t\t\t\ttmp += __builtin_popcount(f[i + k] & m);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(max < tmp){\n\t\t\t\t\t\t\tmax = tmp;\n\t\t\t\t\t\t\tm_i = i, m_j = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max > 0){\n\t\t\t\tint m = ((1 << s[m_i][m_j]) - 1) << (w - m_j - s[m_i][m_j]);\n\t\t\t\tfor(int i = 0; i < s[m_i][m_j]; i++) f[m_i + i] &= ~m;\n\t\t\t\tres++;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}while(update);\n\t\treturn res;\n\t}\n\t// f.assign(reset.begin(), reset.end());\n\tvector<P> ps, X;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif((f[i] >> (w - 1 - j)) & 1){\n\t\t\t\tps.push_back(P(i, j, contain[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(ps.begin(), ps.end());\n\tfor(int i = 0; i < ps.size(); i++){\n\t\tbool ok = true;\n\t\tfor(int j = 0; j < X.size() && ok; j++){\n\t\t\tint x1 = min(ps[i].x, X[j].x), y1 = min(ps[i].y, X[j].y);\n\t\t\tfor(int k = x1; k >= 0 && ok; k--){\n\t\t\t\tif(k + s[k][y1] > ps[i].x && k + s[k][y1] > X[j].x && \n\t\t\t\t   y1 + s[k][y1] > ps[i].y && y1 + s[k][y1] > X[j].y){\n\t\t\t\t\t   ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = y1; k >= 0 && ok; k--){\n\t\t\t\tif(x1 + s[x1][k] > ps[i].x && x1 + s[x1][k] > X[j].x &&\n\t\t\t\t   k + s[x1][k] > ps[i].y && k + s[x1][k] > X[j].y){\n\t\t\t\t\t   ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok) X.push_back(ps[i]);\n\t}\n\t\n\t// for(int i = 0; i < X.size(); i++){\n\t\t// printf(\"%d %d\\n\", X[i].x, X[i].y);\n\t// }\n\treturn X.size();\n\t// return res;\n}\n\nint dfs(int num, vector<int> f){\n\tif(num + hstar(f, false) > limit) return INF;\n\t\n\tull t = calc_hash(f);\n\t// if(mp.find(t) != mp.end() && mp[t] <= num) return INF;\n\t// mp[t] = num;\n\tct++;\n\t//cout << ct << endl;\n\t\n\tbool check = true;\n\tvector<int> reset(f.begin(), f.end());\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tint k = s[i][j];\n\t\t\tif(k > 0){\n\t\t\t\tint tmp = ((1 << k) - 1) << (w - j - k), n = 0;\n\t\t\t\tfor(int m = 0; m < k; m++){\n\t\t\t\t\tif((f[i + m] & (~tmp)) == f[i + m]) n++;\n\t\t\t\t\tf[i + m] &= ~tmp;\n\t\t\t\t}\n\t\t\t\tif(n < k){\n\t\t\t\t\tcheck = false;\n\t\t\t\t\tif(dfs(num + 1, f) < INF) return num;\n\t\t\t\t}\n\t\t\t\tf.assign(reset.begin(), reset.end());\n\t\t\t}\n\t\t}\n\t}\n\treturn (check ? num : INF);\n}\nint solve(vector<int>& f){\n\tinit(f);\n\t// for(int i = 0; i < h; i++){\n\t\t// for(int j = 0; j < w; j++){\n\t\t\t// printf(\"%d \", s[i][j]);\n\t\t// }\n\t\t// cout << endl;\n\t// }\n\tct = 0;\n\tfor(limit = hstar(f, true);; limit++){\n\t\t// printf(\"limit = %d\\n\", limit);\n\t\tmp.clear();\n\t\tif(dfs(0, f) < INF) return limit;\n\t}\n\t// cout << hstar(f) << endl;\n}\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tvector<int> f(h, 0);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tf[i] = 0;\n\t\t\tint a;\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> a;\n\t\t\t\tf[i] = (f[i] << 1) | a;\n\t\t\t}\n\t\t}\n\t\tcout << solve(f) << endl;\n\t\t// cout << \"ct = \" << ct << \"\\n\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nint W, H;\nint grid[10][10];\nint len[10][10];\nvector<int> xs, ys;\nint ub;\nbool used[10][10];\nconst int INF = 1000000000;\nint dfs(int k, int use, int fill){\n    if(use >= ub) return INF;\n    if(fill == 0){\n        return ub = use;\n    }\n    if(k == xs.size()) return INF;\n    int res = INF;\n    int x = xs[k];\n    int y = ys[k];\n    bool used_d[10][10];\n    memcpy(used_d, used, sizeof(used));\n    int nfill = fill;\n    REP(dy, len[y][x]) REP(dx, len[y][x]){\n        if(!used[y + dy][x + dx] && grid[y + dy][x + dx]){\n            used[y + dy][x + dx] = true;\n            nfill--;\n        }\n    }\n    if(nfill < fill){\n        res = min(res, dfs(k + 1, use + 1, nfill));\n    }\n    memcpy(used, used_d, sizeof(used));\n    if(used[y][x]){\n        res = min(res, dfs(k + 1, use, fill));\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> W >> H && W){\n        REP(y, H) REP(x, W) cin >> grid[y][x];\n        // 最大の正方形を計算\n        REP(y, H) REP(x, W){\n            len[y][x] = 0;\n            for(int d = 1; x + d <= W && y + d <= W; d++){\n                bool ok = true;\n                REP(dy, d) REP(dx, d) if(!grid[y + dy][x + dx]) ok = false;\n                if(ok) len[y][x] = d;\n            }\n        }\n        // 包含されている正方形をチェック\n        REP(y, H) REP(x, W) {\n            REP(ly, y + 1) REP(lx, x + 1){\n                if(ly == y && lx == x) continue;\n                if(ly + len[ly][lx] >= y + len[y][x] && lx + len[ly][lx] >= x + len[y][x]){\n                    len[y][x] = 0;\n                }\n            }\n        }\n\n        xs.clear();\n        ys.clear();\n        int erase = 0;\n        REP(y, H) REP(x, W){\n            if(len[y][x] > 1) {\n                xs.push_back(x);\n                ys.push_back(y);\n            }\n            if(len[y][x] == 1){\n                grid[y][x] = 0;\n                erase++;\n            }\n        }\n        //cout << xs.size() << \" \" << ys.size() << endl;\n\n\n        int count = 0;\n        REP(y, H) REP(x, W) count += grid[y][x];\n        int ans;\n        for(ub = 0; ; ub++){\n            ans = dfs(0, 0, count);\n            if(ans < INF) break;\n        }\n        cout << ans + erase << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,n,A[11][11],ans,cnt;\nbitset<100> B[11][11],p;\n\nvoid dfs(int d,bitset<100> s,int sco){\n  if(d==n){\n    ans=min(ans,sco);\n    return;\n  }\n  cnt++;\n  if(cnt>=5000000)return;\n  if(ans<=sco)return;\n  if(!A[d/w][d%w])dfs(d+1,s,sco);\n  else{\n    int y=d/w;\n    int x=d%w;\n    if((B[y][x]&s).any()){\n      p&=0;\n      p.set(y*10+x);//(y*100+x);\n      if(!(s&p).any())dfs(d+1,s,sco);\n      dfs(d+1,(B[y][x]|s)^B[y][x],sco+1);\n    }\n    else dfs(d+1,s,sco);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    memset(A,0,sizeof(A));\n    r(i,11)r(j,11)B[i][j]&=0;\n    n=h*w;\n    bitset<100> b;\n    r(i,h)r(j,w)cin>>A[i][j];\n    r(i,h)r(j,w)if(A[i][j]){\n      int sum=1;\n      for(;;sum++){\n        int f=0;\n        for(int y=i;y<i+sum;y++){\n          for(int x=j;x<j+sum;x++){\n            if(A[y][x]==0)f++;\n          }\n        }\n        if(f){\n          sum--;\n          break;\n        }\n      }\n      bitset<100>tmp;\n      for(int y=i,k=0;k<sum;k++,y++){\n        for(int x=j,l=0;l<sum;l++,x++){\n          tmp.set(y*10+x);\n        }\n      }\n      b.set(i*10+j);\n      B[i][j]=tmp;\n    }\n    ans=100;\n    cnt=0;\n    dfs(0,b,0);\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 10;\nint w, h;\nint of[N][N];\nvi field;\n\nint p2w[N][N];\nint res;\n\ninline bool calcnp(int & y, int & x){\n    do {\n        if(p2w[y][x] == 0 and (field[y] & (1 << x))) return false;\n\n        x++;\n        if(x == w){\n            y = y + 1;\n            x = 0;\n        }\n    } while(p2w[y][x] == 0);\n\n    return true;\n}\n\nvoid dfs(int cy, int cx, int cost){\n    if(cost >= res) return;\n\n    // cout << \"-----cost ------>: \" << cost << \" (\" << cx << \", \" << cy << \")\" << endl;\n    // rep(y, h){\n    //     rep(x, w){\n    //         if((field[y] & (1 << x)) == 0){\n    //             cout << \"0 \";\n    //         }\n    //         else {\n    //             cout << \"1 \";\n    //         }\n    //     }\n    //     cout << endl;\n    // }\n\n    if((field[cy] & (1 << cx)) == 0){\n        int ny = cy, nx = cx;\n        if(calcnp(ny, nx)){\n            dfs(ny, nx, cost);\n        }\n    }\n\n    int ww = p2w[cy][cx];\n\n    int mask = 0;\n    rep(loop, ww){\n        mask <<= 1;\n        mask  |= (1 << cx);\n    }\n\n    bool correct = false;\n    vi oof = field;\n    rep(y, cy, cy + ww){\n        if(not correct and (field[y] & mask) != 0){\n            correct = true;\n        }\n        field[y] &= ~mask;\n    }\n\n    if(not correct) return;\n\n    bool end = true;\n    rep(y, h){\n        if(field[y] != 0){\n            end = false;\n        }\n    }\n    if(end){\n        chmin(res, cost);\n    }\n    else {\n        int ny = cy, nx = cx;\n        if(calcnp(ny, nx)){\n            dfs(ny, nx, cost + 1);\n        }\n    }\n\n    field = oof;\n    //rep(y, cy, cy + ww){\n    //    field[y] |= mask;\n    //}\n    // cout << \"=====end cost ==========>: \" << cost << endl;\n}\n\ninline int calc(int sy, int sx, int ww){\n    int ret = 0;\n\n    rep(y, sy, h){\n        rep(x, sx, sx + ww){\n            if(of[y][x] == 0){\n                return ret;\n            }\n        }\n        ret++;\n    }\n\n    return ret;\n}\n\nint main(void){\n    for(; cin >> w >> h, w;){\n        rep(y, h){\n            rep(x, w){\n                p2w[y][x] = 0;\n            }\n        }\n\n        int sy = -1, sx;\n        rep(y, h){\n            rep(x, w){\n                cin >> of[y][x];\n\n                if(sy == -1 and of[y][x] == 1){\n                    sy = y;\n                    sx = x;\n                }\n            }\n        }\n\n        rep(y, h){\n            rep(x, w){\n                if(of[y][x] == 0) continue;\n\n                rep(ww, 1, w - x + 1){\n                    int hh = min(ww, calc(y, x, ww));\n\n                    if(hh == ww){\n                        p2w[y][x] = ww;\n                    }\n                }\n            }\n        }\n\n        rrep(y, h - 1){\n            rrep(x, w - 1){\n                if(p2w[y][x] > p2w[y + 1][x]) p2w[y + 1][x] = 0;\n                if(p2w[y][x] > p2w[y][x + 1]) p2w[y][x + 1] = 0;\n                if(p2w[y][x] > p2w[y + 1][x + 1]) p2w[y + 1][x + 1] = 0;\n            }\n        }\n\n        int fst = 0;\n        rep(y, h){\n            rep(x, w){\n                if(p2w[y][x] == 1){\n                    of[y][x] = 0;\n                    fst++;\n                    p2w[y][x] = 0;\n                }\n            }\n        }\n\n        field = vi(h);\n        rep(y, h){\n            int & cur = field[y] = 0;\n            rep(x, w){\n                if(of[y][x]){\n                    cur |= (1 << x);\n                }\n            }\n        }\n\n        // rep(y, h){\n        //     rep(x, w){\n        //         cout << p2w[y][x] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n\n        if(sy == -1){\n            res = 0;\n        }\n        else {\n            res = 1000;\n            dfs(sy, sx, fst + 1);\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[10][10],num;\n};\n\nint W,H,ans,POW[11];\nint first_table[10][10],max_size[10][10];\nint check[1024][1024]; //?????????2???\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\ninline void copyTable(Info& to,int from[10][10],int base_row){\n\n\tfor(int row = base_row; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)to.table[row][col] = from[row][col];\n\t}\n}\n\n\nvoid recursive(Info info,int base_row,int base_col,int pre_must_add){\n\n\tif(info.num == ans)return;\n\n\tif(base_row == H){ //??¨???????????????????????§?????£?????´???\n\t\t//ans = min(ans,info.num);\n\t\tans = info.num;\n\t\treturn;\n\t}\n\n\tif(info.table[base_row][base_col] == -1){ //????????????????¶???????????????§????????´???\n\n\t\t//???????????????????????????????§?\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t\treturn;\n\t}\n\n\t//?°?????????¨???1???????????°??????????????????????????????????????????[[????????§??????????????????????????????????????]]\n\tint new_num = 0;\n\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\tif(info.table[base_row+i][base_col+k] == 0){\n\t\t\t\tnew_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(new_num != 0)break;\n\t}\n\n\tif(new_num == 0){ //??°?????????????????????????????????\n\n\t\tif(base_col == W-1){\n\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t}else{\n\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t}\n\t}else{\n\n\t\t//????????????(?????????????????¢???????????????????????´?????????):???dfs??§??°????°????????????????????????±???????????????\n\t\tif(info.table[base_row][base_col] != 0){\n\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,pre_must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,pre_must_add);\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????\n\t\tfor(int i = 0; i < max_size[base_row][base_col]; i++){\n\t\t\tfor(int k = 0; k < max_size[base_row][base_col]; k++){\n\t\t\t\tinfo.table[base_row+i][base_col+k]++;\n\t\t\t}\n\t\t}\n\n\t\tint must_add = 0;\n\t\tbool FLG = false;\n\t\t//?°?????????¨??????????????§??????????????????????????°????¨????\n\t\tfor(int row = base_row; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(info.table[row][col] == 0 && first_table[row][col] == 1){\n\t\t\t\t\tmust_add++;\n\t\t\t\t}else if(info.table[row][col] == 0 && first_table[row][col] > 1){\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)must_add++;\n\n\t\tinfo.num++;\n\n\t\tif(info.num+must_add < ans){\n\t\t\tif(base_col == W-1){\n\t\t\t\trecursive(info,base_row+1,0,must_add);\n\t\t\t}else{\n\t\t\t\trecursive(info,base_row,base_col+1,must_add);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first_table[row][col]);\n\t\t\tfirst_table[row][col] -= 1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint size;\n\t//?????????????????????????????§????????????????±???????\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tmax_size[row][col] = 0;\n\t\t\t}else{\n\t\t\t\tsize = 1;\n\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(rangeCheck(row+i,col+k) == false || first_table[row+i][col+k] == -1){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\n\t\t\t\tmax_size[row][col] = size;\n\n\t\t\t\t//1??????????????????????????????????????????????????????????????????????????§?????????????????§??????????????´?????????????????????????????????\n\t\t\t\tfor(int calc_size = 1; calc_size <= size; calc_size++){\n\t\t\t\t\tfor(int i = 0; i < calc_size; i++){\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tfirst_table[row+i][col+k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo start;\n\tstart.num = 0;\n\tint pre_must_add = 0;\n\tFLG = false;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_table[row][col] == -1){\n\t\t\t\tstart.table[row][col] = -1;\n\t\t\t}else{\n\t\t\t\tif(first_table[row][col] == 1){\n\t\t\t\t\tpre_must_add++;\n\t\t\t\t}else{\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t\tstart.table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG)pre_must_add++;\n\n\tans = BIG_NUM;\n\n\trecursive(start,0,0,pre_must_add);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint p[10][10], s[10][10];\nvector< vector< int > > st;\nmap< tuple< vector< vector< int > >, int, int >, int > dp;\nint W, H;\n\nint dfs(int x, int y)\n{\n  auto ps = tie(st, x, y);\n  if(dp.count(ps)) return (dp[ps]);\n  if(y == H) return (0);\n  if(x == W) return (dfs(0, y + 1));\n  if(p[y][x] == 0) return (dfs(x + 1, y));\n  int ret = 1 << 30;\n  if(st[y][x] == 0) ret = min(ret, dfs(x + 1, y));\n  vector< pair< int, int > > beet;\n  for(int i = 0; i < s[y][x]; i++) {\n    for(int j = 0; j < s[y][x]; j++) {\n      if(st[y + i][x + j] == 1) {\n        beet.emplace_back(y + i, x + j);\n        st[y + i][x + j] = 0;\n      }\n    }\n  }\n  if(beet.size()) {\n    ret = min(ret, dfs(x + 1, y) + 1);\n    for(auto &p : beet) st[p.first][p.second] = 1;\n  }\n  return (dp[ps] = ret);\n}\n\nint main()\n{\n  while(cin >> W >> H, W) {\n    dp.clear();\n    st.resize(H);\n    for(int i = 0; i < H; i++) {\n      st[i].resize(W);\n      for(int j = 0; j < W; j++) {\n        cin >> p[i][j];\n        st[i][j] = p[i][j];\n      }\n    }\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        for(int k = min(H - i, W - j); k >= 1; k--) {\n          bool flag = true;\n          for(int l = 0; l < k; l++) {\n            for(int m = 0; m < k; m++) flag &= p[i + l][j + m];\n          }\n          if(flag) {\n            s[i][j] = k;\n            break;\n          }\n        }\n      }\n    }\n    cout << dfs(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcount(n))\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx];\n\t\t\trep(a,cy,cy+l)rep(b,cx,cx+l) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcount(n))\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\n\tif(y==h){\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(min_res>cur) min_res=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\tclr(num,0);\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx];\n\t\t\trep(a,cy,cy+l)rep(b,cx,cx+l) board[a]&=(1023^bit(b));\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\trep(i,h) min_res+=popcount(board[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,min_res)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nint H,W,mincost;\nint P[10][10],bin[10],bc[(1<<10)];\nint put[10][10],counter[10][10];\n\nbool can_put(int len,int x,int y){\n  REP(i,y,y+len)REP(j,x,x+len) if( !P[i][j] ) return false;\n  return true;\n}\n\nvoid dfs(int cur,int cost,int remain){\n\n  if( cost >= mincost ) return;\n  if( cost + ((remain>0)?1:0) >= mincost ) return;\n\n  if( cur >= H*W ) {\n    mincost = min(mincost,cost);\n    return;\n  }\n\n  int x = cur % W, y = cur / W;\n\n  if( !P[y][x] || counter[y][x] == 1 ) {\n    dfs(cur+1,cost,remain);\n    return;\n  }\n\n  if( (bin[y]>>x) & 1 ) dfs(cur+1,cost,remain);\n\n  int len = put[y][x];\n  int bitmask = ((1<<len)-1)<<x;\n  int buf[len];\n  int add = 0, nremain = remain;\n  rep(j,len) {\n    buf[j] = bin[y+j];\n    add += len - bc[((1<<len)-1)&(bin[y+j]>>x)];\n    bin[y+j] |= bitmask;\n  }\n  nremain -= add;\n  if( add ) dfs(cur+1,cost+1,nremain);\n  rep(j,len) bin[y+j] = buf[j];\n\n}\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\nint main(){\n\n  rep(i,(1<<10)) bc[i] = __builtin_popcount(i);\n\n  while( scanf(\"%d%d\",&W,&H), W | H ){\n\n    rep(i,H){\n      bin[i] = 0;\n      rep(j,W){\n        cin >> P[i][j];\n        put[i][j] = 0;\n      }\n    }\n    rep(y,H) rep(x,W) if( P[y][x] ) {\n      for(int len=min(H,W);len>=1;len--){\n        if( x + len - 1 < W && y + len - 1 < H ) {\n          if( can_put(len,x,y) ){\n            put[y][x] = len;\n            break;\n          }\n        }\n      }\n    }\n\n    rep(i,H)rep(j,W) counter[i][j] = 0;\n    rep(i,H)rep(j,W)if(P[i][j]){\n      REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n        counter[y][x]++;\n      }\n    }\n\n    rep(i,H){\n      rep(j,W){\n        if( counter[i][j] == 1 ){\n          REP(y,i,i+put[i][j])REP(x,j,j+put[i][j]){\n            bin[y] |= (1<<x);\n          }\n        }\n      }\n    }\n\n    int add = 0;\n    int remain = 0;\n    mincost = 0;\n    rep(i,H)rep(j,W)remain += ((bin[i]>>j)&1),mincost += P[i][j];\n    remain = mincost - remain;\n    dfs(0,0,remain);\n\n    rep(i,H)rep(j,W)if(counter[i][j]==1)add++;\n    cout << mincost+add << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint w, h, p[10][10], cnt;\nbool scrach[10][10];\n\nbool check2(int y, int x){\n  if(y<0||x<0||h<=y||w<=x) return true;\n  return (!scrach[y][x])||(scrach[y][x]&&!p[y][x]);\n}\n\nint check(int y, int x, int l){\n  \n  if(h<=y+l||w<=x+l) return 0;\n  \n  int y1=y, x1=x;\n  int y2=y+l, x2=x;\n  int y3=y, x3=x+l;\n  int y4=y+l, x4=x+l;\n  \n  bool flag=false;\n  \n  flag|=(check2(y1-1,x1)&&check2(y1,x1-1)&&p[y1][x1]);\n  flag|=(check2(y2+1,x2)&&check2(y2,x2-1)&&p[y2][x2]);\n  flag|=(check2(y3-1,x3)&&check2(y3,x3+1)&&p[y3][x3]);\n  flag|=(check2(y4+1,x4)&&check2(y4,x4+1)&&p[y4][x4]);\n  \n  bool f=true;\n\n  int res=0;\n  \n  for(int i=y;i<=y+l;i++)\n    for(int j=x;j<=x+l;j++){\n      if(!scrach[i][j]) f=false;\n      res+=p[i][j];\n    }\n  \n  flag&=f;\n  \n  if(flag){\n    for(int i=y;i<=y+l;i++)\n      for(int j=x;j<=x+l;j++) p[i][j]=0;\n    return res;  \n  }\n  \n  return 0;\n}\n\nvoid solve(){\n\n  int ans=0;\n  \n  for(int l=9;l>=0;l--){\n\n    int flag=1;\n    \n    while(flag&&cnt){\n      \n      flag=0;\n      \n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  int r=check(i,j,l);\n\t  \n\t  if(r){\n\t    flag=1;\n\t    cnt-=r;\n\t    ans++;\n\t    break;\n\t  }\n\t}\n\tif(flag) break;\n      }\n\n    }\n    \n  }\n\n  cout<<ans<<endl;\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>w>>h;\n    if(!w&&!h) break;\n    \n    cnt=0;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin>>p[i][j];\n\tcnt+=p[i][j];\n\tscrach[i][j]=p[i][j];\n      }\n\n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int inf=1<<28;\nint h,w;\n\n\nint board[10];\nint len[15][15];\n\nint min_res=0;\nint dfs(int y,int x,int d,int remain){\n\tif(d+(remain?1:0)>min_res) return inf;\n\n\tif(y==h){\t\t\n\t\tif(min_res>d) min_res=d;\n\t\treturn d;\n\t}\n\n\tif(x>=w) return dfs(y+1,0,d,remain);\n\t\n\tif(len[y][x]==0) return dfs(y,x+1,d,remain);\n\n\tint ret=inf;\n\tif((board[y]&bit(x))==0){\n\t\tint cur=dfs(y,x+1,d,remain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\n\tint tboard[10],l=len[y][x];\n\trep(i,y,y+l) tboard[i]=board[i];\n\n\tint nremain=remain;\n\tint mask=((1<<l)-1)<<x;\n\trep(a,y,y+l){\n\t\tnremain-=popcount(board[a]&mask);\n\t\tboard[a]&=(1023^mask);\n\t}\n\n\tif(remain!=nremain){\n\t\tint cur=dfs(y,x+1,d+1,nremain);\n\t\tif(ret>cur) ret=cur;\n\t}\n\t\n\trep(i,y,y+l) board[i]=tboard[i];\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0) break;\n\n\t\trep(i,h){\n\t\t\tboard[i]=0;\n\t\t\trep(j,w){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d \",&tmp);\n\t\t\t\tboard[i]|=(tmp<<j);\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tlen[i][j]=0;\n\t\t\tif((board[i]&bit(j))==0) continue;\n\t\t\tlen[i][j]=min(h-i,w-j);\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) if((board[a]&bit(b))==0) len[i][j]=min(len[i][j],max(a-i,b-j));\n\t\t}\n\n\t\tint num[10][10],sy[10][10],sx[10][10];\n\t\trep(i,h)rep(j,w) num[i][j]=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tconst int l=len[i][j];\n\t\t\trep(a,i,i+l)rep(b,j,j+l) num[a][b]++,sy[a][b]=i,sx[a][b]=j;\n\t\t}\n\n\t\tint add=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(num[i][j]!=1) continue;\n\t\t\tconst int cy=sy[i][j],cx=sx[i][j],l=len[cy][cx],mask=((1<<l)-1)<<cx;\n\t\t\trep(a,cy,cy+l) board[a]&=(1023^mask);\n\t\t\tlen[cy][cx]=0,add++;\n\t\t}\n\n\t\tint remain=0;\n\t\trep(i,h) remain+=popcount(board[i]);\n\t\tmin_res=min(25,remain);\n\t\tprintf(\"%d\\n\",dfs(0,0,0,remain)+add);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool data[10][10];\nchar input[10][10];\nbool vis[10][10];\nint w, h;\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> input[i][j];\n      }\n    }\n    int ans = 0;\n    fill(data[0], data[10], false);\n    for(int k=10;k>=1;k--){\n      fill(vis[0], vis[10], false);\n      for(int l=0;l<k*k;l++){\n        for(int i=0;i+k<=h;i++){\n          for(int j=0;j+k<=w;j++){\n            if(vis[i][j])continue;\n            bool f1 = true;\n            bool f2 = false;\n            int cnt = 0;\n            for(int i1=0;i1<k;i1++){\n              for(int j1=0;j1<k;j1++){\n                if(input[i+i1][j+j1] == '0'){\n                  f1 = false;\n                  break;\n                }\n                if(!data[i+i1][j+j1]) f2 = true;\n                else cnt++;\n              }\n            }\n            if(!f1 || !f2){\n              vis[i][j] = true;\n              continue;\n            }\n            if(cnt > l) continue;\n            ans++;\n            for(int i1=0;i1<k;i1++){\n              for(int j1=0;j1<k;j1++){\n                data[i+i1][j+j1] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define N 11\n#define INF (1<<29)\n\nusing namespace std;\n\nconst int di[] = {-1,1,1,-1};\nconst int dj[] = {1,1,-1,-1};\nint bestAns = INF;\nint minHW;\n\nvoid solve(int H, int W, int M[N][N], int depth){\n  /*\n    for(int k = 0; k < H; ++k){\n    for(int l = 0; l < W; ++l){\n    if(l>0)putchar(' ');\n    printf(\"%d\", M[k][l]);\n    }\n    putchar('\\n');\n    }\n    putchar('\\n');\n  */\n\n  // completed.\n  bool bComp=true;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j]==1){\n\tbComp=false;\n      }\n    }\n  }\n  if(bComp){\n    bestAns = min(bestAns, depth);\n    return ;\n  }\n\n  // back\n  if(1+depth>=bestAns){\n    return ;\n  }\n\n  // embed carpet\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if( M[i][j] == 0 ){\n\tcontinue;\n      }else if( M[i][j] == 1 ){\n\tint maxOneCount=-1;\n\tvector< pair<int,int> > vk;\n\tfor(int k = 0; k < 4; ++k){\n\t  int size = 0;\n\t  for(size = 1; size <= minHW; ++size){\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( m<0||n<0||m>=H||n>=W||M[m][n]==0 ){\n\t\t  --size;\n\t\t  goto next1;\n\t\t}\n\t      }\n\t    }\n\t    if(k==0){\n\t      if(i-size<0||j+size>=W)break;\n\t    }else if(k==1){\n\t      if(i+size>=H||j+size>=W)break;\n\t    }else if(k==2){\n\t      if(i+size>=H||j-size<0)break;\n\t    }else{\n\t      if(i-size<0||j-size<0)break;\n\t    }\n\t  }\n\tnext1:;\n\t  int oneCount=0;\n\t  for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t    for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t      if( M[m][n] == 1 ){\n\t\t++oneCount;\n\t      }\n\t    }\n\t  }\n\t  vk.push_back( make_pair(size,oneCount) );\n\t  maxOneCount = max( maxOneCount, oneCount );\n\t}\n\tfor(int k = 0; k < 4; ++k){\n\t  if(vk[k].second==maxOneCount){\n\t    int size = vk[k].first;\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif(M[m][n]==1){\n\t\t  M[m][n]=depth;\n\t\t}\n\t      }\n\t    }\n\t    solve(H,W,M,depth+1);\n\t    for(int m = i; (k==0||k==3)?(m>i-size):(m<size+i); m+=di[k]){\n\t      for(int n = j; (k==2||k==3)?(n>j-size):(n<size+j); n+=dj[k]){\n\t\tif( M[m][n] == depth ){\n\t\t  M[m][n]=1;\n\t\t}\n\t      }\n\t    }\n\t    if(maxOneCount==1)break;\n\t  }\n\t}\n\treturn ;\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int cnt=0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==H&&H==0)break;\n    int M[N][N];\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &M[i][j]);\n      }\n    }\n\n    bestAns=INF;\n    minHW = min(H,W);\n    solve(H,W,M,2);\n    printf(\"%d\\n\", bestAns-2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1128\n  Title:Square Carpets\n  @kankichi573\n*/\n#include <stdio.h>\n#define min(x,y) (((x)<(y))?(x):(y))\nint panel[10][10];\nint w,h;\nint y_[100],x_[100],s_[100];\n\nvoid search_pos(int *y,int *x)\n{\n  int i,j;\n\n  i=*y;j=*x;\n  goto SEARCH;\n\n  for(i=0;i<h;i++)\n    for(j=0;j<w;j++)\n      {\n      SEARCH:\n\tif(panel[i][j])\n\t  {\n\t    *y=i;*x=j;\n\t    return;\n\t  }\n      }\n  *x=*y=-1;\n}\n\nint check_square(int y,int x,int *scr)\n{\n  int i,j,ret,c1[11],minwh;\n\n  minwh=min(h-y,w-x);\n  c1[1]=((panel[y][x]==1)?1:0);\n  for(ret=2;ret<=minwh;ret++)\n    {\n      c1[ret]=0;\n      for(i=0;i<ret;i++)\n\tfor(j=0;j<ret;j++)\n\t  if(panel[y+i][x+j]==0)\n\t    {\n\t      //printf(\"** %d %d\\n\",y+j,x+i);\n\t      if(c1[ret-1])  // at least 1 scratched panel\n\t\t{\n\t\t  *scr=c1[ret-1];  //count of scratch panel\n\t\t  return(ret-1);\n\t\t}\n\t      else\n\t\t{\n\t\t  *scr=0;\n\t\t  return(0);\n\t\t}\n\t    }\n\t  else if(panel[y+i][x+j]==1)\n\t    c1[ret]++;\n    }\n  if(c1[ret-1])\n    {\n      *scr=c1[ret-1];\n      return(minwh);\n    }\n  else\n    {\n      *scr=0;\n      return(0);\n    }\n}\n\n\nint search_biggest_square(int *yp,int *xp)\n{\n  int max_=0,siz,y,x,max_x,max_y,minwh,c1[11];\n  int i,j,ret,scr,scrmax;\n\n  x=y=scrmax=0;\n  while(search_pos(&y,&x) , y!=-1)\n    {\n      ret=check_square(y,x,&scr);\n      //printf(\"yxr=%d %d %d [%d]\\n\",y,x,ret,scr);\n\n      if(scr > scrmax)\n\t{\n\t  max_=ret;\n\t  scrmax=scr;\n\t  max_y=y;max_x=x;\n\t}\n      x++;\n      if(x>=w)\n\t{\n\t  y++;\n\t  x=0;\n\t}\n      if(y>=h)\n\tbreak;\n    }\n  *xp=max_x;\n  *yp=max_y;\n  return(max_);\n}\n\n\n\nvoid carpet_square(int y,int x,int size)\n{\n  int i,j;\n\n    for(i=0;i<size;i++)\n      for(j=0;j<size;j++)\n\tpanel[y+i][x+j]++;\n\n}\nvoid dump(int y,int x,int siz,int seq)\n{\n  int i,j;\n\n    for(i=0;i<h;i++)\n      {\n\tfor(j=0;j<w;j++)\n#ifdef COLOR\n\t  if(j>=x && j<x+siz && i>=y && i< y+siz) \n\t    printf(\"\\x1b[34m%d\\x1b[37m\",panel[i][j]);\n\t  else\n\t    printf(\"\\x1b[37m%d\\x1b[37m\",panel[i][j]);\n#else\n\tprintf(\"%d\",panel[i][j]);\n#endif\n\tprintf(\"\\n\");\n      }\n    printf(\"----------[%d]yxs=%d %d %d\\n\",seq,y,x,siz);\n}\n\nint check_all_covered(int cnt)\n{\n  int i,j,k,ret;\n  ret=0;\n  for(i=0;i<cnt;i++)\n    {\n      for(j=y_[i];j<y_[i]+s_[i];j++)\n\tfor(k=x_[i];k<x_[i]+s_[i];k++)\n\t  if(panel[j][k]==2)\n\t    goto NEXT;\n      ret++;\n      //printf(\"cvr=%d\\n\",i);\n    NEXT:;\n    }\n  return(ret);\n}\n\n\nint solve()\n{\n  int ret=0,siz,y,x,ret2;\n  \n  y=x=0;\n  while(siz=search_biggest_square(&y,&x))\n    {\n      //printf(\"csqsiz=%d yx=%d %d\\n\",siz,y,x);\n      carpet_square(y,x,siz);\n      y_[ret]=y;\n      x_[ret]=x;\n      s_[ret]=siz;\n      ret++;\n#ifdef DEBUG      \n      dump(y,x,siz,ret);\n#endif\n      x++;\n      if(x>=w)\n\t{\n\t  x=0;\n\t  y++;\n\t}\n      if(y>h)\n\tbreak;\n    }\n  ret2=check_all_covered(ret);\n  return(ret-ret2);\n}\nmain()\n{\n  int i,j,ret;\n\n  while(scanf(\"%d %d\",&w,&h) && (w||h))\n    {\n      for(i=0;i<h;i++)\n\tfor(j=0;j<w;j++)\n\t  scanf(\"%d\",&panel[i][j]);\n      ret=solve();\n      printf(\"%d\\n\",ret);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1128\n  Title:Square Carpets\n  @kankichi573\n*/\n#include <stdio.h>\n#define min(x,y) (((x)<(y))?(x):(y))\nint panel[10][10];\nint w,h;\n\nvoid search_pos(int *y,int *x)\n{\n  int i,j;\n\n  i=*y;j=*x;\n  goto SEARCH;\n\n  for(i=0;i<h;i++)\n    for(j=0;j<w;j++)\n      {\n      SEARCH:\n\tif(panel[i][j])\n\t  {\n\t    *y=i;*x=j;\n\t    return;\n\t  }\n      }\n  *x=*y=-1;\n}\n\nint check_square(int y,int x,int *scr)\n{\n  int i,j,ret,c1[11],minwh;\n\n  minwh=min(h-y,w-x);\n  c1[1]=((panel[y][x]==1)?1:0);\n  for(ret=2;ret<=minwh;ret++)\n    {\n      c1[ret]=0;\n      for(i=0;i<ret;i++)\n\tfor(j=0;j<ret;j++)\n\t  if(panel[y+i][x+j]==0)\n\t    {\n\t      //printf(\"** %d %d\\n\",y+j,x+i);\n\t      if(c1[ret-1])  // at least 1 scratched panel\n\t\t{\n\t\t  *scr=c1[ret-1];  //count of scratch panel\n\t\t  return(ret-1);\n\t\t}\n\t      else\n\t\treturn(0);\n\t    }\n\t  else if(panel[y+i][x+j]==1)\n\t    c1[ret]++;\n    }\n  if(c1[ret-1])\n    {\n      *scr=c1[ret-1];\n      return(minwh);\n    }\n  else\n    {\n      *scr=0;\n      return(0);\n    }\n}\n\n\nint search_biggest_square(int *yp,int *xp)\n{\n  int max_=0,siz,y,x,max_x,max_y,minwh,c1[11];\n  int i,j,ret,scr,scrmax;\n\n  x=y=scrmax=0;\n  while(search_pos(&y,&x) , y!=-1)\n    {\n      ret=check_square(y,x,&scr);\n      //printf(\"yxr=%d %d %d [%d]\\n\",y,x,ret,scr);\n      if(ret>max_)\n\t{\n\t  max_=ret;\n\t  scrmax=scr;\n\t  max_y=y;max_x=x;\n\t}\n      else if(ret==max_ && scr > scrmax)\n\t{\n\t  scrmax=scr;\n\t  max_y=y;max_x=x;\n\t}\n      x++;\n      if(x>=w)\n\t{\n\t  y++;\n\t  x=0;\n\t}\n      if(y>=h)\n\tbreak;\n    }\n  *xp=max_x;\n  *yp=max_y;\n  return(max_);\n}\n\n\n\nvoid carpet_square(int y,int x,int size)\n{\n  int i,j;\n\n    for(i=0;i<size;i++)\n      for(j=0;j<size;j++)\n\tpanel[y+i][x+j]=2;\n}\nvoid dump()\n{\n  int i,j;\n\n    for(i=0;i<h;i++)\n      {\n\tfor(j=0;j<w;j++)\n\t  printf(\"%d\",panel[i][j]);\n\tprintf(\"\\n\");\n      }\n    printf(\"----------\\n\");\n}\nint solve()\n{\n  int ret=0,siz,y,x;\n  \n  y=x=0;\n  while(siz=search_biggest_square(&y,&x))\n    {\n      //printf(\"csqsiz=%d yx=%d %d\\n\",siz,y,x);\n      carpet_square(y,x,siz);\n      ret++;\n      //dump();\n\n      x++;\n      if(x>=w)\n\t{\n\t  x=0;\n\t  y++;\n\t}\n      if(y>h)\n\tbreak;\n    }\n  return(ret);\n}\nmain()\n{\n  int i,j,ret;\n\n  while(scanf(\"%d %d\",&w,&h) && (w||h))\n    {\n      for(i=0;i<h;i++)\n\tfor(j=0;j<w;j++)\n\t  scanf(\"%d\",&panel[i][j]);\n      ret=solve();\n      printf(\"%d\\n\",ret);\n    }\n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Square Carpets\npublic class Main{\n\n\tint w, h, res, L;\n\tint[][] a, t;\n\tboolean[][][] ok;\n\tMap<String, Integer> ref;\n\t\n\tvoid copy(int[][] a, int[][] b){\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)b[i][j]=a[i][j];\n\t}\n\t\n\tString get(int[][] t){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)sb.append(t[i][j]);\n\t\treturn sb.toString();\n\t}\n\t\n\tvoid dump(){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]==0)System.out.print(\"-\");\n\t\t\t\telse if(t[i][j]==0)System.out.print(\"x\");\n\t\t\t\telse System.out.print(\"o\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tvoid dfs(int step){\n\t\tif(res<=step)return;\n//\t\tSystem.out.println(\"Step:\"+step);\n//\t\tdump();\n\t\tString r = get(t);\n\t\tif(ref.containsKey(r)&&ref.get(r)<=step)return;\n\t\tref.put(r, step);\n\t\tboolean e = false;\n\t\tint[][] p = new int[h][w];\n\t\tcopy(t, p);\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(a[i][j]==0||a[i][j]==1&&t[i][j]==1)continue;\n\t\t\te = true;\n\t\t\tfor(int len=L;len>0;len--){\n\t\t\t\tint max = 0;\n\t\t\t\tint pi = -1, pj = -1;\n\t\t\t\tfor(int y=i-len+1;y<=i;y++){\n\t\t\t\t\tif(y<0||h<=y)continue;\n\t\t\t\t\tfor(int x=j-len+1;x<=j;x++){\n\t\t\t\t\t\tif(x<0||w<=x)continue;\n\t\t\t\t\t\tif(!ok[y][x][len])continue;\n\t\t\t\t\t\tint cov = 0;\n\t\t\t\t\t\tfor(int n=y;n<y+len;n++)for(int m=x;m<x+len;m++){\n\t\t\t\t\t\t\tif(t[n][m]==0)cov++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(max<cov){\n\t\t\t\t\t\t\tmax = cov; pi = y; pj = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max==0)continue;\n\t\t\t\tfor(int n=pi;n<pi+len;n++)for(int m=pj;m<pj+len;m++)t[n][m] = 1;\n\t\t\t\tdfs(step+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(!e)res = step;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tL = Math.min(h, w);\n\t\t\ta = new int[h][w];\n\t\t\tok = new boolean[h][w][L+1];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)a[i][j]=sc.nextInt();\n\t\t\tfor(int d=1;d<=L;d++)for(int i=0;i+d<=h;i++)for(int j=0;j+d<=w;j++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int y=i;y<i+d;y++)for(int x=j;x<j+d;x++)if(a[y][x]==0)f = false;\n\t\t\t\tif(f)ok[i][j][d] = true;\n\t\t\t}\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tres = w*h;\n\t\t\tt = new int[h][w];\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Square Carpets\npublic class Main{\n\n\tint w, h, res, L;\n\tint[][] a, t;\n\tboolean[][][] ok;\n\tMap<Integer, Integer> ref;\n\n\tvoid copy(int[][] a, int[][] b){\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)b[i][j]=a[i][j];\n\t}\n\n\tString get(int[][] t){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)sb.append(t[i][j]);\n\t\treturn sb.toString();\n\t}\n\n\tvoid dump(){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]==0)System.out.print(\"-\");\n\t\t\t\telse if(t[i][j]==0)System.out.print(\"x\");\n\t\t\t\telse System.out.print(\"o\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tclass R implements Comparable<R>{\n\t\tint i, j, num, len;\n\t\tpublic R(int i, int j, int num, int len) {\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t\tthis.num = num;\n\t\t\tthis.len = len;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn num!=o.num?o.num-num:i*w+j-(o.i*w+o.j);\n\t\t}\n\t}\n\n\tclass P{\n\t\tint y1, x1, y2, x2;\n\t\tpublic P(int y1, int x1, int y2, int x2) {\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y2 = y2;\n\t\t\tthis.x2 = x2;\n\t\t}\n\t\tboolean con(P p){\n\t\t\treturn y1<=p.y1&&p.y2<=y2&&x1<=p.x1&&p.x2<=x2;\n\t\t}\n\t}\n\n\tint hs(int i, int j){\n\t\tint hs = 0;\n\t\tif(i<h-1){\n\t\t\tfor(int y=i;y+1<h;y++)for(int x=j;x<w;x++){\n\t\t\t\tif(x-1<0)continue;\n\t\t\t\tif(a[y][x-1]==0&&a[y][x]==1&&a[y+1][x-1]==1&&a[y+1][x]==1){\n\t\t\t\t\tif(t[y][x]==1&&t[y+1][x-1]==1)hs+=2;\n\t\t\t\t\telse if(t[y][x]==1||t[y+1][x-1]==1||t[y+1][x]==1)hs++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int x=j;x<w;x++)if(a[i][x]==1)hs++;\n\t\t}\n\t\treturn hs;\n\t}\n\n\tvoid dfs(int i, int j, int step){\n//\t\tSystem.out.println(i+\",\"+j+\" \"+step+\" Res:\"+res);\n//\t\tif(i>=h-1)dump();\n\t\tif(res<=step)return;\n\t\tif(i==h){\n\t\t\tres = step; return;\n\t\t}\n\t\tif(a[i][j]==0){\n\t\t\tif(j==w-1)dfs(i+1, 0, step);\n\t\t\telse dfs(i, j+1, step);\n\t\t}\n//\t\tif(res<=hs(i, j)+step)return;\n\t\tint[][] p = new int[h][w];\n\t\tcopy(t, p);\n\t\tif(t[i][j]==0){\n\t\t\tfor(int len=L;len>0;len--){\n\t\t\t\tif(!ok[i][j][len])continue;\n\t\t\t\tfor(int y=i;y<i+len;y++)for(int x=j;x<j+len;x++)t[y][x] = 1;\n\t\t\t\tif(j==w-1)dfs(i+1, 0, step+1);\n\t\t\t\telse dfs(i, j+1, step+1);\n\t\t\t\tcopy(p, t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(j==w-1)dfs(i+1, 0, step);\n\t\t\telse dfs(i, j+1, step);\n\t\t\tfor(int len=L;len>0;len--){\n\t\t\t\tif(!ok[i][j][len])continue;\n\t\t\t\tif(i+1<h&&!ok[i+1][j][len]&&(t[i+len-1][j]==0||t[i+len-1][j+len-1]==0)){\n\t\t\t\t\tfor(int y=i;y<i+len;y++)for(int x=j;x<j+len;x++)t[y][x] = 1;\n\t\t\t\t\tif(j==w-1)dfs(i+1, 0, step+1);\n\t\t\t\t\telse dfs(i, j+1, step+1);\n\t\t\t\t\tcopy(p, t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n//\n//\tboolean dfs(int step, int limit){\n//\t\tif(res<=step)return false;\n//\t\tSystem.out.println(\"Step:\"+step+\" Res:\"+res);\n//\t\t//\t\tdump();\n//\t\tString r = get(t);\n//\t\tif(ref.containsKey(r.hashCode()))return false;\n//\t\tref.put(r.hashCode(), step);\n//\t\tboolean e = false;\n//\t\tint[][] p = new int[h][w];\n//\t\tcopy(t, p);\n//\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n//\t\t\tif(a[i][j]==0||a[i][j]==1&&t[i][j]==1)continue;\n//\t\t\tint hs = 0;\n//\t\t\tfor(int y=i;y+1<h;y++)for(int x=j;x<w;x++){\n//\t\t\t\tif(x-1<0)continue;\n//\t\t\t\tif(a[y][x-1]==0&&a[y][x]==1&&a[y+1][x-1]==1&&a[y+1][x]==1)hs+=2;\n//\t\t\t}\n//\t\t\tif(res<=step+hs)return false;\n//\t\t\t//\t\t\tSystem.out.println(\"H:\"+hs +\" \"+(step+h)+\" res:\"+res);\n//\t\t\te = true;\n//\t\t\t//\t\t\tboolean f = false;\n//\t\t\tPriorityQueue<R> q = new PriorityQueue<R>();\n//\t\t\tfor(int len=L;len>0;len--){\n//\t\t\t\t//\t\t\t\tif(f)break;\n//\t\t\t\tfor(int y=i;y>i-len;y--){\n//\t\t\t\t\tif(y<0||h<=y)continue;\n//\t\t\t\t\tfor(int x=j;x>j-len;x--){\n//\t\t\t\t\t\t//\t\t\t\t\t\tSystem.out.println(\"Y:\"+y+\" X:\"+x);\n//\t\t\t\t\t\tif(x<0||w<=x)continue;\n//\t\t\t\t\t\tif(!ok[y][x][len])continue;\n//\t\t\t\t\t\tint cov = 0;\n//\t\t\t\t\t\t//\t\t\t\t\t\tf = true;\n//\t\t\t\t\t\t//\t\t\t\t\t\tboolean c = false;\n//\t\t\t\t\t\tfor(int n=y;n<y+len;n++)for(int m=x;m<x+len;m++){\n//\t\t\t\t\t\t\tif(t[n][m]==0)cov++;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tq.add(new R(y, x, cov, len));\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t//\t\t\tSystem.out.println(q.size());\n//\t\t\tList<P> ps = new ArrayList<P>();\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tR v = q.poll();\n//\t\t\t\tP pp = new P(v.i, v.j, v.i+v.len-1, v.j+v.len-1);\n//\t\t\t\tboolean go = true;\n//\t\t\t\tfor(P ppp:ps)if(ppp.con(pp)||pp.con(ppp))go=false;\n//\t\t\t\t//\t\t\t\tif(dfs(step+1, limit))return true;\n//\t\t\t\tif(go){\n//\t\t\t\t\t//\t\t\t\t\tSystem.out.println(\"Put:\"+v.i+\",\"+v.j+\" Len:\"+v.len);\n//\t\t\t\t\t//\t\t\t\t\tdump();\n//\t\t\t\t\tps.add(pp);\n//\t\t\t\t\tfor(int y=v.i;y<v.i+v.len;y++)for(int x=v.j;x<v.j+v.len;x++)t[y][x] = 1;\n//\t\t\t\t\t//\t\t\t\t\tdump();\n//\t\t\t\t\tdfs(step+1,limit);\n//\t\t\t\t\tcopy(p, t);\n//\t\t\t\t}\n//\t\t\t\telse System.out.println(\"Cut!!\");\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t}\n//\t\tif(!e)res = step;\n//\t\treturn !e;\n//\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tL = Math.min(h, w);\n\t\t\ta = new int[h][w];\n\t\t\tok = new boolean[h][w][L+1];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)a[i][j]=sc.nextInt();\n\t\t\tfor(int d=1;d<=L;d++)for(int i=0;i+d<=h;i++)for(int j=0;j+d<=w;j++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int y=i;y<i+d;y++)for(int x=j;x<j+d;x++)if(a[y][x]==0)f = false;\n\t\t\t\tif(f)ok[i][j][d] = true;\n\t\t\t}\n\t\t\tres = w*h;\n\t\t\tref = new HashMap<Integer, Integer>();\n\t\t\tt = new int[h][w];\n\t\t\tdfs(0, 0, 0);\n\t\t\t//\t\t\tfor(int i=0;i<=res;i++){\n\t\t\t//\t\t\t\tSystem.out.println(\"Limit:\"+i);\n\t\t\t//\t\t\t\tif(dfs(0, i))res=i;\n\t\t\t//\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int W, H;\n\tstatic boolean[][] f;\n\tstatic int[][] size;\n\tstatic int[][] count;\n\tstatic int ans;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tH = sc.nextInt();\n\t\t\tf = new boolean[H + 1][W + 1];\n\t\t\tsize = new int[H + 1][W + 1];\n\t\t\tcount = new int[H + 1][W + 1];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tf[i][j] = sc.next().equals(\"1\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\tans = 999;\n\t\tint rest = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (f[i][j]) ++rest;\n\t\t\t\tOUT: for (int k = 1;; ++k) {\n\t\t\t\t\tfor (int r = i; r < i + k; ++r) {\n\t\t\t\t\t\tfor (int c = j; c < j + k; ++c) {\n\t\t\t\t\t\t\tif (!f[r][c]) {\n\t\t\t\t\t\t\t\tsize[i][j] = k - 1;\n\t\t\t\t\t\t\t\tbreak OUT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (rest == 0) return 0;\n\t\trec(0, 0, 0, rest);\n\t\treturn ans;\n\t}\n\n\tstatic void rec(int r, int c, int num, int rest) {\n\t\tif (rest == 0) {\n\t\t\tans = num;\n\t\t\treturn;\n\t\t}\n\t\tif (num + 1 >= ans) return;\n\t\tif (c == W) {\n\t\t\trec(r + 1, 0, num, rest);\n\t\t\treturn;\n\t\t}\n\t\tif (!f[r][c] || count[r][c] != 0) {\n\t\t\trec(r, c + 1, num, rest);\n\t\t}\n\n\t\t// prune\n\t\tboolean filled = true;\n\t\tfor (int i = 0; i < size[r][c]; ++i) {\n\t\t\tif (count[r + i][c] == 0) {\n\t\t\t\tfilled = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (filled && size[r][c + 1] >= size[r][c]) return;\n\t\tfilled = true;\n\t\tfor (int i = 0; i < size[r][c]; ++i) {\n\t\t\tif (count[r][c + 1] == 0) {\n\t\t\t\tfilled = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (filled && size[r + 1][c] >= size[r][c]) return;\n\n\t\tboolean use = false;\n\t\tfor (int i = 0; i < size[r][c]; ++i) {\n\t\t\tfor (int j = 0; j < size[r][c]; ++j) {\n\t\t\t\tif (count[r + i][c + j] == 0) {\n\t\t\t\t\tuse = true;\n\t\t\t\t\t--rest;\n\t\t\t\t}\n\t\t\t\tcount[r + i][c + j]++;\n\t\t\t}\n\t\t}\n\t\tif (use) {\n\t\t\trec(r, c + 1, num + 1, rest);\n\t\t}\n\t\tfor (int i = 0; i < size[r][c]; ++i) {\n\t\t\tfor (int j = 0; j < size[r][c]; ++j) {\n\t\t\t\tcount[r + i][c + j]--;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint m, n;\n\tint[][] a;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\ta[j][i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\t// 正方形全列挙\n\n\t\tArrayList<BitSet> candidate=new ArrayList<BitSet>();\n\n\t\tfor(int y=0; y<n; y++){\n\t\t\tfor(int x=0; x<m; x++){\n\t\t\t\tfor(int s=1; x+s<=m&&y+s<=n; s++){\n\t\t\t\t\t// (x, y)->(x+s-1, y+s-1)\n\t\t\t\t\tboolean all1=true;\n\t\t\t\t\tBitSet bs=new BitSet();\n\t\t\t\t\tfor(int j=y; j<y+s; j++){\n\t\t\t\t\t\tfor(int i=x; i<x+s; i++){\n\t\t\t\t\t\t\tall1&=a[j][i]==1;\n\t\t\t\t\t\t\t// j*m+i\n\t\t\t\t\t\t\tbs.set(j*m+i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(all1){\n\t\t\t\t\t\t// add\n\t\t\t\t\t\tcandidate.add(bs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean[] use=new boolean[candidate.size()];\n\t\tBitSet[] bss=candidate.toArray(new BitSet[0]);\n\t\tfill(use, true);\n\n\t\tint ans=0;\n\n\t\tfor(;;){\n\t\t\tboolean update=false;\n\n\t\t\tfor(int j=0; j<bss.length; j++){\n\t\t\t\tif(!use[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t\tif(!use[i]||i==j){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// jとiを&したらj\n\t\t\t\t\t// jの方が小さい\n\t\t\t\t\tBitSet bs=(BitSet)bss[j].clone();\n\t\t\t\t\tbs.and(bss[i]);\n\t\t\t\t\tif(bs.equals(bss[j])){\n\t\t\t\t\t\tif(j==2){\n\t\t\t\t\t\t\tdebug(bss[j], bss[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuse[j]=false;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t// debug(i, use[i], bss[i]);\n\t\t\t}\n\t\t\t// debug();\n\n\t\t\tfor(int b=0; b<m*n; b++){\n\t\t\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t\tif(use[i]&&bss[i].get(b)){\n\t\t\t\t\t\tlist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(list.size()==1){\n\t\t\t\t\tans++;\n\t\t\t\t\tint k=list.get(0);\n\t\t\t\t\tdebug(k, bss[k]);\n\t\t\t\t\tuse[k]=false;\n\t\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\t\t\tif(bss[k].get(j*m+i)){\n\t\t\t\t\t\t\t\ta[j][i]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t\t\tif(use[i]){\n\t\t\t\t\t\t\tbss[i].andNot(bss[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug(\"a\");\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t// debug(a[j]);\n\t\t\t}\n\t\t\t// debug(\"ans\", ans);\n\t\t\tif(!update){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdebug(\"a\");\n\t\tfor(int j=0; j<n; j++){\n\t\t\tdebug(a[j]);\n\t\t}\n\n\t\tdebug(use);\n\t\tfor(int i=0; i<bss.length; i++){\n\t\t\tif(use[i]){\n\t\t\t\tdebug(bss[i]);\n\t\t\t}\n\t\t}\n\n\t\tdebug(\"暫定\", ans);\n\n\t\tBitSet all=new BitSet();\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(a[j][i]==1){\n\t\t\t\t\tall.set(j*m+i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tHashSet<BitSet> set=new HashSet<BitSet>();\n\t\tset.add(all);\n\t\tfor(int i=0; i<bss.length; i++){\n\t\t\tif(!use[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tHashSet<BitSet> set2=new HashSet<BitSet>();\n\t\t\tfor(BitSet bs : set){\n\t\t\t\tBitSet bs1=(BitSet)bs.clone();\n\t\t\t\tbs1.and(bss[i]);\n\t\t\t\tBitSet bs2=(BitSet)bs.clone();\n\t\t\t\tbs2.xor(bs1);\n\t\t\t\tset2.add(bs1);\n\t\t\t\tset2.add(bs2);\n\t\t\t}\n\t\t\tset=set2;\n\t\t}\n\t\tset.remove(new BitSet());\n\t\tfor(BitSet bs : set){\n\t\t\tdebug(bs);\n\t\t}\n\t\tBitSet[] compress=set.toArray(new BitSet[0]);\n\t\t// debug(compress);\n\n\t\tint v=compress.length;\n\t\tint[] a=new int[1<<v];\n\t\tfor(int j=0; j<bss.length; j++){\n\t\t\tif(!use[j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint bit=0;\n\t\t\tfor(int i=0; i<v; i++){\n\t\t\t\tif(bss[j].intersects(compress[i])){\n\t\t\t\t\tbit|=1<<i;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[bit]=1;\n\t\t\tdebug(Integer.toBinaryString(bit));\n\t\t}\n\t\t// (1<<v)-1の被覆\n\n\t\tfor(int i=0; i<v; i++)\n\t\t\tfor(int s=0; s<1<<v; s++)\n\t\t\t\tif((s>>i&1)==1)\n\t\t\t\t\ta[s]+=a[s^(1<<i)];\n\n\t\tint left=0, right=n;\n\t\tfor(; left+1<right;){\n\t\t\tint mid=(left+right)/2;\n\t\t\tif(kCover(mid, a, v))\n\t\t\t\tright=mid;\n\t\t\telse\n\t\t\t\tleft=mid;\n\t\t}\n\t\tif(kCover(0, a, v)){\n\t\t\tright=0;\n\t\t}\n\t\tdebug(\"right\", right);\n\n\t\tans+=right;\n\t\tprintln(ans+\"\");\n\t\t// 極大だけ残す\n\t\t// 被覆できるのがひとつなら確定\n\t}\n\n\tint pow(int x, int k){\n\t\tif(k==0)\n\t\t\treturn 1;\n\t\telse if((k&1)==0)\n\t\t\treturn pow(x*x, k>>>1);\n\t\telse\n\t\t\treturn x*pow(x, k-1);\n\t}\n\n\tboolean kCover(int k, int[] f, int n){\n\t\tlong g=0;\n\t\tfor(int i=0; i<1<<n; i++)\n\t\t\tif(Integer.bitCount(((1<<n)-1)^i)%2==0)\n\t\t\t\tg+=pow(f[i], k);\n\t\t\telse\n\t\t\t\tg-=pow(f[i], k);\n\t\treturn g!=0;\n\t}\n\n\tvoid debug(Object... os){\n\t\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint m, n;\n\tint[][] a;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\ta[j][i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\t// 正方形全列挙\n\n\t\tArrayList<BitSet> candidate=new ArrayList<BitSet>();\n\n\t\tfor(int y=0; y<n; y++){\n\t\t\tfor(int x=0; x<m; x++){\n\t\t\t\tfor(int s=1; x+s<=m&&y+s<=n; s++){\n\t\t\t\t\t// (x, y)->(x+s-1, y+s-1)\n\t\t\t\t\tboolean all1=true;\n\t\t\t\t\tBitSet bs=new BitSet();\n\t\t\t\t\tfor(int j=y; j<y+s; j++){\n\t\t\t\t\t\tfor(int i=x; i<x+s; i++){\n\t\t\t\t\t\t\tall1&=a[j][i]==1;\n\t\t\t\t\t\t\t// j*m+i\n\t\t\t\t\t\t\tbs.set(j*m+i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(all1){\n\t\t\t\t\t\t// add\n\t\t\t\t\t\tcandidate.add(bs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean[] use=new boolean[candidate.size()];\n\t\tBitSet[] bss=candidate.toArray(new BitSet[0]);\n\t\tfill(use, true);\n\n\t\tint ans=0;\n\n\t\tfor(;;){\n\t\t\tboolean update=false;\n\n\t\t\tfor(int j=0; j<bss.length; j++){\n\t\t\t\tif(!use[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t\tif(!use[i]||i==j){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// jとiを&したらj\n\t\t\t\t\t// jの方が小さい\n\t\t\t\t\tBitSet bs=(BitSet)bss[j].clone();\n\t\t\t\t\tbs.and(bss[i]);\n\t\t\t\t\tif(bs.equals(bss[j])){\n\t\t\t\t\t\tif(j==2){\n\t\t\t\t\t\t\tdebug(bss[j], bss[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuse[j]=false;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t// debug(i, use[i], bss[i]);\n\t\t\t}\n\t\t\t// debug();\n\n\t\t\tfor(int b=0; b<m*n; b++){\n\t\t\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t\tif(use[i]&&bss[i].get(b)){\n\t\t\t\t\t\tlist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(list.size()==1){\n\t\t\t\t\tans++;\n\t\t\t\t\tint k=list.get(0);\n\t\t\t\t\tdebug(k, bss[k]);\n\t\t\t\t\tuse[k]=false;\n\t\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\t\t\tif(bss[k].get(j*m+i)){\n\t\t\t\t\t\t\t\ta[j][i]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t\t\tif(use[i]){\n\t\t\t\t\t\t\tbss[i].andNot(bss[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug(\"a\");\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t// debug(a[j]);\n\t\t\t}\n\t\t\t// debug(\"ans\", ans);\n\t\t\tif(!update){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdebug(\"a\");\n\t\tfor(int j=0; j<n; j++){\n\t\t\tdebug(a[j]);\n\t\t}\n\n\t\tdebug(use);\n\t\tfor(int i=0; i<bss.length; i++){\n\t\t\tif(use[i]){\n\t\t\t\tdebug(bss[i]);\n\t\t\t}\n\t\t}\n\n\t\tdebug(\"暫定\", ans);\n\n\t\tBitSet all=new BitSet();\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(a[j][i]==1){\n\t\t\t\t\tall.set(j*m+i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tHashSet<BitSet> set=new HashSet<BitSet>();\n\t\tset.add(all);\n\t\tfor(int i=0; i<bss.length; i++){\n\t\t\tif(!use[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tHashSet<BitSet> set2=new HashSet<BitSet>();\n\t\t\tfor(BitSet bs : set){\n\t\t\t\tBitSet bs1=(BitSet)bs.clone();\n\t\t\t\tbs1.and(bss[i]);\n\t\t\t\tBitSet bs2=(BitSet)bs.clone();\n\t\t\t\tbs2.xor(bs1);\n\t\t\t\tset2.add(bs1);\n\t\t\t\tset2.add(bs2);\n\t\t\t}\n\t\t\tset=set2;\n\t\t}\n\t\tset.remove(new BitSet());\n\t\tfor(BitSet bs : set){\n\t\t\tdebug(bs);\n\t\t}\n\t\tBitSet[] compress=set.toArray(new BitSet[0]);\n\t\tdebug(compress);\n\n\t\tint v=compress.length;\n\t\tint[] a=new int[1<<v];\n\t\tfor(int j=0; j<bss.length; j++){\n\t\t\tif(!use[j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint bit=0;\n\t\t\tfor(int i=0; i<v; i++){\n\t\t\t\tif(bss[j].intersects(compress[i])){\n\t\t\t\t\tbit|=1<<i;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[bit]=1;\n\t\t\tdebug(Integer.toBinaryString(bit));\n\t\t}\n\t\t// (1<<v)-1の被覆\n\n\t\tfor(int i=0; i<v; i++)\n\t\t\tfor(int s=0; s<1<<v; s++)\n\t\t\t\tif((s>>i&1)==1)\n\t\t\t\t\ta[s]+=a[s^(1<<i)];\n\n\t\tint left=0, right=n;\n\t\tfor(; left+1<right;){\n\t\t\tint mid=(left+right)/2;\n\t\t\tif(kCover(mid, a, v))\n\t\t\t\tright=mid;\n\t\t\telse\n\t\t\t\tleft=mid;\n\t\t}\n\t\tif(kCover(0, a, v)){\n\t\t\tright=0;\n\t\t}\n\t\tdebug(\"right\", right);\n\n\t\tans+=right;\n\t\tprintln(ans+\"\");\n\t\t// 極大だけ残す\n\t\t// 被覆できるのがひとつなら確定\n\t}\n\n\tint pow(int x, int k){\n\t\tif(k==0)\n\t\t\treturn 1;\n\t\telse if((k&1)==0)\n\t\t\treturn pow(x*x, k>>>1);\n\t\telse\n\t\t\treturn x*pow(x, k-1);\n\t}\n\n\tboolean kCover(int k, int[] f, int n){\n\t\tlong g=0;\n\t\tfor(int i=0; i<1<<n; i++)\n\t\t\tif(Integer.bitCount(((1<<n)-1)^i)%2==0)\n\t\t\t\tg+=pow(f[i], k);\n\t\t\telse\n\t\t\t\tg-=pow(f[i], k);\n\t\treturn g!=0;\n\t}\n\n\tvoid debug(Object... os){\n\t\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Square Carpets\npublic class Main{\n\n\tint w, h, res, L;\n\tint[][] a, t;\n\tboolean[][][] ok;\n\tMap<String, Integer> ref;\n\t\n\tvoid copy(int[][] a, int[][] b){\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)b[i][j]=a[i][j];\n\t}\n\t\n\tString get(int[][] t){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)sb.append(t[i][j]);\n\t\treturn sb.toString();\n\t}\n\t\n\tvoid dump(){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]==0)System.out.print(\"-\");\n\t\t\t\telse if(t[i][j]==0)System.out.print(\"x\");\n\t\t\t\telse System.out.print(\"o\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tclass R implements Comparable<R>{\n\t\tint i, j, num, len;\n\t\tpublic R(int i, int j, int num, int len) {\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t\tthis.num = num;\n\t\t\tthis.len = len;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn num!=o.num?o.num-num:i*w+j-(o.i*w+o.j);\n\t\t}\n\t}\n\t\n\tboolean dfs(int step, int limit){\n\t\tif(res<=step)return false;\n//\t\tSystem.out.println(\"Step:\"+step);\n//\t\tdump();\n//\t\tString r = get(t);\n//\t\tif(ref.containsKey(r)&&ref.get(r)<=step)return false;\n//\t\tref.put(r, step);\n\t\tboolean e = false;\n\t\tint[][] p = new int[h][w];\n\t\tcopy(t, p);\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(a[i][j]==0||a[i][j]==1&&t[i][j]==1)continue;\n\t\t\tint hs = 0;\n\t\t\tfor(int y=i;y+1<h;y++)for(int x=j;x<w;x++){\n\t\t\t\tif(x-1<0)continue;\n\t\t\t\tif(a[y][x-1]==0&&a[y][x]==1&&a[y+1][x-1]==1&&a[y+1][x]==1)hs+=2;\n\t\t\t}\n\t\t\tif(res<=step+hs)return false;\n//\t\t\tSystem.out.println(\"H:\"+hs +\" \"+(step+h)+\" res:\"+res);\n\t\t\te = true;\n//\t\t\tboolean f = false;\n\t\t\tPriorityQueue<R> q = new PriorityQueue<R>();\n\t\t\tfor(int len=L;len>0;len--){\n//\t\t\t\tif(f)break;\n\t\t\t\tfor(int y=i;y>i-len;y--){\n\t\t\t\t\tif(y<0||h<=y)continue;\n\t\t\t\t\tfor(int x=j;x>j-len;x--){\n//\t\t\t\t\t\tSystem.out.println(\"Y:\"+y+\" X:\"+x);\n\t\t\t\t\t\tif(x<0||w<=x)continue;\n\t\t\t\t\t\tif(!ok[y][x][len])continue;\n\t\t\t\t\t\tint cov = 0;\n//\t\t\t\t\t\tf = true;\n//\t\t\t\t\t\tboolean c = false;\n\t\t\t\t\t\tfor(int n=y;n<y+len;n++)for(int m=x;m<x+len;m++){\n\t\t\t\t\t\t\tif(t[n][m]==0)cov++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new R(y, x, cov, len));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(q.size());\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tR v = q.poll();\n\t\t\t\tfor(int y=v.i;y<v.i+v.len;y++)for(int x=v.j;x<v.j+v.len;x++)t[y][x] = 1;\n\t\t\t\tif(dfs(step+1, limit))return true;\n\t\t\t\tcopy(p, t);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(!e)res = step;\n\t\treturn !e;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tL = Math.min(h, w);\n\t\t\ta = new int[h][w];\n\t\t\tok = new boolean[h][w][L+1];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)a[i][j]=sc.nextInt();\n\t\t\tfor(int d=1;d<=L;d++)for(int i=0;i+d<=h;i++)for(int j=0;j+d<=w;j++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int y=i;y<i+d;y++)for(int x=j;x<j+d;x++)if(a[y][x]==0)f = false;\n\t\t\t\tif(f)ok[i][j][d] = true;\n\t\t\t}\n\t\t\tres = w*h;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tt = new int[h][w];\n\t\t\tdfs(0, 0);\n//\t\t\tfor(int i=0;i<=res;i++){\n//\t\t\t\tSystem.out.println(\"Limit:\"+i);\n//\t\t\t\tif(dfs(0, i))res=i;\n//\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint m, n;\n\tint[][] a;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\ta[j][i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tArrayList<BitSet> candidate=new ArrayList<BitSet>();\n\n\t\tfor(int y=0; y<n; y++){\n\t\t\tfor(int x=0; x<m; x++){\n\t\t\t\tfor(int s=1; x+s<=m&&y+s<=n; s++){\n\t\t\t\t\tboolean all1=true;\n\t\t\t\t\tBitSet bs=new BitSet();\n\t\t\t\t\tfor(int j=y; j<y+s; j++){\n\t\t\t\t\t\tfor(int i=x; i<x+s; i++){\n\t\t\t\t\t\t\tall1&=a[j][i]==1;\n\t\t\t\t\t\t\tbs.set(j*m+i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(all1){\n\t\t\t\t\t\tcandidate.add(bs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean[] use=new boolean[candidate.size()];\n\t\tBitSet[] bss=candidate.toArray(new BitSet[0]);\n\t\tfill(use, true);\n\n\t\tint ans=0;\n\t\tfor(;;){\n\t\t\tboolean update=false;\n\n\t\t\tfor(int j=0; j<bss.length; j++){\n\t\t\t\tif(!use[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t\tif(!use[i]||i==j){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tBitSet bs=(BitSet)bss[j].clone();\n\t\t\t\t\tbs.and(bss[i]);\n\t\t\t\t\tif(bs.equals(bss[j])){\n\t\t\t\t\t\tuse[j]=false;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int b=0; b<m*n; b++){\n\t\t\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t\tif(use[i]&&bss[i].get(b)){\n\t\t\t\t\t\tlist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(list.size()==1){\n\t\t\t\t\tans++;\n\t\t\t\t\tint k=list.get(0);\n\t\t\t\t\tuse[k]=false;\n\t\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\t\t\tif(bss[k].get(j*m+i)){\n\t\t\t\t\t\t\t\ta[j][i]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t\t\tif(use[i]){\n\t\t\t\t\t\t\tbss[i].andNot(bss[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tBitSet all=new BitSet();\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(a[j][i]==1){\n\t\t\t\t\tall.set(j*m+i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tHashSet<BitSet> set=new HashSet<BitSet>();\n\t\tset.add(all);\n\t\tfor(int i=0; i<bss.length; i++){\n\t\t\tif(!use[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tHashSet<BitSet> set2=new HashSet<BitSet>();\n\t\t\tfor(BitSet bs : set){\n\t\t\t\tBitSet bs1=(BitSet)bs.clone();\n\t\t\t\tbs1.and(bss[i]);\n\t\t\t\tBitSet bs2=(BitSet)bs.clone();\n\t\t\t\tbs2.xor(bs1);\n\t\t\t\tset2.add(bs1);\n\t\t\t\tset2.add(bs2);\n\t\t\t}\n\t\t\tset=set2;\n\t\t}\n\t\tset.remove(new BitSet());\n\t\tBitSet[] compress=set.toArray(new BitSet[0]);\n\n\t\t// 包除原理によるk-Cover\n\n\t\tint v=compress.length;\n\t\tint[] a=new int[1<<v];\n\t\tfor(int j=0; j<bss.length; j++){\n\t\t\tif(!use[j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint bit=0;\n\t\t\tfor(int i=0; i<v; i++){\n\t\t\t\tif(bss[j].intersects(compress[i])){\n\t\t\t\t\tbit|=1<<i;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[bit]=1;\n\t\t}\n\n\t\tzeta(a, v);\n\n\t\tint left=0, right=n;\n\t\tif(kCover(0, a, v)){\n\t\t\tright=0;\n\t\t}else{\n\t\t\tfor(; left+1<right;){\n\t\t\t\tint mid=(left+right)/2;\n\t\t\t\tif(kCover(mid, a, v))\n\t\t\t\t\tright=mid;\n\t\t\t\telse\n\t\t\t\t\tleft=mid;\n\t\t\t}\n\t\t}\n\t\tans+=right;\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid zeta(int[] a, int v){\n\t\tfor(int i=0; i<v; i++)\n\t\t\tfor(int s=0; s<1<<v; s++)\n\t\t\t\tif((s>>i&1)==1)\n\t\t\t\t\ta[s]+=a[s^(1<<i)];\n\t}\n\n\tint pow(int x, int k){\n\t\tif(k==0)\n\t\t\treturn 1;\n\t\telse if((k&1)==0)\n\t\t\treturn pow(x*x, k>>>1);\n\t\telse\n\t\t\treturn x*pow(x, k-1);\n\t}\n\n\tboolean kCover(int k, int[] f, int n){\n\t\tint g=0;\n\t\tfor(int i=0; i<1<<n; i++)\n\t\t\tif(Integer.bitCount(((1<<n)-1)^i)%2==0)\n\t\t\t\tg+=pow(f[i], k);\n\t\t\telse\n\t\t\t\tg-=pow(f[i], k);\n\t\treturn g!=0;\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main\n{\n\tstatic Scanner scan = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) \n\t{\n\t\tint w;\n\t\tint h;\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\t\n\t\t\tif(h==0 && w == 0)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnew DataSet(w, h);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class DataSet \n\t{\n\t\tint width;\n\t\tint height;\n\t\tint floor[][] = new int[10][10];\n\t\t\n\t\tpublic DataSet(int w, int h)\n\t\t{\n\t\t\twidth = w;\n\t\t\theight = h;\n\t\t\t\n\t\t\tfor(int i = 0; i < height; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < width; j++)\n\t\t\t\t{\n\t\t\t\t\tfloor[j][i] = scan.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(compute());\n\t\t}\n\t\t\n\t\tpublic int compute()\n\t\t{\n\t\t\tint carpets = 0;\n\t\t\t\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\t//find biggest uncovered rectangle\n\t\t\t\tint maxSize = 0;\n\t\t\t\tint maxX = -1;\n\t\t\t\tint maxY = -1;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < height; i++)//y\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < width; j++)//x\n\t\t\t\t\t{\n\t\t\t\t\t\tif(floor[j][i] == 1 || floor[j][i] == 2) //1 scratched, 2 covered\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//check rectangle from this point\n\t\t\t\t\t\t\tboolean go = true;\n\t\t\t\t\t\t\tint size = 1;\n\t\t\t\t\t\t\tboolean hasUncoveredPanel = false;\n\t\t\t\t\t\t\twhile(go == true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(floor[j][i] == 1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\thasUncoveredPanel = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tsize += 1;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif((i + size-1 > height-1) || (j + size-1 > width-1))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//out of bounds\n\t\t\t\t\t\t\t\t\tgo = false;\n\t\t\t\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//check if flawless panel exists under expanded carpet\n\t\t\t\t\t\t\t\t\tboolean prevHadUnc = false;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tfor(int z = 0; z < size && go == true; z++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//+z\n\t\t\t\t\t\t\t\t\t\tint x1 = j + size-1;\n\t\t\t\t\t\t\t\t\t\tint y1 = i + z;\n\t\t\t\t\t\t\t\t\t\tint x2 = j + z;\n\t\t\t\t\t\t\t\t\t\tint y2 = i + size-1;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 1 || floor[x2][y2] == 1)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tprevHadUnc = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 0 || floor[x2][y2] == 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tgo = false;\n\t\t\t\t\t\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(go == true && prevHadUnc == true) {hasUncoveredPanel = true;}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//rectangle from this point checked\n\t\t\t\t\t\t\tif(size > maxSize && hasUncoveredPanel)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmaxSize = size;\n\t\t\t\t\t\t\t\tmaxX = j;\n\t\t\t\t\t\t\t\tmaxY = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\t//now we know where to put the next carpet\n\t\t\t\tif(maxSize == 0)\n\t\t\t\t{\n\t\t\t\t\t//no more carpets\n\t\t\t\t\treturn carpets;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//cover with carpet\n\t\t\t\t\tfor(int x = maxX; x < (maxX + maxSize); x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int y = maxY; y < (maxY + maxSize); y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloor[x][y] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcarpets += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main\n{\n\tstatic List<Integer> ans = new ArrayList<Integer>();\n\tstatic Scanner scan = new Scanner(System.in);\n\tstatic boolean imm = true;\n\t\n\tpublic static void main(String[] args) \n\t{\n\t\tint w;\n\t\tint h;\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\t\n\t\t\tif(h==0 && w == 0)\n\t\t\t{\n\t\t\t\tif(imm == false)\n\t\t\t\t{\n\t\t\t\t\tfor(int i : ans)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnew DataSet(w, h);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class DataSet \n\t{\n\t\tint width;\n\t\tint height;\n\t\tint floor[][] = new int[10][10];\n\t\t\n\t\tpublic DataSet(int w, int h)\n\t\t{\n\t\t\twidth = w;\n\t\t\theight = h;\n\t\t\t\n\t\t\tfor(int i = 0; i < height; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < width; j++)\n\t\t\t\t{\n\t\t\t\t\tfloor[j][i] = scan.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint anss = compute();\n\t\t\tans.add(anss);\t\t\t\n\t\t\tif(imm) {System.out.println(anss);}\n\t\t}\n\t\t\n\t\tpublic int compute()\n\t\t{\n\t\t\tint carpets = 0;\n\t\t\t\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\t//find biggest uncovered rectangle\n\t\t\t\tint maxSize = 0;\n\t\t\t\tint maxCovered = 0;\n\t\t\t\tint maxRecovered = 999;\n\t\t\t\tint maxAdditionalPriority = 0;\n\t\t\t\tint maxX = -1;\n\t\t\t\tint maxY = -1;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < height; i++)//y\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < width; j++)//x\n\t\t\t\t\t{\n\t\t\t\t\t\tif(floor[j][i] == 1 || floor[j][i] == 2) //1 scratched, 2 covered\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//check rectangle from this point\n\t\t\t\t\t\t\tboolean go = true;\n\t\t\t\t\t\t\tint size = 1;\n\t\t\t\t\t\t\tboolean hasUncoveredPanel = false;\n\t\t\t\t\t\t\tint covered = 0;\n\t\t\t\t\t\t\tint recovered = 0;\n\t\t\t\t\t\t\tint additionalPriority = 0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(floor[j][i] == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(covered == 0) {covered += 1;}\n//\t\t\t\t\t\t\t\tif(covered != 0) {System.out.println(\"Apaan nih!!?\");}\n\t\t\t\t\t\t\t\thasUncoveredPanel = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(j > 0 && floor[j-1][i] == 0) {additionalPriority += 1;}\n\t\t\t\t\t\t\tif(i > 0 && floor[j][i-1] == 0) {additionalPriority += 1;}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\twhile(go == true)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tsize += 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif((i + size-1 > height-1) || (j + size-1 > width-1))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//out of bounds\n\t\t\t\t\t\t\t\t\t\tgo = false;\n\t\t\t\t\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//check if flawless panel exists under expanded carpet\n\t\t\t\t\t\t\t\t\t\tboolean prevHadUnc = false;\n\t\t\t\t\t\t\t\t\t\tint prevUnc = 0;\n\t\t\t\t\t\t\t\t\t\tint prevRec = 0;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tfor(int z = 0; z < size && go == true; z++)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t//+z\n\t\t\t\t\t\t\t\t\t\t\tint x1 = j + size-1;\n\t\t\t\t\t\t\t\t\t\t\tint y1 = i + z;\n\t\t\t\t\t\t\t\t\t\t\tint x2 = j + z;\n\t\t\t\t\t\t\t\t\t\t\tint y2 = i + size-1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 1 || floor[x2][y2] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevHadUnc = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevUnc += 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x2][y2] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(x1 == x2 && y1 == y2)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprevUnc += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t//rec\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 2)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevRec += 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x2][y2] == 2)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(x1 == x2 && y1 == y2)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprevRec += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 0 || floor[x2][y2] == 0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tgo = false;\n\t\t\t\t\t\t\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif(go == true && prevHadUnc == true) \n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\thasUncoveredPanel = true;\n\t\t\t\t\t\t\t\t\t\t\tcovered += prevUnc;\n\t\t\t\t\t\t\t\t\t\t\trecovered += prevRec;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//rectangle from this point checked\n//\t\t\t\t\t\t\tif((covered > maxCovered && hasUncoveredPanel) || (covered == maxCovered && additionalPriority > maxAdditionalPriority && hasUncoveredPanel) || (covered == maxCovered && additionalPriority == maxAdditionalPriority && size > maxSize && hasUncoveredPanel))\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif((covered > maxCovered && hasUncoveredPanel) || (covered == maxCovered && size > maxSize && hasUncoveredPanel) || (covered == maxCovered && size == maxSize && additionalPriority > maxAdditionalPriority && hasUncoveredPanel))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmaxSize = size;\n\t\t\t\t\t\t\t\tmaxCovered = covered;\n\t\t\t\t\t\t\t\tmaxRecovered = recovered;\n\t\t\t\t\t\t\t\tmaxAdditionalPriority = additionalPriority;\n\t\t\t\t\t\t\t\tmaxX = j;\n\t\t\t\t\t\t\t\tmaxY = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\t//now we know where to put the next carpet\n//\t\t\t\t\tif(maxSize == 0)\n\t\t\t\tif(maxCovered == 0)\n\t\t\t\t{\n\t\t\t\t\t//no more carpets\n\t\t\t\t\treturn carpets;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"[\" + (carpets+1) + \"] Put carpet on \" + maxX + \", \" + maxY + \" of size \" + maxSize + \", covering \" + maxCovered + \" recovering \" + maxRecovered);\n\t\t\t\t\t//cover with carpet\n\t\t\t\t\tfor(int x = maxX; x < (maxX + maxSize); x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int y = maxY; y < (maxY + maxSize); y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloor[x][y] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcarpets += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main\n{\n\tstatic List<Integer> ans = new ArrayList<Integer>();\n\tstatic Scanner scan = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) \n\t{\n\t\tint w;\n\t\tint h;\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\t\n\t\t\tif(h==0 && w == 0)\n\t\t\t{\n\t\t\t\tfor(int i : ans)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnew DataSet(w, h);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class DataSet \n\t{\n\t\tint width;\n\t\tint height;\n\t\tint floor[][] = new int[10][10];\n\t\t\n\t\tpublic DataSet(int w, int h)\n\t\t{\n\t\t\twidth = w;\n\t\t\theight = h;\n\t\t\t\n\t\t\tfor(int i = 0; i < height; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < width; j++)\n\t\t\t\t{\n\t\t\t\t\tfloor[j][i] = scan.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans.add(compute());\t\t\t\n//\t\t\tSystem.out.println(compute());\n\t\t}\n\t\t\n\t\tpublic int compute()\n\t\t{\n\t\t\tint carpets = 0;\n\t\t\t\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\t//find biggest uncovered rectangle\n\t\t\t\tint maxSize = 0;\n\t\t\t\tint maxCovered = 0;\n\t\t\t\tint maxX = -1;\n\t\t\t\tint maxY = -1;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < height; i++)//y\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < width; j++)//x\n\t\t\t\t\t{\n\t\t\t\t\t\tif(floor[j][i] == 1 || floor[j][i] == 2) //1 scratched, 2 covered\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//check rectangle from this point\n\t\t\t\t\t\t\tboolean go = true;\n\t\t\t\t\t\t\tint size = 1;\n\t\t\t\t\t\t\tboolean hasUncoveredPanel = false;\n\t\t\t\t\t\t\tint covered = 0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(floor[j][i] == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(covered == 0) {covered += 1;}\n//\t\t\t\t\t\t\t\tif(covered != 0) {System.out.println(\"Apaan nih!!?\");}\n\t\t\t\t\t\t\t\thasUncoveredPanel = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\twhile(go == true)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tsize += 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif((i + size-1 > height-1) || (j + size-1 > width-1))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//out of bounds\n\t\t\t\t\t\t\t\t\t\tgo = false;\n\t\t\t\t\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//check if flawless panel exists under expanded carpet\n\t\t\t\t\t\t\t\t\t\tboolean prevHadUnc = false;\n\t\t\t\t\t\t\t\t\t\tint prevUnc = 0;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tfor(int z = 0; z < size && go == true; z++)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t//+z\n\t\t\t\t\t\t\t\t\t\t\tint x1 = j + size-1;\n\t\t\t\t\t\t\t\t\t\t\tint y1 = i + z;\n\t\t\t\t\t\t\t\t\t\t\tint x2 = j + z;\n\t\t\t\t\t\t\t\t\t\t\tint y2 = i + size-1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 1 || floor[x2][y2] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevHadUnc = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevUnc += 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x2][y2] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(x1 == x2 && y1 == y2)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprevUnc += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 0 || floor[x2][y2] == 0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tgo = false;\n\t\t\t\t\t\t\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif(go == true && prevHadUnc == true) \n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\thasUncoveredPanel = true;\n\t\t\t\t\t\t\t\t\t\t\tcovered += prevUnc;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//rectangle from this point checked\n//\t\t\t\t\t\t\tif(size > maxSize && hasUncoveredPanel)\n\t\t\t\t\t\t\tif((covered > maxCovered && hasUncoveredPanel) || (covered == maxCovered && size > maxSize && hasUncoveredPanel))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmaxSize = size;\n\t\t\t\t\t\t\t\tmaxCovered = covered;\n\t\t\t\t\t\t\t\tmaxX = j;\n\t\t\t\t\t\t\t\tmaxY = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\t//now we know where to put the next carpet\n//\t\t\t\t\tif(maxSize == 0)\n\t\t\t\tif(maxCovered == 0)\n\t\t\t\t{\n\t\t\t\t\t//no more carpets\n\t\t\t\t\treturn carpets;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"Put carpet on \" + maxX + \", \" + maxY + \" of size \" + maxSize + \", covering \" + maxCovered);\n\t\t\t\t\t//cover with carpet\n\t\t\t\t\tfor(int x = maxX; x < (maxX + maxSize); x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int y = maxY; y < (maxY + maxSize); y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloor[x][y] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcarpets += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main\n{\n\tstatic List<Integer> ans = new ArrayList<Integer>();\n\tstatic Scanner scan = new Scanner(System.in);\n\tstatic boolean imm = true;\n\t\n\tpublic static void main(String[] args) \n\t{\n\t\tint w;\n\t\tint h;\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\t\n\t\t\tif(h==0 && w == 0)\n\t\t\t{\n\t\t\t\tif(imm == false)\n\t\t\t\t{\n\t\t\t\t\tfor(int i : ans)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnew DataSet(w, h);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class DataSet \n\t{\n\t\tint width;\n\t\tint height;\n\t\tint floor[][] = new int[10][10];\n\t\t\n\t\tpublic DataSet(int w, int h)\n\t\t{\n\t\t\twidth = w;\n\t\t\theight = h;\n\t\t\t\n\t\t\tfor(int i = 0; i < height; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < width; j++)\n\t\t\t\t{\n\t\t\t\t\tfloor[j][i] = scan.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint anss = compute();\n\t\t\tans.add(anss);\t\t\t\n\t\t\tif(imm) {System.out.println(anss);}\n\t\t}\n\t\t\n\t\tpublic int compute()\n\t\t{\n\t\t\tint carpets = 0;\n\t\t\t\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\t//find biggest uncovered rectangle\n\t\t\t\tint maxSize = 0;\n\t\t\t\tint maxCovered = 0;\n\t\t\t\tint maxRecovered = 999;\n\t\t\t\tint maxAdditionalPriority = 0;\n\t\t\t\tint maxX = -1;\n\t\t\t\tint maxY = -1;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < height; i++)//y\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < width; j++)//x\n\t\t\t\t\t{\n\t\t\t\t\t\tif(floor[j][i] == 1 || floor[j][i] == 2) //1 scratched, 2 covered\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//check rectangle from this point\n\t\t\t\t\t\t\tboolean go = true;\n\t\t\t\t\t\t\tint size = 1;\n\t\t\t\t\t\t\tboolean hasUncoveredPanel = false;\n\t\t\t\t\t\t\tint covered = 0;\n\t\t\t\t\t\t\tint recovered = 0;\n\t\t\t\t\t\t\tint additionalPriority = 0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(floor[j][i] == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(covered == 0) {covered += 1;}\n//\t\t\t\t\t\t\t\tif(covered != 0) {System.out.println(\"Apaan nih!!?\");}\n\t\t\t\t\t\t\t\thasUncoveredPanel = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(j > 0 && floor[j-1][i] == 0) {additionalPriority += 1;}\n\t\t\t\t\t\t\tif(i > 0 && floor[j][i-1] == 0) {additionalPriority += 1;}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\twhile(go == true)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tsize += 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif((i + size-1 > height-1) || (j + size-1 > width-1))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//out of bounds\n\t\t\t\t\t\t\t\t\t\tgo = false;\n\t\t\t\t\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//check if flawless panel exists under expanded carpet\n\t\t\t\t\t\t\t\t\t\tboolean prevHadUnc = false;\n\t\t\t\t\t\t\t\t\t\tint prevUnc = 0;\n\t\t\t\t\t\t\t\t\t\tint prevRec = 0;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tfor(int z = 0; z < size && go == true; z++)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t//+z\n\t\t\t\t\t\t\t\t\t\t\tint x1 = j + size-1;\n\t\t\t\t\t\t\t\t\t\t\tint y1 = i + z;\n\t\t\t\t\t\t\t\t\t\t\tint x2 = j + z;\n\t\t\t\t\t\t\t\t\t\t\tint y2 = i + size-1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 1 || floor[x2][y2] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevHadUnc = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevUnc += 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x2][y2] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(x1 == x2 && y1 == y2)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprevUnc += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t//rec\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 2)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevRec += 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x2][y2] == 2)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(x1 == x2 && y1 == y2)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprevRec += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 0 || floor[x2][y2] == 0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tgo = false;\n\t\t\t\t\t\t\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif(go == true && prevHadUnc == true) \n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\thasUncoveredPanel = true;\n\t\t\t\t\t\t\t\t\t\t\tcovered += prevUnc;\n\t\t\t\t\t\t\t\t\t\t\trecovered += prevRec;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//rectangle from this point checked\n//\t\t\t\t\t\t\tif(size > maxSize && hasUncoveredPanel)\n//\t\t\t\t\t\t\tif((covered > maxCovered && hasUncoveredPanel) || (covered == maxCovered && size > maxSize && hasUncoveredPanel) || (covered == maxCovered && size == maxSize && recovered < maxRecovered) && hasUncoveredPanel)\n//\t\t\t\t\t\t\t\tif((covered > maxCovered && hasUncoveredPanel) || (covered == maxCovered && recovered < maxRecovered && hasUncoveredPanel) || (covered == maxCovered && recovered == maxRecovered && size > maxSize) && hasUncoveredPanel)\n//\t\t\t\t\t\t\tif((covered > maxCovered && hasUncoveredPanel) || (covered == maxCovered && size > maxSize) && hasUncoveredPanel)\n\t\t\t\t\t\t\tif((covered > maxCovered && hasUncoveredPanel) || (covered == maxCovered && size < maxSize && hasUncoveredPanel) || (covered == maxCovered && size == maxSize && additionalPriority > maxAdditionalPriority && hasUncoveredPanel))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmaxSize = size;\n\t\t\t\t\t\t\t\tmaxCovered = covered;\n\t\t\t\t\t\t\t\tmaxRecovered = recovered;\n\t\t\t\t\t\t\t\tmaxAdditionalPriority = additionalPriority;\n\t\t\t\t\t\t\t\tmaxX = j;\n\t\t\t\t\t\t\t\tmaxY = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\t//now we know where to put the next carpet\n//\t\t\t\t\tif(maxSize == 0)\n\t\t\t\tif(maxCovered == 0)\n\t\t\t\t{\n\t\t\t\t\t//no more carpets\n\t\t\t\t\treturn carpets;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"[\" + (carpets+1) + \"] Put carpet on \" + maxX + \", \" + maxY + \" of size \" + maxSize + \", covering \" + maxCovered + \" recovering \" + maxRecovered);\n\t\t\t\t\t//cover with carpet\n\t\t\t\t\tfor(int x = maxX; x < (maxX + maxSize); x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int y = maxY; y < (maxY + maxSize); y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloor[x][y] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcarpets += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main\n{\n\tstatic List<Integer> ans = new ArrayList<Integer>();\n\tstatic Scanner scan = new Scanner(System.in);\n\tstatic boolean imm = true;\n\t\n\tpublic static void main(String[] args) \n\t{\n\t\tint w;\n\t\tint h;\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\t\n\t\t\tif(h==0 && w == 0)\n\t\t\t{\n\t\t\t\tif(imm == false)\n\t\t\t\t{\n\t\t\t\t\tfor(int i : ans)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnew DataSet(w, h);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class DataSet \n\t{\n\t\tint width;\n\t\tint height;\n\t\tint floor[][] = new int[10][10];\n\t\t\n\t\tpublic DataSet(int w, int h)\n\t\t{\n\t\t\twidth = w;\n\t\t\theight = h;\n\t\t\t\n\t\t\tfor(int i = 0; i < height; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < width; j++)\n\t\t\t\t{\n\t\t\t\t\tfloor[j][i] = scan.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint anss = compute();\n\t\t\tans.add(anss);\t\t\t\n\t\t\tif(imm) {System.out.println(anss);}\n\t\t}\n\t\t\n\t\tpublic int compute()\n\t\t{\n\t\t\tint carpets = 0;\n\t\t\t\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\t//find biggest uncovered rectangle\n\t\t\t\tint maxSize = 0;\n\t\t\t\tint maxCovered = 0;\n\t\t\t\tint maxRecovered = 999;\n\t\t\t\tint maxAdditionalPriority = 0;\n\t\t\t\tint maxX = -1;\n\t\t\t\tint maxY = -1;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < height; i++)//y\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < width; j++)//x\n\t\t\t\t\t{\n\t\t\t\t\t\tif(floor[j][i] == 1 || floor[j][i] == 2) //1 scratched, 2 covered\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//check rectangle from this point\n\t\t\t\t\t\t\tboolean go = true;\n\t\t\t\t\t\t\tint size = 1;\n\t\t\t\t\t\t\tboolean hasUncoveredPanel = false;\n\t\t\t\t\t\t\tint covered = 0;\n\t\t\t\t\t\t\tint recovered = 0;\n\t\t\t\t\t\t\tint additionalPriority = 0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(floor[j][i] == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(covered == 0) {covered += 1;}\n//\t\t\t\t\t\t\t\tif(covered != 0) {System.out.println(\"Apaan nih!!?\");}\n\t\t\t\t\t\t\t\thasUncoveredPanel = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(j > 0 && floor[j-1][i] == 0) {additionalPriority += 1;}\n\t\t\t\t\t\t\tif(i > 0 && floor[j][i-1] == 0) {additionalPriority += 1;}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\twhile(go == true)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tsize += 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif((i + size-1 > height-1) || (j + size-1 > width-1))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//out of bounds\n\t\t\t\t\t\t\t\t\t\tgo = false;\n\t\t\t\t\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//check if flawless panel exists under expanded carpet\n\t\t\t\t\t\t\t\t\t\tboolean prevHadUnc = false;\n\t\t\t\t\t\t\t\t\t\tint prevUnc = 0;\n\t\t\t\t\t\t\t\t\t\tint prevRec = 0;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tfor(int z = 0; z < size && go == true; z++)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t//+z\n\t\t\t\t\t\t\t\t\t\t\tint x1 = j + size-1;\n\t\t\t\t\t\t\t\t\t\t\tint y1 = i + z;\n\t\t\t\t\t\t\t\t\t\t\tint x2 = j + z;\n\t\t\t\t\t\t\t\t\t\t\tint y2 = i + size-1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 1 || floor[x2][y2] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevHadUnc = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevUnc += 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x2][y2] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(x1 == x2 && y1 == y2)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprevUnc += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t//rec\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 2)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevRec += 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x2][y2] == 2)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(x1 == x2 && y1 == y2)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprevRec += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 0 || floor[x2][y2] == 0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tgo = false;\n\t\t\t\t\t\t\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif(go == true && prevHadUnc == true) \n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\thasUncoveredPanel = true;\n\t\t\t\t\t\t\t\t\t\t\tcovered += prevUnc;\n\t\t\t\t\t\t\t\t\t\t\trecovered += prevRec;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//rectangle from this point checked\n\t\t\t\t\t\t\tif((covered > maxCovered && hasUncoveredPanel) || (covered == maxCovered && additionalPriority > maxAdditionalPriority && hasUncoveredPanel) || (covered == maxCovered && additionalPriority == maxAdditionalPriority && size > maxSize && hasUncoveredPanel))\n\t\t\t\t\t\t\t\t\n//\t\t\t\t\t\t\tif((covered > maxCovered && hasUncoveredPanel) || (covered == maxCovered && size > maxSize && hasUncoveredPanel) || (covered == maxCovered && size == maxSize && additionalPriority > maxAdditionalPriority && hasUncoveredPanel))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmaxSize = size;\n\t\t\t\t\t\t\t\tmaxCovered = covered;\n\t\t\t\t\t\t\t\tmaxRecovered = recovered;\n\t\t\t\t\t\t\t\tmaxAdditionalPriority = additionalPriority;\n\t\t\t\t\t\t\t\tmaxX = j;\n\t\t\t\t\t\t\t\tmaxY = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\t//now we know where to put the next carpet\n//\t\t\t\t\tif(maxSize == 0)\n\t\t\t\tif(maxCovered == 0)\n\t\t\t\t{\n\t\t\t\t\t//no more carpets\n\t\t\t\t\treturn carpets;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"[\" + (carpets+1) + \"] Put carpet on \" + maxX + \", \" + maxY + \" of size \" + maxSize + \", covering \" + maxCovered + \" recovering \" + maxRecovered);\n\t\t\t\t\t//cover with carpet\n\t\t\t\t\tfor(int x = maxX; x < (maxX + maxSize); x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int y = maxY; y < (maxY + maxSize); y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloor[x][y] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcarpets += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Square Carpets\npublic class Main{\n\n\tint w, h, res, L;\n\tint[][] a, t;\n\tboolean[][][] ok;\n\tMap<Integer, Integer> ref;\n\n\tvoid copy(int[][] a, int[][] b){\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)b[i][j]=a[i][j];\n\t}\n\n\tint get(int[][] t){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)sb.append(t[i][j]);\n\t\treturn sb.toString().hashCode();\n\t}\n\n\n\tvoid dfs(int i, int j, int step){\n\t\tif(res<=step)return;\n\t\tif(i==h){\n\t\t\tres = step; return;\n\t\t}\n\t\tif(a[i][j]==0){\n\t\t\tif(j==w-1)dfs(i+1, 0, step);\n\t\t\telse dfs(i, j+1, step);\n\t\t}\n\t\tint[][] p = new int[h][w];\n\t\tcopy(t, p);\n\t\tif(t[i][j]==0){\n\t\t\tfor(int len=L;len>0;len--){\n\t\t\t\tif(!ok[i][j][len])continue;\n\t\t\t\tfor(int y=i;y<i+len;y++)for(int x=j;x<j+len;x++)t[y][x] = 1;\n\t\t\t\tint hash = get(t);\n\t\t\t\tif(ref.containsKey(hash)&&ref.get(hash)<=step){\n\t\t\t\t\tcopy(p, t); return;\n\t\t\t\t}\n\t\t\t\tref.put(hash, step);\n\t\t\t\tif(j==w-1)dfs(i+1, 0, step+1);\n\t\t\t\telse dfs(i, j+1, step+1);\n\t\t\t\tcopy(p, t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(j==w-1)dfs(i+1, 0, step);\n\t\t\telse dfs(i, j+1, step);\n\t\t\tfor(int len=L;len>0;len--){\n\t\t\t\tif(!ok[i][j][len])continue;\n\t\t\t\tfor(int y=i;y<i+len;y++)for(int x=j;x<j+len;x++)t[y][x] = 1;\n\t\t\t\tint hash = get(t);\n\t\t\t\tif(ref.containsKey(hash)&&ref.get(hash)<=step){\n\t\t\t\t\tcopy(p, t); return;\n\t\t\t\t}\n\t\t\t\tref.put(hash, step);\n\t\t\t\tif(j==w-1)dfs(i+1, 0, step+1);\n\t\t\t\telse dfs(i, j+1, step+1);\n\t\t\t\tcopy(p, t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tL = Math.min(h, w);\n\t\t\ta = new int[h][w];\n\t\t\tok = new boolean[h][w][L+1];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)a[i][j]=sc.nextInt();\n\t\t\tfor(int d=1;d<=L;d++)for(int i=0;i+d<=h;i++)for(int j=0;j+d<=w;j++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int y=i;y<i+d;y++)for(int x=j;x<j+d;x++)if(a[y][x]==0)f = false;\n\t\t\t\tif(f)ok[i][j][d] = true;\n\t\t\t}\n\t\t\tres = w*h;\n\t\t\tref = new HashMap<Integer, Integer>();\n\t\t\tt = new int[h][w];\n\t\t\tdfs(0, 0, 0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main\n{\n\tstatic Scanner scan = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) \n\t{\n\t\tint w;\n\t\tint h;\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\t\n\t\t\tif(h==0 && w == 0)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnew DataSet(w, h);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class DataSet \n\t{\n\t\tint width;\n\t\tint height;\n\t\tint floor[][] = new int[10][10];\n\t\t\n\t\tpublic DataSet(int w, int h)\n\t\t{\n\t\t\twidth = w;\n\t\t\theight = h;\n\t\t\t\n\t\t\tfor(int i = 0; i < height; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < width; j++)\n\t\t\t\t{\n\t\t\t\t\tfloor[j][i] = scan.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(compute());\n\t\t}\n\t\t\n\t\tpublic int compute()\n\t\t{\n\t\t\tint carpets = 0;\n\t\t\t\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\t//find biggest uncovered rectangle\n\t\t\t\tint maxSize = 0;\n\t\t\t\tint maxCovered = 0;\n\t\t\t\tint maxX = -1;\n\t\t\t\tint maxY = -1;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < height; i++)//y\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < width; j++)//x\n\t\t\t\t\t{\n\t\t\t\t\t\tif(floor[j][i] == 1 || floor[j][i] == 2) //1 scratched, 2 covered\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//check rectangle from this point\n\t\t\t\t\t\t\tboolean go = true;\n\t\t\t\t\t\t\tint size = 1;\n\t\t\t\t\t\t\tboolean hasUncoveredPanel = false;\n\t\t\t\t\t\t\tint covered = 0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(floor[j][i] == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(covered == 0) {covered += 1;}\n//\t\t\t\t\t\t\t\tif(covered != 0) {System.out.println(\"Apaan nih!!?\");}\n\t\t\t\t\t\t\t\thasUncoveredPanel = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\twhile(go == true)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tsize += 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif((i + size-1 > height-1) || (j + size-1 > width-1))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//out of bounds\n\t\t\t\t\t\t\t\t\t\tgo = false;\n\t\t\t\t\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//check if flawless panel exists under expanded carpet\n\t\t\t\t\t\t\t\t\t\tboolean prevHadUnc = false;\n\t\t\t\t\t\t\t\t\t\tint prevUnc = 0;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tfor(int z = 0; z < size && go == true; z++)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t//+z\n\t\t\t\t\t\t\t\t\t\t\tint x1 = j + size-1;\n\t\t\t\t\t\t\t\t\t\t\tint y1 = i + z;\n\t\t\t\t\t\t\t\t\t\t\tint x2 = j + z;\n\t\t\t\t\t\t\t\t\t\t\tint y2 = i + size-1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 1 || floor[x2][y2] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevHadUnc = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tprevUnc += 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x2][y2] == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(x1 == x2 && y1 == y2)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprevUnc += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(floor[x1][y1] == 0 || floor[x2][y2] == 0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tgo = false;\n\t\t\t\t\t\t\t\t\t\t\t\tsize -= 1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif(go == true && prevHadUnc == true) \n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\thasUncoveredPanel = true;\n\t\t\t\t\t\t\t\t\t\t\tcovered += prevUnc;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//rectangle from this point checked\n//\t\t\t\t\t\t\tif(size > maxSize && hasUncoveredPanel)\n\t\t\t\t\t\t\tif((covered > maxCovered && hasUncoveredPanel) || (covered == maxCovered && size > maxSize && hasUncoveredPanel))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmaxSize = size;\n\t\t\t\t\t\t\t\tmaxCovered = covered;\n\t\t\t\t\t\t\t\tmaxX = j;\n\t\t\t\t\t\t\t\tmaxY = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\t//now we know where to put the next carpet\n//\t\t\t\t\tif(maxSize == 0)\n\t\t\t\tif(maxCovered == 0)\n\t\t\t\t{\n\t\t\t\t\t//no more carpets\n\t\t\t\t\treturn carpets;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"Put carpet on \" + maxX + \", \" + maxY + \" of size \" + maxSize + \", covering \" + maxCovered);\n\t\t\t\t\t//cover with carpet\n\t\t\t\t\tfor(int x = maxX; x < (maxX + maxSize); x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int y = maxY; y < (maxY + maxSize); y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloor[x][y] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcarpets += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int W, H;\n\tstatic boolean[][] f;\n\tstatic int[][] size;\n\tstatic int[][] count;\n\tstatic int ans;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tH = sc.nextInt();\n\t\t\tf = new boolean[H + 1][W + 1];\n\t\t\tsize = new int[H + 1][W + 1];\n\t\t\tcount = new int[H + 1][W + 1];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tf[i][j] = sc.next().equals(\"1\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\tans = 999;\n\t\tint rest = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (f[i][j]) ++rest;\n\t\t\t\tOUT: for (int k = 1;; ++k) {\n\t\t\t\t\tfor (int r = i; r < i + k; ++r) {\n\t\t\t\t\t\tfor (int c = j; c < j + k; ++c) {\n\t\t\t\t\t\t\tif (!f[r][c]) {\n\t\t\t\t\t\t\t\tsize[i][j] = k - 1;\n\t\t\t\t\t\t\t\tbreak OUT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trec(0, 0, 0, rest);\n\t\treturn ans;\n\t}\n\n\tstatic void rec(int r, int c, int num, int rest) {\n\t\tif (rest == 0) {\n\t\t\tans = num;\n\t\t\treturn;\n\t\t}\n\t\tif (num + 1 >= ans) return;\n\t\tif (c == W) {\n\t\t\trec(r + 1, 0, num, rest);\n\t\t\treturn;\n\t\t}\n\t\tif (!f[r][c] || count[r][c] != 0) {\n\t\t\trec(r, c + 1, num, rest);\n\t\t}\n\n\t\t// prune\n\t\tboolean filled = true;\n\t\tfor (int i = 0; i < size[r][c]; ++i) {\n\t\t\tif (count[r + i][c] == 0) {\n\t\t\t\tfilled = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (filled && size[r][c + 1] >= size[r][c]) return;\n\t\tfilled = true;\n\t\tfor (int i = 0; i < size[r][c]; ++i) {\n\t\t\tif (count[r][c + 1] == 0) {\n\t\t\t\tfilled = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (filled && size[r + 1][c] >= size[r][c]) return;\n\n\t\tboolean use = false;\n\t\tfor (int i = 0; i < size[r][c]; ++i) {\n\t\t\tfor (int j = 0; j < size[r][c]; ++j) {\n\t\t\t\tif (count[r + i][c + j] == 0) {\n\t\t\t\t\tuse = true;\n\t\t\t\t\t--rest;\n\t\t\t\t}\n\t\t\t\tcount[r + i][c + j]++;\n\t\t\t}\n\t\t}\n\t\tif (use) {\n\t\t\trec(r, c + 1, num + 1, rest);\n\t\t}\n\t\tfor (int i = 0; i < size[r][c]; ++i) {\n\t\t\tfor (int j = 0; j < size[r][c]; ++j) {\n\t\t\t\tcount[r + i][c + j]--;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Square Carpets\npublic class Main{\n\n\tint w, h, res, L;\n\tint[][] a, t;\n\tboolean[][][] ok;\n\tMap<Integer, Integer> ref;\n\n\tvoid copy(int[][] a, int[][] b){\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)b[i][j]=a[i][j];\n\t}\n\n\tint get(int[][] t){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)sb.append(t[i][j]);\n\t\treturn sb.toString().hashCode();\n\t}\n\n\tvoid dfs(int i, int j, int step){\n\t\tif(res<=step)return;\n\t\tif(i==h){\n\t\t\tres = step; return;\n\t\t}\n\t\tif(a[i][j]==0){\n\t\t\tif(j==w-1)dfs(i+1, 0, step);\n\t\t\telse dfs(i, j+1, step);\n\t\t}\n\t\tif(t[i][j]==1){\n\t\t\tif(j==w-1)dfs(i+1, 0, step);\n\t\t\telse dfs(i, j+1, step);\t\n\t\t}\n\t\tint[][] p = new int[h][w];\n\t\tcopy(t, p);\n\t\tfor(int len=L;len>0;len--){\n\t\t\tif(!ok[i][j][len])continue;\n\t\t\tfor(int y=i;y<i+len;y++)for(int x=j;x<j+len;x++)t[y][x] = 1;\n\t\t\tint hash = get(t);\n\t\t\tif(ref.containsKey(hash)&&ref.get(hash)<=step){\n\t\t\t\tcopy(p, t); return;\n\t\t\t}\n\t\t\tref.put(hash, step);\n\t\t\tif(j==w-1)dfs(i+1, 0, step+1);\n\t\t\telse dfs(i, j+1, step+1);\n\t\t\tcopy(p, t);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tL = Math.min(h, w);\n\t\t\ta = new int[h][w];\n\t\t\tok = new boolean[h][w][L+1];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)a[i][j]=sc.nextInt();\n\t\t\tfor(int d=1;d<=L;d++)for(int i=0;i+d<=h;i++)for(int j=0;j+d<=w;j++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int y=i;y<i+d;y++)for(int x=j;x<j+d;x++)if(a[y][x]==0)f = false;\n\t\t\t\tif(f)ok[i][j][d] = true;\n\t\t\t}\n\t\t\tres = w*h;\n\t\t\tref = new HashMap<Integer, Integer>();\n\t\t\tt = new int[h][w];\n\t\t\tdfs(0, 0, 0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Square Carpets\npublic class Main{\n\n\tint w, h, res, L;\n\tint[][] a, t;\n\tboolean[][][] ok;\n\tMap<Integer, Integer> ref;\n\n\tvoid copy(int[][] a, int[][] b){\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)b[i][j]=a[i][j];\n\t}\n\n\tString get(int[][] t){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)sb.append(t[i][j]);\n\t\treturn sb.toString();\n\t}\n\n\tvoid dump(){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]==0)System.out.print(\"-\");\n\t\t\t\telse if(t[i][j]==0)System.out.print(\"x\");\n\t\t\t\telse System.out.print(\"o\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tclass R implements Comparable<R>{\n\t\tint i, j, num, len;\n\t\tpublic R(int i, int j, int num, int len) {\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t\tthis.num = num;\n\t\t\tthis.len = len;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn num!=o.num?o.num-num:i*w+j-(o.i*w+o.j);\n\t\t}\n\t}\n\n\tclass P{\n\t\tint y1, x1, y2, x2;\n\t\tpublic P(int y1, int x1, int y2, int x2) {\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y2 = y2;\n\t\t\tthis.x2 = x2;\n\t\t}\n\t\tboolean con(P p){\n\t\t\treturn y1<=p.y1&&p.y2<=y2&&x1<=p.x1&&p.x2<=x2;\n\t\t}\n\t}\n\n\tint hs(int i, int j){\n\t\tint hs = 0;\n\t\tif(i<h-1){\n\t\t\tfor(int y=i;y+1<h;y++)for(int x=j;x<w;x++){\n\t\t\t\tif(x-1<0)continue;\n\t\t\t\tif(a[y][x-1]==0&&a[y][x]==1&&a[y+1][x-1]==1&&a[y+1][x]==1){\n\t\t\t\t\tif(t[y][x]==1&&t[y+1][x-1]==1)hs+=2;\n\t\t\t\t\telse if(t[y][x]==1||t[y+1][x-1]==1||t[y+1][x]==1)hs++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int x=j;x<w;x++)if(a[i][x]==1)hs++;\n\t\t}\n\t\treturn hs;\n\t}\n\n\tvoid dfs(int i, int j, int step){\n//\t\tSystem.out.println(i+\",\"+j+\" \"+step+\" Res:\"+res);\n//\t\tif(i>=h-1)dump();\n\t\tif(res<=step)return;\n\t\tif(i==h){\n\t\t\tres = step; return;\n\t\t}\n\t\tif(a[i][j]==0){\n\t\t\tif(j==w-1)dfs(i+1, 0, step);\n\t\t\telse dfs(i, j+1, step);\n\t\t}\n//\t\tif(res<=hs(i, j)+step)return;\n\t\tint[][] p = new int[h][w];\n\t\tcopy(t, p);\n\t\tif(t[i][j]==0){\n\t\t\tfor(int len=L;len>0;len--){\n\t\t\t\tif(!ok[i][j][len])continue;\n\t\t\t\tfor(int y=i;y<i+len;y++)for(int x=j;x<j+len;x++)t[y][x] = 1;\n\t\t\t\tint hash = get(t).hashCode();\n\t\t\t\tif(ref.containsKey(hash)&&ref.get(hash)<=step){\n\t\t\t\t\tcopy(p, t); return;\n\t\t\t\t}\n\t\t\t\tref.put(hash, step);\n\t\t\t\tif(j==w-1)dfs(i+1, 0, step+1);\n\t\t\t\telse dfs(i, j+1, step+1);\n\t\t\t\tcopy(p, t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(j==w-1)dfs(i+1, 0, step);\n\t\t\telse dfs(i, j+1, step);\n\t\t\tfor(int len=L;len>0;len--){\n\t\t\t\tif(!ok[i][j][len])continue;\n//\t\t\t\tif(i+1<h&&!ok[i+1][j][len]&&(t[i+len-1][j]==0||t[i+len-1][j+len-1]==0)){\n\t\t\t\t\tfor(int y=i;y<i+len;y++)for(int x=j;x<j+len;x++)t[y][x] = 1;\n\t\t\t\t\tint hash = get(t).hashCode();\n\t\t\t\t\tif(ref.containsKey(hash)&&ref.get(hash)<=step){\n\t\t\t\t\t\tcopy(p, t); return;\n\t\t\t\t\t}\n\t\t\t\t\tref.put(hash, step);\n\t\t\t\t\tif(j==w-1)dfs(i+1, 0, step+1);\n\t\t\t\t\telse dfs(i, j+1, step+1);\n\t\t\t\t\tcopy(p, t);\n//\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n//\n//\tboolean dfs(int step, int limit){\n//\t\tif(res<=step)return false;\n//\t\tSystem.out.println(\"Step:\"+step+\" Res:\"+res);\n//\t\t//\t\tdump();\n//\t\tString r = get(t);\n//\t\tif(ref.containsKey(r.hashCode()))return false;\n//\t\tref.put(r.hashCode(), step);\n//\t\tboolean e = false;\n//\t\tint[][] p = new int[h][w];\n//\t\tcopy(t, p);\n//\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n//\t\t\tif(a[i][j]==0||a[i][j]==1&&t[i][j]==1)continue;\n//\t\t\tint hs = 0;\n//\t\t\tfor(int y=i;y+1<h;y++)for(int x=j;x<w;x++){\n//\t\t\t\tif(x-1<0)continue;\n//\t\t\t\tif(a[y][x-1]==0&&a[y][x]==1&&a[y+1][x-1]==1&&a[y+1][x]==1)hs+=2;\n//\t\t\t}\n//\t\t\tif(res<=step+hs)return false;\n//\t\t\t//\t\t\tSystem.out.println(\"H:\"+hs +\" \"+(step+h)+\" res:\"+res);\n//\t\t\te = true;\n//\t\t\t//\t\t\tboolean f = false;\n//\t\t\tPriorityQueue<R> q = new PriorityQueue<R>();\n//\t\t\tfor(int len=L;len>0;len--){\n//\t\t\t\t//\t\t\t\tif(f)break;\n//\t\t\t\tfor(int y=i;y>i-len;y--){\n//\t\t\t\t\tif(y<0||h<=y)continue;\n//\t\t\t\t\tfor(int x=j;x>j-len;x--){\n//\t\t\t\t\t\t//\t\t\t\t\t\tSystem.out.println(\"Y:\"+y+\" X:\"+x);\n//\t\t\t\t\t\tif(x<0||w<=x)continue;\n//\t\t\t\t\t\tif(!ok[y][x][len])continue;\n//\t\t\t\t\t\tint cov = 0;\n//\t\t\t\t\t\t//\t\t\t\t\t\tf = true;\n//\t\t\t\t\t\t//\t\t\t\t\t\tboolean c = false;\n//\t\t\t\t\t\tfor(int n=y;n<y+len;n++)for(int m=x;m<x+len;m++){\n//\t\t\t\t\t\t\tif(t[n][m]==0)cov++;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tq.add(new R(y, x, cov, len));\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t//\t\t\tSystem.out.println(q.size());\n//\t\t\tList<P> ps = new ArrayList<P>();\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tR v = q.poll();\n//\t\t\t\tP pp = new P(v.i, v.j, v.i+v.len-1, v.j+v.len-1);\n//\t\t\t\tboolean go = true;\n//\t\t\t\tfor(P ppp:ps)if(ppp.con(pp)||pp.con(ppp))go=false;\n//\t\t\t\t//\t\t\t\tif(dfs(step+1, limit))return true;\n//\t\t\t\tif(go){\n//\t\t\t\t\t//\t\t\t\t\tSystem.out.println(\"Put:\"+v.i+\",\"+v.j+\" Len:\"+v.len);\n//\t\t\t\t\t//\t\t\t\t\tdump();\n//\t\t\t\t\tps.add(pp);\n//\t\t\t\t\tfor(int y=v.i;y<v.i+v.len;y++)for(int x=v.j;x<v.j+v.len;x++)t[y][x] = 1;\n//\t\t\t\t\t//\t\t\t\t\tdump();\n//\t\t\t\t\tdfs(step+1,limit);\n//\t\t\t\t\tcopy(p, t);\n//\t\t\t\t}\n//\t\t\t\telse System.out.println(\"Cut!!\");\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t}\n//\t\tif(!e)res = step;\n//\t\treturn !e;\n//\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tL = Math.min(h, w);\n\t\t\ta = new int[h][w];\n\t\t\tok = new boolean[h][w][L+1];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)a[i][j]=sc.nextInt();\n\t\t\tfor(int d=1;d<=L;d++)for(int i=0;i+d<=h;i++)for(int j=0;j+d<=w;j++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int y=i;y<i+d;y++)for(int x=j;x<j+d;x++)if(a[y][x]==0)f = false;\n\t\t\t\tif(f)ok[i][j][d] = true;\n\t\t\t}\n\t\t\tres = w*h;\n\t\t\tref = new HashMap<Integer, Integer>();\n\t\t\tt = new int[h][w];\n\t\t\tdfs(0, 0, 0);\n\t\t\t//\t\t\tfor(int i=0;i<=res;i++){\n\t\t\t//\t\t\t\tSystem.out.println(\"Limit:\"+i);\n\t\t\t//\t\t\t\tif(dfs(0, i))res=i;\n\t\t\t//\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            if(w==0 && h==0) break;\n            int[][] panel = new int[h][w];\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    panel[i][j] = sc.nextInt();\n                }\n            }\n\n            int ans = 0;\n            int[] dx = {1, 1, -1, -1};\n            int[] dy = {1, -1, -1, 1};\n\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    if(panel[i][j]==1){\n                        int len = 0;\n                        int idx = 0;\n                        for(int k=9; k>=1; k--){\n                            boolean boo = true;\n                            int cnt = 0;\n                            int max = -1;\n                           \n                            for(int d=0; d<4; d++){\n                                boo = true;\n                               \n                                int l = i;\n                                while(l != i+k*dy[d]){\n                                    int m = j;\n                                    while(m != j+k*dx[d]){\n                                        if(l<0 || l>=h || m<0 || m>=w || panel[l][m]==0){\n                                            boo = false;\n                                            break;\n                                        }\n                                        if(panel[l][m]==1) cnt++;\n                                        m += dx[d];\n                                    }\n                                    if(!boo) break;\n                                    l += dy[d];\n                                }\n\n                                if(boo){\n                                    if(cnt>max){\n                                        max = cnt;\n                                        idx = d;\n                                    }\n                                } \n                                cnt = 0;\n                            }\n\n                            if(max!=-1){\n                                len = k-1;\n                                break;\n                            }\n                        }\n\n                        for(int k=0; k<=len; k++){\n                            for(int l=0; l<=len; l++){\n                                panel[i+k*dy[idx]][j+l*dx[idx]] = -1;\n                            }\n                        }\n                        ans++;\n                    }\n                }\n            }\n\n            System.out.println(ans);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint m, n;\n\tint[][] a;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\ta[j][i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tArrayList<BitSet> candidate=new ArrayList<BitSet>();\n\n\t\tfor(int y=0; y<n; y++){\n\t\t\tfor(int x=0; x<m; x++){\n\t\t\t\tfor(int s=1; x+s<=m&&y+s<=n; s++){\n\t\t\t\t\tboolean all1=true;\n\t\t\t\t\tBitSet bs=new BitSet();\n\t\t\t\t\tfor(int j=y; j<y+s; j++){\n\t\t\t\t\t\tfor(int i=x; i<x+s; i++){\n\t\t\t\t\t\t\tall1&=a[j][i]==1;\n\t\t\t\t\t\t\tbs.set(j*m+i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(all1){\n\t\t\t\t\t\tcandidate.add(bs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean[] use=new boolean[candidate.size()];\n\t\tBitSet[] bss=candidate.toArray(new BitSet[0]);\n\t\tfill(use, true);\n\n\t\tint ans=0;\n\n\t\tfor(;;){\n\t\t\tboolean update=false;\n\n\t\t\tfor(int j=0; j<bss.length; j++){\n\t\t\t\tif(!use[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t\tif(!use[i]||i==j){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tBitSet bs=(BitSet)bss[j].clone();\n\t\t\t\t\tbs.and(bss[i]);\n\t\t\t\t\tif(bs.equals(bss[j])){\n\t\t\t\t\t\tuse[j]=false;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int b=0; b<m*n; b++){\n\t\t\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t\tif(use[i]&&bss[i].get(b)){\n\t\t\t\t\t\tlist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(list.size()==1){\n\t\t\t\t\tans++;\n\t\t\t\t\tint k=list.get(0);\n\t\t\t\t\tuse[k]=false;\n\t\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\t\t\tif(bss[k].get(j*m+i)){\n\t\t\t\t\t\t\t\ta[j][i]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0; i<bss.length; i++){\n\t\t\t\t\t\tif(use[i]){\n\t\t\t\t\t\t\tbss[i].andNot(bss[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tBitSet all=new BitSet();\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(a[j][i]==1){\n\t\t\t\t\tall.set(j*m+i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tHashSet<BitSet> set=new HashSet<BitSet>();\n\t\tset.add(all);\n\t\tfor(int i=0; i<bss.length; i++){\n\t\t\tif(!use[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tHashSet<BitSet> set2=new HashSet<BitSet>();\n\t\t\tfor(BitSet bs : set){\n\t\t\t\tBitSet bs1=(BitSet)bs.clone();\n\t\t\t\tbs1.and(bss[i]);\n\t\t\t\tBitSet bs2=(BitSet)bs.clone();\n\t\t\t\tbs2.xor(bs1);\n\t\t\t\tset2.add(bs1);\n\t\t\t\tset2.add(bs2);\n\t\t\t}\n\t\t\tset=set2;\n\t\t}\n\t\tset.remove(new BitSet());\n\t\tBitSet[] compress=set.toArray(new BitSet[0]);\n\n\t\tint v=compress.length;\n\t\tint[] a=new int[1<<v];\n\t\tfor(int j=0; j<bss.length; j++){\n\t\t\tif(!use[j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint bit=0;\n\t\t\tfor(int i=0; i<v; i++){\n\t\t\t\tif(bss[j].intersects(compress[i])){\n\t\t\t\t\tbit|=1<<i;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[bit]=1;\n\t\t}\n\n\t\tfor(int i=0; i<v; i++)\n\t\t\tfor(int s=0; s<1<<v; s++)\n\t\t\t\tif((s>>i&1)==1)\n\t\t\t\t\ta[s]+=a[s^(1<<i)];\n\n\t\tint left=0, right=n;\n\t\tif(kCover(0, a, v)){\n\t\t\tright=0;\n\t\t}else{\n\t\t\tfor(; left+1<right;){\n\t\t\t\tint mid=(left+right)/2;\n\t\t\t\tif(kCover(mid, a, v))\n\t\t\t\t\tright=mid;\n\t\t\t\telse\n\t\t\t\t\tleft=mid;\n\t\t\t}\n\t\t}\n\t\tans+=right;\n\t\tprintln(ans+\"\");\n\t}\n\n\tint pow(int x, int k){\n\t\tif(k==0)\n\t\t\treturn 1;\n\t\telse if((k&1)==0)\n\t\t\treturn pow(x*x, k>>>1);\n\t\telse\n\t\t\treturn x*pow(x, k-1);\n\t}\n\n\tboolean kCover(int k, int[] f, int n){\n\t\tlong g=0;\n\t\tfor(int i=0; i<1<<n; i++)\n\t\t\tif(Integer.bitCount(((1<<n)-1)^i)%2==0)\n\t\t\t\tg+=pow(f[i], k);\n\t\t\telse\n\t\t\t\tg-=pow(f[i], k);\n\t\treturn g!=0;\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int W, H;\n\tstatic boolean[][] f;\n\tstatic int[][] size;\n\tstatic int[][] count;\n\tstatic int ans;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tH = sc.nextInt();\n\t\t\tf = new boolean[H + 1][W + 1];\n\t\t\tsize = new int[H + 1][W + 1];\n\t\t\tcount = new int[H + 1][W + 1];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tf[i][j] = sc.next().equals(\"1\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\tans = 999;\n\t\tint rest = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (f[i][j]) ++rest;\n\t\t\t\tOUT: for (int k = 1;; ++k) {\n\t\t\t\t\tfor (int r = i; r < i + k; ++r) {\n\t\t\t\t\t\tfor (int c = j; c < j + k; ++c) {\n\t\t\t\t\t\t\tif (!f[r][c]) {\n\t\t\t\t\t\t\t\tsize[i][j] = k - 1;\n\t\t\t\t\t\t\t\tbreak OUT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (rest == 0) return 0;\n\t\trec(0, 0, 0, rest);\n\t\treturn ans;\n\t}\n\n\tstatic void rec(int r, int c, int num, int rest) {\n\t\tif (rest == 0) {\n\t\t\tans = num;\n\t\t\treturn;\n\t\t}\n\t\tif (num + 1 >= ans) return;\n\t\tif (c == W) {\n\t\t\trec(r + 1, 0, num, rest);\n\t\t\treturn;\n\t\t}\n\t\tif (!f[r][c] || count[r][c] != 0) {\n\t\t\trec(r, c + 1, num, rest);\n\t\t}\n\n\t\t// prune\n\t\tboolean filled = true;\n\t\tfor (int i = 0; i < size[r][c]; ++i) {\n\t\t\tif (count[r + i][c] == 0) {\n\t\t\t\tfilled = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (filled && size[r][c + 1] >= size[r][c]) return;\n\t\tfilled = true;\n\t\tfor (int i = 0; i < size[r][c]; ++i) {\n\t\t\tif (count[r][c + i] == 0) {\n\t\t\t\tfilled = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (filled && size[r + 1][c] >= size[r][c]) return;\n\n\t\tboolean use = false;\n\t\tfor (int i = 0; i < size[r][c]; ++i) {\n\t\t\tfor (int j = 0; j < size[r][c]; ++j) {\n\t\t\t\tif (count[r + i][c + j] == 0) {\n\t\t\t\t\tuse = true;\n\t\t\t\t\t--rest;\n\t\t\t\t}\n\t\t\t\tcount[r + i][c + j]++;\n\t\t\t}\n\t\t}\n\t\tif (use) {\n\t\t\trec(r, c + 1, num + 1, rest);\n\t\t}\n\t\tfor (int i = 0; i < size[r][c]; ++i) {\n\t\t\tfor (int j = 0; j < size[r][c]; ++j) {\n\t\t\t\tcount[r + i][c + j]--;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "until (w, h = gets.split.map(&:to_i)).all?(&:zero?)\n  floor = Array.new\n  floor << (w + 2).times.map{0}\n  floor += h.times.map{[0] + gets.split.map(&:to_i) + [0]}\n  floor << (w + 2).times.map{0}\n\n  dp = Array.new(h + 2){Array.new(w + 2){0}}\n  h.downto(1) do |i|\n    w.downto(1) do |j|\n      next if floor[i][j].zero?\n      dp[i][j] = [dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1]].min + 1\n    end\n  end\n\n  answer = 0\n  h.downto(1) do |i|\n    w.downto(1) do |j|\n      next if floor[i][j].zero?\n      answer += 1\n      start = [i, j, dp[i][j]]\n      q = Array.new\n      q << [i, j]\n      until q.empty?\n        y, x = q.shift\n        next if floor[y][x].zero?\n        next if dp[y][x] <= [i - y, j - x].max\n        start = [y, x, dp[y][x]] if start.last <= dp[y][x]\n        q << [y - 1, x] if dp[y][x] <= dp[y - 1][x]\n        q << [y, x - 1] if dp[y][x] <= dp[y][x - 1]\n        q << [y - 1, x - 1] if dp[y][x] <= dp[y - 1][x - 1]\n      end\n      si, sj, size = start\n      si.upto(si + size - 1) do |y|\n        sj.upto(sj + size - 1) do |x|\n          floor[y][x] = 0\n        end\n      end\n    end\n  end\n  p answer\nend"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from itertools import combinations\n    from sys import stdin\n    file_input = stdin\n    \n    while True:\n        W, H = map(int, file_input.readline().split())\n        if W == 0:\n            break\n        \n        carpets = []\n        state = 0\n        \n        # Largest Square algorithm\n        prev = [0] * (W + 1)\n        for i in range(1, H + 1):\n            f_line = file_input.readline().split()\n            cur = [0] * (W + 1)\n            for j, tpl in enumerate(zip(f_line, prev, prev[1:]), start=1):\n                p, p1, p2 = tpl\n                if p == '1':\n                    side = min(p1, p2, cur[j - 1]) + 1\n                    cur[j] = side\n                    \n                    # making carpet bit sequence\n                    line_bit = (1 << side) - 1\n                    line_bit <<= (j - side)\n                    c_b = line_bit\n                    for k in range(side - 1):\n                        c_b <<= W\n                        c_b += line_bit\n                    c_b <<= (W * (i - side))\n                    carpets.append(c_b)\n                else:\n                    b = 1 << (j - 1)\n                    b <<= (W * (i - 1))\n                    state += b\n            prev = cur\n        \n        flag = -1\n        ans = 0\n        while flag != state:\n            flag = state\n            \n            c_check = dict(zip(carpets, [False] * len(carpets)))\n            for c1, c2 in combinations(carpets, 2):\n                if c_check[c1] or c_check[c2]:\n                    continue\n                overlap = c1 & c2\n                if overlap == c2:\n                    c_check[c2] = True\n                elif overlap == c1:\n                    c_check[c1] = True\n            carpets = []\n            for k, v in c_check.items():\n                if not v:\n                    carpets.append(k)\n            \n            for i in range(W * H):\n                b = 1 << i\n                if b & state:\n                    continue\n                t_carpets = []\n                for c in carpets:\n                    if b & c:\n                        t_carpets.append(c)\n                if len(t_carpets) == 1:\n                    c = t_carpets[0]\n                    state |= c\n                    ans += 1\n                    carpets.remove(c)\n            \n            carpets = list(set(c^(c & state) for c in carpets))\n            \n        goal = (1 << (W*H)) - 1\n        if state == goal:\n            print(ans)\n            continue\n        \n        for i in range(1, len(carpets) + 1):\n            for t_carpets in combinations(carpets, i):\n                t_state = state\n                for c in t_carpets:\n                    t_state |= c\n                if t_state == goal:\n                    print(ans + i)\n                    break\n                else:\n                    continue\n                break\n            else:\n                continue\n            break\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef solve():\n    W, H = map(int, readline().split())\n    if W == 0:\n        return False\n    MP = [list(map(int, input().split())) for i in range(H)]\n    C = [[0]*W for i in range(H)]\n    for j in range(W):\n        cur = 0\n        for i in range(H-1, -1, -1):\n            if MP[i][j]:\n                cur += 1\n            else:\n                cur = 0\n            C[i][j] = cur\n    D = [[0]*W for i in range(H)]\n    E = [[0]*W for i in range(H)]\n    for i in range(H):\n        st = []\n        for j in range(W):\n            c = C[i][j]\n            last = j\n            while st and c <= st[-1][0]:\n                p, k = st.pop()\n                last = k\n                d = min(j - k, p)\n                for e in range(k, j-d+1):\n                    D[i][e] = max(D[i][e], d)\n            st.append((c, last))\n        while st:\n            p, k = st.pop()\n            d = min(W - k, p)\n            if d:\n                for e in range(k, W-d+1):\n                    D[i][e] = max(D[i][e], d)\n        st.append((W, 0))\n\n    S = []\n    Z = [0]*(W*H)\n    ALL = 0\n    for i in range(H):\n        for j in range(W):\n            if MP[i][j]:\n                ALL |= 1 << (i*W + j)\n            if E[i][j] < D[i][j]:\n                S.append(i*W + j)\n                Z[i*W + j] = D[i][j]\n            E[i][j] = e = max(E[i][j], D[i][j])\n            if e > 1:\n                E[i+1][j] = max(E[i+1][j], e-1)\n                E[i][j+1] = max(E[i][j+1], e-1)\n                E[i+e-1][j+e-1] = max(E[i+e-1][j+e-1], 1)\n\n    SN = len(S)\n    L = max(W, H)\n    T = [0]*(L+1)\n    for d in range(1, L+1):\n        v = 0\n        for i in range(d):\n            for j in range(d):\n                v |= 1 << (i*W + j)\n        T[d] = v\n    BS = [0]*SN; CS = [0]*SN\n    for i in range(SN):\n        s = S[i]\n        BS[i] = T[Z[s]] << s\n        CS[i] = 1 << s\n\n    memo = [{} for i in range(SN)]\n    def dfs(i, state):\n        if i == SN:\n            if state == ALL:\n                return 0\n            return W*H\n        if state in memo[i]:\n            return memo[i][state]\n        r = W*H\n        if state & CS[i]:\n            r = min(r, dfs(i+1, state))\n        if state & BS[i] != BS[i]:\n            r = min(r, dfs(i+1, state | BS[i]) + 1)\n        memo[i][state] = r\n        return r\n    write(\"%d\\n\" % dfs(0, 0))\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::hash_set::Iter;\nuse std::rc::Rc;\nuse std::ops::DivAssign;\nuse std::ops::MulAssign;\nuse std::ops::SubAssign;\nuse std::collections::BinaryHeap;\nuse std::str::FromStr;\nuse std::collections::HashSet;\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::{AddAssign, Sub};\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::{HashMap, BTreeSet};\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer.trim().to_owned()\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split_whitespace().map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read_map {\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: String) => {\n        let mut $ident = read_value::<String>();\n    };\n    ($ident: ident: String) => {\n        let $ident = read_value::<String>();\n    };\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    (mut $ident: ident: [[$ty:ty]; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    ($ident: ident: [[$ty:ty]; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$ty:ty; $size:expr]) => {\n        let mut $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\nfn move_step(squares: &mut Vec<Vec<HashSet<(usize, usize)>>>, covers: &mut Vec<Vec<HashSet<(usize, usize)>>>) -> (usize, usize) {\n    let mut count = 0usize;\n    let mut cover = 0usize;\n    loop {\n        let mut changed = HashSet::new();\n        while let Some(&(i, j)) = (0 .. squares.len()).flat_map(|i| (0 .. squares[i].len()).map(move |j| (i, j))).find(|&(i, j)| covers[i][j].len() == 1).map(|(i, j)| covers[i][j].iter().next().unwrap()) {\n            count += 1;\n            let covered = squares[i][j].iter().cloned().collect::<Vec<_>>();\n            //println!(\"put i: {}, j: {}, put: {:?}\", i, j, covered);\n            for &(y, x) in &covered {\n                for &(yi, xi) in &covers[y][x] {\n                    squares[yi][xi].remove(&(y, x));\n                    changed.insert((yi, xi));\n                }\n                covers[y][x].clear();\n            }\n            squares[i][j].clear();\n            cover += covered.len();\n        }\n        if changed.is_empty() {break;}\n        //println!(\"changed: {:?}\", changed);\n        for (i, j) in changed {\n            if squares[i][j].is_empty() {continue;}\n            let overlapped = squares[i][j].iter().map(|&(yi, xi)| &covers[yi][xi]).fold((0 .. squares.len()).flat_map(|y| (0 .. squares[y].len()).map(move |x| (y, x))).collect::<HashSet<_>>(), |a, b| a.intersection(b).cloned().collect::<HashSet<_>>());\n            if overlapped.len() > 1 {\n                //println!(\"remove i: {}, j: {}\", i, j);\n                let covered = squares[i][j].iter().cloned().collect::<Vec<_>>();\n                for &(y, x) in &covered {\n                    covers[y][x].remove(&(i, j));\n                }\n                squares[i][j].clear();\n            }\n        }\n    }\n    (count, cover)\n}\nfn search(squares: &mut Vec<Vec<HashSet<(usize, usize)>>>, covers: &mut Vec<Vec<HashSet<(usize, usize)>>>, scratched: usize, current_put: usize, current_min: usize, max_index: (usize, usize)) -> usize {\n    if scratched == 0 {return current_put;}\n    if current_min <= current_put {return current_min;}\n    let (count, cover) = move_step(squares, covers);\n    if cover == scratched {return count + current_put;}\n    let mut result = current_min;\n    for i in 0 .. squares.len() {\n        if i < max_index.0 {continue;}\n        for j in 0 .. squares[i].len() {\n            if i == max_index.0 && j < max_index.1 {continue;}\n            if squares[i][j].is_empty() {continue;}\n            let mut s = squares.clone();\n            let mut c = covers.clone();\n            let covered = squares[i][j].iter().cloned().collect::<Vec<_>>();\n            //println!(\"put i: {}, j: {}, put: {:?}\", i, j, covered);\n            for &(y, x) in &covered {\n                for &(yi, xi) in &covers[y][x] {\n                    s[yi][xi].remove(&(y, x));\n                }\n                c[y][x].clear();\n            }\n            s[i][j].clear();\n            let r = search(&mut s, &mut c, scratched - cover - covered.len(), current_put + 1 + count, result, (i, j));\n            result = min(r, result);\n        }\n    }\n    result\n}\nfn solve(state: &Vec<Vec<usize>>) -> usize {\n    let mut square_size = state.clone();\n    let mut squares = vec![vec![HashSet::<(usize, usize)>::new(); state[0].len()]; state.len()];\n    let mut covers = vec![vec![HashSet::<(usize, usize)>::new(); state[0].len()]; state.len()];\n    for i in (0 .. state.len() - 1).rev() {\n        for j in (0 .. state[i].len() - 1).rev() {\n            if square_size[i][j] != 0 {\n                square_size[i][j] = min(square_size[i + 1][j + 1], min(square_size[i + 1][j], square_size[i][j + 1])) + 1;\n            }\n        }\n    }\n    for i in 0 .. state.len() {\n        for j in 0 .. state[i].len() {\n            for di in 0 .. square_size[i][j] {\n                for dj in 0 .. square_size[i][j] {\n                    squares[i][j].insert((i + di, j + dj));\n                    covers[i + di][j + dj].insert((i, j));\n                }\n            }\n        }\n    }\n\n    for i in 0 .. state.len() {\n        for j in 0 .. state[i].len() {\n            if squares[i][j].is_empty() {continue;}\n            let overlapped = squares[i][j].iter().map(|&(yi, xi)| &covers[yi][xi]).fold((0 .. state.len()).flat_map(|y| (0 .. state[y].len()).map(move |x| (y, x))).collect::<HashSet<_>>(), |a, b| a.intersection(b).cloned().collect::<HashSet<_>>());\n            if overlapped.len() > 1 {\n                //println!(\"remove i: {}, j: {}\", i, j);\n                //println!(\"remove i: {}, j: {}, overlapped: {:?}\", i, j, overlapped);\n                let covered = squares[i][j].iter().cloned().collect::<Vec<_>>();\n                for &(y, x) in &covered {\n                    covers[y][x].remove(&(i, j));\n                }\n                squares[i][j].clear();\n            }\n        }\n    }\n    search(&mut squares, &mut covers, state.iter().map(|line| line.iter().sum::<usize>()).sum::<usize>(), 0, std::usize::MAX, (0, 0))\n}\n\nfn main() {\n    loop {\n        read!(width: usize, height: usize);\n        if height == 0 && width == 0 {break; }\n        read!(state: [[usize]; height]);\n        println!(\"{}\", solve(&state));\n    }\n}\n"
  }
]