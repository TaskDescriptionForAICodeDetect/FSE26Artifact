[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 10\n\nint grid[MAX_SIZE][MAX_SIZE];\nint width, height;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint find_max_square(int x, int y) {\n    int max_size = min(width - x, height - y);\n    for (int size = max_size; size >= 1; size--) {\n        int valid = 1;\n        for (int i = y; i < y + size; i++) {\n            for (int j = x; j < x + size; j++) {\n                if (grid[i][j] != 1) {\n                    valid = 0;\n                    break;\n                }\n            }\n            if (!valid) break;\n        }\n        if (valid) return size;\n    }\n    return 0;\n}\n\nvoid cover(int x, int y, int size, int value) {\n    for (int i = y; i < y + size; i++) {\n        for (int j = x; j < x + size; j++) {\n            grid[i][j] = value;\n        }\n    }\n}\n\nint solve() {\n    int count = 0;\n    while (1) {\n        int max_size = 0;\n        int best_x = -1, best_y = -1;\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                if (grid[y][x] == 1) {\n                    int current_size = find_max_square(x, y);\n                    if (current_size > max_size) {\n                        max_size = current_size;\n                        best_x = x;\n                        best_y = y;\n                    }\n                }\n            }\n        }\n        if (max_size == 0) break;\n        cover(best_x, best_y, max_size, 0);\n        count++;\n    }\n    return count;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &width, &height);\n        if (width == 0 && height == 0) break;\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                scanf(\"%d\", &grid[y][x]);\n            }\n        }\n        printf(\"%d\\n\", solve());\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:05:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CarpetCovering {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int width = scanner.nextInt();\n            int height = scanner.nextInt();\n            \n            if (width == 0 && height == 0) {\n                break;\n            }\n            \n            int[][] grid = new int[height][width];\n            for (int i = 0; i < height; i++) {\n                for (int j = 0; j < width; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n            \n            System.out.println(minimumCarpets(grid));\n        }\n        \n        scanner.close();\n    }\n    \n    private static int minimumCarpets(int[][] grid) {\n        int height = grid.length;\n        int width = grid[0].length;\n        boolean[][] covered = new boolean[height][width];\n        int carpetCount = 0;\n        \n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width; j++) {\n                if (grid[i][j] == 1 && !covered[i][j]) {\n                    placeCarpet(grid, covered, i, j);\n                    carpetCount++;\n                }\n            }\n        }\n        \n        return carpetCount;\n    }\n    \n    private static void placeCarpet(int[][] grid, boolean[][] covered, int row, int col) {\n        int height = grid.length;\n        int width = grid[0].length;\n        \n        for (int i = row; i < Math.min(height, row + 3); i++) {\n            for (int j = col; j < Math.min(width, col + 3); j++) {\n                if (grid[i][j] == 1) {\n                    covered[i][j] = true;\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:05:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool canCover(const vector<vector<int>>& grid, int x, int y, int size) {\n    for (int i = x; i < x + size; ++i) {\n        for (int j = y; j < y + size; ++j) {\n            if (i >= grid.size() || j >= grid[0].size() || grid[i][j] != 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid cover(vector<vector<int>>& grid, int x, int y, int size, int value) {\n    for (int i = x; i < x + size; ++i) {\n        for (int j = y; j < y + size; ++j) {\n            grid[i][j] = value;\n        }\n    }\n}\n\nint dfs(vector<vector<int>>& grid, int count) {\n    int minCarpets = 25; // Since grid size is up to 5x5, 25 is an upper bound\n    bool found = false;\n    int x = -1, y = -1;\n    \n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n                found = true;\n                break;\n            }\n        }\n        if (found) break;\n    }\n    \n    if (!found) {\n        return count;\n    }\n    \n    int maxSize = min(grid.size() - x, grid[0].size() - y);\n    for (int size = maxSize; size >= 1; --size) {\n        if (canCover(grid, x, y, size)) {\n            cover(grid, x, y, size, 0);\n            minCarpets = min(minCarpets, dfs(grid, count + 1));\n            cover(grid, x, y, size, 1);\n        }\n    }\n    \n    return minCarpets;\n}\n\nint main() {\n    int width, height;\n    while (cin >> width >> height, width || height) {\n        vector<vector<int>> grid(height, vector<int>(width));\n        for (int i = 0; i < height; ++i) {\n            for (int j = 0; j < width; ++j) {\n                cin >> grid[i][j];\n            }\n        }\n        cout << dfs(grid, 0) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 20\n\nint grid[MAX_SIZE][MAX_SIZE];\nint width, height;\n\nint can_place_carpet(int row, int col, int size) {\n    for (int r = row; r < row + size; r++) {\n        for (int c = col; c < col + size; c++) {\n            if (r >= height || c >= width || grid[r][c] != 1) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nvoid mark_carpet(int row, int col, int size) {\n    for (int r = row; r < row + size; r++) {\n        for (int c = col; c < col + size; c++) {\n            grid[r][c] = 0;\n        }\n    }\n}\n\nint solve() {\n    int carpets = 0;\n    for (int row = 0; row < height; row++) {\n        for (int col = 0; col < width; col++) {\n            if (grid[row][col] == 1) {\n                int max_size = 1;\n                while (row + max_size <= height && col + max_size <= width && \n                       can_place_carpet(row, col, max_size)) {\n                    max_size++;\n                }\n                max_size--;\n                mark_carpet(row, col, max_size);\n                carpets++;\n            }\n        }\n    }\n    return carpets;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &width, &height);\n        \n        if (width == 0 && height == 0) {\n            break;\n        }\n        \n        for (int r = 0; r < height; r++) {\n            for (int c = 0; c < width; c++) {\n                scanf(\"%d\", &grid[r][c]);\n            }\n        }\n        \n        printf(\"%d\\n\", solve());\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint solve_carpet_problem(int width, int height, vector<vector<int>>& grid) {\n    int carpets = 0;\n    \n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            if (grid[i][j] == 1) {\n                // Place a carpet covering 3x3 area if possible\n                for (int r = max(0, i-1); r <= min(height-1, i+1); r++) {\n                    for (int c = max(0, j-1); c <= min(width-1, j+1); c++) {\n                        grid[r][c] = 0;\n                    }\n                }\n                carpets++;\n            }\n        }\n    }\n    \n    return carpets;\n}\n\nint main() {\n    int width, height;\n    \n    while (cin >> width >> height && width != 0 && height != 0) {\n        vector<vector<int>> grid(height, vector<int>(width));\n        \n        // Read grid\n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width; j++) {\n                cin >> grid[i][j];\n            }\n        }\n        \n        // Solve and output result\n        cout << solve_carpet_problem(width, height, grid) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int w = scanner.nextInt();\n            int h = scanner.nextInt();\n            if (w == 0 && h == 0) break;\n            int[][] grid = new int[h][w];\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n            System.out.println(minCarpets(grid));\n        }\n    }\n\n    private static int minCarpets(int[][] grid) {\n        int count = 0;\n        int h = grid.length;\n        if (h == 0) return 0;\n        int w = grid[0].length;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (grid[i][j] == 1) {\n                    count++;\n                    int maxSize = Math.min(h - i, w - j);\n                    int size = 1;\n                    for (int s = 1; s < maxSize; s++) {\n                        boolean canCover = true;\n                        for (int di = 0; di <= s; di++) {\n                            for (int dj = 0; dj <= s; dj++) {\n                                if (i + di >= h || j + dj >= w || grid[i + di][j + dj] != 1) {\n                                    canCover = false;\n                                    break;\n                                }\n                            }\n                            if (!canCover) break;\n                        }\n                        if (canCover) size = s + 1;\n                        else break;\n                    }\n                    for (int di = 0; di < size; di++) {\n                        for (int dj = 0; dj < size; dj++) {\n                            grid[i + di][j + dj] = 0;\n                        }\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}",
    "timestamp": "2025-08-05 19:06:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_number_of_carpets():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split(\"\\n\")\n    \n    index = 0\n    results = []\n    \n    while index < len(data):\n        # Read grid dimensions\n        width, height = map(int, data[index].split())\n        index += 1\n        \n        if width == 0 and height == 0:\n            break\n        \n        # Read the grid\n        grid = []\n        for _ in range(height):\n            grid.append(list(map(int, data[index].strip())))\n            index += 1\n        \n        # Dynamic Programming approach or Greedy approach could be implemented here\n        def cover_with_min_carpets(grid):\n            def dfs(x, y):\n                if x < 0 or y < 0 or x >= height or y >= width or grid[x][y] == 0:\n                    return\n                grid[x][y] = 0\n                dfs(x + 1, y)\n                dfs(x - 1, y)\n                dfs(x, y + 1)\n                dfs(x, y - 1)\n            \n            carpet_count = 0\n            for i in range(height):\n                for j in range(width):\n                    if grid[i][j] == 1:\n                        carpet_count += 1\n                        dfs(i, j)\n            \n            return carpet_count\n        \n        # Calculate minimum carpets needed\n        min_carpets = cover_with_min_carpets(grid)\n        results.append(min_carpets)\n    \n    for result in results:\n        print(result)\n\nmin_number_of_carpets()",
    "timestamp": "2025-08-13 02:28:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class CarpetCovering {\n\n    private static boolean[][] visited;\n    private static int width, height;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (scanner.hasNext()) {\n            width = scanner.nextInt();\n            height = scanner.nextInt();\n            if (width == 0 && height == 0) break;\n\n            int[][] grid = new int[height][width];\n            visited = new boolean[height][width];\n\n            for (int i = 0; i < height; i++) {\n                for (int j = 0; j < width; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n\n            int carpetCount = 0;\n\n            for (int i = 0; i < height; i++) {\n                for (int j = 0; j < width; j++) {\n                    if (grid[i][j] == 1 && !visited[i][j]) {\n                        carpetCount++;\n                        coverScratchedPanels(grid, i, j);\n                    }\n                }\n            }\n\n            System.out.println(carpetCount);\n        }\n\n        scanner.close();\n    }\n\n    private static void coverScratchedPanels(int[][] grid, int x, int y) {\n        if (x < 0 || x >= height || y < 0 || y >= width || visited[x][y] || grid[x][y] != 1) {\n            return;\n        }\n\n        visited[x][y] = true;\n\n        coverScratchedPanels(grid, x + 1, y);\n        coverScratchedPanels(grid, x - 1, y);\n        coverScratchedPanels(grid, x, y + 1);\n        coverScratchedPanels(grid, x, y - 1);\n    }\n}",
    "timestamp": "2025-08-13 02:28:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\ntypedef struct {\n    int x, y;\n} Rectangle;\n\nint width, height;\nint grid[MAX][MAX];\nint dp[MAX][MAX];\n\n// Checks if the given rectangle can be a square of size size covering only scratched panels\nint canCover(int x, int y, int size) {\n    if (x + size > height || y + size > width) return 0;\n    for (int i = x; i < x + size; i++) {\n        for (int j = y; j < y + size; j++) {\n            if (grid[i][j] == 0) return 0;\n        }\n    }\n    return 1;\n}\n\n// Computes the minimum number of carpets needed\nint minCarpets() {\n    for (int x = height - 1; x >= 0; x--) {\n        for (int y = width - 1; y >= 0; y--) {\n            if (grid[x][y] == 1) {\n                dp[x][y] = dp[x][y+1] + dp[x+1][y] - dp[x+1][y+1] + 1;\n                for (int k = 2; canCover(x, y, k); k++) {\n                    dp[x][y] = dp[x][y] < dp[x+k][y] + dp[x][y+k] - dp[x+k][y+k] + 1 ? dp[x][y] : dp[x+k][y] + dp[x][y+k] - dp[x+k][y+k] + 1;\n                }\n            } else {\n                dp[x][y] = 0;\n            }\n        }\n    }\n    return dp[0][0];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &width, &height);\n        if (width == 0 && height == 0) break;\n\n        for (int i = 0; i < height; ++i) {\n            for (int j = 0; j < width; ++j) {\n                scanf(\"%d\", &grid[i][j]);\n                dp[i][j] = 0;\n            }\n        }\n\n        printf(\"%d\\n\", minCarpets());\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 02:29:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_carpet_problem(width, height, grid):\n    def can_place_carpet(x, y, size):\n        for i in range(x, min(x + size, height)):\n            for j in range(y, min(y + size, width)):\n                if grid[i][j] == 0:\n                    return False\n        return True\n\n    def mark_carpet(x, y, size):\n        for i in range(x, min(x + size, height)):\n            for j in range(y, min(y + size, width)):\n                grid[i][j] = 0\n\n    carpets = 0\n    for i in range(height):\n        for j in range(width):\n            if grid[i][j] == 1:\n                size = 1\n                while size <= max(width, height):\n                    if can_place_carpet(i, j, size):\n                        mark_carpet(i, j, size)\n                        carpets += 1\n                        break\n                    size += 1\n\n    return carpets\n\ndef main():\n    while True:\n        width, height = map(int, input().split())\n        if width == 0 and height == 0:\n            break\n\n        grid = []\n        for _ in range(height):\n            grid.append(list(map(int, input().split())))\n\n        result = solve_carpet_problem(width, height, grid)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:29:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    while True:\n        w, h = map(int, input[ptr:ptr+2])\n        ptr +=2\n        if w ==0 and h ==0:\n            break\n        grid = []\n        for _ in range(h):\n            row = list(map(int, input[ptr:ptr+w]))\n            ptr +=w\n            grid.append(row)\n        \n        count =0\n        for i in range(h):\n            for j in range(w):\n                if grid[i][j] ==1:\n                    # Find the largest possible square starting at (i,j)\n                    max_size = min(h - i, w - j)\n                    found = False\n                    for size in range(max_size, 0, -1):\n                        valid = True\n                        for di in range(size):\n                            for dj in range(size):\n                                if grid[i + di][j + dj] !=1:\n                                    valid = False\n                                    break\n                            if not valid:\n                                break\n                        if valid:\n                            # Mark this square as covered\n                            for di in range(size):\n                                for dj in range(size):\n                                    grid[i + di][j + dj] = 0\n                            count +=1\n                            found = True\n                            break\n                    if not found:\n                        # Cover the single cell\n                        grid[i][j] =0\n                        count +=1\n        print(count)\n\nsolve()",
    "timestamp": "2025-08-13 02:29:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint findMaximalSquare(vector<vector<int>>& grid, int x, int y, vector<vector<int>>& maxSquare) {\n    if (x == 0 || y == 0) return grid[x][y];\n    if (grid[x][y] == 0) return 0;\n    \n    if (maxSquare[x][y] != -1) return maxSquare[x][y];\n    \n    int size = min({findMaximalSquare(grid, x - 1, y - 1, maxSquare),\n                    findMaximalSquare(grid, x - 1, y, maxSquare),\n                    findMaximalSquare(grid, x, y - 1, maxSquare)}) + 1;\n                    \n    maxSquare[x][y] = size;\n    return size;\n}\n\nint countSquares(vector<vector<int>>& grid) {\n    int width = grid.size();\n    int height = grid[0].size();\n    vector<vector<int>> maxSquare(width, vector<int>(height, -1));\n    int carpetCount = 0;\n    while (true) {\n        int maxSize = 0;\n        int startX = -1, startY = -1;\n        for (int x = 0; x < width; ++x) {\n            for (int y = 0; y < height; ++y) {\n                if (grid[x][y] == 1) {\n                    int size = findMaximalSquare(grid, x, y, maxSquare);\n                    if (size > maxSize) {\n                        maxSize = size;\n                        startX = x;\n                        startY = y;\n                    }\n                }\n            }\n        }\n        if (maxSize == 0) break;\n        for (int x = startX; x > startX - maxSize; --x) {\n            for (int y = startY; y > startY - maxSize; --y) {\n                grid[x][y] = 0;\n            }\n        }\n        carpetCount++;\n    }\n    return carpetCount;\n}\n\nint main() {\n    while (true) {\n        int width, height;\n        cin >> width >> height;\n        if (width == 0 && height == 0) break;\n        \n        vector<vector<int>> grid(width, vector<int>(height));\n        for (int x = 0; x < width; ++x) {\n            for (int y = 0; y < height; ++y) {\n                cin >> grid[x][y];\n            }\n        }\n        \n        int result = countSquares(grid);\n        cout << result << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:06:13"
  }
]