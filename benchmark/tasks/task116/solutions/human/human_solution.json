[
  {
    "language": "C++",
    "code": "/*\n * 0290.cc: Microorganism Power Generation\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 12;\nconst int NBITS = 1 << MAX_N;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef pair<int,int> pii;\n\n/* global variables */\n\nint m, w;\nint mbits, wbits;\nint bms[MAX_N], bws[MAX_N], engs[MAX_N][MAX_N];\nint dp[NBITS][NBITS];\n\n/* subroutines */\n\ninline int engy(int bm, int bw) {\n  int db0 = abs(bm - bw), db1 = db0 - 30;\n  return db0 * db1 * db1;\n}\n\nint rec(int bits0, int bits1) {\n  if (dp[bits0][bits1] >= 0) return dp[bits0][bits1];\n\n  int maxd = 0;\n  for (int i = 0, bi = 1; i < m; i++, bi <<= 1)\n    if (bits0 & bi)\n      for (int j = 0, bj = 1; j < w; j++, bj <<= 1)\n\tif (bits1 & bj) {\n\t  int d = engs[i][j] + rec(bits0 ^ bi, bits1 ^ bj);\n\t  if (maxd < d) maxd = d;\n\t}\n\n  return (dp[bits0][bits1] = maxd);\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> m >> w;\n    if (m == 0) break;\n\n    for (int i = 0; i < m; i++) cin >> bms[i];\n    for (int i = 0; i < w; i++) cin >> bws[i];\n\n    for (int i = 0; i < m; i++)\n      for (int j = 0; j < w; j++) engs[i][j] = engy(bms[i], bws[j]);\n    \n    mbits = 1 << m;\n    wbits = 1 << w;\n\n    for (int bits0 = 0; bits0 < mbits; bits0++)\n      for (int bits1 = 0; bits1 < wbits; bits1++)\n\tdp[bits0][bits1] = -1;\n    for (int bits = 0; bits < mbits; bits++) dp[bits][0] = 0;\n    for (int bits = 0; bits < wbits; bits++) dp[0][wbits] = 0;\n\n    int ans = rec(mbits - 1, wbits - 1);\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint dp[1 << 12];\n\nsigned main(){\n\tint m,w;\n\twhile(cin >> m >> w,m){\n\t\tint a[12],b[12];\n\t\tfor(int i = 0;i < m;i++) cin >> a[i];\n\t\tfor(int i = 0;i < w;i++) cin >> b[i];\n\t\tif(m > w){\n\t\t\tfor(int i = 0;i < 12;i++) swap(a[i],b[i]);\n\t\t\tswap(m,w);\n\t\t}\n\t\tfor(int i = 0;i < (1 << w);i++) dp[i] = 0;\n\t\tfor(int i = 0;i < (1 << w);i++){\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0;j < w;j++) if(i >> j & 1) cnt++;\n\t\t\tif(cnt >= m) continue;\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(i >> j & 1) continue;\n\t\t\t\tdp[i | (1 << j)] = max(dp[i | (1 << j)],dp[i] + abs(a[cnt] - b[j]) * (abs(a[cnt] - b[j]) - 30) * (abs(a[cnt] - b[j]) - 30));\n\t\t\t}\n\t\t}\n\t\tint ma = 0;\n\t\tfor(int i = 0;i < (1 << w);i++) ma = max(ma,dp[i]);\n\t\tcout << ma << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint m, w;\ndouble bm[22], bw[22];\ndouble memo[1<<13][1<<13];\n\ndouble e(int i, int j){\n\n  double p = abs(bm[i] - bw[j]);\n  return p * (p-30) * (p-30);\n\n}\n\ndouble solve(int bitm, int bitw){\n\n  if(memo[bitm][bitw]) return memo[bitm][bitw];\n  \n  double ret = 0;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<w;j++){\n      if(!(bitm & (1<<i)) && !(bitw & (1<<j))){\n\tret = max(ret, solve((bitm | (1<<i)), (bitw | (1<<j))) + e(i, j));\n      }\n    } \n  }\n\n  return memo[bitm][bitw] = ret;\n  \n}\nint main(){\n\n  \n  while(cin >> m >> w){\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    \n    memset(memo, 0, sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nint m[30];\nint w[30];\nint dp[13][1<<12];\nint ABS(int a){return max(a,-a);}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%d\",m+i);\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",w+i);\n\t\tfor(int i=0;i<13;i++)for(int j=0;j<(1<<12);j++)\n\t\t\tdp[i][j]=-999999999;\n\t\tdp[0][0]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<(1<<b);j++){\n\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif(j&(1<<k))continue;\n\t\t\t\t\tdp[i+1][j+(1<<k)]=max(dp[i+1][j+(1<<k)],dp[i][j]+ABS(m[i]-w[k])*(ABS(m[i]-w[k])-30)*(ABS(m[i]-w[k])-30));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<(1<<b);i++)ret=max(ret,dp[a][i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#define N 12\nusing namespace std;\nint Cal(int,int);\n\nint main(){\n  int M,W,inbm,inbw,ans,dp[(1<<N)];\n  vector<int> bm,bw;\n  while(1){\n    cin >> M >> W;\n    if(!M&&!W) break;\n    for(int i=0;i<M;i++) cin >> inbm,bm.push_back(inbm);\n    for(int i=0;i<W;i++) cin >> inbw,bw.push_back(inbw);\n    if(M>W){\n      swap(M,W);\n      swap(bm,bw);\n    }\n    for(int i=0;i<(1<<N);i++) dp[i]=0;\n    ans=0;\n    for(int i=0;i<M;i++){\n      for(int j=0;j<(1<<W);j++){\n\tif(i==__builtin_popcount(j)){\n\t  for(int k=0;k<W;k++){\n\t    if(!(j&(1<<k))){\n\t      dp[(j|(1<<k))]=max(dp[(j|(1<<k))],dp[j]+Cal(bm[i],bw[k]));\n\t      ans=max(ans,dp[(j|(1<<k))]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    bm.clear();\n    bw.clear();\n    cout << ans << endl;\n  }\n  return 0;  \n}\n\nint Cal(int m,int w){\n  return abs(m-w)*(abs(m-w)-30)*(abs(m-w)-30);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  while(1){\n    int m,w,bm[12],bw[12];\n    cin >> m >> w;\n    if(m==0 && w==0) break;\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    int dp[(1<<12)]={},ans=0;\n    for(int i=0;i<m;i++)\n      for(int S=(1<<w)-1;S>=0;S--)\n\tfor(int k=0;k<w;k++){\n\t  if((S&(1<<k))!=0)continue;\n\t  int t = abs(bm[i]-bw[k])*(abs(bm[i]-bw[k])-30)*(abs(bm[i]-bw[k])-30);\n\t  dp[S+(1<<k)] = max(dp[S+(1<<k)],dp[S]+t); \n\t  ans = max(ans,dp[S+(1<<k)]);\n\t}\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint M,W,memo[13][1<<13];\nvector<int> A,B;\n\nint getEn(int bm,int bw){\n  int x = abs(bm-bw);\n  return x*pow(x-30,2);\n}\n\nint solve(int idx,int S){\n  if(idx == M){ return memo[idx][S] = 0; }\n  if(memo[idx][S] >= 0){ return memo[idx][S]; }\n  int res = -1;\n  for(int i = 0 ; i < W ; i++){\n    if(S >> i & 1){ continue; }\n    res = max(res,solve(idx+1,S|(1<<i))+getEn(A[idx],B[i]));\n  }\n  return memo[idx][S] = res;\n}\n\nint main(){\n  while(cin >> M >> W, M){\n    A.resize(M); B.resize(W);\n    for(int i = 0 ; i < M ; i++){ cin >> A[i]; }\n    for(int i = 0 ; i < W ; i++){ cin >> B[i]; }\n    if(M > W){ swap(M,W); swap(A,B); }\n    memset(memo,-1,sizeof(memo));\n    cout << solve(0,0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#define N 12\nusing namespace std;\nint Cal(int,int);\n\nint main(){\n  int M,W,inbm,inbw,ans,dp[(1<<N)];\n  vector<int> bm,bw;\n  while(1){\n    cin >> M >> W;\n    if(!M&&!W) break;\n    for(int i=0;i<M;i++) cin >> inbm,bm.push_back(inbm);\n    for(int i=0;i<W;i++) cin >> inbw,bw.push_back(inbw);\n    if(M>W){\n      swap(M,W);\n      swap(bm,bw);\n    }\n    for(int i=0;i<(1<<N);i++) dp[i]=0;\n    ans=0;\n    for(int i=0;i<M;i++){\n      for(int j=0;j<(1<<W);j++){\n\tif(i==__builtin_popcount(j)){\n\t  for(int k=0;k<W;k++){\n\t    if(!(j&(1<<k))){\n\t      dp[(j|(1<<k))]=max(dp[(j|(1<<k))],dp[j]+Cal(bm[i],bw[k]));\n\t      ans=max(ans,dp[(j|(1<<k))]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    bm.clear();\n    bw.clear();\n    cout << ans << endl;\n  }\n  return 0;  \n}\n\nint Cal(int m,int w){\n  return abs(m-w)*(abs(m-w)-30)*(abs(m-w)-30);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define endl \"\\n\"\n\nconst long long INF = (long long)1e18;\nconst long long MOD = (long long)1e9 + 7; \n\nstring yn(bool f){return f?\"Yes\":\"No\";}\nstring YN(bool f){return f?\"YES\":\"NO\";}\n\n#define MAX\n#define TWELVE 12\n\n\n\ninline int calen(int bm, int bw){\n\tint x = abs(bm - bw);\n\treturn x*(x-30)*(x-30);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tvector<int> bitc;\n\t\n\tfor(int i = 0; i <= (1<<(TWELVE)); i++){\n\t\tint con = 0;\n\t\tfor(int j = 0; (1<<j) <= i; j++){\n\t\t\tif((1<<j)&i) con++;\n\t\t}\n\t\t// cout<<i<<\" \"<<con<<endl;\n\t\tbitc.push_back(con);\n\t}\n\t\n\twhile(true){\n\t\tint M, W;\n\t\tint ans = 0;\n\t\tvector<int> m, w;\n\t\tvector<vector<int>>dp;\n\t\t\n\t\tcin>>M>>W;\n\t\t\n\t\tif(!M &&!W) break;\n\t\t\n\t\tm.resize(M);\n\t\tw.resize(W);\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin>>m[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tcin>>w[i];\n\t\t}\n\t\tif(W > M){\n\t\t\tswap(w,m);\n\t\t\tswap(W,M);\n\t\t}\n\t\t\n\t\tdp.resize((1<<M), vector<int>(W+1,0));\n\t\t\n\t\tfor(int i = 1; i <= W; i++){\n\t\t\tfor(int j = 1; j < (1<<M); j++){\n\t\t\t\tif(bitc[j] != i) continue;\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tint bit = j&(~(1<<k));\n\t\t\t\t\t\n\t\t\t\t\tif(bit == j) continue;\n\t\t\t\t\tdp[j][i] = max(dp[bit][i-1] + calen(m[k], w[i-1]),  dp[j][i]);\n\t\t\t\t\t\n\t\t\t\t\t// cout<<i<<\" \"<<j<<\" \"<<k<<\" dp \"<<dp[j][i]<<endl;\n\t\t\t\t\tans = max(dp[j][i], ans);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint M, W;\nint bm[12], bw[12];\nint dp[15][(1<<12)];\n\nint calcPower(int a, int b)\n{\n\tint num = ((a - b) >= 0)? (a - b): (b - a);\n\treturn num * (num - 30) * (num - 30);\n}\n\nint main()\n{\n\twhile(cin >> M >> W, M, W) {\n\t\t// input\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tcin >> bm[i];\n\t\t}\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tcin >> bw[i];\n\t\t}\n\t\t\n\t\tif(M > W) {\n\t\t\tswap(M, W);\n\t\t\tswap(bm, bw);\n\t\t}\n\t\t\n\t\t// initialize\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tfor(int j = 0; j < (1<<W); j++) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tdp[0][(1<<i)] = calcPower(bm[0], bw[i]);\n\t\t}\n\t\t\n\t\t// solve\n\t\tfor(int i = 0; i < M-1; i++) {\n\t\t\tfor(int j = 1; j < (1<<W); j++) {\n\t\t\t\tif(dp[i][j] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < W; k++) {\n\t\t\t\t\tif((j & (1<<k))) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint next = ((j | (1<<k)));\n\t\t\t\t\tint cost = dp[i][j] + calcPower(bm[i+1], bw[k]);\n\t\t\t\t\tdp[i+1][next] = max(dp[i+1][next], cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 0; i < (1<<W); i++) {\n\t\t\tans = max(ans, dp[M-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n#define SQR(x) ((x)*(x))\nint main(){\n  int N, W, bm[12], bw[12];\n\n  while(cin >> N >> W, N){\n    for(int i = 0; i < N; i++){\n      cin >> bm[i];\n    }\n    for(int i = 0; i < W; i++){\n      cin >> bw[i];\n    }\n    vector< int > dp( 1 << W, -1);\n    dp[0] = 0;\n    for(int i = 0; i < N; i++){\n      for(int j = (1 << W) - 1; j >= 0; j--){\n        if(dp[j] == -1) continue;\n        for(int k = 0; k < W; k++){\n          if((j >> k) & 1) continue;\n          dp[j|(1 << k)] = max( dp[j|(1 << k)], dp[j] + abs(bm[i] - bw[k]) * SQR(abs(bm[i] - bw[k]) - 30));\n        }\n      }\n    }\n    cout << *max_element( dp.begin(), dp.end()) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint a[12], b[12];\nint dp[13][1 << 12];\n\nint calc(int i, int j)\n{\n\tint d = abs(a[i] - b[j]);\n\treturn d * (d - 30) * (d - 30);\n}\n\nint solve()\n{\n\tmemset(dp, 0, sizeof dp);\n\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int bit = 0; bit < (1 << m); bit++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (bit & (1 << j)) continue;\n\t\t\t\tint &nx = dp[i + 1][bit + (1 << j)];\n\t\t\t\tnx = max(nx, dp[i][bit] + calc(i, j));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i <= n; i++){\n\t\tfor (int j = 0; j < (1 << m); j++){\n\t\t\tres = max(res, dp[i][j]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> m, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<int> x(n), y(m);\n        for(int i=0; i<n; ++i)\n            cin >> x[i];\n        for(int i=0; i<m; ++i)\n            cin >> y[i];\n\n        if(n < m){\n            swap(n, m);\n            x.swap(y);\n        }\n\n        vector<int> dp(1<<n, 0);\n        for(int i=0; i<(1<<n); ++i){\n            bitset<32> bs(i);\n            int k = bs.count();\n            if(k >= m)\n                continue;\n\n            for(int j=0; j<n; ++j){\n                if(bs[j])\n                    continue;\n                bs[j] = true;\n\n                int e = abs(x[j] - y[k]);\n                e *= (e - 30) * (e - 30);\n                dp[bs.to_ulong()] = max(dp[bs.to_ulong()], dp[i] + e);\n\n                bs[j] = false;\n            }\n        }\n\n        int ans = *max_element(dp.begin(), dp.end());\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[13][1<<12];\nint main(){\n  int m,w,bm[12],bw[12];\n  while(1){ \n    cin>>m>>w;\n    if(m==0 && w==0)break;\n    for(int i=0;i<13;i++)\n      for(int j=0;j<(1<<w);j++) dp[i][j] = 0;\n\n    for(int i=0;i<m;i++)cin>>bm[i];\n    for(int i=0;i<w;i++)cin>>bw[i];\n\n    int ans=0;    \n    for(int i=0;i<m;i++)\n      for(int S=0;S<(1<<w);S++){ \n\t//if(i < __builtin_popcount(S))continue;\n\tfor(int l=0;l<w;l++){\n\t  if((S&(1<<l))!=0)continue;\n\t  int t=abs(bm[i]-bw[l])*(abs(bm[i]-bw[l])-30)*(abs(bm[i]-bw[l])-30);\n\t  dp[i+1][S+(1<<l)]=max(dp[i+1][S+(1<<l)],dp[i][S]+t);\n\t  ans=max(ans,dp[i+1][S+(1<<l)]);\n\t}  \n      }\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int m,w,bm[12],bw[12];\n  while(1){ \n    cin>>m>>w;\n    if(m==0 && w==0)break;\n    int dp[13][1<<12]={};\n    for(int i=0;i<m;i++)cin>>bm[i];\n    for(int i=0;i<w;i++)cin>>bw[i];\n\n    int ans=0;    \n    for(int i=0;i<m;i++)\n      for(int S=0;S<(1<<w);S++){ \n\t//if(i < __builtin_popcount(S))continue;\n\tfor(int l=0;l<w;l++){\n\t  if((S&(1<<l))!=0)continue;\n\t\n\t  int t=abs(bm[i]-bw[l])*(abs(bm[i]-bw[l])-30)*(abs(bm[i]-bw[l])-30);\n\t  dp[i+1][S+(1<<l)]=max(dp[i+1][S+(1<<l)],dp[i][S]+t);\n\t  dp[i+1][S] = max(dp[i+1][S],dp[i][S]);  \n\t  ans=max(ans,dp[i+1][S+(1<<l)]);\n\t}  \n      }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef long long ll;\ntypedef long double ld;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n#define rrep(i,x) for(int i = x-1 ; i >= 0 ; i --)\n#define rrep1(i,x) for(int i = x ; i > 0 ; i --)\n#define fr first\n#define sc second\n#define pb push_back\n\nconst int INF = 1000000000;\n\nint cal(int bm,int bw){\n\tint d = abs(bm-bw);\n\treturn d*(d-30)*(d-30);\n}\n\nint main(){\n\twhile(1){\n\t\tint m,w;\n\t\tint bm[15],bw[15];\n\t\tscanf(\"%d%d\",&m,&w);\n\t\tif(m == 0 && w == 0)break;\n\t\trep(i,m)scanf(\"%d\",&bm[i]);\n\t\trep(i,w)scanf(\"%d\",&bw[i]);\n\t\tint dp[12][1 << 12] = {};\n\t\tint ret = 0;\n\t\trep(i,m){\n\t\t\trep(j,(1<<w)){\n\t\t\t\tdp[i+1][j] = max ( dp[i+1][j] , dp[i][j] );\n\t\t\t\trep(k,w){\n\t\t\t\t\tif((j>>k)&1)continue;\n\t\t\t\t\tdp[i+1][j|(1<<k)] = max ( dp[i+1][j|(1<<k)] , dp[i][j] + cal(bm[i],bw[k]) );\n\t\t\t\t}\n\t\t\t\tret = max ( ret , dp[i][j] );\n\t\t\t}\n\t\t}\n\t\trep(j,(1<<w))ret = max ( ret , dp[m][j] );\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint m, w;\nint bm[22], bw[22];\nint memo[22][1<<13];\n\nint e(int i, int j){\n\n  int p = abs(bm[i] - bw[j]);\n  return p * (p-30) * (p-30);\n\n}\n\nint solve(int cntm, int bitw){\n\n  if(~memo[cntm][bitw]) return memo[cntm][bitw];\n  if(cntm == m) return 0;\n  \n  int ret = 0;\n  for(int i=0;i<w;i++){\n    if(bitw & (1<<i)) continue;\n    ret = max(ret, solve(cntm+1, (bitw | (1<<i))) + e(cntm, i));\n  }\n  \n  ret = max(ret, solve(cntm+1, bitw));\n  \n  return memo[cntm][bitw] = ret;\n  \n}\n\nint main(){\n\n  while(cin >> m >> w){\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    \n    memset(memo, -1, sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nint dp[1<<12][13];\n\nint main(){\n\tint M,W;\n\twhile(scanf(\"%d%d\",&M,&W),M!=0){\n\t\tint bm[12],bw[12];\n\t\tfor(int i=0;i<M;i++) scanf(\"%d\",&bm[i]);\n\t\tfor(int i=0;i<W;i++) scanf(\"%d\",&bw[i]);\n\t\tfor(int i=0;i<(1<<12);i++) for(int j=0;j<13;j++) dp[i][j]=-1;\n\t\tdp[0][0]=0;\n\t\tfor(int j=0;j<W;j++) for(int i=0;i<(1<<M);i++){\n\t\t\tif(dp[i][j]<0) continue;\n\t\t\tdp[i][j+1]=max(dp[i][j],dp[i][j+1]);\n\t\t\tfor(int k=0;k<M;k++){\n\t\t\t\tint x=1<<k;\n\t\t\t\tif(i&x) continue;\n\t\t\t\tint y=abs(bm[k]-bw[j]);\n\t\t\t\tdp[i+x][j+1]=max(dp[i][j]+y*(y-30)*(y-30),dp[i+x][j+1]);\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(int i=0;i<(1<<M);i++) res=max(res,dp[i][W]);\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <time.h>\n#include <cctype>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=1e+5+10;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL mod=1e+9 + 7;\n\nint M, W;\nint MB[16], WB[16];\nint memo[16][1 << 13];\n\nint calc(int m, int w){\n\treturn abs(MB[m] - WB[w]) * (int)pow(abs(MB[m] - WB[w]) - 30, 2);\n}\n\nint rec(int m, int w){\n\tif(memo[m][w] != -1)\n\t\treturn memo[m][w];\n\tif(m >= M)\n\t\treturn 0;\n\tint res = 0;\n\tREP(i,W){\n\t\tif(!(w >> i & 1)){\n\t\t\tres = max(res, rec(m + 1, w | 1 << i) + calc(m, i));\n\t\t}\n\t}\n\treturn memo[m][w] = res;\n}\n\nint main() {\n\twhile(cin >> M >> W && (M || W)){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tREP(i,M){\n\t\t\tcin >> MB[i];\n\t\t}\n\t\tREP(i,W){\n\t\t\tcin >> WB[i];\n\t\t}\n\t\tif(M > W){\n\t\t\tREP(i,M){\n\t\t\t\tif(i < W){\n\t\t\t\t\tswap(MB[i], WB[i]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tWB[i] = MB[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(M, W);\n\t\t}\n\t\tcout << rec(0, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nint hungarian(vector<vector<int> > a) {\n  int n=a.size(),p,q,INF=1<<29;\n  vector<int> fx(n,INF),fy(n,0);\n  vector<int> x(n,-1),y(n,-1);\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      fx[i]=max(fx[i],a[i][j]);\n  for(int i=0;i<n;) {\n    vector<int> t(n,-1),s(n+1,i);\n    for(p=q=0;p<=q&&x[i]<0;p++)\n      for(int k=s[p],j=0;j<n&&x[i]<0;j++)\n        if(fx[k]+fy[j]==a[k][j]&&t[j]<0) {\n          s[++q]=y[j],t[j]=k;\n          if(s[q]<0)for(p=j;p>=0;j=p) y[j]=k=t[j],p=x[k],x[k]=j;\n        }\n    if(x[i]<0) {\n      int d=INF;\n      for(int k=0;k<=q;k++)\n        for(int j=0;j<n;j++)\n          if(t[j]<0) d=min(d,fx[s[k]]+fy[j]-a[s[k]][j]);\n      for(int j=0;j<n;j++) fy[j]+=(t[j]<0?0:d);\n      for(int k=0;k<=q;k++) fx[s[k]]-=d;\n    } else i++;\n  }\n  int ret=0;\n  for(int i=0;i<n;i++) ret+=a[i][x[i]];\n  return ret;\n}\n\nvoid Main() {\n  int n,m;\n  while(cin >> n >> m && n) {\n    vector<int> a(n),b(m);\n    rep(i,n) R a[i];\n    rep(i,m) R b[i];\n    if(n<m) swap(a,b),swap(n,m);\n    vector<vector<int> > v;\n    rep(i,n) {\n      vector<int> w;\n      rep(j,m) {\n        int d=abs(a[i]-b[j]);\n        w.pb(d*(d-30)*(d-30));\n      }\n      REP(j,m,n) w.pb(0);\n      v.pb(w);\n    }\n    pr(hungarian(v));\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint m, w;\nint bm[22], bw[22];\nint memo[22][1<<13];\n\nint e(int a, int b){\n\n  int p = abs(bm[a] - bw[b]);\n  return p * (p-30) * (p-30);\n\n}\n\nint solve(int cntm, int bitw){\n\n  if(memo[cntm][bitw]) return memo[cntm][bitw];\n  if(cntm == m) return 0;\n  \n  int ret = 0;\n  for(int i=0;i<w;i++)\n    if(!(bitw & (1<<i)))\n    ret = max(ret, solve(cntm+1, (bitw | (1<<i))) + e(cntm, i));\n  \n  ret = max(ret, solve(cntm+1, bitw));\n  \n  return memo[cntm][bitw] = ret;\n  \n}\n\nint main(){\n\n  while(cin >> m >> w){\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    \n    memset(memo, 0, sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < 12; i++)check[i] = false;\n\t}\n\n\tshort table[6],index;\n\tbool check[12];\n};\n\nint table_2[2][2],table_3[6][3],table_4[24][4],table_5[120][5],table_6[720][6];\n\nvoid func(int M,int W){\n\tint m_data[M],w_data[W];\n\n\tfor(int i = 0; i < M; i++)scanf(\"%d\",&m_data[i]);\n\tfor(int i = 0; i < W; i++)scanf(\"%d\",&w_data[i]);\n\n\tint maximum = 0,tmp,select_num,num,left_index,right_index,left_tmp,right_tmp,left_max,right_max,limit,loc_left[7],loc_right[7],index,val,calc[7];\n\n\tif(M == 1){\n\t\tfor(int i = 0; i < W; i++){\n\t\t\ttmp = abs(w_data[i] - m_data[0])*(abs(w_data[i] - m_data[0])-30)*(abs(w_data[i] - m_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else if(W == 1){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\ttmp = abs(m_data[i] - w_data[0])*(abs(m_data[i] - w_data[0])-30)*(abs(m_data[i] - w_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else{\n\t\tif(M > W){\n\t\t\tselect_num = (M+1)/2;\n\n\t\t\tlimit = pow(2,M);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\t//??°???????????????????????????\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tif(left_index == 1){\n\t\t\t\t\tval = abs(w_data[0] - m_data[loc_left[0]]);\n\t\t\t\t\tleft_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t}else if(left_index == 2){\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_2[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 3){\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_3[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 4){\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],calc[3] = m_data[loc_left[3]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_4[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 5){\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],calc[3] = m_data[loc_left[3]],calc[4] = m_data[loc_left[4]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_5[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //left_index == 6\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],\n\t\t\t\t\t\t\t\tcalc[3] = m_data[loc_left[3]],calc[4] = m_data[loc_left[4]],calc[5] = m_data[loc_left[5]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_6[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(right_index == 1){\n\t\t\t\t\tval = abs(w_data[W-1] - m_data[loc_right[0]]);\n\t\t\t\t\tright_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t}else if(right_index == 2){\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_2[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 3){\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_3[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 4){\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],calc[3] = m_data[loc_right[3]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_4[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 5){\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],calc[3] = m_data[loc_right[3]],calc[4] = m_data[loc_right[4]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_5[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //right_index == 6\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],\n\t\t\t\t\t\t\t\tcalc[3] = m_data[loc_right[3]],calc[4] = m_data[loc_right[4]],calc[5] = m_data[loc_right[5]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_6[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\n\t\t}else{ //W >= M\n\t\t\tselect_num = (W+1)/2;\n\n\t\t\tlimit = pow(2,W);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tif(left_index == 1){\n\t\t\t\t\tval = abs(m_data[0] - w_data[loc_left[0]]);\n\t\t\t\t\tleft_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t}else if(left_index == 2){\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_2[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 3){\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_3[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 4){\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],calc[3] = w_data[loc_left[3]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_4[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 5){\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],calc[3] = w_data[loc_left[3]],calc[4] = w_data[loc_left[4]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_5[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //left_index == 6\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],\n\t\t\t\t\t\t\t\tcalc[3] = w_data[loc_left[3]],calc[4] = w_data[loc_left[4]],calc[5] = w_data[loc_left[5]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_6[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(right_index == 1){\n\t\t\t\t\tval = abs(m_data[M-1] - w_data[loc_right[0]]);\n\t\t\t\t\tright_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t}else if(right_index == 2){\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_2[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 3){\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_3[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 4){\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],calc[3] = w_data[loc_right[3]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_4[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 5){\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],calc[3] = w_data[loc_right[3]],calc[4] = w_data[loc_right[4]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_5[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //right_index == 6\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],\n\t\t\t\t\t\t\t\tcalc[3] = w_data[loc_right[3]],calc[4] = w_data[loc_right[4]],calc[5] = w_data[loc_right[5]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_6[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\tint M,W,index_2 = 0,index_3 = 0,index_4 = 0, index_5 = 0,index_6 = 0;\n\n\tfor(int a = 0; a < 2; a++){\n\t\tfor(int b = 0; b < 2; b++){\n\t\t\tif(a != b){\n\t\t\t\ttable_2[index_2][0] = a,table_2[index_2][1] = b;\n\t\t\t\tindex_2++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < 3; a++){\n\t\tfor(int b = 0; b < 3; b++){\n\t\t\tfor(int c = 0; c < 3; c++){\n\t\t\t\tif(a != b && a != c && b != c){\n\t\t\t\t\ttable_3[index_3][0] = a,table_3[index_3][1] = b,table_3[index_3][2] = c;\n\t\t\t\t\tindex_3++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < 4; a++){\n\t\tfor(int b = 0; b < 4; b++){\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tif(a != b && a != c && a != d && b != c && b != d && c != d){\n\t\t\t\t\t\ttable_4[index_4][0] = a,table_4[index_4][1] = b,table_4[index_4][2] = c,table_4[index_4][3] = d;\n\t\t\t\t\t\tindex_4++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < 5; a++){\n\t\tfor(int b = 0; b < 5; b++){\n\t\t\tfor(int c = 0; c < 5; c++){\n\t\t\t\tfor(int d = 0; d < 5; d++){\n\t\t\t\t\tfor(int e = 0; e < 5; e++){\n\t\t\t\t\t\tif(a != b && a != c && a != d && a != e && b != c && b != d && b != e && c != d && c != e && d != e){\n\t\t\t\t\t\t\ttable_5[index_5][0] = a,table_5[index_5][1] = b,table_5[index_5][2] = c,table_5[index_5][3] = d,table_5[index_5][4] = e;\n\t\t\t\t\t\t\tindex_5++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < 6; a ++){\n\t\tfor(int b = 0; b < 6; b++){\n\t\t\tfor(int c = 0; c < 6; c++){\n\t\t\t\tfor(int d = 0; d < 6; d++){\n\t\t\t\t\tfor(int e = 0; e < 6; e++){\n\t\t\t\t\t\tfor(int f = 0; f < 6; f++){\n\t\t\t\t\t\t\tif(a != b && a != c && a != d && a != e && a != f && b != c && b != d && b != e && b != f && c != d && c != e && c != f && d != e && d != f && e != f){\n\t\t\t\t\t\t\t\ttable_6[index_6][0] = a,table_6[index_6][1] = b,table_6[index_6][2] = c,table_6[index_6][3] = d,table_6[index_6][4] = e,table_6[index_6][5] = f;\n\t\t\t\t\t\t\t\tindex_6++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&M,&W);\n\t\tif(M == 0 && W == 0)break;\n\n\t\tfunc(M,W);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[1<<12][1<<12];\nint main(){\n  int m,w,bm[12],bw[12];\n  while(1){ \n    cin>>m>>w;\n    if(m==0)break;\n    int ans=0;\n    for(int i=0;i<(1<<m);i++)\n      for(int j=0;j<(1<<w);j++)dp[i][j]=0;\n    for(int i=0;i<m;i++)cin>>bm[i];\n    for(int i=0;i<w;i++)cin>>bw[i];\n\n    for(int i=0;i<(1<<m);i++){  \n      for(int j=0;j<(1<<w);j++){ \n\tif(__builtin_popcount(i) != __builtin_popcount(j))continue;\n\tfor(int k=0;k<m;k++)\n\t  for(int l=0;l<w;l++){\n\t    if((i&(1<<k))!=0||(j&(1<<l))!=0)continue;\n\t    int t=abs(bm[k]-bw[l])*(abs(bm[k]-bw[l])-30)*(abs(bm[k]-bw[l])-30);\n\t    dp[i+(1<<k)][j+(1<<l)]=max(dp[i+(1<<k)][j+(1<<l)],dp[i][j]+t);\n\t    ans=max(ans,dp[i+(1<<k)][j+(1<<l)]);\n\t  }   \n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint m, w;\nint bm[22], bw[22];\nint memo[22][1<<13];\n\nint e(int i, int j){\n\n  int p = abs(bm[i] - bw[j]);\n  return p * (p-30) * (p-30);\n\n}\n\nint solve(int cntm, int bitw){\n\n  if(~memo[cntm][bitw]) return memo[cntm][bitw];\n  if(cntm == m) return 0;\n  \n  int ret = 0;\n  for(int i=0;i<w;i++)\n    if(!(bitw & (1<<i)))\n      ret = max(ret, solve(cntm+1, (bitw | (1<<i))) + e(cntm, i));\n\n  ret = max(ret, solve(cnt+1, bitw));\n  \n  return memo[cntm][bitw] = ret;\n  \n}\n\nint main(){\n\n  while(cin >> m >> w){\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    \n    memset(memo, -1, sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nll dp[1 << 12][13], a[12], b[12];\nint main() {\n\tint m, w;\n\twhile (scanf(\"%lld%lld\", &m, &w), m) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(i, m)scanf(\"%lld\", &a[i]);\n\t\trep(i, w)scanf(\"%lld\", &b[i]);\n\t\trep(i, 1 << w)rep(j, m) {\n\t\t\trep(k, w) {\n\t\t\t\tif (i >> k & 1)continue;\n\t\t\t\tint c = abs(a[j] - b[k]);\n\t\t\t\tdp[i | 1 << k][j + 1] = max(dp[i | 1 << k][j + 1], dp[i][j] + c*(c - 30)*(c - 30));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", *max_element(dp[0], dp[1 << w]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define DPSIZE (1<<12)\n\nint M, W;\nint bm[12], bw[12];\nint dp[DPSIZE];\n\nint calcPower(int a, int b)\n{\n\tint num = a - b;\n\tif(num < 0) {\n\t\tnum *= -1;\n\t}\n\t\n\treturn num * (num - 30) * (num - 30);\n}\n\nint main()\n{\n\twhile(cin >> M >> W, M, W) {\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tcin >> bm[i];\n\t\t}\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tcin >> bw[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < DPSIZE; i++) {\n\t\t\tdp[i] = 0;\n\t\t}\n\t\t\n\t\tif(M < W) {\n\t\t\tswap(M, W);\n\t\t\tswap(bm, bw);\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < (1<<M)-1; i++) {\n\t\t\tif(i != 0 && dp[i] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tif(i & (1<<j)) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tif((i & (1<<j))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint next = (i | (1<<j));\n\t\t\t\tdp[next] = max(dp[next], dp[i] + ((cnt < W)? calcPower(bm[j], bw[cnt]): 0));\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << dp[(1<<M)-1] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint f(int a, int b){\n    return abs(a-b) * (abs(a-b)-30) * (abs(a-b)-30);\n}\n\nint main(){\n    int m, w;\n    while(cin >> m >> w, m+w){\n        int bm[m], bw[w];\n        for(int i = 0; i < m; i++)  cin >> bm[i];\n        for(int i = 0; i < w; i++)  cin >> bw[i];\n        vector<vector<int>> dp(m+1, vector<int>(1<<w, -1));\n        dp[0][0] = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < 1<<w; j++){\n                if(dp[i][j] < 0)    continue;\n                dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n                for(int k = 0; k < w; k++){\n                    if((j>>k)&1)  continue;\n                    dp[i+1][j|(1<<k)] = max(dp[i+1][j|(1<<k)], dp[i][j]+f(bm[i], bw[k]));\n                }\n            }\n        }\n        int ans = 0;\n        for(int j = 0; j < 1<<w; j++)   ans = max(ans, dp[m][j]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint m, w;\nint bm[22], bw[22];\nint memo[1<<12][1<<12];\n\nint e(int i, int j){\n\n  int p = abs(bm[i] - bw[j]);\n  return p * (p-30) * (p-30);\n\n}\n\nint solve(int bitm, int bitw){\n\n  if(~memo[bitm][bitw]) return memo[bitm][bitw];\n  \n  int ret = 0;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<w;j++){\n      if(!(bitm & (1<<i)) && !(bitw & (1<<j))){\n\tret = max(ret, solve((bitm | (1<<i)), (bitw | (1<<j))) + e(i, j));\n      }\n    } \n  }\n\n  return memo[bitm][bitw] = ret;\n  \n}\nint main(){\n\n  \n  while(cin >> m >> w){\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    \n    memset(memo, -1, sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint M, W;\nint bm[12], bw[12];\nint dp[15][(1 << 12)];\n\nint calcPower(int a, int b) {\n\tint num = ((a - b) >= 0) ? (a - b) : (b - a);\n\treturn num * (num - 30) * (num - 30);\n}\n\nint main() {\n\twhile (cin >> M >> W, M, W) {\n\t\t// input\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> bm[i];\n\t\t}\n\t\tfor (int i = 0; i < W; i++) {\n\t\t\tcin >> bw[i];\n\t\t}\n\n\t\tif (M > W) {\n\t\t\tswap(M, W);\n\t\t\tswap(bm, bw);\n\t\t}\n\n\t\t// initialize\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfor (int j = 0; j < (1 << W); j++) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < W; i++) {\n\t\t\tdp[0][(1 << i)] = calcPower(bm[0], bw[i]);\n\t\t}\n\n\t\t// solve\n\t\tfor (int i = 0; i < M - 1; i++) {\n\t\t\tfor (int j = 1; j < (1 << W); j++) {\n\t\t\t\tif (dp[i][j] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (int k = 0; k < W; k++) {\n\t\t\t\t\tif ((j & (1 << k))) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint next = ((j | (1 << k)));\n\t\t\t\t\tint cost = dp[i][j] + calcPower(bm[i + 1], bw[k]);\n\t\t\t\t\tdp[i + 1][next] = max(dp[i + 1][next], cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = -1;\n\t\tfor (int i = 0; i < (1 << W); i++) {\n\t\t\tans = max(ans, dp[M - 1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < 12; i++)check[i] = false;\n\t}\n\n\tshort table[6],index;\n\tbool check[12];\n};\n\nint table_2[2][2],table_3[6][3],table_4[24][4],table_5[120][5],table_6[720][6];\n\nvoid func(int M,int W){\n\tint m_data[M],w_data[W];\n\n\tfor(int i = 0; i < M; i++)scanf(\"%d\",&m_data[i]);\n\tfor(int i = 0; i < W; i++)scanf(\"%d\",&w_data[i]);\n\n\tint maximum = 0,tmp,select_num,num,left_index,right_index,left_tmp,right_tmp,left_max,right_max,limit,loc_left[7],loc_right[7],index,val,calc[7];\n\n\tif(M == 1){\n\t\tfor(int i = 0; i < W; i++){\n\t\t\ttmp = abs(w_data[i] - m_data[0])*(abs(w_data[i] - m_data[0])-30)*(abs(w_data[i] - m_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else if(W == 1){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\ttmp = abs(m_data[i] - w_data[0])*(abs(m_data[i] - w_data[0])-30)*(abs(m_data[i] - w_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else{\n\t\tif(M > W){\n\t\t\tselect_num = (M+1)/2;\n\n\t\t\tlimit = pow(2,M);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\t//??°???????????????????????????\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tif(left_index == 1){\n\t\t\t\t\tval = abs(w_data[0] - m_data[loc_left[0]]);\n\t\t\t\t\tleft_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t}else if(left_index == 2){\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_2[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 3){\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_3[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 4){\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],calc[3] = m_data[loc_left[3]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_4[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 5){\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],calc[3] = m_data[loc_left[3]],calc[4] = m_data[loc_left[4]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_5[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //left_index == 6\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],\n\t\t\t\t\t\t\t\tcalc[3] = m_data[loc_left[3]],calc[4] = m_data[loc_left[4]],calc[5] = m_data[loc_left[5]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_6[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(right_index == 1){\n\t\t\t\t\tval = abs(w_data[W-1] - m_data[loc_right[0]]);\n\t\t\t\t\tright_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t}else if(right_index == 2){\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_2[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 3){\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_3[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 4){\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],calc[3] = m_data[loc_right[3]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_4[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 5){\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],calc[3] = m_data[loc_right[3]],calc[4] = m_data[loc_right[4]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_5[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //right_index == 6\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],\n\t\t\t\t\t\t\t\tcalc[3] = m_data[loc_right[3]],calc[4] = m_data[loc_right[4]],calc[5] = m_data[loc_right[5]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_6[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\n\t\t}else{ //W >= M\n\t\t\tselect_num = (W+1)/2;\n\n\t\t\tlimit = pow(2,W);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tif(left_index == 1){\n\t\t\t\t\tval = abs(m_data[0] - w_data[loc_left[0]]);\n\t\t\t\t\tleft_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t}else if(left_index == 2){\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_2[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 3){\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_3[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 4){\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],calc[3] = w_data[loc_left[3]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_4[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 5){\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],calc[3] = w_data[loc_left[3]],calc[4] = w_data[loc_left[4]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_5[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //left_index == 6\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],\n\t\t\t\t\t\t\t\tcalc[3] = w_data[loc_left[3]],calc[4] = w_data[loc_left[4]],calc[5] = w_data[loc_left[5]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_6[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(right_index == 1){\n\t\t\t\t\tval = abs(m_data[M-1] - w_data[loc_right[0]]);\n\t\t\t\t\tright_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t}else if(right_index == 2){\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_2[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 3){\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_3[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 4){\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],calc[3] = w_data[loc_right[3]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_4[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 5){\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],calc[3] = w_data[loc_right[3]],calc[4] = w_data[loc_right[4]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_5[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //right_index == 6\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],\n\t\t\t\t\t\t\t\tcalc[3] = w_data[loc_right[3]],calc[4] = w_data[loc_right[4]],calc[5] = w_data[loc_right[5]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_6[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\tint M,W,index_2 = 0,index_3 = 0,index_4 = 0, index_5 = 0,index_6 = 0;\n\n\tfor(int a = 0; a < 6; a ++){\n\t\tfor(int b = 0; b < 6; b++){\n\t\t\tif(a < 2 && b < 2){\n\t\t\t\tif(a != b){\n\t\t\t\t\ttable_2[index_2][0] = a,table_2[index_2][1] = b;\n\t\t\t\t\tindex_2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int c = 0; c < 6; c++){\n\t\t\t\tif(a < 3 && b < 3 && c < 3){\n\t\t\t\t\tif(a != b && a != c && b != c){\n\t\t\t\t\t\ttable_3[index_3][0] = a,table_3[index_3][1] = b,table_3[index_3][2] = c;\n\t\t\t\t\t\tindex_3++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int d = 0; d < 6; d++){\n\t\t\t\t\tif(a < 4 && b < 4 && c < 4 && d < 4){\n\t\t\t\t\t\tif(a != b && a != c && a != d && b != c && b != d && c != d){\n\t\t\t\t\t\t\ttable_4[index_4][0] = a,table_4[index_4][1] = b,table_4[index_4][2] = c,table_4[index_4][3] = d;\n\t\t\t\t\t\t\tindex_4++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int e = 0; e < 6; e++){\n\t\t\t\t\t\tif(a < 5 && b < 5 && c < 5 && d < 5 && e < 5){\n\t\t\t\t\t\t\tif(a != b && a != c && a != d && a != e && b != c && b != d && b != e && c != d && c != e && d != e){\n\t\t\t\t\t\t\t\ttable_5[index_5][0] = a,table_5[index_5][1] = b,table_5[index_5][2] = c,table_5[index_5][3] = d,table_5[index_5][4] = e;\n\t\t\t\t\t\t\t\tindex_5++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int f = 0; f < 6; f++){\n\t\t\t\t\t\t\tif(a != b && a != c && a != d && a != e && a != f && b != c && b != d && b != e && b != f && c != d && c != e && c != f && d != e && d != f && e != f){\n\t\t\t\t\t\t\t\ttable_6[index_6][0] = a,table_6[index_6][1] = b,table_6[index_6][2] = c,table_6[index_6][3] = d,table_6[index_6][4] = e,table_6[index_6][5] = f;\n\t\t\t\t\t\t\t\tindex_6++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&M,&W);\n\t\tif(M == 0 && W == 0)break;\n\n\t\tfunc(M,W);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, s, e) for(int i = (int)s; i < (int) e; i++)\n#define rep(i, n) REP(i, 0 ,n)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp nake_pair\n\ntypedef long long ll;\n\nll d[(1<<13)+10];\n\nint main(){\n    int m, w;\n    while(~scanf(\"%d%d\", &m, &w)){\n        vector<int> a(m), b(w);\n        rep(i, m) scanf(\"%d\", &a[i]);\n        rep(i, w) scanf(\"%d\", &b[i]);\n        rep(i, (1<<13)+10) d[i] = 0LL;\n        ll ans = 0LL;\n        rep(i, m){\n            rep(j, w){\n                rep(mask, 1<<w){\n                    if((mask&(1<<j))!=0) continue;\n                    int nxt = mask | (1<<j);\n                    ll c = abs(a[i]-b[j]);\n                    d[nxt] = max(d[nxt], d[mask] + c*(c-30)*(c-30));\n                    if(i == m -1) ans = max(d[nxt], ans);\n                }\n            }\n        }\n        //int goal = (1<<w)-1;\n        printf(\"%lld\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[13][1<<12];\nint main(){\n  int m,w,bm[12],bw[12];\n  while(1){ \n    cin>>m>>w;\n    if(m==0)break;\n    int ans=0;\n    for(int j=0;j<12;j++)\n      for(int i=0;i<(1<<w);i++)dp[j][i]=0;\n    for(int i=0;i<m;i++)cin>>bm[i];\n    for(int i=0;i<w;i++)cin>>bw[i];\n\n    for(int i=0;i<m;i++){  \n      for(int S=0;S<(1<<w);S++){ \n\tif(i < __builtin_popcount(S))continue;\n\tfor(int l=0;l<w;l++){\n\t  if((S&(1<<l))!=0)continue;\n\t  int t=abs(bm[i]-bw[l])*(abs(bm[i]-bw[l])-30)*(abs(bm[i]-bw[l])-30);\n\t  dp[i+1][S+(1<<l)]=max(dp[i+1][S+(1<<l)],dp[i][S]+t);\n\t  ans=max(ans,dp[i+1][S+(1<<l)]);\n\t}  \n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint m, w;\nint bm[22], bw[22];\nint memo[22][1<<13];\n\nint e(int i, int j){\n\n  int p = abs(bm[i] - bw[j]);\n  return p * (p-30) * (p-30);\n\n}\n\nint solve(int cntm, int bitw){\n\n  if(~memo[cntm][bitw]) return memo[cntm][bitw];\n  if(cntm == m) return 0;\n  \n  int ret = 0;\n  for(int i=0;i<w;i++)\n    if(!(bitw & (1<<i)))\n      ret = max(ret, solve(cntm+1, (bitw | (1<<i))) + e(cntm, i));\n\n  return memo[cntm][bitw] = ret;\n  \n}\n\nint main(){\n\n  while(cin >> m >> w){\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    \n    memset(memo, -1, sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nusing namespace std;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true){\n\t\tint m,w; cin >> m >> w;\n\t\tif(m == 0) break;\n\n\t\tint bm[m],bw[w];\n\t\tfor (int i = 0;i < m;i++){\n\t\t\tcin >> bm[i];\n\t\t}\n\t\tfor (int i = 0;i < w;i++){\n\t\t\tcin >> bw[i];\n\t\t}\n\n\t\tint dp[w+1][1<<m];\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][0] = 0;\n\n\t\tfor (int i = 0;i < w;i++){\n\t\t\tfor (int j = 0;j < (1<<m);j++){\n\t\t\t\tif(dp[i][j] == -1) continue;\n\t\t\t\tdp[i+1][j] = max(dp[i][j],dp[i+1][j]);\n\t\t\t\tfor (int k = 0;k < m;k++){\n\t\t\t\t\tif(j & (1<<k)) continue;\n\t\t\t\t\tint e = abs(bm[k]-bw[i]);\n\t\t\t\t\te = e*e*e - 60*e*e + 900*e;\n\t\t\t\t\tint ni = i+1;\n\t\t\t\t\tint nj = (j | (1<<k));\n\t\t\t\t\tdp[ni][nj] = max(dp[ni][nj],dp[i][j]+e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\tfor (int i = 0;i < (1<<m);i++){\n\t\t\tans = max(ans,dp[w][i]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[1<<12];\nint n,m;\nint a[12],b[12];\nint f(int A,int B)\n{\n\tint s=abs(A-B);\n\treturn s*(s-30)*(s-30);\n}\nmain()\n{\n\twhile(cin>>n>>m,n)\n\t{\n\t\tif(n>=m)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)cin>>a[i];\n\t\t\tfor(int j=0;j<m;j++)cin>>b[j];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)cin>>b[i];\n\t\t\tfor(int j=0;j<m;j++)cin>>a[j];\n\t\t\tswap(n,m);\n\t\t}\n\t\tfor(int i=0;i<1<<n;i++)dp[i]=0;\n\t\tint ans=0;\n\t\tfor(int i=1;i<1<<n;i++)\n\t\t{\n\t\t\tint t=__builtin_popcount(i)-1;\n\t\t\tif(t>=m)continue;\n\t\t\tint now=0;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(i&1<<j)\n\t\t\t\t{\n\t\t\t\t\tnow=max(now,dp[i&~(1<<j)]+f(a[j],b[t]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=max(ans,dp[i]=now);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n#define SQR(x) ((x)*(x))\nint main(){\n  int N, W, bm[12], bw[12];\n  int *m, *w;\n\n  while(cin >> N >> W, N){\n    for(int i = 0; i < N; i++){\n      cin >> bm[i];\n    }\n    for(int i = 0; i < W; i++){\n      cin >> bw[i];\n    }\n\n    if(N < W){\n      swap( N, W);\n      m = bw, w = bm;\n    } else {\n      m = bm, w = bw;\n    }\n\n    vector< int > dp( 1 << W, -1);\n    dp[0] = 0;\n    for(int i = 0; i < N; i++){\n      for(int j = (1 << W) - 1; j >= 0; j--){\n        if(dp[j] == -1) continue;\n        for(int k = 0; k < W; k++){\n          if((j >> k) & 1) continue;\n          dp[j|(1 << k)] = max( dp[j|(1 << k)], dp[j] + abs(m[i] - w[k]) * SQR(abs(m[i] - w[k]) - 30));\n        }\n      }\n    }\n    cout << *max_element( dp.begin(), dp.end()) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint m, w;\ndouble bm[22], bw[22];\ndouble memo[1<<12][1<<12];\n\ndouble e(int i, int j){\n\n  double p = abs(bm[i] - bw[j]);\n  return p * (p-30) * (p-30);\n\n}\n\ndouble solve(int bitm, int bitw){\n\n  if(memo[bitm][bitw]) return memo[bitm][bitw];\n  \n  double ret = 0;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<w;j++){\n      if(!(bitm & (1<<i)) && !(bitw & (1<<j))){\n\tret = max(ret, solve((bitm | (1<<i)), (bitw | (1<<j))) + e(i, j));\n      }\n    } \n  }\n\n  return memo[bitm][bitw] = ret;\n  \n}\nint main(){\n\n  \n  while(cin >> m >> w){\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    \n    memset(memo, 0, sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long bitDP(bitset<13> b,long long now);\nlong long ene(long long a,long long b);\nlong long m,w;\nlong long mem[1<<12][13];\nlong long maxsb[20];\nlong long minsb[20];\nmain(){\n  while(1){\n    cin>>m>>w;\n    if(m==0&&w==0) break;\n    memset(mem,-1,sizeof(mem));\n    if(m<=w){\n      for(int i=0;i<m;i++){\n\tcin>>minsb[i];\n      }\n      for(int i=0;i<w;i++){\n\tcin>>maxsb[i];\n      }\n    }\n    else{\n      for(int i=0;i<m;i++){\n\tcin>>maxsb[i];\n      }\n      for(int i=0;i<w;i++){\n\tcin>>minsb[i];\n      }\n    }\n    cout<<bitDP(0,0)<<endl;\n  }\n}\nlong long bitDP(bitset<13> b,long long now){\n  if(now>=min(m,w)){\n    return 0;\n  }\n  else if(mem[b.to_ulong()][now]!=-1) return mem[b.to_ulong()][now];\n  long long ret=-10000000;\n  bitset<13> bb(1);\n  for(int i=0;i<max(m,w);i++){\n    if((b&bb)==0){\n      ret=max(ret,bitDP(b|bb,now+1)+ene(minsb[now],maxsb[i]));\n    }\n    bb=bb<<1;\n  }\n  return mem[b.to_ulong()][now]=ret;\n}\nlong long ene(long long a,long long b){\n  return llabs(a-b)*(llabs(a-b)-30)*(llabs(a-b)-30);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint bm[12],bw[12];\nint dp[1<<12][12];\nint n,m;\nint f(int a,int b){\n    return abs(a-b) * (abs(a-b)-30)*(abs(a-b)-30);\n}\nint dfs(int x,int bit){\n    if( x == n ) return 0;\n    if( dp[bit][x] != -1 ) return dp[bit][x];\n\n    int ans = dfs(x+1,bit);\n    for(int i = 0 ; i < m ; i++){\n        if( bit >> i & 1 ){\n            ans = max(ans,dfs(x+1,bit^(1<<i)) + f(bm[x],bw[i]));\n        }\n    }\n    return dp[bit][x] = ans;\n}\nint main(){\n\n    while(cin >> n >> m && n){\n        for(int i = 0 ; i < n ; i++) cin >> bm[i];\n        for(int i = 0 ; i < m ; i++) cin >> bw[i];\n        memset(dp,-1,sizeof(dp));\n        cout << dfs(0,(1<<m)-1) << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint m, w;\nint bm[22], bw[22];\nint memo[22][1<<13];\n\nint e(int i, int j){\n\n  int p = abs(bm[i] - bw[j]);\n  return p * (p-30) * (p-30);\n\n}\n\nint solve(int cntm, int bitw){\n\n  if(~memo[cntm][bitw]) return memo[cntm][bitw];\n  if(cntm == m) return 0;\n  \n  int ret = 0;\n  for(int i=0;i<w;i++)\n    if(!(bitw & (1<<i)))\n      ret = max(ret, solve(cntm+1, (bitw | (1<<i))) + e(cntm, i));\n\n  ret = max(ret, solve(cntm+1, bitw));\n  \n  return memo[cntm][bitw] = ret;\n  \n}\n\nint main(){\n\n  while(cin >> m >> w){\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    \n    memset(memo, -1, sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < 12; i++)check[i] = false;\n\t}\n\n\tshort table[6],index;\n\tbool check[12];\n};\n\nint table_2[2][2],table_3[6][3],table_4[24][4],table_5[120][5],table_6[720][6];\n\nvoid func(int M,int W){\n\tint m_data[M],w_data[W];\n\n\tfor(int i = 0; i < M; i++)scanf(\"%d\",&m_data[i]);\n\tfor(int i = 0; i < W; i++)scanf(\"%d\",&w_data[i]);\n\n\tint maximum = 0,tmp,select_num,num,left_index,right_index,left_tmp,right_tmp,left_max,right_max,limit,loc_left[7],loc_right[7],index,val,calc[7];\n\n\tif(M == 1){\n\t\tfor(int i = 0; i < W; i++){\n\t\t\ttmp = abs(w_data[i] - m_data[0])*(abs(w_data[i] - m_data[0])-30)*(abs(w_data[i] - m_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else if(W == 1){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\ttmp = abs(m_data[i] - w_data[0])*(abs(m_data[i] - w_data[0])-30)*(abs(m_data[i] - w_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else{\n\t\tif(M > W){\n\t\t\tselect_num = (M+1)/2;\n\n\t\t\tlimit = pow(2,M);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\t//??°???????????????????????????\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tif(left_index == 1){\n\t\t\t\t\tval = abs(w_data[0] - m_data[loc_left[0]]);\n\t\t\t\t\tleft_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t}else if(left_index == 2){\n\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]];\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_2[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 3){\n\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]];\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_3[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 4){\n\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],calc[3] = m_data[loc_left[3]];\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_4[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 5){\n\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],calc[3] = m_data[loc_left[3]],calc[4] = m_data[loc_left[4]];\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_5[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //left_index == 6\n\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],\n\t\t\t\t\t\t\t\t\t\t\t\t\tcalc[3] = m_data[loc_left[3]],calc[4] = m_data[loc_left[4]],calc[5] = m_data[loc_left[5]];\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_6[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(right_index == 1){\n\t\t\t\t\tval = abs(w_data[W-1] - m_data[loc_right[0]]);\n\t\t\t\t\tright_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t}else if(right_index == 2){\n\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]];\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_2[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 3){\n\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]];\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_3[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 4){\n\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],calc[3] = m_data[loc_right[3]];\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_4[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 5){\n\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],calc[3] = m_data[loc_right[3]],calc[4] = m_data[loc_right[4]];\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_5[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //right_index == 6\n\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],\n\t\t\t\t\t\t\t\t\t\t\t\t\tcalc[3] = m_data[loc_right[3]],calc[4] = m_data[loc_right[4]],calc[5] = m_data[loc_right[5]];\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_6[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\n\t\t}else{ //W >= M\n\t\t\tselect_num = (W+1)/2;\n\n\t\t\tlimit = pow(2,W);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tif(left_index == 1){\n\t\t\t\t\tval = abs(m_data[0] - w_data[loc_left[0]]);\n\t\t\t\t\tleft_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t}else if(left_index == 2){\n\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]];\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_2[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 3){\n\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]];\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_3[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 4){\n\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],calc[3] = w_data[loc_left[3]];\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_4[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 5){\n\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],calc[3] = w_data[loc_left[3]],calc[4] = w_data[loc_left[4]];\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_5[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //left_index == 6\n\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],\n\t\t\t\t\t\t\t\t\t\t\t\t\tcalc[3] = w_data[loc_left[3]],calc[4] = w_data[loc_left[4]],calc[5] = w_data[loc_left[5]];\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_6[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(right_index == 1){\n\t\t\t\t\tval = abs(m_data[M-1] - w_data[loc_right[0]]);\n\t\t\t\t\tright_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t}else if(right_index == 2){\n\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]];\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_2[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 3){\n\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]];\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_3[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 4){\n\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],calc[3] = w_data[loc_right[3]];\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_4[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 5){\n\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],calc[3] = w_data[loc_right[3]],calc[4] = w_data[loc_right[4]];\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_5[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //right_index == 6\n\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],\n\t\t\t\t\t\t\t\t\t\t\t\t\tcalc[3] = w_data[loc_right[3]],calc[4] = w_data[loc_right[4]],calc[5] = w_data[loc_right[5]];\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_6[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\tint M,W,index_2 = 0,index_3 = 0,index_4 = 0, index_5 = 0,index_6 = 0;\n\n\tfor(int a = 0; a < 2; a++){\n\t\tfor(int b = 0; b < 2; b++){\n\t\t\tif(a != b){\n\t\t\t\ttable_2[index_2][0] = a,table_2[index_2][1] = b;\n\t\t\t\tindex_2++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < 3; a++){\n\t\tfor(int b = 0; b < 3; b++){\n\t\t\tfor(int c = 0; c < 3; c++){\n\t\t\t\tif(a != b && a != c && b != c){\n\t\t\t\t\ttable_3[index_3][0] = a,table_3[index_3][1] = b,table_3[index_3][2] = c;\n\t\t\t\t\tindex_3++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < 4; a++){\n\t\tfor(int b = 0; b < 4; b++){\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tif(a != b && a != c && a != d && b != c && b != d && c != d){\n\t\t\t\t\t\ttable_4[index_4][0] = a,table_4[index_4][1] = b,table_4[index_4][2] = c,table_4[index_4][3] = d;\n\t\t\t\t\t\tindex_4++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < 5; a++){\n\t\tfor(int b = 0; b < 5; b++){\n\t\t\tfor(int c = 0; c < 5; c++){\n\t\t\t\tfor(int d = 0; d < 5; d++){\n\t\t\t\t\tfor(int e = 0; e < 5; e++){\n\t\t\t\t\t\tif(a != b && a != c && a != d && a != e && b != c && b != d && b != e && c != d && c != e && d != e){\n\t\t\t\t\t\t\ttable_5[index_5][0] = a,table_5[index_5][1] = b,table_5[index_5][2] = c,table_5[index_5][3] = d,table_5[index_5][4] = e;\n\t\t\t\t\t\t\tindex_5++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < 6; a ++){\n\t\tfor(int b = 0; b < 6; b++){\n\t\t\tfor(int c = 0; c < 6; c++){\n\t\t\t\tfor(int d = 0; d < 6; d++){\n\t\t\t\t\tfor(int e = 0; e < 6; e++){\n\t\t\t\t\t\tfor(int f = 0; f < 6; f++){\n\t\t\t\t\t\t\tif(a != b && a != c && a != d && a != e && a != f && b != c && b != d && b != e && b != f && c != d && c != e && c != f && d != e && d != f && e != f){\n\t\t\t\t\t\t\t\ttable_6[index_6][0] = a,table_6[index_6][1] = b,table_6[index_6][2] = c,table_6[index_6][3] = d,table_6[index_6][4] = e,table_6[index_6][5] = f;\n\t\t\t\t\t\t\t\tindex_6++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&M,&W);\n\t\tif(M == 0 && W == 0)break;\n\n\t\tfunc(M,W);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nint m,w;\nint bm[13],bw[13];\nint dp[13][1<<13];\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&m,&w);\n\t\tif(m==0)break;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<m;i++)scanf(\"%d\",&bm[i]);\n\t\tfor(int i=0;i<w;i++)scanf(\"%d\",&bw[i]);\n\t\tdp[0][0]=0;\n\t\tint res=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<(1<<w);j++){\n\t\t\t\tif(dp[i][j]!=-1){\n\t\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\t\tres=max(res,dp[i][j]);\n\t\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\t\tif(!((j>>k) & 1)){\n\t\t\t\t\t\t\tint nj=j|1<<k;\n\t\t\t\t\t\t\tif(nj>=(1<<w))printf(\"error\\n\");\n\t\t\t\t\t\t\tint z=abs(bm[i]-bw[k]);\n\t\t\t\t\t\t\tint e=z*(z-30)*(z-30);\n\t\t\t\t\t\t\tdp[i+1][nj]=max(dp[i+1][nj],dp[i][j]+e);\n\t\t\t\t\t\t\tres=max(dp[i+1][nj],res);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nstruct Edge{\n  int to,cap,cost,rev;\n  Edge(int to=0,int cap=0,int cost=0,int rev=0):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nconst int MAX_V = 1100, IINF = INT_MAX;\nint V;\nvector<Edge> G[MAX_V];\nint h[MAX_V],dist[MAX_V],prevv[MAX_V],preve[MAX_V];\n\ninline void add_edge(int from,int to,int cap,int cost){\n  G[from].push_back(Edge(to,cap,cost,G[to].size()));\n  G[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t){\n  int res = 0;\n  fill(h,h+V,0);\n  while(1){\n    priority_queue<ii,vector<ii>,greater<ii> > Q;\n    fill(dist,dist+V,IINF);\n    dist[s] = 0;\n    Q.push(ii(0,s));\n    while(!Q.empty()){\n      ii p = Q.top(); Q.pop();\n      int v = p.second;\n      if( dist[v] < p.first ) continue;\n      for(int i=0;i<G[v].size();i++){\n        Edge &e = G[v][i];\n        if( e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to] ) { \n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          Q.push(ii(dist[e.to],e.to));\n        }\n      }\n    }\n    rep(v,V) h[v] += dist[v];\n    if( h[t] >= 0 ) break;\n    int d = IINF;\n    for(int v=t;v!=s;v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n    res += d * h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      Edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\n\nstruct Data { int bitmask,cost; };\nint n[2],arr[2][20];\n#define pow2(a) ((a)*(a))\n\nint main(){\n  while( cin >> n[0] >> n[1], n[0]|n[1] ){\n    rep(i,2) rep(j,n[i]) cin >> arr[i][j];\n    int source = n[0] + n[1];\n    int sink   = source + 1;\n    V = sink+1;\n    rep(i,V) G[i].clear();\n    rep(i,n[0]) add_edge(source,i,1,0);\n    rep(i,n[1]) add_edge(n[0]+i,sink,1,0);\n    rep(i,n[0]) rep(j,n[1]) {\n      int s = i, t = n[0] + j;\n      int const_v = abs(arr[0][i]-arr[1][j]);\n      add_edge(s,t,1,-const_v*pow2(const_v-30));\n    }\n    cout << -min_cost_flow(source,sink) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint dp[13][1 << 12], bm[13], bw[13];\nint M, W;\n \nsigned main() {\n    while(cin >> M >> W, M || W) {\n        for(int i=0; i<M; i++) {\n            cin >> bm[i];\n        }\n        for(int i=0; i<W; i++) {\n            cin >> bw[i];\n        }\n\n        fill(dp[0], dp[W+1], -1);\n        dp[0][0] = 0;\n        for(int i=0; i<W; i++) {\n            for(int bit=0; bit<(1<<M); bit++) {\n                if(dp[i][bit] < 0) continue;\n                chmax(dp[i+1][bit], dp[i][bit]);\n\n                for(int j=0; j<M; j++) {\n                    if(bit >> j & 1) continue;\n                    int nbit = bit | (1 << j);\n                    int diff = abs(bm[j] - bw[i]);\n                    int cost = diff * (diff - 30) * (diff - 30);\n\n                    chmax(dp[i+1][nbit], dp[i][bit] + cost);\n                }\n            }\n        }\n\n        cout << *max_element(dp[W], dp[W] + (1 << M)) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_V=100;\nconst int INF=1001001001;\nint S,T;\nstruct edge{\n    int to,cap,cost,rev;\n    edge(int to,int cap,int cost,int rev)\n        :to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge>G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill_n(dist,V,INF);\n        dist[s]=0;\n        bool update=true;\n        while(update){\n            update=false;\n            for(int v=0;v<V;v++){\n                if(dist[v]==INF)continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n                        dist[e.to]=dist[v]+e.cost;\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        update=true;\n                    }\n                }\n            }\n        }\n\n        if(dist[t]==INF)return INF;\n\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        res+=d*dist[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n\nvoid init(){\n    fill_n(G,MAX_V,vector<edge>());\n}\n\nint main(){\n    V=100;\n    int M,W;\n    while(scanf(\"%d%d\",&M,&W),M||W){\n        init();\n        vector<int>bm(M),bw(W);\n        for(int i=0;i<M;i++)scanf(\"%d\",&bm[i]);\n        for(int i=0;i<W;i++)scanf(\"%d\",&bw[i]);\n\n\n        S=98,T=99;\n        for(int i=0;i<M;i++){\n            for(int j=0;j<W;j++){\n                int ab=abs(bm[i]-bw[j]);\n                int val=ab*(ab-30)*(ab-30);\n                add_edge(i,M+j,1,-val);\n            }\n        }\n\n        for(int i=0;i<M;i++){\n            add_edge(S,i,1,0);\n        }\n        for(int i=0;i<W;i++){\n            add_edge(i+M,T,1,0);\n        }\n\n        cout<<-min_cost_flow(S,T,min(M,W))<<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, m, a[12], b[12], dp[1 << 12];\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tfor (int i = 0; i < n; i++) cin >> a[i];\n\t\tfor (int i = 0; i < m; i++) cin >> b[i];\n\t\tif (n < m) swap(n, m), swap(a, b);\n\t\tfill(dp, dp + (1 << n), 0);\n\t\tfor (int i = 1; i < (1 << n); i++) {\n\t\t\tint r = __builtin_popcount(i);\n\t\t\tif (r > m) continue;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i & (1 << j)) {\n\t\t\t\t\tint p = abs(a[j] - b[r - 1]);\n\t\t\t\t\tdp[i] = max(dp[i], dp[i - (1 << j)] + p * (p - 30) * (p - 30));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << *max_element(dp, dp + (1 << n)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define SIZE 26\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n\nint calc(int m,int w){\n  int ans = 0;\n  int bm[12],bw[12];\n  int dp[13][1<<12] = {0};\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%d\",bm+i);\n  }\n  \n  for(int i=0;i<w;i++){\n    scanf(\"%d\",bw+i);\n  }\n\n  for(int i=0;i<=w;i++){\n    for(int j=0;j<(1<<m);j++){\n      dp[i][j] = -INF;\n    }\n  }\n\n  dp[0][0] = 0;\n  \n  for(int i=0;i<w;i++){\n    for(int j=0;j<(1<<m);j++){\n      for(int k=0;k<m;k++){\n\tdp[i+1][j] = max(dp[i+1][j],dp[i][j]);\n\tif(j&(1<<k)) continue;\n\tint d = abs(bw[i]-bm[k]);\n\tint add = d * (d-30) * (d-30);\n\tdp[i+1][j+(1<<k)] = max(dp[i+1][j+(1<<k)],dp[i][j] + add);\n\tans = max(ans,dp[i+1][j+(1<<k)]);\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  int m,w;\n    \n  while(1){\n    scanf(\"%d%d\",&m,&w);\n    if(m==0) break;\n    \n    printf(\"%d\\n\",calc(m,w));\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < 12; i++)check[i] = false;\n\t}\n\n\tshort table[6],index;\n\tbool check[12];\n};\n\nvoid func(int M,int W){\n\tint m_data[M],w_data[W];\n\n\tfor(int i = 0; i < M; i++)scanf(\"%d\",&m_data[i]);\n\tfor(int i = 0; i < W; i++)scanf(\"%d\",&w_data[i]);\n\n\tint maximum = 0,tmp,select_num,num,left_index,right_index,left_tmp,right_tmp,left_max,right_max,limit,loc_left[7],loc_right[7],val;\n\n\tif(M == 1){\n\t\tfor(int i = 0; i < W; i++){\n\t\t\ttmp = abs(w_data[i] - m_data[0])*(abs(w_data[i] - m_data[0])-30)*(abs(w_data[i] - m_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else if(W == 1){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\ttmp = abs(m_data[i] - w_data[0])*(abs(m_data[i] - w_data[0])-30)*(abs(m_data[i] - w_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else{\n\t\tif(M > W){\n\t\t\tselect_num = (M+1)/2;\n\n\t\t\tlimit = pow(2,M);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\t//??°???????????????????????????\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tqueue<Info> Q;\n\t\t\t\tInfo current,left_first,right_first;\n\n\t\t\t\tfor(int k = 0; k < left_index;k++){\n\t\t\t\t\tleft_first.check[loc_left[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(left_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == left_index){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - current.table[p]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < left_index; p++){\n\t\t\t\t\t\tif(current.check[loc_left[p]]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < 12; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = m_data[loc_left[p]];\n\t\t\t\t\t\t\tnew_info.check[loc_left[p]] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int k = 0; k < right_index;k++){\n\t\t\t\t\tright_first.check[loc_right[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(right_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == right_index){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - current.table[p-((W+1)/2)]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < right_index; p++){\n\t\t\t\t\t\tif(current.check[loc_right[p]]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < 12; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = m_data[loc_right[p]];\n\t\t\t\t\t\t\tnew_info.check[loc_right[p]] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\n\t\t}else{ //W >= M\n\t\t\tselect_num = (W+1)/2;\n\n\t\t\tlimit = pow(2,W);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tqueue<Info> Q;\n\t\t\t\tInfo current,left_first,right_first;\n\n\t\t\t\tfor(int k = 0; k < left_index;k++){\n\t\t\t\t\tleft_first.check[loc_left[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(left_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == left_index){\n\t\t\t\t\t\tleft_tmp = 0;\n\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - current.table[p]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < left_index; p++){\n\t\t\t\t\t\tif(current.check[loc_left[p]] == true){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < W; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = w_data[loc_left[p]];\n\t\t\t\t\t\t\tnew_info.check[loc_left[p]] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int k = 0; k < right_index;k++){\n\t\t\t\t\tright_first.check[loc_right[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(right_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == right_index){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - current.table[p-((M+1)/2)]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < right_index; p++){\n\t\t\t\t\t\tif(current.check[loc_right[p]]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < W; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = w_data[loc_right[p]];\n\t\t\t\t\t\t\tnew_info.check[loc_right[p]] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\tint M,W;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&M,&W);\n\t\tif(M == 0 && W == 0)break;\n\n\t\tfunc(M,W);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX_V 100\n#define INF (1<<24)\n\nstruct edge { int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid init_edge(){\n  for(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<V;v++){\n        if(dist[v]==INF)continue;\n        for(int i=0;i< (int) G[v].size();i++){\n          edge &e = G[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n            dist[e.to] = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve [e.to] = i;\n            update = true;\n          }\n        }\n      }\n    }\n    if(dist[t]==INF)return -1;\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*dist[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++){\n    G[i].clear();\n  }\n}\n\nint main(){\n  int N,M;\n  int a[20],b[20];\n  while(1){\n    init();\n    scanf(\"%d %d\",&N,&M);\n    if(N==0&&M==0)break;\n    V=N+M+2;\n    for(int i=0;i<N;i++){\n      scanf(\"%d\",&a[i]);\n      add_edge(N+M,i,1,0);\n    }\n    for(int i=0;i<M;i++){\n      scanf(\"%d\",&b[i]);\n      add_edge(N+i,N+M+1,1,0);\n    }\n\n\n    for(int i=0;i<N;i++){\n      for(int j=0;j<M;j++){\n        int d=abs(a[i]-b[j])-30;\n        int k=abs(a[i]-b[j])*d*d;\n        add_edge(i,N+j,1,-k);\n      }\n    }\n    cout<< -min_cost_flow(N+M,N+M+1,min(N,M)) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define SIZE 26\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n\nint calc(int m,int w){\n  int ans = 0;\n  int bm[12],bw[12];\n  int dp[13][1<<12] = {0};\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%d\",bm+i);\n  }\n  \n  for(int i=0;i<w;i++){\n    scanf(\"%d\",bw+i);\n  }\n\n  for(int i=0;i<=w;i++){\n    for(int j=0;j<(1<<m);j++){\n      dp[i][j] = -INF;\n    }\n  }\n\n  dp[0][0] = 0;\n  \n  for(int i=0;i<w;i++){\n    for(int j=0;j<(1<<m);j++){\n      for(int k=0;k<m;k++){\n\tif(j&(1<<k)) continue;\n\tint d = abs(bw[i]-bm[k]);\n\tint add = d * (d-30) * (d-30);\n\tdp[i+1][j+(1<<k)] = max(dp[i+1][j|(1<<k)],dp[i][j] + add);\n\tans = max(ans,dp[i+1][j+(1<<k)]);\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  int m,w;\n    \n  while(1){\n    scanf(\"%d%d\",&m,&w);\n    if(m==0) break;\n    \n    printf(\"%d\\n\",calc(m,w));\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < 12; i++)check[i] = false;\n\t}\n\n\tshort table[6],index;\n\tbool check[12];\n};\n\nint table_2[2][2],table_3[6][3],table_4[24][4],table_5[120][5],table_6[720][6];\n\nvoid func(int M,int W){\n\tint m_data[M],w_data[W];\n\n\tfor(int i = 0; i < M; i++)scanf(\"%d\",&m_data[i]);\n\tfor(int i = 0; i < W; i++)scanf(\"%d\",&w_data[i]);\n\n\tint maximum = 0,tmp,select_num,num,left_index,right_index,left_tmp,right_tmp,left_max,right_max,limit,loc_left[7],loc_right[7],index,val,calc[7];\n\n\tif(M == 1){\n\t\tfor(int i = 0; i < W; i++){\n\t\t\ttmp = abs(w_data[i] - m_data[0])*(abs(w_data[i] - m_data[0])-30)*(abs(w_data[i] - m_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else if(W == 1){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\ttmp = abs(m_data[i] - w_data[0])*(abs(m_data[i] - w_data[0])-30)*(abs(m_data[i] - w_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else{\n\t\tif(M > W){\n\t\t\tselect_num = (M+1)/2;\n\n\t\t\tlimit = pow(2,M);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\t//??°???????????????????????????\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tif(left_index == 1){\n\t\t\t\t\tval = abs(w_data[0] - m_data[loc_left[0]]);\n\t\t\t\t\tleft_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t}else if(left_index == 2){\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_2[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 3){\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_3[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 4){\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],calc[3] = m_data[loc_left[3]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_4[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 5){\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],calc[3] = m_data[loc_left[3]],calc[4] = m_data[loc_left[4]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_5[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //left_index == 6\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],\n\t\t\t\t\t\t\t\tcalc[3] = m_data[loc_left[3]],calc[4] = m_data[loc_left[4]],calc[5] = m_data[loc_left[5]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_6[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(right_index == 1){\n\t\t\t\t\tval = abs(w_data[W-1] - m_data[loc_right[0]]);\n\t\t\t\t\tright_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t}else if(right_index == 2){\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_2[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 3){\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_3[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 4){\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],calc[3] = m_data[loc_right[3]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_4[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 5){\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],calc[3] = m_data[loc_right[3]],calc[4] = m_data[loc_right[4]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_5[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //right_index == 6\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],\n\t\t\t\t\t\t\t\tcalc[3] = m_data[loc_right[3]],calc[4] = m_data[loc_right[4]],calc[5] = m_data[loc_right[5]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_6[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\n\t\t}else{ //W >= M\n\t\t\tselect_num = (W+1)/2;\n\n\t\t\tlimit = pow(2,W);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tif(left_index == 1){\n\t\t\t\t\tval = abs(m_data[0] - w_data[loc_left[0]]);\n\t\t\t\t\tleft_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t}else if(left_index == 2){\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_2[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 3){\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_3[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 4){\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],calc[3] = w_data[loc_left[3]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_4[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 5){\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],calc[3] = w_data[loc_left[3]],calc[4] = w_data[loc_left[4]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_5[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //left_index == 6\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],\n\t\t\t\t\t\t\t\tcalc[3] = w_data[loc_left[3]],calc[4] = w_data[loc_left[4]],calc[5] = w_data[loc_left[5]];\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_6[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(right_index == 1){\n\t\t\t\t\tval = abs(m_data[M-1] - w_data[loc_right[0]]);\n\t\t\t\t\tright_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t}else if(right_index == 2){\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_2[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 3){\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_3[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 4){\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],calc[3] = w_data[loc_right[3]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_4[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 5){\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],calc[3] = w_data[loc_right[3]],calc[4] = w_data[loc_right[4]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_5[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //right_index == 6\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],\n\t\t\t\t\t\t\t\tcalc[3] = w_data[loc_right[3]],calc[4] = w_data[loc_right[4]],calc[5] = w_data[loc_right[5]];\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_6[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\tint M,W,index_2 = 0,index_3 = 0,index_4 = 0, index_5 = 0,index_6 = 0;\n\n\tfor(int a = 0; a < 6; a ++){\n\t\tfor(int b = 0; b < 6; b++){\n\t\t\tif(a < 2 && b < 2){\n\t\t\t\tif(a != b){\n\t\t\t\t\ttable_2[index_2][0] = a,table_2[index_2][1] = b;\n\t\t\t\t\tindex_2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int c = 0; c < 6; c++){\n\t\t\t\tif(a < 3 && b < 3 && c < 3){\n\t\t\t\t\tif(a != b && a != c && b != c){\n\t\t\t\t\t\ttable_3[index_3][0] = a,table_3[index_3][1] = b,table_3[index_3][2] = c;\n\t\t\t\t\t\tindex_3++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int d = 0; d < 6; d++){\n\t\t\t\t\tif(a < 4 && b < 4 && c < 4 && d < 4){\n\t\t\t\t\t\tif(a != b && a != c && a != d && b != c && b != d && c != d){\n\t\t\t\t\t\t\ttable_4[index_4][0] = a,table_4[index_4][1] = b,table_4[index_4][2] = c,table_4[index_4][3] = d;\n\t\t\t\t\t\t\tindex_4++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int e = 0; e < 6; e++){\n\t\t\t\t\t\tif(a < 5 && b < 5 && c < 5 && d < 5 && e < 5){\n\t\t\t\t\t\t\tif(a != b && a != c && a != d && a != e && b != c && b != d && b != e && c != d && c != e && d != e){\n\t\t\t\t\t\t\t\ttable_5[index_5][0] = a,table_5[index_5][1] = b,table_5[index_5][2] = c,table_5[index_5][3] = d,table_5[index_5][4] = e;\n\t\t\t\t\t\t\t\tindex_5++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int f = 0; f < 6; f++){\n\t\t\t\t\t\t\tif(a != b && a != c && a != d && a != e && a != f && b != c && b != d && b != e && b != f && c != d && c != e && c != f && d != e && d != f && e != f){\n\t\t\t\t\t\t\t\ttable_6[index_6][0] = a,table_6[index_6][1] = b,table_6[index_6][2] = c,table_6[index_6][3] = d,table_6[index_6][4] = e,table_6[index_6][5] = f;\n\t\t\t\t\t\t\t\tindex_6++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&M,&W);\n\t\tif(M == 0 && W == 0)break;\n\n\t\tfunc(M,W);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[13][1<<12];\nint main(){\n  int m,w,bm[12],bw[12];\n  while(1){ \n    cin>>m>>w;\n    if(m==0)break;\n    int ans=0;\n    for(int j=0;j<13;j++)\n      for(int i=0;i<(1<<w);i++)dp[j][i]=0;\n    for(int i=0;i<m;i++)cin>>bm[i];\n    for(int i=0;i<w;i++)cin>>bw[i];\n\n    for(int i=0;i<m;i++){  \n      for(int S=0;S<(1<<w);S++){ \n\tif(i < __builtin_popcount(S))continue;\n\tfor(int l=0;l<w;l++){\n\t  if((S&(1<<l))!=0)continue;\n\t  int t=abs(bm[i]-bw[l])*(abs(bm[i]-bw[l])-30)*(abs(bm[i]-bw[l])-30);\n\t  dp[i+1][S+(1<<l)]=max(dp[i+1][S+(1<<l)],dp[i][S]+t);\n\t  ans=max(ans,dp[i+1][S+(1<<l)]);\n\t}  \n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < 12; i++)check[i] = false;\n\t}\n\n\tshort table[6],index;\n\tbool check[12];\n};\n\nvoid func(int M,int W){\n\tint m_data[M],w_data[W];\n\n\tfor(int i = 0; i < M; i++)scanf(\"%d\",&m_data[i]);\n\tfor(int i = 0; i < W; i++)scanf(\"%d\",&w_data[i]);\n\n\tint maximum = 0,tmp,select_num,num,left_index,right_index,left_tmp,right_tmp,left_max,right_max,limit,loc_left[7],loc_right[7],val;\n\n\tif(M == 1){\n\t\tfor(int i = 0; i < W; i++){\n\t\t\ttmp = abs(w_data[i] - m_data[0])*(abs(w_data[i] - m_data[0])-30)*(abs(w_data[i] - m_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else if(W == 1){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\ttmp = abs(m_data[i] - w_data[0])*(abs(m_data[i] - w_data[0])-30)*(abs(m_data[i] - w_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else{\n\t\tif(M > W){\n\t\t\tselect_num = (M+1)/2;\n\n\t\t\tlimit = pow(2,M);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\t//??°???????????????????????????\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tqueue<Info> Q;\n\t\t\t\tInfo current,left_first,right_first;\n\n\t\t\t\tfor(int k = 0; k < left_index;k++){\n\t\t\t\t\tleft_first.check[loc_left[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(left_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == left_index){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - current.table[p]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < M; p++){\n\t\t\t\t\t\tif(current.check[p]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < M; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = m_data[p];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int k = 0; k < right_index;k++){\n\t\t\t\t\tright_first.check[loc_right[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(right_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == right_index){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - current.table[p-((W+1)/2)]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < M; p++){\n\t\t\t\t\t\tif(current.check[p]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < M; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = m_data[p];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\n\t\t}else{ //W >= M\n\t\t\tselect_num = (W+1)/2;\n\n\t\t\tlimit = pow(2,W);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tqueue<Info> Q;\n\t\t\t\tInfo current,left_first,right_first;\n\n\t\t\t\tfor(int k = 0; k < left_index;k++){\n\t\t\t\t\tleft_first.check[loc_left[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(left_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == left_index){\n\t\t\t\t\t\tleft_tmp = 0;\n\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - current.table[p]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < W; p++){\n\t\t\t\t\t\tif(current.check[p] == true){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < W; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = w_data[p];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int k = 0; k < right_index;k++){\n\t\t\t\t\tright_first.check[loc_right[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(right_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == right_index){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - current.table[p-((M+1)/2)]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < W; p++){\n\t\t\t\t\t\tif(current.check[p]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < W; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = w_data[p];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\tint M,W;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&M,&W);\n\t\tif(M == 0 && W == 0)break;\n\n\t\tfunc(M,W);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint a[12], b[12];\nint dp[13][1 << 12];\n\nint calc(int i, int j)\n{\n\tint d = abs(a[i] - b[j]);\n\treturn d * (d - 30) * (d - 30);\n}\n\nint dfs(int i, int bit)\n{\n\tif (i == n) return 0;\n\tif (~dp[i][bit]) return dp[i][bit];\n\tint res = dfs(i + 1, bit);\n\tfor (int j = 0; j < m; j++){\n\t\tif (bit & (1 << j)) continue;\n\t\tres = max(res, calc(i, j) + dfs(i + 1, bit | (1 << j)));\n\t}\n\treturn dp[i][bit] = res;\n}\n\nint main()\n{\n\twhile (cin >> n >> m, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tmemset(dp, -1, sizeof dp);\n\t\tcout << dfs(0, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint m, w;\nint bm[22], bw[22];\nint memo[1<<11][1<<11];\n\nint e(int i, int j){\n\n  int p = abs(bm[i] - bw[j]);\n  return p * (p-30) * (p-30);\n\n}\n\nint solve(int bitm, int bitw){\n\n  if(bitm < 1<<11 && bitw < 1<<11 && ~memo[bitm][bitw]) return memo[bitm][bitw];\n  \n  int ret = 0;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<w;j++){\n      if(!(bitm & (1<<i)) && !(bitw & (1<<j))){\n\tret = max(ret, solve((bitm | (1<<i)), (bitw | (1<<j))) + e(i, j));\n      }\n    } \n  }\n\n  return memo[bitm][bitw] = ret;\n  \n}\nint main(){\n\n  \n  while(cin >> m >> w){\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    \n    memset(memo, -1, sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint dp[13][1 << 12], a[12], b[12];\nint main() {\n\tint m, w;\n\twhile (scanf(\"%d%d\", &m, &w), m) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(i, m)scanf(\"%d\", &a[i]);\n\t\trep(i, w)scanf(\"%d\", &b[i]);\n\t\trep(i, m)rep(j, 1 << w)rep(k, w) {\n\t\t\tif (j >> k & 1)continue;\n\t\t\tint c = abs(a[i] - b[k]);\n\t\t\tdp[i + 1][j | 1 << k] = max(dp[i + 1][j | 1 << k], dp[i][j] + c*(c - 30)*(c - 30));\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp[0], dp[m + 1]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint dp[1 << 12][13], a[12], b[12];\nint main() {\n\tint m, w;\n\twhile (scanf(\"%d%d\", &m, &w), m) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(i, m)scanf(\"%d\", &a[i]);\n\t\trep(i, w)scanf(\"%d\", &b[i]);\n\t\trep(i, 1 << w)rep(j, m) {\n\t\t\trep(k, w) {\n\t\t\t\tif (i >> k & 1)continue;\n\t\t\t\tint c = abs(a[j] - b[k]);\n\t\t\t\tdp[i | 1 << k][j + 1] = max(dp[i | 1 << k][j + 1], dp[i][j] + c*(c - 30)*(c - 30));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp[0], dp[1 << w]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint m, w;\nint bm[20], bw[20];\nint dp[12][1 << 12];\n\nint cost(int bm, int bw) {\n    int diff = abs(bm -bw);\n    return diff * (diff - 30) * (diff - 30);\n}\n\nint solve(int cnt, int b) {\n\n    if(cnt >= m) {\n        return 0;\n    }\n\n    if(dp[cnt][b] != -1) {\n        return dp[cnt][b];\n    }\n\n    int ret = solve(cnt + 1, b);\n\n    for(int i = 0; i < w; ++i) {\n        if(!(b >> i & 1)) {\n            ret = max(ret, solve(cnt + 1, b | 1 << i) + cost(bm[cnt], bw[i]));\n        }\n    }\n\n    return dp[cnt][b] = ret;\n}\n\nint main() {\n\n    while(cin >> m >> w, m || w) {\n\n        for(int i = 0; i < m; ++i) {\n            cin >> bm[i];\n        }\n\n        for(int i = 0; i < w; ++i) {\n            cin >> bw[i];\n        }\n\n        memset(dp, -1, sizeof(dp));\n        cout << solve(0, 0) << endl;\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint m, w;\nint bm[12];\nint bw[12];\n\nint dp[13][1 << 12];\n\nint calc(int a, int b)\n{\n\treturn abs(a - b) * (abs(a - b) - 30) * (abs(a - b) - 30);\n}\n\nvoid solve()\n{\n\tmemset(dp, 0, sizeof(dp));\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tfor (int j = 0; j < (1 << w); j++){\n\t\t\tfor (int k = 0; k < w; k++){\n\t\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\n\t\t\t\tint x = 1 << k;\n\t\t\t\tif (j & x) continue;\n\t\t\t\t\n\t\t\t\tint &next = dp[i + 1][j | x];\n\t\t\t\tnext = max(next, dp[i][j] + calc(bm[i], bw[k]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < (1 << w); i++){\n\t\tres = max(res, dp[m][i]);\n\t}\n\tprintf(\"%d\\n\", res);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &m, &w), m){\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d\", &bm[i]);\n\t\t}\n\t\tfor (int i = 0; i < w; i++){\n\t\t\tscanf(\"%d\", &bw[i]);\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint M, W;\nint Bm[12], Bw[12];\nint DpElectrical[1 << 12];\n\n\nint calculation(int i, int j) {\n\tint num;\n\n\tnum = abs(Bm[i] - Bw[j]);\n\treturn num * pow(num - 30, 2);\n}\n\nvoid solve() {\n\n\tfill(DpElectrical, DpElectrical + (1 << W), -1);\n\tDpElectrical[0] = 0;\n\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = (1 << W) - 1; j >= 0; --j) {\n\t\t\tif (DpElectrical[j] == -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int k = 0; k < W; ++k) {\n\t\t\t\tif (((j >> k) & 1) == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tDpElectrical[j|(1 << k)] = max(DpElectrical[j|(1 << k)], DpElectrical[j] + calculation(i, k));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\n\twhile (cin >> M >> W, M) {\n\t\tmemset(Bm, 0, sizeof(Bm));\n\t\tmemset(Bw, 0, sizeof(Bw));\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tcin >> Bm[i];\n\t\t}\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tcin >> Bw[i];\n\t\t}\n\t\tsolve();\n\t\tcout<<*max_element(DpElectrical, DpElectrical + (1 << W))<< endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\n#include<cstdio>\nusing namespace std;\nint M, W;\nint BM[12], BW[12];\nint DP[13][1 << 12];\nint main()\n{\n\twhile (true){\n\t\tscanf(\"%d%d\", &M, &W);\n\t\tif (M == 0 && W == 0)break;\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tscanf(\"%d\", &BM[i]);\n\t\t}\n\t\tfor (int i = 0; i < W; i++){\n\t\t\tscanf(\"%d\", &BW[i]);\n\t\t}\n\t\tfor (int i = 0; i <= 12; i++)for (int j = 0; j < (1 << 12); j++)DP[i][j] = 0;\n\t\tfor (int i = 1; i <= M; i++){\n\t\t\tfor (int j = 0; j < (1 << W); j++){\n\t\t\t\tDP[i][j] = DP[i - 1][j];\n\t\t\t\tfor (int k = 0; k < W; k++){\n\t\t\t\t\tif ((j >> k) & 1){\n\t\t\t\t\t\tDP[i][j] = max(DP[i][j], DP[i - 1][j - (1 << k)] + abs(BM[i - 1] - BW[k])*(abs(BM[i - 1] - BW[k]) - 30)*(abs(BM[i - 1] - BW[k]) - 30));\n\t\t\t\t\t}\n\t\t\t\t\telse DP[i][j] = DP[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int j = 0; j < (1 << W); j++)ans = max(ans, DP[M][j]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate<typename T>\nT assignment(vector<vector<T>> &v){\n    int n = v.size(), m = v[0].size();\n    vector<T> pot(m), A(m);\n    vector<int> id(m), prv(m);\n    vector<int> l(n, -1), r(m, -1);\n    iota(id.begin(),id.end(), 0);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) A[j] = v[i][j] - pot[j], prv[j] = i;\n        int o = 0, j = 0;\n        T w = 0;\n        [&](){\n            int s = 0, t = 0;\n            while(true){\n                if(s == t){\n                    o = s;\n                    w = A[id[t++]];\n                    for (int k = t; k < m; ++k) {\n                        j = id[k];\n                        T h = A[j];\n                        if(h <= w){\n                            if(h < w) t = s, w = h;\n                            id[k] = id[t]; id[t++] = j;\n                        }\n                    }\n                    for (int k = s; k < t; ++k) {\n                        j = id[k];\n                        if(!~r[j]) return;\n                    }\n                }\n                int q = id[s++], x = r[q];\n                for (int k = t; k < m; ++k) {\n                    j = id[k];\n                    T h = v[x][j]-v[x][q]-(pot[j]-pot[q])+w;\n                    if(h < A[j]){\n                        A[j] = h; prv[j] = x;\n                        if(h == w){\n                            if(r[j] < 0) return;\n                            id[k] = id[t]; id[t++] = j;\n                        }\n                    }\n                }\n            }\n        }();\n        for (int k = 0; k < o; ++k) {\n            pot[id[k]] += A[id[k]]-w;\n        }\n        int x;\n        do {\n            r[j] = x = prv[j];\n            swap(j, l[x]);\n        } while(i != x);\n    }\n    T res = 0;\n    for (int i = 0; i < n; ++i) res += v[i][l[i]];\n    return res;\n}\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n){\n        vector<int> v(n), u(m);\n        for (auto &&i : v) scanf(\"%d\", &i);\n        for (auto &&j : u) scanf(\"%d\", &j);\n        if(n > m) swap(n, m), swap(v, u);\n        vector<vector<int>> A(n, vector<int>(m, 0));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                A[i][j] = -abs(v[i]-u[j])*(abs(v[i]-u[j])-30)*(abs(v[i]-u[j])-30);\n            }\n        }\n        cout << -assignment(A) << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nusing P = pair<int, int>;\n\nint M, W;\nvector<int> bm, bw;\n\nint dp[12][1<<12];\n\nint dfs(int m, int b) {\n  if ( m == M ) return 0;\n  if ( dp[m][b] >= 0 ) return dp[m][b];\n\n  int ret = dfs(m+1, b);  \n  for ( int i = 0; i < W; i++ ) {\n    if ( (1<<i)&b ) continue;\n    int add = abs(bm[m]-bw[i]) * pow(abs(bm[m]-bw[i])-30, 2);    \n    ret = max(ret, dfs(m+1, b|(1<<i))+add);    \n  }\n\n  return dp[m][b] = ret;  \n}\n\nsigned main() {\n  while ( cin >> M >> W, M ) {\n    fill_n(*dp, 12*(1<<12), -1);\n\n    bm = vector<int>(M);\n    bw = vector<int>(W);\n    \n    for ( int i = 0; i < M; i++ ) {\n      cin >> bm[i];\n    }\n    \n    for ( int i = 0; i < W; i++ ) {\n      cin >> bw[i];    \n    }\n\n    cout << dfs(0, 0) << endl;    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < 12; i++)check[i] = false;\n\t}\n\n\tshort table[6],index;\n\tbool check[12];\n};\n\nvoid func(int M,int W){\n\tint m_data[M],w_data[W];\n\n\tfor(int i = 0; i < M; i++)scanf(\"%d\",&m_data[i]);\n\tfor(int i = 0; i < W; i++)scanf(\"%d\",&w_data[i]);\n\n\tint maximum = 0,tmp,select_num,num,left_index,right_index,left_tmp,right_tmp,left_max,right_max,limit,loc_left[7],loc_right[7];\n\n\tif(M == 1){\n\t\tfor(int i = 0; i < W; i++){\n\t\t\ttmp = abs(w_data[i] - m_data[0])*(abs(w_data[i] - m_data[0])-30)*(abs(w_data[i] - m_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else if(W == 1){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\ttmp = abs(m_data[i] - w_data[0])*(abs(m_data[i] - w_data[0])-30)*(abs(m_data[i] - w_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else{\n\t\tif(M > W){\n\t\t\tselect_num = (M+1)/2;\n\n\t\t\tlimit = pow(2,M);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\t//??°???????????????????????????\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tqueue<Info> Q;\n\t\t\t\tInfo current,left_first,right_first;\n\n\t\t\t\tfor(int k = 0; k < left_index;k++){\n\t\t\t\t\tleft_first.check[loc_left[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(left_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == left_index){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tleft_tmp += abs(w_data[p] - current.table[p])*(abs(w_data[p] -current.table[p])-30)*(abs(w_data[p] -current.table[p])-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < 12; p++){\n\t\t\t\t\t\tif(current.check[p]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < 12; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = m_data[p];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int k = 0; k < right_index;k++){\n\t\t\t\t\tright_first.check[loc_right[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(right_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == right_index){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tright_tmp += abs(w_data[p] - current.table[p-((W+1)/2)])\n\t\t\t\t\t\t\t\t\t*(abs(w_data[p] -current.table[p-((W+1)/2)])-30)*(abs(w_data[p] -current.table[p-((W+1)/2)])-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < 12; p++){\n\t\t\t\t\t\tif(current.check[p]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < 12; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = m_data[p];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\n\t\t}else{ //W >= M\n\t\t\tselect_num = (W+1)/2;\n\n\t\t\tlimit = pow(2,W);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tqueue<Info> Q;\n\t\t\t\tInfo current,left_first,right_first;\n\n\t\t\t\tfor(int k = 0; k < left_index;k++){\n\t\t\t\t\tleft_first.check[loc_left[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(left_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == left_index){\n\t\t\t\t\t\tleft_tmp = 0;\n\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tleft_tmp += abs(m_data[p] - current.table[p])*(abs(m_data[p] -current.table[p])-30)*(abs(m_data[p] -current.table[p])-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < 12; p++){\n\t\t\t\t\t\tif(current.check[p] == true){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < 12; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = w_data[p];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int k = 0; k < right_index;k++){\n\t\t\t\t\tright_first.check[loc_right[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(right_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == right_index){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tright_tmp += abs(m_data[p] - current.table[p-((M+1)/2)])\n\t\t\t\t\t\t\t\t\t\t*(abs(m_data[p] -current.table[p-((M+1)/2)])-30)*(abs(m_data[p] -current.table[p-((M+1)/2)])-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < 12; p++){\n\t\t\t\t\t\tif(current.check[p]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < 12; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = w_data[p];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\tint M,W;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&M,&W);\n\t\tif(M == 0 && W == 0)break;\n\n\t\tfunc(M,W);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint dp[13][1 << 12], a[12], b[12];\nint main() {\n\tint m, w;\n\twhile (scanf(\"%d%d\", &m, &w), m) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(i, m)scanf(\"%d\", &a[i]);\n\t\trep(i, w)scanf(\"%d\", &b[i]);\n\t\trep(i, m)rep(j, 1 << w)rep(k, w) {\n\t\t\tif (j >> k & 1)continue;\n\t\t\tint c = abs(b[k] - a[i]);\n\t\t\tdp[i + 1][j | 1 << k] = max(dp[i + 1][j | 1 << k], dp[i][j] + c*(c - 30)*(c - 30));\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp[0], dp[m + 1]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, m, a[12], b[12], dp[1 << 12];\nint main() {\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\tfor(int i = 0; i < m; i++) cin >> b[i];\n\tif(n < m) swap(n, m), swap(a, b);\n\tfor(int i = 1; i < (1 << n); i++) {\n\t\tint r = __builtin_popcount(i);\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tif(i & (1 << j)) {\n\t\t\t\tint p = abs(a[j] - b[r - 1]);\n\t\t\t\tdp[i] = max(dp[i], dp[i - (1 << j)] + r * (r - 30) * (r - 30));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1 << n) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = std::int64_t;\nusing P = std::tuple<int,int>;\n\nint M, W;\nint A[15], B[15];\nint dp[12][1<<12];\n\nint f(int x, int y){\n    int diff = std::abs(x - y);\n\n    return diff * (diff - 30) * (diff - 30);\n}\n\nint rec(int idx, int s){\n    if(idx == M){\n        return 0;\n    }\n\n    if(dp[idx][s] != -1){\n        return dp[idx][s];\n    }\n\n    int mx = 0;\n\n    for(int i=0;i<W;++i){\n        if(s >> i & 1){\n            continue;\n        }\n\n        mx = std::max(mx, f(A[idx], B[i]) + rec(idx + 1, s | (1 << i)));\n    }\n\n    return dp[idx][s] = mx;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while(true){\n        std::cin >> M >> W;\n\n        if(M == 0){\n            break;\n        }\n\n        for(int i=0;i<M;++i){\n            std::cin >> A[i];\n        }\n\n        for(int i=0;i<W;++i){\n            std::cin >> B[i];\n        }\n\n        if(M > W){\n            std::swap(M, W);\n            std::swap(A, B);\n        }\n    \n        memset(dp, -1, sizeof(dp));\n\n        int mx = rec(0, 0);\n        std::cout << mx << std::endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint M,W;\nint bm[12],bw[12];\n\ninline int calc(int m, int w)\n{\n    int d=abs(bm[m]-bw[w]);\n    return d*(d-30)*(d-30);\n}\n\nint dp[13][4100];\nint dfs(int x, int mask)\n{\n    if(dp[x][mask]>=0) return dp[x][mask];\n    if(x==M || mask==(1<<W)-1) return 0;\n\n    int ret=dfs(x+1,mask);\n    rep(i,W)\n    {\n        if(mask>>i&1) continue;\n        ret=max(ret,dfs(x+1,mask+(1<<i))+calc(x,i));\n    }\n\n    return dp[x][mask]=ret;\n}\n\nint main()\n{\n    while(scanf(\" %d %d\", &M, &W),M)\n    {\n        rep(i,M) scanf(\" %d\", &bm[i]);\n        rep(i,W) scanf(\" %d\", &bw[i]);\n\n        memset(dp,-1,sizeof(dp));\n        printf(\"%d\\n\", dfs(0,0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint dp[1 << 12];\n\nsigned main(){\n\tint m,w;\n\twhile(cin >> m >> w,m){\n\t\tint a[12],b[12];\n\t\tfor(int i = 0;i < m;i++) cin >> a[i];\n\t\tfor(int i = 0;i < w;i++) cin >> b[i];\n\t\tif(m > w){\n\t\t\tfor(int i = 0;i < 12;i++) swap(a[i],b[i]);\n\t\t\tswap(m,w);\n\t\t}\n\t\tfor(int i = 0;i < (1 << w);i++) dp[i] = 0;\n\t\tfor(int i = 0;i < (1 << w);i++){\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0;j < w;j++) if(i >> j & 1) cnt++;\n\t\t\tif(cnt >= m) continue;\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(i >> j & 1) continue;\n\t\t\t\tdp[i | (1 << j)] = max(dp[i | (1 << j)],dp[i] + abs(a[cnt] - b[j]) * (abs(a[cnt] - b[j]) - 30) * (abs(a[cnt] - b[j]) - 30));\n\t\t\t}\n\t\t}\n\t\tint ma = 0;\n\t\tfor(int i = 0;i < (1 << w);i++) ma = max(ma,dp[i]);\n\t\tcout << ma << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, s, e) for(int i = (int)s; i < (int) e; i++)\n#define rep(i, n) REP(i, 0 ,n)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp nake_pair\n\ntypedef long long ll;\n\nll d[(1<<13)+10];\n\nint main(){\n    int m, w;\n    while(~scanf(\"%d%d\", &m, &w)){\n        if(m == 0 && w == 0) break;\n        vector<int> a(m), b(w);\n        rep(i, m) scanf(\"%d\", &a[i]);\n        rep(i, w) scanf(\"%d\", &b[i]);\n        if(m > w){\n            swap(a, b);\n            swap(m, w);\n        }\n        rep(i, (1<<13)+10) d[i] = 0LL;\n        ll ans = 0LL;\n        rep(mask, 1<<w){\n            int k = 0;\n            rep(j, w) if(mask & (1<<j)) k++;\n            rep(j, w) {\n                if(mask & (1<<j)) continue;\n                int nxt = mask | (1<<j);\n                ll c = abs(a[k]-b[j]);\n                d[nxt] = max(d[nxt], d[mask]+c*(c-30)*(c-30));\n                ans = max(ans, d[nxt]);\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <math.h>\nusing namespace std;\nint dp[(1<<13)+5][15];\nint main(){\n\tint m,w;\n\twhile(1){\n\t\tscanf(\"%d%d\",&m,&w);\n\t\tif(m+w == 0) return 0; int A[15],B[15];\n\t\tfor(int i=0;i<m;i++) scanf(\"%d\",&A[i]);\n\t\tfor(int i=0;i<w;i++) scanf(\"%d\",&B[i]);\n\t\tfor(int i=0;i<(1<<13)+5;i++) for(int j=0;j<15;j++) dp[i][j] = -100000000;\n\t\tdp[0][0] = 0;\n\t\tfor(int i=0;i<(1<<m);i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(dp[i][j] < 0) continue;\n\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\tdp[i][j+1] = max(dp[i][j+1],dp[i][j]);\n\t\t\t\t\tif(!((i>>k)&1)){\n\t\t\t\t\t\tint x = abs(B[j]-A[k]);\n\t\t\t\t\t\tdp[i + (1<<k)][j+1] = max(dp[i + (1<<k)][j+1] ,dp[i][j]+(x * (x-30) * (x-30)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i=0;i<(1<<13)+5;i++) for(int j=0;j<15;j++) res = max(res,dp[i][j]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint main(){\n  int m,w;\n  while(cin>>m>>w){\n    if(m==0)break;\n    int a,an=0,dp[1<<12]={};\n    vector<int>bm,bw;\n    for(int i=0;i<m;i++)cin>>a,bm.push_back(a);\n    for(int i=0;i<w;i++)cin>>a,bw.push_back(a);\n    if(m>w)swap(bm,bw),swap(m,w);\n    for(int i=0;i<m;i++)\n      for(int S=0;S<(1<<w);S++)\n\tif(__builtin_popcount(S)==i)\n\t  for(int j=0;j<w;j++){\n\t    if(!(S&(1<<j))){\n\t      int p=abs(bm[i]-bw[j]);\n\t      int e=p*(p-30)*(p-30);\n\t      dp[S+(1<<j)]=max(dp[S+(1<<j)],dp[S]+e);\n\t      an=max(an,dp[S+(1<<j)]);\n\t    }\n\t  }\n    cout<<an<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 13\n\nint M,W;\nint small,big,num_small,num_big;\nint POW[SIZE];\nint table[2][SIZE];\nint dp[SIZE][1 << SIZE];\n\nint calc(int a,int b){\n\n\treturn abs(a-b)*(abs(a-b)-30)*(abs(a-b)-30);\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < M; i++){\n\n\t\tscanf(\"%d\",&table[0][i]);\n\t}\n\tfor(int i = 0; i < W; i++){\n\n\t\tscanf(\"%d\",&table[1][i]);\n\t}\n\n\tsmall = 0;\n\tnum_small = M;\n\tbig = 1;\n\tnum_big = W;\n\n\tif(M > W){\n\n\t\tswap(small,big);\n\t\tswap(num_small,num_big);\n\t}\n\n\tfor(int i = 0; i <= num_small; i++){\n\t\tfor(int state = 0; state < POW[num_big]; state++){\n\t\t\tdp[i][state] = -BIG_NUM;\n\t\t}\n\t}\n\n\tdp[0][0] = 0;\n\n\tint ans = 0;\n\tint next_state,next_value;\n\n\tfor(int i = 0; i < num_small; i++){\n\t\tfor(int state = 0; state < POW[num_big]; state++){\n\t\t\tif(dp[i][state] == -BIG_NUM)continue;\n\n\t\t\tfor(int k = 0; k < num_big; k++){\n\t\t\t\tif(state & POW[k])continue;\n\n\t\t\t\tnext_state = state+POW[k];\n\t\t\t\tnext_value = dp[i][state]+calc(table[small][i],table[big][k]);\n\n\t\t\t\tans = max(ans,next_value);\n\t\t\t\tdp[i+1][next_state] = max(dp[i+1][next_state],next_value);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tPOW[0] = 1;\n\tfor(int i = 1; i < SIZE; i++){\n\n\t\tPOW[i] = POW[i-1]*2;\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&M,&W);\n\t\tif(M == 0 && W == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint M, W, bm[12], bw[12], dp[1 << 12];\nint popcount(int n) {\n\tint ret = 0;\n\tfor (int i = 0; i < 31; i++) {\n\t\tif (n & (1 << i)) ret++;\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (true) {\n\t\tscanf(\"%d%d\", &M, &W);\n\t\tif (M == 0 && W == 0) break;\n\t\tif (M < W) {\n\t\t\tswap(M, W);\n\t\t\tswap(bm, bw);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) scanf(\"%d\", &bm[i]);\n\t\tfor (int i = 0; i < W; i++) scanf(\"%d\", &bw[i]);\n\t\tfor (int i = 1; i < (1 << M); i++) {\n\t\t\tint times = popcount(i) - 1;\n\t\t\tif (times < W) {\n\t\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\t\tif (i & (1 << j)) {\n\t\t\t\t\t\tint m = bm[j];\n\t\t\t\t\t\tint w = bw[times];\n\t\t\t\t\t\tdp[i] = max(dp[i], dp[i - (1 << j)] + abs(m - w) * (abs(m - w) - 30) * (abs(m - w) - 30));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < (1 << M); i++) ret = max(ret, dp[i]);\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint M,W;\nint bm[15];\nint bw[15];\nint dp[15][1<<15];\nint en(int a,int b){\n\tint x=abs(a-b);\n\treturn x*(x-30)*(x-30);\n}\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d%d\",&M,&W);\n\t\tif(M==0&&W==0)break;\n\t\tfor(int i=0;i<M;i++)scanf(\"%d\",&bm[i]);\n\t\tfor(int i=0;i<W;i++)scanf(\"%d\",&bw[i]);\n\t\tfor(int i=0;i<15;i++){\n\t\t\tfor(int j=0;j<(1<<15);j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<W;j++){\n\t\t\tdp[0][1<<j]=en(bm[0],bw[j]);\n\t\t}\n\t\tfor(int i=1;i<M;i++){\n\t\t\tfor(int j=0;j<(1<<W);j++){\n\t\t\t\tdp[i][j]=max(dp[i][j],dp[i-1][j]);\n\t\t\t\tfor(int k=0;k<W;k++){\n\t\t\t\t\tif((j>>k)&1){\n\t\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i-1][j-(1<<k)]+en(bm[i],bw[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d:%d\\n\",i,j,dp[i][j]);\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<(1<<W);i++){\n\t\t\tans=max(ans,dp[M-1][i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef long long ll;\ntypedef long double ld;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n#define rrep(i,x) for(int i = x-1 ; i >= 0 ; i --)\n#define rrep1(i,x) for(int i = x ; i > 0 ; i --)\n#define fr first\n#define sc second\n#define pb push_back\n\nconst int INF = 1000000000;\n\nint cal(int bm,int bw){\n\tint d = abs(bm-bw);\n\treturn d*(d-30)*(d-30);\n}\n\nint main(){\n\twhile(1){\n\t\tint m,w;\n\t\tint bm[15],bw[15];\n\t\tscanf(\"%d%d\",&m,&w);\n\t\tif(m == 0 && w == 0)break;\n\t\trep(i,m)scanf(\"%d\",&bm[i]);\n\t\trep(i,w)scanf(\"%d\",&bw[i]);\n\t\tstatic int dp[15][1 << 12] = {};\n\t\trep(i,15)rep(j,(1<<12)){\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t\tint ret = 0;\n\t\trep(i,m){\n\t\t\trep(j,(1<<w)){\n\t\t\t\tdp[i+1][j] = max ( dp[i+1][j] , dp[i][j] );\n\t\t\t\trep(k,w){\n\t\t\t\t\tif((j>>k)&1)continue;\n\t\t\t\t\tdp[i+1][j|(1<<k)] = max ( dp[i+1][j|(1<<k)] , dp[i][j] + cal(bm[i],bw[k]) );\n\t\t\t\t}\n\t\t\t\tret = max ( ret , dp[i][j] );\n\t\t\t}\n\t\t}\n\t\trep(j,(1<<w))ret = max ( ret , dp[m][j] );\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint m, w;\nint bm[22], bw[22];\nunsigned short memo[1<<12][1<<12];\n\nint e(int i, int j){\n\n  int p = abs(bm[i] - bw[j]);\n  return p * (p-30) * (p-30);\n\n}\n\nint solve(int bitm, int bitw){\n\n  if(memo[bitm][bitw]) return memo[bitm][bitw];\n  \n  int ret = 0;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<w;j++){\n      if(!(bitm & (1<<i)) && !(bitw & (1<<j))){\n\tret = max(ret, solve((bitm | (1<<i)), (bitw | (1<<j))) + e(i, j));\n      }\n    } \n  }\n\n  return memo[bitm][bitw] = ret;\n  \n}\nint main(){\n\n  \n  while(cin >> m >> w){\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    \n    memset(memo, 0, sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint dp[13][1 << 12], a[12], b[12];\nint main() {\n\tint m, w;\n\twhile (scanf(\"%d%d\", &m, &w), m) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(i, m)scanf(\"%d\", &a[i]);\n\t\trep(i, w)scanf(\"%d\", &b[i]);\n\t\trep(i, m)rep(j, 1 << w) {\n\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n\t\t\trep(k, w) {\n\t\t\t\tif (j >> k & 1)continue;\n\t\t\t\tint c = abs(a[i] - b[k]);\n\t\t\t\tdp[i + 1][j | 1 << k] = max(dp[i + 1][j | 1 << k], dp[i][j] + c*(c - 30)*(c - 30));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp[0], dp[m + 1]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define DPSIZE (1<<12)\n\nint M, W;\nint bm[12], bw[12];\nint dp[DPSIZE];\n\nint calcPower(int a, int b)\n{\n\tint num = a - b;\n\tif(num < 0) {\n\t\tnum *= -1;\n\t}\n\t\n\treturn num * (num - 30) * (num - 30);\n}\n\nint main()\n{\n\twhile(cin >> M >> W, M, W) {\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tcin >> bm[i];\n\t\t}\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tcin >> bw[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < DPSIZE; i++) {\n\t\t\tdp[i] = 0;\n\t\t}\n\t\t\n\t\tif(M < W) {\n\t\t\tswap(M, W);\n\t\t\tswap(bm, bw);\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < (1<<M)-1; i++) {\n\t\t\tif(i != 0 && dp[i] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tif(i & (1<<j)) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tif((i & (1<<j))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint next = (i | (1<<j));\n\t\t\t\tdp[next] = max(dp[next], dp[i] + ((cnt < W)? calcPower(bm[j], bw[cnt]): 0));\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << dp[(1<<M)-1] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint a[12], b[12];\nint dp[13][1 << 12];\n\nint calc(int i, int j)\n{\n\tint d = abs(a[i] - b[j]);\n\treturn d * (d - 30) * (d - 30);\n}\n\nint solve()\n{\n\tmemset(dp, 0, sizeof dp);\n\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int bit = 0; bit < (1 << m); bit++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (bit & (1 << j)) continue;\n\t\t\t\tint &nx = dp[i + 1][bit + (1 << j)];\n\t\t\t\tnx = max(nx, dp[i][bit] + calc(i, j));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn *max_element(*begin(dp), *end(dp));\n}\n\nint main()\n{\n\twhile (cin >> n >> m, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = int;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<int> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addArc(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == INF)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == INF)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += d*dist[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int M, W; cin >> M >> W&&M;) {\n\t\tvector<int> bm(M); rep(i, 0, M) {\n\t\t\tcin >> bm[i];\n\t\t}\n\t\tvector<int> bw(W); rep(i, 0, W) {\n\t\t\tcin >> bw[i];\n\t\t}\n\t\tMinimumCostFlow mcf(M + W + 2);\n\t\tint s = M + W, t = s + 1;\n\t\trep(i, 0, M) {\n\t\t\tmcf.addArc(s, i, 1, 0);\n\t\t}\n\t\trep(i, 0, W) {\n\t\t\tmcf.addArc(i + M, t, 1, 0);\n\t\t}\n\t\trep(i, 0, M)rep(j, 0, W) {\n\t\t\tmcf.addArc(i, j + M, 1, -abs(bm[i] - bw[j])*(abs(bm[i] - bw[j]) - 30)*(abs(bm[i] - bw[j]) - 30));\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, 0, M + 1) {\n\t\t\tMinimumCostFlow tmcf = mcf;\n\t\t\tMinimumCostFlow::Cost cost = -tmcf.minimumCostFlow(s, t, i);\n\t\t\tchmax(ans, cost);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < 12; i++)check[i] = false;\n\t}\n\n\tshort table[6],index;\n\tbool check[12];\n};\n\nint table_2[2][2],table_3[6][3],table_4[24][4],table_5[120][5],table_6[720][6];\n\nvoid func(int M,int W){\n\tint m_data[M],w_data[W];\n\n\tfor(int i = 0; i < M; i++)scanf(\"%d\",&m_data[i]);\n\tfor(int i = 0; i < W; i++)scanf(\"%d\",&w_data[i]);\n\n\tint maximum = 0,tmp,select_num,num,left_index,right_index,left_tmp,right_tmp,left_max,right_max,limit,loc_left[7],loc_right[7],index,val,calc[7];\n\n\tif(M == 1){\n\t\tfor(int i = 0; i < W; i++){\n\t\t\ttmp = abs(w_data[i] - m_data[0])*(abs(w_data[i] - m_data[0])-30)*(abs(w_data[i] - m_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else if(W == 1){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\ttmp = abs(m_data[i] - w_data[0])*(abs(m_data[i] - w_data[0])-30)*(abs(m_data[i] - w_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else{\n\t\tif(M > W){\n\t\t\tselect_num = (M+1)/2;\n\n\t\t\tlimit = pow(2,M);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\t//??°???????????????????????????\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tif(left_index == 1){\n\t\t\t\t\tval = abs(w_data[0] - m_data[loc_left[0]]);\n\t\t\t\t\tleft_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t}else if(left_index == 2){\n\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]];\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_2[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 3){\n\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]];\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_3[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 4){\n\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],calc[3] = m_data[loc_left[3]];\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_4[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 5){\n\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],calc[3] = m_data[loc_left[3]],calc[4] = m_data[loc_left[4]];\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_5[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //left_index == 6\n\t\t\t\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],\n\t\t\t\t\t\t\t\t\t\t\t\t\tcalc[3] = m_data[loc_left[3]],calc[4] = m_data[loc_left[4]],calc[5] = m_data[loc_left[5]];\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_6[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(right_index == 1){\n\t\t\t\t\tval = abs(w_data[W-1] - m_data[loc_right[0]]);\n\t\t\t\t\tright_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t}else if(right_index == 2){\n\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]];\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_2[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 3){\n\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]];\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_3[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 4){\n\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],calc[3] = m_data[loc_right[3]];\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_4[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 5){\n\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],calc[3] = m_data[loc_right[3]],calc[4] = m_data[loc_right[4]];\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_5[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //right_index == 6\n\t\t\t\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],\n\t\t\t\t\t\t\t\t\t\t\t\t\tcalc[3] = m_data[loc_right[3]],calc[4] = m_data[loc_right[4]],calc[5] = m_data[loc_right[5]];\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - calc[table_6[index][p-((W+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\n\t\t}else{ //W >= M\n\t\t\tselect_num = (W+1)/2;\n\n\t\t\tlimit = pow(2,W);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tif(left_index == 1){\n\t\t\t\t\tval = abs(m_data[0] - w_data[loc_left[0]]);\n\t\t\t\t\tleft_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t}else if(left_index == 2){\n\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]];\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_2[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 3){\n\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]];\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_3[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 4){\n\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],calc[3] = w_data[loc_left[3]];\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_4[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(left_index == 5){\n\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],calc[3] = w_data[loc_left[3]],calc[4] = w_data[loc_left[4]];\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_5[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //left_index == 6\n\t\t\t\t\tcalc[0] = w_data[loc_left[0]],calc[1] = w_data[loc_left[1]],calc[2] = w_data[loc_left[2]],\n\t\t\t\t\t\t\t\t\t\t\t\t\tcalc[3] = w_data[loc_left[3]],calc[4] = w_data[loc_left[4]],calc[5] = w_data[loc_left[5]];\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_6[index][p]]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(right_index == 1){\n\t\t\t\t\tval = abs(m_data[M-1] - w_data[loc_right[0]]);\n\t\t\t\t\tright_tmp = val*(val-30)*(val-30);\n\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t}else if(right_index == 2){\n\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]];\n\t\t\t\t\tfor(index = 0; index < 2; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_2[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 3){\n\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]];\n\t\t\t\t\tfor(index = 0; index < 6; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_3[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 4){\n\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],calc[3] = w_data[loc_right[3]];\n\t\t\t\t\tfor(index = 0; index < 24; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_4[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t}else if(right_index == 5){\n\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],calc[3] = w_data[loc_right[3]],calc[4] = w_data[loc_right[4]];\n\t\t\t\t\tfor(index = 0;index < 120; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_5[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{ //right_index == 6\n\t\t\t\t\tcalc[0] = w_data[loc_right[0]],calc[1] = w_data[loc_right[1]],calc[2] = w_data[loc_right[2]],\n\t\t\t\t\t\t\t\t\t\t\t\t\tcalc[3] = w_data[loc_right[3]],calc[4] = w_data[loc_right[4]],calc[5] = w_data[loc_right[5]];\n\t\t\t\t\tfor(index = 0;index < 720; index++){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int  p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - calc[table_6[index][p-((M+1)/2)]]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\tint M,W,index_2 = 0,index_3 = 0,index_4 = 0, index_5 = 0,index_6 = 0;\n\n\tfor(int a = 0; a < 2; a++){\n\t\tfor(int b = 0; b < 2; b++){\n\t\t\tif(a != b){\n\t\t\t\ttable_2[index_2][0] = a,table_2[index_2][1] = b;\n\t\t\t\tindex_2++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < 3; a++){\n\t\tfor(int b = 0; b < 3; b++){\n\t\t\tfor(int c = 0; c < 3; c++){\n\t\t\t\tif(a != b && a != c && b != c){\n\t\t\t\t\ttable_3[index_3][0] = a,table_3[index_3][1] = b,table_3[index_3][2] = c;\n\t\t\t\t\tindex_3++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < 4; a++){\n\t\tfor(int b = 0; b < 4; b++){\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tif(a != b && a != c && a != d && b != c && b != d && c != d){\n\t\t\t\t\t\ttable_4[index_4][0] = a,table_4[index_4][1] = b,table_4[index_4][2] = c,table_4[index_4][3] = d;\n\t\t\t\t\t\tindex_4++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < 5; a++){\n\t\tfor(int b = 0; b < 5; b++){\n\t\t\tfor(int c = 0; c < 5; c++){\n\t\t\t\tfor(int d = 0; d < 5; d++){\n\t\t\t\t\tfor(int e = 0; e < 5; e++){\n\t\t\t\t\t\tif(a != b && a != c && a != d && a != e && b != c && b != d && b != e && c != d && c != e && d != e){\n\t\t\t\t\t\t\ttable_5[index_5][0] = a,table_5[index_5][1] = b,table_5[index_5][2] = c,table_5[index_5][3] = d,table_5[index_5][4] = e;\n\t\t\t\t\t\t\tindex_5++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < 6; a ++){\n\t\tfor(int b = 0; b < 6; b++){\n\t\t\tfor(int c = 0; c < 6; c++){\n\t\t\t\tfor(int d = 0; d < 6; d++){\n\t\t\t\t\tfor(int e = 0; e < 6; e++){\n\t\t\t\t\t\tfor(int f = 0; f < 6; f++){\n\t\t\t\t\t\t\tif(a != b && a != c && a != d && a != e && a != f && b != c && b != d && b != e && b != f && c != d && c != e && c != f && d != e && d != f && e != f){\n\t\t\t\t\t\t\t\ttable_6[index_6][0] = a,table_6[index_6][1] = b,table_6[index_6][2] = c,table_6[index_6][3] = d,table_6[index_6][4] = e,table_6[index_6][5] = f;\n\t\t\t\t\t\t\t\tindex_6++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&M,&W);\n\t\tif(M == 0 && W == 0)break;\n\n\t\tfunc(M,W);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint M,W;\nint bm[12],bw[12];\n\nint gt(int m,int w){\n\tint sa=abs(bm[m]-bw[w]);\n\tint tmp=sa-30;\n\treturn sa*tmp*tmp;\n}\n\nint memo[12][1<<12];\nint solve(int m,int w,int wn){\n\tif(m<0){return 0;}\n\tif(m+1 < wn){return 0;}\n\tif(memo[m][w]!=-1){return memo[m][w];}\n\n\tint ans=solve(m-1,w,wn);\n\tfor(int i=0;i<W;i++){\n\t\tif(w & (1<<i)){\n\t\t\tans=max(ans,solve(m-1,w-(1<<i),wn-1)+gt(m,i));\n\t\t}\n\t}\n\n\tmemo[m][w]=ans;\n\treturn ans;\n}\n\nint main(){\n\twhile(cin>>M>>W,M){\n\t\tint i,j;\n\t\tfor(i=0;i<M;i++){\n\t\t\tcin>>bm[i];\n\t\t\tfor(j=0;j<(1<<W);j++){\n\t\t\t\tmemo[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<W;i++){\n\t\t\tcin>>bw[i];\n\t\t}\n\n\t\tint ans=0;\n\t\tfor(i=0;i<(1<<W);i++){\n\t\t\tint cnt=0;\n\t\t\tfor(j=0;j<W;j++){\n\t\t\t\tif(i & (1<<j)){cnt++;}\n\t\t\t}\n\t\t\tans=max(ans,solve(M-1,i,cnt));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint N, M, x[12], y[12], a1[12], a2[12];\nint dp[1 << 12];\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M; if (N == 0 && M == 0)break;\n\t\tfor (int i = 0; i < N; i++)cin >> x[i];\n\t\tfor (int i = 0; i < M; i++)cin >> y[i];\n\t\tif (N <= M) {\n\t\t\tfor (int i = 0; i < N; i++)a1[i] = x[i];\n\t\t\tfor (int i = 0; i < M; i++)a2[i] = y[i];\n\t\t}\n\t\tif (N > M) {\n\t\t\tfor (int i = 0; i < N; i++)a2[i] = x[i];\n\t\t\tfor (int i = 0; i < M; i++)a1[i] = y[i];\n\t\t\tswap(N, M);\n\t\t}\n\t\tfor (int i = 0; i < (1 << 12); i++)dp[i] = 0;\n\t\tint maxn = 0;\n\t\tfor (int i = 0; i < (1 << M); i++) {\n\t\t\tint bit[12], cnt = 0;\n\t\t\tfor (int j = 0; j < M; j++) { bit[j] = (i / (1 << j)) % 2; cnt += bit[j]; }\n\t\t\tif (cnt >= N)continue;\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tif (bit[j] == 1)continue;\n\t\t\t\tint Q = abs(a1[cnt] - a2[j])*(abs(a1[cnt] - a2[j]) - 30)*(abs(a1[cnt] - a2[j]) - 30);\n\t\t\t\tdp[i + (1 << j)] = max(dp[i + (1 << j)], dp[i] + Q); maxn = max(maxn, dp[i + (1 << j)]);\n\t\t\t}\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint m, w;\nint bm[22], bw[22];\nunsigned short memo[1<<12][1<<12];\n \nint e(int i, int j){\n \n  int p = abs(bm[i] - bw[j]);\n  return p * (p-30) * (p-30);\n \n}\n \nint solve(int bitm, int bitw){\n \n  if(memo[bitm][bitw]) return memo[bitm][bitw];\n   \n  int ret = 0;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<w;j++){\n      if(!(bitm & (1<<i)) && !(bitw & (1<<j))){\n    ret = max(ret, solve((bitm | (1<<i)), (bitw | (1<<j))) + e(i, j));\n      }\n    } \n  }\n \n  return memo[bitm][bitw] = ret;\n   \n}\nint main(){\n \n   \n  while(cin >> m >> w, m|w){\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n     \n    memset(memo, 0, sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b)a=b;};\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b)a=b;};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int m,w;\n  while(cin>>m>>w,m||w){\n    vector<Int> as(m),bs(w);\n    for(Int i=0;i<m;i++) cin>>as[i];\n    for(Int i=0;i<w;i++) cin>>bs[i];\n\n    auto calc=[&](Int i,Int j)->Int{\n      Int dif=abs(as[i]-bs[j]);\n      return dif*(dif-30)*(dif-30);\n    };\n\n    Int s=1<<w;\n    const Int INF = 1e15;    \n    vector<Int> dp(s,-INF);\n    dp[0]=0;\n    for(Int i=0;i<m;i++){\n      vector<Int> nx(s,-INF);\n      for(Int b=0;b<s;b++){\n\tchmax(nx[b],dp[b]);\n\tfor(Int j=0;j<w;j++){\n\t  if((b>>j)&1) continue;\n\t  chmax(nx[b|(1<<j)],dp[b]+calc(i,j));\t\t   \n\t}\n      }\n      swap(dp,nx);\n    }\n    cout<<*max_element(dp.begin(),dp.end())<<endl;\n  }  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define chmax(a,b) (a) = max((a),(b));\nusing namespace std;\n\nconst int inf = -1e9;\n\ninline int cal(int a, int b){\n  int dif = abs(a-b);\n  return dif * (dif - 30) * (dif - 30);\n}\n\nint main(){\n  int n,m;\n  while(cin >> n >> m, n){\n    vector<int> a(n), b(m);\n    for(int i=0;i<n;i++)cin >> a[i];\n    for(int j=0;j<m;j++)cin >> b[j];\n\n    vector< vector<int> > dp(n+1, vector<int>(1<<m,inf));\n    dp[0][0] = 0;\n\n    for(int i=0;i<n;i++){\n      for(int use=0;use<(1<<m);use++){\n\tif(dp[i][use] == inf)continue;\n\n\tchmax(dp[i+1][use], dp[i][use]);\n\tfor(int j=0;j<m;j++){\n\t  if( (use>>j)&1 )continue;\n\t  chmax(dp[i+1][use | (1<<j)], dp[i][use] + cal(a[i],b[j]));\n\t}\n      }\n    }\n\n    int ans = inf;\n    for(int use=0;use<(1<<m);use++){\n      chmax(ans,dp[n][use]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 0290.cc: Microorganism Power Generation\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 12;\nconst int NBITS = 1 << MAX_N;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef pair<int,int> pii;\n\n/* global variables */\n\nint m, w;\nint mbits, wbits;\nint bms[MAX_N], bws[MAX_N], engs[MAX_N][MAX_N];\nint dp[NBITS][NBITS];\n\n/* subroutines */\n\ninline int engy(int bm, int bw) {\n  int db0 = abs(bm - bw), db1 = db0 - 30;\n  return db0 * db1 * db1;\n}\n\nint rec(int bits0, int bits1) {\n  if (dp[bits0][bits1] >= 0) return dp[bits0][bits1];\n\n  int maxd = 0;\n  for (int i = 0, bi = 1; i < m; i++, bi <<= 1)\n    if (bits0 & bi)\n      for (int j = 0, bj = 1; j < w; j++, bj <<= 1)\n\tif (bits1 & bj) {\n\t  int d = engs[i][j] + rec(bits0 ^ bi, bits1 ^ bj);\n\t  if (maxd < d) maxd = d;\n\t}\n\n  return (dp[bits0][bits1] = maxd);\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> m >> w;\n    if (m == 0) break;\n\n    for (int i = 0; i < m; i++) cin >> bms[i];\n    for (int i = 0; i < w; i++) cin >> bws[i];\n\n    for (int i = 0; i < m; i++)\n      for (int j = 0; j < w; j++) engs[i][j] = engy(bms[i], bws[j]);\n    \n    mbits = 1 << m;\n    wbits = 1 << w;\n\n    for (int bits0 = 0; bits0 < mbits; bits0++)\n      for (int bits1 = 0; bits1 < wbits; bits1++)\n\tdp[bits0][bits1] = -1;\n    for (int bits = 0; bits < mbits; bits++) dp[bits][0] = 0;\n    for (int bits = 0; bits < wbits; bits++) dp[0][wbits] = 0;\n\n    int ans = rec(mbits - 1, wbits - 1);\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint M, W, bm[12], bw[12], dp[1 << 12];\nint popcount(int n) {\n\tint ret = 0;\n\tfor (int i = 0; i < 12; i++) {\n\t\tif (n & (1 << i)) ret++;\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (true) {\n\t\tscanf(\"%d%d\", &M, &W);\n\t\tif (M == 0 && W == 0) break;\n\t\tif (M < W) {\n\t\t\tswap(M, W);\n\t\t\tswap(bm, bw);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) scanf(\"%d\", &bm[i]);\n\t\tfor (int i = 0; i < W; i++) scanf(\"%d\", &bw[i]);\n\t\tfor (int i = 0; i < (1 << M); i++) dp[i] = 0;\n\t\tfor (int i = 1; i < (1 << M); i++) {\n\t\t\tint times = popcount(i) - 1;\n\t\t\tif (times < W) {\n\t\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\t\tif (i & (1 << j)) {\n\t\t\t\t\t\tint m = bm[j];\n\t\t\t\t\t\tint w = bw[times];\n\t\t\t\t\t\tdp[i] = max(dp[i], dp[i - (1 << j)] + abs(m - w) * (abs(m - w) - 30) * (abs(m - w) - 30));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < (1 << M); i++) ret = max(ret, dp[i]);\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_V = 100010;\ntypedef int Capacity;\ntypedef int Cost;\nconst int inf = 1 << 28;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tvector<int> top;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].push_back(Edge{ dst, cap, cost, (int)g[dst].size(), false });\n\t\tg[dst].push_back(Edge{ src, 0, -cost, (int)g[src].size() - 1, true });\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\n\t\tfill(h, h + n, 0);\n\t\tif(top.size()) {\n\t\t\tassert(top.size() == n);\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint v = top[i];\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge& e = g[v][i];\n\t\t\t\t\tif(e.cap == 0) continue;\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\th[u] = min(h[u], h[v] + e.cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.push(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.push(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint bm[12];\nint bw[12];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, W;\n\twhile(cin >> M >> W, M + W) {\n\t\tPrimalDual pd(M + W + 2);\n\t\tint S = M + W, T = S + 1;\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tcin >> bm[i];\n\t\t\tpd.add_edge(S, i, 1, 0);\n\t\t}\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tcin >> bw[i];\n\t\t\tpd.add_edge(M + i, T, 1, 0);\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tint a = abs(bm[i] - bw[j]);\n\t\t\t\tint cost = a * (a - 30) * (a - 30);\n\t\t\t\tpd.add_edge(i, M + j, 1, -cost);\n\t\t\t}\n\t\t}\n\n\t\tcout << -pd.solve(S, T, min(M, W)) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\n \nconst lli INF = 1LL<<60;\nconst lli MAXM = 13;\nconst lli MAXW = 13;\n \nlli M, W;\nlli bm[MAXM], bw[MAXW];\nlli dp[MAXM][1<<MAXW];\n \nlli f(lli bm, lli bw) {\n  return llabs(bm - bw) * (llabs(bm - bw) - 30LL) * (llabs(bm - bw) - 30LL);\n}\n \nint main() {\n  while(cin >> M >> W && (M|W)) {\n    for(lli i = 0; i < M; ++i) cin >> bm[i];\n    for(lli i = 0; i < W; ++i) cin >> bw[i];\n    fill(dp[0], dp[MAXM], -INF);\n    dp[0][0] = 0;\n    for(lli i = 0; i < M; ++i) {\n      for(lli j = (1<<W)-1; j >= 0; --j) {\n        dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n        for(lli k = 0; k < W; ++k) {\n          if(j >> k & 1) {\n            dp[i+1][j] = max(dp[i+1][j], dp[i][j-(1<<k)] + f(bm[i], bw[k]));\n          }\n        }\n      }\n    }\n    lli res = 0;\n    for(lli j = (1<<W)-1; j >= 0; --j) {\n      res = max(res, dp[M][j]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long bitDP(bitset<13> b,long long now);\nlong long ene(long long a,long long b);\nlong long m,w;\nlong long mem[1<<12][13];\nlong long maxsb[20];\nlong long minsb[20];\nmain(){\n  while(1){\n    cin>>m>>w;\n    if(m==0&&w==0) break;\n    memset(mem,-1,sizeof(mem));\n    if(m<=w){\n      for(int i=0;i<m;i++){\n\tcin>>minsb[i];\n      }\n      for(int i=0;i<w;i++){\n\tcin>>maxsb[i];\n      }\n    }\n    else{\n      for(int i=0;i<m;i++){\n\tcin>>maxsb[i];\n      }\n      for(int i=0;i<w;i++){\n\tcin>>minsb[i];\n      }\n    }\n    cout<<bitDP(0,0)<<endl;\n  }\n}\nlong long bitDP(bitset<13> b,long long now){\n  if(now>=min(m,w)){\n    return 0;\n  }\n  else if(mem[b.to_ulong()][now]!=-1) return mem[b.to_ulong()][now];\n  long long ret=-10000000;\n  bitset<13> bb(1);\n  for(int i=0;i<max(m,w);i++){\n    if((b&bb)==0){\n      ret=max(ret,bitDP(b|bb,now+1)+ene(minsb[now],maxsb[i]));\n    }\n    bb=bb<<1;\n  }\n  return mem[b.to_ulong()][now]=ret;\n}\nlong long ene(long long a,long long b){\n  return llabs(a-b)*(llabs(a-b)-30)*(llabs(a-b)-30);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint m, w;\n\nint bm[15];\nint bw[15];\n\nint dp[30][10000];\n\nint pow2(int n){\n  return n*n;\n}\n\nlong long dfs(int i, int bit){\n  if(i == m) return 0;\n  if(dp[i][bit] != -1) return dp[i][bit];\n\n  long long ret = dfs(i+1,bit);\n  for(int j = 0;j < w;j++){\n    if((bit & (1 << j)) == 0){\n      ret = max(ret, dfs(i+1, bit | (1 << j)) + abs(bm[i]-bw[j]) * pow2(abs(bm[i]-bw[j])-30));\n    }\n  }\n\n  return dp[i][bit] = ret;\n}\n\nint main(){\n  while(cin >> m >> w, m != 0){\n\n    for(int i = 0;i < m;i++){\n      cin >> bm[i];\n    }\n\n    for(int i = 0;i < w;i++){\n      cin >> bw[i];\n    }\n\n    memset(dp,-1,sizeof(dp));\n\n    cout << dfs(0, 0) << endl;\n  }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < 12; i++)check[i] = false;\n\t}\n\n\tshort table[6],index;\n\tbool check[12];\n};\n\nvoid func(int M,int W){\n\tint m_data[M],w_data[W];\n\n\tfor(int i = 0; i < M; i++)scanf(\"%d\",&m_data[i]);\n\tfor(int i = 0; i < W; i++)scanf(\"%d\",&w_data[i]);\n\n\tint maximum = 0,tmp,select_num,num,left_index,right_index,left_tmp,right_tmp,left_max,right_max,limit,loc_left[7],loc_right[7],val;\n\n\tif(M == 1){\n\t\tfor(int i = 0; i < W; i++){\n\t\t\ttmp = abs(w_data[i] - m_data[0])*(abs(w_data[i] - m_data[0])-30)*(abs(w_data[i] - m_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else if(W == 1){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\ttmp = abs(m_data[i] - w_data[0])*(abs(m_data[i] - w_data[0])-30)*(abs(m_data[i] - w_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else{\n\t\tif(M > W){\n\t\t\tselect_num = (M+1)/2;\n\n\t\t\tlimit = pow(2,M);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\t//??°???????????????????????????\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tqueue<Info> Q;\n\t\t\t\tInfo current,left_first,right_first;\n\n\t\t\t\tfor(int k = 0; k < left_index;k++){\n\t\t\t\t\tleft_first.check[loc_left[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(left_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == left_index){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - current.table[p]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < M; p++){\n\t\t\t\t\t\tif(current.check[p]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < 12; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = m_data[p];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int k = 0; k < right_index;k++){\n\t\t\t\t\tright_first.check[loc_right[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(right_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == right_index){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - current.table[p-((W+1)/2)]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < M; p++){\n\t\t\t\t\t\tif(current.check[p]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < 12; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = m_data[p];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\n\t\t}else{ //W >= M\n\t\t\tselect_num = (W+1)/2;\n\n\t\t\tlimit = pow(2,W);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tqueue<Info> Q;\n\t\t\t\tInfo current,left_first,right_first;\n\n\t\t\t\tfor(int k = 0; k < left_index;k++){\n\t\t\t\t\tleft_first.check[loc_left[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(left_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == left_index){\n\t\t\t\t\t\tleft_tmp = 0;\n\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - current.table[p]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < W; p++){\n\t\t\t\t\t\tif(current.check[p] == true){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < 12; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = w_data[p];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int k = 0; k < right_index;k++){\n\t\t\t\t\tright_first.check[loc_right[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(right_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == right_index){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - current.table[p-((M+1)/2)]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < W; p++){\n\t\t\t\t\t\tif(current.check[p]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < 12; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = w_data[p];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\tint M,W;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&M,&W);\n\t\tif(M == 0 && W == 0)break;\n\n\t\tfunc(M,W);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint M,W;\nint bm[12],bw[12];\n\ninline int calc(int m, int w)\n{\n    int d=abs(bm[m]-bw[w]);\n    return d*(d-30)*(d-30);\n}\n\nint dp[4100][4100];\nint dfs(int x, int y)\n{\n    if(dp[x][y]>=0) return dp[x][y];\n    if(x==(1<<M)-1 || y==(1<<W)-1) return 0;\n\n    int ret=0;\n    rep(i,M)rep(j,W)\n    {\n        if(x>>i&1 || y>>j&1) continue;\n        ret=max(ret,dfs(x+(1<<i),y+(1<<j))+calc(i,j));\n    }\n\n    return dp[x][y]=ret;\n}\n\nint main()\n{\n    while(scanf(\" %d %d\", &M, &W),M)\n    {\n        rep(i,M) scanf(\" %d\", &bm[i]);\n        rep(i,W) scanf(\" %d\", &bw[i]);\n\n        memset(dp,-1,sizeof(dp));\n        printf(\"%d\\n\", dfs(0,0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\ntypedef long long  Weight;\nstruct Edge {\n\tint src, dest;\n\tint cap, rev;\n\tWeight weight;\n\tbool operator < (const Edge &rhs) const { return weight > rhs.weight; }\n};\n\nconst int V = 4000;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nWeight h[V];                //??????????????£???\nWeight dist[V];             //???????????¢\nint prevv[V], preve[V];  //??´???????????¨??????\n\nvoid add_edge(Graph &g, int src, int dest, int cap, int weight) {\n\tg[src].push_back(Edge{ src, dest, cap, (int)g[dest].size(), weight });\n\tg[dest].push_back(Edge{ dest, src, 0, (int)g[src].size() - 1, -weight });\n}\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 2147483647;\nconst long long int L_INF = 9223372036854775807;\nWeight min_cost_flow(Graph &g, int s, int t, int f) {\n\tWeight res = 0;\n\tmemset(h, 0, sizeof(h));\n\ttypedef pair<Weight, int> P;\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tREP(i, g[v].size()) {\n\t\t\t\tEdge &e = g[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.dest] > dist[v] + e.weight + h[v] - h[e.dest]) {\n\t\t\t\t\tdist[e.dest] = dist[v] + e.weight + h[v] - h[e.dest];\n\t\t\t\t\tprevv[e.dest] = v;\n\t\t\t\t\tpreve[e.dest] = i;\n\t\t\t\t\tque.push(P(dist[e.dest], e.dest));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tREP(v, V) h[v] += dist[v];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) d = min(d, g[prevv[v]][preve[v]].cap);\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\twhile (1) {\n\t\tint M, W; cin >> M >> W;\n\t\tif (!M)break;\n\t\tvector<int>males(M), femas(W);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tcin >> males[i];\n\t\t}\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tcin >> femas[i];\n\t\t}\n\t\tconst int start = 0;\n\t\tconst int man = start + 1;\n\t\tconst int wom = man + M;\n\t\tconst int goal = wom + W;\n\t\tGraph g(goal + 1);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tadd_edge(g, start, man + i, 1, 0);\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tconst int ele = abs(males[i] - femas[j])*((abs(males[i] - femas[j]) - 30)*(abs(males[i] - femas[j]) - 30));\n\t\t\t\tadd_edge(g, man + i, wom + j, 1, 1000000 - ele);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tadd_edge(g, wom + i, goal, 1, 0);\n\t\t}\n\t\tint ans = min_cost_flow(g, start, goal, min(M, W));\n\t\tcout << 1000000 * (min(M, W)) - ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint m, w;\nint bm[22], bw[22];\nint memo[22][1<<13];\n\nint e(int a, int b){\n\n  int p = abs(bm[a] - bw[b]);\n  return p * (p-30) * (p-30);\n\n}\n\nint solve(int cntm, int bitw){\n\n  if(~memo[cntm][bitw]) return memo[cntm][bitw];\n  if(cntm == m) return 0;\n  \n  int ret = 0;\n  for(int i=0;i<w;i++)\n    if(!(bitw & (1<<i)))\n    ret = max(ret, solve(cntm+1, (bitw | (1<<i))) + e(cntm, i));\n  \n  ret = max(ret, solve(cntm+1, bitw));\n  \n  return memo[cntm][bitw] = ret;\n  \n}\n\nint main(){\n\n  while(cin >> m >> w, m|w){\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    \n    memset(memo, -1, sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint M,W;\nvector<int>bm,bw;\nint memo[12][1<<12];\n\nint val(int i,int j){\n    int ab=abs(bm[i]-bw[j]);\n    return ab*(ab-30)*(ab-30);\n}\n\nint calc(int n,int b){\n    if(n==M)return 0;\n    if(~memo[n][b])return memo[n][b];\n    int ret=calc(n+1,b);\n    for(int i=0;i<W;i++){\n        if(b>>i&1)continue;\n        ret=max(ret,calc(n+1,b|(1<<i))+val(n,i));\n    }\n    return memo[n][b]=ret;\n}\n\nint main(){\n    while(cin>>M>>W,M||W){\n        bm.resize(M);\n        bw.resize(W);\n        for(int i=0;i<M;i++)cin>>bm[i];\n        for(int i=0;i<W;i++)cin>>bw[i];\n\n        memset(memo,-1,sizeof(memo));\n        cout<<calc(0,0)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, s, e) for(int i = (int)s; i < (int) e; i++)\n#define rep(i, n) REP(i, 0 ,n)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp nake_pair\n\ntypedef long long ll;\n\nll d[(1<<13)+10];\n\nint main(){\n    int m, w;\n    while(~scanf(\"%d%d\", &m, &w)){\n        if(m == 0 && w == 0) break;\n        vector<int> a(m), b(w);\n        rep(i, m) scanf(\"%d\", &a[i]);\n        rep(i, w) scanf(\"%d\", &b[i]);\n        if(m > w){\n            swap(a, b);\n            swap(m, w);\n        }\n        rep(i, (1<<13)+10) d[i] = 0LL;\n        ll ans = 0LL;\n        rep(mask, 1<<w){\n            int k = 0;\n            rep(j, w) if(mask & (1<<j)) k++;\n            if(k >= m) continue;\n            rep(j, w) {\n                if(mask & (1<<j)) continue;\n                int nxt = mask | (1<<j);\n                ll c = abs(a[k]-b[j]);\n                d[nxt] = max(d[nxt], d[mask]+c*(c-30)*(c-30));\n                ans = max(ans, d[nxt]);\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint M,W;\nint dp[13][(1<<12)];\nint B[13],D[13];\n\nint get(int a,int b){\n  return abs(a-b) * (abs( a - b ) - 30) * (abs( a - b ) - 30);\n}\n\nint solve(int id,int st){\n  if( dp[id][st] != -1 ) return dp[id][st];\n  if( id == M ) return 0;\n  int ret = 0;\n  for(int i=0;i<W;i++){\n    if( st & (1<<i) ) continue;\n    ret = max( ret, solve( id+1, st | (1<<i) ) + get( B[id],D[i] ) );\n  }\n  ret = max( ret, solve( id + 1, st ) );\n  return dp[id][st] = ret;\n}\n\nint main(){\n  while( cin >> M >> W && (M||W) ){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<M;i++)\n      cin >> B[i];\n    for(int i=0;i<W;i++)\n      cin >> D[i];\n    cout << solve( 0, 0 ) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  while(1){\n    int m,w,bm[12],bw[12];\n    cin >> m >> w;\n    if(m==0 && w==0) break;\n    for(int i=0;i<m;i++) cin >> bm[i];\n    for(int i=0;i<w;i++) cin >> bw[i];\n    int dp[(1<<12)]={},ans=0;\n    for(int i=0;i<m;i++)\n      for(int S=(1<<w)-1;S>=0;S--)\n\tfor(int k=0;k<w;k++){\n\t  if((S&(1<<k))!=0)continue;\n\t  int t = abs(bm[i]-bw[k])*(abs(bm[i]-bw[k])-30)*(abs(bm[i]-bw[k])-30);\n\t  dp[S+(1<<k)] = max(dp[S+(1<<k)],dp[S]+t); \n\t  ans = max(ans,dp[S+(1<<k)]);\n\t}\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n// Sccessive Shortest Path(Primal Dual): minimum cost maximum flow\nstruct PrimalDual\n{\n  struct edge\n  {\n    int to, capacity, cost, rev;\n    edge(){}\n    edge(int to, int capacity, int cost, int rev):to(to), capacity(capacity), cost(cost), rev(rev){}\n  };\n\n  vector< vector<edge> > graph;\n  vector<int> potential, mincost, prevv, preve;\n  PrimalDual(int V):graph(V), potential(V), mincost(V), prevv(V), preve(V){}\n  void add_edge(int from, int to, int capacity, int cost)\n  {\n    graph[from].push_back(edge(to, capacity, cost, (int)graph[to].size()));\n    graph[to].push_back(edge(from, 0, -cost, (int)graph[from].size()-1));\n  }\n  int min_cost_flow(int source, int sink, int f)\n  {\n    int res = 0;\n    fill(potential.begin(), potential.end(), 0);\n    fill(prevv.begin(), prevv.end(), -1);\n    fill(preve.begin(), preve.end(), -1);\n\n    while(f > 0) {\n      typedef pair<int, int> Pi;\n      priority_queue<Pi, vector<Pi>, greater<Pi> > que;\n      fill(mincost.begin(), mincost.end(), inf);\n      mincost[source] = 0;\n      que.push(Pi(0, source));\n      while(!que.empty()) {\n\tPi p = que.top(); que.pop();\n\tint v = p.second;\n\tif(mincost[v] < p.first) continue;\n\tfor(int i = 0; i < (int)graph[v].size(); i++) {\n\t  edge& e = graph[v][i];\n\t  int dual_cost = mincost[v] + e.cost + potential[v] - potential[e.to];\n\t  if(e.capacity > 0 && dual_cost < mincost[e.to]) {\n\t    mincost[e.to] = dual_cost;\n\t    prevv[e.to] = v; preve[e.to] = i;\n\t    que.push(Pi(mincost[e.to], e.to));\n\t  }\n\t}\n      }\n\n      if(mincost[sink] == inf) return -1;\n      for(int v = 0; v < (int)graph.size(); v++) potential[v] += mincost[v];\n      int d = f;\n      for(int v = sink; v != source; v = prevv[v]) d = min(d, graph[prevv[v]][preve[v]].capacity);\n      f -= d;\n      res += d * potential[sink];\n      for(int v = sink; v != source; v = prevv[v]) {\n\tedge& e = graph[prevv[v]][preve[v]];\n\te.capacity -= d;\n\tgraph[v][e.rev].capacity += d;\n      }\n    }\n    return res;\n  }\n};\n\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int M, W;\n  while(cin >> M >> W, M || W) {\n    int bm[M], bw[W];\n    rep(i, M) cin >> bm[i];\n    rep(i, W) cin >> bw[i];\n    int s = M + W, t = s + 1, V = t + 1;\n    PrimalDual graph(V);\n    rep(i, M) graph.add_edge(s, i, 1, 0);\n    rep(i, M) rep(j, W) {\n      int dif = abs(bm[i]-bw[j]);\n      graph.add_edge(i, M + j, 1, -dif*(dif-30)*(dif-30));\n    }\n    rep(i, W) graph.add_edge(M + i, t, 1, 0);\n    cout << -graph.min_cost_flow(s, t, min(M, W)) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define lp(i,n) for(int i=0;i<(n);++i)\n#define REPA(i,n) for(int i=1;i<(n);++i)\n#define PII pair<int,int>\n#define PLI pair<long long, int>\n#define PLL pair<long long, long long>\n#define MOD ((int)1e9 + 7)\n#define INF ((int)1e9)\n#define INFLL ((LL)1e18)\n#define ALL(x) (x).begin(),(x).end()\n#define ctoi(x) (x - 'a') \n#define CTOI(x) (x - 'A')\n#define BIT(x) (1 << (x))\nusing namespace std;\n\nLL modinv(LL a){\n    LL b = MOD, u = 1, v = 0;\n    while(b){\n        LL t = a / b;\n        a -= t * b;swap(a, b);\n        u -= t * v;swap(u, v);\n    }\n    u%=MOD;\n    if(u < 0) u += MOD;\n    return u;\n\n}\nLL exp(int a, int b){\n    LL res = 1;\n    LL sum = a;\n    while(b){\n        if(b&1)res = (res * sum) % MOD;\n        sum = (sum * sum) % MOD;\n        b>>=1;\n    }\n    return res;\n}\n\nint cul(int a, int b){\n    int c = abs(a-b);\n    return c * (c - 30) * (c - 30);\n}\n\nint M, W;\nvector<int> m, w;\nvector<vector<int> > dp;\n\nint func(int used, int place){\n    if(place == M)return 0;\n    if(dp[place][used] >= 0)return dp[place][used];\n    int res = 0;\n    REP(i, W){\n        if(used & BIT(i))continue;\n        res = max(res, cul(m[place], w[i]) + func(used | BIT(i), place + 1));\n    }\n    return dp[place][used]=res;\n}\nint main(){\n    while(cin >> M >> W && M){\n        m = vector<int>(M);\n        w = vector<int>(W);\n        REP(i, M)cin>>m[i];\n        REP(i, W)cin>>w[i];\n        if(M > W){\n            swap(m, w);\n            swap(M, W);\n        }\n        dp = vector<vector<int> >(M, vector<int>(1<<W, -1));\n        cout << func(0, 0) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint memo[20][(1 << 12)];\n\nint m, w;\nint bm[20];\nint bw[20];\n\n#define POW(X) ((X)*(X))\n\nint dp(int i, int bit){\n\tif(i == m) return 0;\n\tif(memo[i][bit] != -1) return memo[i][bit];\n\n\tint ans = dp(i+1, bit);\n\n\tfor(int j = 0;j < w;j++){\n\t\tif((bit & (1 << j)) == 0){\n\t\t\tint tmp = abs(bm[i] - bw[j]) * POW(abs(bm[i] - bw[j]) - 30);\n\t\t\tans = max(ans, dp(i+1, bit | (1 << j)) + tmp);\n\t\t}\n\t}\n\n\treturn memo[i][bit] = ans;\n}\n\nsigned main(){\n\twhile(cin >> m >> w, m != 0){\n\t\tfor(int i = 0;i < m;i++) cin >> bm[i];\n\t\tfor(int i = 0;i < w;i++) cin >> bw[i];\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcout << dp(0, 0) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, m, a[12], b[12], dp[1 << 12];\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tfor (int i = 0; i < m; i++) cin >> b[i];\n\tif (n < m) swap(n, m), swap(a, b);\n\tfor (int i = 1; i < (1 << n); i++) {\n\t\tint r = __builtin_popcount(i);\n\t\tif (r > m) continue;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tint p = abs(a[j] - b[r - 1]);\n\t\t\t\tdp[i] = max(dp[i], dp[i - (1 << j)] + p * (p - 30) * (p - 30));\n\t\t\t}\n\t\t}\n\t}\n\tcout << *max_element(dp, dp + 1 << n) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint dp[1 << 12][13], a[12], b[12];\nint main() {\n\tint m, w;\n\twhile (scanf(\"%d%d\", &m, &w), m) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(i, m)scanf(\"%d\", &a[i]);\n\t\trep(i, w)scanf(\"%d\", &b[i]);\n\t\trep(i, 1 << w)rep(j, m) {\n\t\t\trep(k, w) {\n\t\t\t\tif (i >> k & 1)continue;\n\t\t\t\tint c = abs(a[j] - b[k]);\n\t\t\t\tdp[i | 1 << k][j + 1] = max(dp[i | 1 << k][j + 1], dp[i][j] + c*(c - 30)*(c - 30));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp[0], dp[1 << w]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define SIZE 26\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n\nint calc(int m,int w){\n  int ans = 0;\n  int bm[12],bw[12];\n  int dp[12][1<<12] = {0};\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%d\",bm+i);\n  }\n  \n  for(int i=0;i<w;i++){\n    scanf(\"%d\",bw+i);\n  }\n\n  for(int i=0;i<w;i++){\n    for(int j=0;j<(1<<m);j++){\n      dp[i][j] = -INF;\n    }\n  }\n\n  dp[0][0] = 0;\n  \n  for(int i=0;i<w;i++){\n    for(int j=0;j<(1<<m);j++){\n      for(int k=0;k<m;k++){\n\tif(j&(1<<k)) continue;\n\tint d = abs(bw[i]-bm[k]);\n\tint add = d * (d-30) * (d-30);\n\tdp[i+1][j|(1<<k)] = max(dp[i+1][j|(1<<k)],dp[i][j] + add);\n\tans = max(ans,dp[i+1][j|(1<<k)]);\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  int m,w;\n    \n  while(1){\n    scanf(\"%d%d\",&m,&w);\n    if(m==0) break;\n    \n    printf(\"%d\\n\",calc(m,w));\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<map>\n#include<cstring>\n#include<unordered_map>\n#include<set>\n#include<string.h>\n#define int long long\nusing namespace std;\n\nint a, b;\nint c[12], d[12];\nint dp[13][1 << 12];//i???????????§??????j?????£??????????????§???\nvoid saiki(int e, int f) {\n\tdp[e + 1][f] = dp[e][f];\n\tfor (int i = 0; i < b; i++) {\n\t\tif (f&(1ll << i)) {\n\t\t\tdp[e + 1][f - (1ll << i)] = max(dp[e+1][f-(1ll<<i)], dp[e][f] + abs(c[e] - d[i])*(abs(c[e] - d[i]) - 30)*(abs(c[e] - d[i]) - 30));\n\t\t}\n\t}\n}\nsigned main() {\n\twhile (cin >> a >> b, a | b) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (int e = 0; e < a; e++)cin >> c[e];\n\t\tfor (int e = 0; e < b; e++)cin >> d[e];\n\t\tfor (int e = 0; e < a; e++) {\n\t\t\tfor (int f = 0; f < (1ll << b); f++) {\n\t\t\t\tsaiki(e, f);\n\t\t\t}\n\t\t}\n\t\tcout << *max_element(dp[a], dp[a] + (1 << 12)) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <math.h>\nusing namespace std;\nint dp[(1<<12)+5][15];\nint A[15],B[15];\nint main(){\n\tint m,w;\n\twhile(1){\n\t\tscanf(\"%d%d\",&m,&w);\n\t\tif(m+w == 0) return 0;\n\t\tfor(int i=0;i<m;i++) scanf(\"%d\",&A[i]);\n\t\tfor(int i=0;i<w;i++) scanf(\"%d\",&B[i]);\n\t\tfor(int i=0;i<(1<<12)+5;i++) for(int j=0;j<15;j++) dp[i][j] = -10000000;\n\t\tdp[0][0] = 0;\n\t\tfor(int i=0;i<(1<<m);i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(dp[i][j] < 0) continue;\n\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\tdp[i][j+1] = max(dp[i][j+1],dp[i][j]);\n\t\t\t\t\tif(!((i>>k)&1)){\n\t\t\t\t\t\tint x = abs(A[j]-B[k]);\n\t\t\t\t\t\tdp[i | (1<<k)][j+1] = max(dp[i | (1<<k)][j+1] ,dp[i][j]+(x * (x-30) * (x-30)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i=0;i<(1<<12)+5;i++) for(int j=0;j<15;j++) res = max(res,dp[i][j]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_V=100;\nconst int INF=1001001001;\nint S,T;\nstruct edge{\n    int to,cap,cost,rev;\n    edge(int to,int cap,int cost,int rev)\n        :to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge>G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill_n(dist,V,INF);\n        dist[s]=0;\n        bool update=true;\n        while(update){\n            update=false;\n            for(int v=0;v<V;v++){\n                if(dist[v]==INF)continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n                        dist[e.to]=dist[v]+e.cost;\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        update=true;\n                    }\n                }\n            }\n        }\n\n        if(dist[t]==INF)return INF;\n\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        res+=d*dist[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n\nvoid init(){\n    fill_n(G,MAX_V,vector<edge>());\n}\n\nint main(){\n    V=100;\n    int M,W;\n    while(scanf(\"%d%d\",&M,&W),M||W){\n        init();\n        vector<int>bm(M),bw(W);\n        for(int i=0;i<M;i++)scanf(\"%d\",&bm[i]);\n        for(int i=0;i<W;i++)scanf(\"%d\",&bw[i]);\n\n\n        S=98,T=99;\n        for(int i=0;i<M;i++){\n            for(int j=0;j<W;j++){\n                int ab=abs(bm[i]-bw[j]);\n                int val=ab*(ab-30)*(ab-30);\n                add_edge(i,M+j,1,-val);\n            }\n        }\n\n        for(int i=0;i<M;i++){\n            add_edge(S,i,1,0);\n        }\n        for(int i=0;i<W;i++){\n            add_edge(i+M,T,1,0);\n        }\n\n        cout<<-min_cost_flow(S,T,min(M,W))<<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint M, W, bm[12], bw[12], dp[1 << 12];\nint popcount(int n) {\n\tint ret = 0;\n\tfor (int i = 0; i < 31; i++) {\n\t\tif (n & (1 << i)) ret++;\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (true) {\n\t\tscanf(\"%d%d\", &M, &W);\n\t\tif (M == 0 && W == 0) break;\n\t\tif (M < W) {\n\t\t\tswap(M, W);\n\t\t\tswap(bm, bw);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) scanf(\"%d\", &bm[i]);\n\t\tfor (int i = 0; i < W; i++) scanf(\"%d\", &bw[i]);\n\t\tfor (int i = 0; i < (1 << M); i++) dp[i] = 0;\n\t\tfor (int i = 1; i < (1 << M); i++) {\n\t\t\tint times = popcount(i) - 1;\n\t\t\tif (times < W) {\n\t\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\t\tif (i & (1 << j)) {\n\t\t\t\t\t\tint m = bm[j];\n\t\t\t\t\t\tint w = bw[times];\n\t\t\t\t\t\tdp[i] = max(dp[i], dp[i - (1 << j)] + abs(m - w) * (abs(m - w) - 30) * (abs(m - w) - 30));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < (1 << M); i++) ret = max(ret, dp[i]);\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint M,W,memo[13][1<<13];\nvector<int> A,B;\n \nint getEn(int bm,int bw){\n    int x = abs(bm-bw);\n    return x*pow(x-30,2);\n}\n \nint solve(int idx,int S){\n    if(idx == M){ return memo[idx][S] = 0; }\n    if(memo[idx][S] >= 0){ return memo[idx][S]; }\n    int res = -1;\n    for(int i = 0 ; i < W ; i++){\n\tif(S >> i & 1){ continue; }\n\tres = max(res,solve(idx+1,S|(1<<i))+getEn(A[idx],B[i]));\n    }\n    return memo[idx][S] = res;\n}\n \nint main(){\n    while(cin >> M >> W, M){\n\tA.resize(M); B.resize(W);\n\tfor(int i = 0 ; i < M ; i++){ cin >> A[i]; }\n\tfor(int i = 0 ; i < W ; i++){ cin >> B[i]; }\n\tif(M > W){ swap(M,W); swap(A,B); }\n\tmemset(memo,-1,sizeof(memo));\n\tcout << solve(0,0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, m, a[12], b[12], dp[1 << 12];\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tfor (int i = 0; i < m; i++) cin >> b[i];\n\tif (n < m) swap(n, m), swap(a, b);\n\tfor (int i = 1; i < (1 << n); i++) {\n\t\tint r = __builtin_popcount(i);\n\t\tif (r > m) continue;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tint p = abs(a[j] - b[r - 1]);\n\t\t\t\tdp[i] = max(dp[i], dp[i - (1 << j)] + p * (p - 30) * (p - 30));\n\t\t\t}\n\t\t}\n\t}\n\tcout << *max_element(dp, dp + (1 << n)) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, -1, 0};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n#define zclear(a) memset((a), 0, sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n#define show(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint n, m;\nint a[16], b[16];\nint memo[1 << 12][12];\n\nint getMax(int state, int u)\n{\n\tif (u == m || __builtin_popcount(state) == n) return (0);\n\tif (memo[state][u] >= 0) return (memo[state][u]);\n\t\n\tint ans = getMax(state, u + 1);\n\tfor (int i = 0; i < n; i++){\n\t\tif (state >> i & 1) continue;\n\t\tint p = abs(a[i] - b[u]);\n\t\tans = max(ans, getMax(state | (1 << i), u + 1) + p * (p - 30) * (p - 30));\n\t}\n\treturn (memo[state][u] = ans);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m) && n){\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", a + i);\n\t\tfor (int i = 0; i < m; i++) scanf(\"%d\", b + i);\n\t\t\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tprintf(\"%d\\n\", getMax(0, 0));\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[13][(1<<13)];\nvector<int> bmin;\nvector<int> bmax;\n\nint fn(int bm, int bw){\n  return abs(bm-bw)*pow((abs(bm-bw)-30),2);\n}\n\nint solve(int idx, int s){\n  \n  if(idx == bmin.size()) return dp[idx][s] = 0;\n  if(dp[idx][s] != -1) return dp[idx][s];\n  \n  int res = -1;\n  for(int i = 0; i < bmax.size(); i++){\n    int cost = fn(bmin[idx], bmax[i]);\n    if(s>>i & 1) continue;\n    res = max(res,solve(idx+1,s|(1<<i))+cost);\n  }\n  \n  return dp[idx][s] = res;\n\n}\n\nint main(){\n  \n  int M, W;\n  while(1){\n\n    vector<int> bm;\n    vector<int> bw;\n    cin >> M >> W;\n    if(M == 0 && W == 0) break;\n    bm.resize(M);\n    bw.resize(W);\n    for(int i = 0 ; i < M; i++) cin >> bm[i];\n    for(int i = 0 ; i < W; i++) cin >> bw[i];\n    \n\n    memset(dp,-1,sizeof(dp));\n    \n    if(M < W){\n      bmin = bm;\n      bmax = bw;\n    }else{\n      bmin = bw;\n      bmax = bm;\n    }\n    \n\n    cout << solve(0,0) << endl;\n    \n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define DPSIZE (1<<12)\n\nint M, W;\nint bm[12], bw[12];\nint dp[DPSIZE];\n\nint calcPower(int a, int b)\n{\n\tint num = a - b;\n\tif(num < 0) {\n\t\tnum *= -1;\n\t}\n\t\n\treturn num * (num - 30) * (num - 30);\n}\n\nint main()\n{\n\twhile(cin >> M >> W, M, W) {\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tcin >> bm[i];\n\t\t}\n\t\tfor(int i = 0; i < W; i++) {\n\t\t\tcin >> bw[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < DPSIZE; i++) {\n\t\t\tdp[i] = 0;\n\t\t}\n\t\t\n\t\tif(M < W) {\n\t\t\tswap(M, W);\n\t\t\tswap(bm, bw);\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < (1<<M)-1; i++) {\n\t\t\tif(i != 0 && dp[i] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tif(i & (1<<j)) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tif((i & (1<<j))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint next = (i | (1<<j));\n\t\t\t\tdp[next] = max(dp[next], dp[i] + ((cnt < W)? calcPower(bm[j], bw[cnt]): 0));\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << dp[(1<<M)-1] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[12][(1<<12)];\nvector<int> bmin;\nvector<int> bmax;\n\nint fn(int bm, int bw){\n  return abs(bm-bw)*pow((abs(bm-bw)-30),2);\n}\n\nint solve(int idx, int s){\n  \n  if(idx == bmin.size()) return dp[idx][s] = 0;\n  if(dp[idx][s] != -1) return dp[idx][s];\n  \n  int res = -1;\n  for(int i = 0; i < bmax.size(); i++){\n    int cost = fn(bmin[idx], bmax[i]);\n    if(s>>i & 1) continue;\n    res = max(res,solve(idx+1,s|(1<<i))+cost);\n  }\n  \n  return dp[idx][s] = res;\n\n}\n\nint main(){\n  \n  int M, W;\n  while(1){\n    //int bm[12], bw[12];\n    vector<int> bm;\n    vector<int> bw;\n    cin >> M >> W;\n    if(M == 0 && W == 0) break;\n    bm.resize(M);\n    bw.resize(W);\n    for(int i = 0 ; i < M; i++) cin >> bm[i];\n    for(int i = 0 ; i < W; i++) cin >> bw[i];\n    \n\n    memset(dp,-1,sizeof(dp));\n    \n    if(M < W){\n      bmin = bm;\n      bmax = bw;\n    }else{\n      bmin = bw;\n      bmax = bm;\n    }\n    \n\n    cout << solve(0,0) << endl;\n    \n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\n\nconst lli INF = 1LL<<60;\nconst lli MAXM = 13;\nconst lli MAXW = 13;\n\nlli M, W;\nlli bm[MAXM], bw[MAXW];\nlli dp[MAXM][1<<MAXW];\n\nlli f(lli bm, lli bw) {\n  return llabs(bm - bw) * (llabs(bm - bw) - 30LL) * (llabs(bm - bw) - 30LL);\n}\n\nint main() {\n  while(cin >> M >> W && (M|W)) {\n    for(lli i = 0; i < M; ++i) cin >> bm[i];\n    for(lli i = 0; i < W; ++i) cin >> bw[i];\n    fill(dp[0], dp[MAXM], -INF);\n    dp[0][0] = 0;\n    for(lli i = 0; i < M; ++i) {\n      for(lli j = (1<<W)-1; j >= 0; --j) {\n\tdp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n\tfor(lli k = 0; k < W; ++k) {\n\t  if(j >> k & 1) {\n\t    dp[i+1][j] = max(dp[i+1][j], dp[i][j-(1<<k)] + f(bm[i], bw[k]));\n\t  }\n\t}\n      }\n    }\n    lli res = 0;\n    for(lli j = (1<<W)-1; j >= 0; --j) {\n      res = max(res, dp[M][j]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nint M, W;\nvector<int> a, b;\nint dp[1<<12][1<<12];\nint calc(int s, int t)\n{\n    int k = abs(a[s] - b[t]);\n    return k * (k - 30) * (k - 30);\n}\nint dfs(int wbit, int mbit, int pos)\n{\n    if(pos >= W) return 0;\n    if(dp[wbit][mbit] != -1) return dp[wbit][mbit];\n    int res = dfs(wbit, mbit, pos + 1);\n    if(mbit & (1<<pos))\n    {\n        for(int i = 0; i < W; i++)\n        {\n            if(not (wbit & (1<<i)) or a[i] == b[pos]) continue;\n            res = max(res, dfs(wbit & ~(1<<i), mbit & ~(1<<pos), pos + 1) + calc(i, pos));\n        }\n    }\n    return dp[wbit][mbit] = res;\n}\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> M >> W, M or W)\n    {\n        memset(dp, -1, sizeof(dp));\n        a.resize(M);\n        b.resize(W);\n        for(int i = 0; i < M; i++) cin >> a[i];\n        for(int i = 0; i < W; i++) cin >> b[i];\n        if(M > W)\n        {\n            swap(M, W);\n            swap(a, b);\n        }\n        int ans = 0;\n        for(int bit = 0; bit < (1<<W); bit++)\n        {\n            if(__builtin_popcount(bit) != M) continue;\n            ans = max(ans, dfs((1<<M) - 1, bit, 0));\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < 12; i++)check[i] = false;\n\t}\n\n\tshort table[6],index;\n\tbool check[12];\n};\n\nvoid func(int M,int W){\n\tint m_data[M],w_data[W];\n\n\tfor(int i = 0; i < M; i++)scanf(\"%d\",&m_data[i]);\n\tfor(int i = 0; i < W; i++)scanf(\"%d\",&w_data[i]);\n\n\tint maximum = 0,tmp,select_num,num,left_index,right_index,left_tmp,right_tmp,left_max,right_max,limit,loc_left[7],loc_right[7],val;\n\n\tif(M == 1){\n\t\tfor(int i = 0; i < W; i++){\n\t\t\ttmp = abs(w_data[i] - m_data[0])*(abs(w_data[i] - m_data[0])-30)*(abs(w_data[i] - m_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else if(W == 1){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\ttmp = abs(m_data[i] - w_data[0])*(abs(m_data[i] - w_data[0])-30)*(abs(m_data[i] - w_data[0])-30);\n\t\t\tmaximum = max(maximum,tmp);\n\t\t}\n\t}else{\n\t\tif(M > W){\n\t\t\tselect_num = (M+1)/2;\n\n\t\t\tlimit = pow(2,M);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\t//??°???????????????????????????\n\t\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tqueue<Info> Q;\n\t\t\t\tInfo current,left_first,right_first;\n\n\t\t\t\tfor(int k = 0; k < left_index;k++){\n\t\t\t\t\tleft_first.check[loc_left[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(left_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == left_index){\n\t\t\t\t\t\tleft_tmp = 0;\n\t\t\t\t\t\tfor(int p = 0; p < (W+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - current.table[p]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < left_index; p++){\n\t\t\t\t\t\tif(current.check[loc_left[p]]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < 12; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = m_data[loc_left[p]];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int k = 0; k < right_index;k++){\n\t\t\t\t\tright_first.check[loc_right[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(right_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == right_index){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (W+1)/2; p < W;p++){\n\t\t\t\t\t\t\tval = abs(w_data[p] - current.table[p-((W+1)/2)]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < right_index; p++){\n\t\t\t\t\t\tif(current.check[loc_right[p]]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < 12; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = m_data[loc_right[p]];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\n\t\t}else{ //W >= M\n\t\t\tselect_num = (W+1)/2;\n\n\t\t\tlimit = pow(2,W);\n\t\t\tfor(int i = 0; i < limit;i++){\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k))num++;\n\t\t\t\t}\n\t\t\t\tif(num != select_num)continue;\n\n\t\t\t\tleft_index = right_index = 0;\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\t\tloc_left[left_index++] = k;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tloc_right[right_index++] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tleft_max = right_max = 0;\n\n\t\t\t\tqueue<Info> Q;\n\t\t\t\tInfo current,left_first,right_first;\n\n\t\t\t\tfor(int k = 0; k < left_index;k++){\n\t\t\t\t\tleft_first.check[loc_left[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(left_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == left_index){\n\t\t\t\t\t\tleft_tmp = 0;\n\n\t\t\t\t\t\tfor(int p = 0; p < (M+1)/2;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - current.table[p]);\n\t\t\t\t\t\t\tleft_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft_max = max(left_max,left_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < left_index; p++){\n\t\t\t\t\t\tif(current.check[loc_left[p]] == true){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < W; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = w_data[loc_left[p]];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int k = 0; k < right_index;k++){\n\t\t\t\t\tright_first.check[loc_right[k]] = true;\n\t\t\t\t}\n\n\t\t\t\tQ.push(right_first);\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tcurrent = Q.front();\n\t\t\t\t\tQ.pop();\n\n\t\t\t\t\tif(current.index == right_index){\n\t\t\t\t\t\tright_tmp = 0;\n\t\t\t\t\t\tfor(int p = (M+1)/2; p < M;p++){\n\t\t\t\t\t\t\tval = abs(m_data[p] - current.table[p-((M+1)/2)]);\n\t\t\t\t\t\t\tright_tmp += val*(val-30)*(val-30);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright_max = max(right_max,right_tmp);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int p = 0; p < right_index; p++){\n\t\t\t\t\t\tif(current.check[loc_right[p]]){\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tfor(int k = 0; k < W; k++)new_info.check[k] = current.check[k];\n\t\t\t\t\t\t\tfor(int k = 0; k < current.index;k++)new_info.table[k] = current.table[k];\n\t\t\t\t\t\t\tnew_info.table[current.index] = w_data[loc_right[p]];\n\t\t\t\t\t\t\tnew_info.check[p] = false;\n\t\t\t\t\t\t\tnew_info.index = current.index+1;\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaximum = max(maximum,left_max+right_max);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\tint M,W;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&M,&W);\n\t\tif(M == 0 && W == 0)break;\n\n\t\tfunc(M,W);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint dp[1 << 12][13], a[12], b[12];\nint main() {\n\tint m, w;\n\twhile (scanf(\"%d%d\", &m, &w), m) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(i, m)scanf(\"%d\", &a[i]);\n\t\trep(i, w)scanf(\"%d\", &b[i]);\n\t\trep(i, 1 << w)rep(j, m) {\n\t\t\trep(k, w) {\n\t\t\t\tif (i >> k & 1)continue;\n\t\t\t\tdp[i | 1 << k][j + 1] = max(dp[i | 1 << k][j + 1], dp[i][j] + abs(a[j] - b[k])*(int)pow(abs(a[j] - b[k]) - 30, 2));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp[0], dp[1 << w]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_V=100;\nconst int INF=1001001001;\nint S,T;\nstruct edge{\n    int to,cap,cost,rev;\n    edge(int to,int cap,int cost,int rev)\n        :to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nvector<edge>G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill_n(dist,MAX_V,INF);\n        dist[s]=0;\n        bool update=true;\n        while(update){\n            update=false;\n            for(int v=0;v<MAX_V;v++){\n                if(dist[v]==INF)continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n                        dist[e.to]=dist[v]+e.cost;\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        update=true;\n                    }\n                }\n            }\n        }\n\n        if(dist[t]==INF)return INF;\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            d=min(d,e.cap);\n        }\n\n        f-=d;\n        res+=d*dist[t];\n\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n\n\nint main(){\n    int M,W;\n    while(cin>>M>>W,M||W){\n        fill_n(G,MAX_V,vector<edge>());\n\n        vector<int>bm(M),bw(W);\n        for(int i=0;i<M;i++)cin>>bm[i];\n        for(int i=0;i<W;i++)cin>>bw[i];\n\n        S=98;T=99;\n\n        for(int i=0;i<M;i++)add_edge(S,i,1,0);\n        for(int i=0;i<W;i++)add_edge(i+M,T,1,0);\n\n        for(int i=0;i<M;i++){\n            for(int j=0;j<W;j++){\n                int ab=abs(bm[i]-bw[j]);\n                int val=ab*(ab-30)*(ab-30);\n                add_edge(i,j+M,1,-val);\n            }\n        }\n\n        cout<<-min_cost_flow(S,T,min(M,W))<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-2 0290: Microorganism Power Generation\n// 2017.8.17\n\n#include <stdio.h>\n#include <string.h>\n\nint bm[13], bw[13], f[13];\nint M, W;\nint max;\n\nvoid combi(int n, int e)\n{\n\tint i, d;\n\tif (n == M) { if (e > max) max = e; return; }\n\tfor (i = 0; i < W; i++) {\n\t\tif (f[i]) continue;\n\t\tf[i] = 1;\n\t\td = bm[n] - bw[i]; if (d < 0) d = -d;\n\t\tcombi(n + 1, e + d * (d - 30) * (d - 30));\n\t\tf[i] = 0;\n\t}\n}\n\nint main()\n{\n\tint i, t;\n\n\twhile (scanf(\"%d%d\", &M, &W) && M) {\n\t\tif (M <= W) {\n\t\t\tfor (i = 0; i < M; i++) scanf(\"%d\", bm + i);\n\t\t\tfor (i = 0; i < W; i++) scanf(\"%d\", bw + i);\n\t\t} else {\n\t\t\tfor (i = 0; i < M; i++) scanf(\"%d\", bw + i);\n\t\t\tfor (i = 0; i < W; i++) scanf(\"%d\", bm + i);\n\t\t\tt = M, M = W, W = t;\n\t\t}\n\t\tprintf(\"M %d, W %d\\n\", M, W);\n\n\t\tmax = 0;\n\t\tmemset(f, 0, sizeof(f));\n\t\tcombi(0, 0);\n\t\tprintf(\"%d\\n\", max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0290: Microorganism Power Generation\n// 2017.10.27 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint bm[14], bw[14], m, w;\nint tbl[14][14];\nint dp[14][4100];\n\nint main()\n{\n\tint i, j, k, d, x, lim;\n\n\twhile (scanf(\"%d%d\", &m, &w) && m > 0) {\n\t\tfor (i = 0; i < m; i++) scanf(\"%d\", bm + i);\n\t\tfor (j = 0; j < w; j++) scanf(\"%d\", bw + j);\n\n\t\tmemset(tbl, 0, sizeof(tbl));\n\t\tfor (i = 0; i < m; i++) for (j = 0; j < w; j++) {\n\t\t\td = bm[i] - bw[j]; if (d < 0) d = -d;\n\t\t\tx = d * (d - 30) * (d - 30);\n\t\t\ttbl[i][j] = x;\n\t\t}\n\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tdp[0][0] = 0;\n\t\tlim = 1 << w;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tfor (k = 0; k < lim; k++) if (dp[i][k] >= 0) {\n\t\t\t\tif (dp[i+1][k] < dp[i][k]) dp[i+1][k] = dp[i][k];\n\t\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\t\tif (k & (1<<j)) continue;\n\t\t\t\t\td = k | (1<<j);\n\t\t\t\t\tx = dp[i][k] + tbl[i][j];\n\t\t\t\t\tif (dp[i+1][d] < x) dp[i+1][d] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (x = 0, i = 0; i < lim; i++) if (dp[m][i] > x) x = dp[m][i];\n\t\tprintf(\"%d\\n\", x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-2 0290: Microorganism Power Generation\n// 2017.8.17\n\n#include <stdio.h>\n#include <string.h>\n\nint bm[13], bw[13], f[13];\nint M, W;\nint max;\n\nvoid combi(int n, int e)\n{\n\tint i, d;\n\tif (n == M) { if (e > max) max = e; return; }\n\tfor (i = 0; i < W; i++) {\n\t\tif (f[i]) continue;\n\t\tf[i] = 1;\n\t\td = bm[n] - bw[i]; if (d < 0) d = -d;\n\t\tcombi(n + 1, e + d * (d - 30) * (d - 30));\n\t\tf[i] = 0;\n\t}\n}\n\nint main()\n{\n\tint i, t;\n\n\twhile (scanf(\"%d%d\", &M, &W) && M) {\n\t\tif (M <= W) {\n\t\t\tfor (i = 0; i < M; i++) scanf(\"%d\", bm + i);\n\t\t\tfor (i = 0; i < W; i++) scanf(\"%d\", bw + i);\n\t\t} else {\n\t\t\tfor (i = 0; i < M; i++) scanf(\"%d\", bw + i);\n\t\t\tfor (i = 0; i < W; i++) scanf(\"%d\", bm + i);\n\t\t\tt = M, M = W, W = t;\n\t\t}\n\t\tmax = 0;\n\t\tmemset(f, 0, sizeof(f));\n\t\tcombi(0, 0);\n\t\tprintf(\"%d\\n\", max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0290: Microorganism Power Generation\n// 2017.10.27 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint bm[14], bw[14], m, w;\nint tbl[14][14];\nint dp[14][4100];\n\nint main()\n{\n\tint i, j, k, d, x, lim;\n\n\twhile (scanf(\"%d%d\", &m, &w) && m > 0) {\n\t\tfor (i = 0; i < m; i++) scanf(\"%d\", bm + i);\n\t\tfor (j = 0; j < w; j++) scanf(\"%d\", bw + j);\n\t\tmemset(tbl, 0, sizeof(tbl));\n\t\tfor (i = 0; i < m; i++) for (j = 0; j < w; j++) {\n\t\t\td = bm[i] - bw[j]; if (d < 0) d = -d;\n\t\t\tx = d * (d - 30) * (d - 30);\n\t\t\ttbl[i][j] = x;\n\t\t}\n\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tdp[0][0] = 0;\n\t\tlim = 1 << w;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tfor (k = 0; k < lim; k++) if (dp[i][k] >= 0) {\n\t\t\t\tif (dp[i+1][k] < dp[i][k]) dp[i+1][k] = dp[i][k];\n\t\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\t\tif (k & (1<<j)) continue;\n\t\t\t\t\td = k | (1<<j);\n\t\t\t\t\tx = dp[i][k] + tbl[i][j];\n\t\t\t\t\tif (dp[i+1][d] < x) dp[i+1][d] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[m][lim-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint max(int a,int b){\n  if(a>b){return a;}\n  return b;\n}\n\nint min(int a,int b){\n  if(a<b){return a;}\n  return b;\n}\n\nint zt(int a,int b){\n  return max(a,b)-min(a,b);\n}\n\nint val(int a,int b){\n  int z=zt(a,b);\n  return z*(z-30)*(z-30);\n}\n\nint main(){\n  int i,j,k,m,w,bm[16],bw[16];\n  int dp[4096];\n  while(scanf(\"%d%d\",&m,&w),m!=0){\n    for(i=0;i<4096;i++){\n      dp[i]=0;\n    }\n    for(i=0;i<m;i++){scanf(\"%d\",&bm[i]);}\n    for(i=0;i<w;i++){\n      scanf(\"%d\",&bw[i]);\n      for(j=(1<<m)-1;j>=0;j--){\n        for(k=0;k<m;k++){\n          if((j&(1<<k))!=0){continue;}\n          dp[j|(1<<k)]=max(dp[j]+val(bw[i],bm[k]),dp[j|(1<<k)]);\n        }\n      }\n    }\n    printf(\"%d\\n\",dp[(1<<m)-1]);\n  }\n}\n\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.abs\nimport java.util.*\n\nfun main(args:Array<String>):Unit {\n    while(true){\n        val (m, w) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (m == 0 && w == 0) return\n        val network = NetworkFlow(m, w)\n        val bm = readLine()!!.trim().split(' ').map(String::toInt).toIntArray()\n        val bw = readLine()!!.trim().split(' ').map(String::toInt).toIntArray()\n        for (mi in 0 until m){\n            for (wi in 0 until w){\n                network.addForwardNetwork(mi, wi, -energy(bm[mi], bw[wi]))\n            }\n        }\n        repeat(minOf(m, w)){\n            network.addFlow(minPath(network.currentNetwork()))\n        }\n        println(network.currentNetwork().flatMap { it.filter{it is Network.Backward}.map{ -it.cost }}.sum())\n    }\n}\nfun energy(bm:Int, bw:Int):Int {\n    val diff = abs(bm - bw)\n    return diff * ((diff - 30).let{it * it})\n}\ndata class Edge(val to:Int, val cost:Int)\nclass NetworkFlow(m:Int, w:Int){\n    private val mNetwork:Array<Array<Network>> = Array(m){Array(w){ Network.Forward(0) as Network }}\n    fun addForwardNetwork(from:Int, to:Int, cost:Int):Unit {\n        mNetwork[from][to] = Network.Forward(cost)\n    }\n    fun addFlow(flow:Iterable<Int>):Unit {\n        val f = flow.toList().toIntArray()\n        for (i in 0 until f.size step 2){\n            mNetwork[f[i]][f[i + 1]] = Network.Backward(mNetwork[f[i]][f[i + 1]].cost)\n        }\n        for (i in 2 until f.size step 2){\n            mNetwork[f[i]][f[i - 1]] = Network.Forward(mNetwork[f[i]][f[i - 1]].cost)\n        }\n    }\n    fun currentNetwork():Array<Array<Network>> = mNetwork//[from][to]　fromからtoへのネットワークが存在すればそのコスト。残余ネットワークが存在すれば　-コスト。x in 0 until mならばxはオスの微生物\n}\n\nfun minPath(network:Array<Array<Network>>):Iterable<Int> {\n    val minCost = Array(network.size + network[0].size + 2){Array(network.size + network[0].size + 2){Int.MAX_VALUE}}\n    val next = Array(minCost.size){Array(minCost.size){- 1}}\n    /*\n    オスもメスも区別せず最小パスを求める\n    事前条件　=> network[from][to]は現在存在するネットワークとコスト\n    next[from][to]はfromからtoへの最小コストネットワークにおけるfromの次のパス\n    minCost[from][to]はfromからtoへのネットワークのうち最小のもの\n     */\n    for (m in 0 until network.size){\n        for (w in 0 until network[m].size){\n            when(network[m][w]){\n                is Network.Forward -> {\n                    minCost[m][w + network.size] = network[m][w].cost\n                    next[m][w + network.size] = w + network.size\n                }\n                is Network.Backward -> {\n                    minCost[w + network.size][m] = -network[m][w].cost\n                    next[w + network.size][m] = m\n                }\n            }\n        }\n    }\n    for (m in 0 until network.size) {//start\n        if (network[m].all{it is Network.Forward}) {\n            minCost[minCost.size - 2][m] = 0\n            next[minCost.size - 2][m] = m\n        }\n    }\n    for (w in 0 until network[0].size) {//goal\n        if ((0 until network.size).all{network[it][w] is Network.Forward}) {\n            minCost[w + network.size][minCost.size - 1] = 0\n            next[w + network.size][minCost.size - 1] = minCost.size - 1\n        }\n    }\n    for (mid in 0 until minCost.size) for (from in 0 until minCost.size) for (to in 0 until minCost.size){\n        if (minCost[from][mid] != Int.MAX_VALUE && minCost[mid][to] != Int.MAX_VALUE && minCost[from][to] > minCost[from][mid] + minCost[mid][to]){\n            minCost[from][to] = minCost[from][mid] + minCost[mid][to]\n            next[from][to] = next[from][mid]\n        }\n    }\n    val stack = Stack<Int>()\n    var current = minCost.size - 2\n    while (current != minCost.size - 1){\n        current = next[current][minCost.size - 1]\n        stack.push(if (current >= network.size) current - network.size else current)\n    }\n    stack.pop()\n    return stack\n}\nsealed class Network(val cost:Int){\n    class Forward(cost:Int):Network(cost)\n    class Backward(cost:Int):Network(cost)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String S;\n\tstatic int p;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(m == 0 && w == 0) break;\n\t\t\tint[] bm = new int[m];\n\t\t\tint[] bw = new int[w];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbm[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tbw[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint t = 1 << m << w;\n\t\t\tint[] dp = new int[t];\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint p = 1 << j << w;\n\t\t\t\t\tif ((i & p) != 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\t\t\tif ((i & (1 << k)) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint a = i | p | (1 << k);\n\t\t\t\t\t\tdp[a] = Math.max(dp[a],dp[i] + Math.abs(bm[j] - bw[k]) * (Math.abs(bm[j] - bw[k]) - 30) * (Math.abs(bm[j] - bw[k]) - 30));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dp[(1 << m << w) - 1]);\n\t\t}\n\n\n\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint M = scanner.nextInt();\n\t\t\tint W = scanner.nextInt();\n\t\t\tif ((M | W) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] bm = new int[M];\n\t\t\tfor (int i = 0; i < M; i++)\n\t\t\t\tbm[i] = scanner.nextInt();\n\t\t\tint[] bw = new int[W];\n\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\tbw[i] = scanner.nextInt();\n\t\t\tint[] dp = new int[1 << W];\n\t\t\t\tArrays.fill(dp, -1);\n\t\t\tdp[0] = 0;\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tfor (int j = (1 << W) - 2; j >= 0; j--) {\n\t\t\t\t\tif (dp[j] == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int k = 0; k < W; k++) {\n\t\t\t\t\t\tif (((j >> k) & 1) == 1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint a = j | 1 << k;\n\t\t\t\t\t\tint b = (int) (Math.abs(bm[i] - bw[k]) * Math.pow(\n\t\t\t\t\t\t\t\tMath.abs(bm[i] - bw[k]) - 30, 2));\n\t\t\t\t\t\tdp[a] = Math.max(dp[a], dp[j] + b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < 1 << W; i++) {\n\t\t\t\tmax = Math.max(max, dp[i]);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint M = scanner.nextInt();\n\t\t\tint W = scanner.nextInt();\n\t\t\tif ((M | W) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] bm = new int[M];\n\t\t\tfor (int i = 0; i < M; i++)\n\t\t\t\tbm[i] = scanner.nextInt();\n\t\t\tint[] bw = new int[W];\n\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\tbw[i] = scanner.nextInt();\n\t\t\tint[] dp = new int[1 << W];\n\t\t\tArrays.fill(dp, -1);\n\t\t\tdp[0] = 0;\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tfor (int j = (1 << W) - 2; j >= 0; j--) {\n\t\t\t\t\tif (dp[j] == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int k = 0; k < W; k++) {\n\t\t\t\t\t\tif (((j >> k) & 1) == 1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint a = j | 1 << k;\n\t\t\t\t\t\tint b = (int) (Math.abs(bm[i] - bw[k]) * Math.pow(\n\t\t\t\t\t\t\t\tMath.abs(bm[i] - bw[k]) - 30, 2));\n\t\t\t\t\t\tdp[a] = Math.max(dp[a], dp[j] + b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * int max = 0; for (int i = 0; i < 1 << W; i++) { max =\n\t\t\t * Math.max(max, dp[i]); } System.out.println(max);\n\t\t\t */\n\t\t\tSystem.out.println(dp[(1 << W) - 1]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String S;\n\tstatic int p;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(m == 0 && w == 0) break;\n\t\t\tlong[] bm = new long[m];\n\t\t\tlong[] bw = new long[w];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbm[i] = sc.nextLong();\n\t\t\t}\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tbw[i] = sc.nextLong();\n\t\t\t}\n\t\t\tlong[][] dp = new long[m+1][1 << w];\n\t\t\tfor(int i = 0; i < m+1; i++) {\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t}\n\t\t\tdp[0][0] = 0;\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tfor(int j = 0; j < 1 << w; j++) {\n\t\t\t\t\tif(dp[i][j] == -1) continue;\n\t\t\t\t\tdp[i+1][j] = Math.max(dp[i+1][j], dp[i][j]);\n\t\t\t\t\tfor(int k = 0; k < w; k++) {\n\t\t\t\t\t\tif((j & 1 << k) != 0) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tdp[i+1][j | 1 << k] = Math.max(dp[i+1][j | 1 << k], dp[i][j] + Math.abs(bm[i] - bw[k]) * (Math.abs(bm[i] - bw[k])-30) * (Math.abs(bm[i] - bw[k])-30));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(dp[m][(1 << w) -1]);\n\t\t}\n\n\n\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String S;\n\tstatic int p;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(m == 0 && w == 0) break;\n\t\t\tint[] bm = new int[m];\n\t\t\tint[] bw = new int[w];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbm[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tbw[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[] dp = new int[1 << m << w];\n\t\t\tfor (int i = 0; i < 1 << m << w; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\t\t\tif ((i & (1 << j << w)) != 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((i & (1 << k)) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdp[i | (1 << j << w) | (1 << k)] = (int) Math.max(\n\t\t\t\t\t\t\t\tdp[i | (1 << j << w) | (1 << k)],\n\t\t\t\t\t\t\t\tdp[i]\n\t\t\t\t\t\t\t\t\t\t+ Math.abs(bm[j] - bw[k])\n\t\t\t\t\t\t\t\t\t\t* Math.pow(\n\t\t\t\t\t\t\t\t\t\t\t\t(Math.abs(bm[j] - bw[k]) - 30),\n\t\t\t\t\t\t\t\t\t\t\t\t2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dp[(1 << m << w) - 1]);\n\t\t}\n\n\t\t\n\t\t\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String S;\n\tstatic int p;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(m == 0 && w == 0) break;\n\t\t\tint[] bm = new int[m];\n\t\t\tint[] bw = new int[w];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbm[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tbw[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[] dp = new int[1 << m << w];\n\t\t\tfor (int i = 0; i < 1 << m << w; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif ((i & (1 << j << w)) != 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\t\t\tif ((i & (1 << k)) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint a = i | (1 << j << w) | (1 << k);\n\t\t\t\t\t\tdp[a] = Math.max(dp[a],dp[i] + Math.abs(bm[j] - bw[k]) * (Math.abs(bm[j] - bw[k]) - 30) * (Math.abs(bm[j] - bw[k]) - 30));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dp[(1 << m << w) - 1]);\n\t\t}\n\n\n\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String S;\n\tstatic int p;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(m == 0 && w == 0) break;\n\t\t\tint[] bm = new int[m];\n\t\t\tint[] bw = new int[w];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbm[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tbw[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[][] dp = new int[m+1][1 << w];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tfor(int j = 0; j < 1 << w; j++) {\n\t\t\t\t\tfor(int k = 0; k < w; k++) {\n\t\t\t\t\t\tif((j & 1 << k) != 0) continue;\n\t\t\t\t\t\tdp[i+1][j | 1 << k] = Math.max(dp[i+1][j | 1 << k], dp[i][j] + Math.abs(bm[i] - bw[k]) * (Math.abs(bm[i] - bw[k])-30) * (Math.abs(bm[i] - bw[k])-30));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < m+1; i++) {\n\t\t\t\tmax = Math.max(max, dp[i][(1 << w) -1]);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\n\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String S;\n\tstatic int p;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(m == 0 && w == 0) break;\n\t\t\tint[] bm = new int[m];\n\t\t\tint[] bw = new int[w];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbm[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tbw[i] = sc.nextInt();\n\t\t\t}\n\t\t\tlong[][] dp = new long[m+1][1 << w];\n\t\t\tfor(int i = 0; i < m+1; i++) {\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t}\n\t\t\tdp[0][0] = 0;\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tfor(int j = 0; j < 1 << w; j++) {\n\t\t\t\t\tif(dp[i][j] == -1) continue;\n\t\t\t\t\tdp[i+1][j] = Math.max(dp[i+1][j], dp[i][j]);\n\t\t\t\t\tfor(int k = 0; k < w; k++) {\n\t\t\t\t\t\tif((j & 1 << k) != 0) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tdp[i+1][j | 1 << k] = Math.max(dp[i+1][j | 1 << k], dp[i][j] + Math.abs(bm[i] - bw[k]) * (Math.abs(bm[i] - bw[k])-30) * (Math.abs(bm[i] - bw[k])-30));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(dp[m][(1 << w) -1]);\n\t\t}\n\n\n\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint M = scanner.nextInt();\n\t\t\tint W = scanner.nextInt();\n\t\t\tif ((M | W) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] bm = new int[M];\n\t\t\tfor (int i = 0; i < M; i++)\n\t\t\t\tbm[i] = scanner.nextInt();\n\t\t\tint[] bw = new int[W];\n\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\tbw[i] = scanner.nextInt();\n\t\t\tint[] dp = new int[1 << W];\n\n\t\t\tArrays.fill(dp, -1);\n\t\t\tdp[0] = 0;\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tfor (int j = (1 << W) - 1; j >= 0; j--) {\n\t\t\t\t\tif (dp[j] == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int k = 0; k < W; k++) {\n\t\t\t\t\t\tif (((j >> k) & 1) == 1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint a = j | 1 << k;\n\t\t\t\t\t\tint b = (int) (Math.abs(bm[i] - bw[k]) * Math.pow(\n\t\t\t\t\t\t\t\tMath.abs(bm[i] - bw[k]) - 30, 2));\n\t\t\t\t\t\tdp[a] = Math.max(dp[a], dp[j] + b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < 1 << W; i++) {\n\t\t\t\tmax = Math.max(max, dp[i]);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String S;\n\tstatic int p;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(m == 0 && w == 0) break;\n\t\t\tlong[] bm = new long[m];\n\t\t\tlong[] bw = new long[w];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbm[i] = sc.nextLong();\n\t\t\t}\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tbw[i] = sc.nextLong();\n\t\t\t}\n\t\t\tlong[][] dp = new long[m+1][1 << w];\n\t\t\tfor(int i = 0; i < m+1; i++) {\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t}\n\t\t\tdp[0][0] = 0L;\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tfor(int j = 0; j < 1 << w; j++) {\n\t\t\t\t\tif(dp[i][j] == -1) continue;\n\t\t\t\t\tdp[i+1][j] = Math.max(dp[i+1][j], dp[i][j]);\n\t\t\t\t\tfor(int k = 0; k < w; k++) {\n\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\tdp[i+1][j | (1 << k)] = Math.max(dp[i+1][j | (1 << k)], dp[i][j] + Math.abs(bm[i] - bw[k]) * ((Math.abs(bm[i] - bw[k])-30) * (Math.abs(bm[i] - bw[k])-30)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(dp[m][(1 << w)-1]);\n\t\t}\n\n\n\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String S;\n\tstatic int p;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(m == 0 && w == 0) break;\n\t\t\tint[] bm = new int[m];\n\t\t\tint[] bw = new int[w];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbm[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tbw[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[] dp = new int[1 << m << w];\n\t\t\tfor (int i = 0; i < 1 << m << w; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif ((i & (1 << j << w)) != 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\t\t\tif ((i & (1 << k)) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i | (1 << j << w) | (1 << k)] = Math.max(dp[i | (1 << j << w) | (1 << k)],dp[i] + Math.abs(bm[j] - bw[k]) * (Math.abs(bm[j] - bw[k]) - 30) * (Math.abs(bm[j] - bw[k]) - 30));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dp[(1 << m << w) - 1]);\n\t\t}\n\n\n\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String S;\n\tstatic int p;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(m == 0 && w == 0) break;\n\t\t\tlong[] bm = new long[m];\n\t\t\tlong[] bw = new long[w];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbm[i] = sc.nextLong();\n\t\t\t}\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tbw[i] = sc.nextLong();\n\t\t\t}\n\t\t\tlong[][] dp = new long[m+1][1 << w];\n\t\t\tfor(int i = 0; i < m+1; i++) {\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t}\n\t\t\tdp[0][0] = 0L;\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tfor(int j = 0; j < (1 << w); j++) {\n\t\t\t\t\tif(dp[i][j] == -1) continue;\n\t\t\t\t\tdp[i+1][j] = Math.max(dp[i+1][j], dp[i][j]);\n\t\t\t\t\tfor(int k = 0; k < w; k++) {\n\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\tdp[i+1][j | (1 << k)] = Math.max(dp[i+1][j | (1 << k)], dp[i][j] + Math.abs(bm[i] - bw[k]) * ((Math.abs(bm[i] - bw[k])-30) * (Math.abs(bm[i] - bw[k])-30)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong max = 0;\n\t\t\tfor(int i = 0; i < (1 << w); i++) {\n\t\t\t\tmax = Math.max(dp[m][i], max);\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\n\n\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var m = int.Parse(line[0]);\n            var w = int.Parse(line[1]);\n            if (m == 0 && w == 0) break;\n            line = Console.ReadLine().Trim().Split(' ');\n            var bm = Array.ConvertAll(line, int.Parse);\n            line = Console.ReadLine().Trim().Split(' ');\n            var bw = Array.ConvertAll(line, int.Parse);\n            var dp = new int[m + 1, 1 << w];\n            for (int i = 0; i < m + 1; i++)\n                for (int j = 0; j < (1 << w); j++) dp[i, j] = -1;\n            var ans = goDP(dp, bm, bw, m, w);\n            Console.WriteLine(ans);\n        }\n    }\n    static int goDP(int[,] dp, int[] bm, int[] bw, int m, int w)\n    {\n        var ans = 0;\n        dp[0, 0] = 0;\n        var kmax = 1 << w;\n        for (int i = 0; i < m; i++)\n            for (int k = 0; k < kmax; k++)\n            {\n                if (dp[i, k] == -1) continue;\n                dp[i + 1, k] = Max(dp[i + 1, k], dp[i, k]);\n                for (int j = 0; j < w; j++)\n                {\n                    var ww = 1 << j;\n                    if ((k & ww) >= 1) continue;\n                    var t = (k | ww);\n                    dp[i + 1, t] = Max(dp[i + 1, t], dp[i, k] + calcEP(bm[i], bw[j]));\n                    ans = Max(ans, dp[i + 1, t]);\n                }\n            }\n        return ans;\n    }\n    static int calcEP(int m, int b)\n    {\n        var w = Abs(m - b);\n        return w * (w - 30) * (w - 30);\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "def cost(m, w)\n  (m - w).abs * (((m - w).abs - 30) ** 2)\nend\n\nuntil gets.split.map(&:to_i).all?(&:zero?)\n  m = gets.split.map(&:to_i)\n  w = gets.split.map(&:to_i)\n\n   dp = [[0] * (1 << w.size)] * (m.size + 1)\n\n  m.size.times do |i|\n    (1 << w.size).times do |bit|\n      w.size.times do |j|\n        next if bit[j].zero?\n        dp[i][bit] = [dp[i][bit], dp[i - 1][bit ^ (1 << j)] + cost(m[i], w[j])].max\n      end\n    end\n  end\n\n  p dp[m.size - 1].max\nend"
  },
  {
    "language": "Ruby",
    "code": "def cost(m, w)\n  (m - w).abs * (((m - w).abs - 30) ** 2)\nend\n\nuntil gets.split.map(&:to_i).all?(&:zero?)\n  m = gets.split.map(&:to_i)\n  w = gets.split.map(&:to_i)\n\n   dp = Array.new(m.size + 1){Array.new(1 << w.size, 0)}\n\n  m.size.times do |i|\n    (1 << w.size).times do |bit|\n      w.size.times do |j|\n        next if bit[j].zero?\n        dp[i][bit] = [dp[i - 1][bit], dp[i][bit], dp[i - 1][bit ^ (1 << j)] + cost(m[i], w[j])].max\n      end\n    end\n  end\n\n  p dp[m.size - 1].max\nend"
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom collections import deque\nfrom enum import Enum\nimport sys\nimport math\nfrom _heapq import heappush, heappop\nimport copy\nfrom test.support import _MemoryWatchdog\n\nBIG_NUM = 2000000000\nHUGE_NUM = 99999999999999999\n#MOD = 1000000007\nMOD = 10000\nEPS = 0.000000001\nsys.setrecursionlimit(100000)\n\n\nSIZE = 13\nPOW = [1] * (SIZE)\nfor i in range(1,SIZE):\n    POW[i] = POW[i-1]*2\n\nwhile True:\n    M,W = map(int,input().split())\n    if M == 0 and W == 0:\n        break\n\n    table = []\n\n    table.append(list(map(int,input().split()))) #Mの読み込み\n    table.append(list(map(int,input().split()))) #Wの読み込み\n\n    small = None\n    large = None\n    if M < W:\n        small = 0\n        large = 1\n    else:\n        small = 1\n        large = 0\n\n    len_small = len(table[small])\n    len_large = len(table[large])\n\n    dp = [[-BIG_NUM]*POW[len_large] for _ in range(len_small+1)] #要素数が大きい方を常態化する(少ない方は全部使うため)\n\n    ans = 0\n    dp[0][0] = 0 #dp[少ない方のインデックス(1開始)][多い方の使用状態] = 最大値\n\n    for i in range(len_small): #今回マッチさせる微生物のループ(少ない側)\n        for state in range(0,POW[len_large]): #既に使った微生物のループ(大きい側)\n            if dp[i][state] == -BIG_NUM:\n                continue\n            for k in range(len_large):\n                if state & POW[k] != 0:\n                    continue\n                next_state = state+POW[k]\n                next_value = dp[i][state]+abs(table[small][i]-table[large][k])* \\\n                    (abs(table[small][i]-table[large][k])-30)*(abs(table[small][i]-table[large][k])-30)\n\n                dp[i+1][next_state] = max(dp[i+1][next_state],next_value)\n                ans = max(ans,next_value)\n\n    print(\"%d\"%(ans))\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from sys import stdin\n    f_i = stdin\n    \n    def f(bm_i, bw_i):\n        if bm_i > bw_i:\n            d = bm_i - bw_i\n        else:\n            d = bw_i - bm_i\n        return d * (d - 30) ** 2\n    \n    while True:\n        M, W = map(int, f_i.readline().split())\n        if M == 0:\n            break\n        \n        bm = list(map(int, f_i.readline().split()))\n        bw = list(map(int, f_i.readline().split()))\n        \n        e_gen = [[f(m, w) for w in bw] for m in bm]\n        \n        bit_size = (1 << W)\n        dp1 = [-1] * bit_size\n        dp2 = [-1] * bit_size\n        dp1[0] = 0\n        dp2[0] = 0\n        add_bit = [1 << i for i in range(W)]\n        \n        for i in range(M):\n            for s1, e1 in enumerate(dp1):\n                if e1 == -1:\n                    continue\n                for b, e in zip(add_bit, e_gen[i]):\n                    if s1 & b:\n                        continue\n                    s2 = s1 | b\n                    e2 = e1 + e\n                    if e2 > dp2[s2]:\n                        dp2[s2] = e2\n            dp1 = dp2[:]\n        print(max(dp2))\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import itertools as ite\nimport math\n\nINF = 10 ** 18\n\nwhile True:\n    M, W = map(int, raw_input().split())\n    if M == 0:\n        break\n    bm = map(int, raw_input().split())\n    bw = map(int, raw_input().split())\n    if M < W:\n        M, W = W, M\n        bm, bw = bw, bm\n    DP = [0] * (1 << M)\n    for i in range(1 << M):\n        cnt = 0\n        for j in range(M):\n            if i & (1 << j):\n                cnt += 1\n        if cnt > W:\n            continue\n        for j in range(M):\n            if i & (1 << j):\n                num = abs(bw[cnt - 1] - bm[j]) * (abs(bw[cnt - 1] - bm[j]) - 30) ** 2\n                DP[i] = max(DP[i], DP[i - (1 << j)] + num)\n    print max(DP)\n\n"
  },
  {
    "language": "Python",
    "code": "def get_energy(bm, bw):\n    tmp = abs(bm-bw)\n    return tmp * ((tmp-30) ** 2)\n\ndef calc(bsa, bla):\n    value = 0\n\n    if not bsa:\n        return 0\n\n    bs = bsa.pop()\n    sz = len(bla)\n    for i in range(sz):\n        bl = bla.pop(i)\n        tmp = get_energy(bl, bs) + calc(bsa, bla)\n        if tmp > value:\n            value = tmp\n        bla.insert(i, bl)\n    bsa.append(bs)\n    return value\n\nwhile True:\n    s = map(int, raw_input().split())\n    M = s[0]\n    W = s[1]\n    if M == 0 and N == 0:\n        break\n    if M <= W:\n        bsa = map(int, raw_input().split())\n        bla = map(int, raw_input().split())\n    else:\n        bla = map(int, raw_input().split())\n        bsa = map(int, raw_input().split())\n\n    print \"%d\" % calc(bsa, bla)"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        G = self.G\n        G[fr].append([to, cap, cost, len(G[to])])\n        G[to].append([fr, 0, -cost, len(G[fr])-1])\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [0]*N\n\n        while f:\n            dist = [INF]*N\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                for i, (w, cap, cost, _) in enumerate(G[v]):\n                    if cap > 0 and dist[w] > dist[v] + cost + H[v] - H[w]:\n                        dist[w] = r = dist[v] + cost + H[v] - H[w]\n                        prv_v[w] = v; prv_e[w] = i\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return -1\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, G[prv_v[v]][prv_e[v]][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = G[prv_v[v]][prv_e[v]]\n                e[1] -= d\n                G[v][e[3]][1] += d\n                v = prv_v[v]\n        return res\n\nwhile 1:\n    M, W = map(int, input().split())\n    if M == W == 0:\n        break\n    *A, = map(int, input().split())\n    *B, = map(int, input().split())\n    mcf = MinCostFlow(M+W+2)\n    for i in range(M):\n        mcf.add_edge(0, i+1, 1, 0)\n    for i in range(M):\n        for j in range(W):\n            d = abs(A[i] - B[j])\n            mcf.add_edge(i+1, M+1+j, 1, -d*(d-30)*(d-30))\n    for i in range(W):\n        mcf.add_edge(M+1+i, M+W+1, 1, 0)\n    print(-mcf.flow(0, M+W+1, min(M, W)))\n"
  },
  {
    "language": "Python",
    "code": "def get_energy(bm, bw):\n    tmp = abs(bm-bw)\n    return tmp * ((tmp-30) ** 2)\n\ndef calc(bsa, bla):\n    value = 0\n\n    if not bsa:\n        return 0\n\n    bs = bsa.pop()\n    sz = len(bla)\n    for i in range(sz):\n        bl = bla.pop(i)\n        tmp = get_energy(bl, bs) + calc(bsa, bla)\n        if tmp > value:\n            value = tmp\n        bla.insert(i, bl)\n    bsa.append(bs)\n    return value\n\nwhile True:\n    s = map(int, raw_input().split())\n    M = s[0]\n    W = s[1]\n    if M == 0 and W == 0:\n        break\n    if M <= W:\n        bsa = map(int, raw_input().split())\n        bla = map(int, raw_input().split())\n    else:\n        bla = map(int, raw_input().split())\n        bsa = map(int, raw_input().split())\n\n    print \"%d\" % calc(bsa, bla)"
  },
  {
    "language": "Python",
    "code": "def main():\n  while True:\n    m, w = map(int, input().split())\n    if m == 0:\n      break\n  \n    if m >= w:\n      long_lst = list(map(int, input().split()))\n      short_lst = list(map(int, input().split()))\n      rest = 2 ** m - 1\n    else:\n      short_lst = list(map(int, input().split()))\n      long_lst = list(map(int, input().split()))\n      rest = 2 ** w - 1\n    mem = [None] * (rest + 1)\n  \n    def elec(bm, bw):\n      bd = abs(bm - bw)\n      return bd * (bd - 30) ** 2\n  \n    def score(rest, index):\n      if mem[rest] != None:\n        return mem[rest]\n      if rest == 0 or index < 0:\n        return 0\n  \n      mask = 1\n      count = 0\n      ret = 0\n      while mask <= rest:\n        if mask & rest:\n          new_rest = rest & ~mask\n          ret = max(ret, score(new_rest, index - 1) + elec(short_lst[index], long_lst[count]))\n        mask <<= 1\n        count += 1\n  \n      mem[rest] = ret\n      return ret\n  \n    print(score(rest, min(m, w) - 1))\n  \nmain()\n"
  },
  {
    "language": "Python",
    "code": "def get_energy(bm, bw):\n    tmp = abs(bm-bw)\n    return tmp * ((tmp-30) ** 2)\n\ndef calc(bsa, bla):\n    value = 0\n\n    if not bsa:\n        return 0\n\n    bs = bsa.pop()\n    sz = len(bla)\n    for i in range(sz):\n        bl = bla.pop(i)\n        tmp = get_energy(bl, bs) + calc(bsa, bla)\n        if tmp > value:\n            value = tmp\n        bla.insert(i, bl)\n    bsa.append(bs)\n    return value\n\ns = map(int, raw_input().split())\nM = s[0]\nW = s[1]\nif M <= W:\n    bsa = map(int, raw_input().split())\n    bla = map(int, raw_input().split())\nelse:\n    bla = map(int, raw_input().split())\n    bsa = map(int, raw_input().split())\n\nprint \"%d\" % calc(bsa, bla)"
  },
  {
    "language": "Python",
    "code": "def get_energy(bm, bw):\n    tmp = abs(bm-bw)\n    return tmp * ((tmp-30) ** 2)\n\ndef calc(bsa, bla):\n    value = 0\n\n    if not bsa:\n        return 0\n\n    bs = bsa.pop()\n    sz = len(bla)\n    for i in range(sz):\n        bl = bla.pop(i)\n        tmp = get_energy(bl, bs) + calc(bsa, bla)\n        if tmp > value:\n            value = tmp\n        bla.insert(i, bl)\n    bsa.append(bs)\n    return value\n\ns = map(int, raw_input().split())\nM = s[0]\nW = s[1]\nif M <= W:\n    bsa = map(int, raw_input().split())\n    bla = map(int, raw_input().split())\nelse:\n    bla = map(int, raw_input().split())\n    bsa = map(int, raw_input().split())\n\nprint \"%d\" % calc(bsa, bla)"
  }
]