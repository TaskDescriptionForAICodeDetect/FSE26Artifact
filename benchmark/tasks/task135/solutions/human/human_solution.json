[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\nint main() {\n\tint n = ri();\n\tint r = ri();\n\tint t[n], e[n];\n\tfor (int i = 0; i < n; i++) t[i] = ri(), e[i] = ri();\n\tstd::vector<std::pair<int, int> > hen[n];\n\tfor (int i = 0; i < r; i++) {\n\t\tint a = ri() - 1;\n\t\tint b = ri() - 1;\n\t\tint c = ri() - 1;\n\t\then[b].push_back({a, c});\n\t}\n\ttypedef std::pair<int, int> T;\n\tstd::priority_queue<T, std::vector<T>, std::greater<T> > que;\n\tfor (int i = 0; i < n; i++) que.push({t[i], i});\n\twhile (que.size()) {\n\t\tauto cur = que.top();\n\t\tque.pop();\n\t\tif (cur.first != t[cur.second]) continue;\n\t\tfor (auto j : hen[cur.second]) {\n\t\t\tif (t[j.first] > t[cur.second] + j.second) {\n\t\t\t\tt[j.first] = t[cur.second] + j.second;\n\t\t\t\tque.push({t[j.first], j.first});\n\t\t\t}\n\t\t}\n\t}\n\tint64_t res = 0;\n\tfor (int i = 0; i < n; i++) res += (int64_t) t[i] * e[i];\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<iomanip>\n#include<vector>\n#include<set>\n#include<queue>\n#include<utility>\n#include<map>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\n\n#define LL long long\n#define PB push_back\n#define MP make_pair\n#define INT_MAX 2147483647\n\nusing namespace std;\n\nint N, R;\nLL t[100000], e[100000];\nint a[100000], b[100000];\nLL c[100000];\nvector<pair<int, LL>> rule[100000];\n\nint main() {\n\tcin >> N >> R;\n\tfor (int i = 0; i < N; i++) cin >> t[i] >> e[i];\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i];\n\t\ta[i]--; b[i]--;\n\t}\n\n\tset<pair<LL, int>> st;\n\tfor (int i = 0; i < N; i++) {\n\t\tst.insert(MP(t[i], i));\n\t}\n\tfor (int i = 0; i < R; i++) {\n\t\trule[b[i]].PB(MP(a[i], c[i]));\n\t}\n\n\twhile (st.size() > 0) {\n\t\tint i = st.begin()->second;\n\t\tst.erase(st.begin());\n\t\tfor (int j = 0; j < rule[i].size(); j++) {\n\t\t\tint memo = t[rule[i][j].first];\n\t\t\tif (memo > t[i] + rule[i][j].second - 1) {\n\t\t\t\tt[rule[i][j].first] = t[i] + rule[i][j].second - 1;\n\t\t\t\tauto itr = st.find(MP(memo, rule[i][j].first));\n\t\t\t\tst.erase(itr);\n\t\t\t\tst.insert(MP(t[rule[i][j].first], rule[i][j].first));\n\t\t\t}\n\t\t}\n\t}\n\n\tLL ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tans += t[i] * e[i];\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/* Dijkstra O(NlogM)*/\n\ntemplate <typename Type = int>\nstruct Dijkstra{\n  int V;\n  vector<vector<pair<int,Type>>> G;\n  vector<Type> cost;\n\n  Dijkstra(int n):\n    V(n), G(n, vector<pair<int,Type>>()) {}\n\n  void add_edge(int u, int v, Type c){\n    G[u].push_back({v, c});\n  }\n\n  Type solve(int s, int g = -1){\n    cost.assign(V, -1);\n    priority_queue<pair<Type,int>> pq;\n    Type max_cost = 0;\n\n    pq.push({0, s});\n\n    while(pq.size()){\n      Type now_cost = pq.top().first;\n      int now = pq.top().second;\n      pq.pop();\n\n      if(cost[now] >= 0) continue;\n\n      cost[now] = -now_cost;\n      max_cost = max(max_cost, -now_cost);\n\n      if(now == g) return -now_cost;\n\n      for(int i=0; i<(int)G[now].size(); i++)\n        pq.push({now_cost - G[now][i].second, G[now][i].first});\n    }\n\n    return max_cost;\n  }\n};\n\nint t[SIZE], e[SIZE];\n\nint main(){\n  int N, R;\n\n  scanf(\"%d%d\", &N, &R);\n\n  Dijkstra<ll> dijk(N+1);\n\n  int S = N;\n\n  for (int i=0; i<N; i++) {\n    scanf(\"%d%d\", t+i, e+i);\n    dijk.add_edge(S, i, t[i]);\n  }\n\n  for (int i=0; i<R; i++) {\n    int a, b, c;\n    scanf(\"%d%d%d\", &a, &b, &c);\n    a--; b--;\n    dijk.add_edge(b, a, c-1);\n  }\n\n  dijk.solve(S);\n\n  ll ans = 0;\n\n  for (int i=0; i<N; i++) {\n    ans += dijk.cost[i] * e[i];\n  }\n\n  cout << ans << endl;\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n\nsigned main(){\n\tvector<int> num, in;\n\tvector<vector<pair<int,int>>> G;\n\tpriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> Q;\n\tint N, R, sum = 0;\n\t\n\tcin>>N>>R;\n\t\n\tG.resize(N);\n\tnum.resize(N);\n\tin.resize(N);\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tint t, e;\n\t\tcin>>t>>e;\n\t\tnum[i] = t;\n\t\tin[i] = e;\n\t\tQ.push(make_pair(t,i));\n\t}\n\t\n\tfor(int i = 0; i < R; i++){\n\t\tint a, b, c;\n\t\t\n\t\tcin>>a>>b>>c;\n\t\ta--, b--;\n\t\t\n\t\tG[b].push_back(make_pair(a,c));\n\t}\n\t\n\twhile(!Q.empty()){\n\t\tpair<int,int> p = Q.top(); Q.pop();\n\t\t\n\t\tif(num[p.second] > p.first) continue;\n\t\t\n\t\tfor(pair<int,int> next : G[p.second]){\n\t\t\tif(num[next.first] > num[p.second] + next.second - 1){\n\t\t\t\tnum[next.first] = num[p.second] + next.second - 1;\n\t\t\t\tQ.push(make_pair(num[next.first], next.first));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tsum += in[i] * num[i];\n\t}\n\t\n\tcout<<sum<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx\")\n#endif\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing VI = vector<int>;\nusing VVI = vector<vector<int>>;\nusing VLL = vector<ll>;\nusing VVLL = vector<vector<ll>>;\nusing VB = vector<bool>;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\ntemplate <typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int INF = 1000000007;\nconstexpr ll INF_LL = 1'000'000'000'000'000'007;\n#define EXIT(out) do { OUT(out); exit(0); } while (0)\n#define __overload3(_1, _2, _3, name, ...) name\n#define rep(...) __overload3(__VA_ARGS__, repFromUntil, repUntil, repeat)(__VA_ARGS__)\n#define repeat(times) repFromUntil(_repeat\\\n__LINE__, 0, times)\n#define repUntil(name, times) repFromUntil(name, 0, times)\n#define repFromUntil(name, from, until) for (int name = from, name##__until = (until); name < name##__until; name++)\n#define repr(...) __overload3(__VA_ARGS__, reprFromUntil, reprUntil, repeat)(__VA_ARGS__)\n#define reprUntil(name, times) reprFromUntil(name, 0, times)\n#define reprFromUntil(name, from, until) for (int name = (until)-1, name##__from = (from); name >= name##__from; name--)\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define newl \"\\n\"\ntemplate <typename T, typename U>\nbool chmin(T& var, U x) { if (var > x) { var = x; return true; } else return false; }\ntemplate <typename T, typename U>\nbool chmax(T& var, U x) { if (var < x) { var = x; return true; } else return false; }\ntemplate <typename T> int sgn(T val) { return (T(0) < val) - (val < T(0)); }\nll power(ll e, int t, ll mod = INF_LL) {\n  ll res = 1;\n  while (t) {\n    if (t & 1) res = (res * e) % mod;\n    t >>= 1; e = (e * e) % mod;\n  }\n  return res;\n}\ntemplate <typename T> T divceil(T m, T d) { assert(m >= 0 and d > 0); return (m + d - 1) / d; }\ntemplate <typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate <typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v(ts...))>(a, make_v(ts...)); }\nstring operator*(const string& s, int times) { string res = \"\"; rep(times) res += s; return res; }\nstruct Edge {\n  int to; ll cost;\n  Edge(int _to) : to(_to), cost(1) {}\n  Edge(int _to, ll _cost) : to(_to), cost(_cost) {}\n  operator int() { return to; }\n};\nusing Graph = vector<vector<Edge>>;\n// IO\n// formatted version of following is at https://shino-sky.github.io/cp-lib/library/formatted_template.cpp.html\n// ignored \"-Wmisleading-indentation\"\nclass MyScanner { public: int offset = 0; char nc(){ return getchar(); }\ntemplate <typename T> void input_integer(T& var) { var = 0; T sign = 1; int cc = nc(); for (;\ncc<'0' || '9'<cc; cc = nc()) if (cc == '-') sign = -1; for (; '0' <= cc && cc <= '9'; cc = nc(\n)) var = (var << 3) + (var << 1) + cc - '0'; var = var * sign; var += offset; } int c() { char\nc; while (c = nc(), c == ' ' or c == '\\n'); return c; } MyScanner& operator>>(char& var) { var\n= c(); return *this; } MyScanner& operator>>(int& var) { input_integer<int>(var); return *this\n; } MyScanner& operator>>(ll& var) { input_integer<ll>(var); return *this; } MyScanner&\noperator>>(string& var) { var = \"\"; int cc = nc(); for (; !isvisiblechar(cc); cc = nc()); for\n(; isvisiblechar(cc); cc = nc()) var.push_back(cc); return *this; } template <typename T>\noperator T() { T x; *this >> x; return x; } template <typename T> void operator()(T &t) { *\nthis >> t; } template <typename T, typename... Ts> void operator()(T &t, Ts &...ts) { *this >>\nt; this->operator()(ts...); } template <typename Iter> void iter(Iter first, Iter last) {\nwhile (first != last) *this >> *first, first++; } VI vi(int n) { VI res(n); iter(all(res));\nreturn res; } VVI vvi(int n, int m) { VVI res(n); rep(i, n) res[i] = vi(m); return res; } VLL\nvll(int n) { VLL res(n); iter(all(res)); return res; } VVLL vvll(int n, int m) { VVLL res(n);\nrep(i, n) res[i] = vll(m); return res; } template <typename T> vector<T> v(int n) { vector<T>\nres(n); iter(all(res)); return res; } private: int isvisiblechar(int c) { return 0x21 <= c &&\nc <= 0x7E; } } IN, IN1{-1}; class MyPrinter { public: int offset = 0; template <typename T>\nvoid output_integer(T var) { var += offset; if (var == 0) { putchar('0'); return; } if (var <\n0) putchar('-'), var = -var; char stack[32]; int stack_p = 0; while (var) stack[stack_p++] =\n'0' + (var % 10), var /= 10; while (stack_p) putchar(stack[--stack_p]); } MyPrinter& operator\n<<(char c) { putchar(c); return *this; } MyPrinter& operator<<(double x) { printf(\"%.10f\", x);\nreturn *this; } template <typename T> MyPrinter& operator<<(T var) { output_integer<T>(var);\nreturn *this; } MyPrinter& operator<<(char* str_p) { while (*str_p) putchar(*(str_p++));\nreturn *this; } MyPrinter& operator<<(const char* str_p) { while (*str_p) putchar(*(str_p++));\nreturn *this; } MyPrinter& operator<<(const string& str) { const char* p = str.c_str(); const\nchar* l = p + str.size(); while (p < l) putchar(*p++); return *this; } template <typename T>\nvoid operator()(T x) { *this << x << newl; } template <typename T, typename... Ts> void\noperator()(T x, Ts ...xs) { *this << x << \" \"; this->operator()(xs...); } template <typename\nIter> void iter(Iter s, Iter t) { if (s == t) *this << \"\\n\"; else for (; s != t; s++) *this <<\n*s << \" \\n\"[next(s, 1) == t]; } } OUT, OUT1{1}; template <typename T, typename U> MyPrinter&\noperator<<(MyPrinter& out, const pair<T, U>& var) { return out << var.first << \" \" << var.\nsecond; } template <typename Tuple, size_t I, size_t N, enable_if_t<I == N>* = nullptr>\nMyPrinter& tuple_impl(MyPrinter& out, const Tuple& var) { return out; } template <typename\nTuple, size_t I, size_t N, enable_if_t<I != N>* = nullptr> MyPrinter& tuple_impl(MyPrinter&\nout, const Tuple& var) { out << get<I>(var) << \" \"; return tuple_impl<Tuple, I+1, N>(out, var)\n; } template <typename... Ts> MyPrinter& operator<<(MyPrinter& out, const tuple<Ts...>& var) {\nreturn tuple_impl<tuple<Ts...>, 0, sizeof...(Ts)>(out, var); } template <typename T, typename\nU> MyScanner& operator>>(MyScanner& in, pair<T, U>& var) { return in >> var.first >> var.\nsecond; } template <typename Tuple, size_t I, size_t N, enable_if_t<I == N>* = nullptr>\nMyScanner& tuple_impl(MyScanner& in, Tuple& var) { return in; } template <typename Tuple,\nsize_t I, size_t N, enable_if_t<I != N>* = nullptr> MyScanner& tuple_impl(MyScanner& in, Tuple\n& var) { in >> get<I>(var); return tuple_impl<Tuple, I+1, N>(in, var); } template <typename...\nTs> MyScanner& operator>>(MyScanner& in, tuple<Ts...>& var) { return tuple_impl<tuple<Ts...>,\n0, sizeof...(Ts)>(in, var); }\nclass DebugPrint { public: template <typename T> DebugPrint& operator <<(const T& v) {\n#ifdef LOCAL\n    cerr << v;\n#endif\nreturn *this; } } debugos; template <typename T> DebugPrint& operator<<(DebugPrint& os, const\nvector<T>& vec) { os << \"{\"; for (int i = 0; i < vec.size(); i++) os << vec[i] << (i + 1 ==\nvec.size() ? \"\" : \", \"); os << \"}\"; return os; } template <typename T, typename U> DebugPrint&\noperator<<(DebugPrint& os, map<T, U>& map_var) { os << \"{\"; repi(itr, map_var) { os << *itr;\nitr++; if (itr != map_var.end()) os << \", \"; itr--; } os << \"}\"; return os; } template <\ntypename T> DebugPrint& operator<<(DebugPrint& os, set<T>& set_var) { os << \"{\"; repi(itr,\nset_var) { os << *itr; itr++; if (itr != set_var.end()) os << \", \"; itr--; } os << \"}\"; return\nos; } void dump_func() { debugos << newl; } template <class Head, class... Tail> void\ndump_func(Head &&head, Tail &&...tail) { debugos << head; if (sizeof...(Tail) > 0) { debugos\n<< \", \"; } dump_func(std::move(tail)...); }\n#define dump(...) debugos << \"  \" << string(#__VA_ARGS__) << \": \" << \"[\" << to_string(__LINE__) \\\n<< \":\" << __FUNCTION__ << \"]\" << newl << \"    \", dump_func(__VA_ARGS__)\n// warning \"-Wmisleading-indentation\"\n\n\n\n// credit to: rsk0315 (https://atcoder.jp/users/rsk0315)\n// this implementation is from https://atcoder.jp/contests/arc064/submissions/8197391\n\n#include <list>\n#include <memory>\n\nconstexpr intmax_t  operator \"\"_jd(unsigned long long n) { return n; }\nconstexpr uintmax_t operator \"\"_ju(unsigned long long n) { return n; }\nconstexpr size_t    operator \"\"_zu(unsigned long long n) { return n; }\n// constexpr ptrdiff_t operator \"\"_td(unsigned long long n) { return n; }\n\nnamespace bit {\ntemplate <typename Tp>\nint log2p1(Tp n) {\n  if (n == 0) return 0;\n  return (8 * sizeof(long long)) - __builtin_clzll(n);\n}\n}  // bit::\n\ntemplate <typename Key, typename Tp, typename Compare = std::less<>>\nclass fibonacci_heap {\npublic:\n  using size_type = size_t;\n  using key_type = Key;\n  using mapped_type = Tp;\n  using value_type = std::pair<key_type, mapped_type>;\n  using reference = value_type&;\n  using const_reference = value_type const&;\n  using key_compare = Compare;\n  class node_handle;\n\nprivate:\n  class node;\n  using pointer = std::shared_ptr<node>;\n\n  class node {\n    friend fibonacci_heap;\n\n  public:\n    using size_type = size_t;\n    using key_type = Key;\n    using mapped_type = Tp;\n    using value_type = std::pair<key_type, mapped_type>;\n    using reference = value_type&;\n    using const_reference = value_type const&;\n    using key_compare = Compare;\n\n  private:\n    pointer M_parent{nullptr};\n    pointer M_child{nullptr};\n    pointer M_left{nullptr};\n    pointer M_right{nullptr};\n    bool M_damaged = false;\n    size_type M_order = 0;\n    value_type M_value;  // {priority, element}\n\n  public:\n    node() = default;\n    node(node const&) = default;\n    node(node&&) = default;\n    node& operator =(node const&) = default;\n    node& operator =(node&&) = default;\n\n    node(key_type const& key, mapped_type const& mapped):\n      M_value(key, mapped) {}\n  };\n\n  static void S_add_child(pointer parent, pointer child) {\n    ++parent->M_order;\n    child->M_parent = parent;\n    if (!parent->M_child) {\n      parent->M_child = child;\n      child->M_left = child->M_right = nullptr;\n    } else if (!parent->M_child->M_left) {\n      parent->M_child->M_left = parent->M_child->M_right = child;\n      child->M_left = child->M_right = parent->M_child;\n    } else {\n      child->M_left = parent->M_child->M_left;\n      child->M_right = parent->M_child;\n      parent->M_child->M_left->M_right = child;\n      parent->M_child->M_left = child;\n    }\n  }\n\n  static bool S_detach_child(pointer parent, pointer child) {\n    // returns true if the resulting heap is valid, false otherwise\n    bool res = !parent->M_damaged;\n    if (parent->M_parent) parent->M_damaged = true;\n    --parent->M_order;\n\n    if (parent->M_child == child) parent->M_child = child->M_right;\n    child->M_parent = nullptr;\n    child->M_damaged = false;\n\n    if (child->M_left) {\n      if (child->M_left == child->M_right) {\n        child->M_left->M_right = child->M_right->M_left = nullptr;\n      } else {\n        child->M_left->M_right = child->M_right;\n        child->M_right->M_left = child->M_left;\n      }\n      child->M_left = child->M_right = nullptr;\n    }\n    return res;\n  }\n\npublic:\n  class node_handle {\n    friend fibonacci_heap;\n\n  public:\n    using size_type = size_t;\n    using key_type = Key;\n    using mapped_type = Tp;\n    using value_type = std::pair<key_type, mapped_type>;\n    using reference = value_type&;\n    using const_reference = value_type const&;\n    using key_compare = Compare;\n    using pointer = std::weak_ptr<node>;\n\n  private:\n    pointer M_node;\n\n  public:\n    node_handle() = default;\n    node_handle(pointer node): M_node(node) {}\n    const_reference operator *() const { return (*M_node)->M_value; }\n    bool expired() const { return M_node.expired(); }\n  };\n\nprivate:\n  size_type M_size = 0;\n  std::list<pointer> M_roots;  // list for pop()\n  pointer M_top;  // pointer (not iterator) for prioritize()\n  key_compare M_comp = key_compare();\n\n  static size_type S_num_nodes(pointer cur) {\n    pointer child = cur->M_child;\n    if (!child) return 1;\n    size_type res = 1;\n    do {\n      res += S_num_nodes(child);\n      child = child->M_right;\n    } while (child && child != cur->M_child);\n    return res;\n  }\n\n  void M_coleasce() {\n    if (M_size == 0) {\n      M_roots.clear();\n      M_top = nullptr;\n      return;\n    }\n\n    size_type size = 0;\n    for (auto r: M_roots) size += 1_zu << r->M_order;\n    std::vector<pointer> roots(bit::log2p1(size));\n\n    for (auto r: M_roots) {\n      size_type i = r->M_order;\n      while (roots[i]) {\n        if (M_comp(r->M_value.first, roots[i]->M_value.first))\n          std::swap(r, roots[i]);\n\n        S_add_child(r, roots[i]);\n        roots[i] = nullptr;\n        ++i;\n      }\n      roots[i] = r;\n    }\n    M_roots.clear();\n\n    for (auto r: roots) if (r) M_roots.push_back(r);\n    M_top = *M_roots.begin();\n    for (auto p: M_roots)\n      if (M_comp(M_top->M_value.first, p->M_value.first)) M_top = p;\n  }\n\npublic:\n  fibonacci_heap() = default;\n  fibonacci_heap(fibonacci_heap const&) = delete;\n  fibonacci_heap(fibonacci_heap&&) = default;\n  fibonacci_heap& operator =(fibonacci_heap const&) = delete;\n  fibonacci_heap& operator =(fibonacci_heap&&) = default;\n\n  template <typename InputIt>\n  fibonacci_heap(InputIt first, InputIt last) { assign(first, last); }\n  fibonacci_heap(std::initializer_list<value_type> il) { assign(il); }\n\n  size_type size() const noexcept { return M_size; }\n  bool empty() const noexcept { return M_size == 0; }\n\n  const_reference const& top() const { return M_top->M_value; }\n  void pop() {\n    pointer root = M_top;\n    for (auto it = M_roots.begin(); it != M_roots.end(); ++it) {\n      if (*it == M_top) {\n        M_roots.erase(it);\n        break;\n      }\n    }\n    if (root->M_child) {\n      pointer cur = root->M_child;\n      do {\n        pointer tmp = cur->M_right;\n        cur->M_left = cur->M_right = cur->M_parent = nullptr;\n        cur->M_damaged = false;\n        M_roots.push_back(cur);\n        cur = tmp;\n      } while (cur && cur != root->M_child);\n      root->M_child = nullptr;\n    }\n    --M_size;\n    M_coleasce();\n  }\n\n  node_handle push(key_type const& key, mapped_type const& mapped) {\n    pointer newnode = std::make_shared<node>(key, mapped);\n    newnode->M_left = newnode->M_right = nullptr;\n    M_roots.push_back(newnode);\n    if (M_size == 0 || M_comp(M_top->M_value.first, key)) M_top = newnode;\n    ++M_size;\n    return node_handle(newnode);\n  }\n\n  void meld(fibonacci_heap& other) {\n    M_size += other.M_size;\n    other.M_size = 0;\n\n    M_roots.splice(M_roots.end(), other.M_roots);\n    if (M_comp(M_top->M_value.first, other.M_top->M_value.first))\n      M_top = other.M_top;\n  }\n\n  void prioritize(node_handle& nh, key_type const& key) {\n    pointer cur(nh.M_node);\n    // assert(M_comp(cur->M_value.first, key));\n    cur->M_value.first = key;\n    if (M_comp(M_top->M_value.first, key)) M_top = cur;\n    if (!cur->M_parent || !M_comp(cur->M_parent->M_value.first, key)) return;\n\n    bool more_cut = true;\n    while (more_cut) {\n      pointer parent = cur->M_parent;\n      more_cut = !S_detach_child(parent, cur);\n      M_roots.push_back(cur);\n      cur = parent;\n    }\n  }\n};\n\n\n\n\nint main() {\n  int n = IN, r = IN;\n  VI t(n); VLL e(n);\n  rep(i, n) IN >> t[i] >> e[i];\n  Graph graph(n);\n  rep(r) {\n    int a = IN1, b = IN1, c = IN;\n    graph[b].emplace_back(a, c-1);\n  }\n\n  fibonacci_heap<int, int, greater<>> hp;\n  vector<decltype(hp)::node_handle> handle(n);\n  rep(i, n) handle[i] = hp.push(t[i], i);\n\n  while (not hp.empty()) {\n    int t1, i; tie(t1, i) = hp.top(); hp.pop();\n    for (auto e : graph[i]) if (chmin(t[e.to], t1 + e.cost)) {\n      if (handle[e.to].expired()) handle[e.to] = hp.push(t1 + e.cost, e.to);\n      else hp.prioritize(handle[e.to], t1 + e.cost);\n    }\n  }\n\n  ll res = 0;\n  rep(i, n) res += t[i] * e[i];\n  OUT(res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr ll MOD = 1e9 + 7;\ntemplate <typename T> void chmin(T &a, T b) { a = min(a, b); }\ntemplate <typename T> void chmax(T &a, T b) { a = max(a, b); }\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<P>> G(n + 1);\n    vector<ll> t(n + 1), e(n + 1), x(n + 1, LINF);\n    x[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        cin >> t[i] >> e[i];\n        G[0].emplace_back(i, t[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        G[b].emplace_back(a, c - 1);\n    }\n    priority_queue<P, vector<P>, greater<P>> q;\n    q.push(P(0, 0));\n    while (!q.empty()) {\n        int v = q.top().second;\n        if (q.top().first > x[v]) {\n            q.pop();\n            continue;\n        }\n        q.pop();\n        for (auto &e : G[v]) {\n            if (x[e.first] > x[v] + e.second) {\n                x[e.first] = x[v] + e.second;\n                q.push(P(x[e.first], e.first));\n            }\n        }\n    }\n    ll res = 0;\n    for (int i = 1; i <= n; i++) {\n        res += e[i] * x[i];\n    }\n    cout << res << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0423\"\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n#endif\n//BEGIN CUT HERE\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n#endif\n//BEGIN CUT HERE\ntemplate <typename T>\nvector<T> dijkstra(int s,vector< vector< pair<int, T> > > & G){\n  const T INF = numeric_limits<T>::max();\n  using P = pair<T, int>;\n  int n=G.size();\n  vector<T> ds(n,INF);\n  vector<int> bs(n,-1);\n  priority_queue<P, vector<P>, greater<P> > pq;\n  ds[s]=0;\n  pq.emplace(ds[s],s);\n  while(!pq.empty()){\n    P p=pq.top();pq.pop();\n    int v=p.second;\n    if(ds[v]<p.first) continue;\n    for(auto& e:G[v]){\n      int u=e.first;\n      T c=e.second;\n      if(ds[u]>ds[v]+c){\n        ds[u]=ds[v]+c;\n        bs[u]=v;\n        pq.emplace(ds[u],u);\n      }\n    }\n  }\n  return ds;\n}\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  int n,l;\n  scanf(\"%d %d\",&n,&l);\n\n  using P = pair<int, Int>;\n  vector<vector<P> > G(l+1);\n  for(int i=0;i<n;i++){\n    int a,b,c;\n    scanf(\"%d %d %d\",&a,&b,&c);\n    G[a].emplace_back(b,c);\n  }\n\n  for(int i=0;i<l;i++)\n    G[i+1].emplace_back(i,0);\n\n  printf(\"%lld\\n\",dijkstra(0,G)[l]);\n  return 0;\n}\n/*\n  verified on 2018/01/16\n  https://atcoder.jp/contests/arc026/tasks/arc026_3\n*/\n#endif\n\n#undef call_from_test\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n\n  vector<int> ts(n),es(n);\n  for(int i=0;i<n;i++) cin>>ts[i]>>es[i];\n\n  using P = pair<int, int>;\n  vector< vector<P> > G(n+1);\n  for(int i=0;i<m;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;c--;\n    G[b].emplace_back(a,c);\n  }\n\n  for(int i=0;i<n;i++) G[n].emplace_back(i,ts[i]);\n  auto ds=dijkstra(n,G);\n\n  long long ans=0;\n  for(int i=0;i<n;i++) ans+=(long long)ds[i]*es[i];\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"0423.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0423\"\n\n#include <bits/stdc++.h>  // clang-format off\nusing Int = long long;\n#define REP_(i, a_, b_, a, b, ...) for (Int i = (a), lim##i = (b); i < lim##i; i++)\n#define REP(i, ...) REP_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\nstruct SetupIO { SetupIO() { std::cin.tie(nullptr), std::ios::sync_with_stdio(false), std::cout << std::fixed << std::setprecision(13); } } setup_io;\n#ifndef dump\n#define dump(...)\n#endif  // clang-format on\n\n/**\n *    author:  knshnb\n *    created: Mon Apr 27 01:47:13 JST 2020\n **/\n\n#define CALL_FROM_TEST\n#line 1 \"/Users/knshnb/competitive_programming/competitive_library/src/Graph/Dijkstra.hpp\"\ntemplate <class T, bool directed = true> struct Dijkstra {\n    struct Edge {\n        int to;\n        T cost;\n    };\n    std::vector<std::vector<Edge>> g;\n    Dijkstra(int n) : g(n) {}\n    void add_edge(int u, int v, T cost) {\n        g[u].push_back({v, cost});\n        if (!directed) g[v].push_back({u, cost});\n    }\n    std::vector<T> run(int s) {\n        std::vector<T> dist(g.size(), std::numeric_limits<T>::max() / 2);\n        // {d, v}\n        std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> q;\n        q.push({0, s});\n        while (!q.empty()) {\n            std::pair<T, int> p = q.top();\n            q.pop();\n            int v = p.second;\n            if (dist[v] <= p.first) continue;\n            dist[v] = p.first;\n            for (const Edge& e : g[v]) {\n                if (dist[e.to] <= p.first + e.cost) continue;  // 定数倍枝刈り\n                q.emplace(p.first + e.cost, e.to);\n            }\n        }\n        return dist;\n    }\n};\n#line 19 \"0423.test.cpp\"\n#undef CALL_FROM_TEST\n\nsigned main() {\n    Int n, R;\n    std::cin >> n >> R;\n    Dijkstra<Int> dj(n + 1);\n    std::vector<Int> e(n);\n    REP(i, n) {\n        Int t;\n        std::cin >> t >> e[i];\n        dj.add_edge(n, i, t);\n    }\n    REP(_, R) {\n        Int a, b, c;\n        std::cin >> a >> b >> c;\n        a--, b--;\n        dj.add_edge(b, a, c - 1);\n    }\n    auto dist = dj.run(n);\n    Int ans = 0;\n    REP(i, n) ans += dist[i] * e[i];\n    std::cout << ans << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<ll,ll> P;\n#define M 1000000007\n#define F first\n#define S second\n#define PB push_back\n#define INF 1000000000000000000\nll n,m,e[100005],d[100005],ans;\nvector<P>g[100005];\nint main(void){\n    cin>>n>>m;\n    for(int i=1;i<=n;i++){\n\t\tll t;\n\t\tscanf(\"%lld%lld\",&t,&e[i]);\n\t\tg[0].PB(P(i,t));\n\t}\n\twhile(m--){\n\t\tll a,b,c;\n\t\tscanf(\"%lld%lld%lld\",&a,&b,&c);\n\t\tg[b].PB(P(a,c-1));\n\t}\n\tfor(int i=0;i<=n;i++)d[i]=INF;\n\td[0]=0;\n\tpriority_queue<P,vector<P>,greater<P> >dik;\n\tdik.push(P(0,0));\n\twhile(!dik.empty()){\n\t\tll v=dik.top().S,c=dik.top().F;\n\t\tdik.pop();\n\t\tif(d[v]<c)continue;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tll u=g[v][i].F,p=g[v][i].S;\n\t\t\tif(d[u]>c+p){\n\t\t\t\td[u]=c+p;\n\t\t\t\tdik.push(P(d[u],u));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)ans+=e[i]*d[i];\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\n\nstruct Edge {\n\tint to, distance;\n};\nint main() {\n\tint n, r; std::cin >> n >> r;\n\tstd::vector<std::vector<Edge>> machines(n + 1);\n\tstd::vector<int> calories(n);\n\tfor (auto i = 0; i < n; ++i) {\n\t\tint t, e; std::cin >> t >> e;\n\t\tmachines[0].push_back(Edge{ i + 1, t });\n\t\tcalories[i] = e;\n\t}\n\tfor (auto i = 0; i < r; ++i) {\n\t\tint a, b, c; std::cin >> a >> b >> c;\n\t\tmachines[b].push_back(Edge{ a, c - 1 });\n\t}\n\tstd::vector<int> min_time(n + 1, INT_MAX); min_time[0] = 0;\n\tauto comparator = [](const std::pair<int, int>& a, const std::pair<int, int>& b) {return a.first > b.first; };\n\tstd::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(comparator)> queue(comparator); queue.emplace(0, 0);\n\twhile (!queue.empty()) {\n\t\tauto top = queue.top(); queue.pop();\n\t\tif (min_time[top.second] != top.first) continue;\n\t\tfor (const auto& e : machines[top.second]) {\n\t\t\tif (min_time[e.to] > top.first + e.distance) {\n\t\t\t\tmin_time[e.to] = top.first + e.distance;\n\t\t\t\tqueue.emplace(min_time[e.to], e.to);\n\t\t\t}\n\t\t}\n\t}\n\tlong long int sum = 0;\n\tfor (auto i = 0; i < n; ++i) {\n\t\tsum += static_cast<long long int>(calories[i]) * min_time[i + 1];\n\t}\n\tstd::cout << sum << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 100005\n\nstruct Edge{\n\tEdge(int arg_to,ll arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to;\n\tll cost;\n};\n\nstruct Info{\n\tInfo(int arg_node_id,ll arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\n\t\treturn sum_cost > arg.sum_cost; //総コストの昇順(PQ)\n\t}\n\n\tint node_id;\n\tll sum_cost;\n};\n\nint N,R;\nll min_dist[SIZE],value[SIZE];\nvector<Edge> G[SIZE];\n\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&R);\n\n\tint root = 0;\n\n\tll cost;\n\n\tfor(int i = 1; i <= N; i++){\n\n\t\tscanf(\"%lld %lld\",&cost,&value[i]);\n\t\tG[root].push_back(Edge(i,cost));\n\t}\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < R; loop++){\n\n\t\tscanf(\"%d %d %lld\",&to,&from,&cost);\n\t\tG[from].push_back(Edge(to,cost-1));\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\n\t\tmin_dist[i] = HUGE_NUM;\n\t}\n\tmin_dist[root] = 0;\n\n\tpriority_queue<Info> Q;\n\tQ.push(Info(root,0));\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().sum_cost > min_dist[Q.top().node_id]){\n\n\t\t\tQ.pop();\n\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\n\t\t\t\tint next_node = G[Q.top().node_id][i].to;\n\t\t\t\tll next_cost = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\n\t\t\t\tif(min_dist[next_node] > next_cost){\n\t\t\t\t\tmin_dist[next_node] = next_cost;\n\t\t\t\t\tQ.push(Info(next_node,next_cost));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = 1; i <= N; i++){\n\n\t\tans += value[i]*min_dist[i];\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom collections import deque\nfrom enum import Enum\nimport sys\nimport math\nfrom _heapq import heappush, heappop\nimport copy\n\nBIG_NUM = 2000000000\nMOD = 1000000007\nEPS = 0.000000001\n\n\nclass Edge:\n    def __init__(self,arg_to,arg_cost):\n        self.to = arg_to\n        self.cost = arg_cost\n\nclass Info:\n    def __init__(self,arg_node_id,arg_sum_cost):\n        self.node_id = arg_node_id\n        self.sum_cost = arg_sum_cost\n\n    def __lt__(self,another):\n        return self.sum_cost < another.sum_cost\n\n\nN,R = map(int,input().split())\n\nG = [[] for _ in range(N+1)]\nvalue = [None]*(N+1)\nroot = 0\n\nfor i in range(1,N+1):\n    cost,tmp = map(int,input().split())\n    G[root].append(Edge(i,cost))\n    value[i] = tmp\n\nfor _ in range(R):\n    to_,from_,cost = map(int,input().split())\n    G[from_].append(Edge(to_,cost-1))\n\nmin_cost = [BIG_NUM]*(N+1)\nmin_cost[root] = 0;\nQ = []\n\nheappush(Q, Info(root,0))\n\nwhile len(Q) > 0:\n    info = heappop(Q)\n    if info.sum_cost > min_cost[info.node_id]:\n        continue\n    for edge in G[info.node_id]:\n        if min_cost[edge.to] > info.sum_cost+edge.cost:\n            min_cost[edge.to] = info.sum_cost+edge.cost\n            heappush(Q, Info(edge.to,min_cost[edge.to]))\n\nans = 0\nfor i in range(1,N+1):\n    ans += min_cost[i]*value[i]\n\nprint(\"%d\"%(ans))\n"
  }
]