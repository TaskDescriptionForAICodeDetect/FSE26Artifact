[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <vector>\n\nconst int MAXN = 100005;\n\nstd::vector<int> graph[MAXN];\nlong long counter[MAXN];\nlong long lazy[MAXN];\n\nvoid dfs(int node, long long parent_val) {\n    counter[node] += parent_val + lazy[node];\n    \n    for (int child : graph[node]) {\n        dfs(child, counter[node]);\n    }\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    \n    for (int i = 2; i <= N; i++) {\n        int parent;\n        scanf(\"%d\", &parent);\n        graph[parent].push_back(i);\n    }\n    \n    for (int j = 0; j < Q; j++) {\n        int p, x;\n        scanf(\"%d %d\", &p, &x);\n        lazy[p] += x;\n    }\n    \n    dfs(1, 0);\n    \n    for (int i = 1; i <= N; i++) {\n        printf(\"%lld \", counter[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* createNode(int v) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid addEdge(Node* adj[], int src, int dest) {\n    Node* newNode = createNode(dest);\n    newNode->next = adj[src];\n    adj[src] = newNode;\n}\n\nvoid dfs(int u, int* counter, Node* adj[], int* start, int* end, int* time) {\n    start[u] = ++(*time);\n    Node* temp = adj[u];\n    while (temp != NULL) {\n        int v = temp->vertex;\n        dfs(v, counter, adj, start, end, time);\n        temp = temp->next;\n    }\n    end[u] = *time;\n}\n\nvoid update(int* BIT, int n, int index, int val) {\n    while (index <= n) {\n        BIT[index] += val;\n        index += index & (-index);\n    }\n}\n\nint query(int* BIT, int index) {\n    int sum = 0;\n    while (index > 0) {\n        sum += BIT[index];\n        index -= index & (-index);\n    }\n    return sum;\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    Node* adj[N + 1];\n    for (int i = 1; i <= N; i++) {\n        adj[i] = NULL;\n    }\n\n    for (int i = 2; i <= N; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        addEdge(adj, p, i);\n    }\n\n    int start[N + 1], end[N + 1];\n    int time = 0;\n    dfs(1, NULL, adj, start, end, &time);\n\n    int* BIT = (int*)calloc(N + 2, sizeof(int));\n\n    while (Q--) {\n        int p, x;\n        scanf(\"%d %d\", &p, &x);\n        update(BIT, N, start[p], x);\n        update(BIT, N, end[p] + 1, -x);\n    }\n\n    for (int i = 1; i <= N; i++) {\n        printf(\"%d \", query(BIT, start[i]));\n    }\n    printf(\"\\n\");\n\n    free(BIT);\n    for (int i = 1; i <= N; i++) {\n        Node* temp = adj[i];\n        while (temp != NULL) {\n            Node* next = temp->next;\n            free(temp);\n            temp = next;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid dfs(int u, int parent, const vector<vector<int>>& tree, vector<long long>& counter, vector<long long>& res) {\n    res[u] += counter[u];\n    for (int v : tree[u]) {\n        if (v != parent) {\n            counter[v] += counter[u];\n            dfs(v, u, tree, counter, res);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<vector<int>> tree(N + 1);\n    for (int i = 1; i < N; ++i) {\n        int a, b;\n        cin >> a >> b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n\n    vector<long long> counter(N + 1, 0);\n    for (int i = 0; i < Q; ++i) {\n        int p, x;\n        cin >> p >> x;\n        counter[p] += x;\n    }\n\n    vector<long long> res(N + 1, 0);\n    dfs(1, -1, tree, counter, res);\n\n    for (int i = 1; i <= N; ++i) {\n        cout << res[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static List<List<Integer>> tree;\n    static int[] in, out;\n    static int time = 0;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int Q = Integer.parseInt(st.nextToken());\n\n        tree = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            tree.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            tree.get(a).add(b);\n            tree.get(b).add(a);\n        }\n\n        in = new int[N + 1];\n        out = new int[N + 1];\n        dfs(1, -1);\n\n        long[] diff = new long[N + 2];\n        for (int i = 0; i < Q; i++) {\n            st = new StringTokenizer(br.readLine());\n            int p = Integer.parseInt(st.nextToken());\n            int x = Integer.parseInt(st.nextToken());\n            diff[in[p]] += x;\n            diff[out[p] + 1] -= x;\n        }\n\n        long[] res = new long[N + 1];\n        long current = 0;\n        for (int i = 1; i <= N; i++) {\n            current += diff[i];\n            res[i] = current;\n        }\n\n        long[] ans = new long[N + 1];\n        for (int i = 1; i <= N; i++) {\n            ans[i] = res[in[i]];\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 1; i <= N; i++) {\n            sb.append(ans[i]).append(\" \");\n        }\n        System.out.println(sb.toString().trim());\n    }\n\n    static void dfs(int u, int parent) {\n        in[u] = ++time;\n        for (int v : tree.get(u)) {\n            if (v != parent) {\n                dfs(v, u);\n            }\n        }\n        out[u] = time;\n    }\n}",
    "timestamp": "2025-08-05 22:45:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeOperations {\n    static class Node {\n        List<Integer> children = new ArrayList<>();\n        int counter = 0;\n    }\n\n    public static int[] solveTreeOperations(int N, int[][] operations) {\n        Node[] tree = new Node[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new Node();\n        }\n\n        // Build tree structure (assuming parent-child relationships are given)\n        for (int i = 2; i <= N; i++) {\n            int parent = getParent(i);\n            tree[parent].children.add(i);\n        }\n\n        // Perform BFS to increment counters\n        for (int[] op : operations) {\n            int p = op[0], x = op[1];\n            incrementSubtree(tree, p, x);\n        }\n\n        // Collect final counter values\n        int[] result = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            result[i] = tree[i].counter;\n        }\n        return result;\n    }\n\n    private static void incrementSubtree(Node[] tree, int root, int value) {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            tree[current].counter += value;\n            queue.addAll(tree[current].children);\n        }\n    }\n\n    // Placeholder method - replace with actual parent finding logic\n    private static int getParent(int vertex) {\n        return vertex / 2;\n    }\n\n    public static void main(String[] args) {\n        int N = 5;\n        int[][] operations = {{2, 3}, {3, 2}, {4, 1}};\n        int[] result = solveTreeOperations(N, operations);\n        \n        for (int i = 1; i < result.length; i++) {\n            System.out.println(\"Vertex \" + i + \": \" + result[i]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:45:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nvector<int> graph[MAXN];\nint counters[MAXN];\nint in_time[MAXN];\nint out_time[MAXN];\nint timer = 0;\n\nvoid dfs(int v, int parent) {\n    in_time[v] = ++timer;\n    \n    for (int child : graph[v]) {\n        if (child != parent) {\n            dfs(child, v);\n        }\n    }\n    \n    out_time[v] = timer;\n}\n\nvoid update(int l, int r, int val) {\n    counters[l] += val;\n    counters[r + 1] -= val;\n}\n\nvoid solve_diff_array() {\n    for (int i = 1; i <= timer; i++) {\n        counters[i] += counters[i-1];\n    }\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    \n    for (int i = 2; i <= N; i++) {\n        int parent;\n        cin >> parent;\n        graph[parent].push_back(i);\n        graph[i].push_back(parent);\n    }\n    \n    dfs(1, 0);\n    \n    for (int i = 0; i < Q; i++) {\n        int p, x;\n        cin >> p >> x;\n        update(in_time[p], out_time[p], x);\n    }\n    \n    solve_diff_array();\n    \n    for (int i = 1; i <= N; i++) {\n        cout << counters[in_time[i]] << \" \";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:45:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef add_to_subtree(n, edges, operations):\n    adjacency_list = defaultdict(list)\n    for u, v in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    \n    def build_tree(root, parent):\n        tree[root] = []\n        for child in adjacency_list[root]:\n            if child != parent:\n                build_tree(child, root)\n                tree[root].append(child)\n    \n    def dfs(vertex, parent, value):\n        counter[vertex] += value\n        for child in tree[vertex]:\n            dfs(child, vertex, counter[vertex])\n        \n    tree = {}\n    build_tree(1, -1)\n    \n    counter = [0] * (n + 1)\n    \n    for p_j, x_j in operations:\n        counter[p_j] += x_j\n    \n    dfs(1, -1, 0)\n    \n    return counter[1:]\n\n# Example usage\nn = 5\nedges = [(1, 2), (1, 3), (3, 4), (3, 5)]\noperations = [(2, 10), (3, 20)]\nresult = add_to_subtree(n, edges, operations)\nprint(result)",
    "timestamp": "2025-08-13 12:21:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeCounterUpdate {\n    private static void dfs(int node, int increment, int[] result, List<Integer>[] tree) {\n        result[node] += increment;\n        for (int child : tree[node]) {\n            dfs(child, result[node], result, tree);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n        List<Integer>[] tree = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n\n        for (int i = 2; i <= N; i++) {\n            int parent = sc.nextInt();\n            tree[parent].add(i);\n        }\n\n        int Q = sc.nextInt();\n        int[] updates = new int[N + 1];\n        for (int i = 0; i < Q; i++) {\n            int p_j = sc.nextInt();\n            int x_j = sc.nextInt();\n            updates[p_j] += x_j;\n        }\n\n        int[] result = new int[N + 1];\n        dfs(1, updates[1], result, tree);\n\n        for (int i = 1; i <= N; i++) {\n            System.out.print(result[i] + \" \");\n        }\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 12:21:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(int node, vector<int> &counter, vector<vector<int>> &adj, int *subtree_increments) {\n    for (int child : adj[node]) {\n        subtree_increments[child] += subtree_increments[node];\n        dfs(child, counter, adj, subtree_increments);\n    }\n    counter[node] += subtree_increments[node];\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    \n    vector<vector<int>> adj(N + 1);\n    for (int i = 2; i <= N; ++i) {\n        int parent;\n        scanf(\"%d\", &parent);\n        adj[parent].push_back(i);\n    }\n    \n    int *subtree_increments = (int *)calloc(N + 1, sizeof(int));\n    \n    for (int i = 0; i < Q; ++i) {\n        int p, x;\n        scanf(\"%d %d\", &p, &x);\n        subtree_increments[p] += x;\n    }\n    \n    vector<int> counter(N + 1, 0);\n    dfs(1, counter, adj, subtree_increments);\n    \n    for (int i = 1; i <= N; ++i) {\n        printf(\"%d \", counter[i]);\n    }\n    \n    free(subtree_increments);\n    return 0;\n}",
    "timestamp": "2025-08-13 12:21:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function subtreeIncrements(N, edges, operations) {\n    // Build the tree as an adjacency list\n    const tree = Array.from({ length: N + 1 }, () => []);\n    for (const [u, v] of edges) {\n        tree[u].push(v);\n    }\n\n    // Initialize counters and increments\n    const counters = Array(N + 1).fill(0);\n    const increments = Array(N + 1).fill(0);\n\n    // DFS function to apply operations incrementally\n    function applyIncrement(node, increment) {\n        // Apply current increment to the node\n        increments[node] += increment;\n        counters[node] += increments[node];\n\n        // Propagate the increments to the subtree\n        for (const neighbor of tree[node]) {\n            applyIncrement(neighbor, increments[node]);\n        }\n\n        // Reset increment for the returned context\n        increments[node] -= increment;\n    }\n\n    // Process each operation\n    for (const [p_j, x_j] of operations) {\n        applyIncrement(p_j, x_j);\n    }\n\n    // Return counters from vertex 1 to N\n    return counters.slice(1);\n}\n\n// Example usage\nconst N = 5;\nconst edges = [\n    [1, 2],\n    [1, 3],\n    [2, 4],\n    [2, 5],\n];\nconst operations = [\n    [1, 10],\n    [2, 5],\n    [3, 3],\n];\n\nconsole.log(subtreeIncrements(N, edges, operations));",
    "timestamp": "2025-08-13 12:21:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class TreeCounter:\n    def __init__(self, N):\n        self.N = N\n        self.graph = [[] for _ in range(N+1)]\n        self.parent = [0] * (N+1)\n        self.subtree_start = [0] * (N+1)\n        self.subtree_end = [0] * (N+1)\n        self.counter = [0] * (N+1)\n        self.timer = 0\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.parent[v] = u\n\n    def dfs(self, node):\n        self.timer += 1\n        self.subtree_start[node] = self.timer\n        \n        for child in self.graph[node]:\n            self.dfs(child)\n        \n        self.subtree_end[node] = self.timer\n\n    def range_update(self, start, end, value):\n        self.counter[start] += value\n        if end+1 <= self.N:\n            self.counter[end+1] -= value\n\n    def solve(self, operations):\n        # Run first DFS to compute subtree ranges\n        self.dfs(1)\n        \n        # Process range updates\n        for p, x in operations:\n            self.range_update(self.subtree_start[p], self.subtree_end[p], x)\n        \n        # Perform prefix sum to get final counter values\n        for i in range(2, self.N+1):\n            self.counter[i] += self.counter[self.parent[i]]\n        \n        return [self.counter[self.subtree_start[i]] for i in range(1, self.N+1)]\n\ndef main():\n    N, Q = map(int, input().split())\n    \n    tree = TreeCounter(N)\n    \n    # Read tree structure\n    for _ in range(N-1):\n        u, v = map(int, input().split())\n        tree.add_edge(u, v)\n    \n    # Read operations\n    operations = []\n    for _ in range(Q):\n        p, x = map(int, input().split())\n        operations.append((p, x))\n    \n    # Solve and print results\n    result = tree.solve(operations)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:21:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function treeOperations(N, operations) {\n    const tree = Array.from({ length: N + 1 }, () => []);\n    const parent = new Array(N + 1).fill(0);\n    const counters = new Array(N + 1).fill(0);\n    const subtreeSum = new Array(N + 1).fill(0);\n\n    // Build tree adjacency list\n    for (let i = 2; i <= N; i++) {\n        const p = operations[i - 2][0];\n        parent[i] = p;\n        tree[p].push(i);\n    }\n\n    // Perform DFS to update subtree sums\n    function dfs(node) {\n        for (const child of tree[node]) {\n            subtreeSum[child] += subtreeSum[node];\n            dfs(child);\n        }\n    }\n\n    // Process operations\n    for (const [p, x] of operations) {\n        subtreeSum[p] += x;\n    }\n\n    // Propagate subtree sums\n    dfs(1);\n\n    // Compute final counters\n    for (let i = 1; i <= N; i++) {\n        counters[i] = subtreeSum[i];\n    }\n\n    return counters.slice(1);\n}",
    "timestamp": "2025-08-13 12:21:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, Q = map(int, input[ptr:ptr+2])\n    ptr +=2\n    \n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        a, b = map(int, input[ptr:ptr+2])\n        ptr +=2\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # BFS to build parent and children structure\n    parent = [0]*(N+1)\n    children = [[] for _ in range(N+1)]\n    q = deque([1])\n    parent[1] = 0  # 1 is root\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if parent[v] == 0 and v != parent[u]:\n                parent[v] = u\n                children[u].append(v)\n                q.append(v)\n    \n    # Initialize operations\n    ops = [0]*(N+1)\n    for _ in range(Q):\n        p, x = map(int, input[ptr:ptr+2])\n        ptr +=2\n        ops[p] += x\n    \n    # BFS to propagate the operations\n    res = [0]*(N+1)\n    q = deque([1])\n    res[1] = ops[1]\n    while q:\n        u = q.popleft()\n        for v in children[u]:\n            res[v] = res[u] + ops[v]\n            q.append(v)\n    \n    print(' '.join(map(str, res[1:])))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 12:22:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n\nfunction solve() {\n    let ptr = 0;\n    const [N, Q] = input[ptr++].split(' ').map(Number);\n    const adj = Array.from({ length: N + 1 }, () => []);\n    \n    for (let i = 0; i < N - 1; i++) {\n        const [a, b] = input[ptr++].split(' ').map(Number);\n        adj[a].push(b);\n        adj[b].push(a);\n    }\n    \n    const operations = Array(N + 1).fill(0);\n    for (let i = 0; i < Q; i++) {\n        const [p, x] = input[ptr++].split(' ').map(Number);\n        operations[p] += x;\n    }\n    \n    const res = Array(N + 1).fill(0);\n    const stack = [[1, -1, 0]];\n    \n    while (stack.length > 0) {\n        const [u, parent, sum] = stack.pop();\n        const newSum = sum + operations[u];\n        res[u] = newSum;\n        \n        for (const v of adj[u]) {\n            if (v !== parent) {\n                stack.push([v, u, newSum]);\n            }\n        }\n    }\n    \n    console.log(res.slice(1).join(' '));\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:22:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid dfs(int node, int parent, vector<vector<int>>& adj, vector<int>& result, vector<int>& lazy) {\n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            lazy[neighbor] += lazy[node];\n            dfs(neighbor, node, adj, result, lazy);\n        }\n    }\n    result[node] += lazy[node];\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    \n    vector<vector<int>> adj(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    vector<int> lazy(N + 1, 0);\n    for (int i = 0; i < Q; ++i) {\n        int p_j, x_j;\n        cin >> p_j >> x_j;\n        lazy[p_j] += x_j;\n    }\n    \n    vector<int> result(N + 1, 0);\n    dfs(1, -1, adj, result, lazy);  // Start DFS from root (1)\n    \n    for (int i = 1; i <= N; ++i) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:34:16"
  }
]