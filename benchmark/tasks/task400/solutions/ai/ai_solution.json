[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint H, W;\nchar garden[100][100];\n\nint countParts(int x1, int y1, int x2, int y2) {\n    int parts = 1;\n    int side = 0; // 0: not determined, 1: left/above, 2: right/below\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (garden[i][j] == '#') {\n                int pos = (x2 - x1) * (j - x1) - (y2 - y1) * (i - y1);\n                if (pos == 0) {\n                    continue;\n                }\n                int current_side = pos > 0 ? 1 : 2;\n                if (side == 0) {\n                    side = current_side;\n                } else if (current_side != side) {\n                    parts++;\n                    side = current_side;\n                }\n            }\n        }\n    }\n    return parts;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", garden[i]);\n    }\n\n    int max_parts = 1;\n\n    // Check all possible vertical lines between columns\n    for (int j = 0; j <= W; j++) {\n        int parts = countParts(j, 0, j, H);\n        if (parts > max_parts) {\n            max_parts = parts;\n        }\n    }\n\n    // Check all possible horizontal lines between rows\n    for (int i = 0; i <= H; i++) {\n        int parts = countParts(0, i, W, i);\n        if (parts > max_parts) {\n            max_parts = parts;\n        }\n    }\n\n    // Check all possible diagonal lines between corners\n    for (int i1 = 0; i1 <= H; i1++) {\n        for (int j1 = 0; j1 <= W; j1++) {\n            for (int i2 = 0; i2 <= H; i2++) {\n                for (int j2 = 0; j2 <= W; j2++) {\n                    if (i1 == i2 && j1 == j2) continue;\n                    int parts = countParts(j1, i1, j2, i2);\n                    if (parts > max_parts) {\n                        max_parts = parts;\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_parts);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <utility>\nusing namespace std;\n\nint H, W;\nvector<string> garden;\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nvoid dfs(int x, int y, set<pair<int, int>>& visited) {\n    if (!is_valid(x, y) || garden[x][y] != '#' || visited.count({x, y})) {\n        return;\n    }\n    visited.insert({x, y});\n    dfs(x + 1, y, visited);\n    dfs(x - 1, y, visited);\n    dfs(x, y + 1, visited);\n    dfs(x, y - 1, visited);\n}\n\nint count_components(const set<pair<int, int>>& removed) {\n    set<pair<int, int>> visited;\n    int components = 0;\n    for (auto pos : removed) {\n        if (garden[pos.first][pos.second] == '#' && !visited.count(pos)) {\n            dfs(pos.first, pos.second, visited);\n            components++;\n        }\n    }\n    return components;\n}\n\nint main() {\n    cin >> H >> W;\n    garden.resize(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> garden[i];\n    }\n\n    set<pair<int, int>> roses;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (garden[i][j] == '#') {\n                roses.insert({i, j});\n            }\n        }\n    }\n\n    int max_parts = 1;\n    for (int i = 0; i < H; ++i) {\n        set<pair<int, int>> removed;\n        for (auto pos : roses) {\n            if (pos.first != i) {\n                removed.insert(pos);\n            }\n        }\n        if (!removed.empty()) {\n            int parts = count_components(removed);\n            if (parts > max_parts) {\n                max_parts = parts;\n            }\n        }\n    }\n\n    for (int j = 0; j < W; ++j) {\n        set<pair<int, int>> removed;\n        for (auto pos : roses) {\n            if (pos.second != j) {\n                removed.insert(pos);\n            }\n        }\n        if (!removed.empty()) {\n            int parts = count_components(removed);\n            if (parts > max_parts) {\n                max_parts = parts;\n            }\n        }\n    }\n\n    cout << max_parts << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int H, W;\n    static char[][] garden;\n    static boolean[][] visited;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        garden = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            garden[i] = sc.next().toCharArray();\n        }\n\n        int maxParts = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (garden[i][j] == '#') {\n                    maxParts = Math.max(maxParts, checkVerticalSplit(i, j));\n                    maxParts = Math.max(maxParts, checkHorizontalSplit(i, j));\n                    maxParts = Math.max(maxParts, checkDiagonalSplit1(i, j));\n                    maxParts = Math.max(maxParts, checkDiagonalSplit2(i, j));\n                }\n            }\n        }\n        System.out.println(maxParts);\n    }\n\n    static int checkVerticalSplit(int x, int y) {\n        int parts = 0;\n        visited = new boolean[H][W];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (garden[i][j] == '#' && !visited[i][j]) {\n                    if (j < y) {\n                        dfs(i, j, -1, y);\n                        parts++;\n                    } else {\n                        dfs(i, j, y, W);\n                        parts++;\n                    }\n                }\n            }\n        }\n        return parts;\n    }\n\n    static int checkHorizontalSplit(int x, int y) {\n        int parts = 0;\n        visited = new boolean[H][W];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (garden[i][j] == '#' && !visited[i][j]) {\n                    if (i < x) {\n                        dfs(i, j, x, -1);\n                        parts++;\n                    } else {\n                        dfs(i, j, x, W);\n                        parts++;\n                    }\n                }\n            }\n        }\n        return parts;\n    }\n\n    static int checkDiagonalSplit1(int x, int y) {\n        int parts = 0;\n        visited = new boolean[H][W];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (garden[i][j] == '#' && !visited[i][j]) {\n                    if (i - x < j - y) {\n                        dfs(i, j, -1, -1);\n                        parts++;\n                    } else {\n                        dfs(i, j, -1, -1);\n                        parts++;\n                    }\n                }\n            }\n        }\n        return parts;\n    }\n\n    static int checkDiagonalSplit2(int x, int y) {\n        int parts = 0;\n        visited = new boolean[H][W];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (garden[i][j] == '#' && !visited[i][j]) {\n                    if (i - x > y - j) {\n                        dfs(i, j, -1, -1);\n                        parts++;\n                    } else {\n                        dfs(i, j, -1, -1);\n                        parts++;\n                    }\n                }\n            }\n        }\n        return parts;\n    }\n\n    static void dfs(int x, int y, int splitX, int splitY) {\n        if (x < 0 || x >= H || y < 0 || y >= W || garden[x][y] != '#' || visited[x][y]) {\n            return;\n        }\n        visited[x][y] = true;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (splitX != -1 && splitY == -1) {\n                if ((x < splitX && nx >= splitX) || (x >= splitX && nx < splitX)) {\n                    continue;\n                }\n            } else if (splitX == -1 && splitY != -1) {\n                if ((y < splitY && ny >= splitY) || (y >= splitY && ny < splitY)) {\n                    continue;\n                }\n            }\n            dfs(nx, ny, splitX, splitY);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:24:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RoseSplitter {\n    static int[][] grid;\n    static boolean[][] visited;\n    static int H, W;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        grid = new int[H][W];\n        visited = new boolean[H][W];\n\n        for (int i = 0; i < H; i++) {\n            String row = sc.next();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = row.charAt(j) == '#' ? 1 : 0;\n            }\n        }\n\n        int maxParts = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                maxParts = Math.max(maxParts, splitEntity(i, j));\n            }\n        }\n\n        System.out.println(maxParts);\n    }\n\n    static int splitEntity(int row, int col) {\n        if (row < 0 || row >= H || col < 0 || col >= W || grid[row][col] == 0 || visited[row][col]) {\n            return 0;\n        }\n\n        int parts = 0;\n        for (int k = 0; k < W; k++) {\n            if (canSplitVertically(row, k)) {\n                parts = Math.max(parts, countParts(row, k));\n            }\n        }\n\n        for (int k = 0; k < H; k++) {\n            if (canSplitHorizontally(k, col)) {\n                parts = Math.max(parts, countParts(k, col));\n            }\n        }\n\n        return parts;\n    }\n\n    static boolean canSplitVertically(int row, int col) {\n        for (int i = 0; i < H; i++) {\n            if (grid[i][col] == 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static boolean canSplitHorizontally(int row, int col) {\n        for (int j = 0; j < W; j++) {\n            if (grid[row][j] == 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static int countParts(int splitRow, int splitCol) {\n        for (boolean[] row : visited) {\n            Arrays.fill(row, false);\n        }\n\n        int parts = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    if (splitCol != -1 && j == splitCol) continue;\n                    if (splitRow != -1 && i == splitRow) continue;\n                    dfs(i, j, splitRow, splitCol);\n                    parts++;\n                }\n            }\n        }\n        return parts;\n    }\n\n    static void dfs(int row, int col, int splitRow, int splitCol) {\n        if (row < 0 || row >= H || col < 0 || col >= W || grid[row][col] == 0 || visited[row][col]) {\n            return;\n        }\n        if (row == splitRow || col == splitCol) {\n            return;\n        }\n\n        visited[row][col] = true;\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (int[] dir : directions) {\n            dfs(row + dir[0], col + dir[1], splitRow, splitCol);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:24:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 100\n\nint garden[MAX_SIZE][MAX_SIZE];\nint H, W;\n\nvoid dfs(int x, int y, int visited[MAX_SIZE][MAX_SIZE]) {\n    if (x < 0 || x >= H || y < 0 || y >= W || !garden[x][y] || visited[x][y])\n        return;\n    \n    visited[x][y] = 1;\n    \n    dfs(x+1, y, visited);\n    dfs(x-1, y, visited);\n    dfs(x, y+1, visited);\n    dfs(x, y-1, visited);\n}\n\nint countRoseEntities() {\n    int visited[MAX_SIZE][MAX_SIZE] = {0};\n    int count = 0;\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (garden[i][j] && !visited[i][j]) {\n                dfs(i, j, visited);\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint maxSplit() {\n    int maxParts = 1;\n    \n    for (int x = 0; x < H; x++) {\n        for (int y = 0; y < W; y++) {\n            int tempGarden[MAX_SIZE][MAX_SIZE];\n            memcpy(tempGarden, garden, sizeof(garden));\n            \n            for (int i = 0; i < W; i++) {\n                garden[x][i] = 0;\n            }\n            \n            int parts = countRoseEntities();\n            maxParts = (parts > maxParts) ? parts : maxParts;\n            \n            memcpy(garden, tempGarden, sizeof(garden));\n        }\n    }\n    \n    for (int y = 0; y < W; y++) {\n        for (int x = 0; x < H; x++) {\n            int tempGarden[MAX_SIZE][MAX_SIZE];\n            memcpy(tempGarden, garden, sizeof(garden));\n            \n            for (int i = 0; i < H; i++) {\n                garden[i][y] = 0;\n            }\n            \n            int parts = countRoseEntities();\n            maxParts = (parts > maxParts) ? parts : maxParts;\n            \n            memcpy(garden, tempGarden, sizeof(garden));\n        }\n    }\n    \n    return maxParts;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    \n    for (int i = 0; i < H; i++) {\n        char row[MAX_SIZE + 1];\n        scanf(\"%s\", row);\n        for (int j = 0; j < W; j++) {\n            garden[i][j] = (row[j] == '#');\n        }\n    }\n    \n    printf(\"%d\\n\", maxSplit());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:24:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(vector<vector<char>>& garden, int x, int y, vector<vector<bool>>& visited) {\n    int H = garden.size(), W = garden[0].size();\n    if (x < 0 || x >= H || y < 0 || y >= W || garden[x][y] == '.' || visited[x][y]) return;\n    \n    visited[x][y] = true;\n    \n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        dfs(garden, nx, ny, visited);\n    }\n}\n\nint countRoseEntities(vector<vector<char>>& garden) {\n    int H = garden.size(), W = garden[0].size();\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    int entities = 0;\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (garden[i][j] == '#' && !visited[i][j]) {\n                dfs(garden, i, j, visited);\n                entities++;\n            }\n        }\n    }\n    \n    return entities;\n}\n\nint maxSplitRoses(vector<vector<char>>& garden) {\n    int originalEntities = countRoseEntities(garden);\n    int maxSplit = 0;\n    \n    // Horizontal cuts\n    for (int cut = 0; cut < garden.size(); cut++) {\n        vector<vector<char>> temp = garden;\n        for (int j = 0; j < garden[0].size(); j++) {\n            temp[cut][j] = '.';\n        }\n        \n        int newEntities = countRoseEntities(temp);\n        maxSplit = max(maxSplit, newEntities);\n    }\n    \n    // Vertical cuts\n    for (int cut = 0; cut < garden[0].size(); cut++) {\n        vector<vector<char>> temp = garden;\n        for (int i = 0; i < garden.size(); i++) {\n            temp[i][cut] = '.';\n        }\n        \n        int newEntities = countRoseEntities(temp);\n        maxSplit = max(maxSplit, newEntities);\n    }\n    \n    return originalEntities == 0 ? 0 : maxSplit;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<vector<char>> garden(H, vector<char>(W));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> garden[i][j];\n        }\n    }\n    \n    cout << maxSplitRoses(garden) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:24:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_split_roses(H, W, garden):\n    def dfs(x, y, visited):\n        stack = [(x, y)]\n        while stack:\n            cx, cy = stack.pop()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = cx + dx, cy + dy\n                if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny] and garden[nx][ny] == '#':\n                    visited[nx][ny] = True\n                    stack.append((nx, ny))\n\n    # Initialize the garden plot as visited if there is no rose\n    visited = [[False] * W for _ in range(H)]\n    for i in range(H):\n        for j in range(W):\n            if garden[i][j] == '.':\n                visited[i][j] = True\n\n    # Find connected components of roses\n    connected_components = 0\n    for i in range(H):\n        for j in range(W):\n            if garden[i][j] == '#' and not visited[i][j]:\n                visited[i][j] = True\n                connected_components += 1\n                dfs(i, j, visited)\n\n    # Calculate maximum parts by considering a vertical or horizontal line\n    max_split = 0\n\n    # Check splitting lines horizontally\n    for r in range(1, H):\n        upper_visited = [[False] * W for _ in range(r)]\n        lower_visited = [[False] * W for _ in range(H - r)]\n        upper_count = 0\n        lower_count = 0\n\n        for i in range(r):\n            for j in range(W):\n                if garden[i][j] == '#' and not upper_visited[i][j]:\n                    upper_visited[i][j] = True\n                    upper_count += 1\n                    dfs(i, j, upper_visited)\n\n        for i in range(r, H):\n            for j in range(W):\n                if garden[i][j] == '#' and not lower_visited[i - r][j]:\n                    lower_visited[i - r][j] = True\n                    lower_count += 1\n                    dfs(i, j, lower_visited)\n\n        max_split = max(max_split, upper_count + lower_count)\n\n    # Check splitting lines vertically\n    for c in range(1, W):\n        left_visited = [[False] * c for _ in range(H)]\n        right_visited = [[False] * (W - c) for _ in range(H)]\n        left_count = 0\n        right_count = 0\n\n        for i in range(H):\n            for j in range(c):\n                if garden[i][j] == '#' and not left_visited[i][j]:\n                    left_visited[i][j] = True\n                    left_count += 1\n                    dfs(i, j, left_visited)\n\n        for i in range(H):\n            for j in range(c, W):\n                if garden[i][j] == '#' and not right_visited[i][j - c]:\n                    right_visited[i][j - c] = True\n                    right_count += 1\n                    dfs(i, j, right_visited)\n\n        max_split = max(max_split, left_count + right_count)\n\n    return max_split\n\n# Example of how to use this function with an example input\nH = 4\nW = 5\ngarden = [\n    \"#####\",\n    \"#...#\",\n    \"#.#.#\",\n    \"#####\"\n]\nprint(max_split_roses(H, W, garden))",
    "timestamp": "2025-08-13 06:17:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class GardenSplitter {\n\n    private static int W, H;\n    private static char[][] garden;\n\n    private static boolean[][] visited;\n    private static int connectedComponents;\n    private static int[] directionX = {-1, 1, 0, 0};\n    private static int[] directionY = {0, 0, -1, 1};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        H = scanner.nextInt();\n        W = scanner.nextInt();\n        garden = new char[H][W];\n\n        for (int i = 0; i < H; i++) {\n            String row = scanner.next();\n            garden[i] = row.toCharArray();\n        }\n\n        System.out.println(maxPartsAfterSplit());\n    }\n\n    private static int maxPartsAfterSplit() {\n        // Check connected components for ROW split\n        visited = new boolean[H][W];\n        connectedComponents = 0;\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (garden[i][j] == '#' && !visited[i][j]) {\n                    connectedComponents++;\n                    dfs(i, j);\n                }\n            }\n        }\n        int maxParts = connectedComponents;\n\n        // Check connected components for COLUMN split\n        visited = new boolean[H][W];\n        connectedComponents = 0;\n\n        for (int j = 0; j < W; j++) {\n            for (int i = 0; i < H; i++) {\n                if (garden[i][j] == '#' && !visited[i][j]) {\n                    connectedComponents++;\n                    dfs(i, j);\n                }\n            }\n        }\n        maxParts = Math.max(maxParts, connectedComponents);\n\n        return maxParts;\n    }\n\n    private static void dfs(int x, int y) {\n        visited[x][y] = true;\n        for (int dir = 0; dir < 4; dir++) {\n            int newX = x + directionX[dir];\n            int newY = y + directionY[dir];\n            if (isValid(newX, newY) && garden[newX][newY] == '#' && !visited[newX][newY]) {\n                dfs(newX, newY);\n            }\n        }\n    }\n\n    private static boolean isValid(int x, int y) {\n        return x >= 0 && x < H && y >= 0 && y < W;\n    }\n}",
    "timestamp": "2025-08-13 06:17:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 100\n\nint W, H;\nchar garden[MAX][MAX];\nint visited[MAX][MAX];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nvoid dfs(int x, int y) {\n    visited[x][y] = 1;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx >= 0 && ny >= 0 && nx < H && ny < W && !visited[nx][ny] && garden[nx][ny] == '#') {\n            dfs(nx, ny);\n        }\n    }\n}\n\nint main() {\n    // Read dimensions H and W\n    scanf(\"%d %d\", &H, &W);\n\n    // Read the garden layout\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", garden[i]);\n    }\n\n    int total_parts = 0;\n\n    // Try vertical splits\n    memset(visited, 0, sizeof(visited));\n    for (int i = 0; i < W - 1; i++) {\n        int parts = 0;\n        for (int j = 0; j < H; j++) {\n            for (int k = 0; k <= i; k++) {\n                if (garden[j][k] == '#' && !visited[j][k]) {\n                    dfs(j, k);\n                    parts++;\n                }\n            }\n        }\n        for (int j = i + 1; j < W; j++) {\n            for (int k = 0; k < H; k++) {\n                visited[k][j] = 0;\n            }\n        }\n        total_parts = total_parts < parts ? parts : total_parts;\n    }\n\n    // Try horizontal splits\n    memset(visited, 0, sizeof(visited));\n    for (int i = 0; i < H - 1; i++) {\n        int parts = 0;\n        for (int j = 0; j <= i; j++) {\n            for (int k = 0; k < W; k++) {\n                if (garden[j][k] == '#' && !visited[j][k]) {\n                    dfs(j, k);\n                    parts++;\n                }\n            }\n        }\n        for (int j = i + 1; j < H; j++) {\n            for (int k = 0; k < W; k++) {\n                visited[j][k] = 0;\n            }\n        }\n        total_parts = total_parts < parts ? parts : total_parts;\n    }\n\n    // Output the maximum number of parts\n    printf(\"%d\\n\", total_parts);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:17:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_rose_clusters(garden):\n    def dfs(x, y, visited):\n        if x < 0 or x >= len(garden) or y < 0 or y >= len(garden[0]) or garden[x][y] == '.' or (x, y) in visited:\n            return\n        visited.add((x, y))\n        for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:\n            dfs(x+dx, y+dy, visited)\n        return visited\n\n    def count_clusters():\n        visited = set()\n        clusters = 0\n        for i in range(len(garden)):\n            for j in range(len(garden[0])):\n                if garden[i][j] == '#' and (i, j) not in visited:\n                    cluster = dfs(i, j, set())\n                    visited.update(cluster)\n                    clusters += 1\n        return clusters\n\n    max_parts = 1\n    for cut_type in ['horizontal', 'vertical']:\n        for cut in range(1, len(garden) if cut_type == 'horizontal' else len(garden[0])):\n            test_garden = [row.copy() for row in garden]\n            \n            if cut_type == 'horizontal':\n                for j in range(len(test_garden[0])):\n                    test_garden[cut-1][j] = '.'\n            else:\n                for i in range(len(test_garden)):\n                    test_garden[i][cut-1] = '.'\n            \n            max_parts = max(max_parts, count_clusters())\n    \n    return max_parts\n\ndef solve():\n    H, W = map(int, input().split())\n    garden = [list(input().strip()) for _ in range(H)]\n    print(find_rose_clusters(garden))\n\nsolve()",
    "timestamp": "2025-08-13 06:17:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    H, W = map(int, input().split())\n    garden = [input().strip() for _ in range(H)]\n    \n    # Collect all rose positions\n    roses = []\n    for i in range(H):\n        for j in range(W):\n            if garden[i][j] == '#':\n                roses.append((i, j))\n    \n    if not roses:\n        print(0)\n        return\n    \n    max_parts = 1\n    \n    # Check all possible vertical lines (x = c)\n    for x in range(1, H):\n        left = set()\n        right = set()\n        for i, j in roses:\n            if i < x:\n                left.add((i, j))\n            else:\n                right.add((i, j))\n        if left and right:\n            parts = 0\n            if left:\n                parts += 1\n            if right:\n                parts += 1\n            if parts > max_parts:\n                max_parts = parts\n    \n    # Check all possible horizontal lines (y = c)\n    for y in range(1, W):\n        left = set()\n        right = set()\n        for i, j in roses:\n            if j < y:\n                left.add((i, j))\n            else:\n                right.add((i, j))\n        if left and right:\n            parts = 0\n            if left:\n                parts += 1\n            if right:\n                parts += 1\n            if parts > max_parts:\n                max_parts = parts\n    \n    # Check all possible diagonal lines (i - j = c)\n    min_diff = min(i - j for i, j in roses)\n    max_diff = max(i - j for i, j in roses)\n    for c in range(min_diff + 1, max_diff):\n        left = set()\n        right = set()\n        for i, j in roses:\n            if i - j < c:\n                left.add((i, j))\n            else:\n                right.add((i, j))\n        if left and right:\n            parts = 0\n            if left:\n                parts += 1\n            if right:\n                parts += 1\n            if parts > max_parts:\n                max_parts = parts\n    \n    # Check all possible anti-diagonal lines (i + j = c)\n    min_sum = min(i + j for i, j in roses)\n    max_sum = max(i + j for i, j in roses)\n    for c in range(min_sum + 1, max_sum):\n        left = set()\n        right = set()\n        for i, j in roses:\n            if i + j < c:\n                left.add((i, j))\n            else:\n                right.add((i, j))\n        if left and right:\n            parts = 0\n            if left:\n                parts += 1\n            if right:\n                parts += 1\n            if parts > max_parts:\n                max_parts = parts\n    \n    print(max_parts)\n\nsolve()",
    "timestamp": "2025-08-13 06:18:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(int x, int y, vector<vector<char>>& garden, vector<vector<bool>>& visited) {\n    int H = garden.size(), W = garden[0].size();\n    if (x < 0 || x >= H || y < 0 || y >= W || garden[x][y] == '.' || visited[x][y]) return;\n    visited[x][y] = true;\n    dfs(x-1, y, garden, visited);\n    dfs(x+1, y, garden, visited);\n    dfs(x, y-1, garden, visited);\n    dfs(x, y+1, garden, visited);\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> garden(H, vector<char>(W));\n    for (int i = 0; i < H; ++i)\n        for (int j = 0; j < W; ++j)\n            cin >> garden[i][j];\n\n    vector<int> horizontalCuts(H, 0), verticalCuts(W, 0);\n\n    for (int i = 0; i < H; ++i) {\n        int cut = 0;\n        bool found = false;\n        for (int j = 0; j < W; ++j) {\n            if (garden[i][j] == '#') {\n                if (!found) cut++;\n                found = true;\n            } else {\n                found = false;\n            }\n        }\n        horizontalCuts[i] = cut;\n    }\n\n    for (int j = 0; j < W; ++j) {\n        int cut = 0;\n        bool found = false;\n        for (int i = 0; i < H; ++i) {\n            if (garden[i][j] == '#') {\n                if (!found) cut++;\n                found = true;\n            } else {\n                found = false;\n            }\n        }\n        verticalCuts[j] = cut;\n    }\n\n    int maxParts = max(*max_element(horizontalCuts.begin(), horizontalCuts.end()), \n                       *max_element(verticalCuts.begin(), verticalCuts.end()));\n\n    cout << maxParts << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:31:10"
  }
]